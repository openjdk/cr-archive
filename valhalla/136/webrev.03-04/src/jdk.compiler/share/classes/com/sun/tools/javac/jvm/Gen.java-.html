<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import com.sun.tools.javac.code.Types.UniqueType;
  29 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
  30 import com.sun.tools.javac.tree.TreeInfo.PosKind;
  31 import com.sun.tools.javac.util.*;
  32 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  33 import com.sun.tools.javac.util.List;
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.TypeCompound;
  36 import com.sun.tools.javac.code.Symbol.VarSymbol;
  37 import com.sun.tools.javac.comp.*;
  38 import com.sun.tools.javac.tree.*;
  39 
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.code.Type.*;
  42 import com.sun.tools.javac.jvm.Code.*;
  43 import com.sun.tools.javac.jvm.Items.*;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.tree.EndPosTable;
  46 import com.sun.tools.javac.tree.JCTree.*;
  47 
  48 import static com.sun.tools.javac.code.Flags.*;
  49 import static com.sun.tools.javac.code.Kinds.Kind.*;
  50 import static com.sun.tools.javac.code.TypeTag.*;
  51 import static com.sun.tools.javac.jvm.ByteCodes.*;
  52 import static com.sun.tools.javac.jvm.CRTFlags.*;
  53 import static com.sun.tools.javac.main.Option.*;
  54 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  55 
  56 /** This pass maps flat Java (i.e. without inner classes) to bytecodes.
  57  *
  58  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  59  *  If you write code that depends on this, you do so at your own risk.
  60  *  This code and its internal interfaces are subject to change or
  61  *  deletion without notice.&lt;/b&gt;
  62  */
  63 public class Gen extends JCTree.Visitor {
  64     private static final Object[] NO_STATIC_ARGS = new Object[0];
  65     protected static final Context.Key&lt;Gen&gt; genKey = new Context.Key&lt;&gt;();
  66 
  67     private final Log log;
  68     private final Symtab syms;
  69     private final Check chk;
  70     private final Resolve rs;
  71     private final TreeMaker make;
  72     private final Names names;
  73     private final Target target;
  74     private final Name accessDollar;
  75     private final Types types;
  76     private final Lower lower;
  77     private final Annotate annotate;
  78     private final StringConcat concat;
  79     private final TransValues transValues;
  80 
  81     /** Format of stackmap tables to be generated. */
  82     private final Code.StackMapFormat stackMap;
  83 
  84     /** A type that serves as the expected type for all method expressions.
  85      */
  86     private final Type methodType;
  87 
  88     public static Gen instance(Context context) {
  89         Gen instance = context.get(genKey);
  90         if (instance == null)
  91             instance = new Gen(context);
  92         return instance;
  93     }
  94 
  95     /** Constant pool writer, set by genClass.
  96      */
  97     final PoolWriter poolWriter;
  98 
  99     protected Gen(Context context) {
 100         context.put(genKey, this);
 101 
 102         names = Names.instance(context);
 103         log = Log.instance(context);
 104         syms = Symtab.instance(context);
 105         chk = Check.instance(context);
 106         rs = Resolve.instance(context);
 107         make = TreeMaker.instance(context);
 108         target = Target.instance(context);
 109         types = Types.instance(context);
 110         concat = StringConcat.instance(context);
 111 
 112         methodType = new MethodType(null, null, null, syms.methodClass);
 113         accessDollar = names.
 114             fromString(&quot;access&quot; + target.syntheticNameChar());
 115         lower = Lower.instance(context);
 116         transValues = TransValues.instance(context);
 117 
 118         Options options = Options.instance(context);
 119         lineDebugInfo =
 120             options.isUnset(G_CUSTOM) ||
 121             options.isSet(G_CUSTOM, &quot;lines&quot;);
 122         varDebugInfo =
 123             options.isUnset(G_CUSTOM)
 124             ? options.isSet(G)
 125             : options.isSet(G_CUSTOM, &quot;vars&quot;);
 126         genCrt = options.isSet(XJCOV);
 127         debugCode = options.isSet(&quot;debug.code&quot;);
 128         disableVirtualizedPrivateInvoke = options.isSet(&quot;disableVirtualizedPrivateInvoke&quot;);
 129         poolWriter = new PoolWriter(types, names);
 130 
 131         // ignore cldc because we cannot have both stackmap formats
 132         this.stackMap = StackMapFormat.JSR202;
 133         annotate = Annotate.instance(context);
 134     }
 135 
 136     /** Switches
 137      */
 138     private final boolean lineDebugInfo;
 139     private final boolean varDebugInfo;
 140     private final boolean genCrt;
 141     private final boolean debugCode;
 142     private boolean disableVirtualizedPrivateInvoke;
 143 
 144     /** Code buffer, set by genMethod.
 145      */
 146     private Code code;
 147 
 148     /** Items structure, set by genMethod.
 149      */
 150     private Items items;
 151 
 152     /** Environment for symbol lookup, set by genClass
 153      */
 154     private Env&lt;AttrContext&gt; attrEnv;
 155 
 156     /** The top level tree.
 157      */
 158     private JCCompilationUnit toplevel;
 159 
 160     /** The number of code-gen errors in this class.
 161      */
 162     private int nerrs = 0;
 163 
 164     /** An object containing mappings of syntax trees to their
 165      *  ending source positions.
 166      */
 167     EndPosTable endPosTable;
 168 
 169     boolean inCondSwitchExpression;
 170     Chain switchExpressionTrueChain;
 171     Chain switchExpressionFalseChain;
 172     List&lt;LocalItem&gt; stackBeforeSwitchExpression;
 173     LocalItem switchResult;
 174 
 175     /** Generate code to load an integer constant.
 176      *  @param n     The integer to be loaded.
 177      */
 178     void loadIntConst(int n) {
 179         items.makeImmediateItem(syms.intType, n).load();
 180     }
 181 
 182     /** The opcode that loads a zero constant of a given type code.
 183      *  @param tc   The given type code (@see ByteCode).
 184      */
 185     public static int zero(int tc) {
 186         switch(tc) {
 187         case INTcode: case BYTEcode: case SHORTcode: case CHARcode:
 188             return iconst_0;
 189         case LONGcode:
 190             return lconst_0;
 191         case FLOATcode:
 192             return fconst_0;
 193         case DOUBLEcode:
 194             return dconst_0;
 195         default:
 196             throw new AssertionError(&quot;zero&quot;);
 197         }
 198     }
 199 
 200     /** The opcode that loads a one constant of a given type code.
 201      *  @param tc   The given type code (@see ByteCode).
 202      */
 203     public static int one(int tc) {
 204         return zero(tc) + 1;
 205     }
 206 
 207     /** Generate code to load -1 of the given type code (either int or long).
 208      *  @param tc   The given type code (@see ByteCode).
 209      */
 210     void emitMinusOne(int tc) {
 211         if (tc == LONGcode) {
 212             items.makeImmediateItem(syms.longType, Long.valueOf(-1)).load();
 213         } else {
 214             code.emitop0(iconst_m1);
 215         }
 216     }
 217 
 218     /** Construct a symbol to reflect the qualifying type that should
 219      *  appear in the byte code as per JLS 13.1.
 220      *
 221      *  For {@literal target &gt;= 1.2}: Clone a method with the qualifier as owner (except
 222      *  for those cases where we need to work around VM bugs).
 223      *
 224      *  For {@literal target &lt;= 1.1}: If qualified variable or method is defined in a
 225      *  non-accessible class, clone it with the qualifier class as owner.
 226      *
 227      *  @param sym    The accessed symbol
 228      *  @param site   The qualifier&#39;s type.
 229      */
 230     Symbol binaryQualifier(Symbol sym, Type site) {
 231 
 232         if (site.hasTag(ARRAY)) {
 233             if (sym == syms.lengthVar ||
 234                 sym.owner != syms.arrayClass)
 235                 return sym;
 236             // array clone can be qualified by the array type in later targets
 237             Symbol qualifier = new ClassSymbol(Flags.PUBLIC, site.tsym.name,
 238                                                site, syms.noSymbol);
 239             return sym.clone(qualifier);
 240         }
 241 
 242         if (sym.owner == site.tsym ||
 243             (sym.flags() &amp; (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {
 244             return sym;
 245         }
 246 
 247         // leave alone methods inherited from Object
 248         // JLS 13.1.
 249         if (sym.owner == syms.objectType.tsym)
 250             return sym;
 251 
 252         return sym.clone(site.tsym);
 253     }
 254 
 255     /** Insert a reference to given type in the constant pool,
 256      *  checking for an array with too many dimensions;
 257      *  return the reference&#39;s index.
 258      *  @param type   The type for which a reference is inserted.
 259      */
 260     int makeRef(DiagnosticPosition pos, Type type, boolean emitQtype) {
 261         checkDimension(pos, type);
 262         if (emitQtype) {
 263             return poolWriter.putClass(new ConstantPoolQType(type, types));
 264         } else {
 265             return poolWriter.putClass(type);
 266         }
 267     }
 268 
 269     /** Insert a reference to given type in the constant pool,
 270      *  checking for an array with too many dimensions;
 271      *  return the reference&#39;s index.
 272      *  @param type   The type for which a reference is inserted.
 273      */
 274     int makeRef(DiagnosticPosition pos, Type type) {
 275         return makeRef(pos, type, false);
 276     }
 277 
 278     /** Check if the given type is an array with too many dimensions.
 279      */
 280     private Type checkDimension(DiagnosticPosition pos, Type t) {
 281         checkDimensionInternal(pos, t);
 282         return t;
 283     }
 284 
 285     private void checkDimensionInternal(DiagnosticPosition pos, Type t) {
 286         switch (t.getTag()) {
 287         case METHOD:
 288             checkDimension(pos, t.getReturnType());
 289             for (List&lt;Type&gt; args = t.getParameterTypes(); args.nonEmpty(); args = args.tail)
 290                 checkDimension(pos, args.head);
 291             break;
 292         case ARRAY:
 293             if (types.dimensions(t) &gt; ClassFile.MAX_DIMENSIONS) {
 294                 log.error(pos, Errors.LimitDimensions);
 295                 nerrs++;
 296             }
 297             break;
 298         default:
 299             break;
 300         }
 301     }
 302 
 303     /** Create a temporary variable.
 304      *  @param type   The variable&#39;s type.
 305      */
 306     LocalItem makeTemp(Type type) {
 307         VarSymbol v = new VarSymbol(Flags.SYNTHETIC,
 308                                     names.empty,
 309                                     type,
 310                                     env.enclMethod.sym);
 311         code.newLocal(v);
 312         return items.makeLocalItem(v);
 313     }
 314 
 315     /** Generate code to call a non-private method or constructor.
 316      *  @param pos         Position to be used for error reporting.
 317      *  @param site        The type of which the method is a member.
 318      *  @param name        The method&#39;s name.
 319      *  @param argtypes    The method&#39;s argument types.
 320      *  @param isStatic    A flag that indicates whether we call a
 321      *                     static or instance method.
 322      */
 323     void callMethod(DiagnosticPosition pos,
 324                     Type site, Name name, List&lt;Type&gt; argtypes,
 325                     boolean isStatic) {
 326         Symbol msym = rs.
 327             resolveInternalMethod(pos, attrEnv, site, name, argtypes, null);
 328         if (isStatic) items.makeStaticItem(msym).invoke();
 329         else items.makeMemberItem(msym, name == names.init).invoke();
 330     }
 331 
 332     /** Is the given method definition an access method
 333      *  resulting from a qualified super? This is signified by an odd
 334      *  access code.
 335      */
 336     private boolean isAccessSuper(JCMethodDecl enclMethod) {
 337         return
 338             (enclMethod.mods.flags &amp; SYNTHETIC) != 0 &amp;&amp;
 339             isOddAccessName(enclMethod.name);
 340     }
 341 
 342     /** Does given name start with &quot;access$&quot; and end in an odd digit?
 343      */
 344     private boolean isOddAccessName(Name name) {
 345         return
 346             name.startsWith(accessDollar) &amp;&amp;
 347             (name.getByteAt(name.getByteLength() - 1) &amp; 1) == 1;
 348     }
 349 
 350 /* ************************************************************************
 351  * Non-local exits
 352  *************************************************************************/
 353 
 354     /** Generate code to invoke the finalizer associated with given
 355      *  environment.
 356      *  Any calls to finalizers are appended to the environments `cont&#39; chain.
 357      *  Mark beginning of gap in catch all range for finalizer.
 358      */
 359     void genFinalizer(Env&lt;GenContext&gt; env) {
 360         if (code.isAlive() &amp;&amp; env.info.finalize != null)
 361             env.info.finalize.gen();
 362     }
 363 
 364     /** Generate code to call all finalizers of structures aborted by
 365      *  a non-local
 366      *  exit.  Return target environment of the non-local exit.
 367      *  @param target      The tree representing the structure that&#39;s aborted
 368      *  @param env         The environment current at the non-local exit.
 369      */
 370     Env&lt;GenContext&gt; unwind(JCTree target, Env&lt;GenContext&gt; env) {
 371         Env&lt;GenContext&gt; env1 = env;
 372         while (true) {
 373             genFinalizer(env1);
 374             if (env1.tree == target) break;
 375             env1 = env1.next;
 376         }
 377         return env1;
 378     }
 379 
 380     /** Mark end of gap in catch-all range for finalizer.
 381      *  @param env   the environment which might contain the finalizer
 382      *               (if it does, env.info.gaps != null).
 383      */
 384     void endFinalizerGap(Env&lt;GenContext&gt; env) {
 385         if (env.info.gaps != null &amp;&amp; env.info.gaps.length() % 2 == 1)
 386             env.info.gaps.append(code.curCP());
 387     }
 388 
 389     /** Mark end of all gaps in catch-all ranges for finalizers of environments
 390      *  lying between, and including to two environments.
 391      *  @param from    the most deeply nested environment to mark
 392      *  @param to      the least deeply nested environment to mark
 393      */
 394     void endFinalizerGaps(Env&lt;GenContext&gt; from, Env&lt;GenContext&gt; to) {
 395         Env&lt;GenContext&gt; last = null;
 396         while (last != to) {
 397             endFinalizerGap(from);
 398             last = from;
 399             from = from.next;
 400         }
 401     }
 402 
 403     /** Do any of the structures aborted by a non-local exit have
 404      *  finalizers that require an empty stack?
 405      *  @param target      The tree representing the structure that&#39;s aborted
 406      *  @param env         The environment current at the non-local exit.
 407      */
 408     boolean hasFinally(JCTree target, Env&lt;GenContext&gt; env) {
 409         while (env.tree != target) {
 410             if (env.tree.hasTag(TRY) &amp;&amp; env.info.finalize.hasFinalizer())
 411                 return true;
 412             env = env.next;
 413         }
 414         return false;
 415     }
 416 
 417 /* ************************************************************************
 418  * Normalizing class-members.
 419  *************************************************************************/
 420 
 421     /** Distribute member initializer code into constructors and {@code &lt;clinit&gt;}
 422      *  method.
 423      *  @param defs         The list of class member declarations.
 424      *  @param c            The enclosing class.
 425      */
 426     List&lt;JCTree&gt; normalizeDefs(List&lt;JCTree&gt; defs, ClassSymbol c) {
 427         ListBuffer&lt;JCStatement&gt; initCode = new ListBuffer&lt;&gt;();
 428         ListBuffer&lt;Attribute.TypeCompound&gt; initTAs = new ListBuffer&lt;&gt;();
 429         ListBuffer&lt;JCStatement&gt; clinitCode = new ListBuffer&lt;&gt;();
 430         ListBuffer&lt;Attribute.TypeCompound&gt; clinitTAs = new ListBuffer&lt;&gt;();
 431         ListBuffer&lt;JCTree&gt; methodDefs = new ListBuffer&lt;&gt;();
 432         // Sort definitions into three listbuffers:
 433         //  - initCode for instance initializers
 434         //  - clinitCode for class initializers
 435         //  - methodDefs for method definitions
 436         for (List&lt;JCTree&gt; l = defs; l.nonEmpty(); l = l.tail) {
 437             JCTree def = l.head;
 438             switch (def.getTag()) {
 439             case BLOCK:
 440                 JCBlock block = (JCBlock)def;
 441                 if ((block.flags &amp; STATIC) != 0)
 442                     clinitCode.append(block);
 443                 else if ((block.flags &amp; SYNTHETIC) == 0)
 444                     initCode.append(block);
 445                 break;
 446             case METHODDEF:
 447                 methodDefs.append(def);
 448                 break;
 449             case VARDEF:
 450                 JCVariableDecl vdef = (JCVariableDecl) def;
 451                 VarSymbol sym = vdef.sym;
 452                 checkDimension(vdef.pos(), sym.type);
 453                 if (vdef.init != null) {
 454                     if ((sym.flags() &amp; STATIC) == 0) {
 455                         // Always initialize instance variables.
 456                         JCStatement init = make.at(vdef.pos()).
 457                             Assignment(sym, vdef.init);
 458                         initCode.append(init);
 459                         endPosTable.replaceTree(vdef, init);
 460                         initTAs.addAll(getAndRemoveNonFieldTAs(sym));
 461                     } else if (sym.getConstValue() == null) {
 462                         // Initialize class (static) variables only if
 463                         // they are not compile-time constants.
 464                         JCStatement init = make.at(vdef.pos).
 465                             Assignment(sym, vdef.init);
 466                         clinitCode.append(init);
 467                         endPosTable.replaceTree(vdef, init);
 468                         clinitTAs.addAll(getAndRemoveNonFieldTAs(sym));
 469                     } else {
 470                         checkStringConstant(vdef.init.pos(), sym.getConstValue());
 471                         /* if the init contains a reference to an external class, add it to the
 472                          * constant&#39;s pool
 473                          */
 474                         vdef.init.accept(classReferenceVisitor);
 475                     }
 476                 }
 477                 break;
 478             default:
 479                 Assert.error();
 480             }
 481         }
 482         // Insert any instance initializers into all constructors.
 483         if (initCode.length() != 0) {
 484             List&lt;JCStatement&gt; inits = initCode.toList();
 485             initTAs.addAll(c.getInitTypeAttributes());
 486             List&lt;Attribute.TypeCompound&gt; initTAlist = initTAs.toList();
 487             for (JCTree t : methodDefs) {
 488                 normalizeMethod((JCMethodDecl)t, inits, initTAlist);
 489             }
 490         }
 491         // If there are class initializers, create a &lt;clinit&gt; method
 492         // that contains them as its body.
 493         if (clinitCode.length() != 0) {
 494             MethodSymbol clinit = new MethodSymbol(
 495                 STATIC | (c.flags() &amp; STRICTFP),
 496                 names.clinit,
 497                 new MethodType(
 498                     List.nil(), syms.voidType,
 499                     List.nil(), syms.methodClass),
 500                 c);
 501             c.members().enter(clinit);
 502             List&lt;JCStatement&gt; clinitStats = clinitCode.toList();
 503             JCBlock block = make.at(clinitStats.head.pos()).Block(0, clinitStats);
 504             block.endpos = TreeInfo.endPos(clinitStats.last());
 505             methodDefs.append(make.MethodDef(clinit, block));
 506 
 507             if (!clinitTAs.isEmpty())
 508                 clinit.appendUniqueTypeAttributes(clinitTAs.toList());
 509             if (!c.getClassInitTypeAttributes().isEmpty())
 510                 clinit.appendUniqueTypeAttributes(c.getClassInitTypeAttributes());
 511         }
 512         // Return all method definitions.
 513         return methodDefs.toList();
 514     }
 515 
 516     private List&lt;Attribute.TypeCompound&gt; getAndRemoveNonFieldTAs(VarSymbol sym) {
 517         List&lt;TypeCompound&gt; tas = sym.getRawTypeAttributes();
 518         ListBuffer&lt;Attribute.TypeCompound&gt; fieldTAs = new ListBuffer&lt;&gt;();
 519         ListBuffer&lt;Attribute.TypeCompound&gt; nonfieldTAs = new ListBuffer&lt;&gt;();
 520         for (TypeCompound ta : tas) {
 521             Assert.check(ta.getPosition().type != TargetType.UNKNOWN);
 522             if (ta.getPosition().type == TargetType.FIELD) {
 523                 fieldTAs.add(ta);
 524             } else {
 525                 nonfieldTAs.add(ta);
 526             }
 527         }
 528         sym.setTypeAttributes(fieldTAs.toList());
 529         return nonfieldTAs.toList();
 530     }
 531 
 532     /** Check a constant value and report if it is a string that is
 533      *  too large.
 534      */
 535     private void checkStringConstant(DiagnosticPosition pos, Object constValue) {
 536         if (nerrs != 0 || // only complain about a long string once
 537             constValue == null ||
 538             !(constValue instanceof String) ||
 539             ((String)constValue).length() &lt; PoolWriter.MAX_STRING_LENGTH)
 540             return;
 541         log.error(pos, Errors.LimitString);
 542         nerrs++;
 543     }
 544 
 545     /** Insert instance initializer code into initial constructor.
 546      *  @param md        The tree potentially representing a
 547      *                   constructor&#39;s definition.
 548      *  @param initCode  The list of instance initializer statements.
 549      *  @param initTAs  Type annotations from the initializer expression.
 550      */
 551     void normalizeMethod(JCMethodDecl md, List&lt;JCStatement&gt; initCode, List&lt;TypeCompound&gt; initTAs) {
 552         if (md.name == names.init &amp;&amp; TreeInfo.isInitialConstructor(md)) {
 553             // We are seeing a constructor that does not call another
 554             // constructor of the same class.
 555             List&lt;JCStatement&gt; stats = md.body.stats;
 556             ListBuffer&lt;JCStatement&gt; newstats = new ListBuffer&lt;&gt;();
 557 
 558             if (stats.nonEmpty()) {
 559                 // Copy initializers of synthetic variables generated in
 560                 // the translation of inner classes.
 561                 while (TreeInfo.isSyntheticInit(stats.head)) {
 562                     newstats.append(stats.head);
 563                     stats = stats.tail;
 564                 }
 565                 // Copy superclass constructor call
 566                 newstats.append(stats.head);
 567                 stats = stats.tail;
 568                 // Copy remaining synthetic initializers.
 569                 while (stats.nonEmpty() &amp;&amp;
 570                        TreeInfo.isSyntheticInit(stats.head)) {
 571                     newstats.append(stats.head);
 572                     stats = stats.tail;
 573                 }
 574                 // Now insert the initializer code.
 575                 newstats.appendList(initCode);
 576                 // And copy all remaining statements.
 577                 while (stats.nonEmpty()) {
 578                     newstats.append(stats.head);
 579                     stats = stats.tail;
 580                 }
 581             }
 582             md.body.stats = newstats.toList();
 583             if (md.body.endpos == Position.NOPOS)
 584                 md.body.endpos = TreeInfo.endPos(md.body.stats.last());
 585 
 586             md.sym.appendUniqueTypeAttributes(initTAs);
 587         }
 588     }
 589 
 590 /* ************************************************************************
 591  * Traversal methods
 592  *************************************************************************/
 593 
 594     /** Visitor argument: The current environment.
 595      */
 596     Env&lt;GenContext&gt; env;
 597 
 598     /** Visitor argument: The expected type (prototype).
 599      */
 600     Type pt;
 601 
 602     /** Visitor result: The item representing the computed value.
 603      */
 604     Item result;
 605 
 606     /** Visitor method: generate code for a definition, catching and reporting
 607      *  any completion failures.
 608      *  @param tree    The definition to be visited.
 609      *  @param env     The environment current at the definition.
 610      */
 611     public void genDef(JCTree tree, Env&lt;GenContext&gt; env) {
 612         Env&lt;GenContext&gt; prevEnv = this.env;
 613         try {
 614             this.env = env;
 615             tree.accept(this);
 616         } catch (CompletionFailure ex) {
 617             chk.completionError(tree.pos(), ex);
 618         } finally {
 619             this.env = prevEnv;
 620         }
 621     }
 622 
 623     /** Derived visitor method: check whether CharacterRangeTable
 624      *  should be emitted, if so, put a new entry into CRTable
 625      *  and call method to generate bytecode.
 626      *  If not, just call method to generate bytecode.
 627      *  @see    #genStat(JCTree, Env)
 628      *
 629      *  @param  tree     The tree to be visited.
 630      *  @param  env      The environment to use.
 631      *  @param  crtFlags The CharacterRangeTable flags
 632      *                   indicating type of the entry.
 633      */
 634     public void genStat(JCTree tree, Env&lt;GenContext&gt; env, int crtFlags) {
 635         if (!genCrt) {
 636             genStat(tree, env);
 637             return;
 638         }
 639         int startpc = code.curCP();
 640         genStat(tree, env);
 641         if (tree.hasTag(Tag.BLOCK)) crtFlags |= CRT_BLOCK;
 642         code.crt.put(tree, crtFlags, startpc, code.curCP());
 643     }
 644 
 645     /** Derived visitor method: generate code for a statement.
 646      */
 647     public void genStat(JCTree tree, Env&lt;GenContext&gt; env) {
 648         if (code.isAlive()) {
 649             code.statBegin(tree.pos);
 650             genDef(tree, env);
 651         } else if (env.info.isSwitch &amp;&amp; tree.hasTag(VARDEF)) {
 652             // variables whose declarations are in a switch
 653             // can be used even if the decl is unreachable.
 654             code.newLocal(((JCVariableDecl) tree).sym);
 655         }
 656     }
 657 
 658     /** Derived visitor method: check whether CharacterRangeTable
 659      *  should be emitted, if so, put a new entry into CRTable
 660      *  and call method to generate bytecode.
 661      *  If not, just call method to generate bytecode.
 662      *  @see    #genStats(List, Env)
 663      *
 664      *  @param  trees    The list of trees to be visited.
 665      *  @param  env      The environment to use.
 666      *  @param  crtFlags The CharacterRangeTable flags
 667      *                   indicating type of the entry.
 668      */
 669     public void genStats(List&lt;JCStatement&gt; trees, Env&lt;GenContext&gt; env, int crtFlags) {
 670         if (!genCrt) {
 671             genStats(trees, env);
 672             return;
 673         }
 674         if (trees.length() == 1) {        // mark one statement with the flags
 675             genStat(trees.head, env, crtFlags | CRT_STATEMENT);
 676         } else {
 677             int startpc = code.curCP();
 678             genStats(trees, env);
 679             code.crt.put(trees, crtFlags, startpc, code.curCP());
 680         }
 681     }
 682 
 683     /** Derived visitor method: generate code for a list of statements.
 684      */
 685     public void genStats(List&lt;? extends JCTree&gt; trees, Env&lt;GenContext&gt; env) {
 686         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
 687             genStat(l.head, env, CRT_STATEMENT);
 688     }
 689 
 690     /** Derived visitor method: check whether CharacterRangeTable
 691      *  should be emitted, if so, put a new entry into CRTable
 692      *  and call method to generate bytecode.
 693      *  If not, just call method to generate bytecode.
 694      *  @see    #genCond(JCTree,boolean)
 695      *
 696      *  @param  tree     The tree to be visited.
 697      *  @param  crtFlags The CharacterRangeTable flags
 698      *                   indicating type of the entry.
 699      */
 700     public CondItem genCond(JCTree tree, int crtFlags) {
 701         if (!genCrt) return genCond(tree, false);
 702         int startpc = code.curCP();
 703         CondItem item = genCond(tree, (crtFlags &amp; CRT_FLOW_CONTROLLER) != 0);
 704         code.crt.put(tree, crtFlags, startpc, code.curCP());
 705         return item;
 706     }
 707 
 708     /** Derived visitor method: generate code for a boolean
 709      *  expression in a control-flow context.
 710      *  @param _tree         The expression to be visited.
 711      *  @param markBranches The flag to indicate that the condition is
 712      *                      a flow controller so produced conditions
 713      *                      should contain a proper tree to generate
 714      *                      CharacterRangeTable branches for them.
 715      */
 716     public CondItem genCond(JCTree _tree, boolean markBranches) {
 717         JCTree inner_tree = TreeInfo.skipParens(_tree);
 718         if (inner_tree.hasTag(CONDEXPR)) {
 719             JCConditional tree = (JCConditional)inner_tree;
 720             CondItem cond = genCond(tree.cond, CRT_FLOW_CONTROLLER);
 721             if (cond.isTrue()) {
 722                 code.resolve(cond.trueJumps);
 723                 CondItem result = genCond(tree.truepart, CRT_FLOW_TARGET);
 724                 if (markBranches) result.tree = tree.truepart;
 725                 return result;
 726             }
 727             if (cond.isFalse()) {
 728                 code.resolve(cond.falseJumps);
 729                 CondItem result = genCond(tree.falsepart, CRT_FLOW_TARGET);
 730                 if (markBranches) result.tree = tree.falsepart;
 731                 return result;
 732             }
 733             Chain secondJumps = cond.jumpFalse();
 734             code.resolve(cond.trueJumps);
 735             CondItem first = genCond(tree.truepart, CRT_FLOW_TARGET);
 736             if (markBranches) first.tree = tree.truepart;
 737             Chain falseJumps = first.jumpFalse();
 738             code.resolve(first.trueJumps);
 739             Chain trueJumps = code.branch(goto_);
 740             code.resolve(secondJumps);
 741             CondItem second = genCond(tree.falsepart, CRT_FLOW_TARGET);
 742             CondItem result = items.makeCondItem(second.opcode,
 743                                       Code.mergeChains(trueJumps, second.trueJumps),
 744                                       Code.mergeChains(falseJumps, second.falseJumps));
 745             if (markBranches) result.tree = tree.falsepart;
 746             return result;
 747         } else if (inner_tree.hasTag(SWITCH_EXPRESSION)) {
 748             code.resolvePending();
 749 
 750             boolean prevInCondSwitchExpression = inCondSwitchExpression;
 751             Chain prevSwitchExpressionTrueChain = switchExpressionTrueChain;
 752             Chain prevSwitchExpressionFalseChain = switchExpressionFalseChain;
 753             try {
 754                 inCondSwitchExpression = true;
 755                 switchExpressionTrueChain = null;
 756                 switchExpressionFalseChain = null;
 757                 try {
 758                     doHandleSwitchExpression((JCSwitchExpression) inner_tree);
 759                 } catch (CompletionFailure ex) {
 760                     chk.completionError(_tree.pos(), ex);
 761                     code.state.stacksize = 1;
 762                 }
 763                 CondItem result = items.makeCondItem(goto_,
 764                                                      switchExpressionTrueChain,
 765                                                      switchExpressionFalseChain);
 766                 if (markBranches) result.tree = _tree;
 767                 return result;
 768             } finally {
 769                 inCondSwitchExpression = prevInCondSwitchExpression;
 770                 switchExpressionTrueChain = prevSwitchExpressionTrueChain;
 771                 switchExpressionFalseChain = prevSwitchExpressionFalseChain;
 772             }
 773         } else if (inner_tree.hasTag(LETEXPR) &amp;&amp; ((LetExpr) inner_tree).needsCond) {
 774             code.resolvePending();
 775 
 776             LetExpr tree = (LetExpr) inner_tree;
 777             int limit = code.nextreg;
 778             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
 779             try {
 780                 genStats(tree.defs, env);
 781             } finally {
 782                 code.setLetExprStackPos(prevLetExprStart);
 783             }
 784             CondItem result = genCond(tree.expr, markBranches);
 785             code.endScopes(limit);
 786             return result;
 787         } else {
 788             CondItem result = genExpr(_tree, syms.booleanType).mkCond();
 789             if (markBranches) result.tree = _tree;
 790             return result;
 791         }
 792     }
 793 
 794     public Code getCode() {
 795         return code;
 796     }
 797 
 798     public Items getItems() {
 799         return items;
 800     }
 801 
 802     public Env&lt;AttrContext&gt; getAttrEnv() {
 803         return attrEnv;
 804     }
 805 
 806     /** Visitor class for expressions which might be constant expressions.
 807      *  This class is a subset of TreeScanner. Intended to visit trees pruned by
 808      *  Lower as long as constant expressions looking for references to any
 809      *  ClassSymbol. Any such reference will be added to the constant pool so
 810      *  automated tools can detect class dependencies better.
 811      */
 812     class ClassReferenceVisitor extends JCTree.Visitor {
 813 
 814         @Override
 815         public void visitTree(JCTree tree) {}
 816 
 817         @Override
 818         public void visitBinary(JCBinary tree) {
 819             tree.lhs.accept(this);
 820             tree.rhs.accept(this);
 821         }
 822 
 823         @Override
 824         public void visitSelect(JCFieldAccess tree) {
 825             if (tree.selected.type.hasTag(CLASS)) {
 826                 makeRef(tree.selected.pos(), tree.selected.type);
 827             }
 828         }
 829 
 830         @Override
 831         public void visitIdent(JCIdent tree) {
 832             if (tree.sym.owner instanceof ClassSymbol) {
 833                 poolWriter.putClass((ClassSymbol)tree.sym.owner);
 834             }
 835         }
 836 
 837         @Override
 838         public void visitConditional(JCConditional tree) {
 839             tree.cond.accept(this);
 840             tree.truepart.accept(this);
 841             tree.falsepart.accept(this);
 842         }
 843 
 844         @Override
 845         public void visitUnary(JCUnary tree) {
 846             tree.arg.accept(this);
 847         }
 848 
 849         @Override
 850         public void visitParens(JCParens tree) {
 851             tree.expr.accept(this);
 852         }
 853 
 854         @Override
 855         public void visitTypeCast(JCTypeCast tree) {
 856             tree.expr.accept(this);
 857         }
 858     }
 859 
 860     private ClassReferenceVisitor classReferenceVisitor = new ClassReferenceVisitor();
 861 
 862     /** Visitor method: generate code for an expression, catching and reporting
 863      *  any completion failures.
 864      *  @param tree    The expression to be visited.
 865      *  @param pt      The expression&#39;s expected type (proto-type).
 866      */
 867     public Item genExpr(JCTree tree, Type pt) {
 868         Type prevPt = this.pt;
 869         try {
 870             if (tree.type.constValue() != null) {
 871                 // Short circuit any expressions which are constants
 872                 tree.accept(classReferenceVisitor);
 873                 checkStringConstant(tree.pos(), tree.type.constValue());
 874                 Symbol sym = TreeInfo.symbol(tree);
 875                 if (sym != null &amp;&amp; isConstantDynamic(sym)) {
 876                     result = items.makeDynamicItem(sym);
 877                 } else {
 878                     result = items.makeImmediateItem(tree.type, tree.type.constValue());
 879                 }
 880             } else {
 881                 this.pt = pt;
 882                 tree.accept(this);
 883             }
 884             return result.coerce(pt);
 885         } catch (CompletionFailure ex) {
 886             chk.completionError(tree.pos(), ex);
 887             code.state.stacksize = 1;
 888             return items.makeStackItem(pt);
 889         } finally {
 890             this.pt = prevPt;
 891         }
 892     }
 893 
 894     public boolean isConstantDynamic(Symbol sym) {
 895         return sym.kind == VAR &amp;&amp;
 896                 sym instanceof DynamicVarSymbol &amp;&amp;
 897                 ((DynamicVarSymbol)sym).isDynamic();
 898     }
 899 
 900     /** Derived visitor method: generate code for a list of method arguments.
 901      *  @param trees    The argument expressions to be visited.
 902      *  @param pts      The expression&#39;s expected types (i.e. the formal parameter
 903      *                  types of the invoked method).
 904      */
 905     public void genArgs(List&lt;JCExpression&gt; trees, List&lt;Type&gt; pts) {
 906         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail) {
 907             genExpr(l.head, pts.head).load();
 908             pts = pts.tail;
 909         }
 910         // require lists be of same length
 911         Assert.check(pts.isEmpty());
 912     }
 913 
 914 /* ************************************************************************
 915  * Visitor methods for statements and definitions
 916  *************************************************************************/
 917 
 918     /** Thrown when the byte code size exceeds limit.
 919      */
 920     public static class CodeSizeOverflow extends RuntimeException {
 921         private static final long serialVersionUID = 0;
 922         public CodeSizeOverflow() {}
 923     }
 924 
 925     public void visitMethodDef(JCMethodDecl tree) {
 926         // Create a new local environment that points pack at method
 927         // definition.
 928         Env&lt;GenContext&gt; localEnv = env.dup(tree);
 929         localEnv.enclMethod = tree;
 930         // The expected type of every return statement in this method
 931         // is the method&#39;s return type.
 932         this.pt = tree.sym.erasure(types).getReturnType();
 933 
 934         checkDimension(tree.pos(), tree.sym.erasure(types));
 935         genMethod(tree, localEnv, false);
 936     }
 937 //where
 938         /** Generate code for a method.
 939          *  @param tree     The tree representing the method definition.
 940          *  @param env      The environment current for the method body.
 941          *  @param fatcode  A flag that indicates whether all jumps are
 942          *                  within 32K.  We first invoke this method under
 943          *                  the assumption that fatcode == false, i.e. all
 944          *                  jumps are within 32K.  If this fails, fatcode
 945          *                  is set to true and we try again.
 946          */
 947         void genMethod(JCMethodDecl tree, Env&lt;GenContext&gt; env, boolean fatcode) {
 948             MethodSymbol meth = tree.sym;
 949             int extras = 0;
 950             // Count up extra parameters
 951             if (meth.isConstructor()) {
 952                 extras++;
 953                 if (meth.enclClass().isInner() &amp;&amp;
 954                     !meth.enclClass().isStatic()) {
 955                     extras++;
 956                 }
 957             } else if ((tree.mods.flags &amp; STATIC) == 0) {
 958                 extras++;
 959             }
 960             //      System.err.println(&quot;Generating &quot; + meth + &quot; in &quot; + meth.owner); //DEBUG
 961             if (Code.width(types.erasure(env.enclMethod.sym.type).getParameterTypes()) + extras &gt;
 962                 ClassFile.MAX_PARAMETERS) {
 963                 log.error(tree.pos(), Errors.LimitParameters);
 964                 nerrs++;
 965             }
 966 
 967             else if (tree.body != null) {
 968                 // Create a new code structure and initialize it.
 969                 int startpcCrt = initCode(tree, env, fatcode);
 970 
 971                 try {
 972                     genStat(tree.body, env);
 973                 } catch (CodeSizeOverflow e) {
 974                     // Failed due to code limit, try again with jsr/ret
 975                     startpcCrt = initCode(tree, env, fatcode);
 976                     genStat(tree.body, env);
 977                 }
 978 
 979                 if (code.state.stacksize != 0) {
 980                     log.error(tree.body.pos(), Errors.StackSimError(tree.sym));
 981                     throw new AssertionError();
 982                 }
 983 
 984                 // If last statement could complete normally, insert a
 985                 // return at the end.
 986                 if (code.isAlive()) {
 987                     code.statBegin(TreeInfo.endPos(tree.body));
 988                     if (env.enclMethod == null ||
 989                         env.enclMethod.sym.type.getReturnType().hasTag(VOID)) {
 990                         code.emitop0(return_);
 991                     } else if (env.enclMethod.sym.isValueFactory()) {
 992                         items.makeLocalItem(env.enclMethod.factoryProduct).load();
 993                         code.emitop0(areturn);
 994                     } else {
 995                         // sometime dead code seems alive (4415991);
 996                         // generate a small loop instead
 997                         int startpc = code.entryPoint();
 998                         CondItem c = items.makeCondItem(goto_);
 999                         code.resolve(c.jumpTrue(), startpc);
1000                     }
1001                 }
1002                 if (genCrt)
1003                     code.crt.put(tree.body,
1004                                  CRT_BLOCK,
1005                                  startpcCrt,
1006                                  code.curCP());
1007 
1008                 code.endScopes(0);
1009 
1010                 // If we exceeded limits, panic
1011                 if (code.checkLimits(tree.pos(), log)) {
1012                     nerrs++;
1013                     return;
1014                 }
1015 
1016                 // If we generated short code but got a long jump, do it again
1017                 // with fatCode = true.
1018                 if (!fatcode &amp;&amp; code.fatcode) genMethod(tree, env, true);
1019 
1020                 // Clean up
1021                 if(stackMap == StackMapFormat.JSR202) {
1022                     code.lastFrame = null;
1023                     code.frameBeforeLast = null;
1024                 }
1025 
1026                 // Compress exception table
1027                 code.compressCatchTable();
1028 
1029                 // Fill in type annotation positions for exception parameters
1030                 code.fillExceptionParameterPositions();
1031             }
1032         }
1033 
1034         private int initCode(JCMethodDecl tree, Env&lt;GenContext&gt; env, boolean fatcode) {
1035             MethodSymbol meth = tree.sym;
1036 
1037             // Create a new code structure.
1038             meth.code = code = new Code(meth,
1039                                         fatcode,
1040                                         lineDebugInfo ? toplevel.lineMap : null,
1041                                         varDebugInfo,
1042                                         stackMap,
1043                                         debugCode,
1044                                         genCrt ? new CRTable(tree, env.toplevel.endPositions)
1045                                                : null,
1046                                         syms,
1047                                         types,
1048                                         poolWriter);
1049             items = new Items(poolWriter, code, syms, types);
1050             if (code.debugCode) {
1051                 System.err.println(meth + &quot; for body &quot; + tree);
1052             }
1053 
1054             // If method is not static, create a new local variable address
1055             // for `this&#39;.
1056             if ((tree.mods.flags &amp; STATIC) == 0) {
1057                 Type selfType = meth.owner.type;
1058                 if (meth.isConstructor() &amp;&amp; selfType != syms.objectType)
1059                     selfType = UninitializedType.uninitializedThis(selfType);
1060                 code.setDefined(
1061                         code.newLocal(
1062                             new VarSymbol(FINAL, names._this, selfType, meth.owner)));
1063             }
1064 
1065             // Mark all parameters as defined from the beginning of
1066             // the method.
1067             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1068                 checkDimension(l.head.pos(), l.head.sym.type);
1069                 code.setDefined(code.newLocal(l.head.sym));
1070             }
1071 
1072             // Get ready to generate code for method body.
1073             int startpcCrt = genCrt ? code.curCP() : 0;
1074             code.entryPoint();
1075 
1076             // Suppress initial stackmap
1077             code.pendingStackMap = false;
1078 
1079             return startpcCrt;
1080         }
1081 
1082         private void synthesizeValueMethod(JCMethodDecl methodDecl) {
1083 
1084             Name name; List&lt;Type&gt; argTypes; Type resType;
1085 
1086             switch (methodDecl.name.toString()) {
1087                 case &quot;toString&quot;:
1088                     name = names.toString;
1089                     argTypes = List.of(methodDecl.sym.owner.type);
1090                     resType = methodDecl.restype.type;
1091                     break;
1092                 default:
1093                     throw new AssertionError(&quot;Unexpected synthetic method body&quot;);
1094             }
1095 
1096             Type.MethodType indyType = new Type.MethodType(argTypes,
1097                     resType,
1098                     List.nil(),
1099                     syms.methodClass);
1100 
1101             List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
1102                                                 syms.stringType,
1103                                                 syms.methodTypeType);
1104 
1105             Symbol bsm = rs.resolveInternalMethod(methodDecl.pos(),
1106                     getAttrEnv(),
1107                     syms.valueBootstrapMethods,
1108                     names.fromString(&quot;makeBootstrapMethod&quot;),
1109                     bsm_staticArgs,
1110                     null);
1111 
1112             Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(name,
1113                     syms.noSymbol,
1114                     ((MethodSymbol)bsm).asHandle(),
1115                     indyType,
1116                     List.nil().toArray(new LoadableConstant[0]));
1117 
1118             code.emitop0(aload_0);
1119             items.makeDynamicItem(dynSym).invoke();
1120             code.emitop0(areturn);
1121         }
1122 
1123     public void visitVarDef(JCVariableDecl tree) {
1124         VarSymbol v = tree.sym;
1125         if (tree.init != null) {
1126             checkStringConstant(tree.init.pos(), v.getConstValue());
1127             if (v.getConstValue() == null || varDebugInfo) {
1128                 Assert.check(code.isStatementStart());
1129                 code.newLocal(v);
1130                 genExpr(tree.init, v.erasure(types)).load();
1131                 items.makeLocalItem(v).store();
1132                 Assert.check(code.isStatementStart());
1133             }
1134         } else {
1135             code.newLocal(v);
1136         }
1137         checkDimension(tree.pos(), v.type);
1138     }
1139 
1140     public void visitSkip(JCSkip tree) {
1141     }
1142 
1143     public void visitBlock(JCBlock tree) {
1144         if ((tree.flags &amp; SYNTHETIC) != 0 &amp;&amp; env.tree.hasTag(METHODDEF) &amp;&amp; (((JCMethodDecl) env.tree).sym.owner.flags() &amp; VALUE) != 0) {
1145             synthesizeValueMethod((JCMethodDecl) env.tree);
1146             return;
1147         }
1148         int limit = code.nextreg;
1149         Env&lt;GenContext&gt; localEnv = env.dup(tree, new GenContext());
1150         genStats(tree.stats, localEnv);
1151         // End the scope of all block-local variables in variable info.
1152         if (!env.tree.hasTag(METHODDEF)) {
1153             code.statBegin(tree.endpos);
1154             code.endScopes(limit);
1155             code.pendingStatPos = Position.NOPOS;
1156         }
1157     }
1158 
1159     public void visitDoLoop(JCDoWhileLoop tree) {
1160         genLoop(tree, tree.body, tree.cond, List.nil(), false);
1161     }
1162 
1163     public void visitWhileLoop(JCWhileLoop tree) {
1164         genLoop(tree, tree.body, tree.cond, List.nil(), true);
1165     }
1166 
1167     public void visitWithField(JCWithField tree) {
1168         switch(tree.field.getTag()) {
1169             case IDENT:
1170                 Symbol sym = ((JCIdent) tree.field).sym;
1171                 items.makeThisItem().load();
1172                 genExpr(tree.value, tree.field.type).load();
1173                 sym = binaryQualifier(sym, env.enclClass.type);
1174                 code.emitop2(withfield, sym, PoolWriter::putMember);
1175                 result = items.makeStackItem(tree.type);
1176                 break;
1177             case SELECT:
1178                 JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;
1179                 sym = TreeInfo.symbol(fieldAccess);
1180                 // JDK-8207332: To maintain the order of side effects, must compute value ahead of field
1181                 genExpr(tree.value, tree.field.type).load();
1182                 genExpr(fieldAccess.selected, fieldAccess.selected.type).load();
1183                 if (Code.width(tree.field.type) == 2) {
1184                     code.emitop0(dup_x2);
1185                     code.emitop0(pop);
1186                 } else {
1187                     code.emitop0(swap);
1188                 }
1189                 sym = binaryQualifier(sym, fieldAccess.selected.type);
1190                 code.emitop2(withfield, sym, PoolWriter::putMember);
1191                 result = items.makeStackItem(tree.type);
1192                 break;
1193             default:
1194                 Assert.check(false);
1195         }
1196     }
1197 
1198     public void visitForLoop(JCForLoop tree) {
1199         int limit = code.nextreg;
1200         genStats(tree.init, env);
1201         genLoop(tree, tree.body, tree.cond, tree.step, true);
1202         code.endScopes(limit);
1203     }
1204     //where
1205         /** Generate code for a loop.
1206          *  @param loop       The tree representing the loop.
1207          *  @param body       The loop&#39;s body.
1208          *  @param cond       The loop&#39;s controlling condition.
1209          *  @param step       &quot;Step&quot; statements to be inserted at end of
1210          *                    each iteration.
1211          *  @param testFirst  True if the loop test belongs before the body.
1212          */
1213         private void genLoop(JCStatement loop,
1214                              JCStatement body,
1215                              JCExpression cond,
1216                              List&lt;JCExpressionStatement&gt; step,
1217                              boolean testFirst) {
1218             Env&lt;GenContext&gt; loopEnv = env.dup(loop, new GenContext());
1219             int startpc = code.entryPoint();
1220             if (testFirst) { //while or for loop
1221                 CondItem c;
1222                 if (cond != null) {
1223                     code.statBegin(cond.pos);
1224                     Assert.check(code.isStatementStart());
1225                     c = genCond(TreeInfo.skipParens(cond), CRT_FLOW_CONTROLLER);
1226                 } else {
1227                     c = items.makeCondItem(goto_);
1228                 }
1229                 Chain loopDone = c.jumpFalse();
1230                 code.resolve(c.trueJumps);
1231                 Assert.check(code.isStatementStart());
1232                 genStat(body, loopEnv, CRT_STATEMENT | CRT_FLOW_TARGET);
1233                 code.resolve(loopEnv.info.cont);
1234                 genStats(step, loopEnv);
1235                 code.resolve(code.branch(goto_), startpc);
1236                 code.resolve(loopDone);
1237             } else {
1238                 genStat(body, loopEnv, CRT_STATEMENT | CRT_FLOW_TARGET);
1239                 code.resolve(loopEnv.info.cont);
1240                 genStats(step, loopEnv);
1241                 if (code.isAlive()) {
1242                     CondItem c;
1243                     if (cond != null) {
1244                         code.statBegin(cond.pos);
1245                         Assert.check(code.isStatementStart());
1246                         c = genCond(TreeInfo.skipParens(cond), CRT_FLOW_CONTROLLER);
1247                     } else {
1248                         c = items.makeCondItem(goto_);
1249                     }
1250                     code.resolve(c.jumpTrue(), startpc);
1251                     Assert.check(code.isStatementStart());
1252                     code.resolve(c.falseJumps);
1253                 }
1254             }
1255             Chain exit = loopEnv.info.exit;
1256             if (exit != null) {
1257                 code.resolve(exit);
1258                 exit.state.defined.excludeFrom(code.nextreg);
1259             }
1260         }
1261 
1262     public void visitForeachLoop(JCEnhancedForLoop tree) {
1263         throw new AssertionError(); // should have been removed by Lower.
1264     }
1265 
1266     public void visitLabelled(JCLabeledStatement tree) {
1267         Env&lt;GenContext&gt; localEnv = env.dup(tree, new GenContext());
1268         genStat(tree.body, localEnv, CRT_STATEMENT);
1269         Chain exit = localEnv.info.exit;
1270         if (exit != null) {
1271             code.resolve(exit);
1272             exit.state.defined.excludeFrom(code.nextreg);
1273         }
1274     }
1275 
1276     public void visitSwitch(JCSwitch tree) {
1277         handleSwitch(tree, tree.selector, tree.cases);
1278     }
1279 
1280     @Override
1281     public void visitSwitchExpression(JCSwitchExpression tree) {
1282         code.resolvePending();
1283         boolean prevInCondSwitchExpression = inCondSwitchExpression;
1284         try {
1285             inCondSwitchExpression = false;
1286             doHandleSwitchExpression(tree);
1287         } finally {
1288             inCondSwitchExpression = prevInCondSwitchExpression;
1289         }
1290         result = items.makeStackItem(pt);
1291     }
1292 
1293     private void doHandleSwitchExpression(JCSwitchExpression tree) {
1294         List&lt;LocalItem&gt; prevStackBeforeSwitchExpression = stackBeforeSwitchExpression;
1295         LocalItem prevSwitchResult = switchResult;
1296         int limit = code.nextreg;
1297         try {
1298             stackBeforeSwitchExpression = List.nil();
1299             switchResult = null;
1300             if (hasTry(tree)) {
1301                 //if the switch expression contains try-catch, the catch handlers need to have
1302                 //an empty stack. So stash whole stack to local variables, and restore it before
1303                 //breaks:
1304                 while (code.state.stacksize &gt; 0) {
1305                     Type type = code.state.peek();
1306                     Name varName = names.fromString(target.syntheticNameChar() +
1307                                                     &quot;stack&quot; +
1308                                                     target.syntheticNameChar() +
1309                                                     tree.pos +
1310                                                     target.syntheticNameChar() +
1311                                                     code.state.stacksize);
1312                     VarSymbol var = new VarSymbol(Flags.SYNTHETIC, varName, type,
1313                                                   this.env.enclMethod.sym);
1314                     LocalItem item = items.new LocalItem(type, code.newLocal(var));
1315                     stackBeforeSwitchExpression = stackBeforeSwitchExpression.prepend(item);
1316                     item.store();
1317                 }
1318                 switchResult = makeTemp(tree.type);
1319             }
1320             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
1321             try {
1322                 handleSwitch(tree, tree.selector, tree.cases);
1323             } finally {
1324                 code.setLetExprStackPos(prevLetExprStart);
1325             }
1326         } finally {
1327             stackBeforeSwitchExpression = prevStackBeforeSwitchExpression;
1328             switchResult = prevSwitchResult;
1329             code.endScopes(limit);
1330         }
1331     }
1332     //where:
1333         private boolean hasTry(JCSwitchExpression tree) {
1334             boolean[] hasTry = new boolean[1];
1335             new TreeScanner() {
1336                 @Override
1337                 public void visitTry(JCTry tree) {
1338                     hasTry[0] = true;
1339                 }
1340 
1341                 @Override
1342                 public void visitClassDef(JCClassDecl tree) {
1343                 }
1344 
1345                 @Override
1346                 public void visitLambda(JCLambda tree) {
1347                 }
1348             }.scan(tree);
1349             return hasTry[0];
1350         }
1351 
1352     private void handleSwitch(JCTree swtch, JCExpression selector, List&lt;JCCase&gt; cases) {
1353         int limit = code.nextreg;
1354         Assert.check(!selector.type.hasTag(CLASS));
1355         int startpcCrt = genCrt ? code.curCP() : 0;
1356         Assert.check(code.isStatementStart());
1357         Item sel = genExpr(selector, syms.intType);
1358         if (cases.isEmpty()) {
1359             // We are seeing:  switch &lt;sel&gt; {}
1360             sel.load().drop();
1361             if (genCrt)
1362                 code.crt.put(TreeInfo.skipParens(selector),
1363                              CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());
1364         } else {
1365             // We are seeing a nonempty switch.
1366             sel.load();
1367             if (genCrt)
1368                 code.crt.put(TreeInfo.skipParens(selector),
1369                              CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());
1370             Env&lt;GenContext&gt; switchEnv = env.dup(swtch, new GenContext());
1371             switchEnv.info.isSwitch = true;
1372 
1373             // Compute number of labels and minimum and maximum label values.
1374             // For each case, store its label in an array.
1375             int lo = Integer.MAX_VALUE;  // minimum label.
1376             int hi = Integer.MIN_VALUE;  // maximum label.
1377             int nlabels = 0;               // number of labels.
1378 
1379             int[] labels = new int[cases.length()];  // the label array.
1380             int defaultIndex = -1;     // the index of the default clause.
1381 
1382             List&lt;JCCase&gt; l = cases;
1383             for (int i = 0; i &lt; labels.length; i++) {
1384                 if (l.head.pats.nonEmpty()) {
1385                     Assert.check(l.head.pats.size() == 1);
1386                     int val = ((Number)l.head.pats.head.type.constValue()).intValue();
1387                     labels[i] = val;
1388                     if (val &lt; lo) lo = val;
1389                     if (hi &lt; val) hi = val;
1390                     nlabels++;
1391                 } else {
1392                     Assert.check(defaultIndex == -1);
1393                     defaultIndex = i;
1394                 }
1395                 l = l.tail;
1396             }
1397 
1398             // Determine whether to issue a tableswitch or a lookupswitch
1399             // instruction.
1400             long table_space_cost = 4 + ((long) hi - lo + 1); // words
1401             long table_time_cost = 3; // comparisons
1402             long lookup_space_cost = 3 + 2 * (long) nlabels;
1403             long lookup_time_cost = nlabels;
1404             int opcode =
1405                 nlabels &gt; 0 &amp;&amp;
1406                 table_space_cost + 3 * table_time_cost &lt;=
1407                 lookup_space_cost + 3 * lookup_time_cost
1408                 ?
1409                 tableswitch : lookupswitch;
1410 
1411             int startpc = code.curCP();    // the position of the selector operation
1412             code.emitop0(opcode);
1413             code.align(4);
1414             int tableBase = code.curCP();  // the start of the jump table
1415             int[] offsets = null;          // a table of offsets for a lookupswitch
1416             code.emit4(-1);                // leave space for default offset
1417             if (opcode == tableswitch) {
1418                 code.emit4(lo);            // minimum label
1419                 code.emit4(hi);            // maximum label
1420                 for (long i = lo; i &lt;= hi; i++) {  // leave space for jump table
1421                     code.emit4(-1);
1422                 }
1423             } else {
1424                 code.emit4(nlabels);    // number of labels
1425                 for (int i = 0; i &lt; nlabels; i++) {
1426                     code.emit4(-1); code.emit4(-1); // leave space for lookup table
1427                 }
1428                 offsets = new int[labels.length];
1429             }
1430             Code.State stateSwitch = code.state.dup();
1431             code.markDead();
1432 
1433             // For each case do:
1434             l = cases;
1435             for (int i = 0; i &lt; labels.length; i++) {
1436                 JCCase c = l.head;
1437                 l = l.tail;
1438 
1439                 int pc = code.entryPoint(stateSwitch);
1440                 // Insert offset directly into code or else into the
1441                 // offsets table.
1442                 if (i != defaultIndex) {
1443                     if (opcode == tableswitch) {
1444                         code.put4(
1445                             tableBase + 4 * (labels[i] - lo + 3),
1446                             pc - startpc);
1447                     } else {
1448                         offsets[i] = pc - startpc;
1449                     }
1450                 } else {
1451                     code.put4(tableBase, pc - startpc);
1452                 }
1453 
1454                 // Generate code for the statements in this case.
1455                 genStats(c.stats, switchEnv, CRT_FLOW_TARGET);
1456             }
1457 
1458             // Resolve all breaks.
1459             Chain exit = switchEnv.info.exit;
1460             if  (exit != null) {
1461                 code.resolve(exit);
1462                 exit.state.defined.excludeFrom(limit);
1463             }
1464 
1465             // If we have not set the default offset, we do so now.
1466             if (code.get4(tableBase) == -1) {
1467                 code.put4(tableBase, code.entryPoint(stateSwitch) - startpc);
1468             }
1469 
1470             if (opcode == tableswitch) {
1471                 // Let any unfilled slots point to the default case.
1472                 int defaultOffset = code.get4(tableBase);
1473                 for (long i = lo; i &lt;= hi; i++) {
1474                     int t = (int)(tableBase + 4 * (i - lo + 3));
1475                     if (code.get4(t) == -1)
1476                         code.put4(t, defaultOffset);
1477                 }
1478             } else {
1479                 // Sort non-default offsets and copy into lookup table.
1480                 if (defaultIndex &gt;= 0)
1481                     for (int i = defaultIndex; i &lt; labels.length - 1; i++) {
1482                         labels[i] = labels[i+1];
1483                         offsets[i] = offsets[i+1];
1484                     }
1485                 if (nlabels &gt; 0)
1486                     qsort2(labels, offsets, 0, nlabels - 1);
1487                 for (int i = 0; i &lt; nlabels; i++) {
1488                     int caseidx = tableBase + 8 * (i + 1);
1489                     code.put4(caseidx, labels[i]);
1490                     code.put4(caseidx + 4, offsets[i]);
1491                 }
1492             }
1493         }
1494         code.endScopes(limit);
1495     }
1496 //where
1497         /** Sort (int) arrays of keys and values
1498          */
1499        static void qsort2(int[] keys, int[] values, int lo, int hi) {
1500             int i = lo;
1501             int j = hi;
1502             int pivot = keys[(i+j)/2];
1503             do {
1504                 while (keys[i] &lt; pivot) i++;
1505                 while (pivot &lt; keys[j]) j--;
1506                 if (i &lt;= j) {
1507                     int temp1 = keys[i];
1508                     keys[i] = keys[j];
1509                     keys[j] = temp1;
1510                     int temp2 = values[i];
1511                     values[i] = values[j];
1512                     values[j] = temp2;
1513                     i++;
1514                     j--;
1515                 }
1516             } while (i &lt;= j);
1517             if (lo &lt; j) qsort2(keys, values, lo, j);
1518             if (i &lt; hi) qsort2(keys, values, i, hi);
1519         }
1520 
1521     public void visitSynchronized(JCSynchronized tree) {
1522         int limit = code.nextreg;
1523         // Generate code to evaluate lock and save in temporary variable.
1524         final LocalItem lockVar = makeTemp(syms.objectType);
1525         Assert.check(code.isStatementStart());
1526         genExpr(tree.lock, tree.lock.type).load().duplicate();
1527         lockVar.store();
1528 
1529         // Generate code to enter monitor.
1530         code.emitop0(monitorenter);
1531         code.state.lock(lockVar.reg);
1532 
1533         // Generate code for a try statement with given body, no catch clauses
1534         // in a new environment with the &quot;exit-monitor&quot; operation as finalizer.
1535         final Env&lt;GenContext&gt; syncEnv = env.dup(tree, new GenContext());
1536         syncEnv.info.finalize = new GenFinalizer() {
1537             void gen() {
1538                 genLast();
1539                 Assert.check(syncEnv.info.gaps.length() % 2 == 0);
1540                 syncEnv.info.gaps.append(code.curCP());
1541             }
1542             void genLast() {
1543                 if (code.isAlive()) {
1544                     lockVar.load();
1545                     code.emitop0(monitorexit);
1546                     code.state.unlock(lockVar.reg);
1547                 }
1548             }
1549         };
1550         syncEnv.info.gaps = new ListBuffer&lt;&gt;();
1551         genTry(tree.body, List.nil(), syncEnv);
1552         code.endScopes(limit);
1553     }
1554 
1555     public void visitTry(final JCTry tree) {
1556         // Generate code for a try statement with given body and catch clauses,
1557         // in a new environment which calls the finally block if there is one.
1558         final Env&lt;GenContext&gt; tryEnv = env.dup(tree, new GenContext());
1559         final Env&lt;GenContext&gt; oldEnv = env;
1560         tryEnv.info.finalize = new GenFinalizer() {
1561             void gen() {
1562                 Assert.check(tryEnv.info.gaps.length() % 2 == 0);
1563                 tryEnv.info.gaps.append(code.curCP());
1564                 genLast();
1565             }
1566             void genLast() {
1567                 if (tree.finalizer != null)
1568                     genStat(tree.finalizer, oldEnv, CRT_BLOCK);
1569             }
1570             boolean hasFinalizer() {
1571                 return tree.finalizer != null;
1572             }
1573 
1574             @Override
1575             void afterBody() {
1576                 if (tree.finalizer != null &amp;&amp; (tree.finalizer.flags &amp; BODY_ONLY_FINALIZE) != 0) {
1577                     //for body-only finally, remove the GenFinalizer after try body
1578                     //so that the finally is not generated to catch bodies:
1579                     tryEnv.info.finalize = null;
1580                 }
1581             }
1582 
1583         };
1584         tryEnv.info.gaps = new ListBuffer&lt;&gt;();
1585         genTry(tree.body, tree.catchers, tryEnv);
1586     }
1587     //where
1588         /** Generate code for a try or synchronized statement
1589          *  @param body      The body of the try or synchronized statement.
1590          *  @param catchers  The lis of catch clauses.
1591          *  @param env       the environment current for the body.
1592          */
1593         void genTry(JCTree body, List&lt;JCCatch&gt; catchers, Env&lt;GenContext&gt; env) {
1594             int limit = code.nextreg;
1595             int startpc = code.curCP();
1596             Code.State stateTry = code.state.dup();
1597             genStat(body, env, CRT_BLOCK);
1598             int endpc = code.curCP();
1599             List&lt;Integer&gt; gaps = env.info.gaps.toList();
1600             code.statBegin(TreeInfo.endPos(body));
1601             genFinalizer(env);
1602             code.statBegin(TreeInfo.endPos(env.tree));
1603             Chain exitChain = code.branch(goto_);
1604             endFinalizerGap(env);
1605             env.info.finalize.afterBody();
1606             boolean hasFinalizer =
1607                 env.info.finalize != null &amp;&amp;
1608                 env.info.finalize.hasFinalizer();
1609             if (startpc != endpc) for (List&lt;JCCatch&gt; l = catchers; l.nonEmpty(); l = l.tail) {
1610                 // start off with exception on stack
1611                 code.entryPoint(stateTry, l.head.param.sym.type);
1612                 genCatch(l.head, env, startpc, endpc, gaps);
1613                 genFinalizer(env);
1614                 if (hasFinalizer || l.tail.nonEmpty()) {
1615                     code.statBegin(TreeInfo.endPos(env.tree));
1616                     exitChain = Code.mergeChains(exitChain,
1617                                                  code.branch(goto_));
1618                 }
1619                 endFinalizerGap(env);
1620             }
1621             if (hasFinalizer) {
1622                 // Create a new register segment to avoid allocating
1623                 // the same variables in finalizers and other statements.
1624                 code.newRegSegment();
1625 
1626                 // Add a catch-all clause.
1627 
1628                 // start off with exception on stack
1629                 int catchallpc = code.entryPoint(stateTry, syms.throwableType);
1630 
1631                 // Register all exception ranges for catch all clause.
1632                 // The range of the catch all clause is from the beginning
1633                 // of the try or synchronized block until the present
1634                 // code pointer excluding all gaps in the current
1635                 // environment&#39;s GenContext.
1636                 int startseg = startpc;
1637                 while (env.info.gaps.nonEmpty()) {
1638                     int endseg = env.info.gaps.next().intValue();
1639                     registerCatch(body.pos(), startseg, endseg,
1640                                   catchallpc, 0);
1641                     startseg = env.info.gaps.next().intValue();
1642                 }
1643                 code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.FIRST_STAT_POS));
1644                 code.markStatBegin();
1645 
1646                 Item excVar = makeTemp(syms.throwableType);
1647                 excVar.store();
1648                 genFinalizer(env);
1649                 code.resolvePending();
1650                 code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.END_POS));
1651                 code.markStatBegin();
1652 
1653                 excVar.load();
1654                 registerCatch(body.pos(), startseg,
1655                               env.info.gaps.next().intValue(),
1656                               catchallpc, 0);
1657                 code.emitop0(athrow);
1658                 code.markDead();
1659 
1660                 // If there are jsr&#39;s to this finalizer, ...
1661                 if (env.info.cont != null) {
1662                     // Resolve all jsr&#39;s.
1663                     code.resolve(env.info.cont);
1664 
1665                     // Mark statement line number
1666                     code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.FIRST_STAT_POS));
1667                     code.markStatBegin();
1668 
1669                     // Save return address.
1670                     LocalItem retVar = makeTemp(syms.throwableType);
1671                     retVar.store();
1672 
1673                     // Generate finalizer code.
1674                     env.info.finalize.genLast();
1675 
1676                     // Return.
1677                     code.emitop1w(ret, retVar.reg);
1678                     code.markDead();
1679                 }
1680             }
1681             // Resolve all breaks.
1682             code.resolve(exitChain);
1683 
1684             code.endScopes(limit);
1685         }
1686 
1687         /** Generate code for a catch clause.
1688          *  @param tree     The catch clause.
1689          *  @param env      The environment current in the enclosing try.
1690          *  @param startpc  Start pc of try-block.
1691          *  @param endpc    End pc of try-block.
1692          */
1693         void genCatch(JCCatch tree,
1694                       Env&lt;GenContext&gt; env,
1695                       int startpc, int endpc,
1696                       List&lt;Integer&gt; gaps) {
1697             if (startpc != endpc) {
1698                 List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypeExprs
1699                         = catchTypesWithAnnotations(tree);
1700                 while (gaps.nonEmpty()) {
1701                     for (Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt; subCatch1 : catchTypeExprs) {
1702                         JCExpression subCatch = subCatch1.snd;
1703                         int catchType = makeRef(tree.pos(), subCatch.type);
1704                         int end = gaps.head.intValue();
1705                         registerCatch(tree.pos(),
1706                                       startpc,  end, code.curCP(),
1707                                       catchType);
1708                         for (Attribute.TypeCompound tc :  subCatch1.fst) {
1709                                 tc.position.setCatchInfo(catchType, startpc);
1710                         }
1711                     }
1712                     gaps = gaps.tail;
1713                     startpc = gaps.head.intValue();
1714                     gaps = gaps.tail;
1715                 }
1716                 if (startpc &lt; endpc) {
1717                     for (Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt; subCatch1 : catchTypeExprs) {
1718                         JCExpression subCatch = subCatch1.snd;
1719                         int catchType = makeRef(tree.pos(), subCatch.type);
1720                         registerCatch(tree.pos(),
1721                                       startpc, endpc, code.curCP(),
1722                                       catchType);
1723                         for (Attribute.TypeCompound tc :  subCatch1.fst) {
1724                             tc.position.setCatchInfo(catchType, startpc);
1725                         }
1726                     }
1727                 }
1728                 VarSymbol exparam = tree.param.sym;
1729                 code.statBegin(tree.pos);
1730                 code.markStatBegin();
1731                 int limit = code.nextreg;
1732                 code.newLocal(exparam);
1733                 items.makeLocalItem(exparam).store();
1734                 code.statBegin(TreeInfo.firstStatPos(tree.body));
1735                 genStat(tree.body, env, CRT_BLOCK);
1736                 code.endScopes(limit);
1737                 code.statBegin(TreeInfo.endPos(tree.body));
1738             }
1739         }
1740         // where
1741         List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypesWithAnnotations(JCCatch tree) {
1742             return TreeInfo.isMultiCatch(tree) ?
1743                     catchTypesWithAnnotationsFromMulticatch((JCTypeUnion)tree.param.vartype, tree.param.sym.getRawTypeAttributes()) :
1744                     List.of(new Pair&lt;&gt;(tree.param.sym.getRawTypeAttributes(), tree.param.vartype));
1745         }
1746         // where
1747         List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypesWithAnnotationsFromMulticatch(JCTypeUnion tree, List&lt;TypeCompound&gt; first) {
1748             List&lt;JCExpression&gt; alts = tree.alternatives;
1749             List&lt;Pair&lt;List&lt;TypeCompound&gt;, JCExpression&gt;&gt; res = List.of(new Pair&lt;&gt;(first, alts.head));
1750             alts = alts.tail;
1751 
1752             while(alts != null &amp;&amp; alts.head != null) {
1753                 JCExpression alt = alts.head;
1754                 if (alt instanceof JCAnnotatedType) {
1755                     JCAnnotatedType a = (JCAnnotatedType)alt;
1756                     res = res.prepend(new Pair&lt;&gt;(annotate.fromAnnotations(a.annotations), alt));
1757                 } else {
1758                     res = res.prepend(new Pair&lt;&gt;(List.nil(), alt));
1759                 }
1760                 alts = alts.tail;
1761             }
1762             return res.reverse();
1763         }
1764 
1765         /** Register a catch clause in the &quot;Exceptions&quot; code-attribute.
1766          */
1767         void registerCatch(DiagnosticPosition pos,
1768                            int startpc, int endpc,
1769                            int handler_pc, int catch_type) {
1770             char startpc1 = (char)startpc;
1771             char endpc1 = (char)endpc;
1772             char handler_pc1 = (char)handler_pc;
1773             if (startpc1 == startpc &amp;&amp;
1774                 endpc1 == endpc &amp;&amp;
1775                 handler_pc1 == handler_pc) {
1776                 code.addCatch(startpc1, endpc1, handler_pc1,
1777                               (char)catch_type);
1778             } else {
1779                 log.error(pos, Errors.LimitCodeTooLargeForTryStmt);
1780                 nerrs++;
1781             }
1782         }
1783 
1784     public void visitIf(JCIf tree) {
1785         int limit = code.nextreg;
1786         Chain thenExit = null;
1787         Assert.check(code.isStatementStart());
1788         CondItem c = genCond(TreeInfo.skipParens(tree.cond),
1789                              CRT_FLOW_CONTROLLER);
1790         Chain elseChain = c.jumpFalse();
1791         Assert.check(code.isStatementStart());
1792         if (!c.isFalse()) {
1793             code.resolve(c.trueJumps);
1794             genStat(tree.thenpart, env, CRT_STATEMENT | CRT_FLOW_TARGET);
1795             thenExit = code.branch(goto_);
1796         }
1797         if (elseChain != null) {
1798             code.resolve(elseChain);
1799             if (tree.elsepart != null) {
1800                 genStat(tree.elsepart, env,CRT_STATEMENT | CRT_FLOW_TARGET);
1801             }
1802         }
1803         code.resolve(thenExit);
1804         code.endScopes(limit);
1805         Assert.check(code.isStatementStart());
1806     }
1807 
1808     public void visitExec(JCExpressionStatement tree) {
1809         // Optimize x++ to ++x and x-- to --x.
1810         JCExpression e = tree.expr;
1811         switch (e.getTag()) {
1812             case POSTINC:
1813                 ((JCUnary) e).setTag(PREINC);
1814                 break;
1815             case POSTDEC:
1816                 ((JCUnary) e).setTag(PREDEC);
1817                 break;
1818         }
1819         Assert.check(code.isStatementStart());
1820         genExpr(tree.expr, tree.expr.type).drop();
1821         Assert.check(code.isStatementStart());
1822     }
1823 
1824     public void visitBreak(JCBreak tree) {
1825         Assert.check(code.isStatementStart());
1826         final Env&lt;GenContext&gt; targetEnv = unwindBreak(tree.target);
1827         targetEnv.info.addExit(code.branch(goto_));
1828         endFinalizerGaps(env, targetEnv);
1829     }
1830 
1831     public void visitYield(JCYield tree) {
1832         Assert.check(code.isStatementStart());
1833         final Env&lt;GenContext&gt; targetEnv;
1834         if (inCondSwitchExpression) {
1835             CondItem value = genCond(tree.value, CRT_FLOW_TARGET);
1836             Chain falseJumps = value.jumpFalse();
1837 
1838             code.resolve(value.trueJumps);
1839             Env&lt;GenContext&gt; localEnv = unwindBreak(tree.target);
1840             reloadStackBeforeSwitchExpr();
1841             Chain trueJumps = code.branch(goto_);
1842 
1843             endFinalizerGaps(env, localEnv);
1844 
1845             code.resolve(falseJumps);
1846             targetEnv = unwindBreak(tree.target);
1847             reloadStackBeforeSwitchExpr();
1848             falseJumps = code.branch(goto_);
1849 
1850             if (switchExpressionTrueChain == null) {
1851                 switchExpressionTrueChain = trueJumps;
1852             } else {
1853                 switchExpressionTrueChain =
1854                         Code.mergeChains(switchExpressionTrueChain, trueJumps);
1855             }
1856             if (switchExpressionFalseChain == null) {
1857                 switchExpressionFalseChain = falseJumps;
1858             } else {
1859                 switchExpressionFalseChain =
1860                         Code.mergeChains(switchExpressionFalseChain, falseJumps);
1861             }
1862         } else {
1863             genExpr(tree.value, pt).load();
1864             if (switchResult != null)
1865                 switchResult.store();
1866 
1867             targetEnv = unwindBreak(tree.target);
1868 
1869             if (code.isAlive()) {
1870                 reloadStackBeforeSwitchExpr();
1871                 if (switchResult != null)
1872                     switchResult.load();
1873 
1874                 code.state.forceStackTop(tree.target.type);
1875                 targetEnv.info.addExit(code.branch(goto_));
1876                 code.markDead();
1877             }
1878         }
1879         endFinalizerGaps(env, targetEnv);
1880     }
1881     //where:
1882         /** As side-effect, might mark code as dead disabling any further emission.
1883          */
1884         private Env&lt;GenContext&gt; unwindBreak(JCTree target) {
1885             int tmpPos = code.pendingStatPos;
1886             Env&lt;GenContext&gt; targetEnv = unwind(target, env);
1887             code.pendingStatPos = tmpPos;
1888             return targetEnv;
1889         }
1890 
1891         private void reloadStackBeforeSwitchExpr() {
1892             for (LocalItem li : stackBeforeSwitchExpression)
1893                 li.load();
1894         }
1895 
1896     public void visitContinue(JCContinue tree) {
1897         int tmpPos = code.pendingStatPos;
1898         Env&lt;GenContext&gt; targetEnv = unwind(tree.target, env);
1899         code.pendingStatPos = tmpPos;
1900         Assert.check(code.isStatementStart());
1901         targetEnv.info.addCont(code.branch(goto_));
1902         endFinalizerGaps(env, targetEnv);
1903     }
1904 
1905     public void visitReturn(JCReturn tree) {
1906         int limit = code.nextreg;
1907         final Env&lt;GenContext&gt; targetEnv;
1908 
1909         /* Save and then restore the location of the return in case a finally
1910          * is expanded (with unwind()) in the middle of our bytecodes.
1911          */
1912         int tmpPos = code.pendingStatPos;
1913         if (tree.expr != null) {
1914             Assert.check(code.isStatementStart());
1915             Item r = genExpr(tree.expr, pt).load();
1916             if (hasFinally(env.enclMethod, env)) {
1917                 r = makeTemp(pt);
1918                 r.store();
1919             }
1920             targetEnv = unwind(env.enclMethod, env);
1921             code.pendingStatPos = tmpPos;
1922             r.load();
1923             code.emitop0(ireturn + Code.truncate(Code.typecode(pt)));
1924         } else {
1925             targetEnv = unwind(env.enclMethod, env);
1926             code.pendingStatPos = tmpPos;
1927             code.emitop0(return_);
1928         }
1929         endFinalizerGaps(env, targetEnv);
1930         code.endScopes(limit);
1931     }
1932 
1933     public void visitThrow(JCThrow tree) {
1934         Assert.check(code.isStatementStart());
1935         genExpr(tree.expr, tree.expr.type).load();
1936         code.emitop0(athrow);
1937         Assert.check(code.isStatementStart());
1938     }
1939 
1940 /* ************************************************************************
1941  * Visitor methods for expressions
1942  *************************************************************************/
1943 
1944     public void visitApply(JCMethodInvocation tree) {
1945         setTypeAnnotationPositions(tree.pos);
1946         // Generate code for method.
1947         Item m = genExpr(tree.meth, methodType);
1948         // Generate code for all arguments, where the expected types are
1949         // the parameters of the method&#39;s external type (that is, any implicit
1950         // outer instance of a super(...) call appears as first parameter).
1951         MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(tree.meth);
1952         genArgs(tree.args,
1953                 msym.externalType(types).getParameterTypes());
1954         if (!msym.isDynamic()) {
1955             code.statBegin(tree.pos);
1956         }
1957         result = m.invoke();
1958     }
1959 
1960     public void visitConditional(JCConditional tree) {
1961         Chain thenExit = null;
1962         code.statBegin(tree.cond.pos);
1963         CondItem c = genCond(tree.cond, CRT_FLOW_CONTROLLER);
1964         Chain elseChain = c.jumpFalse();
1965         if (!c.isFalse()) {
1966             code.resolve(c.trueJumps);
1967             int startpc = genCrt ? code.curCP() : 0;
1968             code.statBegin(tree.truepart.pos);
1969             genExpr(tree.truepart, pt).load();
1970             code.state.forceStackTop(tree.type);
1971             if (genCrt) code.crt.put(tree.truepart, CRT_FLOW_TARGET,
1972                                      startpc, code.curCP());
1973             thenExit = code.branch(goto_);
1974         }
1975         if (elseChain != null) {
1976             code.resolve(elseChain);
1977             int startpc = genCrt ? code.curCP() : 0;
1978             code.statBegin(tree.falsepart.pos);
1979             genExpr(tree.falsepart, pt).load();
1980             code.state.forceStackTop(tree.type);
1981             if (genCrt) code.crt.put(tree.falsepart, CRT_FLOW_TARGET,
1982                                      startpc, code.curCP());
1983         }
1984         code.resolve(thenExit);
1985         result = items.makeStackItem(pt);
1986     }
1987 
1988     private void setTypeAnnotationPositions(int treePos) {
1989         MethodSymbol meth = code.meth;
1990         boolean initOrClinit = code.meth.getKind() == javax.lang.model.element.ElementKind.CONSTRUCTOR
1991                 || code.meth.getKind() == javax.lang.model.element.ElementKind.STATIC_INIT;
1992 
1993         for (Attribute.TypeCompound ta : meth.getRawTypeAttributes()) {
1994             if (ta.hasUnknownPosition())
1995                 ta.tryFixPosition();
1996 
1997             if (ta.position.matchesPos(treePos))
1998                 ta.position.updatePosOffset(code.cp);
1999         }
2000 
2001         if (!initOrClinit)
2002             return;
2003 
2004         for (Attribute.TypeCompound ta : meth.owner.getRawTypeAttributes()) {
2005             if (ta.hasUnknownPosition())
2006                 ta.tryFixPosition();
2007 
2008             if (ta.position.matchesPos(treePos))
2009                 ta.position.updatePosOffset(code.cp);
2010         }
2011 
2012         ClassSymbol clazz = meth.enclClass();
2013         for (Symbol s : new com.sun.tools.javac.model.FilteredMemberList(clazz.members())) {
2014             if (!s.getKind().isField())
2015                 continue;
2016 
2017             for (Attribute.TypeCompound ta : s.getRawTypeAttributes()) {
2018                 if (ta.hasUnknownPosition())
2019                     ta.tryFixPosition();
2020 
2021                 if (ta.position.matchesPos(treePos))
2022                     ta.position.updatePosOffset(code.cp);
2023             }
2024         }
2025     }
2026 
2027     public void visitNewClass(JCNewClass tree) {
2028         // Enclosing instances or anonymous classes should have been eliminated
2029         // by now.
2030         Assert.check(tree.encl == null &amp;&amp; tree.def == null);
2031         setTypeAnnotationPositions(tree.pos);
2032 
2033         code.emitop2(new_, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);
2034         code.emitop0(dup);
2035 
2036         // Generate code for all arguments, where the expected types are
2037         // the parameters of the constructor&#39;s external type (that is,
2038         // any implicit outer instance appears as first parameter).
2039         genArgs(tree.args, tree.constructor.externalType(types).getParameterTypes());
2040 
2041         items.makeMemberItem(tree.constructor, true).invoke();
2042 
2043         result = items.makeStackItem(tree.type);
2044     }
2045 
2046     public void visitNewArray(JCNewArray tree) {
2047         setTypeAnnotationPositions(tree.pos);
2048 
2049         if (tree.elems != null) {
2050             Type elemtype = types.elemtype(tree.type);
2051             loadIntConst(tree.elems.length());
2052             Item arr = makeNewArray(tree.pos(), tree.type, 1);
2053             int i = 0;
2054             for (List&lt;JCExpression&gt; l = tree.elems; l.nonEmpty(); l = l.tail) {
2055                 arr.duplicate();
2056                 loadIntConst(i);
2057                 i++;
2058                 genExpr(l.head, elemtype).load();
2059                 items.makeIndexedItem(elemtype).store();
2060             }
2061             result = arr;
2062         } else {
2063             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
2064                 genExpr(l.head, syms.intType).load();
2065             }
2066             result = makeNewArray(tree.pos(), tree.type, tree.dims.length());
2067         }
2068     }
2069 //where
2070         /** Generate code to create an array with given element type and number
2071          *  of dimensions.
2072          */
2073         Item makeNewArray(DiagnosticPosition pos, Type type, int ndims) {
2074             Type elemtype = types.elemtype(type);
2075             if (types.dimensions(type) &gt; ClassFile.MAX_DIMENSIONS) {
2076                 log.error(pos, Errors.LimitDimensions);
2077                 nerrs++;
2078             }
2079             int elemcode = Code.arraycode(elemtype);
2080             if (elemcode == 0 || (elemcode == 1 &amp;&amp; ndims == 1)) {
2081                 code.emitAnewarray(makeRef(pos, elemtype, types.isValue(elemtype)), type);
2082             } else if (elemcode == 1) {
2083                 code.emitMultianewarray(ndims, makeRef(pos, type), type);
2084             } else {
2085                 code.emitNewarray(elemcode, type);
2086             }
2087             return items.makeStackItem(type);
2088         }
2089 
2090     public void visitParens(JCParens tree) {
2091         result = genExpr(tree.expr, tree.expr.type);
2092     }
2093 
2094     public void visitAssign(JCAssign tree) {
2095         Item l = genExpr(tree.lhs, tree.lhs.type);
2096         genExpr(tree.rhs, tree.lhs.type).load();
2097         if (tree.rhs.type.hasTag(BOT)) {
2098             /* This is just a case of widening reference conversion that per 5.1.5 simply calls
2099                for &quot;regarding a reference as having some other type in a manner that can be proved
2100                correct at compile time.&quot;
2101             */
2102             code.state.forceStackTop(tree.lhs.type);
2103         }
2104         result = items.makeAssignItem(l);
2105     }
2106 
2107     public void visitAssignop(JCAssignOp tree) {
2108         OperatorSymbol operator = tree.operator;
2109         Item l;
2110         if (operator.opcode == string_add) {
2111             l = concat.makeConcat(tree);
2112         } else {
2113             // Generate code for first expression
2114             l = genExpr(tree.lhs, tree.lhs.type);
2115 
2116             // If we have an increment of -32768 to +32767 of a local
2117             // int variable we can use an incr instruction instead of
2118             // proceeding further.
2119             if ((tree.hasTag(PLUS_ASG) || tree.hasTag(MINUS_ASG)) &amp;&amp;
2120                 l instanceof LocalItem &amp;&amp;
2121                 tree.lhs.type.getTag().isSubRangeOf(INT) &amp;&amp;
2122                 tree.rhs.type.getTag().isSubRangeOf(INT) &amp;&amp;
2123                 tree.rhs.type.constValue() != null) {
2124                 int ival = ((Number) tree.rhs.type.constValue()).intValue();
2125                 if (tree.hasTag(MINUS_ASG)) ival = -ival;
2126                 ((LocalItem)l).incr(ival);
2127                 result = l;
2128                 return;
2129             }
2130             // Otherwise, duplicate expression, load one copy
2131             // and complete binary operation.
2132             l.duplicate();
2133             l.coerce(operator.type.getParameterTypes().head).load();
2134             completeBinop(tree.lhs, tree.rhs, operator).coerce(tree.lhs.type);
2135         }
2136         result = items.makeAssignItem(l);
2137     }
2138 
2139     public void visitUnary(JCUnary tree) {
2140         OperatorSymbol operator = tree.operator;
2141         if (tree.hasTag(NOT)) {
2142             CondItem od = genCond(tree.arg, false);
2143             result = od.negate();
2144         } else {
2145             Item od = genExpr(tree.arg, operator.type.getParameterTypes().head);
2146             switch (tree.getTag()) {
2147             case POS:
2148                 result = od.load();
2149                 break;
2150             case NEG:
2151                 result = od.load();
2152                 code.emitop0(operator.opcode);
2153                 break;
2154             case COMPL:
2155                 result = od.load();
2156                 emitMinusOne(od.typecode);
2157                 code.emitop0(operator.opcode);
2158                 break;
2159             case PREINC: case PREDEC:
2160                 od.duplicate();
2161                 if (od instanceof LocalItem &amp;&amp;
2162                     (operator.opcode == iadd || operator.opcode == isub)) {
2163                     ((LocalItem)od).incr(tree.hasTag(PREINC) ? 1 : -1);
2164                     result = od;
2165                 } else {
2166                     od.load();
2167                     code.emitop0(one(od.typecode));
2168                     code.emitop0(operator.opcode);
2169                     // Perform narrowing primitive conversion if byte,
2170                     // char, or short.  Fix for 4304655.
2171                     if (od.typecode != INTcode &amp;&amp;
2172                         Code.truncate(od.typecode) == INTcode)
2173                       code.emitop0(int2byte + od.typecode - BYTEcode);
2174                     result = items.makeAssignItem(od);
2175                 }
2176                 break;
2177             case POSTINC: case POSTDEC:
2178                 od.duplicate();
2179                 if (od instanceof LocalItem &amp;&amp;
2180                     (operator.opcode == iadd || operator.opcode == isub)) {
2181                     Item res = od.load();
2182                     ((LocalItem)od).incr(tree.hasTag(POSTINC) ? 1 : -1);
2183                     result = res;
2184                 } else {
2185                     Item res = od.load();
2186                     od.stash(od.typecode);
2187                     code.emitop0(one(od.typecode));
2188                     code.emitop0(operator.opcode);
2189                     // Perform narrowing primitive conversion if byte,
2190                     // char, or short.  Fix for 4304655.
2191                     if (od.typecode != INTcode &amp;&amp;
2192                         Code.truncate(od.typecode) == INTcode)
2193                       code.emitop0(int2byte + od.typecode - BYTEcode);
2194                     od.store();
2195                     result = res;
2196                 }
2197                 break;
2198             case NULLCHK:
2199                 result = od.load();
2200                 code.emitop0(dup);
2201                 genNullCheck(tree);
2202                 break;
2203             default:
2204                 Assert.error();
2205             }
2206         }
2207     }
2208 
2209     /** Generate a null check from the object value at stack top. */
2210     private void genNullCheck(JCTree tree) {
2211         code.statBegin(tree.pos);
2212         callMethod(tree.pos(), syms.objectsType, names.requireNonNull,
2213                    List.of(syms.objectType), true);
2214         code.emitop0(pop);
2215     }
2216 
2217     public void visitBinary(JCBinary tree) {
2218         OperatorSymbol operator = tree.operator;
2219         if (operator.opcode == string_add) {
2220             result = concat.makeConcat(tree);
2221         } else if (tree.hasTag(AND)) {
2222             CondItem lcond = genCond(tree.lhs, CRT_FLOW_CONTROLLER);
2223             if (!lcond.isFalse()) {
2224                 Chain falseJumps = lcond.jumpFalse();
2225                 code.resolve(lcond.trueJumps);
2226                 CondItem rcond = genCond(tree.rhs, CRT_FLOW_TARGET);
2227                 result = items.
2228                     makeCondItem(rcond.opcode,
2229                                  rcond.trueJumps,
2230                                  Code.mergeChains(falseJumps,
2231                                                   rcond.falseJumps));
2232             } else {
2233                 result = lcond;
2234             }
2235         } else if (tree.hasTag(OR)) {
2236             CondItem lcond = genCond(tree.lhs, CRT_FLOW_CONTROLLER);
2237             if (!lcond.isTrue()) {
2238                 Chain trueJumps = lcond.jumpTrue();
2239                 code.resolve(lcond.falseJumps);
2240                 CondItem rcond = genCond(tree.rhs, CRT_FLOW_TARGET);
2241                 result = items.
2242                     makeCondItem(rcond.opcode,
2243                                  Code.mergeChains(trueJumps, rcond.trueJumps),
2244                                  rcond.falseJumps);
2245             } else {
2246                 result = lcond;
2247             }
2248         } else {
2249             Item od = genExpr(tree.lhs, operator.type.getParameterTypes().head);
2250             od.load();
2251             result = completeBinop(tree.lhs, tree.rhs, operator);
2252         }
2253     }
2254 
2255 
2256         /** Complete generating code for operation, with left operand
2257          *  already on stack.
2258          *  @param lhs       The tree representing the left operand.
2259          *  @param rhs       The tree representing the right operand.
2260          *  @param operator  The operator symbol.
2261          */
2262         Item completeBinop(JCTree lhs, JCTree rhs, OperatorSymbol operator) {
2263             MethodType optype = (MethodType)operator.type;
2264             int opcode = operator.opcode;
2265             if (opcode &gt;= if_icmpeq &amp;&amp; opcode &lt;= if_icmple &amp;&amp;
2266                 rhs.type.constValue() instanceof Number &amp;&amp;
2267                 ((Number) rhs.type.constValue()).intValue() == 0) {
2268                 opcode = opcode + (ifeq - if_icmpeq);
2269             } else if (opcode &gt;= if_acmpeq &amp;&amp; opcode &lt;= if_acmpne &amp;&amp;
2270                        TreeInfo.isNull(rhs)) {
2271                 opcode = opcode + (if_acmp_null - if_acmpeq);
2272             } else {
2273                 // The expected type of the right operand is
2274                 // the second parameter type of the operator, except for
2275                 // shifts with long shiftcount, where we convert the opcode
2276                 // to a short shift and the expected type to int.
2277                 Type rtype = operator.erasure(types).getParameterTypes().tail.head;
2278                 if (opcode &gt;= ishll &amp;&amp; opcode &lt;= lushrl) {
2279                     opcode = opcode + (ishl - ishll);
2280                     rtype = syms.intType;
2281                 }
2282                 // Generate code for right operand and load.
2283                 genExpr(rhs, rtype).load();
2284                 // If there are two consecutive opcode instructions,
2285                 // emit the first now.
2286                 if (opcode &gt;= (1 &lt;&lt; preShift)) {
2287                     code.emitop0(opcode &gt;&gt; preShift);
2288                     opcode = opcode &amp; 0xFF;
2289                 }
2290             }
2291             if (opcode &gt;= ifeq &amp;&amp; opcode &lt;= if_acmpne ||
2292                 opcode == if_acmp_null || opcode == if_acmp_nonnull) {
2293                 return items.makeCondItem(opcode);
2294             } else {
2295                 code.emitop0(opcode);
2296                 return items.makeStackItem(optype.restype);
2297             }
2298         }
2299 
2300     public void visitTypeCast(JCTypeCast tree) {
2301         result = genExpr(tree.expr, tree.clazz.type).load();
2302         setTypeAnnotationPositions(tree.pos);
2303         // Additional code is only needed if we cast to a reference type
2304         // which is not statically a supertype of the expression&#39;s type.
2305         // For basic types, the coerce(...) in genExpr(...) will do
2306         // the conversion.
2307         // inline widening conversion is a nop, as the VM sees a subtyping relationship.
2308         if (!tree.clazz.type.isPrimitive() &amp;&amp;
2309            !types.isSameType(tree.expr.type, tree.clazz.type) &amp;&amp;
2310             (!tree.clazz.type.tsym.isReferenceProjection() || tree.clazz.type.tsym.valueProjection() != tree.expr.type.tsym) &amp;&amp;
2311            types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
2312             checkDimension(tree.pos(), tree.clazz.type);
2313             if (types.isValue(tree.clazz.type)) {
2314                 code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);
2315             } else {
2316                 code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);
2317             }
2318 
2319         }
2320     }
2321 
2322     public void visitWildcard(JCWildcard tree) {
2323         throw new AssertionError(this.getClass().getName());
2324     }
2325 
2326     public void visitTypeTest(JCInstanceOf tree) {
2327         genExpr(tree.expr, tree.expr.type).load();
2328         setTypeAnnotationPositions(tree.pos);
2329         code.emitop2(instanceof_, makeRef(tree.pos(), tree.pattern.type));
2330         result = items.makeStackItem(syms.booleanType);
2331     }
2332 
2333     public void visitIndexed(JCArrayAccess tree) {
2334         genExpr(tree.indexed, tree.indexed.type).load();
2335         genExpr(tree.index, syms.intType).load();
2336         result = items.makeIndexedItem(tree.type);
2337     }
2338 
2339     public void visitIdent(JCIdent tree) {
2340         Symbol sym = tree.sym;
2341         if (tree.name == names._this || tree.name == names._super) {
2342             Item res = tree.name == names._this
2343                 ? items.makeThisItem()
2344                 : items.makeSuperItem();
2345             if (sym.kind == MTH) {
2346                 // Generate code to address the constructor.
2347                 res.load();
2348                 res = items.makeMemberItem(sym, true);
2349             }
2350             result = res;
2351        } else if (isInvokeDynamic(sym) || isConstantDynamic(sym)) {
2352             if (isConstantDynamic(sym)) {
2353                 setTypeAnnotationPositions(tree.pos);
2354             }
2355             result = items.makeDynamicItem(sym);
2356         } else if (sym.kind == VAR &amp;&amp; (sym.owner.kind == MTH || sym.owner.kind == VAR)) {
2357             result = items.makeLocalItem((VarSymbol)sym);
2358         } else if ((sym.flags() &amp; STATIC) != 0) {
2359             if (!isAccessSuper(env.enclMethod))
2360                 sym = binaryQualifier(sym, env.enclClass.type);
2361             result = items.makeStaticItem(sym);
2362         } else {
2363             items.makeThisItem().load();
2364             sym = binaryQualifier(sym, env.enclClass.type);
2365             result = items.makeMemberItem(sym, nonVirtualForPrivateAccess(sym));
2366         }
2367     }
2368 
2369     //where
2370     private boolean nonVirtualForPrivateAccess(Symbol sym) {
2371         boolean useVirtual = target.hasVirtualPrivateInvoke() &amp;&amp;
2372                              !disableVirtualizedPrivateInvoke;
2373         return !useVirtual &amp;&amp; ((sym.flags() &amp; PRIVATE) != 0);
2374     }
2375 
2376     public void visitSelect(JCFieldAccess tree) {
2377         Symbol sym = tree.sym;
2378 
2379         if (tree.name == names._class) {
2380             code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));
2381             result = items.makeStackItem(pt);
2382             return;
2383         } else if (tree.name == names._default) {
2384             if (tree.type.asElement().isValue()) {
2385                 code.emitop2(defaultvalue, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);
2386             } else if (tree.type.isReference()) {
2387                 code.emitop0(aconst_null);
2388             } else {
2389                 code.emitop0(zero(Code.typecode(tree.type)));
2390             }
2391             result = items.makeStackItem(tree.type);
2392             return;
2393         }
2394 
2395         Symbol ssym = TreeInfo.symbol(tree.selected);
2396 
2397         // Are we selecting via super?
2398         boolean selectSuper =
2399             ssym != null &amp;&amp; (ssym.kind == TYP || ssym.name == names._super);
2400 
2401         // Are we accessing a member of the superclass in an access method
2402         // resulting from a qualified super?
2403         boolean accessSuper = isAccessSuper(env.enclMethod);
2404 
2405         Item base = (selectSuper)
2406             ? items.makeSuperItem()
2407             : genExpr(tree.selected, tree.selected.type);
2408 
2409         if (sym.kind == VAR &amp;&amp; ((VarSymbol) sym).getConstValue() != null) {
2410             // We are seeing a variable that is constant but its selecting
2411             // expression is not.
2412             if ((sym.flags() &amp; STATIC) != 0) {
2413                 if (!selectSuper &amp;&amp; (ssym == null || ssym.kind != TYP))
2414                     base = base.load();
2415                 base.drop();
2416             } else {
2417                 base.load();
2418                 genNullCheck(tree.selected);
2419             }
2420             result = items.
2421                 makeImmediateItem(sym.type, ((VarSymbol) sym).getConstValue());
2422         } else {
2423             if (isInvokeDynamic(sym)) {
2424                 result = items.makeDynamicItem(sym);
2425                 return;
2426             } else {
2427                 sym = binaryQualifier(sym, tree.selected.type);
2428             }
2429             if ((sym.flags() &amp; STATIC) != 0) {
2430                 if (!selectSuper &amp;&amp; (ssym == null || ssym.kind != TYP))
2431                     base = base.load();
2432                 base.drop();
2433                 result = items.makeStaticItem(sym);
2434             } else {
2435                 base.load();
2436                 if (sym == syms.lengthVar) {
2437                     code.emitop0(arraylength);
2438                     result = items.makeStackItem(syms.intType);
2439                 } else {
2440                     result = items.
2441                         makeMemberItem(sym,
2442                                        nonVirtualForPrivateAccess(sym) ||
2443                                        selectSuper || accessSuper);
2444                 }
2445             }
2446         }
2447     }
2448 
2449     public boolean isInvokeDynamic(Symbol sym) {
2450         return sym.kind == MTH &amp;&amp; ((MethodSymbol)sym).isDynamic();
2451     }
2452 
2453     public void visitLiteral(JCLiteral tree) {
2454         if (tree.type.hasTag(BOT)) {
2455             code.emitop0(aconst_null);
2456             result = items.makeStackItem(tree.type);
2457         }
2458         else
2459             result = items.makeImmediateItem(tree.type, tree.value);
2460     }
2461 
2462     public void visitLetExpr(LetExpr tree) {
2463         code.resolvePending();
2464 
2465         int limit = code.nextreg;
2466         int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
2467         try {
2468             genStats(tree.defs, env);
2469         } finally {
2470             code.setLetExprStackPos(prevLetExprStart);
2471         }
2472         result = genExpr(tree.expr, tree.expr.type).load();
2473         code.endScopes(limit);
2474     }
2475 
2476     private void generateReferencesToPrunedTree(ClassSymbol classSymbol) {
2477         List&lt;JCTree&gt; prunedInfo = lower.prunedTree.get(classSymbol);
2478         if (prunedInfo != null) {
2479             for (JCTree prunedTree: prunedInfo) {
2480                 prunedTree.accept(classReferenceVisitor);
2481             }
2482         }
2483     }
2484 
2485 /* ************************************************************************
2486  * main method
2487  *************************************************************************/
2488 
2489     /** Generate code for a class definition.
2490      *  @param env   The attribution environment that belongs to the
2491      *               outermost class containing this class definition.
2492      *               We need this for resolving some additional symbols.
2493      *  @param cdef  The tree representing the class definition.
2494      *  @return      True if code is generated with no errors.
2495      */
2496     public boolean genClass(Env&lt;AttrContext&gt; env, JCClassDecl cdef) {
2497         try {
2498             attrEnv = env;
2499             ClassSymbol c = cdef.sym;
2500             this.toplevel = env.toplevel;
2501             this.endPosTable = toplevel.endPositions;
2502             /* method normalizeDefs() can add references to external classes into the constant pool
2503              */
2504             cdef.defs = normalizeDefs(cdef.defs, c);
2505             cdef = transValues.translateTopLevelClass(cdef, make);
2506             generateReferencesToPrunedTree(c);
2507             Env&lt;GenContext&gt; localEnv = new Env&lt;&gt;(cdef, new GenContext());
2508             localEnv.toplevel = env.toplevel;
2509             localEnv.enclClass = cdef;
2510 
2511             for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2512                 genDef(l.head, localEnv);
2513             }
2514             if (poolWriter.size() &gt; PoolWriter.MAX_ENTRIES) {
2515                 log.error(cdef.pos(), Errors.LimitPool);
2516                 nerrs++;
2517             }
2518             if (nerrs != 0) {
2519                 // if errors, discard code
2520                 for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2521                     if (l.head.hasTag(METHODDEF))
2522                         ((JCMethodDecl) l.head).sym.code = null;
2523                 }
2524             }
2525             cdef.defs = List.nil(); // discard trees
2526             return nerrs == 0;
2527         } finally {
2528             // note: this method does NOT support recursion.
2529             attrEnv = null;
2530             this.env = null;
2531             toplevel = null;
2532             endPosTable = null;
2533             nerrs = 0;
2534         }
2535     }
2536 
2537 /* ************************************************************************
2538  * Auxiliary classes
2539  *************************************************************************/
2540 
2541     /** An abstract class for finalizer generation.
2542      */
2543     abstract class GenFinalizer {
2544         /** Generate code to clean up when unwinding. */
2545         abstract void gen();
2546 
2547         /** Generate code to clean up at last. */
2548         abstract void genLast();
2549 
2550         /** Does this finalizer have some nontrivial cleanup to perform? */
2551         boolean hasFinalizer() { return true; }
2552 
2553         /** Should be invoked after the try&#39;s body has been visited. */
2554         void afterBody() {}
2555     }
2556 
2557     /** code generation contexts,
2558      *  to be used as type parameter for environments.
2559      */
2560     static class GenContext {
2561 
2562         /** A chain for all unresolved jumps that exit the current environment.
2563          */
2564         Chain exit = null;
2565 
2566         /** A chain for all unresolved jumps that continue in the
2567          *  current environment.
2568          */
2569         Chain cont = null;
2570 
2571         /** A closure that generates the finalizer of the current environment.
2572          *  Only set for Synchronized and Try contexts.
2573          */
2574         GenFinalizer finalize = null;
2575 
2576         /** Is this a switch statement?  If so, allocate registers
2577          * even when the variable declaration is unreachable.
2578          */
2579         boolean isSwitch = false;
2580 
2581         /** A list buffer containing all gaps in the finalizer range,
2582          *  where a catch all exception should not apply.
2583          */
2584         ListBuffer&lt;Integer&gt; gaps = null;
2585 
2586         /** Add given chain to exit chain.
2587          */
2588         void addExit(Chain c)  {
2589             exit = Code.mergeChains(c, exit);
2590         }
2591 
2592         /** Add given chain to cont chain.
2593          */
2594         void addCont(Chain c) {
2595             cont = Code.mergeChains(c, cont);
2596         }
2597     }
2598 
2599 }
    </pre>
  </body>
</html>