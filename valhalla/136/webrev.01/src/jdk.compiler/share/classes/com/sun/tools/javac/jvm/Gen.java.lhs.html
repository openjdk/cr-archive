<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import com.sun.tools.javac.code.Types.UniqueType;
  29 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
  30 import com.sun.tools.javac.tree.TreeInfo.PosKind;
  31 import com.sun.tools.javac.util.*;
  32 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  33 import com.sun.tools.javac.util.List;
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.TypeCompound;
  36 import com.sun.tools.javac.code.Symbol.VarSymbol;
  37 import com.sun.tools.javac.comp.*;
  38 import com.sun.tools.javac.tree.*;
  39 
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.code.Type.*;
  42 import com.sun.tools.javac.jvm.Code.*;
  43 import com.sun.tools.javac.jvm.Items.*;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.tree.EndPosTable;
  46 import com.sun.tools.javac.tree.JCTree.*;
  47 
  48 import static com.sun.tools.javac.code.Flags.*;
  49 import static com.sun.tools.javac.code.Kinds.Kind.*;
  50 import static com.sun.tools.javac.code.TypeTag.*;
  51 import static com.sun.tools.javac.jvm.ByteCodes.*;
  52 import static com.sun.tools.javac.jvm.CRTFlags.*;
  53 import static com.sun.tools.javac.main.Option.*;
  54 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  55 
  56 /** This pass maps flat Java (i.e. without inner classes) to bytecodes.
  57  *
  58  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  59  *  If you write code that depends on this, you do so at your own risk.
  60  *  This code and its internal interfaces are subject to change or
  61  *  deletion without notice.&lt;/b&gt;
  62  */
  63 public class Gen extends JCTree.Visitor {
  64     private static final Object[] NO_STATIC_ARGS = new Object[0];
  65     protected static final Context.Key&lt;Gen&gt; genKey = new Context.Key&lt;&gt;();
  66 
  67     private final Log log;
  68     private final Symtab syms;
  69     private final Check chk;
  70     private final Resolve rs;
  71     private final TreeMaker make;
  72     private final Names names;
  73     private final Target target;
  74     private final Name accessDollar;
  75     private final Types types;
  76     private final Lower lower;
  77     private final Annotate annotate;
  78     private final StringConcat concat;
  79     private final TransValues transValues;
  80 
  81     /** Format of stackmap tables to be generated. */
  82     private final Code.StackMapFormat stackMap;
  83 
  84     /** A type that serves as the expected type for all method expressions.
  85      */
  86     private final Type methodType;
  87 
  88     public static Gen instance(Context context) {
  89         Gen instance = context.get(genKey);
  90         if (instance == null)
  91             instance = new Gen(context);
  92         return instance;
  93     }
  94 
  95     /** Constant pool writer, set by genClass.
  96      */
  97     final PoolWriter poolWriter;
  98 
  99     protected Gen(Context context) {
 100         context.put(genKey, this);
 101 
 102         names = Names.instance(context);
 103         log = Log.instance(context);
 104         syms = Symtab.instance(context);
 105         chk = Check.instance(context);
 106         rs = Resolve.instance(context);
 107         make = TreeMaker.instance(context);
 108         target = Target.instance(context);
 109         types = Types.instance(context);
 110         concat = StringConcat.instance(context);
 111 
 112         methodType = new MethodType(null, null, null, syms.methodClass);
 113         accessDollar = names.
 114             fromString(&quot;access&quot; + target.syntheticNameChar());
 115         lower = Lower.instance(context);
 116         transValues = TransValues.instance(context);
 117 
 118         Options options = Options.instance(context);
 119         lineDebugInfo =
 120             options.isUnset(G_CUSTOM) ||
 121             options.isSet(G_CUSTOM, &quot;lines&quot;);
 122         varDebugInfo =
 123             options.isUnset(G_CUSTOM)
 124             ? options.isSet(G)
 125             : options.isSet(G_CUSTOM, &quot;vars&quot;);
 126         genCrt = options.isSet(XJCOV);
 127         debugCode = options.isSet(&quot;debug.code&quot;);
 128         disableVirtualizedPrivateInvoke = options.isSet(&quot;disableVirtualizedPrivateInvoke&quot;);
 129         poolWriter = new PoolWriter(types, names);
 130 
 131         // ignore cldc because we cannot have both stackmap formats
 132         this.stackMap = StackMapFormat.JSR202;
 133         annotate = Annotate.instance(context);
 134     }
 135 
 136     /** Switches
 137      */
 138     private final boolean lineDebugInfo;
 139     private final boolean varDebugInfo;
 140     private final boolean genCrt;
 141     private final boolean debugCode;
 142     private boolean disableVirtualizedPrivateInvoke;
 143 
 144     /** Code buffer, set by genMethod.
 145      */
 146     private Code code;
 147 
 148     /** Items structure, set by genMethod.
 149      */
 150     private Items items;
 151 
 152     /** Environment for symbol lookup, set by genClass
 153      */
 154     private Env&lt;AttrContext&gt; attrEnv;
 155 
 156     /** The top level tree.
 157      */
 158     private JCCompilationUnit toplevel;
 159 
 160     /** The number of code-gen errors in this class.
 161      */
 162     private int nerrs = 0;
 163 
 164     /** An object containing mappings of syntax trees to their
 165      *  ending source positions.
 166      */
 167     EndPosTable endPosTable;
 168 
 169     boolean inCondSwitchExpression;
 170     Chain switchExpressionTrueChain;
 171     Chain switchExpressionFalseChain;
 172     List&lt;LocalItem&gt; stackBeforeSwitchExpression;
 173     LocalItem switchResult;
 174 
 175     /** Generate code to load an integer constant.
 176      *  @param n     The integer to be loaded.
 177      */
 178     void loadIntConst(int n) {
 179         items.makeImmediateItem(syms.intType, n).load();
 180     }
 181 
 182     /** The opcode that loads a zero constant of a given type code.
 183      *  @param tc   The given type code (@see ByteCode).
 184      */
 185     public static int zero(int tc) {
 186         switch(tc) {
 187         case INTcode: case BYTEcode: case SHORTcode: case CHARcode:
 188             return iconst_0;
 189         case LONGcode:
 190             return lconst_0;
 191         case FLOATcode:
 192             return fconst_0;
 193         case DOUBLEcode:
 194             return dconst_0;
 195         default:
 196             throw new AssertionError(&quot;zero&quot;);
 197         }
 198     }
 199 
 200     /** The opcode that loads a one constant of a given type code.
 201      *  @param tc   The given type code (@see ByteCode).
 202      */
 203     public static int one(int tc) {
 204         return zero(tc) + 1;
 205     }
 206 
 207     /** Generate code to load -1 of the given type code (either int or long).
 208      *  @param tc   The given type code (@see ByteCode).
 209      */
 210     void emitMinusOne(int tc) {
 211         if (tc == LONGcode) {
 212             items.makeImmediateItem(syms.longType, Long.valueOf(-1)).load();
 213         } else {
 214             code.emitop0(iconst_m1);
 215         }
 216     }
 217 
 218     /** Construct a symbol to reflect the qualifying type that should
 219      *  appear in the byte code as per JLS 13.1.
 220      *
 221      *  For {@literal target &gt;= 1.2}: Clone a method with the qualifier as owner (except
 222      *  for those cases where we need to work around VM bugs).
 223      *
 224      *  For {@literal target &lt;= 1.1}: If qualified variable or method is defined in a
 225      *  non-accessible class, clone it with the qualifier class as owner.
 226      *
 227      *  @param sym    The accessed symbol
 228      *  @param site   The qualifier&#39;s type.
 229      */
 230     Symbol binaryQualifier(Symbol sym, Type site) {
 231 
 232         if (site.hasTag(ARRAY)) {
 233             if (sym == syms.lengthVar ||
 234                 sym.owner != syms.arrayClass)
 235                 return sym;
 236             // array clone can be qualified by the array type in later targets
 237             Symbol qualifier = new ClassSymbol(Flags.PUBLIC, site.tsym.name,
 238                                                site, syms.noSymbol);
 239             return sym.clone(qualifier);
 240         }
 241 
 242         if (sym.owner == site.tsym ||
 243             (sym.flags() &amp; (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {
 244             return sym;
 245         }
 246 
 247         // leave alone methods inherited from Object
 248         // JLS 13.1.
 249         if (sym.owner == syms.objectType.tsym)
 250             return sym;
 251 
 252         return sym.clone(site.tsym);
 253     }
 254 
 255     /** Insert a reference to given type in the constant pool,
 256      *  checking for an array with too many dimensions;
 257      *  return the reference&#39;s index.
 258      *  @param type   The type for which a reference is inserted.
 259      */
 260     int makeRef(DiagnosticPosition pos, Type type, boolean emitQtype) {
 261         checkDimension(pos, type);
 262         if (emitQtype) {
 263             return poolWriter.putClass(new ConstantPoolQType(type, types));
 264         } else {
 265             return poolWriter.putClass(type);
 266         }
 267     }
 268 
 269     /** Insert a reference to given type in the constant pool,
 270      *  checking for an array with too many dimensions;
 271      *  return the reference&#39;s index.
 272      *  @param type   The type for which a reference is inserted.
 273      */
 274     int makeRef(DiagnosticPosition pos, Type type) {
 275         return makeRef(pos, type, false);
 276     }
 277 
 278     /** Check if the given type is an array with too many dimensions.
 279      */
 280     private Type checkDimension(DiagnosticPosition pos, Type t) {
 281         checkDimensionInternal(pos, t);
 282         return t;
 283     }
 284 
 285     private void checkDimensionInternal(DiagnosticPosition pos, Type t) {
 286         switch (t.getTag()) {
 287         case METHOD:
 288             checkDimension(pos, t.getReturnType());
 289             for (List&lt;Type&gt; args = t.getParameterTypes(); args.nonEmpty(); args = args.tail)
 290                 checkDimension(pos, args.head);
 291             break;
 292         case ARRAY:
 293             if (types.dimensions(t) &gt; ClassFile.MAX_DIMENSIONS) {
 294                 log.error(pos, Errors.LimitDimensions);
 295                 nerrs++;
 296             }
 297             break;
 298         default:
 299             break;
 300         }
 301     }
 302 
 303     /** Create a temporary variable.
 304      *  @param type   The variable&#39;s type.
 305      */
 306     LocalItem makeTemp(Type type) {
 307         VarSymbol v = new VarSymbol(Flags.SYNTHETIC,
 308                                     names.empty,
 309                                     type,
 310                                     env.enclMethod.sym);
 311         code.newLocal(v);
 312         return items.makeLocalItem(v);
 313     }
 314 
 315     /** Generate code to call a non-private method or constructor.
 316      *  @param pos         Position to be used for error reporting.
 317      *  @param site        The type of which the method is a member.
 318      *  @param name        The method&#39;s name.
 319      *  @param argtypes    The method&#39;s argument types.
 320      *  @param isStatic    A flag that indicates whether we call a
 321      *                     static or instance method.
 322      */
 323     void callMethod(DiagnosticPosition pos,
 324                     Type site, Name name, List&lt;Type&gt; argtypes,
 325                     boolean isStatic) {
 326         Symbol msym = rs.
 327             resolveInternalMethod(pos, attrEnv, site, name, argtypes, null);
 328         if (isStatic) items.makeStaticItem(msym).invoke();
 329         else items.makeMemberItem(msym, name == names.init).invoke();
 330     }
 331 
 332     /** Is the given method definition an access method
 333      *  resulting from a qualified super? This is signified by an odd
 334      *  access code.
 335      */
 336     private boolean isAccessSuper(JCMethodDecl enclMethod) {
 337         return
 338             (enclMethod.mods.flags &amp; SYNTHETIC) != 0 &amp;&amp;
 339             isOddAccessName(enclMethod.name);
 340     }
 341 
 342     /** Does given name start with &quot;access$&quot; and end in an odd digit?
 343      */
 344     private boolean isOddAccessName(Name name) {
 345         return
 346             name.startsWith(accessDollar) &amp;&amp;
 347             (name.getByteAt(name.getByteLength() - 1) &amp; 1) == 1;
 348     }
 349 
 350 /* ************************************************************************
 351  * Non-local exits
 352  *************************************************************************/
 353 
 354     /** Generate code to invoke the finalizer associated with given
 355      *  environment.
 356      *  Any calls to finalizers are appended to the environments `cont&#39; chain.
 357      *  Mark beginning of gap in catch all range for finalizer.
 358      */
 359     void genFinalizer(Env&lt;GenContext&gt; env) {
 360         if (code.isAlive() &amp;&amp; env.info.finalize != null)
 361             env.info.finalize.gen();
 362     }
 363 
 364     /** Generate code to call all finalizers of structures aborted by
 365      *  a non-local
 366      *  exit.  Return target environment of the non-local exit.
 367      *  @param target      The tree representing the structure that&#39;s aborted
 368      *  @param env         The environment current at the non-local exit.
 369      */
 370     Env&lt;GenContext&gt; unwind(JCTree target, Env&lt;GenContext&gt; env) {
 371         Env&lt;GenContext&gt; env1 = env;
 372         while (true) {
 373             genFinalizer(env1);
 374             if (env1.tree == target) break;
 375             env1 = env1.next;
 376         }
 377         return env1;
 378     }
 379 
 380     /** Mark end of gap in catch-all range for finalizer.
 381      *  @param env   the environment which might contain the finalizer
 382      *               (if it does, env.info.gaps != null).
 383      */
 384     void endFinalizerGap(Env&lt;GenContext&gt; env) {
 385         if (env.info.gaps != null &amp;&amp; env.info.gaps.length() % 2 == 1)
 386             env.info.gaps.append(code.curCP());
 387     }
 388 
 389     /** Mark end of all gaps in catch-all ranges for finalizers of environments
 390      *  lying between, and including to two environments.
 391      *  @param from    the most deeply nested environment to mark
 392      *  @param to      the least deeply nested environment to mark
 393      */
 394     void endFinalizerGaps(Env&lt;GenContext&gt; from, Env&lt;GenContext&gt; to) {
 395         Env&lt;GenContext&gt; last = null;
 396         while (last != to) {
 397             endFinalizerGap(from);
 398             last = from;
 399             from = from.next;
 400         }
 401     }
 402 
 403     /** Do any of the structures aborted by a non-local exit have
 404      *  finalizers that require an empty stack?
 405      *  @param target      The tree representing the structure that&#39;s aborted
 406      *  @param env         The environment current at the non-local exit.
 407      */
 408     boolean hasFinally(JCTree target, Env&lt;GenContext&gt; env) {
 409         while (env.tree != target) {
 410             if (env.tree.hasTag(TRY) &amp;&amp; env.info.finalize.hasFinalizer())
 411                 return true;
 412             env = env.next;
 413         }
 414         return false;
 415     }
 416 
 417 /* ************************************************************************
 418  * Normalizing class-members.
 419  *************************************************************************/
 420 
 421     /** Distribute member initializer code into constructors and {@code &lt;clinit&gt;}
 422      *  method.
 423      *  @param defs         The list of class member declarations.
 424      *  @param c            The enclosing class.
 425      */
 426     List&lt;JCTree&gt; normalizeDefs(List&lt;JCTree&gt; defs, ClassSymbol c) {
 427         ListBuffer&lt;JCStatement&gt; initCode = new ListBuffer&lt;&gt;();
 428         ListBuffer&lt;Attribute.TypeCompound&gt; initTAs = new ListBuffer&lt;&gt;();
 429         ListBuffer&lt;JCStatement&gt; clinitCode = new ListBuffer&lt;&gt;();
 430         ListBuffer&lt;Attribute.TypeCompound&gt; clinitTAs = new ListBuffer&lt;&gt;();
 431         ListBuffer&lt;JCTree&gt; methodDefs = new ListBuffer&lt;&gt;();
 432         // Sort definitions into three listbuffers:
 433         //  - initCode for instance initializers
 434         //  - clinitCode for class initializers
 435         //  - methodDefs for method definitions
 436         for (List&lt;JCTree&gt; l = defs; l.nonEmpty(); l = l.tail) {
 437             JCTree def = l.head;
 438             switch (def.getTag()) {
 439             case BLOCK:
 440                 JCBlock block = (JCBlock)def;
 441                 if ((block.flags &amp; STATIC) != 0)
 442                     clinitCode.append(block);
 443                 else if ((block.flags &amp; SYNTHETIC) == 0)
 444                     initCode.append(block);
 445                 break;
 446             case METHODDEF:
 447                 methodDefs.append(def);
 448                 break;
 449             case VARDEF:
 450                 JCVariableDecl vdef = (JCVariableDecl) def;
 451                 VarSymbol sym = vdef.sym;
 452                 checkDimension(vdef.pos(), sym.type);
 453                 if (vdef.init != null) {
 454                     if ((sym.flags() &amp; STATIC) == 0) {
 455                         // Always initialize instance variables.
 456                         JCStatement init = make.at(vdef.pos()).
 457                             Assignment(sym, vdef.init);
 458                         initCode.append(init);
 459                         endPosTable.replaceTree(vdef, init);
 460                         initTAs.addAll(getAndRemoveNonFieldTAs(sym));
 461                     } else if (sym.getConstValue() == null) {
 462                         // Initialize class (static) variables only if
 463                         // they are not compile-time constants.
 464                         JCStatement init = make.at(vdef.pos).
 465                             Assignment(sym, vdef.init);
 466                         clinitCode.append(init);
 467                         endPosTable.replaceTree(vdef, init);
 468                         clinitTAs.addAll(getAndRemoveNonFieldTAs(sym));
 469                     } else {
 470                         checkStringConstant(vdef.init.pos(), sym.getConstValue());
 471                         /* if the init contains a reference to an external class, add it to the
 472                          * constant&#39;s pool
 473                          */
 474                         vdef.init.accept(classReferenceVisitor);
 475                     }
 476                 }
 477                 break;
 478             default:
 479                 Assert.error();
 480             }
 481         }
 482         // Insert any instance initializers into all constructors.
 483         if (initCode.length() != 0) {
 484             List&lt;JCStatement&gt; inits = initCode.toList();
 485             initTAs.addAll(c.getInitTypeAttributes());
 486             List&lt;Attribute.TypeCompound&gt; initTAlist = initTAs.toList();
 487             for (JCTree t : methodDefs) {
 488                 normalizeMethod((JCMethodDecl)t, inits, initTAlist);
 489             }
 490         }
 491         // If there are class initializers, create a &lt;clinit&gt; method
 492         // that contains them as its body.
 493         if (clinitCode.length() != 0) {
 494             MethodSymbol clinit = new MethodSymbol(
 495                 STATIC | (c.flags() &amp; STRICTFP),
 496                 names.clinit,
 497                 new MethodType(
 498                     List.nil(), syms.voidType,
 499                     List.nil(), syms.methodClass),
 500                 c);
 501             c.members().enter(clinit);
 502             List&lt;JCStatement&gt; clinitStats = clinitCode.toList();
 503             JCBlock block = make.at(clinitStats.head.pos()).Block(0, clinitStats);
 504             block.endpos = TreeInfo.endPos(clinitStats.last());
 505             methodDefs.append(make.MethodDef(clinit, block));
 506 
 507             if (!clinitTAs.isEmpty())
 508                 clinit.appendUniqueTypeAttributes(clinitTAs.toList());
 509             if (!c.getClassInitTypeAttributes().isEmpty())
 510                 clinit.appendUniqueTypeAttributes(c.getClassInitTypeAttributes());
 511         }
 512         // Return all method definitions.
 513         return methodDefs.toList();
 514     }
 515 
 516     private List&lt;Attribute.TypeCompound&gt; getAndRemoveNonFieldTAs(VarSymbol sym) {
 517         List&lt;TypeCompound&gt; tas = sym.getRawTypeAttributes();
 518         ListBuffer&lt;Attribute.TypeCompound&gt; fieldTAs = new ListBuffer&lt;&gt;();
 519         ListBuffer&lt;Attribute.TypeCompound&gt; nonfieldTAs = new ListBuffer&lt;&gt;();
 520         for (TypeCompound ta : tas) {
 521             Assert.check(ta.getPosition().type != TargetType.UNKNOWN);
 522             if (ta.getPosition().type == TargetType.FIELD) {
 523                 fieldTAs.add(ta);
 524             } else {
 525                 nonfieldTAs.add(ta);
 526             }
 527         }
 528         sym.setTypeAttributes(fieldTAs.toList());
 529         return nonfieldTAs.toList();
 530     }
 531 
 532     /** Check a constant value and report if it is a string that is
 533      *  too large.
 534      */
 535     private void checkStringConstant(DiagnosticPosition pos, Object constValue) {
 536         if (nerrs != 0 || // only complain about a long string once
 537             constValue == null ||
 538             !(constValue instanceof String) ||
 539             ((String)constValue).length() &lt; PoolWriter.MAX_STRING_LENGTH)
 540             return;
 541         log.error(pos, Errors.LimitString);
 542         nerrs++;
 543     }
 544 
 545     /** Insert instance initializer code into initial constructor.
 546      *  @param md        The tree potentially representing a
 547      *                   constructor&#39;s definition.
 548      *  @param initCode  The list of instance initializer statements.
 549      *  @param initTAs  Type annotations from the initializer expression.
 550      */
 551     void normalizeMethod(JCMethodDecl md, List&lt;JCStatement&gt; initCode, List&lt;TypeCompound&gt; initTAs) {
 552         if (md.name == names.init &amp;&amp; TreeInfo.isInitialConstructor(md)) {
 553             // We are seeing a constructor that does not call another
 554             // constructor of the same class.
 555             List&lt;JCStatement&gt; stats = md.body.stats;
 556             ListBuffer&lt;JCStatement&gt; newstats = new ListBuffer&lt;&gt;();
 557 
 558             if (stats.nonEmpty()) {
 559                 // Copy initializers of synthetic variables generated in
 560                 // the translation of inner classes.
 561                 while (TreeInfo.isSyntheticInit(stats.head)) {
 562                     newstats.append(stats.head);
 563                     stats = stats.tail;
 564                 }
 565                 // Copy superclass constructor call
 566                 newstats.append(stats.head);
 567                 stats = stats.tail;
 568                 // Copy remaining synthetic initializers.
 569                 while (stats.nonEmpty() &amp;&amp;
 570                        TreeInfo.isSyntheticInit(stats.head)) {
 571                     newstats.append(stats.head);
 572                     stats = stats.tail;
 573                 }
 574                 // Now insert the initializer code.
 575                 newstats.appendList(initCode);
 576                 // And copy all remaining statements.
 577                 while (stats.nonEmpty()) {
 578                     newstats.append(stats.head);
 579                     stats = stats.tail;
 580                 }
 581             }
 582             md.body.stats = newstats.toList();
 583             if (md.body.endpos == Position.NOPOS)
 584                 md.body.endpos = TreeInfo.endPos(md.body.stats.last());
 585 
 586             md.sym.appendUniqueTypeAttributes(initTAs);
 587         }
 588     }
 589 
 590 /* ************************************************************************
 591  * Traversal methods
 592  *************************************************************************/
 593 
 594     /** Visitor argument: The current environment.
 595      */
 596     Env&lt;GenContext&gt; env;
 597 
 598     /** Visitor argument: The expected type (prototype).
 599      */
 600     Type pt;
 601 
 602     /** Visitor result: The item representing the computed value.
 603      */
 604     Item result;
 605 
 606     /** Visitor method: generate code for a definition, catching and reporting
 607      *  any completion failures.
 608      *  @param tree    The definition to be visited.
 609      *  @param env     The environment current at the definition.
 610      */
 611     public void genDef(JCTree tree, Env&lt;GenContext&gt; env) {
 612         Env&lt;GenContext&gt; prevEnv = this.env;
 613         try {
 614             this.env = env;
 615             tree.accept(this);
 616         } catch (CompletionFailure ex) {
 617             chk.completionError(tree.pos(), ex);
 618         } finally {
 619             this.env = prevEnv;
 620         }
 621     }
 622 
 623     /** Derived visitor method: check whether CharacterRangeTable
 624      *  should be emitted, if so, put a new entry into CRTable
 625      *  and call method to generate bytecode.
 626      *  If not, just call method to generate bytecode.
 627      *  @see    #genStat(JCTree, Env)
 628      *
 629      *  @param  tree     The tree to be visited.
 630      *  @param  env      The environment to use.
 631      *  @param  crtFlags The CharacterRangeTable flags
 632      *                   indicating type of the entry.
 633      */
 634     public void genStat(JCTree tree, Env&lt;GenContext&gt; env, int crtFlags) {
 635         if (!genCrt) {
 636             genStat(tree, env);
 637             return;
 638         }
 639         int startpc = code.curCP();
 640         genStat(tree, env);
 641         if (tree.hasTag(Tag.BLOCK)) crtFlags |= CRT_BLOCK;
 642         code.crt.put(tree, crtFlags, startpc, code.curCP());
 643     }
 644 
 645     /** Derived visitor method: generate code for a statement.
 646      */
 647     public void genStat(JCTree tree, Env&lt;GenContext&gt; env) {
 648         if (code.isAlive()) {
 649             code.statBegin(tree.pos);
 650             genDef(tree, env);
 651         } else if (env.info.isSwitch &amp;&amp; tree.hasTag(VARDEF)) {
 652             // variables whose declarations are in a switch
 653             // can be used even if the decl is unreachable.
 654             code.newLocal(((JCVariableDecl) tree).sym);
 655         }
 656     }
 657 
 658     /** Derived visitor method: check whether CharacterRangeTable
 659      *  should be emitted, if so, put a new entry into CRTable
 660      *  and call method to generate bytecode.
 661      *  If not, just call method to generate bytecode.
 662      *  @see    #genStats(List, Env)
 663      *
 664      *  @param  trees    The list of trees to be visited.
 665      *  @param  env      The environment to use.
 666      *  @param  crtFlags The CharacterRangeTable flags
 667      *                   indicating type of the entry.
 668      */
 669     public void genStats(List&lt;JCStatement&gt; trees, Env&lt;GenContext&gt; env, int crtFlags) {
 670         if (!genCrt) {
 671             genStats(trees, env);
 672             return;
 673         }
 674         if (trees.length() == 1) {        // mark one statement with the flags
 675             genStat(trees.head, env, crtFlags | CRT_STATEMENT);
 676         } else {
 677             int startpc = code.curCP();
 678             genStats(trees, env);
 679             code.crt.put(trees, crtFlags, startpc, code.curCP());
 680         }
 681     }
 682 
 683     /** Derived visitor method: generate code for a list of statements.
 684      */
 685     public void genStats(List&lt;? extends JCTree&gt; trees, Env&lt;GenContext&gt; env) {
 686         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
 687             genStat(l.head, env, CRT_STATEMENT);
 688     }
 689 
 690     /** Derived visitor method: check whether CharacterRangeTable
 691      *  should be emitted, if so, put a new entry into CRTable
 692      *  and call method to generate bytecode.
 693      *  If not, just call method to generate bytecode.
 694      *  @see    #genCond(JCTree,boolean)
 695      *
 696      *  @param  tree     The tree to be visited.
 697      *  @param  crtFlags The CharacterRangeTable flags
 698      *                   indicating type of the entry.
 699      */
 700     public CondItem genCond(JCTree tree, int crtFlags) {
 701         if (!genCrt) return genCond(tree, false);
 702         int startpc = code.curCP();
 703         CondItem item = genCond(tree, (crtFlags &amp; CRT_FLOW_CONTROLLER) != 0);
 704         code.crt.put(tree, crtFlags, startpc, code.curCP());
 705         return item;
 706     }
 707 
 708     /** Derived visitor method: generate code for a boolean
 709      *  expression in a control-flow context.
 710      *  @param _tree         The expression to be visited.
 711      *  @param markBranches The flag to indicate that the condition is
 712      *                      a flow controller so produced conditions
 713      *                      should contain a proper tree to generate
 714      *                      CharacterRangeTable branches for them.
 715      */
 716     public CondItem genCond(JCTree _tree, boolean markBranches) {
 717         JCTree inner_tree = TreeInfo.skipParens(_tree);
 718         if (inner_tree.hasTag(CONDEXPR)) {
 719             JCConditional tree = (JCConditional)inner_tree;
 720             CondItem cond = genCond(tree.cond, CRT_FLOW_CONTROLLER);
 721             if (cond.isTrue()) {
 722                 code.resolve(cond.trueJumps);
 723                 CondItem result = genCond(tree.truepart, CRT_FLOW_TARGET);
 724                 if (markBranches) result.tree = tree.truepart;
 725                 return result;
 726             }
 727             if (cond.isFalse()) {
 728                 code.resolve(cond.falseJumps);
 729                 CondItem result = genCond(tree.falsepart, CRT_FLOW_TARGET);
 730                 if (markBranches) result.tree = tree.falsepart;
 731                 return result;
 732             }
 733             Chain secondJumps = cond.jumpFalse();
 734             code.resolve(cond.trueJumps);
 735             CondItem first = genCond(tree.truepart, CRT_FLOW_TARGET);
 736             if (markBranches) first.tree = tree.truepart;
 737             Chain falseJumps = first.jumpFalse();
 738             code.resolve(first.trueJumps);
 739             Chain trueJumps = code.branch(goto_);
 740             code.resolve(secondJumps);
 741             CondItem second = genCond(tree.falsepart, CRT_FLOW_TARGET);
 742             CondItem result = items.makeCondItem(second.opcode,
 743                                       Code.mergeChains(trueJumps, second.trueJumps),
 744                                       Code.mergeChains(falseJumps, second.falseJumps));
 745             if (markBranches) result.tree = tree.falsepart;
 746             return result;
 747         } else if (inner_tree.hasTag(SWITCH_EXPRESSION)) {
 748             code.resolvePending();
 749 
 750             boolean prevInCondSwitchExpression = inCondSwitchExpression;
 751             Chain prevSwitchExpressionTrueChain = switchExpressionTrueChain;
 752             Chain prevSwitchExpressionFalseChain = switchExpressionFalseChain;
 753             try {
 754                 inCondSwitchExpression = true;
 755                 switchExpressionTrueChain = null;
 756                 switchExpressionFalseChain = null;
 757                 try {
 758                     doHandleSwitchExpression((JCSwitchExpression) inner_tree);
 759                 } catch (CompletionFailure ex) {
 760                     chk.completionError(_tree.pos(), ex);
 761                     code.state.stacksize = 1;
 762                 }
 763                 CondItem result = items.makeCondItem(goto_,
 764                                                      switchExpressionTrueChain,
 765                                                      switchExpressionFalseChain);
 766                 if (markBranches) result.tree = _tree;
 767                 return result;
 768             } finally {
 769                 inCondSwitchExpression = prevInCondSwitchExpression;
 770                 switchExpressionTrueChain = prevSwitchExpressionTrueChain;
 771                 switchExpressionFalseChain = prevSwitchExpressionFalseChain;
 772             }
 773         } else if (inner_tree.hasTag(LETEXPR) &amp;&amp; ((LetExpr) inner_tree).needsCond) {
 774             code.resolvePending();
 775 
 776             LetExpr tree = (LetExpr) inner_tree;
 777             int limit = code.nextreg;
 778             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
 779             try {
 780                 genStats(tree.defs, env);
 781             } finally {
 782                 code.setLetExprStackPos(prevLetExprStart);
 783             }
 784             CondItem result = genCond(tree.expr, markBranches);
 785             code.endScopes(limit);
 786             return result;
 787         } else {
 788             CondItem result = genExpr(_tree, syms.booleanType).mkCond();
 789             if (markBranches) result.tree = _tree;
 790             return result;
 791         }
 792     }
 793 
 794     public Code getCode() {
 795         return code;
 796     }
 797 
 798     public Items getItems() {
 799         return items;
 800     }
 801 
 802     public Env&lt;AttrContext&gt; getAttrEnv() {
 803         return attrEnv;
 804     }
 805 
 806     /** Visitor class for expressions which might be constant expressions.
 807      *  This class is a subset of TreeScanner. Intended to visit trees pruned by
 808      *  Lower as long as constant expressions looking for references to any
 809      *  ClassSymbol. Any such reference will be added to the constant pool so
 810      *  automated tools can detect class dependencies better.
 811      */
 812     class ClassReferenceVisitor extends JCTree.Visitor {
 813 
 814         @Override
 815         public void visitTree(JCTree tree) {}
 816 
 817         @Override
 818         public void visitBinary(JCBinary tree) {
 819             tree.lhs.accept(this);
 820             tree.rhs.accept(this);
 821         }
 822 
 823         @Override
 824         public void visitSelect(JCFieldAccess tree) {
 825             if (tree.selected.type.hasTag(CLASS)) {
 826                 makeRef(tree.selected.pos(), tree.selected.type);
 827             }
 828         }
 829 
 830         @Override
 831         public void visitIdent(JCIdent tree) {
 832             if (tree.sym.owner instanceof ClassSymbol) {
 833                 poolWriter.putClass((ClassSymbol)tree.sym.owner);
 834             }
 835         }
 836 
 837         @Override
 838         public void visitConditional(JCConditional tree) {
 839             tree.cond.accept(this);
 840             tree.truepart.accept(this);
 841             tree.falsepart.accept(this);
 842         }
 843 
 844         @Override
 845         public void visitUnary(JCUnary tree) {
 846             tree.arg.accept(this);
 847         }
 848 
 849         @Override
 850         public void visitParens(JCParens tree) {
 851             tree.expr.accept(this);
 852         }
 853 
 854         @Override
 855         public void visitTypeCast(JCTypeCast tree) {
 856             tree.expr.accept(this);
 857         }
 858     }
 859 
 860     private ClassReferenceVisitor classReferenceVisitor = new ClassReferenceVisitor();
 861 
 862     /** Visitor method: generate code for an expression, catching and reporting
 863      *  any completion failures.
 864      *  @param tree    The expression to be visited.
 865      *  @param pt      The expression&#39;s expected type (proto-type).
 866      */
 867     public Item genExpr(JCTree tree, Type pt) {
 868         Type prevPt = this.pt;
 869         try {
 870             if (tree.type.constValue() != null) {
 871                 // Short circuit any expressions which are constants
 872                 tree.accept(classReferenceVisitor);
 873                 checkStringConstant(tree.pos(), tree.type.constValue());
 874                 Symbol sym = TreeInfo.symbol(tree);
 875                 if (sym != null &amp;&amp; isConstantDynamic(sym)) {
 876                     result = items.makeDynamicItem(sym);
 877                 } else {
 878                     result = items.makeImmediateItem(tree.type, tree.type.constValue());
 879                 }
 880             } else {
 881                 this.pt = pt;
 882                 tree.accept(this);
 883             }
 884             return result.coerce(pt);
 885         } catch (CompletionFailure ex) {
 886             chk.completionError(tree.pos(), ex);
 887             code.state.stacksize = 1;
 888             return items.makeStackItem(pt);
 889         } finally {
 890             this.pt = prevPt;
 891         }
 892     }
 893 
 894     public boolean isConstantDynamic(Symbol sym) {
 895         return sym.kind == VAR &amp;&amp;
 896                 sym instanceof DynamicVarSymbol &amp;&amp;
 897                 ((DynamicVarSymbol)sym).isDynamic();
 898     }
 899 
 900     /** Derived visitor method: generate code for a list of method arguments.
 901      *  @param trees    The argument expressions to be visited.
 902      *  @param pts      The expression&#39;s expected types (i.e. the formal parameter
 903      *                  types of the invoked method).
 904      */
 905     public void genArgs(List&lt;JCExpression&gt; trees, List&lt;Type&gt; pts) {
 906         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail) {
 907             genExpr(l.head, pts.head).load();
 908             pts = pts.tail;
 909         }
 910         // require lists be of same length
 911         Assert.check(pts.isEmpty());
 912     }
 913 
 914 /* ************************************************************************
 915  * Visitor methods for statements and definitions
 916  *************************************************************************/
 917 
 918     /** Thrown when the byte code size exceeds limit.
 919      */
 920     public static class CodeSizeOverflow extends RuntimeException {
 921         private static final long serialVersionUID = 0;
 922         public CodeSizeOverflow() {}
 923     }
 924 
 925     public void visitMethodDef(JCMethodDecl tree) {
 926         // Create a new local environment that points pack at method
 927         // definition.
 928         Env&lt;GenContext&gt; localEnv = env.dup(tree);
 929         localEnv.enclMethod = tree;
 930         // The expected type of every return statement in this method
 931         // is the method&#39;s return type.
 932         this.pt = tree.sym.erasure(types).getReturnType();
 933 
 934         checkDimension(tree.pos(), tree.sym.erasure(types));
 935         genMethod(tree, localEnv, false);
 936     }
 937 //where
 938         /** Generate code for a method.
 939          *  @param tree     The tree representing the method definition.
 940          *  @param env      The environment current for the method body.
 941          *  @param fatcode  A flag that indicates whether all jumps are
 942          *                  within 32K.  We first invoke this method under
 943          *                  the assumption that fatcode == false, i.e. all
 944          *                  jumps are within 32K.  If this fails, fatcode
 945          *                  is set to true and we try again.
 946          */
 947         void genMethod(JCMethodDecl tree, Env&lt;GenContext&gt; env, boolean fatcode) {
 948             MethodSymbol meth = tree.sym;
 949             int extras = 0;
 950             // Count up extra parameters
 951             if (meth.isConstructor()) {
 952                 extras++;
 953                 if (meth.enclClass().isInner() &amp;&amp;
 954                     !meth.enclClass().isStatic()) {
 955                     extras++;
 956                 }
 957             } else if ((tree.mods.flags &amp; STATIC) == 0) {
 958                 extras++;
 959             }
 960             //      System.err.println(&quot;Generating &quot; + meth + &quot; in &quot; + meth.owner); //DEBUG
 961             if (Code.width(types.erasure(env.enclMethod.sym.type).getParameterTypes()) + extras &gt;
 962                 ClassFile.MAX_PARAMETERS) {
 963                 log.error(tree.pos(), Errors.LimitParameters);
 964                 nerrs++;
 965             }
 966 
 967             else if (tree.body != null) {
 968                 // Create a new code structure and initialize it.
 969                 int startpcCrt = initCode(tree, env, fatcode);
 970 
 971                 try {
 972                     genStat(tree.body, env);
 973                 } catch (CodeSizeOverflow e) {
 974                     // Failed due to code limit, try again with jsr/ret
 975                     startpcCrt = initCode(tree, env, fatcode);
 976                     genStat(tree.body, env);
 977                 }
 978 
 979                 if (code.state.stacksize != 0) {
 980                     log.error(tree.body.pos(), Errors.StackSimError(tree.sym));
 981                     throw new AssertionError();
 982                 }
 983 
 984                 // If last statement could complete normally, insert a
 985                 // return at the end.
 986                 if (code.isAlive()) {
 987                     code.statBegin(TreeInfo.endPos(tree.body));
 988                     if (env.enclMethod == null ||
 989                         env.enclMethod.sym.type.getReturnType().hasTag(VOID)) {
 990                         code.emitop0(return_);
 991                     } else if (env.enclMethod.sym.isValueFactory()) {
 992                         items.makeLocalItem(env.enclMethod.factoryProduct).load();
 993                         code.emitop0(areturn);
 994                     } else {
 995                         // sometime dead code seems alive (4415991);
 996                         // generate a small loop instead
 997                         int startpc = code.entryPoint();
 998                         CondItem c = items.makeCondItem(goto_);
 999                         code.resolve(c.jumpTrue(), startpc);
1000                     }
1001                 }
1002                 if (genCrt)
1003                     code.crt.put(tree.body,
1004                                  CRT_BLOCK,
1005                                  startpcCrt,
1006                                  code.curCP());
1007 
1008                 code.endScopes(0);
1009 
1010                 // If we exceeded limits, panic
1011                 if (code.checkLimits(tree.pos(), log)) {
1012                     nerrs++;
1013                     return;
1014                 }
1015 
1016                 // If we generated short code but got a long jump, do it again
1017                 // with fatCode = true.
1018                 if (!fatcode &amp;&amp; code.fatcode) genMethod(tree, env, true);
1019 
1020                 // Clean up
1021                 if(stackMap == StackMapFormat.JSR202) {
1022                     code.lastFrame = null;
1023                     code.frameBeforeLast = null;
1024                 }
1025 
1026                 // Compress exception table
1027                 code.compressCatchTable();
1028 
1029                 // Fill in type annotation positions for exception parameters
1030                 code.fillExceptionParameterPositions();
1031             }
1032         }
1033 
1034         private int initCode(JCMethodDecl tree, Env&lt;GenContext&gt; env, boolean fatcode) {
1035             MethodSymbol meth = tree.sym;
1036 
1037             // Create a new code structure.
1038             meth.code = code = new Code(meth,
1039                                         fatcode,
1040                                         lineDebugInfo ? toplevel.lineMap : null,
1041                                         varDebugInfo,
1042                                         stackMap,
1043                                         debugCode,
1044                                         genCrt ? new CRTable(tree, env.toplevel.endPositions)
1045                                                : null,
1046                                         syms,
1047                                         types,
1048                                         poolWriter);
1049             items = new Items(poolWriter, code, syms, types);
1050             if (code.debugCode) {
1051                 System.err.println(meth + &quot; for body &quot; + tree);
1052             }
1053 
1054             // If method is not static, create a new local variable address
1055             // for `this&#39;.
1056             if ((tree.mods.flags &amp; STATIC) == 0) {
1057                 Type selfType = meth.owner.type;
1058                 if (meth.isConstructor() &amp;&amp; selfType != syms.objectType)
1059                     selfType = UninitializedType.uninitializedThis(selfType);
1060                 code.setDefined(
1061                         code.newLocal(
1062                             new VarSymbol(FINAL, names._this, selfType, meth.owner)));
1063             }
1064 
1065             // Mark all parameters as defined from the beginning of
1066             // the method.
1067             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1068                 checkDimension(l.head.pos(), l.head.sym.type);
1069                 code.setDefined(code.newLocal(l.head.sym));
1070             }
1071 
1072             // Get ready to generate code for method body.
1073             int startpcCrt = genCrt ? code.curCP() : 0;
1074             code.entryPoint();
1075 
1076             // Suppress initial stackmap
1077             code.pendingStackMap = false;
1078 
1079             return startpcCrt;
1080         }
1081 
1082         private void synthesizeValueMethod(JCMethodDecl methodDecl) {
1083 
1084             Name name; List&lt;Type&gt; argTypes; Type resType;
1085 
1086             switch (methodDecl.name.toString()) {
<a name="1" id="anc1"></a><span class="line-removed">1087                 case &quot;hashCode&quot;:</span>
<span class="line-removed">1088                     name = names.hashCode;</span>
<span class="line-removed">1089                     argTypes = List.of(methodDecl.sym.owner.type);</span>
<span class="line-removed">1090                     resType = methodDecl.restype.type;</span>
<span class="line-removed">1091                     break;</span>
<span class="line-removed">1092                 case &quot;equals&quot;:</span>
<span class="line-removed">1093                     name = names.equals;</span>
<span class="line-removed">1094                     argTypes = List.of(methodDecl.sym.owner.type, syms.objectType);</span>
<span class="line-removed">1095                     resType = methodDecl.restype.type;</span>
<span class="line-removed">1096                     break;</span>
1097                 case &quot;toString&quot;:
1098                     name = names.toString;
1099                     argTypes = List.of(methodDecl.sym.owner.type);
1100                     resType = methodDecl.restype.type;
1101                     break;
1102                 default:
1103                     throw new AssertionError(&quot;Unexpected synthetic method body&quot;);
1104             }
1105 
1106             Type.MethodType indyType = new Type.MethodType(argTypes,
1107                     resType,
1108                     List.nil(),
1109                     syms.methodClass);
1110 
1111             List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
1112                                                 syms.stringType,
1113                                                 syms.methodTypeType);
1114 
1115             Symbol bsm = rs.resolveInternalMethod(methodDecl.pos(),
1116                     getAttrEnv(),
1117                     syms.valueBootstrapMethods,
1118                     names.fromString(&quot;makeBootstrapMethod&quot;),
1119                     bsm_staticArgs,
1120                     null);
1121 
1122             Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(name,
1123                     syms.noSymbol,
1124                     ((MethodSymbol)bsm).asHandle(),
1125                     indyType,
1126                     List.nil().toArray(new LoadableConstant[0]));
1127 
<a name="2" id="anc2"></a><span class="line-removed">1128 </span>
1129             switch (methodDecl.name.toString()) {
<a name="3" id="anc3"></a><span class="line-removed">1130                 case &quot;hashCode&quot;:</span>
<span class="line-removed">1131                     code.emitop0(aload_0);</span>
<span class="line-removed">1132                     items.makeDynamicItem(dynSym).invoke();</span>
<span class="line-removed">1133                     code.emitop0(ireturn);</span>
<span class="line-removed">1134                     return;</span>
<span class="line-removed">1135                 case &quot;equals&quot;:</span>
<span class="line-removed">1136                     code.emitop0(aload_0);</span>
<span class="line-removed">1137                     code.emitop0(aload_1);</span>
<span class="line-removed">1138                     items.makeDynamicItem(dynSym).invoke();</span>
<span class="line-removed">1139                     code.emitop0(ireturn);</span>
<span class="line-removed">1140                     return;</span>
1141                 case &quot;toString&quot;:
1142                     code.emitop0(aload_0);
1143                     items.makeDynamicItem(dynSym).invoke();
1144                     code.emitop0(areturn);
1145                     return;
1146             }
1147         }
1148 
1149     public void visitVarDef(JCVariableDecl tree) {
1150         VarSymbol v = tree.sym;
1151         if (tree.init != null) {
1152             checkStringConstant(tree.init.pos(), v.getConstValue());
1153             if (v.getConstValue() == null || varDebugInfo) {
1154                 Assert.check(code.isStatementStart());
1155                 code.newLocal(v);
1156                 genExpr(tree.init, v.erasure(types)).load();
1157                 items.makeLocalItem(v).store();
1158                 Assert.check(code.isStatementStart());
1159             }
1160         } else {
1161             code.newLocal(v);
1162         }
1163         checkDimension(tree.pos(), v.type);
1164     }
1165 
1166     public void visitSkip(JCSkip tree) {
1167     }
1168 
1169     public void visitBlock(JCBlock tree) {
1170         if ((tree.flags &amp; SYNTHETIC) != 0 &amp;&amp; env.tree.hasTag(METHODDEF) &amp;&amp; (((JCMethodDecl) env.tree).sym.owner.flags() &amp; VALUE) != 0) {
1171             synthesizeValueMethod((JCMethodDecl) env.tree);
1172             return;
1173         }
1174         int limit = code.nextreg;
1175         Env&lt;GenContext&gt; localEnv = env.dup(tree, new GenContext());
1176         genStats(tree.stats, localEnv);
1177         // End the scope of all block-local variables in variable info.
1178         if (!env.tree.hasTag(METHODDEF)) {
1179             code.statBegin(tree.endpos);
1180             code.endScopes(limit);
1181             code.pendingStatPos = Position.NOPOS;
1182         }
1183     }
1184 
1185     public void visitDoLoop(JCDoWhileLoop tree) {
1186         genLoop(tree, tree.body, tree.cond, List.nil(), false);
1187     }
1188 
1189     public void visitWhileLoop(JCWhileLoop tree) {
1190         genLoop(tree, tree.body, tree.cond, List.nil(), true);
1191     }
1192 
1193     public void visitWithField(JCWithField tree) {
1194         switch(tree.field.getTag()) {
1195             case IDENT:
1196                 Symbol sym = ((JCIdent) tree.field).sym;
1197                 items.makeThisItem().load();
1198                 genExpr(tree.value, tree.field.type).load();
1199                 sym = binaryQualifier(sym, env.enclClass.type);
1200                 code.emitop2(withfield, sym, PoolWriter::putMember);
1201                 result = items.makeStackItem(tree.type);
1202                 break;
1203             case SELECT:
1204                 JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;
1205                 sym = TreeInfo.symbol(fieldAccess);
1206                 // JDK-8207332: To maintain the order of side effects, must compute value ahead of field
1207                 genExpr(tree.value, tree.field.type).load();
1208                 genExpr(fieldAccess.selected, fieldAccess.selected.type).load();
1209                 if (Code.width(tree.field.type) == 2) {
1210                     code.emitop0(dup_x2);
1211                     code.emitop0(pop);
1212                 } else {
1213                     code.emitop0(swap);
1214                 }
1215                 sym = binaryQualifier(sym, fieldAccess.selected.type);
1216                 code.emitop2(withfield, sym, PoolWriter::putMember);
1217                 result = items.makeStackItem(tree.type);
1218                 break;
1219             default:
1220                 Assert.check(false);
1221         }
1222     }
1223 
1224     public void visitForLoop(JCForLoop tree) {
1225         int limit = code.nextreg;
1226         genStats(tree.init, env);
1227         genLoop(tree, tree.body, tree.cond, tree.step, true);
1228         code.endScopes(limit);
1229     }
1230     //where
1231         /** Generate code for a loop.
1232          *  @param loop       The tree representing the loop.
1233          *  @param body       The loop&#39;s body.
1234          *  @param cond       The loop&#39;s controlling condition.
1235          *  @param step       &quot;Step&quot; statements to be inserted at end of
1236          *                    each iteration.
1237          *  @param testFirst  True if the loop test belongs before the body.
1238          */
1239         private void genLoop(JCStatement loop,
1240                              JCStatement body,
1241                              JCExpression cond,
1242                              List&lt;JCExpressionStatement&gt; step,
1243                              boolean testFirst) {
1244             Env&lt;GenContext&gt; loopEnv = env.dup(loop, new GenContext());
1245             int startpc = code.entryPoint();
1246             if (testFirst) { //while or for loop
1247                 CondItem c;
1248                 if (cond != null) {
1249                     code.statBegin(cond.pos);
1250                     Assert.check(code.isStatementStart());
1251                     c = genCond(TreeInfo.skipParens(cond), CRT_FLOW_CONTROLLER);
1252                 } else {
1253                     c = items.makeCondItem(goto_);
1254                 }
1255                 Chain loopDone = c.jumpFalse();
1256                 code.resolve(c.trueJumps);
1257                 Assert.check(code.isStatementStart());
1258                 genStat(body, loopEnv, CRT_STATEMENT | CRT_FLOW_TARGET);
1259                 code.resolve(loopEnv.info.cont);
1260                 genStats(step, loopEnv);
1261                 code.resolve(code.branch(goto_), startpc);
1262                 code.resolve(loopDone);
1263             } else {
1264                 genStat(body, loopEnv, CRT_STATEMENT | CRT_FLOW_TARGET);
1265                 code.resolve(loopEnv.info.cont);
1266                 genStats(step, loopEnv);
1267                 if (code.isAlive()) {
1268                     CondItem c;
1269                     if (cond != null) {
1270                         code.statBegin(cond.pos);
1271                         Assert.check(code.isStatementStart());
1272                         c = genCond(TreeInfo.skipParens(cond), CRT_FLOW_CONTROLLER);
1273                     } else {
1274                         c = items.makeCondItem(goto_);
1275                     }
1276                     code.resolve(c.jumpTrue(), startpc);
1277                     Assert.check(code.isStatementStart());
1278                     code.resolve(c.falseJumps);
1279                 }
1280             }
1281             Chain exit = loopEnv.info.exit;
1282             if (exit != null) {
1283                 code.resolve(exit);
1284                 exit.state.defined.excludeFrom(code.nextreg);
1285             }
1286         }
1287 
1288     public void visitForeachLoop(JCEnhancedForLoop tree) {
1289         throw new AssertionError(); // should have been removed by Lower.
1290     }
1291 
1292     public void visitLabelled(JCLabeledStatement tree) {
1293         Env&lt;GenContext&gt; localEnv = env.dup(tree, new GenContext());
1294         genStat(tree.body, localEnv, CRT_STATEMENT);
1295         Chain exit = localEnv.info.exit;
1296         if (exit != null) {
1297             code.resolve(exit);
1298             exit.state.defined.excludeFrom(code.nextreg);
1299         }
1300     }
1301 
1302     public void visitSwitch(JCSwitch tree) {
1303         handleSwitch(tree, tree.selector, tree.cases);
1304     }
1305 
1306     @Override
1307     public void visitSwitchExpression(JCSwitchExpression tree) {
1308         code.resolvePending();
1309         boolean prevInCondSwitchExpression = inCondSwitchExpression;
1310         try {
1311             inCondSwitchExpression = false;
1312             doHandleSwitchExpression(tree);
1313         } finally {
1314             inCondSwitchExpression = prevInCondSwitchExpression;
1315         }
1316         result = items.makeStackItem(pt);
1317     }
1318 
1319     private void doHandleSwitchExpression(JCSwitchExpression tree) {
1320         List&lt;LocalItem&gt; prevStackBeforeSwitchExpression = stackBeforeSwitchExpression;
1321         LocalItem prevSwitchResult = switchResult;
1322         int limit = code.nextreg;
1323         try {
1324             stackBeforeSwitchExpression = List.nil();
1325             switchResult = null;
1326             if (hasTry(tree)) {
1327                 //if the switch expression contains try-catch, the catch handlers need to have
1328                 //an empty stack. So stash whole stack to local variables, and restore it before
1329                 //breaks:
1330                 while (code.state.stacksize &gt; 0) {
1331                     Type type = code.state.peek();
1332                     Name varName = names.fromString(target.syntheticNameChar() +
1333                                                     &quot;stack&quot; +
1334                                                     target.syntheticNameChar() +
1335                                                     tree.pos +
1336                                                     target.syntheticNameChar() +
1337                                                     code.state.stacksize);
1338                     VarSymbol var = new VarSymbol(Flags.SYNTHETIC, varName, type,
1339                                                   this.env.enclMethod.sym);
1340                     LocalItem item = items.new LocalItem(type, code.newLocal(var));
1341                     stackBeforeSwitchExpression = stackBeforeSwitchExpression.prepend(item);
1342                     item.store();
1343                 }
1344                 switchResult = makeTemp(tree.type);
1345             }
1346             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
1347             try {
1348                 handleSwitch(tree, tree.selector, tree.cases);
1349             } finally {
1350                 code.setLetExprStackPos(prevLetExprStart);
1351             }
1352         } finally {
1353             stackBeforeSwitchExpression = prevStackBeforeSwitchExpression;
1354             switchResult = prevSwitchResult;
1355             code.endScopes(limit);
1356         }
1357     }
1358     //where:
1359         private boolean hasTry(JCSwitchExpression tree) {
1360             boolean[] hasTry = new boolean[1];
1361             new TreeScanner() {
1362                 @Override
1363                 public void visitTry(JCTry tree) {
1364                     hasTry[0] = true;
1365                 }
1366 
1367                 @Override
1368                 public void visitClassDef(JCClassDecl tree) {
1369                 }
1370 
1371                 @Override
1372                 public void visitLambda(JCLambda tree) {
1373                 }
1374             }.scan(tree);
1375             return hasTry[0];
1376         }
1377 
1378     private void handleSwitch(JCTree swtch, JCExpression selector, List&lt;JCCase&gt; cases) {
1379         int limit = code.nextreg;
1380         Assert.check(!selector.type.hasTag(CLASS));
1381         int startpcCrt = genCrt ? code.curCP() : 0;
1382         Assert.check(code.isStatementStart());
1383         Item sel = genExpr(selector, syms.intType);
1384         if (cases.isEmpty()) {
1385             // We are seeing:  switch &lt;sel&gt; {}
1386             sel.load().drop();
1387             if (genCrt)
1388                 code.crt.put(TreeInfo.skipParens(selector),
1389                              CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());
1390         } else {
1391             // We are seeing a nonempty switch.
1392             sel.load();
1393             if (genCrt)
1394                 code.crt.put(TreeInfo.skipParens(selector),
1395                              CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());
1396             Env&lt;GenContext&gt; switchEnv = env.dup(swtch, new GenContext());
1397             switchEnv.info.isSwitch = true;
1398 
1399             // Compute number of labels and minimum and maximum label values.
1400             // For each case, store its label in an array.
1401             int lo = Integer.MAX_VALUE;  // minimum label.
1402             int hi = Integer.MIN_VALUE;  // maximum label.
1403             int nlabels = 0;               // number of labels.
1404 
1405             int[] labels = new int[cases.length()];  // the label array.
1406             int defaultIndex = -1;     // the index of the default clause.
1407 
1408             List&lt;JCCase&gt; l = cases;
1409             for (int i = 0; i &lt; labels.length; i++) {
1410                 if (l.head.pats.nonEmpty()) {
1411                     Assert.check(l.head.pats.size() == 1);
1412                     int val = ((Number)l.head.pats.head.type.constValue()).intValue();
1413                     labels[i] = val;
1414                     if (val &lt; lo) lo = val;
1415                     if (hi &lt; val) hi = val;
1416                     nlabels++;
1417                 } else {
1418                     Assert.check(defaultIndex == -1);
1419                     defaultIndex = i;
1420                 }
1421                 l = l.tail;
1422             }
1423 
1424             // Determine whether to issue a tableswitch or a lookupswitch
1425             // instruction.
1426             long table_space_cost = 4 + ((long) hi - lo + 1); // words
1427             long table_time_cost = 3; // comparisons
1428             long lookup_space_cost = 3 + 2 * (long) nlabels;
1429             long lookup_time_cost = nlabels;
1430             int opcode =
1431                 nlabels &gt; 0 &amp;&amp;
1432                 table_space_cost + 3 * table_time_cost &lt;=
1433                 lookup_space_cost + 3 * lookup_time_cost
1434                 ?
1435                 tableswitch : lookupswitch;
1436 
1437             int startpc = code.curCP();    // the position of the selector operation
1438             code.emitop0(opcode);
1439             code.align(4);
1440             int tableBase = code.curCP();  // the start of the jump table
1441             int[] offsets = null;          // a table of offsets for a lookupswitch
1442             code.emit4(-1);                // leave space for default offset
1443             if (opcode == tableswitch) {
1444                 code.emit4(lo);            // minimum label
1445                 code.emit4(hi);            // maximum label
1446                 for (long i = lo; i &lt;= hi; i++) {  // leave space for jump table
1447                     code.emit4(-1);
1448                 }
1449             } else {
1450                 code.emit4(nlabels);    // number of labels
1451                 for (int i = 0; i &lt; nlabels; i++) {
1452                     code.emit4(-1); code.emit4(-1); // leave space for lookup table
1453                 }
1454                 offsets = new int[labels.length];
1455             }
1456             Code.State stateSwitch = code.state.dup();
1457             code.markDead();
1458 
1459             // For each case do:
1460             l = cases;
1461             for (int i = 0; i &lt; labels.length; i++) {
1462                 JCCase c = l.head;
1463                 l = l.tail;
1464 
1465                 int pc = code.entryPoint(stateSwitch);
1466                 // Insert offset directly into code or else into the
1467                 // offsets table.
1468                 if (i != defaultIndex) {
1469                     if (opcode == tableswitch) {
1470                         code.put4(
1471                             tableBase + 4 * (labels[i] - lo + 3),
1472                             pc - startpc);
1473                     } else {
1474                         offsets[i] = pc - startpc;
1475                     }
1476                 } else {
1477                     code.put4(tableBase, pc - startpc);
1478                 }
1479 
1480                 // Generate code for the statements in this case.
1481                 genStats(c.stats, switchEnv, CRT_FLOW_TARGET);
1482             }
1483 
1484             // Resolve all breaks.
1485             Chain exit = switchEnv.info.exit;
1486             if  (exit != null) {
1487                 code.resolve(exit);
1488                 exit.state.defined.excludeFrom(limit);
1489             }
1490 
1491             // If we have not set the default offset, we do so now.
1492             if (code.get4(tableBase) == -1) {
1493                 code.put4(tableBase, code.entryPoint(stateSwitch) - startpc);
1494             }
1495 
1496             if (opcode == tableswitch) {
1497                 // Let any unfilled slots point to the default case.
1498                 int defaultOffset = code.get4(tableBase);
1499                 for (long i = lo; i &lt;= hi; i++) {
1500                     int t = (int)(tableBase + 4 * (i - lo + 3));
1501                     if (code.get4(t) == -1)
1502                         code.put4(t, defaultOffset);
1503                 }
1504             } else {
1505                 // Sort non-default offsets and copy into lookup table.
1506                 if (defaultIndex &gt;= 0)
1507                     for (int i = defaultIndex; i &lt; labels.length - 1; i++) {
1508                         labels[i] = labels[i+1];
1509                         offsets[i] = offsets[i+1];
1510                     }
1511                 if (nlabels &gt; 0)
1512                     qsort2(labels, offsets, 0, nlabels - 1);
1513                 for (int i = 0; i &lt; nlabels; i++) {
1514                     int caseidx = tableBase + 8 * (i + 1);
1515                     code.put4(caseidx, labels[i]);
1516                     code.put4(caseidx + 4, offsets[i]);
1517                 }
1518             }
1519         }
1520         code.endScopes(limit);
1521     }
1522 //where
1523         /** Sort (int) arrays of keys and values
1524          */
1525        static void qsort2(int[] keys, int[] values, int lo, int hi) {
1526             int i = lo;
1527             int j = hi;
1528             int pivot = keys[(i+j)/2];
1529             do {
1530                 while (keys[i] &lt; pivot) i++;
1531                 while (pivot &lt; keys[j]) j--;
1532                 if (i &lt;= j) {
1533                     int temp1 = keys[i];
1534                     keys[i] = keys[j];
1535                     keys[j] = temp1;
1536                     int temp2 = values[i];
1537                     values[i] = values[j];
1538                     values[j] = temp2;
1539                     i++;
1540                     j--;
1541                 }
1542             } while (i &lt;= j);
1543             if (lo &lt; j) qsort2(keys, values, lo, j);
1544             if (i &lt; hi) qsort2(keys, values, i, hi);
1545         }
1546 
1547     public void visitSynchronized(JCSynchronized tree) {
1548         int limit = code.nextreg;
1549         // Generate code to evaluate lock and save in temporary variable.
1550         final LocalItem lockVar = makeTemp(syms.objectType);
1551         Assert.check(code.isStatementStart());
1552         genExpr(tree.lock, tree.lock.type).load().duplicate();
1553         lockVar.store();
1554 
1555         // Generate code to enter monitor.
1556         code.emitop0(monitorenter);
1557         code.state.lock(lockVar.reg);
1558 
1559         // Generate code for a try statement with given body, no catch clauses
1560         // in a new environment with the &quot;exit-monitor&quot; operation as finalizer.
1561         final Env&lt;GenContext&gt; syncEnv = env.dup(tree, new GenContext());
1562         syncEnv.info.finalize = new GenFinalizer() {
1563             void gen() {
1564                 genLast();
1565                 Assert.check(syncEnv.info.gaps.length() % 2 == 0);
1566                 syncEnv.info.gaps.append(code.curCP());
1567             }
1568             void genLast() {
1569                 if (code.isAlive()) {
1570                     lockVar.load();
1571                     code.emitop0(monitorexit);
1572                     code.state.unlock(lockVar.reg);
1573                 }
1574             }
1575         };
1576         syncEnv.info.gaps = new ListBuffer&lt;&gt;();
1577         genTry(tree.body, List.nil(), syncEnv);
1578         code.endScopes(limit);
1579     }
1580 
1581     public void visitTry(final JCTry tree) {
1582         // Generate code for a try statement with given body and catch clauses,
1583         // in a new environment which calls the finally block if there is one.
1584         final Env&lt;GenContext&gt; tryEnv = env.dup(tree, new GenContext());
1585         final Env&lt;GenContext&gt; oldEnv = env;
1586         tryEnv.info.finalize = new GenFinalizer() {
1587             void gen() {
1588                 Assert.check(tryEnv.info.gaps.length() % 2 == 0);
1589                 tryEnv.info.gaps.append(code.curCP());
1590                 genLast();
1591             }
1592             void genLast() {
1593                 if (tree.finalizer != null)
1594                     genStat(tree.finalizer, oldEnv, CRT_BLOCK);
1595             }
1596             boolean hasFinalizer() {
1597                 return tree.finalizer != null;
1598             }
1599 
1600             @Override
1601             void afterBody() {
1602                 if (tree.finalizer != null &amp;&amp; (tree.finalizer.flags &amp; BODY_ONLY_FINALIZE) != 0) {
1603                     //for body-only finally, remove the GenFinalizer after try body
1604                     //so that the finally is not generated to catch bodies:
1605                     tryEnv.info.finalize = null;
1606                 }
1607             }
1608 
1609         };
1610         tryEnv.info.gaps = new ListBuffer&lt;&gt;();
1611         genTry(tree.body, tree.catchers, tryEnv);
1612     }
1613     //where
1614         /** Generate code for a try or synchronized statement
1615          *  @param body      The body of the try or synchronized statement.
1616          *  @param catchers  The lis of catch clauses.
1617          *  @param env       the environment current for the body.
1618          */
1619         void genTry(JCTree body, List&lt;JCCatch&gt; catchers, Env&lt;GenContext&gt; env) {
1620             int limit = code.nextreg;
1621             int startpc = code.curCP();
1622             Code.State stateTry = code.state.dup();
1623             genStat(body, env, CRT_BLOCK);
1624             int endpc = code.curCP();
1625             List&lt;Integer&gt; gaps = env.info.gaps.toList();
1626             code.statBegin(TreeInfo.endPos(body));
1627             genFinalizer(env);
1628             code.statBegin(TreeInfo.endPos(env.tree));
1629             Chain exitChain = code.branch(goto_);
1630             endFinalizerGap(env);
1631             env.info.finalize.afterBody();
1632             boolean hasFinalizer =
1633                 env.info.finalize != null &amp;&amp;
1634                 env.info.finalize.hasFinalizer();
1635             if (startpc != endpc) for (List&lt;JCCatch&gt; l = catchers; l.nonEmpty(); l = l.tail) {
1636                 // start off with exception on stack
1637                 code.entryPoint(stateTry, l.head.param.sym.type);
1638                 genCatch(l.head, env, startpc, endpc, gaps);
1639                 genFinalizer(env);
1640                 if (hasFinalizer || l.tail.nonEmpty()) {
1641                     code.statBegin(TreeInfo.endPos(env.tree));
1642                     exitChain = Code.mergeChains(exitChain,
1643                                                  code.branch(goto_));
1644                 }
1645                 endFinalizerGap(env);
1646             }
1647             if (hasFinalizer) {
1648                 // Create a new register segment to avoid allocating
1649                 // the same variables in finalizers and other statements.
1650                 code.newRegSegment();
1651 
1652                 // Add a catch-all clause.
1653 
1654                 // start off with exception on stack
1655                 int catchallpc = code.entryPoint(stateTry, syms.throwableType);
1656 
1657                 // Register all exception ranges for catch all clause.
1658                 // The range of the catch all clause is from the beginning
1659                 // of the try or synchronized block until the present
1660                 // code pointer excluding all gaps in the current
1661                 // environment&#39;s GenContext.
1662                 int startseg = startpc;
1663                 while (env.info.gaps.nonEmpty()) {
1664                     int endseg = env.info.gaps.next().intValue();
1665                     registerCatch(body.pos(), startseg, endseg,
1666                                   catchallpc, 0);
1667                     startseg = env.info.gaps.next().intValue();
1668                 }
1669                 code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.FIRST_STAT_POS));
1670                 code.markStatBegin();
1671 
1672                 Item excVar = makeTemp(syms.throwableType);
1673                 excVar.store();
1674                 genFinalizer(env);
1675                 code.resolvePending();
1676                 code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.END_POS));
1677                 code.markStatBegin();
1678 
1679                 excVar.load();
1680                 registerCatch(body.pos(), startseg,
1681                               env.info.gaps.next().intValue(),
1682                               catchallpc, 0);
1683                 code.emitop0(athrow);
1684                 code.markDead();
1685 
1686                 // If there are jsr&#39;s to this finalizer, ...
1687                 if (env.info.cont != null) {
1688                     // Resolve all jsr&#39;s.
1689                     code.resolve(env.info.cont);
1690 
1691                     // Mark statement line number
1692                     code.statBegin(TreeInfo.finalizerPos(env.tree, PosKind.FIRST_STAT_POS));
1693                     code.markStatBegin();
1694 
1695                     // Save return address.
1696                     LocalItem retVar = makeTemp(syms.throwableType);
1697                     retVar.store();
1698 
1699                     // Generate finalizer code.
1700                     env.info.finalize.genLast();
1701 
1702                     // Return.
1703                     code.emitop1w(ret, retVar.reg);
1704                     code.markDead();
1705                 }
1706             }
1707             // Resolve all breaks.
1708             code.resolve(exitChain);
1709 
1710             code.endScopes(limit);
1711         }
1712 
1713         /** Generate code for a catch clause.
1714          *  @param tree     The catch clause.
1715          *  @param env      The environment current in the enclosing try.
1716          *  @param startpc  Start pc of try-block.
1717          *  @param endpc    End pc of try-block.
1718          */
1719         void genCatch(JCCatch tree,
1720                       Env&lt;GenContext&gt; env,
1721                       int startpc, int endpc,
1722                       List&lt;Integer&gt; gaps) {
1723             if (startpc != endpc) {
1724                 List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypeExprs
1725                         = catchTypesWithAnnotations(tree);
1726                 while (gaps.nonEmpty()) {
1727                     for (Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt; subCatch1 : catchTypeExprs) {
1728                         JCExpression subCatch = subCatch1.snd;
1729                         int catchType = makeRef(tree.pos(), subCatch.type);
1730                         int end = gaps.head.intValue();
1731                         registerCatch(tree.pos(),
1732                                       startpc,  end, code.curCP(),
1733                                       catchType);
1734                         for (Attribute.TypeCompound tc :  subCatch1.fst) {
1735                                 tc.position.setCatchInfo(catchType, startpc);
1736                         }
1737                     }
1738                     gaps = gaps.tail;
1739                     startpc = gaps.head.intValue();
1740                     gaps = gaps.tail;
1741                 }
1742                 if (startpc &lt; endpc) {
1743                     for (Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt; subCatch1 : catchTypeExprs) {
1744                         JCExpression subCatch = subCatch1.snd;
1745                         int catchType = makeRef(tree.pos(), subCatch.type);
1746                         registerCatch(tree.pos(),
1747                                       startpc, endpc, code.curCP(),
1748                                       catchType);
1749                         for (Attribute.TypeCompound tc :  subCatch1.fst) {
1750                             tc.position.setCatchInfo(catchType, startpc);
1751                         }
1752                     }
1753                 }
1754                 VarSymbol exparam = tree.param.sym;
1755                 code.statBegin(tree.pos);
1756                 code.markStatBegin();
1757                 int limit = code.nextreg;
1758                 code.newLocal(exparam);
1759                 items.makeLocalItem(exparam).store();
1760                 code.statBegin(TreeInfo.firstStatPos(tree.body));
1761                 genStat(tree.body, env, CRT_BLOCK);
1762                 code.endScopes(limit);
1763                 code.statBegin(TreeInfo.endPos(tree.body));
1764             }
1765         }
1766         // where
1767         List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypesWithAnnotations(JCCatch tree) {
1768             return TreeInfo.isMultiCatch(tree) ?
1769                     catchTypesWithAnnotationsFromMulticatch((JCTypeUnion)tree.param.vartype, tree.param.sym.getRawTypeAttributes()) :
1770                     List.of(new Pair&lt;&gt;(tree.param.sym.getRawTypeAttributes(), tree.param.vartype));
1771         }
1772         // where
1773         List&lt;Pair&lt;List&lt;Attribute.TypeCompound&gt;, JCExpression&gt;&gt; catchTypesWithAnnotationsFromMulticatch(JCTypeUnion tree, List&lt;TypeCompound&gt; first) {
1774             List&lt;JCExpression&gt; alts = tree.alternatives;
1775             List&lt;Pair&lt;List&lt;TypeCompound&gt;, JCExpression&gt;&gt; res = List.of(new Pair&lt;&gt;(first, alts.head));
1776             alts = alts.tail;
1777 
1778             while(alts != null &amp;&amp; alts.head != null) {
1779                 JCExpression alt = alts.head;
1780                 if (alt instanceof JCAnnotatedType) {
1781                     JCAnnotatedType a = (JCAnnotatedType)alt;
1782                     res = res.prepend(new Pair&lt;&gt;(annotate.fromAnnotations(a.annotations), alt));
1783                 } else {
1784                     res = res.prepend(new Pair&lt;&gt;(List.nil(), alt));
1785                 }
1786                 alts = alts.tail;
1787             }
1788             return res.reverse();
1789         }
1790 
1791         /** Register a catch clause in the &quot;Exceptions&quot; code-attribute.
1792          */
1793         void registerCatch(DiagnosticPosition pos,
1794                            int startpc, int endpc,
1795                            int handler_pc, int catch_type) {
1796             char startpc1 = (char)startpc;
1797             char endpc1 = (char)endpc;
1798             char handler_pc1 = (char)handler_pc;
1799             if (startpc1 == startpc &amp;&amp;
1800                 endpc1 == endpc &amp;&amp;
1801                 handler_pc1 == handler_pc) {
1802                 code.addCatch(startpc1, endpc1, handler_pc1,
1803                               (char)catch_type);
1804             } else {
1805                 log.error(pos, Errors.LimitCodeTooLargeForTryStmt);
1806                 nerrs++;
1807             }
1808         }
1809 
1810     public void visitIf(JCIf tree) {
1811         int limit = code.nextreg;
1812         Chain thenExit = null;
1813         Assert.check(code.isStatementStart());
1814         CondItem c = genCond(TreeInfo.skipParens(tree.cond),
1815                              CRT_FLOW_CONTROLLER);
1816         Chain elseChain = c.jumpFalse();
1817         Assert.check(code.isStatementStart());
1818         if (!c.isFalse()) {
1819             code.resolve(c.trueJumps);
1820             genStat(tree.thenpart, env, CRT_STATEMENT | CRT_FLOW_TARGET);
1821             thenExit = code.branch(goto_);
1822         }
1823         if (elseChain != null) {
1824             code.resolve(elseChain);
1825             if (tree.elsepart != null) {
1826                 genStat(tree.elsepart, env,CRT_STATEMENT | CRT_FLOW_TARGET);
1827             }
1828         }
1829         code.resolve(thenExit);
1830         code.endScopes(limit);
1831         Assert.check(code.isStatementStart());
1832     }
1833 
1834     public void visitExec(JCExpressionStatement tree) {
1835         // Optimize x++ to ++x and x-- to --x.
1836         JCExpression e = tree.expr;
1837         switch (e.getTag()) {
1838             case POSTINC:
1839                 ((JCUnary) e).setTag(PREINC);
1840                 break;
1841             case POSTDEC:
1842                 ((JCUnary) e).setTag(PREDEC);
1843                 break;
1844         }
1845         Assert.check(code.isStatementStart());
1846         genExpr(tree.expr, tree.expr.type).drop();
1847         Assert.check(code.isStatementStart());
1848     }
1849 
1850     public void visitBreak(JCBreak tree) {
1851         Assert.check(code.isStatementStart());
1852         final Env&lt;GenContext&gt; targetEnv = unwindBreak(tree.target);
1853         targetEnv.info.addExit(code.branch(goto_));
1854         endFinalizerGaps(env, targetEnv);
1855     }
1856 
1857     public void visitYield(JCYield tree) {
1858         Assert.check(code.isStatementStart());
1859         final Env&lt;GenContext&gt; targetEnv;
1860         if (inCondSwitchExpression) {
1861             CondItem value = genCond(tree.value, CRT_FLOW_TARGET);
1862             Chain falseJumps = value.jumpFalse();
1863 
1864             code.resolve(value.trueJumps);
1865             Env&lt;GenContext&gt; localEnv = unwindBreak(tree.target);
1866             reloadStackBeforeSwitchExpr();
1867             Chain trueJumps = code.branch(goto_);
1868 
1869             endFinalizerGaps(env, localEnv);
1870 
1871             code.resolve(falseJumps);
1872             targetEnv = unwindBreak(tree.target);
1873             reloadStackBeforeSwitchExpr();
1874             falseJumps = code.branch(goto_);
1875 
1876             if (switchExpressionTrueChain == null) {
1877                 switchExpressionTrueChain = trueJumps;
1878             } else {
1879                 switchExpressionTrueChain =
1880                         Code.mergeChains(switchExpressionTrueChain, trueJumps);
1881             }
1882             if (switchExpressionFalseChain == null) {
1883                 switchExpressionFalseChain = falseJumps;
1884             } else {
1885                 switchExpressionFalseChain =
1886                         Code.mergeChains(switchExpressionFalseChain, falseJumps);
1887             }
1888         } else {
1889             genExpr(tree.value, pt).load();
1890             if (switchResult != null)
1891                 switchResult.store();
1892 
1893             targetEnv = unwindBreak(tree.target);
1894 
1895             if (code.isAlive()) {
1896                 reloadStackBeforeSwitchExpr();
1897                 if (switchResult != null)
1898                     switchResult.load();
1899 
1900                 code.state.forceStackTop(tree.target.type);
1901                 targetEnv.info.addExit(code.branch(goto_));
1902                 code.markDead();
1903             }
1904         }
1905         endFinalizerGaps(env, targetEnv);
1906     }
1907     //where:
1908         /** As side-effect, might mark code as dead disabling any further emission.
1909          */
1910         private Env&lt;GenContext&gt; unwindBreak(JCTree target) {
1911             int tmpPos = code.pendingStatPos;
1912             Env&lt;GenContext&gt; targetEnv = unwind(target, env);
1913             code.pendingStatPos = tmpPos;
1914             return targetEnv;
1915         }
1916 
1917         private void reloadStackBeforeSwitchExpr() {
1918             for (LocalItem li : stackBeforeSwitchExpression)
1919                 li.load();
1920         }
1921 
1922     public void visitContinue(JCContinue tree) {
1923         int tmpPos = code.pendingStatPos;
1924         Env&lt;GenContext&gt; targetEnv = unwind(tree.target, env);
1925         code.pendingStatPos = tmpPos;
1926         Assert.check(code.isStatementStart());
1927         targetEnv.info.addCont(code.branch(goto_));
1928         endFinalizerGaps(env, targetEnv);
1929     }
1930 
1931     public void visitReturn(JCReturn tree) {
1932         int limit = code.nextreg;
1933         final Env&lt;GenContext&gt; targetEnv;
1934 
1935         /* Save and then restore the location of the return in case a finally
1936          * is expanded (with unwind()) in the middle of our bytecodes.
1937          */
1938         int tmpPos = code.pendingStatPos;
1939         if (tree.expr != null) {
1940             Assert.check(code.isStatementStart());
1941             Item r = genExpr(tree.expr, pt).load();
1942             if (hasFinally(env.enclMethod, env)) {
1943                 r = makeTemp(pt);
1944                 r.store();
1945             }
1946             targetEnv = unwind(env.enclMethod, env);
1947             code.pendingStatPos = tmpPos;
1948             r.load();
1949             code.emitop0(ireturn + Code.truncate(Code.typecode(pt)));
1950         } else {
1951             targetEnv = unwind(env.enclMethod, env);
1952             code.pendingStatPos = tmpPos;
1953             code.emitop0(return_);
1954         }
1955         endFinalizerGaps(env, targetEnv);
1956         code.endScopes(limit);
1957     }
1958 
1959     public void visitThrow(JCThrow tree) {
1960         Assert.check(code.isStatementStart());
1961         genExpr(tree.expr, tree.expr.type).load();
1962         code.emitop0(athrow);
1963         Assert.check(code.isStatementStart());
1964     }
1965 
1966 /* ************************************************************************
1967  * Visitor methods for expressions
1968  *************************************************************************/
1969 
1970     public void visitApply(JCMethodInvocation tree) {
1971         setTypeAnnotationPositions(tree.pos);
1972         // Generate code for method.
1973         Item m = genExpr(tree.meth, methodType);
1974         // Generate code for all arguments, where the expected types are
1975         // the parameters of the method&#39;s external type (that is, any implicit
1976         // outer instance of a super(...) call appears as first parameter).
1977         MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(tree.meth);
1978         genArgs(tree.args,
1979                 msym.externalType(types).getParameterTypes());
1980         if (!msym.isDynamic()) {
1981             code.statBegin(tree.pos);
1982         }
1983         result = m.invoke();
1984     }
1985 
1986     public void visitConditional(JCConditional tree) {
1987         Chain thenExit = null;
1988         code.statBegin(tree.cond.pos);
1989         CondItem c = genCond(tree.cond, CRT_FLOW_CONTROLLER);
1990         Chain elseChain = c.jumpFalse();
1991         if (!c.isFalse()) {
1992             code.resolve(c.trueJumps);
1993             int startpc = genCrt ? code.curCP() : 0;
1994             code.statBegin(tree.truepart.pos);
1995             genExpr(tree.truepart, pt).load();
1996             code.state.forceStackTop(tree.type);
1997             if (genCrt) code.crt.put(tree.truepart, CRT_FLOW_TARGET,
1998                                      startpc, code.curCP());
1999             thenExit = code.branch(goto_);
2000         }
2001         if (elseChain != null) {
2002             code.resolve(elseChain);
2003             int startpc = genCrt ? code.curCP() : 0;
2004             code.statBegin(tree.falsepart.pos);
2005             genExpr(tree.falsepart, pt).load();
2006             code.state.forceStackTop(tree.type);
2007             if (genCrt) code.crt.put(tree.falsepart, CRT_FLOW_TARGET,
2008                                      startpc, code.curCP());
2009         }
2010         code.resolve(thenExit);
2011         result = items.makeStackItem(pt);
2012     }
2013 
2014     private void setTypeAnnotationPositions(int treePos) {
2015         MethodSymbol meth = code.meth;
2016         boolean initOrClinit = code.meth.getKind() == javax.lang.model.element.ElementKind.CONSTRUCTOR
2017                 || code.meth.getKind() == javax.lang.model.element.ElementKind.STATIC_INIT;
2018 
2019         for (Attribute.TypeCompound ta : meth.getRawTypeAttributes()) {
2020             if (ta.hasUnknownPosition())
2021                 ta.tryFixPosition();
2022 
2023             if (ta.position.matchesPos(treePos))
2024                 ta.position.updatePosOffset(code.cp);
2025         }
2026 
2027         if (!initOrClinit)
2028             return;
2029 
2030         for (Attribute.TypeCompound ta : meth.owner.getRawTypeAttributes()) {
2031             if (ta.hasUnknownPosition())
2032                 ta.tryFixPosition();
2033 
2034             if (ta.position.matchesPos(treePos))
2035                 ta.position.updatePosOffset(code.cp);
2036         }
2037 
2038         ClassSymbol clazz = meth.enclClass();
2039         for (Symbol s : new com.sun.tools.javac.model.FilteredMemberList(clazz.members())) {
2040             if (!s.getKind().isField())
2041                 continue;
2042 
2043             for (Attribute.TypeCompound ta : s.getRawTypeAttributes()) {
2044                 if (ta.hasUnknownPosition())
2045                     ta.tryFixPosition();
2046 
2047                 if (ta.position.matchesPos(treePos))
2048                     ta.position.updatePosOffset(code.cp);
2049             }
2050         }
2051     }
2052 
2053     public void visitNewClass(JCNewClass tree) {
2054         // Enclosing instances or anonymous classes should have been eliminated
2055         // by now.
2056         Assert.check(tree.encl == null &amp;&amp; tree.def == null);
2057         setTypeAnnotationPositions(tree.pos);
2058 
2059         code.emitop2(new_, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);
2060         code.emitop0(dup);
2061 
2062         // Generate code for all arguments, where the expected types are
2063         // the parameters of the constructor&#39;s external type (that is,
2064         // any implicit outer instance appears as first parameter).
2065         genArgs(tree.args, tree.constructor.externalType(types).getParameterTypes());
2066 
2067         items.makeMemberItem(tree.constructor, true).invoke();
2068 
2069         result = items.makeStackItem(tree.type);
2070     }
2071 
2072     public void visitNewArray(JCNewArray tree) {
2073         setTypeAnnotationPositions(tree.pos);
2074 
2075         if (tree.elems != null) {
2076             Type elemtype = types.elemtype(tree.type);
2077             loadIntConst(tree.elems.length());
2078             Item arr = makeNewArray(tree.pos(), tree.type, 1);
2079             int i = 0;
2080             for (List&lt;JCExpression&gt; l = tree.elems; l.nonEmpty(); l = l.tail) {
2081                 arr.duplicate();
2082                 loadIntConst(i);
2083                 i++;
2084                 genExpr(l.head, elemtype).load();
2085                 items.makeIndexedItem(elemtype).store();
2086             }
2087             result = arr;
2088         } else {
2089             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
2090                 genExpr(l.head, syms.intType).load();
2091             }
2092             result = makeNewArray(tree.pos(), tree.type, tree.dims.length());
2093         }
2094     }
2095 //where
2096         /** Generate code to create an array with given element type and number
2097          *  of dimensions.
2098          */
2099         Item makeNewArray(DiagnosticPosition pos, Type type, int ndims) {
2100             Type elemtype = types.elemtype(type);
2101             if (types.dimensions(type) &gt; ClassFile.MAX_DIMENSIONS) {
2102                 log.error(pos, Errors.LimitDimensions);
2103                 nerrs++;
2104             }
2105             int elemcode = Code.arraycode(elemtype);
2106             if (elemcode == 0 || (elemcode == 1 &amp;&amp; ndims == 1)) {
2107                 code.emitAnewarray(makeRef(pos, elemtype, types.isValue(elemtype)), type);
2108             } else if (elemcode == 1) {
2109                 code.emitMultianewarray(ndims, makeRef(pos, type), type);
2110             } else {
2111                 code.emitNewarray(elemcode, type);
2112             }
2113             return items.makeStackItem(type);
2114         }
2115 
2116     public void visitParens(JCParens tree) {
2117         result = genExpr(tree.expr, tree.expr.type);
2118     }
2119 
2120     public void visitAssign(JCAssign tree) {
2121         Item l = genExpr(tree.lhs, tree.lhs.type);
2122         genExpr(tree.rhs, tree.lhs.type).load();
2123         if (tree.rhs.type.hasTag(BOT)) {
2124             /* This is just a case of widening reference conversion that per 5.1.5 simply calls
2125                for &quot;regarding a reference as having some other type in a manner that can be proved
2126                correct at compile time.&quot;
2127             */
2128             code.state.forceStackTop(tree.lhs.type);
2129         }
2130         result = items.makeAssignItem(l);
2131     }
2132 
2133     public void visitAssignop(JCAssignOp tree) {
2134         OperatorSymbol operator = tree.operator;
2135         Item l;
2136         if (operator.opcode == string_add) {
2137             l = concat.makeConcat(tree);
2138         } else {
2139             // Generate code for first expression
2140             l = genExpr(tree.lhs, tree.lhs.type);
2141 
2142             // If we have an increment of -32768 to +32767 of a local
2143             // int variable we can use an incr instruction instead of
2144             // proceeding further.
2145             if ((tree.hasTag(PLUS_ASG) || tree.hasTag(MINUS_ASG)) &amp;&amp;
2146                 l instanceof LocalItem &amp;&amp;
2147                 tree.lhs.type.getTag().isSubRangeOf(INT) &amp;&amp;
2148                 tree.rhs.type.getTag().isSubRangeOf(INT) &amp;&amp;
2149                 tree.rhs.type.constValue() != null) {
2150                 int ival = ((Number) tree.rhs.type.constValue()).intValue();
2151                 if (tree.hasTag(MINUS_ASG)) ival = -ival;
2152                 ((LocalItem)l).incr(ival);
2153                 result = l;
2154                 return;
2155             }
2156             // Otherwise, duplicate expression, load one copy
2157             // and complete binary operation.
2158             l.duplicate();
2159             l.coerce(operator.type.getParameterTypes().head).load();
2160             completeBinop(tree.lhs, tree.rhs, operator).coerce(tree.lhs.type);
2161         }
2162         result = items.makeAssignItem(l);
2163     }
2164 
2165     public void visitUnary(JCUnary tree) {
2166         OperatorSymbol operator = tree.operator;
2167         if (tree.hasTag(NOT)) {
2168             CondItem od = genCond(tree.arg, false);
2169             result = od.negate();
2170         } else {
2171             Item od = genExpr(tree.arg, operator.type.getParameterTypes().head);
2172             switch (tree.getTag()) {
2173             case POS:
2174                 result = od.load();
2175                 break;
2176             case NEG:
2177                 result = od.load();
2178                 code.emitop0(operator.opcode);
2179                 break;
2180             case COMPL:
2181                 result = od.load();
2182                 emitMinusOne(od.typecode);
2183                 code.emitop0(operator.opcode);
2184                 break;
2185             case PREINC: case PREDEC:
2186                 od.duplicate();
2187                 if (od instanceof LocalItem &amp;&amp;
2188                     (operator.opcode == iadd || operator.opcode == isub)) {
2189                     ((LocalItem)od).incr(tree.hasTag(PREINC) ? 1 : -1);
2190                     result = od;
2191                 } else {
2192                     od.load();
2193                     code.emitop0(one(od.typecode));
2194                     code.emitop0(operator.opcode);
2195                     // Perform narrowing primitive conversion if byte,
2196                     // char, or short.  Fix for 4304655.
2197                     if (od.typecode != INTcode &amp;&amp;
2198                         Code.truncate(od.typecode) == INTcode)
2199                       code.emitop0(int2byte + od.typecode - BYTEcode);
2200                     result = items.makeAssignItem(od);
2201                 }
2202                 break;
2203             case POSTINC: case POSTDEC:
2204                 od.duplicate();
2205                 if (od instanceof LocalItem &amp;&amp;
2206                     (operator.opcode == iadd || operator.opcode == isub)) {
2207                     Item res = od.load();
2208                     ((LocalItem)od).incr(tree.hasTag(POSTINC) ? 1 : -1);
2209                     result = res;
2210                 } else {
2211                     Item res = od.load();
2212                     od.stash(od.typecode);
2213                     code.emitop0(one(od.typecode));
2214                     code.emitop0(operator.opcode);
2215                     // Perform narrowing primitive conversion if byte,
2216                     // char, or short.  Fix for 4304655.
2217                     if (od.typecode != INTcode &amp;&amp;
2218                         Code.truncate(od.typecode) == INTcode)
2219                       code.emitop0(int2byte + od.typecode - BYTEcode);
2220                     od.store();
2221                     result = res;
2222                 }
2223                 break;
2224             case NULLCHK:
2225                 result = od.load();
2226                 code.emitop0(dup);
2227                 genNullCheck(tree);
2228                 break;
2229             default:
2230                 Assert.error();
2231             }
2232         }
2233     }
2234 
2235     /** Generate a null check from the object value at stack top. */
2236     private void genNullCheck(JCTree tree) {
2237         code.statBegin(tree.pos);
2238         callMethod(tree.pos(), syms.objectsType, names.requireNonNull,
2239                    List.of(syms.objectType), true);
2240         code.emitop0(pop);
2241     }
2242 
2243     public void visitBinary(JCBinary tree) {
2244         OperatorSymbol operator = tree.operator;
2245         if (operator.opcode == string_add) {
2246             result = concat.makeConcat(tree);
2247         } else if (tree.hasTag(AND)) {
2248             CondItem lcond = genCond(tree.lhs, CRT_FLOW_CONTROLLER);
2249             if (!lcond.isFalse()) {
2250                 Chain falseJumps = lcond.jumpFalse();
2251                 code.resolve(lcond.trueJumps);
2252                 CondItem rcond = genCond(tree.rhs, CRT_FLOW_TARGET);
2253                 result = items.
2254                     makeCondItem(rcond.opcode,
2255                                  rcond.trueJumps,
2256                                  Code.mergeChains(falseJumps,
2257                                                   rcond.falseJumps));
2258             } else {
2259                 result = lcond;
2260             }
2261         } else if (tree.hasTag(OR)) {
2262             CondItem lcond = genCond(tree.lhs, CRT_FLOW_CONTROLLER);
2263             if (!lcond.isTrue()) {
2264                 Chain trueJumps = lcond.jumpTrue();
2265                 code.resolve(lcond.falseJumps);
2266                 CondItem rcond = genCond(tree.rhs, CRT_FLOW_TARGET);
2267                 result = items.
2268                     makeCondItem(rcond.opcode,
2269                                  Code.mergeChains(trueJumps, rcond.trueJumps),
2270                                  rcond.falseJumps);
2271             } else {
2272                 result = lcond;
2273             }
2274         } else {
2275             Item od = genExpr(tree.lhs, operator.type.getParameterTypes().head);
2276             od.load();
2277             result = completeBinop(tree.lhs, tree.rhs, operator);
2278         }
2279     }
2280 
2281 
2282         /** Complete generating code for operation, with left operand
2283          *  already on stack.
2284          *  @param lhs       The tree representing the left operand.
2285          *  @param rhs       The tree representing the right operand.
2286          *  @param operator  The operator symbol.
2287          */
2288         Item completeBinop(JCTree lhs, JCTree rhs, OperatorSymbol operator) {
2289             MethodType optype = (MethodType)operator.type;
2290             int opcode = operator.opcode;
2291             if (opcode &gt;= if_icmpeq &amp;&amp; opcode &lt;= if_icmple &amp;&amp;
2292                 rhs.type.constValue() instanceof Number &amp;&amp;
2293                 ((Number) rhs.type.constValue()).intValue() == 0) {
2294                 opcode = opcode + (ifeq - if_icmpeq);
2295             } else if (opcode &gt;= if_acmpeq &amp;&amp; opcode &lt;= if_acmpne &amp;&amp;
2296                        TreeInfo.isNull(rhs)) {
2297                 opcode = opcode + (if_acmp_null - if_acmpeq);
2298             } else {
2299                 // The expected type of the right operand is
2300                 // the second parameter type of the operator, except for
2301                 // shifts with long shiftcount, where we convert the opcode
2302                 // to a short shift and the expected type to int.
2303                 Type rtype = operator.erasure(types).getParameterTypes().tail.head;
2304                 if (opcode &gt;= ishll &amp;&amp; opcode &lt;= lushrl) {
2305                     opcode = opcode + (ishl - ishll);
2306                     rtype = syms.intType;
2307                 }
2308                 // Generate code for right operand and load.
2309                 genExpr(rhs, rtype).load();
2310                 // If there are two consecutive opcode instructions,
2311                 // emit the first now.
2312                 if (opcode &gt;= (1 &lt;&lt; preShift)) {
2313                     code.emitop0(opcode &gt;&gt; preShift);
2314                     opcode = opcode &amp; 0xFF;
2315                 }
2316             }
2317             if (opcode &gt;= ifeq &amp;&amp; opcode &lt;= if_acmpne ||
2318                 opcode == if_acmp_null || opcode == if_acmp_nonnull) {
2319                 return items.makeCondItem(opcode);
2320             } else {
2321                 code.emitop0(opcode);
2322                 return items.makeStackItem(optype.restype);
2323             }
2324         }
2325 
2326     public void visitTypeCast(JCTypeCast tree) {
2327         result = genExpr(tree.expr, tree.clazz.type).load();
2328         setTypeAnnotationPositions(tree.pos);
2329         // Additional code is only needed if we cast to a reference type
2330         // which is not statically a supertype of the expression&#39;s type.
2331         // For basic types, the coerce(...) in genExpr(...) will do
2332         // the conversion.
2333         // inline widening conversion is a nop, as the VM sees a subtyping relationship.
2334         if (!tree.clazz.type.isPrimitive() &amp;&amp;
2335            !types.isSameType(tree.expr.type, tree.clazz.type) &amp;&amp;
2336             (!tree.clazz.type.tsym.isReferenceProjection() || tree.clazz.type.tsym.valueProjection() != tree.expr.type.tsym) &amp;&amp;
2337            types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
2338             checkDimension(tree.pos(), tree.clazz.type);
2339             if (types.isValue(tree.clazz.type)) {
2340                 code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);
2341             } else {
2342                 code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);
2343             }
2344 
2345         }
2346     }
2347 
2348     public void visitWildcard(JCWildcard tree) {
2349         throw new AssertionError(this.getClass().getName());
2350     }
2351 
2352     public void visitTypeTest(JCInstanceOf tree) {
2353         genExpr(tree.expr, tree.expr.type).load();
2354         setTypeAnnotationPositions(tree.pos);
2355         code.emitop2(instanceof_, makeRef(tree.pos(), tree.pattern.type));
2356         result = items.makeStackItem(syms.booleanType);
2357     }
2358 
2359     public void visitIndexed(JCArrayAccess tree) {
2360         genExpr(tree.indexed, tree.indexed.type).load();
2361         genExpr(tree.index, syms.intType).load();
2362         result = items.makeIndexedItem(tree.type);
2363     }
2364 
2365     public void visitIdent(JCIdent tree) {
2366         Symbol sym = tree.sym;
2367         if (tree.name == names._this || tree.name == names._super) {
2368             Item res = tree.name == names._this
2369                 ? items.makeThisItem()
2370                 : items.makeSuperItem();
2371             if (sym.kind == MTH) {
2372                 // Generate code to address the constructor.
2373                 res.load();
2374                 res = items.makeMemberItem(sym, true);
2375             }
2376             result = res;
2377        } else if (isInvokeDynamic(sym) || isConstantDynamic(sym)) {
2378             if (isConstantDynamic(sym)) {
2379                 setTypeAnnotationPositions(tree.pos);
2380             }
2381             result = items.makeDynamicItem(sym);
2382         } else if (sym.kind == VAR &amp;&amp; (sym.owner.kind == MTH || sym.owner.kind == VAR)) {
2383             result = items.makeLocalItem((VarSymbol)sym);
2384         } else if ((sym.flags() &amp; STATIC) != 0) {
2385             if (!isAccessSuper(env.enclMethod))
2386                 sym = binaryQualifier(sym, env.enclClass.type);
2387             result = items.makeStaticItem(sym);
2388         } else {
2389             items.makeThisItem().load();
2390             sym = binaryQualifier(sym, env.enclClass.type);
2391             result = items.makeMemberItem(sym, nonVirtualForPrivateAccess(sym));
2392         }
2393     }
2394 
2395     //where
2396     private boolean nonVirtualForPrivateAccess(Symbol sym) {
2397         boolean useVirtual = target.hasVirtualPrivateInvoke() &amp;&amp;
2398                              !disableVirtualizedPrivateInvoke;
2399         return !useVirtual &amp;&amp; ((sym.flags() &amp; PRIVATE) != 0);
2400     }
2401 
2402     public void visitSelect(JCFieldAccess tree) {
2403         Symbol sym = tree.sym;
2404 
2405         if (tree.name == names._class) {
2406             code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));
2407             result = items.makeStackItem(pt);
2408             return;
2409         } else if (tree.name == names._default) {
2410             if (tree.type.asElement().isValue()) {
2411                 code.emitop2(defaultvalue, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);
2412             } else if (tree.type.isReference()) {
2413                 code.emitop0(aconst_null);
2414             } else {
2415                 code.emitop0(zero(Code.typecode(tree.type)));
2416             }
2417             result = items.makeStackItem(tree.type);
2418             return;
2419         }
2420 
2421         Symbol ssym = TreeInfo.symbol(tree.selected);
2422 
2423         // Are we selecting via super?
2424         boolean selectSuper =
2425             ssym != null &amp;&amp; (ssym.kind == TYP || ssym.name == names._super);
2426 
2427         // Are we accessing a member of the superclass in an access method
2428         // resulting from a qualified super?
2429         boolean accessSuper = isAccessSuper(env.enclMethod);
2430 
2431         Item base = (selectSuper)
2432             ? items.makeSuperItem()
2433             : genExpr(tree.selected, tree.selected.type);
2434 
2435         if (sym.kind == VAR &amp;&amp; ((VarSymbol) sym).getConstValue() != null) {
2436             // We are seeing a variable that is constant but its selecting
2437             // expression is not.
2438             if ((sym.flags() &amp; STATIC) != 0) {
2439                 if (!selectSuper &amp;&amp; (ssym == null || ssym.kind != TYP))
2440                     base = base.load();
2441                 base.drop();
2442             } else {
2443                 base.load();
2444                 genNullCheck(tree.selected);
2445             }
2446             result = items.
2447                 makeImmediateItem(sym.type, ((VarSymbol) sym).getConstValue());
2448         } else {
2449             if (isInvokeDynamic(sym)) {
2450                 result = items.makeDynamicItem(sym);
2451                 return;
2452             } else {
2453                 sym = binaryQualifier(sym, tree.selected.type);
2454             }
2455             if ((sym.flags() &amp; STATIC) != 0) {
2456                 if (!selectSuper &amp;&amp; (ssym == null || ssym.kind != TYP))
2457                     base = base.load();
2458                 base.drop();
2459                 result = items.makeStaticItem(sym);
2460             } else {
2461                 base.load();
2462                 if (sym == syms.lengthVar) {
2463                     code.emitop0(arraylength);
2464                     result = items.makeStackItem(syms.intType);
2465                 } else {
2466                     result = items.
2467                         makeMemberItem(sym,
2468                                        nonVirtualForPrivateAccess(sym) ||
2469                                        selectSuper || accessSuper);
2470                 }
2471             }
2472         }
2473     }
2474 
2475     public boolean isInvokeDynamic(Symbol sym) {
2476         return sym.kind == MTH &amp;&amp; ((MethodSymbol)sym).isDynamic();
2477     }
2478 
2479     public void visitLiteral(JCLiteral tree) {
2480         if (tree.type.hasTag(BOT)) {
2481             code.emitop0(aconst_null);
2482             result = items.makeStackItem(tree.type);
2483         }
2484         else
2485             result = items.makeImmediateItem(tree.type, tree.value);
2486     }
2487 
2488     public void visitLetExpr(LetExpr tree) {
2489         code.resolvePending();
2490 
2491         int limit = code.nextreg;
2492         int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
2493         try {
2494             genStats(tree.defs, env);
2495         } finally {
2496             code.setLetExprStackPos(prevLetExprStart);
2497         }
2498         result = genExpr(tree.expr, tree.expr.type).load();
2499         code.endScopes(limit);
2500     }
2501 
2502     private void generateReferencesToPrunedTree(ClassSymbol classSymbol) {
2503         List&lt;JCTree&gt; prunedInfo = lower.prunedTree.get(classSymbol);
2504         if (prunedInfo != null) {
2505             for (JCTree prunedTree: prunedInfo) {
2506                 prunedTree.accept(classReferenceVisitor);
2507             }
2508         }
2509     }
2510 
2511 /* ************************************************************************
2512  * main method
2513  *************************************************************************/
2514 
2515     /** Generate code for a class definition.
2516      *  @param env   The attribution environment that belongs to the
2517      *               outermost class containing this class definition.
2518      *               We need this for resolving some additional symbols.
2519      *  @param cdef  The tree representing the class definition.
2520      *  @return      True if code is generated with no errors.
2521      */
2522     public boolean genClass(Env&lt;AttrContext&gt; env, JCClassDecl cdef) {
2523         try {
2524             attrEnv = env;
2525             ClassSymbol c = cdef.sym;
2526             this.toplevel = env.toplevel;
2527             this.endPosTable = toplevel.endPositions;
2528             /* method normalizeDefs() can add references to external classes into the constant pool
2529              */
2530             cdef.defs = normalizeDefs(cdef.defs, c);
2531             cdef = transValues.translateTopLevelClass(cdef, make);
2532             generateReferencesToPrunedTree(c);
2533             Env&lt;GenContext&gt; localEnv = new Env&lt;&gt;(cdef, new GenContext());
2534             localEnv.toplevel = env.toplevel;
2535             localEnv.enclClass = cdef;
2536 
2537             for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2538                 genDef(l.head, localEnv);
2539             }
2540             if (poolWriter.size() &gt; PoolWriter.MAX_ENTRIES) {
2541                 log.error(cdef.pos(), Errors.LimitPool);
2542                 nerrs++;
2543             }
2544             if (nerrs != 0) {
2545                 // if errors, discard code
2546                 for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2547                     if (l.head.hasTag(METHODDEF))
2548                         ((JCMethodDecl) l.head).sym.code = null;
2549                 }
2550             }
2551             cdef.defs = List.nil(); // discard trees
2552             return nerrs == 0;
2553         } finally {
2554             // note: this method does NOT support recursion.
2555             attrEnv = null;
2556             this.env = null;
2557             toplevel = null;
2558             endPosTable = null;
2559             nerrs = 0;
2560         }
2561     }
2562 
2563 /* ************************************************************************
2564  * Auxiliary classes
2565  *************************************************************************/
2566 
2567     /** An abstract class for finalizer generation.
2568      */
2569     abstract class GenFinalizer {
2570         /** Generate code to clean up when unwinding. */
2571         abstract void gen();
2572 
2573         /** Generate code to clean up at last. */
2574         abstract void genLast();
2575 
2576         /** Does this finalizer have some nontrivial cleanup to perform? */
2577         boolean hasFinalizer() { return true; }
2578 
2579         /** Should be invoked after the try&#39;s body has been visited. */
2580         void afterBody() {}
2581     }
2582 
2583     /** code generation contexts,
2584      *  to be used as type parameter for environments.
2585      */
2586     static class GenContext {
2587 
2588         /** A chain for all unresolved jumps that exit the current environment.
2589          */
2590         Chain exit = null;
2591 
2592         /** A chain for all unresolved jumps that continue in the
2593          *  current environment.
2594          */
2595         Chain cont = null;
2596 
2597         /** A closure that generates the finalizer of the current environment.
2598          *  Only set for Synchronized and Try contexts.
2599          */
2600         GenFinalizer finalize = null;
2601 
2602         /** Is this a switch statement?  If so, allocate registers
2603          * even when the variable declaration is unreachable.
2604          */
2605         boolean isSwitch = false;
2606 
2607         /** A list buffer containing all gaps in the finalizer range,
2608          *  where a catch all exception should not apply.
2609          */
2610         ListBuffer&lt;Integer&gt; gaps = null;
2611 
2612         /** Add given chain to exit chain.
2613          */
2614         void addExit(Chain c)  {
2615             exit = Code.mergeChains(c, exit);
2616         }
2617 
2618         /** Add given chain to cont chain.
2619          */
2620         void addCont(Chain c) {
2621             cont = Code.mergeChains(c, cont);
2622         }
2623     }
2624 
2625 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>