<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/valhalla/inlinetypes/InlineTypeTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package compiler.valhalla.inlinetypes;
 25 
 26 import compiler.whitebox.CompilerWhiteBoxTest;
 27 import jdk.test.lib.Asserts;
 28 import jdk.test.lib.management.InputArguments;
 29 import jdk.test.lib.Platform;
 30 import jdk.test.lib.process.ProcessTools;
 31 import jdk.test.lib.process.OutputAnalyzer;
 32 import jdk.test.lib.Utils;
 33 import sun.hotspot.WhiteBox;
 34 
 35 import java.lang.annotation.Retention;
 36 import java.lang.annotation.RetentionPolicy;
 37 import java.lang.annotation.Repeatable;
 38 import java.lang.invoke.*;
 39 import java.lang.reflect.Method;
 40 import java.util.ArrayList;
 41 import java.util.Arrays;
 42 import java.util.Collection;
 43 import java.util.Collections;
 44 import java.util.Hashtable;
 45 import java.util.LinkedHashMap;
 46 import java.util.List;
 47 import java.util.Map;
 48 import java.util.regex.Matcher;
 49 import java.util.regex.Pattern;
 50 import java.util.stream.Stream;
 51 import java.util.TreeMap;
 52 import java.util.function.BooleanSupplier;
 53 
 54 // Mark method as test
 55 @Retention(RetentionPolicy.RUNTIME)
 56 @Repeatable(Tests.class)
 57 @interface Test {
 58     // Regular expression used to match forbidden IR nodes
 59     // in the C2 IR emitted for this test.
 60     String failOn() default &quot;&quot;;
 61     // Regular expressions used to match and count IR nodes.
 62     String[] match() default { };
 63     int[] matchCount() default { };
 64     int compLevel() default InlineTypeTest.COMP_LEVEL_ANY;
 65     int valid() default 0;
 66 }
 67 
 68 @Retention(RetentionPolicy.RUNTIME)
 69 @interface Tests {
 70     Test[] value();
 71 }
 72 
 73 // Force method inlining during compilation
 74 @Retention(RetentionPolicy.RUNTIME)
 75 @interface ForceInline { }
 76 
 77 // Prevent method inlining during compilation
 78 @Retention(RetentionPolicy.RUNTIME)
 79 @interface DontInline { }
 80 
 81 // Prevent method compilation
 82 @Retention(RetentionPolicy.RUNTIME)
 83 @interface DontCompile { }
 84 
 85 // Force method compilation
 86 @Retention(RetentionPolicy.RUNTIME)
 87 @interface ForceCompile {
 88     int compLevel() default InlineTypeTest.COMP_LEVEL_ANY;
 89 }
 90 
 91 // Number of warmup iterations
 92 @Retention(RetentionPolicy.RUNTIME)
 93 @interface Warmup {
 94     int value();
 95 }
 96 
 97 // Do not enqueue the test method for compilation immediately after warmup loops have finished. Instead
 98 // let the test method be compiled with on-stack-replacement.
 99 @Retention(RetentionPolicy.RUNTIME)
100 @interface OSRCompileOnly {}
101 
102 // Skip this test temporarily for C1 testing
103 @Retention(RetentionPolicy.RUNTIME)
104 @interface TempSkipForC1 {
105     String reason() default &quot;&quot;;
106 }
107 
108 public abstract class InlineTypeTest {
109     protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
110 
111     protected static final int COMP_LEVEL_ANY               = -2;
112     protected static final int COMP_LEVEL_ALL               = -2;
113     protected static final int COMP_LEVEL_AOT               = -1;
114     protected static final int COMP_LEVEL_NONE              =  0;
115     protected static final int COMP_LEVEL_SIMPLE            =  1;     // C1
116     protected static final int COMP_LEVEL_LIMITED_PROFILE   =  2;     // C1, invocation &amp; backedge counters
117     protected static final int COMP_LEVEL_FULL_PROFILE      =  3;     // C1, invocation &amp; backedge counters + mdo
118     protected static final int COMP_LEVEL_FULL_OPTIMIZATION =  4;     // C2 or JVMCI
119 
120     protected static final boolean TieredCompilation = (Boolean)WHITE_BOX.getVMFlag(&quot;TieredCompilation&quot;);
121     protected static final long TieredStopAtLevel = (Long)WHITE_BOX.getVMFlag(&quot;TieredStopAtLevel&quot;);
122     static final boolean TEST_C1 = TieredCompilation &amp;&amp; TieredStopAtLevel &lt; COMP_LEVEL_FULL_OPTIMIZATION;
123 
124     // Random test values
125     public static final int  rI = Utils.getRandomInstance().nextInt() % 1000;
126     public static final long rL = Utils.getRandomInstance().nextLong() % 1000;
127     public static final double rD = Utils.getRandomInstance().nextDouble() % 1000;
128 
129     // User defined settings
130     protected static final boolean XCOMP = Platform.isComp();
131     private static final boolean PRINT_GRAPH = true;
132     private static final boolean VERBOSE = Boolean.parseBoolean(System.getProperty(&quot;Verbose&quot;, &quot;false&quot;));
133     private static final boolean PRINT_TIMES = Boolean.parseBoolean(System.getProperty(&quot;PrintTimes&quot;, &quot;false&quot;));
134     private static final boolean COMPILE_COMMANDS = Boolean.parseBoolean(System.getProperty(&quot;CompileCommands&quot;, &quot;true&quot;));
135     private static       boolean VERIFY_IR = Boolean.parseBoolean(System.getProperty(&quot;VerifyIR&quot;, &quot;true&quot;)) &amp;&amp; !XCOMP &amp;&amp; !TEST_C1 &amp;&amp; COMPILE_COMMANDS;
136     private static final boolean VERIFY_VM = Boolean.parseBoolean(System.getProperty(&quot;VerifyVM&quot;, &quot;false&quot;));
137     private static final String SCENARIOS = System.getProperty(&quot;Scenarios&quot;, &quot;&quot;);
138     private static final String TESTLIST = System.getProperty(&quot;Testlist&quot;, &quot;&quot;);
139     private static final String EXCLUDELIST = System.getProperty(&quot;Exclude&quot;, &quot;&quot;);
140     private static final int WARMUP = Integer.parseInt(System.getProperty(&quot;Warmup&quot;, &quot;251&quot;));
141     private static final boolean DUMP_REPLAY = Boolean.parseBoolean(System.getProperty(&quot;DumpReplay&quot;, &quot;false&quot;));
142     private static final boolean FLIP_C1_C2 = Boolean.parseBoolean(System.getProperty(&quot;FlipC1C2&quot;, &quot;false&quot;));
143     private static final boolean GC_AFTER = Boolean.parseBoolean(System.getProperty(&quot;GCAfter&quot;, &quot;false&quot;));
144     private static final int OSR_TEST_TIMEOUT = Integer.parseInt(System.getProperty(&quot;OSRTestTimeOut&quot;, &quot;5000&quot;));
145     protected static final boolean STRESS_CC = Boolean.parseBoolean(System.getProperty(&quot;StressCC&quot;, &quot;false&quot;));
146     private static final boolean SHUFFLE_TESTS = Boolean.parseBoolean(System.getProperty(&quot;ShuffleTests&quot;, &quot;false&quot;));
147 
148     // &quot;jtreg -DXcomp=true&quot; runs all the scenarios with -Xcomp. This is faster than &quot;jtreg -javaoptions:-Xcomp&quot;.
149     protected static final boolean RUN_SCENARIOS_WITH_XCOMP = Boolean.parseBoolean(System.getProperty(&quot;Xcomp&quot;, &quot;false&quot;));
150 
151     // Pre-defined settings
152     private static final String[] defaultFlags = {
153         &quot;-XX:-BackgroundCompilation&quot;};
154     private static final String[] compileCommandFlags = {
155         &quot;-XX:CompileCommand=quiet&quot;,
156         &quot;-XX:CompileCommand=compileonly,java.lang.invoke.*::*&quot;,
157         &quot;-XX:CompileCommand=compileonly,java.lang.Long::sum&quot;,
158         &quot;-XX:CompileCommand=compileonly,java.lang.Object::&lt;init&gt;&quot;,
159         &quot;-XX:CompileCommand=inline,compiler.valhalla.inlinetypes.MyValue*::&lt;init&gt;&quot;,
160         &quot;-XX:CompileCommand=compileonly,compiler.valhalla.inlinetypes.*::*&quot;};
161     private static final String[] printFlags = {
162         &quot;-XX:+PrintCompilation&quot;, &quot;-XX:+PrintIdeal&quot;, &quot;-XX:+UnlockDiagnosticVMOptions&quot;, &quot;-XX:+PrintOptoAssembly&quot;};
163     private static final String[] verifyFlags = {
164         &quot;-XX:+VerifyOops&quot;, &quot;-XX:+VerifyStack&quot;, &quot;-XX:+VerifyLastFrame&quot;, &quot;-XX:+VerifyBeforeGC&quot;, &quot;-XX:+VerifyAfterGC&quot;,
165         &quot;-XX:+VerifyDuringGC&quot;, &quot;-XX:+VerifyAdapterSharing&quot;};
166 
167     protected static final int InlineTypePassFieldsAsArgsOn = 0x1;
168     protected static final int InlineTypePassFieldsAsArgsOff = 0x2;
169     protected static final int InlineTypeArrayFlattenOn = 0x4;
170     protected static final int InlineTypeArrayFlattenOff = 0x8;
171     protected static final int InlineTypeReturnedAsFieldsOn = 0x10;
172     protected static final int InlineTypeReturnedAsFieldsOff = 0x20;
173     protected static final int AlwaysIncrementalInlineOn = 0x40;
174     protected static final int AlwaysIncrementalInlineOff = 0x80;
175     protected static final int G1GCOn = 0x100;
176     protected static final int G1GCOff = 0x200;
177     protected static final int ZGCOn = 0x400;
178     protected static final int ZGCOff = 0x800;
179     protected static final int ArrayLoadStoreProfileOn = 0x1000;
180     protected static final int ArrayLoadStoreProfileOff = 0x2000;
181     protected static final int TypeProfileOn = 0x4000;
182     protected static final int TypeProfileOff = 0x8000;
183     protected static final boolean InlineTypePassFieldsAsArgs = (Boolean)WHITE_BOX.getVMFlag(&quot;InlineTypePassFieldsAsArgs&quot;);
184     protected static final boolean InlineTypeArrayFlatten = (WHITE_BOX.getIntxVMFlag(&quot;FlatArrayElementMaxSize&quot;) == -1);
185     protected static final boolean InlineTypeReturnedAsFields = (Boolean)WHITE_BOX.getVMFlag(&quot;InlineTypeReturnedAsFields&quot;);
186     protected static final boolean AlwaysIncrementalInline = (Boolean)WHITE_BOX.getVMFlag(&quot;AlwaysIncrementalInline&quot;);
187     protected static final boolean G1GC = (Boolean)WHITE_BOX.getVMFlag(&quot;UseG1GC&quot;);
188     protected static final boolean ZGC = (Boolean)WHITE_BOX.getVMFlag(&quot;UseZGC&quot;);
189     protected static final boolean VerifyOops = (Boolean)WHITE_BOX.getVMFlag(&quot;VerifyOops&quot;);
190     protected static final boolean UseArrayLoadStoreProfile = (Boolean)WHITE_BOX.getVMFlag(&quot;UseArrayLoadStoreProfile&quot;);
191     protected static final long TypeProfileLevel = (Long)WHITE_BOX.getVMFlag(&quot;TypeProfileLevel&quot;);
192 
193     protected static final Hashtable&lt;String, Method&gt; tests = new Hashtable&lt;String, Method&gt;();
194     protected static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(&quot;UseCompiler&quot;);
195     protected static final boolean PRINT_IDEAL  = WHITE_BOX.getBooleanVMFlag(&quot;PrintIdeal&quot;);
196 
197     // Regular expressions used to match nodes in the PrintIdeal output
198     protected static final String START = &quot;(\\d+\\t(.*&quot;;
199     protected static final String MID = &quot;.*)+\\t===.*&quot;;
200     protected static final String END = &quot;)|&quot;;
201     // Generic allocation
202     protected static final String ALLOC_G  = &quot;(.*call,static  wrapper for: _new_instance_Java&quot; + END;
203     protected static final String ALLOCA_G = &quot;(.*call,static  wrapper for: _new_array_Java&quot; + END;
204     // Inline type allocation
205     protected static final String ALLOC  = &quot;(.*precise klass compiler/valhalla/inlinetypes/MyValue.*\\R(.*(movl|xorl|nop|spill).*\\R)*.*_new_instance_Java&quot; + END;
206     protected static final String ALLOCA = &quot;(.*precise klass \\[(L|Q)compiler/valhalla/inlinetypes/MyValue.*\\R(.*(movl|xorl|nop|spill).*\\R)*.*_new_array_Java&quot; + END;
207     protected static final String LOAD   = START + &quot;Load(B|S|I|L|F|D|P|N)&quot; + MID + &quot;@compiler/valhalla/inlinetypes/MyValue.*&quot; + END;
208     protected static final String LOADK  = START + &quot;LoadK&quot; + MID + END;
209     protected static final String STORE  = START + &quot;Store(B|C|S|I|L|F|D|P|N)&quot; + MID + &quot;@compiler/valhalla/inlinetypes/MyValue.*&quot; + END;
210     protected static final String LOOP   = START + &quot;Loop&quot; + MID + &quot;&quot; + END;
211     protected static final String COUNTEDLOOP = START + &quot;CountedLoop\\b&quot; + MID + &quot;&quot; + END;
212     protected static final String COUNTEDLOOP_MAIN = START + &quot;CountedLoop\\b&quot; + MID + &quot;main&quot; + END;
213     protected static final String TRAP   = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*(unstable_if|predicate)&quot; + END;
214     protected static final String RETURN = START + &quot;Return&quot; + MID + &quot;returns&quot; + END;
215     protected static final String LINKTOSTATIC = START + &quot;CallStaticJava&quot; + MID + &quot;linkToStatic&quot; + END;
216     protected static final String NPE = START + &quot;CallStaticJava&quot; + MID + &quot;null_check&quot; + END;
217     protected static final String CALL = START + &quot;CallStaticJava&quot; + MID + END;
218     protected static final String STORE_INLINE_FIELDS = START + &quot;CallStaticJava&quot; + MID + &quot;store_inline_type_fields&quot; + END;
219     protected static final String SCOBJ = &quot;(.*# ScObj.*&quot; + END;
220     protected static final String LOAD_UNKNOWN_INLINE = &quot;(.*call_leaf,runtime  load_unknown_inline.*&quot; + END;
221     protected static final String STORE_UNKNOWN_INLINE = &quot;(.*call_leaf,runtime  store_unknown_inline.*&quot; + END;
222     protected static final String INLINE_ARRAY_NULL_GUARD = &quot;(.*call,static  wrapper for: uncommon_trap.*reason=&#39;null_check&#39; action=&#39;none&#39;.*&quot; + END;
223     protected static final String INTRINSIC_SLOW_PATH = &quot;(.*call,static  wrapper for: uncommon_trap.*reason=&#39;intrinsic_or_type_checked_inlining&#39;.*&quot; + END;
224     protected static final String CLASS_CHECK_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*class_check&quot; + END;
225     protected static final String NULL_CHECK_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*null_check&quot; + END;
226     protected static final String RANGE_CHECK_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*range_check&quot; + END;
227     protected static final String UNHANDLED_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*unhandled&quot; + END;
228     protected static final String PREDICATE_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*predicate&quot; + END;
229     protected static final String MEMBAR = START + &quot;MemBar&quot; + MID + END;
230     protected static final String CHECKCAST_ARRAY = &quot;(cmp.*precise klass \\[(L|Q)compiler/valhalla/inlinetypes/MyValue.*&quot; + END;
231 
232     public static String[] concat(String prefix[], String... extra) {
233         ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
234         if (prefix != null) {
235             for (String s : prefix) {
236                 list.add(s);
237             }
238         }
239         if (extra != null) {
240             for (String s : extra) {
241                 list.add(s);
242             }
243         }
244 
245         return list.toArray(new String[list.size()]);
246     }
247 
248     /**
249      * Override getNumScenarios and getVMParameters if you want to run with more than
250      * the 6 built-in scenarios
251      */
252     public int getNumScenarios() {
253         return 6;
254     }
255 
256     /**
257      * VM parameters for the 5 built-in test scenarios. If your test needs to append
258      * extra parameters for (some of) these scenarios, override getExtraVMParameters().
259      */
260     public String[] getVMParameters(int scenario) {
261         switch (scenario) {
262         case 0: return new String[] {
263                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
264                 &quot;-XX:+AlwaysIncrementalInline&quot;,
265                 &quot;-XX:FlatArrayElementMaxOops=5&quot;,
266                 &quot;-XX:FlatArrayElementMaxSize=-1&quot;,
267                 &quot;-XX:InlineFieldMaxFlatSize=-1&quot;,
268                 &quot;-XX:+InlineTypePassFieldsAsArgs&quot;,
269                 &quot;-XX:+InlineTypeReturnedAsFields&quot;};
270         case 1: return new String[] {
271                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
272                 &quot;-XX:-UseCompressedOops&quot;,
273                 &quot;-XX:FlatArrayElementMaxOops=5&quot;,
274                 &quot;-XX:FlatArrayElementMaxSize=-1&quot;,
275                 &quot;-XX:InlineFieldMaxFlatSize=-1&quot;,
276                 &quot;-XX:-InlineTypePassFieldsAsArgs&quot;,
277                 &quot;-XX:-InlineTypeReturnedAsFields&quot;};
278         case 2: return new String[] {
279                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
280                 &quot;-XX:-UseCompressedOops&quot;,
281                 &quot;-XX:FlatArrayElementMaxOops=0&quot;,
282                 &quot;-XX:FlatArrayElementMaxSize=0&quot;,
283                 &quot;-XX:InlineFieldMaxFlatSize=-1&quot;,
284                 &quot;-XX:+InlineTypePassFieldsAsArgs&quot;,
285                 &quot;-XX:+InlineTypeReturnedAsFields&quot;,
286                 &quot;-XX:+StressInlineTypeReturnedAsFields&quot;};
287         case 3: return new String[] {
288                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
289                 &quot;-DVerifyIR=false&quot;,
290                 &quot;-XX:+AlwaysIncrementalInline&quot;,
291                 &quot;-XX:FlatArrayElementMaxOops=0&quot;,
292                 &quot;-XX:FlatArrayElementMaxSize=0&quot;,
293                 &quot;-XX:InlineFieldMaxFlatSize=0&quot;,
294                 &quot;-XX:+InlineTypePassFieldsAsArgs&quot;,
295                 &quot;-XX:+InlineTypeReturnedAsFields&quot;};
296         case 4: return new String[] {
297                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
298                 &quot;-DVerifyIR=false&quot;,
299                 &quot;-XX:FlatArrayElementMaxOops=-1&quot;,
300                 &quot;-XX:FlatArrayElementMaxSize=-1&quot;,
301                 &quot;-XX:InlineFieldMaxFlatSize=0&quot;,
302                 &quot;-XX:+InlineTypePassFieldsAsArgs&quot;,
303                 &quot;-XX:-InlineTypeReturnedAsFields&quot;,
304                 &quot;-XX:-ReduceInitialCardMarks&quot;};
305         case 5: return new String[] {
306                 &quot;-XX:-UseArrayLoadStoreProfile&quot;,
307                 &quot;-XX:+AlwaysIncrementalInline&quot;,
308                 &quot;-XX:FlatArrayElementMaxOops=5&quot;,
309                 &quot;-XX:FlatArrayElementMaxSize=-1&quot;,
310                 &quot;-XX:InlineFieldMaxFlatSize=-1&quot;,
311                 &quot;-XX:-InlineTypePassFieldsAsArgs&quot;,
312                 &quot;-XX:-InlineTypeReturnedAsFields&quot;};
313         }
314         return null;
315     }
316 
317     /**
318      * Override this method and return a non-null reason if the given scenario should be
319      * ignored (due to an existing bug, etc).
320      */
321     String isScenarioIgnored(int scenario) {
322         return null;
323     }
324 
325     /**
326      * Override this method to provide extra parameters for selected scenarios
327      */
328     public String[] getExtraVMParameters(int scenario) {
329         return null;
330     }
331 
332     public static void main(String[] args) throws Throwable {
333         if (args.length != 1) {
334             throw new RuntimeException(&quot;Usage: @run main/othervm/timeout=120 -Xbootclasspath/a:.&quot; +
335                                        &quot; -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions&quot; +
336                                        &quot; -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI&quot; +
337                                        &quot; compiler.valhalla.inlinetypes.InlineTypeTest &lt;YourTestMainClass&gt;&quot;);
338         }
339         String testMainClassName = args[0];
340         Class testMainClass = Class.forName(testMainClassName);
341         InlineTypeTest test = (InlineTypeTest)testMainClass.newInstance();
342         List&lt;String&gt; scenarios = null;
343         if (!SCENARIOS.isEmpty()) {
344            scenarios = Arrays.asList(SCENARIOS.split(&quot;,&quot;));
345         }
346         for (int i=0; i&lt;test.getNumScenarios(); i++) {
347             String reason;
348             if ((reason = test.isScenarioIgnored(i)) != null) {
349                 System.out.println(&quot;Scenario #&quot; + i + &quot; is ignored: &quot; + reason);
350             } else if (scenarios != null &amp;&amp; !scenarios.contains(Integer.toString(i))) {
351                 System.out.println(&quot;Scenario #&quot; + i + &quot; is skipped due to -Dscenarios=&quot; + SCENARIOS);
352             } else {
353                 System.out.println(&quot;Scenario #&quot; + i + &quot; -------- &quot;);
354                 String[] cmds = InputArguments.getVmInputArgs();
355                 if (RUN_SCENARIOS_WITH_XCOMP) {
356                     cmds = concat(cmds, &quot;-Xcomp&quot;);
357                 }
358                 cmds = concat(cmds, test.getVMParameters(i));
359                 cmds = concat(cmds, test.getExtraVMParameters(i));
360                 cmds = concat(cmds, testMainClassName);
361 
362                 OutputAnalyzer oa = ProcessTools.executeTestJvm(cmds);
363                 String output = oa.getOutput();
364                 oa.shouldHaveExitValue(0);
365                 System.out.println(output);
366             }
367         }
368     }
369 
370     // To exclude test cases, use -DExclude=&lt;case1&gt;,&lt;case2&gt;,...
371     // Each case can be just the method name, or can be &lt;class&gt;.&lt;method&gt;. The latter form is useful
372     // when you are running several tests at the same time.
373     //
374     // jtreg -DExclude=test12 TestArrays.java
375     // jtreg -DExclude=test34 TestLWorld.java
376     // -- or --
377     // jtreg -DExclude=TestArrays.test12,TestLWorld.test34 TestArrays.java TestLWorld.java
378     //
379     private List&lt;String&gt; buildExcludeList() {
380         List&lt;String&gt; exclude = null;
381         String classPrefix = getClass().getSimpleName() + &quot;.&quot;;
382         if (!EXCLUDELIST.isEmpty()) {
383             exclude = new ArrayList(Arrays.asList(EXCLUDELIST.split(&quot;,&quot;)));
384             for (int i = exclude.size() - 1; i &gt;= 0; i--) {
385                 String ex = exclude.get(i);
386                 if (ex.indexOf(&quot;.&quot;) &gt; 0) {
387                     if (ex.startsWith(classPrefix)) {
388                         ex = ex.substring(classPrefix.length());
389                         exclude.set(i, ex);
390                     } else {
391                         exclude.remove(i);
392                     }
393                 }
394             }
395         }
396         return exclude;
397     }
398 
399     protected InlineTypeTest() {
400         List&lt;String&gt; list = null;
401         if (!TESTLIST.isEmpty()) {
402            list = Arrays.asList(TESTLIST.split(&quot;,&quot;));
403         }
404         List&lt;String&gt; exclude = buildExcludeList();
405 
406         // Gather all test methods and put them in Hashtable
407         for (Method m : getClass().getDeclaredMethods()) {
408             Test[] annos = m.getAnnotationsByType(Test.class);
409             if (annos.length != 0 &amp;&amp;
410                 ((list == null || list.contains(m.getName())) &amp;&amp; (exclude == null || !exclude.contains(m.getName())))) {
411                 tests.put(getClass().getSimpleName() + &quot;::&quot; + m.getName(), m);
412             } else if (annos.length == 0 &amp;&amp; m.getName().startsWith(&quot;test&quot;)) {
413                 try {
414                     getClass().getMethod(m.getName() + &quot;_verifier&quot;, boolean.class);
415                     throw new RuntimeException(m.getName() + &quot; has a verifier method but no @Test annotation&quot;);
416                 } catch (NoSuchMethodException e) {
417                     // Expected
418                 }
419             }
420         }
421     }
422 
423     protected void run(String[] args, Class&lt;?&gt;... classes) throws Throwable {
424         if (args.length == 0) {
425             // Spawn a new VM instance
426             execute_vm();
427         } else {
428             // Execute tests in the VM spawned by the above code.
429             Asserts.assertTrue(args.length == 1 &amp;&amp; args[0].equals(&quot;run&quot;), &quot;must be&quot;);
430             run(classes);
431         }
432     }
433 
434     private void execute_vm() throws Throwable {
435         Asserts.assertFalse(tests.isEmpty(), &quot;no tests to execute&quot;);
436         String[] vmInputArgs = InputArguments.getVmInputArgs();
437         for (String arg : vmInputArgs) {
438             if (arg.startsWith(&quot;-XX:CompileThreshold&quot;)) {
439                 // Disable IR verification if non-default CompileThreshold is set
440                 VERIFY_IR = false;
441             }
442         }
443         // Each VM is launched with flags in this order, so the later ones can override the earlier one:
444         //     VERIFY_IR/VERIFY_VM flags specified below
445         //     vmInputArgs, which consists of:
446         //        @run options
447         //        getVMParameters()
448         //        getExtraVMParameters()
449         //     defaultFlags
450         //     compileCommandFlags
451         String cmds[] = null;
452         if (VERIFY_IR) {
453             // Add print flags for IR verification
454             cmds = concat(cmds, printFlags);
455             // Always trap for exception throwing to not confuse IR verification
456             cmds = concat(cmds, &quot;-XX:-OmitStackTraceInFastThrow&quot;);
457         }
458         if (VERIFY_VM) {
459             cmds = concat(cmds, verifyFlags);
460         }
461         cmds = concat(cmds, vmInputArgs);
462         cmds = concat(cmds, defaultFlags);
463         if (COMPILE_COMMANDS) {
464           cmds = concat(cmds, compileCommandFlags);
465         }
466 
467         // Run tests in own process and verify output
468         cmds = concat(cmds, getClass().getName(), &quot;run&quot;);
469         OutputAnalyzer oa = ProcessTools.executeTestJvm(cmds);
470         // If ideal graph printing is enabled/supported, verify output
471         String output = oa.getOutput();
472         oa.shouldHaveExitValue(0);
473         if (VERIFY_IR) {
474             if (output.contains(&quot;PrintIdeal enabled&quot;)) {
475                 parseOutput(output);
476             } else {
477                 System.out.println(output);
478                 System.out.println(&quot;WARNING: IR verification failed! Running with -Xint, -Xcomp or release build?&quot;);
479             }
480         }
481     }
482 
483     static final class TestAnnotation {
484         private final int flag;
485         private final BooleanSupplier predicate;
486 
487         private static final TestAnnotation testAnnotations[] = {
488             new TestAnnotation(InlineTypePassFieldsAsArgsOn, () -&gt; InlineTypePassFieldsAsArgs),
489             new TestAnnotation(InlineTypePassFieldsAsArgsOff, () -&gt; !InlineTypePassFieldsAsArgs),
490             new TestAnnotation(InlineTypeArrayFlattenOn, () -&gt; InlineTypeArrayFlatten),
491             new TestAnnotation(InlineTypeArrayFlattenOff, () -&gt; !InlineTypeArrayFlatten),
492             new TestAnnotation(InlineTypeReturnedAsFieldsOn, () -&gt; InlineTypeReturnedAsFields),
493             new TestAnnotation(InlineTypeReturnedAsFieldsOff, () -&gt; !InlineTypeReturnedAsFields),
494             new TestAnnotation(AlwaysIncrementalInlineOn, () -&gt; AlwaysIncrementalInline),
495             new TestAnnotation(AlwaysIncrementalInlineOff, () -&gt; !AlwaysIncrementalInline),
496             new TestAnnotation(G1GCOn, () -&gt; G1GC),
497             new TestAnnotation(G1GCOff, () -&gt; !G1GC),
498             new TestAnnotation(ZGCOn, () -&gt; ZGC),
499             new TestAnnotation(ZGCOff, () -&gt; !ZGC),
500             new TestAnnotation(ArrayLoadStoreProfileOn, () -&gt; UseArrayLoadStoreProfile),
501             new TestAnnotation(ArrayLoadStoreProfileOff, () -&gt; !UseArrayLoadStoreProfile),
502             new TestAnnotation(TypeProfileOn, () -&gt; TypeProfileLevel == 222),
503             new TestAnnotation(TypeProfileOff, () -&gt; TypeProfileLevel == 0),
504         };
505 
506         private TestAnnotation(int flag, BooleanSupplier predicate) {
507             this.flag = flag;
508             this.predicate = predicate;
509         }
510 
511         private boolean match(Test a) {
512             return (a.valid() &amp; flag) != 0 &amp;&amp; predicate.getAsBoolean();
513         }
514 
515         static boolean find(Test a) {
516             Stream&lt;TestAnnotation&gt; s = Arrays.stream(testAnnotations).filter(t -&gt; t.match(a));
517             long c = s.count();
518             if (c &gt; 1) {
519                 throw new RuntimeException(&quot;At most one Test annotation should match&quot;);
520             }
521             return c &gt; 0;
522         }
523     }
524 
525     private void parseOutput(String output) throws Exception {
526         Pattern comp_re = Pattern.compile(&quot;\\n\\s+\\d+\\s+\\d+\\s+(%| )(s| )(!| )b(n| )\\s+\\d?\\s+\\S+\\.(?&lt;name&gt;[^.]+::\\S+)\\s+(?&lt;osr&gt;@ \\d+\\s+)?[(]\\d+ bytes[)]&quot;);
527         Matcher m = comp_re.matcher(output);
528         Map&lt;String,String&gt; compilations = new LinkedHashMap&lt;&gt;();
529         int prev = 0;
530         String methodName = null;
531         while (m.find()) {
532             if (prev == 0) {
533                 // Print header
534                 System.out.print(output.substring(0, m.start()+1));
535             } else if (methodName != null) {
536                 compilations.put(methodName, output.substring(prev, m.start()+1));
537             }
538             if (m.group(&quot;osr&quot;) != null) {
539                 methodName = null;
540             } else {
541                 methodName = m.group(&quot;name&quot;);
542             }
543             prev = m.end();
544         }
545         if (prev == 0) {
546             // Print header
547             System.out.print(output);
548         } else if (methodName != null) {
549             compilations.put(methodName, output.substring(prev));
550         }
551         // Iterate over compilation output
552         for (String testName : compilations.keySet()) {
553             Method test = tests.get(testName);
554             if (test == null) {
555                 // Skip helper methods
556                 continue;
557             }
558             String graph = compilations.get(testName);
559             if (PRINT_GRAPH) {
560                 System.out.println(&quot;\nGraph for &quot; + testName + &quot;\n&quot; + graph);
561             }
562             // Parse graph using regular expressions to determine if it contains forbidden nodes
563             Test[] annos = test.getAnnotationsByType(Test.class);
564             Test anno = Arrays.stream(annos).filter(TestAnnotation::find).findFirst().orElse(null);
565             if (anno == null) {
566                 Object[] res = Arrays.stream(annos).filter(a -&gt; a.valid() == 0).toArray();
567                 if (res.length != 1) {
568                     throw new RuntimeException(&quot;Only one Test annotation should match&quot;);
569                 }
570                 anno = (Test)res[0];
571             }
572             String regexFail = anno.failOn();
573             if (!regexFail.isEmpty()) {
574                 Pattern pattern = Pattern.compile(regexFail.substring(0, regexFail.length()-1));
575                 Matcher matcher = pattern.matcher(graph);
576                 boolean found = matcher.find();
577                 Asserts.assertFalse(found, &quot;Graph for &#39;&quot; + testName + &quot;&#39; contains forbidden node:\n&quot; + (found ? matcher.group() : &quot;&quot;));
578             }
579             String[] regexMatch = anno.match();
580             int[] matchCount = anno.matchCount();
581             for (int i = 0; i &lt; regexMatch.length; ++i) {
582                 Pattern pattern = Pattern.compile(regexMatch[i].substring(0, regexMatch[i].length()-1));
583                 Matcher matcher = pattern.matcher(graph);
584                 int count = 0;
585                 String nodes = &quot;&quot;;
586                 while (matcher.find()) {
587                     count++;
588                     nodes += matcher.group() + &quot;\n&quot;;
589                 }
590                 if (matchCount[i] &lt; 0) {
591                     Asserts.assertLTE(Math.abs(matchCount[i]), count, &quot;Graph for &#39;&quot; + testName + &quot;&#39; contains different number of match nodes (expected &gt;= &quot; + Math.abs(matchCount[i]) + &quot; but got &quot; + count + &quot;):\n&quot; + nodes);
592                 } else {
593                     Asserts.assertEQ(matchCount[i], count, &quot;Graph for &#39;&quot; + testName + &quot;&#39; contains different number of match nodes (expected &quot; + matchCount[i] + &quot; but got &quot; + count + &quot;):\n&quot; + nodes);
594                 }
595             }
596             tests.remove(testName);
597             System.out.println(testName + &quot; passed&quot;);
598         }
599         // Check if all tests were compiled
600         if (tests.size() != 0) {
601             for (String name : tests.keySet()) {
602                 System.out.println(&quot;Test &#39;&quot; + name + &quot;&#39; not compiled!&quot;);
603             }
604             throw new RuntimeException(&quot;Not all tests were compiled&quot;);
605         }
606     }
607 
608     private void setup(Class&lt;?&gt; clazz) {
609         if (XCOMP) {
610             // Don&#39;t control compilation if -Xcomp is enabled
611             return;
612         }
613         if (DUMP_REPLAY) {
614             // Generate replay compilation files
615             String directive = &quot;[{ match: \&quot;*.*\&quot;, DumpReplay: true }]&quot;;
616             if (WHITE_BOX.addCompilerDirective(directive) != 1) {
617                 throw new RuntimeException(&quot;Failed to add compiler directive&quot;);
618             }
619         }
620 
621         Method[] methods = clazz.getDeclaredMethods();
622         for (Method m : methods) {
623             if (m.isAnnotationPresent(Test.class)) {
624                 // Don&#39;t inline tests
625                 WHITE_BOX.testSetDontInlineMethod(m, true);
626             }
627             if (m.isAnnotationPresent(DontCompile.class)) {
628                 WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_ANY, true);
629                 WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_ANY, false);
630                 WHITE_BOX.testSetDontInlineMethod(m, true);
631             }
632             if (m.isAnnotationPresent(ForceInline.class)) {
633                 Asserts.assertFalse(m.isAnnotationPresent(DontInline.class), &quot;Method &quot; + m.getName() + &quot; has contradicting DontInline annotation&quot;);
634                 WHITE_BOX.testSetForceInlineMethod(m, true);
635             }
636             if (m.isAnnotationPresent(DontInline.class)) {
637                 Asserts.assertFalse(m.isAnnotationPresent(ForceInline.class), &quot;Method &quot; + m.getName() + &quot; has contradicting ForceInline annotation&quot;);
638                 WHITE_BOX.testSetDontInlineMethod(m, true);
639             }
640             if (STRESS_CC) {
641                 // Exclude some methods from compilation with C2 to stress test the calling convention
642                 if (Utils.getRandomInstance().nextBoolean()) {
643                     System.out.println(&quot;Excluding from C2 compilation: &quot; + m);
644                     WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_FULL_OPTIMIZATION, false);
645                 }
646             }
647         }
648         // Only force compilation now because above annotations affect inlining
649         for (Method m : methods) {
650             if (m.isAnnotationPresent(ForceCompile.class)) {
651                 Asserts.assertFalse(m.isAnnotationPresent(DontCompile.class), &quot;Method &quot; + m.getName() + &quot; has contradicting DontCompile annotation&quot;);
652                 int compLevel = getCompLevel(m.getAnnotation(ForceCompile.class));
653                 enqueueMethodForCompilation(m, compLevel);
654             }
655         }
656         // Compile class initializers
657         int compLevel = getCompLevel(null);
658         WHITE_BOX.enqueueInitializerForCompilation(clazz, compLevel);
659     }
660 
661     private void run(Class&lt;?&gt;... classes) throws Exception {
662         if (USE_COMPILER &amp;&amp; PRINT_IDEAL &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
663             System.out.println(&quot;PrintIdeal enabled&quot;);
664         }
665         System.out.format(&quot;rI = %d, rL = %d\n&quot;, rI, rL);
666 
667         setup(getClass());
668         for (Class&lt;?&gt; clazz : classes) {
669             setup(clazz);
670         }
671 
672         TreeMap&lt;Long, String&gt; durations = (PRINT_TIMES || VERBOSE) ? new TreeMap&lt;Long, String&gt;() : null;
673         List&lt;Method&gt; testList = new ArrayList&lt;Method&gt;(tests.values());
674         if (SHUFFLE_TESTS) {
675             // Execute tests in random order (execution sequence affects profiling)
676             Collections.shuffle(testList, Utils.getRandomInstance());
677         }
678         for (Method test : testList) {
679             if (VERBOSE) {
680                 System.out.println(&quot;Starting &quot; + test.getName());
681             }
682             TempSkipForC1 c1skip = test.getAnnotation(TempSkipForC1.class);
683             if (TEST_C1 &amp;&amp; c1skip != null) {
684                 System.out.println(&quot;Skipped &quot; + test.getName() + &quot; for C1 testing: &quot; + c1skip.reason());
685                 continue;
686             }
687             long startTime = System.nanoTime();
688             Method verifier = getClass().getMethod(test.getName() + &quot;_verifier&quot;, boolean.class);
689             // Warmup using verifier method
690             Warmup anno = test.getAnnotation(Warmup.class);
691             int warmup = anno == null ? WARMUP : anno.value();
692             for (int i = 0; i &lt; warmup; ++i) {
693                 verifier.invoke(this, true);
694             }
695             boolean osrOnly = (test.getAnnotation(OSRCompileOnly.class) != null);
696             int compLevel = getCompLevel(test.getAnnotation(Test.class));
697 
698             // C1 generates a lot of code when VerifyOops is enabled and may run out of space (for a small
699             // number of test cases).
700             boolean maybeCodeBufferOverflow = (TEST_C1 &amp;&amp; VerifyOops);
701 
702             if (osrOnly) {
703                 long started = System.currentTimeMillis();
704                 boolean stateCleared = false;
705                 for (;;) {
706                     long elapsed = System.currentTimeMillis() - started;
707                     int level = WHITE_BOX.getMethodCompilationLevel(test);
708                     if (maybeCodeBufferOverflow &amp;&amp; elapsed &gt; 5000 &amp;&amp; (!WHITE_BOX.isMethodCompiled(test, false) || level != compLevel)) {
709                         System.out.println(&quot;Temporarily disabling VerifyOops&quot;);
710                         try {
711                             WHITE_BOX.setBooleanVMFlag(&quot;VerifyOops&quot;, false);
712                             if (!stateCleared) {
713                                 WHITE_BOX.clearMethodState(test);
714                                 stateCleared = true;
715                             }
716                             verifier.invoke(this, false);
717                         } finally {
718                             WHITE_BOX.setBooleanVMFlag(&quot;VerifyOops&quot;, true);
719                             System.out.println(&quot;Re-enabled VerifyOops&quot;);
720                         }
721                     } else {
722                         verifier.invoke(this, false);
723                     }
724 
725                     boolean b = WHITE_BOX.isMethodCompiled(test, false);
726                     if (VERBOSE) {
727                         System.out.println(&quot;Is &quot; + test.getName() + &quot; compiled? &quot; + b);
728                     }
729                     if (b || XCOMP || STRESS_CC || !USE_COMPILER) {
730                         // Don&#39;t control compilation if -Xcomp is enabled, or if compiler is disabled
731                         break;
732                     }
733                     Asserts.assertTrue(OSR_TEST_TIMEOUT &lt; 0 || elapsed &lt; OSR_TEST_TIMEOUT, test + &quot; not compiled after &quot; + OSR_TEST_TIMEOUT + &quot; ms&quot;);
734                 }
735             } else {
736                 // Trigger compilation
737                 enqueueMethodForCompilation(test, compLevel);
738                 if (maybeCodeBufferOverflow &amp;&amp; !WHITE_BOX.isMethodCompiled(test, false)) {
739                     // Let&#39;s disable VerifyOops temporarily and retry.
740                     WHITE_BOX.setBooleanVMFlag(&quot;VerifyOops&quot;, false);
741                     WHITE_BOX.clearMethodState(test);
742                     enqueueMethodForCompilation(test, compLevel);
743                     WHITE_BOX.setBooleanVMFlag(&quot;VerifyOops&quot;, true);
744                 }
745                 if (!STRESS_CC &amp;&amp; USE_COMPILER) {
746                     Asserts.assertTrue(WHITE_BOX.isMethodCompiled(test, false), test + &quot; not compiled&quot;);
747                     int level = WHITE_BOX.getMethodCompilationLevel(test);
748                     Asserts.assertEQ(level, compLevel, &quot;Unexpected compilation level for &quot; + test);
749                 }
750                 // Check result
751                 verifier.invoke(this, false);
752             }
753             if (PRINT_TIMES || VERBOSE) {
754                 long endTime = System.nanoTime();
755                 long duration = (endTime - startTime);
756                 durations.put(duration, test.getName());
757                 if (VERBOSE) {
758                     System.out.println(&quot;Done &quot; + test.getName() + &quot;: &quot; + duration + &quot; ns = &quot; + (duration / 1000000) + &quot; ms&quot;);
759                 }
760             }
761             if (GC_AFTER) {
762                 System.out.println(&quot;doing GC&quot;);
763                 System.gc();
764             }
765         }
766 
767         // Print execution times
768         if (PRINT_TIMES) {
769           System.out.println(&quot;\n\nTest execution times:&quot;);
770           for (Map.Entry&lt;Long, String&gt; entry : durations.entrySet()) {
771               System.out.format(&quot;%-10s%15d ns\n&quot;, entry.getValue() + &quot;:&quot;, entry.getKey());
772           }
773         }
774     }
775 
776     // Get the appropriate compilation level for a method, according to the
777     // given annotation, as well as the current test scenario and VM options.
778     //
779     private int getCompLevel(Object annotation) {
780         int compLevel;
781         if (annotation == null) {
782             compLevel = COMP_LEVEL_ANY;
783         } else if (annotation instanceof Test) {
784             compLevel = ((Test)annotation).compLevel();
785         } else {
786             compLevel = ((ForceCompile)annotation).compLevel();
787         }
788 
789         return restrictCompLevel(compLevel);
790     }
791 
792     // Get the appropriate level as permitted by the test scenario and VM options.
793     private static int restrictCompLevel(int compLevel) {
794         if (compLevel == COMP_LEVEL_ANY) {
795             compLevel = COMP_LEVEL_FULL_OPTIMIZATION;
796         }
797         if (FLIP_C1_C2) {
798             // Effectively treat all (compLevel = C1) as (compLevel = C2), and
799             //                       (compLevel = C2) as (compLevel = C1).
800             if (compLevel == COMP_LEVEL_SIMPLE) {
801                 compLevel = COMP_LEVEL_FULL_OPTIMIZATION;
802             } else if (compLevel == COMP_LEVEL_FULL_OPTIMIZATION) {
803                 compLevel = COMP_LEVEL_SIMPLE;
804             }
805         }
806         if (!TEST_C1 &amp;&amp; compLevel &lt; COMP_LEVEL_FULL_OPTIMIZATION) {
807             compLevel = COMP_LEVEL_FULL_OPTIMIZATION;
808         }
809         if (TieredCompilation &amp;&amp; compLevel &gt; (int)TieredStopAtLevel) {
810             compLevel = (int)TieredStopAtLevel;
811         }
812         return compLevel;
813     }
814 
815     public static void enqueueMethodForCompilation(Method m, int level) {
816         level = restrictCompLevel(level);
817         if (VERBOSE) {
818             System.out.println(&quot;enqueueMethodForCompilation &quot; + m + &quot;, level = &quot; + level);
819         }
820         WHITE_BOX.enqueueMethodForCompilation(m, level);
821     }
822 
823     // Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to
824     // a normal method invocation when encountering flattened arrays.
825     static boolean isCompiledByC2(Method m) {
826         return USE_COMPILER &amp;&amp; !XCOMP &amp;&amp; WHITE_BOX.isMethodCompiled(m, false) &amp;&amp;
827             WHITE_BOX.getMethodCompilationLevel(m, false) &gt;= COMP_LEVEL_FULL_OPTIMIZATION;
828     }
829 }
    </pre>
  </body>
</html>