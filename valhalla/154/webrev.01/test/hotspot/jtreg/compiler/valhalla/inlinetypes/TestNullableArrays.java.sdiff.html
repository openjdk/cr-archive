<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestMethodHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  88         }
  89         for (int i = 1; i &lt; len; ++i) {
  90             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  91         }
  92         return va;
  93     }
  94 
  95     @DontCompile
  96     public void test1_verifier(boolean warmup) {
  97         int len = Math.abs(rI % 10);
  98         MyValue1.ref[] va = test1(len);
  99         if (len &gt; 0) {
 100             Asserts.assertEQ(va[0], null);
 101         }
 102         for (int i = 1; i &lt; len; ++i) {
 103             Asserts.assertEQ(va[i].hash(), hash());
 104         }
 105     }
 106 
 107     // Test creation of an inline type array and element access
<span class="line-modified"> 108     @Test</span>
<span class="line-removed"> 109     // TODO 8227588</span>
<span class="line-removed"> 110     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>
 111     public long test2() {
 112         MyValue1.ref[] va = new MyValue1.ref[1];
 113         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 114         return va[0].hash();
 115     }
 116 
 117     @DontCompile
 118     public void test2_verifier(boolean warmup) {
 119         long result = test2();
 120         Asserts.assertEQ(result, hash());
 121     }
 122 
 123     // Test receiving an inline type array from the interpreter,
 124     // updating its elements in a loop and computing a hash.
 125     @Test(failOn = ALLOCA)
 126     public long test3(MyValue1.ref[] va) {
 127         long result = 0;
 128         for (int i = 0; i &lt; 10; ++i) {
 129             if (va[i] != null) {
 130                 result += va[i].hash();
</pre>
<hr />
<pre>
 592     }
 593 
 594     // arraycopy() of inline type array with no oop field
 595     @Test
 596     public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {
 597         System.arraycopy(src, 0, dst, 0, src.length);
 598     }
 599 
 600     @DontCompile
 601     public void test21_verifier(boolean warmup) {
 602         int len = Math.abs(rI) % 10;
 603         MyValue2.ref[] src1 = new MyValue2.ref[len];
 604         MyValue2.ref[] src2 = new MyValue2.ref[len];
 605         MyValue2[]  src3 = new MyValue2[len];
 606         MyValue2[]  src4 = new MyValue2[len];
 607         MyValue2.ref[] dst1 = new MyValue2.ref[len];
 608         MyValue2[]  dst2 = new MyValue2[len];
 609         MyValue2.ref[] dst3 = new MyValue2.ref[len];
 610         MyValue2[]  dst4 = new MyValue2[len];
 611         if (len &gt; 0) {
<span class="line-modified"> 612             src2[0] = MyValue2.createWithFieldsInline(rI, true);</span>
 613         }
 614         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified"> 615             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
<span class="line-modified"> 616             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
<span class="line-modified"> 617             src3[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
<span class="line-modified"> 618             src4[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 619         }
 620         test21(src1, dst1);
 621         test21(src2, dst2);
 622         test21(src3, dst3);
 623         test21(src4, dst4);
 624         if (len &gt; 0) {
 625             Asserts.assertEQ(dst1[0], null);
 626             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 627             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 628             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 629         }
 630         for (int i = 1; i &lt; len; ++i) {
 631             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 632             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 633             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 634             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 635         }
 636     }
 637 
 638     // arraycopy() of inline type array with oop field and tightly
</pre>
<hr />
<pre>
 738             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 739         }
 740     }
 741 
 742     // short arraycopy() with no oop field
 743     @Test
 744     public void test25(MyValue2.ref[] src, MyValue2.ref[] dst) {
 745         System.arraycopy(src, 0, dst, 0, 8);
 746     }
 747 
 748     @DontCompile
 749     public void test25_verifier(boolean warmup) {
 750         MyValue2.ref[] src1 = new MyValue2.ref[8];
 751         MyValue2.ref[] src2 = new MyValue2.ref[8];
 752         MyValue2[]  src3 = new MyValue2[8];
 753         MyValue2[]  src4 = new MyValue2[8];
 754         MyValue2.ref[] dst1 = new MyValue2.ref[8];
 755         MyValue2[]  dst2 = new MyValue2[8];
 756         MyValue2.ref[] dst3 = new MyValue2.ref[8];
 757         MyValue2[]  dst4 = new MyValue2[8];
<span class="line-modified"> 758         src2[0] = MyValue2.createWithFieldsInline(rI, true);</span>
 759         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified"> 760             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
<span class="line-modified"> 761             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
<span class="line-modified"> 762             src3[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
<span class="line-modified"> 763             src4[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 764         }
 765         test25(src1, dst1);
 766         test25(src2, dst2);
 767         test25(src3, dst3);
 768         test25(src4, dst4);
 769         Asserts.assertEQ(dst1[0], null);
 770         Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 771         Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 772         Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 773         for (int i = 1; i &lt; 8; ++i) {
 774             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 775             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 776             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 777             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 778         }
 779     }
 780 
 781     // short arraycopy() with oop fields
 782     @Test
 783     public void test26(MyValue1.ref[] src, MyValue1.ref[] dst) {
</pre>
<hr />
<pre>
 841         }
 842         test27(src1, dst1);
 843         test27(src2, dst2);
 844         test27(src3, dst3);
 845         test27(src4, dst4);
 846         for (int i = 0; i &lt; 2; ++i) {
 847             Asserts.assertEQ(dst1[i], null);
 848             Asserts.assertEQ(dst2[i].hash(), MyValue1.default.hash());
 849             Asserts.assertEQ(dst3[i], null);
 850             Asserts.assertEQ(dst4[i].hash(), MyValue1.default.hash());
 851         }
 852         for (int i = 2; i &lt; 8; ++i) {
 853             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 854             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 855             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 856             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 857         }
 858     }
 859 
 860     // non escaping allocations
<span class="line-modified"> 861     // TODO ZGC does not support the clone intrinsic, remove this once JDK-8232896 is fixed</span>
 862     @Test(valid = ZGCOff, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 863     @Test(valid = ZGCOn)
 864     public MyValue2.ref test28() {
 865         MyValue2.ref[] src = new MyValue2.ref[10];
 866         src[0] = null;
 867         MyValue2.ref[] dst = (MyValue2.ref[])src.clone();
 868         return dst[0];
 869     }
 870 
 871     @DontCompile
 872     public void test28_verifier(boolean warmup) {
<span class="line-modified"> 873         MyValue2 v = MyValue2.createWithFieldsInline(rI, false);</span>
 874         MyValue2.ref result = test28();
 875         Asserts.assertEQ(result, null);
 876     }
 877 
 878     // non escaping allocations
 879     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
 880     @Test(failOn = ALLOCA + LOOP + TRAP)
 881     public MyValue2.ref test29(MyValue2.ref[] src) {
 882         MyValue2.ref[] dst = new MyValue2.ref[10];
 883         System.arraycopy(src, 0, dst, 0, 10);
 884         return dst[0];
 885     }
 886 
 887     @DontCompile
 888     public void test29_verifier(boolean warmup) {
 889         MyValue2.ref[] src1 = new MyValue2.ref[10];
 890         MyValue2.val[] src2 = new MyValue2.val[10];
 891         for (int i = 0; i &lt; 10; ++i) {
<span class="line-modified"> 892             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
<span class="line-modified"> 893             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 894         }
 895         MyValue2.ref v = test29(src1);
 896         Asserts.assertEQ(src1[0].hash(), v.hash());
 897         if (!warmup) {
 898             v = test29(src2);
 899             Asserts.assertEQ(src2[0].hash(), v.hash());
 900         }
 901     }
 902 
 903     // non escaping allocation with uncommon trap that needs
 904     // eliminated inline type array element as debug info
 905     @Test
 906     @Warmup(10000)
 907     public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {
 908         MyValue2.ref[] dst = new MyValue2.ref[10];
 909         System.arraycopy(src, 0, dst, 0, 10);
 910         if (flag) { }
 911         return dst[0];
 912     }
 913 
 914     @DontCompile
 915     public void test30_verifier(boolean warmup) {
 916         MyValue2.ref[] src1 = new MyValue2.ref[10];
 917         MyValue2.val[] src2 = new MyValue2.val[10];
 918         for (int i = 0; i &lt; 10; ++i) {
<span class="line-modified"> 919             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
<span class="line-modified"> 920             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 921         }
 922         MyValue2.ref v = test30(src1, !warmup);
 923         Asserts.assertEQ(src1[0].hash(), v.hash());
 924         if (!warmup) {
 925             v = test30(src2, true);
 926             Asserts.assertEQ(src2[0].hash(), v.hash());
 927         }
 928     }
 929 
 930     // non escaping allocation with memory phi
 931     @Test()
 932     // TODO 8227588
 933     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 934     public long test31(boolean b, boolean deopt) {
 935         MyValue2.ref[] src = new MyValue2.ref[1];
 936         if (b) {
<span class="line-modified"> 937             src[0] = MyValue2.createWithFieldsInline(rI, true);</span>
 938         } else {
<span class="line-modified"> 939             src[0] = MyValue2.createWithFieldsInline(rI, false);</span>
 940         }
 941         if (deopt) {
 942             // uncommon trap
 943             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test31&quot;));
 944         }
 945         return src[0].hash();
 946     }
 947 
 948     @DontCompile
 949     public void test31_verifier(boolean warmup) {
<span class="line-modified"> 950         MyValue2 v1 = MyValue2.createWithFieldsInline(rI, true);</span>
 951         long result1 = test31(true, !warmup);
 952         Asserts.assertEQ(result1, v1.hash());
<span class="line-modified"> 953         MyValue2 v2 = MyValue2.createWithFieldsInline(rI, false);</span>
 954         long result2 = test31(false, !warmup);
 955         Asserts.assertEQ(result2, v2.hash());
 956     }
 957 
 958     // Tests with Object arrays and clone/arraycopy
 959     // clone() as stub call
 960     @Test
 961     public Object[] test32(Object[] va) {
 962         return va.clone();
 963     }
 964 
 965     @DontCompile
 966     public void test32_verifier(boolean warmup) {
 967         int len = Math.abs(rI) % 10;
 968         MyValue1.ref[] va1 = new MyValue1.ref[len];
 969         MyValue1[] va2 = new MyValue1[len];
 970         for (int i = 1; i &lt; len; ++i) {
 971             va1[i] = testValue1;
 972             va2[i] = testValue1;
 973         }
</pre>
<hr />
<pre>
1118         }
1119         test35(src, dst, src.length);
1120         verify(src, dst);
1121         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test35&quot;)) {
1122             test35(src, dst, src.length);
1123             verify(src, dst);
1124         }
1125     }
1126 
1127     @Test
1128     public void test36(Object src, MyValue2.ref[] dst) {
1129         System.arraycopy(src, 0, dst, 0, dst.length);
1130     }
1131 
1132     @DontCompile
1133     public void test36_verifier(boolean warmup) {
1134         int len = Math.abs(rI) % 10;
1135         MyValue2.ref[] src = new MyValue2.ref[len];
1136         MyValue2.ref[] dst = new MyValue2.ref[len];
1137         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1138             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1139         }
1140         test36(src, dst);
1141         verify(src, dst);
1142         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test36&quot;)) {
1143             test36(src, dst);
1144             verify(src, dst);
1145         }
1146     }
1147 
1148     @Test
1149     public void test37(MyValue2.ref[] src, Object dst) {
1150         System.arraycopy(src, 0, dst, 0, src.length);
1151     }
1152 
1153     @DontCompile
1154     public void test37_verifier(boolean warmup) {
1155         int len = Math.abs(rI) % 10;
1156         MyValue2.ref[] src = new MyValue2.ref[len];
1157         MyValue2.ref[] dst = new MyValue2.ref[len];
1158         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1159             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1160         }
1161         test37(src, dst);
1162         verify(src, dst);
1163         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test37&quot;)) {
1164             test37(src, dst);
1165             verify(src, dst);
1166         }
1167     }
1168 
1169     @Test
1170     @Warmup(1) // Avoid early compilation
1171     public void test38(Object src, MyValue2.ref[] dst) {
1172         System.arraycopy(src, 0, dst, 0, dst.length);
1173     }
1174 
1175     @DontCompile
1176     public void test38_verifier(boolean warmup) {
1177         int len = Math.abs(rI) % 10;
1178         Object[] src = new Object[len];
1179         MyValue2.ref[] dst = new MyValue2.ref[len];
1180         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1181             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1182         }
1183         test38(src, dst);
1184         verify(dst, src);
1185         if (!warmup) {
1186             Method m = tests.get(&quot;TestNullableArrays::test38&quot;);
1187             assertDeoptimizedByC2(m);
1188             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1189             test38(src, dst);
1190             verify(dst, src);
1191             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1192                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1193             }
1194         }
1195     }
1196 
1197     @Test
1198     public void test39(MyValue2.ref[] src, Object dst) {
1199         System.arraycopy(src, 0, dst, 0, src.length);
1200     }
1201 
1202     @DontCompile
1203     public void test39_verifier(boolean warmup) {
1204         int len = Math.abs(rI) % 10;
1205         MyValue2.ref[] src = new MyValue2.ref[len];
1206         Object[] dst = new Object[len];
1207         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1208             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1209         }
1210         test39(src, dst);
1211         verify(src, dst);
1212         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test39&quot;)) {
1213             test39(src, dst);
1214             verify(src, dst);
1215         }
1216     }
1217 
1218     @Test
1219     @Warmup(1) // Avoid early compilation
1220     public void test40(Object[] src, Object dst) {
1221         System.arraycopy(src, 0, dst, 0, src.length);
1222     }
1223 
1224     @DontCompile
1225     public void test40_verifier(boolean warmup) {
1226         int len = Math.abs(rI) % 10;
1227         Object[] src = new Object[len];
1228         MyValue2.ref[] dst = new MyValue2.ref[len];
1229         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1230             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1231         }
1232         test40(src, dst);
1233         verify(dst, src);
1234         if (!warmup) {
1235             Method m = tests.get(&quot;TestNullableArrays::test40&quot;);
1236             assertDeoptimizedByC2(m);
1237             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1238             test40(src, dst);
1239             verify(dst, src);
1240             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1241                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1242             }
1243         }
1244     }
1245 
1246     @Test
1247     public void test41(Object src, Object[] dst) {
1248         System.arraycopy(src, 0, dst, 0, dst.length);
1249     }
1250 
1251     @DontCompile
1252     public void test41_verifier(boolean warmup) {
1253         int len = Math.abs(rI) % 10;
1254         MyValue2.ref[] src = new MyValue2.ref[len];
1255         Object[] dst = new Object[len];
1256         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1257             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1258         }
1259         test41(src, dst);
1260         verify(src, dst);
1261         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test41&quot;)) {
1262             test41(src, dst);
1263             verify(src, dst);
1264         }
1265     }
1266 
1267     @Test
1268     public void test42(Object[] src, Object[] dst) {
1269         System.arraycopy(src, 0, dst, 0, src.length);
1270     }
1271 
1272     @DontCompile
1273     public void test42_verifier(boolean warmup) {
1274         int len = Math.abs(rI) % 10;
1275         Object[] src = new Object[len];
1276         Object[] dst = new Object[len];
1277         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1278             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1279         }
1280         test42(src, dst);
1281         verify(src, dst);
1282         if (!warmup) {
1283             Method m = tests.get(&quot;TestNullableArrays::test42&quot;);
1284             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1285                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1286             }
1287         }
1288     }
1289 
1290     // short arraycopy()&#39;s
1291     @Test
1292     public void test43(Object src, Object dst) {
1293         System.arraycopy(src, 0, dst, 0, 8);
1294     }
1295 
1296     @DontCompile
1297     public void test43_verifier(boolean warmup) {
1298         MyValue1.ref[] src = new MyValue1.ref[8];
</pre>
<hr />
<pre>
1301             src[i] = testValue1;
1302         }
1303         test43(src, dst);
1304         verify(src, dst);
1305         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test43&quot;)) {
1306             test43(src, dst);
1307             verify(src, dst);
1308         }
1309     }
1310 
1311     @Test
1312     public void test44(Object src, MyValue2.ref[] dst) {
1313         System.arraycopy(src, 0, dst, 0, 8);
1314     }
1315 
1316     @DontCompile
1317     public void test44_verifier(boolean warmup) {
1318         MyValue2.ref[] src = new MyValue2.ref[8];
1319         MyValue2.ref[] dst = new MyValue2.ref[8];
1320         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1321             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1322         }
1323         test44(src, dst);
1324         verify(src, dst);
1325         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test44&quot;)) {
1326             test44(src, dst);
1327             verify(src, dst);
1328         }
1329     }
1330 
1331     @Test
1332     public void test45(MyValue2.ref[] src, Object dst) {
1333         System.arraycopy(src, 0, dst, 0, 8);
1334     }
1335 
1336     @DontCompile
1337     public void test45_verifier(boolean warmup) {
1338         MyValue2.ref[] src = new MyValue2.ref[8];
1339         MyValue2.ref[] dst = new MyValue2.ref[8];
1340         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1341             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1342         }
1343         test45(src, dst);
1344         verify(src, dst);
1345         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test45&quot;)) {
1346             test45(src, dst);
1347             verify(src, dst);
1348         }
1349     }
1350 
1351     @Test
1352     @Warmup(1) // Avoid early compilation
1353     public void test46(Object[] src, MyValue2.ref[] dst) {
1354         System.arraycopy(src, 0, dst, 0, 8);
1355     }
1356 
1357     @DontCompile
1358     public void test46_verifier(boolean warmup) {
1359         Object[] src = new Object[8];
1360         MyValue2.ref[] dst = new MyValue2.ref[8];
1361         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1362             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1363         }
1364         test46(src, dst);
1365         verify(dst, src);
1366         if (!warmup) {
1367             Method m = tests.get(&quot;TestNullableArrays::test46&quot;);
1368             assertDeoptimizedByC2(m);
1369             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1370             test46(src, dst);
1371             verify(dst, src);
1372             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1373                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1374             }
1375         }
1376     }
1377 
1378     @Test
1379     public void test47(MyValue2.ref[] src, Object[] dst) {
1380         System.arraycopy(src, 0, dst, 0, 8);
1381     }
1382 
1383     @DontCompile
1384     public void test47_verifier(boolean warmup) {
1385         MyValue2.ref[] src = new MyValue2.ref[8];
1386         Object[] dst = new Object[8];
1387         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1388             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1389         }
1390         test47(src, dst);
1391         verify(src, dst);
1392         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test47&quot;)) {
1393             test47(src, dst);
1394             verify(src, dst);
1395         }
1396     }
1397 
1398     @Test
1399     @Warmup(1) // Avoid early compilation
1400     public void test48(Object[] src, Object dst) {
1401         System.arraycopy(src, 0, dst, 0, 8);
1402     }
1403 
1404     @DontCompile
1405     public void test48_verifier(boolean warmup) {
1406         Object[] src = new Object[8];
1407         MyValue2.ref[] dst = new MyValue2.ref[8];
1408         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1409             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1410         }
1411         test48(src, dst);
1412         verify(dst, src);
1413         if (!warmup) {
1414             Method m = tests.get(&quot;TestNullableArrays::test48&quot;);
1415             assertDeoptimizedByC2(m);
1416             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1417             test48(src, dst);
1418             verify(dst, src);
1419             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1420                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1421             }
1422         }
1423     }
1424 
1425     @Test
1426     public void test49(Object src, Object[] dst) {
1427         System.arraycopy(src, 0, dst, 0, 8);
1428     }
1429 
1430     @DontCompile
1431     public void test49_verifier(boolean warmup) {
1432         MyValue2.ref[] src = new MyValue2.ref[8];
1433         Object[] dst = new Object[8];
1434         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1435             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1436         }
1437         test49(src, dst);
1438         verify(src, dst);
1439         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test49&quot;)) {
1440             test49(src, dst);
1441             verify(src, dst);
1442         }
1443     }
1444 
1445     @Test
1446     public void test50(Object[] src, Object[] dst) {
1447         System.arraycopy(src, 0, dst, 0, 8);
1448     }
1449 
1450     @DontCompile
1451     public void test50_verifier(boolean warmup) {
1452         Object[] src = new Object[8];
1453         Object[] dst = new Object[8];
1454         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1455             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1456         }
1457         test50(src, dst);
1458         verify(src, dst);
1459         if (!warmup) {
1460             Method m = tests.get(&quot;TestNullableArrays::test50&quot;);
1461             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1462                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1463             }
1464         }
1465     }
1466 
1467     @Test
1468     public MyValue1.ref[] test51(MyValue1.ref[] va) {
1469         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1470     }
1471 
1472     @DontCompile
1473     public void test51_verifier(boolean warmup) {
1474         int len = Math.abs(rI) % 10;
1475         MyValue1.ref[] va = new MyValue1.ref[len];
</pre>
<hr />
<pre>
1831         va[0] = va[1];
1832         return va;
1833     }
1834 
1835     @DontCompile
1836     public void test70_verifier(boolean warmup) {
1837         MyValue1.ref[] va = new MyValue1.ref[2];
1838         MyValue1.ref[] var = test70(va);
1839         for (int i = 0; i &lt; 2; ++i) {
1840             Asserts.assertEQ(va[i], var[i]);
1841         }
1842     }
1843 
1844     // EA needs to consider oop fields in flattened arrays
1845     @Test
1846     public void test71() {
1847         int len = 10;
1848         MyValue2.ref[] src = new MyValue2.ref[len];
1849         MyValue2.ref[] dst = new MyValue2.ref[len];
1850         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1851             src[i] = MyValue2.createWithFieldsDontInline(rI, (i % 2) == 0);</span>
1852         }
1853         System.arraycopy(src, 0, dst, 0, src.length);
1854         for (int i = 0; i &lt; len; ++i) {
1855             if (src[i] == null) {
1856                 Asserts.assertEQ(dst[i], null);
1857             } else {
1858                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1859             }
1860         }
1861     }
1862 
1863     @DontCompile
1864     public void test71_verifier(boolean warmup) {
1865         test71();
1866     }
1867 
1868     // Test EA with leaf call to &#39;store_unknown_value&#39;
1869     @Test
1870     public void test72(Object[] o, boolean b, Object element) {
1871         Object[] arr1 = new Object[10];
</pre>
</td>
<td>
<hr />
<pre>
  88         }
  89         for (int i = 1; i &lt; len; ++i) {
  90             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  91         }
  92         return va;
  93     }
  94 
  95     @DontCompile
  96     public void test1_verifier(boolean warmup) {
  97         int len = Math.abs(rI % 10);
  98         MyValue1.ref[] va = test1(len);
  99         if (len &gt; 0) {
 100             Asserts.assertEQ(va[0], null);
 101         }
 102         for (int i = 1; i &lt; len; ++i) {
 103             Asserts.assertEQ(va[i].hash(), hash());
 104         }
 105     }
 106 
 107     // Test creation of an inline type array and element access
<span class="line-modified"> 108     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>


 109     public long test2() {
 110         MyValue1.ref[] va = new MyValue1.ref[1];
 111         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 112         return va[0].hash();
 113     }
 114 
 115     @DontCompile
 116     public void test2_verifier(boolean warmup) {
 117         long result = test2();
 118         Asserts.assertEQ(result, hash());
 119     }
 120 
 121     // Test receiving an inline type array from the interpreter,
 122     // updating its elements in a loop and computing a hash.
 123     @Test(failOn = ALLOCA)
 124     public long test3(MyValue1.ref[] va) {
 125         long result = 0;
 126         for (int i = 0; i &lt; 10; ++i) {
 127             if (va[i] != null) {
 128                 result += va[i].hash();
</pre>
<hr />
<pre>
 590     }
 591 
 592     // arraycopy() of inline type array with no oop field
 593     @Test
 594     public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {
 595         System.arraycopy(src, 0, dst, 0, src.length);
 596     }
 597 
 598     @DontCompile
 599     public void test21_verifier(boolean warmup) {
 600         int len = Math.abs(rI) % 10;
 601         MyValue2.ref[] src1 = new MyValue2.ref[len];
 602         MyValue2.ref[] src2 = new MyValue2.ref[len];
 603         MyValue2[]  src3 = new MyValue2[len];
 604         MyValue2[]  src4 = new MyValue2[len];
 605         MyValue2.ref[] dst1 = new MyValue2.ref[len];
 606         MyValue2[]  dst2 = new MyValue2[len];
 607         MyValue2.ref[] dst3 = new MyValue2.ref[len];
 608         MyValue2[]  dst4 = new MyValue2[len];
 609         if (len &gt; 0) {
<span class="line-modified"> 610             src2[0] = MyValue2.createWithFieldsInline(rI, rD);</span>
 611         }
 612         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified"> 613             src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 614             src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 615             src3[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 616             src4[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 617         }
 618         test21(src1, dst1);
 619         test21(src2, dst2);
 620         test21(src3, dst3);
 621         test21(src4, dst4);
 622         if (len &gt; 0) {
 623             Asserts.assertEQ(dst1[0], null);
 624             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 625             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 626             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 627         }
 628         for (int i = 1; i &lt; len; ++i) {
 629             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 630             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 631             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 632             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 633         }
 634     }
 635 
 636     // arraycopy() of inline type array with oop field and tightly
</pre>
<hr />
<pre>
 736             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 737         }
 738     }
 739 
 740     // short arraycopy() with no oop field
 741     @Test
 742     public void test25(MyValue2.ref[] src, MyValue2.ref[] dst) {
 743         System.arraycopy(src, 0, dst, 0, 8);
 744     }
 745 
 746     @DontCompile
 747     public void test25_verifier(boolean warmup) {
 748         MyValue2.ref[] src1 = new MyValue2.ref[8];
 749         MyValue2.ref[] src2 = new MyValue2.ref[8];
 750         MyValue2[]  src3 = new MyValue2[8];
 751         MyValue2[]  src4 = new MyValue2[8];
 752         MyValue2.ref[] dst1 = new MyValue2.ref[8];
 753         MyValue2[]  dst2 = new MyValue2[8];
 754         MyValue2.ref[] dst3 = new MyValue2.ref[8];
 755         MyValue2[]  dst4 = new MyValue2[8];
<span class="line-modified"> 756         src2[0] = MyValue2.createWithFieldsInline(rI, rD);</span>
 757         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified"> 758             src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 759             src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 760             src3[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 761             src4[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 762         }
 763         test25(src1, dst1);
 764         test25(src2, dst2);
 765         test25(src3, dst3);
 766         test25(src4, dst4);
 767         Asserts.assertEQ(dst1[0], null);
 768         Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 769         Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 770         Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 771         for (int i = 1; i &lt; 8; ++i) {
 772             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 773             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 774             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 775             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 776         }
 777     }
 778 
 779     // short arraycopy() with oop fields
 780     @Test
 781     public void test26(MyValue1.ref[] src, MyValue1.ref[] dst) {
</pre>
<hr />
<pre>
 839         }
 840         test27(src1, dst1);
 841         test27(src2, dst2);
 842         test27(src3, dst3);
 843         test27(src4, dst4);
 844         for (int i = 0; i &lt; 2; ++i) {
 845             Asserts.assertEQ(dst1[i], null);
 846             Asserts.assertEQ(dst2[i].hash(), MyValue1.default.hash());
 847             Asserts.assertEQ(dst3[i], null);
 848             Asserts.assertEQ(dst4[i].hash(), MyValue1.default.hash());
 849         }
 850         for (int i = 2; i &lt; 8; ++i) {
 851             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 852             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 853             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 854             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 855         }
 856     }
 857 
 858     // non escaping allocations
<span class="line-modified"> 859     // TODO 8252027: Make sure this is optimized with ZGC</span>
 860     @Test(valid = ZGCOff, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 861     @Test(valid = ZGCOn)
 862     public MyValue2.ref test28() {
 863         MyValue2.ref[] src = new MyValue2.ref[10];
 864         src[0] = null;
 865         MyValue2.ref[] dst = (MyValue2.ref[])src.clone();
 866         return dst[0];
 867     }
 868 
 869     @DontCompile
 870     public void test28_verifier(boolean warmup) {
<span class="line-modified"> 871         MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);</span>
 872         MyValue2.ref result = test28();
 873         Asserts.assertEQ(result, null);
 874     }
 875 
 876     // non escaping allocations
 877     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
 878     @Test(failOn = ALLOCA + LOOP + TRAP)
 879     public MyValue2.ref test29(MyValue2.ref[] src) {
 880         MyValue2.ref[] dst = new MyValue2.ref[10];
 881         System.arraycopy(src, 0, dst, 0, 10);
 882         return dst[0];
 883     }
 884 
 885     @DontCompile
 886     public void test29_verifier(boolean warmup) {
 887         MyValue2.ref[] src1 = new MyValue2.ref[10];
 888         MyValue2.val[] src2 = new MyValue2.val[10];
 889         for (int i = 0; i &lt; 10; ++i) {
<span class="line-modified"> 890             src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 891             src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 892         }
 893         MyValue2.ref v = test29(src1);
 894         Asserts.assertEQ(src1[0].hash(), v.hash());
 895         if (!warmup) {
 896             v = test29(src2);
 897             Asserts.assertEQ(src2[0].hash(), v.hash());
 898         }
 899     }
 900 
 901     // non escaping allocation with uncommon trap that needs
 902     // eliminated inline type array element as debug info
 903     @Test
 904     @Warmup(10000)
 905     public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {
 906         MyValue2.ref[] dst = new MyValue2.ref[10];
 907         System.arraycopy(src, 0, dst, 0, 10);
 908         if (flag) { }
 909         return dst[0];
 910     }
 911 
 912     @DontCompile
 913     public void test30_verifier(boolean warmup) {
 914         MyValue2.ref[] src1 = new MyValue2.ref[10];
 915         MyValue2.val[] src2 = new MyValue2.val[10];
 916         for (int i = 0; i &lt; 10; ++i) {
<span class="line-modified"> 917             src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 918             src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 919         }
 920         MyValue2.ref v = test30(src1, !warmup);
 921         Asserts.assertEQ(src1[0].hash(), v.hash());
 922         if (!warmup) {
 923             v = test30(src2, true);
 924             Asserts.assertEQ(src2[0].hash(), v.hash());
 925         }
 926     }
 927 
 928     // non escaping allocation with memory phi
 929     @Test()
 930     // TODO 8227588
 931     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 932     public long test31(boolean b, boolean deopt) {
 933         MyValue2.ref[] src = new MyValue2.ref[1];
 934         if (b) {
<span class="line-modified"> 935             src[0] = MyValue2.createWithFieldsInline(rI, rD);</span>
 936         } else {
<span class="line-modified"> 937             src[0] = MyValue2.createWithFieldsInline(rI+1, rD+1);</span>
 938         }
 939         if (deopt) {
 940             // uncommon trap
 941             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test31&quot;));
 942         }
 943         return src[0].hash();
 944     }
 945 
 946     @DontCompile
 947     public void test31_verifier(boolean warmup) {
<span class="line-modified"> 948         MyValue2 v1 = MyValue2.createWithFieldsInline(rI, rD);</span>
 949         long result1 = test31(true, !warmup);
 950         Asserts.assertEQ(result1, v1.hash());
<span class="line-modified"> 951         MyValue2 v2 = MyValue2.createWithFieldsInline(rI+1, rD+1);</span>
 952         long result2 = test31(false, !warmup);
 953         Asserts.assertEQ(result2, v2.hash());
 954     }
 955 
 956     // Tests with Object arrays and clone/arraycopy
 957     // clone() as stub call
 958     @Test
 959     public Object[] test32(Object[] va) {
 960         return va.clone();
 961     }
 962 
 963     @DontCompile
 964     public void test32_verifier(boolean warmup) {
 965         int len = Math.abs(rI) % 10;
 966         MyValue1.ref[] va1 = new MyValue1.ref[len];
 967         MyValue1[] va2 = new MyValue1[len];
 968         for (int i = 1; i &lt; len; ++i) {
 969             va1[i] = testValue1;
 970             va2[i] = testValue1;
 971         }
</pre>
<hr />
<pre>
1116         }
1117         test35(src, dst, src.length);
1118         verify(src, dst);
1119         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test35&quot;)) {
1120             test35(src, dst, src.length);
1121             verify(src, dst);
1122         }
1123     }
1124 
1125     @Test
1126     public void test36(Object src, MyValue2.ref[] dst) {
1127         System.arraycopy(src, 0, dst, 0, dst.length);
1128     }
1129 
1130     @DontCompile
1131     public void test36_verifier(boolean warmup) {
1132         int len = Math.abs(rI) % 10;
1133         MyValue2.ref[] src = new MyValue2.ref[len];
1134         MyValue2.ref[] dst = new MyValue2.ref[len];
1135         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1136             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1137         }
1138         test36(src, dst);
1139         verify(src, dst);
1140         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test36&quot;)) {
1141             test36(src, dst);
1142             verify(src, dst);
1143         }
1144     }
1145 
1146     @Test
1147     public void test37(MyValue2.ref[] src, Object dst) {
1148         System.arraycopy(src, 0, dst, 0, src.length);
1149     }
1150 
1151     @DontCompile
1152     public void test37_verifier(boolean warmup) {
1153         int len = Math.abs(rI) % 10;
1154         MyValue2.ref[] src = new MyValue2.ref[len];
1155         MyValue2.ref[] dst = new MyValue2.ref[len];
1156         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1157             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1158         }
1159         test37(src, dst);
1160         verify(src, dst);
1161         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test37&quot;)) {
1162             test37(src, dst);
1163             verify(src, dst);
1164         }
1165     }
1166 
1167     @Test
1168     @Warmup(1) // Avoid early compilation
1169     public void test38(Object src, MyValue2.ref[] dst) {
1170         System.arraycopy(src, 0, dst, 0, dst.length);
1171     }
1172 
1173     @DontCompile
1174     public void test38_verifier(boolean warmup) {
1175         int len = Math.abs(rI) % 10;
1176         Object[] src = new Object[len];
1177         MyValue2.ref[] dst = new MyValue2.ref[len];
1178         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1179             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1180         }
1181         test38(src, dst);
1182         verify(dst, src);
1183         if (!warmup) {
1184             Method m = tests.get(&quot;TestNullableArrays::test38&quot;);
1185             assertDeoptimizedByC2(m);
1186             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1187             test38(src, dst);
1188             verify(dst, src);
1189             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1190                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1191             }
1192         }
1193     }
1194 
1195     @Test
1196     public void test39(MyValue2.ref[] src, Object dst) {
1197         System.arraycopy(src, 0, dst, 0, src.length);
1198     }
1199 
1200     @DontCompile
1201     public void test39_verifier(boolean warmup) {
1202         int len = Math.abs(rI) % 10;
1203         MyValue2.ref[] src = new MyValue2.ref[len];
1204         Object[] dst = new Object[len];
1205         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1206             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1207         }
1208         test39(src, dst);
1209         verify(src, dst);
1210         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test39&quot;)) {
1211             test39(src, dst);
1212             verify(src, dst);
1213         }
1214     }
1215 
1216     @Test
1217     @Warmup(1) // Avoid early compilation
1218     public void test40(Object[] src, Object dst) {
1219         System.arraycopy(src, 0, dst, 0, src.length);
1220     }
1221 
1222     @DontCompile
1223     public void test40_verifier(boolean warmup) {
1224         int len = Math.abs(rI) % 10;
1225         Object[] src = new Object[len];
1226         MyValue2.ref[] dst = new MyValue2.ref[len];
1227         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1228             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1229         }
1230         test40(src, dst);
1231         verify(dst, src);
1232         if (!warmup) {
1233             Method m = tests.get(&quot;TestNullableArrays::test40&quot;);
1234             assertDeoptimizedByC2(m);
1235             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1236             test40(src, dst);
1237             verify(dst, src);
1238             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1239                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1240             }
1241         }
1242     }
1243 
1244     @Test
1245     public void test41(Object src, Object[] dst) {
1246         System.arraycopy(src, 0, dst, 0, dst.length);
1247     }
1248 
1249     @DontCompile
1250     public void test41_verifier(boolean warmup) {
1251         int len = Math.abs(rI) % 10;
1252         MyValue2.ref[] src = new MyValue2.ref[len];
1253         Object[] dst = new Object[len];
1254         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1255             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1256         }
1257         test41(src, dst);
1258         verify(src, dst);
1259         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test41&quot;)) {
1260             test41(src, dst);
1261             verify(src, dst);
1262         }
1263     }
1264 
1265     @Test
1266     public void test42(Object[] src, Object[] dst) {
1267         System.arraycopy(src, 0, dst, 0, src.length);
1268     }
1269 
1270     @DontCompile
1271     public void test42_verifier(boolean warmup) {
1272         int len = Math.abs(rI) % 10;
1273         Object[] src = new Object[len];
1274         Object[] dst = new Object[len];
1275         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1276             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1277         }
1278         test42(src, dst);
1279         verify(src, dst);
1280         if (!warmup) {
1281             Method m = tests.get(&quot;TestNullableArrays::test42&quot;);
1282             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1283                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1284             }
1285         }
1286     }
1287 
1288     // short arraycopy()&#39;s
1289     @Test
1290     public void test43(Object src, Object dst) {
1291         System.arraycopy(src, 0, dst, 0, 8);
1292     }
1293 
1294     @DontCompile
1295     public void test43_verifier(boolean warmup) {
1296         MyValue1.ref[] src = new MyValue1.ref[8];
</pre>
<hr />
<pre>
1299             src[i] = testValue1;
1300         }
1301         test43(src, dst);
1302         verify(src, dst);
1303         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test43&quot;)) {
1304             test43(src, dst);
1305             verify(src, dst);
1306         }
1307     }
1308 
1309     @Test
1310     public void test44(Object src, MyValue2.ref[] dst) {
1311         System.arraycopy(src, 0, dst, 0, 8);
1312     }
1313 
1314     @DontCompile
1315     public void test44_verifier(boolean warmup) {
1316         MyValue2.ref[] src = new MyValue2.ref[8];
1317         MyValue2.ref[] dst = new MyValue2.ref[8];
1318         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1319             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1320         }
1321         test44(src, dst);
1322         verify(src, dst);
1323         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test44&quot;)) {
1324             test44(src, dst);
1325             verify(src, dst);
1326         }
1327     }
1328 
1329     @Test
1330     public void test45(MyValue2.ref[] src, Object dst) {
1331         System.arraycopy(src, 0, dst, 0, 8);
1332     }
1333 
1334     @DontCompile
1335     public void test45_verifier(boolean warmup) {
1336         MyValue2.ref[] src = new MyValue2.ref[8];
1337         MyValue2.ref[] dst = new MyValue2.ref[8];
1338         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1339             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1340         }
1341         test45(src, dst);
1342         verify(src, dst);
1343         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test45&quot;)) {
1344             test45(src, dst);
1345             verify(src, dst);
1346         }
1347     }
1348 
1349     @Test
1350     @Warmup(1) // Avoid early compilation
1351     public void test46(Object[] src, MyValue2.ref[] dst) {
1352         System.arraycopy(src, 0, dst, 0, 8);
1353     }
1354 
1355     @DontCompile
1356     public void test46_verifier(boolean warmup) {
1357         Object[] src = new Object[8];
1358         MyValue2.ref[] dst = new MyValue2.ref[8];
1359         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1360             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1361         }
1362         test46(src, dst);
1363         verify(dst, src);
1364         if (!warmup) {
1365             Method m = tests.get(&quot;TestNullableArrays::test46&quot;);
1366             assertDeoptimizedByC2(m);
1367             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1368             test46(src, dst);
1369             verify(dst, src);
1370             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1371                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1372             }
1373         }
1374     }
1375 
1376     @Test
1377     public void test47(MyValue2.ref[] src, Object[] dst) {
1378         System.arraycopy(src, 0, dst, 0, 8);
1379     }
1380 
1381     @DontCompile
1382     public void test47_verifier(boolean warmup) {
1383         MyValue2.ref[] src = new MyValue2.ref[8];
1384         Object[] dst = new Object[8];
1385         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1386             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1387         }
1388         test47(src, dst);
1389         verify(src, dst);
1390         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test47&quot;)) {
1391             test47(src, dst);
1392             verify(src, dst);
1393         }
1394     }
1395 
1396     @Test
1397     @Warmup(1) // Avoid early compilation
1398     public void test48(Object[] src, Object dst) {
1399         System.arraycopy(src, 0, dst, 0, 8);
1400     }
1401 
1402     @DontCompile
1403     public void test48_verifier(boolean warmup) {
1404         Object[] src = new Object[8];
1405         MyValue2.ref[] dst = new MyValue2.ref[8];
1406         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1407             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1408         }
1409         test48(src, dst);
1410         verify(dst, src);
1411         if (!warmup) {
1412             Method m = tests.get(&quot;TestNullableArrays::test48&quot;);
1413             assertDeoptimizedByC2(m);
1414             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1415             test48(src, dst);
1416             verify(dst, src);
1417             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1418                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1419             }
1420         }
1421     }
1422 
1423     @Test
1424     public void test49(Object src, Object[] dst) {
1425         System.arraycopy(src, 0, dst, 0, 8);
1426     }
1427 
1428     @DontCompile
1429     public void test49_verifier(boolean warmup) {
1430         MyValue2.ref[] src = new MyValue2.ref[8];
1431         Object[] dst = new Object[8];
1432         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1433             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1434         }
1435         test49(src, dst);
1436         verify(src, dst);
1437         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test49&quot;)) {
1438             test49(src, dst);
1439             verify(src, dst);
1440         }
1441     }
1442 
1443     @Test
1444     public void test50(Object[] src, Object[] dst) {
1445         System.arraycopy(src, 0, dst, 0, 8);
1446     }
1447 
1448     @DontCompile
1449     public void test50_verifier(boolean warmup) {
1450         Object[] src = new Object[8];
1451         Object[] dst = new Object[8];
1452         for (int i = 1; i &lt; 8; ++i) {
<span class="line-modified">1453             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1454         }
1455         test50(src, dst);
1456         verify(src, dst);
1457         if (!warmup) {
1458             Method m = tests.get(&quot;TestNullableArrays::test50&quot;);
1459             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1460                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1461             }
1462         }
1463     }
1464 
1465     @Test
1466     public MyValue1.ref[] test51(MyValue1.ref[] va) {
1467         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1468     }
1469 
1470     @DontCompile
1471     public void test51_verifier(boolean warmup) {
1472         int len = Math.abs(rI) % 10;
1473         MyValue1.ref[] va = new MyValue1.ref[len];
</pre>
<hr />
<pre>
1829         va[0] = va[1];
1830         return va;
1831     }
1832 
1833     @DontCompile
1834     public void test70_verifier(boolean warmup) {
1835         MyValue1.ref[] va = new MyValue1.ref[2];
1836         MyValue1.ref[] var = test70(va);
1837         for (int i = 0; i &lt; 2; ++i) {
1838             Asserts.assertEQ(va[i], var[i]);
1839         }
1840     }
1841 
1842     // EA needs to consider oop fields in flattened arrays
1843     @Test
1844     public void test71() {
1845         int len = 10;
1846         MyValue2.ref[] src = new MyValue2.ref[len];
1847         MyValue2.ref[] dst = new MyValue2.ref[len];
1848         for (int i = 1; i &lt; len; ++i) {
<span class="line-modified">1849             src[i] = MyValue2.createWithFieldsDontInline(rI+i, rD+i);</span>
1850         }
1851         System.arraycopy(src, 0, dst, 0, src.length);
1852         for (int i = 0; i &lt; len; ++i) {
1853             if (src[i] == null) {
1854                 Asserts.assertEQ(dst[i], null);
1855             } else {
1856                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1857             }
1858         }
1859     }
1860 
1861     @DontCompile
1862     public void test71_verifier(boolean warmup) {
1863         test71();
1864     }
1865 
1866     // Test EA with leaf call to &#39;store_unknown_value&#39;
1867     @Test
1868     public void test72(Object[] o, boolean b, Object element) {
1869         Object[] arr1 = new Object[10];
</pre>
</td>
</tr>
</table>
<center><a href="TestMethodHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>