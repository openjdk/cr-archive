<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/inlinetypes/InlineTypeTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="MyValue1.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/inlinetypes/InlineTypeTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  */
 23 
 24 package compiler.valhalla.inlinetypes;
 25 
 26 import compiler.whitebox.CompilerWhiteBoxTest;
 27 import jdk.test.lib.Asserts;
 28 import jdk.test.lib.management.InputArguments;
 29 import jdk.test.lib.Platform;
 30 import jdk.test.lib.process.ProcessTools;
 31 import jdk.test.lib.process.OutputAnalyzer;
 32 import jdk.test.lib.Utils;
 33 import sun.hotspot.WhiteBox;
 34 
 35 import java.lang.annotation.Retention;
 36 import java.lang.annotation.RetentionPolicy;
 37 import java.lang.annotation.Repeatable;
 38 import java.lang.invoke.*;
 39 import java.lang.reflect.Method;
 40 import java.util.ArrayList;
 41 import java.util.Arrays;


 42 import java.util.Hashtable;
 43 import java.util.LinkedHashMap;
 44 import java.util.List;
 45 import java.util.Map;
 46 import java.util.regex.Matcher;
 47 import java.util.regex.Pattern;
 48 import java.util.stream.Stream;
 49 import java.util.TreeMap;
 50 import java.util.function.BooleanSupplier;
 51 
 52 // Mark method as test
 53 @Retention(RetentionPolicy.RUNTIME)
 54 @Repeatable(Tests.class)
 55 @interface Test {
 56     // Regular expression used to match forbidden IR nodes
 57     // in the C2 IR emitted for this test.
 58     String failOn() default &quot;&quot;;
 59     // Regular expressions used to match and count IR nodes.
 60     String[] match() default { };
 61     int[] matchCount() default { };
</pre>
<hr />
<pre>
105 
106 public abstract class InlineTypeTest {
107     protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
108 
109     protected static final int COMP_LEVEL_ANY               = -2;
110     protected static final int COMP_LEVEL_ALL               = -2;
111     protected static final int COMP_LEVEL_AOT               = -1;
112     protected static final int COMP_LEVEL_NONE              =  0;
113     protected static final int COMP_LEVEL_SIMPLE            =  1;     // C1
114     protected static final int COMP_LEVEL_LIMITED_PROFILE   =  2;     // C1, invocation &amp; backedge counters
115     protected static final int COMP_LEVEL_FULL_PROFILE      =  3;     // C1, invocation &amp; backedge counters + mdo
116     protected static final int COMP_LEVEL_FULL_OPTIMIZATION =  4;     // C2 or JVMCI
117 
118     protected static final boolean TieredCompilation = (Boolean)WHITE_BOX.getVMFlag(&quot;TieredCompilation&quot;);
119     protected static final long TieredStopAtLevel = (Long)WHITE_BOX.getVMFlag(&quot;TieredStopAtLevel&quot;);
120     static final boolean TEST_C1 = TieredCompilation &amp;&amp; TieredStopAtLevel &lt; COMP_LEVEL_FULL_OPTIMIZATION;
121 
122     // Random test values
123     public static final int  rI = Utils.getRandomInstance().nextInt() % 1000;
124     public static final long rL = Utils.getRandomInstance().nextLong() % 1000;

125 
126     // User defined settings
127     protected static final boolean XCOMP = Platform.isComp();
128     private static final boolean PRINT_GRAPH = true;
129     private static final boolean VERBOSE = Boolean.parseBoolean(System.getProperty(&quot;Verbose&quot;, &quot;false&quot;));
130     private static final boolean PRINT_TIMES = Boolean.parseBoolean(System.getProperty(&quot;PrintTimes&quot;, &quot;false&quot;));
131     private static final boolean COMPILE_COMMANDS = Boolean.parseBoolean(System.getProperty(&quot;CompileCommands&quot;, &quot;true&quot;));
132     private static       boolean VERIFY_IR = Boolean.parseBoolean(System.getProperty(&quot;VerifyIR&quot;, &quot;true&quot;)) &amp;&amp; !XCOMP &amp;&amp; !TEST_C1 &amp;&amp; COMPILE_COMMANDS;
133     private static final boolean VERIFY_VM = Boolean.parseBoolean(System.getProperty(&quot;VerifyVM&quot;, &quot;false&quot;));
134     private static final String SCENARIOS = System.getProperty(&quot;Scenarios&quot;, &quot;&quot;);
135     private static final String TESTLIST = System.getProperty(&quot;Testlist&quot;, &quot;&quot;);
136     private static final String EXCLUDELIST = System.getProperty(&quot;Exclude&quot;, &quot;&quot;);
137     private static final int WARMUP = Integer.parseInt(System.getProperty(&quot;Warmup&quot;, &quot;251&quot;));
138     private static final boolean DUMP_REPLAY = Boolean.parseBoolean(System.getProperty(&quot;DumpReplay&quot;, &quot;false&quot;));
139     private static final boolean FLIP_C1_C2 = Boolean.parseBoolean(System.getProperty(&quot;FlipC1C2&quot;, &quot;false&quot;));
140     private static final boolean GC_AFTER = Boolean.parseBoolean(System.getProperty(&quot;GCAfter&quot;, &quot;false&quot;));
141     private static final int OSR_TEST_TIMEOUT = Integer.parseInt(System.getProperty(&quot;OSRTestTimeOut&quot;, &quot;5000&quot;));
142     protected static final boolean STRESS_CC = Boolean.parseBoolean(System.getProperty(&quot;StressCC&quot;, &quot;false&quot;));

143 
144     // &quot;jtreg -DXcomp=true&quot; runs all the scenarios with -Xcomp. This is faster than &quot;jtreg -javaoptions:-Xcomp&quot;.
145     protected static final boolean RUN_SCENARIOS_WITH_XCOMP = Boolean.parseBoolean(System.getProperty(&quot;Xcomp&quot;, &quot;false&quot;));
146 
147     // Pre-defined settings
148     private static final String[] defaultFlags = {
149         &quot;-XX:-BackgroundCompilation&quot;};
150     private static final String[] compileCommandFlags = {
151         &quot;-XX:CompileCommand=quiet&quot;,
152         &quot;-XX:CompileCommand=compileonly,java.lang.invoke.*::*&quot;,
153         &quot;-XX:CompileCommand=compileonly,java.lang.Long::sum&quot;,
154         &quot;-XX:CompileCommand=compileonly,java.lang.Object::&lt;init&gt;&quot;,
155         &quot;-XX:CompileCommand=inline,compiler.valhalla.inlinetypes.MyValue*::&lt;init&gt;&quot;,
156         &quot;-XX:CompileCommand=compileonly,compiler.valhalla.inlinetypes.*::*&quot;};
157     private static final String[] printFlags = {
158         &quot;-XX:+PrintCompilation&quot;, &quot;-XX:+PrintIdeal&quot;, &quot;-XX:+UnlockDiagnosticVMOptions&quot;, &quot;-XX:+PrintOptoAssembly&quot;};
159     private static final String[] verifyFlags = {
160         &quot;-XX:+VerifyOops&quot;, &quot;-XX:+VerifyStack&quot;, &quot;-XX:+VerifyLastFrame&quot;, &quot;-XX:+VerifyBeforeGC&quot;, &quot;-XX:+VerifyAfterGC&quot;,
161         &quot;-XX:+VerifyDuringGC&quot;, &quot;-XX:+VerifyAdapterSharing&quot;};
162 
163     protected static final int InlineTypePassFieldsAsArgsOn = 0x1;
164     protected static final int InlineTypePassFieldsAsArgsOff = 0x2;
165     protected static final int InlineTypeArrayFlattenOn = 0x4;
166     protected static final int InlineTypeArrayFlattenOff = 0x8;
167     protected static final int InlineTypeReturnedAsFieldsOn = 0x10;
168     protected static final int InlineTypeReturnedAsFieldsOff = 0x20;
169     protected static final int AlwaysIncrementalInlineOn = 0x40;
170     protected static final int AlwaysIncrementalInlineOff = 0x80;
171     protected static final int G1GCOn = 0x100;
172     protected static final int G1GCOff = 0x200;
173     protected static final int ZGCOn = 0x400;
174     protected static final int ZGCOff = 0x800;
175     protected static final int ArrayLoadStoreProfileOn = 0x1000;
176     protected static final int ArrayLoadStoreProfileOff = 0x2000;
177     protected static final int TypeProfileOn = 0x4000;
178     protected static final int TypeProfileOff = 0x8000;
179     protected static final boolean InlineTypePassFieldsAsArgs = (Boolean)WHITE_BOX.getVMFlag(&quot;InlineTypePassFieldsAsArgs&quot;);
<span class="line-modified">180     protected static final boolean InlineTypeArrayFlatten = (WHITE_BOX.getIntxVMFlag(&quot;FlatArrayElementMaxSize&quot;) == -1); // FIXME - fix this if default of FlatArrayElementMaxSize is changed</span>
181     protected static final boolean InlineTypeReturnedAsFields = (Boolean)WHITE_BOX.getVMFlag(&quot;InlineTypeReturnedAsFields&quot;);
182     protected static final boolean AlwaysIncrementalInline = (Boolean)WHITE_BOX.getVMFlag(&quot;AlwaysIncrementalInline&quot;);
183     protected static final boolean G1GC = (Boolean)WHITE_BOX.getVMFlag(&quot;UseG1GC&quot;);
184     protected static final boolean ZGC = (Boolean)WHITE_BOX.getVMFlag(&quot;UseZGC&quot;);
185     protected static final boolean VerifyOops = (Boolean)WHITE_BOX.getVMFlag(&quot;VerifyOops&quot;);
186     protected static final boolean UseArrayLoadStoreProfile = (Boolean)WHITE_BOX.getVMFlag(&quot;UseArrayLoadStoreProfile&quot;);
187     protected static final long TypeProfileLevel = (Long)WHITE_BOX.getVMFlag(&quot;TypeProfileLevel&quot;);
188 
189     protected static final Hashtable&lt;String, Method&gt; tests = new Hashtable&lt;String, Method&gt;();
190     protected static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(&quot;UseCompiler&quot;);
191     protected static final boolean PRINT_IDEAL  = WHITE_BOX.getBooleanVMFlag(&quot;PrintIdeal&quot;);
192 
193     // Regular expressions used to match nodes in the PrintIdeal output
194     protected static final String START = &quot;(\\d+\\t(.*&quot;;
195     protected static final String MID = &quot;.*)+\\t===.*&quot;;
196     protected static final String END = &quot;)|&quot;;
197     // Generic allocation
198     protected static final String ALLOC_G  = &quot;(.*call,static  wrapper for: _new_instance_Java&quot; + END;
199     protected static final String ALLOCA_G = &quot;(.*call,static  wrapper for: _new_array_Java&quot; + END;
200     // Inline type allocation
201     protected static final String ALLOC  = &quot;(.*precise klass compiler/valhalla/inlinetypes/MyValue.*\\R(.*(movl|xorl|nop|spill).*\\R)*.*_new_instance_Java&quot; + END;
202     protected static final String ALLOCA = &quot;(.*precise klass \\[(L|Q)compiler/valhalla/inlinetypes/MyValue.*\\R(.*(movl|xorl|nop|spill).*\\R)*.*_new_array_Java&quot; + END;
203     protected static final String LOAD   = START + &quot;Load(B|S|I|L|F|D|P|N)&quot; + MID + &quot;@compiler/valhalla/inlinetypes/MyValue.*&quot; + END;
204     protected static final String LOADK  = START + &quot;LoadK&quot; + MID + END;
205     protected static final String STORE  = START + &quot;Store(B|C|S|I|L|F|D|P|N)&quot; + MID + &quot;@compiler/valhalla/inlinetypes/MyValue.*&quot; + END;
206     protected static final String LOOP   = START + &quot;Loop&quot; + MID + &quot;&quot; + END;
207     protected static final String COUNTEDLOOP = START + &quot;CountedLoop\\b&quot; + MID + &quot;&quot; + END;
208     protected static final String COUNTEDLOOP_MAIN = START + &quot;CountedLoop\\b&quot; + MID + &quot;main&quot; + END;
209     protected static final String TRAP   = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*(unstable_if|predicate)&quot; + END;
210     protected static final String RETURN = START + &quot;Return&quot; + MID + &quot;returns&quot; + END;
211     protected static final String LINKTOSTATIC = START + &quot;CallStaticJava&quot; + MID + &quot;linkToStatic&quot; + END;
212     protected static final String NPE = START + &quot;CallStaticJava&quot; + MID + &quot;null_check&quot; + END;
213     protected static final String CALL = START + &quot;CallStaticJava&quot; + MID + END;
214     protected static final String STORE_INLINE_FIELDS = START + &quot;CallStaticJava&quot; + MID + &quot;store_inline_type_fields&quot; + END;
215     protected static final String SCOBJ = &quot;(.*# ScObj.*&quot; + END;
216     protected static final String LOAD_UNKNOWN_INLINE = &quot;(.*call_leaf,runtime  load_unknown_inline.*&quot; + END;
217     protected static final String STORE_UNKNOWN_INLINE = &quot;(.*call_leaf,runtime  store_unknown_inline.*&quot; + END;
218     protected static final String INLINE_ARRAY_NULL_GUARD = &quot;(.*call,static  wrapper for: uncommon_trap.*reason=&#39;null_check&#39; action=&#39;none&#39;.*&quot; + END;

219     protected static final String CLASS_CHECK_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*class_check&quot; + END;
220     protected static final String NULL_CHECK_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*null_check&quot; + END;
221     protected static final String RANGE_CHECK_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*range_check&quot; + END;
222     protected static final String UNHANDLED_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*unhandled&quot; + END;
223     protected static final String PREDICATE_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*predicate&quot; + END;
224     protected static final String MEMBAR = START + &quot;MemBar&quot; + MID + END;
225     protected static final String CHECKCAST_ARRAY = &quot;(cmp.*precise klass \\[(L|Q)compiler/valhalla/inlinetypes/MyValue.*&quot; + END;
226 
227     public static String[] concat(String prefix[], String... extra) {
228         ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
229         if (prefix != null) {
230             for (String s : prefix) {
231                 list.add(s);
232             }
233         }
234         if (extra != null) {
235             for (String s : extra) {
236                 list.add(s);
237             }
238         }
</pre>
<hr />
<pre>
387                     }
388                 }
389             }
390         }
391         return exclude;
392     }
393 
394     protected InlineTypeTest() {
395         List&lt;String&gt; list = null;
396         if (!TESTLIST.isEmpty()) {
397            list = Arrays.asList(TESTLIST.split(&quot;,&quot;));
398         }
399         List&lt;String&gt; exclude = buildExcludeList();
400 
401         // Gather all test methods and put them in Hashtable
402         for (Method m : getClass().getDeclaredMethods()) {
403             Test[] annos = m.getAnnotationsByType(Test.class);
404             if (annos.length != 0 &amp;&amp;
405                 ((list == null || list.contains(m.getName())) &amp;&amp; (exclude == null || !exclude.contains(m.getName())))) {
406                 tests.put(getClass().getSimpleName() + &quot;::&quot; + m.getName(), m);







407             }
408         }
409     }
410 
411     protected void run(String[] args, Class&lt;?&gt;... classes) throws Throwable {
412         if (args.length == 0) {
413             // Spawn a new VM instance
414             execute_vm();
415         } else {
416             // Execute tests in the VM spawned by the above code.
417             Asserts.assertTrue(args.length == 1 &amp;&amp; args[0].equals(&quot;run&quot;), &quot;must be&quot;);
418             run(classes);
419         }
420     }
421 
422     private void execute_vm() throws Throwable {
423         Asserts.assertFalse(tests.isEmpty(), &quot;no tests to execute&quot;);
424         String[] vmInputArgs = InputArguments.getVmInputArgs();
425         for (String arg : vmInputArgs) {
426             if (arg.startsWith(&quot;-XX:CompileThreshold&quot;)) {
</pre>
<hr />
<pre>
559             }
560             String regexFail = anno.failOn();
561             if (!regexFail.isEmpty()) {
562                 Pattern pattern = Pattern.compile(regexFail.substring(0, regexFail.length()-1));
563                 Matcher matcher = pattern.matcher(graph);
564                 boolean found = matcher.find();
565                 Asserts.assertFalse(found, &quot;Graph for &#39;&quot; + testName + &quot;&#39; contains forbidden node:\n&quot; + (found ? matcher.group() : &quot;&quot;));
566             }
567             String[] regexMatch = anno.match();
568             int[] matchCount = anno.matchCount();
569             for (int i = 0; i &lt; regexMatch.length; ++i) {
570                 Pattern pattern = Pattern.compile(regexMatch[i].substring(0, regexMatch[i].length()-1));
571                 Matcher matcher = pattern.matcher(graph);
572                 int count = 0;
573                 String nodes = &quot;&quot;;
574                 while (matcher.find()) {
575                     count++;
576                     nodes += matcher.group() + &quot;\n&quot;;
577                 }
578                 if (matchCount[i] &lt; 0) {
<span class="line-modified">579                     Asserts.assertLTE(Math.abs(matchCount[i]), count, &quot;Graph for &#39;&quot; + testName + &quot;&#39; contains different number of match nodes (expected &lt;= &quot; + matchCount[i] + &quot; but got &quot; + count + &quot;):\n&quot; + nodes);</span>
580                 } else {
581                     Asserts.assertEQ(matchCount[i], count, &quot;Graph for &#39;&quot; + testName + &quot;&#39; contains different number of match nodes (expected &quot; + matchCount[i] + &quot; but got &quot; + count + &quot;):\n&quot; + nodes);
582                 }
583             }
584             tests.remove(testName);
585             System.out.println(testName + &quot; passed&quot;);
586         }
587         // Check if all tests were compiled
588         if (tests.size() != 0) {
589             for (String name : tests.keySet()) {
590                 System.out.println(&quot;Test &#39;&quot; + name + &quot;&#39; not compiled!&quot;);
591             }
592             throw new RuntimeException(&quot;Not all tests were compiled&quot;);
593         }
594     }
595 
596     private void setup(Class&lt;?&gt; clazz) {
597         if (XCOMP) {
598             // Don&#39;t control compilation if -Xcomp is enabled
599             return;
</pre>
<hr />
<pre>
640                 int compLevel = getCompLevel(m.getAnnotation(ForceCompile.class));
641                 enqueueMethodForCompilation(m, compLevel);
642             }
643         }
644         // Compile class initializers
645         int compLevel = getCompLevel(null);
646         WHITE_BOX.enqueueInitializerForCompilation(clazz, compLevel);
647     }
648 
649     private void run(Class&lt;?&gt;... classes) throws Exception {
650         if (USE_COMPILER &amp;&amp; PRINT_IDEAL &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
651             System.out.println(&quot;PrintIdeal enabled&quot;);
652         }
653         System.out.format(&quot;rI = %d, rL = %d\n&quot;, rI, rL);
654 
655         setup(getClass());
656         for (Class&lt;?&gt; clazz : classes) {
657             setup(clazz);
658         }
659 
<span class="line-removed">660         // Execute tests</span>
661         TreeMap&lt;Long, String&gt; durations = (PRINT_TIMES || VERBOSE) ? new TreeMap&lt;Long, String&gt;() : null;
<span class="line-modified">662         for (Method test : tests.values()) {</span>





663             if (VERBOSE) {
664                 System.out.println(&quot;Starting &quot; + test.getName());
665             }
666             TempSkipForC1 c1skip = test.getAnnotation(TempSkipForC1.class);
667             if (TEST_C1 &amp;&amp; c1skip != null) {
668                 System.out.println(&quot;Skipped &quot; + test.getName() + &quot; for C1 testing: &quot; + c1skip.reason());
669                 continue;
670             }
671             long startTime = System.nanoTime();
672             Method verifier = getClass().getMethod(test.getName() + &quot;_verifier&quot;, boolean.class);
673             // Warmup using verifier method
674             Warmup anno = test.getAnnotation(Warmup.class);
675             int warmup = anno == null ? WARMUP : anno.value();
676             for (int i = 0; i &lt; warmup; ++i) {
677                 verifier.invoke(this, true);
678             }
679             boolean osrOnly = (test.getAnnotation(OSRCompileOnly.class) != null);
680             int compLevel = getCompLevel(test.getAnnotation(Test.class));
681 
682             // C1 generates a lot of code when VerifyOops is enabled and may run out of space (for a small
</pre>
</td>
<td>
<hr />
<pre>
 22  */
 23 
 24 package compiler.valhalla.inlinetypes;
 25 
 26 import compiler.whitebox.CompilerWhiteBoxTest;
 27 import jdk.test.lib.Asserts;
 28 import jdk.test.lib.management.InputArguments;
 29 import jdk.test.lib.Platform;
 30 import jdk.test.lib.process.ProcessTools;
 31 import jdk.test.lib.process.OutputAnalyzer;
 32 import jdk.test.lib.Utils;
 33 import sun.hotspot.WhiteBox;
 34 
 35 import java.lang.annotation.Retention;
 36 import java.lang.annotation.RetentionPolicy;
 37 import java.lang.annotation.Repeatable;
 38 import java.lang.invoke.*;
 39 import java.lang.reflect.Method;
 40 import java.util.ArrayList;
 41 import java.util.Arrays;
<span class="line-added"> 42 import java.util.Collection;</span>
<span class="line-added"> 43 import java.util.Collections;</span>
 44 import java.util.Hashtable;
 45 import java.util.LinkedHashMap;
 46 import java.util.List;
 47 import java.util.Map;
 48 import java.util.regex.Matcher;
 49 import java.util.regex.Pattern;
 50 import java.util.stream.Stream;
 51 import java.util.TreeMap;
 52 import java.util.function.BooleanSupplier;
 53 
 54 // Mark method as test
 55 @Retention(RetentionPolicy.RUNTIME)
 56 @Repeatable(Tests.class)
 57 @interface Test {
 58     // Regular expression used to match forbidden IR nodes
 59     // in the C2 IR emitted for this test.
 60     String failOn() default &quot;&quot;;
 61     // Regular expressions used to match and count IR nodes.
 62     String[] match() default { };
 63     int[] matchCount() default { };
</pre>
<hr />
<pre>
107 
108 public abstract class InlineTypeTest {
109     protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
110 
111     protected static final int COMP_LEVEL_ANY               = -2;
112     protected static final int COMP_LEVEL_ALL               = -2;
113     protected static final int COMP_LEVEL_AOT               = -1;
114     protected static final int COMP_LEVEL_NONE              =  0;
115     protected static final int COMP_LEVEL_SIMPLE            =  1;     // C1
116     protected static final int COMP_LEVEL_LIMITED_PROFILE   =  2;     // C1, invocation &amp; backedge counters
117     protected static final int COMP_LEVEL_FULL_PROFILE      =  3;     // C1, invocation &amp; backedge counters + mdo
118     protected static final int COMP_LEVEL_FULL_OPTIMIZATION =  4;     // C2 or JVMCI
119 
120     protected static final boolean TieredCompilation = (Boolean)WHITE_BOX.getVMFlag(&quot;TieredCompilation&quot;);
121     protected static final long TieredStopAtLevel = (Long)WHITE_BOX.getVMFlag(&quot;TieredStopAtLevel&quot;);
122     static final boolean TEST_C1 = TieredCompilation &amp;&amp; TieredStopAtLevel &lt; COMP_LEVEL_FULL_OPTIMIZATION;
123 
124     // Random test values
125     public static final int  rI = Utils.getRandomInstance().nextInt() % 1000;
126     public static final long rL = Utils.getRandomInstance().nextLong() % 1000;
<span class="line-added">127     public static final double rD = Utils.getRandomInstance().nextDouble() % 1000;</span>
128 
129     // User defined settings
130     protected static final boolean XCOMP = Platform.isComp();
131     private static final boolean PRINT_GRAPH = true;
132     private static final boolean VERBOSE = Boolean.parseBoolean(System.getProperty(&quot;Verbose&quot;, &quot;false&quot;));
133     private static final boolean PRINT_TIMES = Boolean.parseBoolean(System.getProperty(&quot;PrintTimes&quot;, &quot;false&quot;));
134     private static final boolean COMPILE_COMMANDS = Boolean.parseBoolean(System.getProperty(&quot;CompileCommands&quot;, &quot;true&quot;));
135     private static       boolean VERIFY_IR = Boolean.parseBoolean(System.getProperty(&quot;VerifyIR&quot;, &quot;true&quot;)) &amp;&amp; !XCOMP &amp;&amp; !TEST_C1 &amp;&amp; COMPILE_COMMANDS;
136     private static final boolean VERIFY_VM = Boolean.parseBoolean(System.getProperty(&quot;VerifyVM&quot;, &quot;false&quot;));
137     private static final String SCENARIOS = System.getProperty(&quot;Scenarios&quot;, &quot;&quot;);
138     private static final String TESTLIST = System.getProperty(&quot;Testlist&quot;, &quot;&quot;);
139     private static final String EXCLUDELIST = System.getProperty(&quot;Exclude&quot;, &quot;&quot;);
140     private static final int WARMUP = Integer.parseInt(System.getProperty(&quot;Warmup&quot;, &quot;251&quot;));
141     private static final boolean DUMP_REPLAY = Boolean.parseBoolean(System.getProperty(&quot;DumpReplay&quot;, &quot;false&quot;));
142     private static final boolean FLIP_C1_C2 = Boolean.parseBoolean(System.getProperty(&quot;FlipC1C2&quot;, &quot;false&quot;));
143     private static final boolean GC_AFTER = Boolean.parseBoolean(System.getProperty(&quot;GCAfter&quot;, &quot;false&quot;));
144     private static final int OSR_TEST_TIMEOUT = Integer.parseInt(System.getProperty(&quot;OSRTestTimeOut&quot;, &quot;5000&quot;));
145     protected static final boolean STRESS_CC = Boolean.parseBoolean(System.getProperty(&quot;StressCC&quot;, &quot;false&quot;));
<span class="line-added">146     private static final boolean SHUFFLE_TESTS = Boolean.parseBoolean(System.getProperty(&quot;ShuffleTests&quot;, &quot;false&quot;));</span>
147 
148     // &quot;jtreg -DXcomp=true&quot; runs all the scenarios with -Xcomp. This is faster than &quot;jtreg -javaoptions:-Xcomp&quot;.
149     protected static final boolean RUN_SCENARIOS_WITH_XCOMP = Boolean.parseBoolean(System.getProperty(&quot;Xcomp&quot;, &quot;false&quot;));
150 
151     // Pre-defined settings
152     private static final String[] defaultFlags = {
153         &quot;-XX:-BackgroundCompilation&quot;};
154     private static final String[] compileCommandFlags = {
155         &quot;-XX:CompileCommand=quiet&quot;,
156         &quot;-XX:CompileCommand=compileonly,java.lang.invoke.*::*&quot;,
157         &quot;-XX:CompileCommand=compileonly,java.lang.Long::sum&quot;,
158         &quot;-XX:CompileCommand=compileonly,java.lang.Object::&lt;init&gt;&quot;,
159         &quot;-XX:CompileCommand=inline,compiler.valhalla.inlinetypes.MyValue*::&lt;init&gt;&quot;,
160         &quot;-XX:CompileCommand=compileonly,compiler.valhalla.inlinetypes.*::*&quot;};
161     private static final String[] printFlags = {
162         &quot;-XX:+PrintCompilation&quot;, &quot;-XX:+PrintIdeal&quot;, &quot;-XX:+UnlockDiagnosticVMOptions&quot;, &quot;-XX:+PrintOptoAssembly&quot;};
163     private static final String[] verifyFlags = {
164         &quot;-XX:+VerifyOops&quot;, &quot;-XX:+VerifyStack&quot;, &quot;-XX:+VerifyLastFrame&quot;, &quot;-XX:+VerifyBeforeGC&quot;, &quot;-XX:+VerifyAfterGC&quot;,
165         &quot;-XX:+VerifyDuringGC&quot;, &quot;-XX:+VerifyAdapterSharing&quot;};
166 
167     protected static final int InlineTypePassFieldsAsArgsOn = 0x1;
168     protected static final int InlineTypePassFieldsAsArgsOff = 0x2;
169     protected static final int InlineTypeArrayFlattenOn = 0x4;
170     protected static final int InlineTypeArrayFlattenOff = 0x8;
171     protected static final int InlineTypeReturnedAsFieldsOn = 0x10;
172     protected static final int InlineTypeReturnedAsFieldsOff = 0x20;
173     protected static final int AlwaysIncrementalInlineOn = 0x40;
174     protected static final int AlwaysIncrementalInlineOff = 0x80;
175     protected static final int G1GCOn = 0x100;
176     protected static final int G1GCOff = 0x200;
177     protected static final int ZGCOn = 0x400;
178     protected static final int ZGCOff = 0x800;
179     protected static final int ArrayLoadStoreProfileOn = 0x1000;
180     protected static final int ArrayLoadStoreProfileOff = 0x2000;
181     protected static final int TypeProfileOn = 0x4000;
182     protected static final int TypeProfileOff = 0x8000;
183     protected static final boolean InlineTypePassFieldsAsArgs = (Boolean)WHITE_BOX.getVMFlag(&quot;InlineTypePassFieldsAsArgs&quot;);
<span class="line-modified">184     protected static final boolean InlineTypeArrayFlatten = (WHITE_BOX.getIntxVMFlag(&quot;FlatArrayElementMaxSize&quot;) == -1);</span>
185     protected static final boolean InlineTypeReturnedAsFields = (Boolean)WHITE_BOX.getVMFlag(&quot;InlineTypeReturnedAsFields&quot;);
186     protected static final boolean AlwaysIncrementalInline = (Boolean)WHITE_BOX.getVMFlag(&quot;AlwaysIncrementalInline&quot;);
187     protected static final boolean G1GC = (Boolean)WHITE_BOX.getVMFlag(&quot;UseG1GC&quot;);
188     protected static final boolean ZGC = (Boolean)WHITE_BOX.getVMFlag(&quot;UseZGC&quot;);
189     protected static final boolean VerifyOops = (Boolean)WHITE_BOX.getVMFlag(&quot;VerifyOops&quot;);
190     protected static final boolean UseArrayLoadStoreProfile = (Boolean)WHITE_BOX.getVMFlag(&quot;UseArrayLoadStoreProfile&quot;);
191     protected static final long TypeProfileLevel = (Long)WHITE_BOX.getVMFlag(&quot;TypeProfileLevel&quot;);
192 
193     protected static final Hashtable&lt;String, Method&gt; tests = new Hashtable&lt;String, Method&gt;();
194     protected static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(&quot;UseCompiler&quot;);
195     protected static final boolean PRINT_IDEAL  = WHITE_BOX.getBooleanVMFlag(&quot;PrintIdeal&quot;);
196 
197     // Regular expressions used to match nodes in the PrintIdeal output
198     protected static final String START = &quot;(\\d+\\t(.*&quot;;
199     protected static final String MID = &quot;.*)+\\t===.*&quot;;
200     protected static final String END = &quot;)|&quot;;
201     // Generic allocation
202     protected static final String ALLOC_G  = &quot;(.*call,static  wrapper for: _new_instance_Java&quot; + END;
203     protected static final String ALLOCA_G = &quot;(.*call,static  wrapper for: _new_array_Java&quot; + END;
204     // Inline type allocation
205     protected static final String ALLOC  = &quot;(.*precise klass compiler/valhalla/inlinetypes/MyValue.*\\R(.*(movl|xorl|nop|spill).*\\R)*.*_new_instance_Java&quot; + END;
206     protected static final String ALLOCA = &quot;(.*precise klass \\[(L|Q)compiler/valhalla/inlinetypes/MyValue.*\\R(.*(movl|xorl|nop|spill).*\\R)*.*_new_array_Java&quot; + END;
207     protected static final String LOAD   = START + &quot;Load(B|S|I|L|F|D|P|N)&quot; + MID + &quot;@compiler/valhalla/inlinetypes/MyValue.*&quot; + END;
208     protected static final String LOADK  = START + &quot;LoadK&quot; + MID + END;
209     protected static final String STORE  = START + &quot;Store(B|C|S|I|L|F|D|P|N)&quot; + MID + &quot;@compiler/valhalla/inlinetypes/MyValue.*&quot; + END;
210     protected static final String LOOP   = START + &quot;Loop&quot; + MID + &quot;&quot; + END;
211     protected static final String COUNTEDLOOP = START + &quot;CountedLoop\\b&quot; + MID + &quot;&quot; + END;
212     protected static final String COUNTEDLOOP_MAIN = START + &quot;CountedLoop\\b&quot; + MID + &quot;main&quot; + END;
213     protected static final String TRAP   = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*(unstable_if|predicate)&quot; + END;
214     protected static final String RETURN = START + &quot;Return&quot; + MID + &quot;returns&quot; + END;
215     protected static final String LINKTOSTATIC = START + &quot;CallStaticJava&quot; + MID + &quot;linkToStatic&quot; + END;
216     protected static final String NPE = START + &quot;CallStaticJava&quot; + MID + &quot;null_check&quot; + END;
217     protected static final String CALL = START + &quot;CallStaticJava&quot; + MID + END;
218     protected static final String STORE_INLINE_FIELDS = START + &quot;CallStaticJava&quot; + MID + &quot;store_inline_type_fields&quot; + END;
219     protected static final String SCOBJ = &quot;(.*# ScObj.*&quot; + END;
220     protected static final String LOAD_UNKNOWN_INLINE = &quot;(.*call_leaf,runtime  load_unknown_inline.*&quot; + END;
221     protected static final String STORE_UNKNOWN_INLINE = &quot;(.*call_leaf,runtime  store_unknown_inline.*&quot; + END;
222     protected static final String INLINE_ARRAY_NULL_GUARD = &quot;(.*call,static  wrapper for: uncommon_trap.*reason=&#39;null_check&#39; action=&#39;none&#39;.*&quot; + END;
<span class="line-added">223     protected static final String INTRINSIC_SLOW_PATH = &quot;(.*call,static  wrapper for: uncommon_trap.*reason=&#39;intrinsic_or_type_checked_inlining&#39;.*&quot; + END;</span>
224     protected static final String CLASS_CHECK_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*class_check&quot; + END;
225     protected static final String NULL_CHECK_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*null_check&quot; + END;
226     protected static final String RANGE_CHECK_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*range_check&quot; + END;
227     protected static final String UNHANDLED_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*unhandled&quot; + END;
228     protected static final String PREDICATE_TRAP = START + &quot;CallStaticJava&quot; + MID + &quot;uncommon_trap.*predicate&quot; + END;
229     protected static final String MEMBAR = START + &quot;MemBar&quot; + MID + END;
230     protected static final String CHECKCAST_ARRAY = &quot;(cmp.*precise klass \\[(L|Q)compiler/valhalla/inlinetypes/MyValue.*&quot; + END;
231 
232     public static String[] concat(String prefix[], String... extra) {
233         ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
234         if (prefix != null) {
235             for (String s : prefix) {
236                 list.add(s);
237             }
238         }
239         if (extra != null) {
240             for (String s : extra) {
241                 list.add(s);
242             }
243         }
</pre>
<hr />
<pre>
392                     }
393                 }
394             }
395         }
396         return exclude;
397     }
398 
399     protected InlineTypeTest() {
400         List&lt;String&gt; list = null;
401         if (!TESTLIST.isEmpty()) {
402            list = Arrays.asList(TESTLIST.split(&quot;,&quot;));
403         }
404         List&lt;String&gt; exclude = buildExcludeList();
405 
406         // Gather all test methods and put them in Hashtable
407         for (Method m : getClass().getDeclaredMethods()) {
408             Test[] annos = m.getAnnotationsByType(Test.class);
409             if (annos.length != 0 &amp;&amp;
410                 ((list == null || list.contains(m.getName())) &amp;&amp; (exclude == null || !exclude.contains(m.getName())))) {
411                 tests.put(getClass().getSimpleName() + &quot;::&quot; + m.getName(), m);
<span class="line-added">412             } else if (annos.length == 0 &amp;&amp; m.getName().startsWith(&quot;test&quot;)) {</span>
<span class="line-added">413                 try {</span>
<span class="line-added">414                     getClass().getMethod(m.getName() + &quot;_verifier&quot;, boolean.class);</span>
<span class="line-added">415                     throw new RuntimeException(m.getName() + &quot; has a verifier method but no @Test annotation&quot;);</span>
<span class="line-added">416                 } catch (NoSuchMethodException e) {</span>
<span class="line-added">417                     // Expected</span>
<span class="line-added">418                 }</span>
419             }
420         }
421     }
422 
423     protected void run(String[] args, Class&lt;?&gt;... classes) throws Throwable {
424         if (args.length == 0) {
425             // Spawn a new VM instance
426             execute_vm();
427         } else {
428             // Execute tests in the VM spawned by the above code.
429             Asserts.assertTrue(args.length == 1 &amp;&amp; args[0].equals(&quot;run&quot;), &quot;must be&quot;);
430             run(classes);
431         }
432     }
433 
434     private void execute_vm() throws Throwable {
435         Asserts.assertFalse(tests.isEmpty(), &quot;no tests to execute&quot;);
436         String[] vmInputArgs = InputArguments.getVmInputArgs();
437         for (String arg : vmInputArgs) {
438             if (arg.startsWith(&quot;-XX:CompileThreshold&quot;)) {
</pre>
<hr />
<pre>
571             }
572             String regexFail = anno.failOn();
573             if (!regexFail.isEmpty()) {
574                 Pattern pattern = Pattern.compile(regexFail.substring(0, regexFail.length()-1));
575                 Matcher matcher = pattern.matcher(graph);
576                 boolean found = matcher.find();
577                 Asserts.assertFalse(found, &quot;Graph for &#39;&quot; + testName + &quot;&#39; contains forbidden node:\n&quot; + (found ? matcher.group() : &quot;&quot;));
578             }
579             String[] regexMatch = anno.match();
580             int[] matchCount = anno.matchCount();
581             for (int i = 0; i &lt; regexMatch.length; ++i) {
582                 Pattern pattern = Pattern.compile(regexMatch[i].substring(0, regexMatch[i].length()-1));
583                 Matcher matcher = pattern.matcher(graph);
584                 int count = 0;
585                 String nodes = &quot;&quot;;
586                 while (matcher.find()) {
587                     count++;
588                     nodes += matcher.group() + &quot;\n&quot;;
589                 }
590                 if (matchCount[i] &lt; 0) {
<span class="line-modified">591                     Asserts.assertLTE(Math.abs(matchCount[i]), count, &quot;Graph for &#39;&quot; + testName + &quot;&#39; contains different number of match nodes (expected &gt;= &quot; + Math.abs(matchCount[i]) + &quot; but got &quot; + count + &quot;):\n&quot; + nodes);</span>
592                 } else {
593                     Asserts.assertEQ(matchCount[i], count, &quot;Graph for &#39;&quot; + testName + &quot;&#39; contains different number of match nodes (expected &quot; + matchCount[i] + &quot; but got &quot; + count + &quot;):\n&quot; + nodes);
594                 }
595             }
596             tests.remove(testName);
597             System.out.println(testName + &quot; passed&quot;);
598         }
599         // Check if all tests were compiled
600         if (tests.size() != 0) {
601             for (String name : tests.keySet()) {
602                 System.out.println(&quot;Test &#39;&quot; + name + &quot;&#39; not compiled!&quot;);
603             }
604             throw new RuntimeException(&quot;Not all tests were compiled&quot;);
605         }
606     }
607 
608     private void setup(Class&lt;?&gt; clazz) {
609         if (XCOMP) {
610             // Don&#39;t control compilation if -Xcomp is enabled
611             return;
</pre>
<hr />
<pre>
652                 int compLevel = getCompLevel(m.getAnnotation(ForceCompile.class));
653                 enqueueMethodForCompilation(m, compLevel);
654             }
655         }
656         // Compile class initializers
657         int compLevel = getCompLevel(null);
658         WHITE_BOX.enqueueInitializerForCompilation(clazz, compLevel);
659     }
660 
661     private void run(Class&lt;?&gt;... classes) throws Exception {
662         if (USE_COMPILER &amp;&amp; PRINT_IDEAL &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
663             System.out.println(&quot;PrintIdeal enabled&quot;);
664         }
665         System.out.format(&quot;rI = %d, rL = %d\n&quot;, rI, rL);
666 
667         setup(getClass());
668         for (Class&lt;?&gt; clazz : classes) {
669             setup(clazz);
670         }
671 

672         TreeMap&lt;Long, String&gt; durations = (PRINT_TIMES || VERBOSE) ? new TreeMap&lt;Long, String&gt;() : null;
<span class="line-modified">673         List&lt;Method&gt; testList = new ArrayList&lt;Method&gt;(tests.values());</span>
<span class="line-added">674         if (SHUFFLE_TESTS) {</span>
<span class="line-added">675             // Execute tests in random order (execution sequence affects profiling)</span>
<span class="line-added">676             Collections.shuffle(testList, Utils.getRandomInstance());</span>
<span class="line-added">677         }</span>
<span class="line-added">678         for (Method test : testList) {</span>
679             if (VERBOSE) {
680                 System.out.println(&quot;Starting &quot; + test.getName());
681             }
682             TempSkipForC1 c1skip = test.getAnnotation(TempSkipForC1.class);
683             if (TEST_C1 &amp;&amp; c1skip != null) {
684                 System.out.println(&quot;Skipped &quot; + test.getName() + &quot; for C1 testing: &quot; + c1skip.reason());
685                 continue;
686             }
687             long startTime = System.nanoTime();
688             Method verifier = getClass().getMethod(test.getName() + &quot;_verifier&quot;, boolean.class);
689             // Warmup using verifier method
690             Warmup anno = test.getAnnotation(Warmup.class);
691             int warmup = anno == null ? WARMUP : anno.value();
692             for (int i = 0; i &lt; warmup; ++i) {
693                 verifier.invoke(this, true);
694             }
695             boolean osrOnly = (test.getAnnotation(OSRCompileOnly.class) != null);
696             int compLevel = getCompLevel(test.getAnnotation(Test.class));
697 
698             // C1 generates a lot of code when VerifyOops is enabled and may run out of space (for a small
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="MyValue1.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>