diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/InlineTypeTest.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/InlineTypeTest.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/InlineTypeTest.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/InlineTypeTest.java
@@ -37,10 +37,12 @@
 import java.lang.annotation.Repeatable;
 import java.lang.invoke.*;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
 import java.util.Hashtable;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.regex.Matcher;
@@ -120,10 +122,11 @@
     static final boolean TEST_C1 = TieredCompilation && TieredStopAtLevel < COMP_LEVEL_FULL_OPTIMIZATION;
 
     // Random test values
     public static final int  rI = Utils.getRandomInstance().nextInt() % 1000;
     public static final long rL = Utils.getRandomInstance().nextLong() % 1000;
+    public static final double rD = Utils.getRandomInstance().nextDouble() % 1000;
 
     // User defined settings
     protected static final boolean XCOMP = Platform.isComp();
     private static final boolean PRINT_GRAPH = true;
     private static final boolean VERBOSE = Boolean.parseBoolean(System.getProperty("Verbose", "false"));
@@ -138,10 +141,11 @@
     private static final boolean DUMP_REPLAY = Boolean.parseBoolean(System.getProperty("DumpReplay", "false"));
     private static final boolean FLIP_C1_C2 = Boolean.parseBoolean(System.getProperty("FlipC1C2", "false"));
     private static final boolean GC_AFTER = Boolean.parseBoolean(System.getProperty("GCAfter", "false"));
     private static final int OSR_TEST_TIMEOUT = Integer.parseInt(System.getProperty("OSRTestTimeOut", "5000"));
     protected static final boolean STRESS_CC = Boolean.parseBoolean(System.getProperty("StressCC", "false"));
+    private static final boolean SHUFFLE_TESTS = Boolean.parseBoolean(System.getProperty("ShuffleTests", "false"));
 
     // "jtreg -DXcomp=true" runs all the scenarios with -Xcomp. This is faster than "jtreg -javaoptions:-Xcomp".
     protected static final boolean RUN_SCENARIOS_WITH_XCOMP = Boolean.parseBoolean(System.getProperty("Xcomp", "false"));
 
     // Pre-defined settings
@@ -175,11 +179,11 @@
     protected static final int ArrayLoadStoreProfileOn = 0x1000;
     protected static final int ArrayLoadStoreProfileOff = 0x2000;
     protected static final int TypeProfileOn = 0x4000;
     protected static final int TypeProfileOff = 0x8000;
     protected static final boolean InlineTypePassFieldsAsArgs = (Boolean)WHITE_BOX.getVMFlag("InlineTypePassFieldsAsArgs");
-    protected static final boolean InlineTypeArrayFlatten = (WHITE_BOX.getIntxVMFlag("FlatArrayElementMaxSize") == -1); // FIXME - fix this if default of FlatArrayElementMaxSize is changed
+    protected static final boolean InlineTypeArrayFlatten = (WHITE_BOX.getIntxVMFlag("FlatArrayElementMaxSize") == -1);
     protected static final boolean InlineTypeReturnedAsFields = (Boolean)WHITE_BOX.getVMFlag("InlineTypeReturnedAsFields");
     protected static final boolean AlwaysIncrementalInline = (Boolean)WHITE_BOX.getVMFlag("AlwaysIncrementalInline");
     protected static final boolean G1GC = (Boolean)WHITE_BOX.getVMFlag("UseG1GC");
     protected static final boolean ZGC = (Boolean)WHITE_BOX.getVMFlag("UseZGC");
     protected static final boolean VerifyOops = (Boolean)WHITE_BOX.getVMFlag("VerifyOops");
@@ -214,10 +218,11 @@
     protected static final String STORE_INLINE_FIELDS = START + "CallStaticJava" + MID + "store_inline_type_fields" + END;
     protected static final String SCOBJ = "(.*# ScObj.*" + END;
     protected static final String LOAD_UNKNOWN_INLINE = "(.*call_leaf,runtime  load_unknown_inline.*" + END;
     protected static final String STORE_UNKNOWN_INLINE = "(.*call_leaf,runtime  store_unknown_inline.*" + END;
     protected static final String INLINE_ARRAY_NULL_GUARD = "(.*call,static  wrapper for: uncommon_trap.*reason='null_check' action='none'.*" + END;
+    protected static final String INTRINSIC_SLOW_PATH = "(.*call,static  wrapper for: uncommon_trap.*reason='intrinsic_or_type_checked_inlining'.*" + END;
     protected static final String CLASS_CHECK_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*class_check" + END;
     protected static final String NULL_CHECK_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*null_check" + END;
     protected static final String RANGE_CHECK_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*range_check" + END;
     protected static final String UNHANDLED_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*unhandled" + END;
     protected static final String PREDICATE_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*predicate" + END;
@@ -402,10 +407,17 @@
         for (Method m : getClass().getDeclaredMethods()) {
             Test[] annos = m.getAnnotationsByType(Test.class);
             if (annos.length != 0 &&
                 ((list == null || list.contains(m.getName())) && (exclude == null || !exclude.contains(m.getName())))) {
                 tests.put(getClass().getSimpleName() + "::" + m.getName(), m);
+            } else if (annos.length == 0 && m.getName().startsWith("test")) {
+                try {
+                    getClass().getMethod(m.getName() + "_verifier", boolean.class);
+                    throw new RuntimeException(m.getName() + " has a verifier method but no @Test annotation");
+                } catch (NoSuchMethodException e) {
+                    // Expected
+                }
             }
         }
     }
 
     protected void run(String[] args, Class<?>... classes) throws Throwable {
@@ -574,11 +586,11 @@
                 while (matcher.find()) {
                     count++;
                     nodes += matcher.group() + "\n";
                 }
                 if (matchCount[i] < 0) {
-                    Asserts.assertLTE(Math.abs(matchCount[i]), count, "Graph for '" + testName + "' contains different number of match nodes (expected <= " + matchCount[i] + " but got " + count + "):\n" + nodes);
+                    Asserts.assertLTE(Math.abs(matchCount[i]), count, "Graph for '" + testName + "' contains different number of match nodes (expected >= " + Math.abs(matchCount[i]) + " but got " + count + "):\n" + nodes);
                 } else {
                     Asserts.assertEQ(matchCount[i], count, "Graph for '" + testName + "' contains different number of match nodes (expected " + matchCount[i] + " but got " + count + "):\n" + nodes);
                 }
             }
             tests.remove(testName);
@@ -655,13 +667,17 @@
         setup(getClass());
         for (Class<?> clazz : classes) {
             setup(clazz);
         }
 
-        // Execute tests
         TreeMap<Long, String> durations = (PRINT_TIMES || VERBOSE) ? new TreeMap<Long, String>() : null;
-        for (Method test : tests.values()) {
+        List<Method> testList = new ArrayList<Method>(tests.values());
+        if (SHUFFLE_TESTS) {
+            // Execute tests in random order (execution sequence affects profiling)
+            Collections.shuffle(testList, Utils.getRandomInstance());
+        }
+        for (Method test : testList) {
             if (VERBOSE) {
                 System.out.println("Starting " + test.getName());
             }
             TempSkipForC1 c1skip = test.getAnnotation(TempSkipForC1.class);
             if (TEST_C1 && c1skip != null) {
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/MyValue1.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/MyValue1.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/MyValue1.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/MyValue1.java
@@ -31,11 +31,11 @@
     final short z;
     final Integer o;
     final int[] oa;
     final MyValue2 v1;
     final MyValue2 v2;
-    static final MyValue2 v3 = MyValue2.createWithFieldsInline(InlineTypeTest.rI, true);
+    static final MyValue2 v3 = MyValue2.createWithFieldsInline(InlineTypeTest.rI, InlineTypeTest.rD);
     final int c;
 
     @ForceInline
     public MyValue1(int x, long y, short z, Integer o, int[] oa, MyValue2 v1, MyValue2 v2, int c) {
         s = 0;
@@ -71,12 +71,12 @@
         v = setY(v, y);
         v = setZ(v, (short)x);
         v = setO(v, new Integer(x));
         int[] oa = {x};
         v = setOA(v, oa);
-        v = setV1(v, MyValue2.createWithFieldsInline(x, y, true));
-        v = setV2(v, MyValue2.createWithFieldsInline(x, y, false));
+        v = setV1(v, MyValue2.createWithFieldsInline(x, y, InlineTypeTest.rD));
+        v = setV2(v, MyValue2.createWithFieldsInline(x, y, InlineTypeTest.rD+x));
         v = setC(v, (int)(x+y));
         return v;
     }
 
     // Hash only primitive and inline type fields to avoid NullPointerException
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/MyValue2.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/MyValue2.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/MyValue2.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/MyValue2.java
@@ -22,112 +22,112 @@
  */
 
 package compiler.valhalla.inlinetypes;
 
 final inline class MyValue2Inline {
-    final boolean b;
-    final long c;
+    final double d;
+    final long l;
 
     @ForceInline
-    public MyValue2Inline(boolean b, long c) {
-        this.b = b;
-        this.c = c;
+    public MyValue2Inline(double d, long l) {
+        this.d = d;
+        this.l = l;
     }
 
     @ForceInline
-    static MyValue2Inline setB(MyValue2Inline v, boolean b) {
-        return new MyValue2Inline(b, v.c);
+    static MyValue2Inline setD(MyValue2Inline v, double d) {
+        return new MyValue2Inline(d, v.l);
     }
 
     @ForceInline
-    static MyValue2Inline setC(MyValue2Inline v, long c) {
-        return new MyValue2Inline(v.b, c);
+    static MyValue2Inline setL(MyValue2Inline v, long l) {
+        return new MyValue2Inline(v.d, l);
     }
 
     @ForceInline
     public static MyValue2Inline createDefault() {
         return MyValue2Inline.default;
     }
 
     @ForceInline
-    public static MyValue2Inline createWithFieldsInline(boolean b, long c) {
+    public static MyValue2Inline createWithFieldsInline(double d, long l) {
         MyValue2Inline v = MyValue2Inline.createDefault();
-        v = MyValue2Inline.setB(v, b);
-        v = MyValue2Inline.setC(v, c);
+        v = MyValue2Inline.setD(v, d);
+        v = MyValue2Inline.setL(v, l);
         return v;
     }
 }
 
 public final inline class MyValue2 extends MyAbstract {
     final int x;
     final byte y;
-    final MyValue2Inline v1;
+    final MyValue2Inline v;
 
     @ForceInline
-    public MyValue2(int x, byte y, MyValue2Inline v1) {
+    public MyValue2(int x, byte y, MyValue2Inline v) {
         this.x = x;
         this.y = y;
-        this.v1 = v1;
+        this.v = v;
     }
 
     @ForceInline
     public static MyValue2 createDefaultInline() {
         return MyValue2.default;
     }
 
     @ForceInline
-    public static MyValue2 createWithFieldsInline(int x, long y, boolean b) {
+    public static MyValue2 createWithFieldsInline(int x, long y, double d) {
         MyValue2 v = createDefaultInline();
         v = setX(v, x);
         v = setY(v, (byte)x);
-        v = setV1(v, MyValue2Inline.createWithFieldsInline(b, y));
+        v = setV(v, MyValue2Inline.createWithFieldsInline(d, y));
         return v;
     }
 
     @ForceInline
-    public static MyValue2 createWithFieldsInline(int x, boolean b) {
+    public static MyValue2 createWithFieldsInline(int x, double d) {
         MyValue2 v = createDefaultInline();
         v = setX(v, x);
         v = setY(v, (byte)x);
-        v = setV1(v, MyValue2Inline.createWithFieldsInline(b, InlineTypeTest.rL));
+        v = setV(v, MyValue2Inline.createWithFieldsInline(d, InlineTypeTest.rL));
         return v;
     }
 
     @DontInline
-    public static MyValue2 createWithFieldsDontInline(int x, boolean b) {
+    public static MyValue2 createWithFieldsDontInline(int x, double d) {
         MyValue2 v = createDefaultInline();
         v = setX(v, x);
         v = setY(v, (byte)x);
-        v = setV1(v, MyValue2Inline.createWithFieldsInline(b, InlineTypeTest.rL));
+        v = setV(v, MyValue2Inline.createWithFieldsInline(d, InlineTypeTest.rL));
         return v;
     }
 
     @ForceInline
     public long hash() {
-        return x + y + (v1.b ? 0 : 1) + v1.c;
+        return x + y + (long)v.d + v.l;
     }
 
     @DontInline
     public long hashInterpreted() {
-        return x + y + (v1.b ? 0 : 1) + v1.c;
+        return x + y + (long)v.d + v.l;
     }
 
     @ForceInline
     public void print() {
-        System.out.print("x=" + x + ", y=" + y + ", b=" + v1.b + ", c=" + v1.c);
+        System.out.print("x=" + x + ", y=" + y + ", d=" + v.d + ", l=" + v.l);
     }
 
     @ForceInline
     static MyValue2 setX(MyValue2 v, int x) {
-        return new MyValue2(x, v.y, v.v1);
+        return new MyValue2(x, v.y, v.v);
     }
 
     @ForceInline
     static MyValue2 setY(MyValue2 v, byte y) {
-        return new MyValue2(v.x, y, v.v1);
+        return new MyValue2(v.x, y, v.v);
     }
 
     @ForceInline
-    static MyValue2 setV1(MyValue2 v, MyValue2Inline v1) {
-        return new MyValue2(v.x, v.y, v1);
+    static MyValue2 setV(MyValue2 v, MyValue2Inline vi) {
+        return new MyValue2(v.x, v.y, vi);
     }
 }
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrayAccessDeopt.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrayAccessDeopt.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrayAccessDeopt.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrayAccessDeopt.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -111,19 +111,21 @@
                 test5(va, vt);
                 test5(vaB, vt);
                 test6(va, vt);
                 try {
                     test6(va, null);
+                    throw new RuntimeException("NullPointerException expected");
                 } catch (NullPointerException npe) {
                     // Expected
                 }
                 test7(va, vt);
                 test8(va, vt);
                 test8(vaB, vt);
                 test9(va, vt);
                 try {
                     test9(va, null);
+                    throw new RuntimeException("NullPointerException expected");
                 } catch (NullPointerException npe) {
                     // Expected
                 }
                 test10(vaB);
                 test11(vaB);
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java
@@ -103,13 +103,11 @@
             Asserts.assertEQ(va[i].hash(), hash());
         }
     }
 
     // Test creation of an inline type array and element access
-    // TODO 8227588
-    @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
-    @Test(valid = InlineTypeArrayFlattenOff)
+    @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     public long test2() {
         MyValue1[] va = new MyValue1[1];
         va[0] = MyValue1.createWithFieldsInline(rI, rL);
         return va[0].hash();
     }
@@ -535,11 +533,11 @@
     public void test21_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         MyValue2[] src = new MyValue2[len];
         MyValue2[] dst = new MyValue2[len];
         for (int i = 0; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test21(src, dst);
         for (int i = 0; i < len; ++i) {
             Asserts.assertEQ(src[i].hash(), dst[i].hash());
         }
@@ -618,11 +616,11 @@
     @DontCompile
     public void test25_verifier(boolean warmup) {
         MyValue2[] src = new MyValue2[8];
         MyValue2[] dst = new MyValue2[8];
         for (int i = 0; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test25(src, dst);
         for (int i = 0; i < 8; ++i) {
             Asserts.assertEQ(src[i].hash(), dst[i].hash());
         }
@@ -665,42 +663,43 @@
             Asserts.assertEQ(src[i-1].hash(), dst[i].hash());
         }
     }
 
     // non escaping allocations
-    // TODO ZGC does not support the clone intrinsic, remove this once JDK-8232896 is fixed
+    // TODO 8252027: Make sure this is optimized with ZGC
     @Test(valid = ZGCOff, failOn = ALLOCA + LOOP + LOAD + TRAP)
     @Test(valid = ZGCOn)
     public MyValue2 test28() {
         MyValue2[] src = new MyValue2[10];
-        src[0] = MyValue2.createWithFieldsInline(rI, false);
+        src[0] = MyValue2.createWithFieldsInline(rI, rD);
         MyValue2[] dst = (MyValue2[])src.clone();
         return dst[0];
     }
 
     @DontCompile
     public void test28_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, false);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         MyValue2 result = test28();
         Asserts.assertEQ(result.hash(), v.hash());
     }
 
     // non escaping allocations
     // TODO 8227588: shouldn't this have the same IR matching rules as test6?
+    // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOCA + LOOP + LOAD + TRAP)
-    @Test(valid = InlineTypeArrayFlattenOff)
+    @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOCA + LOOP + TRAP)
     public MyValue2 test29(MyValue2[] src) {
         MyValue2[] dst = new MyValue2[10];
         System.arraycopy(src, 0, dst, 0, 10);
         return dst[0];
     }
 
     @DontCompile
     public void test29_verifier(boolean warmup) {
         MyValue2[] src = new MyValue2[10];
         for (int i = 0; i < 10; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         MyValue2 v = test29(src);
         Asserts.assertEQ(src[0].hash(), v.hash());
     }
 
@@ -717,40 +716,38 @@
 
     @DontCompile
     public void test30_verifier(boolean warmup) {
         MyValue2[] src = new MyValue2[10];
         for (int i = 0; i < 10; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         MyValue2 v = test30(src, !warmup);
         Asserts.assertEQ(src[0].hash(), v.hash());
     }
 
     // non escaping allocation with memory phi
-    // TODO 8227588
-    @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
-    @Test(valid = InlineTypeArrayFlattenOff)
+    @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     public long test31(boolean b, boolean deopt) {
         MyValue2[] src = new MyValue2[1];
         if (b) {
-            src[0] = MyValue2.createWithFieldsInline(rI, true);
+            src[0] = MyValue2.createWithFieldsInline(rI, rD);
         } else {
-            src[0] = MyValue2.createWithFieldsInline(rI, false);
+            src[0] = MyValue2.createWithFieldsInline(rI+1, rD+1);
         }
         if (deopt) {
             // uncommon trap
             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + "::test31"));
         }
         return src[0].hash();
     }
 
     @DontCompile
     public void test31_verifier(boolean warmup) {
-        MyValue2 v1 = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v1 = MyValue2.createWithFieldsInline(rI, rD);
         long result1 = test31(true, !warmup);
         Asserts.assertEQ(result1, v1.hash());
-        MyValue2 v2 = MyValue2.createWithFieldsInline(rI, false);
+        MyValue2 v2 = MyValue2.createWithFieldsInline(rI+1, rD+1);
         long result2 = test31(false, !warmup);
         Asserts.assertEQ(result2, v2.hash());
     }
 
     // Tests with Object arrays and clone/arraycopy
@@ -919,11 +916,11 @@
     public void test36_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         MyValue2[] src = new MyValue2[len];
         MyValue2[] dst = new MyValue2[len];
         for (int i = 0; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test36(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestArrays::test36")) {
             test36(src, dst);
@@ -940,11 +937,11 @@
     public void test37_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         MyValue2[] src = new MyValue2[len];
         MyValue2[] dst = new MyValue2[len];
         for (int i = 0; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test37(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestArrays::test37")) {
             test37(src, dst);
@@ -962,11 +959,11 @@
     public void test38_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         Object[] src = new Object[len];
         MyValue2[] dst = new MyValue2[len];
         for (int i = 0; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test38(src, dst);
         verify(dst, src);
         if (!warmup) {
             Method m = tests.get("TestArrays::test38");
@@ -989,11 +986,11 @@
     public void test39_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         MyValue2[] src = new MyValue2[len];
         Object[] dst = new Object[len];
         for (int i = 0; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test39(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestArrays::test39")) {
             test39(src, dst);
@@ -1011,11 +1008,11 @@
     public void test40_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         Object[] src = new Object[len];
         MyValue2[] dst = new MyValue2[len];
         for (int i = 0; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test40(src, dst);
         verify(dst, src);
         if (!warmup) {
             Method m = tests.get("TestArrays::test40");
@@ -1038,11 +1035,11 @@
     public void test41_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         MyValue2[] src = new MyValue2[len];
         Object[] dst = new Object[len];
         for (int i = 0; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test41(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestArrays::test41")) {
             test41(src, dst);
@@ -1059,11 +1056,11 @@
     public void test42_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         Object[] src = new Object[len];
         Object[] dst = new Object[len];
         for (int i = 0; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test42(src, dst);
         verify(src, dst);
         if (!warmup) {
             Method m = tests.get("TestArrays::test42");
@@ -1102,11 +1099,11 @@
     @DontCompile
     public void test44_verifier(boolean warmup) {
         MyValue2[] src = new MyValue2[8];
         MyValue2[] dst = new MyValue2[8];
         for (int i = 0; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test44(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestArrays::test44")) {
             test44(src, dst);
@@ -1122,11 +1119,11 @@
     @DontCompile
     public void test45_verifier(boolean warmup) {
         MyValue2[] src = new MyValue2[8];
         MyValue2[] dst = new MyValue2[8];
         for (int i = 0; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test45(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestArrays::test45")) {
             test45(src, dst);
@@ -1143,11 +1140,11 @@
     @DontCompile
     public void test46_verifier(boolean warmup) {
         Object[] src = new Object[8];
         MyValue2[] dst = new MyValue2[8];
         for (int i = 0; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test46(src, dst);
         verify(dst, src);
         if (!warmup) {
             Method m = tests.get("TestArrays::test46");
@@ -1169,11 +1166,11 @@
     @DontCompile
     public void test47_verifier(boolean warmup) {
         MyValue2[] src = new MyValue2[8];
         Object[] dst = new Object[8];
         for (int i = 0; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test47(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestArrays::test47")) {
             test47(src, dst);
@@ -1190,11 +1187,11 @@
     @DontCompile
     public void test48_verifier(boolean warmup) {
         Object[] src = new Object[8];
         MyValue2[] dst = new MyValue2[8];
         for (int i = 0; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test48(src, dst);
         verify(dst, src);
         if (!warmup) {
             Method m = tests.get("TestArrays::test48");
@@ -1216,11 +1213,11 @@
     @DontCompile
     public void test49_verifier(boolean warmup) {
         MyValue2[] src = new MyValue2[8];
         Object[] dst = new Object[8];
         for (int i = 0; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test49(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestArrays::test49")) {
             test49(src, dst);
@@ -1236,11 +1233,11 @@
     @DontCompile
     public void test50_verifier(boolean warmup) {
         Object[] src = new Object[8];
         Object[] dst = new Object[8];
         for (int i = 0; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test50(src, dst);
         verify(src, dst);
         if (!warmup) {
             Method m = tests.get("TestArrays::test50");
@@ -1250,11 +1247,11 @@
         }
     }
 
     @Test
     public MyValue1[] test51(MyValue1[] va) {
-        // TODO Remove cast as workaround once javac is fixed
+        // TODO 8244562: Remove cast as workaround once javac is fixed
         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
     }
 
     @DontCompile
     public void test51_verifier(boolean warmup) {
@@ -1269,11 +1266,11 @@
 
     static final MyValue1[] test52_va = new MyValue1[8];
 
     @Test
     public MyValue1[] test52() {
-        // TODO Remove cast as workaround once javac is fixed
+        // TODO 8244562: Remove cast as workaround once javac is fixed
         return (MyValue1[])Arrays.copyOf(test52_va, 8, MyValue1[].class);
     }
 
     @DontCompile
     public void test52_verifier(boolean warmup) {
@@ -1284,11 +1281,11 @@
         verify(test52_va, result);
     }
 
     @Test
     public MyValue1[] test53(Object[] va) {
-        // TODO Remove cast as workaround once javac is fixed
+        // TODO 8244562: Remove cast as workaround once javac is fixed
         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
     }
 
     @DontCompile
     public void test53_verifier(boolean warmup) {
@@ -1333,11 +1330,11 @@
         verify(va, result);
     }
 
     @Test
     public MyValue1[] test56(Object[] va) {
-        // TODO Remove cast as workaround once javac is fixed
+        // TODO 8244562: Remove cast as workaround once javac is fixed
         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
     }
 
     @DontCompile
     public void test56_verifier(boolean warmup) {
@@ -1639,11 +1636,11 @@
     public void test71() {
         int len = 10;
         MyValue2[] src = new MyValue2[len];
         MyValue2[] dst = new MyValue2[len];
         for (int i = 0; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsDontInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsDontInline(rI+i, rD+i);
         }
         System.arraycopy(src, 0, dst, 0, src.length);
         for (int i = 0; i < len; ++i) {
             Asserts.assertEQ(src[i].hash(), dst[i].hash());
         }
@@ -2243,11 +2240,11 @@
 
     @DontCompile
     public void test93_verifier(boolean warmup) {
         MyValue2[] src = new MyValue2[10];
         for (int i = 0; i < 10; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (rI % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         long res = test93(src, !warmup);
         long expected = 0;
         for (int i = 0; i < 10; ++i) {
             expected += src[i].hash();
@@ -2267,11 +2264,11 @@
 
     @DontCompile
     public void test94_verifier(boolean warmup) {
         MyValue2[] src = new MyValue2[10];
         for (int i = 0; i < 10; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(i, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         for (int i = 0; i < 10; ++i) {
             long res = test94(src, i, !warmup);
             long expected = src[i].hash() + 9*MyValue2.default.hash();
             Asserts.assertEQ(res, expected);
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestBasicFunctionality.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestBasicFunctionality.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestBasicFunctionality.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestBasicFunctionality.java
@@ -184,12 +184,12 @@
         Asserts.assertEQ(test8(true), hash());
         Asserts.assertEQ(test8(false), hash(rI + 1, rL + 1));
     }
 
     // Merge inline types created from two branches
-    @Test(valid = InlineTypePassFieldsAsArgsOn, match = {LOAD}, matchCount = {12}, failOn = TRAP + ALLOC + STORE)
-    @Test(valid = InlineTypePassFieldsAsArgsOff, match = {ALLOC, STORE}, matchCount = {1, 12}, failOn = LOAD + TRAP)
+    @Test(valid = InlineTypePassFieldsAsArgsOn, match = {LOAD}, matchCount = {14}, failOn = TRAP + ALLOC + STORE)
+    @Test(valid = InlineTypePassFieldsAsArgsOff, match = {ALLOC, STORE}, matchCount = {1, 13}, failOn = LOAD + TRAP)
     public MyValue1 test9(boolean b, int localrI, long localrL) {
         MyValue1 v;
         if (b) {
             // Inline type is not allocated
             // Do not use rI/rL directly here as null values may cause
@@ -313,11 +313,11 @@
         Asserts.assertEQ(result, warmup ? rL + (1000 * rI) : ((Math.abs(rI) % 10) + 1) * hash());
     }
 
     // Create an inline type in a non-inlined method and then call a
     // non-inlined method on that inline type.
-    @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = (ALLOC + STORE + TRAP), match = {LOAD}, matchCount = {12})
+    @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = (ALLOC + STORE + TRAP), match = {LOAD}, matchCount = {14})
     @Test(valid = InlineTypePassFieldsAsArgsOff, failOn = (ALLOC + LOAD + STORE + TRAP))
     public long test14() {
         MyValue1 v = MyValue1.createWithFieldsDontInline(rI, rL);
         return v.hashInterpreted();
     }
@@ -445,11 +445,11 @@
     public long test21(int x, long y) {
         // Compute hash of inline type fields
         long result = val1.hash() + val2.hash() + val3.hash() + val4.hash() + val5.hash();
         // Update fields
         val1 = MyValue1.createWithFieldsInline(x, y);
-        val2 = MyValue2.createWithFieldsInline(x, true);
+        val2 = MyValue2.createWithFieldsInline(x, rD);
         val4 = MyValue1.createWithFieldsInline(x, y);
         return result;
     }
 
     @DontCompile
@@ -463,11 +463,11 @@
         long hash = val1.hash() + val2.hash() + val3.hash() + val4.hash() + val5.hash();
         long result = test21(rI + 1, rL + 1);
         Asserts.assertEQ(result, hash);
         // Check if inline type fields were updated
         Asserts.assertEQ(val1.hash(), hash(rI + 1, rL + 1));
-        Asserts.assertEQ(val2.hash(), MyValue2.createWithFieldsInline(rI + 1, true).hash());
+        Asserts.assertEQ(val2.hash(), MyValue2.createWithFieldsInline(rI + 1, rD).hash());
         Asserts.assertEQ(val4.hash(), hash(rI + 1, rL + 1));
     }
 
     // Test folding of constant inline type fields
     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
@@ -510,18 +510,18 @@
     }
 
     // Test withfield
     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
     public long test25() {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         return v.hash();
     }
 
     @DontCompile
     public void test25_verifier(boolean warmup) {
         long result = test25();
-        Asserts.assertEQ(result, MyValue2.createWithFieldsInline(rI, true).hash());
+        Asserts.assertEQ(result, MyValue2.createWithFieldsInline(rI, rD).hash());
     }
 
     // Test withfield
     @Test(failOn = ALLOC + STORE + LOOP + TRAP)
     public long test26() {
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConvention.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConvention.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConvention.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConvention.java
@@ -83,11 +83,11 @@
         return v.hash();
     }
 
     @DontCompile
     public void test1_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         long result = test1(v);
         Asserts.assertEQ(result, v.hashInterpreted());
     }
 
     @Test(failOn = ALLOC + STORE + TRAP)
@@ -95,11 +95,11 @@
         return v.hash() + i1 - i2;
     }
 
     @DontCompile
     public void test2_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         long result = test2(rI, v, 2*rI);
         Asserts.assertEQ(result, v.hashInterpreted() - rI);
     }
 
     @Test(failOn = ALLOC + STORE + TRAP)
@@ -107,11 +107,11 @@
         return v.hash() + l1 - l2;
     }
 
     @DontCompile
     public void test3_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         long result = test3(rL, v, 2*rL);
         Asserts.assertEQ(result, v.hashInterpreted() - rL);
     }
 
     @Test(failOn = ALLOC + STORE + TRAP)
@@ -119,11 +119,11 @@
         return v.hash() + i + l;
     }
 
     @DontCompile
     public void test4_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         long result = test4(rI, v, rL);
         Asserts.assertEQ(result, v.hashInterpreted() + rL + rI);
     }
 
     @Test(failOn = ALLOC + STORE + TRAP)
@@ -131,11 +131,11 @@
         return v.hash() + i + l;
     }
 
     @DontCompile
     public void test5_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         long result = test5(rL, v, rI);
         Asserts.assertEQ(result, v.hashInterpreted() + rL + rI);
     }
 
     @Test(failOn = ALLOC + STORE + TRAP)
@@ -144,11 +144,11 @@
     }
 
     @DontCompile
     public void test6_verifier(boolean warmup) {
         MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI, rL);
-        MyValue2 v2 = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v2 = MyValue2.createWithFieldsInline(rI, rD);
         long result = test6(rL, v1, rI, v2);
         Asserts.assertEQ(result, v1.hashInterpreted() + rL + rI + v2.hashInterpreted());
     }
 
     // Test compiled code to interpreter with various signatures
@@ -162,11 +162,11 @@
         return test7_interp(v);
     }
 
     @DontCompile
     public void test7_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         long result = test7(v);
         Asserts.assertEQ(result, v.hashInterpreted());
     }
 
     @DontCompile
@@ -179,11 +179,11 @@
         return test8_interp(i1, v, i2);
     }
 
     @DontCompile
     public void test8_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         long result = test8(rI, v, 2*rI);
         Asserts.assertEQ(result, v.hashInterpreted() - rI);
     }
 
     @DontCompile
@@ -196,11 +196,11 @@
         return test9_interp(l1, v, l2);
     }
 
     @DontCompile
     public void test9_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         long result = test9(rL, v, 2*rL);
         Asserts.assertEQ(result, v.hashInterpreted() - rL);
     }
 
     @DontCompile
@@ -213,11 +213,11 @@
         return test10_interp(i, v, l);
     }
 
     @DontCompile
     public void test10_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         long result = test10(rI, v, rL);
         Asserts.assertEQ(result, v.hashInterpreted() + rL + rI);
     }
 
     @DontCompile
@@ -230,11 +230,11 @@
         return test11_interp(l, v, i);
     }
 
     @DontCompile
     public void test11_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         long result = test11(rL, v, rI);
         Asserts.assertEQ(result, v.hashInterpreted() + rL + rI);
     }
 
     @DontCompile
@@ -248,11 +248,11 @@
     }
 
     @DontCompile
     public void test12_verifier(boolean warmup) {
         MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI, rL);
-        MyValue2 v2 = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v2 = MyValue2.createWithFieldsInline(rI, rD);
         long result = test12(rL, v1, rI, v2);
         Asserts.assertEQ(result, v1.hashInterpreted() + rL + rI + v2.hashInterpreted());
     }
 
     // Test that debug info at a call is correct
@@ -270,11 +270,11 @@
         return test13_interp(v, va, flag) + l;
     }
 
     @DontCompile
     public void test13_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         MyValue1[] va = new MyValue1[2];
         va[0] = MyValue1.createWithFieldsDontInline(rI, rL);
         va[1] = MyValue1.createWithFieldsDontInline(rI, rL);
         long result = test13(v, va, !warmup, rL);
         Asserts.assertEQ(result, v.hashInterpreted() + va[0].hash() + va[1].hash() + rL);
@@ -285,22 +285,22 @@
     public MyValue2 test14_interp(boolean deopt) {
         if (deopt) {
             // uncommon trap
             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + "::test14"));
         }
-        return MyValue2.createWithFieldsInline(rI, true);
+        return MyValue2.createWithFieldsInline(rI, rD);
     }
 
     @Test()
     public MyValue2 test14(boolean flag) {
         return test14_interp(flag);
     }
 
     @DontCompile
     public void test14_verifier(boolean warmup) {
         MyValue2 result = test14(!warmup);
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         Asserts.assertEQ(result.hash(), v.hash());
     }
 
     // Return inline types in registers from interpreter -> compiled
     final MyValue3 test15_vt = MyValue3.create();
@@ -507,11 +507,11 @@
     @ForceInline
     public MyValue2.ref test26_callee(boolean b) {
         if (b) {
             return null;
         } else {
-            return MyValue2.createWithFieldsInline(rI, true);
+            return MyValue2.createWithFieldsInline(rI, rD);
         }
     }
 
     @Test
     public MyValue2.ref test26(boolean b) {
@@ -521,11 +521,11 @@
     @DontCompile
     public void test26_verifier(boolean warmup) {
         MyValue2.ref vt = test26(true);
         Asserts.assertEQ(vt, null);
         vt = test26(false);
-        Asserts.assertEQ(vt.hash(), MyValue2.createWithFieldsInline(rI, true).hash());
+        Asserts.assertEQ(vt.hash(), MyValue2.createWithFieldsInline(rI, rD).hash());
     }
 
     // Test calling convention with deep hierarchy of flattened fields
     final inline class Test27Value1 {
         final Test27Value2 valueField;
@@ -644,22 +644,22 @@
     public MyValue2 test32_interp(boolean deopt) {
         if (deopt) {
             // uncommon trap
             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + "::test32"));
         }
-        return MyValue2.createWithFieldsInline(rI+32, true);
+        return MyValue2.createWithFieldsInline(rI+32, rD);
     }
 
     @Test()
     public MyValue2 test32(boolean flag) throws Throwable {
         return (MyValue2)test32_mh.invokeExact(this, flag);
     }
 
     @DontCompile
     public void test32_verifier(boolean warmup) throws Throwable {
         MyValue2 result = test32(!warmup);
-        MyValue2 v = MyValue2.createWithFieldsInline(rI+32, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI+32, rD);
         Asserts.assertEQ(result.hash(), v.hash());
     }
 
     // Same as test32, except the return type is not flattenable.
     static MethodHandle test33_mh;
@@ -668,11 +668,11 @@
     public Object test33_interp(boolean deopt) {
         if (deopt) {
             // uncommon trap
             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + "::test33"));
         }
-        return MyValue2.createWithFieldsInline(rI+33, true);
+        return MyValue2.createWithFieldsInline(rI+33, rD);
     }
 
     @Test()
     public MyValue2 test33(boolean flag) throws Throwable {
         Object o = test33_mh.invokeExact(this, flag);
@@ -680,11 +680,11 @@
     }
 
     @DontCompile
     public void test33_verifier(boolean warmup) throws Throwable {
         MyValue2 result = test33(!warmup);
-        MyValue2 v = MyValue2.createWithFieldsInline(rI+33, true);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI+33, rD);
         Asserts.assertEQ(result.hash(), v.hash());
     }
 
     // Test selection of correct entry point in SharedRuntime::handle_wrong_method
     static boolean test34_deopt = false;
@@ -713,11 +713,11 @@
         return test34_callee(vt, i1, i2, i3, i4);
     }
 
     @DontCompile
     public void test34_verifier(boolean warmup) {
-        MyValue2 vt = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);
         long result = test34(vt, rI, rI, rI, rI);
         Asserts.assertEQ(result, vt.hash()+4*rI);
         if (!warmup) {
             test34_deopt = true;
             for (int i = 0; i < 100; ++i) {
@@ -738,11 +738,11 @@
         return vt.hash() + i1 + i2 + i3 + i4 + result;
     }
 
     @DontCompile
     public void test35_verifier(boolean warmup) {
-        MyValue2 vt = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);
         long result = test35(vt, rI, rI, rI, rI);
         Asserts.assertEQ(result, vt.hash()+10004*rI);
     }
 
     // Same as test31 but with GC in callee to verify that the
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestIntrinsics.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestIntrinsics.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestIntrinsics.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestIntrinsics.java
@@ -115,13 +115,13 @@
 
     // Verify that Class::getSuperclass checks with statically known classes are folded
     @Test(failOn = LOADK)
     public boolean test4() {
         boolean check1 = Object.class.getSuperclass() == null;
-        // TODO Remove cast as workaround once javac is fixed
+        // TODO 8244562: Remove cast as workaround once javac is fixed
         boolean check2 = (Class<?>)MyValue1.ref.class.getSuperclass() == MyAbstract.class;
-        // TODO Remove cast as workaround once javac is fixed
+        // TODO 8244562: Remove cast as workaround once javac is fixed
         boolean check3 = (Class<?>)MyValue1.val.class.getSuperclass() == MyValue1.ref.class;
         boolean check4 = Class.class.getSuperclass() == Object.class;
         return check1 && check2 && check3 && check4;
     }
 
@@ -435,14 +435,13 @@
 
     final Test25Value[] test25Array = new Test25Value[10];
 
     @Test
     public Test25Value[] test25(Test25Value element) {
-        // TODO Remove cast as workaround once javac is fixed
-        Test25Value[] newArray = (Test25Value[])Arrays.copyOf(test25Array, test25Array.length + 1);
+        Object[] newArray = Arrays.copyOf(test25Array, test25Array.length + 1);
         newArray[test25Array.length] = element;
-        return newArray;
+        return (Test25Value[]) newArray;
     }
 
     @DontCompile
     public void test25_verifier(boolean warmup) {
         Test25Value vt = new Test25Value();
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorld.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorld.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorld.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorld.java
@@ -64,11 +64,11 @@
     }
 
     // Helper methods
 
     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
-    private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, true);
+    private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, rD);
 
     protected long hash() {
         return testValue1.hash();
     }
 
@@ -184,11 +184,11 @@
         } else if (state == 4) {
             res = valueField1;
         } else if (state == 5) {
             res = null;
         } else if (state == 6) {
-            res = MyValue2.createWithFieldsInline(rI, true);
+            res = MyValue2.createWithFieldsInline(rI, rD);
         } else if (state == 7) {
             res = testValue2;
         }
         return res;
     }
@@ -1626,11 +1626,11 @@
     }
 
     @Test()
     public Object test55(boolean b) {
         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI, rL);
-        MyValue2 vt2 = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 vt2 = MyValue2.createWithFieldsInline(rI, rD);
         return b ? vt1 : vt2;
     }
 
     @DontCompile
     public void test55_verifier(boolean warmup) {
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorldProfiling.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorldProfiling.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorldProfiling.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestLWorldProfiling.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -76,11 +76,11 @@
         TestLWorldProfiling test = new TestLWorldProfiling();
         test.run(args, MyValue1.class, MyValue2.class);
     }
 
     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
-    private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, true);
+    private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, rD);
     private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1};
     private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2};
     private static final Integer[] testIntegerArray = new Integer[] {42};
     private static final Long[] testLongArray = new Long[] {42L};
     private static final Double[] testDoubleArray = new Double[] {42.0D};
@@ -387,11 +387,14 @@
     @DontCompile
     public void test15_verifier(boolean warmup) {
         test15(testNotFlattenableArray, notFlattenable);
         try {
             test15(testNotFlattenableArray, null);
-        } catch (NullPointerException npe) {  }
+            throw new RuntimeException("NullPointerException expected");
+        } catch (NullPointerException npe) {
+            // Expected
+        }
     }
 
     @Warmup(10000)
     @Test(valid = ArrayLoadStoreProfileOn, match = { NULL_CHECK_TRAP }, matchCount = { 2 }, failOn = STORE_UNKNOWN_INLINE)
     @Test(match = { NULL_CHECK_TRAP, STORE_UNKNOWN_INLINE }, matchCount = { 3, 1 })
@@ -402,11 +405,14 @@
     @DontCompile
     public void test16_verifier(boolean warmup) {
         test16(testNotFlattenableArray, notFlattenable);
         try {
             test16(testNotFlattenableArray, null);
-        } catch (NullPointerException npe) {  }
+            throw new RuntimeException("NullPointerException expected");
+        } catch (NullPointerException npe) {
+            // Expected
+        }
         test16(testIntegerArray, 42);
     }
 
     @Warmup(10000)
     @Test(valid = ArrayLoadStoreProfileOn, match = { NULL_CHECK_TRAP }, matchCount = { 1 }, failOn = STORE_UNKNOWN_INLINE)
@@ -416,13 +422,12 @@
     }
 
     @DontCompile
     public void test17_verifier(boolean warmup) {
         test17(testIntegerArray, 42);
-        try {
-            test17(testIntegerArray, null);
-        } catch (NullPointerException npe) {  }
+        test17(testIntegerArray, null);
+        testIntegerArray[0] = 42;
         test17(testLongArray, 42L);
     }
 
     public void test18_helper(Object[] array, Object v) {
         array[0] = v;
@@ -439,13 +444,12 @@
 
     @DontCompile
     public void test18_verifier(boolean warmup) {
         test18_helper(testValue1Array, testValue1); // pollute profile
         test18(testIntegerArray, 42);
-        try {
-            test18(testIntegerArray, null);
-        } catch (NullPointerException npe) {  }
+        test18(testIntegerArray, null);
+        testIntegerArray[0] = 42;
         test18(testLongArray, 42L);
     }
 
     // maybe null free, not flat
 
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestMethodHandles.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestMethodHandles.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestMethodHandles.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestMethodHandles.java
@@ -290,16 +290,16 @@
 
     // Similar as above but with the method handle for target1 not
     // constant. Shouldn't cause any allocation.
     @ForceInline
     static MyValue2 test7_target1() {
-        return MyValue2.createWithFieldsInline(rI, true);
+        return MyValue2.createWithFieldsInline(rI, rD);
     }
 
     @ForceInline
     static MyValue2 test7_target2() {
-        return MyValue2.createWithFieldsInline(rI+1, false);
+        return MyValue2.createWithFieldsInline(rI+1, rD+1);
     }
 
     static boolean test7_bool = true;
     @ForceInline
     static boolean test7_test() {
@@ -316,23 +316,23 @@
 
     @DontCompile
     public void test7_verifier(boolean warmup) throws Throwable {
         test7_bool = !test7_bool;
         long hash = test7();
-        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(rI+(test7_bool ? 0 : 1), test7_bool).hash());
+        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(rI+(test7_bool ? 0 : 1), rD+(test7_bool ? 0 : 1)).hash());
     }
 
     // Same as above but with the method handle for target2 not
     // constant. Shouldn't cause any allocation.
     @ForceInline
     static MyValue2 test8_target1() {
-        return MyValue2.createWithFieldsInline(rI, true);
+        return MyValue2.createWithFieldsInline(rI, rD);
     }
 
     @ForceInline
     static MyValue2 test8_target2() {
-        return MyValue2.createWithFieldsInline(rI+1, false);
+        return MyValue2.createWithFieldsInline(rI+1, rD+1);
     }
 
     static boolean test8_bool = true;
     @ForceInline
     static boolean test8_test() {
@@ -349,11 +349,11 @@
 
     @DontCompile
     public void test8_verifier(boolean warmup) throws Throwable {
         test8_bool = !test8_bool;
         long hash = test8();
-        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(rI+(test8_bool ? 0 : 1), test8_bool).hash());
+        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(rI+(test8_bool ? 0 : 1), rD+(test8_bool ? 0 : 1)).hash());
     }
 
     // Return of target1, target2 and target3 merged in Lambda Forms
     // as an Object. Shouldn't cause any allocation
     final MyValue3 test9_vt1 = MyValue3.create();
@@ -405,21 +405,21 @@
     }
 
     // Same as above but with non constant target2 and target3
     @ForceInline
     static MyValue2 test10_target1() {
-        return MyValue2.createWithFieldsInline(rI, true);
+        return MyValue2.createWithFieldsInline(rI, rD);
     }
 
     @ForceInline
     static MyValue2 test10_target2() {
-        return MyValue2.createWithFieldsInline(rI+1, false);
+        return MyValue2.createWithFieldsInline(rI+1, rD+1);
     }
 
     @ForceInline
     static MyValue2 test10_target3() {
-        return MyValue2.createWithFieldsInline(rI+2, true);
+        return MyValue2.createWithFieldsInline(rI+2, rD+2);
     }
 
     static boolean test10_bool1 = true;
     @ForceInline
     static boolean test10_test1() {
@@ -447,25 +447,25 @@
     public void test10_verifier(boolean warmup) throws Throwable {
         test10_i++;
         test10_bool1 = (test10_i % 2) == 0;
         test10_bool2 = (test10_i % 3) == 0;
         long hash = test10();
-        int i = rI+(test10_bool1 ? 0 : (test10_bool2 ? 1 : 2));
-        boolean b = test10_bool1 ? true : (test10_bool2 ? false : true);
-        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(i, b).hash());
+        int i = rI + (test10_bool1 ? 0 : (test10_bool2 ? 1 : 2));
+        double d = rD + (test10_bool1 ? 0 : (test10_bool2 ? 1 : 2));
+        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(i, d).hash());
     }
 
     static int test11_i = 0;
 
     @ForceInline
     static MyValue2 test11_target1() {
-        return MyValue2.createWithFieldsInline(rI+test11_i, true);
+        return MyValue2.createWithFieldsInline(rI+test11_i, rD+test11_i);
     }
 
     @ForceInline
     static MyValue2 test11_target2() {
-        return MyValue2.createWithFieldsInline(rI-test11_i, false);
+        return MyValue2.createWithFieldsInline(rI-test11_i, rD-test11_i);
     }
 
     @ForceInline
     static boolean test11_test() {
         return (test11_i % 100) == 0;
@@ -485,8 +485,8 @@
     @DontCompile
     public void test11_verifier(boolean warmup) throws Throwable {
         test11_i++;
         long hash = test11();
         boolean b = (test11_i % 100) == 0;
-        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(rI+test11_i * (b ? 1 : -1), b).hash());
+        Asserts.assertEQ(hash, MyValue2.createWithFieldsInline(rI+test11_i * (b ? 1 : -1), rD+test11_i * (b ? 1 : -1)).hash());
     }
 }
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java
@@ -103,13 +103,11 @@
             Asserts.assertEQ(va[i].hash(), hash());
         }
     }
 
     // Test creation of an inline type array and element access
-    @Test
-    // TODO 8227588
-    // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
+    @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     public long test2() {
         MyValue1.ref[] va = new MyValue1.ref[1];
         va[0] = MyValue1.createWithFieldsInline(rI, rL);
         return va[0].hash();
     }
@@ -607,17 +605,17 @@
         MyValue2.ref[] dst1 = new MyValue2.ref[len];
         MyValue2[]  dst2 = new MyValue2[len];
         MyValue2.ref[] dst3 = new MyValue2.ref[len];
         MyValue2[]  dst4 = new MyValue2[len];
         if (len > 0) {
-            src2[0] = MyValue2.createWithFieldsInline(rI, true);
+            src2[0] = MyValue2.createWithFieldsInline(rI, rD);
         }
         for (int i = 1; i < len; ++i) {
-            src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
-            src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
-            src3[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
-            src4[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
+            src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
+            src3[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
+            src4[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test21(src1, dst1);
         test21(src2, dst2);
         test21(src3, dst3);
         test21(src4, dst4);
@@ -753,16 +751,16 @@
         MyValue2[]  src4 = new MyValue2[8];
         MyValue2.ref[] dst1 = new MyValue2.ref[8];
         MyValue2[]  dst2 = new MyValue2[8];
         MyValue2.ref[] dst3 = new MyValue2.ref[8];
         MyValue2[]  dst4 = new MyValue2[8];
-        src2[0] = MyValue2.createWithFieldsInline(rI, true);
+        src2[0] = MyValue2.createWithFieldsInline(rI, rD);
         for (int i = 1; i < 8; ++i) {
-            src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
-            src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
-            src3[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
-            src4[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
+            src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
+            src3[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
+            src4[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test25(src1, dst1);
         test25(src2, dst2);
         test25(src3, dst3);
         test25(src4, dst4);
@@ -856,11 +854,11 @@
             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
         }
     }
 
     // non escaping allocations
-    // TODO ZGC does not support the clone intrinsic, remove this once JDK-8232896 is fixed
+    // TODO 8252027: Make sure this is optimized with ZGC
     @Test(valid = ZGCOff, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     @Test(valid = ZGCOn)
     public MyValue2.ref test28() {
         MyValue2.ref[] src = new MyValue2.ref[10];
         src[0] = null;
@@ -868,11 +866,11 @@
         return dst[0];
     }
 
     @DontCompile
     public void test28_verifier(boolean warmup) {
-        MyValue2 v = MyValue2.createWithFieldsInline(rI, false);
+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);
         MyValue2.ref result = test28();
         Asserts.assertEQ(result, null);
     }
 
     // non escaping allocations
@@ -887,12 +885,12 @@
     @DontCompile
     public void test29_verifier(boolean warmup) {
         MyValue2.ref[] src1 = new MyValue2.ref[10];
         MyValue2.val[] src2 = new MyValue2.val[10];
         for (int i = 0; i < 10; ++i) {
-            src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
-            src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
+            src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         MyValue2.ref v = test29(src1);
         Asserts.assertEQ(src1[0].hash(), v.hash());
         if (!warmup) {
             v = test29(src2);
@@ -914,12 +912,12 @@
     @DontCompile
     public void test30_verifier(boolean warmup) {
         MyValue2.ref[] src1 = new MyValue2.ref[10];
         MyValue2.val[] src2 = new MyValue2.val[10];
         for (int i = 0; i < 10; ++i) {
-            src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
-            src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
+            src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         MyValue2.ref v = test30(src1, !warmup);
         Asserts.assertEQ(src1[0].hash(), v.hash());
         if (!warmup) {
             v = test30(src2, true);
@@ -932,27 +930,27 @@
     // TODO 8227588
     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     public long test31(boolean b, boolean deopt) {
         MyValue2.ref[] src = new MyValue2.ref[1];
         if (b) {
-            src[0] = MyValue2.createWithFieldsInline(rI, true);
+            src[0] = MyValue2.createWithFieldsInline(rI, rD);
         } else {
-            src[0] = MyValue2.createWithFieldsInline(rI, false);
+            src[0] = MyValue2.createWithFieldsInline(rI+1, rD+1);
         }
         if (deopt) {
             // uncommon trap
             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + "::test31"));
         }
         return src[0].hash();
     }
 
     @DontCompile
     public void test31_verifier(boolean warmup) {
-        MyValue2 v1 = MyValue2.createWithFieldsInline(rI, true);
+        MyValue2 v1 = MyValue2.createWithFieldsInline(rI, rD);
         long result1 = test31(true, !warmup);
         Asserts.assertEQ(result1, v1.hash());
-        MyValue2 v2 = MyValue2.createWithFieldsInline(rI, false);
+        MyValue2 v2 = MyValue2.createWithFieldsInline(rI+1, rD+1);
         long result2 = test31(false, !warmup);
         Asserts.assertEQ(result2, v2.hash());
     }
 
     // Tests with Object arrays and clone/arraycopy
@@ -1133,11 +1131,11 @@
     public void test36_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         MyValue2.ref[] src = new MyValue2.ref[len];
         MyValue2.ref[] dst = new MyValue2.ref[len];
         for (int i = 1; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test36(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestNullableArrays::test36")) {
             test36(src, dst);
@@ -1154,11 +1152,11 @@
     public void test37_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         MyValue2.ref[] src = new MyValue2.ref[len];
         MyValue2.ref[] dst = new MyValue2.ref[len];
         for (int i = 1; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test37(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestNullableArrays::test37")) {
             test37(src, dst);
@@ -1176,11 +1174,11 @@
     public void test38_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         Object[] src = new Object[len];
         MyValue2.ref[] dst = new MyValue2.ref[len];
         for (int i = 1; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test38(src, dst);
         verify(dst, src);
         if (!warmup) {
             Method m = tests.get("TestNullableArrays::test38");
@@ -1203,11 +1201,11 @@
     public void test39_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         MyValue2.ref[] src = new MyValue2.ref[len];
         Object[] dst = new Object[len];
         for (int i = 1; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test39(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestNullableArrays::test39")) {
             test39(src, dst);
@@ -1225,11 +1223,11 @@
     public void test40_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         Object[] src = new Object[len];
         MyValue2.ref[] dst = new MyValue2.ref[len];
         for (int i = 1; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test40(src, dst);
         verify(dst, src);
         if (!warmup) {
             Method m = tests.get("TestNullableArrays::test40");
@@ -1252,11 +1250,11 @@
     public void test41_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         MyValue2.ref[] src = new MyValue2.ref[len];
         Object[] dst = new Object[len];
         for (int i = 1; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test41(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestNullableArrays::test41")) {
             test41(src, dst);
@@ -1273,11 +1271,11 @@
     public void test42_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         Object[] src = new Object[len];
         Object[] dst = new Object[len];
         for (int i = 1; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test42(src, dst);
         verify(src, dst);
         if (!warmup) {
             Method m = tests.get("TestNullableArrays::test42");
@@ -1316,11 +1314,11 @@
     @DontCompile
     public void test44_verifier(boolean warmup) {
         MyValue2.ref[] src = new MyValue2.ref[8];
         MyValue2.ref[] dst = new MyValue2.ref[8];
         for (int i = 1; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test44(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestNullableArrays::test44")) {
             test44(src, dst);
@@ -1336,11 +1334,11 @@
     @DontCompile
     public void test45_verifier(boolean warmup) {
         MyValue2.ref[] src = new MyValue2.ref[8];
         MyValue2.ref[] dst = new MyValue2.ref[8];
         for (int i = 1; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test45(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestNullableArrays::test45")) {
             test45(src, dst);
@@ -1357,11 +1355,11 @@
     @DontCompile
     public void test46_verifier(boolean warmup) {
         Object[] src = new Object[8];
         MyValue2.ref[] dst = new MyValue2.ref[8];
         for (int i = 1; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test46(src, dst);
         verify(dst, src);
         if (!warmup) {
             Method m = tests.get("TestNullableArrays::test46");
@@ -1383,11 +1381,11 @@
     @DontCompile
     public void test47_verifier(boolean warmup) {
         MyValue2.ref[] src = new MyValue2.ref[8];
         Object[] dst = new Object[8];
         for (int i = 1; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test47(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestNullableArrays::test47")) {
             test47(src, dst);
@@ -1404,11 +1402,11 @@
     @DontCompile
     public void test48_verifier(boolean warmup) {
         Object[] src = new Object[8];
         MyValue2.ref[] dst = new MyValue2.ref[8];
         for (int i = 1; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test48(src, dst);
         verify(dst, src);
         if (!warmup) {
             Method m = tests.get("TestNullableArrays::test48");
@@ -1430,11 +1428,11 @@
     @DontCompile
     public void test49_verifier(boolean warmup) {
         MyValue2.ref[] src = new MyValue2.ref[8];
         Object[] dst = new Object[8];
         for (int i = 1; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test49(src, dst);
         verify(src, dst);
         if (compile_and_run_again_if_deoptimized(warmup, "TestNullableArrays::test49")) {
             test49(src, dst);
@@ -1450,11 +1448,11 @@
     @DontCompile
     public void test50_verifier(boolean warmup) {
         Object[] src = new Object[8];
         Object[] dst = new Object[8];
         for (int i = 1; i < 8; ++i) {
-            src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);
         }
         test50(src, dst);
         verify(src, dst);
         if (!warmup) {
             Method m = tests.get("TestNullableArrays::test50");
@@ -1846,11 +1844,11 @@
     public void test71() {
         int len = 10;
         MyValue2.ref[] src = new MyValue2.ref[len];
         MyValue2.ref[] dst = new MyValue2.ref[len];
         for (int i = 1; i < len; ++i) {
-            src[i] = MyValue2.createWithFieldsDontInline(rI, (i % 2) == 0);
+            src[i] = MyValue2.createWithFieldsDontInline(rI+i, rD+i);
         }
         System.arraycopy(src, 0, dst, 0, src.length);
         for (int i = 0; i < len; ++i) {
             if (src[i] == null) {
                 Asserts.assertEQ(dst[i], null);
