<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.inlinetypes;
  25 
  26 import jdk.test.lib.Asserts;
  27 import java.lang.reflect.Method;
  28 import java.util.Arrays;
  29 
  30 /*
  31  * @test
  32  * @key randomness
  33  * @summary Test nullable inline type arrays
  34  * @library /testlibrary /test/lib /compiler/whitebox /
  35  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  36  * @compile TestNullableArrays.java
  37  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  38  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  39  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  40  *                               compiler.valhalla.inlinetypes.InlineTypeTest
  41  *                               compiler.valhalla.inlinetypes.TestNullableArrays
  42  */
  43 public class TestNullableArrays extends InlineTypeTest {
  44     // Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to
  45     // a normal method invocation when encountering flattened arrays.
  46     private static void assertDeoptimizedByC2(Method m) {
  47         if (isCompiledByC2(m)) {
  48             throw new RuntimeException(&quot;Type check should have caused it to deoptimize&quot;);
  49         }
  50     }
  51 
  52     // Extra VM parameters for some test scenarios. See InlineTypeTest.getVMParameters()
  53     @Override
  54     public String[] getExtraVMParameters(int scenario) {
  55         switch (scenario) {
  56         case 2: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  57         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  58         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  59         case 5: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  60         }
  61         return null;
  62     }
  63 
  64     public static void main(String[] args) throws Throwable {
  65         TestNullableArrays test = new TestNullableArrays();
  66         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  67     }
  68 
  69     // Helper methods
  70 
  71     protected long hash() {
  72         return hash(rI, rL);
  73     }
  74 
  75     protected long hash(int x, long y) {
  76         return MyValue1.createWithFieldsInline(x, y).hash();
  77     }
  78 
  79     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  80 
  81     // Test nullable inline type array creation and initialization
  82     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
  83     @Test(valid = InlineTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
  84     public MyValue1.ref[] test1(int len) {
  85         MyValue1.ref[] va = new MyValue1.ref[len];
  86         if (len &gt; 0) {
  87             va[0] = null;
  88         }
  89         for (int i = 1; i &lt; len; ++i) {
  90             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  91         }
  92         return va;
  93     }
  94 
  95     @DontCompile
  96     public void test1_verifier(boolean warmup) {
  97         int len = Math.abs(rI % 10);
  98         MyValue1.ref[] va = test1(len);
  99         if (len &gt; 0) {
 100             Asserts.assertEQ(va[0], null);
 101         }
 102         for (int i = 1; i &lt; len; ++i) {
 103             Asserts.assertEQ(va[i].hash(), hash());
 104         }
 105     }
 106 
 107     // Test creation of an inline type array and element access
<a name="1" id="anc1"></a><span class="line-modified"> 108     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>


 109     public long test2() {
 110         MyValue1.ref[] va = new MyValue1.ref[1];
 111         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 112         return va[0].hash();
 113     }
 114 
 115     @DontCompile
 116     public void test2_verifier(boolean warmup) {
 117         long result = test2();
 118         Asserts.assertEQ(result, hash());
 119     }
 120 
 121     // Test receiving an inline type array from the interpreter,
 122     // updating its elements in a loop and computing a hash.
 123     @Test(failOn = ALLOCA)
 124     public long test3(MyValue1.ref[] va) {
 125         long result = 0;
 126         for (int i = 0; i &lt; 10; ++i) {
 127             if (va[i] != null) {
 128                 result += va[i].hash();
 129             }
 130             va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 131         }
 132         va[0] = null;
 133         return result;
 134     }
 135 
 136     @DontCompile
 137     public void test3_verifier(boolean warmup) {
 138         MyValue1.ref[] va = new MyValue1.ref[10];
 139         long expected = 0;
 140         for (int i = 1; i &lt; 10; ++i) {
 141             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 142             expected += va[i].hash();
 143         }
 144         long result = test3(va);
 145         Asserts.assertEQ(expected, result);
 146         Asserts.assertEQ(va[0], null);
 147         for (int i = 1; i &lt; 10; ++i) {
 148             if (va[i].hash() != hash(rI + 1, rL + 1)) {
 149                 Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));
 150             }
 151         }
 152     }
 153 
 154     // Test returning an inline type array received from the interpreter
 155     @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
 156     public MyValue1.ref[] test4(MyValue1.ref[] va) {
 157         return va;
 158     }
 159 
 160     @DontCompile
 161     public void test4_verifier(boolean warmup) {
 162         MyValue1.ref[] va = new MyValue1.ref[10];
 163         for (int i = 0; i &lt; 10; ++i) {
 164             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 165         }
 166         va = test4(va);
 167         for (int i = 0; i &lt; 10; ++i) {
 168             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 169         }
 170     }
 171 
 172     // Merge inline type arrays created from two branches
 173     @Test
 174     public MyValue1.ref[] test5(boolean b) {
 175         MyValue1.ref[] va;
 176         if (b) {
 177             va = new MyValue1.ref[5];
 178             for (int i = 0; i &lt; 5; ++i) {
 179                 va[i] = MyValue1.createWithFieldsInline(rI, rL);
 180             }
 181             va[4] = null;
 182         } else {
 183             va = new MyValue1.ref[10];
 184             for (int i = 0; i &lt; 10; ++i) {
 185                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
 186             }
 187             va[9] = null;
 188         }
 189         long sum = va[0].hashInterpreted();
 190         if (b) {
 191             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
 192         } else {
 193             va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);
 194         }
 195         return va;
 196     }
 197 
 198     @DontCompile
 199     public void test5_verifier(boolean warmup) {
 200         MyValue1.ref[] va = test5(true);
 201         Asserts.assertEQ(va.length, 5);
 202         Asserts.assertEQ(va[0].hash(), hash(rI, hash()));
 203         for (int i = 1; i &lt; 4; ++i) {
 204             Asserts.assertEQ(va[i].hash(), hash());
 205         }
 206         Asserts.assertEQ(va[4], null);
 207         va = test5(false);
 208         Asserts.assertEQ(va.length, 10);
 209         Asserts.assertEQ(va[0].hash(), hash(rI + 1, hash(rI, rL) + 1));
 210         for (int i = 1; i &lt; 9; ++i) {
 211             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 212         }
 213         Asserts.assertEQ(va[9], null);
 214     }
 215 
 216     // Test creation of inline type array with single element
 217     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 218     public MyValue1.ref test6() {
 219         MyValue1.ref[] va = new MyValue1.ref[1];
 220         return va[0];
 221     }
 222 
 223     @DontCompile
 224     public void test6_verifier(boolean warmup) {
 225         MyValue1.ref[] va = new MyValue1.ref[1];
 226         MyValue1.ref v = test6();
 227         Asserts.assertEQ(v, null);
 228     }
 229 
 230     // Test default initialization of inline type arrays
 231     @Test(failOn = LOAD)
 232     public MyValue1.ref[] test7(int len) {
 233         return new MyValue1.ref[len];
 234     }
 235 
 236     @DontCompile
 237     public void test7_verifier(boolean warmup) {
 238         int len = Math.abs(rI % 10);
 239         MyValue1.ref[] va = test7(len);
 240         for (int i = 0; i &lt; len; ++i) {
 241             Asserts.assertEQ(va[i], null);
 242             va[i] = null;
 243         }
 244     }
 245 
 246     // Test creation of inline type array with zero length
 247     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
 248     public MyValue1.ref[] test8() {
 249         return new MyValue1.ref[0];
 250     }
 251 
 252     @DontCompile
 253     public void test8_verifier(boolean warmup) {
 254         MyValue1.ref[] va = test8();
 255         Asserts.assertEQ(va.length, 0);
 256     }
 257 
 258     static MyValue1.ref[] test9_va;
 259 
 260     // Test that inline type array loaded from field has correct type
 261     @Test(failOn = LOOP)
 262     public long test9() {
 263         return test9_va[0].hash();
 264     }
 265 
 266     @DontCompile
 267     public void test9_verifier(boolean warmup) {
 268         test9_va = new MyValue1.ref[1];
 269         test9_va[0] = testValue1;
 270         long result = test9();
 271         Asserts.assertEQ(result, hash());
 272     }
 273 
 274     // Multi-dimensional arrays
 275     @Test
 276     public MyValue1.ref[][][] test10(int len1, int len2, int len3) {
 277         MyValue1.ref[][][] arr = new MyValue1.ref[len1][len2][len3];
 278         for (int i = 0; i &lt; len1; i++) {
 279             for (int j = 0; j &lt; len2; j++) {
 280                 for (int k = 0; k &lt; len3; k++) {
 281                     arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);
 282                     if (k == 0) {
 283                         arr[i][j][k] = null;
 284                     }
 285                 }
 286             }
 287         }
 288         return arr;
 289     }
 290 
 291     @DontCompile
 292     public void test10_verifier(boolean warmup) {
 293         MyValue1.ref[][][] arr = test10(2, 3, 4);
 294         for (int i = 0; i &lt; 2; i++) {
 295             for (int j = 0; j &lt; 3; j++) {
 296                 for (int k = 0; k &lt; 4; k++) {
 297                     if (k == 0) {
 298                         Asserts.assertEQ(arr[i][j][k], null);
 299                     } else {
 300                         Asserts.assertEQ(arr[i][j][k].hash(), MyValue1.createWithFieldsDontInline(rI + i , rL + j + k).hash());
 301                     }
 302                     arr[i][j][k] = null;
 303                 }
 304             }
 305         }
 306     }
 307 
 308     @Test
 309     public void test11(MyValue1.ref[][][] arr, long[] res) {
 310         int l = 0;
 311         for (int i = 0; i &lt; arr.length; i++) {
 312             for (int j = 0; j &lt; arr[i].length; j++) {
 313                 for (int k = 0; k &lt; arr[i][j].length; k++) {
 314                     if (arr[i][j][k] != null) {
 315                         res[l] = arr[i][j][k].hash();
 316                     }
 317                     arr[i][j][k] = null;
 318                     l++;
 319                 }
 320             }
 321         }
 322     }
 323 
 324     @DontCompile
 325     public void test11_verifier(boolean warmup) {
 326         MyValue1.ref[][][] arr = new MyValue1.ref[2][3][4];
 327         long[] res = new long[2*3*4];
 328         long[] verif = new long[2*3*4];
 329         int l = 0;
 330         for (int i = 0; i &lt; 2; i++) {
 331             for (int j = 0; j &lt; 3; j++) {
 332                 for (int k = 0; k &lt; 4; k++) {
 333                     if (j != 2) {
 334                         arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i, rL + j + k);
 335                         verif[l] = arr[i][j][k].hash();
 336                     }
 337                     l++;
 338                 }
 339             }
 340         }
 341         test11(arr, res);
 342         for (int i = 0; i &lt; verif.length; i++) {
 343             Asserts.assertEQ(res[i], verif[i]);
 344         }
 345     }
 346 
 347     // Array load out of bounds (upper bound) at compile time
 348     @Test
 349     public int test12() {
 350         int arraySize = Math.abs(rI) % 10;
 351         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 352 
 353         for (int i = 0; i &lt; arraySize; i++) {
 354             va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 355         }
 356 
 357         try {
 358             return va[arraySize + 1].x;
 359         } catch (ArrayIndexOutOfBoundsException e) {
 360             return rI;
 361         }
 362     }
 363 
 364     public void test12_verifier(boolean warmup) {
 365         Asserts.assertEQ(test12(), rI);
 366     }
 367 
 368     // Array load  out of bounds (lower bound) at compile time
 369     @Test
 370     public int test13() {
 371         int arraySize = Math.abs(rI) % 10;
 372         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 373 
 374         for (int i = 0; i &lt; arraySize; i++) {
 375             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);
 376         }
 377 
 378         try {
 379             return va[-arraySize].x;
 380         } catch (ArrayIndexOutOfBoundsException e) {
 381             return rI;
 382         }
 383     }
 384 
 385     public void test13_verifier(boolean warmup) {
 386         Asserts.assertEQ(test13(), rI);
 387     }
 388 
 389     // Array load out of bound not known to compiler (both lower and upper bound)
 390     @Test
 391     public int test14(MyValue1.ref[] va, int index)  {
 392         return va[index].x;
 393     }
 394 
 395     public void test14_verifier(boolean warmup) {
 396         int arraySize = Math.abs(rI) % 10;
 397         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 398 
 399         for (int i = 0; i &lt; arraySize; i++) {
 400             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 401         }
 402 
 403         int result;
 404         for (int i = -20; i &lt; 20; i++) {
 405             try {
 406                 result = test14(va, i);
 407             } catch (ArrayIndexOutOfBoundsException e) {
 408                 result = rI;
 409             }
 410             Asserts.assertEQ(result, rI);
 411         }
 412     }
 413 
 414     // Array store out of bounds (upper bound) at compile time
 415     @Test
 416     public int test15() {
 417         int arraySize = Math.abs(rI) % 10;
 418         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 419 
 420         try {
 421             for (int i = 0; i &lt;= arraySize; i++) {
 422                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 423             }
 424             return rI - 1;
 425         } catch (ArrayIndexOutOfBoundsException e) {
 426             return rI;
 427         }
 428     }
 429 
 430     public void test15_verifier(boolean warmup) {
 431         Asserts.assertEQ(test15(), rI);
 432     }
 433 
 434     // Array store out of bounds (lower bound) at compile time
 435     @Test
 436     public int test16() {
 437         int arraySize = Math.abs(rI) % 10;
 438         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 439 
 440         try {
 441             for (int i = -1; i &lt;= arraySize; i++) {
 442                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 443             }
 444             return rI - 1;
 445         } catch (ArrayIndexOutOfBoundsException e) {
 446             return rI;
 447         }
 448     }
 449 
 450     public void test16_verifier(boolean warmup) {
 451         Asserts.assertEQ(test16(), rI);
 452     }
 453 
 454     // Array store out of bound not known to compiler (both lower and upper bound)
 455     @Test
 456     public int test17(MyValue1.ref[] va, int index, MyValue1 vt)  {
 457         va[index] = vt;
 458         return va[index].x;
 459     }
 460 
 461     @DontCompile
 462     public void test17_verifier(boolean warmup) {
 463         int arraySize = Math.abs(rI) % 10;
 464         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 465 
 466         for (int i = 0; i &lt; arraySize; i++) {
 467             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 468         }
 469 
 470         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 471         int result;
 472         for (int i = -20; i &lt; 20; i++) {
 473             try {
 474                 result = test17(va, i, vt);
 475             } catch (ArrayIndexOutOfBoundsException e) {
 476                 result = rI + 1;
 477             }
 478             Asserts.assertEQ(result, rI + 1);
 479         }
 480 
 481         for (int i = 0; i &lt; arraySize; i++) {
 482             Asserts.assertEQ(va[i].x, rI + 1);
 483         }
 484     }
 485 
 486     // clone() as stub call
 487     @Test
 488     public MyValue1.ref[] test18(MyValue1.ref[] va) {
 489         return va.clone();
 490     }
 491 
 492     @DontCompile
 493     public void test18_verifier(boolean warmup) {
 494         int len = Math.abs(rI) % 10;
 495         MyValue1.ref[] va1 = new MyValue1.ref[len];
 496         MyValue1[]  va2 = new MyValue1[len];
 497         for (int i = 1; i &lt; len; ++i) {
 498             va1[i] = testValue1;
 499             va2[i] = testValue1;
 500         }
 501         MyValue1.ref[] result1 = test18(va1);
 502         if (len &gt; 0) {
 503             Asserts.assertEQ(result1[0], null);
 504         }
 505         for (int i = 1; i &lt; len; ++i) {
 506             Asserts.assertEQ(result1[i].hash(), va1[i].hash());
 507         }
 508         // make sure we do deopt: GraphKit::new_array assumes an
 509         // array of references
 510         for (int j = 0; j &lt; 10; j++) {
 511             MyValue1.ref[] result2 = test18(va2);
 512 
 513             for (int i = 0; i &lt; len; ++i) {
 514                 Asserts.assertEQ(result2[i].hash(), va2[i].hash());
 515             }
 516         }
 517         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test18&quot;)) {
 518             MyValue1.ref[] result2 = test18(va2);
 519             for (int i = 0; i &lt; len; ++i) {
 520                 Asserts.assertEQ(result2[i].hash(), va2[i].hash());
 521             }
 522         }
 523     }
 524 
 525     // clone() as series of loads/stores
 526     static MyValue1.ref[] test19_orig = null;
 527 
 528     @Test
 529     public MyValue1.ref[] test19() {
 530         MyValue1.ref[] va = new MyValue1.ref[8];
 531         for (int i = 1; i &lt; va.length; ++i) {
 532             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 533         }
 534         test19_orig = va;
 535 
 536         return va.clone();
 537     }
 538 
 539     @DontCompile
 540     public void test19_verifier(boolean warmup) {
 541         MyValue1.ref[] result = test19();
 542         Asserts.assertEQ(result[0], null);
 543         for (int i = 1; i &lt; test19_orig.length; ++i) {
 544             Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
 545         }
 546     }
 547 
 548     // arraycopy() of inline type array with oop fields
 549     @Test
 550     public void test20(MyValue1.ref[] src, MyValue1.ref[] dst) {
 551         System.arraycopy(src, 0, dst, 0, src.length);
 552     }
 553 
 554     @DontCompile
 555     public void test20_verifier(boolean warmup) {
 556         int len = Math.abs(rI) % 10;
 557         MyValue1.ref[] src1 = new MyValue1.ref[len];
 558         MyValue1.ref[] src2 = new MyValue1.ref[len];
 559         MyValue1[]  src3 = new MyValue1[len];
 560         MyValue1[]  src4 = new MyValue1[len];
 561         MyValue1.ref[] dst1 = new MyValue1.ref[len];
 562         MyValue1[]  dst2 = new MyValue1[len];
 563         MyValue1.ref[] dst3 = new MyValue1.ref[len];
 564         MyValue1[]  dst4 = new MyValue1[len];
 565         if (len &gt; 0) {
 566             src2[0] = testValue1;
 567         }
 568         for (int i = 1; i &lt; len; ++i) {
 569             src1[i] = testValue1;
 570             src2[i] = testValue1;
 571             src3[i] = testValue1;
 572             src4[i] = testValue1;
 573         }
 574         test20(src1, dst1);
 575         test20(src2, dst2);
 576         test20(src3, dst3);
 577         test20(src4, dst4);
 578         if (len &gt; 0) {
 579             Asserts.assertEQ(dst1[0], null);
 580             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 581             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 582             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 583         }
 584         for (int i = 1; i &lt; len; ++i) {
 585             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 586             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 587             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 588             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 589         }
 590     }
 591 
 592     // arraycopy() of inline type array with no oop field
 593     @Test
 594     public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {
 595         System.arraycopy(src, 0, dst, 0, src.length);
 596     }
 597 
 598     @DontCompile
 599     public void test21_verifier(boolean warmup) {
 600         int len = Math.abs(rI) % 10;
 601         MyValue2.ref[] src1 = new MyValue2.ref[len];
 602         MyValue2.ref[] src2 = new MyValue2.ref[len];
 603         MyValue2[]  src3 = new MyValue2[len];
 604         MyValue2[]  src4 = new MyValue2[len];
 605         MyValue2.ref[] dst1 = new MyValue2.ref[len];
 606         MyValue2[]  dst2 = new MyValue2[len];
 607         MyValue2.ref[] dst3 = new MyValue2.ref[len];
 608         MyValue2[]  dst4 = new MyValue2[len];
 609         if (len &gt; 0) {
<a name="2" id="anc2"></a><span class="line-modified"> 610             src2[0] = MyValue2.createWithFieldsInline(rI, rD);</span>
 611         }
 612         for (int i = 1; i &lt; len; ++i) {
<a name="3" id="anc3"></a><span class="line-modified"> 613             src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 614             src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 615             src3[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 616             src4[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 617         }
 618         test21(src1, dst1);
 619         test21(src2, dst2);
 620         test21(src3, dst3);
 621         test21(src4, dst4);
 622         if (len &gt; 0) {
 623             Asserts.assertEQ(dst1[0], null);
 624             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 625             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 626             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 627         }
 628         for (int i = 1; i &lt; len; ++i) {
 629             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 630             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 631             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 632             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 633         }
 634     }
 635 
 636     // arraycopy() of inline type array with oop field and tightly
 637     // coupled allocation as dest
 638     @Test
 639     public MyValue1.ref[] test22(MyValue1.ref[] src) {
 640         MyValue1.ref[] dst = new MyValue1.ref[src.length];
 641         System.arraycopy(src, 0, dst, 0, src.length);
 642         return dst;
 643     }
 644 
 645     @DontCompile
 646     public void test22_verifier(boolean warmup) {
 647         int len = Math.abs(rI) % 10;
 648         MyValue1.ref[] src1 = new MyValue1.ref[len];
 649         MyValue1[]  src2 = new MyValue1[len];
 650         for (int i = 1; i &lt; len; ++i) {
 651             src1[i] = testValue1;
 652             src2[i] = testValue1;
 653         }
 654         MyValue1.ref[] dst1 = test22(src1);
 655         MyValue1.ref[] dst2 = test22(src2);
 656         if (len &gt; 0) {
 657             Asserts.assertEQ(dst1[0], null);
 658             Asserts.assertEQ(dst2[0].hash(), MyValue1.default.hash());
 659         }
 660         for (int i = 1; i &lt; len; ++i) {
 661             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 662             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 663         }
 664     }
 665 
 666     // arraycopy() of inline type array with oop fields and tightly
 667     // coupled allocation as dest
 668     @Test
 669     public MyValue1.ref[] test23(MyValue1.ref[] src) {
 670         MyValue1.ref[] dst = new MyValue1.ref[src.length + 10];
 671         System.arraycopy(src, 0, dst, 5, src.length);
 672         return dst;
 673     }
 674 
 675     @DontCompile
 676     public void test23_verifier(boolean warmup) {
 677         int len = Math.abs(rI) % 10;
 678         MyValue1.ref[] src1 = new MyValue1.ref[len];
 679         MyValue1[] src2 = new MyValue1[len];
 680         for (int i = 0; i &lt; len; ++i) {
 681             src1[i] = testValue1;
 682             src2[i] = testValue1;
 683         }
 684         MyValue1.ref[] dst1 = test23(src1);
 685         MyValue1.ref[] dst2 = test23(src2);
 686         for (int i = 0; i &lt; 5; ++i) {
 687             Asserts.assertEQ(dst1[i], null);
 688             Asserts.assertEQ(dst2[i], null);
 689         }
 690         for (int i = 5; i &lt; len; ++i) {
 691             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 692             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 693         }
 694     }
 695 
 696     // arraycopy() of inline type array passed as Object
 697     @Test
 698     public void test24(MyValue1.ref[] src, Object dst) {
 699         System.arraycopy(src, 0, dst, 0, src.length);
 700     }
 701 
 702     @DontCompile
 703     public void test24_verifier(boolean warmup) {
 704         int len = Math.abs(rI) % 10;
 705         MyValue1.ref[] src1 = new MyValue1.ref[len];
 706         MyValue1.ref[] src2 = new MyValue1.ref[len];
 707         MyValue1[]  src3 = new MyValue1[len];
 708         MyValue1[]  src4 = new MyValue1[len];
 709         MyValue1.ref[] dst1 = new MyValue1.ref[len];
 710         MyValue1[]  dst2 = new MyValue1[len];
 711         MyValue1.ref[] dst3 = new MyValue1.ref[len];
 712         MyValue1[]  dst4 = new MyValue1[len];
 713         if (len &gt; 0) {
 714             src2[0] = testValue1;
 715         }
 716         for (int i = 1; i &lt; len; ++i) {
 717             src1[i] = testValue1;
 718             src2[i] = testValue1;
 719             src3[i] = testValue1;
 720             src4[i] = testValue1;
 721         }
 722         test24(src1, dst1);
 723         test24(src2, dst2);
 724         test24(src3, dst3);
 725         test24(src4, dst4);
 726         if (len &gt; 0) {
 727             Asserts.assertEQ(dst1[0], null);
 728             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 729             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 730             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 731         }
 732         for (int i = 1; i &lt; len; ++i) {
 733             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 734             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 735             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 736             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 737         }
 738     }
 739 
 740     // short arraycopy() with no oop field
 741     @Test
 742     public void test25(MyValue2.ref[] src, MyValue2.ref[] dst) {
 743         System.arraycopy(src, 0, dst, 0, 8);
 744     }
 745 
 746     @DontCompile
 747     public void test25_verifier(boolean warmup) {
 748         MyValue2.ref[] src1 = new MyValue2.ref[8];
 749         MyValue2.ref[] src2 = new MyValue2.ref[8];
 750         MyValue2[]  src3 = new MyValue2[8];
 751         MyValue2[]  src4 = new MyValue2[8];
 752         MyValue2.ref[] dst1 = new MyValue2.ref[8];
 753         MyValue2[]  dst2 = new MyValue2[8];
 754         MyValue2.ref[] dst3 = new MyValue2.ref[8];
 755         MyValue2[]  dst4 = new MyValue2[8];
<a name="4" id="anc4"></a><span class="line-modified"> 756         src2[0] = MyValue2.createWithFieldsInline(rI, rD);</span>
 757         for (int i = 1; i &lt; 8; ++i) {
<a name="5" id="anc5"></a><span class="line-modified"> 758             src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 759             src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 760             src3[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 761             src4[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 762         }
 763         test25(src1, dst1);
 764         test25(src2, dst2);
 765         test25(src3, dst3);
 766         test25(src4, dst4);
 767         Asserts.assertEQ(dst1[0], null);
 768         Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 769         Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 770         Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 771         for (int i = 1; i &lt; 8; ++i) {
 772             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 773             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 774             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 775             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 776         }
 777     }
 778 
 779     // short arraycopy() with oop fields
 780     @Test
 781     public void test26(MyValue1.ref[] src, MyValue1.ref[] dst) {
 782         System.arraycopy(src, 0, dst, 0, 8);
 783     }
 784 
 785     @DontCompile
 786     public void test26_verifier(boolean warmup) {
 787         MyValue1.ref[] src1 = new MyValue1.ref[8];
 788         MyValue1.ref[] src2 = new MyValue1.ref[8];
 789         MyValue1[]  src3 = new MyValue1[8];
 790         MyValue1[]  src4 = new MyValue1[8];
 791         MyValue1.ref[] dst1 = new MyValue1.ref[8];
 792         MyValue1[]  dst2 = new MyValue1[8];
 793         MyValue1.ref[] dst3 = new MyValue1.ref[8];
 794         MyValue1[]  dst4 = new MyValue1[8];
 795         src2[0] = testValue1;
 796         for (int i = 1; i &lt; 8 ; ++i) {
 797             src1[i] = testValue1;
 798             src2[i] = testValue1;
 799             src3[i] = testValue1;
 800             src4[i] = testValue1;
 801         }
 802         test26(src1, dst1);
 803         test26(src2, dst2);
 804         test26(src3, dst3);
 805         test26(src4, dst4);
 806         Asserts.assertEQ(dst1[0], null);
 807         Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 808         Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 809         Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 810         for (int i = 1; i &lt; 8; ++i) {
 811             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 812             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 813             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 814             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 815         }
 816     }
 817 
 818     // short arraycopy() with oop fields and offsets
 819     @Test
 820     public void test27(MyValue1.ref[] src, MyValue1.ref[] dst) {
 821         System.arraycopy(src, 1, dst, 2, 6);
 822     }
 823 
 824     @DontCompile
 825     public void test27_verifier(boolean warmup) {
 826         MyValue1.ref[] src1 = new MyValue1.ref[8];
 827         MyValue1.ref[] src2 = new MyValue1.ref[8];
 828         MyValue1[]  src3 = new MyValue1[8];
 829         MyValue1[]  src4 = new MyValue1[8];
 830         MyValue1.ref[] dst1 = new MyValue1.ref[8];
 831         MyValue1[]  dst2 = new MyValue1[8];
 832         MyValue1.ref[] dst3 = new MyValue1.ref[8];
 833         MyValue1[]  dst4 = new MyValue1[8];
 834         for (int i = 1; i &lt; 8; ++i) {
 835             src1[i] = testValue1;
 836             src2[i] = testValue1;
 837             src3[i] = testValue1;
 838             src4[i] = testValue1;
 839         }
 840         test27(src1, dst1);
 841         test27(src2, dst2);
 842         test27(src3, dst3);
 843         test27(src4, dst4);
 844         for (int i = 0; i &lt; 2; ++i) {
 845             Asserts.assertEQ(dst1[i], null);
 846             Asserts.assertEQ(dst2[i].hash(), MyValue1.default.hash());
 847             Asserts.assertEQ(dst3[i], null);
 848             Asserts.assertEQ(dst4[i].hash(), MyValue1.default.hash());
 849         }
 850         for (int i = 2; i &lt; 8; ++i) {
 851             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 852             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 853             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 854             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 855         }
 856     }
 857 
 858     // non escaping allocations
<a name="6" id="anc6"></a><span class="line-modified"> 859     // TODO 8252027: Make sure this is optimized with ZGC</span>
 860     @Test(valid = ZGCOff, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 861     @Test(valid = ZGCOn)
 862     public MyValue2.ref test28() {
 863         MyValue2.ref[] src = new MyValue2.ref[10];
 864         src[0] = null;
 865         MyValue2.ref[] dst = (MyValue2.ref[])src.clone();
 866         return dst[0];
 867     }
 868 
 869     @DontCompile
 870     public void test28_verifier(boolean warmup) {
<a name="7" id="anc7"></a><span class="line-modified"> 871         MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);</span>
 872         MyValue2.ref result = test28();
 873         Asserts.assertEQ(result, null);
 874     }
 875 
 876     // non escaping allocations
 877     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
 878     @Test(failOn = ALLOCA + LOOP + TRAP)
 879     public MyValue2.ref test29(MyValue2.ref[] src) {
 880         MyValue2.ref[] dst = new MyValue2.ref[10];
 881         System.arraycopy(src, 0, dst, 0, 10);
 882         return dst[0];
 883     }
 884 
 885     @DontCompile
 886     public void test29_verifier(boolean warmup) {
 887         MyValue2.ref[] src1 = new MyValue2.ref[10];
 888         MyValue2.val[] src2 = new MyValue2.val[10];
 889         for (int i = 0; i &lt; 10; ++i) {
<a name="8" id="anc8"></a><span class="line-modified"> 890             src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 891             src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 892         }
 893         MyValue2.ref v = test29(src1);
 894         Asserts.assertEQ(src1[0].hash(), v.hash());
 895         if (!warmup) {
 896             v = test29(src2);
 897             Asserts.assertEQ(src2[0].hash(), v.hash());
 898         }
 899     }
 900 
 901     // non escaping allocation with uncommon trap that needs
 902     // eliminated inline type array element as debug info
 903     @Test
 904     @Warmup(10000)
 905     public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {
 906         MyValue2.ref[] dst = new MyValue2.ref[10];
 907         System.arraycopy(src, 0, dst, 0, 10);
 908         if (flag) { }
 909         return dst[0];
 910     }
 911 
 912     @DontCompile
 913     public void test30_verifier(boolean warmup) {
 914         MyValue2.ref[] src1 = new MyValue2.ref[10];
 915         MyValue2.val[] src2 = new MyValue2.val[10];
 916         for (int i = 0; i &lt; 10; ++i) {
<a name="9" id="anc9"></a><span class="line-modified"> 917             src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
<span class="line-modified"> 918             src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 919         }
 920         MyValue2.ref v = test30(src1, !warmup);
 921         Asserts.assertEQ(src1[0].hash(), v.hash());
 922         if (!warmup) {
 923             v = test30(src2, true);
 924             Asserts.assertEQ(src2[0].hash(), v.hash());
 925         }
 926     }
 927 
 928     // non escaping allocation with memory phi
 929     @Test()
 930     // TODO 8227588
 931     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 932     public long test31(boolean b, boolean deopt) {
 933         MyValue2.ref[] src = new MyValue2.ref[1];
 934         if (b) {
<a name="10" id="anc10"></a><span class="line-modified"> 935             src[0] = MyValue2.createWithFieldsInline(rI, rD);</span>
 936         } else {
<a name="11" id="anc11"></a><span class="line-modified"> 937             src[0] = MyValue2.createWithFieldsInline(rI+1, rD+1);</span>
 938         }
 939         if (deopt) {
 940             // uncommon trap
 941             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test31&quot;));
 942         }
 943         return src[0].hash();
 944     }
 945 
 946     @DontCompile
 947     public void test31_verifier(boolean warmup) {
<a name="12" id="anc12"></a><span class="line-modified"> 948         MyValue2 v1 = MyValue2.createWithFieldsInline(rI, rD);</span>
 949         long result1 = test31(true, !warmup);
 950         Asserts.assertEQ(result1, v1.hash());
<a name="13" id="anc13"></a><span class="line-modified"> 951         MyValue2 v2 = MyValue2.createWithFieldsInline(rI+1, rD+1);</span>
 952         long result2 = test31(false, !warmup);
 953         Asserts.assertEQ(result2, v2.hash());
 954     }
 955 
 956     // Tests with Object arrays and clone/arraycopy
 957     // clone() as stub call
 958     @Test
 959     public Object[] test32(Object[] va) {
 960         return va.clone();
 961     }
 962 
 963     @DontCompile
 964     public void test32_verifier(boolean warmup) {
 965         int len = Math.abs(rI) % 10;
 966         MyValue1.ref[] va1 = new MyValue1.ref[len];
 967         MyValue1[] va2 = new MyValue1[len];
 968         for (int i = 1; i &lt; len; ++i) {
 969             va1[i] = testValue1;
 970             va2[i] = testValue1;
 971         }
 972         MyValue1.ref[] result1 = (MyValue1.ref[])test32(va1);
 973         MyValue1.ref[] result2 = (MyValue1.ref[])test32(va2);
 974         if (len &gt; 0) {
 975             Asserts.assertEQ(result1[0], null);
 976             Asserts.assertEQ(result2[0].hash(), MyValue1.default.hash());
 977         }
 978         for (int i = 1; i &lt; len; ++i) {
 979             Asserts.assertEQ(((MyValue1)result1[i]).hash(), ((MyValue1)va1[i]).hash());
 980             Asserts.assertEQ(((MyValue1)result2[i]).hash(), ((MyValue1)va2[i]).hash());
 981         }
 982     }
 983 
 984     @Test
 985     public Object[] test33(Object[] va) {
 986         return va.clone();
 987     }
 988 
 989     @DontCompile
 990     public void test33_verifier(boolean warmup) {
 991         int len = Math.abs(rI) % 10;
 992         Object[] va = new Object[len];
 993         for (int i = 0; i &lt; len; ++i) {
 994             va[i] = testValue1;
 995         }
 996         Object[] result = test33(va);
 997         for (int i = 0; i &lt; len; ++i) {
 998             Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());
 999         }
1000     }
1001 
1002     // clone() as series of loads/stores
1003     static Object[] test34_orig = null;
1004 
1005     @ForceInline
1006     public Object[] test34_helper(boolean flag) {
1007         Object[] va = null;
1008         if (flag) {
1009             va = new MyValue1.ref[8];
1010             for (int i = 0; i &lt; va.length; ++i) {
1011                 va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
1012             }
1013         } else {
1014             va = new Object[8];
1015         }
1016         return va;
1017     }
1018 
1019     @Test
1020     public Object[] test34(boolean flag) {
1021         Object[] va = test34_helper(flag);
1022         test34_orig = va;
1023         return va.clone();
1024     }
1025 
1026     @DontCompile
1027     public void test34_verifier(boolean warmup) {
1028         test34(false);
1029         for (int i = 0; i &lt; 10; i++) { // make sure we do deopt
1030             Object[] result = test34(true);
1031             verify(test34_orig, result);
1032         }
1033         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test34&quot;)) {
1034             Object[] result = test34(true);
1035             verify(test34_orig, result);
1036         }
1037     }
1038 
1039     static void verify(Object[] src, Object[] dst) {
1040         for (int i = 0; i &lt; src.length; ++i) {
1041             if (src[i] != null) {
1042                 Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());
1043             } else {
1044                 Asserts.assertEQ(dst[i], null);
1045             }
1046         }
1047     }
1048 
1049     static void verify(MyValue1.ref[] src, MyValue1.ref[] dst) {
1050         for (int i = 0; i &lt; src.length; ++i) {
1051             if (src[i] != null) {
1052                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1053             } else {
1054                 Asserts.assertEQ(dst[i], null);
1055             }
1056         }
1057     }
1058 
1059     static void verify(MyValue1.ref[] src, Object[] dst) {
1060         for (int i = 0; i &lt; src.length; ++i) {
1061             if (src[i] != null) {
1062                 Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
1063             } else {
1064                 Asserts.assertEQ(dst[i], null);
1065             }
1066         }
1067     }
1068 
1069     static void verify(MyValue2.ref[] src, MyValue2.ref[] dst) {
1070         for (int i = 0; i &lt; src.length; ++i) {
1071             if (src[i] != null) {
1072                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1073             } else {
1074                 Asserts.assertEQ(dst[i], null);
1075             }
1076         }
1077     }
1078 
1079     static void verify(MyValue2.ref[] src, Object[] dst) {
1080         for (int i = 0; i &lt; src.length; ++i) {
1081             if (src[i] != null) {
1082                 Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
1083             } else {
1084                 Asserts.assertEQ(dst[i], null);
1085             }
1086         }
1087     }
1088 
1089     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
1090         if (!warmup) {
1091             Method m = tests.get(test);
1092             if (USE_COMPILER &amp;&amp;  !WHITE_BOX.isMethodCompiled(m, false)) {
1093                 if (!InlineTypeArrayFlatten &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1094                     throw new RuntimeException(&quot;Unexpected deoptimization&quot;);
1095                 }
1096                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1097                 return true;
1098             }
1099         }
1100         return false;
1101     }
1102 
1103     // arraycopy() of inline type array of unknown size
1104     @Test
1105     public void test35(Object src, Object dst, int len) {
1106         System.arraycopy(src, 0, dst, 0, len);
1107     }
1108 
1109     @DontCompile
1110     public void test35_verifier(boolean warmup) {
1111         int len = Math.abs(rI) % 10;
1112         MyValue1.ref[] src = new MyValue1.ref[len];
1113         MyValue1.ref[] dst = new MyValue1.ref[len];
1114         for (int i = 1; i &lt; len; ++i) {
1115             src[i] = testValue1;
1116         }
1117         test35(src, dst, src.length);
1118         verify(src, dst);
1119         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test35&quot;)) {
1120             test35(src, dst, src.length);
1121             verify(src, dst);
1122         }
1123     }
1124 
1125     @Test
1126     public void test36(Object src, MyValue2.ref[] dst) {
1127         System.arraycopy(src, 0, dst, 0, dst.length);
1128     }
1129 
1130     @DontCompile
1131     public void test36_verifier(boolean warmup) {
1132         int len = Math.abs(rI) % 10;
1133         MyValue2.ref[] src = new MyValue2.ref[len];
1134         MyValue2.ref[] dst = new MyValue2.ref[len];
1135         for (int i = 1; i &lt; len; ++i) {
<a name="14" id="anc14"></a><span class="line-modified">1136             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1137         }
1138         test36(src, dst);
1139         verify(src, dst);
1140         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test36&quot;)) {
1141             test36(src, dst);
1142             verify(src, dst);
1143         }
1144     }
1145 
1146     @Test
1147     public void test37(MyValue2.ref[] src, Object dst) {
1148         System.arraycopy(src, 0, dst, 0, src.length);
1149     }
1150 
1151     @DontCompile
1152     public void test37_verifier(boolean warmup) {
1153         int len = Math.abs(rI) % 10;
1154         MyValue2.ref[] src = new MyValue2.ref[len];
1155         MyValue2.ref[] dst = new MyValue2.ref[len];
1156         for (int i = 1; i &lt; len; ++i) {
<a name="15" id="anc15"></a><span class="line-modified">1157             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1158         }
1159         test37(src, dst);
1160         verify(src, dst);
1161         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test37&quot;)) {
1162             test37(src, dst);
1163             verify(src, dst);
1164         }
1165     }
1166 
1167     @Test
1168     @Warmup(1) // Avoid early compilation
1169     public void test38(Object src, MyValue2.ref[] dst) {
1170         System.arraycopy(src, 0, dst, 0, dst.length);
1171     }
1172 
1173     @DontCompile
1174     public void test38_verifier(boolean warmup) {
1175         int len = Math.abs(rI) % 10;
1176         Object[] src = new Object[len];
1177         MyValue2.ref[] dst = new MyValue2.ref[len];
1178         for (int i = 1; i &lt; len; ++i) {
<a name="16" id="anc16"></a><span class="line-modified">1179             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1180         }
1181         test38(src, dst);
1182         verify(dst, src);
1183         if (!warmup) {
1184             Method m = tests.get(&quot;TestNullableArrays::test38&quot;);
1185             assertDeoptimizedByC2(m);
1186             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1187             test38(src, dst);
1188             verify(dst, src);
1189             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1190                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1191             }
1192         }
1193     }
1194 
1195     @Test
1196     public void test39(MyValue2.ref[] src, Object dst) {
1197         System.arraycopy(src, 0, dst, 0, src.length);
1198     }
1199 
1200     @DontCompile
1201     public void test39_verifier(boolean warmup) {
1202         int len = Math.abs(rI) % 10;
1203         MyValue2.ref[] src = new MyValue2.ref[len];
1204         Object[] dst = new Object[len];
1205         for (int i = 1; i &lt; len; ++i) {
<a name="17" id="anc17"></a><span class="line-modified">1206             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1207         }
1208         test39(src, dst);
1209         verify(src, dst);
1210         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test39&quot;)) {
1211             test39(src, dst);
1212             verify(src, dst);
1213         }
1214     }
1215 
1216     @Test
1217     @Warmup(1) // Avoid early compilation
1218     public void test40(Object[] src, Object dst) {
1219         System.arraycopy(src, 0, dst, 0, src.length);
1220     }
1221 
1222     @DontCompile
1223     public void test40_verifier(boolean warmup) {
1224         int len = Math.abs(rI) % 10;
1225         Object[] src = new Object[len];
1226         MyValue2.ref[] dst = new MyValue2.ref[len];
1227         for (int i = 1; i &lt; len; ++i) {
<a name="18" id="anc18"></a><span class="line-modified">1228             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1229         }
1230         test40(src, dst);
1231         verify(dst, src);
1232         if (!warmup) {
1233             Method m = tests.get(&quot;TestNullableArrays::test40&quot;);
1234             assertDeoptimizedByC2(m);
1235             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1236             test40(src, dst);
1237             verify(dst, src);
1238             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1239                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1240             }
1241         }
1242     }
1243 
1244     @Test
1245     public void test41(Object src, Object[] dst) {
1246         System.arraycopy(src, 0, dst, 0, dst.length);
1247     }
1248 
1249     @DontCompile
1250     public void test41_verifier(boolean warmup) {
1251         int len = Math.abs(rI) % 10;
1252         MyValue2.ref[] src = new MyValue2.ref[len];
1253         Object[] dst = new Object[len];
1254         for (int i = 1; i &lt; len; ++i) {
<a name="19" id="anc19"></a><span class="line-modified">1255             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1256         }
1257         test41(src, dst);
1258         verify(src, dst);
1259         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test41&quot;)) {
1260             test41(src, dst);
1261             verify(src, dst);
1262         }
1263     }
1264 
1265     @Test
1266     public void test42(Object[] src, Object[] dst) {
1267         System.arraycopy(src, 0, dst, 0, src.length);
1268     }
1269 
1270     @DontCompile
1271     public void test42_verifier(boolean warmup) {
1272         int len = Math.abs(rI) % 10;
1273         Object[] src = new Object[len];
1274         Object[] dst = new Object[len];
1275         for (int i = 1; i &lt; len; ++i) {
<a name="20" id="anc20"></a><span class="line-modified">1276             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1277         }
1278         test42(src, dst);
1279         verify(src, dst);
1280         if (!warmup) {
1281             Method m = tests.get(&quot;TestNullableArrays::test42&quot;);
1282             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1283                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1284             }
1285         }
1286     }
1287 
1288     // short arraycopy()&#39;s
1289     @Test
1290     public void test43(Object src, Object dst) {
1291         System.arraycopy(src, 0, dst, 0, 8);
1292     }
1293 
1294     @DontCompile
1295     public void test43_verifier(boolean warmup) {
1296         MyValue1.ref[] src = new MyValue1.ref[8];
1297         MyValue1.ref[] dst = new MyValue1.ref[8];
1298         for (int i = 1; i &lt; 8; ++i) {
1299             src[i] = testValue1;
1300         }
1301         test43(src, dst);
1302         verify(src, dst);
1303         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test43&quot;)) {
1304             test43(src, dst);
1305             verify(src, dst);
1306         }
1307     }
1308 
1309     @Test
1310     public void test44(Object src, MyValue2.ref[] dst) {
1311         System.arraycopy(src, 0, dst, 0, 8);
1312     }
1313 
1314     @DontCompile
1315     public void test44_verifier(boolean warmup) {
1316         MyValue2.ref[] src = new MyValue2.ref[8];
1317         MyValue2.ref[] dst = new MyValue2.ref[8];
1318         for (int i = 1; i &lt; 8; ++i) {
<a name="21" id="anc21"></a><span class="line-modified">1319             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1320         }
1321         test44(src, dst);
1322         verify(src, dst);
1323         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test44&quot;)) {
1324             test44(src, dst);
1325             verify(src, dst);
1326         }
1327     }
1328 
1329     @Test
1330     public void test45(MyValue2.ref[] src, Object dst) {
1331         System.arraycopy(src, 0, dst, 0, 8);
1332     }
1333 
1334     @DontCompile
1335     public void test45_verifier(boolean warmup) {
1336         MyValue2.ref[] src = new MyValue2.ref[8];
1337         MyValue2.ref[] dst = new MyValue2.ref[8];
1338         for (int i = 1; i &lt; 8; ++i) {
<a name="22" id="anc22"></a><span class="line-modified">1339             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1340         }
1341         test45(src, dst);
1342         verify(src, dst);
1343         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test45&quot;)) {
1344             test45(src, dst);
1345             verify(src, dst);
1346         }
1347     }
1348 
1349     @Test
1350     @Warmup(1) // Avoid early compilation
1351     public void test46(Object[] src, MyValue2.ref[] dst) {
1352         System.arraycopy(src, 0, dst, 0, 8);
1353     }
1354 
1355     @DontCompile
1356     public void test46_verifier(boolean warmup) {
1357         Object[] src = new Object[8];
1358         MyValue2.ref[] dst = new MyValue2.ref[8];
1359         for (int i = 1; i &lt; 8; ++i) {
<a name="23" id="anc23"></a><span class="line-modified">1360             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1361         }
1362         test46(src, dst);
1363         verify(dst, src);
1364         if (!warmup) {
1365             Method m = tests.get(&quot;TestNullableArrays::test46&quot;);
1366             assertDeoptimizedByC2(m);
1367             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1368             test46(src, dst);
1369             verify(dst, src);
1370             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1371                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1372             }
1373         }
1374     }
1375 
1376     @Test
1377     public void test47(MyValue2.ref[] src, Object[] dst) {
1378         System.arraycopy(src, 0, dst, 0, 8);
1379     }
1380 
1381     @DontCompile
1382     public void test47_verifier(boolean warmup) {
1383         MyValue2.ref[] src = new MyValue2.ref[8];
1384         Object[] dst = new Object[8];
1385         for (int i = 1; i &lt; 8; ++i) {
<a name="24" id="anc24"></a><span class="line-modified">1386             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1387         }
1388         test47(src, dst);
1389         verify(src, dst);
1390         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test47&quot;)) {
1391             test47(src, dst);
1392             verify(src, dst);
1393         }
1394     }
1395 
1396     @Test
1397     @Warmup(1) // Avoid early compilation
1398     public void test48(Object[] src, Object dst) {
1399         System.arraycopy(src, 0, dst, 0, 8);
1400     }
1401 
1402     @DontCompile
1403     public void test48_verifier(boolean warmup) {
1404         Object[] src = new Object[8];
1405         MyValue2.ref[] dst = new MyValue2.ref[8];
1406         for (int i = 1; i &lt; 8; ++i) {
<a name="25" id="anc25"></a><span class="line-modified">1407             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1408         }
1409         test48(src, dst);
1410         verify(dst, src);
1411         if (!warmup) {
1412             Method m = tests.get(&quot;TestNullableArrays::test48&quot;);
1413             assertDeoptimizedByC2(m);
1414             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1415             test48(src, dst);
1416             verify(dst, src);
1417             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1418                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1419             }
1420         }
1421     }
1422 
1423     @Test
1424     public void test49(Object src, Object[] dst) {
1425         System.arraycopy(src, 0, dst, 0, 8);
1426     }
1427 
1428     @DontCompile
1429     public void test49_verifier(boolean warmup) {
1430         MyValue2.ref[] src = new MyValue2.ref[8];
1431         Object[] dst = new Object[8];
1432         for (int i = 1; i &lt; 8; ++i) {
<a name="26" id="anc26"></a><span class="line-modified">1433             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1434         }
1435         test49(src, dst);
1436         verify(src, dst);
1437         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test49&quot;)) {
1438             test49(src, dst);
1439             verify(src, dst);
1440         }
1441     }
1442 
1443     @Test
1444     public void test50(Object[] src, Object[] dst) {
1445         System.arraycopy(src, 0, dst, 0, 8);
1446     }
1447 
1448     @DontCompile
1449     public void test50_verifier(boolean warmup) {
1450         Object[] src = new Object[8];
1451         Object[] dst = new Object[8];
1452         for (int i = 1; i &lt; 8; ++i) {
<a name="27" id="anc27"></a><span class="line-modified">1453             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1454         }
1455         test50(src, dst);
1456         verify(src, dst);
1457         if (!warmup) {
1458             Method m = tests.get(&quot;TestNullableArrays::test50&quot;);
1459             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1460                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1461             }
1462         }
1463     }
1464 
1465     @Test
1466     public MyValue1.ref[] test51(MyValue1.ref[] va) {
1467         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1468     }
1469 
1470     @DontCompile
1471     public void test51_verifier(boolean warmup) {
1472         int len = Math.abs(rI) % 10;
1473         MyValue1.ref[] va = new MyValue1.ref[len];
1474         for (int i = 1; i &lt; len; ++i) {
1475             va[i] = testValue1;
1476         }
1477         MyValue1.ref[] result = test51(va);
1478         verify(va, result);
1479     }
1480 
1481     static final MyValue1.ref[] test52_va = new MyValue1.ref[8];
1482 
1483     @Test
1484     public MyValue1.ref[] test52() {
1485         return Arrays.copyOf(test52_va, 8, MyValue1.ref[].class);
1486     }
1487 
1488     @DontCompile
1489     public void test52_verifier(boolean warmup) {
1490         for (int i = 1; i &lt; 8; ++i) {
1491             test52_va[i] = testValue1;
1492         }
1493         MyValue1.ref[] result = test52();
1494         verify(test52_va, result);
1495     }
1496 
1497     @Test
1498     public MyValue1.ref[] test53(Object[] va) {
1499         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1500     }
1501 
1502     @DontCompile
1503     public void test53_verifier(boolean warmup) {
1504         int len = Math.abs(rI) % 10;
1505         MyValue1.ref[] va = new MyValue1.ref[len];
1506         for (int i = 1; i &lt; len; ++i) {
1507             va[i] = testValue1;
1508         }
1509         MyValue1.ref[] result = test53(va);
1510         verify(result, va);
1511     }
1512 
1513     @Test
1514     public Object[] test54(MyValue1.ref[] va) {
1515         return Arrays.copyOf(va, va.length, Object[].class);
1516     }
1517 
1518     @DontCompile
1519     public void test54_verifier(boolean warmup) {
1520         int len = Math.abs(rI) % 10;
1521         MyValue1.ref[] va = new MyValue1.ref[len];
1522         for (int i = 1; i &lt; len; ++i) {
1523             va[i] = testValue1;
1524         }
1525         Object[] result = test54(va);
1526         verify(va, result);
1527     }
1528 
1529     @Test
1530     public Object[] test55(Object[] va) {
1531         return Arrays.copyOf(va, va.length, Object[].class);
1532     }
1533 
1534     @DontCompile
1535     public void test55_verifier(boolean warmup) {
1536         int len = Math.abs(rI) % 10;
1537         MyValue1.ref[] va = new MyValue1.ref[len];
1538         for (int i = 1; i &lt; len; ++i) {
1539             va[i] = testValue1;
1540         }
1541         Object[] result = test55(va);
1542         verify(va, result);
1543     }
1544 
1545     @Test
1546     public MyValue1.ref[] test56(Object[] va) {
1547         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1548     }
1549 
1550     @DontCompile
1551     public void test56_verifier(boolean warmup) {
1552         int len = Math.abs(rI) % 10;
1553         Object[] va = new Object[len];
1554         for (int i = 1; i &lt; len; ++i) {
1555             va[i] = testValue1;
1556         }
1557         MyValue1.ref[] result = test56(va);
1558         verify(result, va);
1559     }
1560 
1561    @Test
1562     public Object[] test57(Object[] va, Class klass) {
1563         return Arrays.copyOf(va, va.length, klass);
1564     }
1565 
1566     @DontCompile
1567     public void test57_verifier(boolean warmup) {
1568         int len = Math.abs(rI) % 10;
1569         Object[] va = new MyValue1.ref[len];
1570         for (int i = 1; i &lt; len; ++i) {
1571             va[i] = testValue1;
1572         }
1573         Object[] result = test57(va, MyValue1.ref[].class);
1574         verify(va, result);
1575     }
1576 
1577     @Test
1578     public Object[] test58(MyValue1.ref[] va, Class klass) {
1579         return Arrays.copyOf(va, va.length, klass);
1580     }
1581 
1582     @DontCompile
1583     public void test58_verifier(boolean warmup) {
1584         int len = Math.abs(rI) % 10;
1585         MyValue1.ref[] va = new MyValue1.ref[len];
1586         for (int i = 1; i &lt; len; ++i) {
1587             va[i] = testValue1;
1588         }
1589         for (int i = 1; i &lt; 10; i++) {
1590             Object[] result = test58(va, MyValue1.ref[].class);
1591             verify(va, result);
1592         }
1593         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test58&quot;)) {
1594             Object[] result = test58(va, MyValue1.ref[].class);
1595             verify(va, result);
1596         }
1597     }
1598 
1599     @Test
1600     public Object[] test59(MyValue1.ref[] va) {
1601         return Arrays.copyOf(va, va.length+1, MyValue1.ref[].class);
1602     }
1603 
1604     @DontCompile
1605     public void test59_verifier(boolean warmup) {
1606         int len = Math.abs(rI) % 10;
1607         MyValue1.ref[] va = new MyValue1.ref[len];
1608         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1609         for (int i = 1; i &lt; len; ++i) {
1610             va[i] = testValue1;
1611             verif[i] = va[i];
1612         }
1613         Object[] result = test59(va);
1614         verify(verif, result);
1615     }
1616 
1617     @Test
1618     public Object[] test60(Object[] va, Class klass) {
1619         return Arrays.copyOf(va, va.length+1, klass);
1620     }
1621 
1622     @DontCompile
1623     public void test60_verifier(boolean warmup) {
1624         int len = Math.abs(rI) % 10;
1625         MyValue1.ref[] va = new MyValue1.ref[len];
1626         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1627         for (int i = 1; i &lt; len; ++i) {
1628             va[i] = testValue1;
1629             verif[i] = (MyValue1)va[i];
1630         }
1631         Object[] result = test60(va, MyValue1.ref[].class);
1632         verify(verif, result);
1633     }
1634 
1635     @Test
1636     public Object[] test61(Object[] va, Class klass) {
1637         return Arrays.copyOf(va, va.length+1, klass);
1638     }
1639 
1640     @DontCompile
1641     public void test61_verifier(boolean warmup) {
1642         int len = Math.abs(rI) % 10;
1643         Object[] va = new Integer[len];
1644         for (int i = 1; i &lt; len; ++i) {
1645             va[i] = new Integer(rI);
1646         }
1647         Object[] result = test61(va, Integer[].class);
1648         for (int i = 0; i &lt; va.length; ++i) {
1649             Asserts.assertEQ(va[i], result[i]);
1650         }
1651     }
1652 
1653     @ForceInline
1654     public Object[] test62_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1655         Object[] arr = null;
1656         if (i == 10) {
1657             arr = oa;
1658         } else {
1659             arr = va;
1660         }
1661         return arr;
1662     }
1663 
1664     @Test
1665     public Object[] test62(MyValue1.ref[] va, Integer[] oa) {
1666         int i = 0;
1667         for (; i &lt; 10; i++);
1668 
1669         Object[] arr = test62_helper(i, va, oa);
1670 
1671         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1672     }
1673 
1674     @DontCompile
1675     public void test62_verifier(boolean warmup) {
1676         int len = Math.abs(rI) % 10;
1677         MyValue1.ref[] va = new MyValue1.ref[len];
1678         Integer[] oa = new Integer[len];
1679         for (int i = 1; i &lt; len; ++i) {
1680             oa[i] = new Integer(rI);
1681         }
1682         test62_helper(42, va, oa);
1683         Object[] result = test62(va, oa);
1684         for (int i = 0; i &lt; va.length; ++i) {
1685             Asserts.assertEQ(oa[i], result[i]);
1686         }
1687     }
1688 
1689     @ForceInline
1690     public Object[] test63_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1691         Object[] arr = null;
1692         if (i == 10) {
1693             arr = va;
1694         } else {
1695             arr = oa;
1696         }
1697         return arr;
1698     }
1699 
1700     @Test
1701     public Object[] test63(MyValue1.ref[] va, Integer[] oa) {
1702         int i = 0;
1703         for (; i &lt; 10; i++);
1704 
1705         Object[] arr = test63_helper(i, va, oa);
1706 
1707         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1708     }
1709 
1710     @DontCompile
1711     public void test63_verifier(boolean warmup) {
1712         int len = Math.abs(rI) % 10;
1713         MyValue1.ref[] va = new MyValue1.ref[len];
1714         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1715         for (int i = 1; i &lt; len; ++i) {
1716             va[i] = testValue1;
1717             verif[i] = va[i];
1718         }
1719         Integer[] oa = new Integer[len];
1720         test63_helper(42, va, oa);
1721         Object[] result = test63(va, oa);
1722         verify(verif, result);
1723     }
1724 
1725     // Test default initialization of inline type arrays: small array
1726     @Test
1727     public MyValue1.ref[] test64() {
1728         return new MyValue1.ref[8];
1729     }
1730 
1731     @DontCompile
1732     public void test64_verifier(boolean warmup) {
1733         MyValue1.ref[] va = test64();
1734         for (int i = 0; i &lt; 8; ++i) {
1735             Asserts.assertEQ(va[i], null);
1736         }
1737     }
1738 
1739     // Test default initialization of inline type arrays: large array
1740     @Test
1741     public MyValue1.ref[] test65() {
1742         return new MyValue1.ref[32];
1743     }
1744 
1745     @DontCompile
1746     public void test65_verifier(boolean warmup) {
1747         MyValue1.ref[] va = test65();
1748         for (int i = 0; i &lt; 32; ++i) {
1749             Asserts.assertEQ(va[i], null);
1750         }
1751     }
1752 
1753     // Check init store elimination
1754     @Test(match = { ALLOCA }, matchCount = { 1 })
1755     public MyValue1.ref[] test66(MyValue1.ref vt) {
1756         MyValue1.ref[] va = new MyValue1.ref[1];
1757         va[0] = vt;
1758         return va;
1759     }
1760 
1761     @DontCompile
1762     public void test66_verifier(boolean warmup) {
1763         MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);
1764         MyValue1.ref[] va = test66(vt);
1765         Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());
1766     }
1767 
1768     // Zeroing elimination and arraycopy
1769     @Test
1770     public MyValue1.ref[] test67(MyValue1.ref[] src) {
1771         MyValue1.ref[] dst = new MyValue1.ref[16];
1772         System.arraycopy(src, 0, dst, 0, 13);
1773         return dst;
1774     }
1775 
1776     @DontCompile
1777     public void test67_verifier(boolean warmup) {
1778         MyValue1.ref[] va = new MyValue1.ref[16];
1779         MyValue1.ref[] var = test67(va);
1780         for (int i = 0; i &lt; 16; ++i) {
1781             Asserts.assertEQ(var[i], null);
1782         }
1783     }
1784 
1785     // A store with a default value can be eliminated
1786     @Test
1787     public MyValue1.ref[] test68() {
1788         MyValue1.ref[] va = new MyValue1.ref[2];
1789         va[0] = va[1];
1790         return va;
1791     }
1792 
1793     @DontCompile
1794     public void test68_verifier(boolean warmup) {
1795         MyValue1.ref[] va = test68();
1796         for (int i = 0; i &lt; 2; ++i) {
1797             Asserts.assertEQ(va[i], null);
1798         }
1799     }
1800 
1801     // Requires individual stores to init array
1802     @Test
1803     public MyValue1.ref[] test69(MyValue1.ref vt) {
1804         MyValue1.ref[] va = new MyValue1.ref[4];
1805         va[0] = vt;
1806         va[3] = vt;
1807         return va;
1808     }
1809 
1810     @DontCompile
1811     public void test69_verifier(boolean warmup) {
1812         MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);
1813         MyValue1.ref[] va = new MyValue1.ref[4];
1814         va[0] = vt;
1815         va[3] = vt;
1816         MyValue1.ref[] var = test69(vt);
1817         for (int i = 0; i &lt; va.length; ++i) {
1818             Asserts.assertEQ(va[i], var[i]);
1819         }
1820     }
1821 
1822     // A store with a default value can be eliminated: same as test68
1823     // but store is farther away from allocation
1824     @Test
1825     public MyValue1.ref[] test70(MyValue1.ref[] other) {
1826         other[1] = other[0];
1827         MyValue1.ref[] va = new MyValue1.ref[2];
1828         other[0] = va[1];
1829         va[0] = va[1];
1830         return va;
1831     }
1832 
1833     @DontCompile
1834     public void test70_verifier(boolean warmup) {
1835         MyValue1.ref[] va = new MyValue1.ref[2];
1836         MyValue1.ref[] var = test70(va);
1837         for (int i = 0; i &lt; 2; ++i) {
1838             Asserts.assertEQ(va[i], var[i]);
1839         }
1840     }
1841 
1842     // EA needs to consider oop fields in flattened arrays
1843     @Test
1844     public void test71() {
1845         int len = 10;
1846         MyValue2.ref[] src = new MyValue2.ref[len];
1847         MyValue2.ref[] dst = new MyValue2.ref[len];
1848         for (int i = 1; i &lt; len; ++i) {
<a name="28" id="anc28"></a><span class="line-modified">1849             src[i] = MyValue2.createWithFieldsDontInline(rI+i, rD+i);</span>
1850         }
1851         System.arraycopy(src, 0, dst, 0, src.length);
1852         for (int i = 0; i &lt; len; ++i) {
1853             if (src[i] == null) {
1854                 Asserts.assertEQ(dst[i], null);
1855             } else {
1856                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1857             }
1858         }
1859     }
1860 
1861     @DontCompile
1862     public void test71_verifier(boolean warmup) {
1863         test71();
1864     }
1865 
1866     // Test EA with leaf call to &#39;store_unknown_value&#39;
1867     @Test
1868     public void test72(Object[] o, boolean b, Object element) {
1869         Object[] arr1 = new Object[10];
1870         Object[] arr2 = new Object[10];
1871         if (b) {
1872             arr1 = o;
1873         }
1874         arr1[0] = element;
1875         arr2[0] = element;
1876     }
1877 
1878     @DontCompile
1879     public void test72_verifier(boolean warmup) {
1880         Object[] arr = new Object[1];
1881         Object elem = new Object();
1882         test72(arr, true, elem);
1883         test72(arr, false, elem);
1884     }
1885 
1886     @Test
1887     public void test73(Object[] oa, MyValue1.ref v, Object o) {
1888         // TestLWorld.test38 use a C1 Phi node for the array. This test
1889         // adds the case where the stored value is a C1 Phi node.
1890         Object o2 = (o == null) ? v : o;
1891         oa[0] = v;  // The stored value is known to be flattenable
1892         oa[1] = o;  // The stored value may be flattenable
1893         oa[2] = o2; // The stored value may be flattenable (a C1 Phi node)
1894         oa[0] = oa; // The stored value is known to be not flattenable (an Object[])
1895     }
1896 
1897     @DontCompile
1898     public void test73_verifier(boolean warmup) {
1899         MyValue1.ref v0 = MyValue1.createWithFieldsDontInline(rI, rL);
1900         MyValue1.ref v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);
1901         MyValue1.ref[] arr = new MyValue1.ref[3];
1902         try {
1903             test73(arr, v0, v1);
1904             throw new RuntimeException(&quot;ArrayStoreException expected&quot;);
1905         } catch (ArrayStoreException t) {
1906             // expected
1907         }
1908         Asserts.assertEQ(arr[0].hash(), v0.hash());
1909         Asserts.assertEQ(arr[1].hash(), v1.hash());
1910         Asserts.assertEQ(arr[2].hash(), v1.hash());
1911     }
1912 
1913     // Some more array clone tests
1914     @ForceInline
1915     public Object[] test74_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1916         Object[] arr = null;
1917         if (i == 10) {
1918             arr = oa;
1919         } else {
1920             arr = va;
1921         }
1922         return arr;
1923     }
1924 
1925     @Test
1926     public Object[] test74(MyValue1.ref[] va, Integer[] oa) {
1927         int i = 0;
1928         for (; i &lt; 10; i++);
1929 
1930         Object[] arr = test74_helper(i, va, oa);
1931         return arr.clone();
1932     }
1933 
1934     @DontCompile
1935     public void test74_verifier(boolean warmup) {
1936         int len = Math.abs(rI) % 10;
1937         MyValue1.ref[] va = new MyValue1.ref[len];
1938         Integer[] oa = new Integer[len];
1939         for (int i = 1; i &lt; len; ++i) {
1940             oa[i] = new Integer(rI);
1941         }
1942         test74_helper(42, va, oa);
1943         Object[] result = test74(va, oa);
1944 
1945         for (int i = 0; i &lt; va.length; ++i) {
1946             Asserts.assertEQ(oa[i], result[i]);
1947             // Check that array has correct properties (null-ok)
1948             result[i] = null;
1949         }
1950     }
1951 
1952     @ForceInline
1953     public Object[] test75_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1954         Object[] arr = null;
1955         if (i == 10) {
1956             arr = va;
1957         } else {
1958             arr = oa;
1959         }
1960         return arr;
1961     }
1962 
1963     @Test
1964     public Object[] test75(MyValue1.ref[] va, Integer[] oa) {
1965         int i = 0;
1966         for (; i &lt; 10; i++);
1967 
1968         Object[] arr = test75_helper(i, va, oa);
1969         return arr.clone();
1970     }
1971 
1972     @DontCompile
1973     public void test75_verifier(boolean warmup) {
1974         int len = Math.abs(rI) % 10;
1975         MyValue1.ref[] va = new MyValue1.ref[len];
1976         MyValue1.ref[] verif = new MyValue1.ref[len];
1977         for (int i = 1; i &lt; len; ++i) {
1978             va[i] = testValue1;
1979             verif[i] = va[i];
1980         }
1981         Integer[] oa = new Integer[len];
1982         test75_helper(42, va, oa);
1983         Object[] result = test75(va, oa);
1984         verify(verif, result);
1985         if (len &gt; 0) {
1986             // Check that array has correct properties (null-ok)
1987             result[0] = null;
1988         }
1989     }
1990 
1991     // Test mixing nullable and non-nullable arrays
1992     @Test
1993     public Object[] test76(MyValue1[] vva, MyValue1.ref[] vba, MyValue1 vt, Object[] out, int n) {
1994         Object[] result = null;
1995         if (n == 0) {
1996             result = vva;
1997         } else if (n == 1) {
1998             result = vba;
1999         } else if (n == 2) {
2000             result = new MyValue1[42];
2001         } else if (n == 3) {
2002             result = new MyValue1.ref[42];
2003         }
2004         result[0] = vt;
2005         out[0] = result[1];
2006         return result;
2007     }
2008 
2009     @DontCompile
2010     public void test76_verifier(boolean warmup) {
2011         MyValue1 vt = testValue1;
2012         Object[] out = new Object[1];
2013         MyValue1[] vva = new MyValue1[42];
2014         MyValue1[] vva_r = new MyValue1[42];
2015         vva_r[0] = vt;
2016         MyValue1.ref[] vba = new MyValue1.ref[42];
2017         MyValue1.ref[] vba_r = new MyValue1.ref[42];
2018         vba_r[0] = vt;
2019         Object[] result = test76(vva, vba, vt, out, 0);
2020         verify(result, vva_r);
2021         Asserts.assertEQ(out[0], vva_r[1]);
2022         result = test76(vva, vba, vt, out, 1);
2023         verify(result, vba_r);
2024         Asserts.assertEQ(out[0], vba_r[1]);
2025         result = test76(vva, vba, vt, out, 2);
2026         verify(result, vva_r);
2027         Asserts.assertEQ(out[0], vva_r[1]);
2028         result = test76(vva, vba, vt, out, 3);
2029         verify(result, vba_r);
2030         Asserts.assertEQ(out[0], vba_r[1]);
2031     }
2032 
2033     @Test
2034     public Object[] test77(boolean b) {
2035         Object[] va;
2036         if (b) {
2037             va = new MyValue1.ref[5];
2038             for (int i = 0; i &lt; 5; ++i) {
2039                 va[i] = testValue1;
2040             }
2041         } else {
2042             va = new MyValue1[10];
2043             for (int i = 0; i &lt; 10; ++i) {
2044                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
2045             }
2046         }
2047         long sum = ((MyValue1)va[0]).hashInterpreted();
2048         if (b) {
2049             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
2050         } else {
2051             va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);
2052         }
2053         return va;
2054     }
2055 
2056     @DontCompile
2057     public void test77_verifier(boolean warmup) {
2058         Object[] va = test77(true);
2059         Asserts.assertEQ(va.length, 5);
2060         Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI, hash()));
2061         for (int i = 1; i &lt; 5; ++i) {
2062             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash());
2063         }
2064         va = test77(false);
2065         Asserts.assertEQ(va.length, 10);
2066         Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI + 1, hash(rI, rL) + 1));
2067         for (int i = 1; i &lt; 10; ++i) {
2068             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash(rI + i, rL + i));
2069         }
2070     }
2071 
2072     // Same as test76 but with non inline type array cases
2073     @Test
2074     public Object[] test78(MyValue1[] vva, MyValue1.ref[] vba, Object val, Object[] out, int n) {
2075         Object[] result = null;
2076         if (n == 0) {
2077             result = vva;
2078         } else if (n == 1) {
2079             result = vba;
2080         } else if (n == 2) {
2081             result = new MyValue1[42];
2082         } else if (n == 3) {
2083             result = new MyValue1.ref[42];
2084         } else if (n == 4) {
2085             result = new Integer[42];
2086         }
2087         result[0] = val;
2088         out[0] = result[1];
2089         return result;
2090     }
2091 
2092     @DontCompile
2093     public void test78_verifier(boolean warmup) {
2094         MyValue1 vt = testValue1;
2095         Integer i = new Integer(42);
2096         Object[] out = new Object[1];
2097         MyValue1[] vva = new MyValue1[42];
2098         MyValue1[] vva_r = new MyValue1[42];
2099         vva_r[0] = vt;
2100         MyValue1.ref[] vba = new MyValue1.ref[42];
2101         MyValue1.ref[] vba_r = new MyValue1.ref[42];
2102         vba_r[0] = vt;
2103         Object[] result = test78(vva, vba, vt, out, 0);
2104         verify(result, vva_r);
2105         Asserts.assertEQ(out[0], vva_r[1]);
2106         result = test78(vva, vba, vt, out, 1);
2107         verify(result, vba_r);
2108         Asserts.assertEQ(out[0], vba_r[1]);
2109         result = test78(vva, vba, vt, out, 2);
2110         verify(result, vva_r);
2111         Asserts.assertEQ(out[0], vva_r[1]);
2112         result = test78(vva, vba, vt, out, 3);
2113         verify(result, vba_r);
2114         Asserts.assertEQ(out[0], vba_r[1]);
2115         result = test78(vva, vba, i, out, 4);
2116         Asserts.assertEQ(result[0], i);
2117         Asserts.assertEQ(out[0], null);
2118     }
2119 
2120     // Test widening conversions from [Q to [L
2121     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2122     public static MyValue1.ref[] test79(MyValue1[] va) {
2123         return va;
2124     }
2125 
2126     @DontCompile
2127     public void test79_verifier(boolean warmup) {
2128         MyValue1[] va = new MyValue1[1];
2129         va[0] = testValue1;
2130         MyValue1.ref[] res = test79(va);
2131         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2132         try {
2133             res[0] = null;
2134             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2135         } catch (NullPointerException npe) {
2136             // Expected
2137         }
2138         res[0] = testValue1;
2139         test79(null); // Should not throw NPE
2140     }
2141 
2142     // Same as test79 but with explicit cast and Object return
2143     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2144     public static Object[] test80(MyValue1[] va) {
2145         return (MyValue1.ref[])va;
2146     }
2147 
2148     @DontCompile
2149     public void test80_verifier(boolean warmup) {
2150         MyValue1[] va = new MyValue1[1];
2151         va[0] = testValue1;
2152         Object[] res = test80(va);
2153         Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());
2154         try {
2155             res[0] = null;
2156             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2157         } catch (NullPointerException npe) {
2158             // Expected
2159         }
2160         res[0] = testValue1;
2161         test80(null); // Should not throw NPE
2162     }
2163 
2164     // Test mixing widened and boxed array type
2165     @Test()
2166     public static long test81(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt, boolean b, boolean shouldThrow) {
2167         MyValue1.ref[] result = b ? va1 : va2;
2168         try {
2169             result[0] = vt;
2170         } catch (NullPointerException npe) {
2171             // Ignored
2172         }
2173         return result[1].hash();
2174     }
2175 
2176     @DontCompile
2177     public void test81_verifier(boolean warmup) {
2178         MyValue1[] va = new MyValue1[2];
2179         MyValue1.ref[] vaB = new MyValue1.ref[2];
2180         va[1] = testValue1;
2181         vaB[1] = testValue1;
2182         long res = test81(va, vaB, testValue1, true, true);
2183         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2184         Asserts.assertEquals(res, testValue1.hash());
2185         res = test81(va, vaB, testValue1, false, false);
2186         Asserts.assertEquals(vaB[0].hash(), testValue1.hash());
2187         Asserts.assertEquals(res, testValue1.hash());
2188         res = test81(va, va, testValue1, false, true);
2189         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2190         Asserts.assertEquals(res, testValue1.hash());
2191     }
2192 
2193     // Same as test81 but more cases and null writes
2194     @Test()
2195     public static long test82(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt1, MyValue1.ref vt2, int i, boolean shouldThrow) {
2196         MyValue1.ref[] result = null;
2197         if (i == 0) {
2198             result = va1;
2199         } else if (i == 1) {
2200             result = va2;
2201         } else if (i == 2) {
2202             result = new MyValue1.ref[2];
2203             result[1] = vt1;
2204         } else if (i == 3) {
2205             result = new MyValue1[2];
2206             result[1] = vt1;
2207         }
2208         try {
2209             result[0] = (i &lt;= 1) ? null : vt2;
2210             if (shouldThrow) {
2211                 throw new RuntimeException(&quot;NullPointerException expected&quot;);
2212             }
2213         } catch (NullPointerException npe) {
2214             Asserts.assertTrue(shouldThrow, &quot;NullPointerException thrown&quot;);
2215         }
2216         result[0] = vt1;
2217         return result[1].hash();
2218     }
2219 
2220     @DontCompile
2221     public void test82_verifier(boolean warmup) {
2222         MyValue1[] va = new MyValue1[2];
2223         MyValue1.ref[] vaB = new MyValue1.ref[2];
2224         va[1] = testValue1;
2225         vaB[1] = testValue1;
2226         long res = test82(va, vaB, testValue1, testValue1, 0, true);
2227         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2228         Asserts.assertEquals(res, testValue1.hash());
2229         res = test82(va, vaB, testValue1, testValue1, 1, false);
2230         Asserts.assertEquals(vaB[0].hash(), testValue1.hash());
2231         Asserts.assertEquals(res, testValue1.hash());
2232         res = test82(va, va, testValue1, testValue1, 1, true);
2233         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2234         Asserts.assertEquals(res, testValue1.hash());
2235         res = test82(va, va, testValue1, null, 2, false);
2236         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2237         Asserts.assertEquals(res, testValue1.hash());
2238         res = test82(va, va, testValue1, null, 3, true);
2239         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2240         Asserts.assertEquals(res, testValue1.hash());
2241     }
2242 
2243     @Test(failOn = ALLOC + ALLOCA + STORE)
2244     public static long test83(MyValue1[] va) {
2245         MyValue1.ref[] result = va;
2246         return result[0].hash();
2247     }
2248 
2249     @DontCompile
2250     public void test83_verifier(boolean warmup) {
2251         MyValue1[] va = new MyValue1[42];
2252         va[0] = testValue1;
2253         long res = test83(va);
2254         Asserts.assertEquals(res, testValue1.hash());
2255     }
2256 
2257     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + LOOP + STORE + TRAP)
2258     @Test(valid = InlineTypeArrayFlattenOff)
2259     public static MyValue1.ref[] test84(MyValue1 vt1, MyValue1.ref vt2) {
2260         MyValue1.ref[] result = new MyValue1[2];
2261         result[0] = vt1;
2262         result[1] = vt2;
2263         return result;
2264     }
2265 
2266     @DontCompile
2267     public void test84_verifier(boolean warmup) {
2268         MyValue1.ref[] res = test84(testValue1, testValue1);
2269         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2270         Asserts.assertEquals(res[1].hash(), testValue1.hash());
2271         try {
2272             test84(testValue1, null);
2273             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2274         } catch (NullPointerException npe) {
2275             // Expected
2276         }
2277     }
2278 
2279     @Test()
2280     public static long test85(MyValue1.ref[] va, MyValue1 val) {
2281         va[0] = val;
2282         return va[1].hash();
2283     }
2284 
2285     @DontCompile
2286     public void test85_verifier(boolean warmup) {
2287         MyValue1[] va = new MyValue1[2];
2288         MyValue1.ref[] vab = new MyValue1.ref[2];
2289         va[1] = testValue1;
2290         vab[1] = testValue1;
2291         long res = test85(va, testValue1);
2292         Asserts.assertEquals(res, testValue1.hash());
2293         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2294         res = test85(vab, testValue1);
2295         Asserts.assertEquals(res, testValue1.hash());
2296         Asserts.assertEquals(vab[0].hash(), testValue1.hash());
2297     }
2298 
2299     // Same as test85 but with ref value
2300     @Test()
2301     public static long test86(MyValue1.ref[] va, MyValue1.ref val) {
2302         va[0] = val;
2303         return va[1].hash();
2304     }
2305 
2306     @DontCompile
2307     public void test86_verifier(boolean warmup) {
2308         MyValue1[] va = new MyValue1[2];
2309         MyValue1.ref[] vab = new MyValue1.ref[2];
2310         va[1] = testValue1;
2311         vab[1] = testValue1;
2312         long res = test86(va, testValue1);
2313         Asserts.assertEquals(res, testValue1.hash());
2314         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2315         try {
2316             test86(va, null);
2317             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2318         } catch (NullPointerException npe) {
2319             // Expected
2320         }
2321         res = test86(vab, testValue1);
2322         Asserts.assertEquals(res, testValue1.hash());
2323         Asserts.assertEquals(vab[0].hash(), testValue1.hash());
2324         res = test86(vab, null);
2325         Asserts.assertEquals(res, testValue1.hash());
2326         Asserts.assertEquals(vab[0], null);
2327     }
2328 
2329     // Test initialization of nullable array with constant
2330     @Test()
2331     public long test87() {
2332         MyValue1.ref[] va = new MyValue1.ref[1];
2333         va[0] = testValue1;
2334         return va[0].hash();
2335     }
2336 
2337     @DontCompile
2338     public void test87_verifier(boolean warmup) {
2339         long result = test87();
2340         Asserts.assertEQ(result, hash());
2341     }
2342 
2343     // Test narrowing conversion from [L to [Q
2344     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2345     public static MyValue1[] test88(MyValue1.ref[] va) {
2346         return (MyValue1[])va;
2347     }
2348 
2349     @DontCompile
2350     public void test88_verifier(boolean warmup) {
2351         MyValue1[] va = new MyValue1[1];
2352         va[0] = testValue1;
2353         MyValue1[] res = test88(va);
2354         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2355         res[0] = testValue1;
2356         test88(null); // Should not throw NPE
2357         try {
2358             test88(new MyValue1.ref[1]);
2359             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2360         } catch (ClassCastException cce) {
2361             // Expected
2362         }
2363     }
2364 
2365     // Same as test88 but with explicit cast and Object argument
2366     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2367     public static MyValue1[] test89(Object[] va) {
2368         return (MyValue1[])va;
2369     }
2370 
2371     @DontCompile
2372     public void test89_verifier(boolean warmup) {
2373         MyValue1[] va = new MyValue1[1];
2374         va[0] = testValue1;
2375         MyValue1[] res = test89(va);
2376         Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());
2377         res[0] = testValue1;
2378         test89(null); // Should not throw NPE
2379         try {
2380             test89(new MyValue1.ref[1]);
2381             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2382         } catch (ClassCastException cce) {
2383             // Expected
2384         }
2385     }
2386 
2387     // More cast tests
2388     @Test()
2389     public static MyValue1.ref[] test90(Object va) {
2390         return (MyValue1.ref[])va;
2391     }
2392 
2393     @DontCompile
2394     public void test90_verifier(boolean warmup) {
2395         MyValue1[] va = new MyValue1[1];
2396         MyValue1.ref[] vab = new MyValue1.ref[1];
2397         try {
2398           // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
2399           test90(new Integer[0]);
2400         } catch (ClassCastException cce) {
2401           // Expected
2402         }
2403         test90(va);
2404         test90(vab);
2405         test90(null);
2406     }
2407 
2408     @Test()
2409     public static MyValue1.ref[] test91(Object[] va) {
2410         return (MyValue1.ref[])va;
2411     }
2412 
2413     @DontCompile
2414     public void test91_verifier(boolean warmup) {
2415         MyValue1[] va = new MyValue1[1];
2416         MyValue1.ref[] vab = new MyValue1.ref[1];
2417         try {
2418           // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
2419           test91(new Integer[0]);
2420         } catch (ClassCastException cce) {
2421           // Expected
2422         }
2423         test91(va);
2424         test91(vab);
2425         test91(null);
2426     }
2427 
2428     // Test if arraycopy intrinsic correctly checks for flattened source array
2429     @Test()
2430     public static void test92(MyValue1.ref[] src, MyValue1.ref[] dst) {
2431         System.arraycopy(src, 0, dst, 0, 2);
2432     }
2433 
2434     @DontCompile
2435     public void test92_verifier(boolean warmup) {
2436         MyValue1[]  va = new MyValue1[2];
2437         MyValue1.ref[] vab = new MyValue1.ref[2];
2438         va[0] = testValue1;
2439         vab[0] = testValue1;
2440         test92(va, vab);
2441         Asserts.assertEquals(va[0], vab[0]);
2442         Asserts.assertEquals(va[1], vab[1]);
2443     }
2444 
2445     @Test()
2446     public static void test93(Object src, MyValue1.ref[] dst) {
2447         System.arraycopy(src, 0, dst, 0, 2);
2448     }
2449 
2450     @DontCompile
2451     public void test93_verifier(boolean warmup) {
2452         MyValue1[]  va = new MyValue1[2];
2453         MyValue1.ref[] vab = new MyValue1.ref[2];
2454         va[0] = testValue1;
2455         vab[0] = testValue1;
2456         test93(va, vab);
2457         Asserts.assertEquals(va[0], vab[0]);
2458         Asserts.assertEquals(va[1], vab[1]);
2459     }
2460 
2461     // Test non-escaping allocation with arraycopy
2462     // that does not modify loaded array element.
2463     @Test()
2464     public static long test94() {
2465         MyValue1.ref[] src = new MyValue1.ref[8];
2466         MyValue1[]  dst = new MyValue1[8];
2467         for (int i = 1; i &lt; 8; ++i) {
2468             src[i] = testValue1;
2469         }
2470         System.arraycopy(src, 1, dst, 2, 6);
2471         return dst[0].hash();
2472     }
2473 
2474     @DontCompile
2475     public static void test94_verifier(boolean warmup) {
2476         long result = test94();
2477         Asserts.assertEquals(result, MyValue1.default.hash());
2478     }
2479 
2480     // Test meeting constant TypeInstPtr with InlineTypeNode
2481     @ForceInline
2482     public long test95_callee() {
2483         MyValue1.ref[] va = new MyValue1.ref[1];
2484         va[0] = testValue1;
2485         return va[0].hashInterpreted();
2486     }
2487 
2488     @Test()
2489     @Warmup(0)
2490     public long test95() {
2491         return test95_callee();
2492     }
2493 
2494     @DontCompile
2495     public void test95_verifier(boolean warmup) {
2496         long result = test95();
2497         Asserts.assertEQ(result, hash());
2498     }
2499 
2500     // Matrix multiplication test to exercise type flow analysis with nullable inline type arrays
2501     inline static class Complex {
2502         private final double re;
2503         private final double im;
2504 
2505         Complex(double re, double im) {
2506             this.re = re;
2507             this.im = im;
2508         }
2509 
2510         public Complex add(Complex that) {
2511             return new Complex(this.re + that.re, this.im + that.im);
2512         }
2513 
2514         public Complex mul(Complex that) {
2515             return new Complex(this.re * that.re - this.im * that.im,
2516                                this.re * that.im + this.im * that.re);
2517         }
2518     }
2519 
2520     @Test()
2521     public Complex.ref[][] test96(Complex.ref[][] A, Complex.ref[][] B) {
2522         int size = A.length;
2523         Complex.ref[][] R = new Complex.ref[size][size];
2524         for (int i = 0; i &lt; size; i++) {
2525             for (int k = 0; k &lt; size; k++) {
2526                 Complex.ref aik = A[i][k];
2527                 for (int j = 0; j &lt; size; j++) {
2528                     R[i][j] = B[i][j].add(aik.mul((Complex)B[k][j]));
2529                 }
2530             }
2531         }
2532         return R;
2533     }
2534 
2535     static Complex.ref[][] test96_A = new Complex.ref[10][10];
2536     static Complex.ref[][] test96_B = new Complex.ref[10][10];
2537     static Complex.ref[][] test96_R;
2538 
2539     static {
2540         for (int i = 0; i &lt; 10; i++) {
2541             for (int j = 0; j &lt; 10; j++) {
2542                 test96_A[i][j] = new Complex(rI, rI);
2543                 test96_B[i][j] = new Complex(rI, rI);
2544             }
2545         }
2546     }
2547 
2548     @DontCompile
2549     public void test96_verifier(boolean warmup) {
2550         Complex.ref[][] result = test96(test96_A, test96_B);
2551         if (test96_R == null) {
2552             test96_R = result;
2553         }
2554         for (int i = 0; i &lt; 10; i++) {
2555             for (int j = 0; j &lt; 10; j++) {
2556                 Asserts.assertEQ(result[i][j], test96_R[i][j]);
2557             }
2558         }
2559     }
2560 
2561     // Test loads from vararg arrays
2562     @Test(failOn = LOAD_UNKNOWN_INLINE)
2563     public static Object test97(Object... args) {
2564         return args[0];
2565     }
2566 
2567     @DontCompile
2568     public static void test97_verifier(boolean warmup) {
2569         Object obj = new Object();
2570         Object result = test97(obj);
2571         Asserts.assertEquals(result, obj);
2572         Integer[] myInt = new Integer[1];
2573         myInt[0] = rI;
2574         result = test97((Object[])myInt);
2575         Asserts.assertEquals(result, rI);
2576     }
2577 
2578     @Test()
2579     public static Object test98(Object... args) {
2580         return args[0];
2581     }
2582 
2583     @DontCompile
2584     public static void test98_verifier(boolean warmup) {
2585         Object obj = new Object();
2586         Object result = test98(obj);
2587         Asserts.assertEquals(result, obj);
2588         Integer[] myInt = new Integer[1];
2589         myInt[0] = rI;
2590         result = test98((Object[])myInt);
2591         Asserts.assertEquals(result, rI);
2592         if (!warmup) {
2593             MyValue1[] va = new MyValue1[1];
2594             MyValue1.ref[] vab = new MyValue1.ref[1];
2595             result = test98((Object[])va);
2596             Asserts.assertEquals(((MyValue1)result).hash(), MyValue1.default.hash());
2597             result = test98((Object[])vab);
2598             Asserts.assertEquals(result, null);
2599         }
2600     }
2601 
2602     @Test()
2603     public static Object test99(Object... args) {
2604         return args[0];
2605     }
2606 
2607     @DontCompile
2608     public static void test99_verifier(boolean warmup) {
2609         Object obj = new Object();
2610         Object result = test99(obj);
2611         Asserts.assertEquals(result, obj);
2612         Integer[] myInt = new Integer[1];
2613         myInt[0] = rI;
2614         result = test99((Object[])myInt);
2615         Asserts.assertEquals(result, rI);
2616         if (!warmup) {
2617             try {
2618                 test99((Object[])null);
2619                 throw new RuntimeException(&quot;No NPE thrown&quot;);
2620             } catch (NullPointerException npe) {
2621                 // Expected
2622             }
2623         }
2624     }
2625 
2626     @Test()
2627     public static Object test100(Object... args) {
2628         return args[0];
2629     }
2630 
2631     @DontCompile
2632     public static void test100_verifier(boolean warmup) {
2633         Object obj = new Object();
2634         Object result = test100(obj);
2635         Asserts.assertEquals(result, obj);
2636         Integer[] myInt = new Integer[1];
2637         myInt[0] = rI;
2638         result = test100((Object[])myInt);
2639         Asserts.assertEquals(result, rI);
2640         if (!warmup) {
2641             try {
2642                 test100();
2643                 throw new RuntimeException(&quot;No AIOOBE thrown&quot;);
2644             } catch (ArrayIndexOutOfBoundsException aioobe) {
2645                 // Expected
2646             }
2647         }
2648     }
2649 
2650     // Test stores to varag arrays
2651     @Test(failOn = STORE_UNKNOWN_INLINE)
2652     public static void test101(Object val, Object... args) {
2653         args[0] = val;
2654     }
2655 
2656     @DontCompile
2657     public static void test101_verifier(boolean warmup) {
2658         Object obj = new Object();
2659         test101(obj, obj);
2660         Integer[] myInt = new Integer[1];
2661         test101(rI, (Object[])myInt);
2662         Asserts.assertEquals(myInt[0], rI);
2663         test101(null, (Object[])myInt);
2664         Asserts.assertEquals(myInt[0], null);
2665     }
2666 
2667     @Test()
2668     public static void test102(Object val, Object... args) {
2669         args[0] = val;
2670     }
2671 
2672     @DontCompile
2673     public static void test102_verifier(boolean warmup) {
2674         Object obj = new Object();
2675         test102(obj, obj);
2676         Integer[] myInt = new Integer[1];
2677         test102(rI, (Object[])myInt);
2678         Asserts.assertEquals(myInt[0], rI);
2679         test102(null, (Object[])myInt);
2680         Asserts.assertEquals(myInt[0], null);
2681         if (!warmup) {
2682             MyValue1[] va = new MyValue1[1];
2683             MyValue1.ref[] vab = new MyValue1.ref[1];
2684             test102(testValue1, (Object[])va);
2685             Asserts.assertEquals(va[0].hash(), testValue1.hash());
2686             test102(testValue1, (Object[])vab);
2687             Asserts.assertEquals(vab[0].hash(), testValue1.hash());
2688             test102(null, (Object[])vab);
2689             Asserts.assertEquals(vab[0], null);
2690         }
2691     }
2692 
2693     @Test()
2694     public static void test103(Object val, Object... args) {
2695         args[0] = val;
2696     }
2697 
2698     @DontCompile
2699     public static void test103_verifier(boolean warmup) {
2700         Object obj = new Object();
2701         test103(obj, obj);
2702         Integer[] myInt = new Integer[1];
2703         test103(rI, (Object[])myInt);
2704         Asserts.assertEquals(myInt[0], rI);
2705         test103(null, (Object[])myInt);
2706         Asserts.assertEquals(myInt[0], null);
2707         if (!warmup) {
2708             MyValue1[] va = new MyValue1[1];
2709             try {
2710                 test103(null, (Object[])va);
2711                 throw new RuntimeException(&quot;No NPE thrown&quot;);
2712             } catch (NullPointerException npe) {
2713                 // Expected
2714             }
2715         }
2716     }
2717 
2718     @Test()
2719     public static void test104(Object val, Object... args) {
2720         args[0] = val;
2721     }
2722 
2723     @DontCompile
2724     public static void test104_verifier(boolean warmup) {
2725         Object obj = new Object();
2726         test104(obj, obj);
2727         Integer[] myInt = new Integer[1];
2728         test104(rI, (Object[])myInt);
2729         Asserts.assertEquals(myInt[0], rI);
2730         test104(null, (Object[])myInt);
2731         Asserts.assertEquals(myInt[0], null);
2732         if (!warmup) {
2733             try {
2734                 test104(testValue1);
2735                 throw new RuntimeException(&quot;No AIOOBE thrown&quot;);
2736             } catch (ArrayIndexOutOfBoundsException aioobe) {
2737                 // Expected
2738             }
2739         }
2740     }
2741 
2742     @Test()
2743     public static void test105(Object val, Object... args) {
2744         args[0] = val;
2745     }
2746 
2747     @DontCompile
2748     public static void test105_verifier(boolean warmup) {
2749         Object obj = new Object();
2750         test105(obj, obj);
2751         Integer[] myInt = new Integer[1];
2752         test105(rI, (Object[])myInt);
2753         Asserts.assertEquals(myInt[0], rI);
2754         test105(null, (Object[])myInt);
2755         Asserts.assertEquals(myInt[0], null);
2756         if (!warmup) {
2757             try {
2758                 test105(testValue1, (Object[])null);
2759                 throw new RuntimeException(&quot;No NPE thrown&quot;);
2760             } catch (NullPointerException npe) {
2761                 // Expected
2762             }
2763         }
2764     }
2765 
2766     @Test()
2767     public static Object[] test106(Object[] dst, Object... args) {
2768         // Access array to speculate on non-flatness
2769         if (args[0] == null) {
2770             args[0] = testValue1;
2771         }
2772         System.arraycopy(args, 0, dst, 0, args.length);
2773         System.arraycopy(dst, 0, args, 0, dst.length);
2774         Object[] clone = args.clone();
2775         if (clone[0] == null) {
2776             throw new RuntimeException(&quot;Unexpected null&quot;);
2777         }
2778         return Arrays.copyOf(args, args.length, Object[].class);
2779     }
2780 
2781     @DontCompile
2782     public static void test106_verifier(boolean warmup) {
2783         Object[] dst = new Object[1];
2784         Object obj = new Object();
2785         Object[] result = test106(dst, obj);
2786         Asserts.assertEquals(result[0], obj);
2787         Integer[] myInt = new Integer[1];
2788         myInt[0] = rI;
2789         result = test106(myInt, (Object[])myInt);
2790         Asserts.assertEquals(result[0], rI);
2791         if (!warmup) {
2792             MyValue1[] va = new MyValue1[1];
2793             MyValue1.ref[] vab = new MyValue1.ref[1];
2794             result = test106(va, (Object[])va);
2795             Asserts.assertEquals(((MyValue1)result[0]).hash(), MyValue1.default.hash());
2796             result = test106(vab, (Object[])vab);
2797             Asserts.assertEquals(((MyValue1)result[0]).hash(), testValue1.hash());
2798         }
2799     }
2800 
2801     // Test that allocation is not replaced by non-dominating allocation
2802     public long test107_helper(MyValue1.ref[] va, MyValue1 vt) {
2803         try {
2804             va[0] = vt;
2805         } catch (NullPointerException npe) { }
2806         return va[1].hash();
2807     }
2808 
2809     @Test()
2810     public void test107() {
2811         MyValue1[] va = new MyValue1[2];
2812         MyValue1.ref[] tmp = new MyValue1.ref[2];
2813         long res1 = test107_helper(va, testValue1);
2814         long res2 = test107_helper(va, testValue1);
2815         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2816         Asserts.assertEquals(res1, MyValue1.default.hash());
2817         Asserts.assertEquals(res2, MyValue1.default.hash());
2818     }
2819 
2820     @DontCompile
2821     public void test107_verifier(boolean warmup) {
2822         test107();
2823     }
2824 
2825     @Test
2826     @Warmup(10000)
2827     public Object test108(MyValue1.ref[] src, boolean flag) {
2828         MyValue1.ref[] dst = new MyValue1.ref[8];
2829         System.arraycopy(src, 1, dst, 2, 6);
2830         if (flag) {} // uncommon trap
2831         return dst[2];
2832     }
2833 
2834     @DontCompile
2835     public void test108_verifier(boolean warmup) {
2836         MyValue1.ref[] src = new MyValue1.ref[8];
2837         test108(src, !warmup);
2838     }
2839 
2840     // Test LoadNode::can_see_arraycopy_value optimization
2841     @Test()
2842     public static void test109() {
2843         MyValue1[] src = new MyValue1[1];
2844         MyValue1.ref[] dst = new MyValue1.ref[1];
2845         src[0] = testValue1;
2846         System.arraycopy(src, 0, dst, 0, 1);
2847         Asserts.assertEquals(src[0], dst[0]);
2848     }
2849 
2850     @DontCompile
2851     public void test109_verifier(boolean warmup) {
2852         test109();
2853     }
2854 
2855     // Same as test109 but with Object destination array
2856     @Test()
2857     public static void test110() {
2858         MyValue1[] src = new MyValue1[1];
2859         Object[] dst = new Object[1];
2860         src[0] = testValue1;
2861         System.arraycopy(src, 0, dst, 0, 1);
2862         Asserts.assertEquals(src[0], dst[0]);
2863     }
2864 
2865     @DontCompile
2866     public void test110_verifier(boolean warmup) {
2867         test110();
2868     }
2869 
2870     // Same as test109 but with Arrays.copyOf
2871     @Test()
2872     public static void test111() {
2873         MyValue1[] src = new MyValue1[1];
2874         src[0] = testValue1;
2875         MyValue1.ref[] dst = Arrays.copyOf(src, src.length, MyValue1.ref[].class);
2876         Asserts.assertEquals(src[0], dst[0]);
2877     }
2878 
2879     @DontCompile
2880     public void test111_verifier(boolean warmup) {
2881         test111();
2882     }
2883 }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>