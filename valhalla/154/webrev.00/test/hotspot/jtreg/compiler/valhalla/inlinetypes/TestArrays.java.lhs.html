<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.inlinetypes;
  25 
  26 import jdk.test.lib.Asserts;
  27 import java.lang.invoke.*;
  28 import java.lang.reflect.Method;
  29 import java.util.Arrays;
  30 
  31 /*
  32  * @test
  33  * @key randomness
  34  * @summary Test inline type arrays
  35  * @library /testlibrary /test/lib /compiler/whitebox /
  36  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  37  * @compile TestArrays.java
  38  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  39  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  40  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  41  *                               compiler.valhalla.inlinetypes.InlineTypeTest
  42  *                               compiler.valhalla.inlinetypes.TestArrays
  43  */
  44 public class TestArrays extends InlineTypeTest {
  45     // Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to
  46     // a normal method invocation when encountering flattened arrays.
  47     private static void assertDeoptimizedByC2(Method m) {
  48         int CompLevel_none              = 0,         // Interpreter
  49             CompLevel_simple            = 1,         // C1
  50             CompLevel_limited_profile   = 2,         // C1, invocation &amp; backedge counters
  51             CompLevel_full_profile      = 3,         // C1, invocation &amp; backedge counters + mdo
  52             CompLevel_full_optimization = 4;         // C2 or JVMCI
  53 
  54         if (USE_COMPILER &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC &amp;&amp; WHITE_BOX.isMethodCompiled(m, false) &amp;&amp;
  55             WHITE_BOX.getMethodCompilationLevel(m, false) &gt;= CompLevel_full_optimization) {
  56             throw new RuntimeException(&quot;Type check should have caused it to deoptimize&quot;);
  57         }
  58     }
  59 
  60     // Extra VM parameters for some test scenarios. See InlineTypeTest.getVMParameters()
  61     @Override
  62     public String[] getExtraVMParameters(int scenario) {
  63         switch (scenario) {
  64         case 2: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  65         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:FlatArrayElementMaxSize=-1&quot;, &quot;-XX:-UncommonNullCast&quot;};
  66         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  67         case 5: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  68         }
  69         return null;
  70     }
  71 
  72     public static void main(String[] args) throws Throwable {
  73         TestArrays test = new TestArrays();
  74         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  75     }
  76 
  77     // Helper methods
  78 
  79     protected long hash() {
  80         return hash(rI, rL);
  81     }
  82 
  83     protected long hash(int x, long y) {
  84         return MyValue1.createWithFieldsInline(x, y).hash();
  85     }
  86 
  87     // Test inline type array creation and initialization
  88     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
  89     @Test(valid = InlineTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
  90     public MyValue1[] test1(int len) {
  91         MyValue1[] va = new MyValue1[len];
  92         for (int i = 0; i &lt; len; ++i) {
  93             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  94         }
  95         return va;
  96     }
  97 
  98     @DontCompile
  99     public void test1_verifier(boolean warmup) {
 100         int len = Math.abs(rI % 10);
 101         MyValue1[] va = test1(len);
 102         for (int i = 0; i &lt; len; ++i) {
 103             Asserts.assertEQ(va[i].hash(), hash());
 104         }
 105     }
 106 
 107     // Test creation of an inline type array and element access
<a name="1" id="anc1"></a><span class="line-modified"> 108     // TODO 8227588</span>
<span class="line-removed"> 109     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>
<span class="line-removed"> 110     @Test(valid = InlineTypeArrayFlattenOff)</span>
 111     public long test2() {
 112         MyValue1[] va = new MyValue1[1];
 113         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 114         return va[0].hash();
 115     }
 116 
 117     @DontCompile
 118     public void test2_verifier(boolean warmup) {
 119         long result = test2();
 120         Asserts.assertEQ(result, hash());
 121     }
 122 
 123     // Test receiving an inline type array from the interpreter,
 124     // updating its elements in a loop and computing a hash.
 125     @Test(failOn = ALLOCA)
 126     public long test3(MyValue1[] va) {
 127         long result = 0;
 128         for (int i = 0; i &lt; 10; ++i) {
 129             result += va[i].hash();
 130             va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 131         }
 132         return result;
 133     }
 134 
 135     @DontCompile
 136     public void test3_verifier(boolean warmup) {
 137         MyValue1[] va = new MyValue1[10];
 138         long expected = 0;
 139         for (int i = 0; i &lt; 10; ++i) {
 140             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 141             expected += va[i].hash();
 142         }
 143         long result = test3(va);
 144         Asserts.assertEQ(expected, result);
 145         for (int i = 0; i &lt; 10; ++i) {
 146             if (va[i].hash() != hash(rI + 1, rL + 1)) {
 147                 Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));
 148             }
 149         }
 150     }
 151 
 152     // Test returning an inline type array received from the interpreter
 153     @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
 154     public MyValue1[] test4(MyValue1[] va) {
 155         return va;
 156     }
 157 
 158     @DontCompile
 159     public void test4_verifier(boolean warmup) {
 160         MyValue1[] va = new MyValue1[10];
 161         for (int i = 0; i &lt; 10; ++i) {
 162             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 163         }
 164         va = test4(va);
 165         for (int i = 0; i &lt; 10; ++i) {
 166             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 167         }
 168     }
 169 
 170     // Merge inline type arrays created from two branches
 171     @Test
 172     public MyValue1[] test5(boolean b) {
 173         MyValue1[] va;
 174         if (b) {
 175             va = new MyValue1[5];
 176             for (int i = 0; i &lt; 5; ++i) {
 177                 va[i] = MyValue1.createWithFieldsInline(rI, rL);
 178             }
 179         } else {
 180             va = new MyValue1[10];
 181             for (int i = 0; i &lt; 10; ++i) {
 182                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
 183             }
 184         }
 185         long sum = va[0].hashInterpreted();
 186         if (b) {
 187             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
 188         } else {
 189             va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);
 190         }
 191         return va;
 192     }
 193 
 194     @DontCompile
 195     public void test5_verifier(boolean warmup) {
 196         MyValue1[] va = test5(true);
 197         Asserts.assertEQ(va.length, 5);
 198         Asserts.assertEQ(va[0].hash(), hash(rI, hash()));
 199         for (int i = 1; i &lt; 5; ++i) {
 200             Asserts.assertEQ(va[i].hash(), hash());
 201         }
 202         va = test5(false);
 203         Asserts.assertEQ(va.length, 10);
 204         Asserts.assertEQ(va[0].hash(), hash(rI + 1, hash(rI, rL) + 1));
 205         for (int i = 1; i &lt; 10; ++i) {
 206             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 207         }
 208     }
 209 
 210     // Test creation of inline type array with single element
 211     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 212     public MyValue1 test6() {
 213         MyValue1[] va = new MyValue1[1];
 214         return va[0];
 215     }
 216 
 217     @DontCompile
 218     public void test6_verifier(boolean warmup) {
 219         MyValue1[] va = new MyValue1[1];
 220         MyValue1 v = test6();
 221         Asserts.assertEQ(v.hashPrimitive(), va[0].hashPrimitive());
 222     }
 223 
 224     // Test default initialization of inline type arrays
 225     @Test(failOn = LOAD)
 226     public MyValue1[] test7(int len) {
 227         return new MyValue1[len];
 228     }
 229 
 230     @DontCompile
 231     public void test7_verifier(boolean warmup) {
 232         int len = Math.abs(rI % 10);
 233         MyValue1[] va = new MyValue1[len];
 234         MyValue1[] var = test7(len);
 235         for (int i = 0; i &lt; len; ++i) {
 236             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
 237         }
 238     }
 239 
 240     // Test creation of inline type array with zero length
 241     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
 242     public MyValue1[] test8() {
 243         return new MyValue1[0];
 244     }
 245 
 246     @DontCompile
 247     public void test8_verifier(boolean warmup) {
 248         MyValue1[] va = test8();
 249         Asserts.assertEQ(va.length, 0);
 250     }
 251 
 252     static MyValue1[] test9_va;
 253 
 254     // Test that inline type array loaded from field has correct type
 255     @Test(failOn = LOOP)
 256     public long test9() {
 257         return test9_va[0].hash();
 258     }
 259 
 260     @DontCompile
 261     public void test9_verifier(boolean warmup) {
 262         test9_va = new MyValue1[1];
 263         test9_va[0] = MyValue1.createWithFieldsInline(rI, rL);
 264         long result = test9();
 265         Asserts.assertEQ(result, hash());
 266     }
 267 
 268     // Multi-dimensional arrays
 269     @Test
 270     public MyValue1[][][] test10(int len1, int len2, int len3) {
 271         MyValue1[][][] arr = new MyValue1[len1][len2][len3];
 272         for (int i = 0; i &lt; len1; i++) {
 273             for (int j = 0; j &lt; len2; j++) {
 274                 for (int k = 0; k &lt; len3; k++) {
 275                     arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);
 276                 }
 277             }
 278         }
 279         return arr;
 280     }
 281 
 282     @DontCompile
 283     public void test10_verifier(boolean warmup) {
 284         MyValue1[][][] arr = test10(2, 3, 4);
 285         for (int i = 0; i &lt; 2; i++) {
 286             for (int j = 0; j &lt; 3; j++) {
 287                 for (int k = 0; k &lt; 4; k++) {
 288                     Asserts.assertEQ(arr[i][j][k].hash(), MyValue1.createWithFieldsDontInline(rI + i , rL + j + k).hash());
 289                 }
 290             }
 291         }
 292     }
 293 
 294     @Test
 295     public void test11(MyValue1[][][] arr, long[] res) {
 296         int l = 0;
 297         for (int i = 0; i &lt; arr.length; i++) {
 298             for (int j = 0; j &lt; arr[i].length; j++) {
 299                 for (int k = 0; k &lt; arr[i][j].length; k++) {
 300                     res[l] = arr[i][j][k].hash();
 301                     l++;
 302                 }
 303             }
 304         }
 305     }
 306 
 307     @DontCompile
 308     public void test11_verifier(boolean warmup) {
 309         MyValue1[][][] arr = new MyValue1[2][3][4];
 310         long[] res = new long[2*3*4];
 311         long[] verif = new long[2*3*4];
 312         int l = 0;
 313         for (int i = 0; i &lt; 2; i++) {
 314             for (int j = 0; j &lt; 3; j++) {
 315                 for (int k = 0; k &lt; 4; k++) {
 316                     arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i, rL + j + k);
 317                     verif[l] = arr[i][j][k].hash();
 318                     l++;
 319                 }
 320             }
 321         }
 322         test11(arr, res);
 323         for (int i = 0; i &lt; verif.length; i++) {
 324             Asserts.assertEQ(res[i], verif[i]);
 325         }
 326     }
 327 
 328     // Array load out of bounds (upper bound) at compile time
 329     @Test
 330     public int test12() {
 331         int arraySize = Math.abs(rI) % 10;;
 332         MyValue1[] va = new MyValue1[arraySize];
 333 
 334         for (int i = 0; i &lt; arraySize; i++) {
 335             va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 336         }
 337 
 338         try {
 339             return va[arraySize + 1].x;
 340         } catch (ArrayIndexOutOfBoundsException e) {
 341             return rI;
 342         }
 343     }
 344 
 345     public void test12_verifier(boolean warmup) {
 346         Asserts.assertEQ(test12(), rI);
 347     }
 348 
 349     // Array load  out of bounds (lower bound) at compile time
 350     @Test
 351     public int test13() {
 352         int arraySize = Math.abs(rI) % 10;;
 353         MyValue1[] va = new MyValue1[arraySize];
 354 
 355         for (int i = 0; i &lt; arraySize; i++) {
 356             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);
 357         }
 358 
 359         try {
 360             return va[-arraySize].x;
 361         } catch (ArrayIndexOutOfBoundsException e) {
 362             return rI;
 363         }
 364     }
 365 
 366     public void test13_verifier(boolean warmup) {
 367         Asserts.assertEQ(test13(), rI);
 368     }
 369 
 370     // Array load out of bound not known to compiler (both lower and upper bound)
 371     @Test
 372     public int test14(MyValue1[] va, int index)  {
 373         return va[index].x;
 374     }
 375 
 376     public void test14_verifier(boolean warmup) {
 377         int arraySize = Math.abs(rI) % 10;
 378         MyValue1[] va = new MyValue1[arraySize];
 379 
 380         for (int i = 0; i &lt; arraySize; i++) {
 381             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 382         }
 383 
 384         int result;
 385         for (int i = -20; i &lt; 20; i++) {
 386             try {
 387                 result = test14(va, i);
 388             } catch (ArrayIndexOutOfBoundsException e) {
 389                 result = rI;
 390             }
 391             Asserts.assertEQ(result, rI);
 392         }
 393     }
 394 
 395     // Array store out of bounds (upper bound) at compile time
 396     @Test
 397     public int test15() {
 398         int arraySize = Math.abs(rI) % 10;;
 399         MyValue1[] va = new MyValue1[arraySize];
 400 
 401         try {
 402             for (int i = 0; i &lt;= arraySize; i++) {
 403                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 404             }
 405             return rI - 1;
 406         } catch (ArrayIndexOutOfBoundsException e) {
 407             return rI;
 408         }
 409     }
 410 
 411     public void test15_verifier(boolean warmup) {
 412         Asserts.assertEQ(test15(), rI);
 413     }
 414 
 415     // Array store out of bounds (lower bound) at compile time
 416     @Test
 417     public int test16() {
 418         int arraySize = Math.abs(rI) % 10;;
 419         MyValue1[] va = new MyValue1[arraySize];
 420 
 421         try {
 422             for (int i = -1; i &lt;= arraySize; i++) {
 423                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 424             }
 425             return rI - 1;
 426         } catch (ArrayIndexOutOfBoundsException e) {
 427             return rI;
 428         }
 429     }
 430 
 431     public void test16_verifier(boolean warmup) {
 432         Asserts.assertEQ(test16(), rI);
 433     }
 434 
 435     // Array store out of bound not known to compiler (both lower and upper bound)
 436     @Test
 437     public int test17(MyValue1[] va, int index, MyValue1 vt)  {
 438         va[index] = vt;
 439         return va[index].x;
 440     }
 441 
 442     @DontCompile
 443     public void test17_verifier(boolean warmup) {
 444         int arraySize = Math.abs(rI) % 10;
 445         MyValue1[] va = new MyValue1[arraySize];
 446 
 447         for (int i = 0; i &lt; arraySize; i++) {
 448             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 449         }
 450 
 451         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 452         int result;
 453         for (int i = -20; i &lt; 20; i++) {
 454             try {
 455                 result = test17(va, i, vt);
 456             } catch (ArrayIndexOutOfBoundsException e) {
 457                 result = rI + 1;
 458             }
 459             Asserts.assertEQ(result, rI + 1);
 460         }
 461 
 462         for (int i = 0; i &lt; arraySize; i++) {
 463             Asserts.assertEQ(va[i].x, rI + 1);
 464         }
 465     }
 466 
 467     // clone() as stub call
 468     @Test
 469     public MyValue1[] test18(MyValue1[] va) {
 470         return va.clone();
 471     }
 472 
 473     @DontCompile
 474     public void test18_verifier(boolean warmup) {
 475         int len = Math.abs(rI) % 10;
 476         MyValue1[] va = new MyValue1[len];
 477         for (int i = 0; i &lt; len; ++i) {
 478             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 479         }
 480         MyValue1[] result = test18(va);
 481         for (int i = 0; i &lt; len; ++i) {
 482             Asserts.assertEQ(result[i].hash(), va[i].hash());
 483         }
 484     }
 485 
 486     // clone() as series of loads/stores
 487     static MyValue1[] test19_orig = null;
 488 
 489     @Test
 490     public MyValue1[] test19() {
 491         MyValue1[] va = new MyValue1[8];
 492         for (int i = 0; i &lt; va.length; ++i) {
 493             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 494         }
 495         test19_orig = va;
 496 
 497         return va.clone();
 498     }
 499 
 500     @DontCompile
 501     public void test19_verifier(boolean warmup) {
 502         MyValue1[] result = test19();
 503         for (int i = 0; i &lt; test19_orig.length; ++i) {
 504             Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
 505         }
 506     }
 507 
 508     // arraycopy() of inline type array with oop fields
 509     @Test
 510     public void test20(MyValue1[] src, MyValue1[] dst) {
 511         System.arraycopy(src, 0, dst, 0, src.length);
 512     }
 513 
 514     @DontCompile
 515     public void test20_verifier(boolean warmup) {
 516         int len = Math.abs(rI) % 10;
 517         MyValue1[] src = new MyValue1[len];
 518         MyValue1[] dst = new MyValue1[len];
 519         for (int i = 0; i &lt; len; ++i) {
 520             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 521         }
 522         test20(src, dst);
 523         for (int i = 0; i &lt; len; ++i) {
 524             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 525         }
 526     }
 527 
 528     // arraycopy() of inline type array with no oop field
 529     @Test
 530     public void test21(MyValue2[] src, MyValue2[] dst) {
 531         System.arraycopy(src, 0, dst, 0, src.length);
 532     }
 533 
 534     @DontCompile
 535     public void test21_verifier(boolean warmup) {
 536         int len = Math.abs(rI) % 10;
 537         MyValue2[] src = new MyValue2[len];
 538         MyValue2[] dst = new MyValue2[len];
 539         for (int i = 0; i &lt; len; ++i) {
<a name="2" id="anc2"></a><span class="line-modified"> 540             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 541         }
 542         test21(src, dst);
 543         for (int i = 0; i &lt; len; ++i) {
 544             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 545         }
 546     }
 547 
 548     // arraycopy() of inline type array with oop field and tightly
 549     // coupled allocation as dest
 550     @Test
 551     public MyValue1[] test22(MyValue1[] src) {
 552         MyValue1[] dst = new MyValue1[src.length];
 553         System.arraycopy(src, 0, dst, 0, src.length);
 554         return dst;
 555     }
 556 
 557     @DontCompile
 558     public void test22_verifier(boolean warmup) {
 559         int len = Math.abs(rI) % 10;
 560         MyValue1[] src = new MyValue1[len];
 561         for (int i = 0; i &lt; len; ++i) {
 562             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 563         }
 564         MyValue1[] dst = test22(src);
 565         for (int i = 0; i &lt; len; ++i) {
 566             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 567         }
 568     }
 569 
 570     // arraycopy() of inline type array with oop fields and tightly
 571     // coupled allocation as dest
 572     @Test
 573     public MyValue1[] test23(MyValue1[] src) {
 574         MyValue1[] dst = new MyValue1[src.length + 10];
 575         System.arraycopy(src, 0, dst, 5, src.length);
 576         return dst;
 577     }
 578 
 579     @DontCompile
 580     public void test23_verifier(boolean warmup) {
 581         int len = Math.abs(rI) % 10;
 582         MyValue1[] src = new MyValue1[len];
 583         for (int i = 0; i &lt; len; ++i) {
 584             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 585         }
 586         MyValue1[] dst = test23(src);
 587         for (int i = 5; i &lt; len; ++i) {
 588             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 589         }
 590     }
 591 
 592     // arraycopy() of inline type array passed as Object
 593     @Test
 594     public void test24(MyValue1[] src, Object dst) {
 595         System.arraycopy(src, 0, dst, 0, src.length);
 596     }
 597 
 598     @DontCompile
 599     public void test24_verifier(boolean warmup) {
 600         int len = Math.abs(rI) % 10;
 601         MyValue1[] src = new MyValue1[len];
 602         MyValue1[] dst = new MyValue1[len];
 603         for (int i = 0; i &lt; len; ++i) {
 604             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 605         }
 606         test24(src, dst);
 607         for (int i = 0; i &lt; len; ++i) {
 608             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 609         }
 610     }
 611 
 612     // short arraycopy() with no oop field
 613     @Test
 614     public void test25(MyValue2[] src, MyValue2[] dst) {
 615         System.arraycopy(src, 0, dst, 0, 8);
 616     }
 617 
 618     @DontCompile
 619     public void test25_verifier(boolean warmup) {
 620         MyValue2[] src = new MyValue2[8];
 621         MyValue2[] dst = new MyValue2[8];
 622         for (int i = 0; i &lt; 8; ++i) {
<a name="3" id="anc3"></a><span class="line-modified"> 623             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 624         }
 625         test25(src, dst);
 626         for (int i = 0; i &lt; 8; ++i) {
 627             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 628         }
 629     }
 630 
 631     // short arraycopy() with oop fields
 632     @Test
 633     public void test26(MyValue1[] src, MyValue1[] dst) {
 634         System.arraycopy(src, 0, dst, 0, 8);
 635     }
 636 
 637     @DontCompile
 638     public void test26_verifier(boolean warmup) {
 639         MyValue1[] src = new MyValue1[8];
 640         MyValue1[] dst = new MyValue1[8];
 641         for (int i = 0; i &lt; 8; ++i) {
 642             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 643         }
 644         test26(src, dst);
 645         for (int i = 0; i &lt; 8; ++i) {
 646             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 647         }
 648     }
 649 
 650     // short arraycopy() with oop fields and offsets
 651     @Test
 652     public void test27(MyValue1[] src, MyValue1[] dst) {
 653         System.arraycopy(src, 1, dst, 2, 6);
 654     }
 655 
 656     @DontCompile
 657     public void test27_verifier(boolean warmup) {
 658         MyValue1[] src = new MyValue1[8];
 659         MyValue1[] dst = new MyValue1[8];
 660         for (int i = 0; i &lt; 8; ++i) {
 661             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 662         }
 663         test27(src, dst);
 664         for (int i = 2; i &lt; 8; ++i) {
 665             Asserts.assertEQ(src[i-1].hash(), dst[i].hash());
 666         }
 667     }
 668 
 669     // non escaping allocations
<a name="4" id="anc4"></a><span class="line-modified"> 670     // TODO ZGC does not support the clone intrinsic, remove this once JDK-8232896 is fixed</span>
 671     @Test(valid = ZGCOff, failOn = ALLOCA + LOOP + LOAD + TRAP)
 672     @Test(valid = ZGCOn)
 673     public MyValue2 test28() {
 674         MyValue2[] src = new MyValue2[10];
<a name="5" id="anc5"></a><span class="line-modified"> 675         src[0] = MyValue2.createWithFieldsInline(rI, false);</span>
 676         MyValue2[] dst = (MyValue2[])src.clone();
 677         return dst[0];
 678     }
 679 
 680     @DontCompile
 681     public void test28_verifier(boolean warmup) {
<a name="6" id="anc6"></a><span class="line-modified"> 682         MyValue2 v = MyValue2.createWithFieldsInline(rI, false);</span>
 683         MyValue2 result = test28();
 684         Asserts.assertEQ(result.hash(), v.hash());
 685     }
 686 
 687     // non escaping allocations
 688     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
<a name="7" id="anc7"></a>
 689     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOCA + LOOP + LOAD + TRAP)
<a name="8" id="anc8"></a><span class="line-modified"> 690     @Test(valid = InlineTypeArrayFlattenOff)</span>
 691     public MyValue2 test29(MyValue2[] src) {
 692         MyValue2[] dst = new MyValue2[10];
 693         System.arraycopy(src, 0, dst, 0, 10);
 694         return dst[0];
 695     }
 696 
 697     @DontCompile
 698     public void test29_verifier(boolean warmup) {
 699         MyValue2[] src = new MyValue2[10];
 700         for (int i = 0; i &lt; 10; ++i) {
<a name="9" id="anc9"></a><span class="line-modified"> 701             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 702         }
 703         MyValue2 v = test29(src);
 704         Asserts.assertEQ(src[0].hash(), v.hash());
 705     }
 706 
 707     // non escaping allocation with uncommon trap that needs
 708     // eliminated inline type array element as debug info
 709     @Test
 710     @Warmup(10000)
 711     public MyValue2 test30(MyValue2[] src, boolean flag) {
 712         MyValue2[] dst = new MyValue2[10];
 713         System.arraycopy(src, 0, dst, 0, 10);
 714         if (flag) { }
 715         return dst[0];
 716     }
 717 
 718     @DontCompile
 719     public void test30_verifier(boolean warmup) {
 720         MyValue2[] src = new MyValue2[10];
 721         for (int i = 0; i &lt; 10; ++i) {
<a name="10" id="anc10"></a><span class="line-modified"> 722             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 723         }
 724         MyValue2 v = test30(src, !warmup);
 725         Asserts.assertEQ(src[0].hash(), v.hash());
 726     }
 727 
 728     // non escaping allocation with memory phi
<a name="11" id="anc11"></a><span class="line-modified"> 729     // TODO 8227588</span>
<span class="line-removed"> 730     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>
<span class="line-removed"> 731     @Test(valid = InlineTypeArrayFlattenOff)</span>
 732     public long test31(boolean b, boolean deopt) {
 733         MyValue2[] src = new MyValue2[1];
 734         if (b) {
<a name="12" id="anc12"></a><span class="line-modified"> 735             src[0] = MyValue2.createWithFieldsInline(rI, true);</span>
 736         } else {
<a name="13" id="anc13"></a><span class="line-modified"> 737             src[0] = MyValue2.createWithFieldsInline(rI, false);</span>
 738         }
 739         if (deopt) {
 740             // uncommon trap
 741             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test31&quot;));
 742         }
 743         return src[0].hash();
 744     }
 745 
 746     @DontCompile
 747     public void test31_verifier(boolean warmup) {
<a name="14" id="anc14"></a><span class="line-modified"> 748         MyValue2 v1 = MyValue2.createWithFieldsInline(rI, true);</span>
 749         long result1 = test31(true, !warmup);
 750         Asserts.assertEQ(result1, v1.hash());
<a name="15" id="anc15"></a><span class="line-modified"> 751         MyValue2 v2 = MyValue2.createWithFieldsInline(rI, false);</span>
 752         long result2 = test31(false, !warmup);
 753         Asserts.assertEQ(result2, v2.hash());
 754     }
 755 
 756     // Tests with Object arrays and clone/arraycopy
 757     // clone() as stub call
 758     @Test
 759     public Object[] test32(Object[] va) {
 760         return va.clone();
 761     }
 762 
 763     @DontCompile
 764     public void test32_verifier(boolean warmup) {
 765         int len = Math.abs(rI) % 10;
 766         MyValue1[] va = new MyValue1[len];
 767         for (int i = 0; i &lt; len; ++i) {
 768             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 769         }
 770         MyValue1[] result = (MyValue1[])test32(va);
 771         for (int i = 0; i &lt; len; ++i) {
 772             Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());
 773         }
 774     }
 775 
 776     @Test
 777     public Object[] test33(Object[] va) {
 778         return va.clone();
 779     }
 780 
 781     @DontCompile
 782     public void test33_verifier(boolean warmup) {
 783         int len = Math.abs(rI) % 10;
 784         Object[] va = new Object[len];
 785         for (int i = 0; i &lt; len; ++i) {
 786             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 787         }
 788         Object[] result = test33(va);
 789         for (int i = 0; i &lt; len; ++i) {
 790             Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());
 791             // Check that array has correct properties (null-ok)
 792             result[i] = null;
 793         }
 794     }
 795 
 796     // clone() as series of loads/stores
 797     static Object[] test34_orig = null;
 798 
 799     @ForceInline
 800     public Object[] test34_helper(boolean flag) {
 801         Object[] va = null;
 802         if (flag) {
 803             va = new MyValue1[8];
 804             for (int i = 0; i &lt; va.length; ++i) {
 805                 va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 806             }
 807         } else {
 808             va = new Object[8];
 809         }
 810         return va;
 811     }
 812 
 813     @Test
 814     public Object[] test34(boolean flag) {
 815         Object[] va = test34_helper(flag);
 816         test34_orig = va;
 817         return va.clone();
 818     }
 819 
 820     @DontCompile
 821     public void test34_verifier(boolean warmup) {
 822         test34(false);
 823         for (int i = 0; i &lt; 10; i++) { // make sure we do deopt
 824             Object[] result = test34(true);
 825             verify(test34_orig, result);
 826             // Check that array has correct properties (null-free)
 827             try {
 828                 result[0] = null;
 829                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
 830             } catch (NullPointerException e) {
 831                 // Expected
 832             }
 833         }
 834         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test34&quot;)) {
 835             Object[] result = test34(true);
 836             verify(test34_orig, result);
 837             // Check that array has correct properties (null-free)
 838             try {
 839                 result[0] = null;
 840                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
 841             } catch (NullPointerException e) {
 842                 // Expected
 843             }
 844         }
 845     }
 846 
 847     static void verify(Object[] src, Object[] dst) {
 848         for (int i = 0; i &lt; src.length; ++i) {
 849             Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());
 850         }
 851     }
 852 
 853     static void verify(MyValue1[] src, MyValue1[] dst) {
 854         for (int i = 0; i &lt; src.length; ++i) {
 855             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 856         }
 857     }
 858 
 859     static void verify(MyValue1[] src, Object[] dst) {
 860         for (int i = 0; i &lt; src.length; ++i) {
 861             Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
 862         }
 863     }
 864 
 865     static void verify(MyValue2[] src, MyValue2[] dst) {
 866         for (int i = 0; i &lt; src.length; ++i) {
 867             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 868         }
 869     }
 870 
 871     static void verify(MyValue2[] src, Object[] dst) {
 872         for (int i = 0; i &lt; src.length; ++i) {
 873             Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
 874         }
 875     }
 876 
 877     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
 878         if (!warmup) {
 879             Method m = tests.get(test);
 880             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false)) {
 881                 if (!InlineTypeArrayFlatten &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
 882                     throw new RuntimeException(&quot;Unexpected deoptimization&quot;);
 883                 }
 884                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
 885                 return true;
 886             }
 887         }
 888         return false;
 889     }
 890 
 891     // arraycopy() of inline type array of unknown size
 892     @Test
 893     public void test35(Object src, Object dst, int len) {
 894         System.arraycopy(src, 0, dst, 0, len);
 895     }
 896 
 897     @DontCompile
 898     public void test35_verifier(boolean warmup) {
 899         int len = Math.abs(rI) % 10;
 900         MyValue1[] src = new MyValue1[len];
 901         MyValue1[] dst = new MyValue1[len];
 902         for (int i = 0; i &lt; len; ++i) {
 903             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 904         }
 905         test35(src, dst, src.length);
 906         verify(src, dst);
 907         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test35&quot;)) {
 908             test35(src, dst, src.length);
 909             verify(src, dst);
 910         }
 911     }
 912 
 913     @Test
 914     public void test36(Object src, MyValue2[] dst) {
 915         System.arraycopy(src, 0, dst, 0, dst.length);
 916     }
 917 
 918     @DontCompile
 919     public void test36_verifier(boolean warmup) {
 920         int len = Math.abs(rI) % 10;
 921         MyValue2[] src = new MyValue2[len];
 922         MyValue2[] dst = new MyValue2[len];
 923         for (int i = 0; i &lt; len; ++i) {
<a name="16" id="anc16"></a><span class="line-modified"> 924             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 925         }
 926         test36(src, dst);
 927         verify(src, dst);
 928         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test36&quot;)) {
 929             test36(src, dst);
 930             verify(src, dst);
 931         }
 932     }
 933 
 934     @Test
 935     public void test37(MyValue2[] src, Object dst) {
 936         System.arraycopy(src, 0, dst, 0, src.length);
 937     }
 938 
 939     @DontCompile
 940     public void test37_verifier(boolean warmup) {
 941         int len = Math.abs(rI) % 10;
 942         MyValue2[] src = new MyValue2[len];
 943         MyValue2[] dst = new MyValue2[len];
 944         for (int i = 0; i &lt; len; ++i) {
<a name="17" id="anc17"></a><span class="line-modified"> 945             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 946         }
 947         test37(src, dst);
 948         verify(src, dst);
 949         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test37&quot;)) {
 950             test37(src, dst);
 951             verify(src, dst);
 952         }
 953     }
 954 
 955     @Test
 956     @Warmup(1) // Avoid early compilation
 957     public void test38(Object src, MyValue2[] dst) {
 958         System.arraycopy(src, 0, dst, 0, dst.length);
 959     }
 960 
 961     @DontCompile
 962     public void test38_verifier(boolean warmup) {
 963         int len = Math.abs(rI) % 10;
 964         Object[] src = new Object[len];
 965         MyValue2[] dst = new MyValue2[len];
 966         for (int i = 0; i &lt; len; ++i) {
<a name="18" id="anc18"></a><span class="line-modified"> 967             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 968         }
 969         test38(src, dst);
 970         verify(dst, src);
 971         if (!warmup) {
 972             Method m = tests.get(&quot;TestArrays::test38&quot;);
 973             assertDeoptimizedByC2(m);
 974             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
 975             test38(src, dst);
 976             verify(dst, src);
 977             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
 978                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
 979             }
 980         }
 981     }
 982 
 983     @Test
 984     public void test39(MyValue2[] src, Object dst) {
 985         System.arraycopy(src, 0, dst, 0, src.length);
 986     }
 987 
 988     @DontCompile
 989     public void test39_verifier(boolean warmup) {
 990         int len = Math.abs(rI) % 10;
 991         MyValue2[] src = new MyValue2[len];
 992         Object[] dst = new Object[len];
 993         for (int i = 0; i &lt; len; ++i) {
<a name="19" id="anc19"></a><span class="line-modified"> 994             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 995         }
 996         test39(src, dst);
 997         verify(src, dst);
 998         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test39&quot;)) {
 999             test39(src, dst);
1000             verify(src, dst);
1001         }
1002     }
1003 
1004     @Test
1005     @Warmup(1) // Avoid early compilation
1006     public void test40(Object[] src, Object dst) {
1007         System.arraycopy(src, 0, dst, 0, src.length);
1008     }
1009 
1010     @DontCompile
1011     public void test40_verifier(boolean warmup) {
1012         int len = Math.abs(rI) % 10;
1013         Object[] src = new Object[len];
1014         MyValue2[] dst = new MyValue2[len];
1015         for (int i = 0; i &lt; len; ++i) {
<a name="20" id="anc20"></a><span class="line-modified">1016             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1017         }
1018         test40(src, dst);
1019         verify(dst, src);
1020         if (!warmup) {
1021             Method m = tests.get(&quot;TestArrays::test40&quot;);
1022             assertDeoptimizedByC2(m);
1023             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1024             test40(src, dst);
1025             verify(dst, src);
1026             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1027                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1028             }
1029         }
1030     }
1031 
1032     @Test
1033     public void test41(Object src, Object[] dst) {
1034         System.arraycopy(src, 0, dst, 0, dst.length);
1035     }
1036 
1037     @DontCompile
1038     public void test41_verifier(boolean warmup) {
1039         int len = Math.abs(rI) % 10;
1040         MyValue2[] src = new MyValue2[len];
1041         Object[] dst = new Object[len];
1042         for (int i = 0; i &lt; len; ++i) {
<a name="21" id="anc21"></a><span class="line-modified">1043             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1044         }
1045         test41(src, dst);
1046         verify(src, dst);
1047         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test41&quot;)) {
1048             test41(src, dst);
1049             verify(src, dst);
1050         }
1051     }
1052 
1053     @Test
1054     public void test42(Object[] src, Object[] dst) {
1055         System.arraycopy(src, 0, dst, 0, src.length);
1056     }
1057 
1058     @DontCompile
1059     public void test42_verifier(boolean warmup) {
1060         int len = Math.abs(rI) % 10;
1061         Object[] src = new Object[len];
1062         Object[] dst = new Object[len];
1063         for (int i = 0; i &lt; len; ++i) {
<a name="22" id="anc22"></a><span class="line-modified">1064             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1065         }
1066         test42(src, dst);
1067         verify(src, dst);
1068         if (!warmup) {
1069             Method m = tests.get(&quot;TestArrays::test42&quot;);
1070             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1071                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1072             }
1073         }
1074     }
1075 
1076     // short arraycopy()&#39;s
1077     @Test
1078     public void test43(Object src, Object dst) {
1079         System.arraycopy(src, 0, dst, 0, 8);
1080     }
1081 
1082     @DontCompile
1083     public void test43_verifier(boolean warmup) {
1084         MyValue1[] src = new MyValue1[8];
1085         MyValue1[] dst = new MyValue1[8];
1086         for (int i = 0; i &lt; 8; ++i) {
1087             src[i] = MyValue1.createWithFieldsInline(rI, rL);
1088         }
1089         test43(src, dst);
1090         verify(src, dst);
1091         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test43&quot;)) {
1092             test43(src, dst);
1093             verify(src, dst);
1094         }
1095     }
1096 
1097     @Test
1098     public void test44(Object src, MyValue2[] dst) {
1099         System.arraycopy(src, 0, dst, 0, 8);
1100     }
1101 
1102     @DontCompile
1103     public void test44_verifier(boolean warmup) {
1104         MyValue2[] src = new MyValue2[8];
1105         MyValue2[] dst = new MyValue2[8];
1106         for (int i = 0; i &lt; 8; ++i) {
<a name="23" id="anc23"></a><span class="line-modified">1107             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1108         }
1109         test44(src, dst);
1110         verify(src, dst);
1111         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test44&quot;)) {
1112             test44(src, dst);
1113             verify(src, dst);
1114         }
1115     }
1116 
1117     @Test
1118     public void test45(MyValue2[] src, Object dst) {
1119         System.arraycopy(src, 0, dst, 0, 8);
1120     }
1121 
1122     @DontCompile
1123     public void test45_verifier(boolean warmup) {
1124         MyValue2[] src = new MyValue2[8];
1125         MyValue2[] dst = new MyValue2[8];
1126         for (int i = 0; i &lt; 8; ++i) {
<a name="24" id="anc24"></a><span class="line-modified">1127             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1128         }
1129         test45(src, dst);
1130         verify(src, dst);
1131         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test45&quot;)) {
1132             test45(src, dst);
1133             verify(src, dst);
1134         }
1135     }
1136 
1137     @Test
1138     @Warmup(1) // Avoid early compilation
1139     public void test46(Object[] src, MyValue2[] dst) {
1140         System.arraycopy(src, 0, dst, 0, 8);
1141     }
1142 
1143     @DontCompile
1144     public void test46_verifier(boolean warmup) {
1145         Object[] src = new Object[8];
1146         MyValue2[] dst = new MyValue2[8];
1147         for (int i = 0; i &lt; 8; ++i) {
<a name="25" id="anc25"></a><span class="line-modified">1148             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1149         }
1150         test46(src, dst);
1151         verify(dst, src);
1152         if (!warmup) {
1153             Method m = tests.get(&quot;TestArrays::test46&quot;);
1154             assertDeoptimizedByC2(m);
1155             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1156             test46(src, dst);
1157             verify(dst, src);
1158             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1159                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1160             }
1161         }
1162     }
1163 
1164     @Test
1165     public void test47(MyValue2[] src, Object[] dst) {
1166         System.arraycopy(src, 0, dst, 0, 8);
1167     }
1168 
1169     @DontCompile
1170     public void test47_verifier(boolean warmup) {
1171         MyValue2[] src = new MyValue2[8];
1172         Object[] dst = new Object[8];
1173         for (int i = 0; i &lt; 8; ++i) {
<a name="26" id="anc26"></a><span class="line-modified">1174             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1175         }
1176         test47(src, dst);
1177         verify(src, dst);
1178         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test47&quot;)) {
1179             test47(src, dst);
1180             verify(src, dst);
1181         }
1182     }
1183 
1184     @Test
1185     @Warmup(1) // Avoid early compilation
1186     public void test48(Object[] src, Object dst) {
1187         System.arraycopy(src, 0, dst, 0, 8);
1188     }
1189 
1190     @DontCompile
1191     public void test48_verifier(boolean warmup) {
1192         Object[] src = new Object[8];
1193         MyValue2[] dst = new MyValue2[8];
1194         for (int i = 0; i &lt; 8; ++i) {
<a name="27" id="anc27"></a><span class="line-modified">1195             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1196         }
1197         test48(src, dst);
1198         verify(dst, src);
1199         if (!warmup) {
1200             Method m = tests.get(&quot;TestArrays::test48&quot;);
1201             assertDeoptimizedByC2(m);
1202             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1203             test48(src, dst);
1204             verify(dst, src);
1205             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1206                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1207             }
1208         }
1209     }
1210 
1211     @Test
1212     public void test49(Object src, Object[] dst) {
1213         System.arraycopy(src, 0, dst, 0, 8);
1214     }
1215 
1216     @DontCompile
1217     public void test49_verifier(boolean warmup) {
1218         MyValue2[] src = new MyValue2[8];
1219         Object[] dst = new Object[8];
1220         for (int i = 0; i &lt; 8; ++i) {
<a name="28" id="anc28"></a><span class="line-modified">1221             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1222         }
1223         test49(src, dst);
1224         verify(src, dst);
1225         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test49&quot;)) {
1226             test49(src, dst);
1227             verify(src, dst);
1228         }
1229     }
1230 
1231     @Test
1232     public void test50(Object[] src, Object[] dst) {
1233         System.arraycopy(src, 0, dst, 0, 8);
1234     }
1235 
1236     @DontCompile
1237     public void test50_verifier(boolean warmup) {
1238         Object[] src = new Object[8];
1239         Object[] dst = new Object[8];
1240         for (int i = 0; i &lt; 8; ++i) {
<a name="29" id="anc29"></a><span class="line-modified">1241             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1242         }
1243         test50(src, dst);
1244         verify(src, dst);
1245         if (!warmup) {
1246             Method m = tests.get(&quot;TestArrays::test50&quot;);
1247             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1248                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1249             }
1250         }
1251     }
1252 
1253     @Test
1254     public MyValue1[] test51(MyValue1[] va) {
<a name="30" id="anc30"></a><span class="line-modified">1255         // TODO Remove cast as workaround once javac is fixed</span>
1256         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1257     }
1258 
1259     @DontCompile
1260     public void test51_verifier(boolean warmup) {
1261         int len = Math.abs(rI) % 10;
1262         MyValue1[] va = new MyValue1[len];
1263         for (int i = 0; i &lt; len; ++i) {
1264             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1265         }
1266         MyValue1[] result = test51(va);
1267         verify(va, result);
1268     }
1269 
1270     static final MyValue1[] test52_va = new MyValue1[8];
1271 
1272     @Test
1273     public MyValue1[] test52() {
<a name="31" id="anc31"></a><span class="line-modified">1274         // TODO Remove cast as workaround once javac is fixed</span>
1275         return (MyValue1[])Arrays.copyOf(test52_va, 8, MyValue1[].class);
1276     }
1277 
1278     @DontCompile
1279     public void test52_verifier(boolean warmup) {
1280         for (int i = 0; i &lt; 8; ++i) {
1281             test52_va[i] = MyValue1.createWithFieldsInline(rI, rL);
1282         }
1283         MyValue1[] result = test52();
1284         verify(test52_va, result);
1285     }
1286 
1287     @Test
1288     public MyValue1[] test53(Object[] va) {
<a name="32" id="anc32"></a><span class="line-modified">1289         // TODO Remove cast as workaround once javac is fixed</span>
1290         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1291     }
1292 
1293     @DontCompile
1294     public void test53_verifier(boolean warmup) {
1295         int len = Math.abs(rI) % 10;
1296         MyValue1[] va = new MyValue1[len];
1297         for (int i = 0; i &lt; len; ++i) {
1298             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1299         }
1300         MyValue1[] result = test53(va);
1301         verify(result, va);
1302     }
1303 
1304     @Test
1305     public Object[] test54(MyValue1[] va) {
1306         return Arrays.copyOf(va, va.length, Object[].class);
1307     }
1308 
1309     @DontCompile
1310     public void test54_verifier(boolean warmup) {
1311         int len = Math.abs(rI) % 10;
1312         MyValue1[] va = new MyValue1[len];
1313         for (int i = 0; i &lt; len; ++i) {
1314             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1315         }
1316         Object[] result = test54(va);
1317         verify(va, result);
1318     }
1319 
1320     @Test
1321     public Object[] test55(Object[] va) {
1322         return Arrays.copyOf(va, va.length, Object[].class);
1323     }
1324 
1325     @DontCompile
1326     public void test55_verifier(boolean warmup) {
1327         int len = Math.abs(rI) % 10;
1328         MyValue1[] va = new MyValue1[len];
1329         for (int i = 0; i &lt; len; ++i) {
1330             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1331         }
1332         Object[] result = test55(va);
1333         verify(va, result);
1334     }
1335 
1336     @Test
1337     public MyValue1[] test56(Object[] va) {
<a name="33" id="anc33"></a><span class="line-modified">1338         // TODO Remove cast as workaround once javac is fixed</span>
1339         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1340     }
1341 
1342     @DontCompile
1343     public void test56_verifier(boolean warmup) {
1344         int len = Math.abs(rI) % 10;
1345         Object[] va = new Object[len];
1346         for (int i = 0; i &lt; len; ++i) {
1347             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1348         }
1349         MyValue1[] result = test56(va);
1350         verify(result, va);
1351     }
1352 
1353    @Test
1354     public Object[] test57(Object[] va, Class klass) {
1355         return Arrays.copyOf(va, va.length, klass);
1356     }
1357 
1358     @DontCompile
1359     public void test57_verifier(boolean warmup) {
1360         int len = Math.abs(rI) % 10;
1361         Object[] va = new MyValue1[len];
1362         for (int i = 0; i &lt; len; ++i) {
1363             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1364         }
1365         Object[] result = test57(va, MyValue1[].class);
1366         verify(va, result);
1367     }
1368 
1369     @Test
1370     public Object[] test58(MyValue1[] va, Class klass) {
1371         return Arrays.copyOf(va, va.length, klass);
1372     }
1373 
1374     @DontCompile
1375     public void test58_verifier(boolean warmup) {
1376         int len = Math.abs(rI) % 10;
1377         MyValue1[] va = new MyValue1[len];
1378         for (int i = 0; i &lt; len; ++i) {
1379             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1380         }
1381         for (int i = 0; i &lt; 10; i++) {
1382             Object[] result = test58(va, MyValue1[].class);
1383             verify(va, result);
1384         }
1385         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test58&quot;)) {
1386             Object[] result = test58(va, MyValue1[].class);
1387             verify(va, result);
1388         }
1389     }
1390 
1391     @Test
1392     public Object[] test59(MyValue1[] va) {
1393         return Arrays.copyOf(va, va.length+1, MyValue1[].class);
1394     }
1395 
1396     @DontCompile
1397     public void test59_verifier(boolean warmup) {
1398         int len = Math.abs(rI) % 10;
1399         MyValue1[] va = new MyValue1[len];
1400         MyValue1[] verif = new MyValue1[len+1];
1401         for (int i = 0; i &lt; len; ++i) {
1402             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1403             verif[i] = va[i];
1404         }
1405         Object[] result = test59(va);
1406         verify(verif, result);
1407     }
1408 
1409     @Test
1410     public Object[] test60(Object[] va, Class klass) {
1411         return Arrays.copyOf(va, va.length+1, klass);
1412     }
1413 
1414     @DontCompile
1415     public void test60_verifier(boolean warmup) {
1416         int len = Math.abs(rI) % 10;
1417         MyValue1[] va = new MyValue1[len];
1418         MyValue1[] verif = new MyValue1[len+1];
1419         for (int i = 0; i &lt; len; ++i) {
1420             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1421             verif[i] = (MyValue1)va[i];
1422         }
1423         Object[] result = test60(va, MyValue1[].class);
1424         verify(verif, result);
1425     }
1426 
1427     @Test
1428     public Object[] test61(Object[] va, Class klass) {
1429         return Arrays.copyOf(va, va.length+1, klass);
1430     }
1431 
1432     @DontCompile
1433     public void test61_verifier(boolean warmup) {
1434         int len = Math.abs(rI) % 10;
1435         Object[] va = new Integer[len];
1436         for (int i = 0; i &lt; len; ++i) {
1437             va[i] = new Integer(rI);
1438         }
1439         Object[] result = test61(va, Integer[].class);
1440         for (int i = 0; i &lt; va.length; ++i) {
1441             Asserts.assertEQ(va[i], result[i]);
1442         }
1443     }
1444 
1445     @ForceInline
1446     public Object[] test62_helper(int i, MyValue1[] va, Integer[] oa) {
1447         Object[] arr = null;
1448         if (i == 10) {
1449             arr = oa;
1450         } else {
1451             arr = va;
1452         }
1453         return arr;
1454     }
1455 
1456     @Test
1457     public Object[] test62(MyValue1[] va, Integer[] oa) {
1458         int i = 0;
1459         for (; i &lt; 10; i++);
1460 
1461         Object[] arr = test62_helper(i, va, oa);
1462 
1463         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1464     }
1465 
1466     @DontCompile
1467     public void test62_verifier(boolean warmup) {
1468         int len = Math.abs(rI) % 10;
1469         MyValue1[] va = new MyValue1[len];
1470         Integer[] oa = new Integer[len];
1471         for (int i = 0; i &lt; len; ++i) {
1472             oa[i] = new Integer(rI);
1473         }
1474         test62_helper(42, va, oa);
1475         Object[] result = test62(va, oa);
1476         for (int i = 0; i &lt; va.length; ++i) {
1477             Asserts.assertEQ(oa[i], result[i]);
1478         }
1479     }
1480 
1481     @ForceInline
1482     public Object[] test63_helper(int i, MyValue1[] va, Integer[] oa) {
1483         Object[] arr = null;
1484         if (i == 10) {
1485             arr = va;
1486         } else {
1487             arr = oa;
1488         }
1489         return arr;
1490     }
1491 
1492     @Test
1493     public Object[] test63(MyValue1[] va, Integer[] oa) {
1494         int i = 0;
1495         for (; i &lt; 10; i++);
1496 
1497         Object[] arr = test63_helper(i, va, oa);
1498 
1499         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1500     }
1501 
1502     @DontCompile
1503     public void test63_verifier(boolean warmup) {
1504         int len = Math.abs(rI) % 10;
1505         MyValue1[] va = new MyValue1[len];
1506         MyValue1[] verif = new MyValue1[len+1];
1507         for (int i = 0; i &lt; len; ++i) {
1508             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1509             verif[i] = va[i];
1510         }
1511         Integer[] oa = new Integer[len];
1512         test63_helper(42, va, oa);
1513         Object[] result = test63(va, oa);
1514         verify(verif, result);
1515     }
1516 
1517     // Test default initialization of inline type arrays: small array
1518     @Test
1519     public MyValue1[] test64() {
1520         return new MyValue1[8];
1521     }
1522 
1523     @DontCompile
1524     public void test64_verifier(boolean warmup) {
1525         MyValue1[] va = new MyValue1[8];
1526         MyValue1[] var = test64();
1527         for (int i = 0; i &lt; 8; ++i) {
1528             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1529         }
1530     }
1531 
1532     // Test default initialization of inline type arrays: large array
1533     @Test
1534     public MyValue1[] test65() {
1535         return new MyValue1[32];
1536     }
1537 
1538     @DontCompile
1539     public void test65_verifier(boolean warmup) {
1540         MyValue1[] va = new MyValue1[32];
1541         MyValue1[] var = test65();
1542         for (int i = 0; i &lt; 32; ++i) {
1543             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1544         }
1545     }
1546 
1547     // Check init store elimination
1548     @Test(match = { ALLOCA }, matchCount = { 1 })
1549     public MyValue1[] test66(MyValue1 vt) {
1550         MyValue1[] va = new MyValue1[1];
1551         va[0] = vt;
1552         return va;
1553     }
1554 
1555     @DontCompile
1556     public void test66_verifier(boolean warmup) {
1557         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI, rL);
1558         MyValue1[] va = test66(vt);
1559         Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());
1560     }
1561 
1562     // Zeroing elimination and arraycopy
1563     @Test
1564     public MyValue1[] test67(MyValue1[] src) {
1565         MyValue1[] dst = new MyValue1[16];
1566         System.arraycopy(src, 0, dst, 0, 13);
1567         return dst;
1568     }
1569 
1570     @DontCompile
1571     public void test67_verifier(boolean warmup) {
1572         MyValue1[] va = new MyValue1[16];
1573         MyValue1[] var = test67(va);
1574         for (int i = 0; i &lt; 16; ++i) {
1575             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1576         }
1577     }
1578 
1579     // A store with a default value can be eliminated
1580     @Test
1581     public MyValue1[] test68() {
1582         MyValue1[] va = new MyValue1[2];
1583         va[0] = va[1];
1584         return va;
1585     }
1586 
1587     @DontCompile
1588     public void test68_verifier(boolean warmup) {
1589         MyValue1[] va = new MyValue1[2];
1590         MyValue1[] var = test68();
1591         for (int i = 0; i &lt; 2; ++i) {
1592             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1593         }
1594     }
1595 
1596     // Requires individual stores to init array
1597     @Test
1598     public MyValue1[] test69(MyValue1 vt) {
1599         MyValue1[] va = new MyValue1[4];
1600         va[0] = vt;
1601         va[3] = vt;
1602         return va;
1603     }
1604 
1605     @DontCompile
1606     public void test69_verifier(boolean warmup) {
1607         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI, rL);
1608         MyValue1[] va = new MyValue1[4];
1609         va[0] = vt;
1610         va[3] = vt;
1611         MyValue1[] var = test69(vt);
1612         for (int i = 0; i &lt; va.length; ++i) {
1613             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1614         }
1615     }
1616 
1617     // A store with a default value can be eliminated: same as test68
1618     // but store is farther away from allocation
1619     @Test
1620     public MyValue1[] test70(MyValue1[] other) {
1621         other[1] = other[0];
1622         MyValue1[] va = new MyValue1[2];
1623         other[0] = va[1];
1624         va[0] = va[1];
1625         return va;
1626     }
1627 
1628     @DontCompile
1629     public void test70_verifier(boolean warmup) {
1630         MyValue1[] va = new MyValue1[2];
1631         MyValue1[] var = test70(va);
1632         for (int i = 0; i &lt; 2; ++i) {
1633             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1634         }
1635     }
1636 
1637     // EA needs to consider oop fields in flattened arrays
1638     @Test
1639     public void test71() {
1640         int len = 10;
1641         MyValue2[] src = new MyValue2[len];
1642         MyValue2[] dst = new MyValue2[len];
1643         for (int i = 0; i &lt; len; ++i) {
<a name="34" id="anc34"></a><span class="line-modified">1644             src[i] = MyValue2.createWithFieldsDontInline(rI, (i % 2) == 0);</span>
1645         }
1646         System.arraycopy(src, 0, dst, 0, src.length);
1647         for (int i = 0; i &lt; len; ++i) {
1648             Asserts.assertEQ(src[i].hash(), dst[i].hash());
1649         }
1650     }
1651 
1652     @DontCompile
1653     public void test71_verifier(boolean warmup) {
1654         test71();
1655     }
1656 
1657     // Test EA with leaf call to &#39;store_unknown_inline&#39;
1658     @Test
1659     public void test72(Object[] o, boolean b, Object element) {
1660         Object[] arr1 = new Object[10];
1661         Object[] arr2 = new Object[10];
1662         if (b) {
1663             arr1 = o;
1664         }
1665         arr1[0] = element;
1666         arr2[0] = element;
1667     }
1668 
1669     @DontCompile
1670     public void test72_verifier(boolean warmup) {
1671         Object[] arr = new Object[1];
1672         Object elem = new Object();
1673         test72(arr, true, elem);
1674         test72(arr, false, elem);
1675     }
1676 
1677     @Test
1678     public void test73(Object[] oa, MyValue1 v, Object o) {
1679         // TestLWorld.test38 use a C1 Phi node for the array. This test
1680         // adds the case where the stored value is a C1 Phi node.
1681         Object o2 = (o == null) ? v : o;
1682         oa[0] = v;  // The stored value is known to be flattenable
1683         oa[1] = o;  // The stored value may be flattenable
1684         oa[2] = o2; // The stored value may be flattenable (a C1 Phi node)
1685         oa[0] = oa; // The stored value is known to be not flattenable (an Object[])
1686     }
1687 
1688     @DontCompile
1689     public void test73_verifier(boolean warmup) {
1690         MyValue1 v0 = MyValue1.createWithFieldsDontInline(rI, rL);
1691         MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);
1692         MyValue1[] arr = new MyValue1[3];
1693         try {
1694             test73(arr, v0, v1);
1695             throw new RuntimeException(&quot;ArrayStoreException expected&quot;);
1696         } catch (ArrayStoreException t) {
1697             // expected
1698         }
1699         Asserts.assertEQ(arr[0].hash(), v0.hash());
1700         Asserts.assertEQ(arr[1].hash(), v1.hash());
1701         Asserts.assertEQ(arr[2].hash(), v1.hash());
1702     }
1703 
1704     public static void test74Callee(MyValue1[] va) { }
1705 
1706     // Tests invoking unloaded method with inline type array in signature
1707     @Test
1708     @Warmup(0)
1709     public void test74(MethodHandle m, MyValue1[] va) throws Throwable {
1710         m.invoke(va);
1711     }
1712 
1713     @DontCompile
1714     public void test74_verifier(boolean warmup) throws Throwable {
1715         MethodHandle m = MethodHandles.lookup().findStatic(TestArrays.class, &quot;test74Callee&quot;, MethodType.methodType(void.class, MyValue1[].class));
1716         MyValue1[] va = new MyValue1[0];
1717         test74(m, va);
1718     }
1719 
1720     // Some more array clone tests
1721     @ForceInline
1722     public Object[] test75_helper(int i, MyValue1[] va, Integer[] oa) {
1723         Object[] arr = null;
1724         if (i == 10) {
1725             arr = oa;
1726         } else {
1727             arr = va;
1728         }
1729         return arr;
1730     }
1731 
1732     @Test
1733     public Object[] test75(MyValue1[] va, Integer[] oa) {
1734         int i = 0;
1735         for (; i &lt; 10; i++);
1736 
1737         Object[] arr = test75_helper(i, va, oa);
1738         return arr.clone();
1739     }
1740 
1741     @DontCompile
1742     public void test75_verifier(boolean warmup) {
1743         int len = Math.abs(rI) % 10;
1744         MyValue1[] va = new MyValue1[len];
1745         Integer[] oa = new Integer[len];
1746         for (int i = 0; i &lt; len; ++i) {
1747             oa[i] = new Integer(rI);
1748         }
1749         test75_helper(42, va, oa);
1750         Object[] result = test75(va, oa);
1751 
1752         for (int i = 0; i &lt; va.length; ++i) {
1753             Asserts.assertEQ(oa[i], result[i]);
1754             // Check that array has correct properties (null-ok)
1755             result[i] = null;
1756         }
1757     }
1758 
1759     @ForceInline
1760     public Object[] test76_helper(int i, MyValue1[] va, Integer[] oa) {
1761         Object[] arr = null;
1762         if (i == 10) {
1763             arr = va;
1764         } else {
1765             arr = oa;
1766         }
1767         return arr;
1768     }
1769 
1770     @Test
1771     public Object[] test76(MyValue1[] va, Integer[] oa) {
1772         int i = 0;
1773         for (; i &lt; 10; i++);
1774 
1775         Object[] arr = test76_helper(i, va, oa);
1776         return arr.clone();
1777     }
1778 
1779     @DontCompile
1780     public void test76_verifier(boolean warmup) {
1781         int len = Math.abs(rI) % 10;
1782         MyValue1[] va = new MyValue1[len];
1783         MyValue1[] verif = new MyValue1[len];
1784         for (int i = 0; i &lt; len; ++i) {
1785             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1786             verif[i] = va[i];
1787         }
1788         Integer[] oa = new Integer[len];
1789         test76_helper(42, va, oa);
1790         Object[] result = test76(va, oa);
1791         verify(verif, result);
1792         // Check that array has correct properties (null-free)
1793         if (len &gt; 0) {
1794             try {
1795                 result[0] = null;
1796                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
1797             } catch (NullPointerException e) {
1798                 // Expected
1799             }
1800         }
1801     }
1802 
1803     @Test
1804     public void test77() {
1805         MyValue1 v0 = MyValue1.createWithFieldsDontInline(rI, rL);
1806         MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);
1807         MyValue1[] arr = new MyValue1[1];
1808 
1809         Object[] oa = arr;
1810         Object o1 = v1;
1811         Object o = (o1 == null) ? v0 : o1;
1812 
1813         oa[0] = o; // For C1, due to IfOp optimization, the declared_type of o becomes NULL.
1814 
1815         Asserts.assertEQ(arr[0].hash(), v1.hash());
1816     }
1817 
1818 
1819     @DontCompile
1820     public void test77_verifier(boolean warmup) {
1821         test77();
1822     }
1823 
1824     @Test
1825     public long test78(MyValue1 v, int n) {
1826         long x = 0;
1827         for (int i = 0; i&lt;n; i++) {
1828         }
1829 
1830         MyValue1[] a = new MyValue1[n];
1831         a[0] = v;
1832         for (int i = 0; i&lt;n; i++) {
1833             x += a[i].hash(); // C1 PhiSimplifier changes &quot;a&quot; from a Phi node to a NewObjectArray node
1834         }
1835 
1836         return x;
1837     }
1838 
1839     @DontCompile
1840     public void test78_verifier(boolean warmup) {
1841         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
1842         Asserts.assertEQ(test78(v, 1), v.hash());
1843     }
1844 
1845     // Verify that casting an array element to a non-flattenable type marks the array as not-flat
1846     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_INLINE }, matchCount = { 1, 1 })
1847     @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE)
1848     public Object test79(Object[] array, int i) {
1849         Integer i1 = (Integer)array[0];
1850         Object o = array[1];
1851         return array[i];
1852     }
1853 
1854     @DontCompile
1855     public void test79_verifier(boolean warmup) {
1856         Integer i = new Integer(rI);
1857         Integer[] array = new Integer[2];
1858         array[1] = i;
1859         Object result = test79(array, 1);
1860         Asserts.assertEquals(result, i);
1861     }
1862 
1863     inline static class NotFlattenable {
1864         private final Object o1 = null;
1865         private final Object o2 = null;
1866         private final Object o3 = null;
1867         private final Object o4 = null;
1868         private final Object o5 = null;
1869         private final Object o6 = null;
1870     }
1871 
1872     // Same as test79 but with not-flattenable inline type
1873     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_INLINE }, matchCount = { 1, 1 })
1874     @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE)
1875     public Object test80(Object[] array, int i) {
1876         NotFlattenable vt = (NotFlattenable)array[0];
1877         Object o = array[1];
1878         return array[i];
1879     }
1880 
1881     @DontCompile
1882     public void test80_verifier(boolean warmup) {
1883         NotFlattenable vt = new NotFlattenable();
1884         NotFlattenable[] array = new NotFlattenable[2];
1885         array[1] = vt;
1886         Object result = test80(array, 1);
1887         Asserts.assertEquals(result, vt);
1888     }
1889 
1890     // Verify that writing an object of a non-inline, non-null type to an array marks the array as not-null-free and not-flat
1891     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
1892     public Object test81(Object[] array, Integer v, Object o, int i) {
1893         if (v == null) {
1894           return null;
1895         }
1896         array[0] = v;
1897         array[1] = array[0];
1898         array[2] = o;
1899         return array[i];
1900     }
1901 
1902     @DontCompile
1903     public void test81_verifier(boolean warmup) {
1904         Integer i = new Integer(rI);
1905         Integer[] array1 = new Integer[3];
1906         Object[] array2 = new Object[3];
1907         Object result = test81(array1, i, i, 0);
1908         Asserts.assertEquals(array1[0], i);
1909         Asserts.assertEquals(array1[1], i);
1910         Asserts.assertEquals(array1[2], i);
1911         Asserts.assertEquals(result, i);
1912         result = test81(array2, i, i, 1);
1913         Asserts.assertEquals(array2[0], i);
1914         Asserts.assertEquals(array2[1], i);
1915         Asserts.assertEquals(array2[2], i);
1916         Asserts.assertEquals(result, i);
1917     }
1918 
1919     // Verify that writing an object of a non-flattenable inline type to an array marks the array as not-flat
1920     @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE)
1921     @Test(valid = InlineTypePassFieldsAsArgsOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE)
1922     public Object test82(Object[] array, NotFlattenable vt, Object o, int i) {
1923         array[0] = vt;
1924         array[1] = array[0];
1925         array[2] = o;
1926         return array[i];
1927     }
1928 
1929     @DontCompile
1930     public void test82_verifier(boolean warmup) {
1931         NotFlattenable vt = new NotFlattenable();
1932         NotFlattenable[] array1 = new NotFlattenable[3];
1933         Object[] array2 = new Object[3];
1934         Object result = test82(array1, vt, vt, 0);
1935         Asserts.assertEquals(array1[0], vt);
1936         Asserts.assertEquals(array1[1], vt);
1937         Asserts.assertEquals(array1[2], vt);
1938         Asserts.assertEquals(result, vt);
1939         result = test82(array2, vt, vt, 1);
1940         Asserts.assertEquals(array2[0], vt);
1941         Asserts.assertEquals(array2[1], vt);
1942         Asserts.assertEquals(array2[2], vt);
1943         Asserts.assertEquals(result, vt);
1944     }
1945 
1946     // Verify that casting an array element to a non-inline type type marks the array as not-null-free and not-flat
1947     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_INLINE }, matchCount = { 1, 1 }, failOn = ALLOCA_G + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
1948     @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
1949     public void test83(Object[] array, Object o) {
1950         Integer i = (Integer)array[0];
1951         array[1] = o;
1952     }
1953 
1954     @DontCompile
1955     public void test83_verifier(boolean warmup) {
1956         Integer i = new Integer(rI);
1957         Integer[] array1 = new Integer[2];
1958         Object[] array2 = new Object[2];
1959         test83(array1, i);
1960         Asserts.assertEquals(array1[1], i);
1961         test83(array2, null);
1962         Asserts.assertEquals(array2[1], null);
1963     }
1964 
1965     // Verify that writing constant null into an array marks the array as not-null-free and not-flat
1966     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE, match = { INLINE_ARRAY_NULL_GUARD }, matchCount = { 1 })
1967     public Object test84(Object[] array, int i) {
1968         array[0] = null;
1969         array[1] = null;
1970         return array[i];
1971     }
1972 
1973     @DontCompile
1974     public void test84_verifier(boolean warmup) {
1975         NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];
1976         Object[] array2 = new Object[2];
1977         Object result = test84(array1, 0);
1978         Asserts.assertEquals(array1[0], null);
1979         Asserts.assertEquals(result, null);
1980         result = test84(array2, 1);
1981         Asserts.assertEquals(array2[0], null);
1982         Asserts.assertEquals(result, null);
1983         if (!warmup) {
1984             NotFlattenable[] array3 = new NotFlattenable[2];
1985             try {
1986                 test84(array3, 1);
1987                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
1988             } catch (NullPointerException e) {
1989                 // Expected
1990             }
1991         }
1992     }
1993 
1994     // Same as test84 but with branches
1995     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE, match = { INLINE_ARRAY_NULL_GUARD }, matchCount = { 2 })
1996     public void test85(Object[] array, Object o, boolean b) {
1997         if (b) {
1998             array[0] = null;
1999         } else {
2000             array[1] = null;
2001         }
2002         array[1] = o;
2003     }
2004 
2005     @DontCompile
2006     public void test85_verifier(boolean warmup) {
2007         Integer i = new Integer(rI);
2008         Integer[] array1 = new Integer[2];
2009         Object[] array2 = new Object[2];
2010         test85(array1, i, true);
2011         Asserts.assertEquals(array1[1], i);
2012         test85(array1, null, false);
2013         Asserts.assertEquals(array1[1], null);
2014         test85(array2, i, true);
2015         Asserts.assertEquals(array2[1], i);
2016         test85(array2, null, false);
2017         Asserts.assertEquals(array2[1], null);
2018         if (!warmup) {
2019             NotFlattenable[] array3 = new NotFlattenable[2];
2020             try {
2021                 test85(array3, null, true);
2022                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2023             } catch (NullPointerException e) {
2024                 // Expected
2025             }
2026         }
2027     }
2028 
2029     // Same as test85 but with not-flattenable inline type array
2030     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE, match = { INLINE_ARRAY_NULL_GUARD }, matchCount = { 2 })
2031     public void test86(NotFlattenable.ref[] array, NotFlattenable.ref o, boolean b) {
2032         if (b) {
2033             array[0] = null;
2034         } else {
2035             array[1] = null;
2036         }
2037         array[1] = o;
2038     }
2039 
2040     @DontCompile
2041     public void test86_verifier(boolean warmup) {
2042         NotFlattenable vt = new NotFlattenable();
2043         NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];
2044         test86(array1, vt, true);
2045         Asserts.assertEquals(array1[1], vt);
2046         test86(array1, null, false);
2047         Asserts.assertEquals(array1[1], null);
2048         if (!warmup) {
2049             NotFlattenable[] array2 = new NotFlattenable[2];
2050             try {
2051                 test86(array2, null, true);
2052                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2053             } catch (NullPointerException e) {
2054                 // Expected
2055             }
2056         }
2057     }
2058 
2059     // Same as test85 but with inline type array
2060     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE, match = { INLINE_ARRAY_NULL_GUARD }, matchCount = { 2 })
2061     public void test87(MyValue1.ref[] array, MyValue1.ref o, boolean b) {
2062         if (b) {
2063             array[0] = null;
2064         } else {
2065             array[1] = null;
2066         }
2067         array[1] = o;
2068     }
2069 
2070     @DontCompile
2071     public void test87_verifier(boolean warmup) {
2072         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
2073         MyValue1.ref[] array1 = new MyValue1.ref[2];
2074         test87(array1, vt, true);
2075         Asserts.assertEquals(array1[1], vt);
2076         test87(array1, null, false);
2077         Asserts.assertEquals(array1[1], null);
2078         if (!warmup) {
2079             MyValue1[] array2 = new MyValue1[2];
2080             try {
2081                 test87(array2, null, true);
2082                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2083             } catch (NullPointerException e) {
2084                 // Expected
2085             }
2086         }
2087     }
2088 
2089     // Additional correctness tests to make sure we have the required null checks
2090     @Test()
2091     public void test88(Object[] array, Integer v) {
2092         array[0] = v;
2093     }
2094 
2095     @DontCompile
2096     public void test88_verifier(boolean warmup) {
2097         Integer[] array1 = new Integer[1];
2098         Object[] array2 = new Object[1];
2099         test88(array1, null);
2100         Asserts.assertEquals(array1[0], null);
2101         test88(array2, null);
2102         Asserts.assertEquals(array2[0], null);
2103         if (!warmup) {
2104             MyValue1[] array3 = new MyValue1[1];
2105             try {
2106                 test88(array3, null);
2107                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2108             } catch (NullPointerException e) {
2109                 // Expected
2110             }
2111         }
2112     }
2113 
2114     @Test()
2115     public void test89(MyValue1.ref[] array, Integer v) {
2116         Object o = v;
2117         array[0] = (MyValue1.ref)o;
2118     }
2119 
2120     @DontCompile
2121     public void test89_verifier(boolean warmup) {
2122         MyValue1.ref[] array1 = new MyValue1.ref[1];
2123         test89(array1, null);
2124         Asserts.assertEquals(array1[0], null);
2125         if (!warmup) {
2126             MyValue1[] array2 = new MyValue1[1];
2127             try {
2128                 test89(array2, null);
2129                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2130             } catch (NullPointerException e) {
2131                 // Expected
2132             }
2133         }
2134     }
2135 
2136     @Test
2137     public boolean test90() {
2138         boolean b = true;
2139 
2140         MyValue1[] qArray = new MyValue1[0];
2141         MyValue1.ref[] lArray = new MyValue1.ref[0];
2142 
2143         b = b &amp;&amp; (qArray instanceof MyValue1[]);
2144         b = b &amp;&amp; (lArray instanceof MyValue1.ref[]);
2145 
2146         MyValue1[][] qArray2 = new MyValue1[0][0];
2147         MyValue1.ref[][] lArray2 = new MyValue1.ref[0][0];
2148 
2149         b = b &amp;&amp; (qArray2 instanceof MyValue1[][]);
2150         b = b &amp;&amp; (lArray2 instanceof MyValue1.ref[][]);
2151 
2152         return b;
2153     }
2154 
2155     @DontCompile
2156     public void test90_verifier(boolean warmup) {
2157         Asserts.assertEQ(test90(), true);
2158     }
2159 
2160     inline static final class Test91Value {
2161         public final int f0;
2162         public final int f1;
2163         public final int f2;
2164         public final int f3;
2165         public final int f4;
2166         public final int f5;
2167 
2168         public Test91Value(int i) {
2169             this.f0 = i;
2170             this.f1 = i;
2171             this.f2 = i;
2172             this.f3 = i;
2173             this.f4 = i;
2174             this.f5 = i;
2175         }
2176 
2177         public void verify() {
2178             if ((f0 != f1) || (f1 != f2) || (f2 != f3) || (f3 != f4) || (f4 != f5)) {
2179                 throw new RuntimeException(&quot;test91 failed&quot;);
2180             }
2181         }
2182     }
2183 
2184     // Test anti-dependencies between loads and stores from flattened array
2185     @Test
2186     @Warmup(0)
2187     public int test91(Test91Value[] array, int lo, int val) {
2188         int i = 3;
2189         while (lo &lt; i) {
2190             Test91Value tmp = array[lo];
2191             array[lo++] = array[i];
2192             array[i--] = tmp;
2193         }
2194         return val;
2195     }
2196 
2197     @DontCompile
2198     public void test91_verifier(boolean warmup) {
2199         Test91Value[] array = new Test91Value[5];
2200         for (int i = 0; i &lt; 5; ++i) {
2201             array[i] = new Test91Value(i);
2202             array[i].verify();
2203         }
2204         Asserts.assertEQ(test91(array, 0, 5), 5);
2205         for (int i = 0; i &lt; 5; ++i) {
2206             array[i].verify();
2207         }
2208     }
2209 
2210     @Test
2211     public void test92(Object[] src, Object[] dst) {
2212         System.arraycopy(src, 0, dst, 0, src.length);
2213     }
2214 
2215     @DontCompile
2216     public void test92_verifier(boolean warmup) {
2217         MyValue1[] a = new MyValue1[1];
2218         MyValue1[] b = new MyValue1[1];
2219         try {
2220             test92(a, null);
2221             throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2222         } catch (NullPointerException expected) {}
2223 
2224         try {
2225             test92(null, b);
2226             throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2227         } catch (NullPointerException expected) {}
2228 
2229         a[0] = MyValue1.createWithFieldsInline(rI, rL);
2230         test92(a, b);
2231         verify(a, b);
2232     }
2233 
2234     // Same as test30 but accessing all elements of the non-escaping array
2235     @Test
2236     public long test93(MyValue2[] src, boolean flag) {
2237         MyValue2[] dst = new MyValue2[10];
2238         System.arraycopy(src, 0, dst, 0, 10);
2239         if (flag) {  }
2240         return dst[0].hash() + dst[1].hash() + dst[2].hash() + dst[3].hash() + dst[4].hash() +
2241                dst[5].hash() + dst[6].hash() + dst[7].hash() + dst[8].hash() + dst[9].hash();
2242     }
2243 
2244     @DontCompile
2245     public void test93_verifier(boolean warmup) {
2246         MyValue2[] src = new MyValue2[10];
2247         for (int i = 0; i &lt; 10; ++i) {
<a name="35" id="anc35"></a><span class="line-modified">2248             src[i] = MyValue2.createWithFieldsInline(rI, (rI % 2) == 0);</span>
2249         }
2250         long res = test93(src, !warmup);
2251         long expected = 0;
2252         for (int i = 0; i &lt; 10; ++i) {
2253             expected += src[i].hash();
2254         }
2255         Asserts.assertEQ(res, expected);
2256     }
2257 
2258     // Same as test93 but with variable source array offset
2259     @Test
2260     public long test94(MyValue2[] src, int i, boolean flag) {
2261         MyValue2[] dst = new MyValue2[10];
2262         System.arraycopy(src, i, dst, 0, 1);
2263         if (flag) {  }
2264         return dst[0].hash() + dst[1].hash() + dst[2].hash() + dst[3].hash() + dst[4].hash() +
2265                dst[5].hash() + dst[6].hash() + dst[7].hash() + dst[8].hash() + dst[9].hash();
2266     }
2267 
2268     @DontCompile
2269     public void test94_verifier(boolean warmup) {
2270         MyValue2[] src = new MyValue2[10];
2271         for (int i = 0; i &lt; 10; ++i) {
<a name="36" id="anc36"></a><span class="line-modified">2272             src[i] = MyValue2.createWithFieldsInline(i, (i % 2) == 0);</span>
2273         }
2274         for (int i = 0; i &lt; 10; ++i) {
2275             long res = test94(src, i, !warmup);
2276             long expected = src[i].hash() + 9*MyValue2.default.hash();
2277             Asserts.assertEQ(res, expected);
2278         }
2279     }
2280 
2281     // Test propagation of not null-free/flat information
2282     @Test(failOn = CHECKCAST_ARRAY)
2283     public MyValue1[] test95(Object[] array) {
2284         array[0] = null;
2285         // Always throws a ClassCastException because we just successfully
2286         // stored null and therefore the array can&#39;t be an inline type array.
2287         return (MyValue1[])array;
2288     }
2289 
2290     @DontCompile
2291     public void test95_verifier(boolean warmup) {
2292         MyValue1[] array1 = new MyValue1[1];
2293         Integer[] array2 = new Integer[1];
2294         try {
2295             test95(array1);
2296             throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2297         } catch (NullPointerException e) {
2298             // Expected
2299         }
2300         try {
2301             test95(array2);
2302             throw new RuntimeException(&quot;Should throw ClassCastException&quot;);
2303         } catch (ClassCastException e) {
2304             // Expected
2305         }
2306     }
2307 
2308     // Same as test95 but with cmp user of cast result
2309     @Test(failOn = CHECKCAST_ARRAY)
2310     public boolean test96(Object[] array) {
2311         array[0] = null;
2312         // Always throws a ClassCastException because we just successfully
2313         // stored null and therefore the array can&#39;t be an inline type array.
2314         MyValue1[] casted = (MyValue1[])array;
2315         return casted != null;
2316     }
2317 
2318     @DontCompile
2319     public void test96_verifier(boolean warmup) {
2320         MyValue1[] array1 = new MyValue1[1];
2321         Integer[] array2 = new Integer[1];
2322         try {
2323             test96(array1);
2324             throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2325         } catch (NullPointerException e) {
2326             // Expected
2327         }
2328         try {
2329             test96(array2);
2330             throw new RuntimeException(&quot;Should throw ClassCastException&quot;);
2331         } catch (ClassCastException e) {
2332             // Expected
2333         }
2334     }
2335 
2336     // Same as test95 but with instanceof instead of cast
2337     @Test(failOn = CHECKCAST_ARRAY)
2338     public boolean test97(Object[] array) {
2339         array[0] = 42;
2340         // Always throws a ClassCastException because we just successfully stored
2341         // a non-inline value and therefore the array can&#39;t be an inline type array.
2342         return array instanceof MyValue1[];
2343     }
2344 
2345     @DontCompile
2346     public void test97_verifier(boolean warmup) {
2347         MyValue1[] array1 = new MyValue1[1];
2348         Integer[] array2 = new Integer[1];
2349         try {
2350             test97(array1);
2351             throw new RuntimeException(&quot;Should throw ArrayStoreException&quot;);
2352         } catch (ArrayStoreException e) {
2353             // Expected
2354         }
2355         boolean res = test97(array2);
2356         Asserts.assertFalse(res);
2357     }
2358 
2359     // Same as test95 but with non-flattenable store
2360     @Test(valid = InlineTypeArrayFlattenOn, failOn = CHECKCAST_ARRAY)
2361     @Test(valid = InlineTypeArrayFlattenOff)
2362     public MyValue1[] test98(Object[] array) {
2363         array[0] = NotFlattenable.default;
2364         // Always throws a ClassCastException because we just successfully stored a
2365         // non-flattenable value and therefore the array can&#39;t be a flat array.
2366         return (MyValue1[])array;
2367     }
2368 
2369     @DontCompile
2370     public void test98_verifier(boolean warmup) {
2371         MyValue1[] array1 = new MyValue1[1];
2372         NotFlattenable[] array2 = new NotFlattenable[1];
2373         try {
2374             test98(array1);
2375             throw new RuntimeException(&quot;Should throw ArrayStoreException&quot;);
2376         } catch (ArrayStoreException e) {
2377             // Expected
2378         }
2379         try {
2380             test98(array2);
2381             throw new RuntimeException(&quot;Should throw ClassCastException&quot;);
2382         } catch (ClassCastException e) {
2383             // Expected
2384         }
2385     }
2386 
2387     // Same as test98 but with cmp user of cast result
2388     @Test(valid = InlineTypeArrayFlattenOn, failOn = CHECKCAST_ARRAY)
2389     @Test(valid = InlineTypeArrayFlattenOff)
2390     public boolean test99(Object[] array) {
2391         array[0] = NotFlattenable.default;
2392         // Always throws a ClassCastException because we just successfully stored a
2393         // non-flattenable value and therefore the array can&#39;t be a flat array.
2394         MyValue1[] casted = (MyValue1[])array;
2395         return casted != null;
2396     }
2397 
2398     @DontCompile
2399     public void test99_verifier(boolean warmup) {
2400         MyValue1[] array1 = new MyValue1[1];
2401         NotFlattenable[] array2 = new NotFlattenable[1];
2402         try {
2403             test99(array1);
2404             throw new RuntimeException(&quot;Should throw ArrayStoreException&quot;);
2405         } catch (ArrayStoreException e) {
2406             // Expected
2407         }
2408         try {
2409             test99(array2);
2410             throw new RuntimeException(&quot;Should throw ClassCastException&quot;);
2411         } catch (ClassCastException e) {
2412             // Expected
2413         }
2414     }
2415 
2416     // Same as test98 but with instanceof instead of cast
2417     @Test(valid = InlineTypeArrayFlattenOn, failOn = CHECKCAST_ARRAY)
2418     @Test(valid = InlineTypeArrayFlattenOff)
2419     public boolean test100(Object[] array) {
2420         array[0] = NotFlattenable.default;
2421         // Always throws a ClassCastException because we just successfully stored a
2422         // non-flattenable value and therefore the array can&#39;t be a flat array.
2423         return array instanceof MyValue1[];
2424     }
2425 
2426     @DontCompile
2427     public void test100_verifier(boolean warmup) {
2428         MyValue1[] array1 = new MyValue1[1];
2429         NotFlattenable[] array2 = new NotFlattenable[1];
2430         try {
2431             test100(array1);
2432             throw new RuntimeException(&quot;Should throw ArrayStoreException&quot;);
2433         } catch (ArrayStoreException e) {
2434             // Expected
2435         }
2436         boolean res = test100(array2);
2437         Asserts.assertFalse(res);
2438     }
2439 
2440     // Test that CHECKCAST_ARRAY matching works as expected
2441     @Test(match = { CHECKCAST_ARRAY }, matchCount = { 1 })
2442     public boolean test101(Object[] array) {
2443         return array instanceof MyValue1[];
2444     }
2445 
2446     @DontCompile
2447     public void test101_verifier(boolean warmup) {
2448         MyValue1[] array1 = new MyValue1[1];
2449         NotFlattenable[] array2 = new NotFlattenable[1];
2450         Asserts.assertTrue(test101(array1));
2451         Asserts.assertFalse(test101(array2));
2452     }
2453 }
<a name="37" id="anc37"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="37" type="hidden" />
</body>
</html>