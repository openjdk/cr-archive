<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.inlinetypes;
  25 
  26 import jdk.test.lib.Asserts;
  27 import java.lang.invoke.*;
  28 import java.lang.reflect.Method;
  29 import java.util.Arrays;
  30 
  31 /*
  32  * @test
  33  * @key randomness
  34  * @summary Test inline type arrays
  35  * @library /testlibrary /test/lib /compiler/whitebox /
  36  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  37  * @compile TestArrays.java
  38  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  39  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  40  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  41  *                               compiler.valhalla.inlinetypes.InlineTypeTest
  42  *                               compiler.valhalla.inlinetypes.TestArrays
  43  */
  44 public class TestArrays extends InlineTypeTest {
  45     // Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to
  46     // a normal method invocation when encountering flattened arrays.
  47     private static void assertDeoptimizedByC2(Method m) {
  48         int CompLevel_none              = 0,         // Interpreter
  49             CompLevel_simple            = 1,         // C1
  50             CompLevel_limited_profile   = 2,         // C1, invocation &amp; backedge counters
  51             CompLevel_full_profile      = 3,         // C1, invocation &amp; backedge counters + mdo
  52             CompLevel_full_optimization = 4;         // C2 or JVMCI
  53 
  54         if (USE_COMPILER &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC &amp;&amp; WHITE_BOX.isMethodCompiled(m, false) &amp;&amp;
  55             WHITE_BOX.getMethodCompilationLevel(m, false) &gt;= CompLevel_full_optimization) {
  56             throw new RuntimeException(&quot;Type check should have caused it to deoptimize&quot;);
  57         }
  58     }
  59 
  60     // Extra VM parameters for some test scenarios. See InlineTypeTest.getVMParameters()
  61     @Override
  62     public String[] getExtraVMParameters(int scenario) {
  63         switch (scenario) {
  64         case 2: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  65         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:FlatArrayElementMaxSize=-1&quot;, &quot;-XX:-UncommonNullCast&quot;};
  66         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  67         case 5: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  68         }
  69         return null;
  70     }
  71 
  72     public static void main(String[] args) throws Throwable {
  73         TestArrays test = new TestArrays();
  74         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  75     }
  76 
  77     // Helper methods
  78 
  79     protected long hash() {
  80         return hash(rI, rL);
  81     }
  82 
  83     protected long hash(int x, long y) {
  84         return MyValue1.createWithFieldsInline(x, y).hash();
  85     }
  86 
  87     // Test inline type array creation and initialization
  88     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
  89     @Test(valid = InlineTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
  90     public MyValue1[] test1(int len) {
  91         MyValue1[] va = new MyValue1[len];
  92         for (int i = 0; i &lt; len; ++i) {
  93             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  94         }
  95         return va;
  96     }
  97 
  98     @DontCompile
  99     public void test1_verifier(boolean warmup) {
 100         int len = Math.abs(rI % 10);
 101         MyValue1[] va = test1(len);
 102         for (int i = 0; i &lt; len; ++i) {
 103             Asserts.assertEQ(va[i].hash(), hash());
 104         }
 105     }
 106 
 107     // Test creation of an inline type array and element access
<a name="1" id="anc1"></a><span class="line-modified"> 108     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>


 109     public long test2() {
 110         MyValue1[] va = new MyValue1[1];
 111         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 112         return va[0].hash();
 113     }
 114 
 115     @DontCompile
 116     public void test2_verifier(boolean warmup) {
 117         long result = test2();
 118         Asserts.assertEQ(result, hash());
 119     }
 120 
 121     // Test receiving an inline type array from the interpreter,
 122     // updating its elements in a loop and computing a hash.
 123     @Test(failOn = ALLOCA)
 124     public long test3(MyValue1[] va) {
 125         long result = 0;
 126         for (int i = 0; i &lt; 10; ++i) {
 127             result += va[i].hash();
 128             va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 129         }
 130         return result;
 131     }
 132 
 133     @DontCompile
 134     public void test3_verifier(boolean warmup) {
 135         MyValue1[] va = new MyValue1[10];
 136         long expected = 0;
 137         for (int i = 0; i &lt; 10; ++i) {
 138             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 139             expected += va[i].hash();
 140         }
 141         long result = test3(va);
 142         Asserts.assertEQ(expected, result);
 143         for (int i = 0; i &lt; 10; ++i) {
 144             if (va[i].hash() != hash(rI + 1, rL + 1)) {
 145                 Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));
 146             }
 147         }
 148     }
 149 
 150     // Test returning an inline type array received from the interpreter
 151     @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
 152     public MyValue1[] test4(MyValue1[] va) {
 153         return va;
 154     }
 155 
 156     @DontCompile
 157     public void test4_verifier(boolean warmup) {
 158         MyValue1[] va = new MyValue1[10];
 159         for (int i = 0; i &lt; 10; ++i) {
 160             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 161         }
 162         va = test4(va);
 163         for (int i = 0; i &lt; 10; ++i) {
 164             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 165         }
 166     }
 167 
 168     // Merge inline type arrays created from two branches
 169     @Test
 170     public MyValue1[] test5(boolean b) {
 171         MyValue1[] va;
 172         if (b) {
 173             va = new MyValue1[5];
 174             for (int i = 0; i &lt; 5; ++i) {
 175                 va[i] = MyValue1.createWithFieldsInline(rI, rL);
 176             }
 177         } else {
 178             va = new MyValue1[10];
 179             for (int i = 0; i &lt; 10; ++i) {
 180                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
 181             }
 182         }
 183         long sum = va[0].hashInterpreted();
 184         if (b) {
 185             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
 186         } else {
 187             va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);
 188         }
 189         return va;
 190     }
 191 
 192     @DontCompile
 193     public void test5_verifier(boolean warmup) {
 194         MyValue1[] va = test5(true);
 195         Asserts.assertEQ(va.length, 5);
 196         Asserts.assertEQ(va[0].hash(), hash(rI, hash()));
 197         for (int i = 1; i &lt; 5; ++i) {
 198             Asserts.assertEQ(va[i].hash(), hash());
 199         }
 200         va = test5(false);
 201         Asserts.assertEQ(va.length, 10);
 202         Asserts.assertEQ(va[0].hash(), hash(rI + 1, hash(rI, rL) + 1));
 203         for (int i = 1; i &lt; 10; ++i) {
 204             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 205         }
 206     }
 207 
 208     // Test creation of inline type array with single element
 209     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 210     public MyValue1 test6() {
 211         MyValue1[] va = new MyValue1[1];
 212         return va[0];
 213     }
 214 
 215     @DontCompile
 216     public void test6_verifier(boolean warmup) {
 217         MyValue1[] va = new MyValue1[1];
 218         MyValue1 v = test6();
 219         Asserts.assertEQ(v.hashPrimitive(), va[0].hashPrimitive());
 220     }
 221 
 222     // Test default initialization of inline type arrays
 223     @Test(failOn = LOAD)
 224     public MyValue1[] test7(int len) {
 225         return new MyValue1[len];
 226     }
 227 
 228     @DontCompile
 229     public void test7_verifier(boolean warmup) {
 230         int len = Math.abs(rI % 10);
 231         MyValue1[] va = new MyValue1[len];
 232         MyValue1[] var = test7(len);
 233         for (int i = 0; i &lt; len; ++i) {
 234             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
 235         }
 236     }
 237 
 238     // Test creation of inline type array with zero length
 239     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
 240     public MyValue1[] test8() {
 241         return new MyValue1[0];
 242     }
 243 
 244     @DontCompile
 245     public void test8_verifier(boolean warmup) {
 246         MyValue1[] va = test8();
 247         Asserts.assertEQ(va.length, 0);
 248     }
 249 
 250     static MyValue1[] test9_va;
 251 
 252     // Test that inline type array loaded from field has correct type
 253     @Test(failOn = LOOP)
 254     public long test9() {
 255         return test9_va[0].hash();
 256     }
 257 
 258     @DontCompile
 259     public void test9_verifier(boolean warmup) {
 260         test9_va = new MyValue1[1];
 261         test9_va[0] = MyValue1.createWithFieldsInline(rI, rL);
 262         long result = test9();
 263         Asserts.assertEQ(result, hash());
 264     }
 265 
 266     // Multi-dimensional arrays
 267     @Test
 268     public MyValue1[][][] test10(int len1, int len2, int len3) {
 269         MyValue1[][][] arr = new MyValue1[len1][len2][len3];
 270         for (int i = 0; i &lt; len1; i++) {
 271             for (int j = 0; j &lt; len2; j++) {
 272                 for (int k = 0; k &lt; len3; k++) {
 273                     arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);
 274                 }
 275             }
 276         }
 277         return arr;
 278     }
 279 
 280     @DontCompile
 281     public void test10_verifier(boolean warmup) {
 282         MyValue1[][][] arr = test10(2, 3, 4);
 283         for (int i = 0; i &lt; 2; i++) {
 284             for (int j = 0; j &lt; 3; j++) {
 285                 for (int k = 0; k &lt; 4; k++) {
 286                     Asserts.assertEQ(arr[i][j][k].hash(), MyValue1.createWithFieldsDontInline(rI + i , rL + j + k).hash());
 287                 }
 288             }
 289         }
 290     }
 291 
 292     @Test
 293     public void test11(MyValue1[][][] arr, long[] res) {
 294         int l = 0;
 295         for (int i = 0; i &lt; arr.length; i++) {
 296             for (int j = 0; j &lt; arr[i].length; j++) {
 297                 for (int k = 0; k &lt; arr[i][j].length; k++) {
 298                     res[l] = arr[i][j][k].hash();
 299                     l++;
 300                 }
 301             }
 302         }
 303     }
 304 
 305     @DontCompile
 306     public void test11_verifier(boolean warmup) {
 307         MyValue1[][][] arr = new MyValue1[2][3][4];
 308         long[] res = new long[2*3*4];
 309         long[] verif = new long[2*3*4];
 310         int l = 0;
 311         for (int i = 0; i &lt; 2; i++) {
 312             for (int j = 0; j &lt; 3; j++) {
 313                 for (int k = 0; k &lt; 4; k++) {
 314                     arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i, rL + j + k);
 315                     verif[l] = arr[i][j][k].hash();
 316                     l++;
 317                 }
 318             }
 319         }
 320         test11(arr, res);
 321         for (int i = 0; i &lt; verif.length; i++) {
 322             Asserts.assertEQ(res[i], verif[i]);
 323         }
 324     }
 325 
 326     // Array load out of bounds (upper bound) at compile time
 327     @Test
 328     public int test12() {
 329         int arraySize = Math.abs(rI) % 10;;
 330         MyValue1[] va = new MyValue1[arraySize];
 331 
 332         for (int i = 0; i &lt; arraySize; i++) {
 333             va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 334         }
 335 
 336         try {
 337             return va[arraySize + 1].x;
 338         } catch (ArrayIndexOutOfBoundsException e) {
 339             return rI;
 340         }
 341     }
 342 
 343     public void test12_verifier(boolean warmup) {
 344         Asserts.assertEQ(test12(), rI);
 345     }
 346 
 347     // Array load  out of bounds (lower bound) at compile time
 348     @Test
 349     public int test13() {
 350         int arraySize = Math.abs(rI) % 10;;
 351         MyValue1[] va = new MyValue1[arraySize];
 352 
 353         for (int i = 0; i &lt; arraySize; i++) {
 354             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);
 355         }
 356 
 357         try {
 358             return va[-arraySize].x;
 359         } catch (ArrayIndexOutOfBoundsException e) {
 360             return rI;
 361         }
 362     }
 363 
 364     public void test13_verifier(boolean warmup) {
 365         Asserts.assertEQ(test13(), rI);
 366     }
 367 
 368     // Array load out of bound not known to compiler (both lower and upper bound)
 369     @Test
 370     public int test14(MyValue1[] va, int index)  {
 371         return va[index].x;
 372     }
 373 
 374     public void test14_verifier(boolean warmup) {
 375         int arraySize = Math.abs(rI) % 10;
 376         MyValue1[] va = new MyValue1[arraySize];
 377 
 378         for (int i = 0; i &lt; arraySize; i++) {
 379             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 380         }
 381 
 382         int result;
 383         for (int i = -20; i &lt; 20; i++) {
 384             try {
 385                 result = test14(va, i);
 386             } catch (ArrayIndexOutOfBoundsException e) {
 387                 result = rI;
 388             }
 389             Asserts.assertEQ(result, rI);
 390         }
 391     }
 392 
 393     // Array store out of bounds (upper bound) at compile time
 394     @Test
 395     public int test15() {
 396         int arraySize = Math.abs(rI) % 10;;
 397         MyValue1[] va = new MyValue1[arraySize];
 398 
 399         try {
 400             for (int i = 0; i &lt;= arraySize; i++) {
 401                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 402             }
 403             return rI - 1;
 404         } catch (ArrayIndexOutOfBoundsException e) {
 405             return rI;
 406         }
 407     }
 408 
 409     public void test15_verifier(boolean warmup) {
 410         Asserts.assertEQ(test15(), rI);
 411     }
 412 
 413     // Array store out of bounds (lower bound) at compile time
 414     @Test
 415     public int test16() {
 416         int arraySize = Math.abs(rI) % 10;;
 417         MyValue1[] va = new MyValue1[arraySize];
 418 
 419         try {
 420             for (int i = -1; i &lt;= arraySize; i++) {
 421                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 422             }
 423             return rI - 1;
 424         } catch (ArrayIndexOutOfBoundsException e) {
 425             return rI;
 426         }
 427     }
 428 
 429     public void test16_verifier(boolean warmup) {
 430         Asserts.assertEQ(test16(), rI);
 431     }
 432 
 433     // Array store out of bound not known to compiler (both lower and upper bound)
 434     @Test
 435     public int test17(MyValue1[] va, int index, MyValue1 vt)  {
 436         va[index] = vt;
 437         return va[index].x;
 438     }
 439 
 440     @DontCompile
 441     public void test17_verifier(boolean warmup) {
 442         int arraySize = Math.abs(rI) % 10;
 443         MyValue1[] va = new MyValue1[arraySize];
 444 
 445         for (int i = 0; i &lt; arraySize; i++) {
 446             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 447         }
 448 
 449         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 450         int result;
 451         for (int i = -20; i &lt; 20; i++) {
 452             try {
 453                 result = test17(va, i, vt);
 454             } catch (ArrayIndexOutOfBoundsException e) {
 455                 result = rI + 1;
 456             }
 457             Asserts.assertEQ(result, rI + 1);
 458         }
 459 
 460         for (int i = 0; i &lt; arraySize; i++) {
 461             Asserts.assertEQ(va[i].x, rI + 1);
 462         }
 463     }
 464 
 465     // clone() as stub call
 466     @Test
 467     public MyValue1[] test18(MyValue1[] va) {
 468         return va.clone();
 469     }
 470 
 471     @DontCompile
 472     public void test18_verifier(boolean warmup) {
 473         int len = Math.abs(rI) % 10;
 474         MyValue1[] va = new MyValue1[len];
 475         for (int i = 0; i &lt; len; ++i) {
 476             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 477         }
 478         MyValue1[] result = test18(va);
 479         for (int i = 0; i &lt; len; ++i) {
 480             Asserts.assertEQ(result[i].hash(), va[i].hash());
 481         }
 482     }
 483 
 484     // clone() as series of loads/stores
 485     static MyValue1[] test19_orig = null;
 486 
 487     @Test
 488     public MyValue1[] test19() {
 489         MyValue1[] va = new MyValue1[8];
 490         for (int i = 0; i &lt; va.length; ++i) {
 491             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 492         }
 493         test19_orig = va;
 494 
 495         return va.clone();
 496     }
 497 
 498     @DontCompile
 499     public void test19_verifier(boolean warmup) {
 500         MyValue1[] result = test19();
 501         for (int i = 0; i &lt; test19_orig.length; ++i) {
 502             Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
 503         }
 504     }
 505 
 506     // arraycopy() of inline type array with oop fields
 507     @Test
 508     public void test20(MyValue1[] src, MyValue1[] dst) {
 509         System.arraycopy(src, 0, dst, 0, src.length);
 510     }
 511 
 512     @DontCompile
 513     public void test20_verifier(boolean warmup) {
 514         int len = Math.abs(rI) % 10;
 515         MyValue1[] src = new MyValue1[len];
 516         MyValue1[] dst = new MyValue1[len];
 517         for (int i = 0; i &lt; len; ++i) {
 518             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 519         }
 520         test20(src, dst);
 521         for (int i = 0; i &lt; len; ++i) {
 522             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 523         }
 524     }
 525 
 526     // arraycopy() of inline type array with no oop field
 527     @Test
 528     public void test21(MyValue2[] src, MyValue2[] dst) {
 529         System.arraycopy(src, 0, dst, 0, src.length);
 530     }
 531 
 532     @DontCompile
 533     public void test21_verifier(boolean warmup) {
 534         int len = Math.abs(rI) % 10;
 535         MyValue2[] src = new MyValue2[len];
 536         MyValue2[] dst = new MyValue2[len];
 537         for (int i = 0; i &lt; len; ++i) {
<a name="2" id="anc2"></a><span class="line-modified"> 538             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 539         }
 540         test21(src, dst);
 541         for (int i = 0; i &lt; len; ++i) {
 542             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 543         }
 544     }
 545 
 546     // arraycopy() of inline type array with oop field and tightly
 547     // coupled allocation as dest
 548     @Test
 549     public MyValue1[] test22(MyValue1[] src) {
 550         MyValue1[] dst = new MyValue1[src.length];
 551         System.arraycopy(src, 0, dst, 0, src.length);
 552         return dst;
 553     }
 554 
 555     @DontCompile
 556     public void test22_verifier(boolean warmup) {
 557         int len = Math.abs(rI) % 10;
 558         MyValue1[] src = new MyValue1[len];
 559         for (int i = 0; i &lt; len; ++i) {
 560             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 561         }
 562         MyValue1[] dst = test22(src);
 563         for (int i = 0; i &lt; len; ++i) {
 564             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 565         }
 566     }
 567 
 568     // arraycopy() of inline type array with oop fields and tightly
 569     // coupled allocation as dest
 570     @Test
 571     public MyValue1[] test23(MyValue1[] src) {
 572         MyValue1[] dst = new MyValue1[src.length + 10];
 573         System.arraycopy(src, 0, dst, 5, src.length);
 574         return dst;
 575     }
 576 
 577     @DontCompile
 578     public void test23_verifier(boolean warmup) {
 579         int len = Math.abs(rI) % 10;
 580         MyValue1[] src = new MyValue1[len];
 581         for (int i = 0; i &lt; len; ++i) {
 582             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 583         }
 584         MyValue1[] dst = test23(src);
 585         for (int i = 5; i &lt; len; ++i) {
 586             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 587         }
 588     }
 589 
 590     // arraycopy() of inline type array passed as Object
 591     @Test
 592     public void test24(MyValue1[] src, Object dst) {
 593         System.arraycopy(src, 0, dst, 0, src.length);
 594     }
 595 
 596     @DontCompile
 597     public void test24_verifier(boolean warmup) {
 598         int len = Math.abs(rI) % 10;
 599         MyValue1[] src = new MyValue1[len];
 600         MyValue1[] dst = new MyValue1[len];
 601         for (int i = 0; i &lt; len; ++i) {
 602             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 603         }
 604         test24(src, dst);
 605         for (int i = 0; i &lt; len; ++i) {
 606             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 607         }
 608     }
 609 
 610     // short arraycopy() with no oop field
 611     @Test
 612     public void test25(MyValue2[] src, MyValue2[] dst) {
 613         System.arraycopy(src, 0, dst, 0, 8);
 614     }
 615 
 616     @DontCompile
 617     public void test25_verifier(boolean warmup) {
 618         MyValue2[] src = new MyValue2[8];
 619         MyValue2[] dst = new MyValue2[8];
 620         for (int i = 0; i &lt; 8; ++i) {
<a name="3" id="anc3"></a><span class="line-modified"> 621             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 622         }
 623         test25(src, dst);
 624         for (int i = 0; i &lt; 8; ++i) {
 625             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 626         }
 627     }
 628 
 629     // short arraycopy() with oop fields
 630     @Test
 631     public void test26(MyValue1[] src, MyValue1[] dst) {
 632         System.arraycopy(src, 0, dst, 0, 8);
 633     }
 634 
 635     @DontCompile
 636     public void test26_verifier(boolean warmup) {
 637         MyValue1[] src = new MyValue1[8];
 638         MyValue1[] dst = new MyValue1[8];
 639         for (int i = 0; i &lt; 8; ++i) {
 640             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 641         }
 642         test26(src, dst);
 643         for (int i = 0; i &lt; 8; ++i) {
 644             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 645         }
 646     }
 647 
 648     // short arraycopy() with oop fields and offsets
 649     @Test
 650     public void test27(MyValue1[] src, MyValue1[] dst) {
 651         System.arraycopy(src, 1, dst, 2, 6);
 652     }
 653 
 654     @DontCompile
 655     public void test27_verifier(boolean warmup) {
 656         MyValue1[] src = new MyValue1[8];
 657         MyValue1[] dst = new MyValue1[8];
 658         for (int i = 0; i &lt; 8; ++i) {
 659             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 660         }
 661         test27(src, dst);
 662         for (int i = 2; i &lt; 8; ++i) {
 663             Asserts.assertEQ(src[i-1].hash(), dst[i].hash());
 664         }
 665     }
 666 
 667     // non escaping allocations
<a name="4" id="anc4"></a><span class="line-modified"> 668     // TODO 8252027: Make sure this is optimized with ZGC</span>
 669     @Test(valid = ZGCOff, failOn = ALLOCA + LOOP + LOAD + TRAP)
 670     @Test(valid = ZGCOn)
 671     public MyValue2 test28() {
 672         MyValue2[] src = new MyValue2[10];
<a name="5" id="anc5"></a><span class="line-modified"> 673         src[0] = MyValue2.createWithFieldsInline(rI, rD);</span>
 674         MyValue2[] dst = (MyValue2[])src.clone();
 675         return dst[0];
 676     }
 677 
 678     @DontCompile
 679     public void test28_verifier(boolean warmup) {
<a name="6" id="anc6"></a><span class="line-modified"> 680         MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);</span>
 681         MyValue2 result = test28();
 682         Asserts.assertEQ(result.hash(), v.hash());
 683     }
 684 
 685     // non escaping allocations
 686     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
<a name="7" id="anc7"></a><span class="line-added"> 687     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>
 688     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOCA + LOOP + LOAD + TRAP)
<a name="8" id="anc8"></a><span class="line-modified"> 689     @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOCA + LOOP + TRAP)</span>
 690     public MyValue2 test29(MyValue2[] src) {
 691         MyValue2[] dst = new MyValue2[10];
 692         System.arraycopy(src, 0, dst, 0, 10);
 693         return dst[0];
 694     }
 695 
 696     @DontCompile
 697     public void test29_verifier(boolean warmup) {
 698         MyValue2[] src = new MyValue2[10];
 699         for (int i = 0; i &lt; 10; ++i) {
<a name="9" id="anc9"></a><span class="line-modified"> 700             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 701         }
 702         MyValue2 v = test29(src);
 703         Asserts.assertEQ(src[0].hash(), v.hash());
 704     }
 705 
 706     // non escaping allocation with uncommon trap that needs
 707     // eliminated inline type array element as debug info
 708     @Test
 709     @Warmup(10000)
 710     public MyValue2 test30(MyValue2[] src, boolean flag) {
 711         MyValue2[] dst = new MyValue2[10];
 712         System.arraycopy(src, 0, dst, 0, 10);
 713         if (flag) { }
 714         return dst[0];
 715     }
 716 
 717     @DontCompile
 718     public void test30_verifier(boolean warmup) {
 719         MyValue2[] src = new MyValue2[10];
 720         for (int i = 0; i &lt; 10; ++i) {
<a name="10" id="anc10"></a><span class="line-modified"> 721             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 722         }
 723         MyValue2 v = test30(src, !warmup);
 724         Asserts.assertEQ(src[0].hash(), v.hash());
 725     }
 726 
 727     // non escaping allocation with memory phi
<a name="11" id="anc11"></a><span class="line-modified"> 728     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>


 729     public long test31(boolean b, boolean deopt) {
 730         MyValue2[] src = new MyValue2[1];
 731         if (b) {
<a name="12" id="anc12"></a><span class="line-modified"> 732             src[0] = MyValue2.createWithFieldsInline(rI, rD);</span>
 733         } else {
<a name="13" id="anc13"></a><span class="line-modified"> 734             src[0] = MyValue2.createWithFieldsInline(rI+1, rD+1);</span>
 735         }
 736         if (deopt) {
 737             // uncommon trap
 738             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test31&quot;));
 739         }
 740         return src[0].hash();
 741     }
 742 
 743     @DontCompile
 744     public void test31_verifier(boolean warmup) {
<a name="14" id="anc14"></a><span class="line-modified"> 745         MyValue2 v1 = MyValue2.createWithFieldsInline(rI, rD);</span>
 746         long result1 = test31(true, !warmup);
 747         Asserts.assertEQ(result1, v1.hash());
<a name="15" id="anc15"></a><span class="line-modified"> 748         MyValue2 v2 = MyValue2.createWithFieldsInline(rI+1, rD+1);</span>
 749         long result2 = test31(false, !warmup);
 750         Asserts.assertEQ(result2, v2.hash());
 751     }
 752 
 753     // Tests with Object arrays and clone/arraycopy
 754     // clone() as stub call
 755     @Test
 756     public Object[] test32(Object[] va) {
 757         return va.clone();
 758     }
 759 
 760     @DontCompile
 761     public void test32_verifier(boolean warmup) {
 762         int len = Math.abs(rI) % 10;
 763         MyValue1[] va = new MyValue1[len];
 764         for (int i = 0; i &lt; len; ++i) {
 765             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 766         }
 767         MyValue1[] result = (MyValue1[])test32(va);
 768         for (int i = 0; i &lt; len; ++i) {
 769             Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());
 770         }
 771     }
 772 
 773     @Test
 774     public Object[] test33(Object[] va) {
 775         return va.clone();
 776     }
 777 
 778     @DontCompile
 779     public void test33_verifier(boolean warmup) {
 780         int len = Math.abs(rI) % 10;
 781         Object[] va = new Object[len];
 782         for (int i = 0; i &lt; len; ++i) {
 783             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 784         }
 785         Object[] result = test33(va);
 786         for (int i = 0; i &lt; len; ++i) {
 787             Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());
 788             // Check that array has correct properties (null-ok)
 789             result[i] = null;
 790         }
 791     }
 792 
 793     // clone() as series of loads/stores
 794     static Object[] test34_orig = null;
 795 
 796     @ForceInline
 797     public Object[] test34_helper(boolean flag) {
 798         Object[] va = null;
 799         if (flag) {
 800             va = new MyValue1[8];
 801             for (int i = 0; i &lt; va.length; ++i) {
 802                 va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 803             }
 804         } else {
 805             va = new Object[8];
 806         }
 807         return va;
 808     }
 809 
 810     @Test
 811     public Object[] test34(boolean flag) {
 812         Object[] va = test34_helper(flag);
 813         test34_orig = va;
 814         return va.clone();
 815     }
 816 
 817     @DontCompile
 818     public void test34_verifier(boolean warmup) {
 819         test34(false);
 820         for (int i = 0; i &lt; 10; i++) { // make sure we do deopt
 821             Object[] result = test34(true);
 822             verify(test34_orig, result);
 823             // Check that array has correct properties (null-free)
 824             try {
 825                 result[0] = null;
 826                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
 827             } catch (NullPointerException e) {
 828                 // Expected
 829             }
 830         }
 831         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test34&quot;)) {
 832             Object[] result = test34(true);
 833             verify(test34_orig, result);
 834             // Check that array has correct properties (null-free)
 835             try {
 836                 result[0] = null;
 837                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
 838             } catch (NullPointerException e) {
 839                 // Expected
 840             }
 841         }
 842     }
 843 
 844     static void verify(Object[] src, Object[] dst) {
 845         for (int i = 0; i &lt; src.length; ++i) {
 846             Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());
 847         }
 848     }
 849 
 850     static void verify(MyValue1[] src, MyValue1[] dst) {
 851         for (int i = 0; i &lt; src.length; ++i) {
 852             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 853         }
 854     }
 855 
 856     static void verify(MyValue1[] src, Object[] dst) {
 857         for (int i = 0; i &lt; src.length; ++i) {
 858             Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
 859         }
 860     }
 861 
 862     static void verify(MyValue2[] src, MyValue2[] dst) {
 863         for (int i = 0; i &lt; src.length; ++i) {
 864             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 865         }
 866     }
 867 
 868     static void verify(MyValue2[] src, Object[] dst) {
 869         for (int i = 0; i &lt; src.length; ++i) {
 870             Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
 871         }
 872     }
 873 
 874     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
 875         if (!warmup) {
 876             Method m = tests.get(test);
 877             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false)) {
 878                 if (!InlineTypeArrayFlatten &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
 879                     throw new RuntimeException(&quot;Unexpected deoptimization&quot;);
 880                 }
 881                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
 882                 return true;
 883             }
 884         }
 885         return false;
 886     }
 887 
 888     // arraycopy() of inline type array of unknown size
 889     @Test
 890     public void test35(Object src, Object dst, int len) {
 891         System.arraycopy(src, 0, dst, 0, len);
 892     }
 893 
 894     @DontCompile
 895     public void test35_verifier(boolean warmup) {
 896         int len = Math.abs(rI) % 10;
 897         MyValue1[] src = new MyValue1[len];
 898         MyValue1[] dst = new MyValue1[len];
 899         for (int i = 0; i &lt; len; ++i) {
 900             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 901         }
 902         test35(src, dst, src.length);
 903         verify(src, dst);
 904         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test35&quot;)) {
 905             test35(src, dst, src.length);
 906             verify(src, dst);
 907         }
 908     }
 909 
 910     @Test
 911     public void test36(Object src, MyValue2[] dst) {
 912         System.arraycopy(src, 0, dst, 0, dst.length);
 913     }
 914 
 915     @DontCompile
 916     public void test36_verifier(boolean warmup) {
 917         int len = Math.abs(rI) % 10;
 918         MyValue2[] src = new MyValue2[len];
 919         MyValue2[] dst = new MyValue2[len];
 920         for (int i = 0; i &lt; len; ++i) {
<a name="16" id="anc16"></a><span class="line-modified"> 921             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 922         }
 923         test36(src, dst);
 924         verify(src, dst);
 925         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test36&quot;)) {
 926             test36(src, dst);
 927             verify(src, dst);
 928         }
 929     }
 930 
 931     @Test
 932     public void test37(MyValue2[] src, Object dst) {
 933         System.arraycopy(src, 0, dst, 0, src.length);
 934     }
 935 
 936     @DontCompile
 937     public void test37_verifier(boolean warmup) {
 938         int len = Math.abs(rI) % 10;
 939         MyValue2[] src = new MyValue2[len];
 940         MyValue2[] dst = new MyValue2[len];
 941         for (int i = 0; i &lt; len; ++i) {
<a name="17" id="anc17"></a><span class="line-modified"> 942             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 943         }
 944         test37(src, dst);
 945         verify(src, dst);
 946         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test37&quot;)) {
 947             test37(src, dst);
 948             verify(src, dst);
 949         }
 950     }
 951 
 952     @Test
 953     @Warmup(1) // Avoid early compilation
 954     public void test38(Object src, MyValue2[] dst) {
 955         System.arraycopy(src, 0, dst, 0, dst.length);
 956     }
 957 
 958     @DontCompile
 959     public void test38_verifier(boolean warmup) {
 960         int len = Math.abs(rI) % 10;
 961         Object[] src = new Object[len];
 962         MyValue2[] dst = new MyValue2[len];
 963         for (int i = 0; i &lt; len; ++i) {
<a name="18" id="anc18"></a><span class="line-modified"> 964             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 965         }
 966         test38(src, dst);
 967         verify(dst, src);
 968         if (!warmup) {
 969             Method m = tests.get(&quot;TestArrays::test38&quot;);
 970             assertDeoptimizedByC2(m);
 971             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
 972             test38(src, dst);
 973             verify(dst, src);
 974             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
 975                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
 976             }
 977         }
 978     }
 979 
 980     @Test
 981     public void test39(MyValue2[] src, Object dst) {
 982         System.arraycopy(src, 0, dst, 0, src.length);
 983     }
 984 
 985     @DontCompile
 986     public void test39_verifier(boolean warmup) {
 987         int len = Math.abs(rI) % 10;
 988         MyValue2[] src = new MyValue2[len];
 989         Object[] dst = new Object[len];
 990         for (int i = 0; i &lt; len; ++i) {
<a name="19" id="anc19"></a><span class="line-modified"> 991             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 992         }
 993         test39(src, dst);
 994         verify(src, dst);
 995         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test39&quot;)) {
 996             test39(src, dst);
 997             verify(src, dst);
 998         }
 999     }
1000 
1001     @Test
1002     @Warmup(1) // Avoid early compilation
1003     public void test40(Object[] src, Object dst) {
1004         System.arraycopy(src, 0, dst, 0, src.length);
1005     }
1006 
1007     @DontCompile
1008     public void test40_verifier(boolean warmup) {
1009         int len = Math.abs(rI) % 10;
1010         Object[] src = new Object[len];
1011         MyValue2[] dst = new MyValue2[len];
1012         for (int i = 0; i &lt; len; ++i) {
<a name="20" id="anc20"></a><span class="line-modified">1013             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1014         }
1015         test40(src, dst);
1016         verify(dst, src);
1017         if (!warmup) {
1018             Method m = tests.get(&quot;TestArrays::test40&quot;);
1019             assertDeoptimizedByC2(m);
1020             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1021             test40(src, dst);
1022             verify(dst, src);
1023             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1024                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1025             }
1026         }
1027     }
1028 
1029     @Test
1030     public void test41(Object src, Object[] dst) {
1031         System.arraycopy(src, 0, dst, 0, dst.length);
1032     }
1033 
1034     @DontCompile
1035     public void test41_verifier(boolean warmup) {
1036         int len = Math.abs(rI) % 10;
1037         MyValue2[] src = new MyValue2[len];
1038         Object[] dst = new Object[len];
1039         for (int i = 0; i &lt; len; ++i) {
<a name="21" id="anc21"></a><span class="line-modified">1040             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1041         }
1042         test41(src, dst);
1043         verify(src, dst);
1044         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test41&quot;)) {
1045             test41(src, dst);
1046             verify(src, dst);
1047         }
1048     }
1049 
1050     @Test
1051     public void test42(Object[] src, Object[] dst) {
1052         System.arraycopy(src, 0, dst, 0, src.length);
1053     }
1054 
1055     @DontCompile
1056     public void test42_verifier(boolean warmup) {
1057         int len = Math.abs(rI) % 10;
1058         Object[] src = new Object[len];
1059         Object[] dst = new Object[len];
1060         for (int i = 0; i &lt; len; ++i) {
<a name="22" id="anc22"></a><span class="line-modified">1061             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1062         }
1063         test42(src, dst);
1064         verify(src, dst);
1065         if (!warmup) {
1066             Method m = tests.get(&quot;TestArrays::test42&quot;);
1067             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1068                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1069             }
1070         }
1071     }
1072 
1073     // short arraycopy()&#39;s
1074     @Test
1075     public void test43(Object src, Object dst) {
1076         System.arraycopy(src, 0, dst, 0, 8);
1077     }
1078 
1079     @DontCompile
1080     public void test43_verifier(boolean warmup) {
1081         MyValue1[] src = new MyValue1[8];
1082         MyValue1[] dst = new MyValue1[8];
1083         for (int i = 0; i &lt; 8; ++i) {
1084             src[i] = MyValue1.createWithFieldsInline(rI, rL);
1085         }
1086         test43(src, dst);
1087         verify(src, dst);
1088         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test43&quot;)) {
1089             test43(src, dst);
1090             verify(src, dst);
1091         }
1092     }
1093 
1094     @Test
1095     public void test44(Object src, MyValue2[] dst) {
1096         System.arraycopy(src, 0, dst, 0, 8);
1097     }
1098 
1099     @DontCompile
1100     public void test44_verifier(boolean warmup) {
1101         MyValue2[] src = new MyValue2[8];
1102         MyValue2[] dst = new MyValue2[8];
1103         for (int i = 0; i &lt; 8; ++i) {
<a name="23" id="anc23"></a><span class="line-modified">1104             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1105         }
1106         test44(src, dst);
1107         verify(src, dst);
1108         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test44&quot;)) {
1109             test44(src, dst);
1110             verify(src, dst);
1111         }
1112     }
1113 
1114     @Test
1115     public void test45(MyValue2[] src, Object dst) {
1116         System.arraycopy(src, 0, dst, 0, 8);
1117     }
1118 
1119     @DontCompile
1120     public void test45_verifier(boolean warmup) {
1121         MyValue2[] src = new MyValue2[8];
1122         MyValue2[] dst = new MyValue2[8];
1123         for (int i = 0; i &lt; 8; ++i) {
<a name="24" id="anc24"></a><span class="line-modified">1124             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1125         }
1126         test45(src, dst);
1127         verify(src, dst);
1128         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test45&quot;)) {
1129             test45(src, dst);
1130             verify(src, dst);
1131         }
1132     }
1133 
1134     @Test
1135     @Warmup(1) // Avoid early compilation
1136     public void test46(Object[] src, MyValue2[] dst) {
1137         System.arraycopy(src, 0, dst, 0, 8);
1138     }
1139 
1140     @DontCompile
1141     public void test46_verifier(boolean warmup) {
1142         Object[] src = new Object[8];
1143         MyValue2[] dst = new MyValue2[8];
1144         for (int i = 0; i &lt; 8; ++i) {
<a name="25" id="anc25"></a><span class="line-modified">1145             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1146         }
1147         test46(src, dst);
1148         verify(dst, src);
1149         if (!warmup) {
1150             Method m = tests.get(&quot;TestArrays::test46&quot;);
1151             assertDeoptimizedByC2(m);
1152             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1153             test46(src, dst);
1154             verify(dst, src);
1155             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1156                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1157             }
1158         }
1159     }
1160 
1161     @Test
1162     public void test47(MyValue2[] src, Object[] dst) {
1163         System.arraycopy(src, 0, dst, 0, 8);
1164     }
1165 
1166     @DontCompile
1167     public void test47_verifier(boolean warmup) {
1168         MyValue2[] src = new MyValue2[8];
1169         Object[] dst = new Object[8];
1170         for (int i = 0; i &lt; 8; ++i) {
<a name="26" id="anc26"></a><span class="line-modified">1171             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1172         }
1173         test47(src, dst);
1174         verify(src, dst);
1175         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test47&quot;)) {
1176             test47(src, dst);
1177             verify(src, dst);
1178         }
1179     }
1180 
1181     @Test
1182     @Warmup(1) // Avoid early compilation
1183     public void test48(Object[] src, Object dst) {
1184         System.arraycopy(src, 0, dst, 0, 8);
1185     }
1186 
1187     @DontCompile
1188     public void test48_verifier(boolean warmup) {
1189         Object[] src = new Object[8];
1190         MyValue2[] dst = new MyValue2[8];
1191         for (int i = 0; i &lt; 8; ++i) {
<a name="27" id="anc27"></a><span class="line-modified">1192             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1193         }
1194         test48(src, dst);
1195         verify(dst, src);
1196         if (!warmup) {
1197             Method m = tests.get(&quot;TestArrays::test48&quot;);
1198             assertDeoptimizedByC2(m);
1199             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1200             test48(src, dst);
1201             verify(dst, src);
1202             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1203                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1204             }
1205         }
1206     }
1207 
1208     @Test
1209     public void test49(Object src, Object[] dst) {
1210         System.arraycopy(src, 0, dst, 0, 8);
1211     }
1212 
1213     @DontCompile
1214     public void test49_verifier(boolean warmup) {
1215         MyValue2[] src = new MyValue2[8];
1216         Object[] dst = new Object[8];
1217         for (int i = 0; i &lt; 8; ++i) {
<a name="28" id="anc28"></a><span class="line-modified">1218             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1219         }
1220         test49(src, dst);
1221         verify(src, dst);
1222         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test49&quot;)) {
1223             test49(src, dst);
1224             verify(src, dst);
1225         }
1226     }
1227 
1228     @Test
1229     public void test50(Object[] src, Object[] dst) {
1230         System.arraycopy(src, 0, dst, 0, 8);
1231     }
1232 
1233     @DontCompile
1234     public void test50_verifier(boolean warmup) {
1235         Object[] src = new Object[8];
1236         Object[] dst = new Object[8];
1237         for (int i = 0; i &lt; 8; ++i) {
<a name="29" id="anc29"></a><span class="line-modified">1238             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1239         }
1240         test50(src, dst);
1241         verify(src, dst);
1242         if (!warmup) {
1243             Method m = tests.get(&quot;TestArrays::test50&quot;);
1244             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1245                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1246             }
1247         }
1248     }
1249 
1250     @Test
1251     public MyValue1[] test51(MyValue1[] va) {
<a name="30" id="anc30"></a><span class="line-modified">1252         // TODO 8244562: Remove cast as workaround once javac is fixed</span>
1253         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1254     }
1255 
1256     @DontCompile
1257     public void test51_verifier(boolean warmup) {
1258         int len = Math.abs(rI) % 10;
1259         MyValue1[] va = new MyValue1[len];
1260         for (int i = 0; i &lt; len; ++i) {
1261             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1262         }
1263         MyValue1[] result = test51(va);
1264         verify(va, result);
1265     }
1266 
1267     static final MyValue1[] test52_va = new MyValue1[8];
1268 
1269     @Test
1270     public MyValue1[] test52() {
<a name="31" id="anc31"></a><span class="line-modified">1271         // TODO 8244562: Remove cast as workaround once javac is fixed</span>
1272         return (MyValue1[])Arrays.copyOf(test52_va, 8, MyValue1[].class);
1273     }
1274 
1275     @DontCompile
1276     public void test52_verifier(boolean warmup) {
1277         for (int i = 0; i &lt; 8; ++i) {
1278             test52_va[i] = MyValue1.createWithFieldsInline(rI, rL);
1279         }
1280         MyValue1[] result = test52();
1281         verify(test52_va, result);
1282     }
1283 
1284     @Test
1285     public MyValue1[] test53(Object[] va) {
<a name="32" id="anc32"></a><span class="line-modified">1286         // TODO 8244562: Remove cast as workaround once javac is fixed</span>
1287         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1288     }
1289 
1290     @DontCompile
1291     public void test53_verifier(boolean warmup) {
1292         int len = Math.abs(rI) % 10;
1293         MyValue1[] va = new MyValue1[len];
1294         for (int i = 0; i &lt; len; ++i) {
1295             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1296         }
1297         MyValue1[] result = test53(va);
1298         verify(result, va);
1299     }
1300 
1301     @Test
1302     public Object[] test54(MyValue1[] va) {
1303         return Arrays.copyOf(va, va.length, Object[].class);
1304     }
1305 
1306     @DontCompile
1307     public void test54_verifier(boolean warmup) {
1308         int len = Math.abs(rI) % 10;
1309         MyValue1[] va = new MyValue1[len];
1310         for (int i = 0; i &lt; len; ++i) {
1311             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1312         }
1313         Object[] result = test54(va);
1314         verify(va, result);
1315     }
1316 
1317     @Test
1318     public Object[] test55(Object[] va) {
1319         return Arrays.copyOf(va, va.length, Object[].class);
1320     }
1321 
1322     @DontCompile
1323     public void test55_verifier(boolean warmup) {
1324         int len = Math.abs(rI) % 10;
1325         MyValue1[] va = new MyValue1[len];
1326         for (int i = 0; i &lt; len; ++i) {
1327             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1328         }
1329         Object[] result = test55(va);
1330         verify(va, result);
1331     }
1332 
1333     @Test
1334     public MyValue1[] test56(Object[] va) {
<a name="33" id="anc33"></a><span class="line-modified">1335         // TODO 8244562: Remove cast as workaround once javac is fixed</span>
1336         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1337     }
1338 
1339     @DontCompile
1340     public void test56_verifier(boolean warmup) {
1341         int len = Math.abs(rI) % 10;
1342         Object[] va = new Object[len];
1343         for (int i = 0; i &lt; len; ++i) {
1344             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1345         }
1346         MyValue1[] result = test56(va);
1347         verify(result, va);
1348     }
1349 
1350    @Test
1351     public Object[] test57(Object[] va, Class klass) {
1352         return Arrays.copyOf(va, va.length, klass);
1353     }
1354 
1355     @DontCompile
1356     public void test57_verifier(boolean warmup) {
1357         int len = Math.abs(rI) % 10;
1358         Object[] va = new MyValue1[len];
1359         for (int i = 0; i &lt; len; ++i) {
1360             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1361         }
1362         Object[] result = test57(va, MyValue1[].class);
1363         verify(va, result);
1364     }
1365 
1366     @Test
1367     public Object[] test58(MyValue1[] va, Class klass) {
1368         return Arrays.copyOf(va, va.length, klass);
1369     }
1370 
1371     @DontCompile
1372     public void test58_verifier(boolean warmup) {
1373         int len = Math.abs(rI) % 10;
1374         MyValue1[] va = new MyValue1[len];
1375         for (int i = 0; i &lt; len; ++i) {
1376             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1377         }
1378         for (int i = 0; i &lt; 10; i++) {
1379             Object[] result = test58(va, MyValue1[].class);
1380             verify(va, result);
1381         }
1382         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test58&quot;)) {
1383             Object[] result = test58(va, MyValue1[].class);
1384             verify(va, result);
1385         }
1386     }
1387 
1388     @Test
1389     public Object[] test59(MyValue1[] va) {
1390         return Arrays.copyOf(va, va.length+1, MyValue1[].class);
1391     }
1392 
1393     @DontCompile
1394     public void test59_verifier(boolean warmup) {
1395         int len = Math.abs(rI) % 10;
1396         MyValue1[] va = new MyValue1[len];
1397         MyValue1[] verif = new MyValue1[len+1];
1398         for (int i = 0; i &lt; len; ++i) {
1399             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1400             verif[i] = va[i];
1401         }
1402         Object[] result = test59(va);
1403         verify(verif, result);
1404     }
1405 
1406     @Test
1407     public Object[] test60(Object[] va, Class klass) {
1408         return Arrays.copyOf(va, va.length+1, klass);
1409     }
1410 
1411     @DontCompile
1412     public void test60_verifier(boolean warmup) {
1413         int len = Math.abs(rI) % 10;
1414         MyValue1[] va = new MyValue1[len];
1415         MyValue1[] verif = new MyValue1[len+1];
1416         for (int i = 0; i &lt; len; ++i) {
1417             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1418             verif[i] = (MyValue1)va[i];
1419         }
1420         Object[] result = test60(va, MyValue1[].class);
1421         verify(verif, result);
1422     }
1423 
1424     @Test
1425     public Object[] test61(Object[] va, Class klass) {
1426         return Arrays.copyOf(va, va.length+1, klass);
1427     }
1428 
1429     @DontCompile
1430     public void test61_verifier(boolean warmup) {
1431         int len = Math.abs(rI) % 10;
1432         Object[] va = new Integer[len];
1433         for (int i = 0; i &lt; len; ++i) {
1434             va[i] = new Integer(rI);
1435         }
1436         Object[] result = test61(va, Integer[].class);
1437         for (int i = 0; i &lt; va.length; ++i) {
1438             Asserts.assertEQ(va[i], result[i]);
1439         }
1440     }
1441 
1442     @ForceInline
1443     public Object[] test62_helper(int i, MyValue1[] va, Integer[] oa) {
1444         Object[] arr = null;
1445         if (i == 10) {
1446             arr = oa;
1447         } else {
1448             arr = va;
1449         }
1450         return arr;
1451     }
1452 
1453     @Test
1454     public Object[] test62(MyValue1[] va, Integer[] oa) {
1455         int i = 0;
1456         for (; i &lt; 10; i++);
1457 
1458         Object[] arr = test62_helper(i, va, oa);
1459 
1460         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1461     }
1462 
1463     @DontCompile
1464     public void test62_verifier(boolean warmup) {
1465         int len = Math.abs(rI) % 10;
1466         MyValue1[] va = new MyValue1[len];
1467         Integer[] oa = new Integer[len];
1468         for (int i = 0; i &lt; len; ++i) {
1469             oa[i] = new Integer(rI);
1470         }
1471         test62_helper(42, va, oa);
1472         Object[] result = test62(va, oa);
1473         for (int i = 0; i &lt; va.length; ++i) {
1474             Asserts.assertEQ(oa[i], result[i]);
1475         }
1476     }
1477 
1478     @ForceInline
1479     public Object[] test63_helper(int i, MyValue1[] va, Integer[] oa) {
1480         Object[] arr = null;
1481         if (i == 10) {
1482             arr = va;
1483         } else {
1484             arr = oa;
1485         }
1486         return arr;
1487     }
1488 
1489     @Test
1490     public Object[] test63(MyValue1[] va, Integer[] oa) {
1491         int i = 0;
1492         for (; i &lt; 10; i++);
1493 
1494         Object[] arr = test63_helper(i, va, oa);
1495 
1496         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1497     }
1498 
1499     @DontCompile
1500     public void test63_verifier(boolean warmup) {
1501         int len = Math.abs(rI) % 10;
1502         MyValue1[] va = new MyValue1[len];
1503         MyValue1[] verif = new MyValue1[len+1];
1504         for (int i = 0; i &lt; len; ++i) {
1505             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1506             verif[i] = va[i];
1507         }
1508         Integer[] oa = new Integer[len];
1509         test63_helper(42, va, oa);
1510         Object[] result = test63(va, oa);
1511         verify(verif, result);
1512     }
1513 
1514     // Test default initialization of inline type arrays: small array
1515     @Test
1516     public MyValue1[] test64() {
1517         return new MyValue1[8];
1518     }
1519 
1520     @DontCompile
1521     public void test64_verifier(boolean warmup) {
1522         MyValue1[] va = new MyValue1[8];
1523         MyValue1[] var = test64();
1524         for (int i = 0; i &lt; 8; ++i) {
1525             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1526         }
1527     }
1528 
1529     // Test default initialization of inline type arrays: large array
1530     @Test
1531     public MyValue1[] test65() {
1532         return new MyValue1[32];
1533     }
1534 
1535     @DontCompile
1536     public void test65_verifier(boolean warmup) {
1537         MyValue1[] va = new MyValue1[32];
1538         MyValue1[] var = test65();
1539         for (int i = 0; i &lt; 32; ++i) {
1540             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1541         }
1542     }
1543 
1544     // Check init store elimination
1545     @Test(match = { ALLOCA }, matchCount = { 1 })
1546     public MyValue1[] test66(MyValue1 vt) {
1547         MyValue1[] va = new MyValue1[1];
1548         va[0] = vt;
1549         return va;
1550     }
1551 
1552     @DontCompile
1553     public void test66_verifier(boolean warmup) {
1554         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI, rL);
1555         MyValue1[] va = test66(vt);
1556         Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());
1557     }
1558 
1559     // Zeroing elimination and arraycopy
1560     @Test
1561     public MyValue1[] test67(MyValue1[] src) {
1562         MyValue1[] dst = new MyValue1[16];
1563         System.arraycopy(src, 0, dst, 0, 13);
1564         return dst;
1565     }
1566 
1567     @DontCompile
1568     public void test67_verifier(boolean warmup) {
1569         MyValue1[] va = new MyValue1[16];
1570         MyValue1[] var = test67(va);
1571         for (int i = 0; i &lt; 16; ++i) {
1572             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1573         }
1574     }
1575 
1576     // A store with a default value can be eliminated
1577     @Test
1578     public MyValue1[] test68() {
1579         MyValue1[] va = new MyValue1[2];
1580         va[0] = va[1];
1581         return va;
1582     }
1583 
1584     @DontCompile
1585     public void test68_verifier(boolean warmup) {
1586         MyValue1[] va = new MyValue1[2];
1587         MyValue1[] var = test68();
1588         for (int i = 0; i &lt; 2; ++i) {
1589             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1590         }
1591     }
1592 
1593     // Requires individual stores to init array
1594     @Test
1595     public MyValue1[] test69(MyValue1 vt) {
1596         MyValue1[] va = new MyValue1[4];
1597         va[0] = vt;
1598         va[3] = vt;
1599         return va;
1600     }
1601 
1602     @DontCompile
1603     public void test69_verifier(boolean warmup) {
1604         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI, rL);
1605         MyValue1[] va = new MyValue1[4];
1606         va[0] = vt;
1607         va[3] = vt;
1608         MyValue1[] var = test69(vt);
1609         for (int i = 0; i &lt; va.length; ++i) {
1610             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1611         }
1612     }
1613 
1614     // A store with a default value can be eliminated: same as test68
1615     // but store is farther away from allocation
1616     @Test
1617     public MyValue1[] test70(MyValue1[] other) {
1618         other[1] = other[0];
1619         MyValue1[] va = new MyValue1[2];
1620         other[0] = va[1];
1621         va[0] = va[1];
1622         return va;
1623     }
1624 
1625     @DontCompile
1626     public void test70_verifier(boolean warmup) {
1627         MyValue1[] va = new MyValue1[2];
1628         MyValue1[] var = test70(va);
1629         for (int i = 0; i &lt; 2; ++i) {
1630             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1631         }
1632     }
1633 
1634     // EA needs to consider oop fields in flattened arrays
1635     @Test
1636     public void test71() {
1637         int len = 10;
1638         MyValue2[] src = new MyValue2[len];
1639         MyValue2[] dst = new MyValue2[len];
1640         for (int i = 0; i &lt; len; ++i) {
<a name="34" id="anc34"></a><span class="line-modified">1641             src[i] = MyValue2.createWithFieldsDontInline(rI+i, rD+i);</span>
1642         }
1643         System.arraycopy(src, 0, dst, 0, src.length);
1644         for (int i = 0; i &lt; len; ++i) {
1645             Asserts.assertEQ(src[i].hash(), dst[i].hash());
1646         }
1647     }
1648 
1649     @DontCompile
1650     public void test71_verifier(boolean warmup) {
1651         test71();
1652     }
1653 
1654     // Test EA with leaf call to &#39;store_unknown_inline&#39;
1655     @Test
1656     public void test72(Object[] o, boolean b, Object element) {
1657         Object[] arr1 = new Object[10];
1658         Object[] arr2 = new Object[10];
1659         if (b) {
1660             arr1 = o;
1661         }
1662         arr1[0] = element;
1663         arr2[0] = element;
1664     }
1665 
1666     @DontCompile
1667     public void test72_verifier(boolean warmup) {
1668         Object[] arr = new Object[1];
1669         Object elem = new Object();
1670         test72(arr, true, elem);
1671         test72(arr, false, elem);
1672     }
1673 
1674     @Test
1675     public void test73(Object[] oa, MyValue1 v, Object o) {
1676         // TestLWorld.test38 use a C1 Phi node for the array. This test
1677         // adds the case where the stored value is a C1 Phi node.
1678         Object o2 = (o == null) ? v : o;
1679         oa[0] = v;  // The stored value is known to be flattenable
1680         oa[1] = o;  // The stored value may be flattenable
1681         oa[2] = o2; // The stored value may be flattenable (a C1 Phi node)
1682         oa[0] = oa; // The stored value is known to be not flattenable (an Object[])
1683     }
1684 
1685     @DontCompile
1686     public void test73_verifier(boolean warmup) {
1687         MyValue1 v0 = MyValue1.createWithFieldsDontInline(rI, rL);
1688         MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);
1689         MyValue1[] arr = new MyValue1[3];
1690         try {
1691             test73(arr, v0, v1);
1692             throw new RuntimeException(&quot;ArrayStoreException expected&quot;);
1693         } catch (ArrayStoreException t) {
1694             // expected
1695         }
1696         Asserts.assertEQ(arr[0].hash(), v0.hash());
1697         Asserts.assertEQ(arr[1].hash(), v1.hash());
1698         Asserts.assertEQ(arr[2].hash(), v1.hash());
1699     }
1700 
1701     public static void test74Callee(MyValue1[] va) { }
1702 
1703     // Tests invoking unloaded method with inline type array in signature
1704     @Test
1705     @Warmup(0)
1706     public void test74(MethodHandle m, MyValue1[] va) throws Throwable {
1707         m.invoke(va);
1708     }
1709 
1710     @DontCompile
1711     public void test74_verifier(boolean warmup) throws Throwable {
1712         MethodHandle m = MethodHandles.lookup().findStatic(TestArrays.class, &quot;test74Callee&quot;, MethodType.methodType(void.class, MyValue1[].class));
1713         MyValue1[] va = new MyValue1[0];
1714         test74(m, va);
1715     }
1716 
1717     // Some more array clone tests
1718     @ForceInline
1719     public Object[] test75_helper(int i, MyValue1[] va, Integer[] oa) {
1720         Object[] arr = null;
1721         if (i == 10) {
1722             arr = oa;
1723         } else {
1724             arr = va;
1725         }
1726         return arr;
1727     }
1728 
1729     @Test
1730     public Object[] test75(MyValue1[] va, Integer[] oa) {
1731         int i = 0;
1732         for (; i &lt; 10; i++);
1733 
1734         Object[] arr = test75_helper(i, va, oa);
1735         return arr.clone();
1736     }
1737 
1738     @DontCompile
1739     public void test75_verifier(boolean warmup) {
1740         int len = Math.abs(rI) % 10;
1741         MyValue1[] va = new MyValue1[len];
1742         Integer[] oa = new Integer[len];
1743         for (int i = 0; i &lt; len; ++i) {
1744             oa[i] = new Integer(rI);
1745         }
1746         test75_helper(42, va, oa);
1747         Object[] result = test75(va, oa);
1748 
1749         for (int i = 0; i &lt; va.length; ++i) {
1750             Asserts.assertEQ(oa[i], result[i]);
1751             // Check that array has correct properties (null-ok)
1752             result[i] = null;
1753         }
1754     }
1755 
1756     @ForceInline
1757     public Object[] test76_helper(int i, MyValue1[] va, Integer[] oa) {
1758         Object[] arr = null;
1759         if (i == 10) {
1760             arr = va;
1761         } else {
1762             arr = oa;
1763         }
1764         return arr;
1765     }
1766 
1767     @Test
1768     public Object[] test76(MyValue1[] va, Integer[] oa) {
1769         int i = 0;
1770         for (; i &lt; 10; i++);
1771 
1772         Object[] arr = test76_helper(i, va, oa);
1773         return arr.clone();
1774     }
1775 
1776     @DontCompile
1777     public void test76_verifier(boolean warmup) {
1778         int len = Math.abs(rI) % 10;
1779         MyValue1[] va = new MyValue1[len];
1780         MyValue1[] verif = new MyValue1[len];
1781         for (int i = 0; i &lt; len; ++i) {
1782             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1783             verif[i] = va[i];
1784         }
1785         Integer[] oa = new Integer[len];
1786         test76_helper(42, va, oa);
1787         Object[] result = test76(va, oa);
1788         verify(verif, result);
1789         // Check that array has correct properties (null-free)
1790         if (len &gt; 0) {
1791             try {
1792                 result[0] = null;
1793                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
1794             } catch (NullPointerException e) {
1795                 // Expected
1796             }
1797         }
1798     }
1799 
1800     @Test
1801     public void test77() {
1802         MyValue1 v0 = MyValue1.createWithFieldsDontInline(rI, rL);
1803         MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);
1804         MyValue1[] arr = new MyValue1[1];
1805 
1806         Object[] oa = arr;
1807         Object o1 = v1;
1808         Object o = (o1 == null) ? v0 : o1;
1809 
1810         oa[0] = o; // For C1, due to IfOp optimization, the declared_type of o becomes NULL.
1811 
1812         Asserts.assertEQ(arr[0].hash(), v1.hash());
1813     }
1814 
1815 
1816     @DontCompile
1817     public void test77_verifier(boolean warmup) {
1818         test77();
1819     }
1820 
1821     @Test
1822     public long test78(MyValue1 v, int n) {
1823         long x = 0;
1824         for (int i = 0; i&lt;n; i++) {
1825         }
1826 
1827         MyValue1[] a = new MyValue1[n];
1828         a[0] = v;
1829         for (int i = 0; i&lt;n; i++) {
1830             x += a[i].hash(); // C1 PhiSimplifier changes &quot;a&quot; from a Phi node to a NewObjectArray node
1831         }
1832 
1833         return x;
1834     }
1835 
1836     @DontCompile
1837     public void test78_verifier(boolean warmup) {
1838         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
1839         Asserts.assertEQ(test78(v, 1), v.hash());
1840     }
1841 
1842     // Verify that casting an array element to a non-flattenable type marks the array as not-flat
1843     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_INLINE }, matchCount = { 1, 1 })
1844     @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE)
1845     public Object test79(Object[] array, int i) {
1846         Integer i1 = (Integer)array[0];
1847         Object o = array[1];
1848         return array[i];
1849     }
1850 
1851     @DontCompile
1852     public void test79_verifier(boolean warmup) {
1853         Integer i = new Integer(rI);
1854         Integer[] array = new Integer[2];
1855         array[1] = i;
1856         Object result = test79(array, 1);
1857         Asserts.assertEquals(result, i);
1858     }
1859 
1860     inline static class NotFlattenable {
1861         private final Object o1 = null;
1862         private final Object o2 = null;
1863         private final Object o3 = null;
1864         private final Object o4 = null;
1865         private final Object o5 = null;
1866         private final Object o6 = null;
1867     }
1868 
1869     // Same as test79 but with not-flattenable inline type
1870     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_INLINE }, matchCount = { 1, 1 })
1871     @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE)
1872     public Object test80(Object[] array, int i) {
1873         NotFlattenable vt = (NotFlattenable)array[0];
1874         Object o = array[1];
1875         return array[i];
1876     }
1877 
1878     @DontCompile
1879     public void test80_verifier(boolean warmup) {
1880         NotFlattenable vt = new NotFlattenable();
1881         NotFlattenable[] array = new NotFlattenable[2];
1882         array[1] = vt;
1883         Object result = test80(array, 1);
1884         Asserts.assertEquals(result, vt);
1885     }
1886 
1887     // Verify that writing an object of a non-inline, non-null type to an array marks the array as not-null-free and not-flat
1888     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
1889     public Object test81(Object[] array, Integer v, Object o, int i) {
1890         if (v == null) {
1891           return null;
1892         }
1893         array[0] = v;
1894         array[1] = array[0];
1895         array[2] = o;
1896         return array[i];
1897     }
1898 
1899     @DontCompile
1900     public void test81_verifier(boolean warmup) {
1901         Integer i = new Integer(rI);
1902         Integer[] array1 = new Integer[3];
1903         Object[] array2 = new Object[3];
1904         Object result = test81(array1, i, i, 0);
1905         Asserts.assertEquals(array1[0], i);
1906         Asserts.assertEquals(array1[1], i);
1907         Asserts.assertEquals(array1[2], i);
1908         Asserts.assertEquals(result, i);
1909         result = test81(array2, i, i, 1);
1910         Asserts.assertEquals(array2[0], i);
1911         Asserts.assertEquals(array2[1], i);
1912         Asserts.assertEquals(array2[2], i);
1913         Asserts.assertEquals(result, i);
1914     }
1915 
1916     // Verify that writing an object of a non-flattenable inline type to an array marks the array as not-flat
1917     @Test(valid = InlineTypePassFieldsAsArgsOn, failOn = ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE)
1918     @Test(valid = InlineTypePassFieldsAsArgsOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE)
1919     public Object test82(Object[] array, NotFlattenable vt, Object o, int i) {
1920         array[0] = vt;
1921         array[1] = array[0];
1922         array[2] = o;
1923         return array[i];
1924     }
1925 
1926     @DontCompile
1927     public void test82_verifier(boolean warmup) {
1928         NotFlattenable vt = new NotFlattenable();
1929         NotFlattenable[] array1 = new NotFlattenable[3];
1930         Object[] array2 = new Object[3];
1931         Object result = test82(array1, vt, vt, 0);
1932         Asserts.assertEquals(array1[0], vt);
1933         Asserts.assertEquals(array1[1], vt);
1934         Asserts.assertEquals(array1[2], vt);
1935         Asserts.assertEquals(result, vt);
1936         result = test82(array2, vt, vt, 1);
1937         Asserts.assertEquals(array2[0], vt);
1938         Asserts.assertEquals(array2[1], vt);
1939         Asserts.assertEquals(array2[2], vt);
1940         Asserts.assertEquals(result, vt);
1941     }
1942 
1943     // Verify that casting an array element to a non-inline type type marks the array as not-null-free and not-flat
1944     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_INLINE }, matchCount = { 1, 1 }, failOn = ALLOCA_G + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
1945     @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE + INLINE_ARRAY_NULL_GUARD)
1946     public void test83(Object[] array, Object o) {
1947         Integer i = (Integer)array[0];
1948         array[1] = o;
1949     }
1950 
1951     @DontCompile
1952     public void test83_verifier(boolean warmup) {
1953         Integer i = new Integer(rI);
1954         Integer[] array1 = new Integer[2];
1955         Object[] array2 = new Object[2];
1956         test83(array1, i);
1957         Asserts.assertEquals(array1[1], i);
1958         test83(array2, null);
1959         Asserts.assertEquals(array2[1], null);
1960     }
1961 
1962     // Verify that writing constant null into an array marks the array as not-null-free and not-flat
1963     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE, match = { INLINE_ARRAY_NULL_GUARD }, matchCount = { 1 })
1964     public Object test84(Object[] array, int i) {
1965         array[0] = null;
1966         array[1] = null;
1967         return array[i];
1968     }
1969 
1970     @DontCompile
1971     public void test84_verifier(boolean warmup) {
1972         NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];
1973         Object[] array2 = new Object[2];
1974         Object result = test84(array1, 0);
1975         Asserts.assertEquals(array1[0], null);
1976         Asserts.assertEquals(result, null);
1977         result = test84(array2, 1);
1978         Asserts.assertEquals(array2[0], null);
1979         Asserts.assertEquals(result, null);
1980         if (!warmup) {
1981             NotFlattenable[] array3 = new NotFlattenable[2];
1982             try {
1983                 test84(array3, 1);
1984                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
1985             } catch (NullPointerException e) {
1986                 // Expected
1987             }
1988         }
1989     }
1990 
1991     // Same as test84 but with branches
1992     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE, match = { INLINE_ARRAY_NULL_GUARD }, matchCount = { 2 })
1993     public void test85(Object[] array, Object o, boolean b) {
1994         if (b) {
1995             array[0] = null;
1996         } else {
1997             array[1] = null;
1998         }
1999         array[1] = o;
2000     }
2001 
2002     @DontCompile
2003     public void test85_verifier(boolean warmup) {
2004         Integer i = new Integer(rI);
2005         Integer[] array1 = new Integer[2];
2006         Object[] array2 = new Object[2];
2007         test85(array1, i, true);
2008         Asserts.assertEquals(array1[1], i);
2009         test85(array1, null, false);
2010         Asserts.assertEquals(array1[1], null);
2011         test85(array2, i, true);
2012         Asserts.assertEquals(array2[1], i);
2013         test85(array2, null, false);
2014         Asserts.assertEquals(array2[1], null);
2015         if (!warmup) {
2016             NotFlattenable[] array3 = new NotFlattenable[2];
2017             try {
2018                 test85(array3, null, true);
2019                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2020             } catch (NullPointerException e) {
2021                 // Expected
2022             }
2023         }
2024     }
2025 
2026     // Same as test85 but with not-flattenable inline type array
2027     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE, match = { INLINE_ARRAY_NULL_GUARD }, matchCount = { 2 })
2028     public void test86(NotFlattenable.ref[] array, NotFlattenable.ref o, boolean b) {
2029         if (b) {
2030             array[0] = null;
2031         } else {
2032             array[1] = null;
2033         }
2034         array[1] = o;
2035     }
2036 
2037     @DontCompile
2038     public void test86_verifier(boolean warmup) {
2039         NotFlattenable vt = new NotFlattenable();
2040         NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];
2041         test86(array1, vt, true);
2042         Asserts.assertEquals(array1[1], vt);
2043         test86(array1, null, false);
2044         Asserts.assertEquals(array1[1], null);
2045         if (!warmup) {
2046             NotFlattenable[] array2 = new NotFlattenable[2];
2047             try {
2048                 test86(array2, null, true);
2049                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2050             } catch (NullPointerException e) {
2051                 // Expected
2052             }
2053         }
2054     }
2055 
2056     // Same as test85 but with inline type array
2057     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_INLINE + STORE_UNKNOWN_INLINE, match = { INLINE_ARRAY_NULL_GUARD }, matchCount = { 2 })
2058     public void test87(MyValue1.ref[] array, MyValue1.ref o, boolean b) {
2059         if (b) {
2060             array[0] = null;
2061         } else {
2062             array[1] = null;
2063         }
2064         array[1] = o;
2065     }
2066 
2067     @DontCompile
2068     public void test87_verifier(boolean warmup) {
2069         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
2070         MyValue1.ref[] array1 = new MyValue1.ref[2];
2071         test87(array1, vt, true);
2072         Asserts.assertEquals(array1[1], vt);
2073         test87(array1, null, false);
2074         Asserts.assertEquals(array1[1], null);
2075         if (!warmup) {
2076             MyValue1[] array2 = new MyValue1[2];
2077             try {
2078                 test87(array2, null, true);
2079                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2080             } catch (NullPointerException e) {
2081                 // Expected
2082             }
2083         }
2084     }
2085 
2086     // Additional correctness tests to make sure we have the required null checks
2087     @Test()
2088     public void test88(Object[] array, Integer v) {
2089         array[0] = v;
2090     }
2091 
2092     @DontCompile
2093     public void test88_verifier(boolean warmup) {
2094         Integer[] array1 = new Integer[1];
2095         Object[] array2 = new Object[1];
2096         test88(array1, null);
2097         Asserts.assertEquals(array1[0], null);
2098         test88(array2, null);
2099         Asserts.assertEquals(array2[0], null);
2100         if (!warmup) {
2101             MyValue1[] array3 = new MyValue1[1];
2102             try {
2103                 test88(array3, null);
2104                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2105             } catch (NullPointerException e) {
2106                 // Expected
2107             }
2108         }
2109     }
2110 
2111     @Test()
2112     public void test89(MyValue1.ref[] array, Integer v) {
2113         Object o = v;
2114         array[0] = (MyValue1.ref)o;
2115     }
2116 
2117     @DontCompile
2118     public void test89_verifier(boolean warmup) {
2119         MyValue1.ref[] array1 = new MyValue1.ref[1];
2120         test89(array1, null);
2121         Asserts.assertEquals(array1[0], null);
2122         if (!warmup) {
2123             MyValue1[] array2 = new MyValue1[1];
2124             try {
2125                 test89(array2, null);
2126                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2127             } catch (NullPointerException e) {
2128                 // Expected
2129             }
2130         }
2131     }
2132 
2133     @Test
2134     public boolean test90() {
2135         boolean b = true;
2136 
2137         MyValue1[] qArray = new MyValue1[0];
2138         MyValue1.ref[] lArray = new MyValue1.ref[0];
2139 
2140         b = b &amp;&amp; (qArray instanceof MyValue1[]);
2141         b = b &amp;&amp; (lArray instanceof MyValue1.ref[]);
2142 
2143         MyValue1[][] qArray2 = new MyValue1[0][0];
2144         MyValue1.ref[][] lArray2 = new MyValue1.ref[0][0];
2145 
2146         b = b &amp;&amp; (qArray2 instanceof MyValue1[][]);
2147         b = b &amp;&amp; (lArray2 instanceof MyValue1.ref[][]);
2148 
2149         return b;
2150     }
2151 
2152     @DontCompile
2153     public void test90_verifier(boolean warmup) {
2154         Asserts.assertEQ(test90(), true);
2155     }
2156 
2157     inline static final class Test91Value {
2158         public final int f0;
2159         public final int f1;
2160         public final int f2;
2161         public final int f3;
2162         public final int f4;
2163         public final int f5;
2164 
2165         public Test91Value(int i) {
2166             this.f0 = i;
2167             this.f1 = i;
2168             this.f2 = i;
2169             this.f3 = i;
2170             this.f4 = i;
2171             this.f5 = i;
2172         }
2173 
2174         public void verify() {
2175             if ((f0 != f1) || (f1 != f2) || (f2 != f3) || (f3 != f4) || (f4 != f5)) {
2176                 throw new RuntimeException(&quot;test91 failed&quot;);
2177             }
2178         }
2179     }
2180 
2181     // Test anti-dependencies between loads and stores from flattened array
2182     @Test
2183     @Warmup(0)
2184     public int test91(Test91Value[] array, int lo, int val) {
2185         int i = 3;
2186         while (lo &lt; i) {
2187             Test91Value tmp = array[lo];
2188             array[lo++] = array[i];
2189             array[i--] = tmp;
2190         }
2191         return val;
2192     }
2193 
2194     @DontCompile
2195     public void test91_verifier(boolean warmup) {
2196         Test91Value[] array = new Test91Value[5];
2197         for (int i = 0; i &lt; 5; ++i) {
2198             array[i] = new Test91Value(i);
2199             array[i].verify();
2200         }
2201         Asserts.assertEQ(test91(array, 0, 5), 5);
2202         for (int i = 0; i &lt; 5; ++i) {
2203             array[i].verify();
2204         }
2205     }
2206 
2207     @Test
2208     public void test92(Object[] src, Object[] dst) {
2209         System.arraycopy(src, 0, dst, 0, src.length);
2210     }
2211 
2212     @DontCompile
2213     public void test92_verifier(boolean warmup) {
2214         MyValue1[] a = new MyValue1[1];
2215         MyValue1[] b = new MyValue1[1];
2216         try {
2217             test92(a, null);
2218             throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2219         } catch (NullPointerException expected) {}
2220 
2221         try {
2222             test92(null, b);
2223             throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2224         } catch (NullPointerException expected) {}
2225 
2226         a[0] = MyValue1.createWithFieldsInline(rI, rL);
2227         test92(a, b);
2228         verify(a, b);
2229     }
2230 
2231     // Same as test30 but accessing all elements of the non-escaping array
2232     @Test
2233     public long test93(MyValue2[] src, boolean flag) {
2234         MyValue2[] dst = new MyValue2[10];
2235         System.arraycopy(src, 0, dst, 0, 10);
2236         if (flag) {  }
2237         return dst[0].hash() + dst[1].hash() + dst[2].hash() + dst[3].hash() + dst[4].hash() +
2238                dst[5].hash() + dst[6].hash() + dst[7].hash() + dst[8].hash() + dst[9].hash();
2239     }
2240 
2241     @DontCompile
2242     public void test93_verifier(boolean warmup) {
2243         MyValue2[] src = new MyValue2[10];
2244         for (int i = 0; i &lt; 10; ++i) {
<a name="35" id="anc35"></a><span class="line-modified">2245             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
2246         }
2247         long res = test93(src, !warmup);
2248         long expected = 0;
2249         for (int i = 0; i &lt; 10; ++i) {
2250             expected += src[i].hash();
2251         }
2252         Asserts.assertEQ(res, expected);
2253     }
2254 
2255     // Same as test93 but with variable source array offset
2256     @Test
2257     public long test94(MyValue2[] src, int i, boolean flag) {
2258         MyValue2[] dst = new MyValue2[10];
2259         System.arraycopy(src, i, dst, 0, 1);
2260         if (flag) {  }
2261         return dst[0].hash() + dst[1].hash() + dst[2].hash() + dst[3].hash() + dst[4].hash() +
2262                dst[5].hash() + dst[6].hash() + dst[7].hash() + dst[8].hash() + dst[9].hash();
2263     }
2264 
2265     @DontCompile
2266     public void test94_verifier(boolean warmup) {
2267         MyValue2[] src = new MyValue2[10];
2268         for (int i = 0; i &lt; 10; ++i) {
<a name="36" id="anc36"></a><span class="line-modified">2269             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
2270         }
2271         for (int i = 0; i &lt; 10; ++i) {
2272             long res = test94(src, i, !warmup);
2273             long expected = src[i].hash() + 9*MyValue2.default.hash();
2274             Asserts.assertEQ(res, expected);
2275         }
2276     }
2277 
2278     // Test propagation of not null-free/flat information
2279     @Test(failOn = CHECKCAST_ARRAY)
2280     public MyValue1[] test95(Object[] array) {
2281         array[0] = null;
2282         // Always throws a ClassCastException because we just successfully
2283         // stored null and therefore the array can&#39;t be an inline type array.
2284         return (MyValue1[])array;
2285     }
2286 
2287     @DontCompile
2288     public void test95_verifier(boolean warmup) {
2289         MyValue1[] array1 = new MyValue1[1];
2290         Integer[] array2 = new Integer[1];
2291         try {
2292             test95(array1);
2293             throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2294         } catch (NullPointerException e) {
2295             // Expected
2296         }
2297         try {
2298             test95(array2);
2299             throw new RuntimeException(&quot;Should throw ClassCastException&quot;);
2300         } catch (ClassCastException e) {
2301             // Expected
2302         }
2303     }
2304 
2305     // Same as test95 but with cmp user of cast result
2306     @Test(failOn = CHECKCAST_ARRAY)
2307     public boolean test96(Object[] array) {
2308         array[0] = null;
2309         // Always throws a ClassCastException because we just successfully
2310         // stored null and therefore the array can&#39;t be an inline type array.
2311         MyValue1[] casted = (MyValue1[])array;
2312         return casted != null;
2313     }
2314 
2315     @DontCompile
2316     public void test96_verifier(boolean warmup) {
2317         MyValue1[] array1 = new MyValue1[1];
2318         Integer[] array2 = new Integer[1];
2319         try {
2320             test96(array1);
2321             throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2322         } catch (NullPointerException e) {
2323             // Expected
2324         }
2325         try {
2326             test96(array2);
2327             throw new RuntimeException(&quot;Should throw ClassCastException&quot;);
2328         } catch (ClassCastException e) {
2329             // Expected
2330         }
2331     }
2332 
2333     // Same as test95 but with instanceof instead of cast
2334     @Test(failOn = CHECKCAST_ARRAY)
2335     public boolean test97(Object[] array) {
2336         array[0] = 42;
2337         // Always throws a ClassCastException because we just successfully stored
2338         // a non-inline value and therefore the array can&#39;t be an inline type array.
2339         return array instanceof MyValue1[];
2340     }
2341 
2342     @DontCompile
2343     public void test97_verifier(boolean warmup) {
2344         MyValue1[] array1 = new MyValue1[1];
2345         Integer[] array2 = new Integer[1];
2346         try {
2347             test97(array1);
2348             throw new RuntimeException(&quot;Should throw ArrayStoreException&quot;);
2349         } catch (ArrayStoreException e) {
2350             // Expected
2351         }
2352         boolean res = test97(array2);
2353         Asserts.assertFalse(res);
2354     }
2355 
2356     // Same as test95 but with non-flattenable store
2357     @Test(valid = InlineTypeArrayFlattenOn, failOn = CHECKCAST_ARRAY)
2358     @Test(valid = InlineTypeArrayFlattenOff)
2359     public MyValue1[] test98(Object[] array) {
2360         array[0] = NotFlattenable.default;
2361         // Always throws a ClassCastException because we just successfully stored a
2362         // non-flattenable value and therefore the array can&#39;t be a flat array.
2363         return (MyValue1[])array;
2364     }
2365 
2366     @DontCompile
2367     public void test98_verifier(boolean warmup) {
2368         MyValue1[] array1 = new MyValue1[1];
2369         NotFlattenable[] array2 = new NotFlattenable[1];
2370         try {
2371             test98(array1);
2372             throw new RuntimeException(&quot;Should throw ArrayStoreException&quot;);
2373         } catch (ArrayStoreException e) {
2374             // Expected
2375         }
2376         try {
2377             test98(array2);
2378             throw new RuntimeException(&quot;Should throw ClassCastException&quot;);
2379         } catch (ClassCastException e) {
2380             // Expected
2381         }
2382     }
2383 
2384     // Same as test98 but with cmp user of cast result
2385     @Test(valid = InlineTypeArrayFlattenOn, failOn = CHECKCAST_ARRAY)
2386     @Test(valid = InlineTypeArrayFlattenOff)
2387     public boolean test99(Object[] array) {
2388         array[0] = NotFlattenable.default;
2389         // Always throws a ClassCastException because we just successfully stored a
2390         // non-flattenable value and therefore the array can&#39;t be a flat array.
2391         MyValue1[] casted = (MyValue1[])array;
2392         return casted != null;
2393     }
2394 
2395     @DontCompile
2396     public void test99_verifier(boolean warmup) {
2397         MyValue1[] array1 = new MyValue1[1];
2398         NotFlattenable[] array2 = new NotFlattenable[1];
2399         try {
2400             test99(array1);
2401             throw new RuntimeException(&quot;Should throw ArrayStoreException&quot;);
2402         } catch (ArrayStoreException e) {
2403             // Expected
2404         }
2405         try {
2406             test99(array2);
2407             throw new RuntimeException(&quot;Should throw ClassCastException&quot;);
2408         } catch (ClassCastException e) {
2409             // Expected
2410         }
2411     }
2412 
2413     // Same as test98 but with instanceof instead of cast
2414     @Test(valid = InlineTypeArrayFlattenOn, failOn = CHECKCAST_ARRAY)
2415     @Test(valid = InlineTypeArrayFlattenOff)
2416     public boolean test100(Object[] array) {
2417         array[0] = NotFlattenable.default;
2418         // Always throws a ClassCastException because we just successfully stored a
2419         // non-flattenable value and therefore the array can&#39;t be a flat array.
2420         return array instanceof MyValue1[];
2421     }
2422 
2423     @DontCompile
2424     public void test100_verifier(boolean warmup) {
2425         MyValue1[] array1 = new MyValue1[1];
2426         NotFlattenable[] array2 = new NotFlattenable[1];
2427         try {
2428             test100(array1);
2429             throw new RuntimeException(&quot;Should throw ArrayStoreException&quot;);
2430         } catch (ArrayStoreException e) {
2431             // Expected
2432         }
2433         boolean res = test100(array2);
2434         Asserts.assertFalse(res);
2435     }
2436 
2437     // Test that CHECKCAST_ARRAY matching works as expected
2438     @Test(match = { CHECKCAST_ARRAY }, matchCount = { 1 })
2439     public boolean test101(Object[] array) {
2440         return array instanceof MyValue1[];
2441     }
2442 
2443     @DontCompile
2444     public void test101_verifier(boolean warmup) {
2445         MyValue1[] array1 = new MyValue1[1];
2446         NotFlattenable[] array2 = new NotFlattenable[1];
2447         Asserts.assertTrue(test101(array1));
2448         Asserts.assertFalse(test101(array2));
2449     }
2450 }
<a name="37" id="anc37"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="37" type="hidden" />
</body>
</html>