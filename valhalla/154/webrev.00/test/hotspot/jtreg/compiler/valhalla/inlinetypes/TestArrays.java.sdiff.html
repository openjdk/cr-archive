<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestArrayAccessDeopt.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestBasicFunctionality.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  88     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
  89     @Test(valid = InlineTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
  90     public MyValue1[] test1(int len) {
  91         MyValue1[] va = new MyValue1[len];
  92         for (int i = 0; i &lt; len; ++i) {
  93             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  94         }
  95         return va;
  96     }
  97 
  98     @DontCompile
  99     public void test1_verifier(boolean warmup) {
 100         int len = Math.abs(rI % 10);
 101         MyValue1[] va = test1(len);
 102         for (int i = 0; i &lt; len; ++i) {
 103             Asserts.assertEQ(va[i].hash(), hash());
 104         }
 105     }
 106 
 107     // Test creation of an inline type array and element access
<span class="line-modified"> 108     // TODO 8227588</span>
<span class="line-removed"> 109     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>
<span class="line-removed"> 110     @Test(valid = InlineTypeArrayFlattenOff)</span>
 111     public long test2() {
 112         MyValue1[] va = new MyValue1[1];
 113         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 114         return va[0].hash();
 115     }
 116 
 117     @DontCompile
 118     public void test2_verifier(boolean warmup) {
 119         long result = test2();
 120         Asserts.assertEQ(result, hash());
 121     }
 122 
 123     // Test receiving an inline type array from the interpreter,
 124     // updating its elements in a loop and computing a hash.
 125     @Test(failOn = ALLOCA)
 126     public long test3(MyValue1[] va) {
 127         long result = 0;
 128         for (int i = 0; i &lt; 10; ++i) {
 129             result += va[i].hash();
 130             va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
</pre>
<hr />
<pre>
 520             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 521         }
 522         test20(src, dst);
 523         for (int i = 0; i &lt; len; ++i) {
 524             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 525         }
 526     }
 527 
 528     // arraycopy() of inline type array with no oop field
 529     @Test
 530     public void test21(MyValue2[] src, MyValue2[] dst) {
 531         System.arraycopy(src, 0, dst, 0, src.length);
 532     }
 533 
 534     @DontCompile
 535     public void test21_verifier(boolean warmup) {
 536         int len = Math.abs(rI) % 10;
 537         MyValue2[] src = new MyValue2[len];
 538         MyValue2[] dst = new MyValue2[len];
 539         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified"> 540             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 541         }
 542         test21(src, dst);
 543         for (int i = 0; i &lt; len; ++i) {
 544             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 545         }
 546     }
 547 
 548     // arraycopy() of inline type array with oop field and tightly
 549     // coupled allocation as dest
 550     @Test
 551     public MyValue1[] test22(MyValue1[] src) {
 552         MyValue1[] dst = new MyValue1[src.length];
 553         System.arraycopy(src, 0, dst, 0, src.length);
 554         return dst;
 555     }
 556 
 557     @DontCompile
 558     public void test22_verifier(boolean warmup) {
 559         int len = Math.abs(rI) % 10;
 560         MyValue1[] src = new MyValue1[len];
</pre>
<hr />
<pre>
 603         for (int i = 0; i &lt; len; ++i) {
 604             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 605         }
 606         test24(src, dst);
 607         for (int i = 0; i &lt; len; ++i) {
 608             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 609         }
 610     }
 611 
 612     // short arraycopy() with no oop field
 613     @Test
 614     public void test25(MyValue2[] src, MyValue2[] dst) {
 615         System.arraycopy(src, 0, dst, 0, 8);
 616     }
 617 
 618     @DontCompile
 619     public void test25_verifier(boolean warmup) {
 620         MyValue2[] src = new MyValue2[8];
 621         MyValue2[] dst = new MyValue2[8];
 622         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified"> 623             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 624         }
 625         test25(src, dst);
 626         for (int i = 0; i &lt; 8; ++i) {
 627             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 628         }
 629     }
 630 
 631     // short arraycopy() with oop fields
 632     @Test
 633     public void test26(MyValue1[] src, MyValue1[] dst) {
 634         System.arraycopy(src, 0, dst, 0, 8);
 635     }
 636 
 637     @DontCompile
 638     public void test26_verifier(boolean warmup) {
 639         MyValue1[] src = new MyValue1[8];
 640         MyValue1[] dst = new MyValue1[8];
 641         for (int i = 0; i &lt; 8; ++i) {
 642             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 643         }
</pre>
<hr />
<pre>
 650     // short arraycopy() with oop fields and offsets
 651     @Test
 652     public void test27(MyValue1[] src, MyValue1[] dst) {
 653         System.arraycopy(src, 1, dst, 2, 6);
 654     }
 655 
 656     @DontCompile
 657     public void test27_verifier(boolean warmup) {
 658         MyValue1[] src = new MyValue1[8];
 659         MyValue1[] dst = new MyValue1[8];
 660         for (int i = 0; i &lt; 8; ++i) {
 661             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 662         }
 663         test27(src, dst);
 664         for (int i = 2; i &lt; 8; ++i) {
 665             Asserts.assertEQ(src[i-1].hash(), dst[i].hash());
 666         }
 667     }
 668 
 669     // non escaping allocations
<span class="line-modified"> 670     // TODO ZGC does not support the clone intrinsic, remove this once JDK-8232896 is fixed</span>
 671     @Test(valid = ZGCOff, failOn = ALLOCA + LOOP + LOAD + TRAP)
 672     @Test(valid = ZGCOn)
 673     public MyValue2 test28() {
 674         MyValue2[] src = new MyValue2[10];
<span class="line-modified"> 675         src[0] = MyValue2.createWithFieldsInline(rI, false);</span>
 676         MyValue2[] dst = (MyValue2[])src.clone();
 677         return dst[0];
 678     }
 679 
 680     @DontCompile
 681     public void test28_verifier(boolean warmup) {
<span class="line-modified"> 682         MyValue2 v = MyValue2.createWithFieldsInline(rI, false);</span>
 683         MyValue2 result = test28();
 684         Asserts.assertEQ(result.hash(), v.hash());
 685     }
 686 
 687     // non escaping allocations
 688     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?

 689     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOCA + LOOP + LOAD + TRAP)
<span class="line-modified"> 690     @Test(valid = InlineTypeArrayFlattenOff)</span>
 691     public MyValue2 test29(MyValue2[] src) {
 692         MyValue2[] dst = new MyValue2[10];
 693         System.arraycopy(src, 0, dst, 0, 10);
 694         return dst[0];
 695     }
 696 
 697     @DontCompile
 698     public void test29_verifier(boolean warmup) {
 699         MyValue2[] src = new MyValue2[10];
 700         for (int i = 0; i &lt; 10; ++i) {
<span class="line-modified"> 701             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 702         }
 703         MyValue2 v = test29(src);
 704         Asserts.assertEQ(src[0].hash(), v.hash());
 705     }
 706 
 707     // non escaping allocation with uncommon trap that needs
 708     // eliminated inline type array element as debug info
 709     @Test
 710     @Warmup(10000)
 711     public MyValue2 test30(MyValue2[] src, boolean flag) {
 712         MyValue2[] dst = new MyValue2[10];
 713         System.arraycopy(src, 0, dst, 0, 10);
 714         if (flag) { }
 715         return dst[0];
 716     }
 717 
 718     @DontCompile
 719     public void test30_verifier(boolean warmup) {
 720         MyValue2[] src = new MyValue2[10];
 721         for (int i = 0; i &lt; 10; ++i) {
<span class="line-modified"> 722             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 723         }
 724         MyValue2 v = test30(src, !warmup);
 725         Asserts.assertEQ(src[0].hash(), v.hash());
 726     }
 727 
 728     // non escaping allocation with memory phi
<span class="line-modified"> 729     // TODO 8227588</span>
<span class="line-removed"> 730     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>
<span class="line-removed"> 731     @Test(valid = InlineTypeArrayFlattenOff)</span>
 732     public long test31(boolean b, boolean deopt) {
 733         MyValue2[] src = new MyValue2[1];
 734         if (b) {
<span class="line-modified"> 735             src[0] = MyValue2.createWithFieldsInline(rI, true);</span>
 736         } else {
<span class="line-modified"> 737             src[0] = MyValue2.createWithFieldsInline(rI, false);</span>
 738         }
 739         if (deopt) {
 740             // uncommon trap
 741             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test31&quot;));
 742         }
 743         return src[0].hash();
 744     }
 745 
 746     @DontCompile
 747     public void test31_verifier(boolean warmup) {
<span class="line-modified"> 748         MyValue2 v1 = MyValue2.createWithFieldsInline(rI, true);</span>
 749         long result1 = test31(true, !warmup);
 750         Asserts.assertEQ(result1, v1.hash());
<span class="line-modified"> 751         MyValue2 v2 = MyValue2.createWithFieldsInline(rI, false);</span>
 752         long result2 = test31(false, !warmup);
 753         Asserts.assertEQ(result2, v2.hash());
 754     }
 755 
 756     // Tests with Object arrays and clone/arraycopy
 757     // clone() as stub call
 758     @Test
 759     public Object[] test32(Object[] va) {
 760         return va.clone();
 761     }
 762 
 763     @DontCompile
 764     public void test32_verifier(boolean warmup) {
 765         int len = Math.abs(rI) % 10;
 766         MyValue1[] va = new MyValue1[len];
 767         for (int i = 0; i &lt; len; ++i) {
 768             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 769         }
 770         MyValue1[] result = (MyValue1[])test32(va);
 771         for (int i = 0; i &lt; len; ++i) {
</pre>
<hr />
<pre>
 904         }
 905         test35(src, dst, src.length);
 906         verify(src, dst);
 907         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test35&quot;)) {
 908             test35(src, dst, src.length);
 909             verify(src, dst);
 910         }
 911     }
 912 
 913     @Test
 914     public void test36(Object src, MyValue2[] dst) {
 915         System.arraycopy(src, 0, dst, 0, dst.length);
 916     }
 917 
 918     @DontCompile
 919     public void test36_verifier(boolean warmup) {
 920         int len = Math.abs(rI) % 10;
 921         MyValue2[] src = new MyValue2[len];
 922         MyValue2[] dst = new MyValue2[len];
 923         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified"> 924             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 925         }
 926         test36(src, dst);
 927         verify(src, dst);
 928         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test36&quot;)) {
 929             test36(src, dst);
 930             verify(src, dst);
 931         }
 932     }
 933 
 934     @Test
 935     public void test37(MyValue2[] src, Object dst) {
 936         System.arraycopy(src, 0, dst, 0, src.length);
 937     }
 938 
 939     @DontCompile
 940     public void test37_verifier(boolean warmup) {
 941         int len = Math.abs(rI) % 10;
 942         MyValue2[] src = new MyValue2[len];
 943         MyValue2[] dst = new MyValue2[len];
 944         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified"> 945             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 946         }
 947         test37(src, dst);
 948         verify(src, dst);
 949         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test37&quot;)) {
 950             test37(src, dst);
 951             verify(src, dst);
 952         }
 953     }
 954 
 955     @Test
 956     @Warmup(1) // Avoid early compilation
 957     public void test38(Object src, MyValue2[] dst) {
 958         System.arraycopy(src, 0, dst, 0, dst.length);
 959     }
 960 
 961     @DontCompile
 962     public void test38_verifier(boolean warmup) {
 963         int len = Math.abs(rI) % 10;
 964         Object[] src = new Object[len];
 965         MyValue2[] dst = new MyValue2[len];
 966         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified"> 967             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 968         }
 969         test38(src, dst);
 970         verify(dst, src);
 971         if (!warmup) {
 972             Method m = tests.get(&quot;TestArrays::test38&quot;);
 973             assertDeoptimizedByC2(m);
 974             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
 975             test38(src, dst);
 976             verify(dst, src);
 977             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
 978                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
 979             }
 980         }
 981     }
 982 
 983     @Test
 984     public void test39(MyValue2[] src, Object dst) {
 985         System.arraycopy(src, 0, dst, 0, src.length);
 986     }
 987 
 988     @DontCompile
 989     public void test39_verifier(boolean warmup) {
 990         int len = Math.abs(rI) % 10;
 991         MyValue2[] src = new MyValue2[len];
 992         Object[] dst = new Object[len];
 993         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified"> 994             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
 995         }
 996         test39(src, dst);
 997         verify(src, dst);
 998         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test39&quot;)) {
 999             test39(src, dst);
1000             verify(src, dst);
1001         }
1002     }
1003 
1004     @Test
1005     @Warmup(1) // Avoid early compilation
1006     public void test40(Object[] src, Object dst) {
1007         System.arraycopy(src, 0, dst, 0, src.length);
1008     }
1009 
1010     @DontCompile
1011     public void test40_verifier(boolean warmup) {
1012         int len = Math.abs(rI) % 10;
1013         Object[] src = new Object[len];
1014         MyValue2[] dst = new MyValue2[len];
1015         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified">1016             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1017         }
1018         test40(src, dst);
1019         verify(dst, src);
1020         if (!warmup) {
1021             Method m = tests.get(&quot;TestArrays::test40&quot;);
1022             assertDeoptimizedByC2(m);
1023             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1024             test40(src, dst);
1025             verify(dst, src);
1026             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1027                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1028             }
1029         }
1030     }
1031 
1032     @Test
1033     public void test41(Object src, Object[] dst) {
1034         System.arraycopy(src, 0, dst, 0, dst.length);
1035     }
1036 
1037     @DontCompile
1038     public void test41_verifier(boolean warmup) {
1039         int len = Math.abs(rI) % 10;
1040         MyValue2[] src = new MyValue2[len];
1041         Object[] dst = new Object[len];
1042         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified">1043             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1044         }
1045         test41(src, dst);
1046         verify(src, dst);
1047         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test41&quot;)) {
1048             test41(src, dst);
1049             verify(src, dst);
1050         }
1051     }
1052 
1053     @Test
1054     public void test42(Object[] src, Object[] dst) {
1055         System.arraycopy(src, 0, dst, 0, src.length);
1056     }
1057 
1058     @DontCompile
1059     public void test42_verifier(boolean warmup) {
1060         int len = Math.abs(rI) % 10;
1061         Object[] src = new Object[len];
1062         Object[] dst = new Object[len];
1063         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified">1064             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1065         }
1066         test42(src, dst);
1067         verify(src, dst);
1068         if (!warmup) {
1069             Method m = tests.get(&quot;TestArrays::test42&quot;);
1070             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1071                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1072             }
1073         }
1074     }
1075 
1076     // short arraycopy()&#39;s
1077     @Test
1078     public void test43(Object src, Object dst) {
1079         System.arraycopy(src, 0, dst, 0, 8);
1080     }
1081 
1082     @DontCompile
1083     public void test43_verifier(boolean warmup) {
1084         MyValue1[] src = new MyValue1[8];
</pre>
<hr />
<pre>
1087             src[i] = MyValue1.createWithFieldsInline(rI, rL);
1088         }
1089         test43(src, dst);
1090         verify(src, dst);
1091         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test43&quot;)) {
1092             test43(src, dst);
1093             verify(src, dst);
1094         }
1095     }
1096 
1097     @Test
1098     public void test44(Object src, MyValue2[] dst) {
1099         System.arraycopy(src, 0, dst, 0, 8);
1100     }
1101 
1102     @DontCompile
1103     public void test44_verifier(boolean warmup) {
1104         MyValue2[] src = new MyValue2[8];
1105         MyValue2[] dst = new MyValue2[8];
1106         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1107             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1108         }
1109         test44(src, dst);
1110         verify(src, dst);
1111         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test44&quot;)) {
1112             test44(src, dst);
1113             verify(src, dst);
1114         }
1115     }
1116 
1117     @Test
1118     public void test45(MyValue2[] src, Object dst) {
1119         System.arraycopy(src, 0, dst, 0, 8);
1120     }
1121 
1122     @DontCompile
1123     public void test45_verifier(boolean warmup) {
1124         MyValue2[] src = new MyValue2[8];
1125         MyValue2[] dst = new MyValue2[8];
1126         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1127             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1128         }
1129         test45(src, dst);
1130         verify(src, dst);
1131         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test45&quot;)) {
1132             test45(src, dst);
1133             verify(src, dst);
1134         }
1135     }
1136 
1137     @Test
1138     @Warmup(1) // Avoid early compilation
1139     public void test46(Object[] src, MyValue2[] dst) {
1140         System.arraycopy(src, 0, dst, 0, 8);
1141     }
1142 
1143     @DontCompile
1144     public void test46_verifier(boolean warmup) {
1145         Object[] src = new Object[8];
1146         MyValue2[] dst = new MyValue2[8];
1147         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1148             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1149         }
1150         test46(src, dst);
1151         verify(dst, src);
1152         if (!warmup) {
1153             Method m = tests.get(&quot;TestArrays::test46&quot;);
1154             assertDeoptimizedByC2(m);
1155             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1156             test46(src, dst);
1157             verify(dst, src);
1158             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1159                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1160             }
1161         }
1162     }
1163 
1164     @Test
1165     public void test47(MyValue2[] src, Object[] dst) {
1166         System.arraycopy(src, 0, dst, 0, 8);
1167     }
1168 
1169     @DontCompile
1170     public void test47_verifier(boolean warmup) {
1171         MyValue2[] src = new MyValue2[8];
1172         Object[] dst = new Object[8];
1173         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1174             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1175         }
1176         test47(src, dst);
1177         verify(src, dst);
1178         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test47&quot;)) {
1179             test47(src, dst);
1180             verify(src, dst);
1181         }
1182     }
1183 
1184     @Test
1185     @Warmup(1) // Avoid early compilation
1186     public void test48(Object[] src, Object dst) {
1187         System.arraycopy(src, 0, dst, 0, 8);
1188     }
1189 
1190     @DontCompile
1191     public void test48_verifier(boolean warmup) {
1192         Object[] src = new Object[8];
1193         MyValue2[] dst = new MyValue2[8];
1194         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1195             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1196         }
1197         test48(src, dst);
1198         verify(dst, src);
1199         if (!warmup) {
1200             Method m = tests.get(&quot;TestArrays::test48&quot;);
1201             assertDeoptimizedByC2(m);
1202             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1203             test48(src, dst);
1204             verify(dst, src);
1205             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1206                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1207             }
1208         }
1209     }
1210 
1211     @Test
1212     public void test49(Object src, Object[] dst) {
1213         System.arraycopy(src, 0, dst, 0, 8);
1214     }
1215 
1216     @DontCompile
1217     public void test49_verifier(boolean warmup) {
1218         MyValue2[] src = new MyValue2[8];
1219         Object[] dst = new Object[8];
1220         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1221             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1222         }
1223         test49(src, dst);
1224         verify(src, dst);
1225         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test49&quot;)) {
1226             test49(src, dst);
1227             verify(src, dst);
1228         }
1229     }
1230 
1231     @Test
1232     public void test50(Object[] src, Object[] dst) {
1233         System.arraycopy(src, 0, dst, 0, 8);
1234     }
1235 
1236     @DontCompile
1237     public void test50_verifier(boolean warmup) {
1238         Object[] src = new Object[8];
1239         Object[] dst = new Object[8];
1240         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1241             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);</span>
1242         }
1243         test50(src, dst);
1244         verify(src, dst);
1245         if (!warmup) {
1246             Method m = tests.get(&quot;TestArrays::test50&quot;);
1247             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1248                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1249             }
1250         }
1251     }
1252 
1253     @Test
1254     public MyValue1[] test51(MyValue1[] va) {
<span class="line-modified">1255         // TODO Remove cast as workaround once javac is fixed</span>
1256         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1257     }
1258 
1259     @DontCompile
1260     public void test51_verifier(boolean warmup) {
1261         int len = Math.abs(rI) % 10;
1262         MyValue1[] va = new MyValue1[len];
1263         for (int i = 0; i &lt; len; ++i) {
1264             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1265         }
1266         MyValue1[] result = test51(va);
1267         verify(va, result);
1268     }
1269 
1270     static final MyValue1[] test52_va = new MyValue1[8];
1271 
1272     @Test
1273     public MyValue1[] test52() {
<span class="line-modified">1274         // TODO Remove cast as workaround once javac is fixed</span>
1275         return (MyValue1[])Arrays.copyOf(test52_va, 8, MyValue1[].class);
1276     }
1277 
1278     @DontCompile
1279     public void test52_verifier(boolean warmup) {
1280         for (int i = 0; i &lt; 8; ++i) {
1281             test52_va[i] = MyValue1.createWithFieldsInline(rI, rL);
1282         }
1283         MyValue1[] result = test52();
1284         verify(test52_va, result);
1285     }
1286 
1287     @Test
1288     public MyValue1[] test53(Object[] va) {
<span class="line-modified">1289         // TODO Remove cast as workaround once javac is fixed</span>
1290         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1291     }
1292 
1293     @DontCompile
1294     public void test53_verifier(boolean warmup) {
1295         int len = Math.abs(rI) % 10;
1296         MyValue1[] va = new MyValue1[len];
1297         for (int i = 0; i &lt; len; ++i) {
1298             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1299         }
1300         MyValue1[] result = test53(va);
1301         verify(result, va);
1302     }
1303 
1304     @Test
1305     public Object[] test54(MyValue1[] va) {
1306         return Arrays.copyOf(va, va.length, Object[].class);
1307     }
1308 
1309     @DontCompile
</pre>
<hr />
<pre>
1318     }
1319 
1320     @Test
1321     public Object[] test55(Object[] va) {
1322         return Arrays.copyOf(va, va.length, Object[].class);
1323     }
1324 
1325     @DontCompile
1326     public void test55_verifier(boolean warmup) {
1327         int len = Math.abs(rI) % 10;
1328         MyValue1[] va = new MyValue1[len];
1329         for (int i = 0; i &lt; len; ++i) {
1330             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1331         }
1332         Object[] result = test55(va);
1333         verify(va, result);
1334     }
1335 
1336     @Test
1337     public MyValue1[] test56(Object[] va) {
<span class="line-modified">1338         // TODO Remove cast as workaround once javac is fixed</span>
1339         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1340     }
1341 
1342     @DontCompile
1343     public void test56_verifier(boolean warmup) {
1344         int len = Math.abs(rI) % 10;
1345         Object[] va = new Object[len];
1346         for (int i = 0; i &lt; len; ++i) {
1347             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1348         }
1349         MyValue1[] result = test56(va);
1350         verify(result, va);
1351     }
1352 
1353    @Test
1354     public Object[] test57(Object[] va, Class klass) {
1355         return Arrays.copyOf(va, va.length, klass);
1356     }
1357 
1358     @DontCompile
</pre>
<hr />
<pre>
1624         va[0] = va[1];
1625         return va;
1626     }
1627 
1628     @DontCompile
1629     public void test70_verifier(boolean warmup) {
1630         MyValue1[] va = new MyValue1[2];
1631         MyValue1[] var = test70(va);
1632         for (int i = 0; i &lt; 2; ++i) {
1633             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1634         }
1635     }
1636 
1637     // EA needs to consider oop fields in flattened arrays
1638     @Test
1639     public void test71() {
1640         int len = 10;
1641         MyValue2[] src = new MyValue2[len];
1642         MyValue2[] dst = new MyValue2[len];
1643         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified">1644             src[i] = MyValue2.createWithFieldsDontInline(rI, (i % 2) == 0);</span>
1645         }
1646         System.arraycopy(src, 0, dst, 0, src.length);
1647         for (int i = 0; i &lt; len; ++i) {
1648             Asserts.assertEQ(src[i].hash(), dst[i].hash());
1649         }
1650     }
1651 
1652     @DontCompile
1653     public void test71_verifier(boolean warmup) {
1654         test71();
1655     }
1656 
1657     // Test EA with leaf call to &#39;store_unknown_inline&#39;
1658     @Test
1659     public void test72(Object[] o, boolean b, Object element) {
1660         Object[] arr1 = new Object[10];
1661         Object[] arr2 = new Object[10];
1662         if (b) {
1663             arr1 = o;
1664         }
</pre>
<hr />
<pre>
2228 
2229         a[0] = MyValue1.createWithFieldsInline(rI, rL);
2230         test92(a, b);
2231         verify(a, b);
2232     }
2233 
2234     // Same as test30 but accessing all elements of the non-escaping array
2235     @Test
2236     public long test93(MyValue2[] src, boolean flag) {
2237         MyValue2[] dst = new MyValue2[10];
2238         System.arraycopy(src, 0, dst, 0, 10);
2239         if (flag) {  }
2240         return dst[0].hash() + dst[1].hash() + dst[2].hash() + dst[3].hash() + dst[4].hash() +
2241                dst[5].hash() + dst[6].hash() + dst[7].hash() + dst[8].hash() + dst[9].hash();
2242     }
2243 
2244     @DontCompile
2245     public void test93_verifier(boolean warmup) {
2246         MyValue2[] src = new MyValue2[10];
2247         for (int i = 0; i &lt; 10; ++i) {
<span class="line-modified">2248             src[i] = MyValue2.createWithFieldsInline(rI, (rI % 2) == 0);</span>
2249         }
2250         long res = test93(src, !warmup);
2251         long expected = 0;
2252         for (int i = 0; i &lt; 10; ++i) {
2253             expected += src[i].hash();
2254         }
2255         Asserts.assertEQ(res, expected);
2256     }
2257 
2258     // Same as test93 but with variable source array offset
2259     @Test
2260     public long test94(MyValue2[] src, int i, boolean flag) {
2261         MyValue2[] dst = new MyValue2[10];
2262         System.arraycopy(src, i, dst, 0, 1);
2263         if (flag) {  }
2264         return dst[0].hash() + dst[1].hash() + dst[2].hash() + dst[3].hash() + dst[4].hash() +
2265                dst[5].hash() + dst[6].hash() + dst[7].hash() + dst[8].hash() + dst[9].hash();
2266     }
2267 
2268     @DontCompile
2269     public void test94_verifier(boolean warmup) {
2270         MyValue2[] src = new MyValue2[10];
2271         for (int i = 0; i &lt; 10; ++i) {
<span class="line-modified">2272             src[i] = MyValue2.createWithFieldsInline(i, (i % 2) == 0);</span>
2273         }
2274         for (int i = 0; i &lt; 10; ++i) {
2275             long res = test94(src, i, !warmup);
2276             long expected = src[i].hash() + 9*MyValue2.default.hash();
2277             Asserts.assertEQ(res, expected);
2278         }
2279     }
2280 
2281     // Test propagation of not null-free/flat information
2282     @Test(failOn = CHECKCAST_ARRAY)
2283     public MyValue1[] test95(Object[] array) {
2284         array[0] = null;
2285         // Always throws a ClassCastException because we just successfully
2286         // stored null and therefore the array can&#39;t be an inline type array.
2287         return (MyValue1[])array;
2288     }
2289 
2290     @DontCompile
2291     public void test95_verifier(boolean warmup) {
2292         MyValue1[] array1 = new MyValue1[1];
</pre>
</td>
<td>
<hr />
<pre>
  88     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
  89     @Test(valid = InlineTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
  90     public MyValue1[] test1(int len) {
  91         MyValue1[] va = new MyValue1[len];
  92         for (int i = 0; i &lt; len; ++i) {
  93             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  94         }
  95         return va;
  96     }
  97 
  98     @DontCompile
  99     public void test1_verifier(boolean warmup) {
 100         int len = Math.abs(rI % 10);
 101         MyValue1[] va = test1(len);
 102         for (int i = 0; i &lt; len; ++i) {
 103             Asserts.assertEQ(va[i].hash(), hash());
 104         }
 105     }
 106 
 107     // Test creation of an inline type array and element access
<span class="line-modified"> 108     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>


 109     public long test2() {
 110         MyValue1[] va = new MyValue1[1];
 111         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 112         return va[0].hash();
 113     }
 114 
 115     @DontCompile
 116     public void test2_verifier(boolean warmup) {
 117         long result = test2();
 118         Asserts.assertEQ(result, hash());
 119     }
 120 
 121     // Test receiving an inline type array from the interpreter,
 122     // updating its elements in a loop and computing a hash.
 123     @Test(failOn = ALLOCA)
 124     public long test3(MyValue1[] va) {
 125         long result = 0;
 126         for (int i = 0; i &lt; 10; ++i) {
 127             result += va[i].hash();
 128             va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
</pre>
<hr />
<pre>
 518             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 519         }
 520         test20(src, dst);
 521         for (int i = 0; i &lt; len; ++i) {
 522             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 523         }
 524     }
 525 
 526     // arraycopy() of inline type array with no oop field
 527     @Test
 528     public void test21(MyValue2[] src, MyValue2[] dst) {
 529         System.arraycopy(src, 0, dst, 0, src.length);
 530     }
 531 
 532     @DontCompile
 533     public void test21_verifier(boolean warmup) {
 534         int len = Math.abs(rI) % 10;
 535         MyValue2[] src = new MyValue2[len];
 536         MyValue2[] dst = new MyValue2[len];
 537         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified"> 538             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 539         }
 540         test21(src, dst);
 541         for (int i = 0; i &lt; len; ++i) {
 542             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 543         }
 544     }
 545 
 546     // arraycopy() of inline type array with oop field and tightly
 547     // coupled allocation as dest
 548     @Test
 549     public MyValue1[] test22(MyValue1[] src) {
 550         MyValue1[] dst = new MyValue1[src.length];
 551         System.arraycopy(src, 0, dst, 0, src.length);
 552         return dst;
 553     }
 554 
 555     @DontCompile
 556     public void test22_verifier(boolean warmup) {
 557         int len = Math.abs(rI) % 10;
 558         MyValue1[] src = new MyValue1[len];
</pre>
<hr />
<pre>
 601         for (int i = 0; i &lt; len; ++i) {
 602             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 603         }
 604         test24(src, dst);
 605         for (int i = 0; i &lt; len; ++i) {
 606             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 607         }
 608     }
 609 
 610     // short arraycopy() with no oop field
 611     @Test
 612     public void test25(MyValue2[] src, MyValue2[] dst) {
 613         System.arraycopy(src, 0, dst, 0, 8);
 614     }
 615 
 616     @DontCompile
 617     public void test25_verifier(boolean warmup) {
 618         MyValue2[] src = new MyValue2[8];
 619         MyValue2[] dst = new MyValue2[8];
 620         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified"> 621             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 622         }
 623         test25(src, dst);
 624         for (int i = 0; i &lt; 8; ++i) {
 625             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 626         }
 627     }
 628 
 629     // short arraycopy() with oop fields
 630     @Test
 631     public void test26(MyValue1[] src, MyValue1[] dst) {
 632         System.arraycopy(src, 0, dst, 0, 8);
 633     }
 634 
 635     @DontCompile
 636     public void test26_verifier(boolean warmup) {
 637         MyValue1[] src = new MyValue1[8];
 638         MyValue1[] dst = new MyValue1[8];
 639         for (int i = 0; i &lt; 8; ++i) {
 640             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 641         }
</pre>
<hr />
<pre>
 648     // short arraycopy() with oop fields and offsets
 649     @Test
 650     public void test27(MyValue1[] src, MyValue1[] dst) {
 651         System.arraycopy(src, 1, dst, 2, 6);
 652     }
 653 
 654     @DontCompile
 655     public void test27_verifier(boolean warmup) {
 656         MyValue1[] src = new MyValue1[8];
 657         MyValue1[] dst = new MyValue1[8];
 658         for (int i = 0; i &lt; 8; ++i) {
 659             src[i] = MyValue1.createWithFieldsInline(rI, rL);
 660         }
 661         test27(src, dst);
 662         for (int i = 2; i &lt; 8; ++i) {
 663             Asserts.assertEQ(src[i-1].hash(), dst[i].hash());
 664         }
 665     }
 666 
 667     // non escaping allocations
<span class="line-modified"> 668     // TODO 8252027: Make sure this is optimized with ZGC</span>
 669     @Test(valid = ZGCOff, failOn = ALLOCA + LOOP + LOAD + TRAP)
 670     @Test(valid = ZGCOn)
 671     public MyValue2 test28() {
 672         MyValue2[] src = new MyValue2[10];
<span class="line-modified"> 673         src[0] = MyValue2.createWithFieldsInline(rI, rD);</span>
 674         MyValue2[] dst = (MyValue2[])src.clone();
 675         return dst[0];
 676     }
 677 
 678     @DontCompile
 679     public void test28_verifier(boolean warmup) {
<span class="line-modified"> 680         MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);</span>
 681         MyValue2 result = test28();
 682         Asserts.assertEQ(result.hash(), v.hash());
 683     }
 684 
 685     // non escaping allocations
 686     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
<span class="line-added"> 687     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>
 688     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOCA + LOOP + LOAD + TRAP)
<span class="line-modified"> 689     @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOCA + LOOP + TRAP)</span>
 690     public MyValue2 test29(MyValue2[] src) {
 691         MyValue2[] dst = new MyValue2[10];
 692         System.arraycopy(src, 0, dst, 0, 10);
 693         return dst[0];
 694     }
 695 
 696     @DontCompile
 697     public void test29_verifier(boolean warmup) {
 698         MyValue2[] src = new MyValue2[10];
 699         for (int i = 0; i &lt; 10; ++i) {
<span class="line-modified"> 700             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 701         }
 702         MyValue2 v = test29(src);
 703         Asserts.assertEQ(src[0].hash(), v.hash());
 704     }
 705 
 706     // non escaping allocation with uncommon trap that needs
 707     // eliminated inline type array element as debug info
 708     @Test
 709     @Warmup(10000)
 710     public MyValue2 test30(MyValue2[] src, boolean flag) {
 711         MyValue2[] dst = new MyValue2[10];
 712         System.arraycopy(src, 0, dst, 0, 10);
 713         if (flag) { }
 714         return dst[0];
 715     }
 716 
 717     @DontCompile
 718     public void test30_verifier(boolean warmup) {
 719         MyValue2[] src = new MyValue2[10];
 720         for (int i = 0; i &lt; 10; ++i) {
<span class="line-modified"> 721             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 722         }
 723         MyValue2 v = test30(src, !warmup);
 724         Asserts.assertEQ(src[0].hash(), v.hash());
 725     }
 726 
 727     // non escaping allocation with memory phi
<span class="line-modified"> 728     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)</span>


 729     public long test31(boolean b, boolean deopt) {
 730         MyValue2[] src = new MyValue2[1];
 731         if (b) {
<span class="line-modified"> 732             src[0] = MyValue2.createWithFieldsInline(rI, rD);</span>
 733         } else {
<span class="line-modified"> 734             src[0] = MyValue2.createWithFieldsInline(rI+1, rD+1);</span>
 735         }
 736         if (deopt) {
 737             // uncommon trap
 738             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test31&quot;));
 739         }
 740         return src[0].hash();
 741     }
 742 
 743     @DontCompile
 744     public void test31_verifier(boolean warmup) {
<span class="line-modified"> 745         MyValue2 v1 = MyValue2.createWithFieldsInline(rI, rD);</span>
 746         long result1 = test31(true, !warmup);
 747         Asserts.assertEQ(result1, v1.hash());
<span class="line-modified"> 748         MyValue2 v2 = MyValue2.createWithFieldsInline(rI+1, rD+1);</span>
 749         long result2 = test31(false, !warmup);
 750         Asserts.assertEQ(result2, v2.hash());
 751     }
 752 
 753     // Tests with Object arrays and clone/arraycopy
 754     // clone() as stub call
 755     @Test
 756     public Object[] test32(Object[] va) {
 757         return va.clone();
 758     }
 759 
 760     @DontCompile
 761     public void test32_verifier(boolean warmup) {
 762         int len = Math.abs(rI) % 10;
 763         MyValue1[] va = new MyValue1[len];
 764         for (int i = 0; i &lt; len; ++i) {
 765             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 766         }
 767         MyValue1[] result = (MyValue1[])test32(va);
 768         for (int i = 0; i &lt; len; ++i) {
</pre>
<hr />
<pre>
 901         }
 902         test35(src, dst, src.length);
 903         verify(src, dst);
 904         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test35&quot;)) {
 905             test35(src, dst, src.length);
 906             verify(src, dst);
 907         }
 908     }
 909 
 910     @Test
 911     public void test36(Object src, MyValue2[] dst) {
 912         System.arraycopy(src, 0, dst, 0, dst.length);
 913     }
 914 
 915     @DontCompile
 916     public void test36_verifier(boolean warmup) {
 917         int len = Math.abs(rI) % 10;
 918         MyValue2[] src = new MyValue2[len];
 919         MyValue2[] dst = new MyValue2[len];
 920         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified"> 921             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 922         }
 923         test36(src, dst);
 924         verify(src, dst);
 925         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test36&quot;)) {
 926             test36(src, dst);
 927             verify(src, dst);
 928         }
 929     }
 930 
 931     @Test
 932     public void test37(MyValue2[] src, Object dst) {
 933         System.arraycopy(src, 0, dst, 0, src.length);
 934     }
 935 
 936     @DontCompile
 937     public void test37_verifier(boolean warmup) {
 938         int len = Math.abs(rI) % 10;
 939         MyValue2[] src = new MyValue2[len];
 940         MyValue2[] dst = new MyValue2[len];
 941         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified"> 942             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 943         }
 944         test37(src, dst);
 945         verify(src, dst);
 946         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test37&quot;)) {
 947             test37(src, dst);
 948             verify(src, dst);
 949         }
 950     }
 951 
 952     @Test
 953     @Warmup(1) // Avoid early compilation
 954     public void test38(Object src, MyValue2[] dst) {
 955         System.arraycopy(src, 0, dst, 0, dst.length);
 956     }
 957 
 958     @DontCompile
 959     public void test38_verifier(boolean warmup) {
 960         int len = Math.abs(rI) % 10;
 961         Object[] src = new Object[len];
 962         MyValue2[] dst = new MyValue2[len];
 963         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified"> 964             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 965         }
 966         test38(src, dst);
 967         verify(dst, src);
 968         if (!warmup) {
 969             Method m = tests.get(&quot;TestArrays::test38&quot;);
 970             assertDeoptimizedByC2(m);
 971             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
 972             test38(src, dst);
 973             verify(dst, src);
 974             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
 975                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
 976             }
 977         }
 978     }
 979 
 980     @Test
 981     public void test39(MyValue2[] src, Object dst) {
 982         System.arraycopy(src, 0, dst, 0, src.length);
 983     }
 984 
 985     @DontCompile
 986     public void test39_verifier(boolean warmup) {
 987         int len = Math.abs(rI) % 10;
 988         MyValue2[] src = new MyValue2[len];
 989         Object[] dst = new Object[len];
 990         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified"> 991             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
 992         }
 993         test39(src, dst);
 994         verify(src, dst);
 995         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test39&quot;)) {
 996             test39(src, dst);
 997             verify(src, dst);
 998         }
 999     }
1000 
1001     @Test
1002     @Warmup(1) // Avoid early compilation
1003     public void test40(Object[] src, Object dst) {
1004         System.arraycopy(src, 0, dst, 0, src.length);
1005     }
1006 
1007     @DontCompile
1008     public void test40_verifier(boolean warmup) {
1009         int len = Math.abs(rI) % 10;
1010         Object[] src = new Object[len];
1011         MyValue2[] dst = new MyValue2[len];
1012         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified">1013             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1014         }
1015         test40(src, dst);
1016         verify(dst, src);
1017         if (!warmup) {
1018             Method m = tests.get(&quot;TestArrays::test40&quot;);
1019             assertDeoptimizedByC2(m);
1020             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1021             test40(src, dst);
1022             verify(dst, src);
1023             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1024                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1025             }
1026         }
1027     }
1028 
1029     @Test
1030     public void test41(Object src, Object[] dst) {
1031         System.arraycopy(src, 0, dst, 0, dst.length);
1032     }
1033 
1034     @DontCompile
1035     public void test41_verifier(boolean warmup) {
1036         int len = Math.abs(rI) % 10;
1037         MyValue2[] src = new MyValue2[len];
1038         Object[] dst = new Object[len];
1039         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified">1040             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1041         }
1042         test41(src, dst);
1043         verify(src, dst);
1044         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test41&quot;)) {
1045             test41(src, dst);
1046             verify(src, dst);
1047         }
1048     }
1049 
1050     @Test
1051     public void test42(Object[] src, Object[] dst) {
1052         System.arraycopy(src, 0, dst, 0, src.length);
1053     }
1054 
1055     @DontCompile
1056     public void test42_verifier(boolean warmup) {
1057         int len = Math.abs(rI) % 10;
1058         Object[] src = new Object[len];
1059         Object[] dst = new Object[len];
1060         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified">1061             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1062         }
1063         test42(src, dst);
1064         verify(src, dst);
1065         if (!warmup) {
1066             Method m = tests.get(&quot;TestArrays::test42&quot;);
1067             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1068                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1069             }
1070         }
1071     }
1072 
1073     // short arraycopy()&#39;s
1074     @Test
1075     public void test43(Object src, Object dst) {
1076         System.arraycopy(src, 0, dst, 0, 8);
1077     }
1078 
1079     @DontCompile
1080     public void test43_verifier(boolean warmup) {
1081         MyValue1[] src = new MyValue1[8];
</pre>
<hr />
<pre>
1084             src[i] = MyValue1.createWithFieldsInline(rI, rL);
1085         }
1086         test43(src, dst);
1087         verify(src, dst);
1088         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test43&quot;)) {
1089             test43(src, dst);
1090             verify(src, dst);
1091         }
1092     }
1093 
1094     @Test
1095     public void test44(Object src, MyValue2[] dst) {
1096         System.arraycopy(src, 0, dst, 0, 8);
1097     }
1098 
1099     @DontCompile
1100     public void test44_verifier(boolean warmup) {
1101         MyValue2[] src = new MyValue2[8];
1102         MyValue2[] dst = new MyValue2[8];
1103         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1104             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1105         }
1106         test44(src, dst);
1107         verify(src, dst);
1108         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test44&quot;)) {
1109             test44(src, dst);
1110             verify(src, dst);
1111         }
1112     }
1113 
1114     @Test
1115     public void test45(MyValue2[] src, Object dst) {
1116         System.arraycopy(src, 0, dst, 0, 8);
1117     }
1118 
1119     @DontCompile
1120     public void test45_verifier(boolean warmup) {
1121         MyValue2[] src = new MyValue2[8];
1122         MyValue2[] dst = new MyValue2[8];
1123         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1124             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1125         }
1126         test45(src, dst);
1127         verify(src, dst);
1128         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test45&quot;)) {
1129             test45(src, dst);
1130             verify(src, dst);
1131         }
1132     }
1133 
1134     @Test
1135     @Warmup(1) // Avoid early compilation
1136     public void test46(Object[] src, MyValue2[] dst) {
1137         System.arraycopy(src, 0, dst, 0, 8);
1138     }
1139 
1140     @DontCompile
1141     public void test46_verifier(boolean warmup) {
1142         Object[] src = new Object[8];
1143         MyValue2[] dst = new MyValue2[8];
1144         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1145             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1146         }
1147         test46(src, dst);
1148         verify(dst, src);
1149         if (!warmup) {
1150             Method m = tests.get(&quot;TestArrays::test46&quot;);
1151             assertDeoptimizedByC2(m);
1152             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1153             test46(src, dst);
1154             verify(dst, src);
1155             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1156                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1157             }
1158         }
1159     }
1160 
1161     @Test
1162     public void test47(MyValue2[] src, Object[] dst) {
1163         System.arraycopy(src, 0, dst, 0, 8);
1164     }
1165 
1166     @DontCompile
1167     public void test47_verifier(boolean warmup) {
1168         MyValue2[] src = new MyValue2[8];
1169         Object[] dst = new Object[8];
1170         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1171             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1172         }
1173         test47(src, dst);
1174         verify(src, dst);
1175         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test47&quot;)) {
1176             test47(src, dst);
1177             verify(src, dst);
1178         }
1179     }
1180 
1181     @Test
1182     @Warmup(1) // Avoid early compilation
1183     public void test48(Object[] src, Object dst) {
1184         System.arraycopy(src, 0, dst, 0, 8);
1185     }
1186 
1187     @DontCompile
1188     public void test48_verifier(boolean warmup) {
1189         Object[] src = new Object[8];
1190         MyValue2[] dst = new MyValue2[8];
1191         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1192             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1193         }
1194         test48(src, dst);
1195         verify(dst, src);
1196         if (!warmup) {
1197             Method m = tests.get(&quot;TestArrays::test48&quot;);
1198             assertDeoptimizedByC2(m);
1199             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1200             test48(src, dst);
1201             verify(dst, src);
1202             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1203                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1204             }
1205         }
1206     }
1207 
1208     @Test
1209     public void test49(Object src, Object[] dst) {
1210         System.arraycopy(src, 0, dst, 0, 8);
1211     }
1212 
1213     @DontCompile
1214     public void test49_verifier(boolean warmup) {
1215         MyValue2[] src = new MyValue2[8];
1216         Object[] dst = new Object[8];
1217         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1218             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1219         }
1220         test49(src, dst);
1221         verify(src, dst);
1222         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test49&quot;)) {
1223             test49(src, dst);
1224             verify(src, dst);
1225         }
1226     }
1227 
1228     @Test
1229     public void test50(Object[] src, Object[] dst) {
1230         System.arraycopy(src, 0, dst, 0, 8);
1231     }
1232 
1233     @DontCompile
1234     public void test50_verifier(boolean warmup) {
1235         Object[] src = new Object[8];
1236         Object[] dst = new Object[8];
1237         for (int i = 0; i &lt; 8; ++i) {
<span class="line-modified">1238             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
1239         }
1240         test50(src, dst);
1241         verify(src, dst);
1242         if (!warmup) {
1243             Method m = tests.get(&quot;TestArrays::test50&quot;);
1244             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1245                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1246             }
1247         }
1248     }
1249 
1250     @Test
1251     public MyValue1[] test51(MyValue1[] va) {
<span class="line-modified">1252         // TODO 8244562: Remove cast as workaround once javac is fixed</span>
1253         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1254     }
1255 
1256     @DontCompile
1257     public void test51_verifier(boolean warmup) {
1258         int len = Math.abs(rI) % 10;
1259         MyValue1[] va = new MyValue1[len];
1260         for (int i = 0; i &lt; len; ++i) {
1261             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1262         }
1263         MyValue1[] result = test51(va);
1264         verify(va, result);
1265     }
1266 
1267     static final MyValue1[] test52_va = new MyValue1[8];
1268 
1269     @Test
1270     public MyValue1[] test52() {
<span class="line-modified">1271         // TODO 8244562: Remove cast as workaround once javac is fixed</span>
1272         return (MyValue1[])Arrays.copyOf(test52_va, 8, MyValue1[].class);
1273     }
1274 
1275     @DontCompile
1276     public void test52_verifier(boolean warmup) {
1277         for (int i = 0; i &lt; 8; ++i) {
1278             test52_va[i] = MyValue1.createWithFieldsInline(rI, rL);
1279         }
1280         MyValue1[] result = test52();
1281         verify(test52_va, result);
1282     }
1283 
1284     @Test
1285     public MyValue1[] test53(Object[] va) {
<span class="line-modified">1286         // TODO 8244562: Remove cast as workaround once javac is fixed</span>
1287         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1288     }
1289 
1290     @DontCompile
1291     public void test53_verifier(boolean warmup) {
1292         int len = Math.abs(rI) % 10;
1293         MyValue1[] va = new MyValue1[len];
1294         for (int i = 0; i &lt; len; ++i) {
1295             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1296         }
1297         MyValue1[] result = test53(va);
1298         verify(result, va);
1299     }
1300 
1301     @Test
1302     public Object[] test54(MyValue1[] va) {
1303         return Arrays.copyOf(va, va.length, Object[].class);
1304     }
1305 
1306     @DontCompile
</pre>
<hr />
<pre>
1315     }
1316 
1317     @Test
1318     public Object[] test55(Object[] va) {
1319         return Arrays.copyOf(va, va.length, Object[].class);
1320     }
1321 
1322     @DontCompile
1323     public void test55_verifier(boolean warmup) {
1324         int len = Math.abs(rI) % 10;
1325         MyValue1[] va = new MyValue1[len];
1326         for (int i = 0; i &lt; len; ++i) {
1327             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1328         }
1329         Object[] result = test55(va);
1330         verify(va, result);
1331     }
1332 
1333     @Test
1334     public MyValue1[] test56(Object[] va) {
<span class="line-modified">1335         // TODO 8244562: Remove cast as workaround once javac is fixed</span>
1336         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
1337     }
1338 
1339     @DontCompile
1340     public void test56_verifier(boolean warmup) {
1341         int len = Math.abs(rI) % 10;
1342         Object[] va = new Object[len];
1343         for (int i = 0; i &lt; len; ++i) {
1344             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1345         }
1346         MyValue1[] result = test56(va);
1347         verify(result, va);
1348     }
1349 
1350    @Test
1351     public Object[] test57(Object[] va, Class klass) {
1352         return Arrays.copyOf(va, va.length, klass);
1353     }
1354 
1355     @DontCompile
</pre>
<hr />
<pre>
1621         va[0] = va[1];
1622         return va;
1623     }
1624 
1625     @DontCompile
1626     public void test70_verifier(boolean warmup) {
1627         MyValue1[] va = new MyValue1[2];
1628         MyValue1[] var = test70(va);
1629         for (int i = 0; i &lt; 2; ++i) {
1630             Asserts.assertEQ(va[i].hashPrimitive(), var[i].hashPrimitive());
1631         }
1632     }
1633 
1634     // EA needs to consider oop fields in flattened arrays
1635     @Test
1636     public void test71() {
1637         int len = 10;
1638         MyValue2[] src = new MyValue2[len];
1639         MyValue2[] dst = new MyValue2[len];
1640         for (int i = 0; i &lt; len; ++i) {
<span class="line-modified">1641             src[i] = MyValue2.createWithFieldsDontInline(rI+i, rD+i);</span>
1642         }
1643         System.arraycopy(src, 0, dst, 0, src.length);
1644         for (int i = 0; i &lt; len; ++i) {
1645             Asserts.assertEQ(src[i].hash(), dst[i].hash());
1646         }
1647     }
1648 
1649     @DontCompile
1650     public void test71_verifier(boolean warmup) {
1651         test71();
1652     }
1653 
1654     // Test EA with leaf call to &#39;store_unknown_inline&#39;
1655     @Test
1656     public void test72(Object[] o, boolean b, Object element) {
1657         Object[] arr1 = new Object[10];
1658         Object[] arr2 = new Object[10];
1659         if (b) {
1660             arr1 = o;
1661         }
</pre>
<hr />
<pre>
2225 
2226         a[0] = MyValue1.createWithFieldsInline(rI, rL);
2227         test92(a, b);
2228         verify(a, b);
2229     }
2230 
2231     // Same as test30 but accessing all elements of the non-escaping array
2232     @Test
2233     public long test93(MyValue2[] src, boolean flag) {
2234         MyValue2[] dst = new MyValue2[10];
2235         System.arraycopy(src, 0, dst, 0, 10);
2236         if (flag) {  }
2237         return dst[0].hash() + dst[1].hash() + dst[2].hash() + dst[3].hash() + dst[4].hash() +
2238                dst[5].hash() + dst[6].hash() + dst[7].hash() + dst[8].hash() + dst[9].hash();
2239     }
2240 
2241     @DontCompile
2242     public void test93_verifier(boolean warmup) {
2243         MyValue2[] src = new MyValue2[10];
2244         for (int i = 0; i &lt; 10; ++i) {
<span class="line-modified">2245             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
2246         }
2247         long res = test93(src, !warmup);
2248         long expected = 0;
2249         for (int i = 0; i &lt; 10; ++i) {
2250             expected += src[i].hash();
2251         }
2252         Asserts.assertEQ(res, expected);
2253     }
2254 
2255     // Same as test93 but with variable source array offset
2256     @Test
2257     public long test94(MyValue2[] src, int i, boolean flag) {
2258         MyValue2[] dst = new MyValue2[10];
2259         System.arraycopy(src, i, dst, 0, 1);
2260         if (flag) {  }
2261         return dst[0].hash() + dst[1].hash() + dst[2].hash() + dst[3].hash() + dst[4].hash() +
2262                dst[5].hash() + dst[6].hash() + dst[7].hash() + dst[8].hash() + dst[9].hash();
2263     }
2264 
2265     @DontCompile
2266     public void test94_verifier(boolean warmup) {
2267         MyValue2[] src = new MyValue2[10];
2268         for (int i = 0; i &lt; 10; ++i) {
<span class="line-modified">2269             src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);</span>
2270         }
2271         for (int i = 0; i &lt; 10; ++i) {
2272             long res = test94(src, i, !warmup);
2273             long expected = src[i].hash() + 9*MyValue2.default.hash();
2274             Asserts.assertEQ(res, expected);
2275         }
2276     }
2277 
2278     // Test propagation of not null-free/flat information
2279     @Test(failOn = CHECKCAST_ARRAY)
2280     public MyValue1[] test95(Object[] array) {
2281         array[0] = null;
2282         // Always throws a ClassCastException because we just successfully
2283         // stored null and therefore the array can&#39;t be an inline type array.
2284         return (MyValue1[])array;
2285     }
2286 
2287     @DontCompile
2288     public void test95_verifier(boolean warmup) {
2289         MyValue1[] array1 = new MyValue1[1];
</pre>
</td>
</tr>
</table>
<center><a href="TestArrayAccessDeopt.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestBasicFunctionality.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>