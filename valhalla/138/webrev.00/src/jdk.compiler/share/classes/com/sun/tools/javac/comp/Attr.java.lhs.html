<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;
  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileObject;
  33 
  34 import com.sun.source.tree.CaseTree;
  35 import com.sun.source.tree.IdentifierTree;
  36 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  37 import com.sun.source.tree.MemberSelectTree;
  38 import com.sun.source.tree.TreeVisitor;
  39 import com.sun.source.util.SimpleTreeVisitor;
  40 import com.sun.tools.javac.code.*;
  41 import com.sun.tools.javac.code.Lint.LintCategory;
  42 import com.sun.tools.javac.code.Scope.WriteableScope;
  43 import com.sun.tools.javac.code.Source.Feature;
  44 import com.sun.tools.javac.code.Symbol.*;
  45 import com.sun.tools.javac.code.Type.*;
  46 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  47 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  48 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  49 import com.sun.tools.javac.comp.Check.CheckContext;
  50 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  51 import com.sun.tools.javac.comp.MatchBindingsComputer.MatchBindings;
  52 import com.sun.tools.javac.jvm.*;
  53 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.Diamond;
  54 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArg;
  55 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArgs;
  56 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  57 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  58 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  59 import com.sun.tools.javac.tree.*;
  60 import com.sun.tools.javac.tree.JCTree.*;
  61 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  62 import com.sun.tools.javac.util.*;
  63 import com.sun.tools.javac.util.DefinedBy.Api;
  64 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  65 import com.sun.tools.javac.util.JCDiagnostic.Error;
  66 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  67 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  68 import com.sun.tools.javac.util.List;
  69 
  70 import static com.sun.tools.javac.code.Flags.*;
  71 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  72 import static com.sun.tools.javac.code.Flags.BLOCK;
  73 import static com.sun.tools.javac.code.Kinds.*;
  74 import static com.sun.tools.javac.code.Kinds.Kind.*;
  75 import static com.sun.tools.javac.code.TypeTag.*;
  76 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  77 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  78 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  79 
  80 /** This is the main context-dependent analysis phase in GJC. It
  81  *  encompasses name resolution, type checking and constant folding as
  82  *  subtasks. Some subtasks involve auxiliary classes.
  83  *  @see Check
  84  *  @see Resolve
  85  *  @see ConstFold
  86  *  @see Infer
  87  *
  88  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  89  *  If you write code that depends on this, you do so at your own risk.
  90  *  This code and its internal interfaces are subject to change or
  91  *  deletion without notice.&lt;/b&gt;
  92  */
  93 public class Attr extends JCTree.Visitor {
  94     protected static final Context.Key&lt;Attr&gt; attrKey = new Context.Key&lt;&gt;();
  95 
  96     final Names names;
  97     final Log log;
  98     final Symtab syms;
  99     final Resolve rs;
 100     final Operators operators;
 101     final Infer infer;
 102     final Analyzer analyzer;
 103     final DeferredAttr deferredAttr;
 104     final Check chk;
 105     final Flow flow;
 106     final MemberEnter memberEnter;
 107     final TypeEnter typeEnter;
 108     final TreeMaker make;
 109     final ConstFold cfolder;
 110     final Enter enter;
 111     final Target target;
 112     final Types types;
 113     final Preview preview;
 114     final JCDiagnostic.Factory diags;
 115     final TypeAnnotations typeAnnotations;
 116     final DeferredLintHandler deferredLintHandler;
 117     final TypeEnvs typeEnvs;
 118     final Dependencies dependencies;
 119     final Annotate annotate;
 120     final ArgumentAttr argumentAttr;
 121     final MatchBindingsComputer matchBindingsComputer;
 122 
 123     public static Attr instance(Context context) {
 124         Attr instance = context.get(attrKey);
 125         if (instance == null)
 126             instance = new Attr(context);
 127         return instance;
 128     }
 129 
 130     protected Attr(Context context) {
 131         context.put(attrKey, this);
 132 
 133         names = Names.instance(context);
 134         log = Log.instance(context);
 135         syms = Symtab.instance(context);
 136         rs = Resolve.instance(context);
 137         operators = Operators.instance(context);
 138         chk = Check.instance(context);
 139         flow = Flow.instance(context);
 140         memberEnter = MemberEnter.instance(context);
 141         typeEnter = TypeEnter.instance(context);
 142         make = TreeMaker.instance(context);
 143         enter = Enter.instance(context);
 144         infer = Infer.instance(context);
 145         analyzer = Analyzer.instance(context);
 146         deferredAttr = DeferredAttr.instance(context);
 147         cfolder = ConstFold.instance(context);
 148         target = Target.instance(context);
 149         types = Types.instance(context);
 150         preview = Preview.instance(context);
 151         diags = JCDiagnostic.Factory.instance(context);
 152         annotate = Annotate.instance(context);
 153         typeAnnotations = TypeAnnotations.instance(context);
 154         deferredLintHandler = DeferredLintHandler.instance(context);
 155         typeEnvs = TypeEnvs.instance(context);
 156         dependencies = Dependencies.instance(context);
 157         argumentAttr = ArgumentAttr.instance(context);
 158         matchBindingsComputer = MatchBindingsComputer.instance(context);
 159 
 160         Options options = Options.instance(context);
 161 
 162         Source source = Source.instance(context);
 163         allowPoly = Feature.POLY.allowedInSource(source);
 164         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 165         allowLambda = Feature.LAMBDA.allowedInSource(source);
 166         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 167         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);
 168         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);
 169         allowReifiableTypesInInstanceof =
 170                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;
 171                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
 172         sourceName = source.name;
 173         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
 174         allowEmptyValues = options.isSet(&quot;allowEmptyValues&quot;);
 175         allowValueMemberCycles = options.isSet(&quot;allowValueMemberCycles&quot;);
 176 
 177         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 178         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 179         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 180         methodAttrInfo = new MethodAttrInfo();
 181         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 182         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 183         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 184     }
 185 
 186     /** Switch: support target-typing inference
 187      */
 188     boolean allowPoly;
 189 
 190     /** Switch: support type annotations.
 191      */
 192     boolean allowTypeAnnos;
 193 
 194     /** Switch: support lambda expressions ?
 195      */
 196     boolean allowLambda;
 197 
 198     /** Switch: support default methods ?
 199      */
 200     boolean allowDefaultMethods;
 201 
 202     /** Switch: allow inline types?
 203      */
 204     boolean allowInlineTypes;
 205 
 206     /** Switch: static interface methods enabled?
 207      */
 208     boolean allowStaticInterfaceMethods;
 209 
 210     /** Switch: reifiable types in instanceof enabled?
 211      */
 212     boolean allowReifiableTypesInInstanceof;
 213 
 214     /**
 215      * Switch: warn about use of variable before declaration?
 216      * RFE: 6425594
 217      */
 218     boolean useBeforeDeclarationWarning;
 219 
 220     /**
 221      * Switch: Allow value types with no instance state?
 222      */
 223     boolean allowEmptyValues;
 224 
 225     /**
 226      * Switch: Allow value type member cycles?
 227      */
 228     boolean allowValueMemberCycles;
 229 
 230     /**
 231      * Switch: name of source level; used for error reporting.
 232      */
 233     String sourceName;
 234 
 235     /** Check kind and type of given tree against protokind and prototype.
 236      *  If check succeeds, store type in tree and return it.
 237      *  If check fails, store errType in tree and return it.
 238      *  No checks are performed if the prototype is a method type.
 239      *  It is not necessary in this case since we know that kind and type
 240      *  are correct.
 241      *
 242      *  @param tree     The tree whose kind and type is checked
 243      *  @param found    The computed type of the tree
 244      *  @param ownkind  The computed kind of the tree
 245      *  @param resultInfo  The expected result of the tree
 246      */
 247     Type check(final JCTree tree,
 248                final Type found,
 249                final KindSelector ownkind,
 250                final ResultInfo resultInfo) {
 251         InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
 252         Type owntype;
 253         boolean shouldCheck = !found.hasTag(ERROR) &amp;&amp;
 254                 !resultInfo.pt.hasTag(METHOD) &amp;&amp;
 255                 !resultInfo.pt.hasTag(FORALL);
 256         if (shouldCheck &amp;&amp; !ownkind.subset(resultInfo.pkind)) {
 257             log.error(tree.pos(),
 258                       Errors.UnexpectedType(resultInfo.pkind.kindNames(),
 259                                             ownkind.kindNames()));
 260             owntype = types.createErrorType(found);
 261         } else if (allowPoly &amp;&amp; inferenceContext.free(found)) {
 262             //delay the check if there are inference variables in the found type
 263             //this means we are dealing with a partially inferred poly expression
 264             owntype = shouldCheck ? resultInfo.pt : found;
 265             if (resultInfo.checkMode.installPostInferenceHook()) {
 266                 inferenceContext.addFreeTypeListener(List.of(found),
 267                         instantiatedContext -&gt; {
 268                             ResultInfo pendingResult =
 269                                     resultInfo.dup(inferenceContext.asInstType(resultInfo.pt));
 270                             check(tree, inferenceContext.asInstType(found), ownkind, pendingResult);
 271                         });
 272             }
 273         } else {
 274             owntype = shouldCheck ?
 275             resultInfo.check(tree, found) :
 276             found;
 277         }
 278         if (resultInfo.checkMode.updateTreeType()) {
 279             tree.type = owntype;
 280         }
 281         return owntype;
 282     }
 283 
 284     /** Is given blank final variable assignable, i.e. in a scope where it
 285      *  may be assigned to even though it is final?
 286      *  @param v      The blank final variable.
 287      *  @param env    The current environment.
 288      */
 289     boolean isAssignableAsBlankFinal(VarSymbol v, Env&lt;AttrContext&gt; env) {
 290         Symbol owner = env.info.scope.owner;
 291            // owner refers to the innermost variable, method or
 292            // initializer block declaration at this point.
 293         boolean isAssignable =
 294             v.owner == owner
 295             ||
 296             ((owner.name == names.init ||    // i.e. we are in a constructor
 297               owner.kind == VAR ||           // i.e. we are in a variable initializer
 298               (owner.flags() &amp; BLOCK) != 0)  // i.e. we are in an initializer block
 299              &amp;&amp;
 300              v.owner == owner.owner
 301              &amp;&amp;
 302              ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env));
 303         boolean insideCompactConstructor = env.enclMethod != null &amp;&amp; TreeInfo.isCompactConstructor(env.enclMethod);
 304         return isAssignable &amp; !insideCompactConstructor;
 305     }
 306 
 307     /** Check that variable can be assigned to.
 308      *  @param pos    The current source code position.
 309      *  @param v      The assigned variable
 310      *  @param base   If the variable is referred to in a Select, the part
 311      *                to the left of the `.&#39;, null otherwise.
 312      *  @param env    The current environment.
 313      */
 314     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 315         if (v.name == names._this) {
 316             log.error(pos, Errors.CantAssignValToThis);
 317         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 318             ((v.flags() &amp; HASINIT) != 0
 319              ||
 320              !((base == null ||
 321                TreeInfo.isThisQualifier(base)) &amp;&amp;
 322                isAssignableAsBlankFinal(v, env)))) {
 323             if (v.isResourceVariable()) { //TWR resource
 324                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
 325             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {
 326                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));
 327             } else {
 328                 boolean complain = true;
 329                 /* Allow updates to instance fields of value classes by any method in the same nest via the
 330                    withfield operator -This does not result in mutation of final fields; the code generator
 331                    would implement `copy on write&#39; semantics via the opcode `withfield&#39;.
 332                 */
 333                 if (env.info.inWithField &amp;&amp; v.getKind() == ElementKind.FIELD &amp;&amp; (v.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) {
 334                     if (env.enclClass.sym.outermostClass() == v.owner.outermostClass())
 335                         complain = false;
 336                 }
 337                 if (complain)
 338                     log.error(pos, Errors.CantAssignValToFinalVar(v));
 339             }
 340         }
 341     }
 342 
 343     /** Does tree represent a static reference to an identifier?
 344      *  It is assumed that tree is either a SELECT or an IDENT.
 345      *  We have to weed out selects from non-type names here.
 346      *  @param tree    The candidate tree.
 347      */
 348     boolean isStaticReference(JCTree tree) {
 349         if (tree.hasTag(SELECT)) {
 350             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 351             if (lsym == null || lsym.kind != TYP) {
 352                 return false;
 353             }
 354         }
 355         return true;
 356     }
 357 
 358     /** Is this symbol a type?
 359      */
 360     static boolean isType(Symbol sym) {
 361         return sym != null &amp;&amp; sym.kind == TYP;
 362     }
 363 
 364     /** The current `this&#39; symbol.
 365      *  @param env    The current environment.
 366      */
 367     Symbol thisSym(DiagnosticPosition pos, Env&lt;AttrContext&gt; env) {
 368         return rs.resolveSelf(pos, env, env.enclClass.sym, names._this);
 369     }
 370 
 371     /** Attribute a parsed identifier.
 372      * @param tree Parsed identifier name
 373      * @param topLevel The toplevel to use
 374      */
 375     public Symbol attribIdent(JCTree tree, JCCompilationUnit topLevel) {
 376         Env&lt;AttrContext&gt; localEnv = enter.topLevelEnv(topLevel);
 377         localEnv.enclClass = make.ClassDef(make.Modifiers(0),
 378                                            syms.errSymbol.name,
 379                                            null, null, null, null);
 380         localEnv.enclClass.sym = syms.errSymbol;
 381         return attribIdent(tree, localEnv);
 382     }
 383 
 384     /** Attribute a parsed identifier.
 385      * @param tree Parsed identifier name
 386      * @param env The env to use
 387      */
 388     public Symbol attribIdent(JCTree tree, Env&lt;AttrContext&gt; env) {
 389         return tree.accept(identAttributer, env);
 390     }
 391     // where
 392         private TreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; identAttributer = new IdentAttributer();
 393         private class IdentAttributer extends SimpleTreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; {
 394             @Override @DefinedBy(Api.COMPILER_TREE)
 395             public Symbol visitMemberSelect(MemberSelectTree node, Env&lt;AttrContext&gt; env) {
 396                 Symbol site = visit(node.getExpression(), env);
 397                 if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)
 398                     return site;
 399                 Name name = (Name)node.getIdentifier();
 400                 if (site.kind == PCK) {
 401                     env.toplevel.packge = (PackageSymbol)site;
 402                     return rs.findIdentInPackage(null, env, (TypeSymbol)site, name,
 403                             KindSelector.TYP_PCK);
 404                 } else {
 405                     env.enclClass.sym = (ClassSymbol)site;
 406                     return rs.findMemberType(env, site.asType(), name, (TypeSymbol)site);
 407                 }
 408             }
 409 
 410             @Override @DefinedBy(Api.COMPILER_TREE)
 411             public Symbol visitIdentifier(IdentifierTree node, Env&lt;AttrContext&gt; env) {
 412                 return rs.findIdent(null, env, (Name)node.getName(), KindSelector.TYP_PCK);
 413             }
 414         }
 415 
 416     public Type coerce(Type etype, Type ttype) {
 417         return cfolder.coerce(etype, ttype);
 418     }
 419 
 420     public Type attribType(JCTree node, TypeSymbol sym) {
 421         Env&lt;AttrContext&gt; env = typeEnvs.get(sym);
 422         Env&lt;AttrContext&gt; localEnv = env.dup(node, env.info.dup());
 423         return attribTree(node, localEnv, unknownTypeInfo);
 424     }
 425 
 426     public Type attribImportQualifier(JCImport tree, Env&lt;AttrContext&gt; env) {
 427         // Attribute qualifying package or class.
 428         JCFieldAccess s = (JCFieldAccess)tree.qualid;
 429         return attribTree(s.selected, env,
 430                           new ResultInfo(tree.staticImport ?
 431                                          KindSelector.TYP : KindSelector.TYP_PCK,
 432                        Type.noType));
 433     }
 434 
 435     public Env&lt;AttrContext&gt; attribExprToTree(JCTree expr, Env&lt;AttrContext&gt; env, JCTree tree) {
 436         return attribToTree(expr, env, tree, unknownExprInfo);
 437     }
 438 
 439     public Env&lt;AttrContext&gt; attribStatToTree(JCTree stmt, Env&lt;AttrContext&gt; env, JCTree tree) {
 440         return attribToTree(stmt, env, tree, statInfo);
 441     }
 442 
 443     private Env&lt;AttrContext&gt; attribToTree(JCTree root, Env&lt;AttrContext&gt; env, JCTree tree, ResultInfo resultInfo) {
 444         breakTree = tree;
 445         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 446         try {
 447             deferredAttr.attribSpeculative(root, env, resultInfo,
 448                     null, DeferredAttr.AttributionMode.ANALYZER,
 449                     argumentAttr.withLocalCacheContext());
 450         } catch (BreakAttr b) {
 451             return b.env;
 452         } catch (AssertionError ae) {
 453             if (ae.getCause() instanceof BreakAttr) {
 454                 return ((BreakAttr)(ae.getCause())).env;
 455             } else {
 456                 throw ae;
 457             }
 458         } finally {
 459             breakTree = null;
 460             log.useSource(prev);
 461         }
 462         return env;
 463     }
 464 
 465     private JCTree breakTree = null;
 466 
 467     private static class BreakAttr extends RuntimeException {
 468         static final long serialVersionUID = -6924771130405446405L;
 469         private transient Env&lt;AttrContext&gt; env;
 470         private BreakAttr(Env&lt;AttrContext&gt; env) {
 471             this.env = env;
 472         }
 473     }
 474 
 475     /**
 476      * Mode controlling behavior of Attr.Check
 477      */
 478     enum CheckMode {
 479 
 480         NORMAL,
 481 
 482         /**
 483          * Mode signalling &#39;fake check&#39; - skip tree update. A side-effect of this mode is
 484          * that the captured var cache in {@code InferenceContext} will be used in read-only
 485          * mode when performing inference checks.
 486          */
 487         NO_TREE_UPDATE {
 488             @Override
 489             public boolean updateTreeType() {
 490                 return false;
 491             }
 492         },
 493         /**
 494          * Mode signalling that caller will manage free types in tree decorations.
 495          */
 496         NO_INFERENCE_HOOK {
 497             @Override
 498             public boolean installPostInferenceHook() {
 499                 return false;
 500             }
 501         };
 502 
 503         public boolean updateTreeType() {
 504             return true;
 505         }
 506         public boolean installPostInferenceHook() {
 507             return true;
 508         }
 509     }
 510 
 511 
 512     class ResultInfo {
 513         final KindSelector pkind;
 514         final Type pt;
 515         final CheckContext checkContext;
 516         final CheckMode checkMode;
 517 
 518         ResultInfo(KindSelector pkind, Type pt) {
 519             this(pkind, pt, chk.basicHandler, CheckMode.NORMAL);
 520         }
 521 
 522         ResultInfo(KindSelector pkind, Type pt, CheckMode checkMode) {
 523             this(pkind, pt, chk.basicHandler, checkMode);
 524         }
 525 
 526         protected ResultInfo(KindSelector pkind,
 527                              Type pt, CheckContext checkContext) {
 528             this(pkind, pt, checkContext, CheckMode.NORMAL);
 529         }
 530 
 531         protected ResultInfo(KindSelector pkind,
 532                              Type pt, CheckContext checkContext, CheckMode checkMode) {
 533             this.pkind = pkind;
 534             this.pt = pt;
 535             this.checkContext = checkContext;
 536             this.checkMode = checkMode;
 537         }
 538 
 539         /**
 540          * Should {@link Attr#attribTree} use the {@ArgumentAttr} visitor instead of this one?
 541          * @param tree The tree to be type-checked.
 542          * @return true if {@ArgumentAttr} should be used.
 543          */
 544         protected boolean needsArgumentAttr(JCTree tree) { return false; }
 545 
 546         protected Type check(final DiagnosticPosition pos, final Type found) {
 547             return chk.checkType(pos, found, pt, checkContext);
 548         }
 549 
 550         protected ResultInfo dup(Type newPt) {
 551             return new ResultInfo(pkind, newPt, checkContext, checkMode);
 552         }
 553 
 554         protected ResultInfo dup(CheckContext newContext) {
 555             return new ResultInfo(pkind, pt, newContext, checkMode);
 556         }
 557 
 558         protected ResultInfo dup(Type newPt, CheckContext newContext) {
 559             return new ResultInfo(pkind, newPt, newContext, checkMode);
 560         }
 561 
 562         protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
 563             return new ResultInfo(pkind, newPt, newContext, newMode);
 564         }
 565 
 566         protected ResultInfo dup(CheckMode newMode) {
 567             return new ResultInfo(pkind, pt, checkContext, newMode);
 568         }
 569 
 570         @Override
 571         public String toString() {
 572             if (pt != null) {
 573                 return pt.toString();
 574             } else {
 575                 return &quot;&quot;;
 576             }
 577         }
 578     }
 579 
 580     class MethodAttrInfo extends ResultInfo {
 581         public MethodAttrInfo() {
 582             this(chk.basicHandler);
 583         }
 584 
 585         public MethodAttrInfo(CheckContext checkContext) {
 586             super(KindSelector.VAL, Infer.anyPoly, checkContext);
 587         }
 588 
 589         @Override
 590         protected boolean needsArgumentAttr(JCTree tree) {
 591             return true;
 592         }
 593 
 594         protected ResultInfo dup(Type newPt) {
 595             throw new IllegalStateException();
 596         }
 597 
 598         protected ResultInfo dup(CheckContext newContext) {
 599             return new MethodAttrInfo(newContext);
 600         }
 601 
 602         protected ResultInfo dup(Type newPt, CheckContext newContext) {
 603             throw new IllegalStateException();
 604         }
 605 
 606         protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
 607             throw new IllegalStateException();
 608         }
 609 
 610         protected ResultInfo dup(CheckMode newMode) {
 611             throw new IllegalStateException();
 612         }
 613     }
 614 
 615     class RecoveryInfo extends ResultInfo {
 616 
 617         public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext) {
 618             this(deferredAttrContext, Type.recoveryType);
 619         }
 620 
 621         public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext, Type pt) {
 622             super(KindSelector.VAL, pt, new Check.NestedCheckContext(chk.basicHandler) {
 623                 @Override
 624                 public DeferredAttr.DeferredAttrContext deferredAttrContext() {
 625                     return deferredAttrContext;
 626                 }
 627                 @Override
 628                 public boolean compatible(Type found, Type req, Warner warn) {
 629                     return true;
 630                 }
 631                 @Override
 632                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 633                     if (pt == Type.recoveryType) {
 634                         chk.basicHandler.report(pos, details);
 635                     }
 636                 }
 637             });
 638         }
 639     }
 640 
 641     final ResultInfo statInfo;
 642     final ResultInfo varAssignmentInfo;
 643     final ResultInfo methodAttrInfo;
 644     final ResultInfo unknownExprInfo;
 645     final ResultInfo unknownTypeInfo;
 646     final ResultInfo unknownTypeExprInfo;
 647     final ResultInfo recoveryInfo;
 648 
 649     Type pt() {
 650         return resultInfo.pt;
 651     }
 652 
 653     KindSelector pkind() {
 654         return resultInfo.pkind;
 655     }
 656 
 657 /* ************************************************************************
 658  * Visitor methods
 659  *************************************************************************/
 660 
 661     /** Visitor argument: the current environment.
 662      */
 663     Env&lt;AttrContext&gt; env;
 664 
 665     /** Visitor argument: the currently expected attribution result.
 666      */
 667     ResultInfo resultInfo;
 668 
 669     /** Visitor result: the computed type.
 670      */
 671     Type result;
 672 
 673     MatchBindings matchBindings = MatchBindingsComputer.EMPTY;
 674 
 675     /** Visitor method: attribute a tree, catching any completion failure
 676      *  exceptions. Return the tree&#39;s type.
 677      *
 678      *  @param tree    The tree to be visited.
 679      *  @param env     The environment visitor argument.
 680      *  @param resultInfo   The result info visitor argument.
 681      */
 682     Type attribTree(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
 683         Env&lt;AttrContext&gt; prevEnv = this.env;
 684         ResultInfo prevResult = this.resultInfo;
 685         try {
 686             this.env = env;
 687             this.resultInfo = resultInfo;
 688             if (resultInfo.needsArgumentAttr(tree)) {
 689                 result = argumentAttr.attribArg(tree, env);
 690             } else {
 691                 tree.accept(this);
 692             }
 693             matchBindings = matchBindingsComputer.finishBindings(tree,
 694                                                                  matchBindings);
 695             if (tree == breakTree &amp;&amp;
 696                     resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
 697                 breakTreeFound(copyEnv(env));
 698             }
 699             return result;
 700         } catch (CompletionFailure ex) {
 701             tree.type = syms.errType;
 702             return chk.completionError(tree.pos(), ex);
 703         } finally {
 704             this.env = prevEnv;
 705             this.resultInfo = prevResult;
 706         }
 707     }
 708 
 709     protected void breakTreeFound(Env&lt;AttrContext&gt; env) {
 710         throw new BreakAttr(env);
 711     }
 712 
 713     Env&lt;AttrContext&gt; copyEnv(Env&lt;AttrContext&gt; env) {
 714         Env&lt;AttrContext&gt; newEnv =
 715                 env.dup(env.tree, env.info.dup(copyScope(env.info.scope)));
 716         if (newEnv.outer != null) {
 717             newEnv.outer = copyEnv(newEnv.outer);
 718         }
 719         return newEnv;
 720     }
 721 
 722     WriteableScope copyScope(WriteableScope sc) {
 723         WriteableScope newScope = WriteableScope.create(sc.owner);
 724         List&lt;Symbol&gt; elemsList = List.nil();
 725         for (Symbol sym : sc.getSymbols()) {
 726             elemsList = elemsList.prepend(sym);
 727         }
 728         for (Symbol s : elemsList) {
 729             newScope.enter(s);
 730         }
 731         return newScope;
 732     }
 733 
 734     /** Derived visitor method: attribute an expression tree.
 735      */
 736     public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 737         return attribTree(tree, env, new ResultInfo(KindSelector.VAL, !pt.hasTag(ERROR) ? pt : Type.noType));
 738     }
 739 
 740     /** Derived visitor method: attribute an expression tree with
 741      *  no constraints on the computed type.
 742      */
 743     public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env) {
 744         return attribTree(tree, env, unknownExprInfo);
 745     }
 746 
 747     /** Derived visitor method: attribute a type tree.
 748      */
 749     public Type attribType(JCTree tree, Env&lt;AttrContext&gt; env) {
 750         Type result = attribType(tree, env, Type.noType);
 751         return result;
 752     }
 753 
 754     /** Derived visitor method: attribute a type tree.
 755      */
 756     Type attribType(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 757         Type result = attribTree(tree, env, new ResultInfo(KindSelector.TYP, pt));
 758         return result;
 759     }
 760 
 761     /** Derived visitor method: attribute a statement or definition tree.
 762      */
 763     public Type attribStat(JCTree tree, Env&lt;AttrContext&gt; env) {
 764         Env&lt;AttrContext&gt; analyzeEnv = analyzer.copyEnvIfNeeded(tree, env);
 765         Type result = attribTree(tree, env, statInfo);
 766         analyzer.analyzeIfNeeded(tree, analyzeEnv);
 767         return result;
 768     }
 769 
 770     /** Attribute a list of expressions, returning a list of types.
 771      */
 772     List&lt;Type&gt; attribExprs(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
 773         ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;&gt;();
 774         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 775             ts.append(attribExpr(l.head, env, pt));
 776         return ts.toList();
 777     }
 778 
 779     /** Attribute a list of statements, returning nothing.
 780      */
 781     &lt;T extends JCTree&gt; void attribStats(List&lt;T&gt; trees, Env&lt;AttrContext&gt; env) {
 782         for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
 783             attribStat(l.head, env);
 784     }
 785 
 786     /** Attribute the arguments in a method call, returning the method kind.
 787      */
 788     KindSelector attribArgs(KindSelector initialKind, List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, ListBuffer&lt;Type&gt; argtypes) {
 789         KindSelector kind = initialKind;
 790         for (JCExpression arg : trees) {
 791             Type argtype = chk.checkNonVoid(arg, attribTree(arg, env, allowPoly ? methodAttrInfo : unknownExprInfo));
 792             if (argtype.hasTag(DEFERRED)) {
 793                 kind = KindSelector.of(KindSelector.POLY, kind);
 794             }
 795             argtypes.append(argtype);
 796         }
 797         return kind;
 798     }
 799 
 800     /** Attribute a type argument list, returning a list of types.
 801      *  Caller is responsible for calling checkRefTypes.
 802      */
 803     List&lt;Type&gt; attribAnyTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 804         ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();
 805         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 806             argtypes.append(attribType(l.head, env));
 807         return argtypes.toList();
 808     }
 809 
 810     /** Attribute a type argument list, returning a list of types.
 811      *  Check that all the types are references.
 812      */
 813     List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 814         List&lt;Type&gt; types = attribAnyTypes(trees, env);
 815         return chk.checkRefTypes(trees, types);
 816     }
 817 
 818     /**
 819      * Attribute type variables (of generic classes or methods).
 820      * Compound types are attributed later in attribBounds.
 821      * @param typarams the type variables to enter
 822      * @param env      the current environment
 823      */
 824     void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env, boolean checkCyclic) {
 825         for (JCTypeParameter tvar : typarams) {
 826             TypeVar a = (TypeVar)tvar.type;
 827             a.tsym.flags_field |= UNATTRIBUTED;
 828             a.setUpperBound(Type.noType);
 829             if (!tvar.bounds.isEmpty()) {
 830                 List&lt;Type&gt; bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));
 831                 for (JCExpression bound : tvar.bounds.tail)
 832                     bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));
 833                 types.setBounds(a, bounds.reverse());
 834             } else {
 835                 // if no bounds are given, assume a single bound of
 836                 // java.lang.Object.
 837                 types.setBounds(a, List.of(syms.objectType));
 838             }
 839             a.tsym.flags_field &amp;= ~UNATTRIBUTED;
 840         }
 841         if (checkCyclic) {
 842             for (JCTypeParameter tvar : typarams) {
 843                 chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
 844             }
 845         }
 846     }
 847 
 848     /**
 849      * Attribute the type references in a list of annotations.
 850      */
 851     void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
 852                                Env&lt;AttrContext&gt; env) {
 853         for (List&lt;JCAnnotation&gt; al = annotations; al.nonEmpty(); al = al.tail) {
 854             JCAnnotation a = al.head;
 855             attribType(a.annotationType, env);
 856         }
 857     }
 858 
 859     /**
 860      * Attribute a &quot;lazy constant value&quot;.
 861      *  @param env         The env for the const value
 862      *  @param variable    The initializer for the const value
 863      *  @param type        The expected type, or null
 864      *  @see VarSymbol#setLazyConstValue
 865      */
 866     public Object attribLazyConstantValue(Env&lt;AttrContext&gt; env,
 867                                       JCVariableDecl variable,
 868                                       Type type) {
 869 
 870         DiagnosticPosition prevLintPos
 871                 = deferredLintHandler.setPos(variable.pos());
 872 
 873         final JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);
 874         try {
 875             Type itype = attribExpr(variable.init, env, type);
 876             if (variable.isImplicitlyTyped()) {
 877                 //fixup local variable type
 878                 type = variable.type = variable.sym.type = chk.checkLocalVarType(variable, itype.baseType(), variable.name);
 879             }
 880             if (itype.constValue() != null) {
 881                 return coerce(itype, type).constValue();
 882             } else {
 883                 return null;
 884             }
 885         } finally {
 886             log.useSource(prevSource);
 887             deferredLintHandler.setPos(prevLintPos);
 888         }
 889     }
 890 
 891     /** Attribute type reference in an `extends&#39; or `implements&#39; clause.
 892      *  Supertypes of anonymous inner classes are usually already attributed.
 893      *
 894      *  @param tree              The tree making up the type reference.
 895      *  @param env               The environment current at the reference.
 896      *  @param classExpected     true if only a class is expected here.
 897      *  @param interfaceExpected true if only an interface is expected here.
 898      */
 899     Type attribBase(JCTree tree,
 900                     Env&lt;AttrContext&gt; env,
 901                     boolean classExpected,
 902                     boolean interfaceExpected,
 903                     boolean checkExtensible) {
 904         Type t = tree.type != null ?
 905             tree.type :
 906             attribType(tree, env);
 907         return checkBase(t, tree, env, classExpected, interfaceExpected, checkExtensible);
 908     }
 909     Type checkBase(Type t,
 910                    JCTree tree,
 911                    Env&lt;AttrContext&gt; env,
 912                    boolean classExpected,
 913                    boolean interfaceExpected,
 914                    boolean checkExtensible) {
 915         final DiagnosticPosition pos = tree.hasTag(TYPEAPPLY) ?
 916                 (((JCTypeApply) tree).clazz).pos() : tree.pos();
 917         if (t.tsym.isAnonymous()) {
 918             log.error(pos, Errors.CantInheritFromAnon);
 919             return types.createErrorType(t);
 920         }
 921         if (t.isErroneous())
 922             return t;
 923         if (t.hasTag(TYPEVAR) &amp;&amp; !classExpected &amp;&amp; !interfaceExpected) {
 924             // check that type variable is already visible
 925             if (t.getUpperBound() == null) {
 926                 log.error(pos, Errors.IllegalForwardRef);
 927                 return types.createErrorType(t);
 928             }
 929         } else {
 930             t = chk.checkClassType(pos, t, checkExtensible);
 931         }
 932         if (interfaceExpected &amp;&amp; (t.tsym.flags() &amp; INTERFACE) == 0) {
 933             log.error(pos, Errors.IntfExpectedHere);
 934             // return errType is necessary since otherwise there might
 935             // be undetected cycles which cause attribution to loop
 936             return types.createErrorType(t);
 937         } else if (checkExtensible &amp;&amp;
 938                    classExpected &amp;&amp;
 939                    (t.tsym.flags() &amp; INTERFACE) != 0) {
 940             log.error(pos, Errors.NoIntfExpectedHere);
 941             return types.createErrorType(t);
 942         }
 943         if (checkExtensible &amp;&amp;
 944             ((t.tsym.flags() &amp; FINAL) != 0)) {
 945             log.error(pos,
 946                       Errors.CantInheritFromFinal(t.tsym));
 947         }
 948         chk.checkNonCyclic(pos, t);
 949         return t;
 950     }
 951 
 952     Type attribIdentAsEnumType(Env&lt;AttrContext&gt; env, JCIdent id) {
 953         Assert.check((env.enclClass.sym.flags() &amp; ENUM) != 0);
 954         id.type = env.info.scope.owner.enclClass().type;
 955         id.sym = env.info.scope.owner.enclClass();
 956         return id.type;
 957     }
 958 
 959     public void visitClassDef(JCClassDecl tree) {
 960         Optional&lt;ArgumentAttr.LocalCacheContext&gt; localCacheContext =
 961                 Optional.ofNullable(env.info.attributionMode.isSpeculative ?
 962                         argumentAttr.withLocalCacheContext() : null);
 963         try {
 964             // Local and anonymous classes have not been entered yet, so we need to
 965             // do it now.
 966             if (env.info.scope.owner.kind.matches(KindSelector.VAL_MTH)) {
 967                 enter.classEnter(tree, env);
 968             } else {
 969                 // If this class declaration is part of a class level annotation,
 970                 // as in @MyAnno(new Object() {}) class MyClass {}, enter it in
 971                 // order to simplify later steps and allow for sensible error
 972                 // messages.
 973                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 974                     enter.classEnter(tree, env);
 975             }
 976 
 977             ClassSymbol c = tree.sym;
 978             if (c == null) {
 979                 // exit in case something drastic went wrong during enter.
 980                 result = null;
 981             } else {
 982                 // make sure class has been completed:
 983                 c.complete();
 984 
 985                 // If this class appears as an anonymous class
 986                 // in a superclass constructor call
 987                 // disable implicit outer instance from being passed.
 988                 // (This would be an illegal access to &quot;this before super&quot;).
 989                 if (env.info.isSelfCall &amp;&amp;
 990                         env.tree.hasTag(NEWCLASS)) {
 991                     c.flags_field |= NOOUTERTHIS;
 992                 }
 993                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; types.isValue(c.getSuperclass())) {
 994                     c.flags_field |= VALUE; // avoid further secondary errors.
 995                 }
 996                 attribClass(tree.pos(), c);
 997                 result = tree.type = c.type;
 998             }
 999         } finally {
1000             localCacheContext.ifPresent(LocalCacheContext::leave);
1001         }
1002     }
1003 
1004     public void visitMethodDef(JCMethodDecl tree) {
1005         MethodSymbol m = tree.sym;
1006         boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
1007 
1008         Lint lint = env.info.lint.augment(m);
1009         Lint prevLint = chk.setLint(lint);
1010         MethodSymbol prevMethod = chk.setMethod(m);
1011         try {
1012             deferredLintHandler.flush(tree.pos());
1013             chk.checkDeprecatedAnnotation(tree.pos(), m);
1014 
1015 
1016             // Create a new environment with local scope
1017             // for attributing the method.
1018             Env&lt;AttrContext&gt; localEnv = memberEnter.methodEnv(tree, env);
1019             localEnv.info.lint = lint;
1020 
1021             attribStats(tree.typarams, localEnv);
1022 
1023             // If we override any other methods, check that we do so properly.
1024             // JLS ???
1025             if (m.isStatic()) {
1026                 chk.checkHideClashes(tree.pos(), env.enclClass.type, m);
1027             } else {
1028                 chk.checkOverrideClashes(tree.pos(), env.enclClass.type, m);
1029             }
1030             chk.checkOverride(env, tree, m);
1031 
1032             if (isDefaultMethod &amp;&amp; types.overridesObjectMethod(m.enclClass(), m)) {
1033                 log.error(tree, Errors.DefaultOverridesObjectMember(m.name, Kinds.kindName(m.location()), m.location()));
1034             }
1035 
1036             // Enter all type parameters into the local method scope.
1037             for (List&lt;JCTypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = l.tail)
1038                 localEnv.info.scope.enterIfAbsent(l.head.type.tsym);
1039 
1040             ClassSymbol owner = env.enclClass.sym;
1041             if ((owner.flags() &amp; ANNOTATION) != 0 &amp;&amp;
1042                     (tree.params.nonEmpty() ||
1043                     tree.recvparam != null))
1044                 log.error(tree.params.nonEmpty() ?
1045                         tree.params.head.pos() :
1046                         tree.recvparam.pos(),
1047                         Errors.IntfAnnotationMembersCantHaveParams);
1048 
1049             // Attribute all value parameters.
1050             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1051                 attribStat(l.head, localEnv);
1052             }
1053 
1054             chk.checkVarargsMethodDecl(localEnv, tree);
1055 
1056             // Check that type parameters are well-formed.
1057             chk.validate(tree.typarams, localEnv);
1058 
1059             // Check that result type is well-formed.
1060             if (tree.restype != null &amp;&amp; !tree.restype.type.hasTag(VOID))
1061                 chk.validate(tree.restype, localEnv);
1062 
1063             // Check that receiver type is well-formed.
1064             if (tree.recvparam != null) {
1065                 // Use a new environment to check the receiver parameter.
1066                 // Otherwise I get &quot;might not have been initialized&quot; errors.
1067                 // Is there a better way?
1068                 Env&lt;AttrContext&gt; newEnv = memberEnter.methodEnv(tree, env);
1069                 attribType(tree.recvparam, newEnv);
1070                 chk.validate(tree.recvparam, newEnv);
1071             }
1072 
1073             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP) {
1074                 // lets find if this method is an accessor
1075                 Optional&lt;? extends RecordComponent&gt; recordComponent = env.enclClass.sym.getRecordComponents().stream()
1076                         .filter(rc -&gt; rc.accessor == tree.sym &amp;&amp; (rc.accessor.flags_field &amp; GENERATED_MEMBER) == 0).findFirst();
1077                 if (recordComponent.isPresent()) {
1078                     // the method is a user defined accessor lets check that everything is fine
1079                     if (!tree.sym.isPublic()) {
1080                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.MethodMustBePublic));
1081                     }
1082                     if (!types.isSameType(tree.sym.type.getReturnType(), recordComponent.get().type)) {
1083                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym,
1084                                 Fragments.AccessorReturnTypeDoesntMatch(tree.sym, recordComponent.get())));
1085                     }
1086                     if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1087                         log.error(tree,
1088                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodCantThrowException));
1089                     }
1090                     if (!tree.typarams.isEmpty()) {
1091                         log.error(tree,
1092                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeGeneric));
1093                     }
1094                     if (tree.sym.isStatic()) {
1095                         log.error(tree,
1096                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeStatic));
1097                     }
1098                 }
1099 
1100                 if (tree.name == names.init) {
1101                     // if this a constructor other than the canonical one
1102                     if ((tree.sym.flags_field &amp; RECORD) == 0) {
1103                         JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1104                         if (app == null ||
1105                                 TreeInfo.name(app.meth) != names._this ||
1106                                 !checkFirstConstructorStat(app, tree, false)) {
1107                             log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);
1108                         }
1109                     } else {
1110                         // but if it is the canonical:
1111 
1112                         /* if user generated, then it shouldn&#39;t:
1113                          *     - have an accessibility stricter than that of the record type
1114                          *     - explicitly invoke any other constructor
1115                          */
1116                         if ((tree.sym.flags_field &amp; GENERATEDCONSTR) == 0) {
1117                             if (Check.protection(m.flags()) &gt; Check.protection(env.enclClass.sym.flags())) {
1118                                 log.error(tree,
1119                                         (env.enclClass.sym.flags() &amp; AccessFlags) == 0 ?
1120                                             Errors.InvalidCanonicalConstructorInRecord(
1121                                                 Fragments.Canonical,
1122                                                 env.enclClass.sym.name,
1123                                                 Fragments.CanonicalMustNotHaveStrongerAccess(&quot;package&quot;)
1124                                             ) :
1125                                             Errors.InvalidCanonicalConstructorInRecord(
1126                                                     Fragments.Canonical,
1127                                                     env.enclClass.sym.name,
1128                                                     Fragments.CanonicalMustNotHaveStrongerAccess(asFlagSet(env.enclClass.sym.flags() &amp; AccessFlags))
1129                                             )
1130                                 );
1131                             }
1132 
1133                             JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1134                             if (app != null &amp;&amp;
1135                                     (TreeInfo.name(app.meth) == names._this ||
1136                                             TreeInfo.name(app.meth) == names._super) &amp;&amp;
1137                                     checkFirstConstructorStat(app, tree, false)) {
1138                                 log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1139                                         Fragments.Canonical, env.enclClass.sym.name,
1140                                         Fragments.CanonicalMustNotContainExplicitConstructorInvocation));
1141                             }
1142                         }
1143 
1144                         // also we want to check that no type variables have been defined
1145                         if (!tree.typarams.isEmpty()) {
1146                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1147                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalMustNotDeclareTypeVariables));
1148                         }
1149 
1150                         /* and now we need to check that the constructor&#39;s arguments are exactly the same as those of the
1151                          * record components
1152                          */
1153                         List&lt;? extends RecordComponent&gt; recordComponents = env.enclClass.sym.getRecordComponents();
1154                         List&lt;Type&gt; recordFieldTypes = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.type);
1155                         for (JCVariableDecl param: tree.params) {
1156                             boolean paramIsVarArgs = (param.sym.flags_field &amp; VARARGS) != 0;
1157                             if (!types.isSameType(param.type, recordFieldTypes.head) ||
1158                                     (recordComponents.head.isVarargs() != paramIsVarArgs)) {
1159                                 log.error(param, Errors.InvalidCanonicalConstructorInRecord(
1160                                         Fragments.Canonical, env.enclClass.sym.name,
1161                                         Fragments.TypeMustBeIdenticalToCorrespondingRecordComponentType));
1162                             }
1163                             recordComponents = recordComponents.tail;
1164                             recordFieldTypes = recordFieldTypes.tail;
1165                         }
1166                     }
1167                 }
1168             }
1169 
1170             // annotation method checks
1171             if ((owner.flags() &amp; ANNOTATION) != 0) {
1172                 // annotation method cannot have throws clause
1173                 if (tree.thrown.nonEmpty()) {
1174                     log.error(tree.thrown.head.pos(),
1175                               Errors.ThrowsNotAllowedInIntfAnnotation);
1176                 }
1177                 // annotation method cannot declare type-parameters
1178                 if (tree.typarams.nonEmpty()) {
1179                     log.error(tree.typarams.head.pos(),
1180                               Errors.IntfAnnotationMembersCantHaveTypeParams);
1181                 }
1182                 // validate annotation method&#39;s return type (could be an annotation type)
1183                 chk.validateAnnotationType(tree.restype);
1184                 // ensure that annotation method does not clash with members of Object/Annotation
1185                 chk.validateAnnotationMethod(tree.pos(), m);
1186             }
1187 
1188             for (List&lt;JCExpression&gt; l = tree.thrown; l.nonEmpty(); l = l.tail)
1189                 chk.checkType(l.head.pos(), l.head.type, syms.throwableType);
1190 
1191             if (tree.body == null) {
1192                 // Empty bodies are only allowed for
1193                 // abstract, native, or interface methods, or for methods
1194                 // in a retrofit signature class.
1195                 if (tree.defaultValue != null) {
1196                     if ((owner.flags() &amp; ANNOTATION) == 0)
1197                         log.error(tree.pos(),
1198                                   Errors.DefaultAllowedInIntfAnnotationMember);
1199                 }
1200                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1201                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1202             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1203                 if ((owner.flags() &amp; INTERFACE) != 0) {
1204                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1205                 } else {
1206                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1207                 }
1208             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1209                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1210             } else {
1211                 // Add an implicit super() call unless an explicit call to
1212                 // super(...) or this(...) is given
1213                 // or we are compiling class java.lang.Object.
1214                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1215                     JCBlock body = tree.body;
1216                     if (body.stats.isEmpty() ||
1217                             TreeInfo.getConstructorInvocationName(body.stats, names, true) == names.empty) {
1218                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1219                                 make.Ident(names._super), make.Idents(List.nil())));
1220                         body.stats = body.stats.prepend(supCall);
1221                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1222                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1223                             TreeInfo.isSuperCall(body.stats.head)) {
1224                         // enum constructors are not allowed to call super
1225                         // directly, so make sure there aren&#39;t any super calls
1226                         // in enum constructors, except in the compiler
1227                         // generated one.
1228                         log.error(tree.body.stats.head.pos(),
1229                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1230                     }
1231                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1232                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1233                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1234                         if (!initParamNames.equals(recordComponentNames)) {
1235                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1236                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1237                         }
1238                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1239                             log.error(tree,
1240                                     Errors.InvalidCanonicalConstructorInRecord(
1241                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1242                                             env.enclClass.sym.name,
1243                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1244                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1245                         }
1246                     }
1247                 }
1248                 if (m.isConstructor() &amp;&amp; m.type.getParameterTypes().size() == 0) {
1249                     if ((owner.type == syms.objectType) ||
1250                             (tree.body.stats.size() == 1 &amp;&amp; TreeInfo.getConstructorInvocationName(tree.body.stats, names, false) == names._super)) {
1251                         m.flags_field |= EMPTYNOARGCONSTR;
1252                     }
1253                 }
1254 
1255                 // Attribute all type annotations in the body
1256                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1257                 annotate.flush();
1258 
1259                 // Attribute method body.
1260                 attribStat(tree.body, localEnv);
1261             }
1262 
1263             localEnv.info.scope.leave();
1264             result = tree.type = m.type;
1265         } finally {
1266             chk.setLint(prevLint);
1267             chk.setMethod(prevMethod);
1268         }
1269     }
1270 
1271     public void visitVarDef(JCVariableDecl tree) {
1272         // Local variables have not been entered yet, so we need to do it now:
1273         if (env.info.scope.owner.kind == MTH || env.info.scope.owner.kind == VAR) {
1274             if (tree.sym != null) {
1275                 // parameters have already been entered
1276                 env.info.scope.enter(tree.sym);
1277             } else {
1278                 if (tree.isImplicitlyTyped() &amp;&amp; (tree.getModifiers().flags &amp; PARAMETER) == 0) {
1279                     if (tree.init == null) {
1280                         //cannot use &#39;var&#39; without initializer
1281                         log.error(tree, Errors.CantInferLocalVarType(tree.name, Fragments.LocalMissingInit));
1282                         tree.vartype = make.Erroneous();
1283                     } else {
1284                         Fragment msg = canInferLocalVarType(tree);
1285                         if (msg != null) {
1286                             //cannot use &#39;var&#39; with initializer which require an explicit target
1287                             //(e.g. lambda, method reference, array initializer).
1288                             log.error(tree, Errors.CantInferLocalVarType(tree.name, msg));
1289                             tree.vartype = make.Erroneous();
1290                         }
1291                     }
1292                 }
1293                 try {
1294                     annotate.blockAnnotations();
1295                     memberEnter.memberEnter(tree, env);
1296                 } finally {
1297                     annotate.unblockAnnotations();
1298                 }
1299             }
1300         } else {
1301             if (tree.init != null) {
1302                 // Field initializer expression need to be entered.
1303                 annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());
1304                 annotate.flush();
1305             }
1306         }
1307 
1308         VarSymbol v = tree.sym;
1309         Lint lint = env.info.lint.augment(v);
1310         Lint prevLint = chk.setLint(lint);
1311 
1312         // Check that the variable&#39;s declared type is well-formed.
1313         boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;
1314                 ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1315                 (tree.sym.flags() &amp; PARAMETER) != 0;
1316         chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
1317 
1318         try {
1319             v.getConstValue(); // ensure compile-time constant initializer is evaluated
1320             deferredLintHandler.flush(tree.pos());
1321             chk.checkDeprecatedAnnotation(tree.pos(), v);
1322 
1323             /* Don&#39;t want constant propagation/folding for instance fields of value classes,
1324                as these can undergo updates via copy on write.
1325             */
1326             if (tree.init != null) {
1327                 if ((v.flags_field &amp; FINAL) == 0 || ((v.flags_field &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) ||
1328                     !memberEnter.needsLazyConstValue(tree.init)) {
1329                     // Not a compile-time constant
1330                     // Attribute initializer in a new environment
1331                     // with the declared variable as owner.
1332                     // Check that initializer conforms to variable&#39;s declared type.
1333                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1334                     initEnv.info.lint = lint;
1335                     // In order to catch self-references, we set the variable&#39;s
1336                     // declaration position to maximal possible value, effectively
1337                     // marking the variable as undefined.
1338                     initEnv.info.enclVar = v;
1339                     attribExpr(tree.init, initEnv, v.type);
1340                     if (tree.isImplicitlyTyped()) {
1341                         //fixup local variable type
1342                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1343                     }
1344                 }
1345                 if (tree.isImplicitlyTyped()) {
1346                     setSyntheticVariableType(tree, v.type);
1347                 }
1348             }
1349             result = tree.type = v.type;
1350             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP &amp;&amp; !v.isStatic()) {
1351                 if (isNonArgsMethodInObject(v.name)) {
1352                     log.error(tree, Errors.IllegalRecordComponentName(v));
1353                 }
1354             }
1355         }
1356         finally {
1357             chk.setLint(prevLint);
1358         }
1359     }
1360 
1361     private boolean isNonArgsMethodInObject(Name name) {
1362         for (Symbol s : syms.objectType.tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {
1363             if (s.type.getParameterTypes().isEmpty()) {
1364                 return true;
1365             }
1366         }
1367         return false;
1368     }
1369 
1370     Fragment canInferLocalVarType(JCVariableDecl tree) {
1371         LocalInitScanner lis = new LocalInitScanner();
1372         lis.scan(tree.init);
1373         return lis.badInferenceMsg;
1374     }
1375 
1376     static class LocalInitScanner extends TreeScanner {
1377         Fragment badInferenceMsg = null;
1378         boolean needsTarget = true;
1379 
1380         @Override
1381         public void visitNewArray(JCNewArray tree) {
1382             if (tree.elemtype == null &amp;&amp; needsTarget) {
1383                 badInferenceMsg = Fragments.LocalArrayMissingTarget;
1384             }
1385         }
1386 
1387         @Override
1388         public void visitLambda(JCLambda tree) {
1389             if (needsTarget) {
1390                 badInferenceMsg = Fragments.LocalLambdaMissingTarget;
1391             }
1392         }
1393 
1394         @Override
1395         public void visitTypeCast(JCTypeCast tree) {
1396             boolean prevNeedsTarget = needsTarget;
1397             try {
1398                 needsTarget = false;
1399                 super.visitTypeCast(tree);
1400             } finally {
1401                 needsTarget = prevNeedsTarget;
1402             }
1403         }
1404 
1405         @Override
1406         public void visitReference(JCMemberReference tree) {
1407             if (needsTarget) {
1408                 badInferenceMsg = Fragments.LocalMrefMissingTarget;
1409             }
1410         }
1411 
1412         @Override
1413         public void visitNewClass(JCNewClass tree) {
1414             boolean prevNeedsTarget = needsTarget;
1415             try {
1416                 needsTarget = false;
1417                 super.visitNewClass(tree);
1418             } finally {
1419                 needsTarget = prevNeedsTarget;
1420             }
1421         }
1422 
1423         @Override
1424         public void visitApply(JCMethodInvocation tree) {
1425             boolean prevNeedsTarget = needsTarget;
1426             try {
1427                 needsTarget = false;
1428                 super.visitApply(tree);
1429             } finally {
1430                 needsTarget = prevNeedsTarget;
1431             }
1432         }
1433     }
1434 
1435     public void visitSkip(JCSkip tree) {
1436         result = null;
1437     }
1438 
1439     public void visitBlock(JCBlock tree) {
1440         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {
1441             // Block is a static or instance initializer;
1442             // let the owner of the environment be a freshly
1443             // created BLOCK-method.
1444             Symbol fakeOwner =
1445                 new MethodSymbol(tree.flags | BLOCK |
1446                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1447                     env.info.scope.owner);
1448             final Env&lt;AttrContext&gt; localEnv =
1449                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1450 
1451             if ((tree.flags &amp; STATIC) != 0)
1452                 localEnv.info.staticLevel++;
1453             else if (tree.stats.size() &gt; 0)
1454                 env.info.scope.owner.flags_field |= HASINITBLOCK;
1455 
1456             // Attribute all type annotations in the block
1457             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1458             annotate.flush();
1459             attribStats(tree.stats, localEnv);
1460 
1461             {
1462                 // Store init and clinit type annotations with the ClassSymbol
1463                 // to allow output in Gen.normalizeDefs.
1464                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
1465                 List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();
1466                 if ((tree.flags &amp; STATIC) != 0) {
1467                     cs.appendClassInitTypeAttributes(tas);
1468                 } else {
1469                     cs.appendInitTypeAttributes(tas);
1470                 }
1471             }
1472         } else {
1473             // Create a new local environment with a local scope.
1474             Env&lt;AttrContext&gt; localEnv =
1475                 env.dup(tree, env.info.dup(env.info.scope.dup()));
1476             try {
1477                 attribStats(tree.stats, localEnv);
1478             } finally {
1479                 localEnv.info.scope.leave();
1480             }
1481         }
1482         result = null;
1483     }
1484 
1485     public void visitDoLoop(JCDoWhileLoop tree) {
1486         attribStat(tree.body, env.dup(tree));
1487         attribExpr(tree.cond, env, syms.booleanType);
1488         if (!breaksOutOf(tree, tree.body)) {
1489             //include condition&#39;s body when false after the while, if cannot get out of the loop
1490             MatchBindings condBindings = matchBindings;
1491             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1492             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1493         }
1494         result = null;
1495     }
1496 
1497     public void visitWhileLoop(JCWhileLoop tree) {
1498         attribExpr(tree.cond, env, syms.booleanType);
1499         MatchBindings condBindings = matchBindings;
1500         // include condition&#39;s bindings when true in the body:
1501         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1502         try {
1503             attribStat(tree.body, whileEnv.dup(tree));
1504         } finally {
1505             whileEnv.info.scope.leave();
1506         }
1507         if (!breaksOutOf(tree, tree.body)) {
1508             //include condition&#39;s bindings when false after the while, if cannot get out of the loop
1509             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1510             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1511         }
1512         result = null;
1513     }
1514 
1515     private boolean breaksOutOf(JCTree loop, JCTree body) {
1516         preFlow(body);
1517         return flow.breaksOutOf(env, loop, body, make);
1518     }
1519 
1520     public void visitWithField(JCWithField tree) {
1521         boolean inWithField = env.info.inWithField;
1522         try {
1523             env.info.inWithField = true;
1524             Type fieldtype = attribTree(tree.field, env.dup(tree), varAssignmentInfo);
1525             attribExpr(tree.value, env, fieldtype);
1526             Type capturedType = syms.errType;
1527             if (tree.field.type != null &amp;&amp; !tree.field.type.isErroneous()) {
1528                 final Symbol sym = TreeInfo.symbol(tree.field);
1529                 if (sym == null || sym.kind != VAR || sym.owner.kind != TYP ||
1530                         (sym.flags() &amp; STATIC) != 0 || !types.isValue(sym.owner.type)) {
1531                     log.error(tree.field.pos(), Errors.ValueInstanceFieldExpectedHere);
1532                 } else {
1533                     Type ownType = sym.owner.type;
1534                     switch(tree.field.getTag()) {
1535                         case IDENT:
1536                             JCIdent ident = (JCIdent) tree.field;
1537                             ownType = ident.sym.owner.type;
1538                             break;
1539                         case SELECT:
1540                             JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;
1541                             ownType = fieldAccess.selected.type;
1542                             break;
1543                     }
1544                     capturedType = capture(ownType);
1545                 }
1546             }
1547             result = check(tree, capturedType, KindSelector.VAL, resultInfo);
1548         } finally {
1549             env.info.inWithField = inWithField;
1550         }
1551     }
1552 
1553     public void visitForLoop(JCForLoop tree) {
1554         Env&lt;AttrContext&gt; loopEnv =
1555             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1556         MatchBindings condBindings = MatchBindingsComputer.EMPTY;
1557         try {
1558             attribStats(tree.init, loopEnv);
1559             if (tree.cond != null) {
1560                 attribExpr(tree.cond, loopEnv, syms.booleanType);
1561                 // include condition&#39;s bindings when true in the body and step:
1562                 condBindings = matchBindings;
1563             }
1564             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);
1565             try {
1566                 bodyEnv.tree = tree; // before, we were not in loop!
1567                 attribStats(tree.step, bodyEnv);
1568                 attribStat(tree.body, bodyEnv);
1569             } finally {
1570                 bodyEnv.info.scope.leave();
1571             }
1572             result = null;
1573         }
1574         finally {
1575             loopEnv.info.scope.leave();
1576         }
1577         if (!breaksOutOf(tree, tree.body)) {
1578             //include condition&#39;s body when false after the while, if cannot get out of the loop
1579             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1580             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1581         }
1582     }
1583 
1584     public void visitForeachLoop(JCEnhancedForLoop tree) {
1585         Env&lt;AttrContext&gt; loopEnv =
1586             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1587         try {
1588             //the Formal Parameter of a for-each loop is not in the scope when
1589             //attributing the for-each expression; we mimic this by attributing
1590             //the for-each expression first (against original scope).
1591             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1592             chk.checkNonVoid(tree.pos(), exprType);
1593             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1594             if (elemtype == null) {
1595                 // or perhaps expr implements Iterable&lt;T&gt;?
1596                 Type base = types.asSuper(exprType, syms.iterableType.tsym, true);
1597                 if (base == null) {
1598                     log.error(tree.expr.pos(),
1599                               Errors.ForeachNotApplicableToType(exprType,
1600                                                                 Fragments.TypeReqArrayOrIterable));
1601                     elemtype = types.createErrorType(exprType);
1602                 } else {
1603                     List&lt;Type&gt; iterableParams = base.allparams();
1604                     elemtype = iterableParams.isEmpty()
1605                         ? syms.objectType
1606                         : types.wildUpperBound(iterableParams.head);
1607                 }
1608             }
1609             if (tree.var.isImplicitlyTyped()) {
1610                 Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);
1611                 setSyntheticVariableType(tree.var, inferredType);
1612             }
1613             attribStat(tree.var, loopEnv);
1614             chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
1615             loopEnv.tree = tree; // before, we were not in loop!
1616             attribStat(tree.body, loopEnv);
1617             result = null;
1618         }
1619         finally {
1620             loopEnv.info.scope.leave();
1621         }
1622     }
1623 
1624     public void visitLabelled(JCLabeledStatement tree) {
1625         // Check that label is not used in an enclosing statement
1626         Env&lt;AttrContext&gt; env1 = env;
1627         while (env1 != null &amp;&amp; !env1.tree.hasTag(CLASSDEF)) {
1628             if (env1.tree.hasTag(LABELLED) &amp;&amp;
1629                 ((JCLabeledStatement) env1.tree).label == tree.label) {
1630                 log.error(tree.pos(),
1631                           Errors.LabelAlreadyInUse(tree.label));
1632                 break;
1633             }
1634             env1 = env1.next;
1635         }
1636 
1637         attribStat(tree.body, env.dup(tree));
1638         result = null;
1639     }
1640 
1641     public void visitSwitch(JCSwitch tree) {
1642         handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
1643             attribStats(c.stats, caseEnv);
1644         });
1645         result = null;
1646     }
1647 
1648     public void visitSwitchExpression(JCSwitchExpression tree) {
1649         tree.polyKind = (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly) ?
1650                 PolyKind.STANDALONE : PolyKind.POLY;
1651 
1652         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1653             //this means we are returning a poly conditional from void-compatible lambda expression
1654             resultInfo.checkContext.report(tree, diags.fragment(Fragments.SwitchExpressionTargetCantBeVoid));
1655             result = tree.type = types.createErrorType(resultInfo.pt);
1656             return;
1657         }
1658 
1659         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1660                 unknownExprInfo :
1661                 resultInfo.dup(switchExpressionContext(resultInfo.checkContext));
1662 
1663         ListBuffer&lt;DiagnosticPosition&gt; caseTypePositions = new ListBuffer&lt;&gt;();
1664         ListBuffer&lt;Type&gt; caseTypes = new ListBuffer&lt;&gt;();
1665 
1666         handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
1667             caseEnv.info.yieldResult = condInfo;
1668             attribStats(c.stats, caseEnv);
1669             new TreeScanner() {
1670                 @Override
1671                 public void visitYield(JCYield brk) {
1672                     if (brk.target == tree) {
1673                         caseTypePositions.append(brk.value != null ? brk.value.pos() : brk.pos());
1674                         caseTypes.append(brk.value != null ? brk.value.type : syms.errType);
1675                     }
1676                     super.visitYield(brk);
1677                 }
1678 
1679                 @Override public void visitClassDef(JCClassDecl tree) {}
1680                 @Override public void visitLambda(JCLambda tree) {}
1681             }.scan(c.stats);
1682         });
1683 
1684         if (tree.cases.isEmpty()) {
1685             log.error(tree.pos(),
1686                       Errors.SwitchExpressionEmpty);
1687         } else if (caseTypes.isEmpty()) {
1688             log.error(tree.pos(),
1689                       Errors.SwitchExpressionNoResultExpressions);
1690         }
1691 
1692         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ? condType(caseTypePositions.toList(), caseTypes.toList()) : pt();
1693 
1694         result = tree.type = check(tree, owntype, KindSelector.VAL, resultInfo);
1695     }
1696     //where:
1697         CheckContext switchExpressionContext(CheckContext checkContext) {
1698             return new Check.NestedCheckContext(checkContext) {
1699                 //this will use enclosing check context to check compatibility of
1700                 //subexpression against target type; if we are in a method check context,
1701                 //depending on whether boxing is allowed, we could have incompatibilities
1702                 @Override
1703                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
1704                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInSwitchExpression(details)));
1705                 }
1706             };
1707         }
1708 
1709     private void handleSwitch(JCTree switchTree,
1710                               JCExpression selector,
1711                               List&lt;JCCase&gt; cases,
1712                               BiConsumer&lt;JCCase, Env&lt;AttrContext&gt;&gt; attribCase) {
1713         Type seltype = attribExpr(selector, env);
1714 
1715         Env&lt;AttrContext&gt; switchEnv =
1716             env.dup(switchTree, env.info.dup(env.info.scope.dup()));
1717 
1718         try {
1719             boolean enumSwitch = (seltype.tsym.flags() &amp; Flags.ENUM) != 0;
1720             boolean stringSwitch = types.isSameType(seltype, syms.stringType);
1721             if (!enumSwitch &amp;&amp; !stringSwitch)
1722                 seltype = chk.checkType(selector.pos(), seltype, syms.intType);
1723 
1724             // Attribute all cases and
1725             // check that there are no duplicate case labels or default clauses.
1726             Set&lt;Object&gt; labels = new HashSet&lt;&gt;(); // The set of case labels.
1727             boolean hasDefault = false;      // Is there a default label?
1728             CaseTree.CaseKind caseKind = null;
1729             boolean wasError = false;
1730             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1731                 JCCase c = l.head;
1732                 if (caseKind == null) {
1733                     caseKind = c.caseKind;
1734                 } else if (caseKind != c.caseKind &amp;&amp; !wasError) {
1735                     log.error(c.pos(),
1736                               Errors.SwitchMixingCaseTypes);
1737                     wasError = true;
1738                 }
1739                 if (c.getExpressions().nonEmpty()) {
1740                     for (JCExpression pat : c.getExpressions()) {
1741                         if (TreeInfo.isNull(pat)) {
1742                             log.error(pat.pos(),
1743                                       Errors.SwitchNullNotAllowed);
1744                         } else if (enumSwitch) {
1745                             Symbol sym = enumConstant(pat, seltype);
1746                             if (sym == null) {
1747                                 log.error(pat.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);
1748                             } else if (!labels.add(sym)) {
1749                                 log.error(c.pos(), Errors.DuplicateCaseLabel);
1750                             }
1751                         } else {
1752                             Type pattype = attribExpr(pat, switchEnv, seltype);
1753                             if (!pattype.hasTag(ERROR)) {
1754                                 if (pattype.constValue() == null) {
1755                                     log.error(pat.pos(),
1756                                               (stringSwitch ? Errors.StringConstReq : Errors.ConstExprReq));
1757                                 } else if (!labels.add(pattype.constValue())) {
1758                                     log.error(c.pos(), Errors.DuplicateCaseLabel);
1759                                 }
1760                             }
1761                         }
1762                     }
1763                 } else if (hasDefault) {
1764                     log.error(c.pos(), Errors.DuplicateDefaultLabel);
1765                 } else {
1766                     hasDefault = true;
1767                 }
1768                 Env&lt;AttrContext&gt; caseEnv =
1769                     switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));
1770                 try {
1771                     attribCase.accept(c, caseEnv);
1772                 } finally {
1773                     caseEnv.info.scope.leave();
1774                 }
1775                 addVars(c.stats, switchEnv.info.scope);
1776             }
1777         } finally {
1778             switchEnv.info.scope.leave();
1779         }
1780     }
1781     // where
1782         /** Add any variables defined in stats to the switch scope. */
1783         private static void addVars(List&lt;JCStatement&gt; stats, WriteableScope switchScope) {
1784             for (;stats.nonEmpty(); stats = stats.tail) {
1785                 JCTree stat = stats.head;
1786                 if (stat.hasTag(VARDEF))
1787                     switchScope.enter(((JCVariableDecl) stat).sym);
1788             }
1789         }
1790     // where
1791     /** Return the selected enumeration constant symbol, or null. */
1792     private Symbol enumConstant(JCTree tree, Type enumType) {
1793         if (tree.hasTag(IDENT)) {
1794             JCIdent ident = (JCIdent)tree;
1795             Name name = ident.name;
1796             for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {
1797                 if (sym.kind == VAR) {
1798                     Symbol s = ident.sym = sym;
1799                     ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated
1800                     ident.type = s.type;
1801                     return ((s.flags_field &amp; Flags.ENUM) == 0)
1802                         ? null : s;
1803                 }
1804             }
1805         }
1806         return null;
1807     }
1808 
1809     public void visitSynchronized(JCSynchronized tree) {
1810         chk.checkRefType(tree.pos(), attribExpr(tree.lock, env), false);
1811         attribStat(tree.body, env);
1812         result = null;
1813     }
1814 
1815     public void visitTry(JCTry tree) {
1816         // Create a new local environment with a local
1817         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
1818         try {
1819             boolean isTryWithResource = tree.resources.nonEmpty();
1820             // Create a nested environment for attributing the try block if needed
1821             Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
1822                 env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
1823                 localEnv;
1824             try {
1825                 // Attribute resource declarations
1826                 for (JCTree resource : tree.resources) {
1827                     CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
1828                         @Override
1829                         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1830                             chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
1831                         }
1832                     };
1833                     ResultInfo twrResult =
1834                         new ResultInfo(KindSelector.VAR,
1835                                        syms.autoCloseableType,
1836                                        twrContext);
1837                     if (resource.hasTag(VARDEF)) {
1838                         attribStat(resource, tryEnv);
1839                         twrResult.check(resource, resource.type);
1840 
1841                         //check that resource type cannot throw InterruptedException
1842                         checkAutoCloseable(resource.pos(), localEnv, resource.type);
1843 
1844                         VarSymbol var = ((JCVariableDecl) resource).sym;
1845                         var.setData(ElementKind.RESOURCE_VARIABLE);
1846                     } else {
1847                         attribTree(resource, tryEnv, twrResult);
1848                     }
1849                 }
1850                 // Attribute body
1851                 attribStat(tree.body, tryEnv);
1852             } finally {
1853                 if (isTryWithResource)
1854                     tryEnv.info.scope.leave();
1855             }
1856 
1857             // Attribute catch clauses
1858             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1859                 JCCatch c = l.head;
1860                 Env&lt;AttrContext&gt; catchEnv =
1861                     localEnv.dup(c, localEnv.info.dup(localEnv.info.scope.dup()));
1862                 try {
1863                     Type ctype = attribStat(c.param, catchEnv);
1864                     if (TreeInfo.isMultiCatch(c)) {
1865                         //multi-catch parameter is implicitly marked as final
1866                         c.param.sym.flags_field |= FINAL | UNION;
1867                     }
1868                     if (c.param.sym.kind == VAR) {
1869                         c.param.sym.setData(ElementKind.EXCEPTION_PARAMETER);
1870                     }
1871                     chk.checkType(c.param.vartype.pos(),
1872                                   chk.checkClassType(c.param.vartype.pos(), ctype),
1873                                   syms.throwableType);
1874                     attribStat(c.body, catchEnv);
1875                 } finally {
1876                     catchEnv.info.scope.leave();
1877                 }
1878             }
1879 
1880             // Attribute finalizer
1881             if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);
1882             result = null;
1883         }
1884         finally {
1885             localEnv.info.scope.leave();
1886         }
1887     }
1888 
1889     void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {
1890         if (!resource.isErroneous() &amp;&amp;
1891             types.asSuper(resource, syms.autoCloseableType.tsym, true) != null &amp;&amp;
1892             !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself
1893             Symbol close = syms.noSymbol;
1894             Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
1895             try {
1896                 close = rs.resolveQualifiedMethod(pos,
1897                         env,
1898                         types.skipTypeVars(resource, false),
1899                         names.close,
1900                         List.nil(),
1901                         List.nil());
1902             }
1903             finally {
1904                 log.popDiagnosticHandler(discardHandler);
1905             }
1906             if (close.kind == MTH &amp;&amp;
1907                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1908                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1909                     env.info.lint.isEnabled(LintCategory.TRY)) {
1910                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1911             }
1912         }
1913     }
1914 
1915     public void visitConditional(JCConditional tree) {
1916         Type condtype = attribExpr(tree.cond, env, syms.booleanType);
1917         MatchBindings condBindings = matchBindings;
1918 
1919         tree.polyKind = (!allowPoly ||
1920                 pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly ||
1921                 isBooleanOrNumeric(env, tree)) ?
1922                 PolyKind.STANDALONE : PolyKind.POLY;
1923 
1924         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1925             //this means we are returning a poly conditional from void-compatible lambda expression
1926             resultInfo.checkContext.report(tree, diags.fragment(Fragments.ConditionalTargetCantBeVoid));
1927             result = tree.type = types.createErrorType(resultInfo.pt);
1928             return;
1929         }
1930 
1931         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1932                 unknownExprInfo :
1933                 resultInfo.dup(conditionalContext(resultInfo.checkContext));
1934 
1935 
1936         // x ? y : z
1937         // include x&#39;s bindings when true in y
1938         // include x&#39;s bindings when false in z
1939 
1940         Type truetype;
1941         Env&lt;AttrContext&gt; trueEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1942         try {
1943             truetype = attribTree(tree.truepart, trueEnv, condInfo);
1944         } finally {
1945             trueEnv.info.scope.leave();
1946         }
1947 
1948         MatchBindings trueBindings = matchBindings;
1949 
1950         Type falsetype;
1951         Env&lt;AttrContext&gt; falseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);
1952         try {
1953             falsetype = attribTree(tree.falsepart, falseEnv, condInfo);
1954         } finally {
1955             falseEnv.info.scope.leave();
1956         }
1957 
1958         MatchBindings falseBindings = matchBindings;
1959 
1960         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ?
1961                 condType(List.of(tree.truepart.pos(), tree.falsepart.pos()),
1962                          List.of(truetype, falsetype)) : pt();
1963         if (condtype.constValue() != null &amp;&amp;
1964                 truetype.constValue() != null &amp;&amp;
1965                 falsetype.constValue() != null &amp;&amp;
1966                 !owntype.hasTag(NONE)) {
1967             //constant folding
1968             owntype = cfolder.coerce(condtype.isTrue() ? truetype : falsetype, owntype);
1969         }
1970         result = check(tree, owntype, KindSelector.VAL, resultInfo);
1971         matchBindings = matchBindingsComputer.conditional(tree, condBindings, trueBindings, falseBindings);
1972     }
1973     //where
1974         private boolean isBooleanOrNumeric(Env&lt;AttrContext&gt; env, JCExpression tree) {
1975             switch (tree.getTag()) {
1976                 case LITERAL: return ((JCLiteral)tree).typetag.isSubRangeOf(DOUBLE) ||
1977                               ((JCLiteral)tree).typetag == BOOLEAN ||
1978                               ((JCLiteral)tree).typetag == BOT;
1979                 case LAMBDA: case REFERENCE: return false;
1980                 case PARENS: return isBooleanOrNumeric(env, ((JCParens)tree).expr);
1981                 case CONDEXPR:
1982                     JCConditional condTree = (JCConditional)tree;
1983                     return isBooleanOrNumeric(env, condTree.truepart) &amp;&amp;
1984                             isBooleanOrNumeric(env, condTree.falsepart);
1985                 case APPLY:
1986                     JCMethodInvocation speculativeMethodTree =
1987                             (JCMethodInvocation)deferredAttr.attribSpeculative(
1988                                     tree, env, unknownExprInfo,
1989                                     argumentAttr.withLocalCacheContext());
1990                     Symbol msym = TreeInfo.symbol(speculativeMethodTree.meth);
1991                     Type receiverType = speculativeMethodTree.meth.hasTag(IDENT) ?
1992                             env.enclClass.type :
1993                             ((JCFieldAccess)speculativeMethodTree.meth).selected.type;
1994                     Type owntype = types.memberType(receiverType, msym).getReturnType();
1995                     return primitiveOrBoxed(owntype);
1996                 case NEWCLASS:
1997                     JCExpression className =
1998                             removeClassParams.translate(((JCNewClass)tree).clazz);
1999                     JCExpression speculativeNewClassTree =
2000                             (JCExpression)deferredAttr.attribSpeculative(
2001                                     className, env, unknownTypeInfo,
2002                                     argumentAttr.withLocalCacheContext());
2003                     return primitiveOrBoxed(speculativeNewClassTree.type);
2004                 default:
2005                     Type speculativeType = deferredAttr.attribSpeculative(tree, env, unknownExprInfo,
2006                             argumentAttr.withLocalCacheContext()).type;
2007                     return primitiveOrBoxed(speculativeType);
2008             }
2009         }
2010         //where
2011             boolean primitiveOrBoxed(Type t) {
2012                 return (!t.hasTag(TYPEVAR) &amp;&amp; types.unboxedTypeOrType(t).isPrimitive());
2013             }
2014 
2015             TreeTranslator removeClassParams = new TreeTranslator() {
2016                 @Override
2017                 public void visitTypeApply(JCTypeApply tree) {
2018                     result = translate(tree.clazz);
2019                 }
2020             };
2021 
2022         CheckContext conditionalContext(CheckContext checkContext) {
2023             return new Check.NestedCheckContext(checkContext) {
2024                 //this will use enclosing check context to check compatibility of
2025                 //subexpression against target type; if we are in a method check context,
2026                 //depending on whether boxing is allowed, we could have incompatibilities
2027                 @Override
2028                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
2029                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInConditional(details)));
2030                 }
2031             };
2032         }
2033 
2034         /** Compute the type of a conditional expression, after
2035          *  checking that it exists.  See JLS 15.25. Does not take into
2036          *  account the special case where condition and both arms
2037          *  are constants.
2038          *
2039          *  @param pos      The source position to be used for error
2040          *                  diagnostics.
2041          *  @param thentype The type of the expression&#39;s then-part.
2042          *  @param elsetype The type of the expression&#39;s else-part.
2043          */
2044         Type condType(List&lt;DiagnosticPosition&gt; positions, List&lt;Type&gt; condTypes) {
2045             if (condTypes.isEmpty()) {
2046                 return syms.objectType; //TODO: how to handle?
2047             }
2048             Type first = condTypes.head;
2049             // If same type, that is the result
2050             if (condTypes.tail.stream().allMatch(t -&gt; types.isSameType(first, t)))
2051                 return first.baseType();
2052 
2053             List&lt;Type&gt; unboxedTypes = condTypes.stream()
2054                                                .map(t -&gt; t.isPrimitive() ? t : types.unboxedType(t))
2055                                                .collect(List.collector());
2056 
2057             // Otherwise, if both arms can be converted to a numeric
2058             // type, return the least numeric type that fits both arms
2059             // (i.e. return larger of the two, or return int if one
2060             // arm is short, the other is char).
2061             if (unboxedTypes.stream().allMatch(t -&gt; t.isPrimitive())) {
2062                 // If one arm has an integer subrange type (i.e., byte,
2063                 // short, or char), and the other is an integer constant
2064                 // that fits into the subrange, return the subrange type.
2065                 for (Type type : unboxedTypes) {
2066                     if (!type.getTag().isStrictSubRangeOf(INT)) {
2067                         continue;
2068                     }
2069                     if (unboxedTypes.stream().filter(t -&gt; t != type).allMatch(t -&gt; t.hasTag(INT) &amp;&amp; types.isAssignable(t, type)))
2070                         return type.baseType();
2071                 }
2072 
2073                 for (TypeTag tag : primitiveTags) {
2074                     Type candidate = syms.typeOfTag[tag.ordinal()];
2075                     if (unboxedTypes.stream().allMatch(t -&gt; types.isSubtype(t, candidate))) {
2076                         return candidate;
2077                     }
2078                 }
2079             }
2080 
2081             // Those were all the cases that could result in a primitive
2082             condTypes = condTypes.stream()
2083                                  .map(t -&gt; t.isPrimitive() ? types.boxedClass(t).type : t)
2084                                  .collect(List.collector());
2085 
2086             for (Type type : condTypes) {
2087                 if (condTypes.stream().filter(t -&gt; t != type).allMatch(t -&gt; types.isAssignable(t, type)))
2088                     return type.baseType();
2089             }
2090 
2091             Iterator&lt;DiagnosticPosition&gt; posIt = positions.iterator();
2092 
2093             condTypes = condTypes.stream()
2094                                  .map(t -&gt; chk.checkNonVoid(posIt.next(), t))
2095                                  .collect(List.collector());
2096 
2097             // both are known to be reference types.  The result is
2098             // lub(thentype,elsetype). This cannot fail, as it will
2099             // always be possible to infer &quot;Object&quot; if nothing better.
2100             return types.lub(condTypes.stream().map(t -&gt; t.baseType()).collect(List.collector()));
2101         }
2102 
2103     final static TypeTag[] primitiveTags = new TypeTag[]{
2104         BYTE,
2105         CHAR,
2106         SHORT,
2107         INT,
2108         LONG,
2109         FLOAT,
2110         DOUBLE,
2111         BOOLEAN,
2112     };
2113 
2114     Env&lt;AttrContext&gt; bindingEnv(Env&lt;AttrContext&gt; env, List&lt;BindingSymbol&gt; bindings) {
2115         Env&lt;AttrContext&gt; env1 = env.dup(env.tree, env.info.dup(env.info.scope.dup()));
2116         bindings.forEach(env1.info.scope::enter);
2117         return env1;
2118     }
2119 
2120     public void visitIf(JCIf tree) {
2121         attribExpr(tree.cond, env, syms.booleanType);
2122 
2123         // if (x) { y } [ else z ]
2124         // include x&#39;s bindings when true in y
2125         // include x&#39;s bindings when false in z
2126 
2127         MatchBindings condBindings = matchBindings;
2128         Env&lt;AttrContext&gt; thenEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
2129 
2130         try {
2131             attribStat(tree.thenpart, thenEnv);
2132         } finally {
2133             thenEnv.info.scope.leave();
2134         }
2135 
2136         preFlow(tree.thenpart);
2137         boolean aliveAfterThen = flow.aliveAfter(env, tree.thenpart, make);
2138         boolean aliveAfterElse;
2139 
2140         if (tree.elsepart != null) {
2141             Env&lt;AttrContext&gt; elseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);
2142             try {
2143                 attribStat(tree.elsepart, elseEnv);
2144             } finally {
2145                 elseEnv.info.scope.leave();
2146             }
2147             preFlow(tree.elsepart);
2148             aliveAfterElse = flow.aliveAfter(env, tree.elsepart, make);
2149         } else {
2150             aliveAfterElse = true;
2151         }
2152 
2153         chk.checkEmptyIf(tree);
2154 
2155         List&lt;BindingSymbol&gt; afterIfBindings = List.nil();
2156 
2157         if (aliveAfterThen &amp;&amp; !aliveAfterElse) {
2158             afterIfBindings = condBindings.bindingsWhenTrue;
2159         } else if (aliveAfterElse &amp;&amp; !aliveAfterThen) {
2160             afterIfBindings = condBindings.bindingsWhenFalse;
2161         }
2162 
2163         afterIfBindings.forEach(env.info.scope::enter);
2164         afterIfBindings.forEach(BindingSymbol::preserveBinding);
2165 
2166         result = null;
2167     }
2168 
2169         void preFlow(JCTree tree) {
2170             new PostAttrAnalyzer() {
2171                 @Override
2172                 public void scan(JCTree tree) {
2173                     if (tree == null ||
2174                             (tree.type != null &amp;&amp;
2175                             tree.type == Type.stuckType)) {
2176                         //don&#39;t touch stuck expressions!
2177                         return;
2178                     }
2179                     super.scan(tree);
2180                 }
2181             }.scan(tree);
2182         }
2183 
2184     public void visitExec(JCExpressionStatement tree) {
2185         //a fresh environment is required for 292 inference to work properly ---
2186         //see Infer.instantiatePolymorphicSignatureInstance()
2187         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2188         attribExpr(tree.expr, localEnv);
2189         result = null;
2190     }
2191 
2192     public void visitBreak(JCBreak tree) {
2193         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2194         result = null;
2195     }
2196 
2197     public void visitYield(JCYield tree) {
2198         if (env.info.yieldResult != null) {
2199             attribTree(tree.value, env, env.info.yieldResult);
2200             tree.target = findJumpTarget(tree.pos(), tree.getTag(), names.empty, env);
2201         } else {
2202             log.error(tree.pos(), tree.value.hasTag(PARENS)
2203                     ? Errors.NoSwitchExpressionQualify
2204                     : Errors.NoSwitchExpression);
2205             attribTree(tree.value, env, unknownExprInfo);
2206         }
2207         result = null;
2208     }
2209 
2210     public void visitContinue(JCContinue tree) {
2211         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2212         result = null;
2213     }
2214     //where
2215         /** Return the target of a break, continue or yield statement,
2216          *  if it exists, report an error if not.
2217          *  Note: The target of a labelled break or continue is the
2218          *  (non-labelled) statement tree referred to by the label,
2219          *  not the tree representing the labelled statement itself.
2220          *
2221          *  @param pos     The position to be used for error diagnostics
2222          *  @param tag     The tag of the jump statement. This is either
2223          *                 Tree.BREAK or Tree.CONTINUE.
2224          *  @param label   The label of the jump statement, or null if no
2225          *                 label is given.
2226          *  @param env     The environment current at the jump statement.
2227          */
2228         private JCTree findJumpTarget(DiagnosticPosition pos,
2229                                                    JCTree.Tag tag,
2230                                                    Name label,
2231                                                    Env&lt;AttrContext&gt; env) {
2232             Pair&lt;JCTree, Error&gt; jumpTarget = findJumpTargetNoError(tag, label, env);
2233 
2234             if (jumpTarget.snd != null) {
2235                 log.error(pos, jumpTarget.snd);
2236             }
2237 
2238             return jumpTarget.fst;
2239         }
2240         /** Return the target of a break or continue statement, if it exists,
2241          *  report an error if not.
2242          *  Note: The target of a labelled break or continue is the
2243          *  (non-labelled) statement tree referred to by the label,
2244          *  not the tree representing the labelled statement itself.
2245          *
2246          *  @param tag     The tag of the jump statement. This is either
2247          *                 Tree.BREAK or Tree.CONTINUE.
2248          *  @param label   The label of the jump statement, or null if no
2249          *                 label is given.
2250          *  @param env     The environment current at the jump statement.
2251          */
2252         private Pair&lt;JCTree, JCDiagnostic.Error&gt; findJumpTargetNoError(JCTree.Tag tag,
2253                                                                        Name label,
2254                                                                        Env&lt;AttrContext&gt; env) {
2255             // Search environments outwards from the point of jump.
2256             Env&lt;AttrContext&gt; env1 = env;
2257             JCDiagnostic.Error pendingError = null;
2258             LOOP:
2259             while (env1 != null) {
2260                 switch (env1.tree.getTag()) {
2261                     case LABELLED:
2262                         JCLabeledStatement labelled = (JCLabeledStatement)env1.tree;
2263                         if (label == labelled.label) {
2264                             // If jump is a continue, check that target is a loop.
2265                             if (tag == CONTINUE) {
2266                                 if (!labelled.body.hasTag(DOLOOP) &amp;&amp;
2267                                         !labelled.body.hasTag(WHILELOOP) &amp;&amp;
2268                                         !labelled.body.hasTag(FORLOOP) &amp;&amp;
2269                                         !labelled.body.hasTag(FOREACHLOOP)) {
2270                                     pendingError = Errors.NotLoopLabel(label);
2271                                 }
2272                                 // Found labelled statement target, now go inwards
2273                                 // to next non-labelled tree.
2274                                 return Pair.of(TreeInfo.referencedStatement(labelled), pendingError);
2275                             } else {
2276                                 return Pair.of(labelled, pendingError);
2277                             }
2278                         }
2279                         break;
2280                     case DOLOOP:
2281                     case WHILELOOP:
2282                     case FORLOOP:
2283                     case FOREACHLOOP:
2284                         if (label == null) return Pair.of(env1.tree, pendingError);
2285                         break;
2286                     case SWITCH:
2287                         if (label == null &amp;&amp; tag == BREAK) return Pair.of(env1.tree, null);
2288                         break;
2289                     case SWITCH_EXPRESSION:
2290                         if (tag == YIELD) {
2291                             return Pair.of(env1.tree, null);
2292                         } else if (tag == BREAK) {
2293                             pendingError = Errors.BreakOutsideSwitchExpression;
2294                         } else {
2295                             pendingError = Errors.ContinueOutsideSwitchExpression;
2296                         }
2297                         break;
2298                     case LAMBDA:
2299                     case METHODDEF:
2300                     case CLASSDEF:
2301                         break LOOP;
2302                     default:
2303                 }
2304                 env1 = env1.next;
2305             }
2306             if (label != null)
2307                 return Pair.of(null, Errors.UndefLabel(label));
2308             else if (pendingError != null)
2309                 return Pair.of(null, pendingError);
2310             else if (tag == CONTINUE)
2311                 return Pair.of(null, Errors.ContOutsideLoop);
2312             else
2313                 return Pair.of(null, Errors.BreakOutsideSwitchLoop);
2314         }
2315 
2316     public void visitReturn(JCReturn tree) {
2317         // Check that there is an enclosing method which is
2318         // nested within than the enclosing class.
2319         if (env.info.returnResult == null) {
2320             log.error(tree.pos(), Errors.RetOutsideMeth);
2321         } else if (env.info.yieldResult != null) {
2322             log.error(tree.pos(), Errors.ReturnOutsideSwitchExpression);
2323         } else if (!env.info.isLambda &amp;&amp;
2324                 !env.info.isNewClass &amp;&amp;
2325                 env.enclMethod != null &amp;&amp;
2326                 TreeInfo.isCompactConstructor(env.enclMethod)) {
2327             log.error(env.enclMethod,
2328                     Errors.InvalidCanonicalConstructorInRecord(Fragments.Compact, env.enclMethod.sym.name, Fragments.CanonicalCantHaveReturnStatement));
2329         } else {
2330             // Attribute return expression, if it exists, and check that
2331             // it conforms to result type of enclosing method.
2332             if (tree.expr != null) {
2333                 if (env.info.returnResult.pt.hasTag(VOID)) {
2334                     env.info.returnResult.checkContext.report(tree.expr.pos(),
2335                               diags.fragment(Fragments.UnexpectedRetVal));
2336                 }
2337                 attribTree(tree.expr, env, env.info.returnResult);
2338             } else if (!env.info.returnResult.pt.hasTag(VOID) &amp;&amp;
2339                     !env.info.returnResult.pt.hasTag(NONE)) {
2340                 env.info.returnResult.checkContext.report(tree.pos(),
2341                               diags.fragment(Fragments.MissingRetVal(env.info.returnResult.pt)));
2342             }
2343         }
2344         result = null;
2345     }
2346 
2347     public void visitThrow(JCThrow tree) {
2348         Type owntype = attribExpr(tree.expr, env, allowPoly ? Type.noType : syms.throwableType);
2349         if (allowPoly) {
2350             chk.checkType(tree, owntype, syms.throwableType);
2351         }
2352         result = null;
2353     }
2354 
2355     public void visitAssert(JCAssert tree) {
2356         attribExpr(tree.cond, env, syms.booleanType);
2357         if (tree.detail != null) {
2358             chk.checkNonVoid(tree.detail.pos(), attribExpr(tree.detail, env));
2359         }
2360         result = null;
2361     }
2362 
2363      /** Visitor method for method invocations.
2364      *  NOTE: The method part of an application will have in its type field
2365      *        the return type of the method, not the method&#39;s type itself!
2366      */
2367     public void visitApply(JCMethodInvocation tree) {
2368         // The local environment of a method application is
2369         // a new environment nested in the current one.
2370         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2371 
2372         // The types of the actual method arguments.
2373         List&lt;Type&gt; argtypes;
2374 
2375         // The types of the actual method type arguments.
2376         List&lt;Type&gt; typeargtypes = null;
2377 
2378         Name methName = TreeInfo.name(tree.meth);
2379 
2380         boolean isConstructorCall =
2381             methName == names._this || methName == names._super;
2382 
2383         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2384         if (isConstructorCall) {
2385             // We are seeing a ...this(...) or ...super(...) call.
2386             // Check that this is the first statement in a constructor.
2387             checkFirstConstructorStat(tree, env.enclMethod, true);
2388 
2389             // Record the fact
2390             // that this is a constructor call (using isSelfCall).
2391             localEnv.info.isSelfCall = true;
2392 
2393             // Attribute arguments, yielding list of argument types.
2394             KindSelector kind = attribArgs(KindSelector.MTH, tree.args, localEnv, argtypesBuf);
2395             argtypes = argtypesBuf.toList();
2396             typeargtypes = attribTypes(tree.typeargs, localEnv);
2397 
2398             // Variable `site&#39; points to the class in which the called
2399             // constructor is defined.
2400             Type site = env.enclClass.sym.type;
2401             if (methName == names._super) {
2402                 if (site == syms.objectType) {
2403                     log.error(tree.meth.pos(), Errors.NoSuperclass(site));
2404                     site = types.createErrorType(syms.objectType);
2405                 } else {
2406                     site = types.supertype(site);
2407                 }
2408             }
2409 
2410             if (site.hasTag(CLASS)) {
2411                 Type encl = site.getEnclosingType();
2412                 while (encl != null &amp;&amp; encl.hasTag(TYPEVAR))
2413                     encl = encl.getUpperBound();
2414                 if (encl.hasTag(CLASS)) {
2415                     // we are calling a nested class
2416 
2417                     if (tree.meth.hasTag(SELECT)) {
2418                         JCTree qualifier = ((JCFieldAccess) tree.meth).selected;
2419 
2420                         // We are seeing a prefixed call, of the form
2421                         //     &lt;expr&gt;.super(...).
2422                         // Check that the prefix expression conforms
2423                         // to the outer instance type of the class.
2424                         chk.checkRefType(qualifier.pos(),
2425                                          attribExpr(qualifier, localEnv,
2426                                                     encl));
2427                     } else if (methName == names._super) {
2428                         // qualifier omitted; check for existence
2429                         // of an appropriate implicit qualifier.
2430                         rs.resolveImplicitThis(tree.meth.pos(),
2431                                                localEnv, site, true);
2432                     }
2433                 } else if (tree.meth.hasTag(SELECT)) {
2434                     log.error(tree.meth.pos(),
2435                               Errors.IllegalQualNotIcls(site.tsym));
2436                 }
2437 
2438                 // if we&#39;re calling a java.lang.Enum constructor,
2439                 // prefix the implicit String and int parameters
2440                 if (site.tsym == syms.enumSym)
2441                     argtypes = argtypes.prepend(syms.intType).prepend(syms.stringType);
2442 
2443                 // Resolve the called constructor under the assumption
2444                 // that we are referring to a superclass instance of the
2445                 // current instance (JLS ???).
2446                 boolean selectSuperPrev = localEnv.info.selectSuper;
2447                 localEnv.info.selectSuper = true;
2448                 localEnv.info.pendingResolutionPhase = null;
2449                 Symbol sym = rs.resolveConstructor(
2450                     tree.meth.pos(), localEnv, site, argtypes, typeargtypes);
2451                 localEnv.info.selectSuper = selectSuperPrev;
2452 
2453                 // Set method symbol to resolved constructor...
2454                 TreeInfo.setSymbol(tree.meth, sym);
2455 
2456                 // ...and check that it is legal in the current context.
2457                 // (this will also set the tree&#39;s type)
2458                 Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2459                 checkId(tree.meth, site, sym, localEnv,
2460                         new ResultInfo(kind, mpt));
2461             }
2462             // Otherwise, `site&#39; is an error type and we do nothing
2463             result = tree.type = syms.voidType;
2464         } else {
2465             // Otherwise, we are seeing a regular method call.
2466             // Attribute the arguments, yielding list of argument types, ...
2467             KindSelector kind = attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2468             argtypes = argtypesBuf.toList();
2469             typeargtypes = attribAnyTypes(tree.typeargs, localEnv);
2470 
2471             // ... and attribute the method using as a prototype a methodtype
2472             // whose formal argument types is exactly the list of actual
2473             // arguments (this will also set the method symbol).
2474             Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2475             localEnv.info.pendingResolutionPhase = null;
2476             Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
2477 
2478             // Compute the result type.
2479             Type restype = mtype.getReturnType();
2480             if (restype.hasTag(WILDCARD))
2481                 throw new AssertionError(mtype);
2482 
2483             Type qualifier = (tree.meth.hasTag(SELECT))
2484                     ? ((JCFieldAccess) tree.meth).selected.type
2485                     : env.enclClass.sym.type;
2486             Symbol msym = TreeInfo.symbol(tree.meth);
2487             restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
2488 
2489             chk.checkRefTypes(tree.typeargs, typeargtypes);
2490 
2491             final Symbol symbol = TreeInfo.symbol(tree.meth);
2492             if (symbol != null) {
2493                 /* Is this an ill conceived attempt to invoke jlO methods not available on value types ??
2494                  */
2495                 boolean superCallOnValueReceiver = types.isValue(env.enclClass.sym.type)
2496                         &amp;&amp; (tree.meth.hasTag(SELECT))
2497                         &amp;&amp; ((JCFieldAccess)tree.meth).selected.hasTag(IDENT)
2498                         &amp;&amp; TreeInfo.name(((JCFieldAccess)tree.meth).selected) == names._super;
2499                 if (types.isValue(qualifier) || superCallOnValueReceiver) {
2500                     int argSize = argtypes.size();
2501                     Name name = symbol.name;
2502                     switch (name.toString()) {
2503                         case &quot;wait&quot;:
2504                             if (argSize == 0
2505                                     || (types.isConvertible(argtypes.head, syms.longType) &amp;&amp;
2506                                     (argSize == 1 || (argSize == 2 &amp;&amp; types.isConvertible(argtypes.tail.head, syms.intType))))) {
2507                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));
2508                             }
2509                             break;
2510                         case &quot;notify&quot;:
2511                         case &quot;notifyAll&quot;:
2512                         case &quot;clone&quot;:
2513                         case &quot;finalize&quot;:
2514                             if (argSize == 0)
2515                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));
2516                             break;
2517                         case &quot;hashCode&quot;:
2518                         case &quot;equals&quot;:
2519                         case &quot;toString&quot;:
2520                             if (superCallOnValueReceiver)
2521                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(names.fromString(&quot;invocation of super.&quot; + name)));
2522                             break;
2523                     }
2524                 }
2525             }
2526 
2527             // Check that value of resulting type is admissible in the
2528             // current context.  Also, capture the return type
2529             Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);
2530             result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
2531         }
2532         chk.validate(tree.typeargs, localEnv);
2533     }
2534     //where
2535         Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {
2536             if (msym != null &amp;&amp;
2537                     msym.owner == syms.objectType.tsym &amp;&amp;
2538                     methodName == names.getClass &amp;&amp;
2539                     argtypes.isEmpty()) {
2540                 // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;
2541                 // Temporary treatment for inline class: Given an inline class V that implements
2542                 // I1, I2, ... In, v.getClass() is typed to be Class&lt;? extends Object &amp; I1 &amp; I2 .. &amp; In&gt;
2543                 Type wcb;
2544                 if (qualifierType.isValue()) {
2545                     List&lt;Type&gt; bounds = List.of(syms.objectType).appendList(((ClassSymbol) qualifierType.tsym).getInterfaces());
2546                     wcb = bounds.size() &gt; 1 ? types.makeIntersectionType(bounds) : syms.objectType;
2547                 } else {
2548                     wcb = types.erasure(qualifierType);
2549                 }
2550                 return new ClassType(restype.getEnclosingType(),
2551                         List.of(new WildcardType(wcb,
2552                                 BoundKind.EXTENDS,
2553                                 syms.boundClass)),
2554                         restype.tsym,
2555                         restype.getMetadata());
2556             } else if (msym != null &amp;&amp;
2557                     msym.owner == syms.arrayClass &amp;&amp;
2558                     methodName == names.clone &amp;&amp;
2559                     types.isArray(qualifierType)) {
2560                 // as a special case, array.clone() has a result that is
2561                 // the same as static type of the array being cloned
2562                 return qualifierType;
2563             } else {
2564                 return restype;
2565             }
2566         }
2567 
2568         /** Check that given application node appears as first statement
2569          *  in a constructor call.
2570          *  @param tree          The application node
2571          *  @param enclMethod    The enclosing method of the application.
2572          *  @param error         Should an error be issued?
2573          */
2574         boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {
2575             if (enclMethod != null &amp;&amp; enclMethod.name == names.init) {
2576                 JCBlock body = enclMethod.body;
2577                 if (body.stats.head.hasTag(EXEC) &amp;&amp;
2578                     ((JCExpressionStatement) body.stats.head).expr == tree)
2579                     return true;
2580             }
2581             if (error) {
2582                 log.error(tree.pos(),
2583                         Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));
2584             }
2585             return false;
2586         }
2587 
2588         /** Obtain a method type with given argument types.
2589          */
2590         Type newMethodTemplate(Type restype, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2591             MethodType mt = new MethodType(argtypes, restype, List.nil(), syms.methodClass);
2592             return (typeargtypes == null) ? mt : (Type)new ForAll(typeargtypes, mt);
2593         }
2594 
2595     public void visitNewClass(final JCNewClass tree) {
2596         Type owntype = types.createErrorType(tree.type);
2597 
2598         // The local environment of a class creation is
2599         // a new environment nested in the current one.
2600         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2601 
2602         // The anonymous inner class definition of the new expression,
2603         // if one is defined by it.
2604         JCClassDecl cdef = tree.def;
2605 
2606         // If enclosing class is given, attribute it, and
2607         // complete class name to be fully qualified
2608         JCExpression clazz = tree.clazz; // Class field following new
2609         JCExpression clazzid;            // Identifier in class field
2610         JCAnnotatedType annoclazzid;     // Annotated type enclosing clazzid
2611         annoclazzid = null;
2612 
2613         if (clazz.hasTag(TYPEAPPLY)) {
2614             clazzid = ((JCTypeApply) clazz).clazz;
2615             if (clazzid.hasTag(ANNOTATED_TYPE)) {
2616                 annoclazzid = (JCAnnotatedType) clazzid;
2617                 clazzid = annoclazzid.underlyingType;
2618             }
2619         } else {
2620             if (clazz.hasTag(ANNOTATED_TYPE)) {
2621                 annoclazzid = (JCAnnotatedType) clazz;
2622                 clazzid = annoclazzid.underlyingType;
2623             } else {
2624                 clazzid = clazz;
2625             }
2626         }
2627 
2628         JCExpression clazzid1 = clazzid; // The same in fully qualified form
2629 
2630         if (tree.encl != null) {
2631             // We are seeing a qualified new, of the form
2632             //    &lt;expr&gt;.new C &lt;...&gt; (...) ...
2633             // In this case, we let clazz stand for the name of the
2634             // allocated class C prefixed with the type of the qualifier
2635             // expression, so that we can
2636             // resolve it with standard techniques later. I.e., if
2637             // &lt;expr&gt; has type T, then &lt;expr&gt;.new C &lt;...&gt; (...)
2638             // yields a clazz T.C.
2639             Type encltype = chk.checkRefType(tree.encl.pos(),
2640                                              attribExpr(tree.encl, env));
2641             // TODO 308: in &lt;expr&gt;.new C, do we also want to add the type annotations
2642             // from expr to the combined type, or not? Yes, do this.
2643             clazzid1 = make.at(clazz.pos).Select(make.Type(encltype),
2644                                                  ((JCIdent) clazzid).name);
2645 
2646             EndPosTable endPosTable = this.env.toplevel.endPositions;
2647             endPosTable.storeEnd(clazzid1, tree.getEndPosition(endPosTable));
2648             if (clazz.hasTag(ANNOTATED_TYPE)) {
2649                 JCAnnotatedType annoType = (JCAnnotatedType) clazz;
2650                 List&lt;JCAnnotation&gt; annos = annoType.annotations;
2651 
2652                 if (annoType.underlyingType.hasTag(TYPEAPPLY)) {
2653                     clazzid1 = make.at(tree.pos).
2654                         TypeApply(clazzid1,
2655                                   ((JCTypeApply) clazz).arguments);
2656                 }
2657 
2658                 clazzid1 = make.at(tree.pos).
2659                     AnnotatedType(annos, clazzid1);
2660             } else if (clazz.hasTag(TYPEAPPLY)) {
2661                 clazzid1 = make.at(tree.pos).
2662                     TypeApply(clazzid1,
2663                               ((JCTypeApply) clazz).arguments);
2664             }
2665 
2666             clazz = clazzid1;
2667         }
2668 
2669         // Attribute clazz expression and store
2670         // symbol + type back into the attributed tree.
2671         Type clazztype;
2672 
2673         try {
2674             env.info.isNewClass = true;
2675             clazztype = TreeInfo.isEnumInit(env.tree) ?
2676                 attribIdentAsEnumType(env, (JCIdent)clazz) :
2677                 attribType(clazz, env);
2678         } finally {
2679             env.info.isNewClass = false;
2680         }
2681 
2682         clazztype = chk.checkDiamond(tree, clazztype);
2683         chk.validate(clazz, localEnv);
2684         if (tree.encl != null) {
2685             // We have to work in this case to store
2686             // symbol + type back into the attributed tree.
2687             tree.clazz.type = clazztype;
2688             TreeInfo.setSymbol(clazzid, TreeInfo.symbol(clazzid1));
2689             clazzid.type = ((JCIdent) clazzid).sym.type;
2690             if (annoclazzid != null) {
2691                 annoclazzid.type = clazzid.type;
2692             }
2693             if (!clazztype.isErroneous()) {
2694                 if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2695                     log.error(tree.encl.pos(), Errors.AnonClassImplIntfNoQualForNew);
2696                 } else if (clazztype.tsym.isStatic()) {
2697                     log.error(tree.encl.pos(), Errors.QualifiedNewOfStaticClass(clazztype.tsym));
2698                 }
2699             }
2700         } else if (!clazztype.tsym.isInterface() &amp;&amp;
2701                    clazztype.getEnclosingType().hasTag(CLASS)) {
2702             // Check for the existence of an apropos outer instance
2703             rs.resolveImplicitThis(tree.pos(), env, clazztype);
2704         }
2705 
2706         // Attribute constructor arguments.
2707         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2708         final KindSelector pkind =
2709             attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2710         List&lt;Type&gt; argtypes = argtypesBuf.toList();
2711         List&lt;Type&gt; typeargtypes = attribTypes(tree.typeargs, localEnv);
2712 
2713         if (clazztype.hasTag(CLASS) || clazztype.hasTag(ERROR)) {
2714             // Enums may not be instantiated except implicitly
2715             if ((clazztype.tsym.flags_field &amp; Flags.ENUM) != 0 &amp;&amp;
2716                 (!env.tree.hasTag(VARDEF) ||
2717                  (((JCVariableDecl) env.tree).mods.flags &amp; Flags.ENUM) == 0 ||
2718                  ((JCVariableDecl) env.tree).init != tree))
2719                 log.error(tree.pos(), Errors.EnumCantBeInstantiated);
2720 
2721             boolean isSpeculativeDiamondInferenceRound = TreeInfo.isDiamond(tree) &amp;&amp;
2722                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
2723             boolean skipNonDiamondPath = false;
2724             // Check that it is an instantiation of a class and not a projection type
2725             if (clazz.hasTag(SELECT)) {
2726                 JCFieldAccess fieldAccess = (JCFieldAccess) clazz;
2727                 if (fieldAccess.selected.type.isValue() &amp;&amp;
2728                         (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {
2729                     log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);
2730                 }
2731             }
2732             // Check that class is not abstract
2733             if (cdef == null &amp;&amp; !isSpeculativeDiamondInferenceRound &amp;&amp; // class body may be nulled out in speculative tree copy
2734                 (clazztype.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
2735                 log.error(tree.pos(),
2736                           Errors.AbstractCantBeInstantiated(clazztype.tsym));
2737                 skipNonDiamondPath = true;
2738             } else if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2739                 // Check that no constructor arguments are given to
2740                 // anonymous classes implementing an interface
2741                 if (!argtypes.isEmpty())
2742                     log.error(tree.args.head.pos(), Errors.AnonClassImplIntfNoArgs);
2743 
2744                 if (!typeargtypes.isEmpty())
2745                     log.error(tree.typeargs.head.pos(), Errors.AnonClassImplIntfNoTypeargs);
2746 
2747                 // Error recovery: pretend no arguments were supplied.
2748                 argtypes = List.nil();
2749                 typeargtypes = List.nil();
2750                 skipNonDiamondPath = true;
2751             }
2752             if (TreeInfo.isDiamond(tree)) {
2753                 ClassType site = new ClassType(clazztype.getEnclosingType(),
2754                             clazztype.tsym.type.getTypeArguments(),
2755                                                clazztype.tsym,
2756                                                clazztype.getMetadata());
2757 
2758                 Env&lt;AttrContext&gt; diamondEnv = localEnv.dup(tree);
2759                 diamondEnv.info.selectSuper = cdef != null || tree.classDeclRemoved();
2760                 diamondEnv.info.pendingResolutionPhase = null;
2761 
2762                 //if the type of the instance creation expression is a class type
2763                 //apply method resolution inference (JLS 15.12.2.7). The return type
2764                 //of the resolved constructor will be a partially instantiated type
2765                 Symbol constructor = rs.resolveDiamond(tree.pos(),
2766                             diamondEnv,
2767                             site,
2768                             argtypes,
2769                             typeargtypes);
2770                 tree.constructor = constructor.baseSymbol();
2771 
2772                 final TypeSymbol csym = clazztype.tsym;
2773                 ResultInfo diamondResult = new ResultInfo(pkind, newMethodTemplate(resultInfo.pt, argtypes, typeargtypes),
2774                         diamondContext(tree, csym, resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
2775                 Type constructorType = tree.constructorType = types.createErrorType(clazztype);
2776                 constructorType = checkId(tree, site,
2777                         constructor,
2778                         diamondEnv,
2779                         diamondResult);
2780 
2781                 tree.clazz.type = types.createErrorType(clazztype);
2782                 if (!constructorType.isErroneous()) {
2783                     tree.clazz.type = clazz.type = constructorType.getReturnType();
2784                     tree.constructorType = types.createMethodTypeWithReturn(constructorType, syms.voidType);
2785                 }
2786                 clazztype = chk.checkClassType(tree.clazz, tree.clazz.type, true);
2787             }
2788 
2789             // Resolve the called constructor under the assumption
2790             // that we are referring to a superclass instance of the
2791             // current instance (JLS ???).
2792             else if (!skipNonDiamondPath) {
2793                 //the following code alters some of the fields in the current
2794                 //AttrContext - hence, the current context must be dup&#39;ed in
2795                 //order to avoid downstream failures
2796                 Env&lt;AttrContext&gt; rsEnv = localEnv.dup(tree);
2797                 rsEnv.info.selectSuper = cdef != null;
2798                 rsEnv.info.pendingResolutionPhase = null;
2799                 tree.constructor = rs.resolveConstructor(
2800                     tree.pos(), rsEnv, clazztype, argtypes, typeargtypes);
2801                 if (cdef == null) { //do not check twice!
2802                     tree.constructorType = checkId(tree,
2803                             clazztype,
2804                             tree.constructor,
2805                             rsEnv,
2806                             new ResultInfo(pkind, newMethodTemplate(syms.voidType, argtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));
2807                     if (rsEnv.info.lastResolveVarargs())
2808                         Assert.check(tree.constructorType.isErroneous() || tree.varargsElement != null);
2809                 }
2810             }
2811 
2812             if (cdef != null) {
2813                 visitAnonymousClassDefinition(tree, clazz, clazztype, cdef, localEnv, argtypes, typeargtypes, pkind);
2814                 return;
2815             }
2816 
2817             if (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH)
2818                 owntype = clazztype;
2819         }
2820         result = check(tree, owntype, KindSelector.VAL, resultInfo);
2821         InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
2822         if (tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType)) {
2823             //we need to wait for inference to finish and then replace inference vars in the constructor type
2824             inferenceContext.addFreeTypeListener(List.of(tree.constructorType),
2825                     instantiatedContext -&gt; {
2826                         tree.constructorType = instantiatedContext.asInstType(tree.constructorType);
2827                     });
2828         }
2829         chk.validate(tree.typeargs, localEnv);
2830     }
2831 
2832         // where
2833         private void visitAnonymousClassDefinition(JCNewClass tree, JCExpression clazz, Type clazztype,
2834                                                    JCClassDecl cdef, Env&lt;AttrContext&gt; localEnv,
2835                                                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
2836                                                    KindSelector pkind) {
2837             // We are seeing an anonymous class instance creation.
2838             // In this case, the class instance creation
2839             // expression
2840             //
2841             //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
2842             //
2843             // is represented internally as
2844             //
2845             //    E . new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) ( class &lt;empty-name&gt; { ... } )  .
2846             //
2847             // This expression is then *transformed* as follows:
2848             //
2849             // (1) add an extends or implements clause
2850             // (2) add a constructor.
2851             //
2852             // For instance, if C is a class, and ET is the type of E,
2853             // the expression
2854             //
2855             //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
2856             //
2857             // is translated to (where X is a fresh name and typarams is the
2858             // parameter list of the super constructor):
2859             //
2860             //   new &lt;typeargs1&gt;X(&lt;*nullchk*&gt;E, args) where
2861             //     X extends C&lt;typargs2&gt; {
2862             //       &lt;typarams&gt; X(ET e, args) {
2863             //         e.&lt;typeargs1&gt;super(args)
2864             //       }
2865             //       ...
2866             //     }
2867             InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
2868             final boolean isDiamond = TreeInfo.isDiamond(tree);
2869             if (isDiamond
2870                     &amp;&amp; ((tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType))
2871                     || (tree.clazz.type != null &amp;&amp; inferenceContext.free(tree.clazz.type)))) {
2872                 final ResultInfo resultInfoForClassDefinition = this.resultInfo;
2873                 inferenceContext.addFreeTypeListener(List.of(tree.constructorType, tree.clazz.type),
2874                         instantiatedContext -&gt; {
2875                             tree.constructorType = instantiatedContext.asInstType(tree.constructorType);
2876                             tree.clazz.type = clazz.type = instantiatedContext.asInstType(clazz.type);
2877                             ResultInfo prevResult = this.resultInfo;
2878                             try {
2879                                 this.resultInfo = resultInfoForClassDefinition;
2880                                 visitAnonymousClassDefinition(tree, clazz, clazz.type, cdef,
2881                                                             localEnv, argtypes, typeargtypes, pkind);
2882                             } finally {
2883                                 this.resultInfo = prevResult;
2884                             }
2885                         });
2886             } else {
2887                 if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
2888                     List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
2889                     if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {
2890                         // One or more types inferred in the previous steps is non-denotable.
2891                         Fragment fragment = Diamond(clazztype.tsym);
2892                         log.error(tree.clazz.pos(),
2893                                 Errors.CantApplyDiamond1(
2894                                         fragment,
2895                                         invalidDiamondArgs.size() &gt; 1 ?
2896                                                 DiamondInvalidArgs(invalidDiamondArgs, fragment) :
2897                                                 DiamondInvalidArg(invalidDiamondArgs, fragment)));
2898                     }
2899                     // For &lt;&gt;(){}, inferred types must also be accessible.
2900                     for (Type t : clazztype.getTypeArguments()) {
2901                         rs.checkAccessibleType(env, t);
2902                     }
2903                     chk.checkParameterizationWithValues(tree, clazztype);
2904                 }
2905 
2906                 // If we already errored, be careful to avoid a further avalanche. ErrorType answers
2907                 // false for isInterface call even when the original type is an interface.
2908                 boolean implementing = clazztype.tsym.isInterface() ||
2909                         clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
2910                         clazztype.getOriginalType().tsym.isInterface();
2911 
2912                 if (implementing) {
2913                     cdef.implementing = List.of(clazz);
2914                 } else {
2915                     cdef.extending = clazz;
2916                 }
2917 
2918                 if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
2919                     isSerializable(clazztype)) {
2920                     localEnv.info.isSerializable = true;
2921                 }
2922 
2923                 attribStat(cdef, localEnv);
2924 
2925                 List&lt;Type&gt; finalargtypes;
2926                 // If an outer instance is given,
2927                 // prefix it to the constructor arguments
2928                 // and delete it from the new expression
2929                 if (tree.encl != null &amp;&amp; !clazztype.tsym.isInterface()) {
2930                     finalargtypes = argtypes.prepend(tree.encl.type);
2931                 } else {
2932                     finalargtypes = argtypes;
2933                 }
2934 
2935                 // Reassign clazztype and recompute constructor. As this necessarily involves
2936                 // another attribution pass for deferred types in the case of &lt;&gt;, replicate
2937                 // them. Original arguments have right decorations already.
2938                 if (isDiamond &amp;&amp; pkind.contains(KindSelector.POLY)) {
2939                     finalargtypes = finalargtypes.map(deferredAttr.deferredCopier);
2940                 }
2941 
2942                 clazztype = clazztype.hasTag(ERROR) ? types.createErrorType(cdef.sym.type)
2943                                                     : cdef.sym.type;
2944                 Symbol sym = tree.constructor = rs.resolveConstructor(
2945                         tree.pos(), localEnv, clazztype, finalargtypes, typeargtypes);
2946                 Assert.check(!sym.kind.isResolutionError());
2947                 tree.constructor = sym;
2948                 tree.constructorType = checkId(tree,
2949                         clazztype,
2950                         tree.constructor,
2951                         localEnv,
2952                         new ResultInfo(pkind, newMethodTemplate(syms.voidType, finalargtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));
2953             }
2954             Type owntype = (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH) ?
2955                                 clazztype : types.createErrorType(tree.type);
2956             result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));
2957             chk.validate(tree.typeargs, localEnv);
2958         }
2959 
2960         CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {
2961             return new Check.NestedCheckContext(checkContext) {
2962                 @Override
2963                 public void report(DiagnosticPosition _unused, JCDiagnostic details) {
2964                     enclosingContext.report(clazz.clazz,
2965                             diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
2966                 }
2967             };
2968         }
2969 
2970     /** Make an attributed null check tree.
2971      */
2972     public JCExpression makeNullCheck(JCExpression arg) {
2973         // optimization: new Outer() can never be null; skip null check
2974         if (arg.getTag() == NEWCLASS)
2975             return arg;
2976         // Likewise arg can&#39;t be null if it is a value.
2977         if (types.isValue(arg.type))
2978             return arg;
2979         // optimization: X.this is never null; skip null check
2980         Name name = TreeInfo.name(arg);
2981         if (name == names._this || name == names._super) return arg;
2982 
2983         JCTree.Tag optag = NULLCHK;
2984         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
2985         tree.operator = operators.resolveUnary(arg, optag, arg.type);
2986         tree.type = arg.type;
2987         return tree;
2988     }
2989 
2990     public void visitNewArray(JCNewArray tree) {
2991         Type owntype = types.createErrorType(tree.type);
2992         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2993         Type elemtype;
2994         if (tree.elemtype != null) {
2995             elemtype = attribType(tree.elemtype, localEnv);
2996             chk.validate(tree.elemtype, localEnv);
2997             owntype = elemtype;
2998             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
2999                 attribExpr(l.head, localEnv, syms.intType);
3000                 owntype = new ArrayType(owntype, syms.arrayClass);
3001             }
3002         } else {
3003             // we are seeing an untyped aggregate { ... }
3004             // this is allowed only if the prototype is an array
3005             if (pt().hasTag(ARRAY)) {
3006                 elemtype = types.elemtype(pt());
3007             } else {
3008                 if (!pt().hasTag(ERROR) &amp;&amp;
3009                         (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3010                     log.error(tree.pos(),
3011                               Errors.IllegalInitializerForType(pt()));
3012                 }
3013                 elemtype = types.createErrorType(pt());
3014             }
3015         }
3016         if (tree.elems != null) {
3017             attribExprs(tree.elems, localEnv, elemtype);
3018             owntype = new ArrayType(elemtype, syms.arrayClass);
3019         }
3020         if (!types.isReifiable(elemtype))
3021             log.error(tree.pos(), Errors.GenericArrayCreation);
3022         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3023     }
3024 
3025     /*
3026      * A lambda expression can only be attributed when a target-type is available.
3027      * In addition, if the target-type is that of a functional interface whose
3028      * descriptor contains inference variables in argument position the lambda expression
3029      * is &#39;stuck&#39; (see DeferredAttr).
3030      */
3031     @Override
3032     public void visitLambda(final JCLambda that) {
3033         boolean wrongContext = false;
3034         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
3035             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3036                 //lambda only allowed in assignment or method invocation/cast context
3037                 log.error(that.pos(), Errors.UnexpectedLambda);
3038             }
3039             resultInfo = recoveryInfo;
3040             wrongContext = true;
3041         }
3042         //create an environment for attribution of the lambda expression
3043         final Env&lt;AttrContext&gt; localEnv = lambdaEnv(that, env);
3044         boolean needsRecovery =
3045                 resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK;
3046         try {
3047             if (needsRecovery &amp;&amp; isSerializable(pt())) {
3048                 localEnv.info.isSerializable = true;
3049                 localEnv.info.isSerializableLambda = true;
3050             }
3051             localEnv.info.isLambda = true;
3052             List&lt;Type&gt; explicitParamTypes = null;
3053             if (that.paramKind == JCLambda.ParameterKind.EXPLICIT) {
3054                 //attribute lambda parameters
3055                 attribStats(that.params, localEnv);
3056                 explicitParamTypes = TreeInfo.types(that.params);
3057             }
3058 
3059             TargetInfo targetInfo = getTargetInfo(that, resultInfo, explicitParamTypes);
3060             Type currentTarget = targetInfo.target;
3061             Type lambdaType = targetInfo.descriptor;
3062 
3063             if (currentTarget.isErroneous()) {
3064                 result = that.type = currentTarget;
3065                 return;
3066             }
3067 
3068             setFunctionalInfo(localEnv, that, pt(), lambdaType, currentTarget, resultInfo.checkContext);
3069 
3070             if (lambdaType.hasTag(FORALL)) {
3071                 //lambda expression target desc cannot be a generic method
3072                 Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
3073                                                                     kindName(currentTarget.tsym),
3074                                                                     currentTarget.tsym);
3075                 resultInfo.checkContext.report(that, diags.fragment(msg));
3076                 result = that.type = types.createErrorType(pt());
3077                 return;
3078             }
3079 
3080             if (that.paramKind == JCLambda.ParameterKind.IMPLICIT) {
3081                 //add param type info in the AST
3082                 List&lt;Type&gt; actuals = lambdaType.getParameterTypes();
3083                 List&lt;JCVariableDecl&gt; params = that.params;
3084 
3085                 boolean arityMismatch = false;
3086 
3087                 while (params.nonEmpty()) {
3088                     if (actuals.isEmpty()) {
3089                         //not enough actuals to perform lambda parameter inference
3090                         arityMismatch = true;
3091                     }
3092                     //reset previously set info
3093                     Type argType = arityMismatch ?
3094                             syms.errType :
3095                             actuals.head;
3096                     if (params.head.isImplicitlyTyped()) {
3097                         setSyntheticVariableType(params.head, argType);
3098                     }
3099                     params.head.sym = null;
3100                     actuals = actuals.isEmpty() ?
3101                             actuals :
3102                             actuals.tail;
3103                     params = params.tail;
3104                 }
3105 
3106                 //attribute lambda parameters
3107                 attribStats(that.params, localEnv);
3108 
3109                 if (arityMismatch) {
3110                     resultInfo.checkContext.report(that, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
3111                         result = that.type = types.createErrorType(currentTarget);
3112                         return;
3113                 }
3114             }
3115 
3116             //from this point on, no recovery is needed; if we are in assignment context
3117             //we will be able to attribute the whole lambda body, regardless of errors;
3118             //if we are in a &#39;check&#39; method context, and the lambda is not compatible
3119             //with the target-type, it will be recovered anyway in Attr.checkId
3120             needsRecovery = false;
3121 
3122             ResultInfo bodyResultInfo = localEnv.info.returnResult =
3123                     lambdaBodyResult(that, lambdaType, resultInfo);
3124 
3125             if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
3126                 attribTree(that.getBody(), localEnv, bodyResultInfo);
3127             } else {
3128                 JCBlock body = (JCBlock)that.body;
3129                 if (body == breakTree &amp;&amp;
3130                         resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3131                     breakTreeFound(copyEnv(localEnv));
3132                 }
3133                 attribStats(body.stats, localEnv);
3134             }
3135 
3136             result = check(that, currentTarget, KindSelector.VAL, resultInfo);
3137 
3138             boolean isSpeculativeRound =
3139                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
3140 
3141             preFlow(that);
3142             flow.analyzeLambda(env, that, make, isSpeculativeRound);
3143 
3144             that.type = currentTarget; //avoids recovery at this stage
3145             checkLambdaCompatible(that, lambdaType, resultInfo.checkContext);
3146 
3147             if (!isSpeculativeRound) {
3148                 //add thrown types as bounds to the thrown types free variables if needed:
3149                 if (resultInfo.checkContext.inferenceContext().free(lambdaType.getThrownTypes())) {
3150                     List&lt;Type&gt; inferredThrownTypes = flow.analyzeLambdaThrownTypes(env, that, make);
3151                     if(!checkExConstraints(inferredThrownTypes, lambdaType.getThrownTypes(), resultInfo.checkContext.inferenceContext())) {
3152                         log.error(that, Errors.IncompatibleThrownTypesInMref(lambdaType.getThrownTypes()));
3153                     }
3154                 }
3155 
3156                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), lambdaType, currentTarget);
3157             }
3158             result = wrongContext ? that.type = types.createErrorType(pt())
3159                                   : check(that, currentTarget, KindSelector.VAL, resultInfo);
3160         } catch (Types.FunctionDescriptorLookupError ex) {
3161             JCDiagnostic cause = ex.getDiagnostic();
3162             resultInfo.checkContext.report(that, cause);
3163             result = that.type = types.createErrorType(pt());
3164             return;
3165         } catch (CompletionFailure cf) {
3166             chk.completionError(that.pos(), cf);
3167         } catch (Throwable t) {
3168             //when an unexpected exception happens, avoid attempts to attribute the same tree again
3169             //as that would likely cause the same exception again.
3170             needsRecovery = false;
3171             throw t;
3172         } finally {
3173             localEnv.info.scope.leave();
3174             if (needsRecovery) {
3175                 attribTree(that, env, recoveryInfo);
3176             }
3177         }
3178     }
3179     //where
3180         class TargetInfo {
3181             Type target;
3182             Type descriptor;
3183 
3184             public TargetInfo(Type target, Type descriptor) {
3185                 this.target = target;
3186                 this.descriptor = descriptor;
3187             }
3188         }
3189 
3190         TargetInfo getTargetInfo(JCPolyExpression that, ResultInfo resultInfo, List&lt;Type&gt; explicitParamTypes) {
3191             Type lambdaType;
3192             Type currentTarget = resultInfo.pt;
3193             if (resultInfo.pt != Type.recoveryType) {
3194                 /* We need to adjust the target. If the target is an
3195                  * intersection type, for example: SAM &amp; I1 &amp; I2 ...
3196                  * the target will be updated to SAM
3197                  */
3198                 currentTarget = targetChecker.visit(currentTarget, that);
3199                 if (!currentTarget.isIntersection()) {
3200                     if (explicitParamTypes != null) {
3201                         currentTarget = infer.instantiateFunctionalInterface(that,
3202                                 currentTarget, explicitParamTypes, resultInfo.checkContext);
3203                     }
3204                     currentTarget = types.removeWildcards(currentTarget);
3205                     lambdaType = types.findDescriptorType(currentTarget);
3206                 } else {
3207                     IntersectionClassType ict = (IntersectionClassType)currentTarget;
3208                     ListBuffer&lt;Type&gt; components = new ListBuffer&lt;&gt;();
3209                     for (Type bound : ict.getExplicitComponents()) {
3210                         if (explicitParamTypes != null) {
3211                             try {
3212                                 bound = infer.instantiateFunctionalInterface(that,
3213                                         bound, explicitParamTypes, resultInfo.checkContext);
3214                             } catch (FunctionDescriptorLookupError t) {
3215                                 // do nothing
3216                             }
3217                         }
3218                         bound = types.removeWildcards(bound);
3219                         components.add(bound);
3220                     }
3221                     currentTarget = types.makeIntersectionType(components.toList());
3222                     currentTarget.tsym.flags_field |= INTERFACE;
3223                     lambdaType = types.findDescriptorType(currentTarget);
3224                 }
3225 
3226             } else {
3227                 currentTarget = Type.recoveryType;
3228                 lambdaType = fallbackDescriptorType(that);
3229             }
3230             if (that.hasTag(LAMBDA) &amp;&amp; lambdaType.hasTag(FORALL)) {
3231                 //lambda expression target desc cannot be a generic method
3232                 Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
3233                                                                     kindName(currentTarget.tsym),
3234                                                                     currentTarget.tsym);
3235                 resultInfo.checkContext.report(that, diags.fragment(msg));
3236                 currentTarget = types.createErrorType(pt());
3237             }
3238             return new TargetInfo(currentTarget, lambdaType);
3239         }
3240 
3241         void preFlow(JCLambda tree) {
3242             new PostAttrAnalyzer() {
3243                 @Override
3244                 public void scan(JCTree tree) {
3245                     if (tree == null ||
3246                             (tree.type != null &amp;&amp;
3247                             tree.type == Type.stuckType)) {
3248                         //don&#39;t touch stuck expressions!
3249                         return;
3250                     }
3251                     super.scan(tree);
3252                 }
3253 
3254                 @Override
3255                 public void visitClassDef(JCClassDecl that) {
3256                     // or class declaration trees!
3257                 }
3258 
3259                 public void visitLambda(JCLambda that) {
3260                     // or lambda expressions!
3261                 }
3262             }.scan(tree.body);
3263         }
3264 
3265         Types.MapVisitor&lt;DiagnosticPosition&gt; targetChecker = new Types.MapVisitor&lt;DiagnosticPosition&gt;() {
3266 
3267             @Override
3268             public Type visitClassType(ClassType t, DiagnosticPosition pos) {
3269                 return t.isIntersection() ?
3270                         visitIntersectionClassType((IntersectionClassType)t, pos) : t;
3271             }
3272 
3273             public Type visitIntersectionClassType(IntersectionClassType ict, DiagnosticPosition pos) {
3274                 types.findDescriptorSymbol(makeNotionalInterface(ict, pos));
3275                 return ict;
3276             }
3277 
3278             private TypeSymbol makeNotionalInterface(IntersectionClassType ict, DiagnosticPosition pos) {
3279                 ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
3280                 ListBuffer&lt;Type&gt; supertypes = new ListBuffer&lt;&gt;();
3281                 for (Type i : ict.interfaces_field) {
3282                     if (i.isParameterized()) {
3283                         targs.appendList(i.tsym.type.allparams());
3284                     }
3285                     supertypes.append(i.tsym.type);
3286                 }
3287                 IntersectionClassType notionalIntf = types.makeIntersectionType(supertypes.toList());
3288                 notionalIntf.allparams_field = targs.toList();
3289                 notionalIntf.tsym.flags_field |= INTERFACE;
3290                 return notionalIntf.tsym;
3291             }
3292         };
3293 
3294         private Type fallbackDescriptorType(JCExpression tree) {
3295             switch (tree.getTag()) {
3296                 case LAMBDA:
3297                     JCLambda lambda = (JCLambda)tree;
3298                     List&lt;Type&gt; argtypes = List.nil();
3299                     for (JCVariableDecl param : lambda.params) {
3300                         argtypes = param.vartype != null &amp;&amp; param.vartype.type != null ?
3301                                 argtypes.append(param.vartype.type) :
3302                                 argtypes.append(syms.errType);
3303                     }
3304                     return new MethodType(argtypes, Type.recoveryType,
3305                             List.of(syms.throwableType), syms.methodClass);
3306                 case REFERENCE:
3307                     return new MethodType(List.nil(), Type.recoveryType,
3308                             List.of(syms.throwableType), syms.methodClass);
3309                 default:
3310                     Assert.error(&quot;Cannot get here!&quot;);
3311             }
3312             return null;
3313         }
3314 
3315         private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
3316                 final InferenceContext inferenceContext, final Type... ts) {
3317             checkAccessibleTypes(pos, env, inferenceContext, List.from(ts));
3318         }
3319 
3320         private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
3321                 final InferenceContext inferenceContext, final List&lt;Type&gt; ts) {
3322             if (inferenceContext.free(ts)) {
3323                 inferenceContext.addFreeTypeListener(ts,
3324                         solvedContext -&gt; checkAccessibleTypes(pos, env, solvedContext, solvedContext.asInstTypes(ts)));
3325             } else {
3326                 for (Type t : ts) {
3327                     rs.checkAccessibleType(env, t);
3328                 }
3329             }
3330         }
3331 
3332         /**
3333          * Lambda/method reference have a special check context that ensures
3334          * that i.e. a lambda return type is compatible with the expected
3335          * type according to both the inherited context and the assignment
3336          * context.
3337          */
3338         class FunctionalReturnContext extends Check.NestedCheckContext {
3339 
3340             FunctionalReturnContext(CheckContext enclosingContext) {
3341                 super(enclosingContext);
3342             }
3343 
3344             @Override
3345             public boolean compatible(Type found, Type req, Warner warn) {
3346                 //return type must be compatible in both current context and assignment context
3347                 return chk.basicHandler.compatible(inferenceContext().asUndetVar(found), inferenceContext().asUndetVar(req), warn);
3348             }
3349 
3350             @Override
3351             public void report(DiagnosticPosition pos, JCDiagnostic details) {
3352                 enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleRetTypeInLambda(details)));
3353             }
3354         }
3355 
3356         class ExpressionLambdaReturnContext extends FunctionalReturnContext {
3357 
3358             JCExpression expr;
3359             boolean expStmtExpected;
3360 
3361             ExpressionLambdaReturnContext(JCExpression expr, CheckContext enclosingContext) {
3362                 super(enclosingContext);
3363                 this.expr = expr;
3364             }
3365 
3366             @Override
3367             public void report(DiagnosticPosition pos, JCDiagnostic details) {
3368                 if (expStmtExpected) {
3369                     enclosingContext.report(pos, diags.fragment(Fragments.StatExprExpected));
3370                 } else {
3371                     super.report(pos, details);
3372                 }
3373             }
3374 
3375             @Override
3376             public boolean compatible(Type found, Type req, Warner warn) {
3377                 //a void return is compatible with an expression statement lambda
3378                 if (req.hasTag(VOID)) {
3379                     expStmtExpected = true;
3380                     return TreeInfo.isExpressionStatement(expr);
3381                 } else {
3382                     return super.compatible(found, req, warn);
3383                 }
3384             }
3385         }
3386 
3387         ResultInfo lambdaBodyResult(JCLambda that, Type descriptor, ResultInfo resultInfo) {
3388             FunctionalReturnContext funcContext = that.getBodyKind() == JCLambda.BodyKind.EXPRESSION ?
3389                     new ExpressionLambdaReturnContext((JCExpression)that.getBody(), resultInfo.checkContext) :
3390                     new FunctionalReturnContext(resultInfo.checkContext);
3391 
3392             return descriptor.getReturnType() == Type.recoveryType ?
3393                     recoveryInfo :
3394                     new ResultInfo(KindSelector.VAL,
3395                             descriptor.getReturnType(), funcContext);
3396         }
3397 
3398         /**
3399         * Lambda compatibility. Check that given return types, thrown types, parameter types
3400         * are compatible with the expected functional interface descriptor. This means that:
3401         * (i) parameter types must be identical to those of the target descriptor; (ii) return
3402         * types must be compatible with the return type of the expected descriptor.
3403         */
3404         void checkLambdaCompatible(JCLambda tree, Type descriptor, CheckContext checkContext) {
3405             Type returnType = checkContext.inferenceContext().asUndetVar(descriptor.getReturnType());
3406 
3407             //return values have already been checked - but if lambda has no return
3408             //values, we must ensure that void/value compatibility is correct;
3409             //this amounts at checking that, if a lambda body can complete normally,
3410             //the descriptor&#39;s return type must be void
3411             if (tree.getBodyKind() == JCLambda.BodyKind.STATEMENT &amp;&amp; tree.canCompleteNormally &amp;&amp;
3412                     !returnType.hasTag(VOID) &amp;&amp; returnType != Type.recoveryType) {
3413                 Fragment msg =
3414                         Fragments.IncompatibleRetTypeInLambda(Fragments.MissingRetVal(returnType));
3415                 checkContext.report(tree,
3416                                     diags.fragment(msg));
3417             }
3418 
3419             List&lt;Type&gt; argTypes = checkContext.inferenceContext().asUndetVars(descriptor.getParameterTypes());
3420             if (!types.isSameTypes(argTypes, TreeInfo.types(tree.params))) {
3421                 checkContext.report(tree, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
3422             }
3423         }
3424 
3425         /* Map to hold &#39;fake&#39; clinit methods. If a lambda is used to initialize a
3426          * static field and that lambda has type annotations, these annotations will
3427          * also be stored at these fake clinit methods.
3428          *
3429          * LambdaToMethod also use fake clinit methods so they can be reused.
3430          * Also as LTM is a phase subsequent to attribution, the methods from
3431          * clinits can be safely removed by LTM to save memory.
3432          */
3433         private Map&lt;ClassSymbol, MethodSymbol&gt; clinits = new HashMap&lt;&gt;();
3434 
3435         public MethodSymbol removeClinit(ClassSymbol sym) {
3436             return clinits.remove(sym);
3437         }
3438 
3439         /* This method returns an environment to be used to attribute a lambda
3440          * expression.
3441          *
3442          * The owner of this environment is a method symbol. If the current owner
3443          * is not a method, for example if the lambda is used to initialize
3444          * a field, then if the field is:
3445          *
3446          * - an instance field, we use the first constructor.
3447          * - a static field, we create a fake clinit method.
3448          */
3449         public Env&lt;AttrContext&gt; lambdaEnv(JCLambda that, Env&lt;AttrContext&gt; env) {
3450             Env&lt;AttrContext&gt; lambdaEnv;
3451             Symbol owner = env.info.scope.owner;
3452             if (owner.kind == VAR &amp;&amp; owner.owner.kind == TYP) {
3453                 //field initializer
3454                 ClassSymbol enclClass = owner.enclClass();
3455                 Symbol newScopeOwner = env.info.scope.owner;
3456                 /* if the field isn&#39;t static, then we can get the first constructor
3457                  * and use it as the owner of the environment. This is what
3458                  * LTM code is doing to look for type annotations so we are fine.
3459                  */
3460                 if ((owner.flags() &amp; STATIC) == 0) {
3461                     for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {
3462                         newScopeOwner = s;
3463                         break;
3464                     }
3465                 } else {
3466                     /* if the field is static then we need to create a fake clinit
3467                      * method, this method can later be reused by LTM.
3468                      */
3469                     MethodSymbol clinit = clinits.get(enclClass);
3470                     if (clinit == null) {
3471                         Type clinitType = new MethodType(List.nil(),
3472                                 syms.voidType, List.nil(), syms.methodClass);
3473                         clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,
3474                                 names.clinit, clinitType, enclClass);
3475                         clinit.params = List.nil();
3476                         clinits.put(enclClass, clinit);
3477                     }
3478                     newScopeOwner = clinit;
3479                 }
3480                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));
3481             } else {
3482                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dup()));
3483             }
3484             lambdaEnv.info.yieldResult = null;
3485             return lambdaEnv;
3486         }
3487 
3488     @Override
3489     public void visitReference(final JCMemberReference that) {
3490         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
3491             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3492                 //method reference only allowed in assignment or method invocation/cast context
3493                 log.error(that.pos(), Errors.UnexpectedMref);
3494             }
3495             result = that.type = types.createErrorType(pt());
3496             return;
3497         }
3498         final Env&lt;AttrContext&gt; localEnv = env.dup(that);
3499         try {
3500             //attribute member reference qualifier - if this is a constructor
3501             //reference, the expected kind must be a type
3502             Type exprType = attribTree(that.expr, env, memberReferenceQualifierResult(that));
3503 
3504             if (that.getMode() == JCMemberReference.ReferenceMode.NEW) {
3505                 exprType = chk.checkConstructorRefType(that.expr, exprType);
3506                 if (!exprType.isErroneous() &amp;&amp;
3507                     exprType.isRaw() &amp;&amp;
3508                     that.typeargs != null) {
3509                     log.error(that.expr.pos(),
3510                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3511                                                  Fragments.MrefInferAndExplicitParams));
3512                     exprType = types.createErrorType(exprType);
3513                 }
3514             }
3515 
3516             if (exprType.isErroneous()) {
3517                 //if the qualifier expression contains problems,
3518                 //give up attribution of method reference
3519                 result = that.type = exprType;
3520                 return;
3521             }
3522 
3523             if (TreeInfo.isStaticSelector(that.expr, names)) {
3524                 //if the qualifier is a type, validate it; raw warning check is
3525                 //omitted as we don&#39;t know at this stage as to whether this is a
3526                 //raw selector (because of inference)
3527                 chk.validate(that.expr, env, false);
3528             } else {
3529                 Symbol lhsSym = TreeInfo.symbol(that.expr);
3530                 localEnv.info.selectSuper = lhsSym != null &amp;&amp; lhsSym.name == names._super;
3531             }
3532             //attrib type-arguments
3533             List&lt;Type&gt; typeargtypes = List.nil();
3534             if (that.typeargs != null) {
3535                 typeargtypes = attribTypes(that.typeargs, localEnv);
3536             }
3537 
3538             boolean isTargetSerializable =
3539                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
3540                     isSerializable(pt());
3541             TargetInfo targetInfo = getTargetInfo(that, resultInfo, null);
3542             Type currentTarget = targetInfo.target;
3543             Type desc = targetInfo.descriptor;
3544 
3545             setFunctionalInfo(localEnv, that, pt(), desc, currentTarget, resultInfo.checkContext);
3546             List&lt;Type&gt; argtypes = desc.getParameterTypes();
3547             Resolve.MethodCheck referenceCheck = rs.resolveMethodCheck;
3548 
3549             if (resultInfo.checkContext.inferenceContext().free(argtypes)) {
3550                 referenceCheck = rs.new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
3551             }
3552 
3553             Pair&lt;Symbol, Resolve.ReferenceLookupHelper&gt; refResult = null;
3554             List&lt;Type&gt; saved_undet = resultInfo.checkContext.inferenceContext().save();
3555             try {
3556                 refResult = rs.resolveMemberReference(localEnv, that, that.expr.type,
3557                         that.name, argtypes, typeargtypes, targetInfo.descriptor, referenceCheck,
3558                         resultInfo.checkContext.inferenceContext(), rs.basicReferenceChooser);
3559             } finally {
3560                 resultInfo.checkContext.inferenceContext().rollback(saved_undet);
3561             }
3562 
3563             Symbol refSym = refResult.fst;
3564             Resolve.ReferenceLookupHelper lookupHelper = refResult.snd;
3565 
3566             /** this switch will need to go away and be replaced by the new RESOLUTION_TARGET testing
3567              *  JDK-8075541
3568              */
3569             if (refSym.kind != MTH) {
3570                 boolean targetError;
3571                 switch (refSym.kind) {
3572                     case ABSENT_MTH:
3573                     case MISSING_ENCL:
3574                         targetError = false;
3575                         break;
3576                     case WRONG_MTH:
3577                     case WRONG_MTHS:
3578                     case AMBIGUOUS:
3579                     case HIDDEN:
3580                     case STATICERR:
3581                         targetError = true;
3582                         break;
3583                     default:
3584                         Assert.error(&quot;unexpected result kind &quot; + refSym.kind);
3585                         targetError = false;
3586                 }
3587 
3588                 JCDiagnostic detailsDiag = ((Resolve.ResolveError)refSym.baseSymbol())
3589                         .getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT,
3590                                 that, exprType.tsym, exprType, that.name, argtypes, typeargtypes);
3591 
3592                 JCDiagnostic diag = diags.create(log.currentSource(), that,
3593                         targetError ?
3594                             Fragments.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag) :
3595                             Errors.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag));
3596 
3597                 if (targetError &amp;&amp; currentTarget == Type.recoveryType) {
3598                     //a target error doesn&#39;t make sense during recovery stage
3599                     //as we don&#39;t know what actual parameter types are
3600                     result = that.type = currentTarget;
3601                     return;
3602                 } else {
3603                     if (targetError) {
3604                         resultInfo.checkContext.report(that, diag);
3605                     } else {
3606                         log.report(diag);
3607                     }
3608                     result = that.type = types.createErrorType(currentTarget);
3609                     return;
3610                 }
3611             }
3612 
3613             that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;
3614             that.kind = lookupHelper.referenceKind(that.sym);
3615             that.ownerAccessible = rs.isAccessible(localEnv, that.sym.enclClass());
3616 
3617             if (desc.getReturnType() == Type.recoveryType) {
3618                 // stop here
3619                 result = that.type = currentTarget;
3620                 return;
3621             }
3622 
3623             if (!env.info.attributionMode.isSpeculative &amp;&amp; that.getMode() == JCMemberReference.ReferenceMode.NEW) {
3624                 Type enclosingType = exprType.getEnclosingType();
3625                 if (enclosingType != null &amp;&amp; enclosingType.hasTag(CLASS)) {
3626                     // Check for the existence of an appropriate outer instance
3627                     rs.resolveImplicitThis(that.pos(), env, exprType);
3628                 }
3629             }
3630 
3631             if (resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3632 
3633                 if (that.getMode() == ReferenceMode.INVOKE &amp;&amp;
3634                         TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3635                         that.kind.isUnbound() &amp;&amp;
3636                         lookupHelper.site.isRaw()) {
3637                     chk.checkRaw(that.expr, localEnv);
3638                 }
3639 
3640                 if (that.sym.isStatic() &amp;&amp; TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3641                         exprType.getTypeArguments().nonEmpty()) {
3642                     //static ref with class type-args
3643                     log.error(that.expr.pos(),
3644                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3645                                                  Fragments.StaticMrefWithTargs));
3646                     result = that.type = types.createErrorType(currentTarget);
3647                     return;
3648                 }
3649 
3650                 if (!refSym.isStatic() &amp;&amp; that.kind == JCMemberReference.ReferenceKind.SUPER) {
3651                     // Check that super-qualified symbols are not abstract (JLS)
3652                     rs.checkNonAbstract(that.pos(), that.sym);
3653                 }
3654 
3655                 if (isTargetSerializable) {
3656                     chk.checkAccessFromSerializableElement(that, true);
3657                 }
3658             }
3659 
3660             ResultInfo checkInfo =
3661                     resultInfo.dup(newMethodTemplate(
3662                         desc.getReturnType().hasTag(VOID) ? Type.noType : desc.getReturnType(),
3663                         that.kind.isUnbound() ? argtypes.tail : argtypes, typeargtypes),
3664                         new FunctionalReturnContext(resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
3665 
3666             Type refType = checkId(that, lookupHelper.site, refSym, localEnv, checkInfo);
3667 
3668             if (that.kind.isUnbound() &amp;&amp;
3669                     resultInfo.checkContext.inferenceContext().free(argtypes.head)) {
3670                 //re-generate inference constraints for unbound receiver
3671                 if (!types.isSubtype(resultInfo.checkContext.inferenceContext().asUndetVar(argtypes.head), exprType)) {
3672                     //cannot happen as this has already been checked - we just need
3673                     //to regenerate the inference constraints, as that has been lost
3674                     //as a result of the call to inferenceContext.save()
3675                     Assert.error(&quot;Can&#39;t get here&quot;);
3676                 }
3677             }
3678 
3679             if (!refType.isErroneous()) {
3680                 refType = types.createMethodTypeWithReturn(refType,
3681                         adjustMethodReturnType(refSym, lookupHelper.site, that.name, checkInfo.pt.getParameterTypes(), refType.getReturnType()));
3682             }
3683 
3684             //go ahead with standard method reference compatibility check - note that param check
3685             //is a no-op (as this has been taken care during method applicability)
3686             boolean isSpeculativeRound =
3687                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
3688 
3689             that.type = currentTarget; //avoids recovery at this stage
3690             checkReferenceCompatible(that, desc, refType, resultInfo.checkContext, isSpeculativeRound);
3691             if (!isSpeculativeRound) {
3692                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), desc, currentTarget);
3693             }
3694             result = check(that, currentTarget, KindSelector.VAL, resultInfo);
3695         } catch (Types.FunctionDescriptorLookupError ex) {
3696             JCDiagnostic cause = ex.getDiagnostic();
3697             resultInfo.checkContext.report(that, cause);
3698             result = that.type = types.createErrorType(pt());
3699             return;
3700         }
3701     }
3702     //where
3703         ResultInfo memberReferenceQualifierResult(JCMemberReference tree) {
3704             //if this is a constructor reference, the expected kind must be a type
3705             return new ResultInfo(tree.getMode() == ReferenceMode.INVOKE ?
3706                                   KindSelector.VAL_TYP : KindSelector.TYP,
3707                                   Type.noType);
3708         }
3709 
3710 
3711     @SuppressWarnings(&quot;fallthrough&quot;)
3712     void checkReferenceCompatible(JCMemberReference tree, Type descriptor, Type refType, CheckContext checkContext, boolean speculativeAttr) {
3713         InferenceContext inferenceContext = checkContext.inferenceContext();
3714         Type returnType = inferenceContext.asUndetVar(descriptor.getReturnType());
3715 
3716         Type resType;
3717         switch (tree.getMode()) {
3718             case NEW:
3719                 if (!tree.expr.type.isRaw()) {
3720                     resType = tree.expr.type;
3721                     break;
3722                 }
3723             default:
3724                 resType = refType.getReturnType();
3725         }
3726 
3727         Type incompatibleReturnType = resType;
3728 
3729         if (returnType.hasTag(VOID)) {
3730             incompatibleReturnType = null;
3731         }
3732 
3733         if (!returnType.hasTag(VOID) &amp;&amp; !resType.hasTag(VOID)) {
3734             if (resType.isErroneous() ||
3735                     new FunctionalReturnContext(checkContext).compatible(resType, returnType,
3736                             checkContext.checkWarner(tree, resType, returnType))) {
3737                 incompatibleReturnType = null;
3738             }
3739         }
3740 
3741         if (incompatibleReturnType != null) {
3742             Fragment msg =
3743                     Fragments.IncompatibleRetTypeInMref(Fragments.InconvertibleTypes(resType, descriptor.getReturnType()));
3744             checkContext.report(tree, diags.fragment(msg));
3745         } else {
3746             if (inferenceContext.free(refType)) {
3747                 // we need to wait for inference to finish and then replace inference vars in the referent type
3748                 inferenceContext.addFreeTypeListener(List.of(refType),
3749                         instantiatedContext -&gt; {
3750                             tree.referentType = instantiatedContext.asInstType(refType);
3751                         });
3752             } else {
3753                 tree.referentType = refType;
3754             }
3755         }
3756 
3757         if (!speculativeAttr) {
3758             if (!checkExConstraints(refType.getThrownTypes(), descriptor.getThrownTypes(), inferenceContext)) {
3759                 log.error(tree, Errors.IncompatibleThrownTypesInMref(refType.getThrownTypes()));
3760             }
3761         }
3762     }
3763 
3764     boolean checkExConstraints(
3765             List&lt;Type&gt; thrownByFuncExpr,
3766             List&lt;Type&gt; thrownAtFuncType,
3767             InferenceContext inferenceContext) {
3768         /** 18.2.5: Otherwise, let E1, ..., En be the types in the function type&#39;s throws clause that
3769          *  are not proper types
3770          */
3771         List&lt;Type&gt; nonProperList = thrownAtFuncType.stream()
3772                 .filter(e -&gt; inferenceContext.free(e)).collect(List.collector());
3773         List&lt;Type&gt; properList = thrownAtFuncType.diff(nonProperList);
3774 
3775         /** Let X1,...,Xm be the checked exception types that the lambda body can throw or
3776          *  in the throws clause of the invocation type of the method reference&#39;s compile-time
3777          *  declaration
3778          */
3779         List&lt;Type&gt; checkedList = thrownByFuncExpr.stream()
3780                 .filter(e -&gt; chk.isChecked(e)).collect(List.collector());
3781 
3782         /** If n = 0 (the function type&#39;s throws clause consists only of proper types), then
3783          *  if there exists some i (1 &lt;= i &lt;= m) such that Xi is not a subtype of any proper type
3784          *  in the throws clause, the constraint reduces to false; otherwise, the constraint
3785          *  reduces to true
3786          */
3787         ListBuffer&lt;Type&gt; uncaughtByProperTypes = new ListBuffer&lt;&gt;();
3788         for (Type checked : checkedList) {
3789             boolean isSubtype = false;
3790             for (Type proper : properList) {
3791                 if (types.isSubtype(checked, proper)) {
3792                     isSubtype = true;
3793                     break;
3794                 }
3795             }
3796             if (!isSubtype) {
3797                 uncaughtByProperTypes.add(checked);
3798             }
3799         }
3800 
3801         if (nonProperList.isEmpty() &amp;&amp; !uncaughtByProperTypes.isEmpty()) {
3802             return false;
3803         }
3804 
3805         /** If n &gt; 0, the constraint reduces to a set of subtyping constraints:
3806          *  for all i (1 &lt;= i &lt;= m), if Xi is not a subtype of any proper type in the
3807          *  throws clause, then the constraints include, for all j (1 &lt;= j &lt;= n), &lt;Xi &lt;: Ej&gt;
3808          */
3809         List&lt;Type&gt; nonProperAsUndet = inferenceContext.asUndetVars(nonProperList);
3810         uncaughtByProperTypes.forEach(checkedEx -&gt; {
3811             nonProperAsUndet.forEach(nonProper -&gt; {
3812                 types.isSubtype(checkedEx, nonProper);
3813             });
3814         });
3815 
3816         /** In addition, for all j (1 &lt;= j &lt;= n), the constraint reduces to the bound throws Ej
3817          */
3818         nonProperAsUndet.stream()
3819                 .filter(t -&gt; t.hasTag(UNDETVAR))
3820                 .forEach(t -&gt; ((UndetVar)t).setThrow());
3821         return true;
3822     }
3823 
3824     /**
3825      * Set functional type info on the underlying AST. Note: as the target descriptor
3826      * might contain inference variables, we might need to register an hook in the
3827      * current inference context.
3828      */
3829     private void setFunctionalInfo(final Env&lt;AttrContext&gt; env, final JCFunctionalExpression fExpr,
3830             final Type pt, final Type descriptorType, final Type primaryTarget, final CheckContext checkContext) {
3831         if (checkContext.inferenceContext().free(descriptorType)) {
3832             checkContext.inferenceContext().addFreeTypeListener(List.of(pt, descriptorType),
3833                     inferenceContext -&gt; setFunctionalInfo(env, fExpr, pt, inferenceContext.asInstType(descriptorType),
3834                     inferenceContext.asInstType(primaryTarget), checkContext));
3835         } else {
3836             if (pt.hasTag(CLASS)) {
3837                 fExpr.target = primaryTarget;
3838             }
3839             if (checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
3840                     pt != Type.recoveryType) {
3841                 //check that functional interface class is well-formed
3842                 try {
3843                     /* Types.makeFunctionalInterfaceClass() may throw an exception
3844                      * when it&#39;s executed post-inference. See the listener code
3845                      * above.
3846                      */
3847                     ClassSymbol csym = types.makeFunctionalInterfaceClass(env,
3848                             names.empty, fExpr.target, ABSTRACT);
3849                     if (csym != null) {
3850                         chk.checkImplementations(env.tree, csym, csym);
3851                         try {
3852                             //perform an additional functional interface check on the synthetic class,
3853                             //as there may be spurious errors for raw targets - because of existing issues
3854                             //with membership and inheritance (see JDK-8074570).
3855                             csym.flags_field |= INTERFACE;
3856                             types.findDescriptorType(csym.type);
3857                         } catch (FunctionDescriptorLookupError err) {
3858                             resultInfo.checkContext.report(fExpr,
3859                                     diags.fragment(Fragments.NoSuitableFunctionalIntfInst(fExpr.target)));
3860                         }
3861                     }
3862                 } catch (Types.FunctionDescriptorLookupError ex) {
3863                     JCDiagnostic cause = ex.getDiagnostic();
3864                     resultInfo.checkContext.report(env.tree, cause);
3865                 }
3866             }
3867         }
3868     }
3869 
3870     public void visitParens(JCParens tree) {
3871         Type owntype = attribTree(tree.expr, env, resultInfo);
3872         result = check(tree, owntype, pkind(), resultInfo);
3873         Symbol sym = TreeInfo.symbol(tree);
3874         if (sym != null &amp;&amp; sym.kind.matches(KindSelector.TYP_PCK))
3875             log.error(tree.pos(), Errors.IllegalParenthesizedExpression);
3876     }
3877 
3878     public void visitAssign(JCAssign tree) {
3879         Type owntype = attribTree(tree.lhs, env.dup(tree), varAssignmentInfo);
3880         Type capturedType = capture(owntype);
3881         attribExpr(tree.rhs, env, owntype);
3882         result = check(tree, capturedType, KindSelector.VAL, resultInfo);
3883     }
3884 
3885     public void visitAssignop(JCAssignOp tree) {
3886         // Attribute arguments.
3887         Type owntype = attribTree(tree.lhs, env, varAssignmentInfo);
3888         Type operand = attribExpr(tree.rhs, env);
3889         // Find operator.
3890         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), owntype, operand);
3891         if (operator != operators.noOpSymbol &amp;&amp;
3892                 !owntype.isErroneous() &amp;&amp;
3893                 !operand.isErroneous()) {
3894             chk.checkDivZero(tree.rhs.pos(), operator, operand);
3895             chk.checkCastable(tree.rhs.pos(),
3896                               operator.type.getReturnType(),
3897                               owntype);
3898         }
3899         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3900     }
3901 
3902     public void visitUnary(JCUnary tree) {
3903         // Attribute arguments.
3904         Type argtype = (tree.getTag().isIncOrDecUnaryOp())
3905             ? attribTree(tree.arg, env, varAssignmentInfo)
3906             : chk.checkNonVoid(tree.arg.pos(), attribExpr(tree.arg, env));
3907 
3908         // Find operator.
3909         Symbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);
3910         Type owntype = types.createErrorType(tree.type);
3911         if (operator != operators.noOpSymbol &amp;&amp;
3912                 !argtype.isErroneous()) {
3913             owntype = (tree.getTag().isIncOrDecUnaryOp())
3914                 ? tree.arg.type
3915                 : operator.type.getReturnType();
3916             int opc = ((OperatorSymbol)operator).opcode;
3917 
3918             // If the argument is constant, fold it.
3919             if (argtype.constValue() != null) {
3920                 Type ctype = cfolder.fold1(opc, argtype);
3921                 if (ctype != null) {
3922                     owntype = cfolder.coerce(ctype, owntype);
3923                 }
3924             }
3925         }
3926         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3927         matchBindings = matchBindingsComputer.unary(tree, matchBindings);
3928     }
3929 
3930     public void visitBinary(JCBinary tree) {
3931         // Attribute arguments.
3932         Type left = chk.checkNonVoid(tree.lhs.pos(), attribExpr(tree.lhs, env));
3933         // x &amp;&amp; y
3934         // include x&#39;s bindings when true in y
3935 
3936         // x || y
3937         // include x&#39;s bindings when false in y
3938 
3939         MatchBindings lhsBindings = matchBindings;
3940         List&lt;BindingSymbol&gt; propagatedBindings;
3941         switch (tree.getTag()) {
3942             case AND:
3943                 propagatedBindings = lhsBindings.bindingsWhenTrue;
3944                 break;
3945             case OR:
3946                 propagatedBindings = lhsBindings.bindingsWhenFalse;
3947                 break;
3948             default:
3949                 propagatedBindings = List.nil();
3950                 break;
3951         }
3952         Env&lt;AttrContext&gt; rhsEnv = bindingEnv(env, propagatedBindings);
3953         Type right;
3954         try {
3955             right = chk.checkNonVoid(tree.rhs.pos(), attribExpr(tree.rhs, rhsEnv));
3956         } finally {
3957             rhsEnv.info.scope.leave();
3958         }
3959 
3960         matchBindings = matchBindingsComputer.binary(tree, lhsBindings, matchBindings);
3961 
3962         // Find operator.
3963         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);
3964         Type owntype = types.createErrorType(tree.type);
3965         if (operator != operators.noOpSymbol &amp;&amp;
3966                 !left.isErroneous() &amp;&amp;
3967                 !right.isErroneous()) {
3968             owntype = operator.type.getReturnType();
3969             int opc = ((OperatorSymbol)operator).opcode;
3970             // If both arguments are constants, fold them.
3971             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3972                 Type ctype = cfolder.fold2(opc, left, right);
3973                 if (ctype != null) {
3974                     owntype = cfolder.coerce(ctype, owntype);
3975                 }
3976             }
3977 
3978             // Check that argument types of a reference ==, != are
3979             // castable to each other, (JLS 15.21).  Note: unboxing
3980             // comparisons will not have an acmp* opc at this point.
3981             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
3982                 if (!types.isCastable(left, right, new Warner(tree.pos()))) {
3983                     log.error(tree.pos(), Errors.IncomparableTypes(left, right));
3984                 }
3985                 chk.checkForSuspectClassLiteralComparison(tree, left, right);
3986             }
3987 
3988             chk.checkDivZero(tree.rhs.pos(), operator, right);
3989         }
3990         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3991     }
3992 
3993     public void visitTypeCast(final JCTypeCast tree) {
3994         Type clazztype = attribType(tree.clazz, env);
3995         chk.validate(tree.clazz, env, false);
3996         //a fresh environment is required for 292 inference to work properly ---
3997         //see Infer.instantiatePolymorphicSignatureInstance()
3998         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
3999         //should we propagate the target type?
4000         final ResultInfo castInfo;
4001         JCExpression expr = TreeInfo.skipParens(tree.expr);
4002         boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
4003         if (isPoly) {
4004             //expression is a poly - we need to propagate target type info
4005             castInfo = new ResultInfo(KindSelector.VAL, clazztype,
4006                                       new Check.NestedCheckContext(resultInfo.checkContext) {
4007                 @Override
4008                 public boolean compatible(Type found, Type req, Warner warn) {
4009                     return types.isCastable(found, req, warn);
4010                 }
4011             });
4012         } else {
4013             //standalone cast - target-type info is not propagated
4014             castInfo = unknownExprInfo;
4015         }
4016         Type exprtype = attribTree(tree.expr, localEnv, castInfo);
4017         Type owntype = isPoly ? clazztype : chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
4018         if (exprtype.constValue() != null)
4019             owntype = cfolder.coerce(exprtype, owntype);
4020         result = check(tree, capture(owntype), KindSelector.VAL, resultInfo);
4021         if (!isPoly)
4022             chk.checkRedundantCast(localEnv, tree);
4023     }
4024 
4025     public void visitTypeTest(JCInstanceOf tree) {
4026         Type exprtype = chk.checkNullOrRefType(
4027                 tree.expr.pos(), attribExpr(tree.expr, env));
4028         Type clazztype;
4029         JCTree typeTree;
4030         if (tree.pattern.getTag() == BINDINGPATTERN) {
4031             attribTree(tree.pattern, env, unknownExprInfo);
4032             clazztype = tree.pattern.type;
4033             JCBindingPattern pattern = (JCBindingPattern) tree.pattern;
4034             typeTree = pattern.vartype;
4035             if (!clazztype.hasTag(TYPEVAR)) {
4036                 clazztype = chk.checkClassOrArrayType(pattern.vartype.pos(), clazztype);
4037             }
4038         } else {
4039             clazztype = attribType(tree.pattern, env);
4040             typeTree = tree.pattern;
4041         }
4042         if (!clazztype.hasTag(TYPEVAR)) {
4043             clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);
4044         }
4045         if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {
4046             boolean valid = false;
4047             if (allowReifiableTypesInInstanceof) {
4048                 if (preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF)) {
4049                     preview.warnPreview(tree.expr.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF);
4050                 }
4051                 Warner warner = new Warner();
4052                 if (!types.isCastable(exprtype, clazztype, warner)) {
4053                     chk.basicHandler.report(tree.expr.pos(),
4054                                             diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));
4055                 } else if (warner.hasLint(LintCategory.UNCHECKED)) {
4056                     log.error(tree.expr.pos(),
4057                               Errors.InstanceofReifiableNotSafe(exprtype, clazztype));
4058                 } else {
4059                     valid = true;
4060                 }
4061             } else {
4062                 log.error(typeTree.pos(), Errors.IllegalGenericTypeForInstof);
4063             }
4064             if (!valid) {
4065                 clazztype = types.createErrorType(clazztype);
4066             }
4067         }
4068         chk.validate(typeTree, env, false);
4069         chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
4070         result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
4071     }
4072 
4073     public void visitBindingPattern(JCBindingPattern tree) {
4074         ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);
4075         tree.type = attribTree(tree.vartype, env, varInfo);
4076         VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype.type, env.info.scope.owner);
4077         if (chk.checkUnique(tree.pos(), v, env.info.scope)) {
4078             chk.checkTransparentVar(tree.pos(), v, env.info.scope);
4079         }
4080         annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());
4081         annotate.flush();
4082         result = tree.type;
4083         matchBindings = new MatchBindings(List.of(tree.symbol), List.nil());
4084     }
4085 
4086     public void visitIndexed(JCArrayAccess tree) {
4087         Type owntype = types.createErrorType(tree.type);
4088         Type atype = attribExpr(tree.indexed, env);
4089         attribExpr(tree.index, env, syms.intType);
4090         if (types.isArray(atype))
4091             owntype = types.elemtype(atype);
4092         else if (!atype.hasTag(ERROR))
4093             log.error(tree.pos(), Errors.ArrayReqButFound(atype));
4094         if (!pkind().contains(KindSelector.VAL))
4095             owntype = capture(owntype);
4096         result = check(tree, owntype, KindSelector.VAR, resultInfo);
4097     }
4098 
4099     public void visitIdent(JCIdent tree) {
4100         Symbol sym;
4101 
4102         // Find symbol
4103         if (pt().hasTag(METHOD) || pt().hasTag(FORALL)) {
4104             // If we are looking for a method, the prototype `pt&#39; will be a
4105             // method type with the type of the call&#39;s arguments as parameters.
4106             env.info.pendingResolutionPhase = null;
4107             sym = rs.resolveMethod(tree.pos(), env, tree.name, pt().getParameterTypes(), pt().getTypeArguments());
4108         } else if (tree.sym != null &amp;&amp; tree.sym.kind != VAR) {
4109             sym = tree.sym;
4110         } else {
4111             sym = rs.resolveIdent(tree.pos(), env, tree.name, pkind());
4112         }
4113         tree.sym = sym;
4114 
4115         // (1) Also find the environment current for the class where
4116         //     sym is defined (`symEnv&#39;).
4117         // Only for pre-tiger versions (1.4 and earlier):
4118         // (2) Also determine whether we access symbol out of an anonymous
4119         //     class in a this or super call.  This is illegal for instance
4120         //     members since such classes don&#39;t carry a this$n link.
4121         //     (`noOuterThisPath&#39;).
4122         Env&lt;AttrContext&gt; symEnv = env;
4123         boolean noOuterThisPath = false;
4124         if (env.enclClass.sym.owner.kind != PCK &amp;&amp; // we are in an inner class
4125             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
4126             sym.owner.kind == TYP &amp;&amp;
4127             tree.name != names._this &amp;&amp; tree.name != names._super) {
4128 
4129             // Find environment in which identifier is defined.
4130             while (symEnv.outer != null &amp;&amp;
4131                    !sym.isMemberOf(symEnv.enclClass.sym, types)) {
4132                 if ((symEnv.enclClass.sym.flags() &amp; NOOUTERTHIS) != 0)
4133                     noOuterThisPath = false;
4134                 symEnv = symEnv.outer;
4135             }
4136         }
4137 
4138         // If symbol is a variable, ...
4139         if (sym.kind == VAR) {
4140             VarSymbol v = (VarSymbol)sym;
4141 
4142             // ..., evaluate its initializer, if it has one, and check for
4143             // illegal forward reference.
4144             checkInit(tree, env, v, false);
4145 
4146             // If we are expecting a variable (as opposed to a value), check
4147             // that the variable is assignable in the current environment.
4148             if (KindSelector.ASG.subset(pkind()))
4149                 checkAssignable(tree.pos(), v, null, env);
4150         }
4151 
4152         // In a constructor body,
4153         // if symbol is a field or instance method, check that it is
4154         // not accessed before the supertype constructor is called.
4155         if ((symEnv.info.isSelfCall || noOuterThisPath) &amp;&amp;
4156             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
4157             sym.owner.kind == TYP &amp;&amp;
4158             (sym.flags() &amp; STATIC) == 0) {
4159             chk.earlyRefError(tree.pos(), sym.kind == VAR ?
4160                                           sym : thisSym(tree.pos(), env));
4161         }
4162         Env&lt;AttrContext&gt; env1 = env;
4163         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4164             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4165             // If the found symbol is inaccessible, then it is
4166             // accessed through an enclosing instance.  Locate this
4167             // enclosing instance:
4168             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4169                 env1 = env1.outer;
4170         }
4171 
4172         if (env.info.isSerializable) {
4173             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4174         }
4175 
4176         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4177     }
4178 
4179     public void visitSelect(JCFieldAccess tree) {
4180         // Determine the expected kind of the qualifier expression.
4181         KindSelector skind = KindSelector.NIL;
4182         if (tree.name == names._this || tree.name == names._super ||
4183                 tree.name == names._class || tree.name == names._default)
4184         {
4185             if (tree.name == names._default &amp;&amp; !allowInlineTypes) {
4186                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),
4187                         Feature.INLINE_TYPES.error(sourceName));
4188             }
4189             skind = KindSelector.TYP;
4190         } else {
4191             if (pkind().contains(KindSelector.PCK))
4192                 skind = KindSelector.of(skind, KindSelector.PCK);
4193             if (pkind().contains(KindSelector.TYP))
4194                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4195             if (pkind().contains(KindSelector.VAL_MTH))
4196                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4197         }
4198 
4199         // Attribute the qualifier expression, and determine its symbol (if any).
4200         Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));
4201         if (!pkind().contains(KindSelector.TYP_PCK))
4202             site = capture(site); // Capture field access
4203 
4204         // don&#39;t allow T.class T[].class, etc
4205         if (skind == KindSelector.TYP) {
4206             Type elt = site;
4207             while (elt.hasTag(ARRAY))
4208                 elt = ((ArrayType)elt).elemtype;
4209             if (elt.hasTag(TYPEVAR)) {
4210                 if (tree.name == names._default) {
4211                     result = check(tree, litType(BOT).constType(null),
4212                             KindSelector.VAL, resultInfo);
4213                 } else {
4214                     log.error(tree.pos(), Errors.TypeVarCantBeDeref);
4215                     result = tree.type = types.createErrorType(tree.name, site.tsym, site);
4216                     tree.sym = tree.type.tsym;
4217                     return;
4218                 }
4219             }
4220         }
4221 
4222         // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;
4223         // for the selection. This is relevant for determining whether
4224         // protected symbols are accessible.
4225         Symbol sitesym = TreeInfo.symbol(tree.selected);
4226 
4227         boolean selectSuperPrev = env.info.selectSuper;
4228         env.info.selectSuper =
4229             sitesym != null &amp;&amp;
4230             sitesym.name == names._super;
4231 
4232         // Determine the symbol represented by the selection.
4233         env.info.pendingResolutionPhase = null;
4234         Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
4235         if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
4236             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
4237             sym = syms.errSymbol;
4238         }
4239         if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
4240             site = capture(site);
4241             sym = selectSym(tree, sitesym, site, env, resultInfo);
4242         }
4243         boolean varArgs = env.info.lastResolveVarargs();
4244         tree.sym = sym;
4245 
4246         if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
4247             site = types.skipTypeVars(site, true);
4248         }
4249 
4250         // If that symbol is a variable, ...
4251         if (sym.kind == VAR) {
4252             VarSymbol v = (VarSymbol)sym;
4253 
4254             // ..., evaluate its initializer, if it has one, and check for
4255             // illegal forward reference.
4256             checkInit(tree, env, v, true);
4257 
4258             // If we are expecting a variable (as opposed to a value), check
4259             // that the variable is assignable in the current environment.
4260             if (KindSelector.ASG.subset(pkind()))
4261                 checkAssignable(tree.pos(), v, tree.selected, env);
4262         }
4263 
4264         if (sitesym != null &amp;&amp;
4265                 sitesym.kind == VAR &amp;&amp;
4266                 ((VarSymbol)sitesym).isResourceVariable() &amp;&amp;
4267                 sym.kind == MTH &amp;&amp;
4268                 sym.name.equals(names.close) &amp;&amp;
4269                 sym.overrides(syms.autoCloseableClose, sitesym.type.tsym, types, true) &amp;&amp;
4270                 env.info.lint.isEnabled(LintCategory.TRY)) {
4271             log.warning(LintCategory.TRY, tree, Warnings.TryExplicitCloseCall);
4272         }
4273 
4274         // Disallow selecting a type from an expression
4275         if (isType(sym) &amp;&amp; (sitesym == null || !sitesym.kind.matches(KindSelector.TYP_PCK))) {
4276             tree.type = check(tree.selected, pt(),
4277                               sitesym == null ?
4278                                       KindSelector.VAL : sitesym.kind.toSelector(),
4279                               new ResultInfo(KindSelector.TYP_PCK, pt()));
4280         }
4281 
4282         if (isType(sitesym)) {
4283             if (sym.name == names._this) {
4284                 // If `C&#39; is the currently compiled class, check that
4285                 // C.this&#39; does not appear in a call to a super(...)
4286                 if (env.info.isSelfCall &amp;&amp;
4287                     site.tsym == env.enclClass.sym) {
4288                     chk.earlyRefError(tree.pos(), sym);
4289                 }
4290             } else {
4291                 // Check if type-qualified fields or methods are static (JLS)
4292                 if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
4293                     sym.name != names._super &amp;&amp;
4294                     (sym.kind == VAR || sym.kind == MTH)) {
4295                     rs.accessBase(rs.new StaticError(sym),
4296                               tree.pos(), site, sym.name, true);
4297                 }
4298             }
4299             if (!allowStaticInterfaceMethods &amp;&amp; sitesym.isInterface() &amp;&amp;
4300                     sym.isStatic() &amp;&amp; sym.kind == MTH) {
4301                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(), Feature.STATIC_INTERFACE_METHODS_INVOKE.error(sourceName));
4302             }
4303         } else if (sym.kind != ERR &amp;&amp;
4304                    (sym.flags() &amp; STATIC) != 0 &amp;&amp;
4305                    sym.name != names._class) {
4306             // If the qualified item is not a type and the selected item is static, report
4307             // a warning. Make allowance for the class of an array type e.g. Object[].class)
4308             chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));
4309         }
4310 
4311         // If we are selecting an instance member via a `super&#39;, ...
4312         if (env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0) {
4313 
4314             // Check that super-qualified symbols are not abstract (JLS)
4315             rs.checkNonAbstract(tree.pos(), sym);
4316 
4317             if (site.isRaw()) {
4318                 // Determine argument types for site.
4319                 Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);
4320                 if (site1 != null) site = site1;
4321             }
4322         }
4323 
4324         if (env.info.isSerializable) {
4325             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4326         }
4327 
4328         env.info.selectSuper = selectSuperPrev;
4329         result = checkId(tree, site, sym, env, resultInfo);
4330     }
4331     //where
4332         /** Determine symbol referenced by a Select expression,
4333          *
4334          *  @param tree   The select tree.
4335          *  @param site   The type of the selected expression,
4336          *  @param env    The current environment.
4337          *  @param resultInfo The current result.
4338          */
4339         private Symbol selectSym(JCFieldAccess tree,
4340                                  Symbol location,
4341                                  Type site,
4342                                  Env&lt;AttrContext&gt; env,
4343                                  ResultInfo resultInfo) {
4344             DiagnosticPosition pos = tree.pos();
4345             Name name = tree.name;
4346             switch (site.getTag()) {
4347             case PACKAGE:
4348                 return rs.accessBase(
4349                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),
4350                     pos, location, site, name, true);
4351             case ARRAY:
4352             case CLASS:
4353                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4354                     return rs.resolveQualifiedMethod(
4355                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4356                 } else if (name == names._this || name == names._super) {
4357                     return rs.resolveSelf(pos, env, site.tsym, name);
4358                 } else if (name == names._class) {
4359                     // In this case, we have already made sure in
4360                     // visitSelect that qualifier expression is a type.
4361                     return syms.getClassField(site, types);
4362                 } else if (name == names._default) {
4363                     return new VarSymbol(STATIC, names._default, site, site.tsym);
4364                 } else if (name == names.ref &amp;&amp; site.isValue() &amp;&amp; resultInfo.pkind.contains(KindSelector.TYP)) {
4365                     return site.tsym.referenceProjection();
4366                 } else if (name == names.val &amp;&amp; site.isValue() &amp;&amp; resultInfo.pkind.contains(KindSelector.TYP)) {
4367                     return site.tsym;
4368                 } else {
4369                     // We are seeing a plain identifier as selector.
4370                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
4371                         sym = rs.accessBase(sym, pos, location, site, name, true);
4372                     return sym;
4373                 }
4374             case WILDCARD:
4375                 throw new AssertionError(tree);
4376             case TYPEVAR:
4377                 if (name == names._default) {
4378                     // Be sure to return the default value before examining bounds
4379                     return new VarSymbol(STATIC, names._default, site, site.tsym);
4380                 }
4381                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4382                 // It should only happen during memberEnter/attribBase
4383                 // when determining the super type which *must* be
4384                 // done before attributing the type variables.  In
4385                 // other words, we are seeing this illegal program:
4386                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4387                 Symbol sym = (site.getUpperBound() != null)
4388                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4389                     : null;
4390                 if (sym == null) {
4391                     log.error(pos, Errors.TypeVarCantBeDeref);
4392                     return syms.errSymbol;
4393                 } else {
4394                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4395                         rs.new AccessError(env, site, sym) :
4396                                 sym;
4397                     rs.accessBase(sym2, pos, location, site, name, true);
4398                     return sym;
4399                 }
4400             case ERROR:
4401                 // preserve identifier names through errors
4402                 return types.createErrorType(name, site.tsym, site).tsym;
4403             default:
4404                 // The qualifier expression is of a primitive type -- only
4405                 // .class and .default is allowed for these.
4406                 if (name == names._class) {
4407                     // In this case, we have already made sure in Select that
4408                     // qualifier expression is a type.
4409                     return syms.getClassField(site, types);
4410                 } else if (name == names._default) {
4411                     return new VarSymbol(STATIC, names._default, site, site.tsym);
4412                 } else {
4413                     log.error(pos, Errors.CantDeref(site));
4414                     return syms.errSymbol;
4415                 }
4416             }
4417         }
4418 
4419         /** Determine type of identifier or select expression and check that
4420          *  (1) the referenced symbol is not deprecated
4421          *  (2) the symbol&#39;s type is safe (@see checkSafe)
4422          *  (3) if symbol is a variable, check that its type and kind are
4423          *      compatible with the prototype and protokind.
4424          *  (4) if symbol is an instance field of a raw type,
4425          *      which is being assigned to, issue an unchecked warning if its
4426          *      type changes under erasure.
4427          *  (5) if symbol is an instance method of a raw type, issue an
4428          *      unchecked warning if its argument types change under erasure.
4429          *  If checks succeed:
4430          *    If symbol is a constant, return its constant type
4431          *    else if symbol is a method, return its result type
4432          *    otherwise return its type.
4433          *  Otherwise return errType.
4434          *
4435          *  @param tree       The syntax tree representing the identifier
4436          *  @param site       If this is a select, the type of the selected
4437          *                    expression, otherwise the type of the current class.
4438          *  @param sym        The symbol representing the identifier.
4439          *  @param env        The current environment.
4440          *  @param resultInfo    The expected result
4441          */
4442         Type checkId(JCTree tree,
4443                      Type site,
4444                      Symbol sym,
4445                      Env&lt;AttrContext&gt; env,
4446                      ResultInfo resultInfo) {
4447             return (resultInfo.pt.hasTag(FORALL) || resultInfo.pt.hasTag(METHOD)) ?
4448                     checkMethodIdInternal(tree, site, sym, env, resultInfo) :
4449                     checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);
4450         }
4451 
4452         Type checkMethodIdInternal(JCTree tree,
4453                      Type site,
4454                      Symbol sym,
4455                      Env&lt;AttrContext&gt; env,
4456                      ResultInfo resultInfo) {
4457             if (resultInfo.pkind.contains(KindSelector.POLY)) {
4458                 Type pt = resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, sym, env.info.pendingResolutionPhase));
4459                 Type owntype = checkIdInternal(tree, site, sym, pt, env, resultInfo);
4460                 resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));
4461                 return owntype;
4462             } else {
4463                 return checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);
4464             }
4465         }
4466 
4467         Type checkIdInternal(JCTree tree,
4468                      Type site,
4469                      Symbol sym,
4470                      Type pt,
4471                      Env&lt;AttrContext&gt; env,
4472                      ResultInfo resultInfo) {
4473             if (pt.isErroneous()) {
4474                 return types.createErrorType(site);
4475             }
4476             Type owntype; // The computed type of this identifier occurrence.
4477             switch (sym.kind) {
4478             case TYP:
4479                 // For types, the computed type equals the symbol&#39;s type,
4480                 // except for two situations:
4481                 owntype = sym.type;
4482                 if (owntype.hasTag(CLASS)) {
4483                     chk.checkForBadAuxiliaryClassAccess(tree.pos(), env, (ClassSymbol)sym);
4484                     Type ownOuter = owntype.getEnclosingType();
4485 
4486                     // (a) If the symbol&#39;s type is parameterized, erase it
4487                     // because no type parameters were given.
4488                     // We recover generic outer type later in visitTypeApply.
4489                     if (owntype.tsym.type.getTypeArguments().nonEmpty()) {
4490                         owntype = types.erasure(owntype);
4491                     }
4492 
4493                     // (b) If the symbol&#39;s type is an inner class, then
4494                     // we have to interpret its outer type as a superclass
4495                     // of the site type. Example:
4496                     //
4497                     // class Tree&lt;A&gt; { class Visitor { ... } }
4498                     // class PointTree extends Tree&lt;Point&gt; { ... }
4499                     // ...PointTree.Visitor...
4500                     //
4501                     // Then the type of the last expression above is
4502                     // Tree&lt;Point&gt;.Visitor.
4503                     else if (ownOuter.hasTag(CLASS) &amp;&amp; site != ownOuter) {
4504                         Type normOuter = site;
4505                         if (normOuter.hasTag(CLASS)) {
4506                             normOuter = types.asEnclosingSuper(site, ownOuter.tsym);
4507                         }
4508                         if (normOuter == null) // perhaps from an import
4509                             normOuter = types.erasure(ownOuter);
4510                         if (normOuter != ownOuter)
4511                             owntype = new ClassType(
4512                                 normOuter, List.nil(), owntype.tsym,
4513                                 owntype.getMetadata());
4514                     }
4515                 }
4516                 break;
4517             case VAR:
4518                 VarSymbol v = (VarSymbol)sym;
4519 
4520                 if (env.info.enclVar != null
4521                         &amp;&amp; v.type.hasTag(NONE)) {
4522                     //self reference to implicitly typed variable declaration
4523                     log.error(TreeInfo.positionFor(v, env.enclClass), Errors.CantInferLocalVarType(v.name, Fragments.LocalSelfRef));
4524                     return v.type = types.createErrorType(v.type);
4525                 }
4526 
4527                 // Test (4): if symbol is an instance field of a raw type,
4528                 // which is being assigned to, issue an unchecked warning if
4529                 // its type changes under erasure.
4530                 if (KindSelector.ASG.subset(pkind()) &amp;&amp;
4531                     v.owner.kind == TYP &amp;&amp;
4532                     (v.flags() &amp; STATIC) == 0 &amp;&amp;
4533                     (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
4534                     Type s = types.asOuterSuper(site, v.owner);
4535                     if (s != null &amp;&amp;
4536                         s.isRaw() &amp;&amp;
4537                         !types.isSameType(v.type, v.erasure(types))) {
4538                         chk.warnUnchecked(tree.pos(), Warnings.UncheckedAssignToVar(v, s));
4539                     }
4540                 }
4541                 // The computed type of a variable is the type of the
4542                 // variable symbol, taken as a member of the site type.
4543                 owntype = (sym.owner.kind == TYP &amp;&amp;
4544                            sym.name != names._this &amp;&amp; sym.name != names._super)
4545                     ? types.memberType(site, sym)
4546                     : sym.type;
4547 
4548                 // If the variable is a constant, record constant value in
4549                 // computed type.
4550                 if (v.getConstValue() != null &amp;&amp; isStaticReference(tree))
4551                     owntype = owntype.constType(v.getConstValue());
4552 
4553                 if (resultInfo.pkind == KindSelector.VAL) {
4554                     owntype = capture(owntype); // capture &quot;names as expressions&quot;
4555                 }
4556                 break;
4557             case MTH: {
4558                 owntype = checkMethod(site, sym,
4559                         new ResultInfo(resultInfo.pkind, resultInfo.pt.getReturnType(), resultInfo.checkContext, resultInfo.checkMode),
4560                         env, TreeInfo.args(env.tree), resultInfo.pt.getParameterTypes(),
4561                         resultInfo.pt.getTypeArguments());
4562                 break;
4563             }
4564             case PCK: case ERR:
4565                 owntype = sym.type;
4566                 break;
4567             default:
4568                 throw new AssertionError(&quot;unexpected kind: &quot; + sym.kind +
4569                                          &quot; in tree &quot; + tree);
4570             }
4571 
4572             // Emit a `deprecation&#39; warning if symbol is deprecated.
4573             // (for constructors (but not for constructor references), the error
4574             // was given when the constructor was resolved)
4575 
4576             if (sym.name != names.init || tree.hasTag(REFERENCE)) {
4577                 chk.checkDeprecated(tree.pos(), env.info.scope.owner, sym);
4578                 chk.checkSunAPI(tree.pos(), sym);
4579                 chk.checkProfile(tree.pos(), sym);
4580                 chk.checkPreview(tree.pos(), sym);
4581             }
4582 
4583             // If symbol is a variable, check that its type and
4584             // kind are compatible with the prototype and protokind.
4585             return check(tree, owntype, sym.kind.toSelector(), resultInfo);
4586         }
4587 
4588         /** Check that variable is initialized and evaluate the variable&#39;s
4589          *  initializer, if not yet done. Also check that variable is not
4590          *  referenced before it is defined.
4591          *  @param tree    The tree making up the variable reference.
4592          *  @param env     The current environment.
4593          *  @param v       The variable&#39;s symbol.
4594          */
4595         private void checkInit(JCTree tree,
4596                                Env&lt;AttrContext&gt; env,
4597                                VarSymbol v,
4598                                boolean onlyWarning) {
4599             // A forward reference is diagnosed if the declaration position
4600             // of the variable is greater than the current tree position
4601             // and the tree and variable definition occur in the same class
4602             // definition.  Note that writes don&#39;t count as references.
4603             // This check applies only to class and instance
4604             // variables.  Local variables follow different scope rules,
4605             // and are subject to definite assignment checking.
4606             Env&lt;AttrContext&gt; initEnv = enclosingInitEnv(env);
4607             if (initEnv != null &amp;&amp;
4608                 (initEnv.info.enclVar == v || v.pos &gt; tree.pos) &amp;&amp;
4609                 v.owner.kind == TYP &amp;&amp;
4610                 v.owner == env.info.scope.owner.enclClass() &amp;&amp;
4611                 ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env) &amp;&amp;
4612                 (!env.tree.hasTag(ASSIGN) ||
4613                  TreeInfo.skipParens(((JCAssign) env.tree).lhs) != tree)) {
4614                 if (!onlyWarning || isStaticEnumField(v)) {
4615                     Error errkey = (initEnv.info.enclVar == v) ?
4616                                 Errors.IllegalSelfRef : Errors.IllegalForwardRef;
4617                     log.error(tree.pos(), errkey);
4618                 } else if (useBeforeDeclarationWarning) {
4619                     Warning warnkey = (initEnv.info.enclVar == v) ?
4620                                 Warnings.SelfRef(v) : Warnings.ForwardRef(v);
4621                     log.warning(tree.pos(), warnkey);
4622                 }
4623             }
4624 
4625             v.getConstValue(); // ensure initializer is evaluated
4626 
4627             checkEnumInitializer(tree, env, v);
4628         }
4629 
4630         /**
4631          * Returns the enclosing init environment associated with this env (if any). An init env
4632          * can be either a field declaration env or a static/instance initializer env.
4633          */
4634         Env&lt;AttrContext&gt; enclosingInitEnv(Env&lt;AttrContext&gt; env) {
4635             while (true) {
4636                 switch (env.tree.getTag()) {
4637                     case VARDEF:
4638                         JCVariableDecl vdecl = (JCVariableDecl)env.tree;
4639                         if (vdecl.sym.owner.kind == TYP) {
4640                             //field
4641                             return env;
4642                         }
4643                         break;
4644                     case BLOCK:
4645                         if (env.next.tree.hasTag(CLASSDEF)) {
4646                             //instance/static initializer
4647                             return env;
4648                         }
4649                         break;
4650                     case METHODDEF:
4651                     case CLASSDEF:
4652                     case TOPLEVEL:
4653                         return null;
4654                 }
4655                 Assert.checkNonNull(env.next);
4656                 env = env.next;
4657             }
4658         }
4659 
4660         /**
4661          * Check for illegal references to static members of enum.  In
4662          * an enum type, constructors and initializers may not
4663          * reference its static members unless they are constant.
4664          *
4665          * @param tree    The tree making up the variable reference.
4666          * @param env     The current environment.
4667          * @param v       The variable&#39;s symbol.
4668          * @jls 8.9 Enum Types
4669          */
4670         private void checkEnumInitializer(JCTree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
4671             // JLS:
4672             //
4673             // &quot;It is a compile-time error to reference a static field
4674             // of an enum type that is not a compile-time constant
4675             // (15.28) from constructors, instance initializer blocks,
4676             // or instance variable initializer expressions of that
4677             // type. It is a compile-time error for the constructors,
4678             // instance initializer blocks, or instance variable
4679             // initializer expressions of an enum constant e to refer
4680             // to itself or to an enum constant of the same type that
4681             // is declared to the right of e.&quot;
4682             if (isStaticEnumField(v)) {
4683                 ClassSymbol enclClass = env.info.scope.owner.enclClass();
4684 
4685                 if (enclClass == null || enclClass.owner == null)
4686                     return;
4687 
4688                 // See if the enclosing class is the enum (or a
4689                 // subclass thereof) declaring v.  If not, this
4690                 // reference is OK.
4691                 if (v.owner != enclClass &amp;&amp; !types.isSubtype(enclClass.type, v.owner.type))
4692                     return;
4693 
4694                 // If the reference isn&#39;t from an initializer, then
4695                 // the reference is OK.
4696                 if (!Resolve.isInitializer(env))
4697                     return;
4698 
4699                 log.error(tree.pos(), Errors.IllegalEnumStaticRef);
4700             }
4701         }
4702 
4703         /** Is the given symbol a static, non-constant field of an Enum?
4704          *  Note: enum literals should not be regarded as such
4705          */
4706         private boolean isStaticEnumField(VarSymbol v) {
4707             return Flags.isEnum(v.owner) &amp;&amp;
4708                    Flags.isStatic(v) &amp;&amp;
4709                    !Flags.isConstant(v) &amp;&amp;
4710                    v.name != names._class;
4711         }
4712 
4713     /**
4714      * Check that method arguments conform to its instantiation.
4715      **/
4716     public Type checkMethod(Type site,
4717                             final Symbol sym,
4718                             ResultInfo resultInfo,
4719                             Env&lt;AttrContext&gt; env,
4720                             final List&lt;JCExpression&gt; argtrees,
4721                             List&lt;Type&gt; argtypes,
4722                             List&lt;Type&gt; typeargtypes) {
4723         // Test (5): if symbol is an instance method of a raw type, issue
4724         // an unchecked warning if its argument types change under erasure.
4725         if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
4726             (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
4727             Type s = types.asOuterSuper(site, sym.owner);
4728             if (s != null &amp;&amp; s.isRaw() &amp;&amp;
4729                 !types.isSameTypes(sym.type.getParameterTypes(),
4730                                    sym.erasure(types).getParameterTypes())) {
4731                 chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedCallMbrOfRawType(sym, s));
4732             }
4733         }
4734 
4735         if (env.info.defaultSuperCallSite != null) {
4736             for (Type sup : types.interfaces(env.enclClass.type).prepend(types.supertype((env.enclClass.type)))) {
4737                 if (!sup.tsym.isSubClass(sym.enclClass(), types) ||
4738                         types.isSameType(sup, env.info.defaultSuperCallSite)) continue;
4739                 List&lt;MethodSymbol&gt; icand_sup =
4740                         types.interfaceCandidates(sup, (MethodSymbol)sym);
4741                 if (icand_sup.nonEmpty() &amp;&amp;
4742                         icand_sup.head != sym &amp;&amp;
4743                         icand_sup.head.overrides(sym, icand_sup.head.enclClass(), types, true)) {
4744                     log.error(env.tree.pos(),
4745                               Errors.IllegalDefaultSuperCall(env.info.defaultSuperCallSite, Fragments.OverriddenDefault(sym, sup)));
4746                     break;
4747                 }
4748             }
4749             env.info.defaultSuperCallSite = null;
4750         }
4751 
4752         if (sym.isStatic() &amp;&amp; site.isInterface() &amp;&amp; env.tree.hasTag(APPLY)) {
4753             JCMethodInvocation app = (JCMethodInvocation)env.tree;
4754             if (app.meth.hasTag(SELECT) &amp;&amp;
4755                     !TreeInfo.isStaticSelector(((JCFieldAccess)app.meth).selected, names)) {
4756                 log.error(env.tree.pos(), Errors.IllegalStaticIntfMethCall(site));
4757             }
4758         }
4759 
4760         // Compute the identifier&#39;s instantiated type.
4761         // For methods, we need to compute the instance type by
4762         // Resolve.instantiate from the symbol&#39;s type as well as
4763         // any type arguments and value arguments.
4764         Warner noteWarner = new Warner();
4765         try {
4766             Type owntype = rs.checkMethod(
4767                     env,
4768                     site,
4769                     sym,
4770                     resultInfo,
4771                     argtypes,
4772                     typeargtypes,
4773                     noteWarner);
4774 
4775             DeferredAttr.DeferredTypeMap&lt;Void&gt; checkDeferredMap =
4776                 deferredAttr.new DeferredTypeMap&lt;&gt;(DeferredAttr.AttrMode.CHECK, sym, env.info.pendingResolutionPhase);
4777 
4778             argtypes = argtypes.map(checkDeferredMap);
4779 
4780             if (noteWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
4781                 chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedMethInvocationApplied(kindName(sym),
4782                         sym.name,
4783                         rs.methodArguments(sym.type.getParameterTypes()),
4784                         rs.methodArguments(argtypes.map(checkDeferredMap)),
4785                         kindName(sym.location()),
4786                         sym.location()));
4787                 if (resultInfo.pt != Infer.anyPoly ||
4788                         !owntype.hasTag(METHOD) ||
4789                         !owntype.isPartial()) {
4790                     //if this is not a partially inferred method type, erase return type. Otherwise,
4791                     //erasure is carried out in PartiallyInferredMethodType.check().
4792                     owntype = new MethodType(owntype.getParameterTypes(),
4793                             types.erasure(owntype.getReturnType()),
4794                             types.erasure(owntype.getThrownTypes()),
4795                             syms.methodClass);
4796                 }
4797             }
4798 
4799             PolyKind pkind = (sym.type.hasTag(FORALL) &amp;&amp;
4800                  sym.type.getReturnType().containsAny(((ForAll)sym.type).tvars)) ?
4801                  PolyKind.POLY : PolyKind.STANDALONE;
4802             TreeInfo.setPolyKind(env.tree, pkind);
4803 
4804             return (resultInfo.pt == Infer.anyPoly) ?
4805                     owntype :
4806                     chk.checkMethod(owntype, sym, env, argtrees, argtypes, env.info.lastResolveVarargs(),
4807                             resultInfo.checkContext.inferenceContext());
4808         } catch (Infer.InferenceException ex) {
4809             //invalid target type - propagate exception outwards or report error
4810             //depending on the current check context
4811             resultInfo.checkContext.report(env.tree.pos(), ex.getDiagnostic());
4812             return types.createErrorType(site);
4813         } catch (Resolve.InapplicableMethodException ex) {
4814             final JCDiagnostic diag = ex.getDiagnostic();
4815             Resolve.InapplicableSymbolError errSym = rs.new InapplicableSymbolError(null) {
4816                 @Override
4817                 protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4818                     return new Pair&lt;&gt;(sym, diag);
4819                 }
4820             };
4821             List&lt;Type&gt; argtypes2 = argtypes.map(
4822                     rs.new ResolveDeferredRecoveryMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));
4823             JCDiagnostic errDiag = errSym.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
4824                     env.tree, sym, site, sym.name, argtypes2, typeargtypes);
4825             log.report(errDiag);
4826             return types.createErrorType(site);
4827         }
4828     }
4829 
4830     public void visitLiteral(JCLiteral tree) {
4831         result = check(tree, litType(tree.typetag).constType(tree.value),
4832                 KindSelector.VAL, resultInfo);
4833     }
4834     //where
4835     /** Return the type of a literal with given type tag.
4836      */
4837     Type litType(TypeTag tag) {
4838         return (tag == CLASS) ? syms.stringType : syms.typeOfTag[tag.ordinal()];
4839     }
4840 
4841     public void visitTypeIdent(JCPrimitiveTypeTree tree) {
4842         result = check(tree, syms.typeOfTag[tree.typetag.ordinal()], KindSelector.TYP, resultInfo);
4843     }
4844 
4845     public void visitTypeArray(JCArrayTypeTree tree) {
4846         Type etype = attribType(tree.elemtype, env);
4847         Type type = new ArrayType(etype, syms.arrayClass);
4848         result = check(tree, type, KindSelector.TYP, resultInfo);
4849     }
4850 
4851     /** Visitor method for parameterized types.
4852      *  Bound checking is left until later, since types are attributed
4853      *  before supertype structure is completely known
4854      */
4855     public void visitTypeApply(JCTypeApply tree) {
4856         Type owntype = types.createErrorType(tree.type);
4857 
4858         // Attribute functor part of application and make sure it&#39;s a class.
4859         Type clazztype = chk.checkClassType(tree.clazz.pos(), attribType(tree.clazz, env));
4860 
4861         // Attribute type parameters
4862         List&lt;Type&gt; actuals = attribTypes(tree.arguments, env);
4863 
4864         if (clazztype.hasTag(CLASS)) {
4865             List&lt;Type&gt; formals = clazztype.tsym.type.getTypeArguments();
4866             if (actuals.isEmpty()) //diamond
4867                 actuals = formals;
4868 
4869             if (actuals.length() == formals.length()) {
4870                 List&lt;Type&gt; a = actuals;
4871                 List&lt;Type&gt; f = formals;
4872                 while (a.nonEmpty()) {
4873                     a.head = a.head.withTypeVar(f.head);
4874                     a = a.tail;
4875                     f = f.tail;
4876                 }
4877                 // Compute the proper generic outer
4878                 Type clazzOuter = clazztype.getEnclosingType();
4879                 if (clazzOuter.hasTag(CLASS)) {
4880                     Type site;
4881                     JCExpression clazz = TreeInfo.typeIn(tree.clazz);
4882                     if (clazz.hasTag(IDENT)) {
4883                         site = env.enclClass.sym.type;
4884                     } else if (clazz.hasTag(SELECT)) {
4885                         site = ((JCFieldAccess) clazz).selected.type;
4886                     } else throw new AssertionError(&quot;&quot;+tree);
4887                     if (clazzOuter.hasTag(CLASS) &amp;&amp; site != clazzOuter) {
4888                         if (site.hasTag(CLASS))
4889                             site = types.asOuterSuper(site, clazzOuter.tsym);
4890                         if (site == null)
4891                             site = types.erasure(clazzOuter);
4892                         clazzOuter = site;
4893                     }
4894                 }
4895                 owntype = new ClassType(clazzOuter, actuals, clazztype.tsym,
4896                                         clazztype.getMetadata());
4897             } else {
4898                 if (formals.length() != 0) {
4899                     log.error(tree.pos(),
4900                               Errors.WrongNumberTypeArgs(Integer.toString(formals.length())));
4901                 } else {
4902                     log.error(tree.pos(), Errors.TypeDoesntTakeParams(clazztype.tsym));
4903                 }
4904                 owntype = types.createErrorType(tree.type);
4905             }
4906         }
4907         result = check(tree, owntype, KindSelector.TYP, resultInfo);
4908     }
4909 
4910     public void visitTypeUnion(JCTypeUnion tree) {
4911         ListBuffer&lt;Type&gt; multicatchTypes = new ListBuffer&lt;&gt;();
4912         ListBuffer&lt;Type&gt; all_multicatchTypes = null; // lazy, only if needed
4913         for (JCExpression typeTree : tree.alternatives) {
4914             Type ctype = attribType(typeTree, env);
4915             ctype = chk.checkType(typeTree.pos(),
4916                           chk.checkClassType(typeTree.pos(), ctype),
4917                           syms.throwableType);
4918             if (!ctype.isErroneous()) {
4919                 //check that alternatives of a union type are pairwise
4920                 //unrelated w.r.t. subtyping
4921                 if (chk.intersects(ctype,  multicatchTypes.toList())) {
4922                     for (Type t : multicatchTypes) {
4923                         boolean sub = types.isSubtype(ctype, t);
4924                         boolean sup = types.isSubtype(t, ctype);
4925                         if (sub || sup) {
4926                             //assume &#39;a&#39; &lt;: &#39;b&#39;
4927                             Type a = sub ? ctype : t;
4928                             Type b = sub ? t : ctype;
4929                             log.error(typeTree.pos(), Errors.MulticatchTypesMustBeDisjoint(a, b));
4930                         }
4931                     }
4932                 }
4933                 multicatchTypes.append(ctype);
4934                 if (all_multicatchTypes != null)
4935                     all_multicatchTypes.append(ctype);
4936             } else {
4937                 if (all_multicatchTypes == null) {
4938                     all_multicatchTypes = new ListBuffer&lt;&gt;();
4939                     all_multicatchTypes.appendList(multicatchTypes);
4940                 }
4941                 all_multicatchTypes.append(ctype);
4942             }
4943         }
4944         Type t = check(tree, types.lub(multicatchTypes.toList()),
4945                 KindSelector.TYP, resultInfo.dup(CheckMode.NO_TREE_UPDATE));
4946         if (t.hasTag(CLASS)) {
4947             List&lt;Type&gt; alternatives =
4948                 ((all_multicatchTypes == null) ? multicatchTypes : all_multicatchTypes).toList();
4949             t = new UnionClassType((ClassType) t, alternatives);
4950         }
4951         tree.type = result = t;
4952     }
4953 
4954     public void visitTypeIntersection(JCTypeIntersection tree) {
4955         attribTypes(tree.bounds, env);
4956         tree.type = result = checkIntersection(tree, tree.bounds);
4957     }
4958 
4959     public void visitTypeParameter(JCTypeParameter tree) {
4960         TypeVar typeVar = (TypeVar) tree.type;
4961 
4962         if (tree.annotations != null &amp;&amp; tree.annotations.nonEmpty()) {
4963             annotate.annotateTypeParameterSecondStage(tree, tree.annotations);
4964         }
4965 
4966         if (!typeVar.getUpperBound().isErroneous()) {
4967             //fixup type-parameter bound computed in &#39;attribTypeVariables&#39;
4968             typeVar.setUpperBound(checkIntersection(tree, tree.bounds));
4969         }
4970     }
4971 
4972     Type checkIntersection(JCTree tree, List&lt;JCExpression&gt; bounds) {
4973         Set&lt;Type&gt; boundSet = new HashSet&lt;&gt;();
4974         if (bounds.nonEmpty()) {
4975             // accept class or interface or typevar as first bound.
4976             bounds.head.type = checkBase(bounds.head.type, bounds.head, env, false, false, false);
4977             boundSet.add(types.erasure(bounds.head.type));
4978             if (bounds.head.type.isErroneous()) {
4979                 return bounds.head.type;
4980             }
4981             else if (bounds.head.type.hasTag(TYPEVAR)) {
4982                 // if first bound was a typevar, do not accept further bounds.
4983                 if (bounds.tail.nonEmpty()) {
4984                     log.error(bounds.tail.head.pos(),
4985                               Errors.TypeVarMayNotBeFollowedByOtherBounds);
4986                     return bounds.head.type;
4987                 }
4988             } else {
4989                 // if first bound was a class or interface, accept only interfaces
4990                 // as further bounds.
4991                 for (JCExpression bound : bounds.tail) {
4992                     bound.type = checkBase(bound.type, bound, env, false, true, false);
4993                     if (bound.type.isErroneous()) {
4994                         bounds = List.of(bound);
4995                     }
4996                     else if (bound.type.hasTag(CLASS)) {
4997                         chk.checkNotRepeated(bound.pos(), types.erasure(bound.type), boundSet);
4998                     }
4999                 }
5000             }
5001         }
5002 
5003         if (bounds.length() == 0) {
5004             return syms.objectType;
5005         } else if (bounds.length() == 1) {
5006             return bounds.head.type;
5007         } else {
5008             Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));
5009             // ... the variable&#39;s bound is a class type flagged COMPOUND
5010             // (see comment for TypeVar.bound).
5011             // In this case, generate a class tree that represents the
5012             // bound class, ...
5013             JCExpression extending;
5014             List&lt;JCExpression&gt; implementing;
5015             if (!bounds.head.type.isInterface()) {
5016                 extending = bounds.head;
5017                 implementing = bounds.tail;
5018             } else {
5019                 extending = null;
5020                 implementing = bounds;
5021             }
5022             JCClassDecl cd = make.at(tree).ClassDef(
5023                 make.Modifiers(PUBLIC | ABSTRACT | (extending != null &amp;&amp; TreeInfo.symbol(extending).isValue() ? VALUE : 0)),
5024                 names.empty, List.nil(),
5025                 extending, implementing, List.nil());
5026 
5027             ClassSymbol c = (ClassSymbol)owntype.tsym;
5028             Assert.check((c.flags() &amp; COMPOUND) != 0);
5029             cd.sym = c;
5030             c.sourcefile = env.toplevel.sourcefile;
5031 
5032             // ... and attribute the bound class
5033             c.flags_field |= UNATTRIBUTED;
5034             Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);
5035             typeEnvs.put(c, cenv);
5036             attribClass(c);
5037             return owntype;
5038         }
5039     }
5040 
5041     public void visitWildcard(JCWildcard tree) {
5042         //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
5043         Type type = (tree.kind.kind == BoundKind.UNBOUND)
5044             ? syms.objectType
5045             : attribType(tree.inner, env);
5046         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),
5047                                               tree.kind.kind,
5048                                               syms.boundClass),
5049                 KindSelector.TYP, resultInfo);
5050     }
5051 
5052     public void visitAnnotation(JCAnnotation tree) {
5053         Assert.error(&quot;should be handled in annotate&quot;);
5054     }
5055 
5056     public void visitAnnotatedType(JCAnnotatedType tree) {
5057         attribAnnotationTypes(tree.annotations, env);
5058         Type underlyingType = attribType(tree.underlyingType, env);
5059         Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);
5060 
5061         if (!env.info.isNewClass)
5062             annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
5063         result = tree.type = annotatedType;
5064     }
5065 
5066     public void visitErroneous(JCErroneous tree) {
5067         if (tree.errs != null)
5068             for (JCTree err : tree.errs)
5069                 attribTree(err, env, new ResultInfo(KindSelector.ERR, pt()));
5070         result = tree.type = syms.errType;
5071     }
5072 
5073     /** Default visitor method for all other trees.
5074      */
5075     public void visitTree(JCTree tree) {
5076         throw new AssertionError();
5077     }
5078 
5079     /**
5080      * Attribute an env for either a top level tree or class or module declaration.
5081      */
5082     public void attrib(Env&lt;AttrContext&gt; env) {
5083         switch (env.tree.getTag()) {
5084             case MODULEDEF:
5085                 attribModule(env.tree.pos(), ((JCModuleDecl)env.tree).sym);
5086                 break;
5087             case TOPLEVEL:
5088                 attribTopLevel(env);
5089                 break;
5090             case PACKAGEDEF:
5091                 attribPackage(env.tree.pos(), ((JCPackageDecl) env.tree).packge);
5092                 break;
5093             default:
5094                 attribClass(env.tree.pos(), env.enclClass.sym);
5095         }
5096     }
5097 
5098     /**
5099      * Attribute a top level tree. These trees are encountered when the
5100      * package declaration has annotations.
5101      */
5102     public void attribTopLevel(Env&lt;AttrContext&gt; env) {
5103         JCCompilationUnit toplevel = env.toplevel;
5104         try {
5105             annotate.flush();
5106         } catch (CompletionFailure ex) {
5107             chk.completionError(toplevel.pos(), ex);
5108         }
5109     }
5110 
5111     public void attribPackage(DiagnosticPosition pos, PackageSymbol p) {
5112         try {
5113             annotate.flush();
5114             attribPackage(p);
5115         } catch (CompletionFailure ex) {
5116             chk.completionError(pos, ex);
5117         }
5118     }
5119 
5120     void attribPackage(PackageSymbol p) {
5121         Env&lt;AttrContext&gt; env = typeEnvs.get(p);
5122         chk.checkDeprecatedAnnotation(((JCPackageDecl) env.tree).pid.pos(), p);
5123     }
5124 
5125     public void attribModule(DiagnosticPosition pos, ModuleSymbol m) {
5126         try {
5127             annotate.flush();
5128             attribModule(m);
5129         } catch (CompletionFailure ex) {
5130             chk.completionError(pos, ex);
5131         }
5132     }
5133 
5134     void attribModule(ModuleSymbol m) {
5135         // Get environment current at the point of module definition.
5136         Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
5137         attribStat(env.tree, env);
5138     }
5139 
5140     /** Main method: attribute class definition associated with given class symbol.
5141      *  reporting completion failures at the given position.
5142      *  @param pos The source position at which completion errors are to be
5143      *             reported.
5144      *  @param c   The class symbol whose definition will be attributed.
5145      */
5146     public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
5147         try {
5148             annotate.flush();
5149             attribClass(c);
5150             if (types.isValue(c.type)) {
5151                 final Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5152                 if (!allowValueMemberCycles) {
5153                     if (env != null &amp;&amp; env.tree != null &amp;&amp; env.tree.hasTag(CLASSDEF))
5154                         chk.checkNonCyclicMembership((JCClassDecl)env.tree);
5155                 }
5156             }
5157         } catch (CompletionFailure ex) {
5158             chk.completionError(pos, ex);
5159         }
5160     }
5161 
5162     /** Attribute class definition associated with given class symbol.
5163      *  @param c   The class symbol whose definition will be attributed.
5164      */
5165     void attribClass(ClassSymbol c) throws CompletionFailure {
5166         if (c.type.hasTag(ERROR)) return;
5167 
5168         // Check for cycles in the inheritance graph, which can arise from
5169         // ill-formed class files.
5170         chk.checkNonCyclic(null, c.type);
5171 
5172         Type st = types.supertype(c.type);
5173         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5174             // First, attribute superclass.
5175             if (st.hasTag(CLASS))
5176                 attribClass((ClassSymbol)st.tsym);
5177 
5178             // Next attribute owner, if it is a class.
5179             if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))
5180                 attribClass((ClassSymbol)c.owner);
5181         }
5182 
5183         // The previous operations might have attributed the current class
5184         // if there was a cycle. So we test first whether the class is still
5185         // UNATTRIBUTED.
5186         if ((c.flags_field &amp; UNATTRIBUTED) != 0) {
5187             c.flags_field &amp;= ~UNATTRIBUTED;
5188 
5189             // Get environment current at the point of class definition.
5190             Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5191 
5192             if (c.isSealed() &amp;&amp;
5193                     !c.isEnum() &amp;&amp;
5194                     !c.isPermittedExplicit &amp;&amp;
5195                     c.permitted.isEmpty()) {
5196                 log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.SealedClassMustHaveSubclasses);
5197             }
5198 
5199             if (c.isSealed()) {
5200                 Set&lt;Symbol&gt; permittedTypes = new HashSet&lt;&gt;();
5201                 boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;
5202                 for (Symbol subTypeSym : c.permitted) {
5203                     boolean isTypeVar = false;
5204                     if (subTypeSym.type.getTag() == TYPEVAR) {
5205                         isTypeVar = true; //error recovery
5206                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),
5207                                 Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));
5208                     }
5209                     if (subTypeSym.isAnonymous() &amp;&amp; !c.isEnum()) {
5210                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5211                     }
5212                     if (permittedTypes.contains(subTypeSym)) {
5213                         DiagnosticPosition pos =
5214                                 env.enclClass.permitting.stream()
5215                                         .filter(permittedExpr -&gt; TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)
5216                                         .limit(2).collect(List.collector()).get(1);
5217                         log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));
5218                     } else {
5219                         permittedTypes.add(subTypeSym);
5220                     }
5221                     if (sealedInUnnamed) {
5222                         if (subTypeSym.packge() != c.packge()) {
5223                             log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5224                         }
5225                     } else if (subTypeSym.packge().modle != c.packge().modle) {
5226                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5227                     }
5228                     if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {
5229                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),
5230                                 Errors.InvalidPermitsClause(
5231                                         subTypeSym == c.type.tsym ?
5232                                                 Fragments.MustNotBeSameClass :
5233                                                 Fragments.MustNotBeSupertype(subTypeSym.type)
5234                                 )
5235                         );
5236                     } else if (!isTypeVar) {
5237                         boolean thisIsASuper = types.directSupertypes(subTypeSym.type)
5238                                                     .stream()
5239                                                     .anyMatch(d -&gt; d.tsym == c);
5240                         if (!thisIsASuper) {
5241                             log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),
5242                                     Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));
5243                         }
5244                     }
5245                 }
5246             }
5247 
5248             List&lt;ClassSymbol&gt; sealedSupers = types.directSupertypes(c.type)
5249                                                   .stream()
5250                                                   .filter(s -&gt; s.tsym.isSealed())
5251                                                   .map(s -&gt; (ClassSymbol) s.tsym)
5252                                                   .collect(List.collector());
5253 
5254             if (sealedSupers.isEmpty()) {
5255                 if ((c.flags_field &amp; Flags.NON_SEALED) != 0) {
5256                     boolean hasErrorSuper = types.directSupertypes(c.type)
5257                                                  .stream()
5258                                                  .anyMatch(s -&gt; s.tsym.kind == Kind.ERR);
5259                     if (!hasErrorSuper) {
5260                         log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));
5261                     }
5262                 }
<a name="1" id="anc1"></a><span class="line-modified">5263             } else {</span>
5264                 if (c.isLocal() &amp;&amp; !c.isEnum()) {
5265                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed);
5266                 }
5267 
5268                 for (ClassSymbol supertypeSym : sealedSupers) {
5269                     if (!supertypeSym.permitted.contains(c.type.tsym)) {
5270                         log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));
5271                     }
5272                 }
5273                 if (!c.isNonSealed() &amp;&amp; !c.isFinal() &amp;&amp; !c.isSealed()) {
5274                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree),
5275                             c.isInterface() ?
5276                                     Errors.NonSealedOrSealedExpected :
5277                                     Errors.NonSealedSealedOrFinalExpected);
5278                 }
5279             }
5280 
5281             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5282             // because the annotations were not available at the time the env was created. Therefore,
5283             // we look up the environment chain for the first enclosing environment for which the
5284             // lint value is set. Typically, this is the parent env, but might be further if there
5285             // are any envs created as a result of TypeParameter nodes.
5286             Env&lt;AttrContext&gt; lintEnv = env;
5287             while (lintEnv.info.lint == null)
5288                 lintEnv = lintEnv.next;
5289 
5290             // Having found the enclosing lint value, we can initialize the lint value for this class
5291             env.info.lint = lintEnv.info.lint.augment(c);
5292 
5293             Lint prevLint = chk.setLint(env.info.lint);
5294             JavaFileObject prev = log.useSource(c.sourcefile);
5295             ResultInfo prevReturnRes = env.info.returnResult;
5296 
5297             try {
5298                 deferredLintHandler.flush(env.tree);
5299                 env.info.returnResult = null;
5300                 // java.lang.Enum may not be subclassed by a non-enum
5301                 if (st.tsym == syms.enumSym &amp;&amp;
5302                     ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))
5303                     log.error(env.tree.pos(), Errors.EnumNoSubclassing);
5304 
5305                 // Enums may not be extended by source-level classes
5306                 if (st.tsym != null &amp;&amp;
5307                     ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;
5308                     ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {
5309                     log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);
5310                 }
5311 
5312                 if (isSerializable(c.type)) {
5313                     env.info.isSerializable = true;
5314                 }
5315 
5316                 attribClassBody(env, c);
5317 
5318                 if ((c.flags() &amp; (VALUE | ABSTRACT)) == VALUE) { // for non-intersection, concrete values.
5319                     Assert.check(env.tree.hasTag(CLASSDEF));
5320                     JCClassDecl classDecl = (JCClassDecl) env.tree;
5321                     if (classDecl.extending != null) {
5322                         chk.checkConstraintsOfInlineSuper(env.tree.pos(), c);
5323                     }
5324                 }
5325 
5326                 chk.checkDeprecatedAnnotation(env.tree.pos(), c);
5327                 chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
5328                 chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
5329                 chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);
5330             } finally {
5331                 env.info.returnResult = prevReturnRes;
5332                 log.useSource(prev);
5333                 chk.setLint(prevLint);
5334             }
5335 
5336         }
5337     }
5338 
5339     public void visitImport(JCImport tree) {
5340         // nothing to do
5341     }
5342 
5343     public void visitModuleDef(JCModuleDecl tree) {
5344         tree.sym.completeUsesProvides();
5345         ModuleSymbol msym = tree.sym;
5346         Lint lint = env.outer.info.lint = env.outer.info.lint.augment(msym);
5347         Lint prevLint = chk.setLint(lint);
5348         chk.checkModuleName(tree);
5349         chk.checkDeprecatedAnnotation(tree, msym);
5350 
5351         try {
5352             deferredLintHandler.flush(tree.pos());
5353         } finally {
5354             chk.setLint(prevLint);
5355         }
5356     }
5357 
5358     /** Finish the attribution of a class. */
5359     private void attribClassBody(Env&lt;AttrContext&gt; env, ClassSymbol c) {
5360         JCClassDecl tree = (JCClassDecl)env.tree;
5361         Assert.check(c == tree.sym);
5362 
5363         // Validate type parameters, supertype and interfaces.
5364         attribStats(tree.typarams, env);
5365         if (!c.isAnonymous()) {
5366             //already checked if anonymous
5367             chk.validate(tree.typarams, env);
5368             chk.validate(tree.extending, env);
5369             chk.validate(tree.implementing, env);
5370         }
5371 
5372         c.markAbstractIfNeeded(types);
5373 
5374         // If this is a non-abstract class, check that it has no abstract
5375         // methods or unimplemented methods of an implemented interface.
5376         if ((c.flags() &amp; (ABSTRACT | INTERFACE)) == 0) {
5377             chk.checkAllDefined(tree.pos(), c);
5378         }
5379 
5380         if ((c.flags() &amp; ANNOTATION) != 0) {
5381             if (tree.implementing.nonEmpty())
5382                 log.error(tree.implementing.head.pos(),
5383                           Errors.CantExtendIntfAnnotation);
5384             if (tree.typarams.nonEmpty()) {
5385                 log.error(tree.typarams.head.pos(),
5386                           Errors.IntfAnnotationCantHaveTypeParams(c));
5387             }
5388 
5389             // If this annotation type has a @Repeatable, validate
5390             Attribute.Compound repeatable = c.getAnnotationTypeMetadata().getRepeatable();
5391             // If this annotation type has a @Repeatable, validate
5392             if (repeatable != null) {
5393                 // get diagnostic position for error reporting
5394                 DiagnosticPosition cbPos = getDiagnosticPosition(tree, repeatable.type);
5395                 Assert.checkNonNull(cbPos);
5396 
5397                 chk.validateRepeatable(c, repeatable, cbPos);
5398             }
5399         } else {
5400             // Check that all extended classes and interfaces
5401             // are compatible (i.e. no two define methods with same arguments
5402             // yet different return types).  (JLS 8.4.6.3)
5403             chk.checkCompatibleSupertypes(tree.pos(), c.type);
5404             if (allowDefaultMethods) {
5405                 chk.checkDefaultMethodClashes(tree.pos(), c.type);
5406             }
5407         }
5408 
5409         // Check that class does not import the same parameterized interface
5410         // with two different argument lists.
5411         chk.checkClassBounds(tree.pos(), c.type);
5412 
5413         tree.type = c.type;
5414 
5415         for (List&lt;JCTypeParameter&gt; l = tree.typarams;
5416              l.nonEmpty(); l = l.tail) {
5417              Assert.checkNonNull(env.info.scope.findFirst(l.head.name));
5418         }
5419 
5420         // Check that a generic class doesn&#39;t extend Throwable
5421         if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))
5422             log.error(tree.extending.pos(), Errors.GenericThrowable);
5423 
5424         // Check that all methods which implement some
5425         // method conform to the method they implement.
5426         chk.checkImplementations(tree);
5427 
5428         //check that a resource implementing AutoCloseable cannot throw InterruptedException
5429         checkAutoCloseable(tree.pos(), env, c.type);
5430 
5431         boolean hasInstanceFields = false;
5432         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
5433             // Attribute declaration
5434             attribStat(l.head, env);
5435 
5436             if (l.head.hasTag(VARDEF) &amp;&amp; (TreeInfo.flags(l.head) &amp; STATIC) == 0)
5437                 hasInstanceFields = true;
5438 
5439             // Check that declarations in inner classes are not static (JLS 8.1.2)
5440             // Make an exception for static constants.
5441             if (c.owner.kind != PCK &amp;&amp;
5442                 ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
5443                 (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
5444                 Symbol sym = null;
5445                 if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
5446                 if (sym == null ||
5447                     sym.kind != VAR ||
5448                     ((VarSymbol) sym).getConstValue() == null)
5449                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5450             }
5451         }
5452         if (!allowEmptyValues &amp;&amp; !hasInstanceFields &amp;&amp; (c.flags() &amp; (VALUE | SYNTHETIC)) == VALUE) {
5453             log.error(tree.pos(), Errors.EmptyValueNotYet);
5454         }
5455 
5456         // Check for cycles among non-initial constructors.
5457         chk.checkCyclicConstructors(tree);
5458 
5459         // Check for cycles among annotation elements.
5460         chk.checkNonCyclicElements(tree);
5461 
5462         // Check for proper use of serialVersionUID
5463         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5464                 &amp;&amp; isSerializable(c.type)
5465                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5466                 &amp;&amp; !c.isAnonymous()) {
5467             checkSerialVersionUID(tree, c);
5468         }
5469         if (allowTypeAnnos) {
5470             // Correctly organize the positions of the type annotations
5471             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5472 
5473             // Check type annotations applicability rules
5474             validateTypeAnnotations(tree, false);
5475         }
5476     }
5477         // where
5478         /** get a diagnostic position for an attribute of Type t, or null if attribute missing */
5479         private DiagnosticPosition getDiagnosticPosition(JCClassDecl tree, Type t) {
5480             for(List&lt;JCAnnotation&gt; al = tree.mods.annotations; !al.isEmpty(); al = al.tail) {
5481                 if (types.isSameType(al.head.annotationType.type, t))
5482                     return al.head.pos();
5483             }
5484 
5485             return null;
5486         }
5487 
5488         /** check if a type is a subtype of Serializable, if that is available. */
5489         boolean isSerializable(Type t) {
5490             try {
5491                 syms.serializableType.complete();
5492             }
5493             catch (CompletionFailure e) {
5494                 return false;
5495             }
5496             return types.isSubtype(t, syms.serializableType);
5497         }
5498 
5499         /** Check that an appropriate serialVersionUID member is defined. */
5500         private void checkSerialVersionUID(JCClassDecl tree, ClassSymbol c) {
5501 
5502             // check for presence of serialVersionUID
5503             VarSymbol svuid = null;
5504             for (Symbol sym : c.members().getSymbolsByName(names.serialVersionUID)) {
5505                 if (sym.kind == VAR) {
5506                     svuid = (VarSymbol)sym;
5507                     break;
5508                 }
5509             }
5510 
5511             if (svuid == null) {
5512                 log.warning(LintCategory.SERIAL,
5513                         tree.pos(), Warnings.MissingSVUID(c));
5514                 return;
5515             }
5516 
5517             // check that it is static final
5518             if ((svuid.flags() &amp; (STATIC | FINAL)) !=
5519                 (STATIC | FINAL))
5520                 log.warning(LintCategory.SERIAL,
5521                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ImproperSVUID(c));
5522 
5523             // check that it is long
5524             else if (!svuid.type.hasTag(LONG))
5525                 log.warning(LintCategory.SERIAL,
5526                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.LongSVUID(c));
5527 
5528             // check constant
5529             else if (svuid.getConstValue() == null)
5530                 log.warning(LintCategory.SERIAL,
5531                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ConstantSVUID(c));
5532         }
5533 
5534     private Type capture(Type type) {
5535         return types.capture(type);
5536     }
5537 
5538     private void setSyntheticVariableType(JCVariableDecl tree, Type type) {
5539         if (type.isErroneous()) {
5540             tree.vartype = make.at(Position.NOPOS).Erroneous();
5541         } else {
5542             tree.vartype = make.at(Position.NOPOS).Type(type);
5543         }
5544     }
5545 
5546     public void validateTypeAnnotations(JCTree tree, boolean sigOnly) {
5547         tree.accept(new TypeAnnotationsValidator(sigOnly));
5548     }
5549     //where
5550     private final class TypeAnnotationsValidator extends TreeScanner {
5551 
5552         private final boolean sigOnly;
5553         public TypeAnnotationsValidator(boolean sigOnly) {
5554             this.sigOnly = sigOnly;
5555         }
5556 
5557         public void visitAnnotation(JCAnnotation tree) {
5558             chk.validateTypeAnnotation(tree, false);
5559             super.visitAnnotation(tree);
5560         }
5561         public void visitAnnotatedType(JCAnnotatedType tree) {
5562             if (!tree.underlyingType.type.isErroneous()) {
5563                 super.visitAnnotatedType(tree);
5564             }
5565         }
5566         public void visitTypeParameter(JCTypeParameter tree) {
5567             chk.validateTypeAnnotations(tree.annotations, true);
5568             scan(tree.bounds);
5569             // Don&#39;t call super.
5570             // This is needed because above we call validateTypeAnnotation with
5571             // false, which would forbid annotations on type parameters.
5572             // super.visitTypeParameter(tree);
5573         }
5574         public void visitMethodDef(JCMethodDecl tree) {
5575             if (tree.recvparam != null &amp;&amp;
5576                     !tree.recvparam.vartype.type.isErroneous()) {
5577                 checkForDeclarationAnnotations(tree.recvparam.mods.annotations,
5578                         tree.recvparam.vartype.type.tsym);
5579             }
5580             if (tree.restype != null &amp;&amp; tree.restype.type != null) {
5581                 validateAnnotatedType(tree.restype, tree.restype.type);
5582             }
5583             if (sigOnly) {
5584                 scan(tree.mods);
5585                 scan(tree.restype);
5586                 scan(tree.typarams);
5587                 scan(tree.recvparam);
5588                 scan(tree.params);
5589                 scan(tree.thrown);
5590             } else {
5591                 scan(tree.defaultValue);
5592                 scan(tree.body);
5593             }
5594         }
5595         public void visitVarDef(final JCVariableDecl tree) {
5596             //System.err.println(&quot;validateTypeAnnotations.visitVarDef &quot; + tree);
5597             if (tree.sym != null &amp;&amp; tree.sym.type != null &amp;&amp; !tree.isImplicitlyTyped())
5598                 validateAnnotatedType(tree.vartype, tree.sym.type);
5599             scan(tree.mods);
5600             scan(tree.vartype);
5601             if (!sigOnly) {
5602                 scan(tree.init);
5603             }
5604         }
5605         public void visitTypeCast(JCTypeCast tree) {
5606             if (tree.clazz != null &amp;&amp; tree.clazz.type != null)
5607                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5608             super.visitTypeCast(tree);
5609         }
5610         public void visitTypeTest(JCInstanceOf tree) {
5611             if (tree.pattern != null &amp;&amp; !(tree.pattern instanceof JCPattern) &amp;&amp; tree.pattern.type != null)
5612                 validateAnnotatedType(tree.pattern, tree.pattern.type);
5613             super.visitTypeTest(tree);
5614         }
5615         public void visitNewClass(JCNewClass tree) {
5616             if (tree.clazz != null &amp;&amp; tree.clazz.type != null) {
5617                 if (tree.clazz.hasTag(ANNOTATED_TYPE)) {
5618                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.clazz).annotations,
5619                             tree.clazz.type.tsym);
5620                 }
5621                 if (tree.def != null) {
5622                     checkForDeclarationAnnotations(tree.def.mods.annotations, tree.clazz.type.tsym);
5623                 }
5624 
5625                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5626             }
5627             super.visitNewClass(tree);
5628         }
5629         public void visitNewArray(JCNewArray tree) {
5630             if (tree.elemtype != null &amp;&amp; tree.elemtype.type != null) {
5631                 if (tree.elemtype.hasTag(ANNOTATED_TYPE)) {
5632                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.elemtype).annotations,
5633                             tree.elemtype.type.tsym);
5634                 }
5635                 validateAnnotatedType(tree.elemtype, tree.elemtype.type);
5636             }
5637             super.visitNewArray(tree);
5638         }
5639         public void visitClassDef(JCClassDecl tree) {
5640             //System.err.println(&quot;validateTypeAnnotations.visitClassDef &quot; + tree);
5641             if (sigOnly) {
5642                 scan(tree.mods);
5643                 scan(tree.typarams);
5644                 scan(tree.extending);
5645                 scan(tree.implementing);
5646             }
5647             for (JCTree member : tree.defs) {
5648                 if (member.hasTag(Tag.CLASSDEF)) {
5649                     continue;
5650                 }
5651                 scan(member);
5652             }
5653         }
5654         public void visitBlock(JCBlock tree) {
5655             if (!sigOnly) {
5656                 scan(tree.stats);
5657             }
5658         }
5659 
5660         /* I would want to model this after
5661          * com.sun.tools.javac.comp.Check.Validator.visitSelectInternal(JCFieldAccess)
5662          * and override visitSelect and visitTypeApply.
5663          * However, we only set the annotated type in the top-level type
5664          * of the symbol.
5665          * Therefore, we need to override each individual location where a type
5666          * can occur.
5667          */
5668         private void validateAnnotatedType(final JCTree errtree, final Type type) {
5669             //System.err.println(&quot;Attr.validateAnnotatedType: &quot; + errtree + &quot; type: &quot; + type);
5670 
5671             if (type.isPrimitiveOrVoid()) {
5672                 return;
5673             }
5674 
5675             JCTree enclTr = errtree;
5676             Type enclTy = type;
5677 
5678             boolean repeat = true;
5679             while (repeat) {
5680                 if (enclTr.hasTag(TYPEAPPLY)) {
5681                     List&lt;Type&gt; tyargs = enclTy.getTypeArguments();
5682                     List&lt;JCExpression&gt; trargs = ((JCTypeApply)enclTr).getTypeArguments();
5683                     if (trargs.length() &gt; 0) {
5684                         // Nothing to do for diamonds
5685                         if (tyargs.length() == trargs.length()) {
5686                             for (int i = 0; i &lt; tyargs.length(); ++i) {
5687                                 validateAnnotatedType(trargs.get(i), tyargs.get(i));
5688                             }
5689                         }
5690                         // If the lengths don&#39;t match, it&#39;s either a diamond
5691                         // or some nested type that redundantly provides
5692                         // type arguments in the tree.
5693                     }
5694 
5695                     // Look at the clazz part of a generic type
5696                     enclTr = ((JCTree.JCTypeApply)enclTr).clazz;
5697                 }
5698 
5699                 if (enclTr.hasTag(SELECT)) {
5700                     enclTr = ((JCTree.JCFieldAccess)enclTr).getExpression();
5701                     if (enclTy != null &amp;&amp;
5702                             !enclTy.hasTag(NONE)) {
5703                         enclTy = enclTy.getEnclosingType();
5704                     }
5705                 } else if (enclTr.hasTag(ANNOTATED_TYPE)) {
5706                     JCAnnotatedType at = (JCTree.JCAnnotatedType) enclTr;
5707                     if (enclTy == null || enclTy.hasTag(NONE)) {
5708                         if (at.getAnnotations().size() == 1) {
5709                             log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping1(at.getAnnotations().head.attribute));
5710                         } else {
5711                             ListBuffer&lt;Attribute.Compound&gt; comps = new ListBuffer&lt;&gt;();
5712                             for (JCAnnotation an : at.getAnnotations()) {
5713                                 comps.add(an.attribute);
5714                             }
5715                             log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping(comps.toList()));
5716                         }
5717                         repeat = false;
5718                     }
5719                     enclTr = at.underlyingType;
5720                     // enclTy doesn&#39;t need to be changed
5721                 } else if (enclTr.hasTag(IDENT)) {
5722                     repeat = false;
5723                 } else if (enclTr.hasTag(JCTree.Tag.WILDCARD)) {
5724                     JCWildcard wc = (JCWildcard) enclTr;
5725                     if (wc.getKind() == JCTree.Kind.EXTENDS_WILDCARD ||
5726                             wc.getKind() == JCTree.Kind.SUPER_WILDCARD) {
5727                         validateAnnotatedType(wc.getBound(), wc.getBound().type);
5728                     } else {
5729                         // Nothing to do for UNBOUND
5730                     }
5731                     repeat = false;
5732                 } else if (enclTr.hasTag(TYPEARRAY)) {
5733                     JCArrayTypeTree art = (JCArrayTypeTree) enclTr;
5734                     validateAnnotatedType(art.getType(), art.elemtype.type);
5735                     repeat = false;
5736                 } else if (enclTr.hasTag(TYPEUNION)) {
5737                     JCTypeUnion ut = (JCTypeUnion) enclTr;
5738                     for (JCTree t : ut.getTypeAlternatives()) {
5739                         validateAnnotatedType(t, t.type);
5740                     }
5741                     repeat = false;
5742                 } else if (enclTr.hasTag(TYPEINTERSECTION)) {
5743                     JCTypeIntersection it = (JCTypeIntersection) enclTr;
5744                     for (JCTree t : it.getBounds()) {
5745                         validateAnnotatedType(t, t.type);
5746                     }
5747                     repeat = false;
5748                 } else if (enclTr.getKind() == JCTree.Kind.PRIMITIVE_TYPE ||
5749                            enclTr.getKind() == JCTree.Kind.ERRONEOUS) {
5750                     repeat = false;
5751                 } else {
5752                     Assert.error(&quot;Unexpected tree: &quot; + enclTr + &quot; with kind: &quot; + enclTr.getKind() +
5753                             &quot; within: &quot;+ errtree + &quot; with kind: &quot; + errtree.getKind());
5754                 }
5755             }
5756         }
5757 
5758         private void checkForDeclarationAnnotations(List&lt;? extends JCAnnotation&gt; annotations,
5759                 Symbol sym) {
5760             // Ensure that no declaration annotations are present.
5761             // Note that a tree type might be an AnnotatedType with
5762             // empty annotations, if only declaration annotations were given.
5763             // This method will raise an error for such a type.
5764             for (JCAnnotation ai : annotations) {
5765                 if (!ai.type.isErroneous() &amp;&amp;
5766                         typeAnnotations.annotationTargetType(ai.attribute, sym) == TypeAnnotations.AnnotationType.DECLARATION) {
5767                     log.error(ai.pos(), Errors.AnnotationTypeNotApplicableToType(ai.type));
5768                 }
5769             }
5770         }
5771     }
5772 
5773     // &lt;editor-fold desc=&quot;post-attribution visitor&quot;&gt;
5774 
5775     /**
5776      * Handle missing types/symbols in an AST. This routine is useful when
5777      * the compiler has encountered some errors (which might have ended up
5778      * terminating attribution abruptly); if the compiler is used in fail-over
5779      * mode (e.g. by an IDE) and the AST contains semantic errors, this routine
5780      * prevents NPE to be propagated during subsequent compilation steps.
5781      */
5782     public void postAttr(JCTree tree) {
5783         new PostAttrAnalyzer().scan(tree);
5784     }
5785 
5786     class PostAttrAnalyzer extends TreeScanner {
5787 
5788         private void initTypeIfNeeded(JCTree that) {
5789             if (that.type == null) {
5790                 if (that.hasTag(METHODDEF)) {
5791                     that.type = dummyMethodType((JCMethodDecl)that);
5792                 } else {
5793                     that.type = syms.unknownType;
5794                 }
5795             }
5796         }
5797 
5798         /* Construct a dummy method type. If we have a method declaration,
5799          * and the declared return type is void, then use that return type
5800          * instead of UNKNOWN to avoid spurious error messages in lambda
5801          * bodies (see:JDK-8041704).
5802          */
5803         private Type dummyMethodType(JCMethodDecl md) {
5804             Type restype = syms.unknownType;
5805             if (md != null &amp;&amp; md.restype != null &amp;&amp; md.restype.hasTag(TYPEIDENT)) {
5806                 JCPrimitiveTypeTree prim = (JCPrimitiveTypeTree)md.restype;
5807                 if (prim.typetag == VOID)
5808                     restype = syms.voidType;
5809             }
5810             return new MethodType(List.nil(), restype,
5811                                   List.nil(), syms.methodClass);
5812         }
5813         private Type dummyMethodType() {
5814             return dummyMethodType(null);
5815         }
5816 
5817         @Override
5818         public void scan(JCTree tree) {
5819             if (tree == null) return;
5820             if (tree instanceof JCExpression) {
5821                 initTypeIfNeeded(tree);
5822             }
5823             super.scan(tree);
5824         }
5825 
5826         @Override
5827         public void visitIdent(JCIdent that) {
5828             if (that.sym == null) {
5829                 that.sym = syms.unknownSymbol;
5830             }
5831         }
5832 
5833         @Override
5834         public void visitSelect(JCFieldAccess that) {
5835             if (that.sym == null) {
5836                 that.sym = syms.unknownSymbol;
5837             }
5838             super.visitSelect(that);
5839         }
5840 
5841         @Override
5842         public void visitClassDef(JCClassDecl that) {
5843             initTypeIfNeeded(that);
5844             if (that.sym == null) {
5845                 that.sym = new ClassSymbol(0, that.name, that.type, syms.noSymbol);
5846             }
5847             super.visitClassDef(that);
5848         }
5849 
5850         @Override
5851         public void visitMethodDef(JCMethodDecl that) {
5852             initTypeIfNeeded(that);
5853             if (that.sym == null) {
5854                 that.sym = new MethodSymbol(0, that.name, that.type, syms.noSymbol);
5855             }
5856             super.visitMethodDef(that);
5857         }
5858 
5859         @Override
5860         public void visitVarDef(JCVariableDecl that) {
5861             initTypeIfNeeded(that);
5862             if (that.sym == null) {
5863                 that.sym = new VarSymbol(0, that.name, that.type, syms.noSymbol);
5864                 that.sym.adr = 0;
5865             }
5866             if (that.vartype == null) {
5867                 that.vartype = make.at(Position.NOPOS).Erroneous();
5868             }
5869             super.visitVarDef(that);
5870         }
5871 
5872         @Override
5873         public void visitBindingPattern(JCBindingPattern that) {
5874             if (that.symbol == null) {
5875                 that.symbol = new BindingSymbol(that.name, that.type, syms.noSymbol);
5876                 that.symbol.adr = 0;
5877             }
5878             super.visitBindingPattern(that);
5879         }
5880 
5881         @Override
5882         public void visitNewClass(JCNewClass that) {
5883             if (that.constructor == null) {
5884                 that.constructor = new MethodSymbol(0, names.init,
5885                         dummyMethodType(), syms.noSymbol);
5886             }
5887             if (that.constructorType == null) {
5888                 that.constructorType = syms.unknownType;
5889             }
5890             super.visitNewClass(that);
5891         }
5892 
5893         @Override
5894         public void visitAssignop(JCAssignOp that) {
5895             if (that.operator == null) {
5896                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5897                         -1, syms.noSymbol);
5898             }
5899             super.visitAssignop(that);
5900         }
5901 
5902         @Override
5903         public void visitBinary(JCBinary that) {
5904             if (that.operator == null) {
5905                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5906                         -1, syms.noSymbol);
5907             }
5908             super.visitBinary(that);
5909         }
5910 
5911         @Override
5912         public void visitUnary(JCUnary that) {
5913             if (that.operator == null) {
5914                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5915                         -1, syms.noSymbol);
5916             }
5917             super.visitUnary(that);
5918         }
5919 
5920         @Override
5921         public void visitReference(JCMemberReference that) {
5922             super.visitReference(that);
5923             if (that.sym == null) {
5924                 that.sym = new MethodSymbol(0, names.empty, dummyMethodType(),
5925                         syms.noSymbol);
5926             }
5927         }
5928     }
5929     // &lt;/editor-fold&gt;
5930 
5931     public void setPackageSymbols(JCExpression pid, Symbol pkg) {
5932         new TreeScanner() {
5933             Symbol packge = pkg;
5934             @Override
5935             public void visitIdent(JCIdent that) {
5936                 that.sym = packge;
5937             }
5938 
5939             @Override
5940             public void visitSelect(JCFieldAccess that) {
5941                 that.sym = packge;
5942                 packge = packge.owner;
5943                 super.visitSelect(that);
5944             }
5945         }.scan(pid);
5946     }
5947 
5948 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>