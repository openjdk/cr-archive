<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/library_call.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;ci/ciUtilities.inline.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;
  31 #include &quot;compiler/compileLog.hpp&quot;
  32 #include &quot;gc/shared/barrierSet.hpp&quot;
  33 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;oops/klass.inline.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;opto/addnode.hpp&quot;
  38 #include &quot;opto/arraycopynode.hpp&quot;
  39 #include &quot;opto/c2compiler.hpp&quot;
  40 #include &quot;opto/callGenerator.hpp&quot;
  41 #include &quot;opto/castnode.hpp&quot;
  42 #include &quot;opto/cfgnode.hpp&quot;
  43 #include &quot;opto/convertnode.hpp&quot;
  44 #include &quot;opto/countbitsnode.hpp&quot;
  45 #include &quot;opto/inlinetypenode.hpp&quot;
  46 #include &quot;opto/intrinsicnode.hpp&quot;
  47 #include &quot;opto/idealKit.hpp&quot;
  48 #include &quot;opto/mathexactnode.hpp&quot;
  49 #include &quot;opto/movenode.hpp&quot;
  50 #include &quot;opto/mulnode.hpp&quot;
  51 #include &quot;opto/narrowptrnode.hpp&quot;
  52 #include &quot;opto/opaquenode.hpp&quot;
  53 #include &quot;opto/parse.hpp&quot;
  54 #include &quot;opto/runtime.hpp&quot;
  55 #include &quot;opto/rootnode.hpp&quot;
  56 #include &quot;opto/subnode.hpp&quot;
  57 #include &quot;prims/nativeLookup.hpp&quot;
  58 #include &quot;prims/unsafe.hpp&quot;
  59 #include &quot;runtime/objectMonitor.hpp&quot;
  60 #include &quot;runtime/sharedRuntime.hpp&quot;
  61 #include &quot;utilities/macros.hpp&quot;
  62 #include &quot;utilities/powerOfTwo.hpp&quot;
  63 
  64 class LibraryIntrinsic : public InlineCallGenerator {
  65   // Extend the set of intrinsics known to the runtime:
  66  public:
  67  private:
  68   bool             _is_virtual;
  69   bool             _does_virtual_dispatch;
  70   int8_t           _predicates_count;  // Intrinsic is predicated by several conditions
  71   int8_t           _last_predicate; // Last generated predicate
  72   vmIntrinsics::ID _intrinsic_id;
  73 
  74  public:
  75   LibraryIntrinsic(ciMethod* m, bool is_virtual, int predicates_count, bool does_virtual_dispatch, vmIntrinsics::ID id)
  76     : InlineCallGenerator(m),
  77       _is_virtual(is_virtual),
  78       _does_virtual_dispatch(does_virtual_dispatch),
  79       _predicates_count((int8_t)predicates_count),
  80       _last_predicate((int8_t)-1),
  81       _intrinsic_id(id)
  82   {
  83   }
  84   virtual bool is_intrinsic() const { return true; }
  85   virtual bool is_virtual()   const { return _is_virtual; }
  86   virtual bool is_predicated() const { return _predicates_count &gt; 0; }
  87   virtual int  predicates_count() const { return _predicates_count; }
  88   virtual bool does_virtual_dispatch()   const { return _does_virtual_dispatch; }
  89   virtual JVMState* generate(JVMState* jvms);
  90   virtual Node* generate_predicate(JVMState* jvms, int predicate);
  91   vmIntrinsics::ID intrinsic_id() const { return _intrinsic_id; }
  92 };
  93 
  94 
  95 // Local helper class for LibraryIntrinsic:
  96 class LibraryCallKit : public GraphKit {
  97  private:
  98   LibraryIntrinsic* _intrinsic;     // the library intrinsic being called
  99   Node*             _result;        // the result node, if any
 100   int               _reexecute_sp;  // the stack pointer when bytecode needs to be reexecuted
 101 
 102   const TypeOopPtr* sharpen_unsafe_type(Compile::AliasType* alias_type, const TypePtr *adr_type);
 103 
 104  public:
 105   LibraryCallKit(JVMState* jvms, LibraryIntrinsic* intrinsic)
 106     : GraphKit(jvms),
 107       _intrinsic(intrinsic),
 108       _result(NULL)
 109   {
 110     // Check if this is a root compile.  In that case we don&#39;t have a caller.
 111     if (!jvms-&gt;has_method()) {
 112       _reexecute_sp = sp();
 113     } else {
 114       // Find out how many arguments the interpreter needs when deoptimizing
 115       // and save the stack pointer value so it can used by uncommon_trap.
 116       // We find the argument count by looking at the declared signature.
 117       bool ignored_will_link;
 118       ciSignature* declared_signature = NULL;
 119       ciMethod* ignored_callee = caller()-&gt;get_method_at_bci(bci(), ignored_will_link, &amp;declared_signature);
 120       const int nargs = declared_signature-&gt;arg_size_for_bc(caller()-&gt;java_code_at_bci(bci()));
 121       _reexecute_sp = sp() + nargs;  // &quot;push&quot; arguments back on stack
 122     }
 123   }
 124 
 125   virtual LibraryCallKit* is_LibraryCallKit() const { return (LibraryCallKit*)this; }
 126 
 127   ciMethod*         caller()    const    { return jvms()-&gt;method(); }
 128   int               bci()       const    { return jvms()-&gt;bci(); }
 129   LibraryIntrinsic* intrinsic() const    { return _intrinsic; }
 130   vmIntrinsics::ID  intrinsic_id() const { return _intrinsic-&gt;intrinsic_id(); }
 131   ciMethod*         callee()    const    { return _intrinsic-&gt;method(); }
 132 
 133   bool  try_to_inline(int predicate);
 134   Node* try_to_predicate(int predicate);
 135 
 136   void push_result() {
 137     // Push the result onto the stack.
 138     Node* res = result();
 139     if (!stopped() &amp;&amp; res != NULL) {
 140       BasicType bt = res-&gt;bottom_type()-&gt;basic_type();
 141       if (C-&gt;inlining_incrementally() &amp;&amp; res-&gt;is_InlineType()) {
 142         // The caller expects an oop when incrementally inlining an intrinsic that returns an
 143         // inline type. Make sure the call is re-executed if the allocation triggers a deoptimization.
 144         PreserveReexecuteState preexecs(this);
 145         jvms()-&gt;set_should_reexecute(true);
 146         res = res-&gt;as_InlineType()-&gt;buffer(this);
 147       }
 148       push_node(bt, res);
 149     }
 150   }
 151 
 152  private:
 153   void fatal_unexpected_iid(vmIntrinsics::ID iid) {
 154     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
 155   }
 156 
 157   void  set_result(Node* n) { assert(_result == NULL, &quot;only set once&quot;); _result = n; }
 158   void  set_result(RegionNode* region, PhiNode* value);
 159   Node*     result() { return _result; }
 160 
 161   virtual int reexecute_sp() { return _reexecute_sp; }
 162 
 163   // Helper functions to inline natives
 164   Node* generate_guard(Node* test, RegionNode* region, float true_prob);
 165   Node* generate_slow_guard(Node* test, RegionNode* region);
 166   Node* generate_fair_guard(Node* test, RegionNode* region);
 167   Node* generate_negative_guard(Node* index, RegionNode* region,
 168                                 // resulting CastII of index:
 169                                 Node* *pos_index = NULL);
 170   Node* generate_limit_guard(Node* offset, Node* subseq_length,
 171                              Node* array_length,
 172                              RegionNode* region);
 173   void  generate_string_range_check(Node* array, Node* offset,
 174                                     Node* length, bool char_count);
 175   Node* generate_current_thread(Node* &amp;tls_output);
 176   Node* load_klass_from_mirror_common(Node* mirror, bool never_see_null,
 177                                       RegionNode* region, int null_path,
 178                                       int offset);
 179   Node* load_klass_from_mirror(Node* mirror, bool never_see_null,
 180                                RegionNode* region, int null_path) {
 181     int offset = java_lang_Class::klass_offset();
 182     return load_klass_from_mirror_common(mirror, never_see_null,
 183                                          region, null_path,
 184                                          offset);
 185   }
 186   Node* load_array_klass_from_mirror(Node* mirror, bool never_see_null,
 187                                      RegionNode* region, int null_path) {
 188     int offset = java_lang_Class::array_klass_offset();
 189     return load_klass_from_mirror_common(mirror, never_see_null,
 190                                          region, null_path,
 191                                          offset);
 192   }
 193   Node* generate_access_flags_guard(Node* kls,
 194                                     int modifier_mask, int modifier_bits,
 195                                     RegionNode* region);
 196   Node* generate_interface_guard(Node* kls, RegionNode* region);
 197   Node* generate_value_guard(Node* kls, RegionNode* region);
 198 
 199   enum ArrayKind {
 200     AnyArray,
 201     NonArray,
 202     ObjectArray,
 203     NonObjectArray,
 204     TypeArray,
 205     FlatArray
 206   };
 207 
 208   Node* generate_hidden_class_guard(Node* kls, RegionNode* region);
 209 
 210   Node* generate_array_guard(Node* kls, RegionNode* region) {
 211     return generate_array_guard_common(kls, region, AnyArray);
 212   }
 213   Node* generate_non_array_guard(Node* kls, RegionNode* region) {
 214     return generate_array_guard_common(kls, region, NonArray);
 215   }
 216   Node* generate_objArray_guard(Node* kls, RegionNode* region) {
 217     return generate_array_guard_common(kls, region, ObjectArray);
 218   }
 219   Node* generate_non_objArray_guard(Node* kls, RegionNode* region) {
 220     return generate_array_guard_common(kls, region, NonObjectArray);
 221   }
 222   Node* generate_typeArray_guard(Node* kls, RegionNode* region) {
 223     return generate_array_guard_common(kls, region, TypeArray);
 224   }
 225   Node* generate_flatArray_guard(Node* kls, RegionNode* region) {
 226     assert(UseFlatArray, &quot;can never be flattened&quot;);
 227     return generate_array_guard_common(kls, region, FlatArray);
 228   }
 229   Node* generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind);
 230   Node* generate_virtual_guard(Node* obj_klass, RegionNode* slow_region);
 231   CallJavaNode* generate_method_call(vmIntrinsics::ID method_id,
 232                                      bool is_virtual = false, bool is_static = false);
 233   CallJavaNode* generate_method_call_static(vmIntrinsics::ID method_id) {
 234     return generate_method_call(method_id, false, true);
 235   }
 236   CallJavaNode* generate_method_call_virtual(vmIntrinsics::ID method_id) {
 237     return generate_method_call(method_id, true, false);
 238   }
 239   Node * load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);
 240   Node * field_address_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);
 241 
 242   Node* make_string_method_node(int opcode, Node* str1_start, Node* cnt1, Node* str2_start, Node* cnt2, StrIntrinsicNode::ArgEnc ae);
 243   bool inline_string_compareTo(StrIntrinsicNode::ArgEnc ae);
 244   bool inline_string_indexOf(StrIntrinsicNode::ArgEnc ae);
 245   bool inline_string_indexOfI(StrIntrinsicNode::ArgEnc ae);
 246   Node* make_indexOf_node(Node* src_start, Node* src_count, Node* tgt_start, Node* tgt_count,
 247                           RegionNode* region, Node* phi, StrIntrinsicNode::ArgEnc ae);
 248   bool inline_string_indexOfChar();
 249   bool inline_string_equals(StrIntrinsicNode::ArgEnc ae);
 250   bool inline_string_toBytesU();
 251   bool inline_string_getCharsU();
 252   bool inline_string_copy(bool compress);
 253   bool inline_string_char_access(bool is_store);
 254   Node* round_double_node(Node* n);
 255   bool runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName);
 256   bool inline_math_native(vmIntrinsics::ID id);
 257   bool inline_math(vmIntrinsics::ID id);
 258   bool inline_double_math(vmIntrinsics::ID id);
 259   template &lt;typename OverflowOp&gt;
 260   bool inline_math_overflow(Node* arg1, Node* arg2);
 261   void inline_math_mathExact(Node* math, Node* test);
 262   bool inline_math_addExactI(bool is_increment);
 263   bool inline_math_addExactL(bool is_increment);
 264   bool inline_math_multiplyExactI();
 265   bool inline_math_multiplyExactL();
 266   bool inline_math_multiplyHigh();
 267   bool inline_math_negateExactI();
 268   bool inline_math_negateExactL();
 269   bool inline_math_subtractExactI(bool is_decrement);
 270   bool inline_math_subtractExactL(bool is_decrement);
 271   bool inline_min_max(vmIntrinsics::ID id);
 272   bool inline_notify(vmIntrinsics::ID id);
 273   Node* generate_min_max(vmIntrinsics::ID id, Node* x, Node* y);
 274   // This returns Type::AnyPtr, RawPtr, or OopPtr.
 275   int classify_unsafe_addr(Node* &amp;base, Node* &amp;offset, BasicType type);
 276   Node* make_unsafe_address(Node*&amp; base, Node* offset, DecoratorSet decorators, BasicType type = T_ILLEGAL, bool can_cast = false);
 277 
 278   typedef enum { Relaxed, Opaque, Volatile, Acquire, Release } AccessKind;
 279   DecoratorSet mo_decorator_for_access_kind(AccessKind kind);
 280   bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned);
 281   static bool klass_needs_init_guard(Node* kls);
 282   bool inline_unsafe_allocate();
 283   bool inline_unsafe_newArray(bool uninitialized);
 284   bool inline_unsafe_writeback0();
 285   bool inline_unsafe_writebackSync0(bool is_pre);
 286   bool inline_unsafe_copyMemory();
 287   bool inline_unsafe_make_private_buffer();
 288   bool inline_unsafe_finish_private_buffer();
 289   bool inline_native_currentThread();
 290 
 291   bool inline_native_time_funcs(address method, const char* funcName);
 292 #ifdef JFR_HAVE_INTRINSICS
 293   bool inline_native_classID();
 294   bool inline_native_getEventWriter();
 295 #endif
 296   bool inline_native_Class_query(vmIntrinsics::ID id);
 297   bool inline_native_subtype_check();
 298   bool inline_native_getLength();
 299   bool inline_array_copyOf(bool is_copyOfRange);
 300   bool inline_array_equals(StrIntrinsicNode::ArgEnc ae);
 301   bool inline_preconditions_checkIndex();
 302   void copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array);
 303   bool inline_native_clone(bool is_virtual);
 304   bool inline_native_Reflection_getCallerClass();
 305   // Helper function for inlining native object hash method
 306   bool inline_native_hashcode(bool is_virtual, bool is_static);
 307   bool inline_native_getClass();
 308 
 309   // Helper functions for inlining arraycopy
 310   bool inline_arraycopy();
 311   AllocateArrayNode* tightly_coupled_allocation(Node* ptr,
 312                                                 RegionNode* slow_region);
 313   JVMState* arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp);
 314   void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms, int saved_reexecute_sp,
 315                                       uint new_idx);
 316 
 317   typedef enum { LS_get_add, LS_get_set, LS_cmp_swap, LS_cmp_swap_weak, LS_cmp_exchange } LoadStoreKind;
 318   bool inline_unsafe_load_store(BasicType type,  LoadStoreKind kind, AccessKind access_kind);
 319   bool inline_unsafe_fence(vmIntrinsics::ID id);
 320   bool inline_onspinwait();
 321   bool inline_fp_conversions(vmIntrinsics::ID id);
 322   bool inline_number_methods(vmIntrinsics::ID id);
 323   bool inline_reference_get();
 324   bool inline_Class_cast();
 325   bool inline_aescrypt_Block(vmIntrinsics::ID id);
 326   bool inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id);
 327   bool inline_electronicCodeBook_AESCrypt(vmIntrinsics::ID id);
 328   bool inline_counterMode_AESCrypt(vmIntrinsics::ID id);
 329   Node* inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting);
 330   Node* inline_electronicCodeBook_AESCrypt_predicate(bool decrypting);
 331   Node* inline_counterMode_AESCrypt_predicate();
 332   Node* get_key_start_from_aescrypt_object(Node* aescrypt_object);
 333   Node* get_original_key_start_from_aescrypt_object(Node* aescrypt_object);
 334   bool inline_ghash_processBlocks();
 335   bool inline_base64_encodeBlock();
 336   bool inline_sha_implCompress(vmIntrinsics::ID id);
 337   bool inline_digestBase_implCompressMB(int predicate);
 338   bool inline_sha_implCompressMB(Node* digestBaseObj, ciInstanceKlass* instklass_SHA,
 339                                  bool long_state, address stubAddr, const char *stubName,
 340                                  Node* src_start, Node* ofs, Node* limit);
 341   Node* get_state_from_sha_object(Node *sha_object);
 342   Node* get_state_from_sha5_object(Node *sha_object);
 343   Node* inline_digestBase_implCompressMB_predicate(int predicate);
 344   bool inline_encodeISOArray();
 345   bool inline_updateCRC32();
 346   bool inline_updateBytesCRC32();
 347   bool inline_updateByteBufferCRC32();
 348   Node* get_table_from_crc32c_class(ciInstanceKlass *crc32c_class);
 349   bool inline_updateBytesCRC32C();
 350   bool inline_updateDirectByteBufferCRC32C();
 351   bool inline_updateBytesAdler32();
 352   bool inline_updateByteBufferAdler32();
 353   bool inline_multiplyToLen();
 354   bool inline_hasNegatives();
 355   bool inline_squareToLen();
 356   bool inline_mulAdd();
 357   bool inline_montgomeryMultiply();
 358   bool inline_montgomerySquare();
 359   bool inline_bigIntegerShift(bool isRightShift);
 360   bool inline_vectorizedMismatch();
 361   bool inline_fma(vmIntrinsics::ID id);
 362   bool inline_character_compare(vmIntrinsics::ID id);
 363   bool inline_fp_min_max(vmIntrinsics::ID id);
 364 
 365   bool inline_profileBoolean();
 366   bool inline_isCompileConstant();
 367   void clear_upper_avx() {
 368 #ifdef X86
 369     if (UseAVX &gt;= 2) {
 370       C-&gt;set_clear_upper_avx(true);
 371     }
 372 #endif
 373   }
 374 };
 375 
 376 //---------------------------make_vm_intrinsic----------------------------
 377 CallGenerator* Compile::make_vm_intrinsic(ciMethod* m, bool is_virtual) {
 378   vmIntrinsics::ID id = m-&gt;intrinsic_id();
 379   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 380 
 381   if (!m-&gt;is_loaded()) {
 382     // Do not attempt to inline unloaded methods.
 383     return NULL;
 384   }
 385 
 386   C2Compiler* compiler = (C2Compiler*)CompileBroker::compiler(CompLevel_full_optimization);
 387   bool is_available = false;
 388 
 389   {
 390     // For calling is_intrinsic_supported and is_intrinsic_disabled_by_flag
 391     // the compiler must transition to &#39;_thread_in_vm&#39; state because both
 392     // methods access VM-internal data.
 393     VM_ENTRY_MARK;
 394     methodHandle mh(THREAD, m-&gt;get_Method());
 395     is_available = compiler != NULL &amp;&amp; compiler-&gt;is_intrinsic_supported(mh, is_virtual) &amp;&amp;
 396                    !C-&gt;directive()-&gt;is_intrinsic_disabled(mh) &amp;&amp;
 397                    !vmIntrinsics::is_disabled_by_flags(mh);
 398 
 399   }
 400 
 401   if (is_available) {
 402     assert(id &lt;= vmIntrinsics::LAST_COMPILER_INLINE, &quot;caller responsibility&quot;);
 403     assert(id != vmIntrinsics::_Object_init &amp;&amp; id != vmIntrinsics::_invoke, &quot;enum out of order?&quot;);
 404     return new LibraryIntrinsic(m, is_virtual,
 405                                 vmIntrinsics::predicates_needed(id),
 406                                 vmIntrinsics::does_virtual_dispatch(id),
 407                                 (vmIntrinsics::ID) id);
 408   } else {
 409     return NULL;
 410   }
 411 }
 412 
 413 //----------------------register_library_intrinsics-----------------------
 414 // Initialize this file&#39;s data structures, for each Compile instance.
 415 void Compile::register_library_intrinsics() {
 416   // Nothing to do here.
 417 }
 418 
 419 JVMState* LibraryIntrinsic::generate(JVMState* jvms) {
 420   LibraryCallKit kit(jvms, this);
 421   Compile* C = kit.C;
 422   int nodes = C-&gt;unique();
 423 #ifndef PRODUCT
 424   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
 425     char buf[1000];
 426     const char* str = vmIntrinsics::short_name_as_C_string(intrinsic_id(), buf, sizeof(buf));
 427     tty-&gt;print_cr(&quot;Intrinsic %s&quot;, str);
 428   }
 429 #endif
 430   ciMethod* callee = kit.callee();
 431   const int bci    = kit.bci();
 432 
 433   // Try to inline the intrinsic.
 434   if ((CheckIntrinsics ? callee-&gt;intrinsic_candidate() : true) &amp;&amp;
 435       kit.try_to_inline(_last_predicate)) {
 436     const char *inline_msg = is_virtual() ? &quot;(intrinsic, virtual)&quot;
 437                                           : &quot;(intrinsic)&quot;;
 438     CompileTask::print_inlining_ul(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 439     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 440       C-&gt;print_inlining(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 441     }
 442     C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_worked);
 443     if (C-&gt;log()) {
 444       C-&gt;log()-&gt;elem(&quot;intrinsic id=&#39;%s&#39;%s nodes=&#39;%d&#39;&quot;,
 445                      vmIntrinsics::name_at(intrinsic_id()),
 446                      (is_virtual() ? &quot; virtual=&#39;1&#39;&quot; : &quot;&quot;),
 447                      C-&gt;unique() - nodes);
 448     }
 449     // Push the result from the inlined method onto the stack.
 450     kit.push_result();
 451     C-&gt;print_inlining_update(this);
 452     return kit.transfer_exceptions_into_jvms();
 453   }
 454 
 455   // The intrinsic bailed out
 456   if (jvms-&gt;has_method()) {
 457     // Not a root compile.
 458     const char* msg;
 459     if (callee-&gt;intrinsic_candidate()) {
 460       msg = is_virtual() ? &quot;failed to inline (intrinsic, virtual)&quot; : &quot;failed to inline (intrinsic)&quot;;
 461     } else {
 462       msg = is_virtual() ? &quot;failed to inline (intrinsic, virtual), method not annotated&quot;
 463                          : &quot;failed to inline (intrinsic), method not annotated&quot;;
 464     }
 465     CompileTask::print_inlining_ul(callee, jvms-&gt;depth() - 1, bci, msg);
 466     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 467       C-&gt;print_inlining(callee, jvms-&gt;depth() - 1, bci, msg);
 468     }
 469   } else {
 470     // Root compile
 471     ResourceMark rm;
 472     stringStream msg_stream;
 473     msg_stream.print(&quot;Did not generate intrinsic %s%s at bci:%d in&quot;,
 474                      vmIntrinsics::name_at(intrinsic_id()),
 475                      is_virtual() ? &quot; (virtual)&quot; : &quot;&quot;, bci);
 476     const char *msg = msg_stream.as_string();
 477     log_debug(jit, inlining)(&quot;%s&quot;, msg);
 478     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 479       tty-&gt;print(&quot;%s&quot;, msg);
 480     }
 481   }
 482   C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_failed);
 483   C-&gt;print_inlining_update(this);
 484   return NULL;
 485 }
 486 
 487 Node* LibraryIntrinsic::generate_predicate(JVMState* jvms, int predicate) {
 488   LibraryCallKit kit(jvms, this);
 489   Compile* C = kit.C;
 490   int nodes = C-&gt;unique();
 491   _last_predicate = predicate;
 492 #ifndef PRODUCT
 493   assert(is_predicated() &amp;&amp; predicate &lt; predicates_count(), &quot;sanity&quot;);
 494   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
 495     char buf[1000];
 496     const char* str = vmIntrinsics::short_name_as_C_string(intrinsic_id(), buf, sizeof(buf));
 497     tty-&gt;print_cr(&quot;Predicate for intrinsic %s&quot;, str);
 498   }
 499 #endif
 500   ciMethod* callee = kit.callee();
 501   const int bci    = kit.bci();
 502 
 503   Node* slow_ctl = kit.try_to_predicate(predicate);
 504   if (!kit.failing()) {
 505     const char *inline_msg = is_virtual() ? &quot;(intrinsic, virtual, predicate)&quot;
 506                                           : &quot;(intrinsic, predicate)&quot;;
 507     CompileTask::print_inlining_ul(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 508     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 509       C-&gt;print_inlining(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 510     }
 511     C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_worked);
 512     if (C-&gt;log()) {
 513       C-&gt;log()-&gt;elem(&quot;predicate_intrinsic id=&#39;%s&#39;%s nodes=&#39;%d&#39;&quot;,
 514                      vmIntrinsics::name_at(intrinsic_id()),
 515                      (is_virtual() ? &quot; virtual=&#39;1&#39;&quot; : &quot;&quot;),
 516                      C-&gt;unique() - nodes);
 517     }
 518     return slow_ctl; // Could be NULL if the check folds.
 519   }
 520 
 521   // The intrinsic bailed out
 522   if (jvms-&gt;has_method()) {
 523     // Not a root compile.
 524     const char* msg = &quot;failed to generate predicate for intrinsic&quot;;
 525     CompileTask::print_inlining_ul(kit.callee(), jvms-&gt;depth() - 1, bci, msg);
 526     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 527       C-&gt;print_inlining(kit.callee(), jvms-&gt;depth() - 1, bci, msg);
 528     }
 529   } else {
 530     // Root compile
 531     ResourceMark rm;
 532     stringStream msg_stream;
 533     msg_stream.print(&quot;Did not generate intrinsic %s%s at bci:%d in&quot;,
 534                      vmIntrinsics::name_at(intrinsic_id()),
 535                      is_virtual() ? &quot; (virtual)&quot; : &quot;&quot;, bci);
 536     const char *msg = msg_stream.as_string();
 537     log_debug(jit, inlining)(&quot;%s&quot;, msg);
 538     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 539       C-&gt;print_inlining_stream()-&gt;print(&quot;%s&quot;, msg);
 540     }
 541   }
 542   C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_failed);
 543   return NULL;
 544 }
 545 
 546 bool LibraryCallKit::try_to_inline(int predicate) {
 547   // Handle symbolic names for otherwise undistinguished boolean switches:
 548   const bool is_store       = true;
 549   const bool is_compress    = true;
 550   const bool is_static      = true;
 551   const bool is_volatile    = true;
 552 
 553   if (!jvms()-&gt;has_method()) {
 554     // Root JVMState has a null method.
 555     assert(map()-&gt;memory()-&gt;Opcode() == Op_Parm, &quot;&quot;);
 556     // Insert the memory aliasing node
 557     set_all_memory(reset_memory());
 558   }
 559   assert(merged_memory(), &quot;&quot;);
 560 
 561 
 562   switch (intrinsic_id()) {
 563   case vmIntrinsics::_hashCode:                 return inline_native_hashcode(intrinsic()-&gt;is_virtual(), !is_static);
 564   case vmIntrinsics::_identityHashCode:         return inline_native_hashcode(/*!virtual*/ false,         is_static);
 565   case vmIntrinsics::_getClass:                 return inline_native_getClass();
 566 
 567   case vmIntrinsics::_ceil:
 568   case vmIntrinsics::_floor:
 569   case vmIntrinsics::_rint:
 570   case vmIntrinsics::_dsin:
 571   case vmIntrinsics::_dcos:
 572   case vmIntrinsics::_dtan:
 573   case vmIntrinsics::_dabs:
 574   case vmIntrinsics::_fabs:
 575   case vmIntrinsics::_iabs:
 576   case vmIntrinsics::_labs:
 577   case vmIntrinsics::_datan2:
 578   case vmIntrinsics::_dsqrt:
 579   case vmIntrinsics::_dexp:
 580   case vmIntrinsics::_dlog:
 581   case vmIntrinsics::_dlog10:
 582   case vmIntrinsics::_dpow:                     return inline_math_native(intrinsic_id());
 583 
 584   case vmIntrinsics::_min:
 585   case vmIntrinsics::_max:                      return inline_min_max(intrinsic_id());
 586 
 587   case vmIntrinsics::_notify:
 588   case vmIntrinsics::_notifyAll:
 589     return inline_notify(intrinsic_id());
 590 
 591   case vmIntrinsics::_addExactI:                return inline_math_addExactI(false /* add */);
 592   case vmIntrinsics::_addExactL:                return inline_math_addExactL(false /* add */);
 593   case vmIntrinsics::_decrementExactI:          return inline_math_subtractExactI(true /* decrement */);
 594   case vmIntrinsics::_decrementExactL:          return inline_math_subtractExactL(true /* decrement */);
 595   case vmIntrinsics::_incrementExactI:          return inline_math_addExactI(true /* increment */);
 596   case vmIntrinsics::_incrementExactL:          return inline_math_addExactL(true /* increment */);
 597   case vmIntrinsics::_multiplyExactI:           return inline_math_multiplyExactI();
 598   case vmIntrinsics::_multiplyExactL:           return inline_math_multiplyExactL();
 599   case vmIntrinsics::_multiplyHigh:             return inline_math_multiplyHigh();
 600   case vmIntrinsics::_negateExactI:             return inline_math_negateExactI();
 601   case vmIntrinsics::_negateExactL:             return inline_math_negateExactL();
 602   case vmIntrinsics::_subtractExactI:           return inline_math_subtractExactI(false /* subtract */);
 603   case vmIntrinsics::_subtractExactL:           return inline_math_subtractExactL(false /* subtract */);
 604 
 605   case vmIntrinsics::_arraycopy:                return inline_arraycopy();
 606 
 607   case vmIntrinsics::_compareToL:               return inline_string_compareTo(StrIntrinsicNode::LL);
 608   case vmIntrinsics::_compareToU:               return inline_string_compareTo(StrIntrinsicNode::UU);
 609   case vmIntrinsics::_compareToLU:              return inline_string_compareTo(StrIntrinsicNode::LU);
 610   case vmIntrinsics::_compareToUL:              return inline_string_compareTo(StrIntrinsicNode::UL);
 611 
 612   case vmIntrinsics::_indexOfL:                 return inline_string_indexOf(StrIntrinsicNode::LL);
 613   case vmIntrinsics::_indexOfU:                 return inline_string_indexOf(StrIntrinsicNode::UU);
 614   case vmIntrinsics::_indexOfUL:                return inline_string_indexOf(StrIntrinsicNode::UL);
 615   case vmIntrinsics::_indexOfIL:                return inline_string_indexOfI(StrIntrinsicNode::LL);
 616   case vmIntrinsics::_indexOfIU:                return inline_string_indexOfI(StrIntrinsicNode::UU);
 617   case vmIntrinsics::_indexOfIUL:               return inline_string_indexOfI(StrIntrinsicNode::UL);
 618   case vmIntrinsics::_indexOfU_char:            return inline_string_indexOfChar();
 619 
 620   case vmIntrinsics::_equalsL:                  return inline_string_equals(StrIntrinsicNode::LL);
 621   case vmIntrinsics::_equalsU:                  return inline_string_equals(StrIntrinsicNode::UU);
 622 
 623   case vmIntrinsics::_toBytesStringU:           return inline_string_toBytesU();
 624   case vmIntrinsics::_getCharsStringU:          return inline_string_getCharsU();
 625   case vmIntrinsics::_getCharStringU:           return inline_string_char_access(!is_store);
 626   case vmIntrinsics::_putCharStringU:           return inline_string_char_access( is_store);
 627 
 628   case vmIntrinsics::_compressStringC:
 629   case vmIntrinsics::_compressStringB:          return inline_string_copy( is_compress);
 630   case vmIntrinsics::_inflateStringC:
 631   case vmIntrinsics::_inflateStringB:           return inline_string_copy(!is_compress);
 632 
 633   case vmIntrinsics::_makePrivateBuffer:        return inline_unsafe_make_private_buffer();
 634   case vmIntrinsics::_finishPrivateBuffer:      return inline_unsafe_finish_private_buffer();
 635   case vmIntrinsics::_getReference:             return inline_unsafe_access(!is_store, T_OBJECT,   Relaxed, false);
 636   case vmIntrinsics::_getBoolean:               return inline_unsafe_access(!is_store, T_BOOLEAN,  Relaxed, false);
 637   case vmIntrinsics::_getByte:                  return inline_unsafe_access(!is_store, T_BYTE,     Relaxed, false);
 638   case vmIntrinsics::_getShort:                 return inline_unsafe_access(!is_store, T_SHORT,    Relaxed, false);
 639   case vmIntrinsics::_getChar:                  return inline_unsafe_access(!is_store, T_CHAR,     Relaxed, false);
 640   case vmIntrinsics::_getInt:                   return inline_unsafe_access(!is_store, T_INT,      Relaxed, false);
 641   case vmIntrinsics::_getLong:                  return inline_unsafe_access(!is_store, T_LONG,     Relaxed, false);
 642   case vmIntrinsics::_getFloat:                 return inline_unsafe_access(!is_store, T_FLOAT,    Relaxed, false);
 643   case vmIntrinsics::_getDouble:                return inline_unsafe_access(!is_store, T_DOUBLE,   Relaxed, false);
 644   case vmIntrinsics::_getValue:                 return inline_unsafe_access(!is_store, T_INLINE_TYPE,Relaxed, false);
 645 
 646   case vmIntrinsics::_putReference:             return inline_unsafe_access( is_store, T_OBJECT,   Relaxed, false);
 647   case vmIntrinsics::_putBoolean:               return inline_unsafe_access( is_store, T_BOOLEAN,  Relaxed, false);
 648   case vmIntrinsics::_putByte:                  return inline_unsafe_access( is_store, T_BYTE,     Relaxed, false);
 649   case vmIntrinsics::_putShort:                 return inline_unsafe_access( is_store, T_SHORT,    Relaxed, false);
 650   case vmIntrinsics::_putChar:                  return inline_unsafe_access( is_store, T_CHAR,     Relaxed, false);
 651   case vmIntrinsics::_putInt:                   return inline_unsafe_access( is_store, T_INT,      Relaxed, false);
 652   case vmIntrinsics::_putLong:                  return inline_unsafe_access( is_store, T_LONG,     Relaxed, false);
 653   case vmIntrinsics::_putFloat:                 return inline_unsafe_access( is_store, T_FLOAT,    Relaxed, false);
 654   case vmIntrinsics::_putDouble:                return inline_unsafe_access( is_store, T_DOUBLE,   Relaxed, false);
 655   case vmIntrinsics::_putValue:                 return inline_unsafe_access( is_store, T_INLINE_TYPE,Relaxed, false);
 656 
 657   case vmIntrinsics::_getReferenceVolatile:     return inline_unsafe_access(!is_store, T_OBJECT,   Volatile, false);
 658   case vmIntrinsics::_getBooleanVolatile:       return inline_unsafe_access(!is_store, T_BOOLEAN,  Volatile, false);
 659   case vmIntrinsics::_getByteVolatile:          return inline_unsafe_access(!is_store, T_BYTE,     Volatile, false);
 660   case vmIntrinsics::_getShortVolatile:         return inline_unsafe_access(!is_store, T_SHORT,    Volatile, false);
 661   case vmIntrinsics::_getCharVolatile:          return inline_unsafe_access(!is_store, T_CHAR,     Volatile, false);
 662   case vmIntrinsics::_getIntVolatile:           return inline_unsafe_access(!is_store, T_INT,      Volatile, false);
 663   case vmIntrinsics::_getLongVolatile:          return inline_unsafe_access(!is_store, T_LONG,     Volatile, false);
 664   case vmIntrinsics::_getFloatVolatile:         return inline_unsafe_access(!is_store, T_FLOAT,    Volatile, false);
 665   case vmIntrinsics::_getDoubleVolatile:        return inline_unsafe_access(!is_store, T_DOUBLE,   Volatile, false);
 666 
 667   case vmIntrinsics::_putReferenceVolatile:     return inline_unsafe_access( is_store, T_OBJECT,   Volatile, false);
 668   case vmIntrinsics::_putBooleanVolatile:       return inline_unsafe_access( is_store, T_BOOLEAN,  Volatile, false);
 669   case vmIntrinsics::_putByteVolatile:          return inline_unsafe_access( is_store, T_BYTE,     Volatile, false);
 670   case vmIntrinsics::_putShortVolatile:         return inline_unsafe_access( is_store, T_SHORT,    Volatile, false);
 671   case vmIntrinsics::_putCharVolatile:          return inline_unsafe_access( is_store, T_CHAR,     Volatile, false);
 672   case vmIntrinsics::_putIntVolatile:           return inline_unsafe_access( is_store, T_INT,      Volatile, false);
 673   case vmIntrinsics::_putLongVolatile:          return inline_unsafe_access( is_store, T_LONG,     Volatile, false);
 674   case vmIntrinsics::_putFloatVolatile:         return inline_unsafe_access( is_store, T_FLOAT,    Volatile, false);
 675   case vmIntrinsics::_putDoubleVolatile:        return inline_unsafe_access( is_store, T_DOUBLE,   Volatile, false);
 676 
 677   case vmIntrinsics::_getShortUnaligned:        return inline_unsafe_access(!is_store, T_SHORT,    Relaxed, true);
 678   case vmIntrinsics::_getCharUnaligned:         return inline_unsafe_access(!is_store, T_CHAR,     Relaxed, true);
 679   case vmIntrinsics::_getIntUnaligned:          return inline_unsafe_access(!is_store, T_INT,      Relaxed, true);
 680   case vmIntrinsics::_getLongUnaligned:         return inline_unsafe_access(!is_store, T_LONG,     Relaxed, true);
 681 
 682   case vmIntrinsics::_putShortUnaligned:        return inline_unsafe_access( is_store, T_SHORT,    Relaxed, true);
 683   case vmIntrinsics::_putCharUnaligned:         return inline_unsafe_access( is_store, T_CHAR,     Relaxed, true);
 684   case vmIntrinsics::_putIntUnaligned:          return inline_unsafe_access( is_store, T_INT,      Relaxed, true);
 685   case vmIntrinsics::_putLongUnaligned:         return inline_unsafe_access( is_store, T_LONG,     Relaxed, true);
 686 
 687   case vmIntrinsics::_getReferenceAcquire:      return inline_unsafe_access(!is_store, T_OBJECT,   Acquire, false);
 688   case vmIntrinsics::_getBooleanAcquire:        return inline_unsafe_access(!is_store, T_BOOLEAN,  Acquire, false);
 689   case vmIntrinsics::_getByteAcquire:           return inline_unsafe_access(!is_store, T_BYTE,     Acquire, false);
 690   case vmIntrinsics::_getShortAcquire:          return inline_unsafe_access(!is_store, T_SHORT,    Acquire, false);
 691   case vmIntrinsics::_getCharAcquire:           return inline_unsafe_access(!is_store, T_CHAR,     Acquire, false);
 692   case vmIntrinsics::_getIntAcquire:            return inline_unsafe_access(!is_store, T_INT,      Acquire, false);
 693   case vmIntrinsics::_getLongAcquire:           return inline_unsafe_access(!is_store, T_LONG,     Acquire, false);
 694   case vmIntrinsics::_getFloatAcquire:          return inline_unsafe_access(!is_store, T_FLOAT,    Acquire, false);
 695   case vmIntrinsics::_getDoubleAcquire:         return inline_unsafe_access(!is_store, T_DOUBLE,   Acquire, false);
 696 
 697   case vmIntrinsics::_putReferenceRelease:      return inline_unsafe_access( is_store, T_OBJECT,   Release, false);
 698   case vmIntrinsics::_putBooleanRelease:        return inline_unsafe_access( is_store, T_BOOLEAN,  Release, false);
 699   case vmIntrinsics::_putByteRelease:           return inline_unsafe_access( is_store, T_BYTE,     Release, false);
 700   case vmIntrinsics::_putShortRelease:          return inline_unsafe_access( is_store, T_SHORT,    Release, false);
 701   case vmIntrinsics::_putCharRelease:           return inline_unsafe_access( is_store, T_CHAR,     Release, false);
 702   case vmIntrinsics::_putIntRelease:            return inline_unsafe_access( is_store, T_INT,      Release, false);
 703   case vmIntrinsics::_putLongRelease:           return inline_unsafe_access( is_store, T_LONG,     Release, false);
 704   case vmIntrinsics::_putFloatRelease:          return inline_unsafe_access( is_store, T_FLOAT,    Release, false);
 705   case vmIntrinsics::_putDoubleRelease:         return inline_unsafe_access( is_store, T_DOUBLE,   Release, false);
 706 
 707   case vmIntrinsics::_getReferenceOpaque:       return inline_unsafe_access(!is_store, T_OBJECT,   Opaque, false);
 708   case vmIntrinsics::_getBooleanOpaque:         return inline_unsafe_access(!is_store, T_BOOLEAN,  Opaque, false);
 709   case vmIntrinsics::_getByteOpaque:            return inline_unsafe_access(!is_store, T_BYTE,     Opaque, false);
 710   case vmIntrinsics::_getShortOpaque:           return inline_unsafe_access(!is_store, T_SHORT,    Opaque, false);
 711   case vmIntrinsics::_getCharOpaque:            return inline_unsafe_access(!is_store, T_CHAR,     Opaque, false);
 712   case vmIntrinsics::_getIntOpaque:             return inline_unsafe_access(!is_store, T_INT,      Opaque, false);
 713   case vmIntrinsics::_getLongOpaque:            return inline_unsafe_access(!is_store, T_LONG,     Opaque, false);
 714   case vmIntrinsics::_getFloatOpaque:           return inline_unsafe_access(!is_store, T_FLOAT,    Opaque, false);
 715   case vmIntrinsics::_getDoubleOpaque:          return inline_unsafe_access(!is_store, T_DOUBLE,   Opaque, false);
 716 
 717   case vmIntrinsics::_putReferenceOpaque:       return inline_unsafe_access( is_store, T_OBJECT,   Opaque, false);
 718   case vmIntrinsics::_putBooleanOpaque:         return inline_unsafe_access( is_store, T_BOOLEAN,  Opaque, false);
 719   case vmIntrinsics::_putByteOpaque:            return inline_unsafe_access( is_store, T_BYTE,     Opaque, false);
 720   case vmIntrinsics::_putShortOpaque:           return inline_unsafe_access( is_store, T_SHORT,    Opaque, false);
 721   case vmIntrinsics::_putCharOpaque:            return inline_unsafe_access( is_store, T_CHAR,     Opaque, false);
 722   case vmIntrinsics::_putIntOpaque:             return inline_unsafe_access( is_store, T_INT,      Opaque, false);
 723   case vmIntrinsics::_putLongOpaque:            return inline_unsafe_access( is_store, T_LONG,     Opaque, false);
 724   case vmIntrinsics::_putFloatOpaque:           return inline_unsafe_access( is_store, T_FLOAT,    Opaque, false);
 725   case vmIntrinsics::_putDoubleOpaque:          return inline_unsafe_access( is_store, T_DOUBLE,   Opaque, false);
 726 
 727   case vmIntrinsics::_compareAndSetReference:   return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap,      Volatile);
 728   case vmIntrinsics::_compareAndSetByte:        return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap,      Volatile);
 729   case vmIntrinsics::_compareAndSetShort:       return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap,      Volatile);
 730   case vmIntrinsics::_compareAndSetInt:         return inline_unsafe_load_store(T_INT,    LS_cmp_swap,      Volatile);
 731   case vmIntrinsics::_compareAndSetLong:        return inline_unsafe_load_store(T_LONG,   LS_cmp_swap,      Volatile);
 732 
 733   case vmIntrinsics::_weakCompareAndSetReferencePlain:     return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Relaxed);
 734   case vmIntrinsics::_weakCompareAndSetReferenceAcquire:   return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Acquire);
 735   case vmIntrinsics::_weakCompareAndSetReferenceRelease:   return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Release);
 736   case vmIntrinsics::_weakCompareAndSetReference:          return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Volatile);
 737   case vmIntrinsics::_weakCompareAndSetBytePlain:          return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Relaxed);
 738   case vmIntrinsics::_weakCompareAndSetByteAcquire:        return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Acquire);
 739   case vmIntrinsics::_weakCompareAndSetByteRelease:        return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Release);
 740   case vmIntrinsics::_weakCompareAndSetByte:               return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Volatile);
 741   case vmIntrinsics::_weakCompareAndSetShortPlain:         return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Relaxed);
 742   case vmIntrinsics::_weakCompareAndSetShortAcquire:       return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Acquire);
 743   case vmIntrinsics::_weakCompareAndSetShortRelease:       return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Release);
 744   case vmIntrinsics::_weakCompareAndSetShort:              return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Volatile);
 745   case vmIntrinsics::_weakCompareAndSetIntPlain:           return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Relaxed);
 746   case vmIntrinsics::_weakCompareAndSetIntAcquire:         return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Acquire);
 747   case vmIntrinsics::_weakCompareAndSetIntRelease:         return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Release);
 748   case vmIntrinsics::_weakCompareAndSetInt:                return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Volatile);
 749   case vmIntrinsics::_weakCompareAndSetLongPlain:          return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Relaxed);
 750   case vmIntrinsics::_weakCompareAndSetLongAcquire:        return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Acquire);
 751   case vmIntrinsics::_weakCompareAndSetLongRelease:        return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Release);
 752   case vmIntrinsics::_weakCompareAndSetLong:               return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Volatile);
 753 
 754   case vmIntrinsics::_compareAndExchangeReference:         return inline_unsafe_load_store(T_OBJECT, LS_cmp_exchange,  Volatile);
 755   case vmIntrinsics::_compareAndExchangeReferenceAcquire:  return inline_unsafe_load_store(T_OBJECT, LS_cmp_exchange,  Acquire);
 756   case vmIntrinsics::_compareAndExchangeReferenceRelease:  return inline_unsafe_load_store(T_OBJECT, LS_cmp_exchange,  Release);
 757   case vmIntrinsics::_compareAndExchangeByte:              return inline_unsafe_load_store(T_BYTE,   LS_cmp_exchange,  Volatile);
 758   case vmIntrinsics::_compareAndExchangeByteAcquire:       return inline_unsafe_load_store(T_BYTE,   LS_cmp_exchange,  Acquire);
 759   case vmIntrinsics::_compareAndExchangeByteRelease:       return inline_unsafe_load_store(T_BYTE,   LS_cmp_exchange,  Release);
 760   case vmIntrinsics::_compareAndExchangeShort:             return inline_unsafe_load_store(T_SHORT,  LS_cmp_exchange,  Volatile);
 761   case vmIntrinsics::_compareAndExchangeShortAcquire:      return inline_unsafe_load_store(T_SHORT,  LS_cmp_exchange,  Acquire);
 762   case vmIntrinsics::_compareAndExchangeShortRelease:      return inline_unsafe_load_store(T_SHORT,  LS_cmp_exchange,  Release);
 763   case vmIntrinsics::_compareAndExchangeInt:               return inline_unsafe_load_store(T_INT,    LS_cmp_exchange,  Volatile);
 764   case vmIntrinsics::_compareAndExchangeIntAcquire:        return inline_unsafe_load_store(T_INT,    LS_cmp_exchange,  Acquire);
 765   case vmIntrinsics::_compareAndExchangeIntRelease:        return inline_unsafe_load_store(T_INT,    LS_cmp_exchange,  Release);
 766   case vmIntrinsics::_compareAndExchangeLong:              return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Volatile);
 767   case vmIntrinsics::_compareAndExchangeLongAcquire:       return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Acquire);
 768   case vmIntrinsics::_compareAndExchangeLongRelease:       return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Release);
 769 
 770   case vmIntrinsics::_getAndAddByte:                    return inline_unsafe_load_store(T_BYTE,   LS_get_add,       Volatile);
 771   case vmIntrinsics::_getAndAddShort:                   return inline_unsafe_load_store(T_SHORT,  LS_get_add,       Volatile);
 772   case vmIntrinsics::_getAndAddInt:                     return inline_unsafe_load_store(T_INT,    LS_get_add,       Volatile);
 773   case vmIntrinsics::_getAndAddLong:                    return inline_unsafe_load_store(T_LONG,   LS_get_add,       Volatile);
 774 
 775   case vmIntrinsics::_getAndSetByte:                    return inline_unsafe_load_store(T_BYTE,   LS_get_set,       Volatile);
 776   case vmIntrinsics::_getAndSetShort:                   return inline_unsafe_load_store(T_SHORT,  LS_get_set,       Volatile);
 777   case vmIntrinsics::_getAndSetInt:                     return inline_unsafe_load_store(T_INT,    LS_get_set,       Volatile);
 778   case vmIntrinsics::_getAndSetLong:                    return inline_unsafe_load_store(T_LONG,   LS_get_set,       Volatile);
 779   case vmIntrinsics::_getAndSetReference:               return inline_unsafe_load_store(T_OBJECT, LS_get_set,       Volatile);
 780 
 781   case vmIntrinsics::_loadFence:
 782   case vmIntrinsics::_storeFence:
 783   case vmIntrinsics::_fullFence:                return inline_unsafe_fence(intrinsic_id());
 784 
 785   case vmIntrinsics::_onSpinWait:               return inline_onspinwait();
 786 
 787   case vmIntrinsics::_currentThread:            return inline_native_currentThread();
 788 
 789 #ifdef JFR_HAVE_INTRINSICS
 790   case vmIntrinsics::_counterTime:              return inline_native_time_funcs(CAST_FROM_FN_PTR(address, JFR_TIME_FUNCTION), &quot;counterTime&quot;);
 791   case vmIntrinsics::_getClassId:               return inline_native_classID();
 792   case vmIntrinsics::_getEventWriter:           return inline_native_getEventWriter();
 793 #endif
 794   case vmIntrinsics::_currentTimeMillis:        return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeMillis), &quot;currentTimeMillis&quot;);
 795   case vmIntrinsics::_nanoTime:                 return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeNanos), &quot;nanoTime&quot;);
 796   case vmIntrinsics::_writeback0:               return inline_unsafe_writeback0();
 797   case vmIntrinsics::_writebackPreSync0:        return inline_unsafe_writebackSync0(true);
 798   case vmIntrinsics::_writebackPostSync0:       return inline_unsafe_writebackSync0(false);
 799   case vmIntrinsics::_allocateInstance:         return inline_unsafe_allocate();
 800   case vmIntrinsics::_copyMemory:               return inline_unsafe_copyMemory();
 801   case vmIntrinsics::_getLength:                return inline_native_getLength();
 802   case vmIntrinsics::_copyOf:                   return inline_array_copyOf(false);
 803   case vmIntrinsics::_copyOfRange:              return inline_array_copyOf(true);
 804   case vmIntrinsics::_equalsB:                  return inline_array_equals(StrIntrinsicNode::LL);
 805   case vmIntrinsics::_equalsC:                  return inline_array_equals(StrIntrinsicNode::UU);
 806   case vmIntrinsics::_Preconditions_checkIndex: return inline_preconditions_checkIndex();
 807   case vmIntrinsics::_clone:                    return inline_native_clone(intrinsic()-&gt;is_virtual());
 808 
 809   case vmIntrinsics::_allocateUninitializedArray: return inline_unsafe_newArray(true);
 810   case vmIntrinsics::_newArray:                   return inline_unsafe_newArray(false);
 811 
 812   case vmIntrinsics::_isAssignableFrom:         return inline_native_subtype_check();
 813 
 814   case vmIntrinsics::_isInstance:
 815   case vmIntrinsics::_getModifiers:
 816   case vmIntrinsics::_isInterface:
 817   case vmIntrinsics::_isArray:
 818   case vmIntrinsics::_isPrimitive:
 819   case vmIntrinsics::_isHidden:
 820   case vmIntrinsics::_getSuperclass:
 821   case vmIntrinsics::_getClassAccessFlags:      return inline_native_Class_query(intrinsic_id());
 822 
 823   case vmIntrinsics::_floatToRawIntBits:
 824   case vmIntrinsics::_floatToIntBits:
 825   case vmIntrinsics::_intBitsToFloat:
 826   case vmIntrinsics::_doubleToRawLongBits:
 827   case vmIntrinsics::_doubleToLongBits:
 828   case vmIntrinsics::_longBitsToDouble:         return inline_fp_conversions(intrinsic_id());
 829 
 830   case vmIntrinsics::_numberOfLeadingZeros_i:
 831   case vmIntrinsics::_numberOfLeadingZeros_l:
 832   case vmIntrinsics::_numberOfTrailingZeros_i:
 833   case vmIntrinsics::_numberOfTrailingZeros_l:
 834   case vmIntrinsics::_bitCount_i:
 835   case vmIntrinsics::_bitCount_l:
 836   case vmIntrinsics::_reverseBytes_i:
 837   case vmIntrinsics::_reverseBytes_l:
 838   case vmIntrinsics::_reverseBytes_s:
 839   case vmIntrinsics::_reverseBytes_c:           return inline_number_methods(intrinsic_id());
 840 
 841   case vmIntrinsics::_getCallerClass:           return inline_native_Reflection_getCallerClass();
 842 
 843   case vmIntrinsics::_Reference_get:            return inline_reference_get();
 844 
 845   case vmIntrinsics::_Class_cast:               return inline_Class_cast();
 846 
 847   case vmIntrinsics::_aescrypt_encryptBlock:
 848   case vmIntrinsics::_aescrypt_decryptBlock:    return inline_aescrypt_Block(intrinsic_id());
 849 
 850   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 851   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 852     return inline_cipherBlockChaining_AESCrypt(intrinsic_id());
 853 
 854   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
 855   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
 856     return inline_electronicCodeBook_AESCrypt(intrinsic_id());
 857 
 858   case vmIntrinsics::_counterMode_AESCrypt:
 859     return inline_counterMode_AESCrypt(intrinsic_id());
 860 
 861   case vmIntrinsics::_sha_implCompress:
 862   case vmIntrinsics::_sha2_implCompress:
 863   case vmIntrinsics::_sha5_implCompress:
 864     return inline_sha_implCompress(intrinsic_id());
 865 
 866   case vmIntrinsics::_digestBase_implCompressMB:
 867     return inline_digestBase_implCompressMB(predicate);
 868 
 869   case vmIntrinsics::_multiplyToLen:
 870     return inline_multiplyToLen();
 871 
 872   case vmIntrinsics::_squareToLen:
 873     return inline_squareToLen();
 874 
 875   case vmIntrinsics::_mulAdd:
 876     return inline_mulAdd();
 877 
 878   case vmIntrinsics::_montgomeryMultiply:
 879     return inline_montgomeryMultiply();
 880   case vmIntrinsics::_montgomerySquare:
 881     return inline_montgomerySquare();
 882 
 883   case vmIntrinsics::_bigIntegerRightShiftWorker:
 884     return inline_bigIntegerShift(true);
 885   case vmIntrinsics::_bigIntegerLeftShiftWorker:
 886     return inline_bigIntegerShift(false);
 887 
 888   case vmIntrinsics::_vectorizedMismatch:
 889     return inline_vectorizedMismatch();
 890 
 891   case vmIntrinsics::_ghash_processBlocks:
 892     return inline_ghash_processBlocks();
 893   case vmIntrinsics::_base64_encodeBlock:
 894     return inline_base64_encodeBlock();
 895 
 896   case vmIntrinsics::_encodeISOArray:
 897   case vmIntrinsics::_encodeByteISOArray:
 898     return inline_encodeISOArray();
 899 
 900   case vmIntrinsics::_updateCRC32:
 901     return inline_updateCRC32();
 902   case vmIntrinsics::_updateBytesCRC32:
 903     return inline_updateBytesCRC32();
 904   case vmIntrinsics::_updateByteBufferCRC32:
 905     return inline_updateByteBufferCRC32();
 906 
 907   case vmIntrinsics::_updateBytesCRC32C:
 908     return inline_updateBytesCRC32C();
 909   case vmIntrinsics::_updateDirectByteBufferCRC32C:
 910     return inline_updateDirectByteBufferCRC32C();
 911 
 912   case vmIntrinsics::_updateBytesAdler32:
 913     return inline_updateBytesAdler32();
 914   case vmIntrinsics::_updateByteBufferAdler32:
 915     return inline_updateByteBufferAdler32();
 916 
 917   case vmIntrinsics::_profileBoolean:
 918     return inline_profileBoolean();
 919   case vmIntrinsics::_isCompileConstant:
 920     return inline_isCompileConstant();
 921 
 922   case vmIntrinsics::_hasNegatives:
 923     return inline_hasNegatives();
 924 
 925   case vmIntrinsics::_fmaD:
 926   case vmIntrinsics::_fmaF:
 927     return inline_fma(intrinsic_id());
 928 
 929   case vmIntrinsics::_isDigit:
 930   case vmIntrinsics::_isLowerCase:
 931   case vmIntrinsics::_isUpperCase:
 932   case vmIntrinsics::_isWhitespace:
 933     return inline_character_compare(intrinsic_id());
 934 
 935   case vmIntrinsics::_maxF:
 936   case vmIntrinsics::_minF:
 937   case vmIntrinsics::_maxD:
 938   case vmIntrinsics::_minD:
 939     return inline_fp_min_max(intrinsic_id());
 940 
 941   default:
 942     // If you get here, it may be that someone has added a new intrinsic
 943     // to the list in vmSymbols.hpp without implementing it here.
 944 #ifndef PRODUCT
 945     if ((PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) || PrintOpto) {
 946       tty-&gt;print_cr(&quot;*** Warning: Unimplemented intrinsic %s(%d)&quot;,
 947                     vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());
 948     }
 949 #endif
 950     return false;
 951   }
 952 }
 953 
 954 Node* LibraryCallKit::try_to_predicate(int predicate) {
 955   if (!jvms()-&gt;has_method()) {
 956     // Root JVMState has a null method.
 957     assert(map()-&gt;memory()-&gt;Opcode() == Op_Parm, &quot;&quot;);
 958     // Insert the memory aliasing node
 959     set_all_memory(reset_memory());
 960   }
 961   assert(merged_memory(), &quot;&quot;);
 962 
 963   switch (intrinsic_id()) {
 964   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 965     return inline_cipherBlockChaining_AESCrypt_predicate(false);
 966   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 967     return inline_cipherBlockChaining_AESCrypt_predicate(true);
 968   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
 969     return inline_electronicCodeBook_AESCrypt_predicate(false);
 970   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
 971     return inline_electronicCodeBook_AESCrypt_predicate(true);
 972   case vmIntrinsics::_counterMode_AESCrypt:
 973     return inline_counterMode_AESCrypt_predicate();
 974   case vmIntrinsics::_digestBase_implCompressMB:
 975     return inline_digestBase_implCompressMB_predicate(predicate);
 976 
 977   default:
 978     // If you get here, it may be that someone has added a new intrinsic
 979     // to the list in vmSymbols.hpp without implementing it here.
 980 #ifndef PRODUCT
 981     if ((PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) || PrintOpto) {
 982       tty-&gt;print_cr(&quot;*** Warning: Unimplemented predicate for intrinsic %s(%d)&quot;,
 983                     vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());
 984     }
 985 #endif
 986     Node* slow_ctl = control();
 987     set_control(top()); // No fast path instrinsic
 988     return slow_ctl;
 989   }
 990 }
 991 
 992 //------------------------------set_result-------------------------------
 993 // Helper function for finishing intrinsics.
 994 void LibraryCallKit::set_result(RegionNode* region, PhiNode* value) {
 995   record_for_igvn(region);
 996   set_control(_gvn.transform(region));
 997   set_result( _gvn.transform(value));
 998   assert(value-&gt;type()-&gt;basic_type() == result()-&gt;bottom_type()-&gt;basic_type(), &quot;sanity&quot;);
 999 }
1000 
1001 //------------------------------generate_guard---------------------------
1002 // Helper function for generating guarded fast-slow graph structures.
1003 // The given &#39;test&#39;, if true, guards a slow path.  If the test fails
1004 // then a fast path can be taken.  (We generally hope it fails.)
1005 // In all cases, GraphKit::control() is updated to the fast path.
1006 // The returned value represents the control for the slow path.
1007 // The return value is never &#39;top&#39;; it is either a valid control
1008 // or NULL if it is obvious that the slow path can never be taken.
1009 // Also, if region and the slow control are not NULL, the slow edge
1010 // is appended to the region.
1011 Node* LibraryCallKit::generate_guard(Node* test, RegionNode* region, float true_prob) {
1012   if (stopped()) {
1013     // Already short circuited.
1014     return NULL;
1015   }
1016 
1017   // Build an if node and its projections.
1018   // If test is true we take the slow path, which we assume is uncommon.
1019   if (_gvn.type(test) == TypeInt::ZERO) {
1020     // The slow branch is never taken.  No need to build this guard.
1021     return NULL;
1022   }
1023 
1024   IfNode* iff = create_and_map_if(control(), test, true_prob, COUNT_UNKNOWN);
1025 
1026   Node* if_slow = _gvn.transform(new IfTrueNode(iff));
1027   if (if_slow == top()) {
1028     // The slow branch is never taken.  No need to build this guard.
1029     return NULL;
1030   }
1031 
1032   if (region != NULL)
1033     region-&gt;add_req(if_slow);
1034 
1035   Node* if_fast = _gvn.transform(new IfFalseNode(iff));
1036   set_control(if_fast);
1037 
1038   return if_slow;
1039 }
1040 
1041 inline Node* LibraryCallKit::generate_slow_guard(Node* test, RegionNode* region) {
1042   return generate_guard(test, region, PROB_UNLIKELY_MAG(3));
1043 }
1044 inline Node* LibraryCallKit::generate_fair_guard(Node* test, RegionNode* region) {
1045   return generate_guard(test, region, PROB_FAIR);
1046 }
1047 
1048 inline Node* LibraryCallKit::generate_negative_guard(Node* index, RegionNode* region,
1049                                                      Node* *pos_index) {
1050   if (stopped())
1051     return NULL;                // already stopped
1052   if (_gvn.type(index)-&gt;higher_equal(TypeInt::POS)) // [0,maxint]
1053     return NULL;                // index is already adequately typed
1054   Node* cmp_lt = _gvn.transform(new CmpINode(index, intcon(0)));
1055   Node* bol_lt = _gvn.transform(new BoolNode(cmp_lt, BoolTest::lt));
1056   Node* is_neg = generate_guard(bol_lt, region, PROB_MIN);
1057   if (is_neg != NULL &amp;&amp; pos_index != NULL) {
1058     // Emulate effect of Parse::adjust_map_after_if.
1059     Node* ccast = new CastIINode(index, TypeInt::POS);
1060     ccast-&gt;set_req(0, control());
1061     (*pos_index) = _gvn.transform(ccast);
1062   }
1063   return is_neg;
1064 }
1065 
1066 // Make sure that &#39;position&#39; is a valid limit index, in [0..length].
1067 // There are two equivalent plans for checking this:
1068 //   A. (offset + copyLength)  unsigned&lt;=  arrayLength
1069 //   B. offset  &lt;=  (arrayLength - copyLength)
1070 // We require that all of the values above, except for the sum and
1071 // difference, are already known to be non-negative.
1072 // Plan A is robust in the face of overflow, if offset and copyLength
1073 // are both hugely positive.
1074 //
1075 // Plan B is less direct and intuitive, but it does not overflow at
1076 // all, since the difference of two non-negatives is always
1077 // representable.  Whenever Java methods must perform the equivalent
1078 // check they generally use Plan B instead of Plan A.
1079 // For the moment we use Plan A.
1080 inline Node* LibraryCallKit::generate_limit_guard(Node* offset,
1081                                                   Node* subseq_length,
1082                                                   Node* array_length,
1083                                                   RegionNode* region) {
1084   if (stopped())
1085     return NULL;                // already stopped
1086   bool zero_offset = _gvn.type(offset) == TypeInt::ZERO;
1087   if (zero_offset &amp;&amp; subseq_length-&gt;eqv_uncast(array_length))
1088     return NULL;                // common case of whole-array copy
1089   Node* last = subseq_length;
1090   if (!zero_offset)             // last += offset
1091     last = _gvn.transform(new AddINode(last, offset));
1092   Node* cmp_lt = _gvn.transform(new CmpUNode(array_length, last));
1093   Node* bol_lt = _gvn.transform(new BoolNode(cmp_lt, BoolTest::lt));
1094   Node* is_over = generate_guard(bol_lt, region, PROB_MIN);
1095   return is_over;
1096 }
1097 
1098 // Emit range checks for the given String.value byte array
1099 void LibraryCallKit::generate_string_range_check(Node* array, Node* offset, Node* count, bool char_count) {
1100   if (stopped()) {
1101     return; // already stopped
1102   }
1103   RegionNode* bailout = new RegionNode(1);
1104   record_for_igvn(bailout);
1105   if (char_count) {
1106     // Convert char count to byte count
1107     count = _gvn.transform(new LShiftINode(count, intcon(1)));
1108   }
1109 
1110   // Offset and count must not be negative
1111   generate_negative_guard(offset, bailout);
1112   generate_negative_guard(count, bailout);
1113   // Offset + count must not exceed length of array
1114   generate_limit_guard(offset, count, load_array_length(array), bailout);
1115 
1116   if (bailout-&gt;req() &gt; 1) {
1117     PreserveJVMState pjvms(this);
1118     set_control(_gvn.transform(bailout));
1119     uncommon_trap(Deoptimization::Reason_intrinsic,
1120                   Deoptimization::Action_maybe_recompile);
1121   }
1122 }
1123 
1124 //--------------------------generate_current_thread--------------------
1125 Node* LibraryCallKit::generate_current_thread(Node* &amp;tls_output) {
1126   ciKlass*    thread_klass = env()-&gt;Thread_klass();
1127   const Type* thread_type  = TypeOopPtr::make_from_klass(thread_klass)-&gt;cast_to_ptr_type(TypePtr::NotNull);
1128   Node* thread = _gvn.transform(new ThreadLocalNode());
1129   Node* p = basic_plus_adr(top()/*!oop*/, thread, in_bytes(JavaThread::threadObj_offset()));
1130   Node* threadObj = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p-&gt;bottom_type()-&gt;is_ptr(), thread_type, T_OBJECT, MemNode::unordered));
1131   tls_output = thread;
1132   return threadObj;
1133 }
1134 
1135 
1136 //------------------------------make_string_method_node------------------------
1137 // Helper method for String intrinsic functions. This version is called with
1138 // str1 and str2 pointing to byte[] nodes containing Latin1 or UTF16 encoded
1139 // characters (depending on &#39;is_byte&#39;). cnt1 and cnt2 are pointing to Int nodes
1140 // containing the lengths of str1 and str2.
1141 Node* LibraryCallKit::make_string_method_node(int opcode, Node* str1_start, Node* cnt1, Node* str2_start, Node* cnt2, StrIntrinsicNode::ArgEnc ae) {
1142   Node* result = NULL;
1143   switch (opcode) {
1144   case Op_StrIndexOf:
1145     result = new StrIndexOfNode(control(), memory(TypeAryPtr::BYTES),
1146                                 str1_start, cnt1, str2_start, cnt2, ae);
1147     break;
1148   case Op_StrComp:
1149     result = new StrCompNode(control(), memory(TypeAryPtr::BYTES),
1150                              str1_start, cnt1, str2_start, cnt2, ae);
1151     break;
1152   case Op_StrEquals:
1153     // We already know that cnt1 == cnt2 here (checked in &#39;inline_string_equals&#39;).
1154     // Use the constant length if there is one because optimized match rule may exist.
1155     result = new StrEqualsNode(control(), memory(TypeAryPtr::BYTES),
1156                                str1_start, str2_start, cnt2-&gt;is_Con() ? cnt2 : cnt1, ae);
1157     break;
1158   default:
1159     ShouldNotReachHere();
1160     return NULL;
1161   }
1162 
1163   // All these intrinsics have checks.
1164   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1165   clear_upper_avx();
1166 
1167   return _gvn.transform(result);
1168 }
1169 
1170 //------------------------------inline_string_compareTo------------------------
1171 bool LibraryCallKit::inline_string_compareTo(StrIntrinsicNode::ArgEnc ae) {
1172   Node* arg1 = argument(0);
1173   Node* arg2 = argument(1);
1174 
1175   arg1 = must_be_not_null(arg1, true);
1176   arg2 = must_be_not_null(arg2, true);
1177 
1178   // Get start addr and length of first argument
1179   Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
1180   Node* arg1_cnt    = load_array_length(arg1);
1181 
1182   // Get start addr and length of second argument
1183   Node* arg2_start  = array_element_address(arg2, intcon(0), T_BYTE);
1184   Node* arg2_cnt    = load_array_length(arg2);
1185 
1186   Node* result = make_string_method_node(Op_StrComp, arg1_start, arg1_cnt, arg2_start, arg2_cnt, ae);
1187   set_result(result);
1188   return true;
1189 }
1190 
1191 //------------------------------inline_string_equals------------------------
1192 bool LibraryCallKit::inline_string_equals(StrIntrinsicNode::ArgEnc ae) {
1193   Node* arg1 = argument(0);
1194   Node* arg2 = argument(1);
1195 
1196   // paths (plus control) merge
1197   RegionNode* region = new RegionNode(3);
1198   Node* phi = new PhiNode(region, TypeInt::BOOL);
1199 
1200   if (!stopped()) {
1201 
1202     arg1 = must_be_not_null(arg1, true);
1203     arg2 = must_be_not_null(arg2, true);
1204 
1205     // Get start addr and length of first argument
1206     Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
1207     Node* arg1_cnt    = load_array_length(arg1);
1208 
1209     // Get start addr and length of second argument
1210     Node* arg2_start  = array_element_address(arg2, intcon(0), T_BYTE);
1211     Node* arg2_cnt    = load_array_length(arg2);
1212 
1213     // Check for arg1_cnt != arg2_cnt
1214     Node* cmp = _gvn.transform(new CmpINode(arg1_cnt, arg2_cnt));
1215     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
1216     Node* if_ne = generate_slow_guard(bol, NULL);
1217     if (if_ne != NULL) {
1218       phi-&gt;init_req(2, intcon(0));
1219       region-&gt;init_req(2, if_ne);
1220     }
1221 
1222     // Check for count == 0 is done by assembler code for StrEquals.
1223 
1224     if (!stopped()) {
1225       Node* equals = make_string_method_node(Op_StrEquals, arg1_start, arg1_cnt, arg2_start, arg2_cnt, ae);
1226       phi-&gt;init_req(1, equals);
1227       region-&gt;init_req(1, control());
1228     }
1229   }
1230 
1231   // post merge
1232   set_control(_gvn.transform(region));
1233   record_for_igvn(region);
1234 
1235   set_result(_gvn.transform(phi));
1236   return true;
1237 }
1238 
1239 //------------------------------inline_array_equals----------------------------
1240 bool LibraryCallKit::inline_array_equals(StrIntrinsicNode::ArgEnc ae) {
1241   assert(ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::LL, &quot;unsupported array types&quot;);
1242   Node* arg1 = argument(0);
1243   Node* arg2 = argument(1);
1244 
1245   const TypeAryPtr* mtype = (ae == StrIntrinsicNode::UU) ? TypeAryPtr::CHARS : TypeAryPtr::BYTES;
1246   set_result(_gvn.transform(new AryEqNode(control(), memory(mtype), arg1, arg2, ae)));
1247   clear_upper_avx();
1248 
1249   return true;
1250 }
1251 
1252 //------------------------------inline_hasNegatives------------------------------
1253 bool LibraryCallKit::inline_hasNegatives() {
1254   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1255     return false;
1256   }
1257 
1258   assert(callee()-&gt;signature()-&gt;size() == 3, &quot;hasNegatives has 3 parameters&quot;);
1259   // no receiver since it is static method
1260   Node* ba         = argument(0);
1261   Node* offset     = argument(1);
1262   Node* len        = argument(2);
1263 
1264   ba = must_be_not_null(ba, true);
1265 
1266   // Range checks
1267   generate_string_range_check(ba, offset, len, false);
1268   if (stopped()) {
1269     return true;
1270   }
1271   Node* ba_start = array_element_address(ba, offset, T_BYTE);
1272   Node* result = new HasNegativesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);
1273   set_result(_gvn.transform(result));
1274   return true;
1275 }
1276 
1277 bool LibraryCallKit::inline_preconditions_checkIndex() {
1278   Node* index = argument(0);
1279   Node* length = argument(1);
1280   if (too_many_traps(Deoptimization::Reason_intrinsic) || too_many_traps(Deoptimization::Reason_range_check)) {
1281     return false;
1282   }
1283 
1284   Node* len_pos_cmp = _gvn.transform(new CmpINode(length, intcon(0)));
1285   Node* len_pos_bol = _gvn.transform(new BoolNode(len_pos_cmp, BoolTest::ge));
1286 
1287   {
1288     BuildCutout unless(this, len_pos_bol, PROB_MAX);
1289     uncommon_trap(Deoptimization::Reason_intrinsic,
1290                   Deoptimization::Action_make_not_entrant);
1291   }
1292 
1293   if (stopped()) {
1294     return false;
1295   }
1296 
1297   Node* rc_cmp = _gvn.transform(new CmpUNode(index, length));
1298   BoolTest::mask btest = BoolTest::lt;
1299   Node* rc_bool = _gvn.transform(new BoolNode(rc_cmp, btest));
1300   RangeCheckNode* rc = new RangeCheckNode(control(), rc_bool, PROB_MAX, COUNT_UNKNOWN);
1301   _gvn.set_type(rc, rc-&gt;Value(&amp;_gvn));
1302   if (!rc_bool-&gt;is_Con()) {
1303     record_for_igvn(rc);
1304   }
1305   set_control(_gvn.transform(new IfTrueNode(rc)));
1306   {
1307     PreserveJVMState pjvms(this);
1308     set_control(_gvn.transform(new IfFalseNode(rc)));
1309     uncommon_trap(Deoptimization::Reason_range_check,
1310                   Deoptimization::Action_make_not_entrant);
1311   }
1312 
1313   if (stopped()) {
1314     return false;
1315   }
1316 
1317   Node* result = new CastIINode(index, TypeInt::make(0, _gvn.type(length)-&gt;is_int()-&gt;_hi, Type::WidenMax));
1318   result-&gt;set_req(0, control());
1319   result = _gvn.transform(result);
1320   set_result(result);
1321   replace_in_map(index, result);
1322   clear_upper_avx();
1323   return true;
1324 }
1325 
1326 //------------------------------inline_string_indexOf------------------------
1327 bool LibraryCallKit::inline_string_indexOf(StrIntrinsicNode::ArgEnc ae) {
1328   if (!Matcher::match_rule_supported(Op_StrIndexOf)) {
1329     return false;
1330   }
1331   Node* src = argument(0);
1332   Node* tgt = argument(1);
1333 
1334   // Make the merge point
1335   RegionNode* result_rgn = new RegionNode(4);
1336   Node*       result_phi = new PhiNode(result_rgn, TypeInt::INT);
1337 
1338   src = must_be_not_null(src, true);
1339   tgt = must_be_not_null(tgt, true);
1340 
1341   // Get start addr and length of source string
1342   Node* src_start = array_element_address(src, intcon(0), T_BYTE);
1343   Node* src_count = load_array_length(src);
1344 
1345   // Get start addr and length of substring
1346   Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
1347   Node* tgt_count = load_array_length(tgt);
1348 
1349   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {
1350     // Divide src size by 2 if String is UTF16 encoded
1351     src_count = _gvn.transform(new RShiftINode(src_count, intcon(1)));
1352   }
1353   if (ae == StrIntrinsicNode::UU) {
1354     // Divide substring size by 2 if String is UTF16 encoded
1355     tgt_count = _gvn.transform(new RShiftINode(tgt_count, intcon(1)));
1356   }
1357 
1358   Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, result_rgn, result_phi, ae);
1359   if (result != NULL) {
1360     result_phi-&gt;init_req(3, result);
1361     result_rgn-&gt;init_req(3, control());
1362   }
1363   set_control(_gvn.transform(result_rgn));
1364   record_for_igvn(result_rgn);
1365   set_result(_gvn.transform(result_phi));
1366 
1367   return true;
1368 }
1369 
1370 //-----------------------------inline_string_indexOf-----------------------
1371 bool LibraryCallKit::inline_string_indexOfI(StrIntrinsicNode::ArgEnc ae) {
1372   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1373     return false;
1374   }
1375   if (!Matcher::match_rule_supported(Op_StrIndexOf)) {
1376     return false;
1377   }
1378   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;String.indexOf() has 5 arguments&quot;);
1379   Node* src         = argument(0); // byte[]
1380   Node* src_count   = argument(1); // char count
1381   Node* tgt         = argument(2); // byte[]
1382   Node* tgt_count   = argument(3); // char count
1383   Node* from_index  = argument(4); // char index
1384 
1385   src = must_be_not_null(src, true);
1386   tgt = must_be_not_null(tgt, true);
1387 
1388   // Multiply byte array index by 2 if String is UTF16 encoded
1389   Node* src_offset = (ae == StrIntrinsicNode::LL) ? from_index : _gvn.transform(new LShiftINode(from_index, intcon(1)));
1390   src_count = _gvn.transform(new SubINode(src_count, from_index));
1391   Node* src_start = array_element_address(src, src_offset, T_BYTE);
1392   Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
1393 
1394   // Range checks
1395   generate_string_range_check(src, src_offset, src_count, ae != StrIntrinsicNode::LL);
1396   generate_string_range_check(tgt, intcon(0), tgt_count, ae == StrIntrinsicNode::UU);
1397   if (stopped()) {
1398     return true;
1399   }
1400 
1401   RegionNode* region = new RegionNode(5);
1402   Node* phi = new PhiNode(region, TypeInt::INT);
1403 
1404   Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, region, phi, ae);
1405   if (result != NULL) {
1406     // The result is index relative to from_index if substring was found, -1 otherwise.
1407     // Generate code which will fold into cmove.
1408     Node* cmp = _gvn.transform(new CmpINode(result, intcon(0)));
1409     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::lt));
1410 
1411     Node* if_lt = generate_slow_guard(bol, NULL);
1412     if (if_lt != NULL) {
1413       // result == -1
1414       phi-&gt;init_req(3, result);
1415       region-&gt;init_req(3, if_lt);
1416     }
1417     if (!stopped()) {
1418       result = _gvn.transform(new AddINode(result, from_index));
1419       phi-&gt;init_req(4, result);
1420       region-&gt;init_req(4, control());
1421     }
1422   }
1423 
1424   set_control(_gvn.transform(region));
1425   record_for_igvn(region);
1426   set_result(_gvn.transform(phi));
1427   clear_upper_avx();
1428 
1429   return true;
1430 }
1431 
1432 // Create StrIndexOfNode with fast path checks
1433 Node* LibraryCallKit::make_indexOf_node(Node* src_start, Node* src_count, Node* tgt_start, Node* tgt_count,
1434                                         RegionNode* region, Node* phi, StrIntrinsicNode::ArgEnc ae) {
1435   // Check for substr count &gt; string count
1436   Node* cmp = _gvn.transform(new CmpINode(tgt_count, src_count));
1437   Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::gt));
1438   Node* if_gt = generate_slow_guard(bol, NULL);
1439   if (if_gt != NULL) {
1440     phi-&gt;init_req(1, intcon(-1));
1441     region-&gt;init_req(1, if_gt);
1442   }
1443   if (!stopped()) {
1444     // Check for substr count == 0
1445     cmp = _gvn.transform(new CmpINode(tgt_count, intcon(0)));
1446     bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));
1447     Node* if_zero = generate_slow_guard(bol, NULL);
1448     if (if_zero != NULL) {
1449       phi-&gt;init_req(2, intcon(0));
1450       region-&gt;init_req(2, if_zero);
1451     }
1452   }
1453   if (!stopped()) {
1454     return make_string_method_node(Op_StrIndexOf, src_start, src_count, tgt_start, tgt_count, ae);
1455   }
1456   return NULL;
1457 }
1458 
1459 //-----------------------------inline_string_indexOfChar-----------------------
1460 bool LibraryCallKit::inline_string_indexOfChar() {
1461   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1462     return false;
1463   }
1464   if (!Matcher::match_rule_supported(Op_StrIndexOfChar)) {
1465     return false;
1466   }
1467   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;String.indexOfChar() has 4 arguments&quot;);
1468   Node* src         = argument(0); // byte[]
1469   Node* tgt         = argument(1); // tgt is int ch
1470   Node* from_index  = argument(2);
1471   Node* max         = argument(3);
1472 
1473   src = must_be_not_null(src, true);
1474 
1475   Node* src_offset = _gvn.transform(new LShiftINode(from_index, intcon(1)));
1476   Node* src_start = array_element_address(src, src_offset, T_BYTE);
1477   Node* src_count = _gvn.transform(new SubINode(max, from_index));
1478 
1479   // Range checks
1480   generate_string_range_check(src, src_offset, src_count, true);
1481   if (stopped()) {
1482     return true;
1483   }
1484 
1485   RegionNode* region = new RegionNode(3);
1486   Node* phi = new PhiNode(region, TypeInt::INT);
1487 
1488   Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, tgt, StrIntrinsicNode::none);
1489   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1490   _gvn.transform(result);
1491 
1492   Node* cmp = _gvn.transform(new CmpINode(result, intcon(0)));
1493   Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::lt));
1494 
1495   Node* if_lt = generate_slow_guard(bol, NULL);
1496   if (if_lt != NULL) {
1497     // result == -1
1498     phi-&gt;init_req(2, result);
1499     region-&gt;init_req(2, if_lt);
1500   }
1501   if (!stopped()) {
1502     result = _gvn.transform(new AddINode(result, from_index));
1503     phi-&gt;init_req(1, result);
1504     region-&gt;init_req(1, control());
1505   }
1506   set_control(_gvn.transform(region));
1507   record_for_igvn(region);
1508   set_result(_gvn.transform(phi));
1509 
1510   return true;
1511 }
1512 //---------------------------inline_string_copy---------------------
1513 // compressIt == true --&gt; generate a compressed copy operation (compress char[]/byte[] to byte[])
1514 //   int StringUTF16.compress(char[] src, int srcOff, byte[] dst, int dstOff, int len)
1515 //   int StringUTF16.compress(byte[] src, int srcOff, byte[] dst, int dstOff, int len)
1516 // compressIt == false --&gt; generate an inflated copy operation (inflate byte[] to char[]/byte[])
1517 //   void StringLatin1.inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len)
1518 //   void StringLatin1.inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len)
1519 bool LibraryCallKit::inline_string_copy(bool compress) {
1520   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1521     return false;
1522   }
1523   int nargs = 5;  // 2 oops, 3 ints
1524   assert(callee()-&gt;signature()-&gt;size() == nargs, &quot;string copy has 5 arguments&quot;);
1525 
1526   Node* src         = argument(0);
1527   Node* src_offset  = argument(1);
1528   Node* dst         = argument(2);
1529   Node* dst_offset  = argument(3);
1530   Node* length      = argument(4);
1531 
1532   // Check for allocation before we add nodes that would confuse
1533   // tightly_coupled_allocation()
1534   AllocateArrayNode* alloc = tightly_coupled_allocation(dst, NULL);
1535 
1536   // Figure out the size and type of the elements we will be copying.
1537   const Type* src_type = src-&gt;Value(&amp;_gvn);
1538   const Type* dst_type = dst-&gt;Value(&amp;_gvn);
1539   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1540   BasicType dst_elem = dst_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1541   assert((compress &amp;&amp; dst_elem == T_BYTE &amp;&amp; (src_elem == T_BYTE || src_elem == T_CHAR)) ||
1542          (!compress &amp;&amp; src_elem == T_BYTE &amp;&amp; (dst_elem == T_BYTE || dst_elem == T_CHAR)),
1543          &quot;Unsupported array types for inline_string_copy&quot;);
1544 
1545   src = must_be_not_null(src, true);
1546   dst = must_be_not_null(dst, true);
1547 
1548   // Convert char[] offsets to byte[] offsets
1549   bool convert_src = (compress &amp;&amp; src_elem == T_BYTE);
1550   bool convert_dst = (!compress &amp;&amp; dst_elem == T_BYTE);
1551   if (convert_src) {
1552     src_offset = _gvn.transform(new LShiftINode(src_offset, intcon(1)));
1553   } else if (convert_dst) {
1554     dst_offset = _gvn.transform(new LShiftINode(dst_offset, intcon(1)));
1555   }
1556 
1557   // Range checks
1558   generate_string_range_check(src, src_offset, length, convert_src);
1559   generate_string_range_check(dst, dst_offset, length, convert_dst);
1560   if (stopped()) {
1561     return true;
1562   }
1563 
1564   Node* src_start = array_element_address(src, src_offset, src_elem);
1565   Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
1566   // &#39;src_start&#39; points to src array + scaled offset
1567   // &#39;dst_start&#39; points to dst array + scaled offset
1568   Node* count = NULL;
1569   if (compress) {
1570     count = compress_string(src_start, TypeAryPtr::get_array_body_type(src_elem), dst_start, length);
1571   } else {
1572     inflate_string(src_start, dst_start, TypeAryPtr::get_array_body_type(dst_elem), length);
1573   }
1574 
1575   if (alloc != NULL) {
1576     if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1577       // &quot;You break it, you buy it.&quot;
1578       InitializeNode* init = alloc-&gt;initialization();
1579       assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1580       init-&gt;set_complete_with_arraycopy();
1581       assert(dst-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1582       assert(dst-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1583     }
1584     // Do not let stores that initialize this object be reordered with
1585     // a subsequent store that would make this object accessible by
1586     // other threads.
1587     // Record what AllocateNode this StoreStore protects so that
1588     // escape analysis can go from the MemBarStoreStoreNode to the
1589     // AllocateNode and eliminate the MemBarStoreStoreNode if possible
1590     // based on the escape status of the AllocateNode.
1591     insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
1592   }
1593   if (compress) {
1594     set_result(_gvn.transform(count));
1595   }
1596   clear_upper_avx();
1597 
1598   return true;
1599 }
1600 
1601 #ifdef _LP64
1602 #define XTOP ,top() /*additional argument*/
1603 #else  //_LP64
1604 #define XTOP        /*no additional argument*/
1605 #endif //_LP64
1606 
1607 //------------------------inline_string_toBytesU--------------------------
1608 // public static byte[] StringUTF16.toBytes(char[] value, int off, int len)
1609 bool LibraryCallKit::inline_string_toBytesU() {
1610   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1611     return false;
1612   }
1613   // Get the arguments.
1614   Node* value     = argument(0);
1615   Node* offset    = argument(1);
1616   Node* length    = argument(2);
1617 
1618   Node* newcopy = NULL;
1619 
1620   // Set the original stack and the reexecute bit for the interpreter to reexecute
1621   // the bytecode that invokes StringUTF16.toBytes() if deoptimization happens.
1622   { PreserveReexecuteState preexecs(this);
1623     jvms()-&gt;set_should_reexecute(true);
1624 
1625     // Check if a null path was taken unconditionally.
1626     value = null_check(value);
1627 
1628     RegionNode* bailout = new RegionNode(1);
1629     record_for_igvn(bailout);
1630 
1631     // Range checks
1632     generate_negative_guard(offset, bailout);
1633     generate_negative_guard(length, bailout);
1634     generate_limit_guard(offset, length, load_array_length(value), bailout);
1635     // Make sure that resulting byte[] length does not overflow Integer.MAX_VALUE
1636     generate_limit_guard(length, intcon(0), intcon(max_jint/2), bailout);
1637 
1638     if (bailout-&gt;req() &gt; 1) {
1639       PreserveJVMState pjvms(this);
1640       set_control(_gvn.transform(bailout));
1641       uncommon_trap(Deoptimization::Reason_intrinsic,
1642                     Deoptimization::Action_maybe_recompile);
1643     }
1644     if (stopped()) {
1645       return true;
1646     }
1647 
1648     Node* size = _gvn.transform(new LShiftINode(length, intcon(1)));
1649     Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_BYTE)));
1650     newcopy = new_array(klass_node, size, 0);  // no arguments to push
1651     AllocateArrayNode* alloc = tightly_coupled_allocation(newcopy, NULL);
1652 
1653     // Calculate starting addresses.
1654     Node* src_start = array_element_address(value, offset, T_CHAR);
1655     Node* dst_start = basic_plus_adr(newcopy, arrayOopDesc::base_offset_in_bytes(T_BYTE));
1656 
1657     // Check if src array address is aligned to HeapWordSize (dst is always aligned)
1658     const TypeInt* toffset = gvn().type(offset)-&gt;is_int();
1659     bool aligned = toffset-&gt;is_con() &amp;&amp; ((toffset-&gt;get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
1660 
1661     // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1662     const char* copyfunc_name = &quot;arraycopy&quot;;
1663     address     copyfunc_addr = StubRoutines::select_arraycopy_function(T_CHAR, aligned, true, copyfunc_name, true);
1664     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
1665                       OptoRuntime::fast_arraycopy_Type(),
1666                       copyfunc_addr, copyfunc_name, TypeRawPtr::BOTTOM,
1667                       src_start, dst_start, ConvI2X(length) XTOP);
1668     // Do not let reads from the cloned object float above the arraycopy.
1669     if (alloc != NULL) {
1670       if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1671         // &quot;You break it, you buy it.&quot;
1672         InitializeNode* init = alloc-&gt;initialization();
1673         assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1674         init-&gt;set_complete_with_arraycopy();
1675         assert(newcopy-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1676         assert(newcopy-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1677       }
1678       // Do not let stores that initialize this object be reordered with
1679       // a subsequent store that would make this object accessible by
1680       // other threads.
1681       // Record what AllocateNode this StoreStore protects so that
1682       // escape analysis can go from the MemBarStoreStoreNode to the
1683       // AllocateNode and eliminate the MemBarStoreStoreNode if possible
1684       // based on the escape status of the AllocateNode.
1685       insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
1686     } else {
1687       insert_mem_bar(Op_MemBarCPUOrder);
1688     }
1689   } // original reexecute is set back here
1690 
1691   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1692   if (!stopped()) {
1693     set_result(newcopy);
1694   }
1695   clear_upper_avx();
1696 
1697   return true;
1698 }
1699 
1700 //------------------------inline_string_getCharsU--------------------------
1701 // public void StringUTF16.getChars(byte[] src, int srcBegin, int srcEnd, char dst[], int dstBegin)
1702 bool LibraryCallKit::inline_string_getCharsU() {
1703   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1704     return false;
1705   }
1706 
1707   // Get the arguments.
1708   Node* src       = argument(0);
1709   Node* src_begin = argument(1);
1710   Node* src_end   = argument(2); // exclusive offset (i &lt; src_end)
1711   Node* dst       = argument(3);
1712   Node* dst_begin = argument(4);
1713 
1714   // Check for allocation before we add nodes that would confuse
1715   // tightly_coupled_allocation()
1716   AllocateArrayNode* alloc = tightly_coupled_allocation(dst, NULL);
1717 
1718   // Check if a null path was taken unconditionally.
1719   src = null_check(src);
1720   dst = null_check(dst);
1721   if (stopped()) {
1722     return true;
1723   }
1724 
1725   // Get length and convert char[] offset to byte[] offset
1726   Node* length = _gvn.transform(new SubINode(src_end, src_begin));
1727   src_begin = _gvn.transform(new LShiftINode(src_begin, intcon(1)));
1728 
1729   // Range checks
1730   generate_string_range_check(src, src_begin, length, true);
1731   generate_string_range_check(dst, dst_begin, length, false);
1732   if (stopped()) {
1733     return true;
1734   }
1735 
1736   if (!stopped()) {
1737     // Calculate starting addresses.
1738     Node* src_start = array_element_address(src, src_begin, T_BYTE);
1739     Node* dst_start = array_element_address(dst, dst_begin, T_CHAR);
1740 
1741     // Check if array addresses are aligned to HeapWordSize
1742     const TypeInt* tsrc = gvn().type(src_begin)-&gt;is_int();
1743     const TypeInt* tdst = gvn().type(dst_begin)-&gt;is_int();
1744     bool aligned = tsrc-&gt;is_con() &amp;&amp; ((tsrc-&gt;get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0) &amp;&amp;
1745                    tdst-&gt;is_con() &amp;&amp; ((tdst-&gt;get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
1746 
1747     // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1748     const char* copyfunc_name = &quot;arraycopy&quot;;
1749     address     copyfunc_addr = StubRoutines::select_arraycopy_function(T_CHAR, aligned, true, copyfunc_name, true);
1750     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
1751                       OptoRuntime::fast_arraycopy_Type(),
1752                       copyfunc_addr, copyfunc_name, TypeRawPtr::BOTTOM,
1753                       src_start, dst_start, ConvI2X(length) XTOP);
1754     // Do not let reads from the cloned object float above the arraycopy.
1755     if (alloc != NULL) {
1756       if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1757         // &quot;You break it, you buy it.&quot;
1758         InitializeNode* init = alloc-&gt;initialization();
1759         assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1760         init-&gt;set_complete_with_arraycopy();
1761         assert(dst-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1762         assert(dst-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1763       }
1764       // Do not let stores that initialize this object be reordered with
1765       // a subsequent store that would make this object accessible by
1766       // other threads.
1767       // Record what AllocateNode this StoreStore protects so that
1768       // escape analysis can go from the MemBarStoreStoreNode to the
1769       // AllocateNode and eliminate the MemBarStoreStoreNode if possible
1770       // based on the escape status of the AllocateNode.
1771       insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
1772     } else {
1773       insert_mem_bar(Op_MemBarCPUOrder);
1774     }
1775   }
1776 
1777   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1778   return true;
1779 }
1780 
1781 //----------------------inline_string_char_access----------------------------
1782 // Store/Load char to/from byte[] array.
1783 // static void StringUTF16.putChar(byte[] val, int index, int c)
1784 // static char StringUTF16.getChar(byte[] val, int index)
1785 bool LibraryCallKit::inline_string_char_access(bool is_store) {
1786   Node* value  = argument(0);
1787   Node* index  = argument(1);
1788   Node* ch = is_store ? argument(2) : NULL;
1789 
1790   // This intrinsic accesses byte[] array as char[] array. Computing the offsets
1791   // correctly requires matched array shapes.
1792   assert (arrayOopDesc::base_offset_in_bytes(T_CHAR) == arrayOopDesc::base_offset_in_bytes(T_BYTE),
1793           &quot;sanity: byte[] and char[] bases agree&quot;);
1794   assert (type2aelembytes(T_CHAR) == type2aelembytes(T_BYTE)*2,
1795           &quot;sanity: byte[] and char[] scales agree&quot;);
1796 
1797   // Bail when getChar over constants is requested: constant folding would
1798   // reject folding mismatched char access over byte[]. A normal inlining for getChar
1799   // Java method would constant fold nicely instead.
1800   if (!is_store &amp;&amp; value-&gt;is_Con() &amp;&amp; index-&gt;is_Con()) {
1801     return false;
1802   }
1803 
1804   value = must_be_not_null(value, true);
1805 
1806   Node* adr = array_element_address(value, index, T_CHAR);
1807   if (adr-&gt;is_top()) {
1808     return false;
1809   }
1810   if (is_store) {
1811     access_store_at(value, adr, TypeAryPtr::BYTES, ch, TypeInt::CHAR, T_CHAR, IN_HEAP | MO_UNORDERED | C2_MISMATCHED);
1812   } else {
1813     ch = access_load_at(value, adr, TypeAryPtr::BYTES, TypeInt::CHAR, T_CHAR, IN_HEAP | MO_UNORDERED | C2_MISMATCHED | C2_CONTROL_DEPENDENT_LOAD);
1814     set_result(ch);
1815   }
1816   return true;
1817 }
1818 
1819 //--------------------------round_double_node--------------------------------
1820 // Round a double node if necessary.
1821 Node* LibraryCallKit::round_double_node(Node* n) {
1822   if (Matcher::strict_fp_requires_explicit_rounding) {
1823 #ifdef IA32
1824     if (UseSSE &lt; 2) {
1825       n = _gvn.transform(new RoundDoubleNode(NULL, n));
1826     }
1827 #else
1828     Unimplemented();
1829 #endif // IA32
1830   }
1831   return n;
1832 }
1833 
1834 //------------------------------inline_math-----------------------------------
1835 // public static double Math.abs(double)
1836 // public static double Math.sqrt(double)
1837 // public static double Math.log(double)
1838 // public static double Math.log10(double)
1839 bool LibraryCallKit::inline_double_math(vmIntrinsics::ID id) {
1840   Node* arg = round_double_node(argument(0));
1841   Node* n = NULL;
1842   switch (id) {
1843   case vmIntrinsics::_dabs:   n = new AbsDNode(                arg);  break;
1844   case vmIntrinsics::_dsqrt:  n = new SqrtDNode(C, control(),  arg);  break;
1845   case vmIntrinsics::_ceil:   n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_ceil); break;
1846   case vmIntrinsics::_floor:  n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_floor); break;
1847   case vmIntrinsics::_rint:   n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_rint); break;
1848   default:  fatal_unexpected_iid(id);  break;
1849   }
1850   set_result(_gvn.transform(n));
1851   return true;
1852 }
1853 
1854 //------------------------------inline_math-----------------------------------
1855 // public static float Math.abs(float)
1856 // public static int Math.abs(int)
1857 // public static long Math.abs(long)
1858 bool LibraryCallKit::inline_math(vmIntrinsics::ID id) {
1859   Node* arg = argument(0);
1860   Node* n = NULL;
1861   switch (id) {
1862   case vmIntrinsics::_fabs:   n = new AbsFNode(                arg);  break;
1863   case vmIntrinsics::_iabs:   n = new AbsINode(                arg);  break;
1864   case vmIntrinsics::_labs:   n = new AbsLNode(                arg);  break;
1865   default:  fatal_unexpected_iid(id);  break;
1866   }
1867   set_result(_gvn.transform(n));
1868   return true;
1869 }
1870 
1871 //------------------------------runtime_math-----------------------------
1872 bool LibraryCallKit::runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName) {
1873   assert(call_type == OptoRuntime::Math_DD_D_Type() || call_type == OptoRuntime::Math_D_D_Type(),
1874          &quot;must be (DD)D or (D)D type&quot;);
1875 
1876   // Inputs
1877   Node* a = round_double_node(argument(0));
1878   Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : NULL;
1879 
1880   const TypePtr* no_memory_effects = NULL;
1881   Node* trig = make_runtime_call(RC_LEAF, call_type, funcAddr, funcName,
1882                                  no_memory_effects,
1883                                  a, top(), b, b ? top() : NULL);
1884   Node* value = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+0));
1885 #ifdef ASSERT
1886   Node* value_top = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+1));
1887   assert(value_top == top(), &quot;second value must be top&quot;);
1888 #endif
1889 
1890   set_result(value);
1891   return true;
1892 }
1893 
1894 //------------------------------inline_math_native-----------------------------
1895 bool LibraryCallKit::inline_math_native(vmIntrinsics::ID id) {
1896 #define FN_PTR(f) CAST_FROM_FN_PTR(address, f)
1897   switch (id) {
1898     // These intrinsics are not properly supported on all hardware
1899   case vmIntrinsics::_dsin:
1900     return StubRoutines::dsin() != NULL ?
1901       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dsin(), &quot;dsin&quot;) :
1902       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dsin),   &quot;SIN&quot;);
1903   case vmIntrinsics::_dcos:
1904     return StubRoutines::dcos() != NULL ?
1905       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dcos(), &quot;dcos&quot;) :
1906       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dcos),   &quot;COS&quot;);
1907   case vmIntrinsics::_dtan:
1908     return StubRoutines::dtan() != NULL ?
1909       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dtan(), &quot;dtan&quot;) :
1910       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dtan), &quot;TAN&quot;);
1911   case vmIntrinsics::_dlog:
1912     return StubRoutines::dlog() != NULL ?
1913       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog(), &quot;dlog&quot;) :
1914       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog),   &quot;LOG&quot;);
1915   case vmIntrinsics::_dlog10:
1916     return StubRoutines::dlog10() != NULL ?
1917       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog10(), &quot;dlog10&quot;) :
1918       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog10), &quot;LOG10&quot;);
1919 
1920     // These intrinsics are supported on all hardware
1921   case vmIntrinsics::_ceil:
1922   case vmIntrinsics::_floor:
1923   case vmIntrinsics::_rint:   return Matcher::match_rule_supported(Op_RoundDoubleMode) ? inline_double_math(id) : false;
1924   case vmIntrinsics::_dsqrt:  return Matcher::match_rule_supported(Op_SqrtD) ? inline_double_math(id) : false;
1925   case vmIntrinsics::_dabs:   return Matcher::has_match_rule(Op_AbsD)   ? inline_double_math(id) : false;
1926   case vmIntrinsics::_fabs:   return Matcher::match_rule_supported(Op_AbsF)   ? inline_math(id) : false;
1927   case vmIntrinsics::_iabs:   return Matcher::match_rule_supported(Op_AbsI)   ? inline_math(id) : false;
1928   case vmIntrinsics::_labs:   return Matcher::match_rule_supported(Op_AbsL)   ? inline_math(id) : false;
1929 
1930   case vmIntrinsics::_dexp:
1931     return StubRoutines::dexp() != NULL ?
1932       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dexp(),  &quot;dexp&quot;) :
1933       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dexp),  &quot;EXP&quot;);
1934   case vmIntrinsics::_dpow: {
1935     Node* exp = round_double_node(argument(2));
1936     const TypeD* d = _gvn.type(exp)-&gt;isa_double_constant();
1937     if (d != NULL &amp;&amp; d-&gt;getd() == 2.0) {
1938       // Special case: pow(x, 2.0) =&gt; x * x
1939       Node* base = round_double_node(argument(0));
1940       set_result(_gvn.transform(new MulDNode(base, base)));
1941       return true;
1942     }
1943     return StubRoutines::dpow() != NULL ?
1944       runtime_math(OptoRuntime::Math_DD_D_Type(), StubRoutines::dpow(),  &quot;dpow&quot;) :
1945       runtime_math(OptoRuntime::Math_DD_D_Type(), FN_PTR(SharedRuntime::dpow),  &quot;POW&quot;);
1946   }
1947 #undef FN_PTR
1948 
1949    // These intrinsics are not yet correctly implemented
1950   case vmIntrinsics::_datan2:
1951     return false;
1952 
1953   default:
1954     fatal_unexpected_iid(id);
1955     return false;
1956   }
1957 }
1958 
1959 static bool is_simple_name(Node* n) {
1960   return (n-&gt;req() == 1         // constant
1961           || (n-&gt;is_Type() &amp;&amp; n-&gt;as_Type()-&gt;type()-&gt;singleton())
1962           || n-&gt;is_Proj()       // parameter or return value
1963           || n-&gt;is_Phi()        // local of some sort
1964           );
1965 }
1966 
1967 //----------------------------inline_notify-----------------------------------*
1968 bool LibraryCallKit::inline_notify(vmIntrinsics::ID id) {
1969   const TypeFunc* ftype = OptoRuntime::monitor_notify_Type();
1970   address func;
1971   if (id == vmIntrinsics::_notify) {
1972     func = OptoRuntime::monitor_notify_Java();
1973   } else {
1974     func = OptoRuntime::monitor_notifyAll_Java();
1975   }
1976   Node* call = make_runtime_call(RC_NO_LEAF, ftype, func, NULL, TypeRawPtr::BOTTOM, argument(0));
1977   make_slow_call_ex(call, env()-&gt;Throwable_klass(), false);
1978   return true;
1979 }
1980 
1981 
1982 //----------------------------inline_min_max-----------------------------------
1983 bool LibraryCallKit::inline_min_max(vmIntrinsics::ID id) {
1984   set_result(generate_min_max(id, argument(0), argument(1)));
1985   return true;
1986 }
1987 
1988 void LibraryCallKit::inline_math_mathExact(Node* math, Node *test) {
1989   Node* bol = _gvn.transform( new BoolNode(test, BoolTest::overflow) );
1990   IfNode* check = create_and_map_if(control(), bol, PROB_UNLIKELY_MAG(3), COUNT_UNKNOWN);
1991   Node* fast_path = _gvn.transform( new IfFalseNode(check));
1992   Node* slow_path = _gvn.transform( new IfTrueNode(check) );
1993 
1994   {
1995     PreserveJVMState pjvms(this);
1996     PreserveReexecuteState preexecs(this);
1997     jvms()-&gt;set_should_reexecute(true);
1998 
1999     set_control(slow_path);
2000     set_i_o(i_o());
2001 
2002     uncommon_trap(Deoptimization::Reason_intrinsic,
2003                   Deoptimization::Action_none);
2004   }
2005 
2006   set_control(fast_path);
2007   set_result(math);
2008 }
2009 
2010 template &lt;typename OverflowOp&gt;
2011 bool LibraryCallKit::inline_math_overflow(Node* arg1, Node* arg2) {
2012   typedef typename OverflowOp::MathOp MathOp;
2013 
2014   MathOp* mathOp = new MathOp(arg1, arg2);
2015   Node* operation = _gvn.transform( mathOp );
2016   Node* ofcheck = _gvn.transform( new OverflowOp(arg1, arg2) );
2017   inline_math_mathExact(operation, ofcheck);
2018   return true;
2019 }
2020 
2021 bool LibraryCallKit::inline_math_addExactI(bool is_increment) {
2022   return inline_math_overflow&lt;OverflowAddINode&gt;(argument(0), is_increment ? intcon(1) : argument(1));
2023 }
2024 
2025 bool LibraryCallKit::inline_math_addExactL(bool is_increment) {
2026   return inline_math_overflow&lt;OverflowAddLNode&gt;(argument(0), is_increment ? longcon(1) : argument(2));
2027 }
2028 
2029 bool LibraryCallKit::inline_math_subtractExactI(bool is_decrement) {
2030   return inline_math_overflow&lt;OverflowSubINode&gt;(argument(0), is_decrement ? intcon(1) : argument(1));
2031 }
2032 
2033 bool LibraryCallKit::inline_math_subtractExactL(bool is_decrement) {
2034   return inline_math_overflow&lt;OverflowSubLNode&gt;(argument(0), is_decrement ? longcon(1) : argument(2));
2035 }
2036 
2037 bool LibraryCallKit::inline_math_negateExactI() {
2038   return inline_math_overflow&lt;OverflowSubINode&gt;(intcon(0), argument(0));
2039 }
2040 
2041 bool LibraryCallKit::inline_math_negateExactL() {
2042   return inline_math_overflow&lt;OverflowSubLNode&gt;(longcon(0), argument(0));
2043 }
2044 
2045 bool LibraryCallKit::inline_math_multiplyExactI() {
2046   return inline_math_overflow&lt;OverflowMulINode&gt;(argument(0), argument(1));
2047 }
2048 
2049 bool LibraryCallKit::inline_math_multiplyExactL() {
2050   return inline_math_overflow&lt;OverflowMulLNode&gt;(argument(0), argument(2));
2051 }
2052 
2053 bool LibraryCallKit::inline_math_multiplyHigh() {
2054   set_result(_gvn.transform(new MulHiLNode(argument(0), argument(2))));
2055   return true;
2056 }
2057 
2058 Node*
2059 LibraryCallKit::generate_min_max(vmIntrinsics::ID id, Node* x0, Node* y0) {
2060   // These are the candidate return value:
2061   Node* xvalue = x0;
2062   Node* yvalue = y0;
2063 
2064   if (xvalue == yvalue) {
2065     return xvalue;
2066   }
2067 
2068   bool want_max = (id == vmIntrinsics::_max);
2069 
2070   const TypeInt* txvalue = _gvn.type(xvalue)-&gt;isa_int();
2071   const TypeInt* tyvalue = _gvn.type(yvalue)-&gt;isa_int();
2072   if (txvalue == NULL || tyvalue == NULL)  return top();
2073   // This is not really necessary, but it is consistent with a
2074   // hypothetical MaxINode::Value method:
2075   int widen = MAX2(txvalue-&gt;_widen, tyvalue-&gt;_widen);
2076 
2077   // %%% This folding logic should (ideally) be in a different place.
2078   // Some should be inside IfNode, and there to be a more reliable
2079   // transformation of ?: style patterns into cmoves.  We also want
2080   // more powerful optimizations around cmove and min/max.
2081 
2082   // Try to find a dominating comparison of these guys.
2083   // It can simplify the index computation for Arrays.copyOf
2084   // and similar uses of System.arraycopy.
2085   // First, compute the normalized version of CmpI(x, y).
2086   int   cmp_op = Op_CmpI;
2087   Node* xkey = xvalue;
2088   Node* ykey = yvalue;
2089   Node* ideal_cmpxy = _gvn.transform(new CmpINode(xkey, ykey));
2090   if (ideal_cmpxy-&gt;is_Cmp()) {
2091     // E.g., if we have CmpI(length - offset, count),
2092     // it might idealize to CmpI(length, count + offset)
2093     cmp_op = ideal_cmpxy-&gt;Opcode();
2094     xkey = ideal_cmpxy-&gt;in(1);
2095     ykey = ideal_cmpxy-&gt;in(2);
2096   }
2097 
2098   // Start by locating any relevant comparisons.
2099   Node* start_from = (xkey-&gt;outcnt() &lt; ykey-&gt;outcnt()) ? xkey : ykey;
2100   Node* cmpxy = NULL;
2101   Node* cmpyx = NULL;
2102   for (DUIterator_Fast kmax, k = start_from-&gt;fast_outs(kmax); k &lt; kmax; k++) {
2103     Node* cmp = start_from-&gt;fast_out(k);
2104     if (cmp-&gt;outcnt() &gt; 0 &amp;&amp;            // must have prior uses
2105         cmp-&gt;in(0) == NULL &amp;&amp;           // must be context-independent
2106         cmp-&gt;Opcode() == cmp_op) {      // right kind of compare
2107       if (cmp-&gt;in(1) == xkey &amp;&amp; cmp-&gt;in(2) == ykey)  cmpxy = cmp;
2108       if (cmp-&gt;in(1) == ykey &amp;&amp; cmp-&gt;in(2) == xkey)  cmpyx = cmp;
2109     }
2110   }
2111 
2112   const int NCMPS = 2;
2113   Node* cmps[NCMPS] = { cmpxy, cmpyx };
2114   int cmpn;
2115   for (cmpn = 0; cmpn &lt; NCMPS; cmpn++) {
2116     if (cmps[cmpn] != NULL)  break;     // find a result
2117   }
2118   if (cmpn &lt; NCMPS) {
2119     // Look for a dominating test that tells us the min and max.
2120     int depth = 0;                // Limit search depth for speed
2121     Node* dom = control();
2122     for (; dom != NULL; dom = IfNode::up_one_dom(dom, true)) {
2123       if (++depth &gt;= 100)  break;
2124       Node* ifproj = dom;
2125       if (!ifproj-&gt;is_Proj())  continue;
2126       Node* iff = ifproj-&gt;in(0);
2127       if (!iff-&gt;is_If())  continue;
2128       Node* bol = iff-&gt;in(1);
2129       if (!bol-&gt;is_Bool())  continue;
2130       Node* cmp = bol-&gt;in(1);
2131       if (cmp == NULL)  continue;
2132       for (cmpn = 0; cmpn &lt; NCMPS; cmpn++)
2133         if (cmps[cmpn] == cmp)  break;
2134       if (cmpn == NCMPS)  continue;
2135       BoolTest::mask btest = bol-&gt;as_Bool()-&gt;_test._test;
2136       if (ifproj-&gt;is_IfFalse())  btest = BoolTest(btest).negate();
2137       if (cmp-&gt;in(1) == ykey)    btest = BoolTest(btest).commute();
2138       // At this point, we know that &#39;x btest y&#39; is true.
2139       switch (btest) {
2140       case BoolTest::eq:
2141         // They are proven equal, so we can collapse the min/max.
2142         // Either value is the answer.  Choose the simpler.
2143         if (is_simple_name(yvalue) &amp;&amp; !is_simple_name(xvalue))
2144           return yvalue;
2145         return xvalue;
2146       case BoolTest::lt:          // x &lt; y
2147       case BoolTest::le:          // x &lt;= y
2148         return (want_max ? yvalue : xvalue);
2149       case BoolTest::gt:          // x &gt; y
2150       case BoolTest::ge:          // x &gt;= y
2151         return (want_max ? xvalue : yvalue);
2152       default:
2153         break;
2154       }
2155     }
2156   }
2157 
2158   // We failed to find a dominating test.
2159   // Let&#39;s pick a test that might GVN with prior tests.
2160   Node*          best_bol   = NULL;
2161   BoolTest::mask best_btest = BoolTest::illegal;
2162   for (cmpn = 0; cmpn &lt; NCMPS; cmpn++) {
2163     Node* cmp = cmps[cmpn];
2164     if (cmp == NULL)  continue;
2165     for (DUIterator_Fast jmax, j = cmp-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2166       Node* bol = cmp-&gt;fast_out(j);
2167       if (!bol-&gt;is_Bool())  continue;
2168       BoolTest::mask btest = bol-&gt;as_Bool()-&gt;_test._test;
2169       if (btest == BoolTest::eq || btest == BoolTest::ne)  continue;
2170       if (cmp-&gt;in(1) == ykey)   btest = BoolTest(btest).commute();
2171       if (bol-&gt;outcnt() &gt; (best_bol == NULL ? 0 : best_bol-&gt;outcnt())) {
2172         best_bol   = bol-&gt;as_Bool();
2173         best_btest = btest;
2174       }
2175     }
2176   }
2177 
2178   Node* answer_if_true  = NULL;
2179   Node* answer_if_false = NULL;
2180   switch (best_btest) {
2181   default:
2182     if (cmpxy == NULL)
2183       cmpxy = ideal_cmpxy;
2184     best_bol = _gvn.transform(new BoolNode(cmpxy, BoolTest::lt));
2185     // and fall through:
2186   case BoolTest::lt:          // x &lt; y
2187   case BoolTest::le:          // x &lt;= y
2188     answer_if_true  = (want_max ? yvalue : xvalue);
2189     answer_if_false = (want_max ? xvalue : yvalue);
2190     break;
2191   case BoolTest::gt:          // x &gt; y
2192   case BoolTest::ge:          // x &gt;= y
2193     answer_if_true  = (want_max ? xvalue : yvalue);
2194     answer_if_false = (want_max ? yvalue : xvalue);
2195     break;
2196   }
2197 
2198   jint hi, lo;
2199   if (want_max) {
2200     // We can sharpen the minimum.
2201     hi = MAX2(txvalue-&gt;_hi, tyvalue-&gt;_hi);
2202     lo = MAX2(txvalue-&gt;_lo, tyvalue-&gt;_lo);
2203   } else {
2204     // We can sharpen the maximum.
2205     hi = MIN2(txvalue-&gt;_hi, tyvalue-&gt;_hi);
2206     lo = MIN2(txvalue-&gt;_lo, tyvalue-&gt;_lo);
2207   }
2208 
2209   // Use a flow-free graph structure, to avoid creating excess control edges
2210   // which could hinder other optimizations.
2211   // Since Math.min/max is often used with arraycopy, we want
2212   // tightly_coupled_allocation to be able to see beyond min/max expressions.
2213   Node* cmov = CMoveNode::make(NULL, best_bol,
2214                                answer_if_false, answer_if_true,
2215                                TypeInt::make(lo, hi, widen));
2216 
2217   return _gvn.transform(cmov);
2218 
2219   /*
2220   // This is not as desirable as it may seem, since Min and Max
2221   // nodes do not have a full set of optimizations.
2222   // And they would interfere, anyway, with &#39;if&#39; optimizations
2223   // and with CMoveI canonical forms.
2224   switch (id) {
2225   case vmIntrinsics::_min:
2226     result_val = _gvn.transform(new (C, 3) MinINode(x,y)); break;
2227   case vmIntrinsics::_max:
2228     result_val = _gvn.transform(new (C, 3) MaxINode(x,y)); break;
2229   default:
2230     ShouldNotReachHere();
2231   }
2232   */
2233 }
2234 
2235 inline int
2236 LibraryCallKit::classify_unsafe_addr(Node* &amp;base, Node* &amp;offset, BasicType type) {
2237   const TypePtr* base_type = TypePtr::NULL_PTR;
2238   if (base != NULL)  base_type = _gvn.type(base)-&gt;isa_ptr();
2239   if (base_type == NULL) {
2240     // Unknown type.
2241     return Type::AnyPtr;
2242   } else if (base_type == TypePtr::NULL_PTR) {
2243     // Since this is a NULL+long form, we have to switch to a rawptr.
2244     base   = _gvn.transform(new CastX2PNode(offset));
2245     offset = MakeConX(0);
2246     return Type::RawPtr;
2247   } else if (base_type-&gt;base() == Type::RawPtr) {
2248     return Type::RawPtr;
2249   } else if (base_type-&gt;isa_oopptr()) {
2250     // Base is never null =&gt; always a heap address.
2251     if (!TypePtr::NULL_PTR-&gt;higher_equal(base_type)) {
2252       return Type::OopPtr;
2253     }
2254     // Offset is small =&gt; always a heap address.
2255     const TypeX* offset_type = _gvn.type(offset)-&gt;isa_intptr_t();
2256     if (offset_type != NULL &amp;&amp;
2257         base_type-&gt;offset() == 0 &amp;&amp;     // (should always be?)
2258         offset_type-&gt;_lo &gt;= 0 &amp;&amp;
2259         !MacroAssembler::needs_explicit_null_check(offset_type-&gt;_hi)) {
2260       return Type::OopPtr;
2261     } else if (type == T_OBJECT) {
2262       // off heap access to an oop doesn&#39;t make any sense. Has to be on
2263       // heap.
2264       return Type::OopPtr;
2265     }
2266     // Otherwise, it might either be oop+off or NULL+addr.
2267     return Type::AnyPtr;
2268   } else {
2269     // No information:
2270     return Type::AnyPtr;
2271   }
2272 }
2273 
2274 inline Node* LibraryCallKit::make_unsafe_address(Node*&amp; base, Node* offset, DecoratorSet decorators, BasicType type, bool can_cast) {
2275   Node* uncasted_base = base;
2276   int kind = classify_unsafe_addr(uncasted_base, offset, type);
2277   if (kind == Type::RawPtr) {
2278     return basic_plus_adr(top(), uncasted_base, offset);
2279   } else if (kind == Type::AnyPtr) {
2280     assert(base == uncasted_base, &quot;unexpected base change&quot;);
2281     if (can_cast) {
2282       if (!_gvn.type(base)-&gt;speculative_maybe_null() &amp;&amp;
2283           !too_many_traps(Deoptimization::Reason_speculate_null_check)) {
2284         // According to profiling, this access is always on
2285         // heap. Casting the base to not null and thus avoiding membars
2286         // around the access should allow better optimizations
2287         Node* null_ctl = top();
2288         base = null_check_oop(base, &amp;null_ctl, true, true, true);
2289         assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
2290         return basic_plus_adr(base, offset);
2291       } else if (_gvn.type(base)-&gt;speculative_always_null() &amp;&amp;
2292                  !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {
2293         // According to profiling, this access is always off
2294         // heap.
2295         base = null_assert(base);
2296         Node* raw_base = _gvn.transform(new CastX2PNode(offset));
2297         offset = MakeConX(0);
2298         return basic_plus_adr(top(), raw_base, offset);
2299       }
2300     }
2301     // We don&#39;t know if it&#39;s an on heap or off heap access. Fall back
2302     // to raw memory access.
2303     Node* raw = _gvn.transform(new CheckCastPPNode(control(), base, TypeRawPtr::BOTTOM));
2304     return basic_plus_adr(top(), raw, offset);
2305   } else {
2306     assert(base == uncasted_base, &quot;unexpected base change&quot;);
2307     // We know it&#39;s an on heap access so base can&#39;t be null
2308     if (TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(base))) {
2309       base = must_be_not_null(base, true);
2310     }
2311     return basic_plus_adr(base, offset);
2312   }
2313 }
2314 
2315 //--------------------------inline_number_methods-----------------------------
2316 // inline int     Integer.numberOfLeadingZeros(int)
2317 // inline int        Long.numberOfLeadingZeros(long)
2318 //
2319 // inline int     Integer.numberOfTrailingZeros(int)
2320 // inline int        Long.numberOfTrailingZeros(long)
2321 //
2322 // inline int     Integer.bitCount(int)
2323 // inline int        Long.bitCount(long)
2324 //
2325 // inline char  Character.reverseBytes(char)
2326 // inline short     Short.reverseBytes(short)
2327 // inline int     Integer.reverseBytes(int)
2328 // inline long       Long.reverseBytes(long)
2329 bool LibraryCallKit::inline_number_methods(vmIntrinsics::ID id) {
2330   Node* arg = argument(0);
2331   Node* n = NULL;
2332   switch (id) {
2333   case vmIntrinsics::_numberOfLeadingZeros_i:   n = new CountLeadingZerosINode( arg);  break;
2334   case vmIntrinsics::_numberOfLeadingZeros_l:   n = new CountLeadingZerosLNode( arg);  break;
2335   case vmIntrinsics::_numberOfTrailingZeros_i:  n = new CountTrailingZerosINode(arg);  break;
2336   case vmIntrinsics::_numberOfTrailingZeros_l:  n = new CountTrailingZerosLNode(arg);  break;
2337   case vmIntrinsics::_bitCount_i:               n = new PopCountINode(          arg);  break;
2338   case vmIntrinsics::_bitCount_l:               n = new PopCountLNode(          arg);  break;
2339   case vmIntrinsics::_reverseBytes_c:           n = new ReverseBytesUSNode(0,   arg);  break;
2340   case vmIntrinsics::_reverseBytes_s:           n = new ReverseBytesSNode( 0,   arg);  break;
2341   case vmIntrinsics::_reverseBytes_i:           n = new ReverseBytesINode( 0,   arg);  break;
2342   case vmIntrinsics::_reverseBytes_l:           n = new ReverseBytesLNode( 0,   arg);  break;
2343   default:  fatal_unexpected_iid(id);  break;
2344   }
2345   set_result(_gvn.transform(n));
2346   return true;
2347 }
2348 
2349 //----------------------------inline_unsafe_access----------------------------
2350 
2351 const TypeOopPtr* LibraryCallKit::sharpen_unsafe_type(Compile::AliasType* alias_type, const TypePtr *adr_type) {
2352   // Attempt to infer a sharper value type from the offset and base type.
2353   ciKlass* sharpened_klass = NULL;
2354 
2355   // See if it is an instance field, with an object type.
2356   if (alias_type-&gt;field() != NULL) {
2357     if (alias_type-&gt;field()-&gt;type()-&gt;is_klass()) {
2358       sharpened_klass = alias_type-&gt;field()-&gt;type()-&gt;as_klass();
2359     }
2360   }
2361 
2362   // See if it is a narrow oop array.
2363   if (adr_type-&gt;isa_aryptr()) {
2364     if (adr_type-&gt;offset() &gt;= objArrayOopDesc::base_offset_in_bytes()) {
2365       const TypeOopPtr *elem_type = adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_oopptr();
2366       if (elem_type != NULL) {
2367         sharpened_klass = elem_type-&gt;klass();
2368       }
2369     }
2370   }
2371 
2372   // The sharpened class might be unloaded if there is no class loader
2373   // contraint in place.
2374   if (sharpened_klass != NULL &amp;&amp; sharpened_klass-&gt;is_loaded()) {
2375     const TypeOopPtr* tjp = TypeOopPtr::make_from_klass(sharpened_klass);
2376 
2377 #ifndef PRODUCT
2378     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
2379       tty-&gt;print(&quot;  from base type:  &quot;);  adr_type-&gt;dump(); tty-&gt;cr();
2380       tty-&gt;print(&quot;  sharpened value: &quot;);  tjp-&gt;dump();      tty-&gt;cr();
2381     }
2382 #endif
2383     // Sharpen the value type.
2384     return tjp;
2385   }
2386   return NULL;
2387 }
2388 
2389 DecoratorSet LibraryCallKit::mo_decorator_for_access_kind(AccessKind kind) {
2390   switch (kind) {
2391       case Relaxed:
2392         return MO_UNORDERED;
2393       case Opaque:
2394         return MO_RELAXED;
2395       case Acquire:
2396         return MO_ACQUIRE;
2397       case Release:
2398         return MO_RELEASE;
2399       case Volatile:
2400         return MO_SEQ_CST;
2401       default:
2402         ShouldNotReachHere();
2403         return 0;
2404   }
2405 }
2406 
2407 bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned) {
2408   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2409   DecoratorSet decorators = C2_UNSAFE_ACCESS;
2410   guarantee(!is_store || kind != Acquire, &quot;Acquire accesses can be produced only for loads&quot;);
2411   guarantee( is_store || kind != Release, &quot;Release accesses can be produced only for stores&quot;);
2412   assert(type != T_OBJECT || !unaligned, &quot;unaligned access not supported with object type&quot;);
2413 
2414   if (is_reference_type(type)) {
2415     decorators |= ON_UNKNOWN_OOP_REF;
2416   }
2417 
2418   if (unaligned) {
2419     decorators |= C2_UNALIGNED;
2420   }
2421 
2422 #ifndef PRODUCT
2423   {
2424     ResourceMark rm;
2425     // Check the signatures.
2426     ciSignature* sig = callee()-&gt;signature();
2427 #ifdef ASSERT
2428     if (!is_store) {
2429       // Object getReference(Object base, int/long offset), etc.
2430       BasicType rtype = sig-&gt;return_type()-&gt;basic_type();
2431       assert(rtype == type || (rtype == T_OBJECT &amp;&amp; type == T_INLINE_TYPE), &quot;getter must return the expected value&quot;);
2432       assert(sig-&gt;count() == 2 || (type == T_INLINE_TYPE &amp;&amp; sig-&gt;count() == 3), &quot;oop getter has 2 or 3 arguments&quot;);
2433       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;getter base is object&quot;);
2434       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;getter offset is correct&quot;);
2435     } else {
2436       // void putReference(Object base, int/long offset, Object x), etc.
2437       assert(sig-&gt;return_type()-&gt;basic_type() == T_VOID, &quot;putter must not return a value&quot;);
2438       assert(sig-&gt;count() == 3 || (type == T_INLINE_TYPE &amp;&amp; sig-&gt;count() == 4), &quot;oop putter has 3 arguments&quot;);
2439       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;putter base is object&quot;);
2440       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;putter offset is correct&quot;);
2441       BasicType vtype = sig-&gt;type_at(sig-&gt;count()-1)-&gt;basic_type();
2442       assert(vtype == type || (type == T_INLINE_TYPE &amp;&amp; vtype == T_OBJECT), &quot;putter must accept the expected value&quot;);
2443     }
2444 #endif // ASSERT
2445  }
2446 #endif //PRODUCT
2447 
2448   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
2449 
2450   Node* receiver = argument(0);  // type: oop
2451 
2452   // Build address expression.
2453   Node* adr;
2454   Node* heap_base_oop = top();
2455   Node* offset = top();
2456   Node* val;
2457 
2458   // The base is either a Java object or a value produced by Unsafe.staticFieldBase
2459   Node* base = argument(1);  // type: oop
2460   // The offset is a value produced by Unsafe.staticFieldOffset or Unsafe.objectFieldOffset
2461   offset = argument(2);  // type: long
2462   // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
2463   // to be plain byte offsets, which are also the same as those accepted
2464   // by oopDesc::field_addr.
2465   assert(Unsafe_field_offset_to_byte_offset(11) == 11,
2466          &quot;fieldOffset must be byte-scaled&quot;);
2467 
2468   ciInlineKlass* inline_klass = NULL;
2469   if (type == T_INLINE_TYPE) {
2470     Node* cls = null_check(argument(4));
2471     if (stopped()) {
2472       return true;
2473     }
2474     Node* kls = load_klass_from_mirror(cls, false, NULL, 0);
2475     const TypeKlassPtr* kls_t = _gvn.type(kls)-&gt;isa_klassptr();
2476     if (!kls_t-&gt;klass_is_exact()) {
2477       return false;
2478     }
2479     ciKlass* klass = kls_t-&gt;klass();
2480     if (!klass-&gt;is_inlinetype()) {
2481       return false;
2482     }
2483     inline_klass = klass-&gt;as_inline_klass();
2484   }
2485 
2486   receiver = null_check(receiver);
2487   if (stopped()) {
2488     return true;
2489   }
2490 
2491   if (base-&gt;is_InlineType()) {
2492     InlineTypeNode* vt = base-&gt;as_InlineType();
<a name="1" id="anc1"></a>
2493     if (is_store) {
2494       if (!vt-&gt;is_allocated(&amp;_gvn) || !_gvn.type(vt)-&gt;is_inlinetype()-&gt;larval()) {
2495         return false;
2496       }
2497       base = vt-&gt;get_oop();
2498     } else {
2499       if (offset-&gt;is_Con()) {
2500         long off = find_long_con(offset, 0);
2501         ciInlineKlass* vk = vt-&gt;type()-&gt;inline_klass();
2502         if ((long)(int)off != off || !vk-&gt;contains_field_offset(off)) {
2503           return false;
2504         }
2505 
<a name="2" id="anc2"></a><span class="line-modified">2506         ciField* field = vk-&gt;get_non_flattened_field_by_offset(off);</span>
<span class="line-modified">2507         if (field != NULL) {</span>
<span class="line-modified">2508           BasicType bt = field-&gt;layout_type();</span>
<span class="line-modified">2509           if (bt == T_ARRAY || bt == T_NARROWOOP || (bt == T_INLINE_TYPE &amp;&amp; !field-&gt;is_flattened())) {</span>

2510             bt = T_OBJECT;
2511           }
<a name="3" id="anc3"></a><span class="line-modified">2512           if (bt == type &amp;&amp; (bt != T_INLINE_TYPE || field-&gt;type() == inline_klass)) {</span>
<span class="line-modified">2513             set_result(vt-&gt;field_value_by_offset(off, false));</span>
<span class="line-modified">2514             return true;</span>


2515           }
2516         }
2517       }
2518       // Re-execute the unsafe access if allocation triggers deoptimization.
2519       PreserveReexecuteState preexecs(this);
2520       jvms()-&gt;set_should_reexecute(true);
2521       base = vt-&gt;buffer(this)-&gt;get_oop();
2522     }
2523   }
2524 
2525   // 32-bit machines ignore the high half!
2526   offset = ConvL2X(offset);
2527   adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);
2528 
2529   if (_gvn.type(base)-&gt;isa_ptr() == TypePtr::NULL_PTR) {
2530     if (type != T_OBJECT &amp;&amp; (inline_klass == NULL || !inline_klass-&gt;has_object_fields())) {
2531       decorators |= IN_NATIVE; // off-heap primitive access
2532     } else {
2533       return false; // off-heap oop accesses are not supported
2534     }
2535   } else {
2536     heap_base_oop = base; // on-heap or mixed access
2537   }
2538 
2539   // Can base be NULL? Otherwise, always on-heap access.
2540   bool can_access_non_heap = TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(base));
2541 
2542   if (!can_access_non_heap) {
2543     decorators |= IN_HEAP;
2544   }
2545 
2546   val = is_store ? argument(4 + (type == T_INLINE_TYPE ? 1 : 0)) : NULL;
2547 
2548   const TypePtr* adr_type = _gvn.type(adr)-&gt;isa_ptr();
2549   if (adr_type == TypePtr::NULL_PTR) {
2550     return false; // off-heap access with zero address
2551   }
2552 
2553   // Try to categorize the address.
2554   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
2555   assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
2556 
2557   if (alias_type-&gt;adr_type() == TypeInstPtr::KLASS ||
2558       alias_type-&gt;adr_type() == TypeAryPtr::RANGE) {
2559     return false; // not supported
2560   }
2561 
2562   bool mismatched = false;
2563   BasicType bt = T_ILLEGAL;
2564   ciField* field = NULL;
2565   if (adr_type-&gt;isa_instptr()) {
2566     const TypeInstPtr* instptr = adr_type-&gt;is_instptr();
2567     ciInstanceKlass* k = instptr-&gt;klass()-&gt;as_instance_klass();
2568     int off = instptr-&gt;offset();
2569     if (instptr-&gt;const_oop() != NULL &amp;&amp;
2570         instptr-&gt;klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
2571         instptr-&gt;offset() &gt;= (instptr-&gt;klass()-&gt;as_instance_klass()-&gt;size_helper() * wordSize)) {
2572       k = instptr-&gt;const_oop()-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
2573       field = k-&gt;get_field_by_offset(off, true);
2574     } else {
2575       field = k-&gt;get_non_flattened_field_by_offset(off);
2576     }
2577     if (field != NULL) {
2578       bt = field-&gt;layout_type();
2579     }
2580     assert(bt == alias_type-&gt;basic_type() || bt == T_INLINE_TYPE, &quot;should match&quot;);
2581     if (field != NULL &amp;&amp; bt == T_INLINE_TYPE &amp;&amp; !field-&gt;is_flattened()) {
2582       bt = T_OBJECT;
2583     }
2584   } else {
2585     bt = alias_type-&gt;basic_type();
2586   }
2587 
2588   if (bt != T_ILLEGAL) {
2589     assert(alias_type-&gt;adr_type()-&gt;is_oopptr(), &quot;should be on-heap access&quot;);
2590     if (bt == T_BYTE &amp;&amp; adr_type-&gt;isa_aryptr()) {
2591       // Alias type doesn&#39;t differentiate between byte[] and boolean[]).
2592       // Use address type to get the element type.
2593       bt = adr_type-&gt;is_aryptr()-&gt;elem()-&gt;array_element_basic_type();
2594     }
2595     if (bt == T_ARRAY || bt == T_NARROWOOP) {
2596       // accessing an array field with getReference is not a mismatch
2597       bt = T_OBJECT;
2598     }
2599     if ((bt == T_OBJECT) != (type == T_OBJECT)) {
2600       // Don&#39;t intrinsify mismatched object accesses
2601       return false;
2602     }
2603     mismatched = (bt != type);
2604   } else if (alias_type-&gt;adr_type()-&gt;isa_oopptr()) {
2605     mismatched = true; // conservatively mark all &quot;wide&quot; on-heap accesses as mismatched
2606   }
2607 
2608   if (type == T_INLINE_TYPE) {
2609     if (adr_type-&gt;isa_instptr()) {
2610       if (field == NULL || field-&gt;type() != inline_klass) {
2611         mismatched = true;
2612       }
2613     } else if (adr_type-&gt;isa_aryptr()) {
2614       const Type* elem = adr_type-&gt;is_aryptr()-&gt;elem();
2615       if (!elem-&gt;isa_inlinetype()) {
2616         mismatched = true;
2617       } else if (elem-&gt;inline_klass() != inline_klass) {
2618         mismatched = true;
2619       }
2620     }
2621     if (is_store) {
2622       const Type* val_t = _gvn.type(val);
2623       if (!val_t-&gt;isa_inlinetype() || val_t-&gt;inline_klass() != inline_klass) {
2624         return false;
2625       }
2626     }
2627   }
2628 
2629   assert(!mismatched || alias_type-&gt;adr_type()-&gt;is_oopptr(), &quot;off-heap access can&#39;t be mismatched&quot;);
2630 
2631   if (mismatched) {
2632     decorators |= C2_MISMATCHED;
2633   }
2634 
2635   // First guess at the value type.
2636   const Type *value_type = Type::get_const_basic_type(type);
2637 
2638   // Figure out the memory ordering.
2639   decorators |= mo_decorator_for_access_kind(kind);
2640 
2641   if (!is_store) {
2642     if (type == T_OBJECT) {
2643       const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);
2644       if (tjp != NULL) {
2645         value_type = tjp;
2646       }
2647     } else if (type == T_INLINE_TYPE) {
2648       value_type = NULL;
2649     }
2650   }
2651 
2652   // Heap pointers get a null-check from the interpreter,
2653   // as a courtesy.  However, this is not guaranteed by Unsafe,
2654   // and it is not possible to fully distinguish unintended nulls
2655   // from intended ones in this API.
2656 
2657   if (!is_store) {
2658     Node* p = NULL;
2659     // Try to constant fold a load from a constant field
2660 
2661     if (heap_base_oop != top() &amp;&amp; field != NULL &amp;&amp; field-&gt;is_constant() &amp;&amp; !mismatched) {
2662       // final or stable field
2663       p = make_constant_from_field(field, heap_base_oop);
2664     }
2665 
2666     if (p == NULL) { // Could not constant fold the load
2667       if (type == T_INLINE_TYPE) {
2668         if (adr_type-&gt;isa_instptr() &amp;&amp; !mismatched) {
2669           ciInstanceKlass* holder = adr_type-&gt;is_instptr()-&gt;klass()-&gt;as_instance_klass();
2670           int offset = adr_type-&gt;is_instptr()-&gt;offset();
2671           p = InlineTypeNode::make_from_flattened(this, inline_klass, base, base, holder, offset, decorators);
2672         } else {
2673           p = InlineTypeNode::make_from_flattened(this, inline_klass, base, adr, NULL, 0, decorators);
2674         }
2675       } else {
2676         p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);
2677       }
2678       // Normalize the value returned by getBoolean in the following cases
2679       if (type == T_BOOLEAN &amp;&amp;
2680           (mismatched ||
2681            heap_base_oop == top() ||                  // - heap_base_oop is NULL or
2682            (can_access_non_heap &amp;&amp; field == NULL))    // - heap_base_oop is potentially NULL
2683                                                       //   and the unsafe access is made to large offset
2684                                                       //   (i.e., larger than the maximum offset necessary for any
2685                                                       //   field access)
2686             ) {
2687           IdealKit ideal = IdealKit(this);
2688 #define __ ideal.
2689           IdealVariable normalized_result(ideal);
2690           __ declarations_done();
2691           __ set(normalized_result, p);
2692           __ if_then(p, BoolTest::ne, ideal.ConI(0));
2693           __ set(normalized_result, ideal.ConI(1));
2694           ideal.end_if();
2695           final_sync(ideal);
2696           p = __ value(normalized_result);
2697 #undef __
2698       }
2699     }
2700     if (type == T_ADDRESS) {
2701       p = gvn().transform(new CastP2XNode(NULL, p));
2702       p = ConvX2UL(p);
2703     }
2704     if (field != NULL &amp;&amp; field-&gt;type()-&gt;is_inlinetype() &amp;&amp; !field-&gt;is_flattened()) {
2705       // Load a non-flattened inline type from memory
2706       if (value_type-&gt;inline_klass()-&gt;is_scalarizable()) {
2707         p = InlineTypeNode::make_from_oop(this, p, value_type-&gt;inline_klass());
2708       } else {
2709         p = null2default(p, value_type-&gt;inline_klass());
2710       }
2711     }
2712     // The load node has the control of the preceding MemBarCPUOrder.  All
2713     // following nodes will have the control of the MemBarCPUOrder inserted at
2714     // the end of this method.  So, pushing the load onto the stack at a later
2715     // point is fine.
2716     set_result(p);
2717   } else {
2718     if (bt == T_ADDRESS) {
2719       // Repackage the long as a pointer.
2720       val = ConvL2X(val);
2721       val = gvn().transform(new CastX2PNode(val));
2722     }
2723     if (type == T_INLINE_TYPE) {
2724       if (adr_type-&gt;isa_instptr() &amp;&amp; !mismatched) {
2725         ciInstanceKlass* holder = adr_type-&gt;is_instptr()-&gt;klass()-&gt;as_instance_klass();
2726         int offset = adr_type-&gt;is_instptr()-&gt;offset();
2727         val-&gt;as_InlineType()-&gt;store_flattened(this, base, base, holder, offset, decorators);
2728       } else {
2729         val-&gt;as_InlineType()-&gt;store_flattened(this, base, adr, NULL, 0, decorators);
2730       }
2731     } else {
2732       access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);
2733     }
2734   }
2735 
2736   if (argument(1)-&gt;is_InlineType() &amp;&amp; is_store) {
2737     Node* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(base)-&gt;inline_klass());
2738     value = value-&gt;as_InlineType()-&gt;make_larval(this, false);
2739     replace_in_map(argument(1), value);
2740   }
2741 
2742   return true;
2743 }
2744 
2745 bool LibraryCallKit::inline_unsafe_make_private_buffer() {
2746   Node* receiver = argument(0);
2747   Node* value = argument(1);
2748 
2749   receiver = null_check(receiver);
2750   if (stopped()) {
2751     return true;
2752   }
2753 
2754   if (!value-&gt;is_InlineType()) {
2755     return false;
2756   }
2757 
2758   set_result(value-&gt;as_InlineType()-&gt;make_larval(this, true));
2759 
2760   return true;
2761 }
2762 
2763 bool LibraryCallKit::inline_unsafe_finish_private_buffer() {
2764   Node* receiver = argument(0);
2765   Node* buffer = argument(1);
2766 
2767   receiver = null_check(receiver);
2768   if (stopped()) {
2769     return true;
2770   }
2771 
2772   if (!buffer-&gt;is_InlineType()) {
2773     return false;
2774   }
2775 
2776   InlineTypeNode* vt = buffer-&gt;as_InlineType();
2777   if (!vt-&gt;is_allocated(&amp;_gvn) || !_gvn.type(vt)-&gt;is_inlinetype()-&gt;larval()) {
2778     return false;
2779   }
2780 
2781   set_result(vt-&gt;finish_larval(this));
2782 
2783   return true;
2784 }
2785 
2786 //----------------------------inline_unsafe_load_store----------------------------
2787 // This method serves a couple of different customers (depending on LoadStoreKind):
2788 //
2789 // LS_cmp_swap:
2790 //
2791 //   boolean compareAndSetReference(Object o, long offset, Object expected, Object x);
2792 //   boolean compareAndSetInt(   Object o, long offset, int    expected, int    x);
2793 //   boolean compareAndSetLong(  Object o, long offset, long   expected, long   x);
2794 //
2795 // LS_cmp_swap_weak:
2796 //
2797 //   boolean weakCompareAndSetReference(       Object o, long offset, Object expected, Object x);
2798 //   boolean weakCompareAndSetReferencePlain(  Object o, long offset, Object expected, Object x);
2799 //   boolean weakCompareAndSetReferenceAcquire(Object o, long offset, Object expected, Object x);
2800 //   boolean weakCompareAndSetReferenceRelease(Object o, long offset, Object expected, Object x);
2801 //
2802 //   boolean weakCompareAndSetInt(          Object o, long offset, int    expected, int    x);
2803 //   boolean weakCompareAndSetIntPlain(     Object o, long offset, int    expected, int    x);
2804 //   boolean weakCompareAndSetIntAcquire(   Object o, long offset, int    expected, int    x);
2805 //   boolean weakCompareAndSetIntRelease(   Object o, long offset, int    expected, int    x);
2806 //
2807 //   boolean weakCompareAndSetLong(         Object o, long offset, long   expected, long   x);
2808 //   boolean weakCompareAndSetLongPlain(    Object o, long offset, long   expected, long   x);
2809 //   boolean weakCompareAndSetLongAcquire(  Object o, long offset, long   expected, long   x);
2810 //   boolean weakCompareAndSetLongRelease(  Object o, long offset, long   expected, long   x);
2811 //
2812 // LS_cmp_exchange:
2813 //
2814 //   Object compareAndExchangeReferenceVolatile(Object o, long offset, Object expected, Object x);
2815 //   Object compareAndExchangeReferenceAcquire( Object o, long offset, Object expected, Object x);
2816 //   Object compareAndExchangeReferenceRelease( Object o, long offset, Object expected, Object x);
2817 //
2818 //   Object compareAndExchangeIntVolatile(   Object o, long offset, Object expected, Object x);
2819 //   Object compareAndExchangeIntAcquire(    Object o, long offset, Object expected, Object x);
2820 //   Object compareAndExchangeIntRelease(    Object o, long offset, Object expected, Object x);
2821 //
2822 //   Object compareAndExchangeLongVolatile(  Object o, long offset, Object expected, Object x);
2823 //   Object compareAndExchangeLongAcquire(   Object o, long offset, Object expected, Object x);
2824 //   Object compareAndExchangeLongRelease(   Object o, long offset, Object expected, Object x);
2825 //
2826 // LS_get_add:
2827 //
2828 //   int  getAndAddInt( Object o, long offset, int  delta)
2829 //   long getAndAddLong(Object o, long offset, long delta)
2830 //
2831 // LS_get_set:
2832 //
2833 //   int    getAndSet(Object o, long offset, int    newValue)
2834 //   long   getAndSet(Object o, long offset, long   newValue)
2835 //   Object getAndSet(Object o, long offset, Object newValue)
2836 //
2837 bool LibraryCallKit::inline_unsafe_load_store(const BasicType type, const LoadStoreKind kind, const AccessKind access_kind) {
2838   // This basic scheme here is the same as inline_unsafe_access, but
2839   // differs in enough details that combining them would make the code
2840   // overly confusing.  (This is a true fact! I originally combined
2841   // them, but even I was confused by it!) As much code/comments as
2842   // possible are retained from inline_unsafe_access though to make
2843   // the correspondences clearer. - dl
2844 
2845   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2846 
2847   DecoratorSet decorators = C2_UNSAFE_ACCESS;
2848   decorators |= mo_decorator_for_access_kind(access_kind);
2849 
2850 #ifndef PRODUCT
2851   BasicType rtype;
2852   {
2853     ResourceMark rm;
2854     // Check the signatures.
2855     ciSignature* sig = callee()-&gt;signature();
2856     rtype = sig-&gt;return_type()-&gt;basic_type();
2857     switch(kind) {
2858       case LS_get_add:
2859       case LS_get_set: {
2860       // Check the signatures.
2861 #ifdef ASSERT
2862       assert(rtype == type, &quot;get and set must return the expected type&quot;);
2863       assert(sig-&gt;count() == 3, &quot;get and set has 3 arguments&quot;);
2864       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;get and set base is object&quot;);
2865       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;get and set offset is long&quot;);
2866       assert(sig-&gt;type_at(2)-&gt;basic_type() == type, &quot;get and set must take expected type as new value/delta&quot;);
2867       assert(access_kind == Volatile, &quot;mo is not passed to intrinsic nodes in current implementation&quot;);
2868 #endif // ASSERT
2869         break;
2870       }
2871       case LS_cmp_swap:
2872       case LS_cmp_swap_weak: {
2873       // Check the signatures.
2874 #ifdef ASSERT
2875       assert(rtype == T_BOOLEAN, &quot;CAS must return boolean&quot;);
2876       assert(sig-&gt;count() == 4, &quot;CAS has 4 arguments&quot;);
2877       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;CAS base is object&quot;);
2878       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;CAS offset is long&quot;);
2879 #endif // ASSERT
2880         break;
2881       }
2882       case LS_cmp_exchange: {
2883       // Check the signatures.
2884 #ifdef ASSERT
2885       assert(rtype == type, &quot;CAS must return the expected type&quot;);
2886       assert(sig-&gt;count() == 4, &quot;CAS has 4 arguments&quot;);
2887       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;CAS base is object&quot;);
2888       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;CAS offset is long&quot;);
2889 #endif // ASSERT
2890         break;
2891       }
2892       default:
2893         ShouldNotReachHere();
2894     }
2895   }
2896 #endif //PRODUCT
2897 
2898   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
2899 
2900   // Get arguments:
2901   Node* receiver = NULL;
2902   Node* base     = NULL;
2903   Node* offset   = NULL;
2904   Node* oldval   = NULL;
2905   Node* newval   = NULL;
2906   switch(kind) {
2907     case LS_cmp_swap:
2908     case LS_cmp_swap_weak:
2909     case LS_cmp_exchange: {
2910       const bool two_slot_type = type2size[type] == 2;
2911       receiver = argument(0);  // type: oop
2912       base     = argument(1);  // type: oop
2913       offset   = argument(2);  // type: long
2914       oldval   = argument(4);  // type: oop, int, or long
2915       newval   = argument(two_slot_type ? 6 : 5);  // type: oop, int, or long
2916       break;
2917     }
2918     case LS_get_add:
2919     case LS_get_set: {
2920       receiver = argument(0);  // type: oop
2921       base     = argument(1);  // type: oop
2922       offset   = argument(2);  // type: long
2923       oldval   = NULL;
2924       newval   = argument(4);  // type: oop, int, or long
2925       break;
2926     }
2927     default:
2928       ShouldNotReachHere();
2929   }
2930 
2931   // Build field offset expression.
2932   // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
2933   // to be plain byte offsets, which are also the same as those accepted
2934   // by oopDesc::field_addr.
2935   assert(Unsafe_field_offset_to_byte_offset(11) == 11, &quot;fieldOffset must be byte-scaled&quot;);
2936   // 32-bit machines ignore the high half of long offsets
2937   offset = ConvL2X(offset);
2938   Node* adr = make_unsafe_address(base, offset, ACCESS_WRITE | ACCESS_READ, type, false);
2939   const TypePtr *adr_type = _gvn.type(adr)-&gt;isa_ptr();
2940 
2941   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
2942   BasicType bt = alias_type-&gt;basic_type();
2943   if (bt != T_ILLEGAL &amp;&amp;
2944       (is_reference_type(bt) != (type == T_OBJECT))) {
2945     // Don&#39;t intrinsify mismatched object accesses.
2946     return false;
2947   }
2948 
2949   // For CAS, unlike inline_unsafe_access, there seems no point in
2950   // trying to refine types. Just use the coarse types here.
2951   assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
2952   const Type *value_type = Type::get_const_basic_type(type);
2953 
2954   switch (kind) {
2955     case LS_get_set:
2956     case LS_cmp_exchange: {
2957       if (type == T_OBJECT) {
2958         const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);
2959         if (tjp != NULL) {
2960           value_type = tjp;
2961         }
2962       }
2963       break;
2964     }
2965     case LS_cmp_swap:
2966     case LS_cmp_swap_weak:
2967     case LS_get_add:
2968       break;
2969     default:
2970       ShouldNotReachHere();
2971   }
2972 
2973   // Null check receiver.
2974   receiver = null_check(receiver);
2975   if (stopped()) {
2976     return true;
2977   }
2978 
2979   int alias_idx = C-&gt;get_alias_index(adr_type);
2980 
2981   if (is_reference_type(type)) {
2982     decorators |= IN_HEAP | ON_UNKNOWN_OOP_REF;
2983 
2984     // Transformation of a value which could be NULL pointer (CastPP #NULL)
2985     // could be delayed during Parse (for example, in adjust_map_after_if()).
2986     // Execute transformation here to avoid barrier generation in such case.
2987     if (_gvn.type(newval) == TypePtr::NULL_PTR)
2988       newval = _gvn.makecon(TypePtr::NULL_PTR);
2989 
2990     if (oldval != NULL &amp;&amp; _gvn.type(oldval) == TypePtr::NULL_PTR) {
2991       // Refine the value to a null constant, when it is known to be null
2992       oldval = _gvn.makecon(TypePtr::NULL_PTR);
2993     }
2994   }
2995 
2996   Node* result = NULL;
2997   switch (kind) {
2998     case LS_cmp_exchange: {
2999       result = access_atomic_cmpxchg_val_at(base, adr, adr_type, alias_idx,
3000                                             oldval, newval, value_type, type, decorators);
3001       break;
3002     }
3003     case LS_cmp_swap_weak:
3004       decorators |= C2_WEAK_CMPXCHG;
3005     case LS_cmp_swap: {
3006       result = access_atomic_cmpxchg_bool_at(base, adr, adr_type, alias_idx,
3007                                              oldval, newval, value_type, type, decorators);
3008       break;
3009     }
3010     case LS_get_set: {
3011       result = access_atomic_xchg_at(base, adr, adr_type, alias_idx,
3012                                      newval, value_type, type, decorators);
3013       break;
3014     }
3015     case LS_get_add: {
3016       result = access_atomic_add_at(base, adr, adr_type, alias_idx,
3017                                     newval, value_type, type, decorators);
3018       break;
3019     }
3020     default:
3021       ShouldNotReachHere();
3022   }
3023 
3024   assert(type2size[result-&gt;bottom_type()-&gt;basic_type()] == type2size[rtype], &quot;result type should match&quot;);
3025   set_result(result);
3026   return true;
3027 }
3028 
3029 bool LibraryCallKit::inline_unsafe_fence(vmIntrinsics::ID id) {
3030   // Regardless of form, don&#39;t allow previous ld/st to move down,
3031   // then issue acquire, release, or volatile mem_bar.
3032   insert_mem_bar(Op_MemBarCPUOrder);
3033   switch(id) {
3034     case vmIntrinsics::_loadFence:
3035       insert_mem_bar(Op_LoadFence);
3036       return true;
3037     case vmIntrinsics::_storeFence:
3038       insert_mem_bar(Op_StoreFence);
3039       return true;
3040     case vmIntrinsics::_fullFence:
3041       insert_mem_bar(Op_MemBarVolatile);
3042       return true;
3043     default:
3044       fatal_unexpected_iid(id);
3045       return false;
3046   }
3047 }
3048 
3049 bool LibraryCallKit::inline_onspinwait() {
3050   insert_mem_bar(Op_OnSpinWait);
3051   return true;
3052 }
3053 
3054 bool LibraryCallKit::klass_needs_init_guard(Node* kls) {
3055   if (!kls-&gt;is_Con()) {
3056     return true;
3057   }
3058   const TypeKlassPtr* klsptr = kls-&gt;bottom_type()-&gt;isa_klassptr();
3059   if (klsptr == NULL) {
3060     return true;
3061   }
3062   ciInstanceKlass* ik = klsptr-&gt;klass()-&gt;as_instance_klass();
3063   // don&#39;t need a guard for a klass that is already initialized
3064   return !ik-&gt;is_initialized();
3065 }
3066 
3067 //----------------------------inline_unsafe_writeback0-------------------------
3068 // public native void Unsafe.writeback0(long address)
3069 bool LibraryCallKit::inline_unsafe_writeback0() {
3070   if (!Matcher::has_match_rule(Op_CacheWB)) {
3071     return false;
3072   }
3073 #ifndef PRODUCT
3074   assert(Matcher::has_match_rule(Op_CacheWBPreSync), &quot;found match rule for CacheWB but not CacheWBPreSync&quot;);
3075   assert(Matcher::has_match_rule(Op_CacheWBPostSync), &quot;found match rule for CacheWB but not CacheWBPostSync&quot;);
3076   ciSignature* sig = callee()-&gt;signature();
3077   assert(sig-&gt;type_at(0)-&gt;basic_type() == T_LONG, &quot;Unsafe_writeback0 address is long!&quot;);
3078 #endif
3079   null_check_receiver();  // null-check, then ignore
3080   Node *addr = argument(1);
3081   addr = new CastX2PNode(addr);
3082   addr = _gvn.transform(addr);
3083   Node *flush = new CacheWBNode(control(), memory(TypeRawPtr::BOTTOM), addr);
3084   flush = _gvn.transform(flush);
3085   set_memory(flush, TypeRawPtr::BOTTOM);
3086   return true;
3087 }
3088 
3089 //----------------------------inline_unsafe_writeback0-------------------------
3090 // public native void Unsafe.writeback0(long address)
3091 bool LibraryCallKit::inline_unsafe_writebackSync0(bool is_pre) {
3092   if (is_pre &amp;&amp; !Matcher::has_match_rule(Op_CacheWBPreSync)) {
3093     return false;
3094   }
3095   if (!is_pre &amp;&amp; !Matcher::has_match_rule(Op_CacheWBPostSync)) {
3096     return false;
3097   }
3098 #ifndef PRODUCT
3099   assert(Matcher::has_match_rule(Op_CacheWB),
3100          (is_pre ? &quot;found match rule for CacheWBPreSync but not CacheWB&quot;
3101                 : &quot;found match rule for CacheWBPostSync but not CacheWB&quot;));
3102 
3103 #endif
3104   null_check_receiver();  // null-check, then ignore
3105   Node *sync;
3106   if (is_pre) {
3107     sync = new CacheWBPreSyncNode(control(), memory(TypeRawPtr::BOTTOM));
3108   } else {
3109     sync = new CacheWBPostSyncNode(control(), memory(TypeRawPtr::BOTTOM));
3110   }
3111   sync = _gvn.transform(sync);
3112   set_memory(sync, TypeRawPtr::BOTTOM);
3113   return true;
3114 }
3115 
3116 //----------------------------inline_unsafe_allocate---------------------------
3117 // public native Object Unsafe.allocateInstance(Class&lt;?&gt; cls);
3118 bool LibraryCallKit::inline_unsafe_allocate() {
3119   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
3120 
3121   null_check_receiver();  // null-check, then ignore
3122   Node* cls = null_check(argument(1));
3123   if (stopped())  return true;
3124 
3125   Node* kls = load_klass_from_mirror(cls, false, NULL, 0);
3126   kls = null_check(kls);
3127   if (stopped())  return true;  // argument was like int.class
3128 
3129   Node* test = NULL;
3130   if (LibraryCallKit::klass_needs_init_guard(kls)) {
3131     // Note:  The argument might still be an illegal value like
3132     // Serializable.class or Object[].class.   The runtime will handle it.
3133     // But we must make an explicit check for initialization.
3134     Node* insp = basic_plus_adr(kls, in_bytes(InstanceKlass::init_state_offset()));
3135     // Use T_BOOLEAN for InstanceKlass::_init_state so the compiler
3136     // can generate code to load it as unsigned byte.
3137     Node* inst = make_load(NULL, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);
3138     Node* bits = intcon(InstanceKlass::fully_initialized);
3139     test = _gvn.transform(new SubINode(inst, bits));
3140     // The &#39;test&#39; is non-zero if we need to take a slow path.
3141   }
3142 
3143   Node* obj = new_instance(kls, test);
3144   set_result(obj);
3145   return true;
3146 }
3147 
3148 //------------------------inline_native_time_funcs--------------
3149 // inline code for System.currentTimeMillis() and System.nanoTime()
3150 // these have the same type and signature
3151 bool LibraryCallKit::inline_native_time_funcs(address funcAddr, const char* funcName) {
3152   const TypeFunc* tf = OptoRuntime::void_long_Type();
3153   const TypePtr* no_memory_effects = NULL;
3154   Node* time = make_runtime_call(RC_LEAF, tf, funcAddr, funcName, no_memory_effects);
3155   Node* value = _gvn.transform(new ProjNode(time, TypeFunc::Parms+0));
3156 #ifdef ASSERT
3157   Node* value_top = _gvn.transform(new ProjNode(time, TypeFunc::Parms+1));
3158   assert(value_top == top(), &quot;second value must be top&quot;);
3159 #endif
3160   set_result(value);
3161   return true;
3162 }
3163 
3164 #ifdef JFR_HAVE_INTRINSICS
3165 
3166 /*
3167 * oop -&gt; myklass
3168 * myklass-&gt;trace_id |= USED
3169 * return myklass-&gt;trace_id &amp; ~0x3
3170 */
3171 bool LibraryCallKit::inline_native_classID() {
3172   Node* cls = null_check(argument(0), T_OBJECT);
3173   Node* kls = load_klass_from_mirror(cls, false, NULL, 0);
3174   kls = null_check(kls, T_OBJECT);
3175 
3176   ByteSize offset = KLASS_TRACE_ID_OFFSET;
3177   Node* insp = basic_plus_adr(kls, in_bytes(offset));
3178   Node* tvalue = make_load(NULL, insp, TypeLong::LONG, T_LONG, MemNode::unordered);
3179 
3180   Node* clsused = longcon(0x01l); // set the class bit
3181   Node* orl = _gvn.transform(new OrLNode(tvalue, clsused));
3182   const TypePtr *adr_type = _gvn.type(insp)-&gt;isa_ptr();
3183   store_to_memory(control(), insp, orl, T_LONG, adr_type, MemNode::unordered);
3184 
3185 #ifdef TRACE_ID_META_BITS
3186   Node* mbits = longcon(~TRACE_ID_META_BITS);
3187   tvalue = _gvn.transform(new AndLNode(tvalue, mbits));
3188 #endif
3189 #ifdef TRACE_ID_SHIFT
3190   Node* cbits = intcon(TRACE_ID_SHIFT);
3191   tvalue = _gvn.transform(new URShiftLNode(tvalue, cbits));
3192 #endif
3193 
3194   set_result(tvalue);
3195   return true;
3196 
3197 }
3198 
3199 bool LibraryCallKit::inline_native_getEventWriter() {
3200   Node* tls_ptr = _gvn.transform(new ThreadLocalNode());
3201 
3202   Node* jobj_ptr = basic_plus_adr(top(), tls_ptr,
3203                                   in_bytes(THREAD_LOCAL_WRITER_OFFSET_JFR));
3204 
3205   Node* jobj = make_load(control(), jobj_ptr, TypeRawPtr::BOTTOM, T_ADDRESS, MemNode::unordered);
3206 
3207   Node* jobj_cmp_null = _gvn.transform( new CmpPNode(jobj, null()) );
3208   Node* test_jobj_eq_null  = _gvn.transform( new BoolNode(jobj_cmp_null, BoolTest::eq) );
3209 
3210   IfNode* iff_jobj_null =
3211     create_and_map_if(control(), test_jobj_eq_null, PROB_MIN, COUNT_UNKNOWN);
3212 
3213   enum { _normal_path = 1,
3214          _null_path = 2,
3215          PATH_LIMIT };
3216 
3217   RegionNode* result_rgn = new RegionNode(PATH_LIMIT);
3218   PhiNode*    result_val = new PhiNode(result_rgn, TypeInstPtr::BOTTOM);
3219 
3220   Node* jobj_is_null = _gvn.transform(new IfTrueNode(iff_jobj_null));
3221   result_rgn-&gt;init_req(_null_path, jobj_is_null);
3222   result_val-&gt;init_req(_null_path, null());
3223 
3224   Node* jobj_is_not_null = _gvn.transform(new IfFalseNode(iff_jobj_null));
3225   set_control(jobj_is_not_null);
3226   Node* res = access_load(jobj, TypeInstPtr::NOTNULL, T_OBJECT,
3227                           IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);
3228   result_rgn-&gt;init_req(_normal_path, control());
3229   result_val-&gt;init_req(_normal_path, res);
3230 
3231   set_result(result_rgn, result_val);
3232 
3233   return true;
3234 }
3235 
3236 #endif // JFR_HAVE_INTRINSICS
3237 
3238 //------------------------inline_native_currentThread------------------
3239 bool LibraryCallKit::inline_native_currentThread() {
3240   Node* junk = NULL;
3241   set_result(generate_current_thread(junk));
3242   return true;
3243 }
3244 
3245 //-----------------------load_klass_from_mirror_common-------------------------
3246 // Given a java mirror (a java.lang.Class oop), load its corresponding klass oop.
3247 // Test the klass oop for null (signifying a primitive Class like Integer.TYPE),
3248 // and branch to the given path on the region.
3249 // If never_see_null, take an uncommon trap on null, so we can optimistically
3250 // compile for the non-null case.
3251 // If the region is NULL, force never_see_null = true.
3252 Node* LibraryCallKit::load_klass_from_mirror_common(Node* mirror,
3253                                                     bool never_see_null,
3254                                                     RegionNode* region,
3255                                                     int null_path,
3256                                                     int offset) {
3257   if (region == NULL)  never_see_null = true;
3258   Node* p = basic_plus_adr(mirror, offset);
3259   const TypeKlassPtr*  kls_type = TypeKlassPtr::OBJECT_OR_NULL;
3260   Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));
3261   Node* null_ctl = top();
3262   kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
3263   if (region != NULL) {
3264     // Set region-&gt;in(null_path) if the mirror is a primitive (e.g, int.class).
3265     region-&gt;init_req(null_path, null_ctl);
3266   } else {
3267     assert(null_ctl == top(), &quot;no loose ends&quot;);
3268   }
3269   return kls;
3270 }
3271 
3272 //--------------------(inline_native_Class_query helpers)---------------------
3273 // Use this for JVM_ACC_INTERFACE, JVM_ACC_IS_CLONEABLE_FAST, JVM_ACC_HAS_FINALIZER.
3274 // Fall through if (mods &amp; mask) == bits, take the guard otherwise.
3275 Node* LibraryCallKit::generate_access_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region) {
3276   // Branch around if the given klass has the given modifier bit set.
3277   // Like generate_guard, adds a new path onto the region.
3278   Node* modp = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));
3279   Node* mods = make_load(NULL, modp, TypeInt::INT, T_INT, MemNode::unordered);
3280   Node* mask = intcon(modifier_mask);
3281   Node* bits = intcon(modifier_bits);
3282   Node* mbit = _gvn.transform(new AndINode(mods, mask));
3283   Node* cmp  = _gvn.transform(new CmpINode(mbit, bits));
3284   Node* bol  = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
3285   return generate_fair_guard(bol, region);
3286 }
3287 
3288 Node* LibraryCallKit::generate_interface_guard(Node* kls, RegionNode* region) {
3289   return generate_access_flags_guard(kls, JVM_ACC_INTERFACE, 0, region);
3290 }
3291 Node* LibraryCallKit::generate_hidden_class_guard(Node* kls, RegionNode* region) {
3292   return generate_access_flags_guard(kls, JVM_ACC_IS_HIDDEN_CLASS, 0, region);
3293 }
3294 
3295 Node* LibraryCallKit::generate_value_guard(Node* kls, RegionNode* region) {
3296   return generate_access_flags_guard(kls, JVM_ACC_INLINE, 0, region);
3297 }
3298 
3299 //-------------------------inline_native_Class_query-------------------
3300 bool LibraryCallKit::inline_native_Class_query(vmIntrinsics::ID id) {
3301   const Type* return_type = TypeInt::BOOL;
3302   Node* prim_return_value = top();  // what happens if it&#39;s a primitive class?
3303   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3304   bool expect_prim = false;     // most of these guys expect to work on refs
3305 
3306   enum { _normal_path = 1, _prim_path = 2, PATH_LIMIT };
3307 
3308   Node* mirror = argument(0);
3309   Node* obj    = top();
3310 
3311   switch (id) {
3312   case vmIntrinsics::_isInstance:
3313     // nothing is an instance of a primitive type
3314     prim_return_value = intcon(0);
3315     obj = argument(1);
3316     break;
3317   case vmIntrinsics::_getModifiers:
3318     prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);
3319     assert(is_power_of_2((int)JVM_ACC_WRITTEN_FLAGS+1), &quot;change next line&quot;);
3320     return_type = TypeInt::make(0, JVM_ACC_WRITTEN_FLAGS, Type::WidenMin);
3321     break;
3322   case vmIntrinsics::_isInterface:
3323     prim_return_value = intcon(0);
3324     break;
3325   case vmIntrinsics::_isArray:
3326     prim_return_value = intcon(0);
3327     expect_prim = true;  // cf. ObjectStreamClass.getClassSignature
3328     break;
3329   case vmIntrinsics::_isPrimitive:
3330     prim_return_value = intcon(1);
3331     expect_prim = true;  // obviously
3332     break;
3333   case vmIntrinsics::_isHidden:
3334     prim_return_value = intcon(0);
3335     break;
3336   case vmIntrinsics::_getSuperclass:
3337     prim_return_value = null();
3338     return_type = TypeInstPtr::MIRROR-&gt;cast_to_ptr_type(TypePtr::BotPTR);
3339     break;
3340   case vmIntrinsics::_getClassAccessFlags:
3341     prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);
3342     return_type = TypeInt::INT;  // not bool!  6297094
3343     break;
3344   default:
3345     fatal_unexpected_iid(id);
3346     break;
3347   }
3348 
3349   const TypeInstPtr* mirror_con = _gvn.type(mirror)-&gt;isa_instptr();
3350   if (mirror_con == NULL)  return false;  // cannot happen?
3351 
3352 #ifndef PRODUCT
3353   if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
3354     ciType* k = mirror_con-&gt;java_mirror_type();
3355     if (k) {
3356       tty-&gt;print(&quot;Inlining %s on constant Class &quot;, vmIntrinsics::name_at(intrinsic_id()));
3357       k-&gt;print_name();
3358       tty-&gt;cr();
3359     }
3360   }
3361 #endif
3362 
3363   // Null-check the mirror, and the mirror&#39;s klass ptr (in case it is a primitive).
3364   RegionNode* region = new RegionNode(PATH_LIMIT);
3365   record_for_igvn(region);
3366   PhiNode* phi = new PhiNode(region, return_type);
3367 
3368   // The mirror will never be null of Reflection.getClassAccessFlags, however
3369   // it may be null for Class.isInstance or Class.getModifiers. Throw a NPE
3370   // if it is. See bug 4774291.
3371 
3372   // For Reflection.getClassAccessFlags(), the null check occurs in
3373   // the wrong place; see inline_unsafe_access(), above, for a similar
3374   // situation.
3375   mirror = null_check(mirror);
3376   // If mirror or obj is dead, only null-path is taken.
3377   if (stopped())  return true;
3378 
3379   if (expect_prim)  never_see_null = false;  // expect nulls (meaning prims)
3380 
3381   // Now load the mirror&#39;s klass metaobject, and null-check it.
3382   // Side-effects region with the control path if the klass is null.
3383   Node* kls = load_klass_from_mirror(mirror, never_see_null, region, _prim_path);
3384   // If kls is null, we have a primitive mirror.
3385   phi-&gt;init_req(_prim_path, prim_return_value);
3386   if (stopped()) { set_result(region, phi); return true; }
3387   bool safe_for_replace = (region-&gt;in(_prim_path) == top());
3388 
3389   Node* p;  // handy temp
3390   Node* null_ctl;
3391 
3392   // Now that we have the non-null klass, we can perform the real query.
3393   // For constant classes, the query will constant-fold in LoadNode::Value.
3394   Node* query_value = top();
3395   switch (id) {
3396   case vmIntrinsics::_isInstance:
3397     // nothing is an instance of a primitive type
3398     query_value = gen_instanceof(obj, kls, safe_for_replace);
3399     break;
3400 
3401   case vmIntrinsics::_getModifiers:
3402     p = basic_plus_adr(kls, in_bytes(Klass::modifier_flags_offset()));
3403     query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);
3404     break;
3405 
3406   case vmIntrinsics::_isInterface:
3407     // (To verify this code sequence, check the asserts in JVM_IsInterface.)
3408     if (generate_interface_guard(kls, region) != NULL)
3409       // A guard was added.  If the guard is taken, it was an interface.
3410       phi-&gt;add_req(intcon(1));
3411     // If we fall through, it&#39;s a plain class.
3412     query_value = intcon(0);
3413     break;
3414 
3415   case vmIntrinsics::_isArray:
3416     // (To verify this code sequence, check the asserts in JVM_IsArrayClass.)
3417     if (generate_array_guard(kls, region) != NULL)
3418       // A guard was added.  If the guard is taken, it was an array.
3419       phi-&gt;add_req(intcon(1));
3420     // If we fall through, it&#39;s a plain class.
3421     query_value = intcon(0);
3422     break;
3423 
3424   case vmIntrinsics::_isPrimitive:
3425     query_value = intcon(0); // &quot;normal&quot; path produces false
3426     break;
3427 
3428   case vmIntrinsics::_isHidden:
3429     // (To verify this code sequence, check the asserts in JVM_IsHiddenClass.)
3430     if (generate_hidden_class_guard(kls, region) != NULL)
3431       // A guard was added.  If the guard is taken, it was an hidden class.
3432       phi-&gt;add_req(intcon(1));
3433     // If we fall through, it&#39;s a plain class.
3434     query_value = intcon(0);
3435     break;
3436 
3437 
3438   case vmIntrinsics::_getSuperclass:
3439     // The rules here are somewhat unfortunate, but we can still do better
3440     // with random logic than with a JNI call.
3441     // Interfaces store null or Object as _super, but must report null.
3442     // Arrays store an intermediate super as _super, but must report Object.
3443     // Other types can report the actual _super.
3444     // (To verify this code sequence, check the asserts in JVM_IsInterface.)
3445     if (generate_interface_guard(kls, region) != NULL)
3446       // A guard was added.  If the guard is taken, it was an interface.
3447       phi-&gt;add_req(null());
3448     if (generate_array_guard(kls, region) != NULL)
3449       // A guard was added.  If the guard is taken, it was an array.
3450       phi-&gt;add_req(makecon(TypeInstPtr::make(env()-&gt;Object_klass()-&gt;java_mirror())));
3451     // If we fall through, it&#39;s a plain class.  Get its _super.
3452     p = basic_plus_adr(kls, in_bytes(Klass::super_offset()));
3453     kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));
3454     null_ctl = top();
3455     kls = null_check_oop(kls, &amp;null_ctl);
3456     if (null_ctl != top()) {
3457       // If the guard is taken, Object.superClass is null (both klass and mirror).
3458       region-&gt;add_req(null_ctl);
3459       phi   -&gt;add_req(null());
3460     }
3461     if (!stopped()) {
3462       query_value = load_mirror_from_klass(kls);
3463     }
3464     break;
3465 
3466   case vmIntrinsics::_getClassAccessFlags:
3467     p = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));
3468     query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);
3469     break;
3470 
3471   default:
3472     fatal_unexpected_iid(id);
3473     break;
3474   }
3475 
3476   // Fall-through is the normal case of a query to a real class.
3477   phi-&gt;init_req(1, query_value);
3478   region-&gt;init_req(1, control());
3479 
3480   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3481   set_result(region, phi);
3482   return true;
3483 }
3484 
3485 //-------------------------inline_Class_cast-------------------
3486 bool LibraryCallKit::inline_Class_cast() {
3487   Node* mirror = argument(0); // Class
3488   Node* obj    = argument(1);
3489   const TypeInstPtr* mirror_con = _gvn.type(mirror)-&gt;isa_instptr();
3490   if (mirror_con == NULL) {
3491     return false;  // dead path (mirror-&gt;is_top()).
3492   }
3493   if (obj == NULL || obj-&gt;is_top()) {
3494     return false;  // dead path
3495   }
3496   ciKlass* obj_klass = NULL;
3497   const Type* obj_t = _gvn.type(obj);
3498   if (obj-&gt;is_InlineType()) {
3499     obj_klass = obj_t-&gt;inline_klass();
3500   } else if (obj_t-&gt;isa_oopptr()) {
3501     obj_klass = obj_t-&gt;is_oopptr()-&gt;klass();
3502   }
3503 
3504   // First, see if Class.cast() can be folded statically.
3505   // java_mirror_type() returns non-null for compile-time Class constants.
3506   ciType* tm = mirror_con-&gt;java_mirror_type();
3507   if (tm != NULL &amp;&amp; tm-&gt;is_klass() &amp;&amp; obj_klass != NULL) {
3508     if (!obj_klass-&gt;is_loaded()) {
3509       // Don&#39;t use intrinsic when class is not loaded.
3510       return false;
3511     } else {
3512       if (!obj-&gt;is_InlineType() &amp;&amp; tm-&gt;as_klass()-&gt;is_inlinetype()) {
3513         // Casting to .val, check for null
3514         obj = null_check(obj);
3515         if (stopped()) {
3516           return true;
3517         }
3518       }
3519       int static_res = C-&gt;static_subtype_check(tm-&gt;as_klass(), obj_klass);
3520       if (static_res == Compile::SSC_always_true) {
3521         // isInstance() is true - fold the code.
3522         set_result(obj);
3523         return true;
3524       } else if (static_res == Compile::SSC_always_false) {
3525         // Don&#39;t use intrinsic, have to throw ClassCastException.
3526         // If the reference is null, the non-intrinsic bytecode will
3527         // be optimized appropriately.
3528         return false;
3529       }
3530     }
3531   }
3532 
3533   // Bailout intrinsic and do normal inlining if exception path is frequent.
3534   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
3535     return false;
3536   }
3537 
3538   // Generate dynamic checks.
3539   // Class.cast() is java implementation of _checkcast bytecode.
3540   // Do checkcast (Parse::do_checkcast()) optimizations here.
3541 
3542   mirror = null_check(mirror);
3543   // If mirror is dead, only null-path is taken.
3544   if (stopped()) {
3545     return true;
3546   }
3547 
3548   // Not-subtype or the mirror&#39;s klass ptr is NULL (in case it is a primitive).
3549   enum { _bad_type_path = 1, _prim_path = 2, _npe_path = 3, PATH_LIMIT };
3550   RegionNode* region = new RegionNode(PATH_LIMIT);
3551   record_for_igvn(region);
3552 
3553   // Now load the mirror&#39;s klass metaobject, and null-check it.
3554   // If kls is null, we have a primitive mirror and
3555   // nothing is an instance of a primitive type.
3556   Node* kls = load_klass_from_mirror(mirror, false, region, _prim_path);
3557 
3558   Node* res = top();
3559   if (!stopped()) {
3560     if (EnableValhalla &amp;&amp; !obj-&gt;is_InlineType()) {
3561       // Check if we are casting to .val
3562       Node* is_val_kls = generate_value_guard(kls, NULL);
3563       if (is_val_kls != NULL) {
3564         RegionNode* r = new RegionNode(3);
3565         record_for_igvn(r);
3566         r-&gt;init_req(1, control());
3567 
3568         // Casting to .val, check for null
3569         set_control(is_val_kls);
3570         Node* null_ctr = top();
3571         null_check_oop(obj, &amp;null_ctr);
3572         region-&gt;init_req(_npe_path, null_ctr);
3573         r-&gt;init_req(2, control());
3574 
3575         set_control(_gvn.transform(r));
3576       }
3577     }
3578 
3579     Node* bad_type_ctrl = top();
3580     // Do checkcast optimizations.
3581     res = gen_checkcast(obj, kls, &amp;bad_type_ctrl);
3582     region-&gt;init_req(_bad_type_path, bad_type_ctrl);
3583   }
3584   if (region-&gt;in(_prim_path) != top() ||
3585       region-&gt;in(_bad_type_path) != top() ||
3586       region-&gt;in(_npe_path) != top()) {
3587     // Let Interpreter throw ClassCastException.
3588     PreserveJVMState pjvms(this);
3589     set_control(_gvn.transform(region));
3590     uncommon_trap(Deoptimization::Reason_intrinsic,
3591                   Deoptimization::Action_maybe_recompile);
3592   }
3593   if (!stopped()) {
3594     set_result(res);
3595   }
3596   return true;
3597 }
3598 
3599 
3600 //--------------------------inline_native_subtype_check------------------------
3601 // This intrinsic takes the JNI calls out of the heart of
3602 // UnsafeFieldAccessorImpl.set, which improves Field.set, readObject, etc.
3603 bool LibraryCallKit::inline_native_subtype_check() {
3604   // Pull both arguments off the stack.
3605   Node* args[2];                // two java.lang.Class mirrors: superc, subc
3606   args[0] = argument(0);
3607   args[1] = argument(1);
3608   Node* klasses[2];             // corresponding Klasses: superk, subk
3609   klasses[0] = klasses[1] = top();
3610 
3611   enum {
3612     // A full decision tree on {superc is prim, subc is prim}:
3613     _prim_0_path = 1,           // {P,N} =&gt; false
3614                                 // {P,P} &amp; superc!=subc =&gt; false
3615     _prim_same_path,            // {P,P} &amp; superc==subc =&gt; true
3616     _prim_1_path,               // {N,P} =&gt; false
3617     _ref_subtype_path,          // {N,N} &amp; subtype check wins =&gt; true
3618     _both_ref_path,             // {N,N} &amp; subtype check loses =&gt; false
3619     PATH_LIMIT
3620   };
3621 
3622   RegionNode* region = new RegionNode(PATH_LIMIT);
3623   RegionNode* prim_region = new RegionNode(2);
3624   Node*       phi    = new PhiNode(region, TypeInt::BOOL);
3625   record_for_igvn(region);
3626   record_for_igvn(prim_region);
3627 
3628   const TypePtr* adr_type = TypeRawPtr::BOTTOM;   // memory type of loads
3629   const TypeKlassPtr* kls_type = TypeKlassPtr::OBJECT_OR_NULL;
3630   int class_klass_offset = java_lang_Class::klass_offset();
3631 
3632   // First null-check both mirrors and load each mirror&#39;s klass metaobject.
3633   int which_arg;
3634   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3635     Node* arg = args[which_arg];
3636     arg = null_check(arg);
3637     if (stopped())  break;
3638     args[which_arg] = arg;
3639 
3640     Node* p = basic_plus_adr(arg, class_klass_offset);
3641     Node* kls = LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, adr_type, kls_type);
3642     klasses[which_arg] = _gvn.transform(kls);
3643   }
3644 
3645   // Having loaded both klasses, test each for null.
3646   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3647   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3648     Node* kls = klasses[which_arg];
3649     Node* null_ctl = top();
3650     kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
3651     if (which_arg == 0) {
3652       prim_region-&gt;init_req(1, null_ctl);
3653     } else {
3654       region-&gt;init_req(_prim_1_path, null_ctl);
3655     }
3656     if (stopped())  break;
3657     klasses[which_arg] = kls;
3658   }
3659 
3660   if (!stopped()) {
3661     // now we have two reference types, in klasses[0..1]
3662     Node* subk   = klasses[1];  // the argument to isAssignableFrom
3663     Node* superk = klasses[0];  // the receiver
3664     region-&gt;set_req(_both_ref_path, gen_subtype_check(subk, superk));
3665     // now we have a successful reference subtype check
3666     region-&gt;set_req(_ref_subtype_path, control());
3667   }
3668 
3669   // If both operands are primitive (both klasses null), then
3670   // we must return true when they are identical primitives.
3671   // It is convenient to test this after the first null klass check.
3672   // This path is also used if superc is a value mirror.
3673   set_control(_gvn.transform(prim_region));
3674   if (!stopped()) {
3675     // Since superc is primitive, make a guard for the superc==subc case.
3676     Node* cmp_eq = _gvn.transform(new CmpPNode(args[0], args[1]));
3677     Node* bol_eq = _gvn.transform(new BoolNode(cmp_eq, BoolTest::eq));
3678     generate_fair_guard(bol_eq, region);
3679     if (region-&gt;req() == PATH_LIMIT+1) {
3680       // A guard was added.  If the added guard is taken, superc==subc.
3681       region-&gt;swap_edges(PATH_LIMIT, _prim_same_path);
3682       region-&gt;del_req(PATH_LIMIT);
3683     }
3684     region-&gt;set_req(_prim_0_path, control()); // Not equal after all.
3685   }
3686 
3687   // these are the only paths that produce &#39;true&#39;:
3688   phi-&gt;set_req(_prim_same_path,   intcon(1));
3689   phi-&gt;set_req(_ref_subtype_path, intcon(1));
3690 
3691   // pull together the cases:
3692   assert(region-&gt;req() == PATH_LIMIT, &quot;sane region&quot;);
3693   for (uint i = 1; i &lt; region-&gt;req(); i++) {
3694     Node* ctl = region-&gt;in(i);
3695     if (ctl == NULL || ctl == top()) {
3696       region-&gt;set_req(i, top());
3697       phi   -&gt;set_req(i, top());
3698     } else if (phi-&gt;in(i) == NULL) {
3699       phi-&gt;set_req(i, intcon(0)); // all other paths produce &#39;false&#39;
3700     }
3701   }
3702 
3703   set_control(_gvn.transform(region));
3704   set_result(_gvn.transform(phi));
3705   return true;
3706 }
3707 
3708 //---------------------generate_array_guard_common------------------------
3709 Node* LibraryCallKit::generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind) {
3710 
3711   if (stopped()) {
3712     return NULL;
3713   }
3714 
3715   // Like generate_guard, adds a new path onto the region.
3716   jint  layout_con = 0;
3717   Node* layout_val = get_layout_helper(kls, layout_con);
3718   if (layout_val == NULL) {
3719     bool query = 0;
3720     switch(kind) {
3721       case ObjectArray:    query = Klass::layout_helper_is_objArray(layout_con); break;
3722       case NonObjectArray: query = !Klass::layout_helper_is_objArray(layout_con); break;
3723       case TypeArray:      query = Klass::layout_helper_is_typeArray(layout_con); break;
3724       case FlatArray:      query = Klass::layout_helper_is_flatArray(layout_con); break;
3725       case AnyArray:       query = Klass::layout_helper_is_array(layout_con); break;
3726       case NonArray:       query = !Klass::layout_helper_is_array(layout_con); break;
3727       default:
3728         ShouldNotReachHere();
3729     }
3730     if (!query) {
3731       return NULL;                       // never a branch
3732     } else {                             // always a branch
3733       Node* always_branch = control();
3734       if (region != NULL)
3735         region-&gt;add_req(always_branch);
3736       set_control(top());
3737       return always_branch;
3738     }
3739   }
3740   unsigned int value = 0;
3741   BoolTest::mask btest = BoolTest::illegal;
3742   switch(kind) {
3743     case ObjectArray:
3744     case NonObjectArray: {
3745       value = Klass::_lh_array_tag_obj_value;
3746       layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));
3747       btest = kind == ObjectArray ? BoolTest::eq : BoolTest::ne;
3748       break;
3749     }
3750     case TypeArray: {
3751       value = Klass::_lh_array_tag_type_value;
3752       layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));
3753       btest = BoolTest::eq;
3754       break;
3755     }
3756     case FlatArray: {
3757       value = Klass::_lh_array_tag_vt_value;
3758       layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));
3759       btest = BoolTest::eq;
3760       break;
3761     }
3762     case AnyArray:    value = Klass::_lh_neutral_value; btest = BoolTest::lt; break;
3763     case NonArray:    value = Klass::_lh_neutral_value; btest = BoolTest::gt; break;
3764     default:
3765       ShouldNotReachHere();
3766   }
3767   // Now test the correct condition.
3768   jint nval = (jint)value;
3769   Node* cmp = _gvn.transform(new CmpINode(layout_val, intcon(nval)));
3770   Node* bol = _gvn.transform(new BoolNode(cmp, btest));
3771   return generate_fair_guard(bol, region);
3772 }
3773 
3774 
3775 //-----------------------inline_native_newArray--------------------------
3776 // private static native Object java.lang.reflect.Array.newArray(Class&lt;?&gt; componentType, int length);
3777 // private        native Object Unsafe.allocateUninitializedArray0(Class&lt;?&gt; cls, int size);
3778 bool LibraryCallKit::inline_unsafe_newArray(bool uninitialized) {
3779   Node* mirror;
3780   Node* count_val;
3781   if (uninitialized) {
3782     mirror    = argument(1);
3783     count_val = argument(2);
3784   } else {
3785     mirror    = argument(0);
3786     count_val = argument(1);
3787   }
3788 
3789   mirror = null_check(mirror);
3790   // If mirror or obj is dead, only null-path is taken.
3791   if (stopped())  return true;
3792 
3793   enum { _normal_path = 1, _slow_path = 2, PATH_LIMIT };
3794   RegionNode* result_reg = new RegionNode(PATH_LIMIT);
3795   PhiNode*    result_val = new PhiNode(result_reg, TypeInstPtr::NOTNULL);
3796   PhiNode*    result_io  = new PhiNode(result_reg, Type::ABIO);
3797   PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
3798 
3799   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3800   Node* klass_node = load_array_klass_from_mirror(mirror, never_see_null,
3801                                                   result_reg, _slow_path);
3802   Node* normal_ctl   = control();
3803   Node* no_array_ctl = result_reg-&gt;in(_slow_path);
3804 
3805   // Generate code for the slow case.  We make a call to newArray().
3806   set_control(no_array_ctl);
3807   if (!stopped()) {
3808     // Either the input type is void.class, or else the
3809     // array klass has not yet been cached.  Either the
3810     // ensuing call will throw an exception, or else it
3811     // will cache the array klass for next time.
3812     PreserveJVMState pjvms(this);
3813     CallJavaNode* slow_call = generate_method_call_static(vmIntrinsics::_newArray);
3814     Node* slow_result = set_results_for_java_call(slow_call);
3815     // this-&gt;control() comes from set_results_for_java_call
3816     result_reg-&gt;set_req(_slow_path, control());
3817     result_val-&gt;set_req(_slow_path, slow_result);
3818     result_io -&gt;set_req(_slow_path, i_o());
3819     result_mem-&gt;set_req(_slow_path, reset_memory());
3820   }
3821 
3822   set_control(normal_ctl);
3823   if (!stopped()) {
3824     // Normal case:  The array type has been cached in the java.lang.Class.
3825     // The following call works fine even if the array type is polymorphic.
3826     // It could be a dynamic mix of int[], boolean[], Object[], etc.
3827     Node* obj = new_array(klass_node, count_val, 0);  // no arguments to push
3828     result_reg-&gt;init_req(_normal_path, control());
3829     result_val-&gt;init_req(_normal_path, obj);
3830     result_io -&gt;init_req(_normal_path, i_o());
3831     result_mem-&gt;init_req(_normal_path, reset_memory());
3832 
3833     if (uninitialized) {
3834       // Mark the allocation so that zeroing is skipped
3835       AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(obj, &amp;_gvn);
3836       alloc-&gt;maybe_set_complete(&amp;_gvn);
3837     }
3838   }
3839 
3840   // Return the combined state.
3841   set_i_o(        _gvn.transform(result_io)  );
3842   set_all_memory( _gvn.transform(result_mem));
3843 
3844   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3845   set_result(result_reg, result_val);
3846   return true;
3847 }
3848 
3849 //----------------------inline_native_getLength--------------------------
3850 // public static native int java.lang.reflect.Array.getLength(Object array);
3851 bool LibraryCallKit::inline_native_getLength() {
3852   if (too_many_traps(Deoptimization::Reason_intrinsic))  return false;
3853 
3854   Node* array = null_check(argument(0));
3855   // If array is dead, only null-path is taken.
3856   if (stopped())  return true;
3857 
3858   // Deoptimize if it is a non-array.
3859   Node* non_array = generate_non_array_guard(load_object_klass(array), NULL);
3860 
3861   if (non_array != NULL) {
3862     PreserveJVMState pjvms(this);
3863     set_control(non_array);
3864     uncommon_trap(Deoptimization::Reason_intrinsic,
3865                   Deoptimization::Action_maybe_recompile);
3866   }
3867 
3868   // If control is dead, only non-array-path is taken.
3869   if (stopped())  return true;
3870 
3871   // The works fine even if the array type is polymorphic.
3872   // It could be a dynamic mix of int[], boolean[], Object[], etc.
3873   Node* result = load_array_length(array);
3874 
3875   C-&gt;set_has_split_ifs(true);  // Has chance for split-if optimization
3876   set_result(result);
3877   return true;
3878 }
3879 
3880 //------------------------inline_array_copyOf----------------------------
3881 // public static &lt;T,U&gt; T[] java.util.Arrays.copyOf(     U[] original, int newLength,         Class&lt;? extends T[]&gt; newType);
3882 // public static &lt;T,U&gt; T[] java.util.Arrays.copyOfRange(U[] original, int from,      int to, Class&lt;? extends T[]&gt; newType);
3883 bool LibraryCallKit::inline_array_copyOf(bool is_copyOfRange) {
3884   if (too_many_traps(Deoptimization::Reason_intrinsic))  return false;
3885 
3886   // Get the arguments.
3887   Node* original          = argument(0);
3888   Node* start             = is_copyOfRange? argument(1): intcon(0);
3889   Node* end               = is_copyOfRange? argument(2): argument(1);
3890   Node* array_type_mirror = is_copyOfRange? argument(3): argument(2);
3891 
3892   Node* newcopy = NULL;
3893 
3894   // Set the original stack and the reexecute bit for the interpreter to reexecute
3895   // the bytecode that invokes Arrays.copyOf if deoptimization happens.
3896   { PreserveReexecuteState preexecs(this);
3897     jvms()-&gt;set_should_reexecute(true);
3898 
3899     array_type_mirror = null_check(array_type_mirror);
3900     original          = null_check(original);
3901 
3902     // Check if a null path was taken unconditionally.
3903     if (stopped())  return true;
3904 
3905     Node* orig_length = load_array_length(original);
3906 
3907     Node* klass_node = load_klass_from_mirror(array_type_mirror, false, NULL, 0);
3908     klass_node = null_check(klass_node);
3909 
3910     RegionNode* bailout = new RegionNode(1);
3911     record_for_igvn(bailout);
3912 
3913     // Despite the generic type of Arrays.copyOf, the mirror might be int, int[], etc.
3914     // Bail out if that is so.
3915     // Inline type array may have object field that would require a
3916     // write barrier. Conservatively, go to slow path.
3917     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
3918     Node* not_objArray = !bs-&gt;array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing) ?
3919         generate_typeArray_guard(klass_node, bailout) : generate_non_objArray_guard(klass_node, bailout);
3920     if (not_objArray != NULL) {
3921       // Improve the klass node&#39;s type from the new optimistic assumption:
3922       ciKlass* ak = ciArrayKlass::make(env()-&gt;Object_klass());
3923       const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0));
3924       Node* cast = new CastPPNode(klass_node, akls);
3925       cast-&gt;init_req(0, control());
3926       klass_node = _gvn.transform(cast);
3927     }
3928 
3929     Node* original_kls = load_object_klass(original);
3930     // ArrayCopyNode:Ideal may transform the ArrayCopyNode to
3931     // loads/stores but it is legal only if we&#39;re sure the
3932     // Arrays.copyOf would succeed. So we need all input arguments
3933     // to the copyOf to be validated, including that the copy to the
3934     // new array won&#39;t trigger an ArrayStoreException. That subtype
3935     // check can be optimized if we know something on the type of
3936     // the input array from type speculation.
3937     if (_gvn.type(klass_node)-&gt;singleton() &amp;&amp; !stopped()) {
3938       ciKlass* subk   = _gvn.type(original_kls)-&gt;is_klassptr()-&gt;klass();
3939       ciKlass* superk = _gvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
3940 
3941       int test = C-&gt;static_subtype_check(superk, subk);
3942       if (test != Compile::SSC_always_true &amp;&amp; test != Compile::SSC_always_false) {
3943         const TypeOopPtr* t_original = _gvn.type(original)-&gt;is_oopptr();
3944         if (t_original-&gt;speculative_type() != NULL) {
3945           original = maybe_cast_profiled_obj(original, t_original-&gt;speculative_type(), true);
3946           original_kls = load_object_klass(original);
3947         }
3948       }
3949     }
3950 
3951     if (UseFlatArray) {
3952       // Either both or neither new array klass and original array
3953       // klass must be flattened
3954       const TypeAryPtr* t_original = _gvn.type(original)-&gt;isa_aryptr();
3955       Node* is_flat = generate_flatArray_guard(klass_node, NULL);
3956       if (t_original == NULL || !t_original-&gt;is_not_flat()) {
3957         generate_flatArray_guard(original_kls, bailout);
3958       }
3959       if (is_flat != NULL) {
3960         RegionNode* r = new RegionNode(2);
3961         record_for_igvn(r);
3962         r-&gt;init_req(1, control());
3963         set_control(is_flat);
3964         if (t_original == NULL || !t_original-&gt;is_not_flat()) {
3965           generate_flatArray_guard(original_kls, r);
3966         }
3967         bailout-&gt;add_req(control());
3968         set_control(_gvn.transform(r));
3969       }
3970     }
3971 
3972     // Bail out if either start or end is negative.
3973     generate_negative_guard(start, bailout, &amp;start);
3974     generate_negative_guard(end,   bailout, &amp;end);
3975 
3976     Node* length = end;
3977     if (_gvn.type(start) != TypeInt::ZERO) {
3978       length = _gvn.transform(new SubINode(end, start));
3979     }
3980 
3981     // Bail out if length is negative.
3982     // Without this the new_array would throw
3983     // NegativeArraySizeException but IllegalArgumentException is what
3984     // should be thrown
3985     generate_negative_guard(length, bailout, &amp;length);
3986 
3987     if (bailout-&gt;req() &gt; 1) {
3988       PreserveJVMState pjvms(this);
3989       set_control(_gvn.transform(bailout));
3990       uncommon_trap(Deoptimization::Reason_intrinsic,
3991                     Deoptimization::Action_maybe_recompile);
3992     }
3993 
3994     if (!stopped()) {
3995       // How many elements will we copy from the original?
3996       // The answer is MinI(orig_length - start, length).
3997       Node* orig_tail = _gvn.transform(new SubINode(orig_length, start));
3998       Node* moved = generate_min_max(vmIntrinsics::_min, orig_tail, length);
3999 
4000       // Generate a direct call to the right arraycopy function(s).
4001       // We know the copy is disjoint but we might not know if the
4002       // oop stores need checking.
4003       // Extreme case:  Arrays.copyOf((Integer[])x, 10, String[].class).
4004       // This will fail a store-check if x contains any non-nulls.
4005 
4006       bool validated = false;
4007       // Reason_class_check rather than Reason_intrinsic because we
4008       // want to intrinsify even if this traps.
4009       if (!too_many_traps(Deoptimization::Reason_class_check)) {
4010         Node* not_subtype_ctrl = gen_subtype_check(original, klass_node);
4011 
4012         if (not_subtype_ctrl != top()) {
4013           PreserveJVMState pjvms(this);
4014           set_control(not_subtype_ctrl);
4015           uncommon_trap(Deoptimization::Reason_class_check,
4016                         Deoptimization::Action_make_not_entrant);
4017           assert(stopped(), &quot;Should be stopped&quot;);
4018         }
4019         validated = true;
4020       }
4021 
4022       if (!stopped()) {
4023         newcopy = new_array(klass_node, length, 0);  // no arguments to push
4024 
4025         ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, false,
4026                                                 original_kls, klass_node);
4027         if (!is_copyOfRange) {
4028           ac-&gt;set_copyof(validated);
4029         } else {
4030           ac-&gt;set_copyofrange(validated);
4031         }
4032         Node* n = _gvn.transform(ac);
4033         if (n == ac) {
4034           ac-&gt;connect_outputs(this);
4035         } else {
4036           assert(validated, &quot;shouldn&#39;t transform if all arguments not validated&quot;);
4037           set_all_memory(n);
4038         }
4039       }
4040     }
4041   } // original reexecute is set back here
4042 
4043   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
4044   if (!stopped()) {
4045     set_result(newcopy);
4046   }
4047   return true;
4048 }
4049 
4050 
4051 //----------------------generate_virtual_guard---------------------------
4052 // Helper for hashCode and clone.  Peeks inside the vtable to avoid a call.
4053 Node* LibraryCallKit::generate_virtual_guard(Node* obj_klass,
4054                                              RegionNode* slow_region) {
4055   ciMethod* method = callee();
4056   int vtable_index = method-&gt;vtable_index();
4057   assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index,
4058          &quot;bad index %d&quot;, vtable_index);
4059   // Get the Method* out of the appropriate vtable entry.
4060   int entry_offset  = in_bytes(Klass::vtable_start_offset()) +
4061                      vtable_index*vtableEntry::size_in_bytes() +
4062                      vtableEntry::method_offset_in_bytes();
4063   Node* entry_addr  = basic_plus_adr(obj_klass, entry_offset);
4064   Node* target_call = make_load(NULL, entry_addr, TypePtr::NOTNULL, T_ADDRESS, MemNode::unordered);
4065 
4066   // Compare the target method with the expected method (e.g., Object.hashCode).
4067   const TypePtr* native_call_addr = TypeMetadataPtr::make(method);
4068 
4069   Node* native_call = makecon(native_call_addr);
4070   Node* chk_native  = _gvn.transform(new CmpPNode(target_call, native_call));
4071   Node* test_native = _gvn.transform(new BoolNode(chk_native, BoolTest::ne));
4072 
4073   return generate_slow_guard(test_native, slow_region);
4074 }
4075 
4076 //-----------------------generate_method_call----------------------------
4077 // Use generate_method_call to make a slow-call to the real
4078 // method if the fast path fails.  An alternative would be to
4079 // use a stub like OptoRuntime::slow_arraycopy_Java.
4080 // This only works for expanding the current library call,
4081 // not another intrinsic.  (E.g., don&#39;t use this for making an
4082 // arraycopy call inside of the copyOf intrinsic.)
4083 CallJavaNode*
4084 LibraryCallKit::generate_method_call(vmIntrinsics::ID method_id, bool is_virtual, bool is_static) {
4085   // When compiling the intrinsic method itself, do not use this technique.
4086   guarantee(callee() != C-&gt;method(), &quot;cannot make slow-call to self&quot;);
4087 
4088   ciMethod* method = callee();
4089   // ensure the JVMS we have will be correct for this call
4090   guarantee(method_id == method-&gt;intrinsic_id(), &quot;must match&quot;);
4091 
4092   const TypeFunc* tf = TypeFunc::make(method);
4093   CallJavaNode* slow_call;
4094   if (is_static) {
4095     assert(!is_virtual, &quot;&quot;);
4096     slow_call = new CallStaticJavaNode(C, tf,
4097                            SharedRuntime::get_resolve_static_call_stub(),
4098                            method, bci());
4099   } else if (is_virtual) {
4100     null_check_receiver();
4101     int vtable_index = Method::invalid_vtable_index;
4102     if (UseInlineCaches) {
4103       // Suppress the vtable call
4104     } else {
4105       // hashCode and clone are not a miranda methods,
4106       // so the vtable index is fixed.
4107       // No need to use the linkResolver to get it.
4108        vtable_index = method-&gt;vtable_index();
4109        assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index,
4110               &quot;bad index %d&quot;, vtable_index);
4111     }
4112     slow_call = new CallDynamicJavaNode(tf,
4113                           SharedRuntime::get_resolve_virtual_call_stub(),
4114                           method, vtable_index, bci());
4115   } else {  // neither virtual nor static:  opt_virtual
4116     null_check_receiver();
4117     slow_call = new CallStaticJavaNode(C, tf,
4118                                 SharedRuntime::get_resolve_opt_virtual_call_stub(),
4119                                 method, bci());
4120     slow_call-&gt;set_optimized_virtual(true);
4121   }
4122   if (CallGenerator::is_inlined_method_handle_intrinsic(this-&gt;method(), bci(), callee())) {
4123     // To be able to issue a direct call (optimized virtual or virtual)
4124     // and skip a call to MH.linkTo*/invokeBasic adapter, additional information
4125     // about the method being invoked should be attached to the call site to
4126     // make resolution logic work (see SharedRuntime::resolve_{virtual,opt_virtual}_call_C).
4127     slow_call-&gt;set_override_symbolic_info(true);
4128   }
4129   set_arguments_for_java_call(slow_call);
4130   set_edges_for_java_call(slow_call);
4131   return slow_call;
4132 }
4133 
4134 
4135 /**
4136  * Build special case code for calls to hashCode on an object. This call may
4137  * be virtual (invokevirtual) or bound (invokespecial). For each case we generate
4138  * slightly different code.
4139  */
4140 bool LibraryCallKit::inline_native_hashcode(bool is_virtual, bool is_static) {
4141   assert(is_static == callee()-&gt;is_static(), &quot;correct intrinsic selection&quot;);
4142   assert(!(is_virtual &amp;&amp; is_static), &quot;either virtual, special, or static&quot;);
4143 
4144   enum { _slow_path = 1, _fast_path, _null_path, PATH_LIMIT };
4145 
4146   RegionNode* result_reg = new RegionNode(PATH_LIMIT);
4147   PhiNode*    result_val = new PhiNode(result_reg, TypeInt::INT);
4148   PhiNode*    result_io  = new PhiNode(result_reg, Type::ABIO);
4149   PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
4150   Node* obj = argument(0);
4151 
4152   if (obj-&gt;is_InlineType() || gvn().type(obj)-&gt;is_inlinetypeptr()) {
4153     return false;
4154   }
4155 
4156   if (!is_static) {
4157     // Check for hashing null object
4158     obj = null_check_receiver();
4159     if (stopped())  return true;        // unconditionally null
4160     result_reg-&gt;init_req(_null_path, top());
4161     result_val-&gt;init_req(_null_path, top());
4162   } else {
4163     // Do a null check, and return zero if null.
4164     // System.identityHashCode(null) == 0
4165     Node* null_ctl = top();
4166     obj = null_check_oop(obj, &amp;null_ctl);
4167     result_reg-&gt;init_req(_null_path, null_ctl);
4168     result_val-&gt;init_req(_null_path, _gvn.intcon(0));
4169   }
4170 
4171   // Unconditionally null?  Then return right away.
4172   if (stopped()) {
4173     set_control( result_reg-&gt;in(_null_path));
4174     if (!stopped())
4175       set_result(result_val-&gt;in(_null_path));
4176     return true;
4177   }
4178 
4179   // We only go to the fast case code if we pass a number of guards.  The
4180   // paths which do not pass are accumulated in the slow_region.
4181   RegionNode* slow_region = new RegionNode(1);
4182   record_for_igvn(slow_region);
4183 
4184   // If this is a virtual call, we generate a funny guard.  We pull out
4185   // the vtable entry corresponding to hashCode() from the target object.
4186   // If the target method which we are calling happens to be the native
4187   // Object hashCode() method, we pass the guard.  We do not need this
4188   // guard for non-virtual calls -- the caller is known to be the native
4189   // Object hashCode().
4190   if (is_virtual) {
4191     // After null check, get the object&#39;s klass.
4192     Node* obj_klass = load_object_klass(obj);
4193     generate_virtual_guard(obj_klass, slow_region);
4194   }
4195 
4196   // Get the header out of the object, use LoadMarkNode when available
4197   Node* header_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
4198   // The control of the load must be NULL. Otherwise, the load can move before
4199   // the null check after castPP removal.
4200   Node* no_ctrl = NULL;
4201   Node* header = make_load(no_ctrl, header_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
4202 
4203   // Test the header to see if it is unlocked.
4204   // This also serves as guard against inline types (they have the always_locked_pattern set).
4205   Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);
4206   Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));
4207   Node *unlocked_val   = _gvn.MakeConX(markWord::unlocked_value);
4208   Node *chk_unlocked   = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));
4209   Node *test_unlocked  = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));
4210 
4211   generate_slow_guard(test_unlocked, slow_region);
4212 
4213   // Get the hash value and check to see that it has been properly assigned.
4214   // We depend on hash_mask being at most 32 bits and avoid the use of
4215   // hash_mask_in_place because it could be larger than 32 bits in a 64-bit
4216   // vm: see markWord.hpp.
4217   Node *hash_mask      = _gvn.intcon(markWord::hash_mask);
4218   Node *hash_shift     = _gvn.intcon(markWord::hash_shift);
4219   Node *hshifted_header= _gvn.transform(new URShiftXNode(header, hash_shift));
4220   // This hack lets the hash bits live anywhere in the mark object now, as long
4221   // as the shift drops the relevant bits into the low 32 bits.  Note that
4222   // Java spec says that HashCode is an int so there&#39;s no point in capturing
4223   // an &#39;X&#39;-sized hashcode (32 in 32-bit build or 64 in 64-bit build).
4224   hshifted_header      = ConvX2I(hshifted_header);
4225   Node *hash_val       = _gvn.transform(new AndINode(hshifted_header, hash_mask));
4226 
4227   Node *no_hash_val    = _gvn.intcon(markWord::no_hash);
4228   Node *chk_assigned   = _gvn.transform(new CmpINode( hash_val, no_hash_val));
4229   Node *test_assigned  = _gvn.transform(new BoolNode( chk_assigned, BoolTest::eq));
4230 
4231   generate_slow_guard(test_assigned, slow_region);
4232 
4233   Node* init_mem = reset_memory();
4234   // fill in the rest of the null path:
4235   result_io -&gt;init_req(_null_path, i_o());
4236   result_mem-&gt;init_req(_null_path, init_mem);
4237 
4238   result_val-&gt;init_req(_fast_path, hash_val);
4239   result_reg-&gt;init_req(_fast_path, control());
4240   result_io -&gt;init_req(_fast_path, i_o());
4241   result_mem-&gt;init_req(_fast_path, init_mem);
4242 
4243   // Generate code for the slow case.  We make a call to hashCode().
4244   set_control(_gvn.transform(slow_region));
4245   if (!stopped()) {
4246     // No need for PreserveJVMState, because we&#39;re using up the present state.
4247     set_all_memory(init_mem);
4248     vmIntrinsics::ID hashCode_id = is_static ? vmIntrinsics::_identityHashCode : vmIntrinsics::_hashCode;
4249     CallJavaNode* slow_call = generate_method_call(hashCode_id, is_virtual, is_static);
4250     Node* slow_result = set_results_for_java_call(slow_call);
4251     // this-&gt;control() comes from set_results_for_java_call
4252     result_reg-&gt;init_req(_slow_path, control());
4253     result_val-&gt;init_req(_slow_path, slow_result);
4254     result_io  -&gt;set_req(_slow_path, i_o());
4255     result_mem -&gt;set_req(_slow_path, reset_memory());
4256   }
4257 
4258   // Return the combined state.
4259   set_i_o(        _gvn.transform(result_io)  );
4260   set_all_memory( _gvn.transform(result_mem));
4261 
4262   set_result(result_reg, result_val);
4263   return true;
4264 }
4265 
4266 //---------------------------inline_native_getClass----------------------------
4267 // public final native Class&lt;?&gt; java.lang.Object.getClass();
4268 //
4269 // Build special case code for calls to getClass on an object.
4270 bool LibraryCallKit::inline_native_getClass() {
4271   Node* obj = argument(0);
4272   if (obj-&gt;is_InlineType()) {
4273     ciKlass* vk = _gvn.type(obj)-&gt;inline_klass();
4274     set_result(makecon(TypeInstPtr::make(vk-&gt;java_mirror())));
4275     return true;
4276   }
4277   obj = null_check_receiver();
4278   if (stopped())  return true;
4279   set_result(load_mirror_from_klass(load_object_klass(obj)));
4280   return true;
4281 }
4282 
4283 //-----------------inline_native_Reflection_getCallerClass---------------------
4284 // public static native Class&lt;?&gt; sun.reflect.Reflection.getCallerClass();
4285 //
4286 // In the presence of deep enough inlining, getCallerClass() becomes a no-op.
4287 //
4288 // NOTE: This code must perform the same logic as JVM_GetCallerClass
4289 // in that it must skip particular security frames and checks for
4290 // caller sensitive methods.
4291 bool LibraryCallKit::inline_native_Reflection_getCallerClass() {
4292 #ifndef PRODUCT
4293   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4294     tty-&gt;print_cr(&quot;Attempting to inline sun.reflect.Reflection.getCallerClass&quot;);
4295   }
4296 #endif
4297 
4298   if (!jvms()-&gt;has_method()) {
4299 #ifndef PRODUCT
4300     if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4301       tty-&gt;print_cr(&quot;  Bailing out because intrinsic was inlined at top level&quot;);
4302     }
4303 #endif
4304     return false;
4305   }
4306 
4307   // Walk back up the JVM state to find the caller at the required
4308   // depth.
4309   JVMState* caller_jvms = jvms();
4310 
4311   // Cf. JVM_GetCallerClass
4312   // NOTE: Start the loop at depth 1 because the current JVM state does
4313   // not include the Reflection.getCallerClass() frame.
4314   for (int n = 1; caller_jvms != NULL; caller_jvms = caller_jvms-&gt;caller(), n++) {
4315     ciMethod* m = caller_jvms-&gt;method();
4316     switch (n) {
4317     case 0:
4318       fatal(&quot;current JVM state does not include the Reflection.getCallerClass frame&quot;);
4319       break;
4320     case 1:
4321       // Frame 0 and 1 must be caller sensitive (see JVM_GetCallerClass).
4322       if (!m-&gt;caller_sensitive()) {
4323 #ifndef PRODUCT
4324         if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4325           tty-&gt;print_cr(&quot;  Bailing out: CallerSensitive annotation expected at frame %d&quot;, n);
4326         }
4327 #endif
4328         return false;  // bail-out; let JVM_GetCallerClass do the work
4329       }
4330       break;
4331     default:
4332       if (!m-&gt;is_ignored_by_security_stack_walk()) {
4333         // We have reached the desired frame; return the holder class.
4334         // Acquire method holder as java.lang.Class and push as constant.
4335         ciInstanceKlass* caller_klass = caller_jvms-&gt;method()-&gt;holder();
4336         ciInstance* caller_mirror = caller_klass-&gt;java_mirror();
4337         set_result(makecon(TypeInstPtr::make(caller_mirror)));
4338 
4339 #ifndef PRODUCT
4340         if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4341           tty-&gt;print_cr(&quot;  Succeeded: caller = %d) %s.%s, JVMS depth = %d&quot;, n, caller_klass-&gt;name()-&gt;as_utf8(), caller_jvms-&gt;method()-&gt;name()-&gt;as_utf8(), jvms()-&gt;depth());
4342           tty-&gt;print_cr(&quot;  JVM state at this point:&quot;);
4343           for (int i = jvms()-&gt;depth(), n = 1; i &gt;= 1; i--, n++) {
4344             ciMethod* m = jvms()-&gt;of_depth(i)-&gt;method();
4345             tty-&gt;print_cr(&quot;   %d) %s.%s&quot;, n, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
4346           }
4347         }
4348 #endif
4349         return true;
4350       }
4351       break;
4352     }
4353   }
4354 
4355 #ifndef PRODUCT
4356   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4357     tty-&gt;print_cr(&quot;  Bailing out because caller depth exceeded inlining depth = %d&quot;, jvms()-&gt;depth());
4358     tty-&gt;print_cr(&quot;  JVM state at this point:&quot;);
4359     for (int i = jvms()-&gt;depth(), n = 1; i &gt;= 1; i--, n++) {
4360       ciMethod* m = jvms()-&gt;of_depth(i)-&gt;method();
4361       tty-&gt;print_cr(&quot;   %d) %s.%s&quot;, n, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
4362     }
4363   }
4364 #endif
4365 
4366   return false;  // bail-out; let JVM_GetCallerClass do the work
4367 }
4368 
4369 bool LibraryCallKit::inline_fp_conversions(vmIntrinsics::ID id) {
4370   Node* arg = argument(0);
4371   Node* result = NULL;
4372 
4373   switch (id) {
4374   case vmIntrinsics::_floatToRawIntBits:    result = new MoveF2INode(arg);  break;
4375   case vmIntrinsics::_intBitsToFloat:       result = new MoveI2FNode(arg);  break;
4376   case vmIntrinsics::_doubleToRawLongBits:  result = new MoveD2LNode(arg);  break;
4377   case vmIntrinsics::_longBitsToDouble:     result = new MoveL2DNode(arg);  break;
4378 
4379   case vmIntrinsics::_doubleToLongBits: {
4380     // two paths (plus control) merge in a wood
4381     RegionNode *r = new RegionNode(3);
4382     Node *phi = new PhiNode(r, TypeLong::LONG);
4383 
4384     Node *cmpisnan = _gvn.transform(new CmpDNode(arg, arg));
4385     // Build the boolean node
4386     Node *bolisnan = _gvn.transform(new BoolNode(cmpisnan, BoolTest::ne));
4387 
4388     // Branch either way.
4389     // NaN case is less traveled, which makes all the difference.
4390     IfNode *ifisnan = create_and_xform_if(control(), bolisnan, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);
4391     Node *opt_isnan = _gvn.transform(ifisnan);
4392     assert( opt_isnan-&gt;is_If(), &quot;Expect an IfNode&quot;);
4393     IfNode *opt_ifisnan = (IfNode*)opt_isnan;
4394     Node *iftrue = _gvn.transform(new IfTrueNode(opt_ifisnan));
4395 
4396     set_control(iftrue);
4397 
4398     static const jlong nan_bits = CONST64(0x7ff8000000000000);
4399     Node *slow_result = longcon(nan_bits); // return NaN
4400     phi-&gt;init_req(1, _gvn.transform( slow_result ));
4401     r-&gt;init_req(1, iftrue);
4402 
4403     // Else fall through
4404     Node *iffalse = _gvn.transform(new IfFalseNode(opt_ifisnan));
4405     set_control(iffalse);
4406 
4407     phi-&gt;init_req(2, _gvn.transform(new MoveD2LNode(arg)));
4408     r-&gt;init_req(2, iffalse);
4409 
4410     // Post merge
4411     set_control(_gvn.transform(r));
4412     record_for_igvn(r);
4413 
4414     C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
4415     result = phi;
4416     assert(result-&gt;bottom_type()-&gt;isa_long(), &quot;must be&quot;);
4417     break;
4418   }
4419 
4420   case vmIntrinsics::_floatToIntBits: {
4421     // two paths (plus control) merge in a wood
4422     RegionNode *r = new RegionNode(3);
4423     Node *phi = new PhiNode(r, TypeInt::INT);
4424 
4425     Node *cmpisnan = _gvn.transform(new CmpFNode(arg, arg));
4426     // Build the boolean node
4427     Node *bolisnan = _gvn.transform(new BoolNode(cmpisnan, BoolTest::ne));
4428 
4429     // Branch either way.
4430     // NaN case is less traveled, which makes all the difference.
4431     IfNode *ifisnan = create_and_xform_if(control(), bolisnan, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);
4432     Node *opt_isnan = _gvn.transform(ifisnan);
4433     assert( opt_isnan-&gt;is_If(), &quot;Expect an IfNode&quot;);
4434     IfNode *opt_ifisnan = (IfNode*)opt_isnan;
4435     Node *iftrue = _gvn.transform(new IfTrueNode(opt_ifisnan));
4436 
4437     set_control(iftrue);
4438 
4439     static const jint nan_bits = 0x7fc00000;
4440     Node *slow_result = makecon(TypeInt::make(nan_bits)); // return NaN
4441     phi-&gt;init_req(1, _gvn.transform( slow_result ));
4442     r-&gt;init_req(1, iftrue);
4443 
4444     // Else fall through
4445     Node *iffalse = _gvn.transform(new IfFalseNode(opt_ifisnan));
4446     set_control(iffalse);
4447 
4448     phi-&gt;init_req(2, _gvn.transform(new MoveF2INode(arg)));
4449     r-&gt;init_req(2, iffalse);
4450 
4451     // Post merge
4452     set_control(_gvn.transform(r));
4453     record_for_igvn(r);
4454 
4455     C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
4456     result = phi;
4457     assert(result-&gt;bottom_type()-&gt;isa_int(), &quot;must be&quot;);
4458     break;
4459   }
4460 
4461   default:
4462     fatal_unexpected_iid(id);
4463     break;
4464   }
4465   set_result(_gvn.transform(result));
4466   return true;
4467 }
4468 
4469 //----------------------inline_unsafe_copyMemory-------------------------
4470 // public native void Unsafe.copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
4471 bool LibraryCallKit::inline_unsafe_copyMemory() {
4472   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
4473   null_check_receiver();  // null-check receiver
4474   if (stopped())  return true;
4475 
4476   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
4477 
4478   Node* src_ptr =         argument(1);   // type: oop
4479   Node* src_off = ConvL2X(argument(2));  // type: long
4480   Node* dst_ptr =         argument(4);   // type: oop
4481   Node* dst_off = ConvL2X(argument(5));  // type: long
4482   Node* size    = ConvL2X(argument(7));  // type: long
4483 
4484   assert(Unsafe_field_offset_to_byte_offset(11) == 11,
4485          &quot;fieldOffset must be byte-scaled&quot;);
4486 
4487   Node* src = make_unsafe_address(src_ptr, src_off, ACCESS_READ);
4488   Node* dst = make_unsafe_address(dst_ptr, dst_off, ACCESS_WRITE);
4489 
4490   // Conservatively insert a memory barrier on all memory slices.
4491   // Do not let writes of the copy source or destination float below the copy.
4492   insert_mem_bar(Op_MemBarCPUOrder);
4493 
4494   Node* thread = _gvn.transform(new ThreadLocalNode());
4495   Node* doing_unsafe_access_addr = basic_plus_adr(top(), thread, in_bytes(JavaThread::doing_unsafe_access_offset()));
4496   BasicType doing_unsafe_access_bt = T_BYTE;
4497   assert((sizeof(bool) * CHAR_BIT) == 8, &quot;not implemented&quot;);
4498 
4499   // update volatile field
4500   store_to_memory(control(), doing_unsafe_access_addr, intcon(1), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);
4501 
4502   // Call it.  Note that the length argument is not scaled.
4503   make_runtime_call(RC_LEAF|RC_NO_FP,
4504                     OptoRuntime::fast_arraycopy_Type(),
4505                     StubRoutines::unsafe_arraycopy(),
4506                     &quot;unsafe_arraycopy&quot;,
4507                     TypeRawPtr::BOTTOM,
4508                     src, dst, size XTOP);
4509 
4510   store_to_memory(control(), doing_unsafe_access_addr, intcon(0), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);
4511 
4512   // Do not let reads of the copy destination float above the copy.
4513   insert_mem_bar(Op_MemBarCPUOrder);
4514 
4515   return true;
4516 }
4517 
4518 //------------------------clone_coping-----------------------------------
4519 // Helper function for inline_native_clone.
4520 void LibraryCallKit::copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array) {
4521   assert(obj_size != NULL, &quot;&quot;);
4522   Node* raw_obj = alloc_obj-&gt;in(1);
4523   assert(alloc_obj-&gt;is_CheckCastPP() &amp;&amp; raw_obj-&gt;is_Proj() &amp;&amp; raw_obj-&gt;in(0)-&gt;is_Allocate(), &quot;&quot;);
4524 
4525   AllocateNode* alloc = NULL;
4526   if (ReduceBulkZeroing) {
4527     // We will be completely responsible for initializing this object -
4528     // mark Initialize node as complete.
4529     alloc = AllocateNode::Ideal_allocation(alloc_obj, &amp;_gvn);
4530     // The object was just allocated - there should be no any stores!
4531     guarantee(alloc != NULL &amp;&amp; alloc-&gt;maybe_set_complete(&amp;_gvn), &quot;&quot;);
4532     // Mark as complete_with_arraycopy so that on AllocateNode
4533     // expansion, we know this AllocateNode is initialized by an array
4534     // copy and a StoreStore barrier exists after the array copy.
4535     alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
4536   }
4537 
4538   Node* size = _gvn.transform(obj_size);
4539   // Exclude the header but include array length to copy by 8 bytes words.
4540   // Can&#39;t use base_offset_in_bytes(bt) since basic type is unknown.
4541   int base_off = BarrierSetC2::arraycopy_payload_base_offset(is_array);
4542   Node* countx = size;
4543   countx = _gvn.transform(new SubXNode(countx, MakeConX(base_off)));
4544   countx = _gvn.transform(new URShiftXNode(countx, intcon(LogBytesPerLong)));
4545 
4546   access_clone(obj, alloc_obj, countx, is_array);
4547 
4548   // Do not let reads from the cloned object float above the arraycopy.
4549   if (alloc != NULL) {
4550     // Do not let stores that initialize this object be reordered with
4551     // a subsequent store that would make this object accessible by
4552     // other threads.
4553     // Record what AllocateNode this StoreStore protects so that
4554     // escape analysis can go from the MemBarStoreStoreNode to the
4555     // AllocateNode and eliminate the MemBarStoreStoreNode if possible
4556     // based on the escape status of the AllocateNode.
4557     insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
4558   } else {
4559     insert_mem_bar(Op_MemBarCPUOrder);
4560   }
4561 }
4562 
4563 //------------------------inline_native_clone----------------------------
4564 // protected native Object java.lang.Object.clone();
4565 //
4566 // Here are the simple edge cases:
4567 //  null receiver =&gt; normal trap
4568 //  virtual and clone was overridden =&gt; slow path to out-of-line clone
4569 //  not cloneable or finalizer =&gt; slow path to out-of-line Object.clone
4570 //
4571 // The general case has two steps, allocation and copying.
4572 // Allocation has two cases, and uses GraphKit::new_instance or new_array.
4573 //
4574 // Copying also has two cases, oop arrays and everything else.
4575 // Oop arrays use arrayof_oop_arraycopy (same as System.arraycopy).
4576 // Everything else uses the tight inline loop supplied by CopyArrayNode.
4577 //
4578 // These steps fold up nicely if and when the cloned object&#39;s klass
4579 // can be sharply typed as an object array, a type array, or an instance.
4580 //
4581 bool LibraryCallKit::inline_native_clone(bool is_virtual) {
4582   PhiNode* result_val;
4583 
4584   // Set the reexecute bit for the interpreter to reexecute
4585   // the bytecode that invokes Object.clone if deoptimization happens.
4586   { PreserveReexecuteState preexecs(this);
4587     jvms()-&gt;set_should_reexecute(true);
4588 
4589     Node* obj = argument(0);
4590     if (obj-&gt;is_InlineType()) {
4591       return false;
4592     }
4593 
4594     obj = null_check_receiver();
4595     if (stopped())  return true;
4596 
4597     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
4598 
4599     // If we are going to clone an instance, we need its exact type to
4600     // know the number and types of fields to convert the clone to
4601     // loads/stores. Maybe a speculative type can help us.
4602     if (!obj_type-&gt;klass_is_exact() &amp;&amp;
4603         obj_type-&gt;speculative_type() != NULL &amp;&amp;
4604         obj_type-&gt;speculative_type()-&gt;is_instance_klass() &amp;&amp;
4605         !obj_type-&gt;speculative_type()-&gt;is_inlinetype()) {
4606       ciInstanceKlass* spec_ik = obj_type-&gt;speculative_type()-&gt;as_instance_klass();
4607       if (spec_ik-&gt;nof_nonstatic_fields() &lt;= ArrayCopyLoadStoreMaxElem &amp;&amp;
4608           !spec_ik-&gt;has_injected_fields()) {
4609         ciKlass* k = obj_type-&gt;klass();
4610         if (!k-&gt;is_instance_klass() ||
4611             k-&gt;as_instance_klass()-&gt;is_interface() ||
4612             k-&gt;as_instance_klass()-&gt;has_subklass()) {
4613           obj = maybe_cast_profiled_obj(obj, obj_type-&gt;speculative_type(), false);
4614         }
4615       }
4616     }
4617 
4618     // Conservatively insert a memory barrier on all memory slices.
4619     // Do not let writes into the original float below the clone.
4620     insert_mem_bar(Op_MemBarCPUOrder);
4621 
4622     // paths into result_reg:
4623     enum {
4624       _slow_path = 1,     // out-of-line call to clone method (virtual or not)
4625       _objArray_path,     // plain array allocation, plus arrayof_oop_arraycopy
4626       _array_path,        // plain array allocation, plus arrayof_long_arraycopy
4627       _instance_path,     // plain instance allocation, plus arrayof_long_arraycopy
4628       PATH_LIMIT
4629     };
4630     RegionNode* result_reg = new RegionNode(PATH_LIMIT);
4631     result_val             = new PhiNode(result_reg, TypeInstPtr::NOTNULL);
4632     PhiNode*    result_i_o = new PhiNode(result_reg, Type::ABIO);
4633     PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
4634     record_for_igvn(result_reg);
4635 
4636     Node* obj_klass = load_object_klass(obj);
4637     // We only go to the fast case code if we pass a number of guards.
4638     // The paths which do not pass are accumulated in the slow_region.
4639     RegionNode* slow_region = new RegionNode(1);
4640     record_for_igvn(slow_region);
4641 
4642     Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)NULL);
4643     if (array_ctl != NULL) {
4644       // It&#39;s an array.
4645       PreserveJVMState pjvms(this);
4646       set_control(array_ctl);
4647 
4648       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
4649       if (bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing) &amp;&amp;
4650           (!obj_type-&gt;isa_aryptr() || !obj_type-&gt;is_aryptr()-&gt;is_not_flat())) {
4651         // Flattened inline type array may have object field that would require a
4652         // write barrier. Conservatively, go to slow path.
4653         generate_flatArray_guard(obj_klass, slow_region);
4654       }
4655 
4656       if (!stopped()) {
4657         Node* obj_length = load_array_length(obj);
4658         Node* obj_size  = NULL;
4659         Node* alloc_obj = new_array(obj_klass, obj_length, 0, &amp;obj_size, /*deoptimize_on_exception=*/true);
4660 
4661         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
4662         if (bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing)) {
4663           // If it is an oop array, it requires very special treatment,
4664           // because gc barriers are required when accessing the array.
4665           Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);
4666           if (is_obja != NULL) {
4667             PreserveJVMState pjvms2(this);
4668             set_control(is_obja);
4669             // Generate a direct call to the right arraycopy function(s).
4670             Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);
4671             ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);
4672             ac-&gt;set_clone_oop_array();
4673             Node* n = _gvn.transform(ac);
4674             assert(n == ac, &quot;cannot disappear&quot;);
4675             ac-&gt;connect_outputs(this, /*deoptimize_on_exception=*/true);
4676 
4677             result_reg-&gt;init_req(_objArray_path, control());
4678             result_val-&gt;init_req(_objArray_path, alloc_obj);
4679             result_i_o -&gt;set_req(_objArray_path, i_o());
4680             result_mem -&gt;set_req(_objArray_path, reset_memory());
4681           }
4682         }
4683         // Otherwise, there are no barriers to worry about.
4684         // (We can dispense with card marks if we know the allocation
4685         //  comes out of eden (TLAB)...  In fact, ReduceInitialCardMarks
4686         //  causes the non-eden paths to take compensating steps to
4687         //  simulate a fresh allocation, so that no further
4688         //  card marks are required in compiled code to initialize
4689         //  the object.)
4690 
4691         if (!stopped()) {
4692           copy_to_clone(obj, alloc_obj, obj_size, true);
4693 
4694           // Present the results of the copy.
4695           result_reg-&gt;init_req(_array_path, control());
4696           result_val-&gt;init_req(_array_path, alloc_obj);
4697           result_i_o -&gt;set_req(_array_path, i_o());
4698           result_mem -&gt;set_req(_array_path, reset_memory());
4699         }
4700       }
4701     }
4702 
4703     if (!stopped()) {
4704       // It&#39;s an instance (we did array above).  Make the slow-path tests.
4705       // If this is a virtual call, we generate a funny guard.  We grab
4706       // the vtable entry corresponding to clone() from the target object.
4707       // If the target method which we are calling happens to be the
4708       // Object clone() method, we pass the guard.  We do not need this
4709       // guard for non-virtual calls; the caller is known to be the native
4710       // Object clone().
4711       if (is_virtual) {
4712         generate_virtual_guard(obj_klass, slow_region);
4713       }
4714 
4715       // The object must be easily cloneable and must not have a finalizer.
4716       // Both of these conditions may be checked in a single test.
4717       // We could optimize the test further, but we don&#39;t care.
4718       generate_access_flags_guard(obj_klass,
4719                                   // Test both conditions:
4720                                   JVM_ACC_IS_CLONEABLE_FAST | JVM_ACC_HAS_FINALIZER,
4721                                   // Must be cloneable but not finalizer:
4722                                   JVM_ACC_IS_CLONEABLE_FAST,
4723                                   slow_region);
4724     }
4725 
4726     if (!stopped()) {
4727       // It&#39;s an instance, and it passed the slow-path tests.
4728       PreserveJVMState pjvms(this);
4729       Node* obj_size  = NULL;
4730       // Need to deoptimize on exception from allocation since Object.clone intrinsic
4731       // is reexecuted if deoptimization occurs and there could be problems when merging
4732       // exception state between multiple Object.clone versions (reexecute=true vs reexecute=false).
4733       Node* alloc_obj = new_instance(obj_klass, NULL, &amp;obj_size, /*deoptimize_on_exception=*/true);
4734 
4735       copy_to_clone(obj, alloc_obj, obj_size, false);
4736 
4737       // Present the results of the slow call.
4738       result_reg-&gt;init_req(_instance_path, control());
4739       result_val-&gt;init_req(_instance_path, alloc_obj);
4740       result_i_o -&gt;set_req(_instance_path, i_o());
4741       result_mem -&gt;set_req(_instance_path, reset_memory());
4742     }
4743 
4744     // Generate code for the slow case.  We make a call to clone().
4745     set_control(_gvn.transform(slow_region));
4746     if (!stopped()) {
4747       PreserveJVMState pjvms(this);
4748       CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_clone, is_virtual);
4749       // We need to deoptimize on exception (see comment above)
4750       Node* slow_result = set_results_for_java_call(slow_call, false, /* deoptimize */ true);
4751       // this-&gt;control() comes from set_results_for_java_call
4752       result_reg-&gt;init_req(_slow_path, control());
4753       result_val-&gt;init_req(_slow_path, slow_result);
4754       result_i_o -&gt;set_req(_slow_path, i_o());
4755       result_mem -&gt;set_req(_slow_path, reset_memory());
4756     }
4757 
4758     // Return the combined state.
4759     set_control(    _gvn.transform(result_reg));
4760     set_i_o(        _gvn.transform(result_i_o));
4761     set_all_memory( _gvn.transform(result_mem));
4762   } // original reexecute is set back here
4763 
4764   set_result(_gvn.transform(result_val));
4765   return true;
4766 }
4767 
4768 // If we have a tightly coupled allocation, the arraycopy may take care
4769 // of the array initialization. If one of the guards we insert between
4770 // the allocation and the arraycopy causes a deoptimization, an
4771 // unitialized array will escape the compiled method. To prevent that
4772 // we set the JVM state for uncommon traps between the allocation and
4773 // the arraycopy to the state before the allocation so, in case of
4774 // deoptimization, we&#39;ll reexecute the allocation and the
4775 // initialization.
4776 JVMState* LibraryCallKit::arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp) {
4777   if (alloc != NULL) {
4778     ciMethod* trap_method = alloc-&gt;jvms()-&gt;method();
4779     int trap_bci = alloc-&gt;jvms()-&gt;bci();
4780 
4781     if (!C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_intrinsic) &amp;&amp;
4782         !C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_null_check)) {
4783       // Make sure there&#39;s no store between the allocation and the
4784       // arraycopy otherwise visible side effects could be rexecuted
4785       // in case of deoptimization and cause incorrect execution.
4786       bool no_interfering_store = true;
4787       Node* mem = alloc-&gt;in(TypeFunc::Memory);
4788       if (mem-&gt;is_MergeMem()) {
4789         for (MergeMemStream mms(merged_memory(), mem-&gt;as_MergeMem()); mms.next_non_empty2(); ) {
4790           Node* n = mms.memory();
4791           if (n != mms.memory2() &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
4792             assert(n-&gt;is_Store(), &quot;what else?&quot;);
4793             no_interfering_store = false;
4794             break;
4795           }
4796         }
4797       } else {
4798         for (MergeMemStream mms(merged_memory()); mms.next_non_empty(); ) {
4799           Node* n = mms.memory();
4800           if (n != mem &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
4801             assert(n-&gt;is_Store(), &quot;what else?&quot;);
4802             no_interfering_store = false;
4803             break;
4804           }
4805         }
4806       }
4807 
4808       if (no_interfering_store) {
4809         JVMState* old_jvms = alloc-&gt;jvms()-&gt;clone_shallow(C);
4810         uint size = alloc-&gt;req();
4811         SafePointNode* sfpt = new SafePointNode(size, old_jvms);
4812         old_jvms-&gt;set_map(sfpt);
4813         for (uint i = 0; i &lt; size; i++) {
4814           sfpt-&gt;init_req(i, alloc-&gt;in(i));
4815         }
4816         // re-push array length for deoptimization
4817         sfpt-&gt;ins_req(old_jvms-&gt;stkoff() + old_jvms-&gt;sp(), alloc-&gt;in(AllocateNode::ALength));
4818         old_jvms-&gt;set_sp(old_jvms-&gt;sp()+1);
4819         old_jvms-&gt;set_monoff(old_jvms-&gt;monoff()+1);
4820         old_jvms-&gt;set_scloff(old_jvms-&gt;scloff()+1);
4821         old_jvms-&gt;set_endoff(old_jvms-&gt;endoff()+1);
4822         old_jvms-&gt;set_should_reexecute(true);
4823 
4824         sfpt-&gt;set_i_o(map()-&gt;i_o());
4825         sfpt-&gt;set_memory(map()-&gt;memory());
4826         sfpt-&gt;set_control(map()-&gt;control());
4827 
4828         JVMState* saved_jvms = jvms();
4829         saved_reexecute_sp = _reexecute_sp;
4830 
4831         set_jvms(sfpt-&gt;jvms());
4832         _reexecute_sp = jvms()-&gt;sp();
4833 
4834         return saved_jvms;
4835       }
4836     }
4837   }
4838   return NULL;
4839 }
4840 
4841 // In case of a deoptimization, we restart execution at the
4842 // allocation, allocating a new array. We would leave an uninitialized
4843 // array in the heap that GCs wouldn&#39;t expect. Move the allocation
4844 // after the traps so we don&#39;t allocate the array if we
4845 // deoptimize. This is possible because tightly_coupled_allocation()
4846 // guarantees there&#39;s no observer of the allocated array at this point
4847 // and the control flow is simple enough.
4848 void LibraryCallKit::arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms,
4849                                                     int saved_reexecute_sp, uint new_idx) {
4850   if (saved_jvms != NULL &amp;&amp; !stopped()) {
4851     assert(alloc != NULL, &quot;only with a tightly coupled allocation&quot;);
4852     // restore JVM state to the state at the arraycopy
4853     saved_jvms-&gt;map()-&gt;set_control(map()-&gt;control());
4854     assert(saved_jvms-&gt;map()-&gt;memory() == map()-&gt;memory(), &quot;memory state changed?&quot;);
4855     assert(saved_jvms-&gt;map()-&gt;i_o() == map()-&gt;i_o(), &quot;IO state changed?&quot;);
4856     // If we&#39;ve improved the types of some nodes (null check) while
4857     // emitting the guards, propagate them to the current state
4858     map()-&gt;replaced_nodes().apply(saved_jvms-&gt;map(), new_idx);
4859     set_jvms(saved_jvms);
4860     _reexecute_sp = saved_reexecute_sp;
4861 
4862     // Remove the allocation from above the guards
4863     CallProjections* callprojs = alloc-&gt;extract_projections(true);
4864     InitializeNode* init = alloc-&gt;initialization();
4865     Node* alloc_mem = alloc-&gt;in(TypeFunc::Memory);
4866     C-&gt;gvn_replace_by(callprojs-&gt;fallthrough_ioproj, alloc-&gt;in(TypeFunc::I_O));
4867     C-&gt;gvn_replace_by(init-&gt;proj_out(TypeFunc::Memory), alloc_mem);
4868     C-&gt;gvn_replace_by(init-&gt;proj_out(TypeFunc::Control), alloc-&gt;in(0));
4869 
4870     // move the allocation here (after the guards)
4871     _gvn.hash_delete(alloc);
4872     alloc-&gt;set_req(TypeFunc::Control, control());
4873     alloc-&gt;set_req(TypeFunc::I_O, i_o());
4874     Node *mem = reset_memory();
4875     set_all_memory(mem);
4876     alloc-&gt;set_req(TypeFunc::Memory, mem);
4877     set_control(init-&gt;proj_out_or_null(TypeFunc::Control));
4878     set_i_o(callprojs-&gt;fallthrough_ioproj);
4879 
4880     // Update memory as done in GraphKit::set_output_for_allocation()
4881     const TypeInt* length_type = _gvn.find_int_type(alloc-&gt;in(AllocateNode::ALength));
4882     const TypeOopPtr* ary_type = _gvn.type(alloc-&gt;in(AllocateNode::KlassNode))-&gt;is_klassptr()-&gt;as_instance_type();
4883     if (ary_type-&gt;isa_aryptr() &amp;&amp; length_type != NULL) {
4884       ary_type = ary_type-&gt;is_aryptr()-&gt;cast_to_size(length_type);
4885     }
4886     const TypePtr* telemref = ary_type-&gt;add_offset(Type::OffsetBot);
4887     int            elemidx  = C-&gt;get_alias_index(telemref);
4888     set_memory(init-&gt;proj_out_or_null(TypeFunc::Memory), Compile::AliasIdxRaw);
4889     set_memory(init-&gt;proj_out_or_null(TypeFunc::Memory), elemidx);
4890 
4891     Node* allocx = _gvn.transform(alloc);
4892     assert(allocx == alloc, &quot;where has the allocation gone?&quot;);
4893     assert(dest-&gt;is_CheckCastPP(), &quot;not an allocation result?&quot;);
4894 
4895     _gvn.hash_delete(dest);
4896     dest-&gt;set_req(0, control());
4897     Node* destx = _gvn.transform(dest);
4898     assert(destx == dest, &quot;where has the allocation result gone?&quot;);
4899   }
4900 }
4901 
4902 
4903 //------------------------------inline_arraycopy-----------------------
4904 // public static native void java.lang.System.arraycopy(Object src,  int  srcPos,
4905 //                                                      Object dest, int destPos,
4906 //                                                      int length);
4907 bool LibraryCallKit::inline_arraycopy() {
4908   // Get the arguments.
4909   Node* src         = argument(0);  // type: oop
4910   Node* src_offset  = argument(1);  // type: int
4911   Node* dest        = argument(2);  // type: oop
4912   Node* dest_offset = argument(3);  // type: int
4913   Node* length      = argument(4);  // type: int
4914 
4915   uint new_idx = C-&gt;unique();
4916 
4917   // Check for allocation before we add nodes that would confuse
4918   // tightly_coupled_allocation()
4919   AllocateArrayNode* alloc = tightly_coupled_allocation(dest, NULL);
4920 
4921   int saved_reexecute_sp = -1;
4922   JVMState* saved_jvms = arraycopy_restore_alloc_state(alloc, saved_reexecute_sp);
4923   // See arraycopy_restore_alloc_state() comment
4924   // if alloc == NULL we don&#39;t have to worry about a tightly coupled allocation so we can emit all needed guards
4925   // if saved_jvms != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation
4926   // if saved_jvms == NULL and alloc != NULL, we can&#39;t emit any guards
4927   bool can_emit_guards = (alloc == NULL || saved_jvms != NULL);
4928 
4929   // The following tests must be performed
4930   // (1) src and dest are arrays.
4931   // (2) src and dest arrays must have elements of the same BasicType
4932   // (3) src and dest must not be null.
4933   // (4) src_offset must not be negative.
4934   // (5) dest_offset must not be negative.
4935   // (6) length must not be negative.
4936   // (7) src_offset + length must not exceed length of src.
4937   // (8) dest_offset + length must not exceed length of dest.
4938   // (9) each element of an oop array must be assignable
4939 
4940   // (3) src and dest must not be null.
4941   // always do this here because we need the JVM state for uncommon traps
4942   Node* null_ctl = top();
4943   src  = saved_jvms != NULL ? null_check_oop(src, &amp;null_ctl, true, true) : null_check(src,  T_ARRAY);
4944   assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
4945   dest = null_check(dest, T_ARRAY);
4946 
4947   if (!can_emit_guards) {
4948     // if saved_jvms == NULL and alloc != NULL, we don&#39;t emit any
4949     // guards but the arraycopy node could still take advantage of a
4950     // tightly allocated allocation. tightly_coupled_allocation() is
4951     // called again to make sure it takes the null check above into
4952     // account: the null check is mandatory and if it caused an
4953     // uncommon trap to be emitted then the allocation can&#39;t be
4954     // considered tightly coupled in this context.
4955     alloc = tightly_coupled_allocation(dest, NULL);
4956   }
4957 
4958   bool validated = false;
4959 
4960   const Type* src_type  = _gvn.type(src);
4961   const Type* dest_type = _gvn.type(dest);
4962   const TypeAryPtr* top_src  = src_type-&gt;isa_aryptr();
4963   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
4964 
4965   // Do we have the type of src?
4966   bool has_src = (top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL);
4967   // Do we have the type of dest?
4968   bool has_dest = (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL);
4969   // Is the type for src from speculation?
4970   bool src_spec = false;
4971   // Is the type for dest from speculation?
4972   bool dest_spec = false;
4973 
4974   if ((!has_src || !has_dest) &amp;&amp; can_emit_guards) {
4975     // We don&#39;t have sufficient type information, let&#39;s see if
4976     // speculative types can help. We need to have types for both src
4977     // and dest so that it pays off.
4978 
4979     // Do we already have or could we have type information for src
4980     bool could_have_src = has_src;
4981     // Do we already have or could we have type information for dest
4982     bool could_have_dest = has_dest;
4983 
4984     ciKlass* src_k = NULL;
4985     if (!has_src) {
4986       src_k = src_type-&gt;speculative_type_not_null();
4987       if (src_k != NULL &amp;&amp; src_k-&gt;is_array_klass()) {
4988         could_have_src = true;
4989       }
4990     }
4991 
4992     ciKlass* dest_k = NULL;
4993     if (!has_dest) {
4994       dest_k = dest_type-&gt;speculative_type_not_null();
4995       if (dest_k != NULL &amp;&amp; dest_k-&gt;is_array_klass()) {
4996         could_have_dest = true;
4997       }
4998     }
4999 
5000     if (could_have_src &amp;&amp; could_have_dest) {
5001       // This is going to pay off so emit the required guards
5002       if (!has_src) {
5003         src = maybe_cast_profiled_obj(src, src_k, true);
5004         src_type  = _gvn.type(src);
5005         top_src  = src_type-&gt;isa_aryptr();
5006         has_src = (top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL);
5007         src_spec = true;
5008       }
5009       if (!has_dest) {
5010         dest = maybe_cast_profiled_obj(dest, dest_k, true);
5011         dest_type  = _gvn.type(dest);
5012         top_dest  = dest_type-&gt;isa_aryptr();
5013         has_dest = (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL);
5014         dest_spec = true;
5015       }
5016     }
5017   }
5018 
5019   if (has_src &amp;&amp; has_dest &amp;&amp; can_emit_guards) {
5020     BasicType src_elem  = top_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5021     BasicType dest_elem = top_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5022     if (is_reference_type(src_elem))   src_elem  = T_OBJECT;
5023     if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;
5024 
5025     if (src_elem == dest_elem &amp;&amp; src_elem == T_OBJECT) {
5026       // If both arrays are object arrays then having the exact types
5027       // for both will remove the need for a subtype check at runtime
5028       // before the call and may make it possible to pick a faster copy
5029       // routine (without a subtype check on every element)
5030       // Do we have the exact type of src?
5031       bool could_have_src = src_spec;
5032       // Do we have the exact type of dest?
5033       bool could_have_dest = dest_spec;
5034       ciKlass* src_k = top_src-&gt;klass();
5035       ciKlass* dest_k = top_dest-&gt;klass();
5036       if (!src_spec) {
5037         src_k = src_type-&gt;speculative_type_not_null();
5038         if (src_k != NULL &amp;&amp; src_k-&gt;is_array_klass()) {
5039           could_have_src = true;
5040         }
5041       }
5042       if (!dest_spec) {
5043         dest_k = dest_type-&gt;speculative_type_not_null();
5044         if (dest_k != NULL &amp;&amp; dest_k-&gt;is_array_klass()) {
5045           could_have_dest = true;
5046         }
5047       }
5048       if (could_have_src &amp;&amp; could_have_dest) {
5049         // If we can have both exact types, emit the missing guards
5050         if (could_have_src &amp;&amp; !src_spec) {
5051           src = maybe_cast_profiled_obj(src, src_k, true);
5052           src_type = _gvn.type(src);
5053           top_src = src_type-&gt;isa_aryptr();
5054         }
5055         if (could_have_dest &amp;&amp; !dest_spec) {
5056           dest = maybe_cast_profiled_obj(dest, dest_k, true);
5057           dest_type = _gvn.type(dest);
5058           top_dest = dest_type-&gt;isa_aryptr();
5059         }
5060       }
5061     }
5062   }
5063 
5064   ciMethod* trap_method = method();
5065   int trap_bci = bci();
5066   if (saved_jvms != NULL) {
5067     trap_method = alloc-&gt;jvms()-&gt;method();
5068     trap_bci = alloc-&gt;jvms()-&gt;bci();
5069   }
5070 
5071   bool negative_length_guard_generated = false;
5072 
5073   if (!C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_intrinsic) &amp;&amp;
5074       can_emit_guards &amp;&amp;
5075       !src-&gt;is_top() &amp;&amp; !dest-&gt;is_top()) {
5076     // validate arguments: enables transformation the ArrayCopyNode
5077     validated = true;
5078 
5079     RegionNode* slow_region = new RegionNode(1);
5080     record_for_igvn(slow_region);
5081 
5082     // (1) src and dest are arrays.
5083     generate_non_array_guard(load_object_klass(src), slow_region);
5084     generate_non_array_guard(load_object_klass(dest), slow_region);
5085 
5086     // (2) src and dest arrays must have elements of the same BasicType
5087     // done at macro expansion or at Ideal transformation time
5088 
5089     // (4) src_offset must not be negative.
5090     generate_negative_guard(src_offset, slow_region);
5091 
5092     // (5) dest_offset must not be negative.
5093     generate_negative_guard(dest_offset, slow_region);
5094 
5095     // (7) src_offset + length must not exceed length of src.
5096     generate_limit_guard(src_offset, length,
5097                          load_array_length(src),
5098                          slow_region);
5099 
5100     // (8) dest_offset + length must not exceed length of dest.
5101     generate_limit_guard(dest_offset, length,
5102                          load_array_length(dest),
5103                          slow_region);
5104 
5105     // (6) length must not be negative.
5106     // This is also checked in generate_arraycopy() during macro expansion, but
5107     // we also have to check it here for the case where the ArrayCopyNode will
5108     // be eliminated by Escape Analysis.
5109     if (EliminateAllocations) {
5110       generate_negative_guard(length, slow_region);
5111       negative_length_guard_generated = true;
5112     }
5113 
5114     // (9) each element of an oop array must be assignable
5115     Node* dest_klass = load_object_klass(dest);
5116     if (src != dest) {
5117       Node* not_subtype_ctrl = gen_subtype_check(src, dest_klass);
5118 
5119       if (not_subtype_ctrl != top()) {
5120         PreserveJVMState pjvms(this);
5121         set_control(not_subtype_ctrl);
5122         uncommon_trap(Deoptimization::Reason_intrinsic,
5123                       Deoptimization::Action_make_not_entrant);
5124         assert(stopped(), &quot;Should be stopped&quot;);
5125       }
5126     }
5127 
5128     const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)-&gt;is_klassptr();
5129     const Type* toop = TypeOopPtr::make_from_klass(dest_klass_t-&gt;klass());
5130     src = _gvn.transform(new CheckCastPPNode(control(), src, toop));
5131     src_type = _gvn.type(src);
5132     top_src  = src_type-&gt;isa_aryptr();
5133 
5134     if (top_dest != NULL &amp;&amp; !top_dest-&gt;is_flat() &amp;&amp; !top_dest-&gt;is_not_flat()) {
5135       generate_flatArray_guard(dest_klass, slow_region);
5136       top_dest = top_dest-&gt;cast_to_not_flat();
5137       dest = _gvn.transform(new CheckCastPPNode(control(), dest, top_dest));
5138     }
5139     if (top_src != NULL &amp;&amp; !top_src-&gt;is_flat() &amp;&amp; !top_src-&gt;is_not_flat()) {
5140       Node* src_klass = load_object_klass(src);
5141       generate_flatArray_guard(src_klass, slow_region);
5142       top_src = top_src-&gt;cast_to_not_flat();
5143       src = _gvn.transform(new CheckCastPPNode(control(), src, top_src));
5144     }
5145 
5146     {
5147       PreserveJVMState pjvms(this);
5148       set_control(_gvn.transform(slow_region));
5149       uncommon_trap(Deoptimization::Reason_intrinsic,
5150                     Deoptimization::Action_make_not_entrant);
5151       assert(stopped(), &quot;Should be stopped&quot;);
5152     }
5153   }
5154 
5155   arraycopy_move_allocation_here(alloc, dest, saved_jvms, saved_reexecute_sp, new_idx);
5156 
5157   if (stopped()) {
5158     return true;
5159   }
5160 
5161   ArrayCopyNode* ac = ArrayCopyNode::make(this, true, src, src_offset, dest, dest_offset, length, alloc != NULL, negative_length_guard_generated,
5162                                           // Create LoadRange and LoadKlass nodes for use during macro expansion here
5163                                           // so the compiler has a chance to eliminate them: during macro expansion,
5164                                           // we have to set their control (CastPP nodes are eliminated).
5165                                           load_object_klass(src), load_object_klass(dest),
5166                                           load_array_length(src), load_array_length(dest));
5167 
5168   ac-&gt;set_arraycopy(validated);
5169 
5170   Node* n = _gvn.transform(ac);
5171   if (n == ac) {
5172     ac-&gt;connect_outputs(this);
5173   } else {
5174     assert(validated, &quot;shouldn&#39;t transform if all arguments not validated&quot;);
5175     set_all_memory(n);
5176   }
5177   clear_upper_avx();
5178 
5179 
5180   return true;
5181 }
5182 
5183 
5184 // Helper function which determines if an arraycopy immediately follows
5185 // an allocation, with no intervening tests or other escapes for the object.
5186 AllocateArrayNode*
5187 LibraryCallKit::tightly_coupled_allocation(Node* ptr,
5188                                            RegionNode* slow_region) {
5189   if (stopped())             return NULL;  // no fast path
5190   if (C-&gt;AliasLevel() == 0)  return NULL;  // no MergeMems around
5191 
5192   AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(ptr, &amp;_gvn);
5193   if (alloc == NULL)  return NULL;
5194 
5195   Node* rawmem = memory(Compile::AliasIdxRaw);
5196   // Is the allocation&#39;s memory state untouched?
5197   if (!(rawmem-&gt;is_Proj() &amp;&amp; rawmem-&gt;in(0)-&gt;is_Initialize())) {
5198     // Bail out if there have been raw-memory effects since the allocation.
5199     // (Example:  There might have been a call or safepoint.)
5200     return NULL;
5201   }
5202   rawmem = rawmem-&gt;in(0)-&gt;as_Initialize()-&gt;memory(Compile::AliasIdxRaw);
5203   if (!(rawmem-&gt;is_Proj() &amp;&amp; rawmem-&gt;in(0) == alloc)) {
5204     return NULL;
5205   }
5206 
5207   // There must be no unexpected observers of this allocation.
5208   for (DUIterator_Fast imax, i = ptr-&gt;fast_outs(imax); i &lt; imax; i++) {
5209     Node* obs = ptr-&gt;fast_out(i);
5210     if (obs != this-&gt;map()) {
5211       return NULL;
5212     }
5213   }
5214 
5215   // This arraycopy must unconditionally follow the allocation of the ptr.
5216   Node* alloc_ctl = ptr-&gt;in(0);
5217   Node* ctl = control();
5218   while (ctl != alloc_ctl) {
5219     // There may be guards which feed into the slow_region.
5220     // Any other control flow means that we might not get a chance
5221     // to finish initializing the allocated object.
5222     if ((ctl-&gt;is_IfFalse() || ctl-&gt;is_IfTrue()) &amp;&amp; ctl-&gt;in(0)-&gt;is_If()) {
5223       IfNode* iff = ctl-&gt;in(0)-&gt;as_If();
5224       Node* not_ctl = iff-&gt;proj_out_or_null(1 - ctl-&gt;as_Proj()-&gt;_con);
5225       assert(not_ctl != NULL &amp;&amp; not_ctl != ctl, &quot;found alternate&quot;);
5226       if (slow_region != NULL &amp;&amp; slow_region-&gt;find_edge(not_ctl) &gt;= 1) {
5227         ctl = iff-&gt;in(0);       // This test feeds the known slow_region.
5228         continue;
5229       }
5230       // One more try:  Various low-level checks bottom out in
5231       // uncommon traps.  If the debug-info of the trap omits
5232       // any reference to the allocation, as we&#39;ve already
5233       // observed, then there can be no objection to the trap.
5234       bool found_trap = false;
5235       for (DUIterator_Fast jmax, j = not_ctl-&gt;fast_outs(jmax); j &lt; jmax; j++) {
5236         Node* obs = not_ctl-&gt;fast_out(j);
5237         if (obs-&gt;in(0) == not_ctl &amp;&amp; obs-&gt;is_Call() &amp;&amp;
5238             (obs-&gt;as_Call()-&gt;entry_point() == SharedRuntime::uncommon_trap_blob()-&gt;entry_point())) {
5239           found_trap = true; break;
5240         }
5241       }
5242       if (found_trap) {
5243         ctl = iff-&gt;in(0);       // This test feeds a harmless uncommon trap.
5244         continue;
5245       }
5246     }
5247     return NULL;
5248   }
5249 
5250   // If we get this far, we have an allocation which immediately
5251   // precedes the arraycopy, and we can take over zeroing the new object.
5252   // The arraycopy will finish the initialization, and provide
5253   // a new control state to which we will anchor the destination pointer.
5254 
5255   return alloc;
5256 }
5257 
5258 //-------------inline_encodeISOArray-----------------------------------
5259 // encode char[] to byte[] in ISO_8859_1
5260 bool LibraryCallKit::inline_encodeISOArray() {
5261   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;encodeISOArray has 5 parameters&quot;);
5262   // no receiver since it is static method
5263   Node *src         = argument(0);
5264   Node *src_offset  = argument(1);
5265   Node *dst         = argument(2);
5266   Node *dst_offset  = argument(3);
5267   Node *length      = argument(4);
5268 
5269   src = must_be_not_null(src, true);
5270   dst = must_be_not_null(dst, true);
5271 
5272   const Type* src_type = src-&gt;Value(&amp;_gvn);
5273   const Type* dst_type = dst-&gt;Value(&amp;_gvn);
5274   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5275   const TypeAryPtr* top_dest = dst_type-&gt;isa_aryptr();
5276   if (top_src  == NULL || top_src-&gt;klass()  == NULL ||
5277       top_dest == NULL || top_dest-&gt;klass() == NULL) {
5278     // failed array check
5279     return false;
5280   }
5281 
5282   // Figure out the size and type of the elements we will be copying.
5283   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5284   BasicType dst_elem = dst_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5285   if (!((src_elem == T_CHAR) || (src_elem== T_BYTE)) || dst_elem != T_BYTE) {
5286     return false;
5287   }
5288 
5289   Node* src_start = array_element_address(src, src_offset, T_CHAR);
5290   Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
5291   // &#39;src_start&#39; points to src array + scaled offset
5292   // &#39;dst_start&#39; points to dst array + scaled offset
5293 
5294   const TypeAryPtr* mtype = TypeAryPtr::BYTES;
5295   Node* enc = new EncodeISOArrayNode(control(), memory(mtype), src_start, dst_start, length);
5296   enc = _gvn.transform(enc);
5297   Node* res_mem = _gvn.transform(new SCMemProjNode(enc));
5298   set_memory(res_mem, mtype);
5299   set_result(enc);
5300   clear_upper_avx();
5301 
5302   return true;
5303 }
5304 
5305 //-------------inline_multiplyToLen-----------------------------------
5306 bool LibraryCallKit::inline_multiplyToLen() {
5307   assert(UseMultiplyToLenIntrinsic, &quot;not implemented on this platform&quot;);
5308 
5309   address stubAddr = StubRoutines::multiplyToLen();
5310   if (stubAddr == NULL) {
5311     return false; // Intrinsic&#39;s stub is not implemented on this platform
5312   }
5313   const char* stubName = &quot;multiplyToLen&quot;;
5314 
5315   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;multiplyToLen has 5 parameters&quot;);
5316 
5317   // no receiver because it is a static method
5318   Node* x    = argument(0);
5319   Node* xlen = argument(1);
5320   Node* y    = argument(2);
5321   Node* ylen = argument(3);
5322   Node* z    = argument(4);
5323 
5324   x = must_be_not_null(x, true);
5325   y = must_be_not_null(y, true);
5326 
5327   const Type* x_type = x-&gt;Value(&amp;_gvn);
5328   const Type* y_type = y-&gt;Value(&amp;_gvn);
5329   const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
5330   const TypeAryPtr* top_y = y_type-&gt;isa_aryptr();
5331   if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
5332       top_y == NULL || top_y-&gt;klass() == NULL) {
5333     // failed array check
5334     return false;
5335   }
5336 
5337   BasicType x_elem = x_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5338   BasicType y_elem = y_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5339   if (x_elem != T_INT || y_elem != T_INT) {
5340     return false;
5341   }
5342 
5343   // Set the original stack and the reexecute bit for the interpreter to reexecute
5344   // the bytecode that invokes BigInteger.multiplyToLen() if deoptimization happens
5345   // on the return from z array allocation in runtime.
5346   { PreserveReexecuteState preexecs(this);
5347     jvms()-&gt;set_should_reexecute(true);
5348 
5349     Node* x_start = array_element_address(x, intcon(0), x_elem);
5350     Node* y_start = array_element_address(y, intcon(0), y_elem);
5351     // &#39;x_start&#39; points to x array + scaled xlen
5352     // &#39;y_start&#39; points to y array + scaled ylen
5353 
5354     // Allocate the result array
5355     Node* zlen = _gvn.transform(new AddINode(xlen, ylen));
5356     ciKlass* klass = ciTypeArrayKlass::make(T_INT);
5357     Node* klass_node = makecon(TypeKlassPtr::make(klass));
5358 
5359     IdealKit ideal(this);
5360 
5361 #define __ ideal.
5362      Node* one = __ ConI(1);
5363      Node* zero = __ ConI(0);
5364      IdealVariable need_alloc(ideal), z_alloc(ideal);  __ declarations_done();
5365      __ set(need_alloc, zero);
5366      __ set(z_alloc, z);
5367      __ if_then(z, BoolTest::eq, null()); {
5368        __ increment (need_alloc, one);
5369      } __ else_(); {
5370        // Update graphKit memory and control from IdealKit.
5371        sync_kit(ideal);
5372        Node *cast = new CastPPNode(z, TypePtr::NOTNULL);
5373        cast-&gt;init_req(0, control());
5374        _gvn.set_type(cast, cast-&gt;bottom_type());
5375        C-&gt;record_for_igvn(cast);
5376 
5377        Node* zlen_arg = load_array_length(cast);
5378        // Update IdealKit memory and control from graphKit.
5379        __ sync_kit(this);
5380        __ if_then(zlen_arg, BoolTest::lt, zlen); {
5381          __ increment (need_alloc, one);
5382        } __ end_if();
5383      } __ end_if();
5384 
5385      __ if_then(__ value(need_alloc), BoolTest::ne, zero); {
5386        // Update graphKit memory and control from IdealKit.
5387        sync_kit(ideal);
5388        Node * narr = new_array(klass_node, zlen, 1);
5389        // Update IdealKit memory and control from graphKit.
5390        __ sync_kit(this);
5391        __ set(z_alloc, narr);
5392      } __ end_if();
5393 
5394      sync_kit(ideal);
5395      z = __ value(z_alloc);
5396      // Can&#39;t use TypeAryPtr::INTS which uses Bottom offset.
5397      _gvn.set_type(z, TypeOopPtr::make_from_klass(klass));
5398      // Final sync IdealKit and GraphKit.
5399      final_sync(ideal);
5400 #undef __
5401 
5402     Node* z_start = array_element_address(z, intcon(0), T_INT);
5403 
5404     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
5405                                    OptoRuntime::multiplyToLen_Type(),
5406                                    stubAddr, stubName, TypePtr::BOTTOM,
5407                                    x_start, xlen, y_start, ylen, z_start, zlen);
5408   } // original reexecute is set back here
5409 
5410   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
5411   set_result(z);
5412   return true;
5413 }
5414 
5415 //-------------inline_squareToLen------------------------------------
5416 bool LibraryCallKit::inline_squareToLen() {
5417   assert(UseSquareToLenIntrinsic, &quot;not implemented on this platform&quot;);
5418 
5419   address stubAddr = StubRoutines::squareToLen();
5420   if (stubAddr == NULL) {
5421     return false; // Intrinsic&#39;s stub is not implemented on this platform
5422   }
5423   const char* stubName = &quot;squareToLen&quot;;
5424 
5425   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;implSquareToLen has 4 parameters&quot;);
5426 
5427   Node* x    = argument(0);
5428   Node* len  = argument(1);
5429   Node* z    = argument(2);
5430   Node* zlen = argument(3);
5431 
5432   x = must_be_not_null(x, true);
5433   z = must_be_not_null(z, true);
5434 
5435   const Type* x_type = x-&gt;Value(&amp;_gvn);
5436   const Type* z_type = z-&gt;Value(&amp;_gvn);
5437   const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
5438   const TypeAryPtr* top_z = z_type-&gt;isa_aryptr();
5439   if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
5440       top_z  == NULL || top_z-&gt;klass()  == NULL) {
5441     // failed array check
5442     return false;
5443   }
5444 
5445   BasicType x_elem = x_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5446   BasicType z_elem = z_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5447   if (x_elem != T_INT || z_elem != T_INT) {
5448     return false;
5449   }
5450 
5451 
5452   Node* x_start = array_element_address(x, intcon(0), x_elem);
5453   Node* z_start = array_element_address(z, intcon(0), z_elem);
5454 
5455   Node*  call = make_runtime_call(RC_LEAF|RC_NO_FP,
5456                                   OptoRuntime::squareToLen_Type(),
5457                                   stubAddr, stubName, TypePtr::BOTTOM,
5458                                   x_start, len, z_start, zlen);
5459 
5460   set_result(z);
5461   return true;
5462 }
5463 
5464 //-------------inline_mulAdd------------------------------------------
5465 bool LibraryCallKit::inline_mulAdd() {
5466   assert(UseMulAddIntrinsic, &quot;not implemented on this platform&quot;);
5467 
5468   address stubAddr = StubRoutines::mulAdd();
5469   if (stubAddr == NULL) {
5470     return false; // Intrinsic&#39;s stub is not implemented on this platform
5471   }
5472   const char* stubName = &quot;mulAdd&quot;;
5473 
5474   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;mulAdd has 5 parameters&quot;);
5475 
5476   Node* out      = argument(0);
5477   Node* in       = argument(1);
5478   Node* offset   = argument(2);
5479   Node* len      = argument(3);
5480   Node* k        = argument(4);
5481 
5482   out = must_be_not_null(out, true);
5483 
5484   const Type* out_type = out-&gt;Value(&amp;_gvn);
5485   const Type* in_type = in-&gt;Value(&amp;_gvn);
5486   const TypeAryPtr* top_out = out_type-&gt;isa_aryptr();
5487   const TypeAryPtr* top_in = in_type-&gt;isa_aryptr();
5488   if (top_out  == NULL || top_out-&gt;klass()  == NULL ||
5489       top_in == NULL || top_in-&gt;klass() == NULL) {
5490     // failed array check
5491     return false;
5492   }
5493 
5494   BasicType out_elem = out_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5495   BasicType in_elem = in_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5496   if (out_elem != T_INT || in_elem != T_INT) {
5497     return false;
5498   }
5499 
5500   Node* outlen = load_array_length(out);
5501   Node* new_offset = _gvn.transform(new SubINode(outlen, offset));
5502   Node* out_start = array_element_address(out, intcon(0), out_elem);
5503   Node* in_start = array_element_address(in, intcon(0), in_elem);
5504 
5505   Node*  call = make_runtime_call(RC_LEAF|RC_NO_FP,
5506                                   OptoRuntime::mulAdd_Type(),
5507                                   stubAddr, stubName, TypePtr::BOTTOM,
5508                                   out_start,in_start, new_offset, len, k);
5509   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5510   set_result(result);
5511   return true;
5512 }
5513 
5514 //-------------inline_montgomeryMultiply-----------------------------------
5515 bool LibraryCallKit::inline_montgomeryMultiply() {
5516   address stubAddr = StubRoutines::montgomeryMultiply();
5517   if (stubAddr == NULL) {
5518     return false; // Intrinsic&#39;s stub is not implemented on this platform
5519   }
5520 
5521   assert(UseMontgomeryMultiplyIntrinsic, &quot;not implemented on this platform&quot;);
5522   const char* stubName = &quot;montgomery_multiply&quot;;
5523 
5524   assert(callee()-&gt;signature()-&gt;size() == 7, &quot;montgomeryMultiply has 7 parameters&quot;);
5525 
5526   Node* a    = argument(0);
5527   Node* b    = argument(1);
5528   Node* n    = argument(2);
5529   Node* len  = argument(3);
5530   Node* inv  = argument(4);
5531   Node* m    = argument(6);
5532 
5533   const Type* a_type = a-&gt;Value(&amp;_gvn);
5534   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5535   const Type* b_type = b-&gt;Value(&amp;_gvn);
5536   const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
5537   const Type* n_type = a-&gt;Value(&amp;_gvn);
5538   const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
5539   const Type* m_type = a-&gt;Value(&amp;_gvn);
5540   const TypeAryPtr* top_m = m_type-&gt;isa_aryptr();
5541   if (top_a  == NULL || top_a-&gt;klass()  == NULL ||
5542       top_b == NULL || top_b-&gt;klass()  == NULL ||
5543       top_n == NULL || top_n-&gt;klass()  == NULL ||
5544       top_m == NULL || top_m-&gt;klass()  == NULL) {
5545     // failed array check
5546     return false;
5547   }
5548 
5549   BasicType a_elem = a_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5550   BasicType b_elem = b_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5551   BasicType n_elem = n_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5552   BasicType m_elem = m_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5553   if (a_elem != T_INT || b_elem != T_INT || n_elem != T_INT || m_elem != T_INT) {
5554     return false;
5555   }
5556 
5557   // Make the call
5558   {
5559     Node* a_start = array_element_address(a, intcon(0), a_elem);
5560     Node* b_start = array_element_address(b, intcon(0), b_elem);
5561     Node* n_start = array_element_address(n, intcon(0), n_elem);
5562     Node* m_start = array_element_address(m, intcon(0), m_elem);
5563 
5564     Node* call = make_runtime_call(RC_LEAF,
5565                                    OptoRuntime::montgomeryMultiply_Type(),
5566                                    stubAddr, stubName, TypePtr::BOTTOM,
5567                                    a_start, b_start, n_start, len, inv, top(),
5568                                    m_start);
5569     set_result(m);
5570   }
5571 
5572   return true;
5573 }
5574 
5575 bool LibraryCallKit::inline_montgomerySquare() {
5576   address stubAddr = StubRoutines::montgomerySquare();
5577   if (stubAddr == NULL) {
5578     return false; // Intrinsic&#39;s stub is not implemented on this platform
5579   }
5580 
5581   assert(UseMontgomerySquareIntrinsic, &quot;not implemented on this platform&quot;);
5582   const char* stubName = &quot;montgomery_square&quot;;
5583 
5584   assert(callee()-&gt;signature()-&gt;size() == 6, &quot;montgomerySquare has 6 parameters&quot;);
5585 
5586   Node* a    = argument(0);
5587   Node* n    = argument(1);
5588   Node* len  = argument(2);
5589   Node* inv  = argument(3);
5590   Node* m    = argument(5);
5591 
5592   const Type* a_type = a-&gt;Value(&amp;_gvn);
5593   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5594   const Type* n_type = a-&gt;Value(&amp;_gvn);
5595   const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
5596   const Type* m_type = a-&gt;Value(&amp;_gvn);
5597   const TypeAryPtr* top_m = m_type-&gt;isa_aryptr();
5598   if (top_a  == NULL || top_a-&gt;klass()  == NULL ||
5599       top_n == NULL || top_n-&gt;klass()  == NULL ||
5600       top_m == NULL || top_m-&gt;klass()  == NULL) {
5601     // failed array check
5602     return false;
5603   }
5604 
5605   BasicType a_elem = a_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5606   BasicType n_elem = n_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5607   BasicType m_elem = m_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5608   if (a_elem != T_INT || n_elem != T_INT || m_elem != T_INT) {
5609     return false;
5610   }
5611 
5612   // Make the call
5613   {
5614     Node* a_start = array_element_address(a, intcon(0), a_elem);
5615     Node* n_start = array_element_address(n, intcon(0), n_elem);
5616     Node* m_start = array_element_address(m, intcon(0), m_elem);
5617 
5618     Node* call = make_runtime_call(RC_LEAF,
5619                                    OptoRuntime::montgomerySquare_Type(),
5620                                    stubAddr, stubName, TypePtr::BOTTOM,
5621                                    a_start, n_start, len, inv, top(),
5622                                    m_start);
5623     set_result(m);
5624   }
5625 
5626   return true;
5627 }
5628 
5629 bool LibraryCallKit::inline_bigIntegerShift(bool isRightShift) {
5630   address stubAddr = NULL;
5631   const char* stubName = NULL;
5632 
5633   stubAddr = isRightShift? StubRoutines::bigIntegerRightShift(): StubRoutines::bigIntegerLeftShift();
5634   if (stubAddr == NULL) {
5635     return false; // Intrinsic&#39;s stub is not implemented on this platform
5636   }
5637 
5638   stubName = isRightShift? &quot;bigIntegerRightShiftWorker&quot; : &quot;bigIntegerLeftShiftWorker&quot;;
5639 
5640   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;expected 5 arguments&quot;);
5641 
5642   Node* newArr = argument(0);
5643   Node* oldArr = argument(1);
5644   Node* newIdx = argument(2);
5645   Node* shiftCount = argument(3);
5646   Node* numIter = argument(4);
5647 
5648   const Type* newArr_type = newArr-&gt;Value(&amp;_gvn);
5649   const TypeAryPtr* top_newArr = newArr_type-&gt;isa_aryptr();
5650   const Type* oldArr_type = oldArr-&gt;Value(&amp;_gvn);
5651   const TypeAryPtr* top_oldArr = oldArr_type-&gt;isa_aryptr();
5652   if (top_newArr == NULL || top_newArr-&gt;klass() == NULL || top_oldArr == NULL
5653       || top_oldArr-&gt;klass() == NULL) {
5654     return false;
5655   }
5656 
5657   BasicType newArr_elem = newArr_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5658   BasicType oldArr_elem = oldArr_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5659   if (newArr_elem != T_INT || oldArr_elem != T_INT) {
5660     return false;
5661   }
5662 
5663   // Make the call
5664   {
5665     Node* newArr_start = array_element_address(newArr, intcon(0), newArr_elem);
5666     Node* oldArr_start = array_element_address(oldArr, intcon(0), oldArr_elem);
5667 
5668     Node* call = make_runtime_call(RC_LEAF,
5669                                    OptoRuntime::bigIntegerShift_Type(),
5670                                    stubAddr,
5671                                    stubName,
5672                                    TypePtr::BOTTOM,
5673                                    newArr_start,
5674                                    oldArr_start,
5675                                    newIdx,
5676                                    shiftCount,
5677                                    numIter);
5678   }
5679 
5680   return true;
5681 }
5682 
5683 //-------------inline_vectorizedMismatch------------------------------
5684 bool LibraryCallKit::inline_vectorizedMismatch() {
5685   assert(UseVectorizedMismatchIntrinsic, &quot;not implementated on this platform&quot;);
5686 
5687   address stubAddr = StubRoutines::vectorizedMismatch();
5688   if (stubAddr == NULL) {
5689     return false; // Intrinsic&#39;s stub is not implemented on this platform
5690   }
5691   const char* stubName = &quot;vectorizedMismatch&quot;;
5692   int size_l = callee()-&gt;signature()-&gt;size();
5693   assert(callee()-&gt;signature()-&gt;size() == 8, &quot;vectorizedMismatch has 6 parameters&quot;);
5694 
5695   Node* obja = argument(0);
5696   Node* aoffset = argument(1);
5697   Node* objb = argument(3);
5698   Node* boffset = argument(4);
5699   Node* length = argument(6);
5700   Node* scale = argument(7);
5701 
5702   const Type* a_type = obja-&gt;Value(&amp;_gvn);
5703   const Type* b_type = objb-&gt;Value(&amp;_gvn);
5704   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5705   const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
5706   if (top_a == NULL || top_a-&gt;klass() == NULL ||
5707     top_b == NULL || top_b-&gt;klass() == NULL) {
5708     // failed array check
5709     return false;
5710   }
5711 
5712   Node* call;
5713   jvms()-&gt;set_should_reexecute(true);
5714 
5715   Node* obja_adr = make_unsafe_address(obja, aoffset, ACCESS_READ);
5716   Node* objb_adr = make_unsafe_address(objb, boffset, ACCESS_READ);
5717 
5718   call = make_runtime_call(RC_LEAF,
5719     OptoRuntime::vectorizedMismatch_Type(),
5720     stubAddr, stubName, TypePtr::BOTTOM,
5721     obja_adr, objb_adr, length, scale);
5722 
5723   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5724   set_result(result);
5725   return true;
5726 }
5727 
5728 /**
5729  * Calculate CRC32 for byte.
5730  * int java.util.zip.CRC32.update(int crc, int b)
5731  */
5732 bool LibraryCallKit::inline_updateCRC32() {
5733   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5734   assert(callee()-&gt;signature()-&gt;size() == 2, &quot;update has 2 parameters&quot;);
5735   // no receiver since it is static method
5736   Node* crc  = argument(0); // type: int
5737   Node* b    = argument(1); // type: int
5738 
5739   /*
5740    *    int c = ~ crc;
5741    *    b = timesXtoThe32[(b ^ c) &amp; 0xFF];
5742    *    b = b ^ (c &gt;&gt;&gt; 8);
5743    *    crc = ~b;
5744    */
5745 
5746   Node* M1 = intcon(-1);
5747   crc = _gvn.transform(new XorINode(crc, M1));
5748   Node* result = _gvn.transform(new XorINode(crc, b));
5749   result = _gvn.transform(new AndINode(result, intcon(0xFF)));
5750 
5751   Node* base = makecon(TypeRawPtr::make(StubRoutines::crc_table_addr()));
5752   Node* offset = _gvn.transform(new LShiftINode(result, intcon(0x2)));
5753   Node* adr = basic_plus_adr(top(), base, ConvI2X(offset));
5754   result = make_load(control(), adr, TypeInt::INT, T_INT, MemNode::unordered);
5755 
5756   crc = _gvn.transform(new URShiftINode(crc, intcon(8)));
5757   result = _gvn.transform(new XorINode(crc, result));
5758   result = _gvn.transform(new XorINode(result, M1));
5759   set_result(result);
5760   return true;
5761 }
5762 
5763 /**
5764  * Calculate CRC32 for byte[] array.
5765  * int java.util.zip.CRC32.updateBytes(int crc, byte[] buf, int off, int len)
5766  */
5767 bool LibraryCallKit::inline_updateBytesCRC32() {
5768   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5769   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;updateBytes has 4 parameters&quot;);
5770   // no receiver since it is static method
5771   Node* crc     = argument(0); // type: int
5772   Node* src     = argument(1); // type: oop
5773   Node* offset  = argument(2); // type: int
5774   Node* length  = argument(3); // type: int
5775 
5776   const Type* src_type = src-&gt;Value(&amp;_gvn);
5777   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5778   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5779     // failed array check
5780     return false;
5781   }
5782 
5783   // Figure out the size and type of the elements we will be copying.
5784   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5785   if (src_elem != T_BYTE) {
5786     return false;
5787   }
5788 
5789   // &#39;src_start&#39; points to src array + scaled offset
5790   src = must_be_not_null(src, true);
5791   Node* src_start = array_element_address(src, offset, src_elem);
5792 
5793   // We assume that range check is done by caller.
5794   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5795 
5796   // Call the stub.
5797   address stubAddr = StubRoutines::updateBytesCRC32();
5798   const char *stubName = &quot;updateBytesCRC32&quot;;
5799 
5800   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::updateBytesCRC32_Type(),
5801                                  stubAddr, stubName, TypePtr::BOTTOM,
5802                                  crc, src_start, length);
5803   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5804   set_result(result);
5805   return true;
5806 }
5807 
5808 /**
5809  * Calculate CRC32 for ByteBuffer.
5810  * int java.util.zip.CRC32.updateByteBuffer(int crc, long buf, int off, int len)
5811  */
5812 bool LibraryCallKit::inline_updateByteBufferCRC32() {
5813   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5814   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateByteBuffer has 4 parameters and one is long&quot;);
5815   // no receiver since it is static method
5816   Node* crc     = argument(0); // type: int
5817   Node* src     = argument(1); // type: long
5818   Node* offset  = argument(3); // type: int
5819   Node* length  = argument(4); // type: int
5820 
5821   src = ConvL2X(src);  // adjust Java long to machine word
5822   Node* base = _gvn.transform(new CastX2PNode(src));
5823   offset = ConvI2X(offset);
5824 
5825   // &#39;src_start&#39; points to src array + scaled offset
5826   Node* src_start = basic_plus_adr(top(), base, offset);
5827 
5828   // Call the stub.
5829   address stubAddr = StubRoutines::updateBytesCRC32();
5830   const char *stubName = &quot;updateBytesCRC32&quot;;
5831 
5832   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::updateBytesCRC32_Type(),
5833                                  stubAddr, stubName, TypePtr::BOTTOM,
5834                                  crc, src_start, length);
5835   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5836   set_result(result);
5837   return true;
5838 }
5839 
5840 //------------------------------get_table_from_crc32c_class-----------------------
5841 Node * LibraryCallKit::get_table_from_crc32c_class(ciInstanceKlass *crc32c_class) {
5842   Node* table = load_field_from_object(NULL, &quot;byteTable&quot;, &quot;[I&quot;, /*is_exact*/ false, /*is_static*/ true, crc32c_class);
5843   assert (table != NULL, &quot;wrong version of java.util.zip.CRC32C&quot;);
5844 
5845   return table;
5846 }
5847 
5848 //------------------------------inline_updateBytesCRC32C-----------------------
5849 //
5850 // Calculate CRC32C for byte[] array.
5851 // int java.util.zip.CRC32C.updateBytes(int crc, byte[] buf, int off, int end)
5852 //
5853 bool LibraryCallKit::inline_updateBytesCRC32C() {
5854   assert(UseCRC32CIntrinsics, &quot;need CRC32C instruction support&quot;);
5855   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;updateBytes has 4 parameters&quot;);
5856   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;CRC32C class must be loaded&quot;);
5857   // no receiver since it is a static method
5858   Node* crc     = argument(0); // type: int
5859   Node* src     = argument(1); // type: oop
5860   Node* offset  = argument(2); // type: int
5861   Node* end     = argument(3); // type: int
5862 
5863   Node* length = _gvn.transform(new SubINode(end, offset));
5864 
5865   const Type* src_type = src-&gt;Value(&amp;_gvn);
5866   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5867   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5868     // failed array check
5869     return false;
5870   }
5871 
5872   // Figure out the size and type of the elements we will be copying.
5873   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5874   if (src_elem != T_BYTE) {
5875     return false;
5876   }
5877 
5878   // &#39;src_start&#39; points to src array + scaled offset
5879   src = must_be_not_null(src, true);
5880   Node* src_start = array_element_address(src, offset, src_elem);
5881 
5882   // static final int[] byteTable in class CRC32C
5883   Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
5884   table = must_be_not_null(table, true);
5885   Node* table_start = array_element_address(table, intcon(0), T_INT);
5886 
5887   // We assume that range check is done by caller.
5888   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5889 
5890   // Call the stub.
5891   address stubAddr = StubRoutines::updateBytesCRC32C();
5892   const char *stubName = &quot;updateBytesCRC32C&quot;;
5893 
5894   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesCRC32C_Type(),
5895                                  stubAddr, stubName, TypePtr::BOTTOM,
5896                                  crc, src_start, length, table_start);
5897   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5898   set_result(result);
5899   return true;
5900 }
5901 
5902 //------------------------------inline_updateDirectByteBufferCRC32C-----------------------
5903 //
5904 // Calculate CRC32C for DirectByteBuffer.
5905 // int java.util.zip.CRC32C.updateDirectByteBuffer(int crc, long buf, int off, int end)
5906 //
5907 bool LibraryCallKit::inline_updateDirectByteBufferCRC32C() {
5908   assert(UseCRC32CIntrinsics, &quot;need CRC32C instruction support&quot;);
5909   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateDirectByteBuffer has 4 parameters and one is long&quot;);
5910   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;CRC32C class must be loaded&quot;);
5911   // no receiver since it is a static method
5912   Node* crc     = argument(0); // type: int
5913   Node* src     = argument(1); // type: long
5914   Node* offset  = argument(3); // type: int
5915   Node* end     = argument(4); // type: int
5916 
5917   Node* length = _gvn.transform(new SubINode(end, offset));
5918 
5919   src = ConvL2X(src);  // adjust Java long to machine word
5920   Node* base = _gvn.transform(new CastX2PNode(src));
5921   offset = ConvI2X(offset);
5922 
5923   // &#39;src_start&#39; points to src array + scaled offset
5924   Node* src_start = basic_plus_adr(top(), base, offset);
5925 
5926   // static final int[] byteTable in class CRC32C
5927   Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
5928   table = must_be_not_null(table, true);
5929   Node* table_start = array_element_address(table, intcon(0), T_INT);
5930 
5931   // Call the stub.
5932   address stubAddr = StubRoutines::updateBytesCRC32C();
5933   const char *stubName = &quot;updateBytesCRC32C&quot;;
5934 
5935   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesCRC32C_Type(),
5936                                  stubAddr, stubName, TypePtr::BOTTOM,
5937                                  crc, src_start, length, table_start);
5938   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5939   set_result(result);
5940   return true;
5941 }
5942 
5943 //------------------------------inline_updateBytesAdler32----------------------
5944 //
5945 // Calculate Adler32 checksum for byte[] array.
5946 // int java.util.zip.Adler32.updateBytes(int crc, byte[] buf, int off, int len)
5947 //
5948 bool LibraryCallKit::inline_updateBytesAdler32() {
5949   assert(UseAdler32Intrinsics, &quot;Adler32 Instrinsic support need&quot;); // check if we actually need to check this flag or check a different one
5950   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;updateBytes has 4 parameters&quot;);
5951   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;Adler32 class must be loaded&quot;);
5952   // no receiver since it is static method
5953   Node* crc     = argument(0); // type: int
5954   Node* src     = argument(1); // type: oop
5955   Node* offset  = argument(2); // type: int
5956   Node* length  = argument(3); // type: int
5957 
5958   const Type* src_type = src-&gt;Value(&amp;_gvn);
5959   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5960   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5961     // failed array check
5962     return false;
5963   }
5964 
5965   // Figure out the size and type of the elements we will be copying.
5966   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5967   if (src_elem != T_BYTE) {
5968     return false;
5969   }
5970 
5971   // &#39;src_start&#39; points to src array + scaled offset
5972   Node* src_start = array_element_address(src, offset, src_elem);
5973 
5974   // We assume that range check is done by caller.
5975   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5976 
5977   // Call the stub.
5978   address stubAddr = StubRoutines::updateBytesAdler32();
5979   const char *stubName = &quot;updateBytesAdler32&quot;;
5980 
5981   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesAdler32_Type(),
5982                                  stubAddr, stubName, TypePtr::BOTTOM,
5983                                  crc, src_start, length);
5984   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5985   set_result(result);
5986   return true;
5987 }
5988 
5989 //------------------------------inline_updateByteBufferAdler32---------------
5990 //
5991 // Calculate Adler32 checksum for DirectByteBuffer.
5992 // int java.util.zip.Adler32.updateByteBuffer(int crc, long buf, int off, int len)
5993 //
5994 bool LibraryCallKit::inline_updateByteBufferAdler32() {
5995   assert(UseAdler32Intrinsics, &quot;Adler32 Instrinsic support need&quot;); // check if we actually need to check this flag or check a different one
5996   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateByteBuffer has 4 parameters and one is long&quot;);
5997   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;Adler32 class must be loaded&quot;);
5998   // no receiver since it is static method
5999   Node* crc     = argument(0); // type: int
6000   Node* src     = argument(1); // type: long
6001   Node* offset  = argument(3); // type: int
6002   Node* length  = argument(4); // type: int
6003 
6004   src = ConvL2X(src);  // adjust Java long to machine word
6005   Node* base = _gvn.transform(new CastX2PNode(src));
6006   offset = ConvI2X(offset);
6007 
6008   // &#39;src_start&#39; points to src array + scaled offset
6009   Node* src_start = basic_plus_adr(top(), base, offset);
6010 
6011   // Call the stub.
6012   address stubAddr = StubRoutines::updateBytesAdler32();
6013   const char *stubName = &quot;updateBytesAdler32&quot;;
6014 
6015   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesAdler32_Type(),
6016                                  stubAddr, stubName, TypePtr::BOTTOM,
6017                                  crc, src_start, length);
6018 
6019   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
6020   set_result(result);
6021   return true;
6022 }
6023 
6024 //----------------------------inline_reference_get----------------------------
6025 // public T java.lang.ref.Reference.get();
6026 bool LibraryCallKit::inline_reference_get() {
6027   const int referent_offset = java_lang_ref_Reference::referent_offset();
6028 
6029   // Get the argument:
6030   Node* reference_obj = null_check_receiver();
6031   if (stopped()) return true;
6032 
6033   const TypeInstPtr* tinst = _gvn.type(reference_obj)-&gt;isa_instptr();
6034   assert(tinst != NULL, &quot;obj is null&quot;);
6035   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
6036   ciInstanceKlass* referenceKlass = tinst-&gt;klass()-&gt;as_instance_klass();
6037   ciField* field = referenceKlass-&gt;get_field_by_name(ciSymbol::make(&quot;referent&quot;),
6038                                                      ciSymbol::make(&quot;Ljava/lang/Object;&quot;),
6039                                                      false);
6040   assert (field != NULL, &quot;undefined field&quot;);
6041 
6042   Node* adr = basic_plus_adr(reference_obj, reference_obj, referent_offset);
6043   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
6044 
6045   ciInstanceKlass* klass = env()-&gt;Object_klass();
6046   const TypeOopPtr* object_type = TypeOopPtr::make_from_klass(klass);
6047 
6048   DecoratorSet decorators = IN_HEAP | ON_WEAK_OOP_REF;
6049   Node* result = access_load_at(reference_obj, adr, adr_type, object_type, T_OBJECT, decorators);
6050   // Add memory barrier to prevent commoning reads from this field
6051   // across safepoint since GC can change its value.
6052   insert_mem_bar(Op_MemBarCPUOrder);
6053 
6054   set_result(result);
6055   return true;
6056 }
6057 
6058 
6059 Node * LibraryCallKit::load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString,
6060                                               bool is_exact=true, bool is_static=false,
6061                                               ciInstanceKlass * fromKls=NULL) {
6062   if (fromKls == NULL) {
6063     const TypeInstPtr* tinst = _gvn.type(fromObj)-&gt;isa_instptr();
6064     assert(tinst != NULL, &quot;obj is null&quot;);
6065     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
6066     assert(!is_exact || tinst-&gt;klass_is_exact(), &quot;klass not exact&quot;);
6067     fromKls = tinst-&gt;klass()-&gt;as_instance_klass();
6068   } else {
6069     assert(is_static, &quot;only for static field access&quot;);
6070   }
6071   ciField* field = fromKls-&gt;get_field_by_name(ciSymbol::make(fieldName),
6072                                               ciSymbol::make(fieldTypeString),
6073                                               is_static);
6074 
6075   assert (field != NULL, &quot;undefined field&quot;);
6076   if (field == NULL) return (Node *) NULL;
6077 
6078   if (is_static) {
6079     const TypeInstPtr* tip = TypeInstPtr::make(fromKls-&gt;java_mirror());
6080     fromObj = makecon(tip);
6081   }
6082 
6083   // Next code  copied from Parse::do_get_xxx():
6084 
6085   // Compute address and memory type.
6086   int offset  = field-&gt;offset_in_bytes();
6087   bool is_vol = field-&gt;is_volatile();
6088   ciType* field_klass = field-&gt;type();
6089   assert(field_klass-&gt;is_loaded(), &quot;should be loaded&quot;);
6090   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
6091   Node *adr = basic_plus_adr(fromObj, fromObj, offset);
6092   BasicType bt = field-&gt;layout_type();
6093 
6094   // Build the resultant type of the load
6095   const Type *type;
6096   if (bt == T_OBJECT) {
6097     type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
6098   } else {
6099     type = Type::get_const_basic_type(bt);
6100   }
6101 
6102   DecoratorSet decorators = IN_HEAP;
6103 
6104   if (is_vol) {
6105     decorators |= MO_SEQ_CST;
6106   }
6107 
6108   return access_load_at(fromObj, adr, adr_type, type, bt, decorators);
6109 }
6110 
6111 Node * LibraryCallKit::field_address_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString,
6112                                                  bool is_exact = true, bool is_static = false,
6113                                                  ciInstanceKlass * fromKls = NULL) {
6114   if (fromKls == NULL) {
6115     const TypeInstPtr* tinst = _gvn.type(fromObj)-&gt;isa_instptr();
6116     assert(tinst != NULL, &quot;obj is null&quot;);
6117     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
6118     assert(!is_exact || tinst-&gt;klass_is_exact(), &quot;klass not exact&quot;);
6119     fromKls = tinst-&gt;klass()-&gt;as_instance_klass();
6120   }
6121   else {
6122     assert(is_static, &quot;only for static field access&quot;);
6123   }
6124   ciField* field = fromKls-&gt;get_field_by_name(ciSymbol::make(fieldName),
6125     ciSymbol::make(fieldTypeString),
6126     is_static);
6127 
6128   assert(field != NULL, &quot;undefined field&quot;);
6129   assert(!field-&gt;is_volatile(), &quot;not defined for volatile fields&quot;);
6130 
6131   if (is_static) {
6132     const TypeInstPtr* tip = TypeInstPtr::make(fromKls-&gt;java_mirror());
6133     fromObj = makecon(tip);
6134   }
6135 
6136   // Next code  copied from Parse::do_get_xxx():
6137 
6138   // Compute address and memory type.
6139   int offset = field-&gt;offset_in_bytes();
6140   Node *adr = basic_plus_adr(fromObj, fromObj, offset);
6141 
6142   return adr;
6143 }
6144 
6145 //------------------------------inline_aescrypt_Block-----------------------
6146 bool LibraryCallKit::inline_aescrypt_Block(vmIntrinsics::ID id) {
6147   address stubAddr = NULL;
6148   const char *stubName;
6149   assert(UseAES, &quot;need AES instruction support&quot;);
6150 
6151   switch(id) {
6152   case vmIntrinsics::_aescrypt_encryptBlock:
6153     stubAddr = StubRoutines::aescrypt_encryptBlock();
6154     stubName = &quot;aescrypt_encryptBlock&quot;;
6155     break;
6156   case vmIntrinsics::_aescrypt_decryptBlock:
6157     stubAddr = StubRoutines::aescrypt_decryptBlock();
6158     stubName = &quot;aescrypt_decryptBlock&quot;;
6159     break;
6160   default:
6161     break;
6162   }
6163   if (stubAddr == NULL) return false;
6164 
6165   Node* aescrypt_object = argument(0);
6166   Node* src             = argument(1);
6167   Node* src_offset      = argument(2);
6168   Node* dest            = argument(3);
6169   Node* dest_offset     = argument(4);
6170 
6171   src = must_be_not_null(src, true);
6172   dest = must_be_not_null(dest, true);
6173 
6174   // (1) src and dest are arrays.
6175   const Type* src_type = src-&gt;Value(&amp;_gvn);
6176   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
6177   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6178   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
6179   assert (top_src  != NULL &amp;&amp; top_src-&gt;klass()  != NULL &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
6180 
6181   // for the quick and dirty code we will skip all the checks.
6182   // we are just trying to get the call to be generated.
6183   Node* src_start  = src;
6184   Node* dest_start = dest;
6185   if (src_offset != NULL || dest_offset != NULL) {
6186     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
6187     src_start  = array_element_address(src,  src_offset,  T_BYTE);
6188     dest_start = array_element_address(dest, dest_offset, T_BYTE);
6189   }
6190 
6191   // now need to get the start of its expanded key array
6192   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
6193   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
6194   if (k_start == NULL) return false;
6195 
6196   if (Matcher::pass_original_key_for_aes()) {
6197     // on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to
6198     // compatibility issues between Java key expansion and SPARC crypto instructions
6199     Node* original_k_start = get_original_key_start_from_aescrypt_object(aescrypt_object);
6200     if (original_k_start == NULL) return false;
6201 
6202     // Call the stub.
6203     make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::aescrypt_block_Type(),
6204                       stubAddr, stubName, TypePtr::BOTTOM,
6205                       src_start, dest_start, k_start, original_k_start);
6206   } else {
6207     // Call the stub.
6208     make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::aescrypt_block_Type(),
6209                       stubAddr, stubName, TypePtr::BOTTOM,
6210                       src_start, dest_start, k_start);
6211   }
6212 
6213   return true;
6214 }
6215 
6216 //------------------------------inline_cipherBlockChaining_AESCrypt-----------------------
6217 bool LibraryCallKit::inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id) {
6218   address stubAddr = NULL;
6219   const char *stubName = NULL;
6220 
6221   assert(UseAES, &quot;need AES instruction support&quot;);
6222 
6223   switch(id) {
6224   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
6225     stubAddr = StubRoutines::cipherBlockChaining_encryptAESCrypt();
6226     stubName = &quot;cipherBlockChaining_encryptAESCrypt&quot;;
6227     break;
6228   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
6229     stubAddr = StubRoutines::cipherBlockChaining_decryptAESCrypt();
6230     stubName = &quot;cipherBlockChaining_decryptAESCrypt&quot;;
6231     break;
6232   default:
6233     break;
6234   }
6235   if (stubAddr == NULL) return false;
6236 
6237   Node* cipherBlockChaining_object = argument(0);
6238   Node* src                        = argument(1);
6239   Node* src_offset                 = argument(2);
6240   Node* len                        = argument(3);
6241   Node* dest                       = argument(4);
6242   Node* dest_offset                = argument(5);
6243 
6244   src = must_be_not_null(src, false);
6245   dest = must_be_not_null(dest, false);
6246 
6247   // (1) src and dest are arrays.
6248   const Type* src_type = src-&gt;Value(&amp;_gvn);
6249   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
6250   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6251   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
6252   assert (top_src  != NULL &amp;&amp; top_src-&gt;klass()  != NULL
6253           &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
6254 
6255   // checks are the responsibility of the caller
6256   Node* src_start  = src;
6257   Node* dest_start = dest;
6258   if (src_offset != NULL || dest_offset != NULL) {
6259     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
6260     src_start  = array_element_address(src,  src_offset,  T_BYTE);
6261     dest_start = array_element_address(dest, dest_offset, T_BYTE);
6262   }
6263 
6264   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
6265   // (because of the predicated logic executed earlier).
6266   // so we cast it here safely.
6267   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
6268 
6269   Node* embeddedCipherObj = load_field_from_object(cipherBlockChaining_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6270   if (embeddedCipherObj == NULL) return false;
6271 
6272   // cast it to what we know it will be at runtime
6273   const TypeInstPtr* tinst = _gvn.type(cipherBlockChaining_object)-&gt;isa_instptr();
6274   assert(tinst != NULL, &quot;CBC obj is null&quot;);
6275   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CBC obj is not loaded&quot;);
6276   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6277   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6278 
6279   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6280   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
6281   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6282   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
6283   aescrypt_object = _gvn.transform(aescrypt_object);
6284 
6285   // we need to get the start of the aescrypt_object&#39;s expanded key array
6286   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
6287   if (k_start == NULL) return false;
6288 
6289   // similarly, get the start address of the r vector
6290   Node* objRvec = load_field_from_object(cipherBlockChaining_object, &quot;r&quot;, &quot;[B&quot;, /*is_exact*/ false);
6291   if (objRvec == NULL) return false;
6292   Node* r_start = array_element_address(objRvec, intcon(0), T_BYTE);
6293 
6294   Node* cbcCrypt;
6295   if (Matcher::pass_original_key_for_aes()) {
6296     // on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to
6297     // compatibility issues between Java key expansion and SPARC crypto instructions
6298     Node* original_k_start = get_original_key_start_from_aescrypt_object(aescrypt_object);
6299     if (original_k_start == NULL) return false;
6300 
6301     // Call the stub, passing src_start, dest_start, k_start, r_start, src_len and original_k_start
6302     cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
6303                                  OptoRuntime::cipherBlockChaining_aescrypt_Type(),
6304                                  stubAddr, stubName, TypePtr::BOTTOM,
6305                                  src_start, dest_start, k_start, r_start, len, original_k_start);
6306   } else {
6307     // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
6308     cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
6309                                  OptoRuntime::cipherBlockChaining_aescrypt_Type(),
6310                                  stubAddr, stubName, TypePtr::BOTTOM,
6311                                  src_start, dest_start, k_start, r_start, len);
6312   }
6313 
6314   // return cipher length (int)
6315   Node* retvalue = _gvn.transform(new ProjNode(cbcCrypt, TypeFunc::Parms));
6316   set_result(retvalue);
6317   return true;
6318 }
6319 
6320 //------------------------------inline_electronicCodeBook_AESCrypt-----------------------
6321 bool LibraryCallKit::inline_electronicCodeBook_AESCrypt(vmIntrinsics::ID id) {
6322   address stubAddr = NULL;
6323   const char *stubName = NULL;
6324 
6325   assert(UseAES, &quot;need AES instruction support&quot;);
6326 
6327   switch (id) {
6328   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
6329     stubAddr = StubRoutines::electronicCodeBook_encryptAESCrypt();
6330     stubName = &quot;electronicCodeBook_encryptAESCrypt&quot;;
6331     break;
6332   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
6333     stubAddr = StubRoutines::electronicCodeBook_decryptAESCrypt();
6334     stubName = &quot;electronicCodeBook_decryptAESCrypt&quot;;
6335     break;
6336   default:
6337     break;
6338   }
6339 
6340   if (stubAddr == NULL) return false;
6341 
6342   Node* electronicCodeBook_object = argument(0);
6343   Node* src                       = argument(1);
6344   Node* src_offset                = argument(2);
6345   Node* len                       = argument(3);
6346   Node* dest                      = argument(4);
6347   Node* dest_offset               = argument(5);
6348 
6349   // (1) src and dest are arrays.
6350   const Type* src_type = src-&gt;Value(&amp;_gvn);
6351   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
6352   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6353   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
6354   assert(top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL
6355          &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
6356 
6357   // checks are the responsibility of the caller
6358   Node* src_start = src;
6359   Node* dest_start = dest;
6360   if (src_offset != NULL || dest_offset != NULL) {
6361     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
6362     src_start = array_element_address(src, src_offset, T_BYTE);
6363     dest_start = array_element_address(dest, dest_offset, T_BYTE);
6364   }
6365 
6366   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
6367   // (because of the predicated logic executed earlier).
6368   // so we cast it here safely.
6369   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
6370 
6371   Node* embeddedCipherObj = load_field_from_object(electronicCodeBook_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6372   if (embeddedCipherObj == NULL) return false;
6373 
6374   // cast it to what we know it will be at runtime
6375   const TypeInstPtr* tinst = _gvn.type(electronicCodeBook_object)-&gt;isa_instptr();
6376   assert(tinst != NULL, &quot;ECB obj is null&quot;);
6377   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;ECB obj is not loaded&quot;);
6378   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6379   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6380 
6381   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6382   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
6383   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6384   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
6385   aescrypt_object = _gvn.transform(aescrypt_object);
6386 
6387   // we need to get the start of the aescrypt_object&#39;s expanded key array
6388   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
6389   if (k_start == NULL) return false;
6390 
6391   Node* ecbCrypt;
6392   if (Matcher::pass_original_key_for_aes()) {
6393     // no SPARC version for AES/ECB intrinsics now.
6394     return false;
6395   }
6396   // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
6397   ecbCrypt = make_runtime_call(RC_LEAF | RC_NO_FP,
6398                                OptoRuntime::electronicCodeBook_aescrypt_Type(),
6399                                stubAddr, stubName, TypePtr::BOTTOM,
6400                                src_start, dest_start, k_start, len);
6401 
6402   // return cipher length (int)
6403   Node* retvalue = _gvn.transform(new ProjNode(ecbCrypt, TypeFunc::Parms));
6404   set_result(retvalue);
6405   return true;
6406 }
6407 
6408 //------------------------------inline_counterMode_AESCrypt-----------------------
6409 bool LibraryCallKit::inline_counterMode_AESCrypt(vmIntrinsics::ID id) {
6410   assert(UseAES, &quot;need AES instruction support&quot;);
6411   if (!UseAESCTRIntrinsics) return false;
6412 
6413   address stubAddr = NULL;
6414   const char *stubName = NULL;
6415   if (id == vmIntrinsics::_counterMode_AESCrypt) {
6416     stubAddr = StubRoutines::counterMode_AESCrypt();
6417     stubName = &quot;counterMode_AESCrypt&quot;;
6418   }
6419   if (stubAddr == NULL) return false;
6420 
6421   Node* counterMode_object = argument(0);
6422   Node* src = argument(1);
6423   Node* src_offset = argument(2);
6424   Node* len = argument(3);
6425   Node* dest = argument(4);
6426   Node* dest_offset = argument(5);
6427 
6428   // (1) src and dest are arrays.
6429   const Type* src_type = src-&gt;Value(&amp;_gvn);
6430   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
6431   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6432   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
6433   assert(top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL &amp;&amp;
6434          top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
6435 
6436   // checks are the responsibility of the caller
6437   Node* src_start = src;
6438   Node* dest_start = dest;
6439   if (src_offset != NULL || dest_offset != NULL) {
6440     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
6441     src_start = array_element_address(src, src_offset, T_BYTE);
6442     dest_start = array_element_address(dest, dest_offset, T_BYTE);
6443   }
6444 
6445   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
6446   // (because of the predicated logic executed earlier).
6447   // so we cast it here safely.
6448   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
6449   Node* embeddedCipherObj = load_field_from_object(counterMode_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6450   if (embeddedCipherObj == NULL) return false;
6451   // cast it to what we know it will be at runtime
6452   const TypeInstPtr* tinst = _gvn.type(counterMode_object)-&gt;isa_instptr();
6453   assert(tinst != NULL, &quot;CTR obj is null&quot;);
6454   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CTR obj is not loaded&quot;);
6455   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6456   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6457   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6458   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
6459   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6460   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
6461   aescrypt_object = _gvn.transform(aescrypt_object);
6462   // we need to get the start of the aescrypt_object&#39;s expanded key array
6463   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
6464   if (k_start == NULL) return false;
6465   // similarly, get the start address of the r vector
6466   Node* obj_counter = load_field_from_object(counterMode_object, &quot;counter&quot;, &quot;[B&quot;, /*is_exact*/ false);
6467   if (obj_counter == NULL) return false;
6468   Node* cnt_start = array_element_address(obj_counter, intcon(0), T_BYTE);
6469 
6470   Node* saved_encCounter = load_field_from_object(counterMode_object, &quot;encryptedCounter&quot;, &quot;[B&quot;, /*is_exact*/ false);
6471   if (saved_encCounter == NULL) return false;
6472   Node* saved_encCounter_start = array_element_address(saved_encCounter, intcon(0), T_BYTE);
6473   Node* used = field_address_from_object(counterMode_object, &quot;used&quot;, &quot;I&quot;, /*is_exact*/ false);
6474 
6475   Node* ctrCrypt;
6476   if (Matcher::pass_original_key_for_aes()) {
6477     // no SPARC version for AES/CTR intrinsics now.
6478     return false;
6479   }
6480   // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
6481   ctrCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
6482                                OptoRuntime::counterMode_aescrypt_Type(),
6483                                stubAddr, stubName, TypePtr::BOTTOM,
6484                                src_start, dest_start, k_start, cnt_start, len, saved_encCounter_start, used);
6485 
6486   // return cipher length (int)
6487   Node* retvalue = _gvn.transform(new ProjNode(ctrCrypt, TypeFunc::Parms));
6488   set_result(retvalue);
6489   return true;
6490 }
6491 
6492 //------------------------------get_key_start_from_aescrypt_object-----------------------
6493 Node * LibraryCallKit::get_key_start_from_aescrypt_object(Node *aescrypt_object) {
6494 #if defined(PPC64) || defined(S390)
6495   // MixColumns for decryption can be reduced by preprocessing MixColumns with round keys.
6496   // Intel&#39;s extention is based on this optimization and AESCrypt generates round keys by preprocessing MixColumns.
6497   // However, ppc64 vncipher processes MixColumns and requires the same round keys with encryption.
6498   // The ppc64 stubs of encryption and decryption use the same round keys (sessionK[0]).
6499   Node* objSessionK = load_field_from_object(aescrypt_object, &quot;sessionK&quot;, &quot;[[I&quot;, /*is_exact*/ false);
6500   assert (objSessionK != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6501   if (objSessionK == NULL) {
6502     return (Node *) NULL;
6503   }
6504   Node* objAESCryptKey = load_array_element(control(), objSessionK, intcon(0), TypeAryPtr::OOPS);
6505 #else
6506   Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;K&quot;, &quot;[I&quot;, /*is_exact*/ false);
6507 #endif // PPC64
6508   assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6509   if (objAESCryptKey == NULL) return (Node *) NULL;
6510 
6511   // now have the array, need to get the start address of the K array
6512   Node* k_start = array_element_address(objAESCryptKey, intcon(0), T_INT);
6513   return k_start;
6514 }
6515 
6516 //------------------------------get_original_key_start_from_aescrypt_object-----------------------
6517 Node * LibraryCallKit::get_original_key_start_from_aescrypt_object(Node *aescrypt_object) {
6518   Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;lastKey&quot;, &quot;[B&quot;, /*is_exact*/ false);
6519   assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6520   if (objAESCryptKey == NULL) return (Node *) NULL;
6521 
6522   // now have the array, need to get the start address of the lastKey array
6523   Node* original_k_start = array_element_address(objAESCryptKey, intcon(0), T_BYTE);
6524   return original_k_start;
6525 }
6526 
6527 //----------------------------inline_cipherBlockChaining_AESCrypt_predicate----------------------------
6528 // Return node representing slow path of predicate check.
6529 // the pseudo code we want to emulate with this predicate is:
6530 // for encryption:
6531 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6532 // for decryption:
6533 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6534 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6535 //
6536 Node* LibraryCallKit::inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting) {
6537   // The receiver was checked for NULL already.
6538   Node* objCBC = argument(0);
6539 
6540   Node* src = argument(1);
6541   Node* dest = argument(4);
6542 
6543   // Load embeddedCipher field of CipherBlockChaining object.
6544   Node* embeddedCipherObj = load_field_from_object(objCBC, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6545 
6546   // get AESCrypt klass for instanceOf check
6547   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6548   // will have same classloader as CipherBlockChaining object
6549   const TypeInstPtr* tinst = _gvn.type(objCBC)-&gt;isa_instptr();
6550   assert(tinst != NULL, &quot;CBCobj is null&quot;);
6551   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CBCobj is not loaded&quot;);
6552 
6553   // we want to do an instanceof comparison against the AESCrypt class
6554   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6555   if (!klass_AESCrypt-&gt;is_loaded()) {
6556     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6557     Node* ctrl = control();
6558     set_control(top()); // no regular fast path
6559     return ctrl;
6560   }
6561 
6562   src = must_be_not_null(src, true);
6563   dest = must_be_not_null(dest, true);
6564 
6565   // Resolve oops to stable for CmpP below.
6566   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6567 
6568   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6569   Node* cmp_instof  = _gvn.transform(new CmpINode(instof, intcon(1)));
6570   Node* bool_instof  = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6571 
6572   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6573 
6574   // for encryption, we are done
6575   if (!decrypting)
6576     return instof_false;  // even if it is NULL
6577 
6578   // for decryption, we need to add a further check to avoid
6579   // taking the intrinsic path when cipher and plain are the same
6580   // see the original java code for why.
6581   RegionNode* region = new RegionNode(3);
6582   region-&gt;init_req(1, instof_false);
6583 
6584   Node* cmp_src_dest = _gvn.transform(new CmpPNode(src, dest));
6585   Node* bool_src_dest = _gvn.transform(new BoolNode(cmp_src_dest, BoolTest::eq));
6586   Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);
6587   region-&gt;init_req(2, src_dest_conjoint);
6588 
6589   record_for_igvn(region);
6590   return _gvn.transform(region);
6591 }
6592 
6593 //----------------------------inline_electronicCodeBook_AESCrypt_predicate----------------------------
6594 // Return node representing slow path of predicate check.
6595 // the pseudo code we want to emulate with this predicate is:
6596 // for encryption:
6597 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6598 // for decryption:
6599 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6600 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6601 //
6602 Node* LibraryCallKit::inline_electronicCodeBook_AESCrypt_predicate(bool decrypting) {
6603   // The receiver was checked for NULL already.
6604   Node* objECB = argument(0);
6605 
6606   // Load embeddedCipher field of ElectronicCodeBook object.
6607   Node* embeddedCipherObj = load_field_from_object(objECB, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6608 
6609   // get AESCrypt klass for instanceOf check
6610   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6611   // will have same classloader as ElectronicCodeBook object
6612   const TypeInstPtr* tinst = _gvn.type(objECB)-&gt;isa_instptr();
6613   assert(tinst != NULL, &quot;ECBobj is null&quot;);
6614   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;ECBobj is not loaded&quot;);
6615 
6616   // we want to do an instanceof comparison against the AESCrypt class
6617   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6618   if (!klass_AESCrypt-&gt;is_loaded()) {
6619     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6620     Node* ctrl = control();
6621     set_control(top()); // no regular fast path
6622     return ctrl;
6623   }
6624   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6625 
6626   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6627   Node* cmp_instof = _gvn.transform(new CmpINode(instof, intcon(1)));
6628   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6629 
6630   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6631 
6632   // for encryption, we are done
6633   if (!decrypting)
6634     return instof_false;  // even if it is NULL
6635 
6636   // for decryption, we need to add a further check to avoid
6637   // taking the intrinsic path when cipher and plain are the same
6638   // see the original java code for why.
6639   RegionNode* region = new RegionNode(3);
6640   region-&gt;init_req(1, instof_false);
6641   Node* src = argument(1);
6642   Node* dest = argument(4);
6643   Node* cmp_src_dest = _gvn.transform(new CmpPNode(src, dest));
6644   Node* bool_src_dest = _gvn.transform(new BoolNode(cmp_src_dest, BoolTest::eq));
6645   Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);
6646   region-&gt;init_req(2, src_dest_conjoint);
6647 
6648   record_for_igvn(region);
6649   return _gvn.transform(region);
6650 }
6651 
6652 //----------------------------inline_counterMode_AESCrypt_predicate----------------------------
6653 // Return node representing slow path of predicate check.
6654 // the pseudo code we want to emulate with this predicate is:
6655 // for encryption:
6656 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6657 // for decryption:
6658 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6659 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6660 //
6661 
6662 Node* LibraryCallKit::inline_counterMode_AESCrypt_predicate() {
6663   // The receiver was checked for NULL already.
6664   Node* objCTR = argument(0);
6665 
6666   // Load embeddedCipher field of CipherBlockChaining object.
6667   Node* embeddedCipherObj = load_field_from_object(objCTR, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6668 
6669   // get AESCrypt klass for instanceOf check
6670   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6671   // will have same classloader as CipherBlockChaining object
6672   const TypeInstPtr* tinst = _gvn.type(objCTR)-&gt;isa_instptr();
6673   assert(tinst != NULL, &quot;CTRobj is null&quot;);
6674   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CTRobj is not loaded&quot;);
6675 
6676   // we want to do an instanceof comparison against the AESCrypt class
6677   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6678   if (!klass_AESCrypt-&gt;is_loaded()) {
6679     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6680     Node* ctrl = control();
6681     set_control(top()); // no regular fast path
6682     return ctrl;
6683   }
6684 
6685   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6686   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6687   Node* cmp_instof = _gvn.transform(new CmpINode(instof, intcon(1)));
6688   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6689   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6690 
6691   return instof_false; // even if it is NULL
6692 }
6693 
6694 //------------------------------inline_ghash_processBlocks
6695 bool LibraryCallKit::inline_ghash_processBlocks() {
6696   address stubAddr;
6697   const char *stubName;
6698   assert(UseGHASHIntrinsics, &quot;need GHASH intrinsics support&quot;);
6699 
6700   stubAddr = StubRoutines::ghash_processBlocks();
6701   stubName = &quot;ghash_processBlocks&quot;;
6702 
6703   Node* data           = argument(0);
6704   Node* offset         = argument(1);
6705   Node* len            = argument(2);
6706   Node* state          = argument(3);
6707   Node* subkeyH        = argument(4);
6708 
6709   state = must_be_not_null(state, true);
6710   subkeyH = must_be_not_null(subkeyH, true);
6711   data = must_be_not_null(data, true);
6712 
6713   Node* state_start  = array_element_address(state, intcon(0), T_LONG);
6714   assert(state_start, &quot;state is NULL&quot;);
6715   Node* subkeyH_start  = array_element_address(subkeyH, intcon(0), T_LONG);
6716   assert(subkeyH_start, &quot;subkeyH is NULL&quot;);
6717   Node* data_start  = array_element_address(data, offset, T_BYTE);
6718   assert(data_start, &quot;data is NULL&quot;);
6719 
6720   Node* ghash = make_runtime_call(RC_LEAF|RC_NO_FP,
6721                                   OptoRuntime::ghash_processBlocks_Type(),
6722                                   stubAddr, stubName, TypePtr::BOTTOM,
6723                                   state_start, subkeyH_start, data_start, len);
6724   return true;
6725 }
6726 
6727 bool LibraryCallKit::inline_base64_encodeBlock() {
6728   address stubAddr;
6729   const char *stubName;
6730   assert(UseBASE64Intrinsics, &quot;need Base64 intrinsics support&quot;);
6731   assert(callee()-&gt;signature()-&gt;size() == 6, &quot;base64_encodeBlock has 6 parameters&quot;);
6732   stubAddr = StubRoutines::base64_encodeBlock();
6733   stubName = &quot;encodeBlock&quot;;
6734 
6735   if (!stubAddr) return false;
6736   Node* base64obj = argument(0);
6737   Node* src = argument(1);
6738   Node* offset = argument(2);
6739   Node* len = argument(3);
6740   Node* dest = argument(4);
6741   Node* dp = argument(5);
6742   Node* isURL = argument(6);
6743 
6744   src = must_be_not_null(src, true);
6745   dest = must_be_not_null(dest, true);
6746 
6747   Node* src_start = array_element_address(src, intcon(0), T_BYTE);
6748   assert(src_start, &quot;source array is NULL&quot;);
6749   Node* dest_start = array_element_address(dest, intcon(0), T_BYTE);
6750   assert(dest_start, &quot;destination array is NULL&quot;);
6751 
6752   Node* base64 = make_runtime_call(RC_LEAF,
6753                                    OptoRuntime::base64_encodeBlock_Type(),
6754                                    stubAddr, stubName, TypePtr::BOTTOM,
6755                                    src_start, offset, len, dest_start, dp, isURL);
6756   return true;
6757 }
6758 
6759 //------------------------------inline_sha_implCompress-----------------------
6760 //
6761 // Calculate SHA (i.e., SHA-1) for single-block byte[] array.
6762 // void com.sun.security.provider.SHA.implCompress(byte[] buf, int ofs)
6763 //
6764 // Calculate SHA2 (i.e., SHA-244 or SHA-256) for single-block byte[] array.
6765 // void com.sun.security.provider.SHA2.implCompress(byte[] buf, int ofs)
6766 //
6767 // Calculate SHA5 (i.e., SHA-384 or SHA-512) for single-block byte[] array.
6768 // void com.sun.security.provider.SHA5.implCompress(byte[] buf, int ofs)
6769 //
6770 bool LibraryCallKit::inline_sha_implCompress(vmIntrinsics::ID id) {
6771   assert(callee()-&gt;signature()-&gt;size() == 2, &quot;sha_implCompress has 2 parameters&quot;);
6772 
6773   Node* sha_obj = argument(0);
6774   Node* src     = argument(1); // type oop
6775   Node* ofs     = argument(2); // type int
6776 
6777   const Type* src_type = src-&gt;Value(&amp;_gvn);
6778   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6779   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
6780     // failed array check
6781     return false;
6782   }
6783   // Figure out the size and type of the elements we will be copying.
6784   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
6785   if (src_elem != T_BYTE) {
6786     return false;
6787   }
6788   // &#39;src_start&#39; points to src array + offset
6789   src = must_be_not_null(src, true);
6790   Node* src_start = array_element_address(src, ofs, src_elem);
6791   Node* state = NULL;
6792   address stubAddr;
6793   const char *stubName;
6794 
6795   switch(id) {
6796   case vmIntrinsics::_sha_implCompress:
6797     assert(UseSHA1Intrinsics, &quot;need SHA1 instruction support&quot;);
6798     state = get_state_from_sha_object(sha_obj);
6799     stubAddr = StubRoutines::sha1_implCompress();
6800     stubName = &quot;sha1_implCompress&quot;;
6801     break;
6802   case vmIntrinsics::_sha2_implCompress:
6803     assert(UseSHA256Intrinsics, &quot;need SHA256 instruction support&quot;);
6804     state = get_state_from_sha_object(sha_obj);
6805     stubAddr = StubRoutines::sha256_implCompress();
6806     stubName = &quot;sha256_implCompress&quot;;
6807     break;
6808   case vmIntrinsics::_sha5_implCompress:
6809     assert(UseSHA512Intrinsics, &quot;need SHA512 instruction support&quot;);
6810     state = get_state_from_sha5_object(sha_obj);
6811     stubAddr = StubRoutines::sha512_implCompress();
6812     stubName = &quot;sha512_implCompress&quot;;
6813     break;
6814   default:
6815     fatal_unexpected_iid(id);
6816     return false;
6817   }
6818   if (state == NULL) return false;
6819 
6820   assert(stubAddr != NULL, &quot;Stub is generated&quot;);
6821   if (stubAddr == NULL) return false;
6822 
6823   // Call the stub.
6824   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::sha_implCompress_Type(),
6825                                  stubAddr, stubName, TypePtr::BOTTOM,
6826                                  src_start, state);
6827 
6828   return true;
6829 }
6830 
6831 //------------------------------inline_digestBase_implCompressMB-----------------------
6832 //
6833 // Calculate SHA/SHA2/SHA5 for multi-block byte[] array.
6834 // int com.sun.security.provider.DigestBase.implCompressMultiBlock(byte[] b, int ofs, int limit)
6835 //
6836 bool LibraryCallKit::inline_digestBase_implCompressMB(int predicate) {
6837   assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,
6838          &quot;need SHA1/SHA256/SHA512 instruction support&quot;);
6839   assert((uint)predicate &lt; 3, &quot;sanity&quot;);
6840   assert(callee()-&gt;signature()-&gt;size() == 3, &quot;digestBase_implCompressMB has 3 parameters&quot;);
6841 
6842   Node* digestBase_obj = argument(0); // The receiver was checked for NULL already.
6843   Node* src            = argument(1); // byte[] array
6844   Node* ofs            = argument(2); // type int
6845   Node* limit          = argument(3); // type int
6846 
6847   const Type* src_type = src-&gt;Value(&amp;_gvn);
6848   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6849   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
6850     // failed array check
6851     return false;
6852   }
6853   // Figure out the size and type of the elements we will be copying.
6854   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
6855   if (src_elem != T_BYTE) {
6856     return false;
6857   }
6858   // &#39;src_start&#39; points to src array + offset
6859   src = must_be_not_null(src, false);
6860   Node* src_start = array_element_address(src, ofs, src_elem);
6861 
6862   const char* klass_SHA_name = NULL;
6863   const char* stub_name = NULL;
6864   address     stub_addr = NULL;
6865   bool        long_state = false;
6866 
6867   switch (predicate) {
6868   case 0:
6869     if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_sha_implCompress)) {
6870       klass_SHA_name = &quot;sun/security/provider/SHA&quot;;
6871       stub_name = &quot;sha1_implCompressMB&quot;;
6872       stub_addr = StubRoutines::sha1_implCompressMB();
6873     }
6874     break;
6875   case 1:
6876     if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_sha2_implCompress)) {
6877       klass_SHA_name = &quot;sun/security/provider/SHA2&quot;;
6878       stub_name = &quot;sha256_implCompressMB&quot;;
6879       stub_addr = StubRoutines::sha256_implCompressMB();
6880     }
6881     break;
6882   case 2:
6883     if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_sha5_implCompress)) {
6884       klass_SHA_name = &quot;sun/security/provider/SHA5&quot;;
6885       stub_name = &quot;sha512_implCompressMB&quot;;
6886       stub_addr = StubRoutines::sha512_implCompressMB();
6887       long_state = true;
6888     }
6889     break;
6890   default:
6891     fatal(&quot;unknown SHA intrinsic predicate: %d&quot;, predicate);
6892   }
6893   if (klass_SHA_name != NULL) {
6894     assert(stub_addr != NULL, &quot;Stub is generated&quot;);
6895     if (stub_addr == NULL) return false;
6896 
6897     // get DigestBase klass to lookup for SHA klass
6898     const TypeInstPtr* tinst = _gvn.type(digestBase_obj)-&gt;isa_instptr();
6899     assert(tinst != NULL, &quot;digestBase_obj is not instance???&quot;);
6900     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;DigestBase is not loaded&quot;);
6901 
6902     ciKlass* klass_SHA = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(klass_SHA_name));
6903     assert(klass_SHA-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6904     ciInstanceKlass* instklass_SHA = klass_SHA-&gt;as_instance_klass();
6905     return inline_sha_implCompressMB(digestBase_obj, instklass_SHA, long_state, stub_addr, stub_name, src_start, ofs, limit);
6906   }
6907   return false;
6908 }
6909 //------------------------------inline_sha_implCompressMB-----------------------
6910 bool LibraryCallKit::inline_sha_implCompressMB(Node* digestBase_obj, ciInstanceKlass* instklass_SHA,
6911                                                bool long_state, address stubAddr, const char *stubName,
6912                                                Node* src_start, Node* ofs, Node* limit) {
6913   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_SHA);
6914   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6915   Node* sha_obj = new CheckCastPPNode(control(), digestBase_obj, xtype);
6916   sha_obj = _gvn.transform(sha_obj);
6917 
6918   Node* state;
6919   if (long_state) {
6920     state = get_state_from_sha5_object(sha_obj);
6921   } else {
6922     state = get_state_from_sha_object(sha_obj);
6923   }
6924   if (state == NULL) return false;
6925 
6926   // Call the stub.
6927   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
6928                                  OptoRuntime::digestBase_implCompressMB_Type(),
6929                                  stubAddr, stubName, TypePtr::BOTTOM,
6930                                  src_start, state, ofs, limit);
6931   // return ofs (int)
6932   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
6933   set_result(result);
6934 
6935   return true;
6936 }
6937 
6938 //------------------------------get_state_from_sha_object-----------------------
6939 Node * LibraryCallKit::get_state_from_sha_object(Node *sha_object) {
6940   Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[I&quot;, /*is_exact*/ false);
6941   assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA/SHA2&quot;);
6942   if (sha_state == NULL) return (Node *) NULL;
6943 
6944   // now have the array, need to get the start address of the state array
6945   Node* state = array_element_address(sha_state, intcon(0), T_INT);
6946   return state;
6947 }
6948 
6949 //------------------------------get_state_from_sha5_object-----------------------
6950 Node * LibraryCallKit::get_state_from_sha5_object(Node *sha_object) {
6951   Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[J&quot;, /*is_exact*/ false);
6952   assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA5&quot;);
6953   if (sha_state == NULL) return (Node *) NULL;
6954 
6955   // now have the array, need to get the start address of the state array
6956   Node* state = array_element_address(sha_state, intcon(0), T_LONG);
6957   return state;
6958 }
6959 
6960 //----------------------------inline_digestBase_implCompressMB_predicate----------------------------
6961 // Return node representing slow path of predicate check.
6962 // the pseudo code we want to emulate with this predicate is:
6963 //    if (digestBaseObj instanceof SHA/SHA2/SHA5) do_intrinsic, else do_javapath
6964 //
6965 Node* LibraryCallKit::inline_digestBase_implCompressMB_predicate(int predicate) {
6966   assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,
6967          &quot;need SHA1/SHA256/SHA512 instruction support&quot;);
6968   assert((uint)predicate &lt; 3, &quot;sanity&quot;);
6969 
6970   // The receiver was checked for NULL already.
6971   Node* digestBaseObj = argument(0);
6972 
6973   // get DigestBase klass for instanceOf check
6974   const TypeInstPtr* tinst = _gvn.type(digestBaseObj)-&gt;isa_instptr();
6975   assert(tinst != NULL, &quot;digestBaseObj is null&quot;);
6976   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;DigestBase is not loaded&quot;);
6977 
6978   const char* klass_SHA_name = NULL;
6979   switch (predicate) {
6980   case 0:
6981     if (UseSHA1Intrinsics) {
6982       // we want to do an instanceof comparison against the SHA class
6983       klass_SHA_name = &quot;sun/security/provider/SHA&quot;;
6984     }
6985     break;
6986   case 1:
6987     if (UseSHA256Intrinsics) {
6988       // we want to do an instanceof comparison against the SHA2 class
6989       klass_SHA_name = &quot;sun/security/provider/SHA2&quot;;
6990     }
6991     break;
6992   case 2:
6993     if (UseSHA512Intrinsics) {
6994       // we want to do an instanceof comparison against the SHA5 class
6995       klass_SHA_name = &quot;sun/security/provider/SHA5&quot;;
6996     }
6997     break;
6998   default:
6999     fatal(&quot;unknown SHA intrinsic predicate: %d&quot;, predicate);
7000   }
7001 
7002   ciKlass* klass_SHA = NULL;
7003   if (klass_SHA_name != NULL) {
7004     klass_SHA = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(klass_SHA_name));
7005   }
7006   if ((klass_SHA == NULL) || !klass_SHA-&gt;is_loaded()) {
7007     // if none of SHA/SHA2/SHA5 is loaded, we never take the intrinsic fast path
7008     Node* ctrl = control();
7009     set_control(top()); // no intrinsic path
7010     return ctrl;
7011   }
7012   ciInstanceKlass* instklass_SHA = klass_SHA-&gt;as_instance_klass();
7013 
7014   Node* instofSHA = gen_instanceof(digestBaseObj, makecon(TypeKlassPtr::make(instklass_SHA)));
7015   Node* cmp_instof = _gvn.transform(new CmpINode(instofSHA, intcon(1)));
7016   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
7017   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
7018 
7019   return instof_false;  // even if it is NULL
7020 }
7021 
7022 //-------------inline_fma-----------------------------------
7023 bool LibraryCallKit::inline_fma(vmIntrinsics::ID id) {
7024   Node *a = NULL;
7025   Node *b = NULL;
7026   Node *c = NULL;
7027   Node* result = NULL;
7028   switch (id) {
7029   case vmIntrinsics::_fmaD:
7030     assert(callee()-&gt;signature()-&gt;size() == 6, &quot;fma has 3 parameters of size 2 each.&quot;);
7031     // no receiver since it is static method
7032     a = round_double_node(argument(0));
7033     b = round_double_node(argument(2));
7034     c = round_double_node(argument(4));
7035     result = _gvn.transform(new FmaDNode(control(), a, b, c));
7036     break;
7037   case vmIntrinsics::_fmaF:
7038     assert(callee()-&gt;signature()-&gt;size() == 3, &quot;fma has 3 parameters of size 1 each.&quot;);
7039     a = argument(0);
7040     b = argument(1);
7041     c = argument(2);
7042     result = _gvn.transform(new FmaFNode(control(), a, b, c));
7043     break;
7044   default:
7045     fatal_unexpected_iid(id);  break;
7046   }
7047   set_result(result);
7048   return true;
7049 }
7050 
7051 bool LibraryCallKit::inline_character_compare(vmIntrinsics::ID id) {
7052   // argument(0) is receiver
7053   Node* codePoint = argument(1);
7054   Node* n = NULL;
7055 
7056   switch (id) {
7057     case vmIntrinsics::_isDigit :
7058       n = new DigitNode(control(), codePoint);
7059       break;
7060     case vmIntrinsics::_isLowerCase :
7061       n = new LowerCaseNode(control(), codePoint);
7062       break;
7063     case vmIntrinsics::_isUpperCase :
7064       n = new UpperCaseNode(control(), codePoint);
7065       break;
7066     case vmIntrinsics::_isWhitespace :
7067       n = new WhitespaceNode(control(), codePoint);
7068       break;
7069     default:
7070       fatal_unexpected_iid(id);
7071   }
7072 
7073   set_result(_gvn.transform(n));
7074   return true;
7075 }
7076 
7077 //------------------------------inline_fp_min_max------------------------------
7078 bool LibraryCallKit::inline_fp_min_max(vmIntrinsics::ID id) {
7079 /* DISABLED BECAUSE METHOD DATA ISN&#39;T COLLECTED PER CALL-SITE, SEE JDK-8015416.
7080 
7081   // The intrinsic should be used only when the API branches aren&#39;t predictable,
7082   // the last one performing the most important comparison. The following heuristic
7083   // uses the branch statistics to eventually bail out if necessary.
7084 
7085   ciMethodData *md = callee()-&gt;method_data();
7086 
7087   if ( md != NULL &amp;&amp; md-&gt;is_mature() &amp;&amp; md-&gt;invocation_count() &gt; 0 ) {
7088     ciCallProfile cp = caller()-&gt;call_profile_at_bci(bci());
7089 
7090     if ( ((double)cp.count()) / ((double)md-&gt;invocation_count()) &lt; 0.8 ) {
7091       // Bail out if the call-site didn&#39;t contribute enough to the statistics.
7092       return false;
7093     }
7094 
7095     uint taken = 0, not_taken = 0;
7096 
7097     for (ciProfileData *p = md-&gt;first_data(); md-&gt;is_valid(p); p = md-&gt;next_data(p)) {
7098       if (p-&gt;is_BranchData()) {
7099         taken = ((ciBranchData*)p)-&gt;taken();
7100         not_taken = ((ciBranchData*)p)-&gt;not_taken();
7101       }
7102     }
7103 
7104     double balance = (((double)taken) - ((double)not_taken)) / ((double)md-&gt;invocation_count());
7105     balance = balance &lt; 0 ? -balance : balance;
7106     if ( balance &gt; 0.2 ) {
7107       // Bail out if the most important branch is predictable enough.
7108       return false;
7109     }
7110   }
7111 */
7112 
7113   Node *a = NULL;
7114   Node *b = NULL;
7115   Node *n = NULL;
7116   switch (id) {
7117   case vmIntrinsics::_maxF:
7118   case vmIntrinsics::_minF:
7119     assert(callee()-&gt;signature()-&gt;size() == 2, &quot;minF/maxF has 2 parameters of size 1 each.&quot;);
7120     a = argument(0);
7121     b = argument(1);
7122     break;
7123   case vmIntrinsics::_maxD:
7124   case vmIntrinsics::_minD:
7125     assert(callee()-&gt;signature()-&gt;size() == 4, &quot;minD/maxD has 2 parameters of size 2 each.&quot;);
7126     a = round_double_node(argument(0));
7127     b = round_double_node(argument(2));
7128     break;
7129   default:
7130     fatal_unexpected_iid(id);
7131     break;
7132   }
7133   switch (id) {
7134   case vmIntrinsics::_maxF:  n = new MaxFNode(a, b);  break;
7135   case vmIntrinsics::_minF:  n = new MinFNode(a, b);  break;
7136   case vmIntrinsics::_maxD:  n = new MaxDNode(a, b);  break;
7137   case vmIntrinsics::_minD:  n = new MinDNode(a, b);  break;
7138   default:  fatal_unexpected_iid(id);  break;
7139   }
7140   set_result(_gvn.transform(n));
7141   return true;
7142 }
7143 
7144 bool LibraryCallKit::inline_profileBoolean() {
7145   Node* counts = argument(1);
7146   const TypeAryPtr* ary = NULL;
7147   ciArray* aobj = NULL;
7148   if (counts-&gt;is_Con()
7149       &amp;&amp; (ary = counts-&gt;bottom_type()-&gt;isa_aryptr()) != NULL
7150       &amp;&amp; (aobj = ary-&gt;const_oop()-&gt;as_array()) != NULL
7151       &amp;&amp; (aobj-&gt;length() == 2)) {
7152     // Profile is int[2] where [0] and [1] correspond to false and true value occurrences respectively.
7153     jint false_cnt = aobj-&gt;element_value(0).as_int();
7154     jint  true_cnt = aobj-&gt;element_value(1).as_int();
7155 
7156     if (C-&gt;log() != NULL) {
7157       C-&gt;log()-&gt;elem(&quot;observe source=&#39;profileBoolean&#39; false=&#39;%d&#39; true=&#39;%d&#39;&quot;,
7158                      false_cnt, true_cnt);
7159     }
7160 
7161     if (false_cnt + true_cnt == 0) {
7162       // According to profile, never executed.
7163       uncommon_trap_exact(Deoptimization::Reason_intrinsic,
7164                           Deoptimization::Action_reinterpret);
7165       return true;
7166     }
7167 
7168     // result is a boolean (0 or 1) and its profile (false_cnt &amp; true_cnt)
7169     // is a number of each value occurrences.
7170     Node* result = argument(0);
7171     if (false_cnt == 0 || true_cnt == 0) {
7172       // According to profile, one value has been never seen.
7173       int expected_val = (false_cnt == 0) ? 1 : 0;
7174 
7175       Node* cmp  = _gvn.transform(new CmpINode(result, intcon(expected_val)));
7176       Node* test = _gvn.transform(new BoolNode(cmp, BoolTest::eq));
7177 
7178       IfNode* check = create_and_map_if(control(), test, PROB_ALWAYS, COUNT_UNKNOWN);
7179       Node* fast_path = _gvn.transform(new IfTrueNode(check));
7180       Node* slow_path = _gvn.transform(new IfFalseNode(check));
7181 
7182       { // Slow path: uncommon trap for never seen value and then reexecute
7183         // MethodHandleImpl::profileBoolean() to bump the count, so JIT knows
7184         // the value has been seen at least once.
7185         PreserveJVMState pjvms(this);
7186         PreserveReexecuteState preexecs(this);
7187         jvms()-&gt;set_should_reexecute(true);
7188 
7189         set_control(slow_path);
7190         set_i_o(i_o());
7191 
7192         uncommon_trap_exact(Deoptimization::Reason_intrinsic,
7193                             Deoptimization::Action_reinterpret);
7194       }
7195       // The guard for never seen value enables sharpening of the result and
7196       // returning a constant. It allows to eliminate branches on the same value
7197       // later on.
7198       set_control(fast_path);
7199       result = intcon(expected_val);
7200     }
7201     // Stop profiling.
7202     // MethodHandleImpl::profileBoolean() has profiling logic in its bytecode.
7203     // By replacing method body with profile data (represented as ProfileBooleanNode
7204     // on IR level) we effectively disable profiling.
7205     // It enables full speed execution once optimized code is generated.
7206     Node* profile = _gvn.transform(new ProfileBooleanNode(result, false_cnt, true_cnt));
7207     C-&gt;record_for_igvn(profile);
7208     set_result(profile);
7209     return true;
7210   } else {
7211     // Continue profiling.
7212     // Profile data isn&#39;t available at the moment. So, execute method&#39;s bytecode version.
7213     // Usually, when GWT LambdaForms are profiled it means that a stand-alone nmethod
7214     // is compiled and counters aren&#39;t available since corresponding MethodHandle
7215     // isn&#39;t a compile-time constant.
7216     return false;
7217   }
7218 }
7219 
7220 bool LibraryCallKit::inline_isCompileConstant() {
7221   Node* n = argument(0);
7222   set_result(n-&gt;is_Con() ? intcon(1) : intcon(0));
7223   return true;
7224 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>