<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestIntrinsics.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.inlinetypes;
  25 
  26 import java.lang.reflect.Array;
  27 import java.lang.reflect.Field;
  28 import java.util.Arrays;
  29 import java.util.List;
  30 
  31 import jdk.test.lib.Asserts;
  32 import jdk.internal.misc.Unsafe;
  33 
  34 /*
  35  * @test
  36  * @key randomness
  37  * @summary Test intrinsic support for inline types
  38  * @library /testlibrary /test/lib /compiler/whitebox /
  39  * @modules java.base/jdk.internal.misc
  40  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  41  * @compile TestIntrinsics.java
  42  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  43  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  44  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  45  *                               compiler.valhalla.inlinetypes.InlineTypeTest
  46  *                               compiler.valhalla.inlinetypes.TestIntrinsics
  47  */
  48 public class TestIntrinsics extends InlineTypeTest {
  49     // Extra VM parameters for some test scenarios. See InlineTypeTest.getVMParameters()
  50     @Override
  51     public String[] getExtraVMParameters(int scenario) {
  52         switch (scenario) {
  53         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:FlatArrayElementMaxSize=-1&quot;};
  54         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;};
  55         }
  56         return null;
  57     }
  58 
  59     public static void main(String[] args) throws Throwable {
  60         TestIntrinsics test = new TestIntrinsics();
  61         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  62     }
  63 
  64     // Test correctness of the Class::isAssignableFrom intrinsic
  65     @Test()
  66     public boolean test1(Class&lt;?&gt; supercls, Class&lt;?&gt; subcls) {
  67         return supercls.isAssignableFrom(subcls);
  68     }
  69 
  70     public void test1_verifier(boolean warmup) {
  71         Asserts.assertTrue(test1(java.util.AbstractList.class, java.util.ArrayList.class), &quot;test1_1 failed&quot;);
  72         Asserts.assertTrue(test1(MyValue1.ref.class, MyValue1.ref.class), &quot;test1_2 failed&quot;);
  73         Asserts.assertTrue(test1(MyValue1.class, MyValue1.class), &quot;test1_3 failed&quot;);
  74         Asserts.assertTrue(test1(MyValue1.ref.class, MyValue1.class), &quot;test1_4 failed&quot;);
  75         Asserts.assertFalse(test1(MyValue1.class, MyValue1.ref.class), &quot;test1_5 failed&quot;);
  76         Asserts.assertTrue(test1(Object.class, java.util.ArrayList.class), &quot;test1_6 failed&quot;);
  77         Asserts.assertTrue(test1(Object.class, MyValue1.ref.class), &quot;test1_7 failed&quot;);
  78         Asserts.assertTrue(test1(Object.class, MyValue1.class), &quot;test1_8 failed&quot;);
  79         Asserts.assertTrue(!test1(MyValue1.ref.class, Object.class), &quot;test1_9 failed&quot;);
  80         Asserts.assertTrue(!test1(MyValue1.class, Object.class), &quot;test1_10 failed&quot;);
  81     }
  82 
  83     // Verify that Class::isAssignableFrom checks with statically known classes are folded
  84     @Test(failOn = LOADK)
  85     public boolean test2() {
  86         boolean check1 = java.util.AbstractList.class.isAssignableFrom(java.util.ArrayList.class);
  87         boolean check2 = MyValue1.ref.class.isAssignableFrom(MyValue1.ref.class);
  88         boolean check3 = MyValue1.class.isAssignableFrom(MyValue1.class);
  89         boolean check4 = MyValue1.ref.class.isAssignableFrom(MyValue1.class);
  90         boolean check5 = !MyValue1.class.isAssignableFrom(MyValue1.ref.class);
  91         boolean check6 = Object.class.isAssignableFrom(java.util.ArrayList.class);
  92         boolean check7 = Object.class.isAssignableFrom(MyValue1.ref.class);
  93         boolean check8 = Object.class.isAssignableFrom(MyValue1.class);
  94         boolean check9 = !MyValue1.ref.class.isAssignableFrom(Object.class);
  95         boolean check10 = !MyValue1.class.isAssignableFrom(Object.class);
  96         return check1 &amp;&amp; check2 &amp;&amp; check3 &amp;&amp; check4 &amp;&amp; check5 &amp;&amp; check6 &amp;&amp; check7 &amp;&amp; check8 &amp;&amp; check9 &amp;&amp; check10;
  97     }
  98 
  99     public void test2_verifier(boolean warmup) {
 100         Asserts.assertTrue(test2(), &quot;test2 failed&quot;);
 101     }
 102 
 103     // Test correctness of the Class::getSuperclass intrinsic
 104     @Test()
 105     public Class&lt;?&gt; test3(Class&lt;?&gt; cls) {
 106         return cls.getSuperclass();
 107     }
 108 
 109     public void test3_verifier(boolean warmup) {
 110         Asserts.assertTrue(test3(Object.class) == null, &quot;test3_1 failed&quot;);
 111         Asserts.assertTrue(test3(MyValue1.ref.class) == MyAbstract.class, &quot;test3_2 failed&quot;);
 112         Asserts.assertTrue(test3(MyValue1.val.class) == MyValue1.ref.class, &quot;test3_3 failed&quot;);
 113         Asserts.assertTrue(test3(Class.class) == Object.class, &quot;test3_4 failed&quot;);
 114     }
 115 
 116     // Verify that Class::getSuperclass checks with statically known classes are folded
 117     @Test(failOn = LOADK)
 118     public boolean test4() {
 119         boolean check1 = Object.class.getSuperclass() == null;
 120         // TODO Remove cast as workaround once javac is fixed
 121         boolean check2 = (Class&lt;?&gt;)MyValue1.ref.class.getSuperclass() == MyAbstract.class;
 122         // TODO Remove cast as workaround once javac is fixed
 123         boolean check3 = (Class&lt;?&gt;)MyValue1.val.class.getSuperclass() == MyValue1.ref.class;
 124         boolean check4 = Class.class.getSuperclass() == Object.class;
 125         return check1 &amp;&amp; check2 &amp;&amp; check3 &amp;&amp; check4;
 126     }
 127 
 128     public void test4_verifier(boolean warmup) {
 129         Asserts.assertTrue(test4(), &quot;test4 failed&quot;);
 130     }
 131 
 132     // Test toString() method
 133     @Test()
 134     public String test5(MyValue1 v) {
 135         return v.toString();
 136     }
 137 
 138     @DontCompile
 139     public void test5_verifier(boolean warmup) {
 140         MyValue1 v = MyValue1.createDefaultInline();
 141         test5(v);
 142     }
 143 
 144     // Test hashCode() method
 145     @Test()
 146     public int test6(MyValue1 v) {
 147         return v.hashCode();
 148     }
 149 
 150     @DontCompile
 151     public void test6_verifier(boolean warmup) {
 152         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 153         int res = test6(v);
 154         Asserts.assertEQ(res, v.hashCode());
 155     }
 156 
 157     // Test default inline type array creation via reflection
 158     @Test()
 159     public Object[] test7(Class&lt;?&gt; componentType, int len) {
 160         Object[] va = (Object[])Array.newInstance(componentType, len);
 161         return va;
 162     }
 163 
 164     @DontCompile
 165     public void test7_verifier(boolean warmup) {
 166         int len = Math.abs(rI) % 42;
 167         long hash = MyValue1.createDefaultDontInline().hashPrimitive();
 168         Object[] va = test7(MyValue1.class, len);
 169         for (int i = 0; i &lt; len; ++i) {
 170             Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);
 171         }
 172     }
 173 
 174     // Class.isInstance
 175     @Test()
 176     public boolean test8(Class c, MyValue1 vt) {
 177         return c.isInstance(vt);
 178     }
 179 
 180     @DontCompile
 181     public void test8_verifier(boolean warmup) {
 182         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 183         boolean result = test8(MyValue1.class, vt);
 184         Asserts.assertTrue(result);
 185         result = test8(MyValue1.ref.class, vt);
 186         Asserts.assertTrue(result);
 187     }
 188 
 189     @Test()
 190     public boolean test9(Class c, MyValue1 vt) {
 191         return c.isInstance(vt);
 192     }
 193 
 194     @DontCompile
 195     public void test9_verifier(boolean warmup) {
 196         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 197         boolean result = test9(MyValue2.class, vt);
 198         Asserts.assertFalse(result);
 199         result = test9(MyValue2.ref.class, vt);
 200         Asserts.assertFalse(result);
 201     }
 202 
 203     // Class.cast
 204     @Test()
 205     public Object test10(Class c, MyValue1 vt) {
 206         return c.cast(vt);
 207     }
 208 
 209     @DontCompile
 210     public void test10_verifier(boolean warmup) {
 211         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 212         Object result = test10(MyValue1.class, vt);
 213         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 214     }
 215 
 216     @Test()
 217     public Object test11(Class c, MyValue1 vt) {
 218         return c.cast(vt);
 219     }
 220 
 221     @DontCompile
 222     public void test11_verifier(boolean warmup) {
 223         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 224         try {
 225             test11(MyValue2.class, vt);
 226             throw new RuntimeException(&quot;should have thrown&quot;);
 227         } catch (ClassCastException cce) {
 228         }
 229     }
 230 
 231     @Test()
 232     public Object test12(MyValue1 vt) {
 233         return MyValue1.class.cast(vt);
 234     }
 235 
 236     @DontCompile
 237     public void test12_verifier(boolean warmup) {
 238         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 239         Object result = test12(vt);
 240         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 241     }
 242 
 243     @Test()
 244     public Object test13(MyValue1 vt) {
 245         return MyValue2.class.cast(vt);
 246     }
 247 
 248     @DontCompile
 249     public void test13_verifier(boolean warmup) {
 250         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 251         try {
 252             test13(vt);
 253             throw new RuntimeException(&quot;should have thrown&quot;);
 254         } catch (ClassCastException cce) {
 255         }
 256     }
 257 
 258     // inline type array creation via reflection
 259     @Test()
 260     public void test14(int len, long hash) {
 261         Object[] va = (Object[])Array.newInstance(MyValue1.val.class, len);
 262         for (int i = 0; i &lt; len; ++i) {
 263             Asserts.assertEQ(((MyValue1)va[i]).hashPrimitive(), hash);
 264         }
 265     }
 266 
 267     @DontCompile
 268     public void test14_verifier(boolean warmup) {
 269         int len = Math.abs(rI) % 42;
 270         long hash = MyValue1.createDefaultDontInline().hashPrimitive();
 271         test14(len, hash);
 272     }
 273 
 274     // Test hashCode() method
 275     @Test()
 276     public int test15(Object v) {
 277         return v.hashCode();
 278     }
 279 
 280     @DontCompile
 281     public void test15_verifier(boolean warmup) {
 282         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 283         int res = test15(v);
 284         Asserts.assertEQ(res, v.hashCode());
 285     }
 286 
 287     @Test()
 288     public int test16(Object v) {
 289         return System.identityHashCode(v);
 290     }
 291 
 292     @DontCompile
 293     public void test16_verifier(boolean warmup) {
 294         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 295         int res = test16(v);
 296         Asserts.assertEQ(res, System.identityHashCode((Object)v));
 297     }
 298 
 299     @Test()
 300     public int test17(Object v) {
 301         return System.identityHashCode(v);
 302     }
 303 
 304     @DontCompile
 305     public void test17_verifier(boolean warmup) {
 306         Integer v = new Integer(rI);
 307         int res = test17(v);
 308         Asserts.assertEQ(res, System.identityHashCode(v));
 309     }
 310 
 311     @Test()
 312     public int test18(Object v) {
 313         return System.identityHashCode(v);
 314     }
 315 
 316     @DontCompile
 317     public void test18_verifier(boolean warmup) {
 318         Object v = null;
 319         int res = test18(v);
 320         Asserts.assertEQ(res, System.identityHashCode(v));
 321     }
 322 
 323     // hashCode() and toString() with different inline types
 324     @Test()
 325     public int test19(MyValue1 vt1, MyValue1 vt2, boolean b) {
 326         MyValue1 res = b ? vt1 : vt2;
 327         return res.hashCode();
 328     }
 329 
 330     @DontCompile
 331     public void test19_verifier(boolean warmup) {
 332         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 333         int res = test19(vt, vt, true);
 334         Asserts.assertEQ(res, vt.hashCode());
 335         res = test19(vt, vt, false);
 336         Asserts.assertEQ(res, vt.hashCode());
 337     }
 338 
 339     @Test()
 340     public String test20(MyValue1 vt1, MyValue1 vt2, boolean b) {
 341         MyValue1 res = b ? vt1 : vt2;
 342         return res.toString();
 343     }
 344 
 345     @DontCompile
 346     public void test20_verifier(boolean warmup) {
 347         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 348         String res = test20(vt, vt, true);
 349         Asserts.assertEQ(res, vt.toString());
 350         res = test20(vt, vt, false);
 351         Asserts.assertEQ(res, vt.toString());
 352     }
 353 
 354     private static final Unsafe U = Unsafe.getUnsafe();
 355     private static final long X_OFFSET;
 356     private static final long Y_OFFSET;
 357     private static final long V1_OFFSET;
 358     private static final boolean V1_FLATTENED;
 359     static {
 360         try {
 361             Field xField = MyValue1.class.getDeclaredField(&quot;x&quot;);
 362             X_OFFSET = U.objectFieldOffset(xField);
 363             Field yField = MyValue1.class.getDeclaredField(&quot;y&quot;);
 364             Y_OFFSET = U.objectFieldOffset(yField);
 365             Field v1Field = MyValue1.class.getDeclaredField(&quot;v1&quot;);
 366             V1_OFFSET = U.objectFieldOffset(v1Field);
 367             V1_FLATTENED = U.isFlattened(v1Field);
 368         } catch (Exception e) {
 369             throw new RuntimeException(e);
 370         }
 371     }
 372 
 373     protected static final String CALL_Unsafe = START + &quot;CallStaticJava&quot; + MID + &quot;# Static  jdk.internal.misc.Unsafe::&quot; + END;
 374 
 375     @Test(failOn=CALL_Unsafe)
 376     public int test21(MyValue1 v) {
 377        return U.getInt(v, X_OFFSET);
 378     }
 379 
 380     @DontCompile
 381     public void test21_verifier(boolean warmup) {
 382         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 383         int res = test21(v);
 384         Asserts.assertEQ(res, v.x);
 385     }
 386 
 387     MyValue1 test22_vt;
 388     @Test(failOn=CALL_Unsafe + ALLOC)
 389     public void test22(MyValue1 v) {
 390         v = U.makePrivateBuffer(v);
 391         U.putInt(v, X_OFFSET, rI);
 392         v = U.finishPrivateBuffer(v);
 393         test22_vt = v;
 394     }
 395 
 396     @DontCompile
 397     public void test22_verifier(boolean warmup) {
 398         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 399         test22(v.setX(v, 0));
 400         Asserts.assertEQ(test22_vt.hash(), v.hash());
 401     }
 402 
 403     @Test(failOn=CALL_Unsafe)
 404     public int test23(MyValue1 v, long offset) {
 405         return U.getInt(v, offset);
 406     }
 407 
 408     @DontCompile
 409     public void test23_verifier(boolean warmup) {
 410         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 411         int res = test23(v, X_OFFSET);
 412         Asserts.assertEQ(res, v.x);
 413     }
 414 
 415     MyValue1 test24_vt = MyValue1.createWithFieldsInline(rI, rL);
 416 
 417     @Test(failOn=CALL_Unsafe)
 418     public int test24(long offset) {
 419         return U.getInt(test24_vt, offset);
 420     }
 421 
 422     @DontCompile
 423     public void test24_verifier(boolean warmup) {
 424         int res = test24(X_OFFSET);
 425         Asserts.assertEQ(res, test24_vt.x);
 426     }
 427 
 428     // Test copyOf intrinsic with allocated inline type in it&#39;s debug information
 429     final inline class Test25Value {
 430         final int x;
 431         public Test25Value() {
 432             this.x = 42;
 433         }
 434     }
 435 
 436     final Test25Value[] test25Array = new Test25Value[10];
 437 
 438     @Test
 439     public Test25Value[] test25(Test25Value element) {
 440         // TODO Remove cast as workaround once javac is fixed
 441         Test25Value[] newArray = (Test25Value[])Arrays.copyOf(test25Array, test25Array.length + 1);
 442         newArray[test25Array.length] = element;
 443         return newArray;
 444     }
 445 
 446     @DontCompile
 447     public void test25_verifier(boolean warmup) {
 448         Test25Value vt = new Test25Value();
 449         test25(vt);
 450     }
 451 
 452     @Test
 453     public Object test26() {
 454         Class&lt;?&gt;[] ca = new Class&lt;?&gt;[1];
 455         for (int i = 0; i &lt; 1; ++i) {
 456           // Folds during loop opts
 457           ca[i] = MyValue1.val.class;
 458         }
 459         return Array.newInstance(ca[0], 1);
 460     }
 461 
 462     @DontCompile
 463     public void test26_verifier(boolean warmup) {
 464         Object[] res = (Object[])test26();
 465         Asserts.assertEQ(((MyValue1)res[0]).hashPrimitive(), MyValue1.createDefaultInline().hashPrimitive());
 466     }
 467 
 468     // Load non-flattenable inline type field with unsafe
 469     MyValue1.ref test27_vt = MyValue1.createWithFieldsInline(rI, rL);
 470     private static final long TEST27_OFFSET;
 471     static {
 472         try {
 473             Field field = TestIntrinsics.class.getDeclaredField(&quot;test27_vt&quot;);
 474             TEST27_OFFSET = U.objectFieldOffset(field);
 475         } catch (Exception e) {
 476             throw new RuntimeException(e);
 477         }
 478     }
 479 
 480     @Test(failOn=CALL_Unsafe)
 481     public MyValue1 test27() {
 482         return (MyValue1)U.getReference(this, TEST27_OFFSET);
 483     }
 484 
 485     @DontCompile
 486     public void test27_verifier(boolean warmup) {
 487         MyValue1 res = test27();
 488         Asserts.assertEQ(res.hash(), test24_vt.hash());
 489     }
 490 
 491     // Mismatched type
 492     @Test(failOn=CALL_Unsafe)
 493     public int test28(MyValue1 v) {
 494         return U.getByte(v, X_OFFSET);
 495     }
 496 
 497     @DontCompile
 498     public void test28_verifier(boolean warmup) {
 499         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 500         int res = test28(v);
 501         if (java.nio.ByteOrder.nativeOrder() == java.nio.ByteOrder.LITTLE_ENDIAN) {
 502             Asserts.assertEQ(res, (int)((byte)v.x));
 503         } else {
 504             Asserts.assertEQ(res, (int)((byte)Integer.reverseBytes(v.x)));
 505         }
 506     }
 507 
 508     // Wrong alignment
 509     @Test(failOn=CALL_Unsafe)
 510     public long test29(MyValue1 v) {
 511         // Read the field that&#39;s guaranteed to not be last in the
 512         // inline type so we don&#39;t read out of bounds.
 513         if (X_OFFSET &lt; Y_OFFSET) {
 514             return U.getInt(v, X_OFFSET+1);
 515         }
 516         return U.getLong(v, Y_OFFSET+1);
 517     }
 518 
 519     @DontCompile
 520     public void test29_verifier(boolean warmup) {
 521         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 522         long res = test29(v);
 523         if (java.nio.ByteOrder.nativeOrder() == java.nio.ByteOrder.LITTLE_ENDIAN) {
 524             if (X_OFFSET &lt; Y_OFFSET) {
 525                 Asserts.assertEQ(((int)res) &lt;&lt; 8, (v.x &gt;&gt; 8) &lt;&lt; 8);
 526             } else {
 527                 Asserts.assertEQ(res &lt;&lt; 8, (v.y &gt;&gt; 8) &lt;&lt; 8);
 528             }
 529         } else {
 530             if (X_OFFSET &lt; Y_OFFSET) {
 531                 Asserts.assertEQ(((int)res), v.x &gt;&gt;&gt; 8);
 532             } else {
 533                 Asserts.assertEQ(res, v.y &gt;&gt;&gt; 8);
 534             }
 535         }
 536     }
 537 
 538     // getValue to retrieve flattened field from inline type
 539     @Test(failOn=CALL_Unsafe)
 540     public MyValue2 test30(MyValue1 v) {
 541         if (V1_FLATTENED) {
 542             return U.getValue(v, V1_OFFSET, MyValue2.val.class);
 543         }
 544         return (MyValue2)U.getReference(v, V1_OFFSET);
 545     }
 546 
 547     @DontCompile
 548     public void test30_verifier(boolean warmup) {
 549         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 550         MyValue2 res = test30(v);
 551         Asserts.assertEQ(res.hash(), v.v1.hash());
 552     }
 553 
 554     MyValue1 test31_vt;
 555     private static final long TEST31_VT_OFFSET;
 556     private static final boolean TEST31_VT_FLATTENED;
 557     static {
 558         try {
 559             Field test31_vt_Field = TestIntrinsics.class.getDeclaredField(&quot;test31_vt&quot;);
 560             TEST31_VT_OFFSET = U.objectFieldOffset(test31_vt_Field);
 561             TEST31_VT_FLATTENED = U.isFlattened(test31_vt_Field);
 562         } catch (Exception e) {
 563             throw new RuntimeException(e);
 564         }
 565     }
 566 
 567     // getValue to retrieve flattened field from object
 568     @Test(failOn=CALL_Unsafe)
 569     public MyValue1 test31() {
 570         if (TEST31_VT_FLATTENED) {
 571             return U.getValue(this, TEST31_VT_OFFSET, MyValue1.val.class);
 572         }
 573         return (MyValue1)U.getReference(this, TEST31_VT_OFFSET);
 574     }
 575 
 576     @DontCompile
 577     public void test31_verifier(boolean warmup) {
 578         test31_vt = MyValue1.createWithFieldsInline(rI, rL);
 579         MyValue1 res = test31();
 580         Asserts.assertEQ(res.hash(), test31_vt.hash());
 581     }
 582 
 583     // putValue to set flattened field in object
 584     @Test(failOn=CALL_Unsafe)
 585     public void test32(MyValue1 vt) {
 586         if (TEST31_VT_FLATTENED) {
 587             U.putValue(this, TEST31_VT_OFFSET, MyValue1.val.class, vt);
 588         } else {
 589             U.putReference(this, TEST31_VT_OFFSET, vt);
 590         }
 591     }
 592 
 593     @DontCompile
 594     public void test32_verifier(boolean warmup) {
 595         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 596         test31_vt = MyValue1.createDefaultInline();
 597         test32(vt);
 598         Asserts.assertEQ(vt.hash(), test31_vt.hash());
 599     }
 600 
 601     private static final int TEST33_BASE_OFFSET;
 602     private static final int TEST33_INDEX_SCALE;
 603     private static final boolean TEST33_FLATTENED_ARRAY;
 604     static {
 605         try {
 606             TEST33_BASE_OFFSET = U.arrayBaseOffset(MyValue1[].class);
 607             TEST33_INDEX_SCALE = U.arrayIndexScale(MyValue1[].class);
 608             TEST33_FLATTENED_ARRAY = U.isFlattenedArray(MyValue1[].class);
 609         } catch (Exception e) {
 610             throw new RuntimeException(e);
 611         }
 612     }
 613     // getValue to retrieve flattened field from array
 614     @Test(failOn=CALL_Unsafe)
 615     public MyValue1 test33(MyValue1[] arr) {
 616         if (TEST33_FLATTENED_ARRAY) {
 617             return U.getValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.val.class);
 618         }
 619         return (MyValue1)U.getReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE);
 620     }
 621 
 622     @DontCompile
 623     public void test33_verifier(boolean warmup) {
 624         MyValue1[] arr = new MyValue1[2];
 625         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 626         arr[1] = vt;
 627         MyValue1 res = test33(arr);
 628         Asserts.assertEQ(res.hash(), vt.hash());
 629     }
 630 
 631     // putValue to set flattened field in array
 632     @Test(failOn=CALL_Unsafe)
 633     public void test34(MyValue1[] arr, MyValue1 vt) {
 634         if (TEST33_FLATTENED_ARRAY) {
 635             U.putValue(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, MyValue1.val.class, vt);
 636         } else {
 637             U.putReference(arr, TEST33_BASE_OFFSET + TEST33_INDEX_SCALE, vt);
 638         }
 639     }
 640 
 641     @DontCompile
 642     public void test34_verifier(boolean warmup) {
 643         MyValue1[] arr = new MyValue1[2];
 644         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 645         test34(arr, vt);
 646         Asserts.assertEQ(arr[1].hash(), vt.hash());
 647     }
 648 
 649     // getValue to retrieve flattened field from object with unknown
 650     // container type
 651     @Test(failOn=CALL_Unsafe)
 652     public MyValue1 test35(Object o) {
 653         if (TEST31_VT_FLATTENED) {
 654             return U.getValue(o, TEST31_VT_OFFSET, MyValue1.val.class);
 655         }
 656         return (MyValue1)U.getReference(o, TEST31_VT_OFFSET);
 657     }
 658 
 659     @DontCompile
 660     public void test35_verifier(boolean warmup) {
 661         test31_vt = MyValue1.createWithFieldsInline(rI, rL);
 662         MyValue1 res = test35(this);
 663         Asserts.assertEQ(res.hash(), test31_vt.hash());
 664     }
 665 
 666     // getValue to retrieve flattened field from object at unknown
 667     // offset
 668     @Test(failOn=CALL_Unsafe)
 669     public MyValue1 test36(long offset) {
 670         if (TEST31_VT_FLATTENED) {
 671             return U.getValue(this, offset, MyValue1.val.class);
 672         }
 673         return (MyValue1)U.getReference(this, offset);
 674     }
 675 
 676     @DontCompile
 677     public void test36_verifier(boolean warmup) {
 678         test31_vt = MyValue1.createWithFieldsInline(rI, rL);
 679         MyValue1 res = test36(TEST31_VT_OFFSET);
 680         Asserts.assertEQ(res.hash(), test31_vt.hash());
 681     }
 682 
 683     // putValue to set flattened field in object with unknown
 684     // container
 685     @Test(failOn=CALL_Unsafe)
 686     public void test37(Object o, MyValue1 vt) {
 687         if (TEST31_VT_FLATTENED) {
 688             U.putValue(o, TEST31_VT_OFFSET, MyValue1.val.class, vt);
 689         } else {
 690             U.putReference(o, TEST31_VT_OFFSET, vt);
 691         }
 692     }
 693 
 694     @DontCompile
 695     public void test37_verifier(boolean warmup) {
 696         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 697         test31_vt = MyValue1.createDefaultInline();
 698         test37(this, vt);
 699         Asserts.assertEQ(vt.hash(), test31_vt.hash());
 700     }
 701 
 702     // putValue to set flattened field in object, non inline argument
 703     // to store
 704     @Test(match = { CALL_Unsafe }, matchCount = { 1 })
 705     public void test38(Object o) {
 706         if (TEST31_VT_FLATTENED) {
 707             U.putValue(this, TEST31_VT_OFFSET, MyValue1.val.class, o);
 708         } else {
 709             U.putReference(this, TEST31_VT_OFFSET, o);
 710         }
 711     }
 712 
 713     @DontCompile
 714     public void test38_verifier(boolean warmup) {
 715         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 716         test31_vt = MyValue1.createDefaultInline();
 717         test38(vt);
 718         Asserts.assertEQ(vt.hash(), test31_vt.hash());
 719     }
 720 
 721     @Test(failOn=CALL_Unsafe)
 722     public MyValue1 test39(MyValue1 v) {
 723         v = U.makePrivateBuffer(v);
 724         U.putInt(v, X_OFFSET, rI);
 725         v = U.finishPrivateBuffer(v);
 726         return v;
 727     }
 728 
 729     @DontCompile
 730     public void test39_verifier(boolean warmup) {
 731         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
 732         MyValue1 res = test39(v.setX(v, 0));
 733         Asserts.assertEQ(res.hash(), v.hash());
 734     }
 735 
 736     // Test default inline type array creation via reflection
 737     @Test()
 738     public Object[] test40(Class&lt;?&gt; componentType, int len) {
 739         Object[] va = (Object[])Array.newInstance(componentType, len);
 740         return va;
 741     }
 742 
 743     @DontCompile
 744     public void test40_verifier(boolean warmup) {
 745         int len = Math.abs(rI) % 42;
 746         Object[] va = test40(MyValue1.ref.class, len);
 747         for (int i = 0; i &lt; len; ++i) {
 748             Asserts.assertEQ(va[i], null);
 749         }
 750     }
 751 
 752     // Class.isInstance
 753     @Test()
 754     public boolean test41(Class c, MyValue1.ref vt) {
 755         return c.isInstance(vt);
 756     }
 757 
 758     @DontCompile
 759     public void test41_verifier(boolean warmup) {
 760         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 761         boolean result = test41(MyValue1.ref.class, vt);
 762         Asserts.assertTrue(result);
 763         result = test41(MyValue1.class, vt);
 764         Asserts.assertTrue(result);
 765     }
 766 
 767     @Test()
 768     public boolean test42(Class c, MyValue1.ref vt) {
 769         return c.isInstance(vt);
 770     }
 771 
 772     @DontCompile
 773     public void test42_verifier(boolean warmup) {
 774         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 775         boolean result = test42(MyValue2.ref.class, vt);
 776         Asserts.assertFalse(result);
 777         result = test42(MyValue2.class, vt);
 778         Asserts.assertFalse(result);
 779     }
 780 
 781     // Class.cast
 782     @Test()
 783     public Object test43(Class c, MyValue1.ref vt) {
 784         return c.cast(vt);
 785     }
 786 
 787     @DontCompile
 788     public void test43_verifier(boolean warmup) {
 789         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 790         Object result = test43(MyValue1.ref.class, vt);
 791         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 792         result = test43(MyValue1.ref.class, null);
 793         Asserts.assertEQ(result, null);
 794     }
 795 
 796     @Test()
 797     public Object test44(Class c, MyValue1.ref vt) {
 798         return c.cast(vt);
 799     }
 800 
 801     @DontCompile
 802     public void test44_verifier(boolean warmup) {
 803         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 804         try {
 805             test44(MyValue2.ref.class, vt);
 806             throw new RuntimeException(&quot;should have thrown&quot;);
 807         } catch (ClassCastException cce) {
 808         }
 809     }
 810 
 811     @Test()
 812     public Object test45(MyValue1.ref vt) {
 813         return MyValue1.ref.class.cast(vt);
 814     }
 815 
 816     @DontCompile
 817     public void test45_verifier(boolean warmup) {
 818         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 819         Object result = test45(vt);
 820         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 821         result = test45(null);
 822         Asserts.assertEQ(result, null);
 823     }
 824 
 825     @Test()
 826     public Object test46(MyValue1.ref vt) {
 827         return MyValue2.ref.class.cast(vt);
 828     }
 829 
 830     @DontCompile
 831     public void test46_verifier(boolean warmup) {
 832         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 833         test46(null);
 834         try {
 835             test46(vt);
 836             throw new RuntimeException(&quot;should have thrown&quot;);
 837         } catch (ClassCastException cce) {
 838         }
 839     }
 840 
 841     @Test()
 842     public Object test47(MyValue1.ref vt) {
 843         return MyValue1.val.class.cast(vt);
 844     }
 845 
 846     @DontCompile
 847     public void test47_verifier(boolean warmup) {
 848         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 849         Object result = test47(vt);
 850         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 851         try {
 852             test47(null);
 853             throw new RuntimeException(&quot;should have thrown&quot;);
 854         } catch (NullPointerException npe) {
 855         }
 856     }
 857 
 858     @Test()
 859     public Object test48(Class c, MyValue1.ref vt) {
 860         return c.cast(vt);
 861     }
 862 
 863     @DontCompile
 864     public void test48_verifier(boolean warmup) {
 865         MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
 866         Object result = test48(MyValue1.class, vt);
 867         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 868         try {
 869             test48(MyValue1.class, null);
 870             throw new RuntimeException(&quot;should have thrown&quot;);
 871         } catch (NullPointerException npe) {
 872         }
 873     }
 874 
 875     @Test()
 876     public Object test49(MyValue1 vt) {
 877         return MyValue1.ref.class.cast(vt);
 878     }
 879 
 880     @DontCompile
 881     public void test49_verifier(boolean warmup) {
 882         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 883         Object result = test49(vt);
 884         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 885     }
 886 
 887     @Test()
 888     public Object test50(Class c, Object obj) {
 889         return c.cast(obj);
 890     }
 891 
 892     @DontCompile
 893     public void test50_verifier(boolean warmup) {
 894         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
 895         MyValue1[] va  = new MyValue1[42];
 896         MyValue1.ref[] vba = new MyValue1.ref[42];
 897         Object result = test50(MyValue1.class, vt);
 898         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 899         result = test50(MyValue1.ref.class, vt);
 900         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
 901         result = test50(MyValue1[].class, va);
 902         Asserts.assertEQ(result, va);
 903         result = test50(MyValue1.ref[].class, vba);
 904         Asserts.assertEQ(result, vba);
 905         result = test50(MyValue1.ref[].class, va);
 906         Asserts.assertEQ(result, va);
 907         try {
 908             test50(MyValue1.class, null);
 909             throw new RuntimeException(&quot;should have thrown&quot;);
 910         } catch (NullPointerException npe) {
 911         }
 912         try {
 913             test50(MyValue1[].class, vba);
 914             throw new RuntimeException(&quot;should have thrown&quot;);
 915         } catch (ClassCastException cce) {
 916         }
 917     }
 918 
 919     // inline type array creation via reflection
 920     @Test()
 921     public void test51(int len) {
 922         Object[] va = (Object[])Array.newInstance(MyValue1.ref.class, len);
 923         for (int i = 0; i &lt; len; ++i) {
 924             Asserts.assertEQ(va[i], null);
 925         }
 926     }
 927 
 928     @DontCompile
 929     public void test51_verifier(boolean warmup) {
 930         int len = Math.abs(rI) % 42;
 931         test51(len);
 932     }
 933 
 934     // multidimensional inline type array creation via reflection
 935     @Test()
 936     public Object[][] test52(int len, int val) {
 937         MyValue1[][] va1 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);
 938         MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);
 939         Object[][] result;
 940         if (val == 1) {
 941             va1[0] = new MyValue1[1];
 942             result = va1;
 943         } else {
 944             va2[0] = new MyValue1.ref[1];
 945             result = va2;
 946         }
 947         if (val == 1) {
 948             Asserts.assertEQ(va1[0][0].hash(), ((MyValue1)result[0][0]).hash());
 949         } else {
 950             Asserts.assertEQ(result[0][0], null);
 951             result[0][0] = null;
 952         }
 953         return result;
 954     }
 955 
 956     @DontCompile
 957     public void test52_verifier(boolean warmup) {
 958         test52(1, 1);
 959         test52(1, 2);
 960     }
 961 
 962     @Test()
 963     public Object[][] test53(Class&lt;?&gt; c1, Class&lt;?&gt; c2, int len, int val) {
 964         MyValue1[][] va1 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);
 965         MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);
 966         Object[][] va3 = (Object[][])Array.newInstance(c1, len);
 967         Object[][] va4 = (Object[][])Array.newInstance(c2, len);
 968         for (int i = 0; i &lt; len; ++i) {
 969             Asserts.assertEQ(va1[i], null);
 970             Asserts.assertEQ(va2[i], null);
 971             Asserts.assertEQ(va3[i], null);
 972             Asserts.assertEQ(va4[i], null);
 973             va1[i] = new MyValue1[1];
 974             va2[i] = new MyValue1.ref[1];
 975             va3[i] = new MyValue1[1];
 976             va4[i] = new MyValue1.ref[1];
 977             Asserts.assertEQ(va1[i][0].hash(), ((MyValue1)va3[i][0]).hash());
 978             Asserts.assertEQ(va2[i][0], null);
 979             Asserts.assertEQ(va4[i][0], null);
 980         }
 981         Object[][] result;
 982         if (val == 1) {
 983             result = va1;
 984         } else if (val == 2) {
 985             result = va2;
 986         } else if (val == 3) {
 987             result = va3;
 988         } else {
 989             result = va4;
 990         }
 991         if ((val == 1 || val == 3) &amp;&amp; len &gt; 0) {
 992             Asserts.assertEQ(va1[0][0].hash(), ((MyValue1)result[0][0]).hash());
 993         } else if (len &gt; 0) {
 994             Asserts.assertEQ(result[0][0], null);
 995             result[0][0] = null;
 996         }
 997         return result;
 998     }
 999 
1000     @DontCompile
1001     public void test53_verifier(boolean warmup) {
1002         int len = Math.abs(rI) % 42;
1003         test53(MyValue1[].class, MyValue1.ref[].class, len, 1);
1004         test53(MyValue1[].class, MyValue1.ref[].class, len, 2);
1005         test53(MyValue1[].class, MyValue1.ref[].class, len, 3);
1006         test53(MyValue1[].class, MyValue1.ref[].class, len, 4);
1007     }
1008 
1009     // Same as test39 but Unsafe.putInt to buffer is not intrinsified/compiled
1010     @DontCompile
1011     public void test54_callee(MyValue1.ref v) { // Use .ref here to make sure the argument is not scalarized (otherwise larval information is lost)
1012         U.putInt(v, X_OFFSET, rI);
1013     }
1014 
1015     @Test()
1016     @Warmup(10000) // Fill up the TLAB to trigger slow path allocation
1017     public MyValue1 test54(MyValue1 v) {
1018         v = U.makePrivateBuffer(v);
1019         test54_callee(v);
1020         v = U.finishPrivateBuffer(v);
1021         return v;
1022     }
1023 
1024     @DontCompile
1025     public void test54_verifier(boolean warmup) {
1026         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
1027         MyValue1 res = test54(v.setX(v, 0));
1028         Asserts.assertEQ(res.hash(), v.hash());
1029     }
1030 
1031     static final MyValue1 test55_vt = MyValue1.createWithFieldsInline(rI, rL);
1032 
1033     // Same as test30 but with constant field holder
1034     @Test(failOn=CALL_Unsafe)
1035     public MyValue2 test55() {
1036         if (V1_FLATTENED) {
1037             return U.getValue(test55_vt, V1_OFFSET, MyValue2.val.class);
1038         }
1039         return (MyValue2)U.getReference(test55_vt, V1_OFFSET);
1040     }
1041 
1042     @DontCompile
1043     public void test55_verifier(boolean warmup) {
1044         MyValue2 res = test55();
<a name="1" id="anc1"></a><span class="line-modified">1045         Asserts.assertEQ(res.hash(), vfinal.v1.hash());</span>
1046     }
1047 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>