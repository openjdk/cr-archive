<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import com.sun.tools.javac.api.Formattable.LocalizedString;
  29 import com.sun.tools.javac.code.*;
  30 import com.sun.tools.javac.code.Scope.WriteableScope;
  31 import com.sun.tools.javac.code.Source.Feature;
  32 import com.sun.tools.javac.code.Symbol.*;
  33 import com.sun.tools.javac.code.Type.*;
  34 import com.sun.tools.javac.comp.Attr.ResultInfo;
  35 import com.sun.tools.javac.comp.Check.CheckContext;
  36 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  37 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  38 import com.sun.tools.javac.comp.DeferredAttr.DeferredType;
  39 import com.sun.tools.javac.comp.Resolve.MethodResolutionContext.Candidate;
  40 import com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.Template;
  41 import com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind;
  42 import com.sun.tools.javac.jvm.*;
  43 import com.sun.tools.javac.main.Option;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  46 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  47 import com.sun.tools.javac.tree.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
  50 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  51 import com.sun.tools.javac.util.*;
  52 import com.sun.tools.javac.util.DefinedBy.Api;
  53 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  54 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  55 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
  56 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  57 
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.EnumSet;
  61 import java.util.HashSet;
  62 import java.util.Iterator;
  63 import java.util.LinkedHashMap;
  64 import java.util.Map;
  65 import java.util.Set;
  66 import java.util.function.BiFunction;
  67 import java.util.function.BiPredicate;
  68 import java.util.function.Consumer;
  69 import java.util.function.Function;
  70 import java.util.function.Predicate;
  71 import java.util.stream.Stream;
  72 
  73 import javax.lang.model.element.ElementVisitor;
  74 
  75 import static com.sun.tools.javac.code.Flags.*;
  76 import static com.sun.tools.javac.code.Flags.BLOCK;
  77 import static com.sun.tools.javac.code.Flags.STATIC;
  78 import static com.sun.tools.javac.code.Kinds.*;
  79 import static com.sun.tools.javac.code.Kinds.Kind.*;
  80 import static com.sun.tools.javac.code.TypeTag.*;
  81 import static com.sun.tools.javac.comp.Resolve.MethodResolutionPhase.*;
  82 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  83 import static com.sun.tools.javac.util.Iterators.createCompoundIterator;
  84 
  85 /** Helper class for name resolution, used mostly by the attribution phase.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class Resolve {
  93     protected static final Context.Key&lt;Resolve&gt; resolveKey = new Context.Key&lt;&gt;();
  94 
  95     Names names;
  96     Log log;
  97     Symtab syms;
  98     Attr attr;
  99     DeferredAttr deferredAttr;
 100     Check chk;
 101     Infer infer;
 102     ClassFinder finder;
 103     ModuleFinder moduleFinder;
 104     Types types;
 105     JCDiagnostic.Factory diags;
 106     public final boolean allowFunctionalInterfaceMostSpecific;
 107     public final boolean allowModules;
 108     public final boolean checkVarargsAccessAfterResolution;
 109     private final boolean compactMethodDiags;
 110     private final boolean allowLocalVariableTypeInference;
 111     private final boolean allowYieldStatement;
 112     final EnumSet&lt;VerboseResolutionMode&gt; verboseResolutionMode;
 113 
 114     WriteableScope polymorphicSignatureScope;
 115 
 116     protected Resolve(Context context) {
 117         context.put(resolveKey, this);
 118         syms = Symtab.instance(context);
 119 
 120         varNotFound = new SymbolNotFoundError(ABSENT_VAR);
 121         methodNotFound = new SymbolNotFoundError(ABSENT_MTH);
 122         typeNotFound = new SymbolNotFoundError(ABSENT_TYP);
 123         referenceNotFound = ReferenceLookupResult.error(methodNotFound);
 124 
 125         names = Names.instance(context);
 126         log = Log.instance(context);
 127         attr = Attr.instance(context);
 128         deferredAttr = DeferredAttr.instance(context);
 129         chk = Check.instance(context);
 130         infer = Infer.instance(context);
 131         finder = ClassFinder.instance(context);
 132         moduleFinder = ModuleFinder.instance(context);
 133         types = Types.instance(context);
 134         diags = JCDiagnostic.Factory.instance(context);
 135         Preview preview = Preview.instance(context);
 136         Source source = Source.instance(context);
 137         Options options = Options.instance(context);
 138         compactMethodDiags = options.isSet(Option.XDIAGS, &quot;compact&quot;) ||
 139                 options.isUnset(Option.XDIAGS) &amp;&amp; options.isUnset(&quot;rawDiagnostics&quot;);
 140         verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);
 141         Target target = Target.instance(context);
 142         allowFunctionalInterfaceMostSpecific = Feature.FUNCTIONAL_INTERFACE_MOST_SPECIFIC.allowedInSource(source);
 143         allowLocalVariableTypeInference = Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source);
 144         allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 145                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 146         checkVarargsAccessAfterResolution =
 147                 Feature.POST_APPLICABILITY_VARARGS_ACCESS_CHECK.allowedInSource(source);
 148         polymorphicSignatureScope = WriteableScope.create(syms.noSymbol);
 149         allowModules = Feature.MODULES.allowedInSource(source);
 150     }
 151 
 152     /** error symbols, which are returned when resolution fails
 153      */
 154     private final SymbolNotFoundError varNotFound;
 155     private final SymbolNotFoundError methodNotFound;
 156     private final SymbolNotFoundError typeNotFound;
 157 
 158     /** empty reference lookup result */
 159     private final ReferenceLookupResult referenceNotFound;
 160 
 161     public static Resolve instance(Context context) {
 162         Resolve instance = context.get(resolveKey);
 163         if (instance == null)
 164             instance = new Resolve(context);
 165         return instance;
 166     }
 167 
 168     private static Symbol bestOf(Symbol s1,
 169                                  Symbol s2) {
 170         return s1.kind.betterThan(s2.kind) ? s1 : s2;
 171     }
 172 
 173     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Verbose resolution diagnostics support&quot;&gt;
 174     enum VerboseResolutionMode {
 175         SUCCESS(&quot;success&quot;),
 176         FAILURE(&quot;failure&quot;),
 177         APPLICABLE(&quot;applicable&quot;),
 178         INAPPLICABLE(&quot;inapplicable&quot;),
 179         DEFERRED_INST(&quot;deferred-inference&quot;),
 180         PREDEF(&quot;predef&quot;),
 181         OBJECT_INIT(&quot;object-init&quot;),
 182         INTERNAL(&quot;internal&quot;);
 183 
 184         final String opt;
 185 
 186         private VerboseResolutionMode(String opt) {
 187             this.opt = opt;
 188         }
 189 
 190         static EnumSet&lt;VerboseResolutionMode&gt; getVerboseResolutionMode(Options opts) {
 191             String s = opts.get(&quot;debug.verboseResolution&quot;);
 192             EnumSet&lt;VerboseResolutionMode&gt; res = EnumSet.noneOf(VerboseResolutionMode.class);
 193             if (s == null) return res;
 194             if (s.contains(&quot;all&quot;)) {
 195                 res = EnumSet.allOf(VerboseResolutionMode.class);
 196             }
 197             Collection&lt;String&gt; args = Arrays.asList(s.split(&quot;,&quot;));
 198             for (VerboseResolutionMode mode : values()) {
 199                 if (args.contains(mode.opt)) {
 200                     res.add(mode);
 201                 } else if (args.contains(&quot;-&quot; + mode.opt)) {
 202                     res.remove(mode);
 203                 }
 204             }
 205             return res;
 206         }
 207     }
 208 
 209     void reportVerboseResolutionDiagnostic(DiagnosticPosition dpos, Name name, Type site,
 210             List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, Symbol bestSoFar) {
 211         boolean success = !bestSoFar.kind.isResolutionError();
 212 
 213         if (success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.SUCCESS)) {
 214             return;
 215         } else if (!success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.FAILURE)) {
 216             return;
 217         }
 218 
 219         if (bestSoFar.name == names.init &amp;&amp;
 220                 bestSoFar.owner == syms.objectType.tsym &amp;&amp;
 221                 !verboseResolutionMode.contains(VerboseResolutionMode.OBJECT_INIT)) {
 222             return; //skip diags for Object constructor resolution
 223         } else if (site == syms.predefClass.type &amp;&amp;
 224                 !verboseResolutionMode.contains(VerboseResolutionMode.PREDEF)) {
 225             return; //skip spurious diags for predef symbols (i.e. operators)
 226         } else if (currentResolutionContext.internalResolution &amp;&amp;
 227                 !verboseResolutionMode.contains(VerboseResolutionMode.INTERNAL)) {
 228             return;
 229         }
 230 
 231         int pos = 0;
 232         int mostSpecificPos = -1;
 233         ListBuffer&lt;JCDiagnostic&gt; subDiags = new ListBuffer&lt;&gt;();
 234         for (Candidate c : currentResolutionContext.candidates) {
 235             if (currentResolutionContext.step != c.step ||
 236                     (c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.APPLICABLE)) ||
 237                     (!c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.INAPPLICABLE))) {
 238                 continue;
 239             } else {
 240                 subDiags.append(c.isApplicable() ?
 241                         getVerboseApplicableCandidateDiag(pos, c.sym, c.mtype) :
 242                         getVerboseInapplicableCandidateDiag(pos, c.sym, c.details));
 243                 if (c.sym == bestSoFar)
 244                     mostSpecificPos = pos;
 245                 pos++;
 246             }
 247         }
 248         String key = success ? &quot;verbose.resolve.multi&quot; : &quot;verbose.resolve.multi.1&quot;;
 249         List&lt;Type&gt; argtypes2 = argtypes.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, bestSoFar, currentResolutionContext.step));
 250         JCDiagnostic main = diags.note(log.currentSource(), dpos, key, name,
 251                 site.tsym, mostSpecificPos, currentResolutionContext.step,
 252                 methodArguments(argtypes2),
 253                 methodArguments(typeargtypes));
 254         JCDiagnostic d = new JCDiagnostic.MultilineDiagnostic(main, subDiags.toList());
 255         log.report(d);
 256     }
 257 
 258     JCDiagnostic getVerboseApplicableCandidateDiag(int pos, Symbol sym, Type inst) {
 259         JCDiagnostic subDiag = null;
 260         if (sym.type.hasTag(FORALL)) {
 261             subDiag = diags.fragment(Fragments.PartialInstSig(inst));
 262         }
 263 
 264         String key = subDiag == null ?
 265                 &quot;applicable.method.found&quot; :
 266                 &quot;applicable.method.found.1&quot;;
 267 
 268         return diags.fragment(key, pos, sym, subDiag);
 269     }
 270 
 271     JCDiagnostic getVerboseInapplicableCandidateDiag(int pos, Symbol sym, JCDiagnostic subDiag) {
 272         return diags.fragment(Fragments.NotApplicableMethodFound(pos, sym, subDiag));
 273     }
 274     // &lt;/editor-fold&gt;
 275 
 276 /* ************************************************************************
 277  * Identifier resolution
 278  *************************************************************************/
 279 
 280     /** An environment is &quot;static&quot; if its static level is greater than
 281      *  the one of its outer environment
 282      */
 283     protected static boolean isStatic(Env&lt;AttrContext&gt; env) {
 284         return env.outer != null &amp;&amp; env.info.staticLevel &gt; env.outer.info.staticLevel;
 285     }
 286 
 287     /** An environment is an &quot;initializer&quot; if it is a constructor or
 288      *  an instance initializer.
 289      */
 290     static boolean isInitializer(Env&lt;AttrContext&gt; env) {
 291         Symbol owner = env.info.scope.owner;
 292         return owner.isConstructor() ||
 293             owner.owner.kind == TYP &amp;&amp;
 294             (owner.kind == VAR ||
 295              owner.kind == MTH &amp;&amp; (owner.flags() &amp; BLOCK) != 0) &amp;&amp;
 296             (owner.flags() &amp; STATIC) == 0;
 297     }
 298 
 299     /** Is class accessible in given environment?
 300      *  @param env    The current environment.
 301      *  @param c      The class whose accessibility is checked.
 302      */
 303     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c) {
 304         return isAccessible(env, c, false);
 305     }
 306 
 307     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c, boolean checkInner) {
 308 
 309         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 310            to refer to an inaccessible type
 311         */
 312         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 313             return true;
 314 
 315         if (env.info.visitingServiceImplementation &amp;&amp;
 316             env.toplevel.modle == c.packge().modle) {
 317             return true;
 318         }
 319 
 320         boolean isAccessible = false;
 321         switch ((short)(c.flags() &amp; AccessFlags)) {
 322             case PRIVATE:
 323                 isAccessible =
 324                     env.enclClass.sym.outermostClass() ==
 325                     c.owner.outermostClass();
 326                 break;
 327             case 0:
 328                 isAccessible =
 329                     env.toplevel.packge == c.owner // fast special case
 330                     ||
 331                     env.toplevel.packge == c.packge();
 332                 break;
 333             default: // error recovery
 334                 isAccessible = true;
 335                 break;
 336             case PUBLIC:
 337                 if (allowModules) {
 338                     ModuleSymbol currModule = env.toplevel.modle;
 339                     currModule.complete();
 340                     PackageSymbol p = c.packge();
 341                     isAccessible =
 342                         currModule == p.modle ||
 343                         currModule.visiblePackages.get(p.fullname) == p ||
 344                         p == syms.rootPackage ||
 345                         (p.modle == syms.unnamedModule &amp;&amp; currModule.readModules.contains(p.modle));
 346                 } else {
 347                     isAccessible = true;
 348                 }
 349                 break;
 350             case PROTECTED:
 351                 isAccessible =
 352                     env.toplevel.packge == c.owner // fast special case
 353                     ||
 354                     env.toplevel.packge == c.packge()
 355                     ||
 356                     isInnerSubClass(env.enclClass.sym, c.owner);
 357                 break;
 358         }
 359         return (checkInner == false || c.type.getEnclosingType() == Type.noType) ?
 360             isAccessible :
 361             isAccessible &amp;&amp; isAccessible(env, c.type.getEnclosingType(), checkInner);
 362     }
 363     //where
 364         /** Is given class a subclass of given base class, or an inner class
 365          *  of a subclass?
 366          *  Return null if no such class exists.
 367          *  @param c     The class which is the subclass or is contained in it.
 368          *  @param base  The base class
 369          */
 370         private boolean isInnerSubClass(ClassSymbol c, Symbol base) {
 371             while (c != null &amp;&amp; !c.isSubClass(base, types)) {
 372                 c = c.owner.enclClass();
 373             }
 374             return c != null;
 375         }
 376 
 377     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t) {
 378         return isAccessible(env, t, false);
 379     }
 380 
 381     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t, boolean checkInner) {
 382         return (t.hasTag(ARRAY))
 383             ? isAccessible(env, types.cvarUpperBound(types.elemtype(t)))
 384             : isAccessible(env, t.tsym, checkInner);
 385     }
 386 
 387     /** Is symbol accessible as a member of given type in given environment?
 388      *  @param env    The current environment.
 389      *  @param site   The type of which the tested symbol is regarded
 390      *                as a member.
 391      *  @param sym    The symbol.
 392      */
 393     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
 394         return isAccessible(env, site, sym, false);
 395     }
 396     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym, boolean checkInner) {
 397         if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) return false;
 398 
 399         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 400            to refer to an inaccessible type
 401         */
 402         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 403             return true;
 404 
 405         if (env.info.visitingServiceImplementation &amp;&amp;
 406             env.toplevel.modle == sym.packge().modle) {
 407             return true;
 408         }
 409 
 410         ClassSymbol enclosingCsym = env.enclClass.sym;
 411         if (sym.kind == MTH || sym.kind == VAR) {
 412             /* If any inline types are involved, ask the same question in the reference universe,
 413                where the hierarchy is navigable
 414             */
 415             if (site.isValue())
 416                 site = site.referenceProjection();
 417             if (sym.owner.isValue())
 418                 sym = sym.referenceProjection();
 419             if (env.enclClass.sym.isValue())
 420                 env.enclClass.sym = env.enclClass.sym.referenceProjection();
<a name="1" id="anc1"></a><span class="line-added"> 421         } else if (sym.kind == TYP) {</span>
<span class="line-added"> 422             // A type is accessible in a reference projection if it was</span>
<span class="line-added"> 423             // accessible in the value projection.</span>
<span class="line-added"> 424             if (site.isReferenceProjection())</span>
<span class="line-added"> 425                 site = site.valueProjection();</span>
 426         }
 427         try {
 428             switch ((short)(sym.flags() &amp; AccessFlags)) {
 429                 case PRIVATE:
 430                     return
 431                             (env.enclClass.sym == sym.owner // fast special case
 432                                     ||
 433                                     env.enclClass.sym.outermostClass() ==
 434                                             sym.owner.outermostClass())
 435                                     &amp;&amp;
 436                                     sym.isInheritedIn(site.tsym, types);
 437                 case 0:
 438                     return
 439                             (env.toplevel.packge == sym.owner.owner // fast special case
 440                                     ||
 441                                     env.toplevel.packge == sym.packge())
 442                                     &amp;&amp;
 443                                     isAccessible(env, site, checkInner)
 444                                     &amp;&amp;
 445                                     sym.isInheritedIn(site.tsym, types)
 446                                     &amp;&amp;
 447                                     notOverriddenIn(site, sym);
 448                 case PROTECTED:
 449                     return
 450                             (env.toplevel.packge == sym.owner.owner // fast special case
 451                                     ||
 452                                     env.toplevel.packge == sym.packge()
 453                                     ||
 454                                     isProtectedAccessible(sym, env.enclClass.sym, site)
 455                                     ||
 456                                     // OK to select instance method or field from &#39;super&#39; or type name
 457                                     // (but type names should be disallowed elsewhere!)
 458                                     env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0 &amp;&amp; sym.kind != TYP)
 459                                     &amp;&amp;
 460                                     isAccessible(env, site, checkInner)
 461                                     &amp;&amp;
 462                                     notOverriddenIn(site, sym);
 463                 default: // this case includes erroneous combinations as well
 464                     return isAccessible(env, site, checkInner) &amp;&amp; notOverriddenIn(site, sym);
 465             }
 466         } finally {
 467             env.enclClass.sym = enclosingCsym;
 468         }
 469     }
 470     //where
 471     /* `sym&#39; is accessible only if not overridden by
 472      * another symbol which is a member of `site&#39;
 473      * (because, if it is overridden, `sym&#39; is not strictly
 474      * speaking a member of `site&#39;). A polymorphic signature method
 475      * cannot be overridden (e.g. MH.invokeExact(Object[])).
 476      */
 477     private boolean notOverriddenIn(Type site, Symbol sym) {
 478         if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())
 479             return true;
 480 
 481         /* If any inline types are involved, ask the same question in the reference universe,
 482            where the hierarchy is navigable
 483         */
 484         if (site.isValue())
 485             site = site.referenceProjection();
 486         if (sym.owner.isValue())
 487             sym = sym.referenceProjection();
 488 
 489         Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);
 490         return (s2 == null || s2 == sym || sym.owner == s2.owner ||
 491                 !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));
 492     }
 493     //where
 494         /** Is given protected symbol accessible if it is selected from given site
 495          *  and the selection takes place in given class?
 496          *  @param sym     The symbol with protected access
 497          *  @param c       The class where the access takes place
 498          *  @site          The type of the qualifier
 499          */
 500         private
 501         boolean isProtectedAccessible(Symbol sym, ClassSymbol c, Type site) {
 502             Type newSite = site.hasTag(TYPEVAR) ? site.getUpperBound() : site;
 503             while (c != null &amp;&amp;
 504                    !(c.isSubClass(sym.owner, types) &amp;&amp;
 505                      (c.flags() &amp; INTERFACE) == 0 &amp;&amp;
 506                      // In JLS 2e 6.6.2.1, the subclass restriction applies
 507                      // only to instance fields and methods -- types are excluded
 508                      // regardless of whether they are declared &#39;static&#39; or not.
 509                      ((sym.flags() &amp; STATIC) != 0 || sym.kind == TYP || newSite.tsym.isSubClass(c, types))))
 510                 c = c.owner.enclClass();
 511             return c != null;
 512         }
 513 
 514     /**
 515      * Performs a recursive scan of a type looking for accessibility problems
 516      * from current attribution environment
 517      */
 518     void checkAccessibleType(Env&lt;AttrContext&gt; env, Type t) {
 519         accessibilityChecker.visit(t, env);
 520     }
 521 
 522     /**
 523      * Accessibility type-visitor
 524      */
 525     Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt; accessibilityChecker =
 526             new Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt;() {
 527 
 528         void visit(List&lt;Type&gt; ts, Env&lt;AttrContext&gt; env) {
 529             for (Type t : ts) {
 530                 visit(t, env);
 531             }
 532         }
 533 
 534         public Void visitType(Type t, Env&lt;AttrContext&gt; env) {
 535             return null;
 536         }
 537 
 538         @Override
 539         public Void visitArrayType(ArrayType t, Env&lt;AttrContext&gt; env) {
 540             visit(t.elemtype, env);
 541             return null;
 542         }
 543 
 544         @Override
 545         public Void visitClassType(ClassType t, Env&lt;AttrContext&gt; env) {
 546             visit(t.getTypeArguments(), env);
 547             if (!isAccessible(env, t, true)) {
 548                 accessBase(new AccessError(env, null, t.tsym), env.tree.pos(), env.enclClass.sym, t, t.tsym.name, true);
 549             }
 550             return null;
 551         }
 552 
 553         @Override
 554         public Void visitWildcardType(WildcardType t, Env&lt;AttrContext&gt; env) {
 555             visit(t.type, env);
 556             return null;
 557         }
 558 
 559         @Override
 560         public Void visitMethodType(MethodType t, Env&lt;AttrContext&gt; env) {
 561             visit(t.getParameterTypes(), env);
 562             visit(t.getReturnType(), env);
 563             visit(t.getThrownTypes(), env);
 564             return null;
 565         }
 566     };
 567 
 568     /** Try to instantiate the type of a method so that it fits
 569      *  given type arguments and argument types. If successful, return
 570      *  the method&#39;s instantiated type, else return null.
 571      *  The instantiation will take into account an additional leading
 572      *  formal parameter if the method is an instance method seen as a member
 573      *  of an under determined site. In this case, we treat site as an additional
 574      *  parameter and the parameters of the class containing the method as
 575      *  additional type variables that get instantiated.
 576      *
 577      *  @param env         The current environment
 578      *  @param site        The type of which the method is a member.
 579      *  @param m           The method symbol.
 580      *  @param argtypes    The invocation&#39;s given value arguments.
 581      *  @param typeargtypes    The invocation&#39;s given type arguments.
 582      *  @param allowBoxing Allow boxing conversions of arguments.
 583      *  @param useVarargs Box trailing arguments into an array for varargs.
 584      */
 585     Type rawInstantiate(Env&lt;AttrContext&gt; env,
 586                         Type site,
 587                         Symbol m,
 588                         ResultInfo resultInfo,
 589                         List&lt;Type&gt; argtypes,
 590                         List&lt;Type&gt; typeargtypes,
 591                         boolean allowBoxing,
 592                         boolean useVarargs,
 593                         Warner warn) throws Infer.InferenceException {
 594         Type mt = types.memberType(site, m);
 595         // tvars is the list of formal type variables for which type arguments
 596         // need to inferred.
 597         List&lt;Type&gt; tvars = List.nil();
 598         if (typeargtypes == null) typeargtypes = List.nil();
 599         if (!mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 600             // This is not a polymorphic method, but typeargs are supplied
 601             // which is fine, see JLS 15.12.2.1
 602         } else if (mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 603             ForAll pmt = (ForAll) mt;
 604             if (typeargtypes.length() != pmt.tvars.length())
 605                  // not enough args
 606                 throw new InapplicableMethodException(diags.fragment(Fragments.WrongNumberTypeArgs(Integer.toString(pmt.tvars.length()))));
 607             // Check type arguments are within bounds
 608             List&lt;Type&gt; formals = pmt.tvars;
 609             List&lt;Type&gt; actuals = typeargtypes;
 610             while (formals.nonEmpty() &amp;&amp; actuals.nonEmpty()) {
 611                 List&lt;Type&gt; bounds = types.subst(types.getBounds((TypeVar)formals.head),
 612                                                 pmt.tvars, typeargtypes);
 613                 for (; bounds.nonEmpty(); bounds = bounds.tail) {
 614                     if (!types.isSubtypeUnchecked(actuals.head, bounds.head, warn)) {
 615                         throw new InapplicableMethodException(diags.fragment(Fragments.ExplicitParamDoNotConformToBounds(actuals.head, bounds)));
 616                     }
 617                 }
 618                 formals = formals.tail;
 619                 actuals = actuals.tail;
 620             }
 621             mt = types.subst(pmt.qtype, pmt.tvars, typeargtypes);
 622         } else if (mt.hasTag(FORALL)) {
 623             ForAll pmt = (ForAll) mt;
 624             List&lt;Type&gt; tvars1 = types.newInstances(pmt.tvars);
 625             tvars = tvars.appendList(tvars1);
 626             mt = types.subst(pmt.qtype, pmt.tvars, tvars1);
 627         }
 628 
 629         // find out whether we need to go the slow route via infer
 630         boolean instNeeded = tvars.tail != null; /*inlined: tvars.nonEmpty()*/
 631         for (List&lt;Type&gt; l = argtypes;
 632              l.tail != null/*inlined: l.nonEmpty()*/ &amp;&amp; !instNeeded;
 633              l = l.tail) {
 634             if (l.head.hasTag(FORALL)) instNeeded = true;
 635         }
 636 
 637         if (instNeeded) {
 638             return infer.instantiateMethod(env,
 639                                     tvars,
 640                                     (MethodType)mt,
 641                                     resultInfo,
 642                                     (MethodSymbol)m,
 643                                     argtypes,
 644                                     allowBoxing,
 645                                     useVarargs,
 646                                     currentResolutionContext,
 647                                     warn);
 648         }
 649 
 650         DeferredAttr.DeferredAttrContext dc = currentResolutionContext.deferredAttrContext(m, infer.emptyContext, resultInfo, warn);
 651         currentResolutionContext.methodCheck.argumentsAcceptable(env, dc,
 652                                 argtypes, mt.getParameterTypes(), warn);
 653         dc.complete();
 654         return mt;
 655     }
 656 
 657     Type checkMethod(Env&lt;AttrContext&gt; env,
 658                      Type site,
 659                      Symbol m,
 660                      ResultInfo resultInfo,
 661                      List&lt;Type&gt; argtypes,
 662                      List&lt;Type&gt; typeargtypes,
 663                      Warner warn) {
 664         MethodResolutionContext prevContext = currentResolutionContext;
 665         try {
 666             currentResolutionContext = new MethodResolutionContext();
 667             currentResolutionContext.attrMode = (resultInfo.pt == Infer.anyPoly) ?
 668                     AttrMode.SPECULATIVE : DeferredAttr.AttrMode.CHECK;
 669             if (env.tree.hasTag(JCTree.Tag.REFERENCE)) {
 670                 //method/constructor references need special check class
 671                 //to handle inference variables in &#39;argtypes&#39; (might happen
 672                 //during an unsticking round)
 673                 currentResolutionContext.methodCheck =
 674                         new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
 675             }
 676             MethodResolutionPhase step = currentResolutionContext.step = env.info.pendingResolutionPhase;
 677             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 678                     step.isBoxingRequired(), step.isVarargsRequired(), warn);
 679         }
 680         finally {
 681             currentResolutionContext = prevContext;
 682         }
 683     }
 684 
 685     /** Same but returns null instead throwing a NoInstanceException
 686      */
 687     Type instantiate(Env&lt;AttrContext&gt; env,
 688                      Type site,
 689                      Symbol m,
 690                      ResultInfo resultInfo,
 691                      List&lt;Type&gt; argtypes,
 692                      List&lt;Type&gt; typeargtypes,
 693                      boolean allowBoxing,
 694                      boolean useVarargs,
 695                      Warner warn) {
 696         try {
 697             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 698                                   allowBoxing, useVarargs, warn);
 699         } catch (InapplicableMethodException ex) {
 700             return null;
 701         }
 702     }
 703 
 704     /**
 705      * This interface defines an entry point that should be used to perform a
 706      * method check. A method check usually consist in determining as to whether
 707      * a set of types (actuals) is compatible with another set of types (formals).
 708      * Since the notion of compatibility can vary depending on the circumstances,
 709      * this interfaces allows to easily add new pluggable method check routines.
 710      */
 711     interface MethodCheck {
 712         /**
 713          * Main method check routine. A method check usually consist in determining
 714          * as to whether a set of types (actuals) is compatible with another set of
 715          * types (formals). If an incompatibility is found, an unchecked exception
 716          * is assumed to be thrown.
 717          */
 718         void argumentsAcceptable(Env&lt;AttrContext&gt; env,
 719                                 DeferredAttrContext deferredAttrContext,
 720                                 List&lt;Type&gt; argtypes,
 721                                 List&lt;Type&gt; formals,
 722                                 Warner warn);
 723 
 724         /**
 725          * Retrieve the method check object that will be used during a
 726          * most specific check.
 727          */
 728         MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals);
 729     }
 730 
 731     /**
 732      * Helper enum defining all method check diagnostics (used by resolveMethodCheck).
 733      */
 734     enum MethodCheckDiag {
 735         /**
 736          * Actuals and formals differs in length.
 737          */
 738         ARITY_MISMATCH(&quot;arg.length.mismatch&quot;, &quot;infer.arg.length.mismatch&quot;),
 739         /**
 740          * An actual is incompatible with a formal.
 741          */
 742         ARG_MISMATCH(&quot;no.conforming.assignment.exists&quot;, &quot;infer.no.conforming.assignment.exists&quot;),
 743         /**
 744          * An actual is incompatible with the varargs element type.
 745          */
 746         VARARG_MISMATCH(&quot;varargs.argument.mismatch&quot;, &quot;infer.varargs.argument.mismatch&quot;),
 747         /**
 748          * The varargs element type is inaccessible.
 749          */
 750         INACCESSIBLE_VARARGS(&quot;inaccessible.varargs.type&quot;, &quot;inaccessible.varargs.type&quot;);
 751 
 752         final String basicKey;
 753         final String inferKey;
 754 
 755         MethodCheckDiag(String basicKey, String inferKey) {
 756             this.basicKey = basicKey;
 757             this.inferKey = inferKey;
 758         }
 759 
 760         String regex() {
 761             return String.format(&quot;([a-z]*\\.)*(%s|%s)&quot;, basicKey, inferKey);
 762         }
 763     }
 764 
 765     /**
 766      * Dummy method check object. All methods are deemed applicable, regardless
 767      * of their formal parameter types.
 768      */
 769     MethodCheck nilMethodCheck = new MethodCheck() {
 770         public void argumentsAcceptable(Env&lt;AttrContext&gt; env, DeferredAttrContext deferredAttrContext, List&lt;Type&gt; argtypes, List&lt;Type&gt; formals, Warner warn) {
 771             //do nothing - method always applicable regardless of actuals
 772         }
 773 
 774         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 775             return this;
 776         }
 777     };
 778 
 779     /**
 780      * Base class for &#39;real&#39; method checks. The class defines the logic for
 781      * iterating through formals and actuals and provides and entry point
 782      * that can be used by subclasses in order to define the actual check logic.
 783      */
 784     abstract class AbstractMethodCheck implements MethodCheck {
 785         @Override
 786         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 787                                     DeferredAttrContext deferredAttrContext,
 788                                     List&lt;Type&gt; argtypes,
 789                                     List&lt;Type&gt; formals,
 790                                     Warner warn) {
 791             //should we expand formals?
 792             boolean useVarargs = deferredAttrContext.phase.isVarargsRequired();
 793             JCTree callTree = treeForDiagnostics(env);
 794             List&lt;JCExpression&gt; trees = TreeInfo.args(callTree);
 795 
 796             //inference context used during this method check
 797             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
 798 
 799             Type varargsFormal = useVarargs ? formals.last() : null;
 800 
 801             if (varargsFormal == null &amp;&amp;
 802                     argtypes.size() != formals.size()) {
 803                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 804             }
 805 
 806             while (argtypes.nonEmpty() &amp;&amp; formals.head != varargsFormal) {
 807                 DiagnosticPosition pos = trees != null ? trees.head : null;
 808                 checkArg(pos, false, argtypes.head, formals.head, deferredAttrContext, warn);
 809                 argtypes = argtypes.tail;
 810                 formals = formals.tail;
 811                 trees = trees != null ? trees.tail : trees;
 812             }
 813 
 814             if (formals.head != varargsFormal) {
 815                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 816             }
 817 
 818             if (useVarargs) {
 819                 //note: if applicability check is triggered by most specific test,
 820                 //the last argument of a varargs is _not_ an array type (see JLS 15.12.2.5)
 821                 final Type elt = types.elemtype(varargsFormal);
 822                 while (argtypes.nonEmpty()) {
 823                     DiagnosticPosition pos = trees != null ? trees.head : null;
 824                     checkArg(pos, true, argtypes.head, elt, deferredAttrContext, warn);
 825                     argtypes = argtypes.tail;
 826                     trees = trees != null ? trees.tail : trees;
 827                 }
 828             }
 829         }
 830 
 831             // where
 832             private JCTree treeForDiagnostics(Env&lt;AttrContext&gt; env) {
 833                 return env.info.preferredTreeForDiagnostics != null ? env.info.preferredTreeForDiagnostics : env.tree;
 834             }
 835 
 836         /**
 837          * Does the actual argument conforms to the corresponding formal?
 838          */
 839         abstract void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn);
 840 
 841         protected void reportMC(DiagnosticPosition pos, MethodCheckDiag diag, InferenceContext inferenceContext, Object... args) {
 842             boolean inferDiag = inferenceContext != infer.emptyContext;
 843             if (inferDiag &amp;&amp; (!diag.inferKey.equals(diag.basicKey))) {
 844                 Object[] args2 = new Object[args.length + 1];
 845                 System.arraycopy(args, 0, args2, 1, args.length);
 846                 args2[0] = inferenceContext.inferenceVars();
 847                 args = args2;
 848             }
 849             String key = inferDiag ? diag.inferKey : diag.basicKey;
 850             throw inferDiag ?
 851                 infer.error(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args)) :
 852                 methodCheckFailure.setMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args));
 853         }
 854 
 855         /**
 856          * To eliminate the overhead associated with allocating an exception object in such an
 857          * hot execution path, we use flyweight pattern - and share the same exception instance
 858          * across multiple method check failures.
 859          */
 860         class SharedInapplicableMethodException extends InapplicableMethodException {
 861             private static final long serialVersionUID = 0;
 862 
 863             SharedInapplicableMethodException() {
 864                 super(null);
 865             }
 866 
 867             SharedInapplicableMethodException setMessage(JCDiagnostic details) {
 868                 this.diagnostic = details;
 869                 return this;
 870             }
 871         }
 872 
 873         SharedInapplicableMethodException methodCheckFailure = new SharedInapplicableMethodException();
 874 
 875         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 876             return nilMethodCheck;
 877         }
 878 
 879     }
 880 
 881     /**
 882      * Arity-based method check. A method is applicable if the number of actuals
 883      * supplied conforms to the method signature.
 884      */
 885     MethodCheck arityMethodCheck = new AbstractMethodCheck() {
 886         @Override
 887         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 888             //do nothing - actual always compatible to formals
 889         }
 890 
 891         @Override
 892         public String toString() {
 893             return &quot;arityMethodCheck&quot;;
 894         }
 895     };
 896 
 897     /**
 898      * Main method applicability routine. Given a list of actual types A,
 899      * a list of formal types F, determines whether the types in A are
 900      * compatible (by method invocation conversion) with the types in F.
 901      *
 902      * Since this routine is shared between overload resolution and method
 903      * type-inference, a (possibly empty) inference context is used to convert
 904      * formal types to the corresponding &#39;undet&#39; form ahead of a compatibility
 905      * check so that constraints can be propagated and collected.
 906      *
 907      * Moreover, if one or more types in A is a deferred type, this routine uses
 908      * DeferredAttr in order to perform deferred attribution. If one or more actual
 909      * deferred types are stuck, they are placed in a queue and revisited later
 910      * after the remainder of the arguments have been seen. If this is not sufficient
 911      * to &#39;unstuck&#39; the argument, a cyclic inference error is called out.
 912      *
 913      * A method check handler (see above) is used in order to report errors.
 914      */
 915     MethodCheck resolveMethodCheck = new AbstractMethodCheck() {
 916 
 917         @Override
 918         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 919             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 920             mresult.check(pos, actual);
 921         }
 922 
 923         @Override
 924         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 925                                     DeferredAttrContext deferredAttrContext,
 926                                     List&lt;Type&gt; argtypes,
 927                                     List&lt;Type&gt; formals,
 928                                     Warner warn) {
 929             super.argumentsAcceptable(env, deferredAttrContext, argtypes, formals, warn);
 930             // should we check varargs element type accessibility?
 931             if (deferredAttrContext.phase.isVarargsRequired()) {
 932                 if (deferredAttrContext.mode == AttrMode.CHECK || !checkVarargsAccessAfterResolution) {
 933                     varargsAccessible(env, types.elemtype(formals.last()), deferredAttrContext.inferenceContext);
 934                 }
 935             }
 936         }
 937 
 938         /**
 939          * Test that the runtime array element type corresponding to &#39;t&#39; is accessible.  &#39;t&#39; should be the
 940          * varargs element type of either the method invocation type signature (after inference completes)
 941          * or the method declaration signature (before inference completes).
 942          */
 943         private void varargsAccessible(final Env&lt;AttrContext&gt; env, final Type t, final InferenceContext inferenceContext) {
 944             if (inferenceContext.free(t)) {
 945                 inferenceContext.addFreeTypeListener(List.of(t),
 946                         solvedContext -&gt; varargsAccessible(env, solvedContext.asInstType(t), solvedContext));
 947             } else {
 948                 if (!isAccessible(env, types.erasure(t))) {
 949                     Symbol location = env.enclClass.sym;
 950                     reportMC(env.tree, MethodCheckDiag.INACCESSIBLE_VARARGS, inferenceContext, t, Kinds.kindName(location), location);
 951                 }
 952             }
 953         }
 954 
 955         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 956                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 957             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 958                 MethodCheckDiag methodDiag = varargsCheck ?
 959                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
 960 
 961                 @Override
 962                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 963                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
 964                 }
 965             };
 966             return new MethodResultInfo(to, checkContext);
 967         }
 968 
 969         @Override
 970         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 971             return new MostSpecificCheck(actuals);
 972         }
 973 
 974         @Override
 975         public String toString() {
 976             return &quot;resolveMethodCheck&quot;;
 977         }
 978     };
 979 
 980     /**
 981      * This class handles method reference applicability checks; since during
 982      * these checks it&#39;s sometime possible to have inference variables on
 983      * the actual argument types list, the method applicability check must be
 984      * extended so that inference variables are &#39;opened&#39; as needed.
 985      */
 986     class MethodReferenceCheck extends AbstractMethodCheck {
 987 
 988         InferenceContext pendingInferenceContext;
 989 
 990         MethodReferenceCheck(InferenceContext pendingInferenceContext) {
 991             this.pendingInferenceContext = pendingInferenceContext;
 992         }
 993 
 994         @Override
 995         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 996             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 997             mresult.check(pos, actual);
 998         }
 999 
1000         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
1001                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
1002             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
1003                 MethodCheckDiag methodDiag = varargsCheck ?
1004                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
1005 
1006                 @Override
1007                 public boolean compatible(Type found, Type req, Warner warn) {
1008                     found = pendingInferenceContext.asUndetVar(found);
1009                     if (found.hasTag(UNDETVAR) &amp;&amp; req.isPrimitive()) {
1010                         req = types.boxedClass(req).type;
1011                     }
1012                     return super.compatible(found, req, warn);
1013                 }
1014 
1015                 @Override
1016                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
1017                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
1018                 }
1019             };
1020             return new MethodResultInfo(to, checkContext);
1021         }
1022 
1023         @Override
1024         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1025             return new MostSpecificCheck(actuals);
1026         }
1027 
1028         @Override
1029         public String toString() {
1030             return &quot;MethodReferenceCheck&quot;;
1031         }
1032     }
1033 
1034     /**
1035      * Check context to be used during method applicability checks. A method check
1036      * context might contain inference variables.
1037      */
1038     abstract class MethodCheckContext implements CheckContext {
1039 
1040         boolean strict;
1041         DeferredAttrContext deferredAttrContext;
1042         Warner rsWarner;
1043 
1044         public MethodCheckContext(boolean strict, DeferredAttrContext deferredAttrContext, Warner rsWarner) {
1045            this.strict = strict;
1046            this.deferredAttrContext = deferredAttrContext;
1047            this.rsWarner = rsWarner;
1048         }
1049 
1050         public boolean compatible(Type found, Type req, Warner warn) {
1051             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
1052             return strict ?
1053                     types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn) :
1054                     types.isConvertible(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn);
1055         }
1056 
1057         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1058             throw new InapplicableMethodException(details);
1059         }
1060 
1061         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
1062             return rsWarner;
1063         }
1064 
1065         public InferenceContext inferenceContext() {
1066             return deferredAttrContext.inferenceContext;
1067         }
1068 
1069         public DeferredAttrContext deferredAttrContext() {
1070             return deferredAttrContext;
1071         }
1072 
1073         @Override
1074         public String toString() {
1075             return &quot;MethodCheckContext&quot;;
1076         }
1077     }
1078 
1079     /**
1080      * ResultInfo class to be used during method applicability checks. Check
1081      * for deferred types goes through special path.
1082      */
1083     class MethodResultInfo extends ResultInfo {
1084 
1085         public MethodResultInfo(Type pt, CheckContext checkContext) {
1086             attr.super(KindSelector.VAL, pt, checkContext);
1087         }
1088 
1089         @Override
1090         protected Type check(DiagnosticPosition pos, Type found) {
1091             if (found.hasTag(DEFERRED)) {
1092                 DeferredType dt = (DeferredType)found;
1093                 return dt.check(this);
1094             } else {
1095                 Type uResult = U(found);
1096                 Type capturedType = pos == null || pos.getTree() == null ?
1097                         types.capture(uResult) :
1098                         checkContext.inferenceContext()
1099                             .cachedCapture(pos.getTree(), uResult, true);
1100                 return super.check(pos, chk.checkNonVoid(pos, capturedType));
1101             }
1102         }
1103 
1104         /**
1105          * javac has a long-standing &#39;simplification&#39; (see 6391995):
1106          * given an actual argument type, the method check is performed
1107          * on its upper bound. This leads to inconsistencies when an
1108          * argument type is checked against itself. For example, given
1109          * a type-variable T, it is not true that {@code U(T) &lt;: T},
1110          * so we need to guard against that.
1111          */
1112         private Type U(Type found) {
1113             return found == pt ?
1114                     found : types.cvarUpperBound(found);
1115         }
1116 
1117         @Override
1118         protected MethodResultInfo dup(Type newPt) {
1119             return new MethodResultInfo(newPt, checkContext);
1120         }
1121 
1122         @Override
1123         protected ResultInfo dup(CheckContext newContext) {
1124             return new MethodResultInfo(pt, newContext);
1125         }
1126 
1127         @Override
1128         protected ResultInfo dup(Type newPt, CheckContext newContext) {
1129             return new MethodResultInfo(newPt, newContext);
1130         }
1131     }
1132 
1133     /**
1134      * Most specific method applicability routine. Given a list of actual types A,
1135      * a list of formal types F1, and a list of formal types F2, the routine determines
1136      * as to whether the types in F1 can be considered more specific than those in F2 w.r.t.
1137      * argument types A.
1138      */
1139     class MostSpecificCheck implements MethodCheck {
1140 
1141         List&lt;Type&gt; actuals;
1142 
1143         MostSpecificCheck(List&lt;Type&gt; actuals) {
1144             this.actuals = actuals;
1145         }
1146 
1147         @Override
1148         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
1149                                     DeferredAttrContext deferredAttrContext,
1150                                     List&lt;Type&gt; formals1,
1151                                     List&lt;Type&gt; formals2,
1152                                     Warner warn) {
1153             formals2 = adjustArgs(formals2, deferredAttrContext.msym, formals1.length(), deferredAttrContext.phase.isVarargsRequired());
1154             while (formals2.nonEmpty()) {
1155                 ResultInfo mresult = methodCheckResult(formals2.head, deferredAttrContext, warn, actuals.head);
1156                 mresult.check(null, formals1.head);
1157                 formals1 = formals1.tail;
1158                 formals2 = formals2.tail;
1159                 actuals = actuals.isEmpty() ? actuals : actuals.tail;
1160             }
1161         }
1162 
1163        /**
1164         * Create a method check context to be used during the most specific applicability check
1165         */
1166         ResultInfo methodCheckResult(Type to, DeferredAttr.DeferredAttrContext deferredAttrContext,
1167                Warner rsWarner, Type actual) {
1168             return attr.new ResultInfo(KindSelector.VAL, to,
1169                    new MostSpecificCheckContext(deferredAttrContext, rsWarner, actual));
1170         }
1171 
1172         /**
1173          * Subclass of method check context class that implements most specific
1174          * method conversion. If the actual type under analysis is a deferred type
1175          * a full blown structural analysis is carried out.
1176          */
1177         class MostSpecificCheckContext extends MethodCheckContext {
1178 
1179             Type actual;
1180 
1181             public MostSpecificCheckContext(DeferredAttrContext deferredAttrContext, Warner rsWarner, Type actual) {
1182                 super(true, deferredAttrContext, rsWarner);
1183                 this.actual = actual;
1184             }
1185 
1186             public boolean compatible(Type found, Type req, Warner warn) {
1187                 if (allowFunctionalInterfaceMostSpecific &amp;&amp;
1188                         unrelatedFunctionalInterfaces(found, req) &amp;&amp;
1189                         (actual != null &amp;&amp; actual.getTag() == DEFERRED)) {
1190                     DeferredType dt = (DeferredType) actual;
1191                     JCTree speculativeTree = dt.speculativeTree(deferredAttrContext);
1192                     if (speculativeTree != deferredAttr.stuckTree) {
1193                         return functionalInterfaceMostSpecific(found, req, speculativeTree);
1194                     }
1195                 }
1196                 return compatibleBySubtyping(found, req);
1197             }
1198 
1199             private boolean compatibleBySubtyping(Type found, Type req) {
1200                 if (!strict &amp;&amp; found.isPrimitive() != req.isPrimitive()) {
1201                     found = found.isPrimitive() ? types.boxedClass(found).type : types.unboxedType(found);
1202                 }
1203                 return types.isSubtypeNoCapture(found, deferredAttrContext.inferenceContext.asUndetVar(req));
1204             }
1205 
1206             /** Whether {@code t} and {@code s} are unrelated functional interface types. */
1207             private boolean unrelatedFunctionalInterfaces(Type t, Type s) {
1208                 return types.isFunctionalInterface(t.tsym) &amp;&amp;
1209                        types.isFunctionalInterface(s.tsym) &amp;&amp;
1210                        unrelatedInterfaces(t, s);
1211             }
1212 
1213             /** Whether {@code t} and {@code s} are unrelated interface types; recurs on intersections. **/
1214             private boolean unrelatedInterfaces(Type t, Type s) {
1215                 if (t.isCompound()) {
1216                     for (Type ti : types.interfaces(t)) {
1217                         if (!unrelatedInterfaces(ti, s)) {
1218                             return false;
1219                         }
1220                     }
1221                     return true;
1222                 } else if (s.isCompound()) {
1223                     for (Type si : types.interfaces(s)) {
1224                         if (!unrelatedInterfaces(t, si)) {
1225                             return false;
1226                         }
1227                     }
1228                     return true;
1229                 } else {
1230                     return types.asSuper(t, s.tsym) == null &amp;&amp; types.asSuper(s, t.tsym) == null;
1231                 }
1232             }
1233 
1234             /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1235             private boolean functionalInterfaceMostSpecific(Type t, Type s, JCTree tree) {
1236                 Type tDesc = types.findDescriptorType(types.capture(t));
1237                 Type tDescNoCapture = types.findDescriptorType(t);
1238                 Type sDesc = types.findDescriptorType(s);
1239                 final List&lt;Type&gt; tTypeParams = tDesc.getTypeArguments();
1240                 final List&lt;Type&gt; tTypeParamsNoCapture = tDescNoCapture.getTypeArguments();
1241                 final List&lt;Type&gt; sTypeParams = sDesc.getTypeArguments();
1242 
1243                 // compare type parameters
1244                 if (tDesc.hasTag(FORALL) &amp;&amp; !types.hasSameBounds((ForAll) tDesc, (ForAll) tDescNoCapture)) {
1245                     return false;
1246                 }
1247                 // can&#39;t use Types.hasSameBounds on sDesc because bounds may have ivars
1248                 List&lt;Type&gt; tIter = tTypeParams;
1249                 List&lt;Type&gt; sIter = sTypeParams;
1250                 while (tIter.nonEmpty() &amp;&amp; sIter.nonEmpty()) {
1251                     Type tBound = tIter.head.getUpperBound();
1252                     Type sBound = types.subst(sIter.head.getUpperBound(), sTypeParams, tTypeParams);
1253                     if (tBound.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sBound)) {
1254                         return false;
1255                     }
1256                     if (!types.isSameType(tBound, inferenceContext().asUndetVar(sBound))) {
1257                         return false;
1258                     }
1259                     tIter = tIter.tail;
1260                     sIter = sIter.tail;
1261                 }
1262                 if (!tIter.isEmpty() || !sIter.isEmpty()) {
1263                     return false;
1264                 }
1265 
1266                 // compare parameters
1267                 List&lt;Type&gt; tParams = tDesc.getParameterTypes();
1268                 List&lt;Type&gt; tParamsNoCapture = tDescNoCapture.getParameterTypes();
1269                 List&lt;Type&gt; sParams = sDesc.getParameterTypes();
1270                 while (tParams.nonEmpty() &amp;&amp; tParamsNoCapture.nonEmpty() &amp;&amp; sParams.nonEmpty()) {
1271                     Type tParam = tParams.head;
1272                     Type tParamNoCapture = types.subst(tParamsNoCapture.head, tTypeParamsNoCapture, tTypeParams);
1273                     Type sParam = types.subst(sParams.head, sTypeParams, tTypeParams);
1274                     if (tParam.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sParam)) {
1275                         return false;
1276                     }
1277                     if (!types.isSubtype(inferenceContext().asUndetVar(sParam), tParam)) {
1278                         return false;
1279                     }
1280                     if (!types.isSameType(tParamNoCapture, inferenceContext().asUndetVar(sParam))) {
1281                         return false;
1282                     }
1283                     tParams = tParams.tail;
1284                     tParamsNoCapture = tParamsNoCapture.tail;
1285                     sParams = sParams.tail;
1286                 }
1287                 if (!tParams.isEmpty() || !tParamsNoCapture.isEmpty() || !sParams.isEmpty()) {
1288                     return false;
1289                 }
1290 
1291                 // compare returns
1292                 Type tRet = tDesc.getReturnType();
1293                 Type sRet = types.subst(sDesc.getReturnType(), sTypeParams, tTypeParams);
1294                 if (tRet.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sRet)) {
1295                     return false;
1296                 }
1297                 MostSpecificFunctionReturnChecker msc = new MostSpecificFunctionReturnChecker(tRet, sRet);
1298                 msc.scan(tree);
1299                 return msc.result;
1300             }
1301 
1302             /**
1303              * Tests whether one functional interface type can be considered more specific
1304              * than another unrelated functional interface type for the scanned expression.
1305              */
1306             class MostSpecificFunctionReturnChecker extends DeferredAttr.PolyScanner {
1307 
1308                 final Type tRet;
1309                 final Type sRet;
1310                 boolean result;
1311 
1312                 /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1313                 MostSpecificFunctionReturnChecker(Type tRet, Type sRet) {
1314                     this.tRet = tRet;
1315                     this.sRet = sRet;
1316                     result = true;
1317                 }
1318 
1319                 @Override
1320                 void skip(JCTree tree) {
1321                     result &amp;= false;
1322                 }
1323 
1324                 @Override
1325                 public void visitConditional(JCConditional tree) {
1326                     scan(asExpr(tree.truepart));
1327                     scan(asExpr(tree.falsepart));
1328                 }
1329 
1330                 @Override
1331                 public void visitReference(JCMemberReference tree) {
1332                     if (sRet.hasTag(VOID)) {
1333                         result &amp;= true;
1334                     } else if (tRet.hasTag(VOID)) {
1335                         result &amp;= false;
1336                     } else if (tRet.isPrimitive() != sRet.isPrimitive()) {
1337                         boolean retValIsPrimitive =
1338                                 tree.refPolyKind == PolyKind.STANDALONE &amp;&amp;
1339                                 tree.sym.type.getReturnType().isPrimitive();
1340                         result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1341                                   (retValIsPrimitive != sRet.isPrimitive());
1342                     } else {
1343                         result &amp;= compatibleBySubtyping(tRet, sRet);
1344                     }
1345                 }
1346 
1347                 @Override
1348                 public void visitParens(JCParens tree) {
1349                     scan(asExpr(tree.expr));
1350                 }
1351 
1352                 @Override
1353                 public void visitLambda(JCLambda tree) {
1354                     if (sRet.hasTag(VOID)) {
1355                         result &amp;= true;
1356                     } else if (tRet.hasTag(VOID)) {
1357                         result &amp;= false;
1358                     } else {
1359                         List&lt;JCExpression&gt; lambdaResults = lambdaResults(tree);
1360                         if (!lambdaResults.isEmpty() &amp;&amp; unrelatedFunctionalInterfaces(tRet, sRet)) {
1361                             for (JCExpression expr : lambdaResults) {
1362                                 result &amp;= functionalInterfaceMostSpecific(tRet, sRet, expr);
1363                             }
1364                         } else if (!lambdaResults.isEmpty() &amp;&amp; tRet.isPrimitive() != sRet.isPrimitive()) {
1365                             for (JCExpression expr : lambdaResults) {
1366                                 boolean retValIsPrimitive = expr.isStandalone() &amp;&amp; expr.type.isPrimitive();
1367                                 result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1368                                         (retValIsPrimitive != sRet.isPrimitive());
1369                             }
1370                         } else {
1371                             result &amp;= compatibleBySubtyping(tRet, sRet);
1372                         }
1373                     }
1374                 }
1375                 //where
1376 
1377                 private List&lt;JCExpression&gt; lambdaResults(JCLambda lambda) {
1378                     if (lambda.getBodyKind() == JCTree.JCLambda.BodyKind.EXPRESSION) {
1379                         return List.of(asExpr((JCExpression) lambda.body));
1380                     } else {
1381                         final ListBuffer&lt;JCExpression&gt; buffer = new ListBuffer&lt;&gt;();
1382                         DeferredAttr.LambdaReturnScanner lambdaScanner =
1383                                 new DeferredAttr.LambdaReturnScanner() {
1384                                     @Override
1385                                     public void visitReturn(JCReturn tree) {
1386                                         if (tree.expr != null) {
1387                                             buffer.append(asExpr(tree.expr));
1388                                         }
1389                                     }
1390                                 };
1391                         lambdaScanner.scan(lambda.body);
1392                         return buffer.toList();
1393                     }
1394                 }
1395 
1396                 private JCExpression asExpr(JCExpression expr) {
1397                     if (expr.type.hasTag(DEFERRED)) {
1398                         JCTree speculativeTree = ((DeferredType)expr.type).speculativeTree(deferredAttrContext);
1399                         if (speculativeTree != deferredAttr.stuckTree) {
1400                             expr = (JCExpression)speculativeTree;
1401                         }
1402                     }
1403                     return expr;
1404                 }
1405             }
1406 
1407         }
1408 
1409         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1410             Assert.error(&quot;Cannot get here!&quot;);
1411             return null;
1412         }
1413     }
1414 
1415     public static class InapplicableMethodException extends RuntimeException {
1416         private static final long serialVersionUID = 0;
1417 
1418         transient JCDiagnostic diagnostic;
1419 
1420         InapplicableMethodException(JCDiagnostic diag) {
1421             this.diagnostic = diag;
1422         }
1423 
1424         public JCDiagnostic getDiagnostic() {
1425             return diagnostic;
1426         }
1427     }
1428 
1429 /* ***************************************************************************
1430  *  Symbol lookup
1431  *  the following naming conventions for arguments are used
1432  *
1433  *       env      is the environment where the symbol was mentioned
1434  *       site     is the type of which the symbol is a member
1435  *       name     is the symbol&#39;s name
1436  *                if no arguments are given
1437  *       argtypes are the value arguments, if we search for a method
1438  *
1439  *  If no symbol was found, a ResolveError detailing the problem is returned.
1440  ****************************************************************************/
1441 
1442     /** Find field. Synthetic fields are always skipped.
1443      *  @param env     The current environment.
1444      *  @param site    The original type from where the selection takes place.
1445      *  @param name    The name of the field.
1446      *  @param c       The class to search for the field. This is always
1447      *                 a superclass or implemented interface of site&#39;s class.
1448      */
1449     Symbol findField(Env&lt;AttrContext&gt; env,
1450                      Type site,
1451                      Name name,
1452                      TypeSymbol c) {
1453         while (c.type.hasTag(TYPEVAR))
1454             c = c.type.getUpperBound().tsym;
1455         Symbol bestSoFar = varNotFound;
1456         Symbol sym;
1457         for (Symbol s : c.members().getSymbolsByName(name)) {
1458             if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1459                 return isAccessible(env, site, s)
1460                     ? s : new AccessError(env, site, s);
1461             }
1462         }
1463         Type st = types.supertype(c.type);
1464         if (st != null &amp;&amp; (st.hasTag(CLASS) || st.hasTag(TYPEVAR))) {
1465             sym = findField(env, site, name, st.tsym);
1466             bestSoFar = bestOf(bestSoFar, sym);
1467         }
1468         for (List&lt;Type&gt; l = types.interfaces(c.type);
1469              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
1470              l = l.tail) {
1471             sym = findField(env, site, name, l.head.tsym);
1472             if (bestSoFar.exists() &amp;&amp; sym.exists() &amp;&amp;
1473                 sym.owner != bestSoFar.owner)
1474                 bestSoFar = new AmbiguityError(bestSoFar, sym);
1475             else
1476                 bestSoFar = bestOf(bestSoFar, sym);
1477         }
1478         return bestSoFar;
1479     }
1480 
1481     /** Resolve a field identifier, throw a fatal error if not found.
1482      *  @param pos       The position to use for error reporting.
1483      *  @param env       The environment current at the method invocation.
1484      *  @param site      The type of the qualifying expression, in which
1485      *                   identifier is searched.
1486      *  @param name      The identifier&#39;s name.
1487      */
1488     public VarSymbol resolveInternalField(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
1489                                           Type site, Name name) {
1490         Symbol sym = findField(env, site, name, site.tsym);
1491         if (sym.kind == VAR) return (VarSymbol)sym;
1492         else throw new FatalError(
1493                  diags.fragment(Fragments.FatalErrCantLocateField(name)));
1494     }
1495 
1496     /** Find unqualified variable or field with given name.
1497      *  Synthetic fields always skipped.
1498      *  @param env     The current environment.
1499      *  @param name    The name of the variable or field.
1500      */
1501     Symbol findVar(Env&lt;AttrContext&gt; env, Name name) {
1502         Symbol bestSoFar = varNotFound;
1503         Env&lt;AttrContext&gt; env1 = env;
1504         boolean staticOnly = false;
1505         while (env1.outer != null) {
1506             Symbol sym = null;
1507             if (isStatic(env1)) staticOnly = true;
1508             for (Symbol s : env1.info.scope.getSymbolsByName(name)) {
1509                 if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1510                     sym = s;
1511                     break;
1512                 }
1513             }
1514             if (sym == null) {
1515                 sym = findField(env1, env1.enclClass.sym.type, name, env1.enclClass.sym);
1516             }
1517             if (sym.exists()) {
1518                 if (staticOnly &amp;&amp;
1519                     sym.kind == VAR &amp;&amp;
1520                         // if it is a field
1521                         (sym.owner.kind == TYP ||
1522                         // or it is a local variable but it is not declared inside of the static local type
1523                         // only records so far, then error
1524                         (sym.owner.kind == MTH) &amp;&amp;
1525                         (env.enclClass.sym.flags() &amp; STATIC) != 0 &amp;&amp;
1526                         sym.enclClass() != env.enclClass.sym) &amp;&amp;
1527                     (sym.flags() &amp; STATIC) == 0)
1528                     return new StaticError(sym);
1529                 else
1530                     return sym;
1531             } else {
1532                 bestSoFar = bestOf(bestSoFar, sym);
1533             }
1534 
1535             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1536             env1 = env1.outer;
1537         }
1538 
1539         Symbol sym = findField(env, syms.predefClass.type, name, syms.predefClass);
1540         if (sym.exists())
1541             return sym;
1542         if (bestSoFar.exists())
1543             return bestSoFar;
1544 
1545         Symbol origin = null;
1546         for (Scope sc : new Scope[] { env.toplevel.namedImportScope, env.toplevel.starImportScope }) {
1547             for (Symbol currentSymbol : sc.getSymbolsByName(name)) {
1548                 if (currentSymbol.kind != VAR)
1549                     continue;
1550                 // invariant: sym.kind == Symbol.Kind.VAR
1551                 if (!bestSoFar.kind.isResolutionError() &amp;&amp;
1552                     currentSymbol.owner != bestSoFar.owner)
1553                     return new AmbiguityError(bestSoFar, currentSymbol);
1554                 else if (!bestSoFar.kind.betterThan(VAR)) {
1555                     origin = sc.getOrigin(currentSymbol).owner;
1556                     bestSoFar = isAccessible(env, origin.type, currentSymbol)
1557                         ? currentSymbol : new AccessError(env, origin.type, currentSymbol);
1558                 }
1559             }
1560             if (bestSoFar.exists()) break;
1561         }
1562         if (bestSoFar.kind == VAR &amp;&amp; bestSoFar.owner.type != origin.type)
1563             return bestSoFar.clone(origin);
1564         else
1565             return bestSoFar;
1566     }
1567 
1568     Warner noteWarner = new Warner();
1569 
1570     /** Select the best method for a call site among two choices.
1571      *  @param env              The current environment.
1572      *  @param site             The original type from where the
1573      *                          selection takes place.
1574      *  @param argtypes         The invocation&#39;s value arguments,
1575      *  @param typeargtypes     The invocation&#39;s type arguments,
1576      *  @param sym              Proposed new best match.
1577      *  @param bestSoFar        Previously found best match.
1578      *  @param allowBoxing Allow boxing conversions of arguments.
1579      *  @param useVarargs Box trailing arguments into an array for varargs.
1580      */
1581     @SuppressWarnings(&quot;fallthrough&quot;)
1582     Symbol selectBest(Env&lt;AttrContext&gt; env,
1583                       Type site,
1584                       List&lt;Type&gt; argtypes,
1585                       List&lt;Type&gt; typeargtypes,
1586                       Symbol sym,
1587                       Symbol bestSoFar,
1588                       boolean allowBoxing,
1589                       boolean useVarargs) {
1590         if (sym.kind == ERR ||
1591                 (site.tsym != sym.owner &amp;&amp; !sym.isInheritedIn(site.tsym, types)) ||
1592                 !notOverriddenIn(site, sym)) {
1593             return bestSoFar;
1594         } else if (useVarargs &amp;&amp; (sym.flags() &amp; VARARGS) == 0) {
1595             return bestSoFar.kind.isResolutionError() ?
1596                     new BadVarargsMethod((ResolveError)bestSoFar.baseSymbol()) :
1597                     bestSoFar;
1598         }
1599         Assert.check(!sym.kind.isResolutionError());
1600         try {
1601             types.noWarnings.clear();
1602             Type mt = rawInstantiate(env, site, sym, null, argtypes, typeargtypes,
1603                                allowBoxing, useVarargs, types.noWarnings);
1604             currentResolutionContext.addApplicableCandidate(sym, mt);
1605         } catch (InapplicableMethodException ex) {
1606             currentResolutionContext.addInapplicableCandidate(sym, ex.getDiagnostic());
1607             switch (bestSoFar.kind) {
1608                 case ABSENT_MTH:
1609                     return new InapplicableSymbolError(currentResolutionContext);
1610                 case WRONG_MTH:
1611                     bestSoFar = new InapplicableSymbolsError(currentResolutionContext);
1612                 default:
1613                     return bestSoFar;
1614             }
1615         }
1616         if (!isAccessible(env, site, sym)) {
1617             return (bestSoFar.kind == ABSENT_MTH)
1618                 ? new AccessError(env, site, sym)
1619                 : bestSoFar;
1620         }
1621         return (bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS)
1622             ? sym
1623             : mostSpecific(argtypes, sym, bestSoFar, env, site, useVarargs);
1624     }
1625 
1626     /* Return the most specific of the two methods for a call,
1627      *  given that both are accessible and applicable.
1628      *  @param m1               A new candidate for most specific.
1629      *  @param m2               The previous most specific candidate.
1630      *  @param env              The current environment.
1631      *  @param site             The original type from where the selection
1632      *                          takes place.
1633      *  @param allowBoxing Allow boxing conversions of arguments.
1634      *  @param useVarargs Box trailing arguments into an array for varargs.
1635      */
1636     Symbol mostSpecific(List&lt;Type&gt; argtypes, Symbol m1,
1637                         Symbol m2,
1638                         Env&lt;AttrContext&gt; env,
1639                         final Type site,
1640                         boolean useVarargs) {
1641         switch (m2.kind) {
1642         case MTH:
1643             if (m1 == m2) return m1;
1644             boolean m1SignatureMoreSpecific =
1645                     signatureMoreSpecific(argtypes, env, site, m1, m2, useVarargs);
1646             boolean m2SignatureMoreSpecific =
1647                     signatureMoreSpecific(argtypes, env, site, m2, m1, useVarargs);
1648             if (m1SignatureMoreSpecific &amp;&amp; m2SignatureMoreSpecific) {
1649                 Type mt1 = types.memberType(site, m1);
1650                 Type mt2 = types.memberType(site, m2);
1651                 if (!types.overrideEquivalent(mt1, mt2))
1652                     return ambiguityError(m1, m2);
1653 
1654                 // same signature; select (a) the non-bridge method, or
1655                 // (b) the one that overrides the other, or (c) the concrete
1656                 // one, or (d) merge both abstract signatures
1657                 if ((m1.flags() &amp; BRIDGE) != (m2.flags() &amp; BRIDGE))
1658                     return ((m1.flags() &amp; BRIDGE) != 0) ? m2 : m1;
1659 
1660                 if (m1.baseSymbol() == m2.baseSymbol()) {
1661                     // this is the same imported symbol which has been cloned twice.
1662                     // Return the first one (either will do).
1663                     return m1;
1664                 }
1665 
1666                 // if one overrides or hides the other, use it
1667                 TypeSymbol m1Owner = (TypeSymbol)m1.owner;
1668                 TypeSymbol m2Owner = (TypeSymbol)m2.owner;
1669                 // the two owners can never be the same if the target methods are compiled from source,
1670                 // but we need to protect against cases where the methods are defined in some classfile
1671                 // and make sure we issue an ambiguity error accordingly (by skipping the logic below).
1672                 if (m1Owner != m2Owner) {
1673                     if (types.asSuper(m1Owner.type, m2Owner) != null &amp;&amp;
1674                         ((m1.owner.flags_field &amp; INTERFACE) == 0 ||
1675                          (m2.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1676                         m1.overrides(m2, m1Owner, types, false))
1677                         return m1;
1678                     if (types.asSuper(m2Owner.type, m1Owner) != null &amp;&amp;
1679                         ((m2.owner.flags_field &amp; INTERFACE) == 0 ||
1680                          (m1.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1681                         m2.overrides(m1, m2Owner, types, false))
1682                         return m2;
1683                 }
1684                 boolean m1Abstract = (m1.flags() &amp; ABSTRACT) != 0;
1685                 boolean m2Abstract = (m2.flags() &amp; ABSTRACT) != 0;
1686                 if (m1Abstract &amp;&amp; !m2Abstract) return m2;
1687                 if (m2Abstract &amp;&amp; !m1Abstract) return m1;
1688                 // both abstract or both concrete
1689                 return ambiguityError(m1, m2);
1690             }
1691             if (m1SignatureMoreSpecific) return m1;
1692             if (m2SignatureMoreSpecific) return m2;
1693             return ambiguityError(m1, m2);
1694         case AMBIGUOUS:
1695             //compare m1 to ambiguous methods in m2
1696             AmbiguityError e = (AmbiguityError)m2.baseSymbol();
1697             boolean m1MoreSpecificThanAnyAmbiguous = true;
1698             boolean allAmbiguousMoreSpecificThanM1 = true;
1699             for (Symbol s : e.ambiguousSyms) {
1700                 Symbol moreSpecific = mostSpecific(argtypes, m1, s, env, site, useVarargs);
1701                 m1MoreSpecificThanAnyAmbiguous &amp;= moreSpecific == m1;
1702                 allAmbiguousMoreSpecificThanM1 &amp;= moreSpecific == s;
1703             }
1704             if (m1MoreSpecificThanAnyAmbiguous)
1705                 return m1;
1706             //if m1 is more specific than some ambiguous methods, but other ambiguous methods are
1707             //more specific than m1, add it as a new ambiguous method:
1708             if (!allAmbiguousMoreSpecificThanM1)
1709                 e.addAmbiguousSymbol(m1);
1710             return e;
1711         default:
1712             throw new AssertionError();
1713         }
1714     }
1715     //where
1716     private boolean signatureMoreSpecific(List&lt;Type&gt; actuals, Env&lt;AttrContext&gt; env, Type site, Symbol m1, Symbol m2, boolean useVarargs) {
1717         noteWarner.clear();
1718         int maxLength = Math.max(
1719                             Math.max(m1.type.getParameterTypes().length(), actuals.length()),
1720                             m2.type.getParameterTypes().length());
1721         MethodResolutionContext prevResolutionContext = currentResolutionContext;
1722         try {
1723             currentResolutionContext = new MethodResolutionContext();
1724             currentResolutionContext.step = prevResolutionContext.step;
1725             currentResolutionContext.methodCheck =
1726                     prevResolutionContext.methodCheck.mostSpecificCheck(actuals);
1727             Type mst = instantiate(env, site, m2, null,
1728                     adjustArgs(types.cvarLowerBounds(types.memberType(site, m1).getParameterTypes()), m1, maxLength, useVarargs), null,
1729                     false, useVarargs, noteWarner);
1730             return mst != null &amp;&amp;
1731                     !noteWarner.hasLint(Lint.LintCategory.UNCHECKED);
1732         } finally {
1733             currentResolutionContext = prevResolutionContext;
1734         }
1735     }
1736 
1737     List&lt;Type&gt; adjustArgs(List&lt;Type&gt; args, Symbol msym, int length, boolean allowVarargs) {
1738         if ((msym.flags() &amp; VARARGS) != 0 &amp;&amp; allowVarargs) {
1739             Type varargsElem = types.elemtype(args.last());
1740             if (varargsElem == null) {
1741                 Assert.error(&quot;Bad varargs = &quot; + args.last() + &quot; &quot; + msym);
1742             }
1743             List&lt;Type&gt; newArgs = args.reverse().tail.prepend(varargsElem).reverse();
1744             while (newArgs.length() &lt; length) {
1745                 newArgs = newArgs.append(newArgs.last());
1746             }
1747             return newArgs;
1748         } else {
1749             return args;
1750         }
1751     }
1752     //where
1753     Symbol ambiguityError(Symbol m1, Symbol m2) {
1754         if (((m1.flags() | m2.flags()) &amp; CLASH) != 0) {
1755             return (m1.flags() &amp; CLASH) == 0 ? m1 : m2;
1756         } else {
1757             return new AmbiguityError(m1, m2);
1758         }
1759     }
1760 
1761     Symbol findMethodInScope(Env&lt;AttrContext&gt; env,
1762             Type site,
1763             Name name,
1764             List&lt;Type&gt; argtypes,
1765             List&lt;Type&gt; typeargtypes,
1766             Scope sc,
1767             Symbol bestSoFar,
1768             boolean allowBoxing,
1769             boolean useVarargs,
1770             boolean abstractok) {
1771         for (Symbol s : sc.getSymbolsByName(name, new LookupFilter(abstractok))) {
1772             bestSoFar = selectBest(env, site, argtypes, typeargtypes, s,
1773                     bestSoFar, allowBoxing, useVarargs);
1774         }
1775         return bestSoFar;
1776     }
1777     //where
1778         class LookupFilter implements Filter&lt;Symbol&gt; {
1779 
1780             boolean abstractOk;
1781 
1782             LookupFilter(boolean abstractOk) {
1783                 this.abstractOk = abstractOk;
1784             }
1785 
1786             public boolean accepts(Symbol s) {
1787                 long flags = s.flags();
1788                 return s.kind == MTH &amp;&amp;
1789                         (flags &amp; SYNTHETIC) == 0 &amp;&amp;
1790                         (abstractOk ||
1791                         (flags &amp; DEFAULT) != 0 ||
1792                         (flags &amp; ABSTRACT) == 0);
1793             }
1794         }
1795 
1796     /** Find best qualified method matching given name, type and value
1797      *  arguments.
1798      *  @param env       The current environment.
1799      *  @param site      The original type from where the selection
1800      *                   takes place.
1801      *  @param name      The method&#39;s name.
1802      *  @param argtypes  The method&#39;s value arguments.
1803      *  @param typeargtypes The method&#39;s type arguments
1804      *  @param allowBoxing Allow boxing conversions of arguments.
1805      *  @param useVarargs Box trailing arguments into an array for varargs.
1806      */
1807     Symbol findMethod(Env&lt;AttrContext&gt; env,
1808                       Type site,
1809                       Name name,
1810                       List&lt;Type&gt; argtypes,
1811                       List&lt;Type&gt; typeargtypes,
1812                       boolean allowBoxing,
1813                       boolean useVarargs) {
1814         Symbol bestSoFar = methodNotFound;
1815         bestSoFar = findMethod(env,
1816                           site,
1817                           name,
1818                           argtypes,
1819                           typeargtypes,
1820                           site.tsym.type,
1821                           bestSoFar,
1822                           allowBoxing,
1823                           useVarargs);
1824         return bestSoFar;
1825     }
1826     // where
1827     private Symbol findMethod(Env&lt;AttrContext&gt; env,
1828                               Type site,
1829                               Name name,
1830                               List&lt;Type&gt; argtypes,
1831                               List&lt;Type&gt; typeargtypes,
1832                               Type intype,
1833                               Symbol bestSoFar,
1834                               boolean allowBoxing,
1835                               boolean useVarargs) {
1836         @SuppressWarnings({&quot;unchecked&quot;,&quot;rawtypes&quot;})
1837         List&lt;Type&gt;[] itypes = (List&lt;Type&gt;[])new List[] { List.&lt;Type&gt;nil(), List.&lt;Type&gt;nil() };
1838 
1839         InterfaceLookupPhase iphase = InterfaceLookupPhase.ABSTRACT_OK;
1840         for (TypeSymbol s : superclasses(intype)) {
1841             bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1842                     s.members(), bestSoFar, allowBoxing, useVarargs, true);
1843             if (name == names.init) return bestSoFar;
1844             iphase = (iphase == null) ? null : iphase.update(s, this);
1845             if (iphase != null) {
1846                 for (Type itype : types.interfaces(s.type)) {
1847                     itypes[iphase.ordinal()] = types.union(types.closure(itype), itypes[iphase.ordinal()]);
1848                 }
1849             }
1850         }
1851 
1852         Symbol concrete = bestSoFar.kind.isValid() &amp;&amp;
1853                 (bestSoFar.flags() &amp; ABSTRACT) == 0 ?
1854                 bestSoFar : methodNotFound;
1855 
1856         for (InterfaceLookupPhase iphase2 : InterfaceLookupPhase.values()) {
1857             //keep searching for abstract methods
1858             for (Type itype : itypes[iphase2.ordinal()]) {
1859                 if (!itype.isInterface()) continue; //skip j.l.Object (included by Types.closure())
1860                 if (iphase2 == InterfaceLookupPhase.DEFAULT_OK &amp;&amp;
1861                         (itype.tsym.flags() &amp; DEFAULT) == 0) continue;
1862                 bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1863                         itype.tsym.members(), bestSoFar, allowBoxing, useVarargs, true);
1864                 if (concrete != bestSoFar &amp;&amp;
1865                     concrete.kind.isValid() &amp;&amp;
1866                     bestSoFar.kind.isValid() &amp;&amp;
1867                         types.isSubSignature(concrete.type, bestSoFar.type)) {
1868                     //this is an hack - as javac does not do full membership checks
1869                     //most specific ends up comparing abstract methods that might have
1870                     //been implemented by some concrete method in a subclass and,
1871                     //because of raw override, it is possible for an abstract method
1872                     //to be more specific than the concrete method - so we need
1873                     //to explicitly call that out (see CR 6178365)
1874                     bestSoFar = concrete;
1875                 }
1876             }
1877         }
1878         return bestSoFar;
1879     }
1880 
1881     enum InterfaceLookupPhase {
1882         ABSTRACT_OK() {
1883             @Override
1884             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1885                 //We should not look for abstract methods if receiver is a concrete class
1886                 //(as concrete classes are expected to implement all abstracts coming
1887                 //from superinterfaces)
1888                 if ((s.flags() &amp; (ABSTRACT | INTERFACE | ENUM)) != 0) {
1889                     return this;
1890                 } else {
1891                     return DEFAULT_OK;
1892                 }
1893             }
1894         },
1895         DEFAULT_OK() {
1896             @Override
1897             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1898                 return this;
1899             }
1900         };
1901 
1902         abstract InterfaceLookupPhase update(Symbol s, Resolve rs);
1903     }
1904 
1905     /**
1906      * Return an Iterable object to scan the superclasses of a given type.
1907      * It&#39;s crucial that the scan is done lazily, as we don&#39;t want to accidentally
1908      * access more supertypes than strictly needed (as this could trigger completion
1909      * errors if some of the not-needed supertypes are missing/ill-formed).
1910      */
1911     Iterable&lt;TypeSymbol&gt; superclasses(final Type intype) {
1912         return () -&gt; new Iterator&lt;TypeSymbol&gt;() {
1913 
1914             List&lt;TypeSymbol&gt; seen = List.nil();
1915             TypeSymbol currentSym = symbolFor(intype);
1916             TypeSymbol prevSym = null;
1917 
1918             public boolean hasNext() {
1919                 if (currentSym == syms.noSymbol) {
1920                     currentSym = symbolFor(types.supertype(prevSym.type));
1921                 }
1922                 return currentSym != null;
1923             }
1924 
1925             public TypeSymbol next() {
1926                 prevSym = currentSym;
1927                 currentSym = syms.noSymbol;
1928                 Assert.check(prevSym != null || prevSym != syms.noSymbol);
1929                 return prevSym;
1930             }
1931 
1932             public void remove() {
1933                 throw new UnsupportedOperationException();
1934             }
1935 
1936             TypeSymbol symbolFor(Type t) {
1937                 if (!t.hasTag(CLASS) &amp;&amp;
1938                         !t.hasTag(TYPEVAR)) {
1939                     return null;
1940                 }
1941                 t = types.skipTypeVars(t, false);
1942                 if (seen.contains(t.tsym)) {
1943                     //degenerate case in which we have a circular
1944                     //class hierarchy - because of ill-formed classfiles
1945                     return null;
1946                 }
1947                 seen = seen.prepend(t.tsym);
1948                 return t.tsym;
1949             }
1950         };
1951     }
1952 
1953     /** Find unqualified method matching given name, type and value arguments.
1954      *  @param env       The current environment.
1955      *  @param name      The method&#39;s name.
1956      *  @param argtypes  The method&#39;s value arguments.
1957      *  @param typeargtypes  The method&#39;s type arguments.
1958      *  @param allowBoxing Allow boxing conversions of arguments.
1959      *  @param useVarargs Box trailing arguments into an array for varargs.
1960      */
1961     Symbol findFun(Env&lt;AttrContext&gt; env, Name name,
1962                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
1963                    boolean allowBoxing, boolean useVarargs) {
1964         Symbol bestSoFar = methodNotFound;
1965         Env&lt;AttrContext&gt; env1 = env;
1966         boolean staticOnly = false;
1967         while (env1.outer != null) {
1968             if (isStatic(env1)) staticOnly = true;
1969             Assert.check(env1.info.preferredTreeForDiagnostics == null);
1970             env1.info.preferredTreeForDiagnostics = env.tree;
1971             try {
1972                 Symbol sym = findMethod(
1973                     env1, env1.enclClass.sym.type, name, argtypes, typeargtypes,
1974                     allowBoxing, useVarargs);
1975                 if (sym.exists()) {
1976                     if (staticOnly &amp;&amp;
1977                         sym.kind == MTH &amp;&amp;
1978                         sym.owner.kind == TYP &amp;&amp;
1979                         (sym.flags() &amp; STATIC) == 0) return new StaticError(sym);
1980                     else return sym;
1981                 } else {
1982                     bestSoFar = bestOf(bestSoFar, sym);
1983                 }
1984             } finally {
1985                 env1.info.preferredTreeForDiagnostics = null;
1986             }
1987             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1988             env1 = env1.outer;
1989         }
1990 
1991         Symbol sym = findMethod(env, syms.predefClass.type, name, argtypes,
1992                                 typeargtypes, allowBoxing, useVarargs);
1993         if (sym.exists())
1994             return sym;
1995 
1996         for (Symbol currentSym : env.toplevel.namedImportScope.getSymbolsByName(name)) {
1997             Symbol origin = env.toplevel.namedImportScope.getOrigin(currentSym).owner;
1998             if (currentSym.kind == MTH) {
1999                 if (currentSym.owner.type != origin.type)
2000                     currentSym = currentSym.clone(origin);
2001                 if (!isAccessible(env, origin.type, currentSym))
2002                     currentSym = new AccessError(env, origin.type, currentSym);
2003                 bestSoFar = selectBest(env, origin.type,
2004                                        argtypes, typeargtypes,
2005                                        currentSym, bestSoFar,
2006                                        allowBoxing, useVarargs);
2007             }
2008         }
2009         if (bestSoFar.exists())
2010             return bestSoFar;
2011 
2012         for (Symbol currentSym : env.toplevel.starImportScope.getSymbolsByName(name)) {
2013             Symbol origin = env.toplevel.starImportScope.getOrigin(currentSym).owner;
2014             if (currentSym.kind == MTH) {
2015                 if (currentSym.owner.type != origin.type)
2016                     currentSym = currentSym.clone(origin);
2017                 if (!isAccessible(env, origin.type, currentSym))
2018                     currentSym = new AccessError(env, origin.type, currentSym);
2019                 bestSoFar = selectBest(env, origin.type,
2020                                        argtypes, typeargtypes,
2021                                        currentSym, bestSoFar,
2022                                        allowBoxing, useVarargs);
2023             }
2024         }
2025         return bestSoFar;
2026     }
2027 
2028     /** Load toplevel or member class with given fully qualified name and
2029      *  verify that it is accessible.
2030      *  @param env       The current environment.
2031      *  @param name      The fully qualified name of the class to be loaded.
2032      */
2033     Symbol loadClass(Env&lt;AttrContext&gt; env, Name name, RecoveryLoadClass recoveryLoadClass) {
2034         try {
2035             ClassSymbol c = finder.loadClass(env.toplevel.modle, name);
2036             return isAccessible(env, c) ? c : new AccessError(env, null, c);
2037         } catch (ClassFinder.BadClassFile err) {
2038             return new BadClassFileError(err);
2039         } catch (CompletionFailure ex) {
2040             Symbol candidate = recoveryLoadClass.loadClass(env, name);
2041 
2042             if (candidate != null) {
2043                 return candidate;
2044             }
2045 
2046             return typeNotFound;
2047         }
2048     }
2049 
2050     public interface RecoveryLoadClass {
2051         Symbol loadClass(Env&lt;AttrContext&gt; env, Name name);
2052     }
2053 
2054     private final RecoveryLoadClass noRecovery = (env, name) -&gt; null;
2055 
2056     private final RecoveryLoadClass doRecoveryLoadClass = new RecoveryLoadClass() {
2057         @Override public Symbol loadClass(Env&lt;AttrContext&gt; env, Name name) {
2058             List&lt;Name&gt; candidates = Convert.classCandidates(name);
2059             return lookupInvisibleSymbol(env, name,
2060                                          n -&gt; () -&gt; createCompoundIterator(candidates,
2061                                                                            c -&gt; syms.getClassesForName(c)
2062                                                                                     .iterator()),
2063                                          (ms, n) -&gt; {
2064                 for (Name candidate : candidates) {
2065                     try {
2066                         return finder.loadClass(ms, candidate);
2067                     } catch (CompletionFailure cf) {
2068                         //ignore
2069                     }
2070                 }
2071                 return null;
2072             }, sym -&gt; sym.kind == Kind.TYP, typeNotFound);
2073         }
2074     };
2075 
2076     private final RecoveryLoadClass namedImportScopeRecovery = (env, name) -&gt; {
2077         Scope importScope = env.toplevel.namedImportScope;
2078         Symbol existing = importScope.findFirst(Convert.shortName(name),
2079                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2080 
2081         if (existing != null) {
2082             return new InvisibleSymbolError(env, true, existing);
2083         }
2084         return null;
2085     };
2086 
2087     private final RecoveryLoadClass starImportScopeRecovery = (env, name) -&gt; {
2088         Scope importScope = env.toplevel.starImportScope;
2089         Symbol existing = importScope.findFirst(Convert.shortName(name),
2090                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2091 
2092         if (existing != null) {
2093             try {
2094                 existing = finder.loadClass(existing.packge().modle, name);
2095 
2096                 return new InvisibleSymbolError(env, true, existing);
2097             } catch (CompletionFailure cf) {
2098                 //ignore
2099             }
2100         }
2101 
2102         return null;
2103     };
2104 
2105     Symbol lookupPackage(Env&lt;AttrContext&gt; env, Name name) {
2106         PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, name);
2107 
2108         if (allowModules &amp;&amp; isImportOnDemand(env, name)) {
2109             if (pack.members().isEmpty()) {
2110                 return lookupInvisibleSymbol(env, name, syms::getPackagesForName, syms::enterPackage, sym -&gt; {
2111                     sym.complete();
2112                     return !sym.members().isEmpty();
2113                 }, pack);
2114             }
2115         }
2116 
2117         return pack;
2118     }
2119 
2120     private boolean isImportOnDemand(Env&lt;AttrContext&gt; env, Name name) {
2121         if (!env.tree.hasTag(IMPORT))
2122             return false;
2123 
2124         JCTree qualid = ((JCImport) env.tree).qualid;
2125 
2126         if (!qualid.hasTag(SELECT))
2127             return false;
2128 
2129         if (TreeInfo.name(qualid) != names.asterisk)
2130             return false;
2131 
2132         return TreeInfo.fullName(((JCFieldAccess) qualid).selected) == name;
2133     }
2134 
2135     private &lt;S extends Symbol&gt; Symbol lookupInvisibleSymbol(Env&lt;AttrContext&gt; env,
2136                                                             Name name,
2137                                                             Function&lt;Name, Iterable&lt;S&gt;&gt; get,
2138                                                             BiFunction&lt;ModuleSymbol, Name, S&gt; load,
2139                                                             Predicate&lt;S&gt; validate,
2140                                                             Symbol defaultResult) {
2141         //even if a class/package cannot be found in the current module and among packages in modules
2142         //it depends on that are exported for any or this module, the class/package may exist internally
2143         //in some of these modules, or may exist in a module on which this module does not depend.
2144         //Provide better diagnostic in such cases by looking for the class in any module:
2145         Iterable&lt;? extends S&gt; candidates = get.apply(name);
2146 
2147         for (S sym : candidates) {
2148             if (validate.test(sym))
2149                 return createInvisibleSymbolError(env, sym);
2150         }
2151 
2152         Set&lt;ModuleSymbol&gt; recoverableModules = new HashSet&lt;&gt;(syms.getAllModules());
2153 
2154         recoverableModules.add(syms.unnamedModule);
2155         recoverableModules.remove(env.toplevel.modle);
2156 
2157         for (ModuleSymbol ms : recoverableModules) {
2158             //avoid overly eager completing classes from source-based modules, as those
2159             //may not be completable with the current compiler settings:
2160             if (ms.sourceLocation == null) {
2161                 if (ms.classLocation == null) {
2162                     ms = moduleFinder.findModule(ms);
2163                 }
2164 
2165                 if (ms.kind != ERR) {
2166                     S sym = load.apply(ms, name);
2167 
2168                     if (sym != null &amp;&amp; validate.test(sym)) {
2169                         return createInvisibleSymbolError(env, sym);
2170                     }
2171                 }
2172             }
2173         }
2174 
2175         return defaultResult;
2176     }
2177 
2178     private Symbol createInvisibleSymbolError(Env&lt;AttrContext&gt; env, Symbol sym) {
2179         if (symbolPackageVisible(env, sym)) {
2180             return new AccessError(env, null, sym);
2181         } else {
2182             return new InvisibleSymbolError(env, false, sym);
2183         }
2184     }
2185 
2186     private boolean symbolPackageVisible(Env&lt;AttrContext&gt; env, Symbol sym) {
2187         ModuleSymbol envMod = env.toplevel.modle;
2188         PackageSymbol symPack = sym.packge();
2189         return envMod == symPack.modle ||
2190                envMod.visiblePackages.containsKey(symPack.fullname);
2191     }
2192 
2193     /**
2194      * Find a type declared in a scope (not inherited).  Return null
2195      * if none is found.
2196      *  @param env       The current environment.
2197      *  @param site      The original type from where the selection takes
2198      *                   place.
2199      *  @param name      The type&#39;s name.
2200      *  @param c         The class to search for the member type. This is
2201      *                   always a superclass or implemented interface of
2202      *                   site&#39;s class.
2203      */
2204     Symbol findImmediateMemberType(Env&lt;AttrContext&gt; env,
2205                                    Type site,
2206                                    Name name,
2207                                    TypeSymbol c) {
<a name="2" id="anc2"></a><span class="line-added">2208         // ATM, inner/nested types are members of only the declaring inline class,</span>
<span class="line-added">2209         // although accessible via the reference projection.</span>
<span class="line-added">2210         if (c.isReferenceProjection())</span>
<span class="line-added">2211             c = (TypeSymbol) c.valueProjection();</span>
2212         for (Symbol sym : c.members().getSymbolsByName(name)) {
2213             if (sym.kind == TYP) {
2214                 return isAccessible(env, site, sym)
2215                     ? sym
2216                     : new AccessError(env, site, sym);
2217             }
2218         }
2219         return typeNotFound;
2220     }
2221 
2222     /** Find a member type inherited from a superclass or interface.
2223      *  @param env       The current environment.
2224      *  @param site      The original type from where the selection takes
2225      *                   place.
2226      *  @param name      The type&#39;s name.
2227      *  @param c         The class to search for the member type. This is
2228      *                   always a superclass or implemented interface of
2229      *                   site&#39;s class.
2230      */
2231     Symbol findInheritedMemberType(Env&lt;AttrContext&gt; env,
2232                                    Type site,
2233                                    Name name,
2234                                    TypeSymbol c) {
2235         Symbol bestSoFar = typeNotFound;
2236         Symbol sym;
2237         Type st = types.supertype(c.type);
2238         if (st != null &amp;&amp; st.hasTag(CLASS)) {
2239             sym = findMemberType(env, site, name, st.tsym);
2240             bestSoFar = bestOf(bestSoFar, sym);
2241         }
2242         for (List&lt;Type&gt; l = types.interfaces(c.type);
2243              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
2244              l = l.tail) {
2245             sym = findMemberType(env, site, name, l.head.tsym);
2246             if (!bestSoFar.kind.isResolutionError() &amp;&amp;
2247                 !sym.kind.isResolutionError() &amp;&amp;
2248                 sym.owner != bestSoFar.owner)
2249                 bestSoFar = new AmbiguityError(bestSoFar, sym);
2250             else
2251                 bestSoFar = bestOf(bestSoFar, sym);
2252         }
2253         return bestSoFar;
2254     }
2255 
2256     /** Find qualified member type.
2257      *  @param env       The current environment.
2258      *  @param site      The original type from where the selection takes
2259      *                   place.
2260      *  @param name      The type&#39;s name.
2261      *  @param c         The class to search for the member type. This is
2262      *                   always a superclass or implemented interface of
2263      *                   site&#39;s class.
2264      */
2265     Symbol findMemberType(Env&lt;AttrContext&gt; env,
2266                           Type site,
2267                           Name name,
2268                           TypeSymbol c) {
2269         return findMemberTypeInternal(env,site, name, c);
2270     }
2271 
2272     /** Find qualified member type.
2273      *  @param env       The current environment.
2274      *  @param site      The original type from where the selection takes
2275      *                   place.
2276      *  @param name      The type&#39;s name.
2277      *  @param c         The class to search for the member type. This is
2278      *                   always a superclass or implemented interface of
2279      *                   site&#39;s class.
2280      */
2281     Symbol findMemberTypeInternal(Env&lt;AttrContext&gt; env,
2282                           Type site,
2283                           Name name,
2284                           TypeSymbol c) {
2285         Symbol sym = findImmediateMemberType(env, site, name, c);
2286 
2287         if (sym != typeNotFound)
2288             return sym;
2289 
2290         return findInheritedMemberType(env, site, name, c);
2291 
2292     }
2293 
2294     /** Find a global type in given scope and load corresponding class.
2295      *  @param env       The current environment.
2296      *  @param scope     The scope in which to look for the type.
2297      *  @param name      The type&#39;s name.
2298      */
2299     Symbol findGlobalType(Env&lt;AttrContext&gt; env, Scope scope, Name name, RecoveryLoadClass recoveryLoadClass) {
2300         Symbol bestSoFar = typeNotFound;
2301         for (Symbol s : scope.getSymbolsByName(name)) {
2302             Symbol sym = loadClass(env, s.flatName(), recoveryLoadClass);
2303             if (bestSoFar.kind == TYP &amp;&amp; sym.kind == TYP &amp;&amp;
2304                 bestSoFar != sym)
2305                 return new AmbiguityError(bestSoFar, sym);
2306             else
2307                 bestSoFar = bestOf(bestSoFar, sym);
2308         }
2309         return bestSoFar;
2310     }
2311 
2312     Symbol findTypeVar(Env&lt;AttrContext&gt; env, Name name, boolean staticOnly) {
2313         for (Symbol sym : env.info.scope.getSymbolsByName(name)) {
2314             if (sym.kind == TYP) {
2315                 if (staticOnly &amp;&amp;
2316                     sym.type.hasTag(TYPEVAR) &amp;&amp;
2317                     sym.owner.kind == TYP)
2318                     return new StaticError(sym);
2319                 return sym;
2320             }
2321         }
2322         return typeNotFound;
2323     }
2324 
2325     /** Find an unqualified type symbol.
2326      *  @param env       The current environment.
2327      *  @param name      The type&#39;s name.
2328      */
2329     Symbol findType(Env&lt;AttrContext&gt; env, Name name) {
2330         return findTypeInternal(env, name);
2331     }
2332 
2333     /** Find an unqualified type symbol.
2334      *  @param env       The current environment.
2335      *  @param name      The type&#39;s name.
2336      */
2337     Symbol findTypeInternal(Env&lt;AttrContext&gt; env, Name name) {
2338         if (name == names.empty)
2339             return typeNotFound; // do not allow inadvertent &quot;lookup&quot; of anonymous types
2340         Symbol bestSoFar = typeNotFound;
2341         Symbol sym;
2342         boolean staticOnly = false;
2343         for (Env&lt;AttrContext&gt; env1 = env; env1.outer != null; env1 = env1.outer) {
2344             if (isStatic(env1)) staticOnly = true;
2345             // First, look for a type variable and the first member type
2346             final Symbol tyvar = findTypeVar(env1, name, staticOnly);
2347             sym = findImmediateMemberType(env1, env1.enclClass.sym.type,
2348                                           name, env1.enclClass.sym);
2349 
2350             // Return the type variable if we have it, and have no
2351             // immediate member, OR the type variable is for a method.
2352             if (tyvar != typeNotFound) {
2353                 if (env.baseClause || sym == typeNotFound ||
2354                     (tyvar.kind == TYP &amp;&amp; tyvar.exists() &amp;&amp;
2355                      tyvar.owner.kind == MTH)) {
2356                     return tyvar;
2357                 }
2358             }
2359 
2360             // If the environment is a class def, finish up,
2361             // otherwise, do the entire findMemberType
2362             if (sym == typeNotFound)
2363                 sym = findInheritedMemberType(env1, env1.enclClass.sym.type,
2364                                               name, env1.enclClass.sym);
2365 
2366             if (staticOnly &amp;&amp; sym.kind == TYP &amp;&amp;
2367                 sym.type.hasTag(CLASS) &amp;&amp;
2368                 sym.type.getEnclosingType().hasTag(CLASS) &amp;&amp;
2369                 env1.enclClass.sym.type.isParameterized() &amp;&amp;
2370                 sym.type.getEnclosingType().isParameterized())
2371                 return new StaticError(sym);
2372             else if (sym.exists()) return sym;
2373             else bestSoFar = bestOf(bestSoFar, sym);
2374 
2375             JCClassDecl encl = env1.baseClause ? (JCClassDecl)env1.tree : env1.enclClass;
2376             if ((encl.sym.flags() &amp; STATIC) != 0)
2377                 staticOnly = true;
2378         }
2379 
2380         if (!env.tree.hasTag(IMPORT)) {
2381             sym = findGlobalType(env, env.toplevel.namedImportScope, name, namedImportScopeRecovery);
2382             if (sym.exists()) return sym;
2383             else bestSoFar = bestOf(bestSoFar, sym);
2384 
2385             sym = findGlobalType(env, env.toplevel.toplevelScope, name, noRecovery);
2386             if (sym.exists()) return sym;
2387             else bestSoFar = bestOf(bestSoFar, sym);
2388 
2389             sym = findGlobalType(env, env.toplevel.packge.members(), name, noRecovery);
2390             if (sym.exists()) return sym;
2391             else bestSoFar = bestOf(bestSoFar, sym);
2392 
2393             sym = findGlobalType(env, env.toplevel.starImportScope, name, starImportScopeRecovery);
2394             if (sym.exists()) return sym;
2395             else bestSoFar = bestOf(bestSoFar, sym);
2396         }
2397 
2398         return bestSoFar;
2399     }
2400 
2401     /** Find an unqualified identifier which matches a specified kind set.
2402      *  @param pos       position on which report warnings, if any;
2403      *                   null warnings should not be reported
2404      *  @param env       The current environment.
2405      *  @param name      The identifier&#39;s name.
2406      *  @param kind      Indicates the possible symbol kinds
2407      *                   (a subset of VAL, TYP, PCK).
2408      */
2409     Symbol findIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2410         return checkRestrictedType(pos, findIdentInternal(env, name, kind), name);
2411     }
2412 
2413     Symbol findIdentInternal(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2414         Symbol bestSoFar = typeNotFound;
2415         Symbol sym;
2416 
2417         if (kind.contains(KindSelector.VAL)) {
2418             sym = findVar(env, name);
2419             if (sym.exists()) return sym;
2420             else bestSoFar = bestOf(bestSoFar, sym);
2421         }
2422 
2423         if (kind.contains(KindSelector.TYP)) {
2424             sym = findType(env, name);
2425 
2426             if (sym.exists()) return sym;
2427             else bestSoFar = bestOf(bestSoFar, sym);
2428         }
2429 
2430         if (kind.contains(KindSelector.PCK))
2431             return lookupPackage(env, name);
2432         else return bestSoFar;
2433     }
2434 
2435     /** Find an identifier in a package which matches a specified kind set.
2436      *  @param pos       position on which report warnings, if any;
2437      *                   null warnings should not be reported
2438      *  @param env       The current environment.
2439      *  @param name      The identifier&#39;s name.
2440      *  @param kind      Indicates the possible symbol kinds
2441      *                   (a nonempty subset of TYP, PCK).
2442      */
2443     Symbol findIdentInPackage(DiagnosticPosition pos,
2444                               Env&lt;AttrContext&gt; env, TypeSymbol pck,
2445                               Name name, KindSelector kind) {
2446         return checkRestrictedType(pos, findIdentInPackageInternal(env, pck, name, kind), name);
2447     }
2448 
2449     Symbol findIdentInPackageInternal(Env&lt;AttrContext&gt; env, TypeSymbol pck,
2450                               Name name, KindSelector kind) {
2451         Name fullname = TypeSymbol.formFullName(name, pck);
2452         Symbol bestSoFar = typeNotFound;
2453         if (kind.contains(KindSelector.TYP)) {
2454             RecoveryLoadClass recoveryLoadClass =
2455                     allowModules &amp;&amp; !kind.contains(KindSelector.PCK) &amp;&amp;
2456                     !pck.exists() &amp;&amp; !env.info.attributionMode.isSpeculative ?
2457                         doRecoveryLoadClass : noRecovery;
2458             Symbol sym = loadClass(env, fullname, recoveryLoadClass);
2459             if (sym.exists()) {
2460                 // don&#39;t allow programs to use flatnames
2461                 if (name == sym.name) return sym;
2462             }
2463             else bestSoFar = bestOf(bestSoFar, sym);
2464         }
2465         if (kind.contains(KindSelector.PCK)) {
2466             return lookupPackage(env, fullname);
2467         }
2468         return bestSoFar;
2469     }
2470 
2471     /** Find an identifier among the members of a given type `site&#39;.
2472      *  @param pos       position on which report warnings, if any;
2473      *                   null warnings should not be reported
2474      *  @param env       The current environment.
2475      *  @param site      The type containing the symbol to be found.
2476      *  @param name      The identifier&#39;s name.
2477      *  @param kind      Indicates the possible symbol kinds
2478      *                   (a subset of VAL, TYP).
2479      */
2480     Symbol findIdentInType(DiagnosticPosition pos,
2481                            Env&lt;AttrContext&gt; env, Type site,
2482                            Name name, KindSelector kind) {
2483         return checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name);
2484     }
2485 
2486     Symbol findIdentInTypeInternal(Env&lt;AttrContext&gt; env, Type site,
2487                            Name name, KindSelector kind) {
2488         Symbol bestSoFar = typeNotFound;
2489         Symbol sym;
2490         if (kind.contains(KindSelector.VAL)) {
2491             sym = findField(env, site, name, site.tsym);
2492             if (sym.exists()) return sym;
2493             else bestSoFar = bestOf(bestSoFar, sym);
2494         }
2495 
2496         if (kind.contains(KindSelector.TYP)) {
2497             sym = findMemberType(env, site, name, site.tsym);
2498             if (sym.exists()) return sym;
2499             else bestSoFar = bestOf(bestSoFar, sym);
2500         }
2501         return bestSoFar;
2502     }
2503 
2504     private Symbol checkRestrictedType(DiagnosticPosition pos, Symbol bestSoFar, Name name) {
2505         if (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP) {
2506             if (allowLocalVariableTypeInference &amp;&amp; name.equals(names.var)) {
2507                 bestSoFar = new BadRestrictedTypeError(names.var);
2508             } else if (name.equals(names.yield)) {
2509                 if (allowYieldStatement) {
2510                     bestSoFar = new BadRestrictedTypeError(names.yield);
2511                 } else if (pos != null) {
2512                     log.warning(pos, Warnings.IllegalRefToRestrictedType(names.yield));
2513                 }
2514             }
2515         }
2516         return bestSoFar;
2517     }
2518 
2519 /* ***************************************************************************
2520  *  Access checking
2521  *  The following methods convert ResolveErrors to ErrorSymbols, issuing
2522  *  an error message in the process
2523  ****************************************************************************/
2524 
2525     /** If `sym&#39; is a bad symbol: report error and return errSymbol
2526      *  else pass through unchanged,
2527      *  additional arguments duplicate what has been used in trying to find the
2528      *  symbol {@literal (--&gt; flyweight pattern)}. This improves performance since we
2529      *  expect misses to happen frequently.
2530      *
2531      *  @param sym       The symbol that was found, or a ResolveError.
2532      *  @param pos       The position to use for error reporting.
2533      *  @param location  The symbol the served as a context for this lookup
2534      *  @param site      The original type from where the selection took place.
2535      *  @param name      The symbol&#39;s name.
2536      *  @param qualified Did we get here through a qualified expression resolution?
2537      *  @param argtypes  The invocation&#39;s value arguments,
2538      *                   if we looked for a method.
2539      *  @param typeargtypes  The invocation&#39;s type arguments,
2540      *                   if we looked for a method.
2541      *  @param logResolveHelper helper class used to log resolve errors
2542      */
2543     Symbol accessInternal(Symbol sym,
2544                   DiagnosticPosition pos,
2545                   Symbol location,
2546                   Type site,
2547                   Name name,
2548                   boolean qualified,
2549                   List&lt;Type&gt; argtypes,
2550                   List&lt;Type&gt; typeargtypes,
2551                   LogResolveHelper logResolveHelper) {
2552         if (sym.kind.isResolutionError()) {
2553             ResolveError errSym = (ResolveError)sym.baseSymbol();
2554             sym = errSym.access(name, qualified ? site.tsym : syms.noSymbol);
2555             argtypes = logResolveHelper.getArgumentTypes(errSym, sym, name, argtypes);
2556             if (logResolveHelper.resolveDiagnosticNeeded(site, argtypes, typeargtypes)) {
2557                 logResolveError(errSym, pos, location, site, name, argtypes, typeargtypes);
2558             }
2559         }
2560         return sym;
2561     }
2562 
2563     /**
2564      * Variant of the generalized access routine, to be used for generating method
2565      * resolution diagnostics
2566      */
2567     Symbol accessMethod(Symbol sym,
2568                   DiagnosticPosition pos,
2569                   Symbol location,
2570                   Type site,
2571                   Name name,
2572                   boolean qualified,
2573                   List&lt;Type&gt; argtypes,
2574                   List&lt;Type&gt; typeargtypes) {
2575         return accessInternal(sym, pos, location, site, name, qualified, argtypes, typeargtypes, methodLogResolveHelper);
2576     }
2577 
2578     /** Same as original accessMethod(), but without location.
2579      */
2580     Symbol accessMethod(Symbol sym,
2581                   DiagnosticPosition pos,
2582                   Type site,
2583                   Name name,
2584                   boolean qualified,
2585                   List&lt;Type&gt; argtypes,
2586                   List&lt;Type&gt; typeargtypes) {
2587         return accessMethod(sym, pos, site.tsym, site, name, qualified, argtypes, typeargtypes);
2588     }
2589 
2590     /**
2591      * Variant of the generalized access routine, to be used for generating variable,
2592      * type resolution diagnostics
2593      */
2594     Symbol accessBase(Symbol sym,
2595                   DiagnosticPosition pos,
2596                   Symbol location,
2597                   Type site,
2598                   Name name,
2599                   boolean qualified) {
2600         return accessInternal(sym, pos, location, site, name, qualified, List.nil(), null, basicLogResolveHelper);
2601     }
2602 
2603     /** Same as original accessBase(), but without location.
2604      */
2605     Symbol accessBase(Symbol sym,
2606                   DiagnosticPosition pos,
2607                   Type site,
2608                   Name name,
2609                   boolean qualified) {
2610         return accessBase(sym, pos, site.tsym, site, name, qualified);
2611     }
2612 
2613     interface LogResolveHelper {
2614         boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes);
2615         List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes);
2616     }
2617 
2618     LogResolveHelper basicLogResolveHelper = new LogResolveHelper() {
2619         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2620             return !site.isErroneous();
2621         }
2622         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2623             return argtypes;
2624         }
2625     };
2626 
2627     LogResolveHelper methodLogResolveHelper = new LogResolveHelper() {
2628         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2629             return !site.isErroneous() &amp;&amp;
2630                         !Type.isErroneous(argtypes) &amp;&amp;
2631                         (typeargtypes == null || !Type.isErroneous(typeargtypes));
2632         }
2633         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2634             return argtypes.map(new ResolveDeferredRecoveryMap(AttrMode.SPECULATIVE, accessedSym, currentResolutionContext.step));
2635         }
2636     };
2637 
2638     class ResolveDeferredRecoveryMap extends DeferredAttr.RecoveryDeferredTypeMap {
2639 
2640         public ResolveDeferredRecoveryMap(AttrMode mode, Symbol msym, MethodResolutionPhase step) {
2641             deferredAttr.super(mode, msym, step);
2642         }
2643 
2644         @Override
2645         protected Type typeOf(DeferredType dt, Type pt) {
2646             Type res = super.typeOf(dt, pt);
2647             if (!res.isErroneous()) {
2648                 switch (TreeInfo.skipParens(dt.tree).getTag()) {
2649                     case LAMBDA:
2650                     case REFERENCE:
2651                         return dt;
2652                     case CONDEXPR:
2653                         return res == Type.recoveryType ?
2654                                 dt : res;
2655                 }
2656             }
2657             return res;
2658         }
2659     }
2660 
2661     /** Check that sym is not an abstract method.
2662      */
2663     void checkNonAbstract(DiagnosticPosition pos, Symbol sym) {
2664         if ((sym.flags() &amp; ABSTRACT) != 0 &amp;&amp; (sym.flags() &amp; DEFAULT) == 0)
2665             log.error(pos,
2666                       Errors.AbstractCantBeAccessedDirectly(kindName(sym),sym, sym.location()));
2667     }
2668 
2669 /* ***************************************************************************
2670  *  Name resolution
2671  *  Naming conventions are as for symbol lookup
2672  *  Unlike the find... methods these methods will report access errors
2673  ****************************************************************************/
2674 
2675     /** Resolve an unqualified (non-method) identifier.
2676      *  @param pos       The position to use for error reporting.
2677      *  @param env       The environment current at the identifier use.
2678      *  @param name      The identifier&#39;s name.
2679      *  @param kind      The set of admissible symbol kinds for the identifier.
2680      */
2681     Symbol resolveIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2682                         Name name, KindSelector kind) {
2683         return accessBase(
2684             findIdent(pos, env, name, kind),
2685             pos, env.enclClass.sym.type, name, false);
2686     }
2687 
2688     /** Resolve an unqualified method identifier.
2689      *  @param pos       The position to use for error reporting.
2690      *  @param env       The environment current at the method invocation.
2691      *  @param name      The identifier&#39;s name.
2692      *  @param argtypes  The types of the invocation&#39;s value arguments.
2693      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2694      */
2695     Symbol resolveMethod(DiagnosticPosition pos,
2696                          Env&lt;AttrContext&gt; env,
2697                          Name name,
2698                          List&lt;Type&gt; argtypes,
2699                          List&lt;Type&gt; typeargtypes) {
2700         return lookupMethod(env, pos, env.enclClass.sym, resolveMethodCheck,
2701                 new BasicLookupHelper(name, env.enclClass.sym.type, argtypes, typeargtypes) {
2702                     @Override
2703                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2704                         return findFun(env, name, argtypes, typeargtypes,
2705                                 phase.isBoxingRequired(),
2706                                 phase.isVarargsRequired());
2707                     }});
2708     }
2709 
2710     /** Resolve a qualified method identifier
2711      *  @param pos       The position to use for error reporting.
2712      *  @param env       The environment current at the method invocation.
2713      *  @param site      The type of the qualifying expression, in which
2714      *                   identifier is searched.
2715      *  @param name      The identifier&#39;s name.
2716      *  @param argtypes  The types of the invocation&#39;s value arguments.
2717      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2718      */
2719     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2720                                   Type site, Name name, List&lt;Type&gt; argtypes,
2721                                   List&lt;Type&gt; typeargtypes) {
2722         return resolveQualifiedMethod(pos, env, site.tsym, site, name, argtypes, typeargtypes);
2723     }
2724     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2725                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2726                                   List&lt;Type&gt; typeargtypes) {
2727         return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);
2728     }
2729     private Symbol resolveQualifiedMethod(MethodResolutionContext resolveContext,
2730                                   DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2731                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2732                                   List&lt;Type&gt; typeargtypes) {
2733         return lookupMethod(env, pos, location, resolveContext, new BasicLookupHelper(name, site, argtypes, typeargtypes) {
2734             @Override
2735             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2736                 return findMethod(env, site, name, argtypes, typeargtypes,
2737                         phase.isBoxingRequired(),
2738                         phase.isVarargsRequired());
2739             }
2740             @Override
2741             Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2742                 if (sym.kind.isResolutionError()) {
2743                     sym = super.access(env, pos, location, sym);
2744                 } else {
2745                     MethodSymbol msym = (MethodSymbol)sym;
2746                     if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
2747                         env.info.pendingResolutionPhase = BASIC;
2748                         return findPolymorphicSignatureInstance(env, sym, argtypes);
2749                     }
2750                 }
2751                 return sym;
2752             }
2753         });
2754     }
2755 
2756     /** Find or create an implicit method of exactly the given type (after erasure).
2757      *  Searches in a side table, not the main scope of the site.
2758      *  This emulates the lookup process required by JSR 292 in JVM.
2759      *  @param env       Attribution environment
2760      *  @param spMethod  signature polymorphic method - i.e. MH.invokeExact
2761      *  @param argtypes  The required argument types
2762      */
2763     Symbol findPolymorphicSignatureInstance(Env&lt;AttrContext&gt; env,
2764                                             final Symbol spMethod,
2765                                             List&lt;Type&gt; argtypes) {
2766         Type mtype = infer.instantiatePolymorphicSignatureInstance(env,
2767                 (MethodSymbol)spMethod, currentResolutionContext, argtypes);
2768         return findPolymorphicSignatureInstance(spMethod, mtype);
2769     }
2770 
2771     Symbol findPolymorphicSignatureInstance(final Symbol spMethod,
2772                                             Type mtype) {
2773         for (Symbol sym : polymorphicSignatureScope.getSymbolsByName(spMethod.name)) {
2774             // Check that there is already a method symbol for the method
2775             // type and owner
2776             if (types.isSameType(mtype, sym.type) &amp;&amp;
2777                 spMethod.owner == sym.owner) {
2778                 return sym;
2779             }
2780         }
2781 
2782         // Create the desired method
2783         // Retain static modifier is to support invocations to
2784         // MethodHandle.linkTo* methods
2785         long flags = ABSTRACT | HYPOTHETICAL |
2786                      spMethod.flags() &amp; (Flags.AccessFlags | Flags.STATIC);
2787         Symbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner) {
2788             @Override
2789             public Symbol baseSymbol() {
2790                 return spMethod;
2791             }
2792         };
2793         if (!mtype.isErroneous()) { // Cache only if kosher.
2794             polymorphicSignatureScope.enter(msym);
2795         }
2796         return msym;
2797     }
2798 
2799     /** Resolve a qualified method identifier, throw a fatal error if not
2800      *  found.
2801      *  @param pos       The position to use for error reporting.
2802      *  @param env       The environment current at the method invocation.
2803      *  @param site      The type of the qualifying expression, in which
2804      *                   identifier is searched.
2805      *  @param name      The identifier&#39;s name.
2806      *  @param argtypes  The types of the invocation&#39;s value arguments.
2807      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2808      */
2809     public MethodSymbol resolveInternalMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2810                                         Type site, Name name,
2811                                         List&lt;Type&gt; argtypes,
2812                                         List&lt;Type&gt; typeargtypes) {
2813         MethodResolutionContext resolveContext = new MethodResolutionContext();
2814         resolveContext.internalResolution = true;
2815         Symbol sym = resolveQualifiedMethod(resolveContext, pos, env, site.tsym,
2816                 site, name, argtypes, typeargtypes);
2817         if (sym.kind == MTH) return (MethodSymbol)sym;
2818         else throw new FatalError(
2819                  diags.fragment(Fragments.FatalErrCantLocateMeth(name)));
2820     }
2821 
2822     /** Resolve constructor.
2823      *  @param pos       The position to use for error reporting.
2824      *  @param env       The environment current at the constructor invocation.
2825      *  @param site      The type of class for which a constructor is searched.
2826      *  @param argtypes  The types of the constructor invocation&#39;s value
2827      *                   arguments.
2828      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2829      *                   arguments.
2830      */
2831     Symbol resolveConstructor(DiagnosticPosition pos,
2832                               Env&lt;AttrContext&gt; env,
2833                               Type site,
2834                               List&lt;Type&gt; argtypes,
2835                               List&lt;Type&gt; typeargtypes) {
2836         return resolveConstructor(new MethodResolutionContext(), pos, env, site, argtypes, typeargtypes);
2837     }
2838 
2839     private Symbol resolveConstructor(MethodResolutionContext resolveContext,
2840                               final DiagnosticPosition pos,
2841                               Env&lt;AttrContext&gt; env,
2842                               Type site,
2843                               List&lt;Type&gt; argtypes,
2844                               List&lt;Type&gt; typeargtypes) {
2845         return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2846             @Override
2847             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2848                 return findConstructor(pos, env, site, argtypes, typeargtypes,
2849                         phase.isBoxingRequired(),
2850                         phase.isVarargsRequired());
2851             }
2852         });
2853     }
2854 
2855     /** Resolve a constructor, throw a fatal error if not found.
2856      *  @param pos       The position to use for error reporting.
2857      *  @param env       The environment current at the method invocation.
2858      *  @param site      The type to be constructed.
2859      *  @param argtypes  The types of the invocation&#39;s value arguments.
2860      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2861      */
2862     public MethodSymbol resolveInternalConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2863                                         Type site,
2864                                         List&lt;Type&gt; argtypes,
2865                                         List&lt;Type&gt; typeargtypes) {
2866         MethodResolutionContext resolveContext = new MethodResolutionContext();
2867         resolveContext.internalResolution = true;
2868         Symbol sym = resolveConstructor(resolveContext, pos, env, site, argtypes, typeargtypes);
2869         if (sym.kind == MTH) return (MethodSymbol)sym;
2870         else throw new FatalError(
2871                  diags.fragment(Fragments.FatalErrCantLocateCtor(site)));
2872     }
2873 
2874     Symbol findConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2875                               Type site, List&lt;Type&gt; argtypes,
2876                               List&lt;Type&gt; typeargtypes,
2877                               boolean allowBoxing,
2878                               boolean useVarargs) {
2879         Symbol sym = findMethod(env, site,
2880                                     names.init, argtypes,
2881                                     typeargtypes, allowBoxing,
2882                                     useVarargs);
2883         chk.checkDeprecated(pos, env.info.scope.owner, sym);
2884         chk.checkPreview(pos, sym);
2885         return sym;
2886     }
2887 
2888     /** Resolve constructor using diamond inference.
2889      *  @param pos       The position to use for error reporting.
2890      *  @param env       The environment current at the constructor invocation.
2891      *  @param site      The type of class for which a constructor is searched.
2892      *                   The scope of this class has been touched in attribution.
2893      *  @param argtypes  The types of the constructor invocation&#39;s value
2894      *                   arguments.
2895      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2896      *                   arguments.
2897      */
2898     Symbol resolveDiamond(DiagnosticPosition pos,
2899                               Env&lt;AttrContext&gt; env,
2900                               Type site,
2901                               List&lt;Type&gt; argtypes,
2902                               List&lt;Type&gt; typeargtypes) {
2903         return lookupMethod(env, pos, site.tsym, resolveMethodCheck,
2904                 new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2905                     @Override
2906                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2907                         return findDiamond(env, site, argtypes, typeargtypes,
2908                                 phase.isBoxingRequired(),
2909                                 phase.isVarargsRequired());
2910                     }
2911                     @Override
2912                     Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2913                         if (sym.kind.isResolutionError()) {
2914                             if (sym.kind != WRONG_MTH &amp;&amp;
2915                                 sym.kind != WRONG_MTHS) {
2916                                 sym = super.access(env, pos, location, sym);
2917                             } else {
2918                                 final JCDiagnostic details = sym.kind == WRONG_MTH ?
2919                                                 ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
2920                                                 null;
2921                                 sym = new DiamondError(sym, currentResolutionContext);
2922                                 sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);
2923                                 env.info.pendingResolutionPhase = currentResolutionContext.step;
2924                             }
2925                         }
2926                         return sym;
2927                     }});
2928     }
2929 
2930     /** This method scans all the constructor symbol in a given class scope -
2931      *  assuming that the original scope contains a constructor of the kind:
2932      *  {@code Foo(X x, Y y)}, where X,Y are class type-variables declared in Foo,
2933      *  a method check is executed against the modified constructor type:
2934      *  {@code &lt;X,Y&gt;Foo&lt;X,Y&gt;(X x, Y y)}. This is crucial in order to enable diamond
2935      *  inference. The inferred return type of the synthetic constructor IS
2936      *  the inferred type for the diamond operator.
2937      */
2938     private Symbol findDiamond(Env&lt;AttrContext&gt; env,
2939                               Type site,
2940                               List&lt;Type&gt; argtypes,
2941                               List&lt;Type&gt; typeargtypes,
2942                               boolean allowBoxing,
2943                               boolean useVarargs) {
2944         Symbol bestSoFar = methodNotFound;
2945         TypeSymbol tsym = site.tsym.isInterface() ? syms.objectType.tsym : site.tsym;
2946         for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {
2947             //- System.out.println(&quot; e &quot; + e.sym);
2948             if (sym.kind == MTH &amp;&amp;
2949                 (sym.flags_field &amp; SYNTHETIC) == 0) {
2950                     List&lt;Type&gt; oldParams = sym.type.hasTag(FORALL) ?
2951                             ((ForAll)sym.type).tvars :
2952                             List.nil();
2953                     Type constrType = new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),
2954                                                  types.createMethodTypeWithReturn(sym.type.asMethodType(), site));
2955                     MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {
2956                         @Override
2957                         public Symbol baseSymbol() {
2958                             return sym;
2959                         }
2960                     };
2961                     ClassSymbol refProjection = newConstr.owner.isValue() ?
2962                                                      (ClassSymbol) newConstr.owner.referenceProjection() : null;
2963                     if (refProjection != null) {
2964                         MethodSymbol clone = newConstr.clone(refProjection);
2965                         clone.projection = newConstr;
2966                         newConstr.projection = clone;
2967                     }
2968                     bestSoFar = selectBest(env, site, argtypes, typeargtypes,
2969                             newConstr,
2970                             bestSoFar,
2971                             allowBoxing,
2972                             useVarargs);
2973             }
2974         }
2975         return bestSoFar;
2976     }
2977 
2978     Symbol getMemberReference(DiagnosticPosition pos,
2979             Env&lt;AttrContext&gt; env,
2980             JCMemberReference referenceTree,
2981             Type site,
2982             Name name) {
2983 
2984         site = types.capture(site);
2985 
2986         ReferenceLookupHelper lookupHelper = makeReferenceLookupHelper(
2987                 referenceTree, site, name, List.nil(), null, VARARITY);
2988 
2989         Env&lt;AttrContext&gt; newEnv = env.dup(env.tree, env.info.dup());
2990         Symbol sym = lookupMethod(newEnv, env.tree.pos(), site.tsym,
2991                 nilMethodCheck, lookupHelper);
2992 
2993         env.info.pendingResolutionPhase = newEnv.info.pendingResolutionPhase;
2994 
2995         return sym;
2996     }
2997 
2998     ReferenceLookupHelper makeReferenceLookupHelper(JCMemberReference referenceTree,
2999                                   Type site,
3000                                   Name name,
3001                                   List&lt;Type&gt; argtypes,
3002                                   List&lt;Type&gt; typeargtypes,
3003                                   MethodResolutionPhase maxPhase) {
3004         if (!name.equals(names.init)) {
3005             //method reference
3006             return new MethodReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase);
3007         } else if (site.hasTag(ARRAY)) {
3008             //array constructor reference
3009             return new ArrayConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
3010         } else {
3011             //class constructor reference
3012             return new ConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
3013         }
3014     }
3015 
3016     /**
3017      * Resolution of member references is typically done as a single
3018      * overload resolution step, where the argument types A are inferred from
3019      * the target functional descriptor.
3020      *
3021      * If the member reference is a method reference with a type qualifier,
3022      * a two-step lookup process is performed. The first step uses the
3023      * expected argument list A, while the second step discards the first
3024      * type from A (which is treated as a receiver type).
3025      *
3026      * There are two cases in which inference is performed: (i) if the member
3027      * reference is a constructor reference and the qualifier type is raw - in
3028      * which case diamond inference is used to infer a parameterization for the
3029      * type qualifier; (ii) if the member reference is an unbound reference
3030      * where the type qualifier is raw - in that case, during the unbound lookup
3031      * the receiver argument type is used to infer an instantiation for the raw
3032      * qualifier type.
3033      *
3034      * When a multi-step resolution process is exploited, the process of picking
3035      * the resulting symbol is delegated to an helper class {@link com.sun.tools.javac.comp.Resolve.ReferenceChooser}.
3036      *
3037      * This routine returns a pair (T,S), where S is the member reference symbol,
3038      * and T is the type of the class in which S is defined. This is necessary as
3039      * the type T might be dynamically inferred (i.e. if constructor reference
3040      * has a raw qualifier).
3041      */
3042     Pair&lt;Symbol, ReferenceLookupHelper&gt; resolveMemberReference(Env&lt;AttrContext&gt; env,
3043                                   JCMemberReference referenceTree,
3044                                   Type site,
3045                                   Name name,
3046                                   List&lt;Type&gt; argtypes,
3047                                   List&lt;Type&gt; typeargtypes,
3048                                   Type descriptor,
3049                                   MethodCheck methodCheck,
3050                                   InferenceContext inferenceContext,
3051                                   ReferenceChooser referenceChooser) {
3052 
3053         //step 1 - bound lookup
3054         ReferenceLookupHelper boundLookupHelper = makeReferenceLookupHelper(
3055                 referenceTree, site, name, argtypes, typeargtypes, VARARITY);
3056         Env&lt;AttrContext&gt; boundEnv = env.dup(env.tree, env.info.dup());
3057         MethodResolutionContext boundSearchResolveContext = new MethodResolutionContext();
3058         boundSearchResolveContext.methodCheck = methodCheck;
3059         Symbol boundSym = lookupMethod(boundEnv, env.tree.pos(),
3060                 site.tsym, boundSearchResolveContext, boundLookupHelper);
3061         ReferenceLookupResult boundRes = new ReferenceLookupResult(boundSym, boundSearchResolveContext);
3062 
3063         //step 2 - unbound lookup
3064         Symbol unboundSym = methodNotFound;
3065         Env&lt;AttrContext&gt; unboundEnv = env.dup(env.tree, env.info.dup());
3066         ReferenceLookupHelper unboundLookupHelper = boundLookupHelper.unboundLookup(inferenceContext);
3067         ReferenceLookupResult unboundRes = referenceNotFound;
3068         if (unboundLookupHelper != null) {
3069             MethodResolutionContext unboundSearchResolveContext =
3070                     new MethodResolutionContext();
3071             unboundSearchResolveContext.methodCheck = methodCheck;
3072             unboundSym = lookupMethod(unboundEnv, env.tree.pos(),
3073                     site.tsym, unboundSearchResolveContext, unboundLookupHelper);
3074             unboundRes = new ReferenceLookupResult(unboundSym, unboundSearchResolveContext);
3075         }
3076 
3077         //merge results
3078         Pair&lt;Symbol, ReferenceLookupHelper&gt; res;
3079         ReferenceLookupResult bestRes = referenceChooser.result(boundRes, unboundRes);
3080         res = new Pair&lt;&gt;(bestRes.sym,
3081                 bestRes == unboundRes ? unboundLookupHelper : boundLookupHelper);
3082         env.info.pendingResolutionPhase = bestRes == unboundRes ?
3083                 unboundEnv.info.pendingResolutionPhase :
3084                 boundEnv.info.pendingResolutionPhase;
3085 
3086         if (!res.fst.kind.isResolutionError()) {
3087             //handle sigpoly method references
3088             MethodSymbol msym = (MethodSymbol)res.fst;
3089             if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
3090                 env.info.pendingResolutionPhase = BASIC;
3091                 res = new Pair&lt;&gt;(findPolymorphicSignatureInstance(msym, descriptor), res.snd);
3092             }
3093         }
3094 
3095         return res;
3096     }
3097 
3098     /**
3099      * This class is used to represent a method reference lookup result. It keeps track of two
3100      * things: (i) the symbol found during a method reference lookup and (ii) the static kind
3101      * of the lookup (see {@link com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind}).
3102      */
3103     static class ReferenceLookupResult {
3104 
3105         /**
3106          * Static kind associated with a method reference lookup. Erroneous lookups end up with
3107          * the UNDEFINED kind; successful lookups will end up with either STATIC, NON_STATIC,
3108          * depending on whether all applicable candidates are static or non-static methods,
3109          * respectively. If a successful lookup has both static and non-static applicable methods,
3110          * its kind is set to BOTH.
3111          */
3112         enum StaticKind {
3113             STATIC,
3114             NON_STATIC,
3115             BOTH,
3116             UNDEFINED;
3117 
3118             /**
3119              * Retrieve the static kind associated with a given (method) symbol.
3120              */
3121             static StaticKind from(Symbol s) {
3122                 return s.isStatic() ?
3123                         STATIC : NON_STATIC;
3124             }
3125 
3126             /**
3127              * Merge two static kinds together.
3128              */
3129             static StaticKind reduce(StaticKind sk1, StaticKind sk2) {
3130                 if (sk1 == UNDEFINED) {
3131                     return sk2;
3132                 } else if (sk2 == UNDEFINED) {
3133                     return sk1;
3134                 } else {
3135                     return sk1 == sk2 ? sk1 : BOTH;
3136                 }
3137             }
3138         }
3139 
3140         /** The static kind. */
3141         StaticKind staticKind;
3142 
3143         /** The lookup result. */
3144         Symbol sym;
3145 
3146         ReferenceLookupResult(Symbol sym, MethodResolutionContext resolutionContext) {
3147             this(sym, staticKind(sym, resolutionContext));
3148         }
3149 
3150         private ReferenceLookupResult(Symbol sym, StaticKind staticKind) {
3151             this.staticKind = staticKind;
3152             this.sym = sym;
3153         }
3154 
3155         private static StaticKind staticKind(Symbol sym, MethodResolutionContext resolutionContext) {
3156             switch (sym.kind) {
3157                 case MTH:
3158                 case AMBIGUOUS:
3159                     return resolutionContext.candidates.stream()
3160                             .filter(c -&gt; c.isApplicable() &amp;&amp; c.step == resolutionContext.step)
3161                             .map(c -&gt; StaticKind.from(c.sym))
3162                             .reduce(StaticKind::reduce)
3163                             .orElse(StaticKind.UNDEFINED);
3164                 default:
3165                     return StaticKind.UNDEFINED;
3166             }
3167         }
3168 
3169         /**
3170          * Does this result corresponds to a successful lookup (i.e. one where a method has been found?)
3171          */
3172         boolean isSuccess() {
3173             return staticKind != StaticKind.UNDEFINED;
3174         }
3175 
3176         /**
3177          * Does this result have given static kind?
3178          */
3179         boolean hasKind(StaticKind sk) {
3180             return this.staticKind == sk;
3181         }
3182 
3183         /**
3184          * Error recovery helper: can this lookup result be ignored (for the purpose of returning
3185          * some &#39;better&#39; result) ?
3186          */
3187         boolean canIgnore() {
3188             switch (sym.kind) {
3189                 case ABSENT_MTH:
3190                     return true;
3191                 case WRONG_MTH:
3192                     InapplicableSymbolError errSym =
3193                             (InapplicableSymbolError)sym.baseSymbol();
3194                     return new Template(MethodCheckDiag.ARITY_MISMATCH.regex())
3195                             .matches(errSym.errCandidate().snd);
3196                 case WRONG_MTHS:
3197                     InapplicableSymbolsError errSyms =
3198                             (InapplicableSymbolsError)sym.baseSymbol();
3199                     return errSyms.filterCandidates(errSyms.mapCandidates()).isEmpty();
3200                 default:
3201                     return false;
3202             }
3203         }
3204 
3205         static ReferenceLookupResult error(Symbol sym) {
3206             return new ReferenceLookupResult(sym, StaticKind.UNDEFINED);
3207         }
3208     }
3209 
3210     /**
3211      * This abstract class embodies the logic that converts one (bound lookup) or two (unbound lookup)
3212      * {@code ReferenceLookupResult} objects into a (@code Symbol), which is then regarded as the
3213      * result of method reference resolution.
3214      */
3215     abstract class ReferenceChooser {
3216         /**
3217          * Generate a result from a pair of lookup result objects. This method delegates to the
3218          * appropriate result generation routine.
3219          */
3220         ReferenceLookupResult result(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3221             return unboundRes != referenceNotFound ?
3222                     unboundResult(boundRes, unboundRes) :
3223                     boundResult(boundRes);
3224         }
3225 
3226         /**
3227          * Generate a symbol from a given bound lookup result.
3228          */
3229         abstract ReferenceLookupResult boundResult(ReferenceLookupResult boundRes);
3230 
3231         /**
3232          * Generate a symbol from a pair of bound/unbound lookup results.
3233          */
3234         abstract ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes);
3235     }
3236 
3237     /**
3238      * This chooser implements the selection strategy used during a full lookup; this logic
3239      * is described in JLS SE 8 (15.3.2).
3240      */
3241     ReferenceChooser basicReferenceChooser = new ReferenceChooser() {
3242 
3243         @Override
3244         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3245             return !boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC) ?
3246                     boundRes : //the search produces a non-static method
3247                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3248         }
3249 
3250         @Override
3251         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3252             if (boundRes.hasKind(StaticKind.STATIC) &amp;&amp;
3253                     (!unboundRes.isSuccess() || unboundRes.hasKind(StaticKind.STATIC))) {
3254                 //the first search produces a static method and no non-static method is applicable
3255                 //during the second search
3256                 return boundRes;
3257             } else if (unboundRes.hasKind(StaticKind.NON_STATIC) &amp;&amp;
3258                     (!boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC))) {
3259                 //the second search produces a non-static method and no static method is applicable
3260                 //during the first search
3261                 return unboundRes;
3262             } else if (boundRes.isSuccess() &amp;&amp; unboundRes.isSuccess()) {
3263                 //both searches produce some result; ambiguity (error recovery)
3264                 return ReferenceLookupResult.error(ambiguityError(boundRes.sym, unboundRes.sym));
3265             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3266                 //Both searches failed to produce a result with correct staticness (i.e. first search
3267                 //produces an non-static method). Alternatively, a given search produced a result
3268                 //with the right staticness, but the other search has applicable methods with wrong
3269                 //staticness (error recovery)
3270                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3271                         boundRes.sym : unboundRes.sym, true));
3272             } else {
3273                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3274                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3275                         unboundRes : boundRes;
3276             }
3277         }
3278     };
3279 
3280     /**
3281      * This chooser implements the selection strategy used during an arity-based lookup; this logic
3282      * is described in JLS SE 8 (15.12.2.1).
3283      */
3284     ReferenceChooser structuralReferenceChooser = new ReferenceChooser() {
3285 
3286         @Override
3287         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3288             return (!boundRes.isSuccess() || !boundRes.hasKind(StaticKind.STATIC)) ?
3289                     boundRes : //the search has at least one applicable non-static method
3290                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3291         }
3292 
3293         @Override
3294         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3295             if (boundRes.isSuccess() &amp;&amp; !boundRes.hasKind(StaticKind.NON_STATIC)) {
3296                 //the first search has at least one applicable static method
3297                 return boundRes;
3298             } else if (unboundRes.isSuccess() &amp;&amp; !unboundRes.hasKind(StaticKind.STATIC)) {
3299                 //the second search has at least one applicable non-static method
3300                 return unboundRes;
3301             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3302                 //either the first search produces a non-static method, or second search produces
3303                 //a non-static method (error recovery)
3304                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3305                         boundRes.sym : unboundRes.sym, true));
3306             } else {
3307                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3308                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3309                         unboundRes : boundRes;
3310             }
3311         }
3312     };
3313 
3314     /**
3315      * Helper for defining custom method-like lookup logic; a lookup helper
3316      * provides hooks for (i) the actual lookup logic and (ii) accessing the
3317      * lookup result (this step might result in compiler diagnostics to be generated)
3318      */
3319     abstract class LookupHelper {
3320 
3321         /** name of the symbol to lookup */
3322         Name name;
3323 
3324         /** location in which the lookup takes place */
3325         Type site;
3326 
3327         /** actual types used during the lookup */
3328         List&lt;Type&gt; argtypes;
3329 
3330         /** type arguments used during the lookup */
3331         List&lt;Type&gt; typeargtypes;
3332 
3333         /** Max overload resolution phase handled by this helper */
3334         MethodResolutionPhase maxPhase;
3335 
3336         LookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3337             this.name = name;
3338             this.site = site;
3339             this.argtypes = argtypes;
3340             this.typeargtypes = typeargtypes;
3341             this.maxPhase = maxPhase;
3342         }
3343 
3344         /**
3345          * Should lookup stop at given phase with given result
3346          */
3347         final boolean shouldStop(Symbol sym, MethodResolutionPhase phase) {
3348             return phase.ordinal() &gt; maxPhase.ordinal() ||
3349                 !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS;
3350         }
3351 
3352         /**
3353          * Search for a symbol under a given overload resolution phase - this method
3354          * is usually called several times, once per each overload resolution phase
3355          */
3356         abstract Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3357 
3358         /**
3359          * Dump overload resolution info
3360          */
3361         void debug(DiagnosticPosition pos, Symbol sym) {
3362             //do nothing
3363         }
3364 
3365         /**
3366          * Validate the result of the lookup
3367          */
3368         abstract Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym);
3369     }
3370 
3371     abstract class BasicLookupHelper extends LookupHelper {
3372 
3373         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3374             this(name, site, argtypes, typeargtypes, MethodResolutionPhase.VARARITY);
3375         }
3376 
3377         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3378             super(name, site, argtypes, typeargtypes, maxPhase);
3379         }
3380 
3381         @Override
3382         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3383             Symbol sym = doLookup(env, phase);
3384             if (sym.kind == AMBIGUOUS) {
3385                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3386                 sym = a_err.mergeAbstracts(site);
3387             }
3388             return sym;
3389         }
3390 
3391         abstract Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3392 
3393         @Override
3394         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3395             if (sym.kind.isResolutionError()) {
3396                 //if nothing is found return the &#39;first&#39; error
3397                 sym = accessMethod(sym, pos, location, site, name, true, argtypes, typeargtypes);
3398             }
3399             return sym;
3400         }
3401 
3402         @Override
3403         void debug(DiagnosticPosition pos, Symbol sym) {
3404             reportVerboseResolutionDiagnostic(pos, name, site, argtypes, typeargtypes, sym);
3405         }
3406     }
3407 
3408     /**
3409      * Helper class for member reference lookup. A reference lookup helper
3410      * defines the basic logic for member reference lookup; a method gives
3411      * access to an &#39;unbound&#39; helper used to perform an unbound member
3412      * reference lookup.
3413      */
3414     abstract class ReferenceLookupHelper extends LookupHelper {
3415 
3416         /** The member reference tree */
3417         JCMemberReference referenceTree;
3418 
3419         ReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3420                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3421             super(name, site, argtypes, typeargtypes, maxPhase);
3422             this.referenceTree = referenceTree;
3423         }
3424 
3425         /**
3426          * Returns an unbound version of this lookup helper. By default, this
3427          * method returns an dummy lookup helper.
3428          */
3429         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3430             return null;
3431         }
3432 
3433         /**
3434          * Get the kind of the member reference
3435          */
3436         abstract JCMemberReference.ReferenceKind referenceKind(Symbol sym);
3437 
3438         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3439             if (sym.kind == AMBIGUOUS) {
3440                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3441                 sym = a_err.mergeAbstracts(site);
3442             }
3443             //skip error reporting
3444             return sym;
3445         }
3446     }
3447 
3448     /**
3449      * Helper class for method reference lookup. The lookup logic is based
3450      * upon Resolve.findMethod; in certain cases, this helper class has a
3451      * corresponding unbound helper class (see UnboundMethodReferenceLookupHelper).
3452      * In such cases, non-static lookup results are thrown away.
3453      */
3454     class MethodReferenceLookupHelper extends ReferenceLookupHelper {
3455 
3456         /** The original method reference lookup site. */
3457         Type originalSite;
3458 
3459         MethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3460                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3461             super(referenceTree, name, types.skipTypeVars(site, true), argtypes, typeargtypes, maxPhase);
3462             this.originalSite = site;
3463         }
3464 
3465         @Override
3466         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3467             return findMethod(env, site, name, argtypes, typeargtypes,
3468                     phase.isBoxingRequired(), phase.isVarargsRequired());
3469         }
3470 
3471         @Override
3472         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3473             if (TreeInfo.isStaticSelector(referenceTree.expr, names)) {
3474                 if (argtypes.nonEmpty() &amp;&amp;
3475                         (argtypes.head.hasTag(NONE) ||
3476                         types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {
3477                     return new UnboundMethodReferenceLookupHelper(referenceTree, name,
3478                             originalSite, argtypes, typeargtypes, maxPhase);
3479                 } else {
3480                     return new ReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase) {
3481                         @Override
3482                         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3483                             return this;
3484                         }
3485 
3486                         @Override
3487                         Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3488                             return methodNotFound;
3489                         }
3490 
3491                         @Override
3492                         ReferenceKind referenceKind(Symbol sym) {
3493                             Assert.error();
3494                             return null;
3495                         }
3496                     };
3497                 }
3498             } else {
3499                 return super.unboundLookup(inferenceContext);
3500             }
3501         }
3502 
3503         @Override
3504         ReferenceKind referenceKind(Symbol sym) {
3505             if (sym.isStatic()) {
3506                 return ReferenceKind.STATIC;
3507             } else {
3508                 Name selName = TreeInfo.name(referenceTree.getQualifierExpression());
3509                 return selName != null &amp;&amp; selName == names._super ?
3510                         ReferenceKind.SUPER :
3511                         ReferenceKind.BOUND;
3512             }
3513         }
3514     }
3515 
3516     /**
3517      * Helper class for unbound method reference lookup. Essentially the same
3518      * as the basic method reference lookup helper; main difference is that static
3519      * lookup results are thrown away. If qualifier type is raw, an attempt to
3520      * infer a parameterized type is made using the first actual argument (that
3521      * would otherwise be ignored during the lookup).
3522      */
3523     class UnboundMethodReferenceLookupHelper extends MethodReferenceLookupHelper {
3524 
3525         UnboundMethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3526                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3527             super(referenceTree, name, site, argtypes.tail, typeargtypes, maxPhase);
3528             if (site.isRaw() &amp;&amp; !argtypes.head.hasTag(NONE)) {
3529                 Type asSuperSite = types.asSuper(argtypes.head, site.tsym);
3530                 this.site = types.skipTypeVars(asSuperSite, true);
3531             }
3532         }
3533 
3534         @Override
3535         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3536             return this;
3537         }
3538 
3539         @Override
3540         ReferenceKind referenceKind(Symbol sym) {
3541             return ReferenceKind.UNBOUND;
3542         }
3543     }
3544 
3545     /**
3546      * Helper class for array constructor lookup; an array constructor lookup
3547      * is simulated by looking up a method that returns the array type specified
3548      * as qualifier, and that accepts a single int parameter (size of the array).
3549      */
3550     class ArrayConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3551 
3552         ArrayConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3553                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3554             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3555         }
3556 
3557         @Override
3558         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3559             WriteableScope sc = WriteableScope.create(syms.arrayClass);
3560             MethodSymbol arrayConstr = new MethodSymbol(PUBLIC, name, null, site.tsym);
3561             arrayConstr.type = new MethodType(List.of(syms.intType), site, List.nil(), syms.methodClass);
3562             sc.enter(arrayConstr);
3563             return findMethodInScope(env, site, name, argtypes, typeargtypes, sc, methodNotFound, phase.isBoxingRequired(), phase.isVarargsRequired(), false);
3564         }
3565 
3566         @Override
3567         ReferenceKind referenceKind(Symbol sym) {
3568             return ReferenceKind.ARRAY_CTOR;
3569         }
3570     }
3571 
3572     /**
3573      * Helper class for constructor reference lookup. The lookup logic is based
3574      * upon either Resolve.findMethod or Resolve.findDiamond - depending on
3575      * whether the constructor reference needs diamond inference (this is the case
3576      * if the qualifier type is raw). A special erroneous symbol is returned
3577      * if the lookup returns the constructor of an inner class and there&#39;s no
3578      * enclosing instance in scope.
3579      */
3580     class ConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3581 
3582         boolean needsInference;
3583 
3584         ConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3585                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3586             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3587             if (site.isRaw()) {
3588                 this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata());
3589                 needsInference = true;
3590             }
3591         }
3592 
3593         @Override
3594         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3595             Symbol sym = needsInference ?
3596                 findDiamond(env, site, argtypes, typeargtypes, phase.isBoxingRequired(), phase.isVarargsRequired()) :
3597                 findMethod(env, site, name, argtypes, typeargtypes,
3598                         phase.isBoxingRequired(), phase.isVarargsRequired());
3599             return enclosingInstanceMissing(env, site) ? new BadConstructorReferenceError(sym) : sym;
3600         }
3601 
3602         @Override
3603         ReferenceKind referenceKind(Symbol sym) {
3604             return site.getEnclosingType().hasTag(NONE) ?
3605                     ReferenceKind.TOPLEVEL : ReferenceKind.IMPLICIT_INNER;
3606         }
3607     }
3608 
3609     /**
3610      * Main overload resolution routine. On each overload resolution step, a
3611      * lookup helper class is used to perform the method/constructor lookup;
3612      * at the end of the lookup, the helper is used to validate the results
3613      * (this last step might trigger overload resolution diagnostics).
3614      */
3615     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, MethodCheck methodCheck, LookupHelper lookupHelper) {
3616         MethodResolutionContext resolveContext = new MethodResolutionContext();
3617         resolveContext.methodCheck = methodCheck;
3618         return lookupMethod(env, pos, location, resolveContext, lookupHelper);
3619     }
3620 
3621     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location,
3622             MethodResolutionContext resolveContext, LookupHelper lookupHelper) {
3623         MethodResolutionContext prevResolutionContext = currentResolutionContext;
3624         try {
3625             Symbol bestSoFar = methodNotFound;
3626             currentResolutionContext = resolveContext;
3627             for (MethodResolutionPhase phase : methodResolutionSteps) {
3628                 if (lookupHelper.shouldStop(bestSoFar, phase))
3629                     break;
3630                 MethodResolutionPhase prevPhase = currentResolutionContext.step;
3631                 Symbol prevBest = bestSoFar;
3632                 currentResolutionContext.step = phase;
3633                 Symbol sym = lookupHelper.lookup(env, phase);
3634                 lookupHelper.debug(pos, sym);
3635                 bestSoFar = phase.mergeResults(bestSoFar, sym);
3636                 env.info.pendingResolutionPhase = (prevBest == bestSoFar) ? prevPhase : phase;
3637             }
3638             return lookupHelper.access(env, pos, location, bestSoFar);
3639         } finally {
3640             currentResolutionContext = prevResolutionContext;
3641         }
3642     }
3643 
3644     /**
3645      * Resolve `c.name&#39; where name == this or name == super.
3646      * @param pos           The position to use for error reporting.
3647      * @param env           The environment current at the expression.
3648      * @param c             The qualifier.
3649      * @param name          The identifier&#39;s name.
3650      */
3651     Symbol resolveSelf(DiagnosticPosition pos,
3652                        Env&lt;AttrContext&gt; env,
3653                        TypeSymbol c,
3654                        Name name) {
3655         Env&lt;AttrContext&gt; env1 = env;
3656         boolean staticOnly = false;
3657         while (env1.outer != null) {
3658             if (isStatic(env1)) staticOnly = true;
3659             if (env1.enclClass.sym == c) {
3660                 Symbol sym = env1.info.scope.findFirst(name);
3661                 if (sym != null) {
3662                     if (staticOnly) sym = new StaticError(sym);
3663                     return accessBase(sym, pos, env.enclClass.sym.type,
3664                                   name, true);
3665                 }
3666             }
3667             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
3668             env1 = env1.outer;
3669         }
3670         if (c.isInterface() &amp;&amp;
3671             name == names._super &amp;&amp; !isStatic(env) &amp;&amp;
3672             types.isDirectSuperInterface(c, env.enclClass.sym)) {
3673             //this might be a default super call if one of the superinterfaces is &#39;c&#39;
3674             for (Type t : pruneInterfaces(env.enclClass.type)) {
3675                 if (t.tsym == c) {
3676                     env.info.defaultSuperCallSite = t;
3677                     return new VarSymbol(0, names._super,
3678                             types.asSuper(env.enclClass.type, c), env.enclClass.sym);
3679                 }
3680             }
3681             //find a direct super type that is a subtype of &#39;c&#39;
3682             for (Type i : types.directSupertypes(env.enclClass.type)) {
3683                 if (i.tsym.isSubClass(c, types) &amp;&amp; i.tsym != c) {
3684                     log.error(pos,
3685                               Errors.IllegalDefaultSuperCall(c,
3686                                                              Fragments.RedundantSupertype(c, i)));
3687                     return syms.errSymbol;
3688                 }
3689             }
3690             Assert.error();
3691         }
3692         log.error(pos, Errors.NotEnclClass(c));
3693         return syms.errSymbol;
3694     }
3695     //where
3696     private List&lt;Type&gt; pruneInterfaces(Type t) {
3697         ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
3698         for (Type t1 : types.interfaces(t)) {
3699             boolean shouldAdd = true;
3700             for (Type t2 : types.directSupertypes(t)) {
3701                 if (t1 != t2 &amp;&amp; types.isSubtypeNoCapture(t2, t1)) {
3702                     shouldAdd = false;
3703                 }
3704             }
3705             if (shouldAdd) {
3706                 result.append(t1);
3707             }
3708         }
3709         return result.toList();
3710     }
3711 
3712 
3713     /**
3714      * Resolve `c.this&#39; for an enclosing class c that contains the
3715      * named member.
3716      * @param pos           The position to use for error reporting.
3717      * @param env           The environment current at the expression.
3718      * @param member        The member that must be contained in the result.
3719      */
3720     Symbol resolveSelfContaining(DiagnosticPosition pos,
3721                                  Env&lt;AttrContext&gt; env,
3722                                  Symbol member,
3723                                  boolean isSuperCall) {
3724         Symbol sym = resolveSelfContainingInternal(env, member, isSuperCall);
3725         if (sym == null) {
3726             log.error(pos, Errors.EnclClassRequired(member));
3727             return syms.errSymbol;
3728         } else {
3729             return accessBase(sym, pos, env.enclClass.sym.type, sym.name, true);
3730         }
3731     }
3732 
3733     boolean enclosingInstanceMissing(Env&lt;AttrContext&gt; env, Type type) {
3734         if (type.hasTag(CLASS) &amp;&amp; type.getEnclosingType().hasTag(CLASS)) {
3735             Symbol encl = resolveSelfContainingInternal(env, type.tsym, false);
3736             return encl == null || encl.kind.isResolutionError();
3737         }
3738         return false;
3739     }
3740 
3741     private Symbol resolveSelfContainingInternal(Env&lt;AttrContext&gt; env,
3742                                  Symbol member,
3743                                  boolean isSuperCall) {
3744         Name name = names._this;
3745         Env&lt;AttrContext&gt; env1 = isSuperCall ? env.outer : env;
3746         boolean staticOnly = false;
3747         if (env1 != null) {
3748             while (env1 != null &amp;&amp; env1.outer != null) {
3749                 if (isStatic(env1)) staticOnly = true;
3750                 if (env1.enclClass.sym.isSubClass(member.owner.enclClass(), types)) {
3751                     Symbol sym = env1.info.scope.findFirst(name);
3752                     if (sym != null) {
3753                         if (staticOnly) sym = new StaticError(sym);
3754                         return sym;
3755                     }
3756                 }
3757                 if ((env1.enclClass.sym.flags() &amp; STATIC) != 0)
3758                     staticOnly = true;
3759                 env1 = env1.outer;
3760             }
3761         }
3762         return null;
3763     }
3764 
3765     /**
3766      * Resolve an appropriate implicit this instance for t&#39;s container.
3767      * JLS 8.8.5.1 and 15.9.2
3768      */
3769     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t) {
3770         return resolveImplicitThis(pos, env, t, false);
3771     }
3772 
3773     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t, boolean isSuperCall) {
3774         Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)
3775                          ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)
3776                          : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;
3777         if (env.info.isSelfCall &amp;&amp; thisType.tsym == env.enclClass.sym) {
3778             log.error(pos, Errors.CantRefBeforeCtorCalled(&quot;this&quot;));
3779         }
3780         return thisType;
3781     }
3782 
3783 /* ***************************************************************************
3784  *  ResolveError classes, indicating error situations when accessing symbols
3785  ****************************************************************************/
3786 
3787     //used by TransTypes when checking target type of synthetic cast
3788     public void logAccessErrorInternal(Env&lt;AttrContext&gt; env, JCTree tree, Type type) {
3789         AccessError error = new AccessError(env, env.enclClass.type, type.tsym);
3790         logResolveError(error, tree.pos(), env.enclClass.sym, env.enclClass.type, null, null, null);
3791     }
3792     //where
3793     private void logResolveError(ResolveError error,
3794             DiagnosticPosition pos,
3795             Symbol location,
3796             Type site,
3797             Name name,
3798             List&lt;Type&gt; argtypes,
3799             List&lt;Type&gt; typeargtypes) {
3800         JCDiagnostic d = error.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
3801                 pos, location, site, name, argtypes, typeargtypes);
3802         if (d != null) {
3803             d.setFlag(DiagnosticFlag.RESOLVE_ERROR);
3804             log.report(d);
3805         }
3806     }
3807 
3808     private final LocalizedString noArgs = new LocalizedString(&quot;compiler.misc.no.args&quot;);
3809 
3810     public Object methodArguments(List&lt;Type&gt; argtypes) {
3811         if (argtypes == null || argtypes.isEmpty()) {
3812             return noArgs;
3813         } else {
3814             ListBuffer&lt;Object&gt; diagArgs = new ListBuffer&lt;&gt;();
3815             for (Type t : argtypes) {
3816                 if (t.hasTag(DEFERRED)) {
3817                     diagArgs.append(((DeferredAttr.DeferredType)t).tree);
3818                 } else {
3819                     diagArgs.append(t);
3820                 }
3821             }
3822             return diagArgs;
3823         }
3824     }
3825 
3826     /**
3827      * Root class for resolution errors. Subclass of ResolveError
3828      * represent a different kinds of resolution error - as such they must
3829      * specify how they map into concrete compiler diagnostics.
3830      */
3831     abstract class ResolveError extends Symbol {
3832 
3833         /** The name of the kind of error, for debugging only. */
3834         final String debugName;
3835 
3836         ResolveError(Kind kind, String debugName) {
3837             super(kind, 0, null, null, null);
3838             this.debugName = debugName;
3839         }
3840 
3841         @Override @DefinedBy(Api.LANGUAGE_MODEL)
3842         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
3843             throw new AssertionError();
3844         }
3845 
3846         @Override
3847         public String toString() {
3848             return debugName;
3849         }
3850 
3851         @Override
3852         public boolean exists() {
3853             return false;
3854         }
3855 
3856         @Override
3857         public boolean isStatic() {
3858             return false;
3859         }
3860 
3861         /**
3862          * Create an external representation for this erroneous symbol to be
3863          * used during attribution - by default this returns the symbol of a
3864          * brand new error type which stores the original type found
3865          * during resolution.
3866          *
3867          * @param name     the name used during resolution
3868          * @param location the location from which the symbol is accessed
3869          */
3870         protected Symbol access(Name name, TypeSymbol location) {
3871             return types.createErrorType(name, location, syms.errSymbol.type).tsym;
3872         }
3873 
3874         /**
3875          * Create a diagnostic representing this resolution error.
3876          *
3877          * @param dkind     The kind of the diagnostic to be created (e.g error).
3878          * @param pos       The position to be used for error reporting.
3879          * @param site      The original type from where the selection took place.
3880          * @param name      The name of the symbol to be resolved.
3881          * @param argtypes  The invocation&#39;s value arguments,
3882          *                  if we looked for a method.
3883          * @param typeargtypes  The invocation&#39;s type arguments,
3884          *                      if we looked for a method.
3885          */
3886         abstract JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3887                 DiagnosticPosition pos,
3888                 Symbol location,
3889                 Type site,
3890                 Name name,
3891                 List&lt;Type&gt; argtypes,
3892                 List&lt;Type&gt; typeargtypes);
3893     }
3894 
3895     /**
3896      * This class is the root class of all resolution errors caused by
3897      * an invalid symbol being found during resolution.
3898      */
3899     abstract class InvalidSymbolError extends ResolveError {
3900 
3901         /** The invalid symbol found during resolution */
3902         Symbol sym;
3903 
3904         InvalidSymbolError(Kind kind, Symbol sym, String debugName) {
3905             super(kind, debugName);
3906             this.sym = sym;
3907         }
3908 
3909         @Override
3910         public boolean exists() {
3911             return true;
3912         }
3913 
3914         @Override
3915         public String toString() {
3916              return super.toString() + &quot; wrongSym=&quot; + sym;
3917         }
3918 
3919         @Override
3920         public Symbol access(Name name, TypeSymbol location) {
3921             if (!sym.kind.isResolutionError() &amp;&amp; sym.kind.matches(KindSelector.TYP))
3922                 return types.createErrorType(name, location, sym.type).tsym;
3923             else
3924                 return sym;
3925         }
3926     }
3927 
3928     class BadRestrictedTypeError extends ResolveError {
3929         private final Name typeName;
3930         BadRestrictedTypeError(Name typeName) {
3931             super(Kind.BAD_RESTRICTED_TYPE, &quot;bad var use&quot;);
3932             this.typeName = typeName;
3933         }
3934 
3935         @Override
3936         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3937             return diags.create(dkind, log.currentSource(), pos, &quot;illegal.ref.to.restricted.type&quot;, typeName);
3938         }
3939     }
3940 
3941     /**
3942      * InvalidSymbolError error class indicating that a symbol matching a
3943      * given name does not exists in a given site.
3944      */
3945     class SymbolNotFoundError extends ResolveError {
3946 
3947         SymbolNotFoundError(Kind kind) {
3948             this(kind, &quot;symbol not found error&quot;);
3949         }
3950 
3951         SymbolNotFoundError(Kind kind, String debugName) {
3952             super(kind, debugName);
3953         }
3954 
3955         @Override
3956         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3957                 DiagnosticPosition pos,
3958                 Symbol location,
3959                 Type site,
3960                 Name name,
3961                 List&lt;Type&gt; argtypes,
3962                 List&lt;Type&gt; typeargtypes) {
3963             argtypes = argtypes == null ? List.nil() : argtypes;
3964             typeargtypes = typeargtypes == null ? List.nil() : typeargtypes;
3965             if (name == names.error)
3966                 return null;
3967 
3968             boolean hasLocation = false;
3969             if (location == null) {
3970                 location = site.tsym;
3971             }
3972             if (!location.name.isEmpty()) {
3973                 if (location.kind == PCK &amp;&amp; !site.tsym.exists()) {
3974                     return diags.create(dkind, log.currentSource(), pos,
3975                         &quot;doesnt.exist&quot;, location);
3976                 }
3977                 hasLocation = !location.name.equals(names._this) &amp;&amp;
3978                         !location.name.equals(names._super);
3979             }
3980             boolean isConstructor = name == names.init;
3981             KindName kindname = isConstructor ? KindName.CONSTRUCTOR : kind.absentKind();
3982             Name idname = isConstructor ? site.tsym.name : name;
3983             String errKey = getErrorKey(kindname, typeargtypes.nonEmpty(), hasLocation);
3984             if (hasLocation) {
3985                 return diags.create(dkind, log.currentSource(), pos,
3986                         errKey, kindname, idname, //symbol kindname, name
3987                         typeargtypes, args(argtypes), //type parameters and arguments (if any)
3988                         getLocationDiag(location, site)); //location kindname, type
3989             }
3990             else {
3991                 return diags.create(dkind, log.currentSource(), pos,
3992                         errKey, kindname, idname, //symbol kindname, name
3993                         typeargtypes, args(argtypes)); //type parameters and arguments (if any)
3994             }
3995         }
3996         //where
3997         private Object args(List&lt;Type&gt; args) {
3998             return args.isEmpty() ? args : methodArguments(args);
3999         }
4000 
4001         private String getErrorKey(KindName kindname, boolean hasTypeArgs, boolean hasLocation) {
4002             String key = &quot;cant.resolve&quot;;
4003             String suffix = hasLocation ? &quot;.location&quot; : &quot;&quot;;
4004             switch (kindname) {
4005                 case METHOD:
4006                 case CONSTRUCTOR: {
4007                     suffix += &quot;.args&quot;;
4008                     suffix += hasTypeArgs ? &quot;.params&quot; : &quot;&quot;;
4009                 }
4010             }
4011             return key + suffix;
4012         }
4013         private JCDiagnostic getLocationDiag(Symbol location, Type site) {
4014             if (location.kind == VAR) {
4015                 return diags.fragment(Fragments.Location1(kindName(location),
4016                                                           location,
4017                                                           location.type));
4018             } else {
4019                 return diags.fragment(Fragments.Location(typeKindName(site),
4020                                       site,
4021                                       null));
4022             }
4023         }
4024     }
4025 
4026     /**
4027      * InvalidSymbolError error class indicating that a given symbol
4028      * (either a method, a constructor or an operand) is not applicable
4029      * given an actual arguments/type argument list.
4030      */
4031     class InapplicableSymbolError extends ResolveError {
4032 
4033         protected MethodResolutionContext resolveContext;
4034 
4035         InapplicableSymbolError(MethodResolutionContext context) {
4036             this(WRONG_MTH, &quot;inapplicable symbol error&quot;, context);
4037         }
4038 
4039         protected InapplicableSymbolError(Kind kind, String debugName, MethodResolutionContext context) {
4040             super(kind, debugName);
4041             this.resolveContext = context;
4042         }
4043 
4044         @Override
4045         public String toString() {
4046             return super.toString();
4047         }
4048 
4049         @Override
4050         public boolean exists() {
4051             return true;
4052         }
4053 
4054         @Override
4055         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4056                 DiagnosticPosition pos,
4057                 Symbol location,
4058                 Type site,
4059                 Name name,
4060                 List&lt;Type&gt; argtypes,
4061                 List&lt;Type&gt; typeargtypes) {
4062             if (name == names.error)
4063                 return null;
4064 
4065             Pair&lt;Symbol, JCDiagnostic&gt; c = errCandidate();
4066             if (compactMethodDiags) {
4067                 JCDiagnostic simpleDiag =
4068                     MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd);
4069                 if (simpleDiag != null) {
4070                     return simpleDiag;
4071                 }
4072             }
4073             Symbol ws = c.fst.asMemberOf(site, types);
4074             return diags.create(dkind, log.currentSource(), pos,
4075                       &quot;cant.apply.symbol&quot;,
4076                       kindName(ws),
4077                       ws.name == names.init ? ws.owner.name : ws.name,
4078                       methodArguments(ws.type.getParameterTypes()),
4079                       methodArguments(argtypes),
4080                       kindName(ws.owner),
4081                       ws.owner.type,
4082                       c.snd);
4083         }
4084 
4085         @Override
4086         public Symbol access(Name name, TypeSymbol location) {
4087             Symbol sym = bestCandidate();
4088             return types.createErrorType(name, location, sym != null ? sym.type : syms.errSymbol.type).tsym;
4089         }
4090 
4091         protected Symbol bestCandidate() {
4092             return errCandidate().fst;
4093         }
4094 
4095         protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4096             Candidate bestSoFar = null;
4097             for (Candidate c : resolveContext.candidates) {
4098                 if (c.isApplicable()) continue;
4099                 bestSoFar = c;
4100             }
4101             Assert.checkNonNull(bestSoFar);
4102             return new Pair&lt;&gt;(bestSoFar.sym, bestSoFar.details);
4103         }
4104     }
4105 
4106     /**
4107      * ResolveError error class indicating that a symbol (either methods, constructors or operand)
4108      * is not applicable given an actual arguments/type argument list.
4109      */
4110     class InapplicableSymbolsError extends InapplicableSymbolError {
4111 
4112         InapplicableSymbolsError(MethodResolutionContext context) {
4113             super(WRONG_MTHS, &quot;inapplicable symbols&quot;, context);
4114         }
4115 
4116         @Override
4117         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4118                 DiagnosticPosition pos,
4119                 Symbol location,
4120                 Type site,
4121                 Name name,
4122                 List&lt;Type&gt; argtypes,
4123                 List&lt;Type&gt; typeargtypes) {
4124             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4125             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = compactMethodDiags ?
4126                     filterCandidates(candidatesMap) :
4127                     mapCandidates();
4128             if (filteredCandidates.isEmpty()) {
4129                 filteredCandidates = candidatesMap;
4130             }
4131             boolean truncatedDiag = candidatesMap.size() != filteredCandidates.size();
4132             if (filteredCandidates.size() &gt; 1) {
4133                 JCDiagnostic err = diags.create(dkind,
4134                         null,
4135                         truncatedDiag ?
4136                             EnumSet.of(DiagnosticFlag.COMPRESSED) :
4137                             EnumSet.noneOf(DiagnosticFlag.class),
4138                         log.currentSource(),
4139                         pos,
4140                         &quot;cant.apply.symbols&quot;,
4141                         name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),
4142                         name == names.init ? site.tsym.name : name,
4143                         methodArguments(argtypes));
4144                 return new JCDiagnostic.MultilineDiagnostic(err, candidateDetails(filteredCandidates, site));
4145             } else if (filteredCandidates.size() == 1) {
4146                 Map.Entry&lt;Symbol, JCDiagnostic&gt; _e =
4147                                 filteredCandidates.entrySet().iterator().next();
4148                 final Pair&lt;Symbol, JCDiagnostic&gt; p = new Pair&lt;&gt;(_e.getKey(), _e.getValue());
4149                 JCDiagnostic d = new InapplicableSymbolError(resolveContext) {
4150                     @Override
4151                     protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4152                         return p;
4153                     }
4154                 }.getDiagnostic(dkind, pos,
4155                     location, site, name, argtypes, typeargtypes);
4156                 if (truncatedDiag) {
4157                     d.setFlag(DiagnosticFlag.COMPRESSED);
4158                 }
4159                 return d;
4160             } else {
4161                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind, pos,
4162                     location, site, name, argtypes, typeargtypes);
4163             }
4164         }
4165         //where
4166             private Map&lt;Symbol, JCDiagnostic&gt; mapCandidates() {
4167                 MostSpecificMap candidates = new MostSpecificMap();
4168                 for (Candidate c : resolveContext.candidates) {
4169                     if (c.isApplicable()) continue;
4170                     candidates.put(c);
4171                 }
4172                 return candidates;
4173             }
4174 
4175             @SuppressWarnings(&quot;serial&quot;)
4176             private class MostSpecificMap extends LinkedHashMap&lt;Symbol, JCDiagnostic&gt; {
4177                 private void put(Candidate c) {
4178                     ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
4179                     for (Symbol s : keySet()) {
4180                         if (s == c.sym) {
4181                             continue;
4182                         }
4183                         if (c.sym.overrides(s, (TypeSymbol)s.owner, types, false)) {
4184                             overridden.add(s);
4185                         } else if (s.overrides(c.sym, (TypeSymbol)c.sym.owner, types, false)) {
4186                             return;
4187                         }
4188                     }
4189                     for (Symbol s : overridden) {
4190                         remove(s);
4191                     }
4192                     put(c.sym, c.details);
4193                 }
4194             }
4195 
4196             Map&lt;Symbol, JCDiagnostic&gt; filterCandidates(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap) {
4197                 Map&lt;Symbol, JCDiagnostic&gt; candidates = new LinkedHashMap&lt;&gt;();
4198                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4199                     JCDiagnostic d = _entry.getValue();
4200                     if (!new Template(MethodCheckDiag.ARITY_MISMATCH.regex()).matches(d)) {
4201                         candidates.put(_entry.getKey(), d);
4202                     }
4203                 }
4204                 return candidates;
4205             }
4206 
4207             private List&lt;JCDiagnostic&gt; candidateDetails(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap, Type site) {
4208                 List&lt;JCDiagnostic&gt; details = List.nil();
4209                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4210                     Symbol sym = _entry.getKey();
4211                     JCDiagnostic detailDiag =
4212                             diags.fragment(Fragments.InapplicableMethod(Kinds.kindName(sym),
4213                                                                         sym.location(site, types),
4214                                                                         sym.asMemberOf(site, types),
4215                                                                         _entry.getValue()));
4216                     details = details.prepend(detailDiag);
4217                 }
4218                 //typically members are visited in reverse order (see Scope)
4219                 //so we need to reverse the candidate list so that candidates
4220                 //conform to source order
4221                 return details;
4222             }
4223 
4224         @Override
4225         protected Symbol bestCandidate() {
4226             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4227             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = filterCandidates(candidatesMap);
4228             if (filteredCandidates.size() == 1) {
4229                 return filteredCandidates.keySet().iterator().next();
4230             }
4231             return null;
4232         }
4233     }
4234 
4235     /**
4236      * DiamondError error class indicating that a constructor symbol is not applicable
4237      * given an actual arguments/type argument list using diamond inference.
4238      */
4239     class DiamondError extends InapplicableSymbolError {
4240 
4241         Symbol sym;
4242 
4243         public DiamondError(Symbol sym, MethodResolutionContext context) {
4244             super(sym.kind, &quot;diamondError&quot;, context);
4245             this.sym = sym;
4246         }
4247 
4248         JCDiagnostic getDetails() {
4249             return (sym.kind == WRONG_MTH) ?
4250                     ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
4251                     null;
4252         }
4253 
4254         @Override
4255         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos,
4256                 Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4257             JCDiagnostic details = getDetails();
4258             if (details != null &amp;&amp; compactMethodDiags) {
4259                 JCDiagnostic simpleDiag =
4260                         MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, details);
4261                 if (simpleDiag != null) {
4262                     return simpleDiag;
4263                 }
4264             }
4265             String key = details == null ?
4266                 &quot;cant.apply.diamond&quot; :
4267                 &quot;cant.apply.diamond.1&quot;;
4268             return diags.create(dkind, log.currentSource(), pos, key,
4269                     Fragments.Diamond(site.tsym), details);
4270         }
4271     }
4272 
4273     /**
4274      * An InvalidSymbolError error class indicating that a symbol is not
4275      * accessible from a given site
4276      */
4277     class AccessError extends InvalidSymbolError {
4278 
4279         private Env&lt;AttrContext&gt; env;
4280         private Type site;
4281 
4282         AccessError(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
4283             super(HIDDEN, sym, &quot;access error&quot;);
4284             this.env = env;
4285             this.site = site;
4286         }
4287 
4288         @Override
4289         public boolean exists() {
4290             return false;
4291         }
4292 
4293         @Override
4294         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4295                 DiagnosticPosition pos,
4296                 Symbol location,
4297                 Type site,
4298                 Name name,
4299                 List&lt;Type&gt; argtypes,
4300                 List&lt;Type&gt; typeargtypes) {
4301             if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) {
4302                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind,
4303                         pos, location, site, name, argtypes, typeargtypes);
4304             }
4305             else if ((sym.flags() &amp; PUBLIC) != 0
4306                 || (env != null &amp;&amp; this.site != null
4307                     &amp;&amp; !isAccessible(env, this.site))) {
4308                 if (sym.owner.kind == PCK) {
4309                     return diags.create(dkind, log.currentSource(),
4310                             pos, &quot;not.def.access.package.cant.access&quot;,
4311                         sym, sym.location(), inaccessiblePackageReason(env, sym.packge()));
4312                 } else if (   sym.packge() != syms.rootPackage
4313                            &amp;&amp; !symbolPackageVisible(env, sym)) {
4314                     return diags.create(dkind, log.currentSource(),
4315                             pos, &quot;not.def.access.class.intf.cant.access.reason&quot;,
4316                             sym, sym.location(), sym.location().packge(),
4317                             inaccessiblePackageReason(env, sym.packge()));
4318                 } else {
4319                     return diags.create(dkind, log.currentSource(),
4320                             pos, &quot;not.def.access.class.intf.cant.access&quot;,
4321                         sym, sym.location());
4322                 }
4323             }
4324             else if ((sym.flags() &amp; (PRIVATE | PROTECTED)) != 0) {
4325                 return diags.create(dkind, log.currentSource(),
4326                         pos, &quot;report.access&quot;, sym,
4327                         asFlagSet(sym.flags() &amp; (PRIVATE | PROTECTED)),
4328                         sym.location());
4329             }
4330             else {
4331                 return diags.create(dkind, log.currentSource(),
4332                         pos, &quot;not.def.public.cant.access&quot;, sym, sym.location());
4333             }
4334         }
4335 
4336         private String toString(Type type) {
4337             StringBuilder sb = new StringBuilder();
4338             sb.append(type);
4339             if (type != null) {
4340                 sb.append(&quot;[tsym:&quot;).append(type.tsym);
4341                 if (type.tsym != null)
4342                     sb.append(&quot;packge:&quot;).append(type.tsym.packge());
4343                 sb.append(&quot;]&quot;);
4344             }
4345             return sb.toString();
4346         }
4347     }
4348 
4349     class InvisibleSymbolError extends InvalidSymbolError {
4350 
4351         private final Env&lt;AttrContext&gt; env;
4352         private final boolean suppressError;
4353 
4354         InvisibleSymbolError(Env&lt;AttrContext&gt; env, boolean suppressError, Symbol sym) {
4355             super(HIDDEN, sym, &quot;invisible class error&quot;);
4356             this.env = env;
4357             this.suppressError = suppressError;
4358             this.name = sym.name;
4359         }
4360 
4361         @Override
4362         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4363                 DiagnosticPosition pos,
4364                 Symbol location,
4365                 Type site,
4366                 Name name,
4367                 List&lt;Type&gt; argtypes,
4368                 List&lt;Type&gt; typeargtypes) {
4369             if (suppressError)
4370                 return null;
4371 
4372             if (sym.kind == PCK) {
4373                 JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4374                 return diags.create(dkind, log.currentSource(),
4375                         pos, &quot;package.not.visible&quot;, sym, details);
4376             }
4377 
4378             JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4379 
4380             if (pos.getTree() != null) {
4381                 Symbol o = sym;
4382                 JCTree tree = pos.getTree();
4383 
4384                 while (o.kind != PCK &amp;&amp; tree.hasTag(SELECT)) {
4385                     o = o.owner;
4386                     tree = ((JCFieldAccess) tree).selected;
4387                 }
4388 
4389                 if (o.kind == PCK) {
4390                     pos = tree.pos();
4391 
4392                     return diags.create(dkind, log.currentSource(),
4393                             pos, &quot;package.not.visible&quot;, o, details);
4394                 }
4395             }
4396 
4397             return diags.create(dkind, log.currentSource(),
4398                     pos, &quot;not.def.access.package.cant.access&quot;, sym, sym.packge(), details);
4399         }
4400     }
4401 
4402     JCDiagnostic inaccessiblePackageReason(Env&lt;AttrContext&gt; env, PackageSymbol sym) {
4403         //no dependency:
4404         if (!env.toplevel.modle.readModules.contains(sym.modle)) {
4405             //does not read:
4406             if (sym.modle != syms.unnamedModule) {
4407                 if (env.toplevel.modle != syms.unnamedModule) {
4408                     return diags.fragment(Fragments.NotDefAccessDoesNotRead(env.toplevel.modle,
4409                                                                             sym,
4410                                                                             sym.modle));
4411                 } else {
4412                     return diags.fragment(Fragments.NotDefAccessDoesNotReadFromUnnamed(sym,
4413                                                                                        sym.modle));
4414                 }
4415             } else {
4416                 return diags.fragment(Fragments.NotDefAccessDoesNotReadUnnamed(sym,
4417                                                                                env.toplevel.modle));
4418             }
4419         } else {
4420             if (sym.packge().modle.exports.stream().anyMatch(e -&gt; e.packge == sym)) {
4421                 //not exported to this module:
4422                 if (env.toplevel.modle != syms.unnamedModule) {
4423                     return diags.fragment(Fragments.NotDefAccessNotExportedToModule(sym,
4424                                                                                     sym.modle,
4425                                                                                     env.toplevel.modle));
4426                 } else {
4427                     return diags.fragment(Fragments.NotDefAccessNotExportedToModuleFromUnnamed(sym,
4428                                                                                                sym.modle));
4429                 }
4430             } else {
4431                 //not exported:
4432                 if (env.toplevel.modle != syms.unnamedModule) {
4433                     return diags.fragment(Fragments.NotDefAccessNotExported(sym,
4434                                                                             sym.modle));
4435                 } else {
4436                     return diags.fragment(Fragments.NotDefAccessNotExportedFromUnnamed(sym,
4437                                                                                        sym.modle));
4438                 }
4439             }
4440         }
4441     }
4442 
4443     /**
4444      * InvalidSymbolError error class indicating that an instance member
4445      * has erroneously been accessed from a static context.
4446      */
4447     class StaticError extends InvalidSymbolError {
4448 
4449         StaticError(Symbol sym) {
4450             super(STATICERR, sym, &quot;static error&quot;);
4451         }
4452 
4453         @Override
4454         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4455                 DiagnosticPosition pos,
4456                 Symbol location,
4457                 Type site,
4458                 Name name,
4459                 List&lt;Type&gt; argtypes,
4460                 List&lt;Type&gt; typeargtypes) {
4461             Symbol errSym = ((sym.kind == TYP &amp;&amp; sym.type.hasTag(CLASS))
4462                 ? types.erasure(sym.type).tsym
4463                 : sym);
4464             return diags.create(dkind, log.currentSource(), pos,
4465                     &quot;non-static.cant.be.ref&quot;, kindName(sym), errSym);
4466         }
4467     }
4468 
4469     /**
4470      * InvalidSymbolError error class indicating that a pair of symbols
4471      * (either methods, constructors or operands) are ambiguous
4472      * given an actual arguments/type argument list.
4473      */
4474     class AmbiguityError extends ResolveError {
4475 
4476         /** The other maximally specific symbol */
4477         List&lt;Symbol&gt; ambiguousSyms = List.nil();
4478 
4479         @Override
4480         public boolean exists() {
4481             return true;
4482         }
4483 
4484         AmbiguityError(Symbol sym1, Symbol sym2) {
4485             super(AMBIGUOUS, &quot;ambiguity error&quot;);
4486             ambiguousSyms = flatten(sym2).appendList(flatten(sym1));
4487         }
4488 
4489         private List&lt;Symbol&gt; flatten(Symbol sym) {
4490             if (sym.kind == AMBIGUOUS) {
4491                 return ((AmbiguityError)sym.baseSymbol()).ambiguousSyms;
4492             } else {
4493                 return List.of(sym);
4494             }
4495         }
4496 
4497         AmbiguityError addAmbiguousSymbol(Symbol s) {
4498             ambiguousSyms = ambiguousSyms.prepend(s);
4499             return this;
4500         }
4501 
4502         @Override
4503         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4504                 DiagnosticPosition pos,
4505                 Symbol location,
4506                 Type site,
4507                 Name name,
4508                 List&lt;Type&gt; argtypes,
4509                 List&lt;Type&gt; typeargtypes) {
4510             List&lt;Symbol&gt; diagSyms = ambiguousSyms.reverse();
4511             Symbol s1 = diagSyms.head;
4512             Symbol s2 = diagSyms.tail.head;
4513             Name sname = s1.name;
4514             if (sname == names.init) sname = s1.owner.name;
4515             return diags.create(dkind, log.currentSource(),
4516                     pos, &quot;ref.ambiguous&quot;, sname,
4517                     kindName(s1),
4518                     s1,
4519                     s1.location(site, types),
4520                     kindName(s2),
4521                     s2,
4522                     s2.location(site, types));
4523         }
4524 
4525         /**
4526          * If multiple applicable methods are found during overload and none of them
4527          * is more specific than the others, attempt to merge their signatures.
4528          */
4529         Symbol mergeAbstracts(Type site) {
4530             List&lt;Symbol&gt; ambiguousInOrder = ambiguousSyms.reverse();
4531             return types.mergeAbstracts(ambiguousInOrder, site, true).orElse(this);
4532         }
4533 
4534         @Override
4535         protected Symbol access(Name name, TypeSymbol location) {
4536             Symbol firstAmbiguity = ambiguousSyms.last();
4537             return firstAmbiguity.kind == TYP ?
4538                     types.createErrorType(name, location, firstAmbiguity.type).tsym :
4539                     firstAmbiguity;
4540         }
4541     }
4542 
4543     class BadVarargsMethod extends ResolveError {
4544 
4545         ResolveError delegatedError;
4546 
4547         BadVarargsMethod(ResolveError delegatedError) {
4548             super(delegatedError.kind, &quot;badVarargs&quot;);
4549             this.delegatedError = delegatedError;
4550         }
4551 
4552         @Override
4553         public Symbol baseSymbol() {
4554             return delegatedError.baseSymbol();
4555         }
4556 
4557         @Override
4558         protected Symbol access(Name name, TypeSymbol location) {
4559             return delegatedError.access(name, location);
4560         }
4561 
4562         @Override
4563         public boolean exists() {
4564             return true;
4565         }
4566 
4567         @Override
4568         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4569             return delegatedError.getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes);
4570         }
4571     }
4572 
4573     /**
4574      * BadMethodReferenceError error class indicating that a method reference symbol has been found,
4575      * but with the wrong staticness.
4576      */
4577     class BadMethodReferenceError extends StaticError {
4578 
4579         boolean unboundLookup;
4580 
4581         public BadMethodReferenceError(Symbol sym, boolean unboundLookup) {
4582             super(sym);
4583             this.unboundLookup = unboundLookup;
4584         }
4585 
4586         @Override
4587         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4588             final String key;
4589             if (!unboundLookup) {
4590                 key = &quot;bad.static.method.in.bound.lookup&quot;;
4591             } else if (sym.isStatic()) {
4592                 key = &quot;bad.static.method.in.unbound.lookup&quot;;
4593             } else {
4594                 key = &quot;bad.instance.method.in.unbound.lookup&quot;;
4595             }
4596             return sym.kind.isResolutionError() ?
4597                     ((ResolveError)sym).getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes) :
4598                     diags.create(dkind, log.currentSource(), pos, key, Kinds.kindName(sym), sym);
4599         }
4600     }
4601 
4602     /**
4603      * BadConstructorReferenceError error class indicating that a constructor reference symbol has been found,
4604      * but pointing to a class for which an enclosing instance is not available.
4605      */
4606     class BadConstructorReferenceError extends InvalidSymbolError {
4607 
4608         public BadConstructorReferenceError(Symbol sym) {
4609             super(MISSING_ENCL, sym, &quot;BadConstructorReferenceError&quot;);
4610         }
4611 
4612         @Override
4613         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4614            return diags.create(dkind, log.currentSource(), pos,
4615                 &quot;cant.access.inner.cls.constr&quot;, site.tsym.name, argtypes, site.getEnclosingType());
4616         }
4617     }
4618 
4619     class BadClassFileError extends InvalidSymbolError {
4620 
4621         private final CompletionFailure ex;
4622 
4623         public BadClassFileError(CompletionFailure ex) {
4624             super(HIDDEN, ex.sym, &quot;BadClassFileError&quot;);
4625             this.name = sym.name;
4626             this.ex = ex;
4627         }
4628 
4629         @Override
4630         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4631             JCDiagnostic d = diags.create(dkind, log.currentSource(), pos,
4632                 &quot;cant.access&quot;, ex.sym, ex.getDetailValue());
4633 
4634             d.setFlag(DiagnosticFlag.NON_DEFERRABLE);
4635             return d;
4636         }
4637 
4638     }
4639 
4640     /**
4641      * Helper class for method resolution diagnostic simplification.
4642      * Certain resolution diagnostic are rewritten as simpler diagnostic
4643      * where the enclosing resolution diagnostic (i.e. &#39;inapplicable method&#39;)
4644      * is stripped away, as it doesn&#39;t carry additional info. The logic
4645      * for matching a given diagnostic is given in terms of a template
4646      * hierarchy: a diagnostic template can be specified programmatically,
4647      * so that only certain diagnostics are matched. Each templete is then
4648      * associated with a rewriter object that carries out the task of rewtiting
4649      * the diagnostic to a simpler one.
4650      */
4651     static class MethodResolutionDiagHelper {
4652 
4653         /**
4654          * A diagnostic rewriter transforms a method resolution diagnostic
4655          * into a simpler one
4656          */
4657         interface DiagnosticRewriter {
4658             JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
4659                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
4660                     DiagnosticType preferredKind, JCDiagnostic d);
4661         }
4662 
4663         /**
4664          * A diagnostic template is made up of two ingredients: (i) a regular
4665          * expression for matching a diagnostic key and (ii) a list of sub-templates
4666          * for matching diagnostic arguments.
4667          */
4668         static class Template {
4669 
4670             /** regex used to match diag key */
4671             String regex;
4672 
4673             /** templates used to match diagnostic args */
4674             Template[] subTemplates;
4675 
4676             Template(String key, Template... subTemplates) {
4677                 this.regex = key;
4678                 this.subTemplates = subTemplates;
4679             }
4680 
4681             /**
4682              * Returns true if the regex matches the diagnostic key and if
4683              * all diagnostic arguments are matches by corresponding sub-templates.
4684              */
4685             boolean matches(Object o) {
4686                 JCDiagnostic d = (JCDiagnostic)o;
4687                 Object[] args = d.getArgs();
4688                 if (!d.getCode().matches(regex) ||
4689                         subTemplates.length != d.getArgs().length) {
4690                     return false;
4691                 }
4692                 for (int i = 0; i &lt; args.length ; i++) {
4693                     if (!subTemplates[i].matches(args[i])) {
4694                         return false;
4695                     }
4696                 }
4697                 return true;
4698             }
4699         }
4700 
4701         /**
4702          * Common rewriter for all argument mismatch simplifications.
4703          */
4704         static class ArgMismatchRewriter implements DiagnosticRewriter {
4705 
4706             /** the index of the subdiagnostic to be used as primary. */
4707             int causeIndex;
4708 
4709             public ArgMismatchRewriter(int causeIndex) {
4710                 this.causeIndex = causeIndex;
4711             }
4712 
4713             @Override
4714             public JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
4715                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
4716                     DiagnosticType preferredKind, JCDiagnostic d) {
4717                 JCDiagnostic cause = (JCDiagnostic)d.getArgs()[causeIndex];
4718                 DiagnosticPosition pos = d.getDiagnosticPosition();
4719                 if (pos == null) {
4720                     pos = preferredPos;
4721                 }
4722                 return diags.create(preferredKind, preferredSource, pos,
4723                         &quot;prob.found.req&quot;, cause);
4724             }
4725         }
4726 
4727         /** a dummy template that match any diagnostic argument */
4728         static final Template skip = new Template(&quot;&quot;) {
4729             @Override
4730             boolean matches(Object d) {
4731                 return true;
4732             }
4733         };
4734 
4735         /** template for matching inference-free arguments mismatch failures */
4736         static final Template argMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip);
4737 
4738         /** template for matching inference related arguments mismatch failures */
4739         static final Template inferArgMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip, skip) {
4740             @Override
4741             boolean matches(Object o) {
4742                 if (!super.matches(o)) {
4743                     return false;
4744                 }
4745                 JCDiagnostic d = (JCDiagnostic)o;
4746                 @SuppressWarnings(&quot;unchecked&quot;)
4747                 List&lt;Type&gt; tvars = (List&lt;Type&gt;)d.getArgs()[0];
4748                 return !containsAny(d, tvars);
4749             }
4750 
4751             BiPredicate&lt;Object, List&lt;Type&gt;&gt; containsPredicate = (o, ts) -&gt; {
4752                 if (o instanceof Type) {
4753                     return ((Type)o).containsAny(ts);
4754                 } else if (o instanceof JCDiagnostic) {
4755                     return containsAny((JCDiagnostic)o, ts);
4756                 } else {
4757                     return false;
4758                 }
4759             };
4760 
4761             boolean containsAny(JCDiagnostic d, List&lt;Type&gt; ts) {
4762                 return Stream.of(d.getArgs())
4763                         .anyMatch(o -&gt; containsPredicate.test(o, ts));
4764             }
4765         };
4766 
4767         /** rewriter map used for method resolution simplification */
4768         static final Map&lt;Template, DiagnosticRewriter&gt; rewriters = new LinkedHashMap&lt;&gt;();
4769 
4770         static {
4771             rewriters.put(argMismatchTemplate, new ArgMismatchRewriter(0));
4772             rewriters.put(inferArgMismatchTemplate, new ArgMismatchRewriter(1));
4773         }
4774 
4775         /**
4776          * Main entry point for diagnostic rewriting - given a diagnostic, see if any templates matches it,
4777          * and rewrite it accordingly.
4778          */
4779         static JCDiagnostic rewrite(JCDiagnostic.Factory diags, DiagnosticPosition pos, DiagnosticSource source,
4780                                     DiagnosticType dkind, JCDiagnostic d) {
4781             for (Map.Entry&lt;Template, DiagnosticRewriter&gt; _entry : rewriters.entrySet()) {
4782                 if (_entry.getKey().matches(d)) {
4783                     JCDiagnostic simpleDiag =
4784                             _entry.getValue().rewriteDiagnostic(diags, pos, source, dkind, d);
4785                     simpleDiag.setFlag(DiagnosticFlag.COMPRESSED);
4786                     return simpleDiag;
4787                 }
4788             }
4789             return null;
4790         }
4791     }
4792 
4793     enum MethodResolutionPhase {
4794         BASIC(false, false),
4795         BOX(true, false),
4796         VARARITY(true, true) {
4797             @Override
4798             public Symbol mergeResults(Symbol bestSoFar, Symbol sym) {
4799                 //Check invariants (see {@code LookupHelper.shouldStop})
4800                 Assert.check(bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS);
4801                 if (!sym.kind.isResolutionError()) {
4802                     //varargs resolution successful
4803                     return sym;
4804                 } else {
4805                     //pick best error
4806                     switch (bestSoFar.kind) {
4807                         case WRONG_MTH:
4808                         case WRONG_MTHS:
4809                             //Override previous errors if they were caused by argument mismatch.
4810                             //This generally means preferring current symbols - but we need to pay
4811                             //attention to the fact that the varargs lookup returns &#39;less&#39; candidates
4812                             //than the previous rounds, and adjust that accordingly.
4813                             switch (sym.kind) {
4814                                 case WRONG_MTH:
4815                                     //if the previous round matched more than one method, return that
4816                                     //result instead
4817                                     return bestSoFar.kind == WRONG_MTHS ?
4818                                             bestSoFar : sym;
4819                                 case ABSENT_MTH:
4820                                     //do not override erroneous symbol if the arity lookup did not
4821                                     //match any method
4822                                     return bestSoFar;
4823                                 case WRONG_MTHS:
4824                                 default:
4825                                     //safe to override
4826                                     return sym;
4827                             }
4828                         default:
4829                             //otherwise, return first error
4830                             return bestSoFar;
4831                     }
4832                 }
4833             }
4834         };
4835 
4836         final boolean isBoxingRequired;
4837         final boolean isVarargsRequired;
4838 
4839         MethodResolutionPhase(boolean isBoxingRequired, boolean isVarargsRequired) {
4840            this.isBoxingRequired = isBoxingRequired;
4841            this.isVarargsRequired = isVarargsRequired;
4842         }
4843 
4844         public boolean isBoxingRequired() {
4845             return isBoxingRequired;
4846         }
4847 
4848         public boolean isVarargsRequired() {
4849             return isVarargsRequired;
4850         }
4851 
4852         public Symbol mergeResults(Symbol prev, Symbol sym) {
4853             return sym;
4854         }
4855     }
4856 
4857     final List&lt;MethodResolutionPhase&gt; methodResolutionSteps = List.of(BASIC, BOX, VARARITY);
4858 
4859     /**
4860      * A resolution context is used to keep track of intermediate results of
4861      * overload resolution, such as list of method that are not applicable
4862      * (used to generate more precise diagnostics) and so on. Resolution contexts
4863      * can be nested - this means that when each overload resolution routine should
4864      * work within the resolution context it created.
4865      */
4866     class MethodResolutionContext {
4867 
4868         private List&lt;Candidate&gt; candidates = List.nil();
4869 
4870         MethodResolutionPhase step = null;
4871 
4872         MethodCheck methodCheck = resolveMethodCheck;
4873 
4874         private boolean internalResolution = false;
4875         private DeferredAttr.AttrMode attrMode = DeferredAttr.AttrMode.SPECULATIVE;
4876 
4877         void addInapplicableCandidate(Symbol sym, JCDiagnostic details) {
4878             Candidate c = new Candidate(currentResolutionContext.step, sym, details, null);
4879             candidates = candidates.append(c);
4880         }
4881 
4882         void addApplicableCandidate(Symbol sym, Type mtype) {
4883             Candidate c = new Candidate(currentResolutionContext.step, sym, null, mtype);
4884             candidates = candidates.append(c);
4885         }
4886 
4887         DeferredAttrContext deferredAttrContext(Symbol sym, InferenceContext inferenceContext, ResultInfo pendingResult, Warner warn) {
4888             DeferredAttrContext parent = (pendingResult == null)
4889                 ? deferredAttr.emptyDeferredAttrContext
4890                 : pendingResult.checkContext.deferredAttrContext();
4891             return deferredAttr.new DeferredAttrContext(attrMode, sym, step,
4892                     inferenceContext, parent, warn);
4893         }
4894 
4895         /**
4896          * This class represents an overload resolution candidate. There are two
4897          * kinds of candidates: applicable methods and inapplicable methods;
4898          * applicable methods have a pointer to the instantiated method type,
4899          * while inapplicable candidates contain further details about the
4900          * reason why the method has been considered inapplicable.
4901          */
4902         @SuppressWarnings(&quot;overrides&quot;)
4903         class Candidate {
4904 
4905             final MethodResolutionPhase step;
4906             final Symbol sym;
4907             final JCDiagnostic details;
4908             final Type mtype;
4909 
4910             private Candidate(MethodResolutionPhase step, Symbol sym, JCDiagnostic details, Type mtype) {
4911                 this.step = step;
4912                 this.sym = sym;
4913                 this.details = details;
4914                 this.mtype = mtype;
4915             }
4916 
4917             boolean isApplicable() {
4918                 return mtype != null;
4919             }
4920         }
4921 
4922         DeferredAttr.AttrMode attrMode() {
4923             return attrMode;
4924         }
4925 
4926         boolean internal() {
4927             return internalResolution;
4928         }
4929     }
4930 
4931     MethodResolutionContext currentResolutionContext = null;
4932 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>