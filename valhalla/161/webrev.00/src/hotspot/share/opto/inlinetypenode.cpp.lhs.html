<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/inlinetypenode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciInlineKlass.hpp&quot;
 27 #include &quot;opto/addnode.hpp&quot;
 28 #include &quot;opto/castnode.hpp&quot;
 29 #include &quot;opto/graphKit.hpp&quot;
 30 #include &quot;opto/inlinetypenode.hpp&quot;
 31 #include &quot;opto/rootnode.hpp&quot;
 32 #include &quot;opto/phaseX.hpp&quot;
 33 
 34 // Clones the inline type to handle control flow merges involving multiple inline types.
 35 // The inputs are replaced by PhiNodes to represent the merged values for the given region.
 36 InlineTypeBaseNode* InlineTypeBaseNode::clone_with_phis(PhaseGVN* gvn, Node* region) {
<a name="1" id="anc1"></a><span class="line-removed"> 37   assert(!has_phi_inputs(region), &quot;already cloned with phis&quot;);</span>
 38   InlineTypeBaseNode* vt = clone()-&gt;as_InlineTypeBase();
 39 
 40   // Create a PhiNode for merging the oop values
 41   const Type* phi_type = Type::get_const_type(inline_klass());
 42   PhiNode* oop = PhiNode::make(region, vt-&gt;get_oop(), phi_type);
 43   gvn-&gt;set_type(oop, phi_type);
 44   vt-&gt;set_oop(oop);
 45 
 46   // Create a PhiNode each for merging the field values
 47   for (uint i = 0; i &lt; vt-&gt;field_count(); ++i) {
 48     ciType* type = vt-&gt;field_type(i);
 49     Node*  value = vt-&gt;field_value(i);
 50     if (value-&gt;is_InlineTypeBase()) {
 51       // Handle flattened inline type fields recursively
 52       value = value-&gt;as_InlineTypeBase()-&gt;clone_with_phis(gvn, region);
 53     } else {
 54       phi_type = Type::get_const_type(type);
 55       value = PhiNode::make(region, value, phi_type);
 56       gvn-&gt;set_type(value, phi_type);
 57     }
 58     vt-&gt;set_field_value(i, value);
 59   }
 60   gvn-&gt;set_type(vt, vt-&gt;bottom_type());
 61   return vt;
 62 }
 63 
 64 // Checks if the inputs of the InlineTypeBaseTypeNode were replaced by PhiNodes
 65 // for the given region (see InlineTypeBaseTypeNode::clone_with_phis).
 66 bool InlineTypeBaseNode::has_phi_inputs(Node* region) {
 67   // Check oop input
 68   bool result = get_oop()-&gt;is_Phi() &amp;&amp; get_oop()-&gt;as_Phi()-&gt;region() == region;
 69 #ifdef ASSERT
 70   if (result) {
 71     // Check all field value inputs for consistency
 72     for (uint i = Oop; i &lt; field_count(); ++i) {
 73       Node* n = in(i);
 74       if (n-&gt;is_InlineTypeBase()) {
 75         assert(n-&gt;as_InlineTypeBase()-&gt;has_phi_inputs(region), &quot;inconsistent phi inputs&quot;);
 76       } else {
 77         assert(n-&gt;is_Phi() &amp;&amp; n-&gt;as_Phi()-&gt;region() == region, &quot;inconsistent phi inputs&quot;);
 78       }
 79     }
 80   }
 81 #endif
 82   return result;
 83 }
 84 
 85 // Merges &#39;this&#39; with &#39;other&#39; by updating the input PhiNodes added by &#39;clone_with_phis&#39;
 86 InlineTypeBaseNode* InlineTypeBaseNode::merge_with(PhaseGVN* gvn, const InlineTypeBaseNode* other, int pnum, bool transform) {
 87   // Merge oop inputs
 88   PhiNode* phi = get_oop()-&gt;as_Phi();
 89   phi-&gt;set_req(pnum, other-&gt;get_oop());
 90   if (transform) {
 91     set_oop(gvn-&gt;transform(phi));
 92     gvn-&gt;record_for_igvn(phi);
 93   }
 94   // Merge field values
 95   for (uint i = 0; i &lt; field_count(); ++i) {
 96     Node* val1 =        field_value(i);
 97     Node* val2 = other-&gt;field_value(i);
 98     if (val1-&gt;is_InlineTypeBase()) {
 99       val1-&gt;as_InlineTypeBase()-&gt;merge_with(gvn, val2-&gt;as_InlineTypeBase(), pnum, transform);
100     } else {
101       assert(val1-&gt;is_Phi(), &quot;must be a phi node&quot;);
102       val1-&gt;set_req(pnum, val2);
103     }
104     if (transform) {
105       set_field_value(i, gvn-&gt;transform(val1));
106       gvn-&gt;record_for_igvn(val1);
107     }
108   }
109   return this;
110 }
111 
112 // Adds a new merge path to an inline type node with phi inputs
113 void InlineTypeBaseNode::add_new_path(Node* region) {
114   assert(has_phi_inputs(region), &quot;must have phi inputs&quot;);
115 
116   PhiNode* phi = get_oop()-&gt;as_Phi();
117   phi-&gt;add_req(NULL);
118   assert(phi-&gt;req() == region-&gt;req(), &quot;must be same size as region&quot;);
119 
120   for (uint i = 0; i &lt; field_count(); ++i) {
121     Node* val = field_value(i);
122     if (val-&gt;is_InlineType()) {
123       val-&gt;as_InlineType()-&gt;add_new_path(region);
124     } else {
125       val-&gt;as_Phi()-&gt;add_req(NULL);
126       assert(val-&gt;req() == region-&gt;req(), &quot;must be same size as region&quot;);
127     }
128   }
129 }
130 
131 Node* InlineTypeBaseNode::field_value(uint index) const {
132   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
133   return in(Values + index);
134 }
135 
136 // Get the value of the field at the given offset.
137 // If &#39;recursive&#39; is true, flattened inline type fields will be resolved recursively.
138 Node* InlineTypeBaseNode::field_value_by_offset(int offset, bool recursive) const {
139   // If the field at &#39;offset&#39; belongs to a flattened inline type field, &#39;index&#39; refers to the
140   // corresponding InlineTypeNode input and &#39;sub_offset&#39; is the offset in flattened inline type.
141   int index = inline_klass()-&gt;field_index_by_offset(offset);
142   int sub_offset = offset - field_offset(index);
143   Node* value = field_value(index);
144   assert(value != NULL, &quot;field value not found&quot;);
145   if (recursive &amp;&amp; value-&gt;is_InlineType()) {
146     InlineTypeNode* vt = value-&gt;as_InlineType();
147     if (field_is_flattened(index)) {
148       // Flattened inline type field
149       sub_offset += vt-&gt;inline_klass()-&gt;first_field_offset(); // Add header size
150       return vt-&gt;field_value_by_offset(sub_offset, recursive);
151     } else {
152       assert(sub_offset == 0, &quot;should not have a sub offset&quot;);
153       return vt;
154     }
155   }
156   assert(!(recursive &amp;&amp; value-&gt;is_InlineType()), &quot;should not be an inline type&quot;);
157   assert(sub_offset == 0, &quot;offset mismatch&quot;);
158   return value;
159 }
160 
161 void InlineTypeBaseNode::set_field_value(uint index, Node* value) {
162   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
163   set_req(Values + index, value);
164 }
165 
166 void InlineTypeBaseNode::set_field_value_by_offset(int offset, Node* value) {
167   set_field_value(field_index(offset), value);
168 }
169 
170 int InlineTypeBaseNode::field_offset(uint index) const {
171   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
172   return inline_klass()-&gt;declared_nonstatic_field_at(index)-&gt;offset();
173 }
174 
175 uint InlineTypeBaseNode::field_index(int offset) const {
176   uint i = 0;
177   for (; i &lt; field_count() &amp;&amp; field_offset(i) != offset; i++) { }
178   assert(i &lt; field_count(), &quot;field not found&quot;);
179   return i;
180 }
181 
182 ciType* InlineTypeBaseNode::field_type(uint index) const {
183   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
184   return inline_klass()-&gt;declared_nonstatic_field_at(index)-&gt;type();
185 }
186 
187 bool InlineTypeBaseNode::field_is_flattened(uint index) const {
188   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
189   ciField* field = inline_klass()-&gt;declared_nonstatic_field_at(index);
190   assert(!field-&gt;is_flattened() || field-&gt;type()-&gt;is_inlinetype(), &quot;must be an inline type&quot;);
191   return field-&gt;is_flattened();
192 }
193 
194 int InlineTypeBaseNode::make_scalar_in_safepoint(PhaseIterGVN* igvn, Unique_Node_List&amp; worklist, SafePointNode* sfpt) {
195   ciInlineKlass* vk = inline_klass();
196   uint nfields = vk-&gt;nof_nonstatic_fields();
197   JVMState* jvms = sfpt-&gt;jvms();
198   int start = jvms-&gt;debug_start();
199   int end   = jvms-&gt;debug_end();
200   // Replace safepoint edge by SafePointScalarObjectNode and add field values
201   assert(jvms != NULL, &quot;missing JVMS&quot;);
202   uint first_ind = (sfpt-&gt;req() - jvms-&gt;scloff());
203   SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(inline_ptr(),
204 #ifdef ASSERT
205                                                                   NULL,
206 #endif
207                                                                   first_ind, nfields);
208   sobj-&gt;init_req(0, igvn-&gt;C-&gt;root());
209   // Iterate over the inline type fields in order of increasing
210   // offset and add the field values to the safepoint.
211   for (uint j = 0; j &lt; nfields; ++j) {
212     int offset = vk-&gt;nonstatic_field_at(j)-&gt;offset();
213     Node* value = field_value_by_offset(offset, true /* include flattened inline type fields */);
214     if (value-&gt;is_InlineType()) {
215       // Add inline type field to the worklist to process later
216       worklist.push(value);
217     }
218     sfpt-&gt;add_req(value);
219   }
220   jvms-&gt;set_endoff(sfpt-&gt;req());
221   sobj = igvn-&gt;transform(sobj)-&gt;as_SafePointScalarObject();
222   igvn-&gt;rehash_node_delayed(sfpt);
223   return sfpt-&gt;replace_edges_in_range(this, sobj, start, end);
224 }
225 
226 void InlineTypeBaseNode::make_scalar_in_safepoints(PhaseIterGVN* igvn) {
227   // Process all safepoint uses and scalarize inline type
228   Unique_Node_List worklist;
229   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
230     SafePointNode* sfpt = fast_out(i)-&gt;isa_SafePoint();
231     if (sfpt != NULL &amp;&amp; !sfpt-&gt;is_CallLeaf() &amp;&amp; (!sfpt-&gt;is_Call() || sfpt-&gt;as_Call()-&gt;has_debug_use(this))) {
232       int nb = 0;
233       if (is_allocated(igvn) &amp;&amp; get_oop()-&gt;is_Con()) {
234         // Inline type is allocated with a constant oop, link it directly
235         nb = sfpt-&gt;replace_edges_in_range(this, get_oop(), sfpt-&gt;jvms()-&gt;debug_start(), sfpt-&gt;jvms()-&gt;debug_end());
236         igvn-&gt;rehash_node_delayed(sfpt);
237       } else {
238         nb = make_scalar_in_safepoint(igvn, worklist, sfpt);
239       }
240       --i; imax -= nb;
241     }
242   }
243   // Now scalarize non-flattened fields
244   for (uint i = 0; i &lt; worklist.size(); ++i) {
245     Node* vt = worklist.at(i);
246     vt-&gt;as_InlineType()-&gt;make_scalar_in_safepoints(igvn);
247   }
248   igvn-&gt;record_for_igvn(this);
249 }
250 
251 const TypePtr* InlineTypeBaseNode::field_adr_type(Node* base, int offset, ciInstanceKlass* holder, DecoratorSet decorators, PhaseGVN&amp; gvn) const {
252   const TypeAryPtr* ary_type = gvn.type(base)-&gt;isa_aryptr();
253   const TypePtr* adr_type = NULL;
254   bool is_array = ary_type != NULL;
255   if ((decorators &amp; C2_MISMATCHED) != 0) {
256     adr_type = TypeRawPtr::BOTTOM;
257   } else if (is_array) {
258     // In the case of a flattened inline type array, each field has its own slice
259     adr_type = ary_type-&gt;with_field_offset(offset)-&gt;add_offset(Type::OffsetBot);
260   } else {
261     ciField* field = holder-&gt;get_field_by_offset(offset, false);
262     assert(field != NULL, &quot;field not found&quot;);
263     adr_type = gvn.C-&gt;alias_type(field)-&gt;adr_type();
264   }
265   return adr_type;
266 }
267 
268 void InlineTypeBaseNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
269   // Initialize the inline type by loading its field values from
270   // memory and adding the values as input edges to the node.
271   for (uint i = 0; i &lt; field_count(); ++i) {
272     int offset = holder_offset + field_offset(i);
273     Node* value = NULL;
274     ciType* ft = field_type(i);
275     if (field_is_flattened(i)) {
276       // Recursively load the flattened inline type field
277       value = InlineTypeNode::make_from_flattened(kit, ft-&gt;as_inline_klass(), base, ptr, holder, offset, decorators);
278     } else {
279       const TypeOopPtr* oop_ptr = kit-&gt;gvn().type(base)-&gt;isa_oopptr();
280       bool is_array = (oop_ptr-&gt;isa_aryptr() != NULL);
281       if (base-&gt;is_Con() &amp;&amp; !is_array) {
282         // If the oop to the inline type is constant (static final field), we can
283         // also treat the fields as constants because the inline type is immutable.
284         ciObject* constant_oop = oop_ptr-&gt;const_oop();
285         ciField* field = holder-&gt;get_field_by_offset(offset, false);
286         assert(field != NULL, &quot;field not found&quot;);
287         ciConstant constant = constant_oop-&gt;as_instance()-&gt;field_value(field);
288         const Type* con_type = Type::make_from_constant(constant, /*require_const=*/ true);
289         assert(con_type != NULL, &quot;type not found&quot;);
290         value = kit-&gt;gvn().transform(kit-&gt;makecon(con_type));
291         // Check type of constant which might be more precise than the static field type
292         if (con_type-&gt;is_inlinetypeptr()) {
293           assert(!con_type-&gt;is_zero_type(), &quot;Inline types are null-free&quot;);
294           ft = con_type-&gt;inline_klass();
295         }
296       } else {
297         // Load field value from memory
298         const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
299         Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
300         BasicType bt = type2field[ft-&gt;basic_type()];
301         assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
302         const Type* val_type = Type::get_const_type(ft);
303         if (is_array) {
304           decorators |= IS_ARRAY;
305         }
306         value = kit-&gt;access_load_at(base, adr, adr_type, val_type, bt, decorators);
307       }
308       if (ft-&gt;is_inlinetype()) {
309         // Loading a non-flattened inline type from memory
310         if (ft-&gt;as_inline_klass()-&gt;is_scalarizable()) {
311           value = InlineTypeNode::make_from_oop(kit, value, ft-&gt;as_inline_klass());
312         } else {
313           value = kit-&gt;null2default(value, ft-&gt;as_inline_klass());
314         }
315       }
316     }
317     set_field_value(i, value);
318   }
319 }
320 
321 void InlineTypeBaseNode::store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {
322   // The inline type is embedded into the object without an oop header. Subtract the
323   // offset of the first field to account for the missing header when storing the values.
324   if (holder == NULL) {
325     holder = inline_klass();
326   }
327   holder_offset -= inline_klass()-&gt;first_field_offset();
328   store(kit, base, ptr, holder, holder_offset, decorators);
329 }
330 
331 void InlineTypeBaseNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {
332   // Write field values to memory
333   for (uint i = 0; i &lt; field_count(); ++i) {
334     int offset = holder_offset + field_offset(i);
335     Node* value = field_value(i);
336     ciType* ft = field_type(i);
337     if (field_is_flattened(i)) {
338       // Recursively store the flattened inline type field
339       if (!value-&gt;is_InlineType()) {
340         assert(!kit-&gt;gvn().type(value)-&gt;maybe_null(), &quot;Inline types are null-free&quot;);
341         value = InlineTypeNode::make_from_oop(kit, value, ft-&gt;as_inline_klass());
342       }
343       value-&gt;as_InlineType()-&gt;store_flattened(kit, base, ptr, holder, offset, decorators);
344     } else {
345       // Store field value to memory
346       const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
347       Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
348       BasicType bt = type2field[ft-&gt;basic_type()];
349       assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
350       const Type* val_type = Type::get_const_type(ft);
351       const TypeAryPtr* ary_type = kit-&gt;gvn().type(base)-&gt;isa_aryptr();
352       if (ary_type != NULL) {
353         decorators |= IS_ARRAY;
354       }
355       kit-&gt;access_store_at(base, adr, adr_type, value, val_type, bt, decorators);
356     }
357   }
358 }
359 
360 InlineTypePtrNode* InlineTypeBaseNode::buffer(GraphKit* kit, bool safe_for_replace) {
361   assert(is_InlineType(), &quot;sanity&quot;);
362   // Check if inline type is already allocated
363   Node* null_ctl = kit-&gt;top();
364   Node* not_null_oop = kit-&gt;null_check_oop(get_oop(), &amp;null_ctl);
365   if (null_ctl-&gt;is_top()) {
366     // Inline type is allocated
367     return as_ptr(&amp;kit-&gt;gvn());
368   }
369   assert(!is_allocated(&amp;kit-&gt;gvn()), &quot;should not be allocated&quot;);
370   RegionNode* region = new RegionNode(3);
371 
372   // Oop is non-NULL, use it
373   region-&gt;init_req(1, kit-&gt;control());
374   PhiNode* oop = PhiNode::make(region, not_null_oop, inline_ptr());
375   PhiNode* io  = PhiNode::make(region, kit-&gt;i_o(), Type::ABIO);
376   PhiNode* mem = PhiNode::make(region, kit-&gt;merged_memory(), Type::MEMORY, TypePtr::BOTTOM);
377 
378   int bci = kit-&gt;bci();
379   bool reexecute = kit-&gt;jvms()-&gt;should_reexecute();
380   {
381     // Oop is NULL, allocate and initialize buffer
382     PreserveJVMState pjvms(kit);
383     // Propagate re-execution state and bci
384     kit-&gt;set_bci(bci);
385     kit-&gt;jvms()-&gt;set_bci(bci);
386     kit-&gt;jvms()-&gt;set_should_reexecute(reexecute);
387     kit-&gt;set_control(null_ctl);
388     kit-&gt;kill_dead_locals();
389     ciInlineKlass* vk = inline_klass();
390     Node* klass_node = kit-&gt;makecon(TypeKlassPtr::make(vk));
391     Node* alloc_oop  = kit-&gt;new_instance(klass_node, NULL, NULL, /* deoptimize_on_exception */ true, this);
392     store(kit, alloc_oop, alloc_oop, vk, 0);
393 
394     // Do not let stores that initialize this buffer be reordered with a subsequent
395     // store that would make this buffer accessible by other threads.
396     AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop, &amp;kit-&gt;gvn());
397     assert(alloc != NULL, &quot;must have an allocation node&quot;);
398     kit-&gt;insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
399 
400     region-&gt;init_req(2, kit-&gt;control());
401     oop   -&gt;init_req(2, alloc_oop);
402     io    -&gt;init_req(2, kit-&gt;i_o());
403     mem   -&gt;init_req(2, kit-&gt;merged_memory());
404   }
405 
406   // Update GraphKit
407   kit-&gt;set_control(kit-&gt;gvn().transform(region));
408   kit-&gt;set_i_o(kit-&gt;gvn().transform(io));
409   kit-&gt;set_all_memory(kit-&gt;gvn().transform(mem));
410   kit-&gt;record_for_igvn(region);
411   kit-&gt;record_for_igvn(oop);
412   kit-&gt;record_for_igvn(io);
413   kit-&gt;record_for_igvn(mem);
414 
415   // Use cloned InlineTypeNode to propagate oop from now on
416   Node* res_oop = kit-&gt;gvn().transform(oop);
417   InlineTypeBaseNode* vt = clone()-&gt;as_InlineTypeBase();
418   vt-&gt;set_oop(res_oop);
419   vt = kit-&gt;gvn().transform(vt)-&gt;as_InlineTypeBase();
420   if (safe_for_replace) {
421     kit-&gt;replace_in_map(this, vt);
422   }
423   // InlineTypeNode::remove_redundant_allocations piggybacks on split if.
424   // Make sure it gets a chance to remove this allocation.
425   kit-&gt;C-&gt;set_has_split_ifs(true);
426   return vt-&gt;as_ptr(&amp;kit-&gt;gvn());
427 }
428 
429 bool InlineTypeBaseNode::is_allocated(PhaseGVN* phase) const {
430   Node* oop = get_oop();
431   const Type* oop_type = (phase != NULL) ? phase-&gt;type(oop) : oop-&gt;bottom_type();
432   return !oop_type-&gt;maybe_null();
433 }
434 
435 InlineTypePtrNode* InlineTypeBaseNode::as_ptr(PhaseGVN* phase) const {
436   assert(is_allocated(phase), &quot;must be allocated&quot;);
437   if (is_InlineTypePtr()) {
438     return as_InlineTypePtr();
439   }
440   return phase-&gt;transform(new InlineTypePtrNode(this))-&gt;as_InlineTypePtr();
441 }
442 
443 // When a call returns multiple values, it has several result
444 // projections, one per field. Replacing the result of the call by a
445 // inline type node (after late inlining) requires that for each result
446 // projection, we find the corresponding inline type field.
447 void InlineTypeBaseNode::replace_call_results(GraphKit* kit, Node* call, Compile* C) {
448   ciInlineKlass* vk = inline_klass();
449   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
450     ProjNode* pn = call-&gt;fast_out(i)-&gt;as_Proj();
451     uint con = pn-&gt;_con;
452     if (con &gt;= TypeFunc::Parms+1) {
453       uint field_nb = con - (TypeFunc::Parms+1);
454       int extra = 0;
455       for (uint j = 0; j &lt; field_nb - extra; j++) {
456         ciField* f = vk-&gt;nonstatic_field_at(j);
457         BasicType bt = f-&gt;type()-&gt;basic_type();
458         if (bt == T_LONG || bt == T_DOUBLE) {
459           extra++;
460         }
461       }
462       ciField* f = vk-&gt;nonstatic_field_at(field_nb - extra);
463       Node* field = field_value_by_offset(f-&gt;offset(), true);
464       if (field-&gt;is_InlineType()) {
465         assert(field-&gt;as_InlineType()-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
466         field = field-&gt;as_InlineType()-&gt;get_oop();
467       }
468       C-&gt;gvn_replace_by(pn, field);
469       C-&gt;initial_gvn()-&gt;hash_delete(pn);
470       pn-&gt;set_req(0, C-&gt;top());
471       --i; --imax;
472     }
473   }
474 }
475 
476 Node* InlineTypeBaseNode::allocate_fields(GraphKit* kit) {
477   InlineTypeBaseNode* vt = clone()-&gt;as_InlineTypeBase();
478   for (uint i = 0; i &lt; field_count(); i++) {
479      InlineTypeNode* value = field_value(i)-&gt;isa_InlineType();
480      if (field_is_flattened(i)) {
481        // Flattened inline type field
482        vt-&gt;set_field_value(i, value-&gt;allocate_fields(kit));
483      } else if (value != NULL) {
484        // Non-flattened inline type field
485        vt-&gt;set_field_value(i, value-&gt;buffer(kit));
486      }
487   }
488   vt = kit-&gt;gvn().transform(vt)-&gt;as_InlineTypeBase();
489   kit-&gt;replace_in_map(this, vt);
490   return vt;
491 }
492 
493 InlineTypeNode* InlineTypeNode::make_uninitialized(PhaseGVN&amp; gvn, ciInlineKlass* vk) {
494   // Create a new InlineTypeNode with uninitialized values and NULL oop
495   Node* oop = vk-&gt;is_empty() ? default_oop(gvn, vk) : gvn.zerocon(T_INLINE_TYPE);
496   return new InlineTypeNode(vk, oop);
497 }
498 
499 Node* InlineTypeNode::default_oop(PhaseGVN&amp; gvn, ciInlineKlass* vk) {
500   // Returns the constant oop of the default inline type allocation
501   return gvn.makecon(TypeInstPtr::make(vk-&gt;default_instance()));
502 }
503 
504 InlineTypeNode* InlineTypeNode::make_default(PhaseGVN&amp; gvn, ciInlineKlass* vk) {
505   // Create a new InlineTypeNode with default values
506   InlineTypeNode* vt = new InlineTypeNode(vk, default_oop(gvn, vk));
507   for (uint i = 0; i &lt; vt-&gt;field_count(); ++i) {
508     ciType* field_type = vt-&gt;field_type(i);
509     Node* value = NULL;
510     if (field_type-&gt;is_inlinetype()) {
511       ciInlineKlass* field_klass = field_type-&gt;as_inline_klass();
512       if (field_klass-&gt;is_scalarizable()) {
513         value = InlineTypeNode::make_default(gvn, field_klass);
514       } else {
515         value = default_oop(gvn, field_klass);
516       }
517     } else {
518       value = gvn.zerocon(field_type-&gt;basic_type());
519     }
520     vt-&gt;set_field_value(i, value);
521   }
522   vt = gvn.transform(vt)-&gt;as_InlineType();
523   assert(vt-&gt;is_default(&amp;gvn), &quot;must be the default inline type&quot;);
524   return vt;
525 }
526 
527 bool InlineTypeNode::is_default(PhaseGVN* gvn) const {
528   for (uint i = 0; i &lt; field_count(); ++i) {
529     Node* value = field_value(i);
530     if (!gvn-&gt;type(value)-&gt;is_zero_type() &amp;&amp;
531         !(value-&gt;is_InlineType() &amp;&amp; value-&gt;as_InlineType()-&gt;is_default(gvn)) &amp;&amp;
532         !(field_type(i)-&gt;is_inlinetype() &amp;&amp; value == default_oop(*gvn, field_type(i)-&gt;as_inline_klass()))) {
533       return false;
534     }
535   }
536   return true;
537 }
538 
539 InlineTypeNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk) {
540   PhaseGVN&amp; gvn = kit-&gt;gvn();
541 
542   // Create and initialize an InlineTypeNode by loading all field
543   // values from a heap-allocated version and also save the oop.
544   InlineTypeNode* vt = new InlineTypeNode(vk, oop);
545 
546   if (oop-&gt;isa_InlineTypePtr()) {
547     // Can happen with late inlining
548     InlineTypePtrNode* vtptr = oop-&gt;as_InlineTypePtr();
549     vt-&gt;set_oop(vtptr-&gt;get_oop());
550     for (uint i = Oop+1; i &lt; vtptr-&gt;req(); ++i) {
551       vt-&gt;init_req(i, vtptr-&gt;in(i));
552     }
553   } else if (gvn.type(oop)-&gt;maybe_null()) {
554     // Add a null check because the oop may be null
555     Node* null_ctl = kit-&gt;top();
556     Node* not_null_oop = kit-&gt;null_check_oop(oop, &amp;null_ctl);
557     if (kit-&gt;stopped()) {
558       // Constant null
559       kit-&gt;set_control(null_ctl);
560       return make_default(gvn, vk);
561     }
562     vt-&gt;set_oop(not_null_oop);
563     vt-&gt;load(kit, not_null_oop, not_null_oop, vk, /* holder_offset */ 0);
564 
565     if (null_ctl != kit-&gt;top()) {
566       // Return default inline type if oop is null
567       InlineTypeNode* def = make_default(gvn, vk);
568       Node* region = new RegionNode(3);
569       region-&gt;init_req(1, kit-&gt;control());
570       region-&gt;init_req(2, null_ctl);
571 
572       vt = vt-&gt;clone_with_phis(&amp;gvn, region)-&gt;as_InlineType();
573       vt-&gt;merge_with(&amp;gvn, def, 2, true);
574       kit-&gt;set_control(gvn.transform(region));
575     }
576   } else {
577     // Oop can never be null
578     Node* init_ctl = kit-&gt;control();
579     vt-&gt;load(kit, oop, oop, vk, /* holder_offset */ 0);
580     assert(init_ctl != kit-&gt;control() || !gvn.type(oop)-&gt;is_inlinetypeptr() || oop-&gt;is_Con() || oop-&gt;Opcode() == Op_InlineTypePtr ||
581            AllocateNode::Ideal_allocation(oop, &amp;gvn) != NULL || vt-&gt;is_loaded(&amp;gvn) == oop, &quot;inline type should be loaded&quot;);
582   }
583 
584   assert(vt-&gt;is_allocated(&amp;gvn), &quot;inline type should be allocated&quot;);
585   return gvn.transform(vt)-&gt;as_InlineType();
586 }
587 
588 // GraphKit wrapper for the &#39;make_from_flattened&#39; method
589 InlineTypeNode* InlineTypeNode::make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
590   // Create and initialize an InlineTypeNode by loading all field values from
591   // a flattened inline type field at &#39;holder_offset&#39; or from an inline type array.
592   InlineTypeNode* vt = make_uninitialized(kit-&gt;gvn(), vk);
593   // The inline type is flattened into the object without an oop header. Subtract the
594   // offset of the first field to account for the missing header when loading the values.
595   holder_offset -= vk-&gt;first_field_offset();
596   vt-&gt;load(kit, obj, ptr, holder, holder_offset, decorators);
597   assert(vt-&gt;is_loaded(&amp;kit-&gt;gvn()) != obj, &quot;holder oop should not be used as flattened inline type oop&quot;);
598   return kit-&gt;gvn().transform(vt)-&gt;as_InlineType();
599 }
600 
601 InlineTypeNode* InlineTypeNode::make_from_multi(GraphKit* kit, MultiNode* multi, ExtendedSignature&amp; sig, ciInlineKlass* vk, uint&amp; base_input, bool in) {
602   InlineTypeNode* vt = InlineTypeNode::make_uninitialized(kit-&gt;gvn(), vk);
603   vt-&gt;initialize_fields(kit, multi, sig, base_input, 0, in);
604   return kit-&gt;gvn().transform(vt)-&gt;as_InlineType();
605 }
606 
607 InlineTypeNode* InlineTypeNode::make_larval(GraphKit* kit, bool allocate) const {
608   ciInlineKlass* vk = inline_klass();
609   InlineTypeNode* res = clone()-&gt;as_InlineType();
610   if (allocate) {
611     // Re-execute if buffering triggers deoptimization
612     PreserveReexecuteState preexecs(kit);
613     kit-&gt;jvms()-&gt;set_should_reexecute(true);
614     Node* klass_node = kit-&gt;makecon(TypeKlassPtr::make(vk));
615     Node* alloc_oop  = kit-&gt;new_instance(klass_node, NULL, NULL, true);
616     AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop, &amp;kit-&gt;gvn());
617     alloc-&gt;_larval = true;
618 
619     store(kit, alloc_oop, alloc_oop, vk, 0);
620     res-&gt;set_oop(alloc_oop);
621   }
622   res-&gt;set_type(TypeInlineType::make(vk, true));
623   res = kit-&gt;gvn().transform(res)-&gt;as_InlineType();
624   assert(!allocate || res-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
625   return res;
626 }
627 
628 InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit) const {
629   Node* obj = get_oop();
630   Node* mark_addr = kit-&gt;basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
631   Node* mark = kit-&gt;make_load(NULL, mark_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
632   mark = kit-&gt;gvn().transform(new AndXNode(mark, kit-&gt;MakeConX(~markWord::larval_mask_in_place)));
633   kit-&gt;store_to_memory(kit-&gt;control(), mark_addr, mark, TypeX_X-&gt;basic_type(), kit-&gt;gvn().type(mark_addr)-&gt;is_ptr(), MemNode::unordered);
634 
635   // Do not let stores that initialize this buffer be reordered with a subsequent
636   // store that would make this buffer accessible by other threads.
637   AllocateNode* alloc = AllocateNode::Ideal_allocation(obj, &amp;kit-&gt;gvn());
638   assert(alloc != NULL, &quot;must have an allocation node&quot;);
639   kit-&gt;insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
640 
641   ciInlineKlass* vk = inline_klass();
642   InlineTypeNode* res = clone()-&gt;as_InlineType();
643   res-&gt;set_type(TypeInlineType::make(vk, false));
644   res = kit-&gt;gvn().transform(res)-&gt;as_InlineType();
645   return res;
646 }
647 
648 Node* InlineTypeNode::is_loaded(PhaseGVN* phase, ciInlineKlass* vk, Node* base, int holder_offset) {
649   if (vk == NULL) {
650     vk = inline_klass();
651   }
652   if (field_count() == 0) {
653     assert(is_allocated(phase), &quot;must be allocated&quot;);
654     return get_oop();
655   }
656   for (uint i = 0; i &lt; field_count(); ++i) {
657     int offset = holder_offset + field_offset(i);
658     Node* value = field_value(i);
659     if (value-&gt;is_InlineType()) {
660       InlineTypeNode* vt = value-&gt;as_InlineType();
661       if (field_is_flattened(i)) {
662         // Check inline type field load recursively
663         base = vt-&gt;is_loaded(phase, vk, base, offset - vt-&gt;inline_klass()-&gt;first_field_offset());
664         if (base == NULL) {
665           return NULL;
666         }
667         continue;
668       } else {
669         value = vt-&gt;get_oop();
670         if (value-&gt;Opcode() == Op_CastPP) {
671           // Skip CastPP
672           value = value-&gt;in(1);
673         }
674       }
675     }
676     if (value-&gt;isa_DecodeN()) {
677       // Skip DecodeN
678       value = value-&gt;in(1);
679     }
680     if (value-&gt;isa_Load()) {
681       // Check if base and offset of field load matches inline type layout
682       intptr_t loffset = 0;
683       Node* lbase = AddPNode::Ideal_base_and_offset(value-&gt;in(MemNode::Address), phase, loffset);
684       if (lbase == NULL || (lbase != base &amp;&amp; base != NULL) || loffset != offset) {
685         return NULL;
686       } else if (base == NULL) {
687         // Set base and check if pointer type matches
688         base = lbase;
689         const TypeInstPtr* vtptr = phase-&gt;type(base)-&gt;isa_instptr();
690         if (vtptr == NULL || !vtptr-&gt;klass()-&gt;equals(vk)) {
691           return NULL;
692         }
693       }
694     } else {
695       return NULL;
696     }
697   }
698   return base;
699 }
700 
701 Node* InlineTypeNode::tagged_klass(ciInlineKlass* vk, PhaseGVN&amp; gvn) {
702   const TypeKlassPtr* tk = TypeKlassPtr::make(vk);
703   intptr_t bits = tk-&gt;get_con();
704   set_nth_bit(bits, 0);
705   return gvn.makecon(TypeRawPtr::make((address)bits));
706 }
707 
708 void InlineTypeNode::pass_fields(GraphKit* kit, Node* n, ExtendedSignature&amp; sig, uint&amp; base_input, int base_offset) {
709   for (uint i = 0; i &lt; field_count(); i++) {
710     int sig_offset = (*sig)._offset;
711     uint idx = field_index(sig_offset - base_offset);
712     Node* arg = field_value(idx);
713 
714     if (field_is_flattened(idx)) {
715       // Flattened inline type field
716       InlineTypeNode* vt = arg-&gt;as_InlineType();
717       vt-&gt;pass_fields(kit, n, sig, base_input, sig_offset - vt-&gt;inline_klass()-&gt;first_field_offset());
718     } else {
719       if (arg-&gt;is_InlineType()) {
720         // Non-flattened inline type field
721         InlineTypeNode* vt = arg-&gt;as_InlineType();
722         assert(n-&gt;Opcode() != Op_Return || vt-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;inline type field should be allocated on return&quot;);
723         arg = vt-&gt;buffer(kit);
724       }
725       // Initialize call/return arguments
726       BasicType bt = field_type(i)-&gt;basic_type();
727       n-&gt;init_req(base_input++, arg);
728       if (type2size[bt] == 2) {
729         n-&gt;init_req(base_input++, kit-&gt;top());
730       }
731       // Skip reserved arguments
732       while (SigEntry::next_is_reserved(sig, bt)) {
733         n-&gt;init_req(base_input++, kit-&gt;top());
734         if (type2size[bt] == 2) {
735           n-&gt;init_req(base_input++, kit-&gt;top());
736         }
737       }
738     }
739   }
740 }
741 
742 void InlineTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, ExtendedSignature&amp; sig, uint&amp; base_input, int base_offset, bool in) {
743   PhaseGVN&amp; gvn = kit-&gt;gvn();
744   for (uint i = 0; i &lt; field_count(); i++) {
745     int sig_offset = (*sig)._offset;
746     uint idx = field_index(sig_offset - base_offset);
747     ciType* type = field_type(idx);
748 
749     Node* parm = NULL;
750     if (field_is_flattened(idx)) {
751       // Flattened inline type field
752       InlineTypeNode* vt = InlineTypeNode::make_uninitialized(gvn, type-&gt;as_inline_klass());
753       vt-&gt;initialize_fields(kit, multi, sig, base_input, sig_offset - type-&gt;as_inline_klass()-&gt;first_field_offset(), in);
754       parm = gvn.transform(vt);
755     } else {
756       if (multi-&gt;is_Start()) {
757         assert(in, &quot;return from start?&quot;);
758         parm = gvn.transform(new ParmNode(multi-&gt;as_Start(), base_input));
759       } else if (in) {
760         parm = multi-&gt;as_Call()-&gt;in(base_input);
761       } else {
762         parm = gvn.transform(new ProjNode(multi-&gt;as_Call(), base_input));
763       }
764       if (type-&gt;is_inlinetype()) {
765         // Non-flattened inline type field
766         if (type-&gt;as_inline_klass()-&gt;is_scalarizable()) {
767           parm = InlineTypeNode::make_from_oop(kit, parm, type-&gt;as_inline_klass());
768         } else {
769           parm = kit-&gt;null2default(parm, type-&gt;as_inline_klass());
770         }
771       }
772       base_input += type2size[type-&gt;basic_type()];
773       // Skip reserved arguments
774       BasicType bt = type-&gt;basic_type();
775       while (SigEntry::next_is_reserved(sig, bt)) {
776         base_input += type2size[bt];
777       }
778     }
779     assert(parm != NULL, &quot;should never be null&quot;);
780     set_field_value(idx, parm);
781     gvn.record_for_igvn(parm);
782   }
783 }
784 
785 // Replace a buffer allocation by a dominating allocation
786 static void replace_allocation(PhaseIterGVN* igvn, Node* res, Node* dom) {
787   // Remove initializing stores
788   for (DUIterator_Fast imax, i = res-&gt;fast_outs(imax); i &lt; imax; i++) {
789     AddPNode* addp = res-&gt;fast_out(i)-&gt;isa_AddP();
790     if (addp != NULL) {
791       for (DUIterator_Fast jmax, j = addp-&gt;fast_outs(jmax); j &lt; jmax; j++) {
792         StoreNode* store = addp-&gt;fast_out(j)-&gt;isa_Store();
793         if (store != NULL) {
794           igvn-&gt;replace_in_uses(store, store-&gt;in(MemNode::Memory));
795         }
796       }
797     }
798   }
799   igvn-&gt;replace_node(res, dom);
800 }
801 
802 Node* InlineTypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {
803   Node* oop = get_oop();
804   if (is_default(phase) &amp;&amp; (!oop-&gt;is_Con() || phase-&gt;type(oop)-&gt;is_zero_type())) {
805     // Use the pre-allocated oop for default inline types
806     set_oop(default_oop(*phase, inline_klass()));
807     assert(is_allocated(phase), &quot;should now be allocated&quot;);
808     return this;
809   } else if (oop-&gt;isa_InlineTypePtr()) {
810     // Can happen with late inlining
811     InlineTypePtrNode* vtptr = oop-&gt;as_InlineTypePtr();
812     set_oop(vtptr-&gt;get_oop());
813     for (uint i = Oop+1; i &lt; vtptr-&gt;req(); ++i) {
814       set_req(i, vtptr-&gt;in(i));
815     }
816     return this;
817   }
818 
819   if (!is_allocated(phase)) {
820     // Save base oop if fields are loaded from memory and the inline
821     // type is not buffered (in this case we should not use the oop).
822     Node* base = is_loaded(phase);
823     if (base != NULL) {
824       set_oop(base);
825       assert(is_allocated(phase), &quot;should now be allocated&quot;);
826       return this;
827     }
828   }
829 
830   if (can_reshape) {
831     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
832 
833     if (is_allocated(phase)) {
834       // Search for and remove re-allocations of this inline type. Ignore scalar replaceable ones,
835       // they will be removed anyway and changing the memory chain will confuse other optimizations.
836       // This can happen with late inlining when we first allocate an inline type argument
837       // but later decide to inline the call after the callee code also triggered allocation.
838       for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
839         AllocateNode* alloc = fast_out(i)-&gt;isa_Allocate();
840         if (alloc != NULL &amp;&amp; alloc-&gt;in(AllocateNode::InlineTypeNode) == this &amp;&amp; !alloc-&gt;_is_scalar_replaceable) {
841           // Found a re-allocation
842           Node* res = alloc-&gt;result_cast();
843           if (res != NULL &amp;&amp; res-&gt;is_CheckCastPP()) {
844             // Replace allocation by oop and unlink AllocateNode
845             replace_allocation(igvn, res, get_oop());
846             igvn-&gt;replace_input_of(alloc, AllocateNode::InlineTypeNode, igvn-&gt;C-&gt;top());
847             --i; --imax;
848           }
849         }
850       }
851     }
852   }
853   return NULL;
854 }
855 
856 // Search for multiple allocations of this inline type and try to replace them by dominating allocations.
857 // Then unlink the inline type node and remove it.
858 void InlineTypeNode::remove_redundant_allocations(PhaseIterGVN* igvn, PhaseIdealLoop* phase) {
859   // Search for allocations of this inline type. Ignore scalar replaceable ones, they
860   // will be removed anyway and changing the memory chain will confuse other optimizations.
861   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
862     AllocateNode* alloc = fast_out(i)-&gt;isa_Allocate();
863     if (alloc != NULL &amp;&amp; alloc-&gt;in(AllocateNode::InlineTypeNode) == this &amp;&amp; !alloc-&gt;_is_scalar_replaceable) {
864       Node* res = alloc-&gt;result_cast();
865       if (res == NULL || !res-&gt;is_CheckCastPP()) {
866         break; // No unique CheckCastPP
867       }
868       assert(!is_default(igvn) &amp;&amp; !is_allocated(igvn), &quot;re-allocation should be removed by Ideal transformation&quot;);
869       // Search for a dominating allocation of the same inline type
870       Node* res_dom = res;
871       for (DUIterator_Fast jmax, j = fast_outs(jmax); j &lt; jmax; j++) {
872         AllocateNode* alloc_other = fast_out(j)-&gt;isa_Allocate();
873         if (alloc_other != NULL &amp;&amp; alloc_other-&gt;in(AllocateNode::InlineTypeNode) == this &amp;&amp; !alloc_other-&gt;_is_scalar_replaceable) {
874           Node* res_other = alloc_other-&gt;result_cast();
875           if (res_other != NULL &amp;&amp; res_other-&gt;is_CheckCastPP() &amp;&amp; res_other != res_dom &amp;&amp;
876               phase-&gt;is_dominator(res_other-&gt;in(0), res_dom-&gt;in(0))) {
877             res_dom = res_other;
878           }
879         }
880       }
881       if (res_dom != res) {
882         // Replace allocation by dominating one.
883         replace_allocation(igvn, res, res_dom);
884         // The result of the dominated allocation is now unused and will be removed
885         // later in PhaseMacroExpand::eliminate_allocate_node to not confuse loop opts.
886         igvn-&gt;record_for_igvn(alloc);
887       }
888     }
889   }
890 
891   // Process users
892   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
893     Node* out = fast_out(i);
894     if (out-&gt;is_InlineType()) {
895       // Unlink and recursively process inline type users
896       igvn-&gt;hash_delete(out);
897       int nb = out-&gt;replace_edge(this, igvn-&gt;C-&gt;top());
898       out-&gt;as_InlineType()-&gt;remove_redundant_allocations(igvn, phase);
899       --i; imax -= nb;
900     } else if (out-&gt;isa_Allocate() != NULL) {
901       // Unlink AllocateNode
902       assert(out-&gt;in(AllocateNode::InlineTypeNode) == this, &quot;should be linked&quot;);
903       igvn-&gt;replace_input_of(out, AllocateNode::InlineTypeNode, igvn-&gt;C-&gt;top());
904       --i; --imax;
905     } else {
906 #ifdef ASSERT
907       // The inline type should not have any other users at this time
908       out-&gt;dump();
909       assert(false, &quot;unexpected user of inline type&quot;);
910 #endif
911     }
912   }
913   igvn-&gt;remove_dead_node(this);
914 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>