<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.ref.SoftReference;
  29 import java.util.HashSet;
  30 import java.util.HashMap;
  31 import java.util.Locale;
  32 import java.util.Map;
  33 import java.util.Optional;
  34 import java.util.Set;
  35 import java.util.WeakHashMap;
  36 import java.util.function.BiPredicate;
  37 import java.util.function.Function;
  38 import java.util.stream.Collector;
  39 
  40 import javax.tools.JavaFileObject;
  41 
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Lint.LintCategory;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;
  46 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  47 import com.sun.tools.javac.comp.AttrContext;
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.comp.Enter;
  50 import com.sun.tools.javac.comp.Env;
  51 import com.sun.tools.javac.comp.LambdaToMethod;
  52 import com.sun.tools.javac.jvm.ClassFile;
  53 import com.sun.tools.javac.jvm.Target;
  54 import com.sun.tools.javac.util.*;
  55 
  56 import static com.sun.tools.javac.code.BoundKind.*;
  57 import static com.sun.tools.javac.code.Flags.*;
  58 import static com.sun.tools.javac.code.Kinds.Kind.*;
  59 import static com.sun.tools.javac.code.Scope.*;
  60 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  61 import static com.sun.tools.javac.code.Symbol.*;
  62 import static com.sun.tools.javac.code.Type.*;
  63 import static com.sun.tools.javac.code.TypeTag.*;
  64 import static com.sun.tools.javac.jvm.ClassFile.externalize;
  65 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  66 
  67 /**
  68  * Utility class containing various operations on types.
  69  *
  70  * &lt;p&gt;Unless other names are more illustrative, the following naming
  71  * conventions should be observed in this file:
  72  *
  73  * &lt;dl&gt;
  74  * &lt;dt&gt;t&lt;/dt&gt;
  75  * &lt;dd&gt;If the first argument to an operation is a type, it should be named t.&lt;/dd&gt;
  76  * &lt;dt&gt;s&lt;/dt&gt;
  77  * &lt;dd&gt;Similarly, if the second argument to an operation is a type, it should be named s.&lt;/dd&gt;
  78  * &lt;dt&gt;ts&lt;/dt&gt;
  79  * &lt;dd&gt;If an operations takes a list of types, the first should be named ts.&lt;/dd&gt;
  80  * &lt;dt&gt;ss&lt;/dt&gt;
  81  * &lt;dd&gt;A second list of types should be named ss.&lt;/dd&gt;
  82  * &lt;/dl&gt;
  83  *
  84  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  85  * If you write code that depends on this, you do so at your own risk.
  86  * This code and its internal interfaces are subject to change or
  87  * deletion without notice.&lt;/b&gt;
  88  */
  89 public class Types {
  90     protected static final Context.Key&lt;Types&gt; typesKey = new Context.Key&lt;&gt;();
  91 
  92     final Symtab syms;
  93     final JavacMessages messages;
  94     final Names names;
  95     final boolean allowDefaultMethods;
  96     final boolean mapCapturesToBounds;
  97     final boolean allowValueBasedClasses;
  98     final Check chk;
  99     final Enter enter;
 100     JCDiagnostic.Factory diags;
 101     List&lt;Warner&gt; warnStack = List.nil();
 102     final Name capturedName;
 103 
 104     public final Warner noWarnings;
 105 
 106     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;
 107     public static Types instance(Context context) {
 108         Types instance = context.get(typesKey);
 109         if (instance == null)
 110             instance = new Types(context);
 111         return instance;
 112     }
 113 
 114     protected Types(Context context) {
 115         context.put(typesKey, this);
 116         syms = Symtab.instance(context);
 117         names = Names.instance(context);
 118         Source source = Source.instance(context);
 119         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 120         mapCapturesToBounds = Feature.MAP_CAPTURES_TO_BOUNDS.allowedInSource(source);
 121         chk = Check.instance(context);
 122         enter = Enter.instance(context);
 123         capturedName = names.fromString(&quot;&lt;captured wildcard&gt;&quot;);
 124         messages = JavacMessages.instance(context);
 125         diags = JCDiagnostic.Factory.instance(context);
 126         noWarnings = new Warner(null);
 127         Options options = Options.instance(context);
 128         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 129     }
 130     // &lt;/editor-fold&gt;
 131 
 132     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;bounds&quot;&gt;
 133     /**
 134      * Get a wildcard&#39;s upper bound, returning non-wildcards unchanged.
 135      * @param t a type argument, either a wildcard or a type
 136      */
 137     public Type wildUpperBound(Type t) {
 138         if (t.hasTag(WILDCARD)) {
 139             WildcardType w = (WildcardType) t;
 140             if (w.isSuperBound())
 141                 return w.bound == null ? syms.objectType : w.bound.getUpperBound();
 142             else
 143                 return wildUpperBound(w.type);
 144         }
 145         else return t;
 146     }
 147 
 148     /**
 149      * Get a capture variable&#39;s upper bound, returning other types unchanged.
 150      * @param t a type
 151      */
 152     public Type cvarUpperBound(Type t) {
 153         if (t.hasTag(TYPEVAR)) {
 154             TypeVar v = (TypeVar) t;
 155             return v.isCaptured() ? cvarUpperBound(v.getUpperBound()) : v;
 156         }
 157         else return t;
 158     }
 159 
 160     /**
 161      * Get a wildcard&#39;s lower bound, returning non-wildcards unchanged.
 162      * @param t a type argument, either a wildcard or a type
 163      */
 164     public Type wildLowerBound(Type t) {
 165         if (t.hasTag(WILDCARD)) {
 166             WildcardType w = (WildcardType) t;
 167             return w.isExtendsBound() ? syms.botType : wildLowerBound(w.type);
 168         }
 169         else return t;
 170     }
 171 
 172     /**
 173      * Get a capture variable&#39;s lower bound, returning other types unchanged.
 174      * @param t a type
 175      */
 176     public Type cvarLowerBound(Type t) {
 177         if (t.hasTag(TYPEVAR) &amp;&amp; ((TypeVar) t).isCaptured()) {
 178             return cvarLowerBound(t.getLowerBound());
 179         }
 180         else return t;
 181     }
 182 
 183     /**
 184      * Recursively skip type-variables until a class/array type is found; capture conversion is then
 185      * (optionally) applied to the resulting type. This is useful for i.e. computing a site that is
 186      * suitable for a method lookup.
 187      */
 188     public Type skipTypeVars(Type site, boolean capture) {
 189         while (site.hasTag(TYPEVAR)) {
 190             site = site.getUpperBound();
 191         }
 192         return capture ? capture(site) : site;
 193     }
 194     // &lt;/editor-fold&gt;
 195 
 196     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;projections&quot;&gt;
 197 
 198     /**
 199      * A projection kind. See {@link TypeProjection}
 200      */
 201     enum ProjectionKind {
 202         UPWARDS() {
 203             @Override
 204             ProjectionKind complement() {
 205                 return DOWNWARDS;
 206             }
 207         },
 208         DOWNWARDS() {
 209             @Override
 210             ProjectionKind complement() {
 211                 return UPWARDS;
 212             }
 213         };
 214 
 215         abstract ProjectionKind complement();
 216     }
 217 
 218     /**
 219      * This visitor performs upwards and downwards projections on types.
 220      *
 221      * A projection is defined as a function that takes a type T, a set of type variables V and that
 222      * produces another type S.
 223      *
 224      * An upwards projection maps a type T into a type S such that (i) T has no variables in V,
 225      * and (ii) S is an upper bound of T.
 226      *
 227      * A downwards projection maps a type T into a type S such that (i) T has no variables in V,
 228      * and (ii) S is a lower bound of T.
 229      *
 230      * Note that projections are only allowed to touch variables in V. Therefore, it is possible for
 231      * a projection to leave its input type unchanged if it does not contain any variables in V.
 232      *
 233      * Moreover, note that while an upwards projection is always defined (every type as an upper bound),
 234      * a downwards projection is not always defined.
 235      *
 236      * Examples:
 237      *
 238      * {@code upwards(List&lt;#CAP1&gt;, [#CAP1]) = List&lt;? extends String&gt;, where #CAP1 &lt;: String }
 239      * {@code downwards(List&lt;#CAP2&gt;, [#CAP2]) = List&lt;? super String&gt;, where #CAP2 :&gt; String }
 240      * {@code upwards(List&lt;#CAP1&gt;, [#CAP2]) = List&lt;#CAP1&gt; }
 241      * {@code downwards(List&lt;#CAP1&gt;, [#CAP1]) = not defined }
 242      */
 243     class TypeProjection extends TypeMapping&lt;ProjectionKind&gt; {
 244 
 245         List&lt;Type&gt; vars;
 246         Set&lt;Type&gt; seen = new HashSet&lt;&gt;();
 247 
 248         public TypeProjection(List&lt;Type&gt; vars) {
 249             this.vars = vars;
 250         }
 251 
 252         @Override
 253         public Type visitClassType(ClassType t, ProjectionKind pkind) {
 254             if (t.isCompound()) {
 255                 List&lt;Type&gt; components = directSupertypes(t);
 256                 List&lt;Type&gt; components1 = components.map(c -&gt; c.map(this, pkind));
 257                 if (components == components1) return t;
 258                 else return makeIntersectionType(components1);
 259             } else {
 260                 Type outer = t.getEnclosingType();
 261                 Type outer1 = visit(outer, pkind);
 262                 List&lt;Type&gt; typarams = t.getTypeArguments();
 263                 List&lt;Type&gt; formals = t.tsym.type.getTypeArguments();
 264                 ListBuffer&lt;Type&gt; typarams1 = new ListBuffer&lt;&gt;();
 265                 boolean changed = false;
 266                 for (Type actual : typarams) {
 267                     Type t2 = mapTypeArgument(t, formals.head.getUpperBound(), actual, pkind);
 268                     if (t2.hasTag(BOT)) {
 269                         //not defined
 270                         return syms.botType;
 271                     }
 272                     typarams1.add(t2);
 273                     changed |= actual != t2;
 274                     formals = formals.tail;
 275                 }
 276                 if (outer1 == outer &amp;&amp; !changed) return t;
 277                 else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {
 278                     @Override
 279                     protected boolean needsStripping() {
 280                         return true;
 281                     }
 282                 };
 283             }
 284         }
 285 
 286         @Override
 287         public Type visitArrayType(ArrayType t, ProjectionKind s) {
 288             Type elemtype = t.elemtype;
 289             Type elemtype1 = visit(elemtype, s);
 290             if (elemtype1 == elemtype) {
 291                 return t;
 292             } else if (elemtype1.hasTag(BOT)) {
 293                 //undefined
 294                 return syms.botType;
 295             } else {
 296                 return new ArrayType(elemtype1, t.tsym, t.metadata) {
 297                     @Override
 298                     protected boolean needsStripping() {
 299                         return true;
 300                     }
 301                 };
 302             }
 303         }
 304 
 305         @Override
 306         public Type visitTypeVar(TypeVar t, ProjectionKind pkind) {
 307             if (vars.contains(t)) {
 308                 if (seen.add(t)) {
 309                     try {
 310                         final Type bound;
 311                         switch (pkind) {
 312                             case UPWARDS:
 313                                 bound = t.getUpperBound();
 314                                 break;
 315                             case DOWNWARDS:
 316                                 bound = (t.getLowerBound() == null) ?
 317                                         syms.botType :
 318                                         t.getLowerBound();
 319                                 break;
 320                             default:
 321                                 Assert.error();
 322                                 return null;
 323                         }
 324                         return bound.map(this, pkind);
 325                     } finally {
 326                         seen.remove(t);
 327                     }
 328                 } else {
 329                     //cycle
 330                     return pkind == ProjectionKind.UPWARDS ?
 331                             syms.objectType : syms.botType;
 332                 }
 333             } else {
 334                 return t;
 335             }
 336         }
 337 
 338         private Type mapTypeArgument(Type site, Type declaredBound, Type t, ProjectionKind pkind) {
 339             return t.containsAny(vars) ?
 340                     t.map(new TypeArgumentProjection(site, declaredBound), pkind) :
 341                     t;
 342         }
 343 
 344         class TypeArgumentProjection extends TypeMapping&lt;ProjectionKind&gt; {
 345 
 346             Type site;
 347             Type declaredBound;
 348 
 349             TypeArgumentProjection(Type site, Type declaredBound) {
 350                 this.site = site;
 351                 this.declaredBound = declaredBound;
 352             }
 353 
 354             @Override
 355             public Type visitType(Type t, ProjectionKind pkind) {
 356                 //type argument is some type containing restricted vars
 357                 if (pkind == ProjectionKind.DOWNWARDS) {
 358                     //not defined
 359                     return syms.botType;
 360                 }
 361                 Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);
 362                 Type lower = t.map(TypeProjection.this, ProjectionKind.DOWNWARDS);
 363                 List&lt;Type&gt; formals = site.tsym.type.getTypeArguments();
 364                 BoundKind bk;
 365                 Type bound;
 366                 if (!isSameType(upper, syms.objectType) &amp;&amp;
 367                         (declaredBound.containsAny(formals) ||
 368                          !isSubtype(declaredBound, upper))) {
 369                     bound = upper;
 370                     bk = EXTENDS;
 371                 } else if (!lower.hasTag(BOT)) {
 372                     bound = lower;
 373                     bk = SUPER;
 374                 } else {
 375                     bound = syms.objectType;
 376                     bk = UNBOUND;
 377                 }
 378                 return makeWildcard(bound, bk);
 379             }
 380 
 381             @Override
 382             public Type visitWildcardType(WildcardType wt, ProjectionKind pkind) {
 383                 //type argument is some wildcard whose bound contains restricted vars
 384                 Type bound = syms.botType;
 385                 BoundKind bk = wt.kind;
 386                 switch (wt.kind) {
 387                     case EXTENDS:
 388                         bound = wt.type.map(TypeProjection.this, pkind);
 389                         if (bound.hasTag(BOT)) {
 390                             return syms.botType;
 391                         }
 392                         break;
 393                     case SUPER:
 394                         bound = wt.type.map(TypeProjection.this, pkind.complement());
 395                         if (bound.hasTag(BOT)) {
 396                             bound = syms.objectType;
 397                             bk = UNBOUND;
 398                         }
 399                         break;
 400                 }
 401                 return makeWildcard(bound, bk);
 402             }
 403 
 404             private Type makeWildcard(Type bound, BoundKind bk) {
 405                 return new WildcardType(bound, bk, syms.boundClass) {
 406                     @Override
 407                     protected boolean needsStripping() {
 408                         return true;
 409                     }
 410                 };
 411             }
 412         }
 413     }
 414 
 415     /**
 416      * Computes an upward projection of given type, and vars. See {@link TypeProjection}.
 417      *
 418      * @param t the type to be projected
 419      * @param vars the set of type variables to be mapped
 420      * @return the type obtained as result of the projection
 421      */
 422     public Type upward(Type t, List&lt;Type&gt; vars) {
 423         return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);
 424     }
 425 
 426     /**
 427      * Computes the set of captured variables mentioned in a given type. See {@link CaptureScanner}.
 428      * This routine is typically used to computed the input set of variables to be used during
 429      * an upwards projection (see {@link Types#upward(Type, List)}).
 430      *
 431      * @param t the type where occurrences of captured variables have to be found
 432      * @return the set of captured variables found in t
 433      */
 434     public List&lt;Type&gt; captures(Type t) {
 435         CaptureScanner cs = new CaptureScanner();
 436         Set&lt;Type&gt; captures = new HashSet&lt;&gt;();
 437         cs.visit(t, captures);
 438         return List.from(captures);
 439     }
 440 
 441     /**
 442      * This visitor scans a type recursively looking for occurrences of captured type variables.
 443      */
 444     class CaptureScanner extends SimpleVisitor&lt;Void, Set&lt;Type&gt;&gt; {
 445 
 446         @Override
 447         public Void visitType(Type t, Set&lt;Type&gt; types) {
 448             return null;
 449         }
 450 
 451         @Override
 452         public Void visitClassType(ClassType t, Set&lt;Type&gt; seen) {
 453             if (t.isCompound()) {
 454                 directSupertypes(t).forEach(s -&gt; visit(s, seen));
 455             } else {
 456                 t.allparams().forEach(ta -&gt; visit(ta, seen));
 457             }
 458             return null;
 459         }
 460 
 461         @Override
 462         public Void visitArrayType(ArrayType t, Set&lt;Type&gt; seen) {
 463             return visit(t.elemtype, seen);
 464         }
 465 
 466         @Override
 467         public Void visitWildcardType(WildcardType t, Set&lt;Type&gt; seen) {
 468             visit(t.type, seen);
 469             return null;
 470         }
 471 
 472         @Override
 473         public Void visitTypeVar(TypeVar t, Set&lt;Type&gt; seen) {
 474             if ((t.tsym.flags() &amp; Flags.SYNTHETIC) != 0 &amp;&amp; seen.add(t)) {
 475                 visit(t.getUpperBound(), seen);
 476             }
 477             return null;
 478         }
 479 
 480         @Override
 481         public Void visitCapturedType(CapturedType t, Set&lt;Type&gt; seen) {
 482             if (seen.add(t)) {
 483                 visit(t.getUpperBound(), seen);
 484                 visit(t.getLowerBound(), seen);
 485             }
 486             return null;
 487         }
 488     }
 489 
 490     // &lt;/editor-fold&gt;
 491 
 492     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isUnbounded&quot;&gt;
 493     /**
 494      * Checks that all the arguments to a class are unbounded
 495      * wildcards or something else that doesn&#39;t make any restrictions
 496      * on the arguments. If a class isUnbounded, a raw super- or
 497      * subclass can be cast to it without a warning.
 498      * @param t a type
 499      * @return true iff the given type is unbounded or raw
 500      */
 501     public boolean isUnbounded(Type t) {
 502         return isUnbounded.visit(t);
 503     }
 504     // where
 505         private final UnaryVisitor&lt;Boolean&gt; isUnbounded = new UnaryVisitor&lt;Boolean&gt;() {
 506 
 507             public Boolean visitType(Type t, Void ignored) {
 508                 return true;
 509             }
 510 
 511             @Override
 512             public Boolean visitClassType(ClassType t, Void ignored) {
 513                 List&lt;Type&gt; parms = t.tsym.type.allparams();
 514                 List&lt;Type&gt; args = t.allparams();
 515                 while (parms.nonEmpty()) {
 516                     WildcardType unb = new WildcardType(syms.objectType,
 517                                                         BoundKind.UNBOUND,
 518                                                         syms.boundClass,
 519                                                         (TypeVar)parms.head);
 520                     if (!containsType(args.head, unb))
 521                         return false;
 522                     parms = parms.tail;
 523                     args = args.tail;
 524                 }
 525                 return true;
 526             }
 527         };
 528     // &lt;/editor-fold&gt;
 529 
 530     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSub&quot;&gt;
 531     /**
 532      * Return the least specific subtype of t that starts with symbol
 533      * sym.  If none exists, return null.  The least specific subtype
 534      * is determined as follows:
 535      *
 536      * &lt;p&gt;If there is exactly one parameterized instance of sym that is a
 537      * subtype of t, that parameterized instance is returned.&lt;br&gt;
 538      * Otherwise, if the plain type or raw type `sym&#39; is a subtype of
 539      * type t, the type `sym&#39; itself is returned.  Otherwise, null is
 540      * returned.
 541      */
 542     public Type asSub(Type t, Symbol sym) {
 543         return asSub.visit(t, sym);
 544     }
 545     // where
 546         private final SimpleVisitor&lt;Type,Symbol&gt; asSub = new SimpleVisitor&lt;Type,Symbol&gt;() {
 547 
 548             public Type visitType(Type t, Symbol sym) {
 549                 return null;
 550             }
 551 
 552             @Override
 553             public Type visitClassType(ClassType t, Symbol sym) {
 554                 if (t.tsym == sym)
 555                     return t;
 556                 Type base = asSuper(sym.type, t.tsym);
 557                 if (base == null)
 558                     return null;
 559                 ListBuffer&lt;Type&gt; from = new ListBuffer&lt;&gt;();
 560                 ListBuffer&lt;Type&gt; to = new ListBuffer&lt;&gt;();
 561                 try {
 562                     adapt(base, t, from, to);
 563                 } catch (AdaptFailure ex) {
 564                     return null;
 565                 }
 566                 Type res = subst(sym.type, from.toList(), to.toList());
 567                 if (!isSubtype(res, t))
 568                     return null;
 569                 ListBuffer&lt;Type&gt; openVars = new ListBuffer&lt;&gt;();
 570                 for (List&lt;Type&gt; l = sym.type.allparams();
 571                      l.nonEmpty(); l = l.tail)
 572                     if (res.contains(l.head) &amp;&amp; !t.contains(l.head))
 573                         openVars.append(l.head);
 574                 if (openVars.nonEmpty()) {
 575                     if (t.isRaw()) {
 576                         // The subtype of a raw type is raw
 577                         res = erasure(res);
 578                     } else {
 579                         // Unbound type arguments default to ?
 580                         List&lt;Type&gt; opens = openVars.toList();
 581                         ListBuffer&lt;Type&gt; qs = new ListBuffer&lt;&gt;();
 582                         for (List&lt;Type&gt; iter = opens; iter.nonEmpty(); iter = iter.tail) {
 583                             qs.append(new WildcardType(syms.objectType, BoundKind.UNBOUND,
 584                                                        syms.boundClass, (TypeVar) iter.head));
 585                         }
 586                         res = subst(res, opens, qs.toList());
 587                     }
 588                 }
 589                 return res;
 590             }
 591 
 592             @Override
 593             public Type visitErrorType(ErrorType t, Symbol sym) {
 594                 return t;
 595             }
 596         };
 597     // &lt;/editor-fold&gt;
 598 
 599     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isConvertible&quot;&gt;
 600     /**
 601      * Is t a subtype of or convertible via boxing/unboxing
 602      * conversion to s?
 603      */
 604     public boolean isConvertible(Type t, Type s, Warner warn) {
 605         if (t.hasTag(ERROR)) {
 606             return true;
 607         }
 608 
 609         boolean tValue = t.isValue();
 610         boolean sValue = s.isValue();
 611         if (tValue != sValue) {
 612             return tValue ?
 613                     isSubtype(t.referenceProjection(), s) :
 614                     (!t.hasTag(BOT) || isValueBased(s)) &amp;&amp; isSubtype(t, s.referenceProjection());
 615         }
 616 
 617         boolean tPrimitive = t.isPrimitive();
 618         boolean sPrimitive = s.isPrimitive();
 619         if (tPrimitive == sPrimitive) {
 620             return isSubtypeUnchecked(t, s, warn);
 621         }
 622         boolean tUndet = t.hasTag(UNDETVAR);
 623         boolean sUndet = s.hasTag(UNDETVAR);
 624 
 625         if (tUndet || sUndet) {
 626             return tUndet ?
 627                     isSubtype(t, boxedTypeOrType(s)) :
 628                     isSubtype(boxedTypeOrType(t), s);
 629         }
 630 
 631         return tPrimitive
 632             ? isSubtype(boxedClass(t).type, s)
 633             : isSubtype(unboxedType(t), s);
 634     }
 635 
 636     /**
 637      * Is t a subtype of or convertible via boxing/unboxing
 638      * conversions to s?
 639      */
 640     public boolean isConvertible(Type t, Type s) {
 641         return isConvertible(t, s, noWarnings);
 642     }
 643     // &lt;/editor-fold&gt;
 644 
 645     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;findSam&quot;&gt;
 646 
 647     /**
 648      * Exception used to report a function descriptor lookup failure. The exception
 649      * wraps a diagnostic that can be used to generate more details error
 650      * messages.
 651      */
 652     public static class FunctionDescriptorLookupError extends RuntimeException {
 653         private static final long serialVersionUID = 0;
 654 
 655         transient JCDiagnostic diagnostic;
 656 
 657         FunctionDescriptorLookupError() {
 658             this.diagnostic = null;
 659         }
 660 
 661         FunctionDescriptorLookupError setMessage(JCDiagnostic diag) {
 662             this.diagnostic = diag;
 663             return this;
 664         }
 665 
 666         public JCDiagnostic getDiagnostic() {
 667             return diagnostic;
 668         }
 669     }
 670 
 671     /**
 672      * A cache that keeps track of function descriptors associated with given
 673      * functional interfaces.
 674      */
 675     class DescriptorCache {
 676 
 677         private WeakHashMap&lt;TypeSymbol, Entry&gt; _map = new WeakHashMap&lt;&gt;();
 678 
 679         class FunctionDescriptor {
 680             Symbol descSym;
 681 
 682             FunctionDescriptor(Symbol descSym) {
 683                 this.descSym = descSym;
 684             }
 685 
 686             public Symbol getSymbol() {
 687                 return descSym;
 688             }
 689 
 690             public Type getType(Type site) {
 691                 site = removeWildcards(site);
 692                 if (site.isIntersection()) {
 693                     IntersectionClassType ict = (IntersectionClassType)site;
 694                     for (Type component : ict.getExplicitComponents()) {
 695                         if (!chk.checkValidGenericType(component)) {
 696                             //if the inferred functional interface type is not well-formed,
 697                             //or if it&#39;s not a subtype of the original target, issue an error
 698                             throw failure(diags.fragment(Fragments.NoSuitableFunctionalIntfInst(site)));
 699                         }
 700                     }
 701                 } else {
 702                     if (!chk.checkValidGenericType(site)) {
 703                         //if the inferred functional interface type is not well-formed,
 704                         //or if it&#39;s not a subtype of the original target, issue an error
 705                         throw failure(diags.fragment(Fragments.NoSuitableFunctionalIntfInst(site)));
 706                     }
 707                 }
 708                 return memberType(site, descSym);
 709             }
 710         }
 711 
 712         class Entry {
 713             final FunctionDescriptor cachedDescRes;
 714             final int prevMark;
 715 
 716             public Entry(FunctionDescriptor cachedDescRes,
 717                     int prevMark) {
 718                 this.cachedDescRes = cachedDescRes;
 719                 this.prevMark = prevMark;
 720             }
 721 
 722             boolean matches(int mark) {
 723                 return  this.prevMark == mark;
 724             }
 725         }
 726 
 727         FunctionDescriptor get(TypeSymbol origin) throws FunctionDescriptorLookupError {
 728             Entry e = _map.get(origin);
 729             CompoundScope members = membersClosure(origin.type, false);
 730             if (e == null ||
 731                     !e.matches(members.getMark())) {
 732                 FunctionDescriptor descRes = findDescriptorInternal(origin, members);
 733                 _map.put(origin, new Entry(descRes, members.getMark()));
 734                 return descRes;
 735             }
 736             else {
 737                 return e.cachedDescRes;
 738             }
 739         }
 740 
 741         /**
 742          * Compute the function descriptor associated with a given functional interface
 743          */
 744         public FunctionDescriptor findDescriptorInternal(TypeSymbol origin,
 745                 CompoundScope membersCache) throws FunctionDescriptorLookupError {
 746             if (!origin.isInterface() || (origin.flags() &amp; ANNOTATION) != 0 || origin.isSealed()) {
 747                 //t must be an interface
 748                 throw failure(&quot;not.a.functional.intf&quot;, origin);
 749             }
 750 
 751             final ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
 752             for (Symbol sym : membersCache.getSymbols(new DescriptorFilter(origin))) {
 753                 Type mtype = memberType(origin.type, sym);
 754                 if (abstracts.isEmpty()) {
 755                     abstracts.append(sym);
 756                 } else if ((sym.name == abstracts.first().name &amp;&amp;
 757                         overrideEquivalent(mtype, memberType(origin.type, abstracts.first())))) {
 758                     if (!abstracts.stream().filter(msym -&gt; msym.owner.isSubClass(sym.enclClass(), Types.this))
 759                             .map(msym -&gt; memberType(origin.type, msym))
 760                             .anyMatch(abstractMType -&gt; isSubSignature(abstractMType, mtype))) {
 761                         abstracts.append(sym);
 762                     }
 763                 } else {
 764                     //the target method(s) should be the only abstract members of t
 765                     throw failure(&quot;not.a.functional.intf.1&quot;,  origin,
 766                             diags.fragment(Fragments.IncompatibleAbstracts(Kinds.kindName(origin), origin)));
 767                 }
 768             }
 769             if (abstracts.isEmpty()) {
 770                 //t must define a suitable non-generic method
 771                 throw failure(&quot;not.a.functional.intf.1&quot;, origin,
 772                             diags.fragment(Fragments.NoAbstracts(Kinds.kindName(origin), origin)));
 773             } else if (abstracts.size() == 1) {
 774                 return new FunctionDescriptor(abstracts.first());
 775             } else { // size &gt; 1
 776                 FunctionDescriptor descRes = mergeDescriptors(origin, abstracts.toList());
 777                 if (descRes == null) {
 778                     //we can get here if the functional interface is ill-formed
 779                     ListBuffer&lt;JCDiagnostic&gt; descriptors = new ListBuffer&lt;&gt;();
 780                     for (Symbol desc : abstracts) {
 781                         String key = desc.type.getThrownTypes().nonEmpty() ?
 782                                 &quot;descriptor.throws&quot; : &quot;descriptor&quot;;
 783                         descriptors.append(diags.fragment(key, desc.name,
 784                                 desc.type.getParameterTypes(),
 785                                 desc.type.getReturnType(),
 786                                 desc.type.getThrownTypes()));
 787                     }
 788                     JCDiagnostic msg =
 789                             diags.fragment(Fragments.IncompatibleDescsInFunctionalIntf(Kinds.kindName(origin),
 790                                                                                        origin));
 791                     JCDiagnostic.MultilineDiagnostic incompatibleDescriptors =
 792                             new JCDiagnostic.MultilineDiagnostic(msg, descriptors.toList());
 793                     throw failure(incompatibleDescriptors);
 794                 }
 795                 return descRes;
 796             }
 797         }
 798 
 799         /**
 800          * Compute a synthetic type for the target descriptor given a list
 801          * of override-equivalent methods in the functional interface type.
 802          * The resulting method type is a method type that is override-equivalent
 803          * and return-type substitutable with each method in the original list.
 804          */
 805         private FunctionDescriptor mergeDescriptors(TypeSymbol origin, List&lt;Symbol&gt; methodSyms) {
 806             return mergeAbstracts(methodSyms, origin.type, false)
 807                     .map(bestSoFar -&gt; new FunctionDescriptor(bestSoFar.baseSymbol()) {
 808                         @Override
 809                         public Type getType(Type origin) {
 810                             Type mt = memberType(origin, getSymbol());
 811                             return createMethodTypeWithThrown(mt, bestSoFar.type.getThrownTypes());
 812                         }
 813                     }).orElse(null);
 814         }
 815 
 816         FunctionDescriptorLookupError failure(String msg, Object... args) {
 817             return failure(diags.fragment(msg, args));
 818         }
 819 
 820         FunctionDescriptorLookupError failure(JCDiagnostic diag) {
 821             return new FunctionDescriptorLookupError().setMessage(diag);
 822         }
 823     }
 824 
 825     private DescriptorCache descCache = new DescriptorCache();
 826 
 827     /**
 828      * Find the method descriptor associated to this class symbol - if the
 829      * symbol &#39;origin&#39; is not a functional interface, an exception is thrown.
 830      */
 831     public Symbol findDescriptorSymbol(TypeSymbol origin) throws FunctionDescriptorLookupError {
 832         return descCache.get(origin).getSymbol();
 833     }
 834 
 835     /**
 836      * Find the type of the method descriptor associated to this class symbol -
 837      * if the symbol &#39;origin&#39; is not a functional interface, an exception is thrown.
 838      */
 839     public Type findDescriptorType(Type origin) throws FunctionDescriptorLookupError {
 840         return descCache.get(origin.tsym).getType(origin);
 841     }
 842 
 843     /**
 844      * Is given type a functional interface?
 845      */
 846     public boolean isFunctionalInterface(TypeSymbol tsym) {
 847         try {
 848             findDescriptorSymbol(tsym);
 849             return true;
 850         } catch (FunctionDescriptorLookupError ex) {
 851             return false;
 852         }
 853     }
 854 
 855     public boolean isFunctionalInterface(Type site) {
 856         try {
 857             findDescriptorType(site);
 858             return true;
 859         } catch (FunctionDescriptorLookupError ex) {
 860             return false;
 861         }
 862     }
 863 
 864     public Type removeWildcards(Type site) {
 865         if (site.getTypeArguments().stream().anyMatch(t -&gt; t.hasTag(WILDCARD))) {
 866             //compute non-wildcard parameterization - JLS 9.9
 867             List&lt;Type&gt; actuals = site.getTypeArguments();
 868             List&lt;Type&gt; formals = site.tsym.type.getTypeArguments();
 869             ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
 870             for (Type formal : formals) {
 871                 Type actual = actuals.head;
 872                 Type bound = formal.getUpperBound();
 873                 if (actuals.head.hasTag(WILDCARD)) {
 874                     WildcardType wt = (WildcardType)actual;
 875                     //check that bound does not contain other formals
 876                     if (bound.containsAny(formals)) {
 877                         targs.add(wt.type);
 878                     } else {
 879                         //compute new type-argument based on declared bound and wildcard bound
 880                         switch (wt.kind) {
 881                             case UNBOUND:
 882                                 targs.add(bound);
 883                                 break;
 884                             case EXTENDS:
 885                                 targs.add(glb(bound, wt.type));
 886                                 break;
 887                             case SUPER:
 888                                 targs.add(wt.type);
 889                                 break;
 890                             default:
 891                                 Assert.error(&quot;Cannot get here!&quot;);
 892                         }
 893                     }
 894                 } else {
 895                     //not a wildcard - the new type argument remains unchanged
 896                     targs.add(actual);
 897                 }
 898                 actuals = actuals.tail;
 899             }
 900             return subst(site.tsym.type, formals, targs.toList());
 901         } else {
 902             return site;
 903         }
 904     }
 905 
 906     /**
 907      * Create a symbol for a class that implements a given functional interface
 908      * and overrides its functional descriptor. This routine is used for two
 909      * main purposes: (i) checking well-formedness of a functional interface;
 910      * (ii) perform functional interface bridge calculation.
 911      */
 912     public ClassSymbol makeFunctionalInterfaceClass(Env&lt;AttrContext&gt; env, Name name, Type target, long cflags) {
 913         if (target == null || target == syms.unknownType) {
 914             return null;
 915         }
 916         Symbol descSym = findDescriptorSymbol(target.tsym);
 917         Type descType = findDescriptorType(target);
 918         ClassSymbol csym = new ClassSymbol(cflags, name, env.enclClass.sym.outermostClass());
 919         csym.completer = Completer.NULL_COMPLETER;
 920         csym.members_field = WriteableScope.create(csym);
 921         MethodSymbol instDescSym = new MethodSymbol(descSym.flags(), descSym.name, descType, csym);
 922         csym.members_field.enter(instDescSym);
 923         Type.ClassType ctype = new Type.ClassType(Type.noType, List.nil(), csym);
 924         ctype.supertype_field = syms.objectType;
 925         ctype.interfaces_field = target.isIntersection() ?
 926                 directSupertypes(target) :
 927                 List.of(target);
 928         csym.type = ctype;
 929         csym.sourcefile = ((ClassSymbol)csym.owner).sourcefile;
 930         return csym;
 931     }
 932 
 933     /**
 934      * Find the minimal set of methods that are overridden by the functional
 935      * descriptor in &#39;origin&#39;. All returned methods are assumed to have different
 936      * erased signatures.
 937      */
 938     public List&lt;Symbol&gt; functionalInterfaceBridges(TypeSymbol origin) {
 939         Assert.check(isFunctionalInterface(origin));
 940         Symbol descSym = findDescriptorSymbol(origin);
 941         CompoundScope members = membersClosure(origin.type, false);
 942         ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
 943         outer: for (Symbol m2 : members.getSymbolsByName(descSym.name, bridgeFilter)) {
 944             if (m2 == descSym) continue;
 945             else if (descSym.overrides(m2, origin, Types.this, false)) {
 946                 for (Symbol m3 : overridden) {
 947                     if (isSameType(m3.erasure(Types.this), m2.erasure(Types.this)) ||
 948                             (m3.overrides(m2, origin, Types.this, false) &amp;&amp;
 949                             (pendingBridges((ClassSymbol)origin, m3.enclClass()) ||
 950                             (((MethodSymbol)m2).binaryImplementation((ClassSymbol)m3.owner, Types.this) != null)))) {
 951                         continue outer;
 952                     }
 953                 }
 954                 overridden.add(m2);
 955             }
 956         }
 957         return overridden.toList();
 958     }
 959     //where
 960         private Filter&lt;Symbol&gt; bridgeFilter = new Filter&lt;Symbol&gt;() {
 961             public boolean accepts(Symbol t) {
 962                 return t.kind == MTH &amp;&amp;
 963                         t.name != names.init &amp;&amp;
 964                         t.name != names.clinit &amp;&amp;
 965                         (t.flags() &amp; SYNTHETIC) == 0;
 966             }
 967         };
 968         private boolean pendingBridges(ClassSymbol origin, TypeSymbol s) {
 969             //a symbol will be completed from a classfile if (a) symbol has
 970             //an associated file object with CLASS kind and (b) the symbol has
 971             //not been entered
 972             if (origin.classfile != null &amp;&amp;
 973                     origin.classfile.getKind() == JavaFileObject.Kind.CLASS &amp;&amp;
 974                     enter.getEnv(origin) == null) {
 975                 return false;
 976             }
 977             if (origin == s) {
 978                 return true;
 979             }
 980             for (Type t : interfaces(origin.type)) {
 981                 if (pendingBridges((ClassSymbol)t.tsym, s)) {
 982                     return true;
 983                 }
 984             }
 985             return false;
 986         }
 987     // &lt;/editor-fold&gt;
 988 
 989    /**
 990     * Scope filter used to skip methods that should be ignored (such as methods
 991     * overridden by j.l.Object) during function interface conversion interface check
 992     */
 993     class DescriptorFilter implements Filter&lt;Symbol&gt; {
 994 
 995        TypeSymbol origin;
 996 
 997        DescriptorFilter(TypeSymbol origin) {
 998            this.origin = origin;
 999        }
1000 
1001        @Override
1002        public boolean accepts(Symbol sym) {
1003            return sym.kind == MTH &amp;&amp;
1004                    (sym.flags() &amp; (ABSTRACT | DEFAULT)) == ABSTRACT &amp;&amp;
1005                    !overridesObjectMethod(origin, sym) &amp;&amp;
1006                    (interfaceCandidates(origin.type, (MethodSymbol)sym).head.flags() &amp; DEFAULT) == 0;
1007        }
1008     }
1009 
1010     public boolean isValue(Type t) {
1011         return t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags_field &amp; Flags.VALUE) != 0;
1012     }
1013 
1014     public boolean isValueBased(Type t) {
1015         return allowValueBasedClasses &amp;&amp; t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags() &amp; Flags.VALUEBASED) != 0;
1016     }
1017 
1018     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSubtype&quot;&gt;
1019     /**
1020      * Is t an unchecked subtype of s?
1021      */
1022     public boolean isSubtypeUnchecked(Type t, Type s) {
1023         return isSubtypeUnchecked(t, s, noWarnings);
1024     }
1025     /**
1026      * Is t an unchecked subtype of s?
1027      */
1028     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
1029         boolean result = isSubtypeUncheckedInternal(t, s, true, warn);
1030         if (result) {
1031             checkUnsafeVarargsConversion(t, s, warn);
1032         }
1033         return result;
1034     }
1035     //where
1036         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
1037             if (t.hasTag(ARRAY) &amp;&amp; s.hasTag(ARRAY)) {
1038                 if (((ArrayType)t).elemtype.isPrimitive()) {
1039                     return isSameType(elemtype(t), elemtype(s));
1040                 } else {
1041                     // if T.ref &lt;: S, then T[] &lt;: S[]
1042                     Type es = elemtype(s);
1043                     Type et = elemtype(t);
1044                     if (isValue(et)) {
1045                         et = et.referenceProjection();
1046                         if (isValue(es))
1047                             es = es.referenceProjection();  // V &lt;: V, surely
1048                     }
1049                     if (!isSubtypeUncheckedInternal(et, es, false, warn))
1050                         return false;
1051                     return true;
1052                 }
1053             } else if (isSubtype(t, s, capture)) {
1054                 return true;
1055             } else if (t.hasTag(TYPEVAR)) {
1056                 return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);
1057             } else if (!s.isRaw()) {
1058                 Type t2 = asSuper(t, s.tsym);
1059                 if (t2 != null &amp;&amp; t2.isRaw()) {
1060                     if (isReifiable(s)) {
1061                         warn.silentWarn(LintCategory.UNCHECKED);
1062                     } else {
1063                         warn.warn(LintCategory.UNCHECKED);
1064                     }
1065                     return true;
1066                 }
1067             }
1068             return false;
1069         }
1070 
1071         private void checkUnsafeVarargsConversion(Type t, Type s, Warner warn) {
1072             if (!t.hasTag(ARRAY) || isReifiable(t)) {
1073                 return;
1074             }
1075             ArrayType from = (ArrayType)t;
1076             boolean shouldWarn = false;
1077             switch (s.getTag()) {
1078                 case ARRAY:
1079                     ArrayType to = (ArrayType)s;
1080                     shouldWarn = from.isVarargs() &amp;&amp;
1081                             !to.isVarargs() &amp;&amp;
1082                             !isReifiable(from);
1083                     break;
1084                 case CLASS:
1085                     shouldWarn = from.isVarargs();
1086                     break;
1087             }
1088             if (shouldWarn) {
1089                 warn.warn(LintCategory.VARARGS);
1090             }
1091         }
1092 
1093     /**
1094      * Is t a subtype of s?&lt;br&gt;
1095      * (not defined for Method and ForAll types)
1096      */
1097     final public boolean isSubtype(Type t, Type s) {
1098         return isSubtype(t, s, true);
1099     }
1100     final public boolean isSubtypeNoCapture(Type t, Type s) {
1101         return isSubtype(t, s, false);
1102     }
1103     public boolean isSubtype(Type t, Type s, boolean capture) {
1104         if (t.equalsIgnoreMetadata(s))
1105             return true;
1106         if (s.isPartial())
1107             return isSuperType(s, t);
1108 
1109         if (s.isCompound()) {
1110             for (Type s2 : interfaces(s).prepend(supertype(s))) {
1111                 if (!isSubtype(t, s2, capture))
1112                     return false;
1113             }
1114             return true;
1115         }
1116 
1117         // Generally, if &#39;s&#39; is a lower-bounded type variable, recur on lower bound; but
1118         // for inference variables and intersections, we need to keep &#39;s&#39;
1119         // (see JLS 4.10.2 for intersections and 18.2.3 for inference vars)
1120         if (!t.hasTag(UNDETVAR) &amp;&amp; !t.isCompound()) {
1121             // TODO: JDK-8039198, bounds checking sometimes passes in a wildcard as s
1122             Type lower = cvarLowerBound(wildLowerBound(s));
1123             if (s != lower &amp;&amp; !lower.hasTag(BOT))
1124                 return isSubtype(capture ? capture(t) : t, lower, false);
1125         }
1126 
1127         return isSubtype.visit(capture ? capture(t) : t, s);
1128     }
1129     // where
1130         private TypeRelation isSubtype = new TypeRelation()
1131         {
1132             @Override
1133             public Boolean visitType(Type t, Type s) {
1134                 switch (t.getTag()) {
1135                  case BYTE:
1136                      return (!s.hasTag(CHAR) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1137                  case CHAR:
1138                      return (!s.hasTag(SHORT) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1139                  case SHORT: case INT: case LONG:
1140                  case FLOAT: case DOUBLE:
1141                      return t.getTag().isSubRangeOf(s.getTag());
1142                  case BOOLEAN: case VOID:
1143                      return t.hasTag(s.getTag());
1144                  case TYPEVAR:
1145                      return isSubtypeNoCapture(t.getUpperBound(), s);
1146                  case BOT:
1147                      return
1148                          s.hasTag(BOT) || (s.hasTag(CLASS) &amp;&amp; (!isValue(s) || isValueBased(s))) ||
1149                          s.hasTag(ARRAY) || s.hasTag(TYPEVAR);
1150                  case WILDCARD: //we shouldn&#39;t be here - avoids crash (see 7034495)
1151                  case NONE:
1152                      return false;
1153                  default:
1154                      throw new AssertionError(&quot;isSubtype &quot; + t.getTag());
1155                  }
1156             }
1157 
1158             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1159 
1160             private boolean containsTypeRecursive(Type t, Type s) {
1161                 TypePair pair = new TypePair(t, s);
1162                 if (cache.add(pair)) {
1163                     try {
1164                         return containsType(t.getTypeArguments(),
1165                                             s.getTypeArguments());
1166                     } finally {
1167                         cache.remove(pair);
1168                     }
1169                 } else {
1170                     return containsType(t.getTypeArguments(),
1171                                         rewriteSupers(s).getTypeArguments());
1172                 }
1173             }
1174 
1175             private Type rewriteSupers(Type t) {
1176                 if (!t.isParameterized())
1177                     return t;
1178                 ListBuffer&lt;Type&gt; from = new ListBuffer&lt;&gt;();
1179                 ListBuffer&lt;Type&gt; to = new ListBuffer&lt;&gt;();
1180                 adaptSelf(t, from, to);
1181                 if (from.isEmpty())
1182                     return t;
1183                 ListBuffer&lt;Type&gt; rewrite = new ListBuffer&lt;&gt;();
1184                 boolean changed = false;
1185                 for (Type orig : to.toList()) {
1186                     Type s = rewriteSupers(orig);
1187                     if (s.isSuperBound() &amp;&amp; !s.isExtendsBound()) {
1188                         s = new WildcardType(syms.objectType,
1189                                              BoundKind.UNBOUND,
1190                                              syms.boundClass,
1191                                              s.getMetadata());
1192                         changed = true;
1193                     } else if (s != orig) {
1194                         s = new WildcardType(wildUpperBound(s),
1195                                              BoundKind.EXTENDS,
1196                                              syms.boundClass,
1197                                              s.getMetadata());
1198                         changed = true;
1199                     }
1200                     rewrite.append(s);
1201                 }
1202                 if (changed)
1203                     return subst(t.tsym.type, from.toList(), rewrite.toList());
1204                 else
1205                     return t;
1206             }
1207 
1208             @Override
1209             public Boolean visitClassType(ClassType t, Type s) {
1210                 Type sup = asSuper(t, s.tsym);
1211                 if (sup == null) return false;
1212                 // If t is an intersection, sup might not be a class type
1213                 if (!sup.hasTag(CLASS)) return isSubtypeNoCapture(sup, s);
1214                 return sup.tsym == s.tsym
1215                      // Check type variable containment
1216                     &amp;&amp; (!s.isParameterized() || containsTypeRecursive(s, sup))
1217                     &amp;&amp; isSubtypeNoCapture(sup.getEnclosingType(),
1218                                           s.getEnclosingType());
1219             }
1220 
1221             @Override
1222             public Boolean visitArrayType(ArrayType t, Type s) {
1223                 if (s.hasTag(ARRAY)) {
1224                     if (t.elemtype.isPrimitive())
1225                         return isSameType(t.elemtype, elemtype(s));
1226                     else {
1227                         // if T.ref &lt;: S, then T[] &lt;: S[]
1228                         Type es = elemtype(s);
1229                         Type et = elemtype(t);
1230                         if (isValue(et)) {
1231                             et = et.referenceProjection();
1232                             if (isValue(es))
1233                                 es = es.referenceProjection();  // V &lt;: V, surely
1234                         }
1235                         return isSubtypeNoCapture(et, es);
1236                     }
1237                 }
1238 
1239                 if (s.hasTag(CLASS)) {
1240                     Name sname = s.tsym.getQualifiedName();
1241                     return sname == names.java_lang_Object
1242                         || sname == names.java_lang_Cloneable
1243                         || sname == names.java_io_Serializable
1244                         || sname == names.java_lang_IdentityObject;
1245                 }
1246 
1247                 return false;
1248             }
1249 
1250             @Override
1251             public Boolean visitUndetVar(UndetVar t, Type s) {
1252                 //todo: test against origin needed? or replace with substitution?
1253                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1254                     return true;
1255                 } else if (s.hasTag(BOT)) {
1256                     //if &#39;s&#39; is &#39;null&#39; there&#39;s no instantiated type U for which
1257                     //U &lt;: s (but &#39;null&#39; itself, which is not a valid type)
1258                     return false;
1259                 }
1260 
1261                 t.addBound(InferenceBound.UPPER, s, Types.this);
1262                 return true;
1263             }
1264 
1265             @Override
1266             public Boolean visitErrorType(ErrorType t, Type s) {
1267                 return true;
1268             }
1269         };
1270 
1271     /**
1272      * Is t a subtype of every type in given list `ts&#39;?&lt;br&gt;
1273      * (not defined for Method and ForAll types)&lt;br&gt;
1274      * Allows unchecked conversions.
1275      */
1276     public boolean isSubtypeUnchecked(Type t, List&lt;Type&gt; ts, Warner warn) {
1277         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1278             if (!isSubtypeUnchecked(t, l.head, warn))
1279                 return false;
1280         return true;
1281     }
1282 
1283     /**
1284      * Are corresponding elements of ts subtypes of ss?  If lists are
1285      * of different length, return false.
1286      */
1287     public boolean isSubtypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1288         while (ts.tail != null &amp;&amp; ss.tail != null
1289                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1290                isSubtype(ts.head, ss.head)) {
1291             ts = ts.tail;
1292             ss = ss.tail;
1293         }
1294         return ts.tail == null &amp;&amp; ss.tail == null;
1295         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1296     }
1297 
1298     /**
1299      * Are corresponding elements of ts subtypes of ss, allowing
1300      * unchecked conversions?  If lists are of different length,
1301      * return false.
1302      **/
1303     public boolean isSubtypesUnchecked(List&lt;Type&gt; ts, List&lt;Type&gt; ss, Warner warn) {
1304         while (ts.tail != null &amp;&amp; ss.tail != null
1305                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1306                isSubtypeUnchecked(ts.head, ss.head, warn)) {
1307             ts = ts.tail;
1308             ss = ss.tail;
1309         }
1310         return ts.tail == null &amp;&amp; ss.tail == null;
1311         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1312     }
1313     // &lt;/editor-fold&gt;
1314 
1315     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSuperType&quot;&gt;
1316     /**
1317      * Is t a supertype of s?
1318      */
1319     public boolean isSuperType(Type t, Type s) {
1320         switch (t.getTag()) {
1321         case ERROR:
1322             return true;
1323         case UNDETVAR: {
1324             UndetVar undet = (UndetVar)t;
1325             if (t == s ||
1326                 undet.qtype == s ||
1327                 s.hasTag(ERROR) ||
1328                 s.hasTag(BOT)) {
1329                 return true;
1330             }
1331             undet.addBound(InferenceBound.LOWER, s, this);
1332             return true;
1333         }
1334         default:
1335             return isSubtype(s, t);
1336         }
1337     }
1338     // &lt;/editor-fold&gt;
1339 
1340     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSameType&quot;&gt;
1341     /**
1342      * Are corresponding elements of the lists the same type?  If
1343      * lists are of different length, return false.
1344      */
1345     public boolean isSameTypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1346         while (ts.tail != null &amp;&amp; ss.tail != null
1347                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1348                isSameType(ts.head, ss.head)) {
1349             ts = ts.tail;
1350             ss = ss.tail;
1351         }
1352         return ts.tail == null &amp;&amp; ss.tail == null;
1353         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1354     }
1355 
1356     /**
1357      * A polymorphic signature method (JLS 15.12.3) is a method that
1358      *   (i) is declared in the java.lang.invoke.MethodHandle/VarHandle classes;
1359      *  (ii) takes a single variable arity parameter;
1360      * (iii) whose declared type is Object[];
1361      *  (iv) has any return type, Object signifying a polymorphic return type; and
1362      *   (v) is native.
1363     */
1364    public boolean isSignaturePolymorphic(MethodSymbol msym) {
1365        List&lt;Type&gt; argtypes = msym.type.getParameterTypes();
1366        return (msym.flags_field &amp; NATIVE) != 0 &amp;&amp;
1367               (msym.owner == syms.methodHandleType.tsym || msym.owner == syms.varHandleType.tsym) &amp;&amp;
1368                argtypes.length() == 1 &amp;&amp;
1369                argtypes.head.hasTag(TypeTag.ARRAY) &amp;&amp;
1370                ((ArrayType)argtypes.head).elemtype.tsym == syms.objectType.tsym;
1371    }
1372 
1373     /**
1374      * Is t the same type as s?
1375      */
1376     public boolean isSameType(Type t, Type s) {
1377         return isSameTypeVisitor.visit(t, s);
1378     }
1379     // where
1380 
1381         /**
1382          * Type-equality relation - type variables are considered
1383          * equals if they share the same object identity.
1384          */
1385         TypeRelation isSameTypeVisitor = new TypeRelation() {
1386 
1387             public Boolean visitType(Type t, Type s) {
1388                 if (t.equalsIgnoreMetadata(s))
1389                     return true;
1390 
1391                 if (s.isPartial())
1392                     return visit(s, t);
1393 
1394                 switch (t.getTag()) {
1395                 case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
1396                 case DOUBLE: case BOOLEAN: case VOID: case BOT: case NONE:
1397                     return t.hasTag(s.getTag());
1398                 case TYPEVAR: {
1399                     if (s.hasTag(TYPEVAR)) {
1400                         //type-substitution does not preserve type-var types
1401                         //check that type var symbols and bounds are indeed the same
1402                         return t == s;
1403                     }
1404                     else {
1405                         //special case for s == ? super X, where upper(s) = u
1406                         //check that u == t, where u has been set by Type.withTypeVar
1407                         return s.isSuperBound() &amp;&amp;
1408                                 !s.isExtendsBound() &amp;&amp;
1409                                 visit(t, wildUpperBound(s));
1410                     }
1411                 }
1412                 default:
1413                     throw new AssertionError(&quot;isSameType &quot; + t.getTag());
1414                 }
1415             }
1416 
1417             @Override
1418             public Boolean visitWildcardType(WildcardType t, Type s) {
1419                 if (!s.hasTag(WILDCARD)) {
1420                     return false;
1421                 } else {
1422                     WildcardType t2 = (WildcardType)s;
1423                     return (t.kind == t2.kind || (t.isExtendsBound() &amp;&amp; s.isExtendsBound())) &amp;&amp;
1424                             isSameType(t.type, t2.type);
1425                 }
1426             }
1427 
1428             @Override
1429             public Boolean visitClassType(ClassType t, Type s) {
1430                 if (t == s)
1431                     return true;
1432 
1433                 if (s.isPartial())
1434                     return visit(s, t);
1435 
1436                 if (s.isSuperBound() &amp;&amp; !s.isExtendsBound())
1437                     return visit(t, wildUpperBound(s)) &amp;&amp; visit(t, wildLowerBound(s));
1438 
1439                 if (t.isCompound() &amp;&amp; s.isCompound()) {
1440                     if (!visit(supertype(t), supertype(s)))
1441                         return false;
1442 
1443                     Map&lt;Symbol,Type&gt; tMap = new HashMap&lt;&gt;();
1444                     for (Type ti : interfaces(t)) {
1445                         if (tMap.containsKey(ti)) {
1446                             throw new AssertionError(&quot;Malformed intersection&quot;);
1447                         }
1448                         tMap.put(ti.tsym, ti);
1449                     }
1450                     for (Type si : interfaces(s)) {
1451                         if (!tMap.containsKey(si.tsym))
1452                             return false;
1453                         Type ti = tMap.remove(si.tsym);
1454                         if (!visit(ti, si))
1455                             return false;
1456                     }
1457                     return tMap.isEmpty();
1458                 }
1459                 return t.tsym == s.tsym
1460                     &amp;&amp; visit(t.getEnclosingType(), s.getEnclosingType())
1461                     &amp;&amp; containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());
1462             }
1463 
1464             @Override
1465             public Boolean visitArrayType(ArrayType t, Type s) {
1466                 if (t == s)
1467                     return true;
1468 
1469                 if (s.isPartial())
1470                     return visit(s, t);
1471 
1472                 return s.hasTag(ARRAY)
1473                     &amp;&amp; containsTypeEquivalent(t.elemtype, elemtype(s));
1474             }
1475 
1476             @Override
1477             public Boolean visitMethodType(MethodType t, Type s) {
1478                 // isSameType for methods does not take thrown
1479                 // exceptions into account!
1480                 return hasSameArgs(t, s) &amp;&amp; visit(t.getReturnType(), s.getReturnType());
1481             }
1482 
1483             @Override
1484             public Boolean visitPackageType(PackageType t, Type s) {
1485                 return t == s;
1486             }
1487 
1488             @Override
1489             public Boolean visitForAll(ForAll t, Type s) {
1490                 if (!s.hasTag(FORALL)) {
1491                     return false;
1492                 }
1493 
1494                 ForAll forAll = (ForAll)s;
1495                 return hasSameBounds(t, forAll)
1496                     &amp;&amp; visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));
1497             }
1498 
1499             @Override
1500             public Boolean visitUndetVar(UndetVar t, Type s) {
1501                 if (s.hasTag(WILDCARD)) {
1502                     // FIXME, this might be leftovers from before capture conversion
1503                     return false;
1504                 }
1505 
1506                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1507                     return true;
1508                 }
1509 
1510                 t.addBound(InferenceBound.EQ, s, Types.this);
1511 
1512                 return true;
1513             }
1514 
1515             @Override
1516             public Boolean visitErrorType(ErrorType t, Type s) {
1517                 return true;
1518             }
1519         };
1520 
1521     // &lt;/editor-fold&gt;
1522 
1523     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Contains Type&quot;&gt;
1524     public boolean containedBy(Type t, Type s) {
1525         switch (t.getTag()) {
1526         case UNDETVAR:
1527             if (s.hasTag(WILDCARD)) {
1528                 UndetVar undetvar = (UndetVar)t;
1529                 WildcardType wt = (WildcardType)s;
1530                 switch(wt.kind) {
1531                     case UNBOUND:
1532                         break;
1533                     case EXTENDS: {
1534                         Type bound = wildUpperBound(s);
1535                         undetvar.addBound(InferenceBound.UPPER, bound, this);
1536                         break;
1537                     }
1538                     case SUPER: {
1539                         Type bound = wildLowerBound(s);
1540                         undetvar.addBound(InferenceBound.LOWER, bound, this);
1541                         break;
1542                     }
1543                 }
1544                 return true;
1545             } else {
1546                 return isSameType(t, s);
1547             }
1548         case ERROR:
1549             return true;
1550         default:
1551             return containsType(s, t);
1552         }
1553     }
1554 
1555     boolean containsType(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1556         while (ts.nonEmpty() &amp;&amp; ss.nonEmpty()
1557                &amp;&amp; containsType(ts.head, ss.head)) {
1558             ts = ts.tail;
1559             ss = ss.tail;
1560         }
1561         return ts.isEmpty() &amp;&amp; ss.isEmpty();
1562     }
1563 
1564     /**
1565      * Check if t contains s.
1566      *
1567      * &lt;p&gt;T contains S if:
1568      *
1569      * &lt;p&gt;{@code L(T) &lt;: L(S) &amp;&amp; U(S) &lt;: U(T)}
1570      *
1571      * &lt;p&gt;This relation is only used by ClassType.isSubtype(), that
1572      * is,
1573      *
1574      * &lt;p&gt;{@code C&lt;S&gt; &lt;: C&lt;T&gt; if T contains S.}
1575      *
1576      * &lt;p&gt;Because of F-bounds, this relation can lead to infinite
1577      * recursion.  Thus we must somehow break that recursion.  Notice
1578      * that containsType() is only called from ClassType.isSubtype().
1579      * Since the arguments have already been checked against their
1580      * bounds, we know:
1581      *
1582      * &lt;p&gt;{@code U(S) &lt;: U(T) if T is &quot;super&quot; bound (U(T) *is* the bound)}
1583      *
1584      * &lt;p&gt;{@code L(T) &lt;: L(S) if T is &quot;extends&quot; bound (L(T) is bottom)}
1585      *
1586      * @param t a type
1587      * @param s a type
1588      */
1589     public boolean containsType(Type t, Type s) {
1590         return containsType.visit(t, s);
1591     }
1592     // where
1593         private TypeRelation containsType = new TypeRelation() {
1594 
1595             public Boolean visitType(Type t, Type s) {
1596                 if (s.isPartial())
1597                     return containedBy(s, t);
1598                 else
1599                     return isSameType(t, s);
1600             }
1601 
1602 //            void debugContainsType(WildcardType t, Type s) {
1603 //                System.err.println();
1604 //                System.err.format(&quot; does %s contain %s?%n&quot;, t, s);
1605 //                System.err.format(&quot; %s U(%s) &lt;: U(%s) %s = %s%n&quot;,
1606 //                                  wildUpperBound(s), s, t, wildUpperBound(t),
1607 //                                  t.isSuperBound()
1608 //                                  || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t)));
1609 //                System.err.format(&quot; %s L(%s) &lt;: L(%s) %s = %s%n&quot;,
1610 //                                  wildLowerBound(t), t, s, wildLowerBound(s),
1611 //                                  t.isExtendsBound()
1612 //                                  || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s)));
1613 //                System.err.println();
1614 //            }
1615 
1616             @Override
1617             public Boolean visitWildcardType(WildcardType t, Type s) {
1618                 if (s.isPartial())
1619                     return containedBy(s, t);
1620                 else {
1621 //                    debugContainsType(t, s);
1622 
1623                     // -----------------------------------  Unspecified behavior ----------------
1624 
1625                     /* If a value class V implements an interface I, then does &quot;? extends I&quot; contain V?
1626                        It seems widening must be applied here to answer yes to compile some common code
1627                        patterns.
1628                     */
1629 
1630                     // ---------------------------------------------------------------------------
1631                     return isSameWildcard(t, s)
1632                         || isCaptureOf(s, t)
1633                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &amp;&amp;
1634                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
1635                 }
1636             }
1637 
1638             @Override
1639             public Boolean visitUndetVar(UndetVar t, Type s) {
1640                 if (!s.hasTag(WILDCARD)) {
1641                     return isSameType(t, s);
1642                 } else {
1643                     return false;
1644                 }
1645             }
1646 
1647             @Override
1648             public Boolean visitErrorType(ErrorType t, Type s) {
1649                 return true;
1650             }
1651         };
1652 
1653     public boolean isCaptureOf(Type s, WildcardType t) {
1654         if (!s.hasTag(TYPEVAR) || !((TypeVar)s).isCaptured())
1655             return false;
1656         return isSameWildcard(t, ((CapturedType)s).wildcard);
1657     }
1658 
1659     public boolean isSameWildcard(WildcardType t, Type s) {
1660         if (!s.hasTag(WILDCARD))
1661             return false;
1662         WildcardType w = (WildcardType)s;
1663         return w.kind == t.kind &amp;&amp; w.type == t.type;
1664     }
1665 
1666     public boolean containsTypeEquivalent(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1667         while (ts.nonEmpty() &amp;&amp; ss.nonEmpty()
1668                &amp;&amp; containsTypeEquivalent(ts.head, ss.head)) {
1669             ts = ts.tail;
1670             ss = ss.tail;
1671         }
1672         return ts.isEmpty() &amp;&amp; ss.isEmpty();
1673     }
1674     // &lt;/editor-fold&gt;
1675 
1676     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isCastable&quot;&gt;
1677     public boolean isCastable(Type t, Type s) {
1678         return isCastable(t, s, noWarnings);
1679     }
1680 
1681     /**
1682      * Is t is castable to s?&lt;br&gt;
1683      * s is assumed to be an erased type.&lt;br&gt;
1684      * (not defined for Method and ForAll types).
1685      */
1686     public boolean isCastable(Type t, Type s, Warner warn) {
1687         if (t == s)
1688             return true;
1689         if (t.isPrimitive() != s.isPrimitive()) {
1690             t = skipTypeVars(t, false);
1691             return (isConvertible(t, s, warn)
1692                     || (s.isPrimitive() &amp;&amp;
1693                         isSubtype(boxedClass(s).type, t)));
1694         }
1695         if (warn != warnStack.head) {
1696             try {
1697                 warnStack = warnStack.prepend(warn);
1698                 checkUnsafeVarargsConversion(t, s, warn);
1699                 return isCastable.visit(t,s);
1700             } finally {
1701                 warnStack = warnStack.tail;
1702             }
1703         } else {
1704             return isCastable.visit(t,s);
1705         }
1706     }
1707     // where
1708         private TypeRelation isCastable = new TypeRelation() {
1709 
1710             public Boolean visitType(Type t, Type s) {
1711                 if (s.hasTag(ERROR) || t.hasTag(NONE))
1712                     return true;
1713 
1714                 switch (t.getTag()) {
1715                 case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
1716                 case DOUBLE:
1717                     return s.isNumeric();
1718                 case BOOLEAN:
1719                     return s.hasTag(BOOLEAN);
1720                 case VOID:
1721                     return false;
1722                 case BOT:
1723                     return isSubtype(t, s);
1724                 default:
1725                     throw new AssertionError();
1726                 }
1727             }
1728 
1729             @Override
1730             public Boolean visitWildcardType(WildcardType t, Type s) {
1731                 return isCastable(wildUpperBound(t), s, warnStack.head);
1732             }
1733 
1734             @Override
1735             public Boolean visitClassType(ClassType t, Type s) {
1736                 if (s.hasTag(ERROR) || (s.hasTag(BOT) &amp;&amp; !isValue(t)))
1737                     return true;
1738 
1739                 if (s.hasTag(TYPEVAR)) {
1740                     if (isCastable(t, s.getUpperBound(), noWarnings)) {
1741                         warnStack.head.warn(LintCategory.UNCHECKED);
1742                         return true;
1743                     } else {
1744                         return false;
1745                     }
1746                 }
1747 
1748                 if (t.isCompound() || s.isCompound()) {
1749                     return !t.isCompound() ?
1750                             visitCompoundType((ClassType)s, t, true) :
1751                             visitCompoundType(t, s, false);
1752                 }
1753 
1754                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {
1755                     if (isValue(t)) {
1756                         // (s) Value ? == (s) Value.ref
1757                         t = t.referenceProjection();
1758                     }
1759                     if (isValue(s)) {
1760                         // (Value) t ? == (Value.ref) t
1761                         s = s.referenceProjection();
1762                     }
1763                     boolean upcast;
1764                     if ((upcast = isSubtype(erasure(t), erasure(s)))
1765                         || isSubtype(erasure(s), erasure(t))) {
1766                         if (!upcast &amp;&amp; s.hasTag(ARRAY)) {
1767                             if (!isReifiable(s))
1768                                 warnStack.head.warn(LintCategory.UNCHECKED);
1769                             return true;
1770                         } else if (s.isRaw()) {
1771                             return true;
1772                         } else if (t.isRaw()) {
1773                             if (!isUnbounded(s))
1774                                 warnStack.head.warn(LintCategory.UNCHECKED);
1775                             return true;
1776                         }
1777                         // Assume |a| &lt;: |b|
1778                         final Type a = upcast ? t : s;
1779                         final Type b = upcast ? s : t;
1780                         final boolean HIGH = true;
1781                         final boolean LOW = false;
1782                         final boolean DONT_REWRITE_TYPEVARS = false;
1783                         Type aHigh = rewriteQuantifiers(a, HIGH, DONT_REWRITE_TYPEVARS);
1784                         Type aLow  = rewriteQuantifiers(a, LOW,  DONT_REWRITE_TYPEVARS);
1785                         Type bHigh = rewriteQuantifiers(b, HIGH, DONT_REWRITE_TYPEVARS);
1786                         Type bLow  = rewriteQuantifiers(b, LOW,  DONT_REWRITE_TYPEVARS);
1787                         Type lowSub = asSub(bLow, aLow.tsym);
1788                         Type highSub = (lowSub == null) ? null : asSub(bHigh, aHigh.tsym);
1789                         if (highSub == null) {
1790                             final boolean REWRITE_TYPEVARS = true;
1791                             aHigh = rewriteQuantifiers(a, HIGH, REWRITE_TYPEVARS);
1792                             aLow  = rewriteQuantifiers(a, LOW,  REWRITE_TYPEVARS);
1793                             bHigh = rewriteQuantifiers(b, HIGH, REWRITE_TYPEVARS);
1794                             bLow  = rewriteQuantifiers(b, LOW,  REWRITE_TYPEVARS);
1795                             lowSub = asSub(bLow, aLow.tsym);
1796                             highSub = (lowSub == null) ? null : asSub(bHigh, aHigh.tsym);
1797                         }
1798                         if (highSub != null) {
1799                             if (!(a.tsym == highSub.tsym &amp;&amp; a.tsym == lowSub.tsym)) {
1800                                 Assert.error(a.tsym + &quot; != &quot; + highSub.tsym + &quot; != &quot; + lowSub.tsym);
1801                             }
1802                             if (!disjointTypes(aHigh.allparams(), highSub.allparams())
1803                                 &amp;&amp; !disjointTypes(aHigh.allparams(), lowSub.allparams())
1804                                 &amp;&amp; !disjointTypes(aLow.allparams(), highSub.allparams())
1805                                 &amp;&amp; !disjointTypes(aLow.allparams(), lowSub.allparams())) {
1806                                 if (upcast ? giveWarning(a, b) :
1807                                     giveWarning(b, a))
1808                                     warnStack.head.warn(LintCategory.UNCHECKED);
1809                                 return true;
1810                             }
1811                         }
1812                         if (isReifiable(s))
1813                             return isSubtypeUnchecked(a, b);
1814                         else
1815                             return isSubtypeUnchecked(a, b, warnStack.head);
1816                     }
1817 
1818                     // Sidecast
1819                     if (s.hasTag(CLASS)) {
1820                         if ((s.tsym.flags() &amp; INTERFACE) != 0) {
1821                             return (dynamicTypeMayImplementAdditionalInterfaces(t.tsym))
1822                                 ? sideCast(t, s, warnStack.head)
1823                                 : sideCastFinal(t, s, warnStack.head);
1824                         } else if ((t.tsym.flags() &amp; INTERFACE) != 0) {
1825                             return ((s.tsym.flags() &amp; FINAL) == 0)
1826                                 ? sideCast(t, s, warnStack.head)
1827                                 : sideCastFinal(t, s, warnStack.head);
1828                         } else {
1829                             // unrelated class types
1830                             return false;
1831                         }
1832                     }
1833                 }
1834                 return false;
1835             }
1836 
1837             boolean visitCompoundType(ClassType ct, Type s, boolean reverse) {
1838                 Warner warn = noWarnings;
1839                 for (Type c : directSupertypes(ct)) {
1840                     warn.clear();
1841                     if (reverse ? !isCastable(s, c, warn) : !isCastable(c, s, warn))
1842                         return false;
1843                 }
1844                 if (warn.hasLint(LintCategory.UNCHECKED))
1845                     warnStack.head.warn(LintCategory.UNCHECKED);
1846                 return true;
1847             }
1848 
1849             @Override
1850             public Boolean visitArrayType(ArrayType t, Type s) {
1851                 switch (s.getTag()) {
1852                 case ERROR:
1853                 case BOT:
1854                     return true;
1855                 case TYPEVAR:
1856                     if (isCastable(s, t, noWarnings)) {
1857                         warnStack.head.warn(LintCategory.UNCHECKED);
1858                         return true;
1859                     } else {
1860                         return false;
1861                     }
1862                 case CLASS:
1863                     return isSubtype(t, s);
1864                 case ARRAY:
1865                     if (elemtype(t).isPrimitive() || elemtype(s).isPrimitive()) {
1866                         return elemtype(t).hasTag(elemtype(s).getTag());
1867                     } else {
1868                         Type et = elemtype(t);
1869                         Type es = elemtype(s);
1870                         if (!visit(et, es))
1871                             return false;
1872                         return true;
1873                     }
1874                 default:
1875                     return false;
1876                 }
1877             }
1878 
1879             @Override
1880             public Boolean visitTypeVar(TypeVar t, Type s) {
1881                 switch (s.getTag()) {
1882                 case ERROR:
1883                 case BOT:
1884                     return true;
1885                 case TYPEVAR:
1886                     if (isSubtype(t, s)) {
1887                         return true;
1888                     } else if (isCastable(t.getUpperBound(), s, noWarnings)) {
1889                         warnStack.head.warn(LintCategory.UNCHECKED);
1890                         return true;
1891                     } else {
1892                         return false;
1893                     }
1894                 default:
1895                     return isCastable(t.getUpperBound(), s, warnStack.head);
1896                 }
1897             }
1898 
1899             @Override
1900             public Boolean visitErrorType(ErrorType t, Type s) {
1901                 return true;
1902             }
1903         };
1904     // &lt;/editor-fold&gt;
1905 
1906     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;disjointTypes&quot;&gt;
1907     public boolean disjointTypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1908         while (ts.tail != null &amp;&amp; ss.tail != null) {
1909             if (disjointType(ts.head, ss.head)) return true;
1910             ts = ts.tail;
1911             ss = ss.tail;
1912         }
1913         return false;
1914     }
1915 
1916     /**
1917      * Two types or wildcards are considered disjoint if it can be
1918      * proven that no type can be contained in both. It is
1919      * conservative in that it is allowed to say that two types are
1920      * not disjoint, even though they actually are.
1921      *
1922      * The type {@code C&lt;X&gt;} is castable to {@code C&lt;Y&gt;} exactly if
1923      * {@code X} and {@code Y} are not disjoint.
1924      */
1925     public boolean disjointType(Type t, Type s) {
1926         return disjointType.visit(t, s);
1927     }
1928     // where
1929         private TypeRelation disjointType = new TypeRelation() {
1930 
1931             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1932 
1933             @Override
1934             public Boolean visitType(Type t, Type s) {
1935                 if (s.hasTag(WILDCARD))
1936                     return visit(s, t);
1937                 else
1938                     return notSoftSubtypeRecursive(t, s) || notSoftSubtypeRecursive(s, t);
1939             }
1940 
1941             private boolean isCastableRecursive(Type t, Type s) {
1942                 TypePair pair = new TypePair(t, s);
1943                 if (cache.add(pair)) {
1944                     try {
1945                         return Types.this.isCastable(t, s);
1946                     } finally {
1947                         cache.remove(pair);
1948                     }
1949                 } else {
1950                     return true;
1951                 }
1952             }
1953 
1954             private boolean notSoftSubtypeRecursive(Type t, Type s) {
1955                 TypePair pair = new TypePair(t, s);
1956                 if (cache.add(pair)) {
1957                     try {
1958                         return Types.this.notSoftSubtype(t, s);
1959                     } finally {
1960                         cache.remove(pair);
1961                     }
1962                 } else {
1963                     return false;
1964                 }
1965             }
1966 
1967             @Override
1968             public Boolean visitWildcardType(WildcardType t, Type s) {
1969                 if (t.isUnbound())
1970                     return false;
1971 
1972                 if (!s.hasTag(WILDCARD)) {
1973                     if (t.isExtendsBound())
1974                         return notSoftSubtypeRecursive(s, t.type);
1975                     else
1976                         return notSoftSubtypeRecursive(t.type, s);
1977                 }
1978 
1979                 if (s.isUnbound())
1980                     return false;
1981 
1982                 if (t.isExtendsBound()) {
1983                     if (s.isExtendsBound())
1984                         return !isCastableRecursive(t.type, wildUpperBound(s));
1985                     else if (s.isSuperBound())
1986                         return notSoftSubtypeRecursive(wildLowerBound(s), t.type);
1987                 } else if (t.isSuperBound()) {
1988                     if (s.isExtendsBound())
1989                         return notSoftSubtypeRecursive(t.type, wildUpperBound(s));
1990                 }
1991                 return false;
1992             }
1993         };
1994     // &lt;/editor-fold&gt;
1995 
1996     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;cvarLowerBounds&quot;&gt;
1997     public List&lt;Type&gt; cvarLowerBounds(List&lt;Type&gt; ts) {
1998         return ts.map(cvarLowerBoundMapping);
1999     }
2000         private final TypeMapping&lt;Void&gt; cvarLowerBoundMapping = new TypeMapping&lt;Void&gt;() {
2001             @Override
2002             public Type visitCapturedType(CapturedType t, Void _unused) {
2003                 return cvarLowerBound(t);
2004             }
2005         };
2006     // &lt;/editor-fold&gt;
2007 
2008     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;notSoftSubtype&quot;&gt;
2009     /**
2010      * This relation answers the question: is impossible that
2011      * something of type `t&#39; can be a subtype of `s&#39;? This is
2012      * different from the question &quot;is `t&#39; not a subtype of `s&#39;?&quot;
2013      * when type variables are involved: Integer is not a subtype of T
2014      * where {@code &lt;T extends Number&gt;} but it is not true that Integer cannot
2015      * possibly be a subtype of T.
2016      */
2017     public boolean notSoftSubtype(Type t, Type s) {
2018         if (t == s) return false;
2019         if (t.hasTag(TYPEVAR)) {
2020             TypeVar tv = (TypeVar) t;
2021             return !isCastable(tv.getUpperBound(),
2022                                relaxBound(s),
2023                                noWarnings);
2024         }
2025         if (!s.hasTag(WILDCARD))
2026             s = cvarUpperBound(s);
2027 
2028         return !isSubtype(t, relaxBound(s));
2029     }
2030 
2031     private Type relaxBound(Type t) {
2032         return (t.hasTag(TYPEVAR)) ?
2033                 rewriteQuantifiers(skipTypeVars(t, false), true, true) :
2034                 t;
2035     }
2036     // &lt;/editor-fold&gt;
2037 
2038     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isReifiable&quot;&gt;
2039     public boolean isReifiable(Type t) {
2040         return isReifiable.visit(t);
2041     }
2042     // where
2043         private UnaryVisitor&lt;Boolean&gt; isReifiable = new UnaryVisitor&lt;Boolean&gt;() {
2044 
2045             public Boolean visitType(Type t, Void ignored) {
2046                 return true;
2047             }
2048 
2049             @Override
2050             public Boolean visitClassType(ClassType t, Void ignored) {
2051                 if (t.isCompound())
2052                     return false;
2053                 else {
2054                     if (!t.isParameterized())
2055                         return true;
2056 
2057                     for (Type param : t.allparams()) {
2058                         if (!param.isUnbound())
2059                             return false;
2060                     }
2061                     return true;
2062                 }
2063             }
2064 
2065             @Override
2066             public Boolean visitArrayType(ArrayType t, Void ignored) {
2067                 return visit(t.elemtype);
2068             }
2069 
2070             @Override
2071             public Boolean visitTypeVar(TypeVar t, Void ignored) {
2072                 return false;
2073             }
2074         };
2075     // &lt;/editor-fold&gt;
2076 
2077     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Array Utils&quot;&gt;
2078     public boolean isArray(Type t) {
2079         while (t.hasTag(WILDCARD))
2080             t = wildUpperBound(t);
2081         return t.hasTag(ARRAY);
2082     }
2083 
2084     /**
2085      * The element type of an array.
2086      */
2087     public Type elemtype(Type t) {
2088         switch (t.getTag()) {
2089         case WILDCARD:
2090             return elemtype(wildUpperBound(t));
2091         case ARRAY:
2092             return ((ArrayType)t).elemtype;
2093         case FORALL:
2094             return elemtype(((ForAll)t).qtype);
2095         case ERROR:
2096             return t;
2097         default:
2098             return null;
2099         }
2100     }
2101 
2102     public Type elemtypeOrType(Type t) {
2103         Type elemtype = elemtype(t);
2104         return elemtype != null ?
2105             elemtype :
2106             t;
2107     }
2108 
2109     /**
2110      * Mapping to take element type of an arraytype
2111      */
2112     private TypeMapping&lt;Void&gt; elemTypeFun = new TypeMapping&lt;Void&gt;() {
2113         @Override
2114         public Type visitArrayType(ArrayType t, Void _unused) {
2115             return t.elemtype;
2116         }
2117 
2118         @Override
2119         public Type visitTypeVar(TypeVar t, Void _unused) {
2120             return visit(skipTypeVars(t, false));
2121         }
2122     };
2123 
2124     /**
2125      * The number of dimensions of an array type.
2126      */
2127     public int dimensions(Type t) {
2128         int result = 0;
2129         while (t.hasTag(ARRAY)) {
2130             result++;
2131             t = elemtype(t);
2132         }
2133         return result;
2134     }
2135 
2136     /**
2137      * Returns an ArrayType with the component type t
2138      *
2139      * @param t The component type of the ArrayType
2140      * @return the ArrayType for the given component
2141      */
2142     public ArrayType makeArrayType(Type t) {
2143         if (t.hasTag(VOID) || t.hasTag(PACKAGE)) {
2144             Assert.error(&quot;Type t must not be a VOID or PACKAGE type, &quot; + t.toString());
2145         }
2146         return new ArrayType(t, syms.arrayClass);
2147     }
2148     // &lt;/editor-fold&gt;
2149 
2150     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSuper&quot;&gt;
2151     /**
2152      * Return the (most specific) base type of t that starts with the
2153      * given symbol.  If none exists, return null.
2154      *
2155      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2156      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2157      * this method could yield surprising answers when invoked on arrays. For example when
2158      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2159      *
2160      * @param t a type
2161      * @param sym a symbol
2162      */
2163     public Type asSuper(Type t, Symbol sym) {
2164         return asSuper(t, sym, false);
2165     }
2166 
2167     /**
2168      * Return the (most specific) base type of t that starts with the
2169      * given symbol.  If none exists, return null.
2170      *
2171      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2172      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2173      * this method could yield surprising answers when invoked on arrays. For example when
2174      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2175      *
2176      * @param t a type
2177      * @param sym a symbol
2178      * @param checkReferenceProjection if true, first compute reference projection of t
2179      */
2180     public Type asSuper(Type t, Symbol sym, boolean checkReferenceProjection) {
2181         /* Some examples:
2182          *
2183          * (Enum&lt;E&gt;, Comparable) =&gt; Comparable&lt;E&gt;
2184          * (c.s.s.d.AttributeTree.ValueKind, Enum) =&gt; Enum&lt;c.s.s.d.AttributeTree.ValueKind&gt;
2185          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) =&gt; c.s.s.t.Tree
2186          * (j.u.List&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;, Iterable) =&gt;
2187          *     Iterable&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;
2188          */
2189 
2190         /* For a (value or identity) class V, whether it implements an interface I, boils down to whether
2191            V.ref is a subtype of I. OIOW, whether asSuper(V.ref, sym) != null. (Likewise for an abstract
2192            superclass)
2193         */
2194         if (checkReferenceProjection)
2195             t = t.isValue() ? t.referenceProjection() : t;
2196 
2197         if (sym.type == syms.objectType) { //optimization
2198             if (!isValue(t))
2199                 return syms.objectType;
2200         }
2201         if (sym.type == syms.identityObjectType) {
2202             // IdentityObject is super interface of every concrete identity class other than jlO
2203             if (t.isValue() || t.tsym == syms.objectType.tsym)
2204                 return null;
2205             if (t.hasTag(ARRAY))
2206                 return syms.identityObjectType;
2207             if (t.hasTag(CLASS) &amp;&amp; !t.isReferenceProjection() &amp;&amp; !t.tsym.isInterface() &amp;&amp; !t.tsym.isAbstract()) {
2208                 return syms.identityObjectType;
2209             } // else fall through and look for explicit coded super interface
2210         }
2211         return asSuper.visit(t, sym);
2212     }
2213     // where
2214         private SimpleVisitor&lt;Type,Symbol&gt; asSuper = new SimpleVisitor&lt;Type,Symbol&gt;() {
2215 
2216             public Type visitType(Type t, Symbol sym) {
2217                 return null;
2218             }
2219 
2220             @Override
2221             public Type visitClassType(ClassType t, Symbol sym) {
2222                 if (t.tsym == sym)
2223                     return t;
2224 
2225                 // No man may be an island, but the bell tolls for a value.
2226                 if (isValue(t))
2227                     return null;
2228 
2229                 Symbol c = t.tsym;
2230                 if ((c.flags_field &amp; LOCKED) != 0) {
2231                     return null;
2232                 }
2233                 try {
2234                     c.flags_field |= LOCKED;
2235                     Type st = supertype(t);
2236                     if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
2237                         Type x = asSuper(st, sym);
2238                         if (x != null)
2239                             return x;
2240                     }
2241                     if ((sym.flags() &amp; INTERFACE) != 0) {
2242                         for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
2243                             if (!l.head.hasTag(ERROR)) {
2244                                 Type x = asSuper(l.head, sym);
2245                                 if (x != null)
2246                                     return x;
2247                             }
2248                         }
2249                     }
2250                     return null;
2251                 } finally {
2252                     c.flags_field &amp;= ~LOCKED;
2253                 }
2254             }
2255 
2256             @Override
2257             public Type visitArrayType(ArrayType t, Symbol sym) {
2258                 return isSubtype(t, sym.type) ? sym.type : null;
2259             }
2260 
2261             @Override
2262             public Type visitTypeVar(TypeVar t, Symbol sym) {
2263                 if (t.tsym == sym)
2264                     return t;
2265                 else
2266                     return asSuper(t.getUpperBound(), sym);
2267             }
2268 
2269             @Override
2270             public Type visitErrorType(ErrorType t, Symbol sym) {
2271                 return t;
2272             }
2273         };
2274 
2275     /**
2276      * Return the base type of t or any of its outer types that starts
2277      * with the given symbol.  If none exists, return null.
2278      *
2279      * @param t a type
2280      * @param sym a symbol
2281      */
2282     public Type asOuterSuper(Type t, Symbol sym) {
2283         switch (t.getTag()) {
2284         case CLASS:
2285             do {
2286                 Type s = asSuper(t, sym);
2287                 if (s != null) return s;
2288                 t = t.getEnclosingType();
2289             } while (t.hasTag(CLASS));
2290             return null;
2291         case ARRAY:
2292             return isSubtype(t, sym.type) ? sym.type : null;
2293         case TYPEVAR:
2294             return asSuper(t, sym);
2295         case ERROR:
2296             return t;
2297         default:
2298             return null;
2299         }
2300     }
2301 
2302     /**
2303      * Return the base type of t or any of its enclosing types that
2304      * starts with the given symbol.  If none exists, return null.
2305      *
2306      * @param t a type
2307      * @param sym a symbol
2308      */
2309     public Type asEnclosingSuper(Type t, Symbol sym) {
2310         switch (t.getTag()) {
2311         case CLASS:
2312             do {
2313                 Type s = asSuper(t, sym);
2314                 if (s != null) return s;
2315                 Type outer = t.getEnclosingType();
2316                 t = (outer.hasTag(CLASS)) ? outer :
2317                     (t.tsym.owner.enclClass() != null) ? t.tsym.owner.enclClass().type :
2318                     Type.noType;
2319             } while (t.hasTag(CLASS));
2320             return null;
2321         case ARRAY:
2322             return isSubtype(t, sym.type) ? sym.type : null;
2323         case TYPEVAR:
2324             return asSuper(t, sym);
2325         case ERROR:
2326             return t;
2327         default:
2328             return null;
2329         }
2330     }
2331     // &lt;/editor-fold&gt;
2332 
2333     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;memberType&quot;&gt;
2334     /**
2335      * The type of given symbol, seen as a member of t.
2336      *
2337      * @param t a type
2338      * @param sym a symbol
2339      */
2340     public Type memberType(Type t, Symbol sym) {
2341 
2342         if ((sym.flags() &amp; STATIC) != 0)
2343             return sym.type;
2344 
2345         /* If any inline types are involved, switch over to the reference universe,
2346            where the hierarchy is navigable. V and V.ref have identical membership
2347            with no bridging needs.
2348         */
2349         if (t.isValue())
2350             t = t.referenceProjection();
2351 
2352         if (sym.owner.isValue())
2353             sym = sym.referenceProjection();
2354 
2355         return memberType.visit(t, sym);
2356         }
2357     // where
2358         private SimpleVisitor&lt;Type,Symbol&gt; memberType = new SimpleVisitor&lt;Type,Symbol&gt;() {
2359 
2360             public Type visitType(Type t, Symbol sym) {
2361                 return sym.type;
2362             }
2363 
2364             @Override
2365             public Type visitWildcardType(WildcardType t, Symbol sym) {
2366                 return memberType(wildUpperBound(t), sym);
2367             }
2368 
2369             @Override
2370             public Type visitClassType(ClassType t, Symbol sym) {
2371                 Symbol owner = sym.owner;
2372                 long flags = sym.flags();
2373                 if (((flags &amp; STATIC) == 0) &amp;&amp; owner.type.isParameterized()) {
2374                     Type base = asOuterSuper(t, owner);
2375                     //if t is an intersection type T = CT &amp; I1 &amp; I2 ... &amp; In
2376                     //its supertypes CT, I1, ... In might contain wildcards
2377                     //so we need to go through capture conversion
2378                     base = t.isCompound() ? capture(base) : base;
2379                     if (base != null) {
2380                         List&lt;Type&gt; ownerParams = owner.type.allparams();
2381                         List&lt;Type&gt; baseParams = base.allparams();
2382                         if (ownerParams.nonEmpty()) {
2383                             if (baseParams.isEmpty()) {
2384                                 // then base is a raw type
2385                                 return erasure(sym.type);
2386                             } else {
2387                                 return subst(sym.type, ownerParams, baseParams);
2388                             }
2389                         }
2390                     }
2391                 }
2392                 return sym.type;
2393             }
2394 
2395             @Override
2396             public Type visitTypeVar(TypeVar t, Symbol sym) {
2397                 return memberType(t.getUpperBound(), sym);
2398             }
2399 
2400             @Override
2401             public Type visitErrorType(ErrorType t, Symbol sym) {
2402                 return t;
2403             }
2404         };
2405     // &lt;/editor-fold&gt;
2406 
2407     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isAssignable&quot;&gt;
2408     public boolean isAssignable(Type t, Type s) {
2409         return isAssignable(t, s, noWarnings);
2410     }
2411 
2412     /**
2413      * Is t assignable to s?&lt;br&gt;
2414      * Equivalent to subtype except for constant values and raw
2415      * types.&lt;br&gt;
2416      * (not defined for Method and ForAll types)
2417      */
2418     public boolean isAssignable(Type t, Type s, Warner warn) {
2419         if (t.hasTag(ERROR))
2420             return true;
2421         if (t.getTag().isSubRangeOf(INT) &amp;&amp; t.constValue() != null) {
2422             int value = ((Number)t.constValue()).intValue();
2423             switch (s.getTag()) {
2424             case BYTE:
2425             case CHAR:
2426             case SHORT:
2427             case INT:
2428                 if (s.getTag().checkRange(value))
2429                     return true;
2430                 break;
2431             case CLASS:
2432                 switch (unboxedType(s).getTag()) {
2433                 case BYTE:
2434                 case CHAR:
2435                 case SHORT:
2436                     return isAssignable(t, unboxedType(s), warn);
2437                 }
2438                 break;
2439             }
2440         }
2441         return isConvertible(t, s, warn);
2442     }
2443     // &lt;/editor-fold&gt;
2444 
2445     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;erasure&quot;&gt;
2446     /**
2447      * The erasure of t {@code |t|} -- the type that results when all
2448      * type parameters in t are deleted.
2449      */
2450     public Type erasure(Type t) {
2451         return eraseNotNeeded(t) ? t : erasure(t, false);
2452     }
2453     //where
2454     private boolean eraseNotNeeded(Type t) {
2455         // We don&#39;t want to erase primitive types and String type as that
2456         // operation is idempotent. Also, erasing these could result in loss
2457         // of information such as constant values attached to such types.
2458         return (t.isPrimitive()) || (syms.stringType.tsym == t.tsym);
2459     }
2460 
2461     private Type erasure(Type t, boolean recurse) {
2462         if (t.isPrimitive()) {
2463             return t; /* fast special case */
2464         } else {
2465             Type out = erasure.visit(t, recurse);
2466             return out;
2467         }
2468     }
2469     // where
2470         private TypeMapping&lt;Boolean&gt; erasure = new StructuralTypeMapping&lt;Boolean&gt;() {
2471             private Type combineMetadata(final Type s,
2472                                          final Type t) {
2473                 if (t.getMetadata() != TypeMetadata.EMPTY) {
2474                     switch (s.getKind()) {
2475                         case OTHER:
2476                         case UNION:
2477                         case INTERSECTION:
2478                         case PACKAGE:
2479                         case EXECUTABLE:
2480                         case NONE:
2481                         case VOID:
2482                         case ERROR:
2483                             return s;
2484                         default: return s.cloneWithMetadata(s.getMetadata().without(Kind.ANNOTATIONS));
2485                     }
2486                 } else {
2487                     return s;
2488                 }
2489             }
2490 
2491             public Type visitType(Type t, Boolean recurse) {
2492                 if (t.isPrimitive())
2493                     return t; /*fast special case*/
2494                 else {
2495                     //other cases already handled
2496                     return combineMetadata(t, t);
2497                 }
2498             }
2499 
2500             @Override
2501             public Type visitWildcardType(WildcardType t, Boolean recurse) {
2502                 Type erased = erasure(wildUpperBound(t), recurse);
2503                 return combineMetadata(erased, t);
2504             }
2505 
2506             @Override
2507             public Type visitClassType(ClassType t, Boolean recurse) {
2508                 Type erased = t.tsym.erasure(Types.this);
2509                 if (recurse) {
2510                     erased = new ErasedClassType(erased.getEnclosingType(),erased.tsym,
2511                             t.getMetadata().without(Kind.ANNOTATIONS));
2512                     return erased;
2513                 } else {
2514                     return combineMetadata(erased, t);
2515                 }
2516             }
2517 
2518             @Override
2519             public Type visitTypeVar(TypeVar t, Boolean recurse) {
2520                 Type erased = erasure(t.getUpperBound(), recurse);
2521                 return combineMetadata(erased, t);
2522             }
2523         };
2524 
2525     public List&lt;Type&gt; erasure(List&lt;Type&gt; ts) {
2526         return erasure.visit(ts, false);
2527     }
2528 
2529     public Type erasureRecursive(Type t) {
2530         return erasure(t, true);
2531     }
2532 
2533     public List&lt;Type&gt; erasureRecursive(List&lt;Type&gt; ts) {
2534         return erasure.visit(ts, true);
2535     }
2536     // &lt;/editor-fold&gt;
2537 
2538     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;makeIntersectionType&quot;&gt;
2539     /**
2540      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2541      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. Note that this might cause a symbol completion.
2542      * Hence, this version of makeIntersectionType may not be called during a classfile read.
2543      *
2544      * @param bounds    the types from which the intersection type is formed
2545      */
2546     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds) {
2547         return makeIntersectionType(bounds, bounds.head.tsym.isInterface());
2548     }
2549 
2550     /**
2551      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2552      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. This does not cause symbol completion as
2553      * an extra parameter indicates as to whether all bounds are interfaces - in which case the
2554      * supertype is implicitly assumed to be &#39;Object&#39;.
2555      *
2556      * @param bounds        the types from which the intersection type is formed
2557      * @param allInterfaces are all bounds interface types?
2558      */
2559     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds, boolean allInterfaces) {
2560         Assert.check(bounds.nonEmpty());
2561         Type firstExplicitBound = bounds.head;
2562         if (allInterfaces) {
2563             bounds = bounds.prepend(syms.objectType);
2564         }
2565         long flags = ABSTRACT | PUBLIC | SYNTHETIC | COMPOUND | ACYCLIC;
2566         if (isValue(bounds.head))
2567             flags |= VALUE;
2568         ClassSymbol bc =
2569             new ClassSymbol(flags,
2570                             Type.moreInfo
2571                                 ? names.fromString(bounds.toString())
2572                                 : names.empty,
2573                             null,
2574                             syms.noSymbol);
2575         IntersectionClassType intersectionType = new IntersectionClassType(bounds, bc, allInterfaces);
2576         bc.type = intersectionType;
2577         bc.erasure_field = (bounds.head.hasTag(TYPEVAR)) ?
2578                 syms.objectType : // error condition, recover
2579                 erasure(firstExplicitBound);
2580         bc.members_field = WriteableScope.create(bc);
2581         return intersectionType;
2582     }
2583     // &lt;/editor-fold&gt;
2584 
2585     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;supertype&quot;&gt;
2586     public Type supertype(Type t) {
2587         return supertype.visit(t);
2588     }
2589     // where
2590         private UnaryVisitor&lt;Type&gt; supertype = new UnaryVisitor&lt;Type&gt;() {
2591 
2592             public Type visitType(Type t, Void ignored) {
2593                 // A note on wildcards: there is no good way to
2594                 // determine a supertype for a super bounded wildcard.
2595                 return Type.noType;
2596             }
2597 
2598             @Override
2599             public Type visitClassType(ClassType t, Void ignored) {
2600                 if (t.supertype_field == null) {
2601                     Type supertype = ((ClassSymbol)t.tsym).getSuperclass();
2602                     // An interface has no superclass; its supertype is Object.
2603                     if (t.isInterface())
2604                         supertype = ((ClassType)t.tsym.type).supertype_field;
2605                     if (t.supertype_field == null) {
2606                         List&lt;Type&gt; actuals = classBound(t).allparams();
2607                         List&lt;Type&gt; formals = t.tsym.type.allparams();
2608                         if (t.hasErasedSupertypes()) {
2609                             t.supertype_field = erasureRecursive(supertype);
2610                         } else if (formals.nonEmpty()) {
2611                             t.supertype_field = subst(supertype, formals, actuals);
2612                         }
2613                         else {
2614                             t.supertype_field = supertype;
2615                         }
2616                     }
2617                 }
2618                 return t.supertype_field;
2619             }
2620 
2621             /**
2622              * The supertype is always a class type. If the type
2623              * variable&#39;s bounds start with a class type, this is also
2624              * the supertype.  Otherwise, the supertype is
2625              * java.lang.Object.
2626              */
2627             @Override
2628             public Type visitTypeVar(TypeVar t, Void ignored) {
2629                 if (t.getUpperBound().hasTag(TYPEVAR) ||
2630                     (!t.getUpperBound().isCompound() &amp;&amp; !t.getUpperBound().isInterface())) {
2631                     return t.getUpperBound();
2632                 } else {
2633                     return supertype(t.getUpperBound());
2634                 }
2635             }
2636 
2637             @Override
2638             public Type visitArrayType(ArrayType t, Void ignored) {
2639                 if (t.elemtype.isPrimitive() || isSameType(t.elemtype, syms.objectType))
2640                     return arraySuperType();
2641                 else
2642                     return new ArrayType(supertype(t.elemtype), t.tsym);
2643             }
2644 
2645             @Override
2646             public Type visitErrorType(ErrorType t, Void ignored) {
2647                 return Type.noType;
2648             }
2649         };
2650     // &lt;/editor-fold&gt;
2651 
2652     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;interfaces&quot;&gt;
2653     /**
2654      * Return the interfaces implemented by this class.
2655      */
2656     public List&lt;Type&gt; interfaces(Type t) {
2657         return interfaces.visit(t);
2658     }
2659     // where
2660         private UnaryVisitor&lt;List&lt;Type&gt;&gt; interfaces = new UnaryVisitor&lt;List&lt;Type&gt;&gt;() {
2661 
2662             public List&lt;Type&gt; visitType(Type t, Void ignored) {
2663                 return List.nil();
2664             }
2665 
2666             @Override
2667             public List&lt;Type&gt; visitClassType(ClassType t, Void ignored) {
2668                 if (t.interfaces_field == null) {
2669                     List&lt;Type&gt; interfaces = ((ClassSymbol)t.tsym).getInterfaces();
2670                     if (t.interfaces_field == null) {
2671                         // If t.interfaces_field is null, then t must
2672                         // be a parameterized type (not to be confused
2673                         // with a generic type declaration).
2674                         // Terminology:
2675                         //    Parameterized type: List&lt;String&gt;
2676                         //    Generic type declaration: class List&lt;E&gt; { ... }
2677                         // So t corresponds to List&lt;String&gt; and
2678                         // t.tsym.type corresponds to List&lt;E&gt;.
2679                         // The reason t must be parameterized type is
2680                         // that completion will happen as a side
2681                         // effect of calling
2682                         // ClassSymbol.getInterfaces.  Since
2683                         // t.interfaces_field is null after
2684                         // completion, we can assume that t is not the
2685                         // type of a class/interface declaration.
2686                         Assert.check(t != t.tsym.type, t);
2687                         List&lt;Type&gt; actuals = t.allparams();
2688                         List&lt;Type&gt; formals = t.tsym.type.allparams();
2689                         if (t.hasErasedSupertypes()) {
2690                             t.interfaces_field = erasureRecursive(interfaces);
2691                         } else if (formals.nonEmpty()) {
2692                             t.interfaces_field = subst(interfaces, formals, actuals);
2693                         }
2694                         else {
2695                             t.interfaces_field = interfaces;
2696                         }
2697                     }
2698                 }
2699                 return t.interfaces_field;
2700             }
2701 
2702             @Override
2703             public List&lt;Type&gt; visitTypeVar(TypeVar t, Void ignored) {
2704                 if (t.getUpperBound().isCompound())
2705                     return interfaces(t.getUpperBound());
2706 
2707                 if (t.getUpperBound().isInterface())
2708                     return List.of(t.getUpperBound());
2709 
2710                 return List.nil();
2711             }
2712         };
2713 
2714     public List&lt;Type&gt; directSupertypes(Type t) {
2715         return directSupertypes.visit(t);
2716     }
2717     // where
2718         private final UnaryVisitor&lt;List&lt;Type&gt;&gt; directSupertypes = new UnaryVisitor&lt;List&lt;Type&gt;&gt;() {
2719 
2720             public List&lt;Type&gt; visitType(final Type type, final Void ignored) {
2721                 if (!type.isIntersection()) {
2722                     final Type sup = supertype(type);
2723                     return (sup == Type.noType || sup == type || sup == null)
2724                         ? interfaces(type)
2725                         : interfaces(type).prepend(sup);
2726                 } else {
2727                     return ((IntersectionClassType)type).getExplicitComponents();
2728                 }
2729             }
2730         };
2731 
2732     public boolean isDirectSuperInterface(TypeSymbol isym, TypeSymbol origin) {
2733         for (Type i2 : interfaces(origin.type)) {
2734             if (isym == i2.tsym) return true;
2735         }
2736         return false;
2737     }
2738     // &lt;/editor-fold&gt;
2739 
2740     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isDerivedRaw&quot;&gt;
2741     Map&lt;Type,Boolean&gt; isDerivedRawCache = new HashMap&lt;&gt;();
2742 
2743     public boolean isDerivedRaw(Type t) {
2744         Boolean result = isDerivedRawCache.get(t);
2745         if (result == null) {
2746             result = isDerivedRawInternal(t);
2747             isDerivedRawCache.put(t, result);
2748         }
2749         return result;
2750     }
2751 
2752     public boolean isDerivedRawInternal(Type t) {
2753         if (t.isErroneous())
2754             return false;
2755         return
2756             t.isRaw() ||
2757             supertype(t) != Type.noType &amp;&amp; isDerivedRaw(supertype(t)) ||
2758             isDerivedRaw(interfaces(t));
2759     }
2760 
2761     public boolean isDerivedRaw(List&lt;Type&gt; ts) {
2762         List&lt;Type&gt; l = ts;
2763         while (l.nonEmpty() &amp;&amp; !isDerivedRaw(l.head)) l = l.tail;
2764         return l.nonEmpty();
2765     }
2766     // &lt;/editor-fold&gt;
2767 
2768     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;setBounds&quot;&gt;
2769     /**
2770      * Same as {@link Types#setBounds(TypeVar, List, boolean)}, except that third parameter is computed directly,
2771      * as follows: if all all bounds are interface types, the computed supertype is Object,otherwise
2772      * the supertype is simply left null (in this case, the supertype is assumed to be the head of
2773      * the bound list passed as second argument). Note that this check might cause a symbol completion.
2774      * Hence, this version of setBounds may not be called during a classfile read.
2775      *
2776      * @param t         a type variable
2777      * @param bounds    the bounds, must be nonempty
2778      */
2779     public void setBounds(TypeVar t, List&lt;Type&gt; bounds) {
2780         setBounds(t, bounds, bounds.head.tsym.isInterface());
2781     }
2782 
2783     /**
2784      * Set the bounds field of the given type variable to reflect a (possibly multiple) list of bounds.
2785      * This does not cause symbol completion as an extra parameter indicates as to whether all bounds
2786      * are interfaces - in which case the supertype is implicitly assumed to be &#39;Object&#39;.
2787      *
2788      * @param t             a type variable
2789      * @param bounds        the bounds, must be nonempty
2790      * @param allInterfaces are all bounds interface types?
2791      */
2792     public void setBounds(TypeVar t, List&lt;Type&gt; bounds, boolean allInterfaces) {
2793         t.setUpperBound( bounds.tail.isEmpty() ?
2794                 bounds.head :
2795                 makeIntersectionType(bounds, allInterfaces) );
2796         t.rank_field = -1;
2797     }
2798     // &lt;/editor-fold&gt;
2799 
2800     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;getBounds&quot;&gt;
2801     /**
2802      * Return list of bounds of the given type variable.
2803      */
2804     public List&lt;Type&gt; getBounds(TypeVar t) {
2805         if (t.getUpperBound().hasTag(NONE))
2806             return List.nil();
2807         else if (t.getUpperBound().isErroneous() || !t.getUpperBound().isCompound())
2808             return List.of(t.getUpperBound());
2809         else if ((erasure(t).tsym.flags() &amp; INTERFACE) == 0)
2810             return interfaces(t).prepend(supertype(t));
2811         else
2812             // No superclass was given in bounds.
2813             // In this case, supertype is Object, erasure is first interface.
2814             return interfaces(t);
2815     }
2816     // &lt;/editor-fold&gt;
2817 
2818     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;classBound&quot;&gt;
2819     /**
2820      * If the given type is a (possibly selected) type variable,
2821      * return the bounding class of this type, otherwise return the
2822      * type itself.
2823      */
2824     public Type classBound(Type t) {
2825         return classBound.visit(t);
2826     }
2827     // where
2828         private UnaryVisitor&lt;Type&gt; classBound = new UnaryVisitor&lt;Type&gt;() {
2829 
2830             public Type visitType(Type t, Void ignored) {
2831                 return t;
2832             }
2833 
2834             @Override
2835             public Type visitClassType(ClassType t, Void ignored) {
2836                 Type outer1 = classBound(t.getEnclosingType());
2837                 if (outer1 != t.getEnclosingType())
2838                     return new ClassType(outer1, t.getTypeArguments(), t.tsym,
2839                                          t.getMetadata());
2840                 else
2841                     return t;
2842             }
2843 
2844             @Override
2845             public Type visitTypeVar(TypeVar t, Void ignored) {
2846                 return classBound(supertype(t));
2847             }
2848 
2849             @Override
2850             public Type visitErrorType(ErrorType t, Void ignored) {
2851                 return t;
2852             }
2853         };
2854     // &lt;/editor-fold&gt;
2855 
2856     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;sub signature / override equivalence&quot;&gt;
2857     /**
2858      * Returns true iff the first signature is a &lt;em&gt;sub
2859      * signature&lt;/em&gt; of the other.  This is &lt;b&gt;not&lt;/b&gt; an equivalence
2860      * relation.
2861      *
2862      * @jls 8.4.2 Method Signature
2863      * @see #overrideEquivalent(Type t, Type s)
2864      * @param t first signature (possibly raw).
2865      * @param s second signature (could be subjected to erasure).
2866      * @return true if t is a sub signature of s.
2867      */
2868     public boolean isSubSignature(Type t, Type s) {
2869         return isSubSignature(t, s, true);
2870     }
2871 
2872     public boolean isSubSignature(Type t, Type s, boolean strict) {
2873         return hasSameArgs(t, s, strict) || hasSameArgs(t, erasure(s), strict);
2874     }
2875 
2876     /**
2877      * Returns true iff these signatures are related by &lt;em&gt;override
2878      * equivalence&lt;/em&gt;.  This is the natural extension of
2879      * isSubSignature to an equivalence relation.
2880      *
2881      * @jls 8.4.2 Method Signature
2882      * @see #isSubSignature(Type t, Type s)
2883      * @param t a signature (possible raw, could be subjected to
2884      * erasure).
2885      * @param s a signature (possible raw, could be subjected to
2886      * erasure).
2887      * @return true if either argument is a sub signature of the other.
2888      */
2889     public boolean overrideEquivalent(Type t, Type s) {
2890         return hasSameArgs(t, s) ||
2891             hasSameArgs(t, erasure(s)) || hasSameArgs(erasure(t), s);
2892     }
2893 
2894     public boolean overridesObjectMethod(TypeSymbol origin, Symbol msym) {
2895         for (Symbol sym : syms.objectType.tsym.members().getSymbolsByName(msym.name)) {
2896             if (msym.overrides(sym, origin, Types.this, true)) {
2897                 return true;
2898             }
2899         }
2900         return false;
2901     }
2902 
2903     /**
2904      * This enum defines the strategy for implementing most specific return type check
2905      * during the most specific and functional interface checks.
2906      */
2907     public enum MostSpecificReturnCheck {
2908         /**
2909          * Return r1 is more specific than r2 if {@code r1 &lt;: r2}. Extra care required for (i) handling
2910          * method type variables (if either method is generic) and (ii) subtyping should be replaced
2911          * by type-equivalence for primitives. This is essentially an inlined version of
2912          * {@link Types#resultSubtype(Type, Type, Warner)}, where the assignability check has been
2913          * replaced with a strict subtyping check.
2914          */
2915         BASIC() {
2916             @Override
2917             public boolean test(Type mt1, Type mt2, Types types) {
2918                 List&lt;Type&gt; tvars = mt1.getTypeArguments();
2919                 List&lt;Type&gt; svars = mt2.getTypeArguments();
2920                 Type t = mt1.getReturnType();
2921                 Type s = types.subst(mt2.getReturnType(), svars, tvars);
2922                 return types.isSameType(t, s) ||
2923                     !t.isPrimitive() &amp;&amp;
2924                     !s.isPrimitive() &amp;&amp;
2925                     types.isSubtype(t, s);
2926             }
2927         },
2928         /**
2929          * Return r1 is more specific than r2 if r1 is return-type-substitutable for r2.
2930          */
2931         RTS() {
2932             @Override
2933             public boolean test(Type mt1, Type mt2, Types types) {
2934                 return types.returnTypeSubstitutable(mt1, mt2);
2935             }
2936         };
2937 
2938         public abstract boolean test(Type mt1, Type mt2, Types types);
2939     }
2940 
2941     /**
2942      * Merge multiple abstract methods. The preferred method is a method that is a subsignature
2943      * of all the other signatures and whose return type is more specific {@see MostSpecificReturnCheck}.
2944      * The resulting preferred method has a thrown clause that is the intersection of the merged
2945      * methods&#39; clauses.
2946      */
2947     public Optional&lt;Symbol&gt; mergeAbstracts(List&lt;Symbol&gt; ambiguousInOrder, Type site, boolean sigCheck) {
2948         //first check for preconditions
2949         boolean shouldErase = false;
2950         List&lt;Type&gt; erasedParams = ambiguousInOrder.head.erasure(this).getParameterTypes();
2951         for (Symbol s : ambiguousInOrder) {
2952             if ((s.flags() &amp; ABSTRACT) == 0 ||
2953                     (sigCheck &amp;&amp; !isSameTypes(erasedParams, s.erasure(this).getParameterTypes()))) {
2954                 return Optional.empty();
2955             } else if (s.type.hasTag(FORALL)) {
2956                 shouldErase = true;
2957             }
2958         }
2959         //then merge abstracts
2960         for (MostSpecificReturnCheck mostSpecificReturnCheck : MostSpecificReturnCheck.values()) {
2961             outer: for (Symbol s : ambiguousInOrder) {
2962                 Type mt = memberType(site, s);
2963                 List&lt;Type&gt; allThrown = mt.getThrownTypes();
2964                 for (Symbol s2 : ambiguousInOrder) {
2965                     if (s != s2) {
2966                         Type mt2 = memberType(site, s2);
2967                         if (!isSubSignature(mt, mt2) ||
2968                                 !mostSpecificReturnCheck.test(mt, mt2, this)) {
2969                             //ambiguity cannot be resolved
2970                             continue outer;
2971                         } else {
2972                             List&lt;Type&gt; thrownTypes2 = mt2.getThrownTypes();
2973                             if (!mt.hasTag(FORALL) &amp;&amp; shouldErase) {
2974                                 thrownTypes2 = erasure(thrownTypes2);
2975                             } else if (mt.hasTag(FORALL)) {
2976                                 //subsignature implies that if most specific is generic, then all other
2977                                 //methods are too
2978                                 Assert.check(mt2.hasTag(FORALL));
2979                                 // if both are generic methods, adjust thrown types ahead of intersection computation
2980                                 thrownTypes2 = subst(thrownTypes2, mt2.getTypeArguments(), mt.getTypeArguments());
2981                             }
2982                             allThrown = chk.intersect(allThrown, thrownTypes2);
2983                         }
2984                     }
2985                 }
2986                 return (allThrown == mt.getThrownTypes()) ?
2987                         Optional.of(s) :
2988                         Optional.of(new MethodSymbol(
2989                                 s.flags(),
2990                                 s.name,
2991                                 createMethodTypeWithThrown(s.type, allThrown),
2992                                 s.owner) {
2993                             @Override
2994                             public Symbol baseSymbol() {
2995                                 return s;
2996                             }
2997                         });
2998             }
2999         }
3000         return Optional.empty();
3001     }
3002 
3003     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determining method implementation in given site&quot;&gt;
3004     class ImplementationCache {
3005 
3006         private WeakHashMap&lt;MethodSymbol, SoftReference&lt;Map&lt;TypeSymbol, Entry&gt;&gt;&gt; _map = new WeakHashMap&lt;&gt;();
3007 
3008         class Entry {
3009             final MethodSymbol cachedImpl;
3010             final Filter&lt;Symbol&gt; implFilter;
3011             final boolean checkResult;
3012             final int prevMark;
3013 
3014             public Entry(MethodSymbol cachedImpl,
3015                     Filter&lt;Symbol&gt; scopeFilter,
3016                     boolean checkResult,
3017                     int prevMark) {
3018                 this.cachedImpl = cachedImpl;
3019                 this.implFilter = scopeFilter;
3020                 this.checkResult = checkResult;
3021                 this.prevMark = prevMark;
3022             }
3023 
3024             boolean matches(Filter&lt;Symbol&gt; scopeFilter, boolean checkResult, int mark) {
3025                 return this.implFilter == scopeFilter &amp;&amp;
3026                         this.checkResult == checkResult &amp;&amp;
3027                         this.prevMark == mark;
3028             }
3029         }
3030 
3031         MethodSymbol get(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3032             SoftReference&lt;Map&lt;TypeSymbol, Entry&gt;&gt; ref_cache = _map.get(ms);
3033             Map&lt;TypeSymbol, Entry&gt; cache = ref_cache != null ? ref_cache.get() : null;
3034             if (cache == null) {
3035                 cache = new HashMap&lt;&gt;();
3036                 _map.put(ms, new SoftReference&lt;&gt;(cache));
3037             }
3038             Entry e = cache.get(origin);
3039             CompoundScope members = membersClosure(origin.type, true);
3040             if (e == null ||
3041                     !e.matches(implFilter, checkResult, members.getMark())) {
3042                 MethodSymbol impl = implementationInternal(ms, origin, checkResult, implFilter);
3043                 cache.put(origin, new Entry(impl, implFilter, checkResult, members.getMark()));
3044                 return impl;
3045             }
3046             else {
3047                 return e.cachedImpl;
3048             }
3049         }
3050 
3051         private MethodSymbol implementationInternal(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3052             for (Type t = origin.type; t.hasTag(CLASS) || t.hasTag(TYPEVAR); t = supertype(t)) {
3053                 t = skipTypeVars(t, false);
3054                 TypeSymbol c = t.tsym;
3055                 Symbol bestSoFar = null;
3056                 for (Symbol sym : c.members().getSymbolsByName(ms.name, implFilter)) {
3057                     if (sym != null &amp;&amp; sym.overrides(ms, origin, Types.this, checkResult)) {
3058                         bestSoFar = sym;
3059                         if ((sym.flags() &amp; ABSTRACT) == 0) {
3060                             //if concrete impl is found, exit immediately
3061                             break;
3062                         }
3063                     }
3064                 }
3065                 if (bestSoFar != null) {
3066                     //return either the (only) concrete implementation or the first abstract one
3067                     return (MethodSymbol)bestSoFar;
3068                 }
3069             }
3070             return null;
3071         }
3072     }
3073 
3074     private ImplementationCache implCache = new ImplementationCache();
3075 
3076     public MethodSymbol implementation(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3077         return implCache.get(ms, origin, checkResult, implFilter);
3078     }
3079     // &lt;/editor-fold&gt;
3080 
3081     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;compute transitive closure of all members in given site&quot;&gt;
3082     class MembersClosureCache extends SimpleVisitor&lt;Scope.CompoundScope, Void&gt; {
3083 
3084         private Map&lt;TypeSymbol, CompoundScope&gt; _map = new HashMap&lt;&gt;();
3085 
3086         Set&lt;TypeSymbol&gt; seenTypes = new HashSet&lt;&gt;();
3087 
3088         class MembersScope extends CompoundScope {
3089 
3090             CompoundScope scope;
3091 
3092             public MembersScope(CompoundScope scope) {
3093                 super(scope.owner);
3094                 this.scope = scope;
3095             }
3096 
3097             Filter&lt;Symbol&gt; combine(Filter&lt;Symbol&gt; sf) {
3098                 return s -&gt; !s.owner.isInterface() &amp;&amp; (sf == null || sf.accepts(s));
3099             }
3100 
3101             @Override
3102             public Iterable&lt;Symbol&gt; getSymbols(Filter&lt;Symbol&gt; sf, LookupKind lookupKind) {
3103                 return scope.getSymbols(combine(sf), lookupKind);
3104             }
3105 
3106             @Override
3107             public Iterable&lt;Symbol&gt; getSymbolsByName(Name name, Filter&lt;Symbol&gt; sf, LookupKind lookupKind) {
3108                 return scope.getSymbolsByName(name, combine(sf), lookupKind);
3109             }
3110 
3111             @Override
3112             public int getMark() {
3113                 return scope.getMark();
3114             }
3115         }
3116 
3117         CompoundScope nilScope;
3118 
3119         /** members closure visitor methods **/
3120 
3121         public CompoundScope visitType(Type t, Void _unused) {
3122             if (nilScope == null) {
3123                 nilScope = new CompoundScope(syms.noSymbol);
3124             }
3125             return nilScope;
3126         }
3127 
3128         @Override
3129         public CompoundScope visitClassType(ClassType t, Void _unused) {
3130             if (!seenTypes.add(t.tsym)) {
3131                 //this is possible when an interface is implemented in multiple
3132                 //superclasses, or when a class hierarchy is circular - in such
3133                 //cases we don&#39;t need to recurse (empty scope is returned)
3134                 return new CompoundScope(t.tsym);
3135             }
3136             try {
3137                 seenTypes.add(t.tsym);
3138                 ClassSymbol csym = (ClassSymbol)t.tsym;
3139                 CompoundScope membersClosure = _map.get(csym);
3140                 if (membersClosure == null) {
3141                     membersClosure = new CompoundScope(csym);
3142                     for (Type i : interfaces(t)) {
3143                         membersClosure.prependSubScope(visit(i, null));
3144                     }
3145                     membersClosure.prependSubScope(visit(supertype(t), null));
3146                     membersClosure.prependSubScope(csym.members());
3147                     _map.put(csym, membersClosure);
3148                 }
3149                 return membersClosure;
3150             }
3151             finally {
3152                 seenTypes.remove(t.tsym);
3153             }
3154         }
3155 
3156         @Override
3157         public CompoundScope visitTypeVar(TypeVar t, Void _unused) {
3158             return visit(t.getUpperBound(), null);
3159         }
3160     }
3161 
3162     private MembersClosureCache membersCache = new MembersClosureCache();
3163 
3164     public CompoundScope membersClosure(Type site, boolean skipInterface) {
3165         CompoundScope cs = membersCache.visit(site, null);
3166         Assert.checkNonNull(cs, () -&gt; &quot;type &quot; + site);
3167         return skipInterface ? membersCache.new MembersScope(cs) : cs;
3168     }
3169     // &lt;/editor-fold&gt;
3170 
3171 
3172     /** Return first abstract member of class `sym&#39;.
3173      */
3174     public MethodSymbol firstUnimplementedAbstract(ClassSymbol sym) {
3175         try {
3176             return firstUnimplementedAbstractImpl(sym, sym);
3177         } catch (CompletionFailure ex) {
3178             chk.completionError(enter.getEnv(sym).tree.pos(), ex);
3179             return null;
3180         }
3181     }
3182         //where:
3183         private MethodSymbol firstUnimplementedAbstractImpl(ClassSymbol impl, ClassSymbol c) {
3184             MethodSymbol undef = null;
3185             // Do not bother to search in classes that are not abstract,
3186             // since they cannot have abstract members.
3187             if (c == impl || (c.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
3188                 Scope s = c.members();
3189                 for (Symbol sym : s.getSymbols(NON_RECURSIVE)) {
3190                     if (sym.kind == MTH &amp;&amp;
3191                         (sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
3192                         MethodSymbol absmeth = (MethodSymbol)sym;
3193                         MethodSymbol implmeth = absmeth.implementation(impl, this, true);
3194                         if (implmeth == null || implmeth == absmeth) {
3195                             //look for default implementations
3196                             if (allowDefaultMethods) {
3197                                 MethodSymbol prov = interfaceCandidates(impl.type, absmeth).head;
3198                                 if (prov != null &amp;&amp; prov.overrides(absmeth, impl, this, true)) {
3199                                     implmeth = prov;
3200                                 }
3201                             }
3202                         }
3203                         if (implmeth == null || implmeth == absmeth) {
3204                             undef = absmeth;
3205                             break;
3206                         }
3207                     }
3208                 }
3209                 if (undef == null) {
3210                     Type st = supertype(c.type);
3211                     if (st.hasTag(CLASS))
3212                         undef = firstUnimplementedAbstractImpl(impl, (ClassSymbol)st.tsym);
3213                 }
3214                 for (List&lt;Type&gt; l = interfaces(c.type);
3215                      undef == null &amp;&amp; l.nonEmpty();
3216                      l = l.tail) {
3217                     undef = firstUnimplementedAbstractImpl(impl, (ClassSymbol)l.head.tsym);
3218                 }
3219             }
3220             return undef;
3221         }
3222 
3223     public class CandidatesCache {
3224         public Map&lt;Entry, List&lt;MethodSymbol&gt;&gt; cache = new WeakHashMap&lt;&gt;();
3225 
3226         class Entry {
3227             Type site;
3228             MethodSymbol msym;
3229 
3230             Entry(Type site, MethodSymbol msym) {
3231                 this.site = site;
3232                 this.msym = msym;
3233             }
3234 
3235             @Override
3236             public boolean equals(Object obj) {
3237                 if (obj instanceof Entry) {
3238                     Entry e = (Entry)obj;
3239                     return e.msym == msym &amp;&amp; isSameType(site, e.site);
3240                 } else {
3241                     return false;
3242                 }
3243             }
3244 
3245             @Override
3246             public int hashCode() {
3247                 return Types.this.hashCode(site) &amp; ~msym.hashCode();
3248             }
3249         }
3250 
3251         public List&lt;MethodSymbol&gt; get(Entry e) {
3252             return cache.get(e);
3253         }
3254 
3255         public void put(Entry e, List&lt;MethodSymbol&gt; msymbols) {
3256             cache.put(e, msymbols);
3257         }
3258     }
3259 
3260     public CandidatesCache candidatesCache = new CandidatesCache();
3261 
3262     //where
3263     public List&lt;MethodSymbol&gt; interfaceCandidates(Type site, MethodSymbol ms) {
3264         CandidatesCache.Entry e = candidatesCache.new Entry(site, ms);
3265         List&lt;MethodSymbol&gt; candidates = candidatesCache.get(e);
3266         if (candidates == null) {
3267             Filter&lt;Symbol&gt; filter = new MethodFilter(ms, site);
3268             List&lt;MethodSymbol&gt; candidates2 = List.nil();
3269             for (Symbol s : membersClosure(site, false).getSymbols(filter)) {
3270                 if (!site.tsym.isInterface() &amp;&amp; !s.owner.isInterface()) {
3271                     return List.of((MethodSymbol)s);
3272                 } else if (!candidates2.contains(s)) {
3273                     candidates2 = candidates2.prepend((MethodSymbol)s);
3274                 }
3275             }
3276             candidates = prune(candidates2);
3277             candidatesCache.put(e, candidates);
3278         }
3279         return candidates;
3280     }
3281 
3282     public List&lt;MethodSymbol&gt; prune(List&lt;MethodSymbol&gt; methods) {
3283         ListBuffer&lt;MethodSymbol&gt; methodsMin = new ListBuffer&lt;&gt;();
3284         for (MethodSymbol m1 : methods) {
3285             boolean isMin_m1 = true;
3286             for (MethodSymbol m2 : methods) {
3287                 if (m1 == m2) continue;
3288                 if (m2.owner != m1.owner &amp;&amp;
3289                         asSuper(m2.owner.type, m1.owner) != null) {
3290                     isMin_m1 = false;
3291                     break;
3292                 }
3293             }
3294             if (isMin_m1)
3295                 methodsMin.append(m1);
3296         }
3297         return methodsMin.toList();
3298     }
3299     // where
3300             private class MethodFilter implements Filter&lt;Symbol&gt; {
3301 
3302                 Symbol msym;
3303                 Type site;
3304 
3305                 MethodFilter(Symbol msym, Type site) {
3306                     this.msym = msym;
3307                     this.site = site;
3308                 }
3309 
3310                 public boolean accepts(Symbol s) {
3311                     return s.kind == MTH &amp;&amp;
3312                             s.name == msym.name &amp;&amp;
3313                             (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
3314                             s.isInheritedIn(site.tsym, Types.this) &amp;&amp;
3315                             overrideEquivalent(memberType(site, s), memberType(site, msym));
3316                 }
3317             }
3318     // &lt;/editor-fold&gt;
3319 
3320     /**
3321      * Does t have the same arguments as s?  It is assumed that both
3322      * types are (possibly polymorphic) method types.  Monomorphic
3323      * method types &quot;have the same arguments&quot;, if their argument lists
3324      * are equal.  Polymorphic method types &quot;have the same arguments&quot;,
3325      * if they have the same arguments after renaming all type
3326      * variables of one to corresponding type variables in the other,
3327      * where correspondence is by position in the type parameter list.
3328      */
3329     public boolean hasSameArgs(Type t, Type s) {
3330         return hasSameArgs(t, s, true);
3331     }
3332 
3333     public boolean hasSameArgs(Type t, Type s, boolean strict) {
3334         return hasSameArgs(t, s, strict ? hasSameArgs_strict : hasSameArgs_nonstrict);
3335     }
3336 
3337     private boolean hasSameArgs(Type t, Type s, TypeRelation hasSameArgs) {
3338         return hasSameArgs.visit(t, s);
3339     }
3340     // where
3341         private class HasSameArgs extends TypeRelation {
3342 
3343             boolean strict;
3344 
3345             public HasSameArgs(boolean strict) {
3346                 this.strict = strict;
3347             }
3348 
3349             public Boolean visitType(Type t, Type s) {
3350                 throw new AssertionError();
3351             }
3352 
3353             @Override
3354             public Boolean visitMethodType(MethodType t, Type s) {
3355                 return s.hasTag(METHOD)
3356                     &amp;&amp; containsTypeEquivalent(t.argtypes, s.getParameterTypes());
3357             }
3358 
3359             @Override
3360             public Boolean visitForAll(ForAll t, Type s) {
3361                 if (!s.hasTag(FORALL))
3362                     return strict ? false : visitMethodType(t.asMethodType(), s);
3363 
3364                 ForAll forAll = (ForAll)s;
3365                 return hasSameBounds(t, forAll)
3366                     &amp;&amp; visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));
3367             }
3368 
3369             @Override
3370             public Boolean visitErrorType(ErrorType t, Type s) {
3371                 return false;
3372             }
3373         }
3374 
3375     TypeRelation hasSameArgs_strict = new HasSameArgs(true);
3376         TypeRelation hasSameArgs_nonstrict = new HasSameArgs(false);
3377 
3378     // &lt;/editor-fold&gt;
3379 
3380     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;subst&quot;&gt;
3381     public List&lt;Type&gt; subst(List&lt;Type&gt; ts,
3382                             List&lt;Type&gt; from,
3383                             List&lt;Type&gt; to) {
3384         return ts.map(new Subst(from, to));
3385     }
3386 
3387     /**
3388      * Substitute all occurrences of a type in `from&#39; with the
3389      * corresponding type in `to&#39; in &#39;t&#39;. Match lists `from&#39; and `to&#39;
3390      * from the right: If lists have different length, discard leading
3391      * elements of the longer list.
3392      */
3393     public Type subst(Type t, List&lt;Type&gt; from, List&lt;Type&gt; to) {
3394         return t.map(new Subst(from, to));
3395     }
3396 
3397     private class Subst extends StructuralTypeMapping&lt;Void&gt; {
3398         List&lt;Type&gt; from;
3399         List&lt;Type&gt; to;
3400 
3401         public Subst(List&lt;Type&gt; from, List&lt;Type&gt; to) {
3402             int fromLength = from.length();
3403             int toLength = to.length();
3404             while (fromLength &gt; toLength) {
3405                 fromLength--;
3406                 from = from.tail;
3407             }
3408             while (fromLength &lt; toLength) {
3409                 toLength--;
3410                 to = to.tail;
3411             }
3412             this.from = from;
3413             this.to = to;
3414         }
3415 
3416         @Override
3417         public Type visitTypeVar(TypeVar t, Void ignored) {
3418             for (List&lt;Type&gt; from = this.from, to = this.to;
3419                  from.nonEmpty();
3420                  from = from.tail, to = to.tail) {
3421                 if (t.equalsIgnoreMetadata(from.head)) {
3422                     return to.head.withTypeVar(t);
3423                 }
3424             }
3425             return t;
3426         }
3427 
3428         @Override
3429         public Type visitClassType(ClassType t, Void ignored) {
3430             if (!t.isCompound()) {
3431                 return super.visitClassType(t, ignored);
3432             } else {
3433                 Type st = visit(supertype(t));
3434                 List&lt;Type&gt; is = visit(interfaces(t), ignored);
3435                 if (st == supertype(t) &amp;&amp; is == interfaces(t))
3436                     return t;
3437                 else
3438                     return makeIntersectionType(is.prepend(st));
3439             }
3440         }
3441 
3442         @Override
3443         public Type visitWildcardType(WildcardType t, Void ignored) {
3444             WildcardType t2 = (WildcardType)super.visitWildcardType(t, ignored);
3445             if (t2 != t &amp;&amp; t.isExtendsBound() &amp;&amp; t2.type.isExtendsBound()) {
3446                 t2.type = wildUpperBound(t2.type);
3447             }
3448             return t2;
3449         }
3450 
3451         @Override
3452         public Type visitForAll(ForAll t, Void ignored) {
3453             if (Type.containsAny(to, t.tvars)) {
3454                 //perform alpha-renaming of free-variables in &#39;t&#39;
3455                 //if &#39;to&#39; types contain variables that are free in &#39;t&#39;
3456                 List&lt;Type&gt; freevars = newInstances(t.tvars);
3457                 t = new ForAll(freevars,
3458                                Types.this.subst(t.qtype, t.tvars, freevars));
3459             }
3460             List&lt;Type&gt; tvars1 = substBounds(t.tvars, from, to);
3461             Type qtype1 = visit(t.qtype);
3462             if (tvars1 == t.tvars &amp;&amp; qtype1 == t.qtype) {
3463                 return t;
3464             } else if (tvars1 == t.tvars) {
3465                 return new ForAll(tvars1, qtype1) {
3466                     @Override
3467                     public boolean needsStripping() {
3468                         return true;
3469                     }
3470                 };
3471             } else {
3472                 return new ForAll(tvars1, Types.this.subst(qtype1, t.tvars, tvars1)) {
3473                     @Override
3474                     public boolean needsStripping() {
3475                         return true;
3476                     }
3477                 };
3478             }
3479         }
3480     }
3481 
3482     public List&lt;Type&gt; substBounds(List&lt;Type&gt; tvars,
3483                                   List&lt;Type&gt; from,
3484                                   List&lt;Type&gt; to) {
3485         if (tvars.isEmpty())
3486             return tvars;
3487         ListBuffer&lt;Type&gt; newBoundsBuf = new ListBuffer&lt;&gt;();
3488         boolean changed = false;
3489         // calculate new bounds
3490         for (Type t : tvars) {
3491             TypeVar tv = (TypeVar) t;
3492             Type bound = subst(tv.getUpperBound(), from, to);
3493             if (bound != tv.getUpperBound())
3494                 changed = true;
3495             newBoundsBuf.append(bound);
3496         }
3497         if (!changed)
3498             return tvars;
3499         ListBuffer&lt;Type&gt; newTvars = new ListBuffer&lt;&gt;();
3500         // create new type variables without bounds
3501         for (Type t : tvars) {
3502             newTvars.append(new TypeVar(t.tsym, null, syms.botType,
3503                                         t.getMetadata()));
3504         }
3505         // the new bounds should use the new type variables in place
3506         // of the old
3507         List&lt;Type&gt; newBounds = newBoundsBuf.toList();
3508         from = tvars;
3509         to = newTvars.toList();
3510         for (; !newBounds.isEmpty(); newBounds = newBounds.tail) {
3511             newBounds.head = subst(newBounds.head, from, to);
3512         }
3513         newBounds = newBoundsBuf.toList();
3514         // set the bounds of new type variables to the new bounds
3515         for (Type t : newTvars.toList()) {
3516             TypeVar tv = (TypeVar) t;
3517             tv.setUpperBound( newBounds.head );
3518             newBounds = newBounds.tail;
3519         }
3520         return newTvars.toList();
3521     }
3522 
3523     public TypeVar substBound(TypeVar t, List&lt;Type&gt; from, List&lt;Type&gt; to) {
3524         Type bound1 = subst(t.getUpperBound(), from, to);
3525         if (bound1 == t.getUpperBound())
3526             return t;
3527         else {
3528             // create new type variable without bounds
3529             TypeVar tv = new TypeVar(t.tsym, null, syms.botType,
3530                                      t.getMetadata());
3531             // the new bound should use the new type variable in place
3532             // of the old
3533             tv.setUpperBound( subst(bound1, List.of(t), List.of(tv)) );
3534             return tv;
3535         }
3536     }
3537     // &lt;/editor-fold&gt;
3538 
3539     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;hasSameBounds&quot;&gt;
3540     /**
3541      * Does t have the same bounds for quantified variables as s?
3542      */
3543     public boolean hasSameBounds(ForAll t, ForAll s) {
3544         List&lt;Type&gt; l1 = t.tvars;
3545         List&lt;Type&gt; l2 = s.tvars;
3546         while (l1.nonEmpty() &amp;&amp; l2.nonEmpty() &amp;&amp;
3547                isSameType(l1.head.getUpperBound(),
3548                           subst(l2.head.getUpperBound(),
3549                                 s.tvars,
3550                                 t.tvars))) {
3551             l1 = l1.tail;
3552             l2 = l2.tail;
3553         }
3554         return l1.isEmpty() &amp;&amp; l2.isEmpty();
3555     }
3556     // &lt;/editor-fold&gt;
3557 
3558     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;newInstances&quot;&gt;
3559     /** Create new vector of type variables from list of variables
3560      *  changing all recursive bounds from old to new list.
3561      */
3562     public List&lt;Type&gt; newInstances(List&lt;Type&gt; tvars) {
3563         List&lt;Type&gt; tvars1 = tvars.map(newInstanceFun);
3564         for (List&lt;Type&gt; l = tvars1; l.nonEmpty(); l = l.tail) {
3565             TypeVar tv = (TypeVar) l.head;
3566             tv.setUpperBound( subst(tv.getUpperBound(), tvars, tvars1) );
3567         }
3568         return tvars1;
3569     }
3570         private static final TypeMapping&lt;Void&gt; newInstanceFun = new TypeMapping&lt;Void&gt;() {
3571             @Override
3572             public TypeVar visitTypeVar(TypeVar t, Void _unused) {
3573                 return new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata());
3574             }
3575         };
3576     // &lt;/editor-fold&gt;
3577 
3578     public Type createMethodTypeWithParameters(Type original, List&lt;Type&gt; newParams) {
3579         return original.accept(methodWithParameters, newParams);
3580     }
3581     // where
3582         private final MapVisitor&lt;List&lt;Type&gt;&gt; methodWithParameters = new MapVisitor&lt;List&lt;Type&gt;&gt;() {
3583             public Type visitType(Type t, List&lt;Type&gt; newParams) {
3584                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3585             }
3586             public Type visitMethodType(MethodType t, List&lt;Type&gt; newParams) {
3587                 return new MethodType(newParams, t.restype, t.thrown, t.tsym);
3588             }
3589             public Type visitForAll(ForAll t, List&lt;Type&gt; newParams) {
3590                 return new ForAll(t.tvars, t.qtype.accept(this, newParams));
3591             }
3592         };
3593 
3594     public Type createMethodTypeWithThrown(Type original, List&lt;Type&gt; newThrown) {
3595         return original.accept(methodWithThrown, newThrown);
3596     }
3597     // where
3598         private final MapVisitor&lt;List&lt;Type&gt;&gt; methodWithThrown = new MapVisitor&lt;List&lt;Type&gt;&gt;() {
3599             public Type visitType(Type t, List&lt;Type&gt; newThrown) {
3600                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3601             }
3602             public Type visitMethodType(MethodType t, List&lt;Type&gt; newThrown) {
3603                 return new MethodType(t.argtypes, t.restype, newThrown, t.tsym);
3604             }
3605             public Type visitForAll(ForAll t, List&lt;Type&gt; newThrown) {
3606                 return new ForAll(t.tvars, t.qtype.accept(this, newThrown));
3607             }
3608         };
3609 
3610     public Type createMethodTypeWithReturn(Type original, Type newReturn) {
3611         return original.accept(methodWithReturn, newReturn);
3612     }
3613     // where
3614         private final MapVisitor&lt;Type&gt; methodWithReturn = new MapVisitor&lt;Type&gt;() {
3615             public Type visitType(Type t, Type newReturn) {
3616                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3617             }
3618             public Type visitMethodType(MethodType t, Type newReturn) {
3619                 return new MethodType(t.argtypes, newReturn, t.thrown, t.tsym) {
3620                     @Override
3621                     public Type baseType() {
3622                         return t;
3623                     }
3624                 };
3625             }
3626             public Type visitForAll(ForAll t, Type newReturn) {
3627                 return new ForAll(t.tvars, t.qtype.accept(this, newReturn)) {
3628                     @Override
3629                     public Type baseType() {
3630                         return t;
3631                     }
3632                 };
3633             }
3634         };
3635 
3636     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;createErrorType&quot;&gt;
3637     public Type createErrorType(Type originalType) {
3638         return new ErrorType(originalType, syms.errSymbol);
3639     }
3640 
3641     public Type createErrorType(ClassSymbol c, Type originalType) {
3642         return new ErrorType(c, originalType);
3643     }
3644 
3645     public Type createErrorType(Name name, TypeSymbol container, Type originalType) {
3646         return new ErrorType(name, container, originalType);
3647     }
3648     // &lt;/editor-fold&gt;
3649 
3650     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;rank&quot;&gt;
3651     /**
3652      * The rank of a class is the length of the longest path between
3653      * the class and java.lang.Object in the class inheritance
3654      * graph. Undefined for all but reference types.
3655      */
3656     public int rank(Type t) {
3657         switch(t.getTag()) {
3658         case CLASS: {
3659             ClassType cls = (ClassType)t;
3660             if (cls.rank_field &lt; 0) {
3661                 Name fullname = cls.tsym.getQualifiedName();
3662                 if (fullname == names.java_lang_Object)
3663                     cls.rank_field = 0;
3664                 else {
3665                     int r = rank(supertype(cls));
3666                     for (List&lt;Type&gt; l = interfaces(cls);
3667                          l.nonEmpty();
3668                          l = l.tail) {
3669                         if (rank(l.head) &gt; r)
3670                             r = rank(l.head);
3671                     }
3672                     cls.rank_field = r + 1;
3673                 }
3674             }
3675             return cls.rank_field;
3676         }
3677         case TYPEVAR: {
3678             TypeVar tvar = (TypeVar)t;
3679             if (tvar.rank_field &lt; 0) {
3680                 int r = rank(supertype(tvar));
3681                 for (List&lt;Type&gt; l = interfaces(tvar);
3682                      l.nonEmpty();
3683                      l = l.tail) {
3684                     if (rank(l.head) &gt; r) r = rank(l.head);
3685                 }
3686                 tvar.rank_field = r + 1;
3687             }
3688             return tvar.rank_field;
3689         }
3690         case ERROR:
3691         case NONE:
3692             return 0;
3693         default:
3694             throw new AssertionError();
3695         }
3696     }
3697     // &lt;/editor-fold&gt;
3698 
3699     /**
3700      * Helper method for generating a string representation of a given type
3701      * accordingly to a given locale
3702      */
3703     public String toString(Type t, Locale locale) {
3704         return Printer.createStandardPrinter(messages).visit(t, locale);
3705     }
3706 
3707     /**
3708      * Helper method for generating a string representation of a given type
3709      * accordingly to a given locale
3710      */
3711     public String toString(Symbol t, Locale locale) {
3712         return Printer.createStandardPrinter(messages).visit(t, locale);
3713     }
3714 
3715     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;toString&quot;&gt;
3716     /**
3717      * This toString is slightly more descriptive than the one on Type.
3718      *
3719      * @deprecated Types.toString(Type t, Locale l) provides better support
3720      * for localization
3721      */
3722     @Deprecated
3723     public String toString(Type t) {
3724         if (t.hasTag(FORALL)) {
3725             ForAll forAll = (ForAll)t;
3726             return typaramsString(forAll.tvars) + forAll.qtype;
3727         }
3728         return &quot;&quot; + t;
3729     }
3730     // where
3731         private String typaramsString(List&lt;Type&gt; tvars) {
3732             StringBuilder s = new StringBuilder();
3733             s.append(&#39;&lt;&#39;);
3734             boolean first = true;
3735             for (Type t : tvars) {
3736                 if (!first) s.append(&quot;, &quot;);
3737                 first = false;
3738                 appendTyparamString(((TypeVar)t), s);
3739             }
3740             s.append(&#39;&gt;&#39;);
3741             return s.toString();
3742         }
3743         private void appendTyparamString(TypeVar t, StringBuilder buf) {
3744             buf.append(t);
3745             if (t.getUpperBound() == null ||
3746                 t.getUpperBound().tsym.getQualifiedName() == names.java_lang_Object)
3747                 return;
3748             buf.append(&quot; extends &quot;); // Java syntax; no need for i18n
3749             Type bound = t.getUpperBound();
3750             if (!bound.isCompound()) {
3751                 buf.append(bound);
3752             } else if ((erasure(t).tsym.flags() &amp; INTERFACE) == 0) {
3753                 buf.append(supertype(t));
3754                 for (Type intf : interfaces(t)) {
3755                     buf.append(&#39;&amp;&#39;);
3756                     buf.append(intf);
3757                 }
3758             } else {
3759                 // No superclass was given in bounds.
3760                 // In this case, supertype is Object, erasure is first interface.
3761                 boolean first = true;
3762                 for (Type intf : interfaces(t)) {
3763                     if (!first) buf.append(&#39;&amp;&#39;);
3764                     first = false;
3765                     buf.append(intf);
3766                 }
3767             }
3768         }
3769     // &lt;/editor-fold&gt;
3770 
3771     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determining least upper bounds of types&quot;&gt;
3772     /**
3773      * A cache for closures.
3774      *
3775      * &lt;p&gt;A closure is a list of all the supertypes and interfaces of
3776      * a class or interface type, ordered by ClassSymbol.precedes
3777      * (that is, subclasses come first, arbitrary but fixed
3778      * otherwise).
3779      */
3780     private Map&lt;Type,List&lt;Type&gt;&gt; closureCache = new HashMap&lt;&gt;();
3781 
3782     /**
3783      * Returns the closure of a class or interface type.
3784      */
3785     public List&lt;Type&gt; closure(Type t) {
3786         List&lt;Type&gt; cl = closureCache.get(t);
3787         if (cl == null) {
3788             Type st = supertype(t);
3789             if (!t.isCompound()) {
3790                 if (st.hasTag(CLASS)) {
3791                     cl = insert(closure(st), t);
3792                 } else if (st.hasTag(TYPEVAR)) {
3793                     cl = closure(st).prepend(t);
3794                 } else {
3795                     cl = List.of(t);
3796                 }
3797             } else {
3798                 cl = closure(supertype(t));
3799             }
3800             for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail)
3801                 cl = union(cl, closure(l.head));
3802             closureCache.put(t, cl);
3803         }
3804         return cl;
3805     }
3806 
3807     /**
3808      * Collect types into a new closure (using a @code{ClosureHolder})
3809      */
3810     public Collector&lt;Type, ClosureHolder, List&lt;Type&gt;&gt; closureCollector(boolean minClosure, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3811         return Collector.of(() -&gt; new ClosureHolder(minClosure, shouldSkip),
3812                 ClosureHolder::add,
3813                 ClosureHolder::merge,
3814                 ClosureHolder::closure);
3815     }
3816     //where
3817         class ClosureHolder {
3818             List&lt;Type&gt; closure;
3819             final boolean minClosure;
3820             final BiPredicate&lt;Type, Type&gt; shouldSkip;
3821 
3822             ClosureHolder(boolean minClosure, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3823                 this.closure = List.nil();
3824                 this.minClosure = minClosure;
3825                 this.shouldSkip = shouldSkip;
3826             }
3827 
3828             void add(Type type) {
3829                 closure = insert(closure, type, shouldSkip);
3830             }
3831 
3832             ClosureHolder merge(ClosureHolder other) {
3833                 closure = union(closure, other.closure, shouldSkip);
3834                 return this;
3835             }
3836 
3837             List&lt;Type&gt; closure() {
3838                 return minClosure ? closureMin(closure) : closure;
3839             }
3840         }
3841 
3842     BiPredicate&lt;Type, Type&gt; basicClosureSkip = (t1, t2) -&gt; t1.tsym == t2.tsym;
3843 
3844     /**
3845      * Insert a type in a closure
3846      */
3847     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3848         if (cl.isEmpty()) {
3849             return cl.prepend(t);
3850         } else if (shouldSkip.test(t, cl.head)) {
3851             return cl;
3852         } else if (t.tsym.precedes(cl.head.tsym, this)) {
3853             return cl.prepend(t);
3854         } else {
3855             // t comes after head, or the two are unrelated
3856             return insert(cl.tail, t, shouldSkip).prepend(cl.head);
3857         }
3858     }
3859 
3860     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t) {
3861         return insert(cl, t, basicClosureSkip);
3862     }
3863 
3864     /**
3865      * Form the union of two closures
3866      */
3867     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3868         if (cl1.isEmpty()) {
3869             return cl2;
3870         } else if (cl2.isEmpty()) {
3871             return cl1;
3872         } else if (shouldSkip.test(cl1.head, cl2.head)) {
3873             return union(cl1.tail, cl2.tail, shouldSkip).prepend(cl1.head);
3874         } else if (cl2.head.tsym.precedes(cl1.head.tsym, this)) {
3875             return union(cl1, cl2.tail, shouldSkip).prepend(cl2.head);
3876         } else {
3877             return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);
3878         }
3879     }
3880 
3881     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3882         return union(cl1, cl2, basicClosureSkip);
3883     }
3884 
3885     /**
3886      * Intersect two closures
3887      */
3888     public List&lt;Type&gt; intersect(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3889         if (cl1 == cl2)
3890             return cl1;
3891         if (cl1.isEmpty() || cl2.isEmpty())
3892             return List.nil();
3893         if (cl1.head.tsym.precedes(cl2.head.tsym, this))
3894             return intersect(cl1.tail, cl2);
3895         if (cl2.head.tsym.precedes(cl1.head.tsym, this))
3896             return intersect(cl1, cl2.tail);
3897         if (isSameType(cl1.head, cl2.head))
3898             return intersect(cl1.tail, cl2.tail).prepend(cl1.head);
3899         if (cl1.head.tsym == cl2.head.tsym &amp;&amp;
3900             cl1.head.hasTag(CLASS) &amp;&amp; cl2.head.hasTag(CLASS)) {
3901             if (cl1.head.isParameterized() &amp;&amp; cl2.head.isParameterized()) {
3902                 Type merge = merge(cl1.head,cl2.head);
3903                 return intersect(cl1.tail, cl2.tail).prepend(merge);
3904             }
3905             if (cl1.head.isRaw() || cl2.head.isRaw())
3906                 return intersect(cl1.tail, cl2.tail).prepend(erasure(cl1.head));
3907         }
3908         return intersect(cl1.tail, cl2.tail);
3909     }
3910     // where
3911         class TypePair {
3912             final Type t1;
3913             final Type t2;;
3914 
3915             TypePair(Type t1, Type t2) {
3916                 this.t1 = t1;
3917                 this.t2 = t2;
3918             }
3919             @Override
3920             public int hashCode() {
3921                 return 127 * Types.this.hashCode(t1) + Types.this.hashCode(t2);
3922             }
3923             @Override
3924             public boolean equals(Object obj) {
3925                 if (!(obj instanceof TypePair))
3926                     return false;
3927                 TypePair typePair = (TypePair)obj;
3928                 return isSameType(t1, typePair.t1)
3929                     &amp;&amp; isSameType(t2, typePair.t2);
3930             }
3931         }
3932         Set&lt;TypePair&gt; mergeCache = new HashSet&lt;&gt;();
3933         private Type merge(Type c1, Type c2) {
3934             ClassType class1 = (ClassType) c1;
3935             List&lt;Type&gt; act1 = class1.getTypeArguments();
3936             ClassType class2 = (ClassType) c2;
3937             List&lt;Type&gt; act2 = class2.getTypeArguments();
3938             ListBuffer&lt;Type&gt; merged = new ListBuffer&lt;&gt;();
3939             List&lt;Type&gt; typarams = class1.tsym.type.getTypeArguments();
3940 
3941             while (act1.nonEmpty() &amp;&amp; act2.nonEmpty() &amp;&amp; typarams.nonEmpty()) {
3942                 if (containsType(act1.head, act2.head)) {
3943                     merged.append(act1.head);
3944                 } else if (containsType(act2.head, act1.head)) {
3945                     merged.append(act2.head);
3946                 } else {
3947                     TypePair pair = new TypePair(c1, c2);
3948                     Type m;
3949                     if (mergeCache.add(pair)) {
3950                         m = new WildcardType(lub(wildUpperBound(act1.head),
3951                                                  wildUpperBound(act2.head)),
3952                                              BoundKind.EXTENDS,
3953                                              syms.boundClass);
3954                         mergeCache.remove(pair);
3955                     } else {
3956                         m = new WildcardType(syms.objectType,
3957                                              BoundKind.UNBOUND,
3958                                              syms.boundClass);
3959                     }
3960                     merged.append(m.withTypeVar(typarams.head));
3961                 }
3962                 act1 = act1.tail;
3963                 act2 = act2.tail;
3964                 typarams = typarams.tail;
3965             }
3966             Assert.check(act1.isEmpty() &amp;&amp; act2.isEmpty() &amp;&amp; typarams.isEmpty());
3967             // There is no spec detailing how type annotations are to
3968             // be inherited.  So set it to noAnnotations for now
3969             return new ClassType(class1.getEnclosingType(), merged.toList(),
3970                                  class1.tsym);
3971         }
3972 
3973     /**
3974      * Return the minimum type of a closure, a compound type if no
3975      * unique minimum exists.
3976      */
3977     private Type compoundMin(List&lt;Type&gt; cl) {
3978         if (cl.isEmpty()) return syms.objectType;
3979         List&lt;Type&gt; compound = closureMin(cl);
3980         if (compound.isEmpty())
3981             return null;
3982         else if (compound.tail.isEmpty())
3983             return compound.head;
3984         else
3985             return makeIntersectionType(compound);
3986     }
3987 
3988     /**
3989      * Return the minimum types of a closure, suitable for computing
3990      * compoundMin or glb.
3991      */
3992     private List&lt;Type&gt; closureMin(List&lt;Type&gt; cl) {
3993         ListBuffer&lt;Type&gt; classes = new ListBuffer&lt;&gt;();
3994         ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
3995         Set&lt;Type&gt; toSkip = new HashSet&lt;&gt;();
3996         while (!cl.isEmpty()) {
3997             Type current = cl.head;
3998             boolean keep = !toSkip.contains(current);
3999             if (keep &amp;&amp; current.hasTag(TYPEVAR)) {
4000                 // skip lower-bounded variables with a subtype in cl.tail
4001                 for (Type t : cl.tail) {
4002                     if (isSubtypeNoCapture(t, current)) {
4003                         keep = false;
4004                         break;
4005                     }
4006                 }
4007             }
4008             if (keep) {
4009                 if (current.isInterface())
4010                     interfaces.append(current);
4011                 else
4012                     classes.append(current);
4013                 for (Type t : cl.tail) {
4014                     // skip supertypes of &#39;current&#39; in cl.tail
4015                     if (isSubtypeNoCapture(current, t))
4016                         toSkip.add(t);
4017                 }
4018             }
4019             cl = cl.tail;
4020         }
4021         return classes.appendList(interfaces).toList();
4022     }
4023 
4024     /**
4025      * Return the least upper bound of list of types.  if the lub does
4026      * not exist return null.
4027      */
4028     public Type lub(List&lt;Type&gt; ts) {
4029         return lub(ts.toArray(new Type[ts.length()]));
4030     }
4031 
4032     /**
4033      * Return the least upper bound (lub) of set of types.  If the lub
4034      * does not exist return the type of null (bottom).
4035      */
4036     public Type lub(Type... ts) {
4037         final int UNKNOWN_BOUND = 0;
4038         final int ARRAY_BOUND = 1;
4039         final int CLASS_BOUND = 2;
4040 
4041         int[] kinds = new int[ts.length];
4042         int boundkind = UNKNOWN_BOUND;
4043         for (int i = 0 ; i &lt; ts.length ; i++) {
4044             Type t = ts[i];
4045             switch (t.getTag()) {
4046             case CLASS:
4047                 boundkind |= kinds[i] = CLASS_BOUND;
4048                 break;
4049             case ARRAY:
4050                 boundkind |= kinds[i] = ARRAY_BOUND;
4051                 break;
4052             case  TYPEVAR:
4053                 do {
4054                     t = t.getUpperBound();
4055                 } while (t.hasTag(TYPEVAR));
4056                 if (t.hasTag(ARRAY)) {
4057                     boundkind |= kinds[i] = ARRAY_BOUND;
4058                 } else {
4059                     boundkind |= kinds[i] = CLASS_BOUND;
4060                 }
4061                 break;
4062             default:
4063                 kinds[i] = UNKNOWN_BOUND;
4064                 if (t.isPrimitive())
4065                     return syms.errType;
4066             }
4067         }
4068         switch (boundkind) {
4069         case 0:
4070             return syms.botType;
4071 
4072         case ARRAY_BOUND:
4073             // calculate lub(A[], B[])
4074             Type[] elements = new Type[ts.length];
4075             for (int i = 0 ; i &lt; ts.length ; i++) {
4076                 Type elem = elements[i] = elemTypeFun.apply(ts[i]);
4077                 if (elem.isPrimitive()) {
4078                     // if a primitive type is found, then return
4079                     // arraySuperType unless all the types are the
4080                     // same
4081                     Type first = ts[0];
4082                     for (int j = 1 ; j &lt; ts.length ; j++) {
4083                         if (!isSameType(first, ts[j])) {
4084                              // lub(int[], B[]) is Cloneable &amp; Serializable
4085                             return arraySuperType();
4086                         }
4087                     }
4088                     // all the array types are the same, return one
4089                     // lub(int[], int[]) is int[]
4090                     return first;
4091                 }
4092             }
4093             // lub(A[], B[]) is lub(A, B)[]
4094             return new ArrayType(lub(elements), syms.arrayClass);
4095 
4096         case CLASS_BOUND:
4097             // calculate lub(A, B)
4098             int startIdx = 0;
4099             for (int i = 0; i &lt; ts.length ; i++) {
4100                 Type t = ts[i];
4101                 if (t.hasTag(CLASS) || t.hasTag(TYPEVAR)) {
4102                     break;
4103                 } else {
4104                     startIdx++;
4105                 }
4106             }
4107             Assert.check(startIdx &lt; ts.length);
4108             //step 1 - compute erased candidate set (EC)
4109             List&lt;Type&gt; cl = erasedSupertypes(ts[startIdx]);
4110             for (int i = startIdx + 1 ; i &lt; ts.length ; i++) {
4111                 Type t = ts[i];
4112                 if (t.hasTag(CLASS) || t.hasTag(TYPEVAR))
4113                     cl = intersect(cl, erasedSupertypes(t));
4114             }
4115             //step 2 - compute minimal erased candidate set (MEC)
4116             List&lt;Type&gt; mec = closureMin(cl);
4117             //step 3 - for each element G in MEC, compute lci(Inv(G))
4118             List&lt;Type&gt; candidates = List.nil();
4119             for (Type erasedSupertype : mec) {
4120                 List&lt;Type&gt; lci = List.of(asSuper(ts[startIdx], erasedSupertype.tsym));
4121                 for (int i = startIdx + 1 ; i &lt; ts.length ; i++) {
4122                     Type superType = asSuper(ts[i], erasedSupertype.tsym);
4123                     lci = intersect(lci, superType != null ? List.of(superType) : List.nil());
4124                 }
4125                 candidates = candidates.appendList(lci);
4126             }
4127             //step 4 - let MEC be { G1, G2 ... Gn }, then we have that
4128             //lub = lci(Inv(G1)) &amp; lci(Inv(G2)) &amp; ... &amp; lci(Inv(Gn))
4129             return compoundMin(candidates);
4130 
4131         default:
4132             // calculate lub(A, B[])
4133             List&lt;Type&gt; classes = List.of(arraySuperType());
4134             for (int i = 0 ; i &lt; ts.length ; i++) {
4135                 if (kinds[i] != ARRAY_BOUND) // Filter out any arrays
4136                     classes = classes.prepend(ts[i]);
4137             }
4138             // lub(A, B[]) is lub(A, arraySuperType)
4139             return lub(classes);
4140         }
4141     }
4142     // where
4143         List&lt;Type&gt; erasedSupertypes(Type t) {
4144             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
4145             for (Type sup : closure(t)) {
4146                 if (sup.hasTag(TYPEVAR)) {
4147                     buf.append(sup);
4148                 } else {
4149                     buf.append(erasure(sup));
4150                 }
4151             }
4152             return buf.toList();
4153         }
4154 
4155         private Type arraySuperType = null;
4156         private Type arraySuperType() {
4157             // initialized lazily to avoid problems during compiler startup
4158             if (arraySuperType == null) {
4159                 synchronized (this) {
4160                     if (arraySuperType == null) {
4161                         // JLS 10.8: all arrays implement Cloneable and Serializable.
4162                         List&lt;Type&gt; ifaces =
4163                                 List.of(syms.serializableType, syms.cloneableType, syms.identityObjectType);
4164                         arraySuperType = makeIntersectionType(ifaces, true);
4165                     }
4166                 }
4167             }
4168             return arraySuperType;
4169         }
4170     // &lt;/editor-fold&gt;
4171 
4172     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Greatest lower bound&quot;&gt;
4173     public Type glb(List&lt;Type&gt; ts) {
4174         Type t1 = ts.head;
4175         for (Type t2 : ts.tail) {
4176             if (t1.isErroneous())
4177                 return t1;
4178             t1 = glb(t1, t2);
4179         }
4180         return t1;
4181     }
4182     //where
4183     public Type glb(Type t, Type s) {
4184         if (s == null)
4185             return t;
4186         else if (t.isPrimitive() || s.isPrimitive())
4187             return syms.errType;
4188         else if (isSubtypeNoCapture(t, s))
4189             return t;
4190         else if (isSubtypeNoCapture(s, t))
4191             return s;
4192 
4193         List&lt;Type&gt; closure = union(closure(t), closure(s));
4194         return glbFlattened(closure, t);
4195     }
4196     //where
4197     /**
4198      * Perform glb for a list of non-primitive, non-error, non-compound types;
4199      * redundant elements are removed.  Bounds should be ordered according to
4200      * {@link Symbol#precedes(TypeSymbol,Types)}.
4201      *
4202      * @param flatBounds List of type to glb
4203      * @param errT Original type to use if the result is an error type
4204      */
4205     private Type glbFlattened(List&lt;Type&gt; flatBounds, Type errT) {
4206         List&lt;Type&gt; bounds = closureMin(flatBounds);
4207 
4208         if (bounds.isEmpty()) {             // length == 0
4209             return syms.objectType;
4210         } else if (bounds.tail.isEmpty()) { // length == 1
4211             return bounds.head;
4212         } else {                            // length &gt; 1
4213             int classCount = 0;
4214             List&lt;Type&gt; cvars = List.nil();
4215             List&lt;Type&gt; lowers = List.nil();
4216             for (Type bound : bounds) {
4217                 if (!bound.isInterface()) {
4218                     classCount++;
4219                     Type lower = cvarLowerBound(bound);
4220                     if (bound != lower &amp;&amp; !lower.hasTag(BOT)) {
4221                         cvars = cvars.append(bound);
4222                         lowers = lowers.append(lower);
4223                     }
4224                 }
4225             }
4226             if (classCount &gt; 1) {
4227                 if (lowers.isEmpty()) {
4228                     return createErrorType(errT);
4229                 } else {
4230                     // try again with lower bounds included instead of capture variables
4231                     List&lt;Type&gt; newBounds = bounds.diff(cvars).appendList(lowers);
4232                     return glb(newBounds);
4233                 }
4234             }
4235         }
4236         return makeIntersectionType(bounds);
4237     }
4238     // &lt;/editor-fold&gt;
4239 
4240     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;hashCode&quot;&gt;
4241     /**
4242      * Compute a hash code on a type.
4243      */
4244     public int hashCode(Type t) {
4245         return hashCode(t, false);
4246     }
4247 
4248     public int hashCode(Type t, boolean strict) {
4249         return strict ?
4250                 hashCodeStrictVisitor.visit(t) :
4251                 hashCodeVisitor.visit(t);
4252     }
4253     // where
4254         private static final HashCodeVisitor hashCodeVisitor = new HashCodeVisitor();
4255         private static final HashCodeVisitor hashCodeStrictVisitor = new HashCodeVisitor() {
4256             @Override
4257             public Integer visitTypeVar(TypeVar t, Void ignored) {
4258                 return System.identityHashCode(t);
4259             }
4260         };
4261 
4262         private static class HashCodeVisitor extends UnaryVisitor&lt;Integer&gt; {
4263             public Integer visitType(Type t, Void ignored) {
4264                 return t.getTag().ordinal();
4265             }
4266 
4267             @Override
4268             public Integer visitClassType(ClassType t, Void ignored) {
4269                 int result = visit(t.getEnclosingType());
4270                 result *= 127;
4271                 result += t.tsym.flatName().hashCode();
4272                 for (Type s : t.getTypeArguments()) {
4273                     result *= 127;
4274                     result += visit(s);
4275                 }
4276                 return result;
4277             }
4278 
4279             @Override
4280             public Integer visitMethodType(MethodType t, Void ignored) {
4281                 int h = METHOD.ordinal();
4282                 for (List&lt;Type&gt; thisargs = t.argtypes;
4283                      thisargs.tail != null;
4284                      thisargs = thisargs.tail)
4285                     h = (h &lt;&lt; 5) + visit(thisargs.head);
4286                 return (h &lt;&lt; 5) + visit(t.restype);
4287             }
4288 
4289             @Override
4290             public Integer visitWildcardType(WildcardType t, Void ignored) {
4291                 int result = t.kind.hashCode();
4292                 if (t.type != null) {
4293                     result *= 127;
4294                     result += visit(t.type);
4295                 }
4296                 return result;
4297             }
4298 
4299             @Override
4300             public Integer visitArrayType(ArrayType t, Void ignored) {
4301                 return visit(t.elemtype) + 12;
4302             }
4303 
4304             @Override
4305             public Integer visitTypeVar(TypeVar t, Void ignored) {
4306                 return System.identityHashCode(t);
4307             }
4308 
4309             @Override
4310             public Integer visitUndetVar(UndetVar t, Void ignored) {
4311                 return System.identityHashCode(t);
4312             }
4313 
4314             @Override
4315             public Integer visitErrorType(ErrorType t, Void ignored) {
4316                 return 0;
4317             }
4318         }
4319     // &lt;/editor-fold&gt;
4320 
4321     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Return-Type-Substitutable&quot;&gt;
4322     /**
4323      * Does t have a result that is a subtype of the result type of s,
4324      * suitable for covariant returns?  It is assumed that both types
4325      * are (possibly polymorphic) method types.  Monomorphic method
4326      * types are handled in the obvious way.  Polymorphic method types
4327      * require renaming all type variables of one to corresponding
4328      * type variables in the other, where correspondence is by
4329      * position in the type parameter list. */
4330     public boolean resultSubtype(Type t, Type s, Warner warner) {
4331         List&lt;Type&gt; tvars = t.getTypeArguments();
4332         List&lt;Type&gt; svars = s.getTypeArguments();
4333         Type tres = t.getReturnType();
4334         Type sres = subst(s.getReturnType(), svars, tvars);
4335         return covariantReturnType(tres, sres, warner);
4336     }
4337 
4338     /**
4339      * Return-Type-Substitutable.
4340      * @jls 8.4.5 Method Result
4341      */
4342     public boolean returnTypeSubstitutable(Type r1, Type r2) {
4343         if (hasSameArgs(r1, r2))
4344             return resultSubtype(r1, r2, noWarnings);
4345         else
4346             return covariantReturnType(r1.getReturnType(),
4347                                        erasure(r2.getReturnType()),
4348                                        noWarnings);
4349     }
4350 
4351     public boolean returnTypeSubstitutable(Type r1,
4352                                            Type r2, Type r2res,
4353                                            Warner warner) {
4354         if (isSameType(r1.getReturnType(), r2res))
4355             return true;
4356         if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())
4357             return false;
4358 
4359         if (hasSameArgs(r1, r2))
4360             return covariantReturnType(r1.getReturnType(), r2res, warner);
4361         if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))
4362             return true;
4363         if (!isSubtype(r1.getReturnType(), erasure(r2res)))
4364             return false;
4365         warner.warn(LintCategory.UNCHECKED);
4366         return true;
4367     }
4368 
4369     /**
4370      * Is t an appropriate return type in an overrider for a
4371      * method that returns s?
4372      */
4373     public boolean covariantReturnType(Type t, Type s, Warner warner) {
4374         return
4375             isSameType(t, s) ||
4376             !t.isPrimitive() &amp;&amp;
4377             !s.isPrimitive() &amp;&amp;
4378             isAssignable(t, s, warner);
4379     }
4380     // &lt;/editor-fold&gt;
4381 
4382     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Box/unbox support&quot;&gt;
4383     /**
4384      * Return the class that boxes the given primitive.
4385      */
4386     public ClassSymbol boxedClass(Type t) {
4387         return syms.enterClass(syms.java_base, syms.boxedName[t.getTag().ordinal()]);
4388     }
4389 
4390     /**
4391      * Return the boxed type if &#39;t&#39; is primitive, otherwise return &#39;t&#39; itself.
4392      */
4393     public Type boxedTypeOrType(Type t) {
4394         return t.isPrimitive() ?
4395             boxedClass(t).type :
4396             t;
4397     }
4398 
4399     /**
4400      * Return the primitive type corresponding to a boxed type.
4401      */
4402     public Type unboxedType(Type t) {
4403         for (int i=0; i&lt;syms.boxedName.length; i++) {
4404             Name box = syms.boxedName[i];
4405             if (box != null &amp;&amp;
4406                 asSuper(t, syms.enterClass(syms.java_base, box)) != null)
4407                 return syms.typeOfTag[i];
4408         }
4409         return Type.noType;
4410     }
4411 
4412     /**
4413      * Return the unboxed type if &#39;t&#39; is a boxed class, otherwise return &#39;t&#39; itself.
4414      */
4415     public Type unboxedTypeOrType(Type t) {
4416         Type unboxedType = unboxedType(t);
4417         return unboxedType.hasTag(NONE) ? t : unboxedType;
4418     }
4419     // &lt;/editor-fold&gt;
4420 
4421     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Capture conversion&quot;&gt;
4422     /*
4423      * JLS 5.1.10 Capture Conversion:
4424      *
4425      * Let G name a generic type declaration with n formal type
4426      * parameters A1 ... An with corresponding bounds U1 ... Un. There
4427      * exists a capture conversion from G&lt;T1 ... Tn&gt; to G&lt;S1 ... Sn&gt;,
4428      * where, for 1 &lt;= i &lt;= n:
4429      *
4430      * + If Ti is a wildcard type argument (4.5.1) of the form ? then
4431      *   Si is a fresh type variable whose upper bound is
4432      *   Ui[A1 := S1, ..., An := Sn] and whose lower bound is the null
4433      *   type.
4434      *
4435      * + If Ti is a wildcard type argument of the form ? extends Bi,
4436      *   then Si is a fresh type variable whose upper bound is
4437      *   glb(Bi, Ui[A1 := S1, ..., An := Sn]) and whose lower bound is
4438      *   the null type, where glb(V1,... ,Vm) is V1 &amp; ... &amp; Vm. It is
4439      *   a compile-time error if for any two classes (not interfaces)
4440      *   Vi and Vj,Vi is not a subclass of Vj or vice versa.
4441      *
4442      * + If Ti is a wildcard type argument of the form ? super Bi,
4443      *   then Si is a fresh type variable whose upper bound is
4444      *   Ui[A1 := S1, ..., An := Sn] and whose lower bound is Bi.
4445      *
4446      * + Otherwise, Si = Ti.
4447      *
4448      * Capture conversion on any type other than a parameterized type
4449      * (4.5) acts as an identity conversion (5.1.1). Capture
4450      * conversions never require a special action at run time and
4451      * therefore never throw an exception at run time.
4452      *
4453      * Capture conversion is not applied recursively.
4454      */
4455     /**
4456      * Capture conversion as specified by the JLS.
4457      */
4458 
4459     public List&lt;Type&gt; capture(List&lt;Type&gt; ts) {
4460         List&lt;Type&gt; buf = List.nil();
4461         for (Type t : ts) {
4462             buf = buf.prepend(capture(t));
4463         }
4464         return buf.reverse();
4465     }
4466 
4467     public Type capture(Type t) {
4468         if (!t.hasTag(CLASS)) {
4469             return t;
4470         }
4471         if (t.getEnclosingType() != Type.noType) {
4472             Type capturedEncl = capture(t.getEnclosingType());
4473             if (capturedEncl != t.getEnclosingType()) {
4474                 Type type1 = memberType(capturedEncl, t.tsym);
4475                 t = subst(type1, t.tsym.type.getTypeArguments(), t.getTypeArguments());
4476             }
4477         }
4478         ClassType cls = (ClassType)t;
4479         if (cls.isRaw() || !cls.isParameterized())
4480             return cls;
4481 
4482         ClassType G = (ClassType)cls.asElement().asType();
4483         List&lt;Type&gt; A = G.getTypeArguments();
4484         List&lt;Type&gt; T = cls.getTypeArguments();
4485         List&lt;Type&gt; S = freshTypeVariables(T);
4486 
4487         List&lt;Type&gt; currentA = A;
4488         List&lt;Type&gt; currentT = T;
4489         List&lt;Type&gt; currentS = S;
4490         boolean captured = false;
4491         while (!currentA.isEmpty() &amp;&amp;
4492                !currentT.isEmpty() &amp;&amp;
4493                !currentS.isEmpty()) {
4494             if (currentS.head != currentT.head) {
4495                 captured = true;
4496                 WildcardType Ti = (WildcardType)currentT.head;
4497                 Type Ui = currentA.head.getUpperBound();
4498                 CapturedType Si = (CapturedType)currentS.head;
4499                 if (Ui == null)
4500                     Ui = syms.objectType;
4501                 switch (Ti.kind) {
4502                 case UNBOUND:
4503                     Si.setUpperBound( subst(Ui, A, S) );
4504                     Si.lower = syms.botType;
4505                     break;
4506                 case EXTENDS:
4507                     Si.setUpperBound( glb(Ti.getExtendsBound(), subst(Ui, A, S)) );
4508                     Si.lower = syms.botType;
4509                     break;
4510                 case SUPER:
4511                     Si.setUpperBound( subst(Ui, A, S) );
4512                     Si.lower = Ti.getSuperBound();
4513                     break;
4514                 }
4515                 Type tmpBound = Si.getUpperBound().hasTag(UNDETVAR) ? ((UndetVar)Si.getUpperBound()).qtype : Si.getUpperBound();
4516                 Type tmpLower = Si.lower.hasTag(UNDETVAR) ? ((UndetVar)Si.lower).qtype : Si.lower;
4517                 if (!Si.getUpperBound().hasTag(ERROR) &amp;&amp;
4518                     !Si.lower.hasTag(ERROR) &amp;&amp;
4519                     isSameType(tmpBound, tmpLower)) {
4520                     currentS.head = Si.getUpperBound();
4521                 }
4522             }
4523             currentA = currentA.tail;
4524             currentT = currentT.tail;
4525             currentS = currentS.tail;
4526         }
4527         if (!currentA.isEmpty() || !currentT.isEmpty() || !currentS.isEmpty())
4528             return erasure(t); // some &quot;rare&quot; type involved
4529 
4530         if (captured)
4531             return new ClassType(cls.getEnclosingType(), S, cls.tsym,
4532                                  cls.getMetadata());
4533         else
4534             return t;
4535     }
4536     // where
4537         public List&lt;Type&gt; freshTypeVariables(List&lt;Type&gt; types) {
4538             ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
4539             for (Type t : types) {
4540                 if (t.hasTag(WILDCARD)) {
4541                     Type bound = ((WildcardType)t).getExtendsBound();
4542                     if (bound == null)
4543                         bound = syms.objectType;
4544                     result.append(new CapturedType(capturedName,
4545                                                    syms.noSymbol,
4546                                                    bound,
4547                                                    syms.botType,
4548                                                    (WildcardType)t));
4549                 } else {
4550                     result.append(t);
4551                 }
4552             }
4553             return result.toList();
4554         }
4555     // &lt;/editor-fold&gt;
4556 
4557     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Internal utility methods&quot;&gt;
4558     private boolean sideCast(Type from, Type to, Warner warn) {
4559         // We are casting from type $from$ to type $to$, which are
4560         // non-final unrelated types.  This method
4561         // tries to reject a cast by transferring type parameters
4562         // from $to$ to $from$ by common superinterfaces.
4563         boolean reverse = false;
4564         Type target = to;
4565         if ((to.tsym.flags() &amp; INTERFACE) == 0) {
4566             Assert.check((from.tsym.flags() &amp; INTERFACE) != 0);
4567             reverse = true;
4568             to = from;
4569             from = target;
4570         }
4571         List&lt;Type&gt; commonSupers = superClosure(to, erasure(from));
4572         boolean giveWarning = commonSupers.isEmpty();
4573         // The arguments to the supers could be unified here to
4574         // get a more accurate analysis
4575         while (commonSupers.nonEmpty()) {
4576             Type t1 = asSuper(from, commonSupers.head.tsym);
4577             Type t2 = commonSupers.head; // same as asSuper(to, commonSupers.head.tsym);
4578             if (disjointTypes(t1.getTypeArguments(), t2.getTypeArguments()))
4579                 return false;
4580             giveWarning = giveWarning || (reverse ? giveWarning(t2, t1) : giveWarning(t1, t2));
4581             commonSupers = commonSupers.tail;
4582         }
4583         if (giveWarning &amp;&amp; !isReifiable(reverse ? from : to))
4584             warn.warn(LintCategory.UNCHECKED);
4585         return true;
4586     }
4587 
4588     private boolean sideCastFinal(Type from, Type to, Warner warn) {
4589         // We are casting from type $from$ to type $to$, which are
4590         // unrelated types one of which is final and the other of
4591         // which is an interface.  This method
4592         // tries to reject a cast by transferring type parameters
4593         // from the final class to the interface.
4594         boolean reverse = false;
4595         Type target = to;
4596         if ((to.tsym.flags() &amp; INTERFACE) == 0) {
4597             Assert.check((from.tsym.flags() &amp; INTERFACE) != 0);
4598             reverse = true;
4599             to = from;
4600             from = target;
4601         }
4602         Assert.check(!dynamicTypeMayImplementAdditionalInterfaces(from.tsym));
4603         Type t1 = asSuper(from, to.tsym);
4604         if (t1 == null) return false;
4605         Type t2 = to;
4606         if (disjointTypes(t1.getTypeArguments(), t2.getTypeArguments()))
4607             return false;
4608         if (!isReifiable(target) &amp;&amp;
4609             (reverse ? giveWarning(t2, t1) : giveWarning(t1, t2)))
4610             warn.warn(LintCategory.UNCHECKED);
4611         return true;
4612     }
4613 
4614     private boolean dynamicTypeMayImplementAdditionalInterfaces(TypeSymbol tsym) {
4615         return (tsym.flags() &amp; FINAL) == 0 &amp;&amp; !tsym.isReferenceProjection();
4616     }
4617 
4618     private boolean giveWarning(Type from, Type to) {
4619         List&lt;Type&gt; bounds = to.isCompound() ?
4620                 directSupertypes(to) : List.of(to);
4621         for (Type b : bounds) {
4622             Type subFrom = asSub(from, b.tsym);
4623             if (b.isParameterized() &amp;&amp;
4624                     (!(isUnbounded(b) ||
4625                     isSubtype(from, b) ||
4626                     ((subFrom != null) &amp;&amp; containsType(b.allparams(), subFrom.allparams()))))) {
4627                 return true;
4628             }
4629         }
4630         return false;
4631     }
4632 
4633     private List&lt;Type&gt; superClosure(Type t, Type s) {
4634         List&lt;Type&gt; cl = List.nil();
4635         for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
4636             if (isSubtype(s, erasure(l.head))) {
4637                 cl = insert(cl, l.head);
4638             } else {
4639                 cl = union(cl, superClosure(l.head, s));
4640             }
4641         }
4642         return cl;
4643     }
4644 
4645     private boolean containsTypeEquivalent(Type t, Type s) {
4646         return isSameType(t, s) || // shortcut
4647             containsType(t, s) &amp;&amp; containsType(s, t);
4648     }
4649 
4650     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;adapt&quot;&gt;
4651     /**
4652      * Adapt a type by computing a substitution which maps a source
4653      * type to a target type.
4654      *
4655      * @param source    the source type
4656      * @param target    the target type
4657      * @param from      the type variables of the computed substitution
4658      * @param to        the types of the computed substitution.
4659      */
4660     public void adapt(Type source,
4661                        Type target,
4662                        ListBuffer&lt;Type&gt; from,
4663                        ListBuffer&lt;Type&gt; to) throws AdaptFailure {
4664         new Adapter(from, to).adapt(source, target);
4665     }
4666 
4667     class Adapter extends SimpleVisitor&lt;Void, Type&gt; {
4668 
4669         ListBuffer&lt;Type&gt; from;
4670         ListBuffer&lt;Type&gt; to;
4671         Map&lt;Symbol,Type&gt; mapping;
4672 
4673         Adapter(ListBuffer&lt;Type&gt; from, ListBuffer&lt;Type&gt; to) {
4674             this.from = from;
4675             this.to = to;
4676             mapping = new HashMap&lt;&gt;();
4677         }
4678 
4679         public void adapt(Type source, Type target) throws AdaptFailure {
4680             visit(source, target);
4681             List&lt;Type&gt; fromList = from.toList();
4682             List&lt;Type&gt; toList = to.toList();
4683             while (!fromList.isEmpty()) {
4684                 Type val = mapping.get(fromList.head.tsym);
4685                 if (toList.head != val)
4686                     toList.head = val;
4687                 fromList = fromList.tail;
4688                 toList = toList.tail;
4689             }
4690         }
4691 
4692         @Override
4693         public Void visitClassType(ClassType source, Type target) throws AdaptFailure {
4694             if (target.hasTag(CLASS))
4695                 adaptRecursive(source.allparams(), target.allparams());
4696             return null;
4697         }
4698 
4699         @Override
4700         public Void visitArrayType(ArrayType source, Type target) throws AdaptFailure {
4701             if (target.hasTag(ARRAY))
4702                 adaptRecursive(elemtype(source), elemtype(target));
4703             return null;
4704         }
4705 
4706         @Override
4707         public Void visitWildcardType(WildcardType source, Type target) throws AdaptFailure {
4708             if (source.isExtendsBound())
4709                 adaptRecursive(wildUpperBound(source), wildUpperBound(target));
4710             else if (source.isSuperBound())
4711                 adaptRecursive(wildLowerBound(source), wildLowerBound(target));
4712             return null;
4713         }
4714 
4715         @Override
4716         public Void visitTypeVar(TypeVar source, Type target) throws AdaptFailure {
4717             // Check to see if there is
4718             // already a mapping for $source$, in which case
4719             // the old mapping will be merged with the new
4720             Type val = mapping.get(source.tsym);
4721             if (val != null) {
4722                 if (val.isSuperBound() &amp;&amp; target.isSuperBound()) {
4723                     val = isSubtype(wildLowerBound(val), wildLowerBound(target))
4724                         ? target : val;
4725                 } else if (val.isExtendsBound() &amp;&amp; target.isExtendsBound()) {
4726                     val = isSubtype(wildUpperBound(val), wildUpperBound(target))
4727                         ? val : target;
4728                 } else if (!isSameType(val, target)) {
4729                     throw new AdaptFailure();
4730                 }
4731             } else {
4732                 val = target;
4733                 from.append(source);
4734                 to.append(target);
4735             }
4736             mapping.put(source.tsym, val);
4737             return null;
4738         }
4739 
4740         @Override
4741         public Void visitType(Type source, Type target) {
4742             return null;
4743         }
4744 
4745         private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
4746 
4747         private void adaptRecursive(Type source, Type target) {
4748             TypePair pair = new TypePair(source, target);
4749             if (cache.add(pair)) {
4750                 try {
4751                     visit(source, target);
4752                 } finally {
4753                     cache.remove(pair);
4754                 }
4755             }
4756         }
4757 
4758         private void adaptRecursive(List&lt;Type&gt; source, List&lt;Type&gt; target) {
4759             if (source.length() == target.length()) {
4760                 while (source.nonEmpty()) {
4761                     adaptRecursive(source.head, target.head);
4762                     source = source.tail;
4763                     target = target.tail;
4764                 }
4765             }
4766         }
4767     }
4768 
4769     public static class AdaptFailure extends RuntimeException {
4770         static final long serialVersionUID = -7490231548272701566L;
4771     }
4772 
4773     private void adaptSelf(Type t,
4774                            ListBuffer&lt;Type&gt; from,
4775                            ListBuffer&lt;Type&gt; to) {
4776         try {
4777             //if (t.tsym.type != t)
4778                 adapt(t.tsym.type, t, from, to);
4779         } catch (AdaptFailure ex) {
4780             // Adapt should never fail calculating a mapping from
4781             // t.tsym.type to t as there can be no merge problem.
4782             throw new AssertionError(ex);
4783         }
4784     }
4785     // &lt;/editor-fold&gt;
4786 
4787     /**
4788      * Rewrite all type variables (universal quantifiers) in the given
4789      * type to wildcards (existential quantifiers).  This is used to
4790      * determine if a cast is allowed.  For example, if high is true
4791      * and {@code T &lt;: Number}, then {@code List&lt;T&gt;} is rewritten to
4792      * {@code List&lt;?  extends Number&gt;}.  Since {@code List&lt;Integer&gt; &lt;:
4793      * List&lt;? extends Number&gt;} a {@code List&lt;T&gt;} can be cast to {@code
4794      * List&lt;Integer&gt;} with a warning.
4795      * @param t a type
4796      * @param high if true return an upper bound; otherwise a lower
4797      * bound
4798      * @param rewriteTypeVars only rewrite captured wildcards if false;
4799      * otherwise rewrite all type variables
4800      * @return the type rewritten with wildcards (existential
4801      * quantifiers) only
4802      */
4803     private Type rewriteQuantifiers(Type t, boolean high, boolean rewriteTypeVars) {
4804         return new Rewriter(high, rewriteTypeVars).visit(t);
4805     }
4806 
4807     class Rewriter extends UnaryVisitor&lt;Type&gt; {
4808 
4809         boolean high;
4810         boolean rewriteTypeVars;
4811 
4812         Rewriter(boolean high, boolean rewriteTypeVars) {
4813             this.high = high;
4814             this.rewriteTypeVars = rewriteTypeVars;
4815         }
4816 
4817         @Override
4818         public Type visitClassType(ClassType t, Void s) {
4819             ListBuffer&lt;Type&gt; rewritten = new ListBuffer&lt;&gt;();
4820             boolean changed = false;
4821             for (Type arg : t.allparams()) {
4822                 Type bound = visit(arg);
4823                 if (arg != bound) {
4824                     changed = true;
4825                 }
4826                 rewritten.append(bound);
4827             }
4828             if (changed)
4829                 return subst(t.tsym.type,
4830                         t.tsym.type.allparams(),
4831                         rewritten.toList());
4832             else
4833                 return t;
4834         }
4835 
4836         public Type visitType(Type t, Void s) {
4837             return t;
4838         }
4839 
4840         @Override
4841         public Type visitCapturedType(CapturedType t, Void s) {
4842             Type w_bound = t.wildcard.type;
4843             Type bound = w_bound.contains(t) ?
4844                         erasure(w_bound) :
4845                         visit(w_bound);
4846             return rewriteAsWildcardType(visit(bound), t.wildcard.bound, t.wildcard.kind);
4847         }
4848 
4849         @Override
4850         public Type visitTypeVar(TypeVar t, Void s) {
4851             if (rewriteTypeVars) {
4852                 Type bound = t.getUpperBound().contains(t) ?
4853                         erasure(t.getUpperBound()) :
4854                         visit(t.getUpperBound());
4855                 return rewriteAsWildcardType(bound, t, EXTENDS);
4856             } else {
4857                 return t;
4858             }
4859         }
4860 
4861         @Override
4862         public Type visitWildcardType(WildcardType t, Void s) {
4863             Type bound2 = visit(t.type);
4864             return t.type == bound2 ? t : rewriteAsWildcardType(bound2, t.bound, t.kind);
4865         }
4866 
4867         private Type rewriteAsWildcardType(Type bound, TypeVar formal, BoundKind bk) {
4868             switch (bk) {
4869                case EXTENDS: return high ?
4870                        makeExtendsWildcard(B(bound), formal) :
4871                        makeExtendsWildcard(syms.objectType, formal);
4872                case SUPER: return high ?
4873                        makeSuperWildcard(syms.botType, formal) :
4874                        makeSuperWildcard(B(bound), formal);
4875                case UNBOUND: return makeExtendsWildcard(syms.objectType, formal);
4876                default:
4877                    Assert.error(&quot;Invalid bound kind &quot; + bk);
4878                    return null;
4879             }
4880         }
4881 
4882         Type B(Type t) {
4883             while (t.hasTag(WILDCARD)) {
4884                 WildcardType w = (WildcardType)t;
4885                 t = high ?
4886                     w.getExtendsBound() :
4887                     w.getSuperBound();
4888                 if (t == null) {
4889                     t = high ? syms.objectType : syms.botType;
4890                 }
4891             }
4892             return t;
4893         }
4894     }
4895 
4896 
4897     /**
4898      * Create a wildcard with the given upper (extends) bound; create
4899      * an unbounded wildcard if bound is Object.
4900      *
4901      * @param bound the upper bound
4902      * @param formal the formal type parameter that will be
4903      * substituted by the wildcard
4904      */
4905     private WildcardType makeExtendsWildcard(Type bound, TypeVar formal) {
4906         if (bound == syms.objectType) {
4907             return new WildcardType(syms.objectType,
4908                                     BoundKind.UNBOUND,
4909                                     syms.boundClass,
4910                                     formal);
4911         } else {
4912             return new WildcardType(bound,
4913                                     BoundKind.EXTENDS,
4914                                     syms.boundClass,
4915                                     formal);
4916         }
4917     }
4918 
4919     /**
4920      * Create a wildcard with the given lower (super) bound; create an
4921      * unbounded wildcard if bound is bottom (type of {@code null}).
4922      *
4923      * @param bound the lower bound
4924      * @param formal the formal type parameter that will be
4925      * substituted by the wildcard
4926      */
4927     private WildcardType makeSuperWildcard(Type bound, TypeVar formal) {
4928         if (bound.hasTag(BOT)) {
4929             return new WildcardType(syms.objectType,
4930                                     BoundKind.UNBOUND,
4931                                     syms.boundClass,
4932                                     formal);
4933         } else {
4934             return new WildcardType(bound,
4935                                     BoundKind.SUPER,
4936                                     syms.boundClass,
4937                                     formal);
4938         }
4939     }
4940 
4941     /**
4942      * A wrapper for a type that allows use in sets.
4943      */
4944     public static class UniqueType {
4945         public final Type type;
4946         final Types types;
4947         private boolean encodeTypeSig;
4948 
4949         public UniqueType(Type type, Types types, boolean encodeTypeSig) {
4950             this.type = type;
4951             this.types = types;
4952             this.encodeTypeSig = encodeTypeSig;
4953         }
4954 
4955         public UniqueType(Type type, Types types) {
4956             this(type, types, true);
4957         }
4958 
4959         public int hashCode() {
4960             return types.hashCode(type);
4961         }
4962 
4963         public boolean equals(Object obj) {
4964             return (obj instanceof UniqueType) &amp;&amp;
4965                 types.isSameType(type, ((UniqueType)obj).type);
4966         }
4967 
4968         public boolean encodeTypeSig() {
4969             return encodeTypeSig;
4970         }
4971 
4972         public String toString() {
4973             return type.toString();
4974         }
4975 
4976     }
4977     // &lt;/editor-fold&gt;
4978 
4979     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Visitors&quot;&gt;
4980     /**
4981      * A default visitor for types.  All visitor methods except
4982      * visitType are implemented by delegating to visitType.  Concrete
4983      * subclasses must provide an implementation of visitType and can
4984      * override other methods as needed.
4985      *
4986      * @param &lt;R&gt; the return type of the operation implemented by this
4987      * visitor; use Void if no return type is needed.
4988      * @param &lt;S&gt; the type of the second argument (the first being the
4989      * type itself) of the operation implemented by this visitor; use
4990      * Void if a second argument is not needed.
4991      */
4992     public static abstract class DefaultTypeVisitor&lt;R,S&gt; implements Type.Visitor&lt;R,S&gt; {
4993         final public R visit(Type t, S s)               { return t.accept(this, s); }
4994         public R visitClassType(ClassType t, S s)       { return visitType(t, s); }
4995         public R visitWildcardType(WildcardType t, S s) { return visitType(t, s); }
4996         public R visitArrayType(ArrayType t, S s)       { return visitType(t, s); }
4997         public R visitMethodType(MethodType t, S s)     { return visitType(t, s); }
4998         public R visitPackageType(PackageType t, S s)   { return visitType(t, s); }
4999         public R visitModuleType(ModuleType t, S s)     { return visitType(t, s); }
5000         public R visitTypeVar(TypeVar t, S s)           { return visitType(t, s); }
5001         public R visitCapturedType(CapturedType t, S s) { return visitType(t, s); }
5002         public R visitForAll(ForAll t, S s)             { return visitType(t, s); }
5003         public R visitUndetVar(UndetVar t, S s)         { return visitType(t, s); }
5004         public R visitErrorType(ErrorType t, S s)       { return visitType(t, s); }
5005     }
5006 
5007     /**
5008      * A default visitor for symbols.  All visitor methods except
5009      * visitSymbol are implemented by delegating to visitSymbol.  Concrete
5010      * subclasses must provide an implementation of visitSymbol and can
5011      * override other methods as needed.
5012      *
5013      * @param &lt;R&gt; the return type of the operation implemented by this
5014      * visitor; use Void if no return type is needed.
5015      * @param &lt;S&gt; the type of the second argument (the first being the
5016      * symbol itself) of the operation implemented by this visitor; use
5017      * Void if a second argument is not needed.
5018      */
5019     public static abstract class DefaultSymbolVisitor&lt;R,S&gt; implements Symbol.Visitor&lt;R,S&gt; {
5020         final public R visit(Symbol s, S arg)                   { return s.accept(this, arg); }
5021         public R visitClassSymbol(ClassSymbol s, S arg)         { return visitSymbol(s, arg); }
5022         public R visitMethodSymbol(MethodSymbol s, S arg)       { return visitSymbol(s, arg); }
5023         public R visitOperatorSymbol(OperatorSymbol s, S arg)   { return visitSymbol(s, arg); }
5024         public R visitPackageSymbol(PackageSymbol s, S arg)     { return visitSymbol(s, arg); }
5025         public R visitTypeSymbol(TypeSymbol s, S arg)           { return visitSymbol(s, arg); }
5026         public R visitVarSymbol(VarSymbol s, S arg)             { return visitSymbol(s, arg); }
5027     }
5028 
5029     /**
5030      * A &lt;em&gt;simple&lt;/em&gt; visitor for types.  This visitor is simple as
5031      * captured wildcards, for-all types (generic methods), and
5032      * undetermined type variables (part of inference) are hidden.
5033      * Captured wildcards are hidden by treating them as type
5034      * variables and the rest are hidden by visiting their qtypes.
5035      *
5036      * @param &lt;R&gt; the return type of the operation implemented by this
5037      * visitor; use Void if no return type is needed.
5038      * @param &lt;S&gt; the type of the second argument (the first being the
5039      * type itself) of the operation implemented by this visitor; use
5040      * Void if a second argument is not needed.
5041      */
5042     public static abstract class SimpleVisitor&lt;R,S&gt; extends DefaultTypeVisitor&lt;R,S&gt; {
5043         @Override
5044         public R visitCapturedType(CapturedType t, S s) {
5045             return visitTypeVar(t, s);
5046         }
5047         @Override
5048         public R visitForAll(ForAll t, S s) {
5049             return visit(t.qtype, s);
5050         }
5051         @Override
5052         public R visitUndetVar(UndetVar t, S s) {
5053             return visit(t.qtype, s);
5054         }
5055     }
5056 
5057     /**
5058      * A plain relation on types.  That is a 2-ary function on the
5059      * form Type&amp;nbsp;&amp;times;&amp;nbsp;Type&amp;nbsp;&amp;rarr;&amp;nbsp;Boolean.
5060      * &lt;!-- In plain text: Type x Type -&gt; Boolean --&gt;
5061      */
5062     public static abstract class TypeRelation extends SimpleVisitor&lt;Boolean,Type&gt; {}
5063 
5064     /**
5065      * A convenience visitor for implementing operations that only
5066      * require one argument (the type itself), that is, unary
5067      * operations.
5068      *
5069      * @param &lt;R&gt; the return type of the operation implemented by this
5070      * visitor; use Void if no return type is needed.
5071      */
5072     public static abstract class UnaryVisitor&lt;R&gt; extends SimpleVisitor&lt;R,Void&gt; {
5073         final public R visit(Type t) { return t.accept(this, null); }
5074     }
5075 
5076     /**
5077      * A visitor for implementing a mapping from types to types.  The
5078      * default behavior of this class is to implement the identity
5079      * mapping (mapping a type to itself).  This can be overridden in
5080      * subclasses.
5081      *
5082      * @param &lt;S&gt; the type of the second argument (the first being the
5083      * type itself) of this mapping; use Void if a second argument is
5084      * not needed.
5085      */
5086     public static class MapVisitor&lt;S&gt; extends DefaultTypeVisitor&lt;Type,S&gt; {
5087         final public Type visit(Type t) { return t.accept(this, null); }
5088         public Type visitType(Type t, S s) { return t; }
5089     }
5090 
5091     /**
5092      * An abstract class for mappings from types to types (see {@link Type#map(TypeMapping)}.
5093      * This class implements the functional interface {@code Function}, that allows it to be used
5094      * fluently in stream-like processing.
5095      */
5096     public static class TypeMapping&lt;S&gt; extends MapVisitor&lt;S&gt; implements Function&lt;Type, Type&gt; {
5097         @Override
5098         public Type apply(Type type) { return visit(type); }
5099 
5100         List&lt;Type&gt; visit(List&lt;Type&gt; ts, S s) {
5101             return ts.map(t -&gt; visit(t, s));
5102         }
5103 
5104         @Override
5105         public Type visitCapturedType(CapturedType t, S s) {
5106             return visitTypeVar(t, s);
5107         }
5108     }
5109     // &lt;/editor-fold&gt;
5110 
5111 
5112     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Annotation support&quot;&gt;
5113 
5114     public RetentionPolicy getRetention(Attribute.Compound a) {
5115         return getRetention(a.type.tsym);
5116     }
5117 
5118     public RetentionPolicy getRetention(TypeSymbol sym) {
5119         RetentionPolicy vis = RetentionPolicy.CLASS; // the default
5120         Attribute.Compound c = sym.attribute(syms.retentionType.tsym);
5121         if (c != null) {
5122             Attribute value = c.member(names.value);
5123             if (value != null &amp;&amp; value instanceof Attribute.Enum) {
5124                 Name levelName = ((Attribute.Enum)value).value.name;
5125                 if (levelName == names.SOURCE) vis = RetentionPolicy.SOURCE;
5126                 else if (levelName == names.CLASS) vis = RetentionPolicy.CLASS;
5127                 else if (levelName == names.RUNTIME) vis = RetentionPolicy.RUNTIME;
5128                 else ;// /* fail soft */ throw new AssertionError(levelName);
5129             }
5130         }
5131         return vis;
5132     }
5133     // &lt;/editor-fold&gt;
5134 
5135     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Signature Generation&quot;&gt;
5136 
5137     public static abstract class SignatureGenerator {
5138 
5139         public static class InvalidSignatureException extends RuntimeException {
5140             private static final long serialVersionUID = 0;
5141 
5142             private final transient Type type;
5143 
5144             InvalidSignatureException(Type type) {
5145                 this.type = type;
5146             }
5147 
5148             public Type type() {
5149                 return type;
5150             }
5151         }
5152 
5153         private final Types types;
5154 
5155         protected abstract void append(char ch);
5156         protected abstract void append(byte[] ba);
5157         protected abstract void append(Name name);
5158         protected void classReference(ClassSymbol c) { /* by default: no-op */ }
5159 
5160         protected SignatureGenerator(Types types) {
5161             this.types = types;
5162         }
5163 
5164         protected void reportIllegalSignature(Type t) {
5165             throw new InvalidSignatureException(t);
5166         }
5167 
5168         /**
5169          * Assemble signature of given type in string buffer.
5170          */
5171         public void assembleSig(Type type) {
5172             switch (type.getTag()) {
5173                 case BYTE:
5174                     append(&#39;B&#39;);
5175                     break;
5176                 case SHORT:
5177                     append(&#39;S&#39;);
5178                     break;
5179                 case CHAR:
5180                     append(&#39;C&#39;);
5181                     break;
5182                 case INT:
5183                     append(&#39;I&#39;);
5184                     break;
5185                 case LONG:
5186                     append(&#39;J&#39;);
5187                     break;
5188                 case FLOAT:
5189                     append(&#39;F&#39;);
5190                     break;
5191                 case DOUBLE:
5192                     append(&#39;D&#39;);
5193                     break;
5194                 case BOOLEAN:
5195                     append(&#39;Z&#39;);
5196                     break;
5197                 case VOID:
5198                     append(&#39;V&#39;);
5199                     break;
5200                 case CLASS:
5201                     if (type.isCompound()) {
5202                         reportIllegalSignature(type);
5203                     }
5204                     if (types.isValue(type))
5205                         append(&#39;Q&#39;);
5206                     else
5207                         append(&#39;L&#39;);
5208                     assembleClassSig(type);
5209                     append(&#39;;&#39;);
5210                     break;
5211                 case ARRAY:
5212                     ArrayType at = (ArrayType) type;
5213                     append(&#39;[&#39;);
5214                     assembleSig(at.elemtype);
5215                     break;
5216                 case METHOD:
5217                     MethodType mt = (MethodType) type;
5218                     append(&#39;(&#39;);
5219                     assembleSig(mt.argtypes);
5220                     append(&#39;)&#39;);
5221                     assembleSig(mt.restype);
5222                     if (hasTypeVar(mt.thrown)) {
5223                         for (List&lt;Type&gt; l = mt.thrown; l.nonEmpty(); l = l.tail) {
5224                             append(&#39;^&#39;);
5225                             assembleSig(l.head);
5226                         }
5227                     }
5228                     break;
5229                 case WILDCARD: {
5230                     Type.WildcardType ta = (Type.WildcardType) type;
5231                     switch (ta.kind) {
5232                         case SUPER:
5233                             append(&#39;-&#39;);
5234                             assembleSig(ta.type);
5235                             break;
5236                         case EXTENDS:
5237                             append(&#39;+&#39;);
5238                             assembleSig(ta.type);
5239                             break;
5240                         case UNBOUND:
5241                             append(&#39;*&#39;);
5242                             break;
5243                         default:
5244                             throw new AssertionError(ta.kind);
5245                     }
5246                     break;
5247                 }
5248                 case TYPEVAR:
5249                     if (((TypeVar)type).isCaptured()) {
5250                         reportIllegalSignature(type);
5251                     }
5252                     append(&#39;T&#39;);
5253                     append(type.tsym.name);
5254                     append(&#39;;&#39;);
5255                     break;
5256                 case FORALL:
5257                     Type.ForAll ft = (Type.ForAll) type;
5258                     assembleParamsSig(ft.tvars);
5259                     assembleSig(ft.qtype);
5260                     break;
5261                 default:
5262                     throw new AssertionError(&quot;typeSig &quot; + type.getTag());
5263             }
5264         }
5265 
5266         public boolean hasTypeVar(List&lt;Type&gt; l) {
5267             while (l.nonEmpty()) {
5268                 if (l.head.hasTag(TypeTag.TYPEVAR)) {
5269                     return true;
5270                 }
5271                 l = l.tail;
5272             }
5273             return false;
5274         }
5275 
5276         public void assembleClassSig(Type type) {
5277             ClassType ct = (ClassType) type;
5278             ClassSymbol c = (ClassSymbol) ct.tsym;
5279             classReference(c);
5280             Type outer = ct.getEnclosingType();
5281             if (outer.allparams().nonEmpty()) {
5282                 boolean rawOuter =
5283                         c.owner.kind == MTH || // either a local class
5284                         c.name == types.names.empty; // or anonymous
5285                 assembleClassSig(rawOuter
5286                         ? types.erasure(outer)
5287                         : outer);
5288                 append(rawOuter ? &#39;$&#39; : &#39;.&#39;);
5289                 Assert.check(c.flatname.startsWith(c.owner.enclClass().flatname));
5290                 append(rawOuter
5291                         ? c.flatname.subName(c.owner.enclClass().flatname.getByteLength() + 1, c.flatname.getByteLength())
5292                         : c.name);
5293             } else {
5294                 append(externalize(c.flatname));
5295             }
5296             if (ct.getTypeArguments().nonEmpty()) {
5297                 append(&#39;&lt;&#39;);
5298                 assembleSig(ct.getTypeArguments());
5299                 append(&#39;&gt;&#39;);
5300             }
5301         }
5302 
5303         public void assembleParamsSig(List&lt;Type&gt; typarams) {
5304             append(&#39;&lt;&#39;);
5305             for (List&lt;Type&gt; ts = typarams; ts.nonEmpty(); ts = ts.tail) {
5306                 Type.TypeVar tvar = (Type.TypeVar) ts.head;
5307                 append(tvar.tsym.name);
5308                 List&lt;Type&gt; bounds = types.getBounds(tvar);
5309                 if ((bounds.head.tsym.flags() &amp; INTERFACE) != 0) {
5310                     append(&#39;:&#39;);
5311                 }
5312                 for (List&lt;Type&gt; l = bounds; l.nonEmpty(); l = l.tail) {
5313                     append(&#39;:&#39;);
5314                     assembleSig(l.head);
5315                 }
5316             }
5317             append(&#39;&gt;&#39;);
5318         }
5319 
5320         public void assembleSig(List&lt;Type&gt; types) {
5321             for (List&lt;Type&gt; ts = types; ts.nonEmpty(); ts = ts.tail) {
5322                 assembleSig(ts.head);
5323             }
5324         }
5325     }
5326 
5327     public Type constantType(LoadableConstant c) {
5328         switch (c.poolTag()) {
5329             case ClassFile.CONSTANT_Class:
5330                 return syms.classType;
5331             case ClassFile.CONSTANT_String:
5332                 return syms.stringType;
5333             case ClassFile.CONSTANT_Integer:
5334                 return syms.intType;
5335             case ClassFile.CONSTANT_Float:
5336                 return syms.floatType;
5337             case ClassFile.CONSTANT_Long:
5338                 return syms.longType;
5339             case ClassFile.CONSTANT_Double:
5340                 return syms.doubleType;
5341             case ClassFile.CONSTANT_MethodHandle:
5342                 return syms.methodHandleType;
5343             case ClassFile.CONSTANT_MethodType:
5344                 return syms.methodTypeType;
5345             case ClassFile.CONSTANT_Dynamic:
5346                 return ((DynamicVarSymbol)c).type;
5347             default:
5348                 throw new AssertionError(&quot;Not a loadable constant: &quot; + c.poolTag());
5349         }
5350     }
5351     // &lt;/editor-fold&gt;
5352 
5353     public void newRound() {
5354         descCache._map.clear();
5355         isDerivedRawCache.clear();
5356         implCache._map.clear();
5357         membersCache._map.clear();
5358         closureCache.clear();
5359     }
5360 }
    </pre>
  </body>
</html>