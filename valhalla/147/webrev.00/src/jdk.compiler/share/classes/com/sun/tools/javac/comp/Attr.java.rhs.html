<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;
  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileObject;
  33 
  34 import com.sun.source.tree.CaseTree;
  35 import com.sun.source.tree.IdentifierTree;
  36 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  37 import com.sun.source.tree.MemberSelectTree;
  38 import com.sun.source.tree.TreeVisitor;
  39 import com.sun.source.util.SimpleTreeVisitor;
  40 import com.sun.tools.javac.code.*;
  41 import com.sun.tools.javac.code.Lint.LintCategory;
  42 import com.sun.tools.javac.code.Scope.WriteableScope;
  43 import com.sun.tools.javac.code.Source.Feature;
  44 import com.sun.tools.javac.code.Symbol.*;
  45 import com.sun.tools.javac.code.Type.*;
  46 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  47 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  48 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  49 import com.sun.tools.javac.comp.Check.CheckContext;
  50 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  51 import com.sun.tools.javac.comp.MatchBindingsComputer.MatchBindings;
  52 import com.sun.tools.javac.jvm.*;
  53 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.Diamond;
  54 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArg;
  55 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArgs;
  56 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  57 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  58 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  59 import com.sun.tools.javac.tree.*;
  60 import com.sun.tools.javac.tree.JCTree.*;
  61 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  62 import com.sun.tools.javac.util.*;
  63 import com.sun.tools.javac.util.DefinedBy.Api;
  64 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  65 import com.sun.tools.javac.util.JCDiagnostic.Error;
  66 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  67 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  68 import com.sun.tools.javac.util.List;
  69 
  70 import static com.sun.tools.javac.code.Flags.*;
  71 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  72 import static com.sun.tools.javac.code.Flags.BLOCK;
  73 import static com.sun.tools.javac.code.Kinds.*;
  74 import static com.sun.tools.javac.code.Kinds.Kind.*;
  75 import static com.sun.tools.javac.code.TypeTag.*;
  76 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  77 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  78 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  79 
  80 /** This is the main context-dependent analysis phase in GJC. It
  81  *  encompasses name resolution, type checking and constant folding as
  82  *  subtasks. Some subtasks involve auxiliary classes.
  83  *  @see Check
  84  *  @see Resolve
  85  *  @see ConstFold
  86  *  @see Infer
  87  *
  88  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  89  *  If you write code that depends on this, you do so at your own risk.
  90  *  This code and its internal interfaces are subject to change or
  91  *  deletion without notice.&lt;/b&gt;
  92  */
  93 public class Attr extends JCTree.Visitor {
  94     protected static final Context.Key&lt;Attr&gt; attrKey = new Context.Key&lt;&gt;();
  95 
  96     final Names names;
  97     final Log log;
  98     final Symtab syms;
  99     final Resolve rs;
 100     final Operators operators;
 101     final Infer infer;
 102     final Analyzer analyzer;
 103     final DeferredAttr deferredAttr;
 104     final Check chk;
 105     final Flow flow;
 106     final MemberEnter memberEnter;
 107     final TypeEnter typeEnter;
 108     final TreeMaker make;
 109     final ConstFold cfolder;
 110     final Enter enter;
 111     final Target target;
 112     final Types types;
 113     final Preview preview;
 114     final JCDiagnostic.Factory diags;
 115     final TypeAnnotations typeAnnotations;
 116     final DeferredLintHandler deferredLintHandler;
 117     final TypeEnvs typeEnvs;
 118     final Dependencies dependencies;
 119     final Annotate annotate;
 120     final ArgumentAttr argumentAttr;
 121     final MatchBindingsComputer matchBindingsComputer;
 122 
 123     public static Attr instance(Context context) {
 124         Attr instance = context.get(attrKey);
 125         if (instance == null)
 126             instance = new Attr(context);
 127         return instance;
 128     }
 129 
 130     protected Attr(Context context) {
 131         context.put(attrKey, this);
 132 
 133         names = Names.instance(context);
 134         log = Log.instance(context);
 135         syms = Symtab.instance(context);
 136         rs = Resolve.instance(context);
 137         operators = Operators.instance(context);
 138         chk = Check.instance(context);
 139         flow = Flow.instance(context);
 140         memberEnter = MemberEnter.instance(context);
 141         typeEnter = TypeEnter.instance(context);
 142         make = TreeMaker.instance(context);
 143         enter = Enter.instance(context);
 144         infer = Infer.instance(context);
 145         analyzer = Analyzer.instance(context);
 146         deferredAttr = DeferredAttr.instance(context);
 147         cfolder = ConstFold.instance(context);
 148         target = Target.instance(context);
 149         types = Types.instance(context);
 150         preview = Preview.instance(context);
 151         diags = JCDiagnostic.Factory.instance(context);
 152         annotate = Annotate.instance(context);
 153         typeAnnotations = TypeAnnotations.instance(context);
 154         deferredLintHandler = DeferredLintHandler.instance(context);
 155         typeEnvs = TypeEnvs.instance(context);
 156         dependencies = Dependencies.instance(context);
 157         argumentAttr = ArgumentAttr.instance(context);
 158         matchBindingsComputer = MatchBindingsComputer.instance(context);
 159 
 160         Options options = Options.instance(context);
 161 
 162         Source source = Source.instance(context);
 163         allowPoly = Feature.POLY.allowedInSource(source);
 164         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 165         allowLambda = Feature.LAMBDA.allowedInSource(source);
 166         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 167         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);
 168         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);
 169         allowReifiableTypesInInstanceof =
 170                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;
 171                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
 172         sourceName = source.name;
 173         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
 174         allowValueMemberCycles = options.isSet(&quot;allowValueMemberCycles&quot;);
 175 
 176         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 177         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 178         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 179         methodAttrInfo = new MethodAttrInfo();
 180         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 181         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 182         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 183     }
 184 
 185     /** Switch: support target-typing inference
 186      */
 187     boolean allowPoly;
 188 
 189     /** Switch: support type annotations.
 190      */
 191     boolean allowTypeAnnos;
 192 
 193     /** Switch: support lambda expressions ?
 194      */
 195     boolean allowLambda;
 196 
 197     /** Switch: support default methods ?
 198      */
 199     boolean allowDefaultMethods;
 200 
 201     /** Switch: allow inline types?
 202      */
 203     boolean allowInlineTypes;
 204 
 205     /** Switch: static interface methods enabled?
 206      */
 207     boolean allowStaticInterfaceMethods;
 208 
 209     /** Switch: reifiable types in instanceof enabled?
 210      */
 211     boolean allowReifiableTypesInInstanceof;
 212 
 213     /**
 214      * Switch: warn about use of variable before declaration?
 215      * RFE: 6425594
 216      */
 217     boolean useBeforeDeclarationWarning;
 218 
 219     /**
 220      * Switch: Allow value type member cycles?
 221      */
 222     boolean allowValueMemberCycles;
 223 
 224     /**
 225      * Switch: name of source level; used for error reporting.
 226      */
 227     String sourceName;
 228 
 229     /** Check kind and type of given tree against protokind and prototype.
 230      *  If check succeeds, store type in tree and return it.
 231      *  If check fails, store errType in tree and return it.
 232      *  No checks are performed if the prototype is a method type.
 233      *  It is not necessary in this case since we know that kind and type
 234      *  are correct.
 235      *
 236      *  @param tree     The tree whose kind and type is checked
 237      *  @param found    The computed type of the tree
 238      *  @param ownkind  The computed kind of the tree
 239      *  @param resultInfo  The expected result of the tree
 240      */
 241     Type check(final JCTree tree,
 242                final Type found,
 243                final KindSelector ownkind,
 244                final ResultInfo resultInfo) {
 245         InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
 246         Type owntype;
 247         boolean shouldCheck = !found.hasTag(ERROR) &amp;&amp;
 248                 !resultInfo.pt.hasTag(METHOD) &amp;&amp;
 249                 !resultInfo.pt.hasTag(FORALL);
 250         if (shouldCheck &amp;&amp; !ownkind.subset(resultInfo.pkind)) {
 251             log.error(tree.pos(),
 252                       Errors.UnexpectedType(resultInfo.pkind.kindNames(),
 253                                             ownkind.kindNames()));
 254             owntype = types.createErrorType(found);
 255         } else if (allowPoly &amp;&amp; inferenceContext.free(found)) {
 256             //delay the check if there are inference variables in the found type
 257             //this means we are dealing with a partially inferred poly expression
 258             owntype = shouldCheck ? resultInfo.pt : found;
 259             if (resultInfo.checkMode.installPostInferenceHook()) {
 260                 inferenceContext.addFreeTypeListener(List.of(found),
 261                         instantiatedContext -&gt; {
 262                             ResultInfo pendingResult =
 263                                     resultInfo.dup(inferenceContext.asInstType(resultInfo.pt));
 264                             check(tree, inferenceContext.asInstType(found), ownkind, pendingResult);
 265                         });
 266             }
 267         } else {
 268             owntype = shouldCheck ?
 269             resultInfo.check(tree, found) :
 270             found;
 271         }
 272         if (resultInfo.checkMode.updateTreeType()) {
 273             tree.type = owntype;
 274         }
 275         return owntype;
 276     }
 277 
 278     /** Is given blank final variable assignable, i.e. in a scope where it
 279      *  may be assigned to even though it is final?
 280      *  @param v      The blank final variable.
 281      *  @param env    The current environment.
 282      */
 283     boolean isAssignableAsBlankFinal(VarSymbol v, Env&lt;AttrContext&gt; env) {
 284         Symbol owner = env.info.scope.owner;
 285            // owner refers to the innermost variable, method or
 286            // initializer block declaration at this point.
 287         boolean isAssignable =
 288             v.owner == owner
 289             ||
 290             ((owner.name == names.init ||    // i.e. we are in a constructor
 291               owner.kind == VAR ||           // i.e. we are in a variable initializer
 292               (owner.flags() &amp; BLOCK) != 0)  // i.e. we are in an initializer block
 293              &amp;&amp;
 294              v.owner == owner.owner
 295              &amp;&amp;
 296              ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env));
 297         boolean insideCompactConstructor = env.enclMethod != null &amp;&amp; TreeInfo.isCompactConstructor(env.enclMethod);
 298         return isAssignable &amp; !insideCompactConstructor;
 299     }
 300 
 301     /** Check that variable can be assigned to.
 302      *  @param pos    The current source code position.
 303      *  @param v      The assigned variable
 304      *  @param base   If the variable is referred to in a Select, the part
 305      *                to the left of the `.&#39;, null otherwise.
 306      *  @param env    The current environment.
 307      */
 308     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 309         if (v.name == names._this) {
 310             log.error(pos, Errors.CantAssignValToThis);
 311         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 312             ((v.flags() &amp; HASINIT) != 0
 313              ||
 314              !((base == null ||
 315                TreeInfo.isThisQualifier(base)) &amp;&amp;
 316                isAssignableAsBlankFinal(v, env)))) {
 317             if (v.isResourceVariable()) { //TWR resource
 318                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
 319             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {
 320                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));
 321             } else {
 322                 boolean complain = true;
 323                 /* Allow updates to instance fields of value classes by any method in the same nest via the
 324                    withfield operator -This does not result in mutation of final fields; the code generator
 325                    would implement `copy on write&#39; semantics via the opcode `withfield&#39;.
 326                 */
 327                 if (env.info.inWithField &amp;&amp; v.getKind() == ElementKind.FIELD &amp;&amp; (v.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) {
 328                     if (env.enclClass.sym.outermostClass() == v.owner.outermostClass())
 329                         complain = false;
 330                 }
 331                 if (complain)
 332                     log.error(pos, Errors.CantAssignValToFinalVar(v));
 333             }
 334         }
 335     }
 336 
 337     /** Does tree represent a static reference to an identifier?
 338      *  It is assumed that tree is either a SELECT or an IDENT.
 339      *  We have to weed out selects from non-type names here.
 340      *  @param tree    The candidate tree.
 341      */
 342     boolean isStaticReference(JCTree tree) {
 343         if (tree.hasTag(SELECT)) {
 344             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 345             if (lsym == null || lsym.kind != TYP) {
 346                 return false;
 347             }
 348         }
 349         return true;
 350     }
 351 
 352     /** Is this symbol a type?
 353      */
 354     static boolean isType(Symbol sym) {
 355         return sym != null &amp;&amp; sym.kind == TYP;
 356     }
 357 
 358     /** The current `this&#39; symbol.
 359      *  @param env    The current environment.
 360      */
 361     Symbol thisSym(DiagnosticPosition pos, Env&lt;AttrContext&gt; env) {
 362         return rs.resolveSelf(pos, env, env.enclClass.sym, names._this);
 363     }
 364 
 365     /** Attribute a parsed identifier.
 366      * @param tree Parsed identifier name
 367      * @param topLevel The toplevel to use
 368      */
 369     public Symbol attribIdent(JCTree tree, JCCompilationUnit topLevel) {
 370         Env&lt;AttrContext&gt; localEnv = enter.topLevelEnv(topLevel);
 371         localEnv.enclClass = make.ClassDef(make.Modifiers(0),
 372                                            syms.errSymbol.name,
 373                                            null, null, null, null);
 374         localEnv.enclClass.sym = syms.errSymbol;
 375         return attribIdent(tree, localEnv);
 376     }
 377 
 378     /** Attribute a parsed identifier.
 379      * @param tree Parsed identifier name
 380      * @param env The env to use
 381      */
 382     public Symbol attribIdent(JCTree tree, Env&lt;AttrContext&gt; env) {
 383         return tree.accept(identAttributer, env);
 384     }
 385     // where
 386         private TreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; identAttributer = new IdentAttributer();
 387         private class IdentAttributer extends SimpleTreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; {
 388             @Override @DefinedBy(Api.COMPILER_TREE)
 389             public Symbol visitMemberSelect(MemberSelectTree node, Env&lt;AttrContext&gt; env) {
 390                 Symbol site = visit(node.getExpression(), env);
 391                 if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)
 392                     return site;
 393                 Name name = (Name)node.getIdentifier();
 394                 if (site.kind == PCK) {
 395                     env.toplevel.packge = (PackageSymbol)site;
 396                     return rs.findIdentInPackage(null, env, (TypeSymbol)site, name,
 397                             KindSelector.TYP_PCK);
 398                 } else {
 399                     env.enclClass.sym = (ClassSymbol)site;
 400                     return rs.findMemberType(env, site.asType(), name, (TypeSymbol)site);
 401                 }
 402             }
 403 
 404             @Override @DefinedBy(Api.COMPILER_TREE)
 405             public Symbol visitIdentifier(IdentifierTree node, Env&lt;AttrContext&gt; env) {
 406                 return rs.findIdent(null, env, (Name)node.getName(), KindSelector.TYP_PCK);
 407             }
 408         }
 409 
 410     public Type coerce(Type etype, Type ttype) {
 411         return cfolder.coerce(etype, ttype);
 412     }
 413 
 414     public Type attribType(JCTree node, TypeSymbol sym) {
 415         Env&lt;AttrContext&gt; env = typeEnvs.get(sym);
 416         Env&lt;AttrContext&gt; localEnv = env.dup(node, env.info.dup());
 417         return attribTree(node, localEnv, unknownTypeInfo);
 418     }
 419 
 420     public Type attribImportQualifier(JCImport tree, Env&lt;AttrContext&gt; env) {
 421         // Attribute qualifying package or class.
 422         JCFieldAccess s = (JCFieldAccess)tree.qualid;
 423         return attribTree(s.selected, env,
 424                           new ResultInfo(tree.staticImport ?
 425                                          KindSelector.TYP : KindSelector.TYP_PCK,
 426                        Type.noType));
 427     }
 428 
 429     public Env&lt;AttrContext&gt; attribExprToTree(JCTree expr, Env&lt;AttrContext&gt; env, JCTree tree) {
 430         return attribToTree(expr, env, tree, unknownExprInfo);
 431     }
 432 
 433     public Env&lt;AttrContext&gt; attribStatToTree(JCTree stmt, Env&lt;AttrContext&gt; env, JCTree tree) {
 434         return attribToTree(stmt, env, tree, statInfo);
 435     }
 436 
 437     private Env&lt;AttrContext&gt; attribToTree(JCTree root, Env&lt;AttrContext&gt; env, JCTree tree, ResultInfo resultInfo) {
 438         breakTree = tree;
 439         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 440         try {
 441             deferredAttr.attribSpeculative(root, env, resultInfo,
 442                     null, DeferredAttr.AttributionMode.ANALYZER,
 443                     argumentAttr.withLocalCacheContext());
 444         } catch (BreakAttr b) {
 445             return b.env;
 446         } catch (AssertionError ae) {
 447             if (ae.getCause() instanceof BreakAttr) {
 448                 return ((BreakAttr)(ae.getCause())).env;
 449             } else {
 450                 throw ae;
 451             }
 452         } finally {
 453             breakTree = null;
 454             log.useSource(prev);
 455         }
 456         return env;
 457     }
 458 
 459     private JCTree breakTree = null;
 460 
 461     private static class BreakAttr extends RuntimeException {
 462         static final long serialVersionUID = -6924771130405446405L;
 463         private transient Env&lt;AttrContext&gt; env;
 464         private BreakAttr(Env&lt;AttrContext&gt; env) {
 465             this.env = env;
 466         }
 467     }
 468 
 469     /**
 470      * Mode controlling behavior of Attr.Check
 471      */
 472     enum CheckMode {
 473 
 474         NORMAL,
 475 
 476         /**
 477          * Mode signalling &#39;fake check&#39; - skip tree update. A side-effect of this mode is
 478          * that the captured var cache in {@code InferenceContext} will be used in read-only
 479          * mode when performing inference checks.
 480          */
 481         NO_TREE_UPDATE {
 482             @Override
 483             public boolean updateTreeType() {
 484                 return false;
 485             }
 486         },
 487         /**
 488          * Mode signalling that caller will manage free types in tree decorations.
 489          */
 490         NO_INFERENCE_HOOK {
 491             @Override
 492             public boolean installPostInferenceHook() {
 493                 return false;
 494             }
 495         };
 496 
 497         public boolean updateTreeType() {
 498             return true;
 499         }
 500         public boolean installPostInferenceHook() {
 501             return true;
 502         }
 503     }
 504 
 505 
 506     class ResultInfo {
 507         final KindSelector pkind;
 508         final Type pt;
 509         final CheckContext checkContext;
 510         final CheckMode checkMode;
 511 
 512         ResultInfo(KindSelector pkind, Type pt) {
 513             this(pkind, pt, chk.basicHandler, CheckMode.NORMAL);
 514         }
 515 
 516         ResultInfo(KindSelector pkind, Type pt, CheckMode checkMode) {
 517             this(pkind, pt, chk.basicHandler, checkMode);
 518         }
 519 
 520         protected ResultInfo(KindSelector pkind,
 521                              Type pt, CheckContext checkContext) {
 522             this(pkind, pt, checkContext, CheckMode.NORMAL);
 523         }
 524 
 525         protected ResultInfo(KindSelector pkind,
 526                              Type pt, CheckContext checkContext, CheckMode checkMode) {
 527             this.pkind = pkind;
 528             this.pt = pt;
 529             this.checkContext = checkContext;
 530             this.checkMode = checkMode;
 531         }
 532 
 533         /**
 534          * Should {@link Attr#attribTree} use the {@ArgumentAttr} visitor instead of this one?
 535          * @param tree The tree to be type-checked.
 536          * @return true if {@ArgumentAttr} should be used.
 537          */
 538         protected boolean needsArgumentAttr(JCTree tree) { return false; }
 539 
 540         protected Type check(final DiagnosticPosition pos, final Type found) {
 541             return chk.checkType(pos, found, pt, checkContext);
 542         }
 543 
 544         protected ResultInfo dup(Type newPt) {
 545             return new ResultInfo(pkind, newPt, checkContext, checkMode);
 546         }
 547 
 548         protected ResultInfo dup(CheckContext newContext) {
 549             return new ResultInfo(pkind, pt, newContext, checkMode);
 550         }
 551 
 552         protected ResultInfo dup(Type newPt, CheckContext newContext) {
 553             return new ResultInfo(pkind, newPt, newContext, checkMode);
 554         }
 555 
 556         protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
 557             return new ResultInfo(pkind, newPt, newContext, newMode);
 558         }
 559 
 560         protected ResultInfo dup(CheckMode newMode) {
 561             return new ResultInfo(pkind, pt, checkContext, newMode);
 562         }
 563 
 564         @Override
 565         public String toString() {
 566             if (pt != null) {
 567                 return pt.toString();
 568             } else {
 569                 return &quot;&quot;;
 570             }
 571         }
 572     }
 573 
 574     class MethodAttrInfo extends ResultInfo {
 575         public MethodAttrInfo() {
 576             this(chk.basicHandler);
 577         }
 578 
 579         public MethodAttrInfo(CheckContext checkContext) {
 580             super(KindSelector.VAL, Infer.anyPoly, checkContext);
 581         }
 582 
 583         @Override
 584         protected boolean needsArgumentAttr(JCTree tree) {
 585             return true;
 586         }
 587 
 588         protected ResultInfo dup(Type newPt) {
 589             throw new IllegalStateException();
 590         }
 591 
 592         protected ResultInfo dup(CheckContext newContext) {
 593             return new MethodAttrInfo(newContext);
 594         }
 595 
 596         protected ResultInfo dup(Type newPt, CheckContext newContext) {
 597             throw new IllegalStateException();
 598         }
 599 
 600         protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
 601             throw new IllegalStateException();
 602         }
 603 
 604         protected ResultInfo dup(CheckMode newMode) {
 605             throw new IllegalStateException();
 606         }
 607     }
 608 
 609     class RecoveryInfo extends ResultInfo {
 610 
 611         public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext) {
 612             this(deferredAttrContext, Type.recoveryType);
 613         }
 614 
 615         public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext, Type pt) {
 616             super(KindSelector.VAL, pt, new Check.NestedCheckContext(chk.basicHandler) {
 617                 @Override
 618                 public DeferredAttr.DeferredAttrContext deferredAttrContext() {
 619                     return deferredAttrContext;
 620                 }
 621                 @Override
 622                 public boolean compatible(Type found, Type req, Warner warn) {
 623                     return true;
 624                 }
 625                 @Override
 626                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 627                     if (pt == Type.recoveryType) {
 628                         chk.basicHandler.report(pos, details);
 629                     }
 630                 }
 631             });
 632         }
 633     }
 634 
 635     final ResultInfo statInfo;
 636     final ResultInfo varAssignmentInfo;
 637     final ResultInfo methodAttrInfo;
 638     final ResultInfo unknownExprInfo;
 639     final ResultInfo unknownTypeInfo;
 640     final ResultInfo unknownTypeExprInfo;
 641     final ResultInfo recoveryInfo;
 642 
 643     Type pt() {
 644         return resultInfo.pt;
 645     }
 646 
 647     KindSelector pkind() {
 648         return resultInfo.pkind;
 649     }
 650 
 651 /* ************************************************************************
 652  * Visitor methods
 653  *************************************************************************/
 654 
 655     /** Visitor argument: the current environment.
 656      */
 657     Env&lt;AttrContext&gt; env;
 658 
 659     /** Visitor argument: the currently expected attribution result.
 660      */
 661     ResultInfo resultInfo;
 662 
 663     /** Visitor result: the computed type.
 664      */
 665     Type result;
 666 
 667     MatchBindings matchBindings = MatchBindingsComputer.EMPTY;
 668 
 669     /** Visitor method: attribute a tree, catching any completion failure
 670      *  exceptions. Return the tree&#39;s type.
 671      *
 672      *  @param tree    The tree to be visited.
 673      *  @param env     The environment visitor argument.
 674      *  @param resultInfo   The result info visitor argument.
 675      */
 676     Type attribTree(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
 677         Env&lt;AttrContext&gt; prevEnv = this.env;
 678         ResultInfo prevResult = this.resultInfo;
 679         try {
 680             this.env = env;
 681             this.resultInfo = resultInfo;
 682             if (resultInfo.needsArgumentAttr(tree)) {
 683                 result = argumentAttr.attribArg(tree, env);
 684             } else {
 685                 tree.accept(this);
 686             }
 687             matchBindings = matchBindingsComputer.finishBindings(tree,
 688                                                                  matchBindings);
 689             if (tree == breakTree &amp;&amp;
 690                     resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
 691                 breakTreeFound(copyEnv(env));
 692             }
 693             return result;
 694         } catch (CompletionFailure ex) {
 695             tree.type = syms.errType;
 696             return chk.completionError(tree.pos(), ex);
 697         } finally {
 698             this.env = prevEnv;
 699             this.resultInfo = prevResult;
 700         }
 701     }
 702 
 703     protected void breakTreeFound(Env&lt;AttrContext&gt; env) {
 704         throw new BreakAttr(env);
 705     }
 706 
 707     Env&lt;AttrContext&gt; copyEnv(Env&lt;AttrContext&gt; env) {
 708         Env&lt;AttrContext&gt; newEnv =
 709                 env.dup(env.tree, env.info.dup(copyScope(env.info.scope)));
 710         if (newEnv.outer != null) {
 711             newEnv.outer = copyEnv(newEnv.outer);
 712         }
 713         return newEnv;
 714     }
 715 
 716     WriteableScope copyScope(WriteableScope sc) {
 717         WriteableScope newScope = WriteableScope.create(sc.owner);
 718         List&lt;Symbol&gt; elemsList = List.nil();
 719         for (Symbol sym : sc.getSymbols()) {
 720             elemsList = elemsList.prepend(sym);
 721         }
 722         for (Symbol s : elemsList) {
 723             newScope.enter(s);
 724         }
 725         return newScope;
 726     }
 727 
 728     /** Derived visitor method: attribute an expression tree.
 729      */
 730     public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 731         return attribTree(tree, env, new ResultInfo(KindSelector.VAL, !pt.hasTag(ERROR) ? pt : Type.noType));
 732     }
 733 
 734     /** Derived visitor method: attribute an expression tree with
 735      *  no constraints on the computed type.
 736      */
 737     public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env) {
 738         return attribTree(tree, env, unknownExprInfo);
 739     }
 740 
 741     /** Derived visitor method: attribute a type tree.
 742      */
 743     public Type attribType(JCTree tree, Env&lt;AttrContext&gt; env) {
 744         Type result = attribType(tree, env, Type.noType);
 745         return result;
 746     }
 747 
 748     /** Derived visitor method: attribute a type tree.
 749      */
 750     Type attribType(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 751         Type result = attribTree(tree, env, new ResultInfo(KindSelector.TYP, pt));
 752         return result;
 753     }
 754 
 755     /** Derived visitor method: attribute a statement or definition tree.
 756      */
 757     public Type attribStat(JCTree tree, Env&lt;AttrContext&gt; env) {
 758         Env&lt;AttrContext&gt; analyzeEnv = analyzer.copyEnvIfNeeded(tree, env);
 759         Type result = attribTree(tree, env, statInfo);
 760         analyzer.analyzeIfNeeded(tree, analyzeEnv);
 761         return result;
 762     }
 763 
 764     /** Attribute a list of expressions, returning a list of types.
 765      */
 766     List&lt;Type&gt; attribExprs(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
 767         ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;&gt;();
 768         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 769             ts.append(attribExpr(l.head, env, pt));
 770         return ts.toList();
 771     }
 772 
 773     /** Attribute a list of statements, returning nothing.
 774      */
 775     &lt;T extends JCTree&gt; void attribStats(List&lt;T&gt; trees, Env&lt;AttrContext&gt; env) {
 776         for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
 777             attribStat(l.head, env);
 778     }
 779 
 780     /** Attribute the arguments in a method call, returning the method kind.
 781      */
 782     KindSelector attribArgs(KindSelector initialKind, List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, ListBuffer&lt;Type&gt; argtypes) {
 783         KindSelector kind = initialKind;
 784         for (JCExpression arg : trees) {
 785             Type argtype = chk.checkNonVoid(arg, attribTree(arg, env, allowPoly ? methodAttrInfo : unknownExprInfo));
 786             if (argtype.hasTag(DEFERRED)) {
 787                 kind = KindSelector.of(KindSelector.POLY, kind);
 788             }
 789             argtypes.append(argtype);
 790         }
 791         return kind;
 792     }
 793 
 794     /** Attribute a type argument list, returning a list of types.
 795      *  Caller is responsible for calling checkRefTypes.
 796      */
 797     List&lt;Type&gt; attribAnyTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 798         ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();
 799         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 800             argtypes.append(attribType(l.head, env));
 801         return argtypes.toList();
 802     }
 803 
 804     /** Attribute a type argument list, returning a list of types.
 805      *  Check that all the types are references.
 806      */
 807     List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 808         List&lt;Type&gt; types = attribAnyTypes(trees, env);
 809         return chk.checkRefTypes(trees, types);
 810     }
 811 
 812     /**
 813      * Attribute type variables (of generic classes or methods).
 814      * Compound types are attributed later in attribBounds.
 815      * @param typarams the type variables to enter
 816      * @param env      the current environment
 817      */
 818     void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env, boolean checkCyclic) {
 819         for (JCTypeParameter tvar : typarams) {
 820             TypeVar a = (TypeVar)tvar.type;
 821             a.tsym.flags_field |= UNATTRIBUTED;
 822             a.setUpperBound(Type.noType);
 823             if (!tvar.bounds.isEmpty()) {
 824                 List&lt;Type&gt; bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));
 825                 for (JCExpression bound : tvar.bounds.tail)
 826                     bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));
 827                 types.setBounds(a, bounds.reverse());
 828             } else {
 829                 // if no bounds are given, assume a single bound of
 830                 // java.lang.Object.
 831                 types.setBounds(a, List.of(syms.objectType));
 832             }
 833             a.tsym.flags_field &amp;= ~UNATTRIBUTED;
 834         }
 835         if (checkCyclic) {
 836             for (JCTypeParameter tvar : typarams) {
 837                 chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
 838             }
 839         }
 840     }
 841 
 842     /**
 843      * Attribute the type references in a list of annotations.
 844      */
 845     void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
 846                                Env&lt;AttrContext&gt; env) {
 847         for (List&lt;JCAnnotation&gt; al = annotations; al.nonEmpty(); al = al.tail) {
 848             JCAnnotation a = al.head;
 849             attribType(a.annotationType, env);
 850         }
 851     }
 852 
 853     /**
 854      * Attribute a &quot;lazy constant value&quot;.
 855      *  @param env         The env for the const value
 856      *  @param variable    The initializer for the const value
 857      *  @param type        The expected type, or null
 858      *  @see VarSymbol#setLazyConstValue
 859      */
 860     public Object attribLazyConstantValue(Env&lt;AttrContext&gt; env,
 861                                       JCVariableDecl variable,
 862                                       Type type) {
 863 
 864         DiagnosticPosition prevLintPos
 865                 = deferredLintHandler.setPos(variable.pos());
 866 
 867         final JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);
 868         try {
 869             Type itype = attribExpr(variable.init, env, type);
 870             if (variable.isImplicitlyTyped()) {
 871                 //fixup local variable type
 872                 type = variable.type = variable.sym.type = chk.checkLocalVarType(variable, itype.baseType(), variable.name);
 873             }
 874             if (itype.constValue() != null) {
 875                 return coerce(itype, type).constValue();
 876             } else {
 877                 return null;
 878             }
 879         } finally {
 880             log.useSource(prevSource);
 881             deferredLintHandler.setPos(prevLintPos);
 882         }
 883     }
 884 
 885     /** Attribute type reference in an `extends&#39; or `implements&#39; clause.
 886      *  Supertypes of anonymous inner classes are usually already attributed.
 887      *
 888      *  @param tree              The tree making up the type reference.
 889      *  @param env               The environment current at the reference.
 890      *  @param classExpected     true if only a class is expected here.
 891      *  @param interfaceExpected true if only an interface is expected here.
 892      */
 893     Type attribBase(JCTree tree,
 894                     Env&lt;AttrContext&gt; env,
 895                     boolean classExpected,
 896                     boolean interfaceExpected,
 897                     boolean checkExtensible) {
 898         Type t = tree.type != null ?
 899             tree.type :
 900             attribType(tree, env);
 901         return checkBase(t, tree, env, classExpected, interfaceExpected, checkExtensible);
 902     }
 903     Type checkBase(Type t,
 904                    JCTree tree,
 905                    Env&lt;AttrContext&gt; env,
 906                    boolean classExpected,
 907                    boolean interfaceExpected,
 908                    boolean checkExtensible) {
 909         final DiagnosticPosition pos = tree.hasTag(TYPEAPPLY) ?
 910                 (((JCTypeApply) tree).clazz).pos() : tree.pos();
 911         if (t.tsym.isAnonymous()) {
 912             log.error(pos, Errors.CantInheritFromAnon);
 913             return types.createErrorType(t);
 914         }
 915         if (t.isErroneous())
 916             return t;
 917         if (t.hasTag(TYPEVAR) &amp;&amp; !classExpected &amp;&amp; !interfaceExpected) {
 918             // check that type variable is already visible
 919             if (t.getUpperBound() == null) {
 920                 log.error(pos, Errors.IllegalForwardRef);
 921                 return types.createErrorType(t);
 922             }
 923         } else {
 924             t = chk.checkClassType(pos, t, checkExtensible);
 925         }
 926         if (interfaceExpected &amp;&amp; (t.tsym.flags() &amp; INTERFACE) == 0) {
 927             log.error(pos, Errors.IntfExpectedHere);
 928             // return errType is necessary since otherwise there might
 929             // be undetected cycles which cause attribution to loop
 930             return types.createErrorType(t);
 931         } else if (checkExtensible &amp;&amp;
 932                    classExpected &amp;&amp;
 933                    (t.tsym.flags() &amp; INTERFACE) != 0) {
 934             log.error(pos, Errors.NoIntfExpectedHere);
 935             return types.createErrorType(t);
 936         }
 937         if (checkExtensible &amp;&amp;
 938             ((t.tsym.flags() &amp; FINAL) != 0)) {
 939             log.error(pos,
 940                       Errors.CantInheritFromFinal(t.tsym));
 941         }
 942         chk.checkNonCyclic(pos, t);
 943         return t;
 944     }
 945 
 946     Type attribIdentAsEnumType(Env&lt;AttrContext&gt; env, JCIdent id) {
 947         Assert.check((env.enclClass.sym.flags() &amp; ENUM) != 0);
 948         id.type = env.info.scope.owner.enclClass().type;
 949         id.sym = env.info.scope.owner.enclClass();
 950         return id.type;
 951     }
 952 
 953     public void visitClassDef(JCClassDecl tree) {
 954         Optional&lt;ArgumentAttr.LocalCacheContext&gt; localCacheContext =
 955                 Optional.ofNullable(env.info.attributionMode.isSpeculative ?
 956                         argumentAttr.withLocalCacheContext() : null);
 957         try {
 958             // Local and anonymous classes have not been entered yet, so we need to
 959             // do it now.
 960             if (env.info.scope.owner.kind.matches(KindSelector.VAL_MTH)) {
 961                 enter.classEnter(tree, env);
 962             } else {
 963                 // If this class declaration is part of a class level annotation,
 964                 // as in @MyAnno(new Object() {}) class MyClass {}, enter it in
 965                 // order to simplify later steps and allow for sensible error
 966                 // messages.
 967                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 968                     enter.classEnter(tree, env);
 969             }
 970 
 971             ClassSymbol c = tree.sym;
 972             if (c == null) {
 973                 // exit in case something drastic went wrong during enter.
 974                 result = null;
 975             } else {
 976                 // make sure class has been completed:
 977                 c.complete();
 978 
 979                 // If this class appears as an anonymous class
 980                 // in a superclass constructor call
 981                 // disable implicit outer instance from being passed.
 982                 // (This would be an illegal access to &quot;this before super&quot;).
 983                 if (env.info.isSelfCall &amp;&amp;
 984                         env.tree.hasTag(NEWCLASS)) {
 985                     c.flags_field |= NOOUTERTHIS;
 986                 }
 987                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; types.isValue(c.getSuperclass())) {
 988                     c.flags_field |= VALUE; // avoid further secondary errors.
 989                 }
 990                 attribClass(tree.pos(), c);
 991                 result = tree.type = c.type;
 992             }
 993         } finally {
 994             localCacheContext.ifPresent(LocalCacheContext::leave);
 995         }
 996     }
 997 
 998     public void visitMethodDef(JCMethodDecl tree) {
 999         MethodSymbol m = tree.sym;
1000         boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
1001 
1002         Lint lint = env.info.lint.augment(m);
1003         Lint prevLint = chk.setLint(lint);
1004         MethodSymbol prevMethod = chk.setMethod(m);
1005         try {
1006             deferredLintHandler.flush(tree.pos());
1007             chk.checkDeprecatedAnnotation(tree.pos(), m);
1008 
1009 
1010             // Create a new environment with local scope
1011             // for attributing the method.
1012             Env&lt;AttrContext&gt; localEnv = memberEnter.methodEnv(tree, env);
1013             localEnv.info.lint = lint;
1014 
1015             attribStats(tree.typarams, localEnv);
1016 
1017             // If we override any other methods, check that we do so properly.
1018             // JLS ???
1019             if (m.isStatic()) {
1020                 chk.checkHideClashes(tree.pos(), env.enclClass.type, m);
1021             } else {
1022                 chk.checkOverrideClashes(tree.pos(), env.enclClass.type, m);
1023             }
1024             chk.checkOverride(env, tree, m);
1025 
1026             if (isDefaultMethod &amp;&amp; types.overridesObjectMethod(m.enclClass(), m)) {
1027                 log.error(tree, Errors.DefaultOverridesObjectMember(m.name, Kinds.kindName(m.location()), m.location()));
1028             }
1029 
1030             // Enter all type parameters into the local method scope.
1031             for (List&lt;JCTypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = l.tail)
1032                 localEnv.info.scope.enterIfAbsent(l.head.type.tsym);
1033 
1034             ClassSymbol owner = env.enclClass.sym;
1035             if ((owner.flags() &amp; ANNOTATION) != 0 &amp;&amp;
1036                     (tree.params.nonEmpty() ||
1037                     tree.recvparam != null))
1038                 log.error(tree.params.nonEmpty() ?
1039                         tree.params.head.pos() :
1040                         tree.recvparam.pos(),
1041                         Errors.IntfAnnotationMembersCantHaveParams);
1042 
1043             // Attribute all value parameters.
1044             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1045                 attribStat(l.head, localEnv);
1046             }
1047 
1048             chk.checkVarargsMethodDecl(localEnv, tree);
1049 
1050             // Check that type parameters are well-formed.
1051             chk.validate(tree.typarams, localEnv);
1052 
1053             // Check that result type is well-formed.
1054             if (tree.restype != null &amp;&amp; !tree.restype.type.hasTag(VOID))
1055                 chk.validate(tree.restype, localEnv);
1056 
1057             // Check that receiver type is well-formed.
1058             if (tree.recvparam != null) {
1059                 // Use a new environment to check the receiver parameter.
1060                 // Otherwise I get &quot;might not have been initialized&quot; errors.
1061                 // Is there a better way?
1062                 Env&lt;AttrContext&gt; newEnv = memberEnter.methodEnv(tree, env);
1063                 attribType(tree.recvparam, newEnv);
1064                 chk.validate(tree.recvparam, newEnv);
1065             }
1066 
1067             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP) {
1068                 // lets find if this method is an accessor
1069                 Optional&lt;? extends RecordComponent&gt; recordComponent = env.enclClass.sym.getRecordComponents().stream()
1070                         .filter(rc -&gt; rc.accessor == tree.sym &amp;&amp; (rc.accessor.flags_field &amp; GENERATED_MEMBER) == 0).findFirst();
1071                 if (recordComponent.isPresent()) {
1072                     // the method is a user defined accessor lets check that everything is fine
1073                     if (!tree.sym.isPublic()) {
1074                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.MethodMustBePublic));
1075                     }
1076                     if (!types.isSameType(tree.sym.type.getReturnType(), recordComponent.get().type)) {
1077                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym,
1078                                 Fragments.AccessorReturnTypeDoesntMatch(tree.sym, recordComponent.get())));
1079                     }
1080                     if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1081                         log.error(tree,
1082                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodCantThrowException));
1083                     }
1084                     if (!tree.typarams.isEmpty()) {
1085                         log.error(tree,
1086                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeGeneric));
1087                     }
1088                     if (tree.sym.isStatic()) {
1089                         log.error(tree,
1090                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeStatic));
1091                     }
1092                 }
1093 
1094                 if (tree.name == names.init) {
1095                     // if this a constructor other than the canonical one
1096                     if ((tree.sym.flags_field &amp; RECORD) == 0) {
1097                         JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1098                         if (app == null ||
1099                                 TreeInfo.name(app.meth) != names._this ||
1100                                 !checkFirstConstructorStat(app, tree, false)) {
1101                             log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);
1102                         }
1103                     } else {
1104                         // but if it is the canonical:
1105 
1106                         /* if user generated, then it shouldn&#39;t:
1107                          *     - have an accessibility stricter than that of the record type
1108                          *     - explicitly invoke any other constructor
1109                          */
1110                         if ((tree.sym.flags_field &amp; GENERATEDCONSTR) == 0) {
1111                             if (Check.protection(m.flags()) &gt; Check.protection(env.enclClass.sym.flags())) {
1112                                 log.error(tree,
1113                                         (env.enclClass.sym.flags() &amp; AccessFlags) == 0 ?
1114                                             Errors.InvalidCanonicalConstructorInRecord(
1115                                                 Fragments.Canonical,
1116                                                 env.enclClass.sym.name,
1117                                                 Fragments.CanonicalMustNotHaveStrongerAccess(&quot;package&quot;)
1118                                             ) :
1119                                             Errors.InvalidCanonicalConstructorInRecord(
1120                                                     Fragments.Canonical,
1121                                                     env.enclClass.sym.name,
1122                                                     Fragments.CanonicalMustNotHaveStrongerAccess(asFlagSet(env.enclClass.sym.flags() &amp; AccessFlags))
1123                                             )
1124                                 );
1125                             }
1126 
1127                             JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1128                             if (app != null &amp;&amp;
1129                                     (TreeInfo.name(app.meth) == names._this ||
1130                                             TreeInfo.name(app.meth) == names._super) &amp;&amp;
1131                                     checkFirstConstructorStat(app, tree, false)) {
1132                                 log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1133                                         Fragments.Canonical, env.enclClass.sym.name,
1134                                         Fragments.CanonicalMustNotContainExplicitConstructorInvocation));
1135                             }
1136                         }
1137 
1138                         // also we want to check that no type variables have been defined
1139                         if (!tree.typarams.isEmpty()) {
1140                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1141                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalMustNotDeclareTypeVariables));
1142                         }
1143 
1144                         /* and now we need to check that the constructor&#39;s arguments are exactly the same as those of the
1145                          * record components
1146                          */
1147                         List&lt;? extends RecordComponent&gt; recordComponents = env.enclClass.sym.getRecordComponents();
1148                         List&lt;Type&gt; recordFieldTypes = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.type);
1149                         for (JCVariableDecl param: tree.params) {
1150                             boolean paramIsVarArgs = (param.sym.flags_field &amp; VARARGS) != 0;
1151                             if (!types.isSameType(param.type, recordFieldTypes.head) ||
1152                                     (recordComponents.head.isVarargs() != paramIsVarArgs)) {
1153                                 log.error(param, Errors.InvalidCanonicalConstructorInRecord(
1154                                         Fragments.Canonical, env.enclClass.sym.name,
1155                                         Fragments.TypeMustBeIdenticalToCorrespondingRecordComponentType));
1156                             }
1157                             recordComponents = recordComponents.tail;
1158                             recordFieldTypes = recordFieldTypes.tail;
1159                         }
1160                     }
1161                 }
1162             }
1163 
1164             // annotation method checks
1165             if ((owner.flags() &amp; ANNOTATION) != 0) {
1166                 // annotation method cannot have throws clause
1167                 if (tree.thrown.nonEmpty()) {
1168                     log.error(tree.thrown.head.pos(),
1169                               Errors.ThrowsNotAllowedInIntfAnnotation);
1170                 }
1171                 // annotation method cannot declare type-parameters
1172                 if (tree.typarams.nonEmpty()) {
1173                     log.error(tree.typarams.head.pos(),
1174                               Errors.IntfAnnotationMembersCantHaveTypeParams);
1175                 }
1176                 // validate annotation method&#39;s return type (could be an annotation type)
1177                 chk.validateAnnotationType(tree.restype);
1178                 // ensure that annotation method does not clash with members of Object/Annotation
1179                 chk.validateAnnotationMethod(tree.pos(), m);
1180             }
1181 
1182             for (List&lt;JCExpression&gt; l = tree.thrown; l.nonEmpty(); l = l.tail)
1183                 chk.checkType(l.head.pos(), l.head.type, syms.throwableType);
1184 
1185             if (tree.body == null) {
1186                 // Empty bodies are only allowed for
1187                 // abstract, native, or interface methods, or for methods
1188                 // in a retrofit signature class.
1189                 if (tree.defaultValue != null) {
1190                     if ((owner.flags() &amp; ANNOTATION) == 0)
1191                         log.error(tree.pos(),
1192                                   Errors.DefaultAllowedInIntfAnnotationMember);
1193                 }
1194                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1195                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1196             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1197                 if ((owner.flags() &amp; INTERFACE) != 0) {
1198                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1199                 } else {
1200                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1201                 }
1202             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1203                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1204             } else {
1205                 // Add an implicit super() call unless an explicit call to
1206                 // super(...) or this(...) is given
1207                 // or we are compiling class java.lang.Object.
1208                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1209                     JCBlock body = tree.body;
1210                     if (body.stats.isEmpty() ||
1211                             TreeInfo.getConstructorInvocationName(body.stats, names, true) == names.empty) {
1212                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1213                                 make.Ident(names._super), make.Idents(List.nil())));
1214                         body.stats = body.stats.prepend(supCall);
1215                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1216                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1217                             TreeInfo.isSuperCall(body.stats.head)) {
1218                         // enum constructors are not allowed to call super
1219                         // directly, so make sure there aren&#39;t any super calls
1220                         // in enum constructors, except in the compiler
1221                         // generated one.
1222                         log.error(tree.body.stats.head.pos(),
1223                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1224                     }
1225                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1226                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1227                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1228                         if (!initParamNames.equals(recordComponentNames)) {
1229                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1230                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1231                         }
1232                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1233                             log.error(tree,
1234                                     Errors.InvalidCanonicalConstructorInRecord(
1235                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1236                                             env.enclClass.sym.name,
1237                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1238                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1239                         }
1240                     }
1241                 }
1242                 if (m.isConstructor() &amp;&amp; m.type.getParameterTypes().size() == 0) {
1243                     if ((owner.type == syms.objectType) ||
1244                             (tree.body.stats.size() == 1 &amp;&amp; TreeInfo.getConstructorInvocationName(tree.body.stats, names, false) == names._super)) {
1245                         m.flags_field |= EMPTYNOARGCONSTR;
1246                     }
1247                 }
1248 
1249                 // Attribute all type annotations in the body
1250                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1251                 annotate.flush();
1252 
1253                 // Attribute method body.
1254                 attribStat(tree.body, localEnv);
1255             }
1256 
1257             localEnv.info.scope.leave();
1258             result = tree.type = m.type;
1259         } finally {
1260             chk.setLint(prevLint);
1261             chk.setMethod(prevMethod);
1262         }
1263     }
1264 
1265     public void visitVarDef(JCVariableDecl tree) {
1266         // Local variables have not been entered yet, so we need to do it now:
1267         if (env.info.scope.owner.kind == MTH || env.info.scope.owner.kind == VAR) {
1268             if (tree.sym != null) {
1269                 // parameters have already been entered
1270                 env.info.scope.enter(tree.sym);
1271             } else {
1272                 if (tree.isImplicitlyTyped() &amp;&amp; (tree.getModifiers().flags &amp; PARAMETER) == 0) {
1273                     if (tree.init == null) {
1274                         //cannot use &#39;var&#39; without initializer
1275                         log.error(tree, Errors.CantInferLocalVarType(tree.name, Fragments.LocalMissingInit));
1276                         tree.vartype = make.Erroneous();
1277                     } else {
1278                         Fragment msg = canInferLocalVarType(tree);
1279                         if (msg != null) {
1280                             //cannot use &#39;var&#39; with initializer which require an explicit target
1281                             //(e.g. lambda, method reference, array initializer).
1282                             log.error(tree, Errors.CantInferLocalVarType(tree.name, msg));
1283                             tree.vartype = make.Erroneous();
1284                         }
1285                     }
1286                 }
1287                 try {
1288                     annotate.blockAnnotations();
1289                     memberEnter.memberEnter(tree, env);
1290                 } finally {
1291                     annotate.unblockAnnotations();
1292                 }
1293             }
1294         } else {
1295             if (tree.init != null) {
1296                 // Field initializer expression need to be entered.
1297                 annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());
1298                 annotate.flush();
1299             }
1300         }
1301 
1302         VarSymbol v = tree.sym;
1303         Lint lint = env.info.lint.augment(v);
1304         Lint prevLint = chk.setLint(lint);
1305 
1306         // Check that the variable&#39;s declared type is well-formed.
1307         boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;
1308                 ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1309                 (tree.sym.flags() &amp; PARAMETER) != 0;
1310         chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
1311 
1312         try {
1313             v.getConstValue(); // ensure compile-time constant initializer is evaluated
1314             deferredLintHandler.flush(tree.pos());
1315             chk.checkDeprecatedAnnotation(tree.pos(), v);
1316 
1317             /* Don&#39;t want constant propagation/folding for instance fields of value classes,
1318                as these can undergo updates via copy on write.
1319             */
1320             if (tree.init != null) {
1321                 if ((v.flags_field &amp; FINAL) == 0 || ((v.flags_field &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) ||
1322                     !memberEnter.needsLazyConstValue(tree.init)) {
1323                     // Not a compile-time constant
1324                     // Attribute initializer in a new environment
1325                     // with the declared variable as owner.
1326                     // Check that initializer conforms to variable&#39;s declared type.
1327                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1328                     initEnv.info.lint = lint;
1329                     // In order to catch self-references, we set the variable&#39;s
1330                     // declaration position to maximal possible value, effectively
1331                     // marking the variable as undefined.
1332                     initEnv.info.enclVar = v;
1333                     attribExpr(tree.init, initEnv, v.type);
1334                     if (tree.isImplicitlyTyped()) {
1335                         //fixup local variable type
1336                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1337                     }
1338                 }
1339                 if (tree.isImplicitlyTyped()) {
1340                     setSyntheticVariableType(tree, v.type);
1341                 }
1342             }
1343             result = tree.type = v.type;
1344             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP &amp;&amp; !v.isStatic()) {
1345                 if (isNonArgsMethodInObject(v.name)) {
1346                     log.error(tree, Errors.IllegalRecordComponentName(v));
1347                 }
1348             }
1349         }
1350         finally {
1351             chk.setLint(prevLint);
1352         }
1353     }
1354 
1355     private boolean isNonArgsMethodInObject(Name name) {
1356         for (Symbol s : syms.objectType.tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {
1357             if (s.type.getParameterTypes().isEmpty()) {
1358                 return true;
1359             }
1360         }
1361         return false;
1362     }
1363 
1364     Fragment canInferLocalVarType(JCVariableDecl tree) {
1365         LocalInitScanner lis = new LocalInitScanner();
1366         lis.scan(tree.init);
1367         return lis.badInferenceMsg;
1368     }
1369 
1370     static class LocalInitScanner extends TreeScanner {
1371         Fragment badInferenceMsg = null;
1372         boolean needsTarget = true;
1373 
1374         @Override
1375         public void visitNewArray(JCNewArray tree) {
1376             if (tree.elemtype == null &amp;&amp; needsTarget) {
1377                 badInferenceMsg = Fragments.LocalArrayMissingTarget;
1378             }
1379         }
1380 
1381         @Override
1382         public void visitLambda(JCLambda tree) {
1383             if (needsTarget) {
1384                 badInferenceMsg = Fragments.LocalLambdaMissingTarget;
1385             }
1386         }
1387 
1388         @Override
1389         public void visitTypeCast(JCTypeCast tree) {
1390             boolean prevNeedsTarget = needsTarget;
1391             try {
1392                 needsTarget = false;
1393                 super.visitTypeCast(tree);
1394             } finally {
1395                 needsTarget = prevNeedsTarget;
1396             }
1397         }
1398 
1399         @Override
1400         public void visitReference(JCMemberReference tree) {
1401             if (needsTarget) {
1402                 badInferenceMsg = Fragments.LocalMrefMissingTarget;
1403             }
1404         }
1405 
1406         @Override
1407         public void visitNewClass(JCNewClass tree) {
1408             boolean prevNeedsTarget = needsTarget;
1409             try {
1410                 needsTarget = false;
1411                 super.visitNewClass(tree);
1412             } finally {
1413                 needsTarget = prevNeedsTarget;
1414             }
1415         }
1416 
1417         @Override
1418         public void visitApply(JCMethodInvocation tree) {
1419             boolean prevNeedsTarget = needsTarget;
1420             try {
1421                 needsTarget = false;
1422                 super.visitApply(tree);
1423             } finally {
1424                 needsTarget = prevNeedsTarget;
1425             }
1426         }
1427     }
1428 
1429     public void visitSkip(JCSkip tree) {
1430         result = null;
1431     }
1432 
1433     public void visitBlock(JCBlock tree) {
1434         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {
1435             // Block is a static or instance initializer;
1436             // let the owner of the environment be a freshly
1437             // created BLOCK-method.
1438             Symbol fakeOwner =
1439                 new MethodSymbol(tree.flags | BLOCK |
1440                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1441                     env.info.scope.owner);
1442             final Env&lt;AttrContext&gt; localEnv =
1443                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1444 
1445             if ((tree.flags &amp; STATIC) != 0)
1446                 localEnv.info.staticLevel++;
1447             else if (tree.stats.size() &gt; 0)
1448                 env.info.scope.owner.flags_field |= HASINITBLOCK;
1449 
1450             // Attribute all type annotations in the block
1451             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1452             annotate.flush();
1453             attribStats(tree.stats, localEnv);
1454 
1455             {
1456                 // Store init and clinit type annotations with the ClassSymbol
1457                 // to allow output in Gen.normalizeDefs.
1458                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
1459                 List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();
1460                 if ((tree.flags &amp; STATIC) != 0) {
1461                     cs.appendClassInitTypeAttributes(tas);
1462                 } else {
1463                     cs.appendInitTypeAttributes(tas);
1464                 }
1465             }
1466         } else {
1467             // Create a new local environment with a local scope.
1468             Env&lt;AttrContext&gt; localEnv =
1469                 env.dup(tree, env.info.dup(env.info.scope.dup()));
1470             try {
1471                 attribStats(tree.stats, localEnv);
1472             } finally {
1473                 localEnv.info.scope.leave();
1474             }
1475         }
1476         result = null;
1477     }
1478 
1479     public void visitDoLoop(JCDoWhileLoop tree) {
1480         attribStat(tree.body, env.dup(tree));
1481         attribExpr(tree.cond, env, syms.booleanType);
1482         if (!breaksOutOf(tree, tree.body)) {
1483             //include condition&#39;s body when false after the while, if cannot get out of the loop
1484             MatchBindings condBindings = matchBindings;
1485             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1486             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1487         }
1488         result = null;
1489     }
1490 
1491     public void visitWhileLoop(JCWhileLoop tree) {
1492         attribExpr(tree.cond, env, syms.booleanType);
1493         MatchBindings condBindings = matchBindings;
1494         // include condition&#39;s bindings when true in the body:
1495         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1496         try {
1497             attribStat(tree.body, whileEnv.dup(tree));
1498         } finally {
1499             whileEnv.info.scope.leave();
1500         }
1501         if (!breaksOutOf(tree, tree.body)) {
1502             //include condition&#39;s bindings when false after the while, if cannot get out of the loop
1503             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1504             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1505         }
1506         result = null;
1507     }
1508 
1509     private boolean breaksOutOf(JCTree loop, JCTree body) {
1510         preFlow(body);
1511         return flow.breaksOutOf(env, loop, body, make);
1512     }
1513 
1514     public void visitWithField(JCWithField tree) {
1515         boolean inWithField = env.info.inWithField;
1516         try {
1517             env.info.inWithField = true;
1518             Type fieldtype = attribTree(tree.field, env.dup(tree), varAssignmentInfo);
1519             attribExpr(tree.value, env, fieldtype);
1520             Type capturedType = syms.errType;
1521             if (tree.field.type != null &amp;&amp; !tree.field.type.isErroneous()) {
1522                 final Symbol sym = TreeInfo.symbol(tree.field);
1523                 if (sym == null || sym.kind != VAR || sym.owner.kind != TYP ||
1524                         (sym.flags() &amp; STATIC) != 0 || !types.isValue(sym.owner.type)) {
1525                     log.error(tree.field.pos(), Errors.ValueInstanceFieldExpectedHere);
1526                 } else {
1527                     Type ownType = sym.owner.type;
1528                     switch(tree.field.getTag()) {
1529                         case IDENT:
1530                             JCIdent ident = (JCIdent) tree.field;
1531                             ownType = ident.sym.owner.type;
1532                             break;
1533                         case SELECT:
1534                             JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;
1535                             ownType = fieldAccess.selected.type;
1536                             break;
1537                     }
1538                     capturedType = capture(ownType);
1539                 }
1540             }
1541             result = check(tree, capturedType, KindSelector.VAL, resultInfo);
1542         } finally {
1543             env.info.inWithField = inWithField;
1544         }
1545     }
1546 
1547     public void visitForLoop(JCForLoop tree) {
1548         Env&lt;AttrContext&gt; loopEnv =
1549             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1550         MatchBindings condBindings = MatchBindingsComputer.EMPTY;
1551         try {
1552             attribStats(tree.init, loopEnv);
1553             if (tree.cond != null) {
1554                 attribExpr(tree.cond, loopEnv, syms.booleanType);
1555                 // include condition&#39;s bindings when true in the body and step:
1556                 condBindings = matchBindings;
1557             }
1558             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);
1559             try {
1560                 bodyEnv.tree = tree; // before, we were not in loop!
1561                 attribStats(tree.step, bodyEnv);
1562                 attribStat(tree.body, bodyEnv);
1563             } finally {
1564                 bodyEnv.info.scope.leave();
1565             }
1566             result = null;
1567         }
1568         finally {
1569             loopEnv.info.scope.leave();
1570         }
1571         if (!breaksOutOf(tree, tree.body)) {
1572             //include condition&#39;s body when false after the while, if cannot get out of the loop
1573             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1574             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1575         }
1576     }
1577 
1578     public void visitForeachLoop(JCEnhancedForLoop tree) {
1579         Env&lt;AttrContext&gt; loopEnv =
1580             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1581         try {
1582             //the Formal Parameter of a for-each loop is not in the scope when
1583             //attributing the for-each expression; we mimic this by attributing
1584             //the for-each expression first (against original scope).
1585             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1586             chk.checkNonVoid(tree.pos(), exprType);
1587             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1588             if (elemtype == null) {
1589                 // or perhaps expr implements Iterable&lt;T&gt;?
1590                 Type base = types.asSuper(exprType, syms.iterableType.tsym, true);
1591                 if (base == null) {
1592                     log.error(tree.expr.pos(),
1593                               Errors.ForeachNotApplicableToType(exprType,
1594                                                                 Fragments.TypeReqArrayOrIterable));
1595                     elemtype = types.createErrorType(exprType);
1596                 } else {
1597                     List&lt;Type&gt; iterableParams = base.allparams();
1598                     elemtype = iterableParams.isEmpty()
1599                         ? syms.objectType
1600                         : types.wildUpperBound(iterableParams.head);
1601                 }
1602             }
1603             if (tree.var.isImplicitlyTyped()) {
1604                 Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);
1605                 setSyntheticVariableType(tree.var, inferredType);
1606             }
1607             attribStat(tree.var, loopEnv);
1608             chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
1609             loopEnv.tree = tree; // before, we were not in loop!
1610             attribStat(tree.body, loopEnv);
1611             result = null;
1612         }
1613         finally {
1614             loopEnv.info.scope.leave();
1615         }
1616     }
1617 
1618     public void visitLabelled(JCLabeledStatement tree) {
1619         // Check that label is not used in an enclosing statement
1620         Env&lt;AttrContext&gt; env1 = env;
1621         while (env1 != null &amp;&amp; !env1.tree.hasTag(CLASSDEF)) {
1622             if (env1.tree.hasTag(LABELLED) &amp;&amp;
1623                 ((JCLabeledStatement) env1.tree).label == tree.label) {
1624                 log.error(tree.pos(),
1625                           Errors.LabelAlreadyInUse(tree.label));
1626                 break;
1627             }
1628             env1 = env1.next;
1629         }
1630 
1631         attribStat(tree.body, env.dup(tree));
1632         result = null;
1633     }
1634 
1635     public void visitSwitch(JCSwitch tree) {
1636         handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
1637             attribStats(c.stats, caseEnv);
1638         });
1639         result = null;
1640     }
1641 
1642     public void visitSwitchExpression(JCSwitchExpression tree) {
1643         tree.polyKind = (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly) ?
1644                 PolyKind.STANDALONE : PolyKind.POLY;
1645 
1646         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1647             //this means we are returning a poly conditional from void-compatible lambda expression
1648             resultInfo.checkContext.report(tree, diags.fragment(Fragments.SwitchExpressionTargetCantBeVoid));
1649             result = tree.type = types.createErrorType(resultInfo.pt);
1650             return;
1651         }
1652 
1653         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1654                 unknownExprInfo :
1655                 resultInfo.dup(switchExpressionContext(resultInfo.checkContext));
1656 
1657         ListBuffer&lt;DiagnosticPosition&gt; caseTypePositions = new ListBuffer&lt;&gt;();
1658         ListBuffer&lt;Type&gt; caseTypes = new ListBuffer&lt;&gt;();
1659 
1660         handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
1661             caseEnv.info.yieldResult = condInfo;
1662             attribStats(c.stats, caseEnv);
1663             new TreeScanner() {
1664                 @Override
1665                 public void visitYield(JCYield brk) {
1666                     if (brk.target == tree) {
1667                         caseTypePositions.append(brk.value != null ? brk.value.pos() : brk.pos());
1668                         caseTypes.append(brk.value != null ? brk.value.type : syms.errType);
1669                     }
1670                     super.visitYield(brk);
1671                 }
1672 
1673                 @Override public void visitClassDef(JCClassDecl tree) {}
1674                 @Override public void visitLambda(JCLambda tree) {}
1675             }.scan(c.stats);
1676         });
1677 
1678         if (tree.cases.isEmpty()) {
1679             log.error(tree.pos(),
1680                       Errors.SwitchExpressionEmpty);
1681         } else if (caseTypes.isEmpty()) {
1682             log.error(tree.pos(),
1683                       Errors.SwitchExpressionNoResultExpressions);
1684         }
1685 
1686         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ? condType(caseTypePositions.toList(), caseTypes.toList()) : pt();
1687 
1688         result = tree.type = check(tree, owntype, KindSelector.VAL, resultInfo);
1689     }
1690     //where:
1691         CheckContext switchExpressionContext(CheckContext checkContext) {
1692             return new Check.NestedCheckContext(checkContext) {
1693                 //this will use enclosing check context to check compatibility of
1694                 //subexpression against target type; if we are in a method check context,
1695                 //depending on whether boxing is allowed, we could have incompatibilities
1696                 @Override
1697                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
1698                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInSwitchExpression(details)));
1699                 }
1700             };
1701         }
1702 
1703     private void handleSwitch(JCTree switchTree,
1704                               JCExpression selector,
1705                               List&lt;JCCase&gt; cases,
1706                               BiConsumer&lt;JCCase, Env&lt;AttrContext&gt;&gt; attribCase) {
1707         Type seltype = attribExpr(selector, env);
1708 
1709         Env&lt;AttrContext&gt; switchEnv =
1710             env.dup(switchTree, env.info.dup(env.info.scope.dup()));
1711 
1712         try {
1713             boolean enumSwitch = (seltype.tsym.flags() &amp; Flags.ENUM) != 0;
1714             boolean stringSwitch = types.isSameType(seltype, syms.stringType);
1715             if (!enumSwitch &amp;&amp; !stringSwitch)
1716                 seltype = chk.checkType(selector.pos(), seltype, syms.intType);
1717 
1718             // Attribute all cases and
1719             // check that there are no duplicate case labels or default clauses.
1720             Set&lt;Object&gt; labels = new HashSet&lt;&gt;(); // The set of case labels.
1721             boolean hasDefault = false;      // Is there a default label?
1722             CaseTree.CaseKind caseKind = null;
1723             boolean wasError = false;
1724             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1725                 JCCase c = l.head;
1726                 if (caseKind == null) {
1727                     caseKind = c.caseKind;
1728                 } else if (caseKind != c.caseKind &amp;&amp; !wasError) {
1729                     log.error(c.pos(),
1730                               Errors.SwitchMixingCaseTypes);
1731                     wasError = true;
1732                 }
1733                 if (c.getExpressions().nonEmpty()) {
1734                     for (JCExpression pat : c.getExpressions()) {
1735                         if (TreeInfo.isNull(pat)) {
1736                             log.error(pat.pos(),
1737                                       Errors.SwitchNullNotAllowed);
1738                         } else if (enumSwitch) {
1739                             Symbol sym = enumConstant(pat, seltype);
1740                             if (sym == null) {
1741                                 log.error(pat.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);
1742                             } else if (!labels.add(sym)) {
1743                                 log.error(c.pos(), Errors.DuplicateCaseLabel);
1744                             }
1745                         } else {
1746                             Type pattype = attribExpr(pat, switchEnv, seltype);
1747                             if (!pattype.hasTag(ERROR)) {
1748                                 if (pattype.constValue() == null) {
1749                                     log.error(pat.pos(),
1750                                               (stringSwitch ? Errors.StringConstReq : Errors.ConstExprReq));
1751                                 } else if (!labels.add(pattype.constValue())) {
1752                                     log.error(c.pos(), Errors.DuplicateCaseLabel);
1753                                 }
1754                             }
1755                         }
1756                     }
1757                 } else if (hasDefault) {
1758                     log.error(c.pos(), Errors.DuplicateDefaultLabel);
1759                 } else {
1760                     hasDefault = true;
1761                 }
1762                 Env&lt;AttrContext&gt; caseEnv =
1763                     switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));
1764                 try {
1765                     attribCase.accept(c, caseEnv);
1766                 } finally {
1767                     caseEnv.info.scope.leave();
1768                 }
1769                 addVars(c.stats, switchEnv.info.scope);
1770             }
1771         } finally {
1772             switchEnv.info.scope.leave();
1773         }
1774     }
1775     // where
1776         /** Add any variables defined in stats to the switch scope. */
1777         private static void addVars(List&lt;JCStatement&gt; stats, WriteableScope switchScope) {
1778             for (;stats.nonEmpty(); stats = stats.tail) {
1779                 JCTree stat = stats.head;
1780                 if (stat.hasTag(VARDEF))
1781                     switchScope.enter(((JCVariableDecl) stat).sym);
1782             }
1783         }
1784     // where
1785     /** Return the selected enumeration constant symbol, or null. */
1786     private Symbol enumConstant(JCTree tree, Type enumType) {
1787         if (tree.hasTag(IDENT)) {
1788             JCIdent ident = (JCIdent)tree;
1789             Name name = ident.name;
1790             for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {
1791                 if (sym.kind == VAR) {
1792                     Symbol s = ident.sym = sym;
1793                     ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated
1794                     ident.type = s.type;
1795                     return ((s.flags_field &amp; Flags.ENUM) == 0)
1796                         ? null : s;
1797                 }
1798             }
1799         }
1800         return null;
1801     }
1802 
1803     public void visitSynchronized(JCSynchronized tree) {
1804         chk.checkRefType(tree.pos(), attribExpr(tree.lock, env), false);
1805         attribStat(tree.body, env);
1806         result = null;
1807     }
1808 
1809     public void visitTry(JCTry tree) {
1810         // Create a new local environment with a local
1811         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
1812         try {
1813             boolean isTryWithResource = tree.resources.nonEmpty();
1814             // Create a nested environment for attributing the try block if needed
1815             Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
1816                 env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
1817                 localEnv;
1818             try {
1819                 // Attribute resource declarations
1820                 for (JCTree resource : tree.resources) {
1821                     CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
1822                         @Override
1823                         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1824                             chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
1825                         }
1826                     };
1827                     ResultInfo twrResult =
1828                         new ResultInfo(KindSelector.VAR,
1829                                        syms.autoCloseableType,
1830                                        twrContext);
1831                     if (resource.hasTag(VARDEF)) {
1832                         attribStat(resource, tryEnv);
1833                         twrResult.check(resource, resource.type);
1834 
1835                         //check that resource type cannot throw InterruptedException
1836                         checkAutoCloseable(resource.pos(), localEnv, resource.type);
1837 
1838                         VarSymbol var = ((JCVariableDecl) resource).sym;
1839                         var.setData(ElementKind.RESOURCE_VARIABLE);
1840                     } else {
1841                         attribTree(resource, tryEnv, twrResult);
1842                     }
1843                 }
1844                 // Attribute body
1845                 attribStat(tree.body, tryEnv);
1846             } finally {
1847                 if (isTryWithResource)
1848                     tryEnv.info.scope.leave();
1849             }
1850 
1851             // Attribute catch clauses
1852             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1853                 JCCatch c = l.head;
1854                 Env&lt;AttrContext&gt; catchEnv =
1855                     localEnv.dup(c, localEnv.info.dup(localEnv.info.scope.dup()));
1856                 try {
1857                     Type ctype = attribStat(c.param, catchEnv);
1858                     if (TreeInfo.isMultiCatch(c)) {
1859                         //multi-catch parameter is implicitly marked as final
1860                         c.param.sym.flags_field |= FINAL | UNION;
1861                     }
1862                     if (c.param.sym.kind == VAR) {
1863                         c.param.sym.setData(ElementKind.EXCEPTION_PARAMETER);
1864                     }
1865                     chk.checkType(c.param.vartype.pos(),
1866                                   chk.checkClassType(c.param.vartype.pos(), ctype),
1867                                   syms.throwableType);
1868                     attribStat(c.body, catchEnv);
1869                 } finally {
1870                     catchEnv.info.scope.leave();
1871                 }
1872             }
1873 
1874             // Attribute finalizer
1875             if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);
1876             result = null;
1877         }
1878         finally {
1879             localEnv.info.scope.leave();
1880         }
1881     }
1882 
1883     void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {
1884         if (!resource.isErroneous() &amp;&amp;
1885             types.asSuper(resource, syms.autoCloseableType.tsym, true) != null &amp;&amp;
1886             !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself
1887             Symbol close = syms.noSymbol;
1888             Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
1889             try {
1890                 close = rs.resolveQualifiedMethod(pos,
1891                         env,
1892                         types.skipTypeVars(resource, false),
1893                         names.close,
1894                         List.nil(),
1895                         List.nil());
1896             }
1897             finally {
1898                 log.popDiagnosticHandler(discardHandler);
1899             }
1900             if (close.kind == MTH &amp;&amp;
1901                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1902                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1903                     env.info.lint.isEnabled(LintCategory.TRY)) {
1904                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1905             }
1906         }
1907     }
1908 
1909     public void visitConditional(JCConditional tree) {
1910         Type condtype = attribExpr(tree.cond, env, syms.booleanType);
1911         MatchBindings condBindings = matchBindings;
1912 
1913         tree.polyKind = (!allowPoly ||
1914                 pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly ||
1915                 isBooleanOrNumeric(env, tree)) ?
1916                 PolyKind.STANDALONE : PolyKind.POLY;
1917 
1918         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1919             //this means we are returning a poly conditional from void-compatible lambda expression
1920             resultInfo.checkContext.report(tree, diags.fragment(Fragments.ConditionalTargetCantBeVoid));
1921             result = tree.type = types.createErrorType(resultInfo.pt);
1922             return;
1923         }
1924 
1925         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1926                 unknownExprInfo :
1927                 resultInfo.dup(conditionalContext(resultInfo.checkContext));
1928 
1929 
1930         // x ? y : z
1931         // include x&#39;s bindings when true in y
1932         // include x&#39;s bindings when false in z
1933 
1934         Type truetype;
1935         Env&lt;AttrContext&gt; trueEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1936         try {
1937             truetype = attribTree(tree.truepart, trueEnv, condInfo);
1938         } finally {
1939             trueEnv.info.scope.leave();
1940         }
1941 
1942         MatchBindings trueBindings = matchBindings;
1943 
1944         Type falsetype;
1945         Env&lt;AttrContext&gt; falseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);
1946         try {
1947             falsetype = attribTree(tree.falsepart, falseEnv, condInfo);
1948         } finally {
1949             falseEnv.info.scope.leave();
1950         }
1951 
1952         MatchBindings falseBindings = matchBindings;
1953 
1954         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ?
1955                 condType(List.of(tree.truepart.pos(), tree.falsepart.pos()),
1956                          List.of(truetype, falsetype)) : pt();
1957         if (condtype.constValue() != null &amp;&amp;
1958                 truetype.constValue() != null &amp;&amp;
1959                 falsetype.constValue() != null &amp;&amp;
1960                 !owntype.hasTag(NONE)) {
1961             //constant folding
1962             owntype = cfolder.coerce(condtype.isTrue() ? truetype : falsetype, owntype);
1963         }
1964         result = check(tree, owntype, KindSelector.VAL, resultInfo);
1965         matchBindings = matchBindingsComputer.conditional(tree, condBindings, trueBindings, falseBindings);
1966     }
1967     //where
1968         private boolean isBooleanOrNumeric(Env&lt;AttrContext&gt; env, JCExpression tree) {
1969             switch (tree.getTag()) {
1970                 case LITERAL: return ((JCLiteral)tree).typetag.isSubRangeOf(DOUBLE) ||
1971                               ((JCLiteral)tree).typetag == BOOLEAN ||
1972                               ((JCLiteral)tree).typetag == BOT;
1973                 case LAMBDA: case REFERENCE: return false;
1974                 case PARENS: return isBooleanOrNumeric(env, ((JCParens)tree).expr);
1975                 case CONDEXPR:
1976                     JCConditional condTree = (JCConditional)tree;
1977                     return isBooleanOrNumeric(env, condTree.truepart) &amp;&amp;
1978                             isBooleanOrNumeric(env, condTree.falsepart);
1979                 case APPLY:
1980                     JCMethodInvocation speculativeMethodTree =
1981                             (JCMethodInvocation)deferredAttr.attribSpeculative(
1982                                     tree, env, unknownExprInfo,
1983                                     argumentAttr.withLocalCacheContext());
1984                     Symbol msym = TreeInfo.symbol(speculativeMethodTree.meth);
1985                     Type receiverType = speculativeMethodTree.meth.hasTag(IDENT) ?
1986                             env.enclClass.type :
1987                             ((JCFieldAccess)speculativeMethodTree.meth).selected.type;
1988                     Type owntype = types.memberType(receiverType, msym).getReturnType();
1989                     return primitiveOrBoxed(owntype);
1990                 case NEWCLASS:
1991                     JCExpression className =
1992                             removeClassParams.translate(((JCNewClass)tree).clazz);
1993                     JCExpression speculativeNewClassTree =
1994                             (JCExpression)deferredAttr.attribSpeculative(
1995                                     className, env, unknownTypeInfo,
1996                                     argumentAttr.withLocalCacheContext());
1997                     return primitiveOrBoxed(speculativeNewClassTree.type);
1998                 default:
1999                     Type speculativeType = deferredAttr.attribSpeculative(tree, env, unknownExprInfo,
2000                             argumentAttr.withLocalCacheContext()).type;
2001                     return primitiveOrBoxed(speculativeType);
2002             }
2003         }
2004         //where
2005             boolean primitiveOrBoxed(Type t) {
2006                 return (!t.hasTag(TYPEVAR) &amp;&amp; types.unboxedTypeOrType(t).isPrimitive());
2007             }
2008 
2009             TreeTranslator removeClassParams = new TreeTranslator() {
2010                 @Override
2011                 public void visitTypeApply(JCTypeApply tree) {
2012                     result = translate(tree.clazz);
2013                 }
2014             };
2015 
2016         CheckContext conditionalContext(CheckContext checkContext) {
2017             return new Check.NestedCheckContext(checkContext) {
2018                 //this will use enclosing check context to check compatibility of
2019                 //subexpression against target type; if we are in a method check context,
2020                 //depending on whether boxing is allowed, we could have incompatibilities
2021                 @Override
2022                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
2023                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInConditional(details)));
2024                 }
2025             };
2026         }
2027 
2028         /** Compute the type of a conditional expression, after
2029          *  checking that it exists.  See JLS 15.25. Does not take into
2030          *  account the special case where condition and both arms
2031          *  are constants.
2032          *
2033          *  @param pos      The source position to be used for error
2034          *                  diagnostics.
2035          *  @param thentype The type of the expression&#39;s then-part.
2036          *  @param elsetype The type of the expression&#39;s else-part.
2037          */
2038         Type condType(List&lt;DiagnosticPosition&gt; positions, List&lt;Type&gt; condTypes) {
2039             if (condTypes.isEmpty()) {
2040                 return syms.objectType; //TODO: how to handle?
2041             }
2042             Type first = condTypes.head;
2043             // If same type, that is the result
2044             if (condTypes.tail.stream().allMatch(t -&gt; types.isSameType(first, t)))
2045                 return first.baseType();
2046 
2047             List&lt;Type&gt; unboxedTypes = condTypes.stream()
2048                                                .map(t -&gt; t.isPrimitive() ? t : types.unboxedType(t))
2049                                                .collect(List.collector());
2050 
2051             // Otherwise, if both arms can be converted to a numeric
2052             // type, return the least numeric type that fits both arms
2053             // (i.e. return larger of the two, or return int if one
2054             // arm is short, the other is char).
2055             if (unboxedTypes.stream().allMatch(t -&gt; t.isPrimitive())) {
2056                 // If one arm has an integer subrange type (i.e., byte,
2057                 // short, or char), and the other is an integer constant
2058                 // that fits into the subrange, return the subrange type.
2059                 for (Type type : unboxedTypes) {
2060                     if (!type.getTag().isStrictSubRangeOf(INT)) {
2061                         continue;
2062                     }
2063                     if (unboxedTypes.stream().filter(t -&gt; t != type).allMatch(t -&gt; t.hasTag(INT) &amp;&amp; types.isAssignable(t, type)))
2064                         return type.baseType();
2065                 }
2066 
2067                 for (TypeTag tag : primitiveTags) {
2068                     Type candidate = syms.typeOfTag[tag.ordinal()];
2069                     if (unboxedTypes.stream().allMatch(t -&gt; types.isSubtype(t, candidate))) {
2070                         return candidate;
2071                     }
2072                 }
2073             }
2074 
<a name="1" id="anc1"></a><span class="line-modified">2075             // Those were all the cases that could result in a primitive. See if primitive boxing and inline</span>
<span class="line-added">2076             // narrowing conversions bring about a convergence.</span>
2077             condTypes = condTypes.stream()
<a name="2" id="anc2"></a><span class="line-modified">2078                                  .map(t -&gt; t.isPrimitive() ? types.boxedClass(t).type</span>
<span class="line-added">2079                                          : t.isReferenceProjection() ? t.valueProjection() : t)</span>
2080                                  .collect(List.collector());
2081 
2082             for (Type type : condTypes) {
2083                 if (condTypes.stream().filter(t -&gt; t != type).allMatch(t -&gt; types.isAssignable(t, type)))
2084                     return type.baseType();
2085             }
2086 
2087             Iterator&lt;DiagnosticPosition&gt; posIt = positions.iterator();
2088 
2089             condTypes = condTypes.stream()
<a name="3" id="anc3"></a><span class="line-modified">2090                                  .map(t -&gt; chk.checkNonVoid(posIt.next(), t.isValue() ? t.referenceProjection() : t))</span>
2091                                  .collect(List.collector());
2092 
<a name="4" id="anc4"></a><span class="line-modified">2093             // both are known to be reference types (or projections).  The result is</span>
2094             // lub(thentype,elsetype). This cannot fail, as it will
2095             // always be possible to infer &quot;Object&quot; if nothing better.
2096             return types.lub(condTypes.stream().map(t -&gt; t.baseType()).collect(List.collector()));
2097         }
2098 
2099     final static TypeTag[] primitiveTags = new TypeTag[]{
2100         BYTE,
2101         CHAR,
2102         SHORT,
2103         INT,
2104         LONG,
2105         FLOAT,
2106         DOUBLE,
2107         BOOLEAN,
2108     };
2109 
2110     Env&lt;AttrContext&gt; bindingEnv(Env&lt;AttrContext&gt; env, List&lt;BindingSymbol&gt; bindings) {
2111         Env&lt;AttrContext&gt; env1 = env.dup(env.tree, env.info.dup(env.info.scope.dup()));
2112         bindings.forEach(env1.info.scope::enter);
2113         return env1;
2114     }
2115 
2116     public void visitIf(JCIf tree) {
2117         attribExpr(tree.cond, env, syms.booleanType);
2118 
2119         // if (x) { y } [ else z ]
2120         // include x&#39;s bindings when true in y
2121         // include x&#39;s bindings when false in z
2122 
2123         MatchBindings condBindings = matchBindings;
2124         Env&lt;AttrContext&gt; thenEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
2125 
2126         try {
2127             attribStat(tree.thenpart, thenEnv);
2128         } finally {
2129             thenEnv.info.scope.leave();
2130         }
2131 
2132         preFlow(tree.thenpart);
2133         boolean aliveAfterThen = flow.aliveAfter(env, tree.thenpart, make);
2134         boolean aliveAfterElse;
2135 
2136         if (tree.elsepart != null) {
2137             Env&lt;AttrContext&gt; elseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);
2138             try {
2139                 attribStat(tree.elsepart, elseEnv);
2140             } finally {
2141                 elseEnv.info.scope.leave();
2142             }
2143             preFlow(tree.elsepart);
2144             aliveAfterElse = flow.aliveAfter(env, tree.elsepart, make);
2145         } else {
2146             aliveAfterElse = true;
2147         }
2148 
2149         chk.checkEmptyIf(tree);
2150 
2151         List&lt;BindingSymbol&gt; afterIfBindings = List.nil();
2152 
2153         if (aliveAfterThen &amp;&amp; !aliveAfterElse) {
2154             afterIfBindings = condBindings.bindingsWhenTrue;
2155         } else if (aliveAfterElse &amp;&amp; !aliveAfterThen) {
2156             afterIfBindings = condBindings.bindingsWhenFalse;
2157         }
2158 
2159         afterIfBindings.forEach(env.info.scope::enter);
2160         afterIfBindings.forEach(BindingSymbol::preserveBinding);
2161 
2162         result = null;
2163     }
2164 
2165         void preFlow(JCTree tree) {
2166             new PostAttrAnalyzer() {
2167                 @Override
2168                 public void scan(JCTree tree) {
2169                     if (tree == null ||
2170                             (tree.type != null &amp;&amp;
2171                             tree.type == Type.stuckType)) {
2172                         //don&#39;t touch stuck expressions!
2173                         return;
2174                     }
2175                     super.scan(tree);
2176                 }
2177             }.scan(tree);
2178         }
2179 
2180     public void visitExec(JCExpressionStatement tree) {
2181         //a fresh environment is required for 292 inference to work properly ---
2182         //see Infer.instantiatePolymorphicSignatureInstance()
2183         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2184         attribExpr(tree.expr, localEnv);
2185         result = null;
2186     }
2187 
2188     public void visitBreak(JCBreak tree) {
2189         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2190         result = null;
2191     }
2192 
2193     public void visitYield(JCYield tree) {
2194         if (env.info.yieldResult != null) {
2195             attribTree(tree.value, env, env.info.yieldResult);
2196             tree.target = findJumpTarget(tree.pos(), tree.getTag(), names.empty, env);
2197         } else {
2198             log.error(tree.pos(), tree.value.hasTag(PARENS)
2199                     ? Errors.NoSwitchExpressionQualify
2200                     : Errors.NoSwitchExpression);
2201             attribTree(tree.value, env, unknownExprInfo);
2202         }
2203         result = null;
2204     }
2205 
2206     public void visitContinue(JCContinue tree) {
2207         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2208         result = null;
2209     }
2210     //where
2211         /** Return the target of a break, continue or yield statement,
2212          *  if it exists, report an error if not.
2213          *  Note: The target of a labelled break or continue is the
2214          *  (non-labelled) statement tree referred to by the label,
2215          *  not the tree representing the labelled statement itself.
2216          *
2217          *  @param pos     The position to be used for error diagnostics
2218          *  @param tag     The tag of the jump statement. This is either
2219          *                 Tree.BREAK or Tree.CONTINUE.
2220          *  @param label   The label of the jump statement, or null if no
2221          *                 label is given.
2222          *  @param env     The environment current at the jump statement.
2223          */
2224         private JCTree findJumpTarget(DiagnosticPosition pos,
2225                                                    JCTree.Tag tag,
2226                                                    Name label,
2227                                                    Env&lt;AttrContext&gt; env) {
2228             Pair&lt;JCTree, Error&gt; jumpTarget = findJumpTargetNoError(tag, label, env);
2229 
2230             if (jumpTarget.snd != null) {
2231                 log.error(pos, jumpTarget.snd);
2232             }
2233 
2234             return jumpTarget.fst;
2235         }
2236         /** Return the target of a break or continue statement, if it exists,
2237          *  report an error if not.
2238          *  Note: The target of a labelled break or continue is the
2239          *  (non-labelled) statement tree referred to by the label,
2240          *  not the tree representing the labelled statement itself.
2241          *
2242          *  @param tag     The tag of the jump statement. This is either
2243          *                 Tree.BREAK or Tree.CONTINUE.
2244          *  @param label   The label of the jump statement, or null if no
2245          *                 label is given.
2246          *  @param env     The environment current at the jump statement.
2247          */
2248         private Pair&lt;JCTree, JCDiagnostic.Error&gt; findJumpTargetNoError(JCTree.Tag tag,
2249                                                                        Name label,
2250                                                                        Env&lt;AttrContext&gt; env) {
2251             // Search environments outwards from the point of jump.
2252             Env&lt;AttrContext&gt; env1 = env;
2253             JCDiagnostic.Error pendingError = null;
2254             LOOP:
2255             while (env1 != null) {
2256                 switch (env1.tree.getTag()) {
2257                     case LABELLED:
2258                         JCLabeledStatement labelled = (JCLabeledStatement)env1.tree;
2259                         if (label == labelled.label) {
2260                             // If jump is a continue, check that target is a loop.
2261                             if (tag == CONTINUE) {
2262                                 if (!labelled.body.hasTag(DOLOOP) &amp;&amp;
2263                                         !labelled.body.hasTag(WHILELOOP) &amp;&amp;
2264                                         !labelled.body.hasTag(FORLOOP) &amp;&amp;
2265                                         !labelled.body.hasTag(FOREACHLOOP)) {
2266                                     pendingError = Errors.NotLoopLabel(label);
2267                                 }
2268                                 // Found labelled statement target, now go inwards
2269                                 // to next non-labelled tree.
2270                                 return Pair.of(TreeInfo.referencedStatement(labelled), pendingError);
2271                             } else {
2272                                 return Pair.of(labelled, pendingError);
2273                             }
2274                         }
2275                         break;
2276                     case DOLOOP:
2277                     case WHILELOOP:
2278                     case FORLOOP:
2279                     case FOREACHLOOP:
2280                         if (label == null) return Pair.of(env1.tree, pendingError);
2281                         break;
2282                     case SWITCH:
2283                         if (label == null &amp;&amp; tag == BREAK) return Pair.of(env1.tree, null);
2284                         break;
2285                     case SWITCH_EXPRESSION:
2286                         if (tag == YIELD) {
2287                             return Pair.of(env1.tree, null);
2288                         } else if (tag == BREAK) {
2289                             pendingError = Errors.BreakOutsideSwitchExpression;
2290                         } else {
2291                             pendingError = Errors.ContinueOutsideSwitchExpression;
2292                         }
2293                         break;
2294                     case LAMBDA:
2295                     case METHODDEF:
2296                     case CLASSDEF:
2297                         break LOOP;
2298                     default:
2299                 }
2300                 env1 = env1.next;
2301             }
2302             if (label != null)
2303                 return Pair.of(null, Errors.UndefLabel(label));
2304             else if (pendingError != null)
2305                 return Pair.of(null, pendingError);
2306             else if (tag == CONTINUE)
2307                 return Pair.of(null, Errors.ContOutsideLoop);
2308             else
2309                 return Pair.of(null, Errors.BreakOutsideSwitchLoop);
2310         }
2311 
2312     public void visitReturn(JCReturn tree) {
2313         // Check that there is an enclosing method which is
2314         // nested within than the enclosing class.
2315         if (env.info.returnResult == null) {
2316             log.error(tree.pos(), Errors.RetOutsideMeth);
2317         } else if (env.info.yieldResult != null) {
2318             log.error(tree.pos(), Errors.ReturnOutsideSwitchExpression);
2319         } else if (!env.info.isLambda &amp;&amp;
2320                 !env.info.isNewClass &amp;&amp;
2321                 env.enclMethod != null &amp;&amp;
2322                 TreeInfo.isCompactConstructor(env.enclMethod)) {
2323             log.error(env.enclMethod,
2324                     Errors.InvalidCanonicalConstructorInRecord(Fragments.Compact, env.enclMethod.sym.name, Fragments.CanonicalCantHaveReturnStatement));
2325         } else {
2326             // Attribute return expression, if it exists, and check that
2327             // it conforms to result type of enclosing method.
2328             if (tree.expr != null) {
2329                 if (env.info.returnResult.pt.hasTag(VOID)) {
2330                     env.info.returnResult.checkContext.report(tree.expr.pos(),
2331                               diags.fragment(Fragments.UnexpectedRetVal));
2332                 }
2333                 attribTree(tree.expr, env, env.info.returnResult);
2334             } else if (!env.info.returnResult.pt.hasTag(VOID) &amp;&amp;
2335                     !env.info.returnResult.pt.hasTag(NONE)) {
2336                 env.info.returnResult.checkContext.report(tree.pos(),
2337                               diags.fragment(Fragments.MissingRetVal(env.info.returnResult.pt)));
2338             }
2339         }
2340         result = null;
2341     }
2342 
2343     public void visitThrow(JCThrow tree) {
2344         Type owntype = attribExpr(tree.expr, env, allowPoly ? Type.noType : syms.throwableType);
2345         if (allowPoly) {
2346             chk.checkType(tree, owntype, syms.throwableType);
2347         }
2348         result = null;
2349     }
2350 
2351     public void visitAssert(JCAssert tree) {
2352         attribExpr(tree.cond, env, syms.booleanType);
2353         if (tree.detail != null) {
2354             chk.checkNonVoid(tree.detail.pos(), attribExpr(tree.detail, env));
2355         }
2356         result = null;
2357     }
2358 
2359      /** Visitor method for method invocations.
2360      *  NOTE: The method part of an application will have in its type field
2361      *        the return type of the method, not the method&#39;s type itself!
2362      */
2363     public void visitApply(JCMethodInvocation tree) {
2364         // The local environment of a method application is
2365         // a new environment nested in the current one.
2366         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2367 
2368         // The types of the actual method arguments.
2369         List&lt;Type&gt; argtypes;
2370 
2371         // The types of the actual method type arguments.
2372         List&lt;Type&gt; typeargtypes = null;
2373 
2374         Name methName = TreeInfo.name(tree.meth);
2375 
2376         boolean isConstructorCall =
2377             methName == names._this || methName == names._super;
2378 
2379         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2380         if (isConstructorCall) {
2381             // We are seeing a ...this(...) or ...super(...) call.
2382             // Check that this is the first statement in a constructor.
2383             checkFirstConstructorStat(tree, env.enclMethod, true);
2384 
2385             // Record the fact
2386             // that this is a constructor call (using isSelfCall).
2387             localEnv.info.isSelfCall = true;
2388 
2389             // Attribute arguments, yielding list of argument types.
2390             KindSelector kind = attribArgs(KindSelector.MTH, tree.args, localEnv, argtypesBuf);
2391             argtypes = argtypesBuf.toList();
2392             typeargtypes = attribTypes(tree.typeargs, localEnv);
2393 
2394             // Variable `site&#39; points to the class in which the called
2395             // constructor is defined.
2396             Type site = env.enclClass.sym.type;
2397             if (methName == names._super) {
2398                 if (site == syms.objectType) {
2399                     log.error(tree.meth.pos(), Errors.NoSuperclass(site));
2400                     site = types.createErrorType(syms.objectType);
2401                 } else {
2402                     site = types.supertype(site);
2403                 }
2404             }
2405 
2406             if (site.hasTag(CLASS)) {
2407                 Type encl = site.getEnclosingType();
2408                 while (encl != null &amp;&amp; encl.hasTag(TYPEVAR))
2409                     encl = encl.getUpperBound();
2410                 if (encl.hasTag(CLASS)) {
2411                     // we are calling a nested class
2412 
2413                     if (tree.meth.hasTag(SELECT)) {
2414                         JCTree qualifier = ((JCFieldAccess) tree.meth).selected;
2415 
2416                         // We are seeing a prefixed call, of the form
2417                         //     &lt;expr&gt;.super(...).
2418                         // Check that the prefix expression conforms
2419                         // to the outer instance type of the class.
2420                         chk.checkRefType(qualifier.pos(),
2421                                          attribExpr(qualifier, localEnv,
2422                                                     encl));
2423                     } else if (methName == names._super) {
2424                         // qualifier omitted; check for existence
2425                         // of an appropriate implicit qualifier.
2426                         rs.resolveImplicitThis(tree.meth.pos(),
2427                                                localEnv, site, true);
2428                     }
2429                 } else if (tree.meth.hasTag(SELECT)) {
2430                     log.error(tree.meth.pos(),
2431                               Errors.IllegalQualNotIcls(site.tsym));
2432                 }
2433 
2434                 // if we&#39;re calling a java.lang.Enum constructor,
2435                 // prefix the implicit String and int parameters
2436                 if (site.tsym == syms.enumSym)
2437                     argtypes = argtypes.prepend(syms.intType).prepend(syms.stringType);
2438 
2439                 // Resolve the called constructor under the assumption
2440                 // that we are referring to a superclass instance of the
2441                 // current instance (JLS ???).
2442                 boolean selectSuperPrev = localEnv.info.selectSuper;
2443                 localEnv.info.selectSuper = true;
2444                 localEnv.info.pendingResolutionPhase = null;
2445                 Symbol sym = rs.resolveConstructor(
2446                     tree.meth.pos(), localEnv, site, argtypes, typeargtypes);
2447                 localEnv.info.selectSuper = selectSuperPrev;
2448 
2449                 // Set method symbol to resolved constructor...
2450                 TreeInfo.setSymbol(tree.meth, sym);
2451 
2452                 // ...and check that it is legal in the current context.
2453                 // (this will also set the tree&#39;s type)
2454                 Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2455                 checkId(tree.meth, site, sym, localEnv,
2456                         new ResultInfo(kind, mpt));
2457             }
2458             // Otherwise, `site&#39; is an error type and we do nothing
2459             result = tree.type = syms.voidType;
2460         } else {
2461             // Otherwise, we are seeing a regular method call.
2462             // Attribute the arguments, yielding list of argument types, ...
2463             KindSelector kind = attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2464             argtypes = argtypesBuf.toList();
2465             typeargtypes = attribAnyTypes(tree.typeargs, localEnv);
2466 
2467             // ... and attribute the method using as a prototype a methodtype
2468             // whose formal argument types is exactly the list of actual
2469             // arguments (this will also set the method symbol).
2470             Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2471             localEnv.info.pendingResolutionPhase = null;
2472             Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
2473 
2474             // Compute the result type.
2475             Type restype = mtype.getReturnType();
2476             if (restype.hasTag(WILDCARD))
2477                 throw new AssertionError(mtype);
2478 
2479             Type qualifier = (tree.meth.hasTag(SELECT))
2480                     ? ((JCFieldAccess) tree.meth).selected.type
2481                     : env.enclClass.sym.type;
2482             Symbol msym = TreeInfo.symbol(tree.meth);
2483             restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
2484 
2485             chk.checkRefTypes(tree.typeargs, typeargtypes);
2486 
2487             final Symbol symbol = TreeInfo.symbol(tree.meth);
2488             if (symbol != null) {
2489                 /* Is this an ill conceived attempt to invoke jlO methods not available on value types ??
2490                  */
2491                 boolean superCallOnValueReceiver = types.isValue(env.enclClass.sym.type)
2492                         &amp;&amp; (tree.meth.hasTag(SELECT))
2493                         &amp;&amp; ((JCFieldAccess)tree.meth).selected.hasTag(IDENT)
2494                         &amp;&amp; TreeInfo.name(((JCFieldAccess)tree.meth).selected) == names._super;
2495                 if (types.isValue(qualifier) || superCallOnValueReceiver) {
2496                     int argSize = argtypes.size();
2497                     Name name = symbol.name;
2498                     switch (name.toString()) {
2499                         case &quot;wait&quot;:
2500                             if (argSize == 0
2501                                     || (types.isConvertible(argtypes.head, syms.longType) &amp;&amp;
2502                                     (argSize == 1 || (argSize == 2 &amp;&amp; types.isConvertible(argtypes.tail.head, syms.intType))))) {
2503                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));
2504                             }
2505                             break;
2506                         case &quot;notify&quot;:
2507                         case &quot;notifyAll&quot;:
2508                         case &quot;clone&quot;:
2509                         case &quot;finalize&quot;:
2510                             if (argSize == 0)
2511                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));
2512                             break;
2513                         case &quot;hashCode&quot;:
2514                         case &quot;equals&quot;:
2515                         case &quot;toString&quot;:
2516                             if (superCallOnValueReceiver)
2517                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(names.fromString(&quot;invocation of super.&quot; + name)));
2518                             break;
2519                     }
2520                 }
2521             }
2522 
2523             // Check that value of resulting type is admissible in the
2524             // current context.  Also, capture the return type
2525             Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);
2526             result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
2527         }
2528         chk.validate(tree.typeargs, localEnv);
2529     }
2530     //where
2531         Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {
2532             if (msym != null &amp;&amp;
2533                     msym.owner == syms.objectType.tsym &amp;&amp;
2534                     methodName == names.getClass &amp;&amp;
2535                     argtypes.isEmpty()) {
2536                 // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;
2537                 // Temporary treatment for inline class: Given an inline class V that implements
2538                 // I1, I2, ... In, v.getClass() is typed to be Class&lt;? extends Object &amp; I1 &amp; I2 .. &amp; In&gt;
2539                 Type wcb;
2540                 if (qualifierType.isValue()) {
2541                     List&lt;Type&gt; bounds = List.of(syms.objectType).appendList(((ClassSymbol) qualifierType.tsym).getInterfaces());
2542                     wcb = bounds.size() &gt; 1 ? types.makeIntersectionType(bounds) : syms.objectType;
2543                 } else {
2544                     wcb = types.erasure(qualifierType);
2545                 }
2546                 return new ClassType(restype.getEnclosingType(),
2547                         List.of(new WildcardType(wcb,
2548                                 BoundKind.EXTENDS,
2549                                 syms.boundClass)),
2550                         restype.tsym,
2551                         restype.getMetadata());
2552             } else if (msym != null &amp;&amp;
2553                     msym.owner == syms.arrayClass &amp;&amp;
2554                     methodName == names.clone &amp;&amp;
2555                     types.isArray(qualifierType)) {
2556                 // as a special case, array.clone() has a result that is
2557                 // the same as static type of the array being cloned
2558                 return qualifierType;
2559             } else {
2560                 return restype;
2561             }
2562         }
2563 
2564         /** Check that given application node appears as first statement
2565          *  in a constructor call.
2566          *  @param tree          The application node
2567          *  @param enclMethod    The enclosing method of the application.
2568          *  @param error         Should an error be issued?
2569          */
2570         boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {
2571             if (enclMethod != null &amp;&amp; enclMethod.name == names.init) {
2572                 JCBlock body = enclMethod.body;
2573                 if (body.stats.head.hasTag(EXEC) &amp;&amp;
2574                     ((JCExpressionStatement) body.stats.head).expr == tree)
2575                     return true;
2576             }
2577             if (error) {
2578                 log.error(tree.pos(),
2579                         Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));
2580             }
2581             return false;
2582         }
2583 
2584         /** Obtain a method type with given argument types.
2585          */
2586         Type newMethodTemplate(Type restype, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2587             MethodType mt = new MethodType(argtypes, restype, List.nil(), syms.methodClass);
2588             return (typeargtypes == null) ? mt : (Type)new ForAll(typeargtypes, mt);
2589         }
2590 
2591     public void visitNewClass(final JCNewClass tree) {
2592         Type owntype = types.createErrorType(tree.type);
2593 
2594         // The local environment of a class creation is
2595         // a new environment nested in the current one.
2596         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2597 
2598         // The anonymous inner class definition of the new expression,
2599         // if one is defined by it.
2600         JCClassDecl cdef = tree.def;
2601 
2602         // If enclosing class is given, attribute it, and
2603         // complete class name to be fully qualified
2604         JCExpression clazz = tree.clazz; // Class field following new
2605         JCExpression clazzid;            // Identifier in class field
2606         JCAnnotatedType annoclazzid;     // Annotated type enclosing clazzid
2607         annoclazzid = null;
2608 
2609         if (clazz.hasTag(TYPEAPPLY)) {
2610             clazzid = ((JCTypeApply) clazz).clazz;
2611             if (clazzid.hasTag(ANNOTATED_TYPE)) {
2612                 annoclazzid = (JCAnnotatedType) clazzid;
2613                 clazzid = annoclazzid.underlyingType;
2614             }
2615         } else {
2616             if (clazz.hasTag(ANNOTATED_TYPE)) {
2617                 annoclazzid = (JCAnnotatedType) clazz;
2618                 clazzid = annoclazzid.underlyingType;
2619             } else {
2620                 clazzid = clazz;
2621             }
2622         }
2623 
2624         JCExpression clazzid1 = clazzid; // The same in fully qualified form
2625 
2626         if (tree.encl != null) {
2627             // We are seeing a qualified new, of the form
2628             //    &lt;expr&gt;.new C &lt;...&gt; (...) ...
2629             // In this case, we let clazz stand for the name of the
2630             // allocated class C prefixed with the type of the qualifier
2631             // expression, so that we can
2632             // resolve it with standard techniques later. I.e., if
2633             // &lt;expr&gt; has type T, then &lt;expr&gt;.new C &lt;...&gt; (...)
2634             // yields a clazz T.C.
2635             Type encltype = chk.checkRefType(tree.encl.pos(),
2636                                              attribExpr(tree.encl, env));
2637             // TODO 308: in &lt;expr&gt;.new C, do we also want to add the type annotations
2638             // from expr to the combined type, or not? Yes, do this.
2639             clazzid1 = make.at(clazz.pos).Select(make.Type(encltype),
2640                                                  ((JCIdent) clazzid).name);
2641 
2642             EndPosTable endPosTable = this.env.toplevel.endPositions;
2643             endPosTable.storeEnd(clazzid1, tree.getEndPosition(endPosTable));
2644             if (clazz.hasTag(ANNOTATED_TYPE)) {
2645                 JCAnnotatedType annoType = (JCAnnotatedType) clazz;
2646                 List&lt;JCAnnotation&gt; annos = annoType.annotations;
2647 
2648                 if (annoType.underlyingType.hasTag(TYPEAPPLY)) {
2649                     clazzid1 = make.at(tree.pos).
2650                         TypeApply(clazzid1,
2651                                   ((JCTypeApply) clazz).arguments);
2652                 }
2653 
2654                 clazzid1 = make.at(tree.pos).
2655                     AnnotatedType(annos, clazzid1);
2656             } else if (clazz.hasTag(TYPEAPPLY)) {
2657                 clazzid1 = make.at(tree.pos).
2658                     TypeApply(clazzid1,
2659                               ((JCTypeApply) clazz).arguments);
2660             }
2661 
2662             clazz = clazzid1;
2663         }
2664 
2665         // Attribute clazz expression and store
2666         // symbol + type back into the attributed tree.
2667         Type clazztype;
2668 
2669         try {
2670             env.info.isNewClass = true;
2671             clazztype = TreeInfo.isEnumInit(env.tree) ?
2672                 attribIdentAsEnumType(env, (JCIdent)clazz) :
2673                 attribType(clazz, env);
2674         } finally {
2675             env.info.isNewClass = false;
2676         }
2677 
2678         clazztype = chk.checkDiamond(tree, clazztype);
2679         chk.validate(clazz, localEnv);
2680         if (tree.encl != null) {
2681             // We have to work in this case to store
2682             // symbol + type back into the attributed tree.
2683             tree.clazz.type = clazztype;
2684             TreeInfo.setSymbol(clazzid, TreeInfo.symbol(clazzid1));
2685             clazzid.type = ((JCIdent) clazzid).sym.type;
2686             if (annoclazzid != null) {
2687                 annoclazzid.type = clazzid.type;
2688             }
2689             if (!clazztype.isErroneous()) {
2690                 if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2691                     log.error(tree.encl.pos(), Errors.AnonClassImplIntfNoQualForNew);
2692                 } else if (clazztype.tsym.isStatic()) {
2693                     log.error(tree.encl.pos(), Errors.QualifiedNewOfStaticClass(clazztype.tsym));
2694                 }
2695             }
2696         } else if (!clazztype.tsym.isInterface() &amp;&amp;
2697                    clazztype.getEnclosingType().hasTag(CLASS)) {
2698             // Check for the existence of an apropos outer instance
2699             rs.resolveImplicitThis(tree.pos(), env, clazztype);
2700         }
2701 
2702         // Attribute constructor arguments.
2703         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2704         final KindSelector pkind =
2705             attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2706         List&lt;Type&gt; argtypes = argtypesBuf.toList();
2707         List&lt;Type&gt; typeargtypes = attribTypes(tree.typeargs, localEnv);
2708 
2709         if (clazztype.hasTag(CLASS) || clazztype.hasTag(ERROR)) {
2710             // Enums may not be instantiated except implicitly
2711             if ((clazztype.tsym.flags_field &amp; Flags.ENUM) != 0 &amp;&amp;
2712                 (!env.tree.hasTag(VARDEF) ||
2713                  (((JCVariableDecl) env.tree).mods.flags &amp; Flags.ENUM) == 0 ||
2714                  ((JCVariableDecl) env.tree).init != tree))
2715                 log.error(tree.pos(), Errors.EnumCantBeInstantiated);
2716 
2717             boolean isSpeculativeDiamondInferenceRound = TreeInfo.isDiamond(tree) &amp;&amp;
2718                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
2719             boolean skipNonDiamondPath = false;
2720             // Check that it is an instantiation of a class and not a projection type
2721             if (clazz.hasTag(SELECT)) {
2722                 JCFieldAccess fieldAccess = (JCFieldAccess) clazz;
2723                 if (fieldAccess.selected.type.isValue() &amp;&amp;
2724                         (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {
2725                     log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);
2726                 }
2727             }
2728             // Check that class is not abstract
2729             if (cdef == null &amp;&amp; !isSpeculativeDiamondInferenceRound &amp;&amp; // class body may be nulled out in speculative tree copy
2730                 (clazztype.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
2731                 log.error(tree.pos(),
2732                           Errors.AbstractCantBeInstantiated(clazztype.tsym));
2733                 skipNonDiamondPath = true;
2734             } else if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2735                 // Check that no constructor arguments are given to
2736                 // anonymous classes implementing an interface
2737                 if (!argtypes.isEmpty())
2738                     log.error(tree.args.head.pos(), Errors.AnonClassImplIntfNoArgs);
2739 
2740                 if (!typeargtypes.isEmpty())
2741                     log.error(tree.typeargs.head.pos(), Errors.AnonClassImplIntfNoTypeargs);
2742 
2743                 // Error recovery: pretend no arguments were supplied.
2744                 argtypes = List.nil();
2745                 typeargtypes = List.nil();
2746                 skipNonDiamondPath = true;
2747             }
2748             if (TreeInfo.isDiamond(tree)) {
2749                 ClassType site = new ClassType(clazztype.getEnclosingType(),
2750                             clazztype.tsym.type.getTypeArguments(),
2751                                                clazztype.tsym,
2752                                                clazztype.getMetadata());
2753 
2754                 Env&lt;AttrContext&gt; diamondEnv = localEnv.dup(tree);
2755                 diamondEnv.info.selectSuper = cdef != null || tree.classDeclRemoved();
2756                 diamondEnv.info.pendingResolutionPhase = null;
2757 
2758                 //if the type of the instance creation expression is a class type
2759                 //apply method resolution inference (JLS 15.12.2.7). The return type
2760                 //of the resolved constructor will be a partially instantiated type
2761                 Symbol constructor = rs.resolveDiamond(tree.pos(),
2762                             diamondEnv,
2763                             site,
2764                             argtypes,
2765                             typeargtypes);
2766                 tree.constructor = constructor.baseSymbol();
2767 
2768                 final TypeSymbol csym = clazztype.tsym;
2769                 ResultInfo diamondResult = new ResultInfo(pkind, newMethodTemplate(resultInfo.pt, argtypes, typeargtypes),
2770                         diamondContext(tree, csym, resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
2771                 Type constructorType = tree.constructorType = types.createErrorType(clazztype);
2772                 constructorType = checkId(tree, site,
2773                         constructor,
2774                         diamondEnv,
2775                         diamondResult);
2776 
2777                 tree.clazz.type = types.createErrorType(clazztype);
2778                 if (!constructorType.isErroneous()) {
2779                     tree.clazz.type = clazz.type = constructorType.getReturnType();
2780                     tree.constructorType = types.createMethodTypeWithReturn(constructorType, syms.voidType);
2781                 }
2782                 clazztype = chk.checkClassType(tree.clazz, tree.clazz.type, true);
2783             }
2784 
2785             // Resolve the called constructor under the assumption
2786             // that we are referring to a superclass instance of the
2787             // current instance (JLS ???).
2788             else if (!skipNonDiamondPath) {
2789                 //the following code alters some of the fields in the current
2790                 //AttrContext - hence, the current context must be dup&#39;ed in
2791                 //order to avoid downstream failures
2792                 Env&lt;AttrContext&gt; rsEnv = localEnv.dup(tree);
2793                 rsEnv.info.selectSuper = cdef != null;
2794                 rsEnv.info.pendingResolutionPhase = null;
2795                 tree.constructor = rs.resolveConstructor(
2796                     tree.pos(), rsEnv, clazztype, argtypes, typeargtypes);
2797                 if (cdef == null) { //do not check twice!
2798                     tree.constructorType = checkId(tree,
2799                             clazztype,
2800                             tree.constructor,
2801                             rsEnv,
2802                             new ResultInfo(pkind, newMethodTemplate(syms.voidType, argtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));
2803                     if (rsEnv.info.lastResolveVarargs())
2804                         Assert.check(tree.constructorType.isErroneous() || tree.varargsElement != null);
2805                 }
2806             }
2807 
2808             if (cdef != null) {
2809                 visitAnonymousClassDefinition(tree, clazz, clazztype, cdef, localEnv, argtypes, typeargtypes, pkind);
2810                 return;
2811             }
2812 
2813             if (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH)
2814                 owntype = clazztype;
2815         }
2816         result = check(tree, owntype, KindSelector.VAL, resultInfo);
2817         InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
2818         if (tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType)) {
2819             //we need to wait for inference to finish and then replace inference vars in the constructor type
2820             inferenceContext.addFreeTypeListener(List.of(tree.constructorType),
2821                     instantiatedContext -&gt; {
2822                         tree.constructorType = instantiatedContext.asInstType(tree.constructorType);
2823                     });
2824         }
2825         chk.validate(tree.typeargs, localEnv);
2826     }
2827 
2828         // where
2829         private void visitAnonymousClassDefinition(JCNewClass tree, JCExpression clazz, Type clazztype,
2830                                                    JCClassDecl cdef, Env&lt;AttrContext&gt; localEnv,
2831                                                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
2832                                                    KindSelector pkind) {
2833             // We are seeing an anonymous class instance creation.
2834             // In this case, the class instance creation
2835             // expression
2836             //
2837             //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
2838             //
2839             // is represented internally as
2840             //
2841             //    E . new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) ( class &lt;empty-name&gt; { ... } )  .
2842             //
2843             // This expression is then *transformed* as follows:
2844             //
2845             // (1) add an extends or implements clause
2846             // (2) add a constructor.
2847             //
2848             // For instance, if C is a class, and ET is the type of E,
2849             // the expression
2850             //
2851             //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
2852             //
2853             // is translated to (where X is a fresh name and typarams is the
2854             // parameter list of the super constructor):
2855             //
2856             //   new &lt;typeargs1&gt;X(&lt;*nullchk*&gt;E, args) where
2857             //     X extends C&lt;typargs2&gt; {
2858             //       &lt;typarams&gt; X(ET e, args) {
2859             //         e.&lt;typeargs1&gt;super(args)
2860             //       }
2861             //       ...
2862             //     }
2863             InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
2864             final boolean isDiamond = TreeInfo.isDiamond(tree);
2865             if (isDiamond
2866                     &amp;&amp; ((tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType))
2867                     || (tree.clazz.type != null &amp;&amp; inferenceContext.free(tree.clazz.type)))) {
2868                 final ResultInfo resultInfoForClassDefinition = this.resultInfo;
2869                 inferenceContext.addFreeTypeListener(List.of(tree.constructorType, tree.clazz.type),
2870                         instantiatedContext -&gt; {
2871                             tree.constructorType = instantiatedContext.asInstType(tree.constructorType);
2872                             tree.clazz.type = clazz.type = instantiatedContext.asInstType(clazz.type);
2873                             ResultInfo prevResult = this.resultInfo;
2874                             try {
2875                                 this.resultInfo = resultInfoForClassDefinition;
2876                                 visitAnonymousClassDefinition(tree, clazz, clazz.type, cdef,
2877                                                             localEnv, argtypes, typeargtypes, pkind);
2878                             } finally {
2879                                 this.resultInfo = prevResult;
2880                             }
2881                         });
2882             } else {
2883                 if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
2884                     List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
2885                     if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {
2886                         // One or more types inferred in the previous steps is non-denotable.
2887                         Fragment fragment = Diamond(clazztype.tsym);
2888                         log.error(tree.clazz.pos(),
2889                                 Errors.CantApplyDiamond1(
2890                                         fragment,
2891                                         invalidDiamondArgs.size() &gt; 1 ?
2892                                                 DiamondInvalidArgs(invalidDiamondArgs, fragment) :
2893                                                 DiamondInvalidArg(invalidDiamondArgs, fragment)));
2894                     }
2895                     // For &lt;&gt;(){}, inferred types must also be accessible.
2896                     for (Type t : clazztype.getTypeArguments()) {
2897                         rs.checkAccessibleType(env, t);
2898                     }
2899                     chk.checkParameterizationWithValues(tree, clazztype);
2900                 }
2901 
2902                 // If we already errored, be careful to avoid a further avalanche. ErrorType answers
2903                 // false for isInterface call even when the original type is an interface.
2904                 boolean implementing = clazztype.tsym.isInterface() ||
2905                         clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
2906                         clazztype.getOriginalType().tsym.isInterface();
2907 
2908                 if (implementing) {
2909                     cdef.implementing = List.of(clazz);
2910                 } else {
2911                     cdef.extending = clazz;
2912                 }
2913 
2914                 if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
2915                     isSerializable(clazztype)) {
2916                     localEnv.info.isSerializable = true;
2917                 }
2918 
2919                 attribStat(cdef, localEnv);
2920 
2921                 List&lt;Type&gt; finalargtypes;
2922                 // If an outer instance is given,
2923                 // prefix it to the constructor arguments
2924                 // and delete it from the new expression
2925                 if (tree.encl != null &amp;&amp; !clazztype.tsym.isInterface()) {
2926                     finalargtypes = argtypes.prepend(tree.encl.type);
2927                 } else {
2928                     finalargtypes = argtypes;
2929                 }
2930 
2931                 // Reassign clazztype and recompute constructor. As this necessarily involves
2932                 // another attribution pass for deferred types in the case of &lt;&gt;, replicate
2933                 // them. Original arguments have right decorations already.
2934                 if (isDiamond &amp;&amp; pkind.contains(KindSelector.POLY)) {
2935                     finalargtypes = finalargtypes.map(deferredAttr.deferredCopier);
2936                 }
2937 
2938                 clazztype = clazztype.hasTag(ERROR) ? types.createErrorType(cdef.sym.type)
2939                                                     : cdef.sym.type;
2940                 Symbol sym = tree.constructor = rs.resolveConstructor(
2941                         tree.pos(), localEnv, clazztype, finalargtypes, typeargtypes);
2942                 Assert.check(!sym.kind.isResolutionError());
2943                 tree.constructor = sym;
2944                 tree.constructorType = checkId(tree,
2945                         clazztype,
2946                         tree.constructor,
2947                         localEnv,
2948                         new ResultInfo(pkind, newMethodTemplate(syms.voidType, finalargtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));
2949             }
2950             Type owntype = (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH) ?
2951                                 clazztype : types.createErrorType(tree.type);
2952             result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));
2953             chk.validate(tree.typeargs, localEnv);
2954         }
2955 
2956         CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {
2957             return new Check.NestedCheckContext(checkContext) {
2958                 @Override
2959                 public void report(DiagnosticPosition _unused, JCDiagnostic details) {
2960                     enclosingContext.report(clazz.clazz,
2961                             diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
2962                 }
2963             };
2964         }
2965 
2966     /** Make an attributed null check tree.
2967      */
2968     public JCExpression makeNullCheck(JCExpression arg) {
2969         // optimization: new Outer() can never be null; skip null check
2970         if (arg.getTag() == NEWCLASS)
2971             return arg;
2972         // Likewise arg can&#39;t be null if it is a value.
2973         if (types.isValue(arg.type))
2974             return arg;
2975         // optimization: X.this is never null; skip null check
2976         Name name = TreeInfo.name(arg);
2977         if (name == names._this || name == names._super) return arg;
2978 
2979         JCTree.Tag optag = NULLCHK;
2980         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
2981         tree.operator = operators.resolveUnary(arg, optag, arg.type);
2982         tree.type = arg.type;
2983         return tree;
2984     }
2985 
2986     public void visitNewArray(JCNewArray tree) {
2987         Type owntype = types.createErrorType(tree.type);
2988         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2989         Type elemtype;
2990         if (tree.elemtype != null) {
2991             elemtype = attribType(tree.elemtype, localEnv);
2992             chk.validate(tree.elemtype, localEnv);
2993             owntype = elemtype;
2994             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
2995                 attribExpr(l.head, localEnv, syms.intType);
2996                 owntype = new ArrayType(owntype, syms.arrayClass);
2997             }
2998         } else {
2999             // we are seeing an untyped aggregate { ... }
3000             // this is allowed only if the prototype is an array
3001             if (pt().hasTag(ARRAY)) {
3002                 elemtype = types.elemtype(pt());
3003             } else {
3004                 if (!pt().hasTag(ERROR) &amp;&amp;
3005                         (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3006                     log.error(tree.pos(),
3007                               Errors.IllegalInitializerForType(pt()));
3008                 }
3009                 elemtype = types.createErrorType(pt());
3010             }
3011         }
3012         if (tree.elems != null) {
3013             attribExprs(tree.elems, localEnv, elemtype);
3014             owntype = new ArrayType(elemtype, syms.arrayClass);
3015         }
3016         if (!types.isReifiable(elemtype))
3017             log.error(tree.pos(), Errors.GenericArrayCreation);
3018         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3019     }
3020 
3021     /*
3022      * A lambda expression can only be attributed when a target-type is available.
3023      * In addition, if the target-type is that of a functional interface whose
3024      * descriptor contains inference variables in argument position the lambda expression
3025      * is &#39;stuck&#39; (see DeferredAttr).
3026      */
3027     @Override
3028     public void visitLambda(final JCLambda that) {
3029         boolean wrongContext = false;
3030         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
3031             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3032                 //lambda only allowed in assignment or method invocation/cast context
3033                 log.error(that.pos(), Errors.UnexpectedLambda);
3034             }
3035             resultInfo = recoveryInfo;
3036             wrongContext = true;
3037         }
3038         //create an environment for attribution of the lambda expression
3039         final Env&lt;AttrContext&gt; localEnv = lambdaEnv(that, env);
3040         boolean needsRecovery =
3041                 resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK;
3042         try {
3043             if (needsRecovery &amp;&amp; isSerializable(pt())) {
3044                 localEnv.info.isSerializable = true;
3045                 localEnv.info.isSerializableLambda = true;
3046             }
3047             localEnv.info.isLambda = true;
3048             List&lt;Type&gt; explicitParamTypes = null;
3049             if (that.paramKind == JCLambda.ParameterKind.EXPLICIT) {
3050                 //attribute lambda parameters
3051                 attribStats(that.params, localEnv);
3052                 explicitParamTypes = TreeInfo.types(that.params);
3053             }
3054 
3055             TargetInfo targetInfo = getTargetInfo(that, resultInfo, explicitParamTypes);
3056             Type currentTarget = targetInfo.target;
3057             Type lambdaType = targetInfo.descriptor;
3058 
3059             if (currentTarget.isErroneous()) {
3060                 result = that.type = currentTarget;
3061                 return;
3062             }
3063 
3064             setFunctionalInfo(localEnv, that, pt(), lambdaType, currentTarget, resultInfo.checkContext);
3065 
3066             if (lambdaType.hasTag(FORALL)) {
3067                 //lambda expression target desc cannot be a generic method
3068                 Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
3069                                                                     kindName(currentTarget.tsym),
3070                                                                     currentTarget.tsym);
3071                 resultInfo.checkContext.report(that, diags.fragment(msg));
3072                 result = that.type = types.createErrorType(pt());
3073                 return;
3074             }
3075 
3076             if (that.paramKind == JCLambda.ParameterKind.IMPLICIT) {
3077                 //add param type info in the AST
3078                 List&lt;Type&gt; actuals = lambdaType.getParameterTypes();
3079                 List&lt;JCVariableDecl&gt; params = that.params;
3080 
3081                 boolean arityMismatch = false;
3082 
3083                 while (params.nonEmpty()) {
3084                     if (actuals.isEmpty()) {
3085                         //not enough actuals to perform lambda parameter inference
3086                         arityMismatch = true;
3087                     }
3088                     //reset previously set info
3089                     Type argType = arityMismatch ?
3090                             syms.errType :
3091                             actuals.head;
3092                     if (params.head.isImplicitlyTyped()) {
3093                         setSyntheticVariableType(params.head, argType);
3094                     }
3095                     params.head.sym = null;
3096                     actuals = actuals.isEmpty() ?
3097                             actuals :
3098                             actuals.tail;
3099                     params = params.tail;
3100                 }
3101 
3102                 //attribute lambda parameters
3103                 attribStats(that.params, localEnv);
3104 
3105                 if (arityMismatch) {
3106                     resultInfo.checkContext.report(that, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
3107                         result = that.type = types.createErrorType(currentTarget);
3108                         return;
3109                 }
3110             }
3111 
3112             //from this point on, no recovery is needed; if we are in assignment context
3113             //we will be able to attribute the whole lambda body, regardless of errors;
3114             //if we are in a &#39;check&#39; method context, and the lambda is not compatible
3115             //with the target-type, it will be recovered anyway in Attr.checkId
3116             needsRecovery = false;
3117 
3118             ResultInfo bodyResultInfo = localEnv.info.returnResult =
3119                     lambdaBodyResult(that, lambdaType, resultInfo);
3120 
3121             if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
3122                 attribTree(that.getBody(), localEnv, bodyResultInfo);
3123             } else {
3124                 JCBlock body = (JCBlock)that.body;
3125                 if (body == breakTree &amp;&amp;
3126                         resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3127                     breakTreeFound(copyEnv(localEnv));
3128                 }
3129                 attribStats(body.stats, localEnv);
3130             }
3131 
3132             result = check(that, currentTarget, KindSelector.VAL, resultInfo);
3133 
3134             boolean isSpeculativeRound =
3135                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
3136 
3137             preFlow(that);
3138             flow.analyzeLambda(env, that, make, isSpeculativeRound);
3139 
3140             that.type = currentTarget; //avoids recovery at this stage
3141             checkLambdaCompatible(that, lambdaType, resultInfo.checkContext);
3142 
3143             if (!isSpeculativeRound) {
3144                 //add thrown types as bounds to the thrown types free variables if needed:
3145                 if (resultInfo.checkContext.inferenceContext().free(lambdaType.getThrownTypes())) {
3146                     List&lt;Type&gt; inferredThrownTypes = flow.analyzeLambdaThrownTypes(env, that, make);
3147                     if(!checkExConstraints(inferredThrownTypes, lambdaType.getThrownTypes(), resultInfo.checkContext.inferenceContext())) {
3148                         log.error(that, Errors.IncompatibleThrownTypesInMref(lambdaType.getThrownTypes()));
3149                     }
3150                 }
3151 
3152                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), lambdaType, currentTarget);
3153             }
3154             result = wrongContext ? that.type = types.createErrorType(pt())
3155                                   : check(that, currentTarget, KindSelector.VAL, resultInfo);
3156         } catch (Types.FunctionDescriptorLookupError ex) {
3157             JCDiagnostic cause = ex.getDiagnostic();
3158             resultInfo.checkContext.report(that, cause);
3159             result = that.type = types.createErrorType(pt());
3160             return;
3161         } catch (CompletionFailure cf) {
3162             chk.completionError(that.pos(), cf);
3163         } catch (Throwable t) {
3164             //when an unexpected exception happens, avoid attempts to attribute the same tree again
3165             //as that would likely cause the same exception again.
3166             needsRecovery = false;
3167             throw t;
3168         } finally {
3169             localEnv.info.scope.leave();
3170             if (needsRecovery) {
3171                 Type prevResult = result;
3172                 try {
3173                     attribTree(that, env, recoveryInfo);
3174                 } finally {
3175                     if (result == Type.recoveryType) {
3176                         result = prevResult;
3177                     }
3178                 }
3179             }
3180         }
3181     }
3182     //where
3183         class TargetInfo {
3184             Type target;
3185             Type descriptor;
3186 
3187             public TargetInfo(Type target, Type descriptor) {
3188                 this.target = target;
3189                 this.descriptor = descriptor;
3190             }
3191         }
3192 
3193         TargetInfo getTargetInfo(JCPolyExpression that, ResultInfo resultInfo, List&lt;Type&gt; explicitParamTypes) {
3194             Type lambdaType;
3195             Type currentTarget = resultInfo.pt;
3196             if (resultInfo.pt != Type.recoveryType) {
3197                 /* We need to adjust the target. If the target is an
3198                  * intersection type, for example: SAM &amp; I1 &amp; I2 ...
3199                  * the target will be updated to SAM
3200                  */
3201                 currentTarget = targetChecker.visit(currentTarget, that);
3202                 if (!currentTarget.isIntersection()) {
3203                     if (explicitParamTypes != null) {
3204                         currentTarget = infer.instantiateFunctionalInterface(that,
3205                                 currentTarget, explicitParamTypes, resultInfo.checkContext);
3206                     }
3207                     currentTarget = types.removeWildcards(currentTarget);
3208                     lambdaType = types.findDescriptorType(currentTarget);
3209                 } else {
3210                     IntersectionClassType ict = (IntersectionClassType)currentTarget;
3211                     ListBuffer&lt;Type&gt; components = new ListBuffer&lt;&gt;();
3212                     for (Type bound : ict.getExplicitComponents()) {
3213                         if (explicitParamTypes != null) {
3214                             try {
3215                                 bound = infer.instantiateFunctionalInterface(that,
3216                                         bound, explicitParamTypes, resultInfo.checkContext);
3217                             } catch (FunctionDescriptorLookupError t) {
3218                                 // do nothing
3219                             }
3220                         }
3221                         bound = types.removeWildcards(bound);
3222                         components.add(bound);
3223                     }
3224                     currentTarget = types.makeIntersectionType(components.toList());
3225                     currentTarget.tsym.flags_field |= INTERFACE;
3226                     lambdaType = types.findDescriptorType(currentTarget);
3227                 }
3228 
3229             } else {
3230                 currentTarget = Type.recoveryType;
3231                 lambdaType = fallbackDescriptorType(that);
3232             }
3233             if (that.hasTag(LAMBDA) &amp;&amp; lambdaType.hasTag(FORALL)) {
3234                 //lambda expression target desc cannot be a generic method
3235                 Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
3236                                                                     kindName(currentTarget.tsym),
3237                                                                     currentTarget.tsym);
3238                 resultInfo.checkContext.report(that, diags.fragment(msg));
3239                 currentTarget = types.createErrorType(pt());
3240             }
3241             return new TargetInfo(currentTarget, lambdaType);
3242         }
3243 
3244         void preFlow(JCLambda tree) {
3245             new PostAttrAnalyzer() {
3246                 @Override
3247                 public void scan(JCTree tree) {
3248                     if (tree == null ||
3249                             (tree.type != null &amp;&amp;
3250                             tree.type == Type.stuckType)) {
3251                         //don&#39;t touch stuck expressions!
3252                         return;
3253                     }
3254                     super.scan(tree);
3255                 }
3256 
3257                 @Override
3258                 public void visitClassDef(JCClassDecl that) {
3259                     // or class declaration trees!
3260                 }
3261 
3262                 public void visitLambda(JCLambda that) {
3263                     // or lambda expressions!
3264                 }
3265             }.scan(tree.body);
3266         }
3267 
3268         Types.MapVisitor&lt;DiagnosticPosition&gt; targetChecker = new Types.MapVisitor&lt;DiagnosticPosition&gt;() {
3269 
3270             @Override
3271             public Type visitClassType(ClassType t, DiagnosticPosition pos) {
3272                 return t.isIntersection() ?
3273                         visitIntersectionClassType((IntersectionClassType)t, pos) : t;
3274             }
3275 
3276             public Type visitIntersectionClassType(IntersectionClassType ict, DiagnosticPosition pos) {
3277                 types.findDescriptorSymbol(makeNotionalInterface(ict, pos));
3278                 return ict;
3279             }
3280 
3281             private TypeSymbol makeNotionalInterface(IntersectionClassType ict, DiagnosticPosition pos) {
3282                 ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
3283                 ListBuffer&lt;Type&gt; supertypes = new ListBuffer&lt;&gt;();
3284                 for (Type i : ict.interfaces_field) {
3285                     if (i.isParameterized()) {
3286                         targs.appendList(i.tsym.type.allparams());
3287                     }
3288                     supertypes.append(i.tsym.type);
3289                 }
3290                 IntersectionClassType notionalIntf = types.makeIntersectionType(supertypes.toList());
3291                 notionalIntf.allparams_field = targs.toList();
3292                 notionalIntf.tsym.flags_field |= INTERFACE;
3293                 return notionalIntf.tsym;
3294             }
3295         };
3296 
3297         private Type fallbackDescriptorType(JCExpression tree) {
3298             switch (tree.getTag()) {
3299                 case LAMBDA:
3300                     JCLambda lambda = (JCLambda)tree;
3301                     List&lt;Type&gt; argtypes = List.nil();
3302                     for (JCVariableDecl param : lambda.params) {
3303                         argtypes = param.vartype != null &amp;&amp; param.vartype.type != null ?
3304                                 argtypes.append(param.vartype.type) :
3305                                 argtypes.append(syms.errType);
3306                     }
3307                     return new MethodType(argtypes, Type.recoveryType,
3308                             List.of(syms.throwableType), syms.methodClass);
3309                 case REFERENCE:
3310                     return new MethodType(List.nil(), Type.recoveryType,
3311                             List.of(syms.throwableType), syms.methodClass);
3312                 default:
3313                     Assert.error(&quot;Cannot get here!&quot;);
3314             }
3315             return null;
3316         }
3317 
3318         private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
3319                 final InferenceContext inferenceContext, final Type... ts) {
3320             checkAccessibleTypes(pos, env, inferenceContext, List.from(ts));
3321         }
3322 
3323         private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
3324                 final InferenceContext inferenceContext, final List&lt;Type&gt; ts) {
3325             if (inferenceContext.free(ts)) {
3326                 inferenceContext.addFreeTypeListener(ts,
3327                         solvedContext -&gt; checkAccessibleTypes(pos, env, solvedContext, solvedContext.asInstTypes(ts)));
3328             } else {
3329                 for (Type t : ts) {
3330                     rs.checkAccessibleType(env, t);
3331                 }
3332             }
3333         }
3334 
3335         /**
3336          * Lambda/method reference have a special check context that ensures
3337          * that i.e. a lambda return type is compatible with the expected
3338          * type according to both the inherited context and the assignment
3339          * context.
3340          */
3341         class FunctionalReturnContext extends Check.NestedCheckContext {
3342 
3343             FunctionalReturnContext(CheckContext enclosingContext) {
3344                 super(enclosingContext);
3345             }
3346 
3347             @Override
3348             public boolean compatible(Type found, Type req, Warner warn) {
3349                 //return type must be compatible in both current context and assignment context
3350                 return chk.basicHandler.compatible(inferenceContext().asUndetVar(found), inferenceContext().asUndetVar(req), warn);
3351             }
3352 
3353             @Override
3354             public void report(DiagnosticPosition pos, JCDiagnostic details) {
3355                 enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleRetTypeInLambda(details)));
3356             }
3357         }
3358 
3359         class ExpressionLambdaReturnContext extends FunctionalReturnContext {
3360 
3361             JCExpression expr;
3362             boolean expStmtExpected;
3363 
3364             ExpressionLambdaReturnContext(JCExpression expr, CheckContext enclosingContext) {
3365                 super(enclosingContext);
3366                 this.expr = expr;
3367             }
3368 
3369             @Override
3370             public void report(DiagnosticPosition pos, JCDiagnostic details) {
3371                 if (expStmtExpected) {
3372                     enclosingContext.report(pos, diags.fragment(Fragments.StatExprExpected));
3373                 } else {
3374                     super.report(pos, details);
3375                 }
3376             }
3377 
3378             @Override
3379             public boolean compatible(Type found, Type req, Warner warn) {
3380                 //a void return is compatible with an expression statement lambda
3381                 if (req.hasTag(VOID)) {
3382                     expStmtExpected = true;
3383                     return TreeInfo.isExpressionStatement(expr);
3384                 } else {
3385                     return super.compatible(found, req, warn);
3386                 }
3387             }
3388         }
3389 
3390         ResultInfo lambdaBodyResult(JCLambda that, Type descriptor, ResultInfo resultInfo) {
3391             FunctionalReturnContext funcContext = that.getBodyKind() == JCLambda.BodyKind.EXPRESSION ?
3392                     new ExpressionLambdaReturnContext((JCExpression)that.getBody(), resultInfo.checkContext) :
3393                     new FunctionalReturnContext(resultInfo.checkContext);
3394 
3395             return descriptor.getReturnType() == Type.recoveryType ?
3396                     recoveryInfo :
3397                     new ResultInfo(KindSelector.VAL,
3398                             descriptor.getReturnType(), funcContext);
3399         }
3400 
3401         /**
3402         * Lambda compatibility. Check that given return types, thrown types, parameter types
3403         * are compatible with the expected functional interface descriptor. This means that:
3404         * (i) parameter types must be identical to those of the target descriptor; (ii) return
3405         * types must be compatible with the return type of the expected descriptor.
3406         */
3407         void checkLambdaCompatible(JCLambda tree, Type descriptor, CheckContext checkContext) {
3408             Type returnType = checkContext.inferenceContext().asUndetVar(descriptor.getReturnType());
3409 
3410             //return values have already been checked - but if lambda has no return
3411             //values, we must ensure that void/value compatibility is correct;
3412             //this amounts at checking that, if a lambda body can complete normally,
3413             //the descriptor&#39;s return type must be void
3414             if (tree.getBodyKind() == JCLambda.BodyKind.STATEMENT &amp;&amp; tree.canCompleteNormally &amp;&amp;
3415                     !returnType.hasTag(VOID) &amp;&amp; returnType != Type.recoveryType) {
3416                 Fragment msg =
3417                         Fragments.IncompatibleRetTypeInLambda(Fragments.MissingRetVal(returnType));
3418                 checkContext.report(tree,
3419                                     diags.fragment(msg));
3420             }
3421 
3422             List&lt;Type&gt; argTypes = checkContext.inferenceContext().asUndetVars(descriptor.getParameterTypes());
3423             if (!types.isSameTypes(argTypes, TreeInfo.types(tree.params))) {
3424                 checkContext.report(tree, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
3425             }
3426         }
3427 
3428         /* Map to hold &#39;fake&#39; clinit methods. If a lambda is used to initialize a
3429          * static field and that lambda has type annotations, these annotations will
3430          * also be stored at these fake clinit methods.
3431          *
3432          * LambdaToMethod also use fake clinit methods so they can be reused.
3433          * Also as LTM is a phase subsequent to attribution, the methods from
3434          * clinits can be safely removed by LTM to save memory.
3435          */
3436         private Map&lt;ClassSymbol, MethodSymbol&gt; clinits = new HashMap&lt;&gt;();
3437 
3438         public MethodSymbol removeClinit(ClassSymbol sym) {
3439             return clinits.remove(sym);
3440         }
3441 
3442         /* This method returns an environment to be used to attribute a lambda
3443          * expression.
3444          *
3445          * The owner of this environment is a method symbol. If the current owner
3446          * is not a method, for example if the lambda is used to initialize
3447          * a field, then if the field is:
3448          *
3449          * - an instance field, we use the first constructor.
3450          * - a static field, we create a fake clinit method.
3451          */
3452         public Env&lt;AttrContext&gt; lambdaEnv(JCLambda that, Env&lt;AttrContext&gt; env) {
3453             Env&lt;AttrContext&gt; lambdaEnv;
3454             Symbol owner = env.info.scope.owner;
3455             if (owner.kind == VAR &amp;&amp; owner.owner.kind == TYP) {
3456                 //field initializer
3457                 ClassSymbol enclClass = owner.enclClass();
3458                 Symbol newScopeOwner = env.info.scope.owner;
3459                 /* if the field isn&#39;t static, then we can get the first constructor
3460                  * and use it as the owner of the environment. This is what
3461                  * LTM code is doing to look for type annotations so we are fine.
3462                  */
3463                 if ((owner.flags() &amp; STATIC) == 0) {
3464                     for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {
3465                         newScopeOwner = s;
3466                         break;
3467                     }
3468                 } else {
3469                     /* if the field is static then we need to create a fake clinit
3470                      * method, this method can later be reused by LTM.
3471                      */
3472                     MethodSymbol clinit = clinits.get(enclClass);
3473                     if (clinit == null) {
3474                         Type clinitType = new MethodType(List.nil(),
3475                                 syms.voidType, List.nil(), syms.methodClass);
3476                         clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,
3477                                 names.clinit, clinitType, enclClass);
3478                         clinit.params = List.nil();
3479                         clinits.put(enclClass, clinit);
3480                     }
3481                     newScopeOwner = clinit;
3482                 }
3483                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));
3484             } else {
3485                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dup()));
3486             }
3487             lambdaEnv.info.yieldResult = null;
3488             return lambdaEnv;
3489         }
3490 
3491     @Override
3492     public void visitReference(final JCMemberReference that) {
3493         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
3494             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3495                 //method reference only allowed in assignment or method invocation/cast context
3496                 log.error(that.pos(), Errors.UnexpectedMref);
3497             }
3498             result = that.type = types.createErrorType(pt());
3499             return;
3500         }
3501         final Env&lt;AttrContext&gt; localEnv = env.dup(that);
3502         try {
3503             //attribute member reference qualifier - if this is a constructor
3504             //reference, the expected kind must be a type
3505             Type exprType = attribTree(that.expr, env, memberReferenceQualifierResult(that));
3506 
3507             if (that.getMode() == JCMemberReference.ReferenceMode.NEW) {
3508                 exprType = chk.checkConstructorRefType(that.expr, exprType);
3509                 if (!exprType.isErroneous() &amp;&amp;
3510                     exprType.isRaw() &amp;&amp;
3511                     that.typeargs != null) {
3512                     log.error(that.expr.pos(),
3513                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3514                                                  Fragments.MrefInferAndExplicitParams));
3515                     exprType = types.createErrorType(exprType);
3516                 }
3517             }
3518 
3519             if (exprType.isErroneous()) {
3520                 //if the qualifier expression contains problems,
3521                 //give up attribution of method reference
3522                 result = that.type = exprType;
3523                 return;
3524             }
3525 
3526             if (TreeInfo.isStaticSelector(that.expr, names)) {
3527                 //if the qualifier is a type, validate it; raw warning check is
3528                 //omitted as we don&#39;t know at this stage as to whether this is a
3529                 //raw selector (because of inference)
3530                 chk.validate(that.expr, env, false);
3531             } else {
3532                 Symbol lhsSym = TreeInfo.symbol(that.expr);
3533                 localEnv.info.selectSuper = lhsSym != null &amp;&amp; lhsSym.name == names._super;
3534             }
3535             //attrib type-arguments
3536             List&lt;Type&gt; typeargtypes = List.nil();
3537             if (that.typeargs != null) {
3538                 typeargtypes = attribTypes(that.typeargs, localEnv);
3539             }
3540 
3541             boolean isTargetSerializable =
3542                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
3543                     isSerializable(pt());
3544             TargetInfo targetInfo = getTargetInfo(that, resultInfo, null);
3545             Type currentTarget = targetInfo.target;
3546             Type desc = targetInfo.descriptor;
3547 
3548             setFunctionalInfo(localEnv, that, pt(), desc, currentTarget, resultInfo.checkContext);
3549             List&lt;Type&gt; argtypes = desc.getParameterTypes();
3550             Resolve.MethodCheck referenceCheck = rs.resolveMethodCheck;
3551 
3552             if (resultInfo.checkContext.inferenceContext().free(argtypes)) {
3553                 referenceCheck = rs.new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
3554             }
3555 
3556             Pair&lt;Symbol, Resolve.ReferenceLookupHelper&gt; refResult = null;
3557             List&lt;Type&gt; saved_undet = resultInfo.checkContext.inferenceContext().save();
3558             try {
3559                 refResult = rs.resolveMemberReference(localEnv, that, that.expr.type,
3560                         that.name, argtypes, typeargtypes, targetInfo.descriptor, referenceCheck,
3561                         resultInfo.checkContext.inferenceContext(), rs.basicReferenceChooser);
3562             } finally {
3563                 resultInfo.checkContext.inferenceContext().rollback(saved_undet);
3564             }
3565 
3566             Symbol refSym = refResult.fst;
3567             Resolve.ReferenceLookupHelper lookupHelper = refResult.snd;
3568 
3569             /** this switch will need to go away and be replaced by the new RESOLUTION_TARGET testing
3570              *  JDK-8075541
3571              */
3572             if (refSym.kind != MTH) {
3573                 boolean targetError;
3574                 switch (refSym.kind) {
3575                     case ABSENT_MTH:
3576                     case MISSING_ENCL:
3577                         targetError = false;
3578                         break;
3579                     case WRONG_MTH:
3580                     case WRONG_MTHS:
3581                     case AMBIGUOUS:
3582                     case HIDDEN:
3583                     case STATICERR:
3584                         targetError = true;
3585                         break;
3586                     default:
3587                         Assert.error(&quot;unexpected result kind &quot; + refSym.kind);
3588                         targetError = false;
3589                 }
3590 
3591                 JCDiagnostic detailsDiag = ((Resolve.ResolveError)refSym.baseSymbol())
3592                         .getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT,
3593                                 that, exprType.tsym, exprType, that.name, argtypes, typeargtypes);
3594 
3595                 JCDiagnostic diag = diags.create(log.currentSource(), that,
3596                         targetError ?
3597                             Fragments.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag) :
3598                             Errors.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag));
3599 
3600                 if (targetError &amp;&amp; currentTarget == Type.recoveryType) {
3601                     //a target error doesn&#39;t make sense during recovery stage
3602                     //as we don&#39;t know what actual parameter types are
3603                     result = that.type = currentTarget;
3604                     return;
3605                 } else {
3606                     if (targetError) {
3607                         resultInfo.checkContext.report(that, diag);
3608                     } else {
3609                         log.report(diag);
3610                     }
3611                     result = that.type = types.createErrorType(currentTarget);
3612                     return;
3613                 }
3614             }
3615 
3616             that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;
3617             that.kind = lookupHelper.referenceKind(that.sym);
3618             that.ownerAccessible = rs.isAccessible(localEnv, that.sym.enclClass());
3619 
3620             if (desc.getReturnType() == Type.recoveryType) {
3621                 // stop here
3622                 result = that.type = currentTarget;
3623                 return;
3624             }
3625 
3626             if (!env.info.attributionMode.isSpeculative &amp;&amp; that.getMode() == JCMemberReference.ReferenceMode.NEW) {
3627                 Type enclosingType = exprType.getEnclosingType();
3628                 if (enclosingType != null &amp;&amp; enclosingType.hasTag(CLASS)) {
3629                     // Check for the existence of an appropriate outer instance
3630                     rs.resolveImplicitThis(that.pos(), env, exprType);
3631                 }
3632             }
3633 
3634             if (resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3635 
3636                 if (that.getMode() == ReferenceMode.INVOKE &amp;&amp;
3637                         TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3638                         that.kind.isUnbound() &amp;&amp;
3639                         lookupHelper.site.isRaw()) {
3640                     chk.checkRaw(that.expr, localEnv);
3641                 }
3642 
3643                 if (that.sym.isStatic() &amp;&amp; TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3644                         exprType.getTypeArguments().nonEmpty()) {
3645                     //static ref with class type-args
3646                     log.error(that.expr.pos(),
3647                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3648                                                  Fragments.StaticMrefWithTargs));
3649                     result = that.type = types.createErrorType(currentTarget);
3650                     return;
3651                 }
3652 
3653                 if (!refSym.isStatic() &amp;&amp; that.kind == JCMemberReference.ReferenceKind.SUPER) {
3654                     // Check that super-qualified symbols are not abstract (JLS)
3655                     rs.checkNonAbstract(that.pos(), that.sym);
3656                 }
3657 
3658                 if (isTargetSerializable) {
3659                     chk.checkAccessFromSerializableElement(that, true);
3660                 }
3661             }
3662 
3663             ResultInfo checkInfo =
3664                     resultInfo.dup(newMethodTemplate(
3665                         desc.getReturnType().hasTag(VOID) ? Type.noType : desc.getReturnType(),
3666                         that.kind.isUnbound() ? argtypes.tail : argtypes, typeargtypes),
3667                         new FunctionalReturnContext(resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
3668 
3669             Type refType = checkId(that, lookupHelper.site, refSym, localEnv, checkInfo);
3670 
3671             if (that.kind.isUnbound() &amp;&amp;
3672                     resultInfo.checkContext.inferenceContext().free(argtypes.head)) {
3673                 //re-generate inference constraints for unbound receiver
3674                 if (!types.isSubtype(resultInfo.checkContext.inferenceContext().asUndetVar(argtypes.head), exprType)) {
3675                     //cannot happen as this has already been checked - we just need
3676                     //to regenerate the inference constraints, as that has been lost
3677                     //as a result of the call to inferenceContext.save()
3678                     Assert.error(&quot;Can&#39;t get here&quot;);
3679                 }
3680             }
3681 
3682             if (!refType.isErroneous()) {
3683                 refType = types.createMethodTypeWithReturn(refType,
3684                         adjustMethodReturnType(refSym, lookupHelper.site, that.name, checkInfo.pt.getParameterTypes(), refType.getReturnType()));
3685             }
3686 
3687             //go ahead with standard method reference compatibility check - note that param check
3688             //is a no-op (as this has been taken care during method applicability)
3689             boolean isSpeculativeRound =
3690                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
3691 
3692             that.type = currentTarget; //avoids recovery at this stage
3693             checkReferenceCompatible(that, desc, refType, resultInfo.checkContext, isSpeculativeRound);
3694             if (!isSpeculativeRound) {
3695                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), desc, currentTarget);
3696             }
3697             result = check(that, currentTarget, KindSelector.VAL, resultInfo);
3698         } catch (Types.FunctionDescriptorLookupError ex) {
3699             JCDiagnostic cause = ex.getDiagnostic();
3700             resultInfo.checkContext.report(that, cause);
3701             result = that.type = types.createErrorType(pt());
3702             return;
3703         }
3704     }
3705     //where
3706         ResultInfo memberReferenceQualifierResult(JCMemberReference tree) {
3707             //if this is a constructor reference, the expected kind must be a type
3708             return new ResultInfo(tree.getMode() == ReferenceMode.INVOKE ?
3709                                   KindSelector.VAL_TYP : KindSelector.TYP,
3710                                   Type.noType);
3711         }
3712 
3713 
3714     @SuppressWarnings(&quot;fallthrough&quot;)
3715     void checkReferenceCompatible(JCMemberReference tree, Type descriptor, Type refType, CheckContext checkContext, boolean speculativeAttr) {
3716         InferenceContext inferenceContext = checkContext.inferenceContext();
3717         Type returnType = inferenceContext.asUndetVar(descriptor.getReturnType());
3718 
3719         Type resType;
3720         switch (tree.getMode()) {
3721             case NEW:
3722                 if (!tree.expr.type.isRaw()) {
3723                     resType = tree.expr.type;
3724                     break;
3725                 }
3726             default:
3727                 resType = refType.getReturnType();
3728         }
3729 
3730         Type incompatibleReturnType = resType;
3731 
3732         if (returnType.hasTag(VOID)) {
3733             incompatibleReturnType = null;
3734         }
3735 
3736         if (!returnType.hasTag(VOID) &amp;&amp; !resType.hasTag(VOID)) {
3737             if (resType.isErroneous() ||
3738                     new FunctionalReturnContext(checkContext).compatible(resType, returnType,
3739                             checkContext.checkWarner(tree, resType, returnType))) {
3740                 incompatibleReturnType = null;
3741             }
3742         }
3743 
3744         if (incompatibleReturnType != null) {
3745             Fragment msg =
3746                     Fragments.IncompatibleRetTypeInMref(Fragments.InconvertibleTypes(resType, descriptor.getReturnType()));
3747             checkContext.report(tree, diags.fragment(msg));
3748         } else {
3749             if (inferenceContext.free(refType)) {
3750                 // we need to wait for inference to finish and then replace inference vars in the referent type
3751                 inferenceContext.addFreeTypeListener(List.of(refType),
3752                         instantiatedContext -&gt; {
3753                             tree.referentType = instantiatedContext.asInstType(refType);
3754                         });
3755             } else {
3756                 tree.referentType = refType;
3757             }
3758         }
3759 
3760         if (!speculativeAttr) {
3761             if (!checkExConstraints(refType.getThrownTypes(), descriptor.getThrownTypes(), inferenceContext)) {
3762                 log.error(tree, Errors.IncompatibleThrownTypesInMref(refType.getThrownTypes()));
3763             }
3764         }
3765     }
3766 
3767     boolean checkExConstraints(
3768             List&lt;Type&gt; thrownByFuncExpr,
3769             List&lt;Type&gt; thrownAtFuncType,
3770             InferenceContext inferenceContext) {
3771         /** 18.2.5: Otherwise, let E1, ..., En be the types in the function type&#39;s throws clause that
3772          *  are not proper types
3773          */
3774         List&lt;Type&gt; nonProperList = thrownAtFuncType.stream()
3775                 .filter(e -&gt; inferenceContext.free(e)).collect(List.collector());
3776         List&lt;Type&gt; properList = thrownAtFuncType.diff(nonProperList);
3777 
3778         /** Let X1,...,Xm be the checked exception types that the lambda body can throw or
3779          *  in the throws clause of the invocation type of the method reference&#39;s compile-time
3780          *  declaration
3781          */
3782         List&lt;Type&gt; checkedList = thrownByFuncExpr.stream()
3783                 .filter(e -&gt; chk.isChecked(e)).collect(List.collector());
3784 
3785         /** If n = 0 (the function type&#39;s throws clause consists only of proper types), then
3786          *  if there exists some i (1 &lt;= i &lt;= m) such that Xi is not a subtype of any proper type
3787          *  in the throws clause, the constraint reduces to false; otherwise, the constraint
3788          *  reduces to true
3789          */
3790         ListBuffer&lt;Type&gt; uncaughtByProperTypes = new ListBuffer&lt;&gt;();
3791         for (Type checked : checkedList) {
3792             boolean isSubtype = false;
3793             for (Type proper : properList) {
3794                 if (types.isSubtype(checked, proper)) {
3795                     isSubtype = true;
3796                     break;
3797                 }
3798             }
3799             if (!isSubtype) {
3800                 uncaughtByProperTypes.add(checked);
3801             }
3802         }
3803 
3804         if (nonProperList.isEmpty() &amp;&amp; !uncaughtByProperTypes.isEmpty()) {
3805             return false;
3806         }
3807 
3808         /** If n &gt; 0, the constraint reduces to a set of subtyping constraints:
3809          *  for all i (1 &lt;= i &lt;= m), if Xi is not a subtype of any proper type in the
3810          *  throws clause, then the constraints include, for all j (1 &lt;= j &lt;= n), &lt;Xi &lt;: Ej&gt;
3811          */
3812         List&lt;Type&gt; nonProperAsUndet = inferenceContext.asUndetVars(nonProperList);
3813         uncaughtByProperTypes.forEach(checkedEx -&gt; {
3814             nonProperAsUndet.forEach(nonProper -&gt; {
3815                 types.isSubtype(checkedEx, nonProper);
3816             });
3817         });
3818 
3819         /** In addition, for all j (1 &lt;= j &lt;= n), the constraint reduces to the bound throws Ej
3820          */
3821         nonProperAsUndet.stream()
3822                 .filter(t -&gt; t.hasTag(UNDETVAR))
3823                 .forEach(t -&gt; ((UndetVar)t).setThrow());
3824         return true;
3825     }
3826 
3827     /**
3828      * Set functional type info on the underlying AST. Note: as the target descriptor
3829      * might contain inference variables, we might need to register an hook in the
3830      * current inference context.
3831      */
3832     private void setFunctionalInfo(final Env&lt;AttrContext&gt; env, final JCFunctionalExpression fExpr,
3833             final Type pt, final Type descriptorType, final Type primaryTarget, final CheckContext checkContext) {
3834         if (checkContext.inferenceContext().free(descriptorType)) {
3835             checkContext.inferenceContext().addFreeTypeListener(List.of(pt, descriptorType),
3836                     inferenceContext -&gt; setFunctionalInfo(env, fExpr, pt, inferenceContext.asInstType(descriptorType),
3837                     inferenceContext.asInstType(primaryTarget), checkContext));
3838         } else {
3839             if (pt.hasTag(CLASS)) {
3840                 fExpr.target = primaryTarget;
3841             }
3842             if (checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
3843                     pt != Type.recoveryType) {
3844                 //check that functional interface class is well-formed
3845                 try {
3846                     /* Types.makeFunctionalInterfaceClass() may throw an exception
3847                      * when it&#39;s executed post-inference. See the listener code
3848                      * above.
3849                      */
3850                     ClassSymbol csym = types.makeFunctionalInterfaceClass(env,
3851                             names.empty, fExpr.target, ABSTRACT);
3852                     if (csym != null) {
3853                         chk.checkImplementations(env.tree, csym, csym);
3854                         try {
3855                             //perform an additional functional interface check on the synthetic class,
3856                             //as there may be spurious errors for raw targets - because of existing issues
3857                             //with membership and inheritance (see JDK-8074570).
3858                             csym.flags_field |= INTERFACE;
3859                             types.findDescriptorType(csym.type);
3860                         } catch (FunctionDescriptorLookupError err) {
3861                             resultInfo.checkContext.report(fExpr,
3862                                     diags.fragment(Fragments.NoSuitableFunctionalIntfInst(fExpr.target)));
3863                         }
3864                     }
3865                 } catch (Types.FunctionDescriptorLookupError ex) {
3866                     JCDiagnostic cause = ex.getDiagnostic();
3867                     resultInfo.checkContext.report(env.tree, cause);
3868                 }
3869             }
3870         }
3871     }
3872 
3873     public void visitParens(JCParens tree) {
3874         Type owntype = attribTree(tree.expr, env, resultInfo);
3875         result = check(tree, owntype, pkind(), resultInfo);
3876         Symbol sym = TreeInfo.symbol(tree);
3877         if (sym != null &amp;&amp; sym.kind.matches(KindSelector.TYP_PCK))
3878             log.error(tree.pos(), Errors.IllegalParenthesizedExpression);
3879     }
3880 
3881     public void visitAssign(JCAssign tree) {
3882         Type owntype = attribTree(tree.lhs, env.dup(tree), varAssignmentInfo);
3883         Type capturedType = capture(owntype);
3884         attribExpr(tree.rhs, env, owntype);
3885         result = check(tree, capturedType, KindSelector.VAL, resultInfo);
3886     }
3887 
3888     public void visitAssignop(JCAssignOp tree) {
3889         // Attribute arguments.
3890         Type owntype = attribTree(tree.lhs, env, varAssignmentInfo);
3891         Type operand = attribExpr(tree.rhs, env);
3892         // Find operator.
3893         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), owntype, operand);
3894         if (operator != operators.noOpSymbol &amp;&amp;
3895                 !owntype.isErroneous() &amp;&amp;
3896                 !operand.isErroneous()) {
3897             chk.checkDivZero(tree.rhs.pos(), operator, operand);
3898             chk.checkCastable(tree.rhs.pos(),
3899                               operator.type.getReturnType(),
3900                               owntype);
3901         }
3902         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3903     }
3904 
3905     public void visitUnary(JCUnary tree) {
3906         // Attribute arguments.
3907         Type argtype = (tree.getTag().isIncOrDecUnaryOp())
3908             ? attribTree(tree.arg, env, varAssignmentInfo)
3909             : chk.checkNonVoid(tree.arg.pos(), attribExpr(tree.arg, env));
3910 
3911         // Find operator.
3912         Symbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);
3913         Type owntype = types.createErrorType(tree.type);
3914         if (operator != operators.noOpSymbol &amp;&amp;
3915                 !argtype.isErroneous()) {
3916             owntype = (tree.getTag().isIncOrDecUnaryOp())
3917                 ? tree.arg.type
3918                 : operator.type.getReturnType();
3919             int opc = ((OperatorSymbol)operator).opcode;
3920 
3921             // If the argument is constant, fold it.
3922             if (argtype.constValue() != null) {
3923                 Type ctype = cfolder.fold1(opc, argtype);
3924                 if (ctype != null) {
3925                     owntype = cfolder.coerce(ctype, owntype);
3926                 }
3927             }
3928         }
3929         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3930         matchBindings = matchBindingsComputer.unary(tree, matchBindings);
3931     }
3932 
3933     public void visitBinary(JCBinary tree) {
3934         // Attribute arguments.
3935         Type left = chk.checkNonVoid(tree.lhs.pos(), attribExpr(tree.lhs, env));
3936         // x &amp;&amp; y
3937         // include x&#39;s bindings when true in y
3938 
3939         // x || y
3940         // include x&#39;s bindings when false in y
3941 
3942         MatchBindings lhsBindings = matchBindings;
3943         List&lt;BindingSymbol&gt; propagatedBindings;
3944         switch (tree.getTag()) {
3945             case AND:
3946                 propagatedBindings = lhsBindings.bindingsWhenTrue;
3947                 break;
3948             case OR:
3949                 propagatedBindings = lhsBindings.bindingsWhenFalse;
3950                 break;
3951             default:
3952                 propagatedBindings = List.nil();
3953                 break;
3954         }
3955         Env&lt;AttrContext&gt; rhsEnv = bindingEnv(env, propagatedBindings);
3956         Type right;
3957         try {
3958             right = chk.checkNonVoid(tree.rhs.pos(), attribExpr(tree.rhs, rhsEnv));
3959         } finally {
3960             rhsEnv.info.scope.leave();
3961         }
3962 
3963         matchBindings = matchBindingsComputer.binary(tree, lhsBindings, matchBindings);
3964 
3965         // Find operator.
3966         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);
3967         Type owntype = types.createErrorType(tree.type);
3968         if (operator != operators.noOpSymbol &amp;&amp;
3969                 !left.isErroneous() &amp;&amp;
3970                 !right.isErroneous()) {
3971             owntype = operator.type.getReturnType();
3972             int opc = ((OperatorSymbol)operator).opcode;
3973             // If both arguments are constants, fold them.
3974             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3975                 Type ctype = cfolder.fold2(opc, left, right);
3976                 if (ctype != null) {
3977                     owntype = cfolder.coerce(ctype, owntype);
3978                 }
3979             }
3980 
3981             // Check that argument types of a reference ==, != are
3982             // castable to each other, (JLS 15.21).  Note: unboxing
3983             // comparisons will not have an acmp* opc at this point.
3984             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
3985                 if (!types.isCastable(left, right, new Warner(tree.pos()))) {
3986                     log.error(tree.pos(), Errors.IncomparableTypes(left, right));
3987                 }
3988                 chk.checkForSuspectClassLiteralComparison(tree, left, right);
3989             }
3990 
3991             chk.checkDivZero(tree.rhs.pos(), operator, right);
3992         }
3993         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3994     }
3995 
3996     public void visitTypeCast(final JCTypeCast tree) {
3997         Type clazztype = attribType(tree.clazz, env);
3998         chk.validate(tree.clazz, env, false);
3999         //a fresh environment is required for 292 inference to work properly ---
4000         //see Infer.instantiatePolymorphicSignatureInstance()
4001         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
4002         //should we propagate the target type?
4003         final ResultInfo castInfo;
4004         JCExpression expr = TreeInfo.skipParens(tree.expr);
4005         boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
4006         if (isPoly) {
4007             //expression is a poly - we need to propagate target type info
4008             castInfo = new ResultInfo(KindSelector.VAL, clazztype,
4009                                       new Check.NestedCheckContext(resultInfo.checkContext) {
4010                 @Override
4011                 public boolean compatible(Type found, Type req, Warner warn) {
4012                     return types.isCastable(found, req, warn);
4013                 }
4014             });
4015         } else {
4016             //standalone cast - target-type info is not propagated
4017             castInfo = unknownExprInfo;
4018         }
4019         Type exprtype = attribTree(tree.expr, localEnv, castInfo);
4020         Type owntype = isPoly ? clazztype : chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
4021         if (exprtype.constValue() != null)
4022             owntype = cfolder.coerce(exprtype, owntype);
4023         result = check(tree, capture(owntype), KindSelector.VAL, resultInfo);
4024         if (!isPoly)
4025             chk.checkRedundantCast(localEnv, tree);
4026     }
4027 
4028     public void visitTypeTest(JCInstanceOf tree) {
4029         Type exprtype = chk.checkNullOrRefType(
4030                 tree.expr.pos(), attribExpr(tree.expr, env));
4031         Type clazztype;
4032         JCTree typeTree;
4033         if (tree.pattern.getTag() == BINDINGPATTERN) {
4034             attribTree(tree.pattern, env, unknownExprInfo);
4035             clazztype = tree.pattern.type;
4036             JCBindingPattern pattern = (JCBindingPattern) tree.pattern;
4037             typeTree = pattern.vartype;
4038             if (!clazztype.hasTag(TYPEVAR)) {
4039                 clazztype = chk.checkClassOrArrayType(pattern.vartype.pos(), clazztype);
4040             }
4041         } else {
4042             clazztype = attribType(tree.pattern, env);
4043             typeTree = tree.pattern;
4044         }
4045         if (!clazztype.hasTag(TYPEVAR)) {
4046             clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);
4047         }
4048         if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {
4049             boolean valid = false;
4050             if (allowReifiableTypesInInstanceof) {
4051                 if (preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF)) {
4052                     preview.warnPreview(tree.expr.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF);
4053                 }
4054                 Warner warner = new Warner();
4055                 if (!types.isCastable(exprtype, clazztype, warner)) {
4056                     chk.basicHandler.report(tree.expr.pos(),
4057                                             diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));
4058                 } else if (warner.hasLint(LintCategory.UNCHECKED)) {
4059                     log.error(tree.expr.pos(),
4060                               Errors.InstanceofReifiableNotSafe(exprtype, clazztype));
4061                 } else {
4062                     valid = true;
4063                 }
4064             } else {
4065                 log.error(typeTree.pos(), Errors.IllegalGenericTypeForInstof);
4066             }
4067             if (!valid) {
4068                 clazztype = types.createErrorType(clazztype);
4069             }
4070         }
4071         chk.validate(typeTree, env, false);
4072         chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
4073         result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
4074     }
4075 
4076     public void visitBindingPattern(JCBindingPattern tree) {
4077         ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);
4078         tree.type = attribTree(tree.vartype, env, varInfo);
4079         VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype.type, env.info.scope.owner);
4080         if (chk.checkUnique(tree.pos(), v, env.info.scope)) {
4081             chk.checkTransparentVar(tree.pos(), v, env.info.scope);
4082         }
4083         annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());
4084         annotate.flush();
4085         result = tree.type;
4086         matchBindings = new MatchBindings(List.of(tree.symbol), List.nil());
4087     }
4088 
4089     public void visitIndexed(JCArrayAccess tree) {
4090         Type owntype = types.createErrorType(tree.type);
4091         Type atype = attribExpr(tree.indexed, env);
4092         attribExpr(tree.index, env, syms.intType);
4093         if (types.isArray(atype))
4094             owntype = types.elemtype(atype);
4095         else if (!atype.hasTag(ERROR))
4096             log.error(tree.pos(), Errors.ArrayReqButFound(atype));
4097         if (!pkind().contains(KindSelector.VAL))
4098             owntype = capture(owntype);
4099         result = check(tree, owntype, KindSelector.VAR, resultInfo);
4100     }
4101 
4102     public void visitIdent(JCIdent tree) {
4103         Symbol sym;
4104 
4105         // Find symbol
4106         if (pt().hasTag(METHOD) || pt().hasTag(FORALL)) {
4107             // If we are looking for a method, the prototype `pt&#39; will be a
4108             // method type with the type of the call&#39;s arguments as parameters.
4109             env.info.pendingResolutionPhase = null;
4110             sym = rs.resolveMethod(tree.pos(), env, tree.name, pt().getParameterTypes(), pt().getTypeArguments());
4111         } else if (tree.sym != null &amp;&amp; tree.sym.kind != VAR) {
4112             sym = tree.sym;
4113         } else {
4114             sym = rs.resolveIdent(tree.pos(), env, tree.name, pkind());
4115         }
4116         tree.sym = sym;
4117 
4118         // (1) Also find the environment current for the class where
4119         //     sym is defined (`symEnv&#39;).
4120         // Only for pre-tiger versions (1.4 and earlier):
4121         // (2) Also determine whether we access symbol out of an anonymous
4122         //     class in a this or super call.  This is illegal for instance
4123         //     members since such classes don&#39;t carry a this$n link.
4124         //     (`noOuterThisPath&#39;).
4125         Env&lt;AttrContext&gt; symEnv = env;
4126         boolean noOuterThisPath = false;
4127         if (env.enclClass.sym.owner.kind != PCK &amp;&amp; // we are in an inner class
4128             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
4129             sym.owner.kind == TYP &amp;&amp;
4130             tree.name != names._this &amp;&amp; tree.name != names._super) {
4131 
4132             // Find environment in which identifier is defined.
4133             while (symEnv.outer != null &amp;&amp;
4134                    !sym.isMemberOf(symEnv.enclClass.sym, types)) {
4135                 if ((symEnv.enclClass.sym.flags() &amp; NOOUTERTHIS) != 0)
4136                     noOuterThisPath = false;
4137                 symEnv = symEnv.outer;
4138             }
4139         }
4140 
4141         // If symbol is a variable, ...
4142         if (sym.kind == VAR) {
4143             VarSymbol v = (VarSymbol)sym;
4144 
4145             // ..., evaluate its initializer, if it has one, and check for
4146             // illegal forward reference.
4147             checkInit(tree, env, v, false);
4148 
4149             // If we are expecting a variable (as opposed to a value), check
4150             // that the variable is assignable in the current environment.
4151             if (KindSelector.ASG.subset(pkind()))
4152                 checkAssignable(tree.pos(), v, null, env);
4153         }
4154 
4155         // In a constructor body,
4156         // if symbol is a field or instance method, check that it is
4157         // not accessed before the supertype constructor is called.
4158         if ((symEnv.info.isSelfCall || noOuterThisPath) &amp;&amp;
4159             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
4160             sym.owner.kind == TYP &amp;&amp;
4161             (sym.flags() &amp; STATIC) == 0) {
4162             chk.earlyRefError(tree.pos(), sym.kind == VAR ?
4163                                           sym : thisSym(tree.pos(), env));
4164         }
4165         Env&lt;AttrContext&gt; env1 = env;
4166         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4167             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4168             // If the found symbol is inaccessible, then it is
4169             // accessed through an enclosing instance.  Locate this
4170             // enclosing instance:
4171             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4172                 env1 = env1.outer;
4173         }
4174 
4175         if (env.info.isSerializable) {
4176             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4177         }
4178 
4179         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4180     }
4181 
4182     public void visitSelect(JCFieldAccess tree) {
4183         // Determine the expected kind of the qualifier expression.
4184         KindSelector skind = KindSelector.NIL;
4185         if (tree.name == names._this || tree.name == names._super ||
4186                 tree.name == names._class || tree.name == names._default)
4187         {
4188             if (tree.name == names._default &amp;&amp; !allowInlineTypes) {
4189                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),
4190                         Feature.INLINE_TYPES.error(sourceName));
4191             }
4192             skind = KindSelector.TYP;
4193         } else {
4194             if (pkind().contains(KindSelector.PCK))
4195                 skind = KindSelector.of(skind, KindSelector.PCK);
4196             if (pkind().contains(KindSelector.TYP))
4197                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4198             if (pkind().contains(KindSelector.VAL_MTH))
4199                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4200         }
4201 
4202         // Attribute the qualifier expression, and determine its symbol (if any).
4203         Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));
4204         if (!pkind().contains(KindSelector.TYP_PCK))
4205             site = capture(site); // Capture field access
4206 
4207         // don&#39;t allow T.class T[].class, etc
4208         if (skind == KindSelector.TYP) {
4209             Type elt = site;
4210             while (elt.hasTag(ARRAY))
4211                 elt = ((ArrayType)elt).elemtype;
4212             if (elt.hasTag(TYPEVAR)) {
4213                 if (tree.name == names._default) {
4214                     result = check(tree, litType(BOT).constType(null),
4215                             KindSelector.VAL, resultInfo);
4216                 } else {
4217                     log.error(tree.pos(), Errors.TypeVarCantBeDeref);
4218                     result = tree.type = types.createErrorType(tree.name, site.tsym, site);
4219                     tree.sym = tree.type.tsym;
4220                     return;
4221                 }
4222             }
4223         }
4224 
4225         // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;
4226         // for the selection. This is relevant for determining whether
4227         // protected symbols are accessible.
4228         Symbol sitesym = TreeInfo.symbol(tree.selected);
4229 
4230         boolean selectSuperPrev = env.info.selectSuper;
4231         env.info.selectSuper =
4232             sitesym != null &amp;&amp;
4233             sitesym.name == names._super;
4234 
4235         // Determine the symbol represented by the selection.
4236         env.info.pendingResolutionPhase = null;
4237         Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
4238         if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
4239             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
4240             sym = syms.errSymbol;
4241         }
4242         if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
4243             site = capture(site);
4244             sym = selectSym(tree, sitesym, site, env, resultInfo);
4245         }
4246         boolean varArgs = env.info.lastResolveVarargs();
4247         tree.sym = sym;
4248 
4249         if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
4250             site = types.skipTypeVars(site, true);
4251         }
4252 
4253         // If that symbol is a variable, ...
4254         if (sym.kind == VAR) {
4255             VarSymbol v = (VarSymbol)sym;
4256 
4257             // ..., evaluate its initializer, if it has one, and check for
4258             // illegal forward reference.
4259             checkInit(tree, env, v, true);
4260 
4261             // If we are expecting a variable (as opposed to a value), check
4262             // that the variable is assignable in the current environment.
4263             if (KindSelector.ASG.subset(pkind()))
4264                 checkAssignable(tree.pos(), v, tree.selected, env);
4265         }
4266 
4267         if (sitesym != null &amp;&amp;
4268                 sitesym.kind == VAR &amp;&amp;
4269                 ((VarSymbol)sitesym).isResourceVariable() &amp;&amp;
4270                 sym.kind == MTH &amp;&amp;
4271                 sym.name.equals(names.close) &amp;&amp;
4272                 sym.overrides(syms.autoCloseableClose, sitesym.type.tsym, types, true) &amp;&amp;
4273                 env.info.lint.isEnabled(LintCategory.TRY)) {
4274             log.warning(LintCategory.TRY, tree, Warnings.TryExplicitCloseCall);
4275         }
4276 
4277         // Disallow selecting a type from an expression
4278         if (isType(sym) &amp;&amp; (sitesym == null || !sitesym.kind.matches(KindSelector.TYP_PCK))) {
4279             tree.type = check(tree.selected, pt(),
4280                               sitesym == null ?
4281                                       KindSelector.VAL : sitesym.kind.toSelector(),
4282                               new ResultInfo(KindSelector.TYP_PCK, pt()));
4283         }
4284 
4285         if (isType(sitesym)) {
4286             if (sym.name == names._this) {
4287                 // If `C&#39; is the currently compiled class, check that
4288                 // C.this&#39; does not appear in a call to a super(...)
4289                 if (env.info.isSelfCall &amp;&amp;
4290                     site.tsym == env.enclClass.sym) {
4291                     chk.earlyRefError(tree.pos(), sym);
4292                 }
4293             } else {
4294                 // Check if type-qualified fields or methods are static (JLS)
4295                 if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
4296                     sym.name != names._super &amp;&amp;
4297                     (sym.kind == VAR || sym.kind == MTH)) {
4298                     rs.accessBase(rs.new StaticError(sym),
4299                               tree.pos(), site, sym.name, true);
4300                 }
4301             }
4302             if (!allowStaticInterfaceMethods &amp;&amp; sitesym.isInterface() &amp;&amp;
4303                     sym.isStatic() &amp;&amp; sym.kind == MTH) {
4304                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(), Feature.STATIC_INTERFACE_METHODS_INVOKE.error(sourceName));
4305             }
4306         } else if (sym.kind != ERR &amp;&amp;
4307                    (sym.flags() &amp; STATIC) != 0 &amp;&amp;
4308                    sym.name != names._class) {
4309             // If the qualified item is not a type and the selected item is static, report
4310             // a warning. Make allowance for the class of an array type e.g. Object[].class)
4311             chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));
4312         }
4313 
4314         // If we are selecting an instance member via a `super&#39;, ...
4315         if (env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0) {
4316 
4317             // Check that super-qualified symbols are not abstract (JLS)
4318             rs.checkNonAbstract(tree.pos(), sym);
4319 
4320             if (site.isRaw()) {
4321                 // Determine argument types for site.
4322                 Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);
4323                 if (site1 != null) site = site1;
4324             }
4325         }
4326 
4327         if (env.info.isSerializable) {
4328             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4329         }
4330 
4331         env.info.selectSuper = selectSuperPrev;
4332         result = checkId(tree, site, sym, env, resultInfo);
4333     }
4334     //where
4335         /** Determine symbol referenced by a Select expression,
4336          *
4337          *  @param tree   The select tree.
4338          *  @param site   The type of the selected expression,
4339          *  @param env    The current environment.
4340          *  @param resultInfo The current result.
4341          */
4342         private Symbol selectSym(JCFieldAccess tree,
4343                                  Symbol location,
4344                                  Type site,
4345                                  Env&lt;AttrContext&gt; env,
4346                                  ResultInfo resultInfo) {
4347             DiagnosticPosition pos = tree.pos();
4348             Name name = tree.name;
4349             switch (site.getTag()) {
4350             case PACKAGE:
4351                 return rs.accessBase(
4352                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),
4353                     pos, location, site, name, true);
4354             case ARRAY:
4355             case CLASS:
4356                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4357                     return rs.resolveQualifiedMethod(
4358                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4359                 } else if (name == names._this || name == names._super) {
4360                     return rs.resolveSelf(pos, env, site.tsym, name);
4361                 } else if (name == names._class) {
4362                     // In this case, we have already made sure in
4363                     // visitSelect that qualifier expression is a type.
4364                     return syms.getClassField(site, types);
4365                 } else if (name == names._default) {
4366                     return new VarSymbol(STATIC, names._default, site, site.tsym);
4367                 } else if (name == names.ref &amp;&amp; site.isValue() &amp;&amp; resultInfo.pkind.contains(KindSelector.TYP)) {
4368                     return site.tsym.referenceProjection();
4369                 } else if (name == names.val &amp;&amp; site.isValue() &amp;&amp; resultInfo.pkind.contains(KindSelector.TYP)) {
4370                     return site.tsym;
4371                 } else {
4372                     // We are seeing a plain identifier as selector.
4373                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
4374                         sym = rs.accessBase(sym, pos, location, site, name, true);
4375                     return sym;
4376                 }
4377             case WILDCARD:
4378                 throw new AssertionError(tree);
4379             case TYPEVAR:
4380                 if (name == names._default) {
4381                     // Be sure to return the default value before examining bounds
4382                     return new VarSymbol(STATIC, names._default, site, site.tsym);
4383                 }
4384                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4385                 // It should only happen during memberEnter/attribBase
4386                 // when determining the super type which *must* be
4387                 // done before attributing the type variables.  In
4388                 // other words, we are seeing this illegal program:
4389                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4390                 Symbol sym = (site.getUpperBound() != null)
4391                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4392                     : null;
4393                 if (sym == null) {
4394                     log.error(pos, Errors.TypeVarCantBeDeref);
4395                     return syms.errSymbol;
4396                 } else {
4397                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4398                         rs.new AccessError(env, site, sym) :
4399                                 sym;
4400                     rs.accessBase(sym2, pos, location, site, name, true);
4401                     return sym;
4402                 }
4403             case ERROR:
4404                 // preserve identifier names through errors
4405                 return types.createErrorType(name, site.tsym, site).tsym;
4406             default:
4407                 // The qualifier expression is of a primitive type -- only
4408                 // .class and .default is allowed for these.
4409                 if (name == names._class) {
4410                     // In this case, we have already made sure in Select that
4411                     // qualifier expression is a type.
4412                     return syms.getClassField(site, types);
4413                 } else if (name == names._default) {
4414                     return new VarSymbol(STATIC, names._default, site, site.tsym);
4415                 } else {
4416                     log.error(pos, Errors.CantDeref(site));
4417                     return syms.errSymbol;
4418                 }
4419             }
4420         }
4421 
4422         /** Determine type of identifier or select expression and check that
4423          *  (1) the referenced symbol is not deprecated
4424          *  (2) the symbol&#39;s type is safe (@see checkSafe)
4425          *  (3) if symbol is a variable, check that its type and kind are
4426          *      compatible with the prototype and protokind.
4427          *  (4) if symbol is an instance field of a raw type,
4428          *      which is being assigned to, issue an unchecked warning if its
4429          *      type changes under erasure.
4430          *  (5) if symbol is an instance method of a raw type, issue an
4431          *      unchecked warning if its argument types change under erasure.
4432          *  If checks succeed:
4433          *    If symbol is a constant, return its constant type
4434          *    else if symbol is a method, return its result type
4435          *    otherwise return its type.
4436          *  Otherwise return errType.
4437          *
4438          *  @param tree       The syntax tree representing the identifier
4439          *  @param site       If this is a select, the type of the selected
4440          *                    expression, otherwise the type of the current class.
4441          *  @param sym        The symbol representing the identifier.
4442          *  @param env        The current environment.
4443          *  @param resultInfo    The expected result
4444          */
4445         Type checkId(JCTree tree,
4446                      Type site,
4447                      Symbol sym,
4448                      Env&lt;AttrContext&gt; env,
4449                      ResultInfo resultInfo) {
4450             return (resultInfo.pt.hasTag(FORALL) || resultInfo.pt.hasTag(METHOD)) ?
4451                     checkMethodIdInternal(tree, site, sym, env, resultInfo) :
4452                     checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);
4453         }
4454 
4455         Type checkMethodIdInternal(JCTree tree,
4456                      Type site,
4457                      Symbol sym,
4458                      Env&lt;AttrContext&gt; env,
4459                      ResultInfo resultInfo) {
4460             if (resultInfo.pkind.contains(KindSelector.POLY)) {
4461                 Type pt = resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, sym, env.info.pendingResolutionPhase));
4462                 Type owntype = checkIdInternal(tree, site, sym, pt, env, resultInfo);
4463                 resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));
4464                 return owntype;
4465             } else {
4466                 return checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);
4467             }
4468         }
4469 
4470         Type checkIdInternal(JCTree tree,
4471                      Type site,
4472                      Symbol sym,
4473                      Type pt,
4474                      Env&lt;AttrContext&gt; env,
4475                      ResultInfo resultInfo) {
4476             if (pt.isErroneous()) {
4477                 return types.createErrorType(site);
4478             }
4479             Type owntype; // The computed type of this identifier occurrence.
4480             switch (sym.kind) {
4481             case TYP:
4482                 // For types, the computed type equals the symbol&#39;s type,
4483                 // except for two situations:
4484                 owntype = sym.type;
4485                 if (owntype.hasTag(CLASS)) {
4486                     chk.checkForBadAuxiliaryClassAccess(tree.pos(), env, (ClassSymbol)sym);
4487                     Type ownOuter = owntype.getEnclosingType();
4488 
4489                     // (a) If the symbol&#39;s type is parameterized, erase it
4490                     // because no type parameters were given.
4491                     // We recover generic outer type later in visitTypeApply.
4492                     if (owntype.tsym.type.getTypeArguments().nonEmpty()) {
4493                         owntype = types.erasure(owntype);
4494                     }
4495 
4496                     // (b) If the symbol&#39;s type is an inner class, then
4497                     // we have to interpret its outer type as a superclass
4498                     // of the site type. Example:
4499                     //
4500                     // class Tree&lt;A&gt; { class Visitor { ... } }
4501                     // class PointTree extends Tree&lt;Point&gt; { ... }
4502                     // ...PointTree.Visitor...
4503                     //
4504                     // Then the type of the last expression above is
4505                     // Tree&lt;Point&gt;.Visitor.
4506                     else if (ownOuter.hasTag(CLASS) &amp;&amp; site != ownOuter) {
4507                         Type normOuter = site;
4508                         if (normOuter.hasTag(CLASS)) {
4509                             normOuter = types.asEnclosingSuper(site, ownOuter.tsym);
4510                         }
4511                         if (normOuter == null) // perhaps from an import
4512                             normOuter = types.erasure(ownOuter);
4513                         if (normOuter != ownOuter)
4514                             owntype = new ClassType(
4515                                 normOuter, List.nil(), owntype.tsym,
4516                                 owntype.getMetadata());
4517                     }
4518                 }
4519                 break;
4520             case VAR:
4521                 VarSymbol v = (VarSymbol)sym;
4522 
4523                 if (env.info.enclVar != null
4524                         &amp;&amp; v.type.hasTag(NONE)) {
4525                     //self reference to implicitly typed variable declaration
4526                     log.error(TreeInfo.positionFor(v, env.enclClass), Errors.CantInferLocalVarType(v.name, Fragments.LocalSelfRef));
4527                     return v.type = types.createErrorType(v.type);
4528                 }
4529 
4530                 // Test (4): if symbol is an instance field of a raw type,
4531                 // which is being assigned to, issue an unchecked warning if
4532                 // its type changes under erasure.
4533                 if (KindSelector.ASG.subset(pkind()) &amp;&amp;
4534                     v.owner.kind == TYP &amp;&amp;
4535                     (v.flags() &amp; STATIC) == 0 &amp;&amp;
4536                     (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
4537                     Type s = types.asOuterSuper(site, v.owner);
4538                     if (s != null &amp;&amp;
4539                         s.isRaw() &amp;&amp;
4540                         !types.isSameType(v.type, v.erasure(types))) {
4541                         chk.warnUnchecked(tree.pos(), Warnings.UncheckedAssignToVar(v, s));
4542                     }
4543                 }
4544                 // The computed type of a variable is the type of the
4545                 // variable symbol, taken as a member of the site type.
4546                 owntype = (sym.owner.kind == TYP &amp;&amp;
4547                            sym.name != names._this &amp;&amp; sym.name != names._super)
4548                     ? types.memberType(site, sym)
4549                     : sym.type;
4550 
4551                 // If the variable is a constant, record constant value in
4552                 // computed type.
4553                 if (v.getConstValue() != null &amp;&amp; isStaticReference(tree))
4554                     owntype = owntype.constType(v.getConstValue());
4555 
4556                 if (resultInfo.pkind == KindSelector.VAL) {
4557                     owntype = capture(owntype); // capture &quot;names as expressions&quot;
4558                 }
4559                 break;
4560             case MTH: {
4561                 owntype = checkMethod(site, sym,
4562                         new ResultInfo(resultInfo.pkind, resultInfo.pt.getReturnType(), resultInfo.checkContext, resultInfo.checkMode),
4563                         env, TreeInfo.args(env.tree), resultInfo.pt.getParameterTypes(),
4564                         resultInfo.pt.getTypeArguments());
4565                 break;
4566             }
4567             case PCK: case ERR:
4568                 owntype = sym.type;
4569                 break;
4570             default:
4571                 throw new AssertionError(&quot;unexpected kind: &quot; + sym.kind +
4572                                          &quot; in tree &quot; + tree);
4573             }
4574 
4575             // Emit a `deprecation&#39; warning if symbol is deprecated.
4576             // (for constructors (but not for constructor references), the error
4577             // was given when the constructor was resolved)
4578 
4579             if (sym.name != names.init || tree.hasTag(REFERENCE)) {
4580                 chk.checkDeprecated(tree.pos(), env.info.scope.owner, sym);
4581                 chk.checkSunAPI(tree.pos(), sym);
4582                 chk.checkProfile(tree.pos(), sym);
4583                 chk.checkPreview(tree.pos(), sym);
4584             }
4585 
4586             // If symbol is a variable, check that its type and
4587             // kind are compatible with the prototype and protokind.
4588             return check(tree, owntype, sym.kind.toSelector(), resultInfo);
4589         }
4590 
4591         /** Check that variable is initialized and evaluate the variable&#39;s
4592          *  initializer, if not yet done. Also check that variable is not
4593          *  referenced before it is defined.
4594          *  @param tree    The tree making up the variable reference.
4595          *  @param env     The current environment.
4596          *  @param v       The variable&#39;s symbol.
4597          */
4598         private void checkInit(JCTree tree,
4599                                Env&lt;AttrContext&gt; env,
4600                                VarSymbol v,
4601                                boolean onlyWarning) {
4602             // A forward reference is diagnosed if the declaration position
4603             // of the variable is greater than the current tree position
4604             // and the tree and variable definition occur in the same class
4605             // definition.  Note that writes don&#39;t count as references.
4606             // This check applies only to class and instance
4607             // variables.  Local variables follow different scope rules,
4608             // and are subject to definite assignment checking.
4609             Env&lt;AttrContext&gt; initEnv = enclosingInitEnv(env);
4610             if (initEnv != null &amp;&amp;
4611                 (initEnv.info.enclVar == v || v.pos &gt; tree.pos) &amp;&amp;
4612                 v.owner.kind == TYP &amp;&amp;
4613                 v.owner == env.info.scope.owner.enclClass() &amp;&amp;
4614                 ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env) &amp;&amp;
4615                 (!env.tree.hasTag(ASSIGN) ||
4616                  TreeInfo.skipParens(((JCAssign) env.tree).lhs) != tree)) {
4617                 if (!onlyWarning || isStaticEnumField(v)) {
4618                     Error errkey = (initEnv.info.enclVar == v) ?
4619                                 Errors.IllegalSelfRef : Errors.IllegalForwardRef;
4620                     log.error(tree.pos(), errkey);
4621                 } else if (useBeforeDeclarationWarning) {
4622                     Warning warnkey = (initEnv.info.enclVar == v) ?
4623                                 Warnings.SelfRef(v) : Warnings.ForwardRef(v);
4624                     log.warning(tree.pos(), warnkey);
4625                 }
4626             }
4627 
4628             v.getConstValue(); // ensure initializer is evaluated
4629 
4630             checkEnumInitializer(tree, env, v);
4631         }
4632 
4633         /**
4634          * Returns the enclosing init environment associated with this env (if any). An init env
4635          * can be either a field declaration env or a static/instance initializer env.
4636          */
4637         Env&lt;AttrContext&gt; enclosingInitEnv(Env&lt;AttrContext&gt; env) {
4638             while (true) {
4639                 switch (env.tree.getTag()) {
4640                     case VARDEF:
4641                         JCVariableDecl vdecl = (JCVariableDecl)env.tree;
4642                         if (vdecl.sym.owner.kind == TYP) {
4643                             //field
4644                             return env;
4645                         }
4646                         break;
4647                     case BLOCK:
4648                         if (env.next.tree.hasTag(CLASSDEF)) {
4649                             //instance/static initializer
4650                             return env;
4651                         }
4652                         break;
4653                     case METHODDEF:
4654                     case CLASSDEF:
4655                     case TOPLEVEL:
4656                         return null;
4657                 }
4658                 Assert.checkNonNull(env.next);
4659                 env = env.next;
4660             }
4661         }
4662 
4663         /**
4664          * Check for illegal references to static members of enum.  In
4665          * an enum type, constructors and initializers may not
4666          * reference its static members unless they are constant.
4667          *
4668          * @param tree    The tree making up the variable reference.
4669          * @param env     The current environment.
4670          * @param v       The variable&#39;s symbol.
4671          * @jls 8.9 Enum Types
4672          */
4673         private void checkEnumInitializer(JCTree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
4674             // JLS:
4675             //
4676             // &quot;It is a compile-time error to reference a static field
4677             // of an enum type that is not a compile-time constant
4678             // (15.28) from constructors, instance initializer blocks,
4679             // or instance variable initializer expressions of that
4680             // type. It is a compile-time error for the constructors,
4681             // instance initializer blocks, or instance variable
4682             // initializer expressions of an enum constant e to refer
4683             // to itself or to an enum constant of the same type that
4684             // is declared to the right of e.&quot;
4685             if (isStaticEnumField(v)) {
4686                 ClassSymbol enclClass = env.info.scope.owner.enclClass();
4687 
4688                 if (enclClass == null || enclClass.owner == null)
4689                     return;
4690 
4691                 // See if the enclosing class is the enum (or a
4692                 // subclass thereof) declaring v.  If not, this
4693                 // reference is OK.
4694                 if (v.owner != enclClass &amp;&amp; !types.isSubtype(enclClass.type, v.owner.type))
4695                     return;
4696 
4697                 // If the reference isn&#39;t from an initializer, then
4698                 // the reference is OK.
4699                 if (!Resolve.isInitializer(env))
4700                     return;
4701 
4702                 log.error(tree.pos(), Errors.IllegalEnumStaticRef);
4703             }
4704         }
4705 
4706         /** Is the given symbol a static, non-constant field of an Enum?
4707          *  Note: enum literals should not be regarded as such
4708          */
4709         private boolean isStaticEnumField(VarSymbol v) {
4710             return Flags.isEnum(v.owner) &amp;&amp;
4711                    Flags.isStatic(v) &amp;&amp;
4712                    !Flags.isConstant(v) &amp;&amp;
4713                    v.name != names._class;
4714         }
4715 
4716     /**
4717      * Check that method arguments conform to its instantiation.
4718      **/
4719     public Type checkMethod(Type site,
4720                             final Symbol sym,
4721                             ResultInfo resultInfo,
4722                             Env&lt;AttrContext&gt; env,
4723                             final List&lt;JCExpression&gt; argtrees,
4724                             List&lt;Type&gt; argtypes,
4725                             List&lt;Type&gt; typeargtypes) {
4726         // Test (5): if symbol is an instance method of a raw type, issue
4727         // an unchecked warning if its argument types change under erasure.
4728         if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
4729             (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
4730             Type s = types.asOuterSuper(site, sym.owner);
4731             if (s != null &amp;&amp; s.isRaw() &amp;&amp;
4732                 !types.isSameTypes(sym.type.getParameterTypes(),
4733                                    sym.erasure(types).getParameterTypes())) {
4734                 chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedCallMbrOfRawType(sym, s));
4735             }
4736         }
4737 
4738         if (env.info.defaultSuperCallSite != null) {
4739             for (Type sup : types.interfaces(env.enclClass.type).prepend(types.supertype((env.enclClass.type)))) {
4740                 if (!sup.tsym.isSubClass(sym.enclClass(), types) ||
4741                         types.isSameType(sup, env.info.defaultSuperCallSite)) continue;
4742                 List&lt;MethodSymbol&gt; icand_sup =
4743                         types.interfaceCandidates(sup, (MethodSymbol)sym);
4744                 if (icand_sup.nonEmpty() &amp;&amp;
4745                         icand_sup.head != sym &amp;&amp;
4746                         icand_sup.head.overrides(sym, icand_sup.head.enclClass(), types, true)) {
4747                     log.error(env.tree.pos(),
4748                               Errors.IllegalDefaultSuperCall(env.info.defaultSuperCallSite, Fragments.OverriddenDefault(sym, sup)));
4749                     break;
4750                 }
4751             }
4752             env.info.defaultSuperCallSite = null;
4753         }
4754 
4755         if (sym.isStatic() &amp;&amp; site.isInterface() &amp;&amp; env.tree.hasTag(APPLY)) {
4756             JCMethodInvocation app = (JCMethodInvocation)env.tree;
4757             if (app.meth.hasTag(SELECT) &amp;&amp;
4758                     !TreeInfo.isStaticSelector(((JCFieldAccess)app.meth).selected, names)) {
4759                 log.error(env.tree.pos(), Errors.IllegalStaticIntfMethCall(site));
4760             }
4761         }
4762 
4763         // Compute the identifier&#39;s instantiated type.
4764         // For methods, we need to compute the instance type by
4765         // Resolve.instantiate from the symbol&#39;s type as well as
4766         // any type arguments and value arguments.
4767         Warner noteWarner = new Warner();
4768         try {
4769             Type owntype = rs.checkMethod(
4770                     env,
4771                     site,
4772                     sym,
4773                     resultInfo,
4774                     argtypes,
4775                     typeargtypes,
4776                     noteWarner);
4777 
4778             DeferredAttr.DeferredTypeMap&lt;Void&gt; checkDeferredMap =
4779                 deferredAttr.new DeferredTypeMap&lt;&gt;(DeferredAttr.AttrMode.CHECK, sym, env.info.pendingResolutionPhase);
4780 
4781             argtypes = argtypes.map(checkDeferredMap);
4782 
4783             if (noteWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
4784                 chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedMethInvocationApplied(kindName(sym),
4785                         sym.name,
4786                         rs.methodArguments(sym.type.getParameterTypes()),
4787                         rs.methodArguments(argtypes.map(checkDeferredMap)),
4788                         kindName(sym.location()),
4789                         sym.location()));
4790                 if (resultInfo.pt != Infer.anyPoly ||
4791                         !owntype.hasTag(METHOD) ||
4792                         !owntype.isPartial()) {
4793                     //if this is not a partially inferred method type, erase return type. Otherwise,
4794                     //erasure is carried out in PartiallyInferredMethodType.check().
4795                     owntype = new MethodType(owntype.getParameterTypes(),
4796                             types.erasure(owntype.getReturnType()),
4797                             types.erasure(owntype.getThrownTypes()),
4798                             syms.methodClass);
4799                 }
4800             }
4801 
4802             PolyKind pkind = (sym.type.hasTag(FORALL) &amp;&amp;
4803                  sym.type.getReturnType().containsAny(((ForAll)sym.type).tvars)) ?
4804                  PolyKind.POLY : PolyKind.STANDALONE;
4805             TreeInfo.setPolyKind(env.tree, pkind);
4806 
4807             return (resultInfo.pt == Infer.anyPoly) ?
4808                     owntype :
4809                     chk.checkMethod(owntype, sym, env, argtrees, argtypes, env.info.lastResolveVarargs(),
4810                             resultInfo.checkContext.inferenceContext());
4811         } catch (Infer.InferenceException ex) {
4812             //invalid target type - propagate exception outwards or report error
4813             //depending on the current check context
4814             resultInfo.checkContext.report(env.tree.pos(), ex.getDiagnostic());
4815             return types.createErrorType(site);
4816         } catch (Resolve.InapplicableMethodException ex) {
4817             final JCDiagnostic diag = ex.getDiagnostic();
4818             Resolve.InapplicableSymbolError errSym = rs.new InapplicableSymbolError(null) {
4819                 @Override
4820                 protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4821                     return new Pair&lt;&gt;(sym, diag);
4822                 }
4823             };
4824             List&lt;Type&gt; argtypes2 = argtypes.map(
4825                     rs.new ResolveDeferredRecoveryMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));
4826             JCDiagnostic errDiag = errSym.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
4827                     env.tree, sym, site, sym.name, argtypes2, typeargtypes);
4828             log.report(errDiag);
4829             return types.createErrorType(site);
4830         }
4831     }
4832 
4833     public void visitLiteral(JCLiteral tree) {
4834         result = check(tree, litType(tree.typetag).constType(tree.value),
4835                 KindSelector.VAL, resultInfo);
4836     }
4837     //where
4838     /** Return the type of a literal with given type tag.
4839      */
4840     Type litType(TypeTag tag) {
4841         return (tag == CLASS) ? syms.stringType : syms.typeOfTag[tag.ordinal()];
4842     }
4843 
4844     public void visitTypeIdent(JCPrimitiveTypeTree tree) {
4845         result = check(tree, syms.typeOfTag[tree.typetag.ordinal()], KindSelector.TYP, resultInfo);
4846     }
4847 
4848     public void visitTypeArray(JCArrayTypeTree tree) {
4849         Type etype = attribType(tree.elemtype, env);
4850         Type type = new ArrayType(etype, syms.arrayClass);
4851         result = check(tree, type, KindSelector.TYP, resultInfo);
4852     }
4853 
4854     /** Visitor method for parameterized types.
4855      *  Bound checking is left until later, since types are attributed
4856      *  before supertype structure is completely known
4857      */
4858     public void visitTypeApply(JCTypeApply tree) {
4859         Type owntype = types.createErrorType(tree.type);
4860 
4861         // Attribute functor part of application and make sure it&#39;s a class.
4862         Type clazztype = chk.checkClassType(tree.clazz.pos(), attribType(tree.clazz, env));
4863 
4864         // Attribute type parameters
4865         List&lt;Type&gt; actuals = attribTypes(tree.arguments, env);
4866 
4867         if (clazztype.hasTag(CLASS)) {
4868             List&lt;Type&gt; formals = clazztype.tsym.type.getTypeArguments();
4869             if (actuals.isEmpty()) //diamond
4870                 actuals = formals;
4871 
4872             if (actuals.length() == formals.length()) {
4873                 List&lt;Type&gt; a = actuals;
4874                 List&lt;Type&gt; f = formals;
4875                 while (a.nonEmpty()) {
4876                     a.head = a.head.withTypeVar(f.head);
4877                     a = a.tail;
4878                     f = f.tail;
4879                 }
4880                 // Compute the proper generic outer
4881                 Type clazzOuter = clazztype.getEnclosingType();
4882                 if (clazzOuter.hasTag(CLASS)) {
4883                     Type site;
4884                     JCExpression clazz = TreeInfo.typeIn(tree.clazz);
4885                     if (clazz.hasTag(IDENT)) {
4886                         site = env.enclClass.sym.type;
4887                     } else if (clazz.hasTag(SELECT)) {
4888                         site = ((JCFieldAccess) clazz).selected.type;
4889                     } else throw new AssertionError(&quot;&quot;+tree);
4890                     if (clazzOuter.hasTag(CLASS) &amp;&amp; site != clazzOuter) {
4891                         if (site.hasTag(CLASS))
4892                             site = types.asOuterSuper(site, clazzOuter.tsym);
4893                         if (site == null)
4894                             site = types.erasure(clazzOuter);
4895                         clazzOuter = site;
4896                     }
4897                 }
4898                 owntype = new ClassType(clazzOuter, actuals, clazztype.tsym,
4899                                         clazztype.getMetadata());
4900             } else {
4901                 if (formals.length() != 0) {
4902                     log.error(tree.pos(),
4903                               Errors.WrongNumberTypeArgs(Integer.toString(formals.length())));
4904                 } else {
4905                     log.error(tree.pos(), Errors.TypeDoesntTakeParams(clazztype.tsym));
4906                 }
4907                 owntype = types.createErrorType(tree.type);
4908             }
4909         }
4910         result = check(tree, owntype, KindSelector.TYP, resultInfo);
4911     }
4912 
4913     public void visitTypeUnion(JCTypeUnion tree) {
4914         ListBuffer&lt;Type&gt; multicatchTypes = new ListBuffer&lt;&gt;();
4915         ListBuffer&lt;Type&gt; all_multicatchTypes = null; // lazy, only if needed
4916         for (JCExpression typeTree : tree.alternatives) {
4917             Type ctype = attribType(typeTree, env);
4918             ctype = chk.checkType(typeTree.pos(),
4919                           chk.checkClassType(typeTree.pos(), ctype),
4920                           syms.throwableType);
4921             if (!ctype.isErroneous()) {
4922                 //check that alternatives of a union type are pairwise
4923                 //unrelated w.r.t. subtyping
4924                 if (chk.intersects(ctype,  multicatchTypes.toList())) {
4925                     for (Type t : multicatchTypes) {
4926                         boolean sub = types.isSubtype(ctype, t);
4927                         boolean sup = types.isSubtype(t, ctype);
4928                         if (sub || sup) {
4929                             //assume &#39;a&#39; &lt;: &#39;b&#39;
4930                             Type a = sub ? ctype : t;
4931                             Type b = sub ? t : ctype;
4932                             log.error(typeTree.pos(), Errors.MulticatchTypesMustBeDisjoint(a, b));
4933                         }
4934                     }
4935                 }
4936                 multicatchTypes.append(ctype);
4937                 if (all_multicatchTypes != null)
4938                     all_multicatchTypes.append(ctype);
4939             } else {
4940                 if (all_multicatchTypes == null) {
4941                     all_multicatchTypes = new ListBuffer&lt;&gt;();
4942                     all_multicatchTypes.appendList(multicatchTypes);
4943                 }
4944                 all_multicatchTypes.append(ctype);
4945             }
4946         }
4947         Type t = check(tree, types.lub(multicatchTypes.toList()),
4948                 KindSelector.TYP, resultInfo.dup(CheckMode.NO_TREE_UPDATE));
4949         if (t.hasTag(CLASS)) {
4950             List&lt;Type&gt; alternatives =
4951                 ((all_multicatchTypes == null) ? multicatchTypes : all_multicatchTypes).toList();
4952             t = new UnionClassType((ClassType) t, alternatives);
4953         }
4954         tree.type = result = t;
4955     }
4956 
4957     public void visitTypeIntersection(JCTypeIntersection tree) {
4958         attribTypes(tree.bounds, env);
4959         tree.type = result = checkIntersection(tree, tree.bounds);
4960     }
4961 
4962     public void visitTypeParameter(JCTypeParameter tree) {
4963         TypeVar typeVar = (TypeVar) tree.type;
4964 
4965         if (tree.annotations != null &amp;&amp; tree.annotations.nonEmpty()) {
4966             annotate.annotateTypeParameterSecondStage(tree, tree.annotations);
4967         }
4968 
4969         if (!typeVar.getUpperBound().isErroneous()) {
4970             //fixup type-parameter bound computed in &#39;attribTypeVariables&#39;
4971             typeVar.setUpperBound(checkIntersection(tree, tree.bounds));
4972         }
4973     }
4974 
4975     Type checkIntersection(JCTree tree, List&lt;JCExpression&gt; bounds) {
4976         Set&lt;Type&gt; boundSet = new HashSet&lt;&gt;();
4977         if (bounds.nonEmpty()) {
4978             // accept class or interface or typevar as first bound.
4979             bounds.head.type = checkBase(bounds.head.type, bounds.head, env, false, false, false);
4980             boundSet.add(types.erasure(bounds.head.type));
4981             if (bounds.head.type.isErroneous()) {
4982                 return bounds.head.type;
4983             }
4984             else if (bounds.head.type.hasTag(TYPEVAR)) {
4985                 // if first bound was a typevar, do not accept further bounds.
4986                 if (bounds.tail.nonEmpty()) {
4987                     log.error(bounds.tail.head.pos(),
4988                               Errors.TypeVarMayNotBeFollowedByOtherBounds);
4989                     return bounds.head.type;
4990                 }
4991             } else {
4992                 // if first bound was a class or interface, accept only interfaces
4993                 // as further bounds.
4994                 for (JCExpression bound : bounds.tail) {
4995                     bound.type = checkBase(bound.type, bound, env, false, true, false);
4996                     if (bound.type.isErroneous()) {
4997                         bounds = List.of(bound);
4998                     }
4999                     else if (bound.type.hasTag(CLASS)) {
5000                         chk.checkNotRepeated(bound.pos(), types.erasure(bound.type), boundSet);
5001                     }
5002                 }
5003             }
5004         }
5005 
5006         if (bounds.length() == 0) {
5007             return syms.objectType;
5008         } else if (bounds.length() == 1) {
5009             return bounds.head.type;
5010         } else {
5011             Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));
5012             // ... the variable&#39;s bound is a class type flagged COMPOUND
5013             // (see comment for TypeVar.bound).
5014             // In this case, generate a class tree that represents the
5015             // bound class, ...
5016             JCExpression extending;
5017             List&lt;JCExpression&gt; implementing;
5018             if (!bounds.head.type.isInterface()) {
5019                 extending = bounds.head;
5020                 implementing = bounds.tail;
5021             } else {
5022                 extending = null;
5023                 implementing = bounds;
5024             }
5025             JCClassDecl cd = make.at(tree).ClassDef(
5026                 make.Modifiers(PUBLIC | ABSTRACT | (extending != null &amp;&amp; TreeInfo.symbol(extending).isValue() ? VALUE : 0)),
5027                 names.empty, List.nil(),
5028                 extending, implementing, List.nil());
5029 
5030             ClassSymbol c = (ClassSymbol)owntype.tsym;
5031             Assert.check((c.flags() &amp; COMPOUND) != 0);
5032             cd.sym = c;
5033             c.sourcefile = env.toplevel.sourcefile;
5034 
5035             // ... and attribute the bound class
5036             c.flags_field |= UNATTRIBUTED;
5037             Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);
5038             typeEnvs.put(c, cenv);
5039             attribClass(c);
5040             return owntype;
5041         }
5042     }
5043 
5044     public void visitWildcard(JCWildcard tree) {
5045         //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
5046         Type type = (tree.kind.kind == BoundKind.UNBOUND)
5047             ? syms.objectType
5048             : attribType(tree.inner, env);
5049         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),
5050                                               tree.kind.kind,
5051                                               syms.boundClass),
5052                 KindSelector.TYP, resultInfo);
5053     }
5054 
5055     public void visitAnnotation(JCAnnotation tree) {
5056         Assert.error(&quot;should be handled in annotate&quot;);
5057     }
5058 
5059     public void visitAnnotatedType(JCAnnotatedType tree) {
5060         attribAnnotationTypes(tree.annotations, env);
5061         Type underlyingType = attribType(tree.underlyingType, env);
5062         Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);
5063 
5064         if (!env.info.isNewClass)
5065             annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
5066         result = tree.type = annotatedType;
5067     }
5068 
5069     public void visitErroneous(JCErroneous tree) {
5070         if (tree.errs != null)
5071             for (JCTree err : tree.errs)
5072                 attribTree(err, env, new ResultInfo(KindSelector.ERR, pt()));
5073         result = tree.type = syms.errType;
5074     }
5075 
5076     /** Default visitor method for all other trees.
5077      */
5078     public void visitTree(JCTree tree) {
5079         throw new AssertionError();
5080     }
5081 
5082     /**
5083      * Attribute an env for either a top level tree or class or module declaration.
5084      */
5085     public void attrib(Env&lt;AttrContext&gt; env) {
5086         switch (env.tree.getTag()) {
5087             case MODULEDEF:
5088                 attribModule(env.tree.pos(), ((JCModuleDecl)env.tree).sym);
5089                 break;
5090             case TOPLEVEL:
5091                 attribTopLevel(env);
5092                 break;
5093             case PACKAGEDEF:
5094                 attribPackage(env.tree.pos(), ((JCPackageDecl) env.tree).packge);
5095                 break;
5096             default:
5097                 attribClass(env.tree.pos(), env.enclClass.sym);
5098         }
5099     }
5100 
5101     /**
5102      * Attribute a top level tree. These trees are encountered when the
5103      * package declaration has annotations.
5104      */
5105     public void attribTopLevel(Env&lt;AttrContext&gt; env) {
5106         JCCompilationUnit toplevel = env.toplevel;
5107         try {
5108             annotate.flush();
5109         } catch (CompletionFailure ex) {
5110             chk.completionError(toplevel.pos(), ex);
5111         }
5112     }
5113 
5114     public void attribPackage(DiagnosticPosition pos, PackageSymbol p) {
5115         try {
5116             annotate.flush();
5117             attribPackage(p);
5118         } catch (CompletionFailure ex) {
5119             chk.completionError(pos, ex);
5120         }
5121     }
5122 
5123     void attribPackage(PackageSymbol p) {
5124         Env&lt;AttrContext&gt; env = typeEnvs.get(p);
5125         chk.checkDeprecatedAnnotation(((JCPackageDecl) env.tree).pid.pos(), p);
5126     }
5127 
5128     public void attribModule(DiagnosticPosition pos, ModuleSymbol m) {
5129         try {
5130             annotate.flush();
5131             attribModule(m);
5132         } catch (CompletionFailure ex) {
5133             chk.completionError(pos, ex);
5134         }
5135     }
5136 
5137     void attribModule(ModuleSymbol m) {
5138         // Get environment current at the point of module definition.
5139         Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
5140         attribStat(env.tree, env);
5141     }
5142 
5143     /** Main method: attribute class definition associated with given class symbol.
5144      *  reporting completion failures at the given position.
5145      *  @param pos The source position at which completion errors are to be
5146      *             reported.
5147      *  @param c   The class symbol whose definition will be attributed.
5148      */
5149     public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
5150         try {
5151             annotate.flush();
5152             attribClass(c);
5153             if (types.isValue(c.type)) {
5154                 final Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5155                 if (!allowValueMemberCycles) {
5156                     if (env != null &amp;&amp; env.tree != null &amp;&amp; env.tree.hasTag(CLASSDEF))
5157                         chk.checkNonCyclicMembership((JCClassDecl)env.tree);
5158                 }
5159             }
5160         } catch (CompletionFailure ex) {
5161             chk.completionError(pos, ex);
5162         }
5163     }
5164 
5165     /** Attribute class definition associated with given class symbol.
5166      *  @param c   The class symbol whose definition will be attributed.
5167      */
5168     void attribClass(ClassSymbol c) throws CompletionFailure {
5169         if (c.type.hasTag(ERROR)) return;
5170 
5171         // Check for cycles in the inheritance graph, which can arise from
5172         // ill-formed class files.
5173         chk.checkNonCyclic(null, c.type);
5174 
5175         Type st = types.supertype(c.type);
5176         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5177             // First, attribute superclass.
5178             if (st.hasTag(CLASS))
5179                 attribClass((ClassSymbol)st.tsym);
5180 
5181             // Next attribute owner, if it is a class.
5182             if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))
5183                 attribClass((ClassSymbol)c.owner);
5184         }
5185 
5186         // The previous operations might have attributed the current class
5187         // if there was a cycle. So we test first whether the class is still
5188         // UNATTRIBUTED.
5189         if ((c.flags_field &amp; UNATTRIBUTED) != 0) {
5190             c.flags_field &amp;= ~UNATTRIBUTED;
5191 
5192             // Get environment current at the point of class definition.
5193             Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5194 
5195             if (c.isSealed() &amp;&amp;
5196                     !c.isEnum() &amp;&amp;
5197                     !c.isPermittedExplicit &amp;&amp;
5198                     c.permitted.isEmpty()) {
5199                 log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.SealedClassMustHaveSubclasses);
5200             }
5201 
5202             if (c.isSealed()) {
5203                 Set&lt;Symbol&gt; permittedTypes = new HashSet&lt;&gt;();
5204                 boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;
5205                 for (Symbol subTypeSym : c.permitted) {
5206                     boolean isTypeVar = false;
5207                     if (subTypeSym.type.getTag() == TYPEVAR) {
5208                         isTypeVar = true; //error recovery
5209                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),
5210                                 Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));
5211                     }
5212                     if (subTypeSym.isAnonymous() &amp;&amp; !c.isEnum()) {
5213                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5214                     }
5215                     if (permittedTypes.contains(subTypeSym)) {
5216                         DiagnosticPosition pos =
5217                                 env.enclClass.permitting.stream()
5218                                         .filter(permittedExpr -&gt; TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)
5219                                         .limit(2).collect(List.collector()).get(1);
5220                         log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));
5221                     } else {
5222                         permittedTypes.add(subTypeSym);
5223                     }
5224                     if (sealedInUnnamed) {
5225                         if (subTypeSym.packge() != c.packge()) {
5226                             log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5227                         }
5228                     } else if (subTypeSym.packge().modle != c.packge().modle) {
5229                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5230                     }
5231                     if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {
5232                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),
5233                                 Errors.InvalidPermitsClause(
5234                                         subTypeSym == c.type.tsym ?
5235                                                 Fragments.MustNotBeSameClass :
5236                                                 Fragments.MustNotBeSupertype(subTypeSym.type)
5237                                 )
5238                         );
5239                     } else if (!isTypeVar) {
5240                         boolean thisIsASuper = types.directSupertypes(subTypeSym.type)
5241                                                     .stream()
5242                                                     .anyMatch(d -&gt; d.tsym == c);
5243                         if (!thisIsASuper) {
5244                             log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),
5245                                     Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));
5246                         }
5247                     }
5248                 }
5249             }
5250 
5251             List&lt;ClassSymbol&gt; sealedSupers = types.directSupertypes(c.type)
5252                                                   .stream()
5253                                                   .filter(s -&gt; s.tsym.isSealed())
5254                                                   .map(s -&gt; (ClassSymbol) s.tsym)
5255                                                   .collect(List.collector());
5256 
5257             if (sealedSupers.isEmpty()) {
5258                 if ((c.flags_field &amp; Flags.NON_SEALED) != 0) {
5259                     boolean hasErrorSuper = types.directSupertypes(c.type)
5260                                                  .stream()
5261                                                  .anyMatch(s -&gt; s.tsym.kind == Kind.ERR);
5262                     if (!hasErrorSuper) {
5263                         log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));
5264                     }
5265                 }
5266             } else if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5267                 if (c.isLocal() &amp;&amp; !c.isEnum()) {
5268                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed);
5269                 }
5270 
5271                 for (ClassSymbol supertypeSym : sealedSupers) {
5272                     if (!supertypeSym.permitted.contains(c.type.tsym)) {
5273                         log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));
5274                     }
5275                 }
5276                 if (!c.isNonSealed() &amp;&amp; !c.isFinal() &amp;&amp; !c.isSealed()) {
5277                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree),
5278                             c.isInterface() ?
5279                                     Errors.NonSealedOrSealedExpected :
5280                                     Errors.NonSealedSealedOrFinalExpected);
5281                 }
5282             }
5283 
5284             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5285             // because the annotations were not available at the time the env was created. Therefore,
5286             // we look up the environment chain for the first enclosing environment for which the
5287             // lint value is set. Typically, this is the parent env, but might be further if there
5288             // are any envs created as a result of TypeParameter nodes.
5289             Env&lt;AttrContext&gt; lintEnv = env;
5290             while (lintEnv.info.lint == null)
5291                 lintEnv = lintEnv.next;
5292 
5293             // Having found the enclosing lint value, we can initialize the lint value for this class
5294             env.info.lint = lintEnv.info.lint.augment(c);
5295 
5296             Lint prevLint = chk.setLint(env.info.lint);
5297             JavaFileObject prev = log.useSource(c.sourcefile);
5298             ResultInfo prevReturnRes = env.info.returnResult;
5299 
5300             try {
5301                 deferredLintHandler.flush(env.tree);
5302                 env.info.returnResult = null;
5303                 // java.lang.Enum may not be subclassed by a non-enum
5304                 if (st.tsym == syms.enumSym &amp;&amp;
5305                     ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))
5306                     log.error(env.tree.pos(), Errors.EnumNoSubclassing);
5307 
5308                 // Enums may not be extended by source-level classes
5309                 if (st.tsym != null &amp;&amp;
5310                     ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;
5311                     ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {
5312                     log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);
5313                 }
5314 
5315                 if (isSerializable(c.type)) {
5316                     env.info.isSerializable = true;
5317                 }
5318 
5319                 attribClassBody(env, c);
5320 
5321                 if ((c.flags() &amp; (VALUE | ABSTRACT)) == VALUE) { // for non-intersection, concrete values.
5322                     Assert.check(env.tree.hasTag(CLASSDEF));
5323                     JCClassDecl classDecl = (JCClassDecl) env.tree;
5324                     if (classDecl.extending != null) {
5325                         chk.checkConstraintsOfInlineSuper(env.tree.pos(), c);
5326                     }
5327                 }
5328 
5329                 chk.checkDeprecatedAnnotation(env.tree.pos(), c);
5330                 chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
5331                 chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
5332                 chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);
5333             } finally {
5334                 env.info.returnResult = prevReturnRes;
5335                 log.useSource(prev);
5336                 chk.setLint(prevLint);
5337             }
5338 
5339         }
5340     }
5341 
5342     public void visitImport(JCImport tree) {
5343         // nothing to do
5344     }
5345 
5346     public void visitModuleDef(JCModuleDecl tree) {
5347         tree.sym.completeUsesProvides();
5348         ModuleSymbol msym = tree.sym;
5349         Lint lint = env.outer.info.lint = env.outer.info.lint.augment(msym);
5350         Lint prevLint = chk.setLint(lint);
5351         chk.checkModuleName(tree);
5352         chk.checkDeprecatedAnnotation(tree, msym);
5353 
5354         try {
5355             deferredLintHandler.flush(tree.pos());
5356         } finally {
5357             chk.setLint(prevLint);
5358         }
5359     }
5360 
5361     /** Finish the attribution of a class. */
5362     private void attribClassBody(Env&lt;AttrContext&gt; env, ClassSymbol c) {
5363         JCClassDecl tree = (JCClassDecl)env.tree;
5364         Assert.check(c == tree.sym);
5365 
5366         // Validate type parameters, supertype and interfaces.
5367         attribStats(tree.typarams, env);
5368         if (!c.isAnonymous()) {
5369             //already checked if anonymous
5370             chk.validate(tree.typarams, env);
5371             chk.validate(tree.extending, env);
5372             chk.validate(tree.implementing, env);
5373         }
5374 
5375         c.markAbstractIfNeeded(types);
5376 
5377         // If this is a non-abstract class, check that it has no abstract
5378         // methods or unimplemented methods of an implemented interface.
5379         if ((c.flags() &amp; (ABSTRACT | INTERFACE)) == 0) {
5380             chk.checkAllDefined(tree.pos(), c);
5381         }
5382 
5383         if ((c.flags() &amp; ANNOTATION) != 0) {
5384             if (tree.implementing.nonEmpty())
5385                 log.error(tree.implementing.head.pos(),
5386                           Errors.CantExtendIntfAnnotation);
5387             if (tree.typarams.nonEmpty()) {
5388                 log.error(tree.typarams.head.pos(),
5389                           Errors.IntfAnnotationCantHaveTypeParams(c));
5390             }
5391 
5392             // If this annotation type has a @Repeatable, validate
5393             Attribute.Compound repeatable = c.getAnnotationTypeMetadata().getRepeatable();
5394             // If this annotation type has a @Repeatable, validate
5395             if (repeatable != null) {
5396                 // get diagnostic position for error reporting
5397                 DiagnosticPosition cbPos = getDiagnosticPosition(tree, repeatable.type);
5398                 Assert.checkNonNull(cbPos);
5399 
5400                 chk.validateRepeatable(c, repeatable, cbPos);
5401             }
5402         } else {
5403             // Check that all extended classes and interfaces
5404             // are compatible (i.e. no two define methods with same arguments
5405             // yet different return types).  (JLS 8.4.6.3)
5406             chk.checkCompatibleSupertypes(tree.pos(), c.type);
5407             if (allowDefaultMethods) {
5408                 chk.checkDefaultMethodClashes(tree.pos(), c.type);
5409             }
5410         }
5411 
5412         // Check that class does not import the same parameterized interface
5413         // with two different argument lists.
5414         chk.checkClassBounds(tree.pos(), c.type);
5415 
5416         tree.type = c.type;
5417 
5418         for (List&lt;JCTypeParameter&gt; l = tree.typarams;
5419              l.nonEmpty(); l = l.tail) {
5420              Assert.checkNonNull(env.info.scope.findFirst(l.head.name));
5421         }
5422 
5423         // Check that a generic class doesn&#39;t extend Throwable
5424         if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))
5425             log.error(tree.extending.pos(), Errors.GenericThrowable);
5426 
5427         // Check that all methods which implement some
5428         // method conform to the method they implement.
5429         chk.checkImplementations(tree);
5430 
5431         //check that a resource implementing AutoCloseable cannot throw InterruptedException
5432         checkAutoCloseable(tree.pos(), env, c.type);
5433 
5434         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
5435             // Attribute declaration
5436             attribStat(l.head, env);
5437             // Check that declarations in inner classes are not static (JLS 8.1.2)
5438             // Make an exception for static constants.
5439             if (c.owner.kind != PCK &amp;&amp;
5440                 ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
5441                 (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
5442                 Symbol sym = null;
5443                 if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
5444                 if (sym == null ||
5445                     sym.kind != VAR ||
5446                     ((VarSymbol) sym).getConstValue() == null)
5447                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5448             }
5449         }
5450 
5451         // Check for cycles among non-initial constructors.
5452         chk.checkCyclicConstructors(tree);
5453 
5454         // Check for cycles among annotation elements.
5455         chk.checkNonCyclicElements(tree);
5456 
5457         // Check for proper use of serialVersionUID
5458         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5459                 &amp;&amp; isSerializable(c.type)
5460                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5461                 &amp;&amp; !c.isAnonymous()) {
5462             checkSerialVersionUID(tree, c);
5463         }
5464         if (allowTypeAnnos) {
5465             // Correctly organize the positions of the type annotations
5466             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5467 
5468             // Check type annotations applicability rules
5469             validateTypeAnnotations(tree, false);
5470         }
5471     }
5472         // where
5473         /** get a diagnostic position for an attribute of Type t, or null if attribute missing */
5474         private DiagnosticPosition getDiagnosticPosition(JCClassDecl tree, Type t) {
5475             for(List&lt;JCAnnotation&gt; al = tree.mods.annotations; !al.isEmpty(); al = al.tail) {
5476                 if (types.isSameType(al.head.annotationType.type, t))
5477                     return al.head.pos();
5478             }
5479 
5480             return null;
5481         }
5482 
5483         /** check if a type is a subtype of Serializable, if that is available. */
5484         boolean isSerializable(Type t) {
5485             try {
5486                 syms.serializableType.complete();
5487             }
5488             catch (CompletionFailure e) {
5489                 return false;
5490             }
5491             return types.isSubtype(t, syms.serializableType);
5492         }
5493 
5494         /** Check that an appropriate serialVersionUID member is defined. */
5495         private void checkSerialVersionUID(JCClassDecl tree, ClassSymbol c) {
5496 
5497             // check for presence of serialVersionUID
5498             VarSymbol svuid = null;
5499             for (Symbol sym : c.members().getSymbolsByName(names.serialVersionUID)) {
5500                 if (sym.kind == VAR) {
5501                     svuid = (VarSymbol)sym;
5502                     break;
5503                 }
5504             }
5505 
5506             if (svuid == null) {
5507                 log.warning(LintCategory.SERIAL,
5508                         tree.pos(), Warnings.MissingSVUID(c));
5509                 return;
5510             }
5511 
5512             // check that it is static final
5513             if ((svuid.flags() &amp; (STATIC | FINAL)) !=
5514                 (STATIC | FINAL))
5515                 log.warning(LintCategory.SERIAL,
5516                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ImproperSVUID(c));
5517 
5518             // check that it is long
5519             else if (!svuid.type.hasTag(LONG))
5520                 log.warning(LintCategory.SERIAL,
5521                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.LongSVUID(c));
5522 
5523             // check constant
5524             else if (svuid.getConstValue() == null)
5525                 log.warning(LintCategory.SERIAL,
5526                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ConstantSVUID(c));
5527         }
5528 
5529     private Type capture(Type type) {
5530         return types.capture(type);
5531     }
5532 
5533     private void setSyntheticVariableType(JCVariableDecl tree, Type type) {
5534         if (type.isErroneous()) {
5535             tree.vartype = make.at(Position.NOPOS).Erroneous();
5536         } else {
5537             tree.vartype = make.at(Position.NOPOS).Type(type);
5538         }
5539     }
5540 
5541     public void validateTypeAnnotations(JCTree tree, boolean sigOnly) {
5542         tree.accept(new TypeAnnotationsValidator(sigOnly));
5543     }
5544     //where
5545     private final class TypeAnnotationsValidator extends TreeScanner {
5546 
5547         private final boolean sigOnly;
5548         public TypeAnnotationsValidator(boolean sigOnly) {
5549             this.sigOnly = sigOnly;
5550         }
5551 
5552         public void visitAnnotation(JCAnnotation tree) {
5553             chk.validateTypeAnnotation(tree, false);
5554             super.visitAnnotation(tree);
5555         }
5556         public void visitAnnotatedType(JCAnnotatedType tree) {
5557             if (!tree.underlyingType.type.isErroneous()) {
5558                 super.visitAnnotatedType(tree);
5559             }
5560         }
5561         public void visitTypeParameter(JCTypeParameter tree) {
5562             chk.validateTypeAnnotations(tree.annotations, true);
5563             scan(tree.bounds);
5564             // Don&#39;t call super.
5565             // This is needed because above we call validateTypeAnnotation with
5566             // false, which would forbid annotations on type parameters.
5567             // super.visitTypeParameter(tree);
5568         }
5569         public void visitMethodDef(JCMethodDecl tree) {
5570             if (tree.recvparam != null &amp;&amp;
5571                     !tree.recvparam.vartype.type.isErroneous()) {
5572                 checkForDeclarationAnnotations(tree.recvparam.mods.annotations,
5573                         tree.recvparam.vartype.type.tsym);
5574             }
5575             if (tree.restype != null &amp;&amp; tree.restype.type != null) {
5576                 validateAnnotatedType(tree.restype, tree.restype.type);
5577             }
5578             if (sigOnly) {
5579                 scan(tree.mods);
5580                 scan(tree.restype);
5581                 scan(tree.typarams);
5582                 scan(tree.recvparam);
5583                 scan(tree.params);
5584                 scan(tree.thrown);
5585             } else {
5586                 scan(tree.defaultValue);
5587                 scan(tree.body);
5588             }
5589         }
5590         public void visitVarDef(final JCVariableDecl tree) {
5591             //System.err.println(&quot;validateTypeAnnotations.visitVarDef &quot; + tree);
5592             if (tree.sym != null &amp;&amp; tree.sym.type != null &amp;&amp; !tree.isImplicitlyTyped())
5593                 validateAnnotatedType(tree.vartype, tree.sym.type);
5594             scan(tree.mods);
5595             scan(tree.vartype);
5596             if (!sigOnly) {
5597                 scan(tree.init);
5598             }
5599         }
5600         public void visitTypeCast(JCTypeCast tree) {
5601             if (tree.clazz != null &amp;&amp; tree.clazz.type != null)
5602                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5603             super.visitTypeCast(tree);
5604         }
5605         public void visitTypeTest(JCInstanceOf tree) {
5606             if (tree.pattern != null &amp;&amp; !(tree.pattern instanceof JCPattern) &amp;&amp; tree.pattern.type != null)
5607                 validateAnnotatedType(tree.pattern, tree.pattern.type);
5608             super.visitTypeTest(tree);
5609         }
5610         public void visitNewClass(JCNewClass tree) {
5611             if (tree.clazz != null &amp;&amp; tree.clazz.type != null) {
5612                 if (tree.clazz.hasTag(ANNOTATED_TYPE)) {
5613                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.clazz).annotations,
5614                             tree.clazz.type.tsym);
5615                 }
5616                 if (tree.def != null) {
5617                     checkForDeclarationAnnotations(tree.def.mods.annotations, tree.clazz.type.tsym);
5618                 }
5619 
5620                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5621             }
5622             super.visitNewClass(tree);
5623         }
5624         public void visitNewArray(JCNewArray tree) {
5625             if (tree.elemtype != null &amp;&amp; tree.elemtype.type != null) {
5626                 if (tree.elemtype.hasTag(ANNOTATED_TYPE)) {
5627                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.elemtype).annotations,
5628                             tree.elemtype.type.tsym);
5629                 }
5630                 validateAnnotatedType(tree.elemtype, tree.elemtype.type);
5631             }
5632             super.visitNewArray(tree);
5633         }
5634         public void visitClassDef(JCClassDecl tree) {
5635             //System.err.println(&quot;validateTypeAnnotations.visitClassDef &quot; + tree);
5636             if (sigOnly) {
5637                 scan(tree.mods);
5638                 scan(tree.typarams);
5639                 scan(tree.extending);
5640                 scan(tree.implementing);
5641             }
5642             for (JCTree member : tree.defs) {
5643                 if (member.hasTag(Tag.CLASSDEF)) {
5644                     continue;
5645                 }
5646                 scan(member);
5647             }
5648         }
5649         public void visitBlock(JCBlock tree) {
5650             if (!sigOnly) {
5651                 scan(tree.stats);
5652             }
5653         }
5654 
5655         /* I would want to model this after
5656          * com.sun.tools.javac.comp.Check.Validator.visitSelectInternal(JCFieldAccess)
5657          * and override visitSelect and visitTypeApply.
5658          * However, we only set the annotated type in the top-level type
5659          * of the symbol.
5660          * Therefore, we need to override each individual location where a type
5661          * can occur.
5662          */
5663         private void validateAnnotatedType(final JCTree errtree, final Type type) {
5664             //System.err.println(&quot;Attr.validateAnnotatedType: &quot; + errtree + &quot; type: &quot; + type);
5665 
5666             if (type.isPrimitiveOrVoid()) {
5667                 return;
5668             }
5669 
5670             JCTree enclTr = errtree;
5671             Type enclTy = type;
5672 
5673             boolean repeat = true;
5674             while (repeat) {
5675                 if (enclTr.hasTag(TYPEAPPLY)) {
5676                     List&lt;Type&gt; tyargs = enclTy.getTypeArguments();
5677                     List&lt;JCExpression&gt; trargs = ((JCTypeApply)enclTr).getTypeArguments();
5678                     if (trargs.length() &gt; 0) {
5679                         // Nothing to do for diamonds
5680                         if (tyargs.length() == trargs.length()) {
5681                             for (int i = 0; i &lt; tyargs.length(); ++i) {
5682                                 validateAnnotatedType(trargs.get(i), tyargs.get(i));
5683                             }
5684                         }
5685                         // If the lengths don&#39;t match, it&#39;s either a diamond
5686                         // or some nested type that redundantly provides
5687                         // type arguments in the tree.
5688                     }
5689 
5690                     // Look at the clazz part of a generic type
5691                     enclTr = ((JCTree.JCTypeApply)enclTr).clazz;
5692                 }
5693 
5694                 if (enclTr.hasTag(SELECT)) {
5695                     enclTr = ((JCTree.JCFieldAccess)enclTr).getExpression();
5696                     if (enclTy != null &amp;&amp;
5697                             !enclTy.hasTag(NONE)) {
5698                         enclTy = enclTy.getEnclosingType();
5699                     }
5700                 } else if (enclTr.hasTag(ANNOTATED_TYPE)) {
5701                     JCAnnotatedType at = (JCTree.JCAnnotatedType) enclTr;
5702                     if (enclTy == null || enclTy.hasTag(NONE)) {
5703                         if (at.getAnnotations().size() == 1) {
5704                             log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping1(at.getAnnotations().head.attribute));
5705                         } else {
5706                             ListBuffer&lt;Attribute.Compound&gt; comps = new ListBuffer&lt;&gt;();
5707                             for (JCAnnotation an : at.getAnnotations()) {
5708                                 comps.add(an.attribute);
5709                             }
5710                             log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping(comps.toList()));
5711                         }
5712                         repeat = false;
5713                     }
5714                     enclTr = at.underlyingType;
5715                     // enclTy doesn&#39;t need to be changed
5716                 } else if (enclTr.hasTag(IDENT)) {
5717                     repeat = false;
5718                 } else if (enclTr.hasTag(JCTree.Tag.WILDCARD)) {
5719                     JCWildcard wc = (JCWildcard) enclTr;
5720                     if (wc.getKind() == JCTree.Kind.EXTENDS_WILDCARD ||
5721                             wc.getKind() == JCTree.Kind.SUPER_WILDCARD) {
5722                         validateAnnotatedType(wc.getBound(), wc.getBound().type);
5723                     } else {
5724                         // Nothing to do for UNBOUND
5725                     }
5726                     repeat = false;
5727                 } else if (enclTr.hasTag(TYPEARRAY)) {
5728                     JCArrayTypeTree art = (JCArrayTypeTree) enclTr;
5729                     validateAnnotatedType(art.getType(), art.elemtype.type);
5730                     repeat = false;
5731                 } else if (enclTr.hasTag(TYPEUNION)) {
5732                     JCTypeUnion ut = (JCTypeUnion) enclTr;
5733                     for (JCTree t : ut.getTypeAlternatives()) {
5734                         validateAnnotatedType(t, t.type);
5735                     }
5736                     repeat = false;
5737                 } else if (enclTr.hasTag(TYPEINTERSECTION)) {
5738                     JCTypeIntersection it = (JCTypeIntersection) enclTr;
5739                     for (JCTree t : it.getBounds()) {
5740                         validateAnnotatedType(t, t.type);
5741                     }
5742                     repeat = false;
5743                 } else if (enclTr.getKind() == JCTree.Kind.PRIMITIVE_TYPE ||
5744                            enclTr.getKind() == JCTree.Kind.ERRONEOUS) {
5745                     repeat = false;
5746                 } else {
5747                     Assert.error(&quot;Unexpected tree: &quot; + enclTr + &quot; with kind: &quot; + enclTr.getKind() +
5748                             &quot; within: &quot;+ errtree + &quot; with kind: &quot; + errtree.getKind());
5749                 }
5750             }
5751         }
5752 
5753         private void checkForDeclarationAnnotations(List&lt;? extends JCAnnotation&gt; annotations,
5754                 Symbol sym) {
5755             // Ensure that no declaration annotations are present.
5756             // Note that a tree type might be an AnnotatedType with
5757             // empty annotations, if only declaration annotations were given.
5758             // This method will raise an error for such a type.
5759             for (JCAnnotation ai : annotations) {
5760                 if (!ai.type.isErroneous() &amp;&amp;
5761                         typeAnnotations.annotationTargetType(ai.attribute, sym) == TypeAnnotations.AnnotationType.DECLARATION) {
5762                     log.error(ai.pos(), Errors.AnnotationTypeNotApplicableToType(ai.type));
5763                 }
5764             }
5765         }
5766     }
5767 
5768     // &lt;editor-fold desc=&quot;post-attribution visitor&quot;&gt;
5769 
5770     /**
5771      * Handle missing types/symbols in an AST. This routine is useful when
5772      * the compiler has encountered some errors (which might have ended up
5773      * terminating attribution abruptly); if the compiler is used in fail-over
5774      * mode (e.g. by an IDE) and the AST contains semantic errors, this routine
5775      * prevents NPE to be propagated during subsequent compilation steps.
5776      */
5777     public void postAttr(JCTree tree) {
5778         new PostAttrAnalyzer().scan(tree);
5779     }
5780 
5781     class PostAttrAnalyzer extends TreeScanner {
5782 
5783         private void initTypeIfNeeded(JCTree that) {
5784             if (that.type == null) {
5785                 if (that.hasTag(METHODDEF)) {
5786                     that.type = dummyMethodType((JCMethodDecl)that);
5787                 } else {
5788                     that.type = syms.unknownType;
5789                 }
5790             }
5791         }
5792 
5793         /* Construct a dummy method type. If we have a method declaration,
5794          * and the declared return type is void, then use that return type
5795          * instead of UNKNOWN to avoid spurious error messages in lambda
5796          * bodies (see:JDK-8041704).
5797          */
5798         private Type dummyMethodType(JCMethodDecl md) {
5799             Type restype = syms.unknownType;
5800             if (md != null &amp;&amp; md.restype != null &amp;&amp; md.restype.hasTag(TYPEIDENT)) {
5801                 JCPrimitiveTypeTree prim = (JCPrimitiveTypeTree)md.restype;
5802                 if (prim.typetag == VOID)
5803                     restype = syms.voidType;
5804             }
5805             return new MethodType(List.nil(), restype,
5806                                   List.nil(), syms.methodClass);
5807         }
5808         private Type dummyMethodType() {
5809             return dummyMethodType(null);
5810         }
5811 
5812         @Override
5813         public void scan(JCTree tree) {
5814             if (tree == null) return;
5815             if (tree instanceof JCExpression) {
5816                 initTypeIfNeeded(tree);
5817             }
5818             super.scan(tree);
5819         }
5820 
5821         @Override
5822         public void visitIdent(JCIdent that) {
5823             if (that.sym == null) {
5824                 that.sym = syms.unknownSymbol;
5825             }
5826         }
5827 
5828         @Override
5829         public void visitSelect(JCFieldAccess that) {
5830             if (that.sym == null) {
5831                 that.sym = syms.unknownSymbol;
5832             }
5833             super.visitSelect(that);
5834         }
5835 
5836         @Override
5837         public void visitClassDef(JCClassDecl that) {
5838             initTypeIfNeeded(that);
5839             if (that.sym == null) {
5840                 that.sym = new ClassSymbol(0, that.name, that.type, syms.noSymbol);
5841             }
5842             super.visitClassDef(that);
5843         }
5844 
5845         @Override
5846         public void visitMethodDef(JCMethodDecl that) {
5847             initTypeIfNeeded(that);
5848             if (that.sym == null) {
5849                 that.sym = new MethodSymbol(0, that.name, that.type, syms.noSymbol);
5850             }
5851             super.visitMethodDef(that);
5852         }
5853 
5854         @Override
5855         public void visitVarDef(JCVariableDecl that) {
5856             initTypeIfNeeded(that);
5857             if (that.sym == null) {
5858                 that.sym = new VarSymbol(0, that.name, that.type, syms.noSymbol);
5859                 that.sym.adr = 0;
5860             }
5861             if (that.vartype == null) {
5862                 that.vartype = make.at(Position.NOPOS).Erroneous();
5863             }
5864             super.visitVarDef(that);
5865         }
5866 
5867         @Override
5868         public void visitBindingPattern(JCBindingPattern that) {
5869             if (that.symbol == null) {
5870                 that.symbol = new BindingSymbol(that.name, that.type, syms.noSymbol);
5871                 that.symbol.adr = 0;
5872             }
5873             super.visitBindingPattern(that);
5874         }
5875 
5876         @Override
5877         public void visitNewClass(JCNewClass that) {
5878             if (that.constructor == null) {
5879                 that.constructor = new MethodSymbol(0, names.init,
5880                         dummyMethodType(), syms.noSymbol);
5881             }
5882             if (that.constructorType == null) {
5883                 that.constructorType = syms.unknownType;
5884             }
5885             super.visitNewClass(that);
5886         }
5887 
5888         @Override
5889         public void visitAssignop(JCAssignOp that) {
5890             if (that.operator == null) {
5891                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5892                         -1, syms.noSymbol);
5893             }
5894             super.visitAssignop(that);
5895         }
5896 
5897         @Override
5898         public void visitBinary(JCBinary that) {
5899             if (that.operator == null) {
5900                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5901                         -1, syms.noSymbol);
5902             }
5903             super.visitBinary(that);
5904         }
5905 
5906         @Override
5907         public void visitUnary(JCUnary that) {
5908             if (that.operator == null) {
5909                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5910                         -1, syms.noSymbol);
5911             }
5912             super.visitUnary(that);
5913         }
5914 
5915         @Override
5916         public void visitReference(JCMemberReference that) {
5917             super.visitReference(that);
5918             if (that.sym == null) {
5919                 that.sym = new MethodSymbol(0, names.empty, dummyMethodType(),
5920                         syms.noSymbol);
5921             }
5922         }
5923     }
5924     // &lt;/editor-fold&gt;
5925 
5926     public void setPackageSymbols(JCExpression pid, Symbol pkg) {
5927         new TreeScanner() {
5928             Symbol packge = pkg;
5929             @Override
5930             public void visitIdent(JCIdent that) {
5931                 that.sym = packge;
5932             }
5933 
5934             @Override
5935             public void visitSelect(JCFieldAccess that) {
5936                 that.sym = packge;
5937                 packge = packge.owner;
5938                 super.visitSelect(that);
5939             }
5940         }.scan(pid);
5941     }
5942 
5943 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>