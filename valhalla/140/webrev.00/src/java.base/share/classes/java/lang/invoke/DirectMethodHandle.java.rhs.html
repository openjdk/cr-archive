<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.misc.Unsafe;
 29 import jdk.internal.vm.annotation.ForceInline;
 30 import jdk.internal.vm.annotation.Stable;
 31 import sun.invoke.util.ValueConversions;
 32 import sun.invoke.util.VerifyAccess;
 33 import sun.invoke.util.VerifyType;
 34 import sun.invoke.util.Wrapper;
 35 
 36 import java.lang.ref.WeakReference;
 37 import java.util.Arrays;
 38 import java.util.Objects;
 39 
 40 import static java.lang.invoke.LambdaForm.*;
 41 import static java.lang.invoke.LambdaForm.Kind.*;
 42 import static java.lang.invoke.MethodHandleNatives.Constants.*;
 43 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 44 import static java.lang.invoke.MethodHandleStatics.newInternalError;
 45 import static java.lang.invoke.MethodTypeForm.*;
 46 
 47 /**
 48  * The flavor of method handle which implements a constant reference
 49  * to a class member.
 50  * @author jrose
 51  */
 52 class DirectMethodHandle extends MethodHandle {
 53     final MemberName member;
 54     final boolean crackable;
 55 
 56     // Constructors and factory methods in this class *must* be package scoped or private.
 57     private DirectMethodHandle(MethodType mtype, LambdaForm form, MemberName member, boolean crackable) {
 58         super(mtype, form);
 59         if (!member.isResolved())  throw new InternalError();
 60 
 61         if (member.getDeclaringClass().isInterface() &amp;&amp;
 62             member.getReferenceKind() == REF_invokeInterface &amp;&amp;
 63             member.isMethod() &amp;&amp; !member.isAbstract()) {
 64             // Check for corner case: invokeinterface of Object method
 65             MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());
 66             m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);
 67             if (m != null &amp;&amp; m.isPublic()) {
 68                 assert(member.getReferenceKind() == m.getReferenceKind());  // else this.form is wrong
 69                 member = m;
 70             }
 71         }
 72 
 73         this.member = member;
 74         this.crackable = crackable;
 75     }
 76 
 77     // Factory methods:
 78     static DirectMethodHandle make(byte refKind, Class&lt;?&gt; refc, MemberName member, Class&lt;?&gt; callerClass) {
 79         MethodType mtype = member.getMethodOrFieldType();
 80         if (!member.isStatic()) {
 81             if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())
 82                 throw new InternalError(member.toString());
 83             mtype = mtype.insertParameterTypes(0, refc);
 84         }
 85         if (!member.isField()) {
 86             // refKind reflects the original type of lookup via findSpecial or
 87             // findVirtual etc.
 88             switch (refKind) {
 89                 case REF_invokeSpecial: {
 90                     member = member.asSpecial();
 91                     // if caller is an interface we need to adapt to get the
 92                     // receiver check inserted
 93                     if (callerClass == null) {
 94                         throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
 95                     }
 96                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
 97                     return new Special(mtype, lform, member, true, callerClass);
 98                 }
 99                 case REF_invokeInterface: {
100                     // for interfaces we always need the receiver typecheck,
101                     // so we always pass &#39;true&#39; to ensure we adapt if needed
102                     // to include the REF_invokeSpecial case
103                     LambdaForm lform = preparedLambdaForm(member, true);
104                     return new Interface(mtype, lform, member, true, refc);
105                 }
106                 default: {
107                     LambdaForm lform = preparedLambdaForm(member);
108                     return new DirectMethodHandle(mtype, lform, member, true);
109                 }
110             }
111         } else {
112             LambdaForm lform = preparedFieldLambdaForm(member);
113             if (member.isStatic()) {
114                 long offset = MethodHandleNatives.staticFieldOffset(member);
115                 Object base = MethodHandleNatives.staticFieldBase(member);
<a name="1" id="anc1"></a><span class="line-modified">116                 return new StaticAccessor(mtype, lform, member, true, base, offset);</span>

117             } else {
118                 long offset = MethodHandleNatives.objectFieldOffset(member);
119                 assert(offset == (int)offset);
<a name="2" id="anc2"></a><span class="line-modified">120                 return new Accessor(mtype, lform, member, true, (int)offset);</span>

121             }
122         }
123     }
124     static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
125         byte refKind = member.getReferenceKind();
126         if (refKind == REF_invokeSpecial)
127             refKind =  REF_invokeVirtual;
128         return make(refKind, refc, member, null /* no callerClass context */);
129     }
130     static DirectMethodHandle make(MemberName member) {
131         if (member.isObjectConstructor() &amp;&amp; member.getReturnType() == void.class)
132             return makeAllocator(member);
133         return make(member.getDeclaringClass(), member);
134     }
135     private static DirectMethodHandle makeAllocator(MemberName ctor) {
136         assert(ctor.isObjectConstructor() &amp;&amp; !ctor.getDeclaringClass().isInlineClass()) : ctor;
137 
138         Class&lt;?&gt; instanceClass = ctor.getDeclaringClass();
139         ctor = ctor.asObjectConstructor();
140         assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;
141         MethodType mtype = ctor.getMethodType().changeReturnType(instanceClass);
142         LambdaForm lform = preparedLambdaForm(ctor);
143         MemberName init = ctor.asSpecial();
144         assert(init.getMethodType().returnType() == void.class);
145         return new Constructor(mtype, lform, ctor, true, init, instanceClass);
146     }
147 
148     @Override
149     BoundMethodHandle rebind() {
150         return BoundMethodHandle.makeReinvoker(this);
151     }
152 
153     @Override
154     MethodHandle copyWith(MethodType mt, LambdaForm lf) {
155         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
156         return new DirectMethodHandle(mt, lf, member, crackable);
157     }
158 
159     @Override
160     MethodHandle viewAsType(MethodType newType, boolean strict) {
161         // No actual conversions, just a new view of the same method.
162         // However, we must not expose a DMH that is crackable into a
163         // MethodHandleInfo, so we return a cloned, uncrackable DMH
164         assert(viewAsTypeChecks(newType, strict));
165         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
166         return new DirectMethodHandle(newType, form, member, false);
167     }
168 
169     @Override
170     boolean isCrackable() {
171         return crackable;
172     }
173 
174     @Override
175     String internalProperties() {
176         return &quot;\n&amp; DMH.MN=&quot;+internalMemberName();
177     }
178 
179     //// Implementation methods.
180     @Override
181     @ForceInline
182     MemberName internalMemberName() {
183         return member;
184     }
185 
186     private static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
187 
188     /**
189      * Create a LF which can invoke the given method.
190      * Cache and share this structure among all methods with
191      * the same basicType and refKind.
192      */
193     private static LambdaForm preparedLambdaForm(MemberName m, boolean adaptToSpecialIfc) {
194         assert(m.isInvocable()) : m;  // call preparedFieldLambdaForm instead
195         MethodType mtype = m.getInvocationType().basicType();
196         assert(!m.isMethodHandleInvoke()) : m;
197         int which;
198         // MemberName.getReferenceKind represents the JVM optimized form of the call
199         // as distinct from the &quot;kind&quot; passed to DMH.make which represents the original
200         // bytecode-equivalent request. Specifically private/final methods that use a direct
201         // call have getReferenceKind adapted to REF_invokeSpecial, even though the actual
202         // invocation mode may be invokevirtual or invokeinterface.
203         switch (m.getReferenceKind()) {
204         case REF_invokeVirtual:    which = LF_INVVIRTUAL;    break;
205         case REF_invokeStatic:     which = LF_INVSTATIC;     break;
206         case REF_invokeSpecial:    which = LF_INVSPECIAL;    break;
207         case REF_invokeInterface:  which = LF_INVINTERFACE;  break;
208         case REF_newInvokeSpecial: which = LF_NEWINVSPECIAL; break;
209         default:  throw new InternalError(m.toString());
210         }
211         if (which == LF_INVSTATIC &amp;&amp; shouldBeInitialized(m)) {
212             // precompute the barrier-free version:
213             preparedLambdaForm(mtype, which);
214             which = LF_INVSTATIC_INIT;
215         }
216         if (which == LF_INVSPECIAL &amp;&amp; adaptToSpecialIfc) {
217             which = LF_INVSPECIAL_IFC;
218         }
219         LambdaForm lform = preparedLambdaForm(mtype, which);
220         maybeCompile(lform, m);
221         assert(lform.methodType().dropParameterTypes(0, 1)
222                 .equals(m.getInvocationType().basicType()))
223                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
224         return lform;
225     }
226 
227     private static LambdaForm preparedLambdaForm(MemberName m) {
228         return preparedLambdaForm(m, false);
229     }
230 
231     private static LambdaForm preparedLambdaForm(MethodType mtype, int which) {
232         LambdaForm lform = mtype.form().cachedLambdaForm(which);
233         if (lform != null)  return lform;
234         lform = makePreparedLambdaForm(mtype, which);
235         return mtype.form().setCachedLambdaForm(which, lform);
236     }
237 
238     static LambdaForm makePreparedLambdaForm(MethodType mtype, int which) {
239         boolean needsInit = (which == LF_INVSTATIC_INIT);
240         boolean doesAlloc = (which == LF_NEWINVSPECIAL);
241         boolean needsReceiverCheck = (which == LF_INVINTERFACE ||
242                                       which == LF_INVSPECIAL_IFC);
243 
244         String linkerName;
245         LambdaForm.Kind kind;
246         switch (which) {
247         case LF_INVVIRTUAL:    linkerName = &quot;linkToVirtual&quot;;   kind = DIRECT_INVOKE_VIRTUAL;     break;
248         case LF_INVSTATIC:     linkerName = &quot;linkToStatic&quot;;    kind = DIRECT_INVOKE_STATIC;      break;
249         case LF_INVSTATIC_INIT:linkerName = &quot;linkToStatic&quot;;    kind = DIRECT_INVOKE_STATIC_INIT; break;
250         case LF_INVSPECIAL_IFC:linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_INVOKE_SPECIAL_IFC; break;
251         case LF_INVSPECIAL:    linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_INVOKE_SPECIAL;     break;
252         case LF_INVINTERFACE:  linkerName = &quot;linkToInterface&quot;; kind = DIRECT_INVOKE_INTERFACE;   break;
253         case LF_NEWINVSPECIAL: linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_NEW_INVOKE_SPECIAL; break;
254         default:  throw new InternalError(&quot;which=&quot;+which);
255         }
256 
257         MethodType mtypeWithArg = mtype.appendParameterTypes(MemberName.class);
258         if (doesAlloc)
259             mtypeWithArg = mtypeWithArg
260                     .insertParameterTypes(0, Object.class)  // insert newly allocated obj
261                     .changeReturnType(void.class);          // &lt;init&gt; returns void
262         MemberName linker = new MemberName(MethodHandle.class, linkerName, mtypeWithArg, REF_invokeStatic);
263         try {
264             linker = IMPL_NAMES.resolveOrFail(REF_invokeStatic, linker, null, NoSuchMethodException.class);
265         } catch (ReflectiveOperationException ex) {
266             throw newInternalError(ex);
267         }
268         final int DMH_THIS    = 0;
269         final int ARG_BASE    = 1;
270         final int ARG_LIMIT   = ARG_BASE + mtype.parameterCount();
271         int nameCursor = ARG_LIMIT;
272         final int NEW_OBJ     = (doesAlloc ? nameCursor++ : -1);
273         final int GET_MEMBER  = nameCursor++;
274         final int CHECK_RECEIVER = (needsReceiverCheck ? nameCursor++ : -1);
275         final int LINKER_CALL = nameCursor++;
276         Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
277         assert(names.length == nameCursor);
278         if (doesAlloc) {
279             // names = { argx,y,z,... new C, init method }
280             names[NEW_OBJ] = new Name(getFunction(NF_allocateInstance), names[DMH_THIS]);
281             names[GET_MEMBER] = new Name(getFunction(NF_constructorMethod), names[DMH_THIS]);
282         } else if (needsInit) {
283             names[GET_MEMBER] = new Name(getFunction(NF_internalMemberNameEnsureInit), names[DMH_THIS]);
284         } else {
285             names[GET_MEMBER] = new Name(getFunction(NF_internalMemberName), names[DMH_THIS]);
286         }
287         assert(findDirectMethodHandle(names[GET_MEMBER]) == names[DMH_THIS]);
288         Object[] outArgs = Arrays.copyOfRange(names, ARG_BASE, GET_MEMBER+1, Object[].class);
289         if (needsReceiverCheck) {
290             names[CHECK_RECEIVER] = new Name(getFunction(NF_checkReceiver), names[DMH_THIS], names[ARG_BASE]);
291             outArgs[0] = names[CHECK_RECEIVER];
292         }
293         assert(outArgs[outArgs.length-1] == names[GET_MEMBER]);  // look, shifted args!
294         int result = LAST_RESULT;
295         if (doesAlloc) {
296             assert(outArgs[outArgs.length-2] == names[NEW_OBJ]);  // got to move this one
297             System.arraycopy(outArgs, 0, outArgs, 1, outArgs.length-2);
298             outArgs[0] = names[NEW_OBJ];
299             result = NEW_OBJ;
300         }
301         names[LINKER_CALL] = new Name(linker, outArgs);
302         LambdaForm lform = new LambdaForm(ARG_LIMIT, names, result, kind);
303 
304         // This is a tricky bit of code.  Don&#39;t send it through the LF interpreter.
305         lform.compileToBytecode();
306         return lform;
307     }
308 
309     /* assert */ static Object findDirectMethodHandle(Name name) {
310         if (name.function.equals(getFunction(NF_internalMemberName)) ||
311             name.function.equals(getFunction(NF_internalMemberNameEnsureInit)) ||
312             name.function.equals(getFunction(NF_constructorMethod))) {
313             assert(name.arguments.length == 1);
314             return name.arguments[0];
315         }
316         return null;
317     }
318 
319     private static void maybeCompile(LambdaForm lform, MemberName m) {
320         if (lform.vmentry == null &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), MethodHandle.class))
321             // Help along bootstrapping...
322             lform.compileToBytecode();
323     }
324 
325     /** Static wrapper for DirectMethodHandle.internalMemberName. */
326     @ForceInline
327     /*non-public*/
328     static Object internalMemberName(Object mh) {
329         return ((DirectMethodHandle)mh).member;
330     }
331 
332     /** Static wrapper for DirectMethodHandle.internalMemberName.
333      * This one also forces initialization.
334      */
335     /*non-public*/
336     static Object internalMemberNameEnsureInit(Object mh) {
337         DirectMethodHandle dmh = (DirectMethodHandle)mh;
338         dmh.ensureInitialized();
339         return dmh.member;
340     }
341 
342     /*non-public*/
343     static boolean shouldBeInitialized(MemberName member) {
344         switch (member.getReferenceKind()) {
345         case REF_invokeStatic:
346         case REF_getStatic:
347         case REF_putStatic:
348         case REF_newInvokeSpecial:
349             break;
350         default:
351             // No need to initialize the class on this kind of member.
352             return false;
353         }
354         Class&lt;?&gt; cls = member.getDeclaringClass();
355         if (cls == ValueConversions.class ||
356             cls == MethodHandleImpl.class ||
357             cls == Invokers.class) {
358             // These guys have lots of &lt;clinit&gt; DMH creation but we know
359             // the MHs will not be used until the system is booted.
360             return false;
361         }
362         if (VerifyAccess.isSamePackage(MethodHandle.class, cls) ||
363             VerifyAccess.isSamePackage(ValueConversions.class, cls)) {
364             // It is a system class.  It is probably in the process of
365             // being initialized, but we will help it along just to be safe.
366             if (UNSAFE.shouldBeInitialized(cls)) {
367                 UNSAFE.ensureClassInitialized(cls);
368             }
369             return false;
370         }
371         return UNSAFE.shouldBeInitialized(cls);
372     }
373 
374     private static class EnsureInitialized extends ClassValue&lt;WeakReference&lt;Thread&gt;&gt; {
375         @Override
376         protected WeakReference&lt;Thread&gt; computeValue(Class&lt;?&gt; type) {
377             UNSAFE.ensureClassInitialized(type);
378             if (UNSAFE.shouldBeInitialized(type))
379                 // If the previous call didn&#39;t block, this can happen.
380                 // We are executing inside &lt;clinit&gt;.
381                 return new WeakReference&lt;&gt;(Thread.currentThread());
382             return null;
383         }
384         static final EnsureInitialized INSTANCE = new EnsureInitialized();
385     }
386 
387     private void ensureInitialized() {
388         if (checkInitialized(member)) {
389             // The coast is clear.  Delete the &lt;clinit&gt; barrier.
390             if (member.isField())
391                 updateForm(preparedFieldLambdaForm(member));
392             else
393                 updateForm(preparedLambdaForm(member));
394         }
395     }
396     private static boolean checkInitialized(MemberName member) {
397         Class&lt;?&gt; defc = member.getDeclaringClass();
398         WeakReference&lt;Thread&gt; ref = EnsureInitialized.INSTANCE.get(defc);
399         if (ref == null) {
400             return true;  // the final state
401         }
402         Thread clinitThread = ref.get();
403         // Somebody may still be running defc.&lt;clinit&gt;.
404         if (clinitThread == Thread.currentThread()) {
405             // If anybody is running defc.&lt;clinit&gt;, it is this thread.
406             if (UNSAFE.shouldBeInitialized(defc))
407                 // Yes, we are running it; keep the barrier for now.
408                 return false;
409         } else {
410             // We are in a random thread.  Block.
411             UNSAFE.ensureClassInitialized(defc);
412         }
413         assert(!UNSAFE.shouldBeInitialized(defc));
414         // put it into the final state
415         EnsureInitialized.INSTANCE.remove(defc);
416         return true;
417     }
418 
419     /*non-public*/
420     static void ensureInitialized(Object mh) {
421         ((DirectMethodHandle)mh).ensureInitialized();
422     }
423 
424     /** This subclass represents invokespecial instructions. */
425     static class Special extends DirectMethodHandle {
426         private final Class&lt;?&gt; caller;
427         private Special(MethodType mtype, LambdaForm form, MemberName member, boolean crackable, Class&lt;?&gt; caller) {
428             super(mtype, form, member, crackable);
429             this.caller = caller;
430         }
431         @Override
432         boolean isInvokeSpecial() {
433             return true;
434         }
435         @Override
436         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
437             return new Special(mt, lf, member, crackable, caller);
438         }
439         @Override
440         MethodHandle viewAsType(MethodType newType, boolean strict) {
441             assert(viewAsTypeChecks(newType, strict));
442             return new Special(newType, form, member, false, caller);
443         }
444         Object checkReceiver(Object recv) {
445             if (!caller.isInstance(recv)) {
446                 String msg = String.format(&quot;Receiver class %s is not a subclass of caller class %s&quot;,
447                                            recv.getClass().getName(), caller.getName());
448                 throw new IncompatibleClassChangeError(msg);
449             }
450             return recv;
451         }
452     }
453 
454     /** This subclass represents invokeinterface instructions. */
455     static class Interface extends DirectMethodHandle {
456         private final Class&lt;?&gt; refc;
457         private Interface(MethodType mtype, LambdaForm form, MemberName member, boolean crackable, Class&lt;?&gt; refc) {
458             super(mtype, form, member, crackable);
459             assert(refc.isInterface()) : refc;
460             this.refc = refc;
461         }
462         @Override
463         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
464             return new Interface(mt, lf, member, crackable, refc);
465         }
466         @Override
467         MethodHandle viewAsType(MethodType newType, boolean strict) {
468             assert(viewAsTypeChecks(newType, strict));
469             return new Interface(newType, form, member, false, refc);
470         }
471         @Override
472         Object checkReceiver(Object recv) {
473             if (!refc.isInstance(recv)) {
474                 String msg = String.format(&quot;Receiver class %s does not implement the requested interface %s&quot;,
475                                            recv.getClass().getName(), refc.getName());
476                 throw new IncompatibleClassChangeError(msg);
477             }
478             return recv;
479         }
480     }
481 
482     /** Used for interface receiver type checks, by Interface and Special modes. */
483     Object checkReceiver(Object recv) {
484         throw new InternalError(&quot;Should only be invoked on a subclass&quot;);
485     }
486 
487     /** This subclass handles constructor references. */
488     static class Constructor extends DirectMethodHandle {
489         final MemberName initMethod;
490         final Class&lt;?&gt;   instanceClass;
491 
492         private Constructor(MethodType mtype, LambdaForm form, MemberName constructor,
493                             boolean crackable, MemberName initMethod, Class&lt;?&gt; instanceClass) {
494             super(mtype, form, constructor, crackable);
495             this.initMethod = initMethod;
496             this.instanceClass = instanceClass;
497             assert(initMethod.isResolved());
498         }
499         @Override
500         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
501             return new Constructor(mt, lf, member, crackable, initMethod, instanceClass);
502         }
503         @Override
504         MethodHandle viewAsType(MethodType newType, boolean strict) {
505             assert(viewAsTypeChecks(newType, strict));
506             return new Constructor(newType, form, member, false, initMethod, instanceClass);
507         }
508     }
509 
510     /*non-public*/
511     static Object constructorMethod(Object mh) {
512         Constructor dmh = (Constructor)mh;
513         return dmh.initMethod;
514     }
515 
516     /*non-public*/
517     static Object allocateInstance(Object mh) throws InstantiationException {
518         Constructor dmh = (Constructor)mh;
519         return UNSAFE.allocateInstance(dmh.instanceClass);
520     }
521 
522     /** This subclass handles non-static field references. */
523     static class Accessor extends DirectMethodHandle {
524         final Class&lt;?&gt; fieldType;
525         final int      fieldOffset;
526         private Accessor(MethodType mtype, LambdaForm form, MemberName member,
527                          boolean crackable, int fieldOffset) {
528             super(mtype, form, member, crackable);
529             this.fieldType   = member.getFieldType();
530             this.fieldOffset = fieldOffset;
531         }
532 
533         @Override Object checkCast(Object obj) {
534             return fieldType.cast(obj);
535         }
536         @Override
537         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
538             return new Accessor(mt, lf, member, crackable, fieldOffset);
539         }
540         @Override
541         MethodHandle viewAsType(MethodType newType, boolean strict) {
542             assert(viewAsTypeChecks(newType, strict));
543             return new Accessor(newType, form, member, false, fieldOffset);
544         }
545     }
546 
<a name="3" id="anc3"></a>




















547     @ForceInline
548     /*non-public*/
549     static long fieldOffset(Object accessorObj) {
550         // Note: We return a long because that is what Unsafe.getObject likes.
551         // We store a plain int because it is more compact.
552         return ((Accessor)accessorObj).fieldOffset;
553     }
554 
555     @ForceInline
556     /*non-public*/
557     static Object checkBase(Object obj) {
558         // Note that the object&#39;s class has already been verified,
559         // since the parameter type of the Accessor method handle
560         // is either member.getDeclaringClass or a subclass.
561         // This was verified in DirectMethodHandle.make.
562         // Therefore, the only remaining check is for null.
563         // Since this check is *not* guaranteed by Unsafe.getInt
564         // and its siblings, we need to make an explicit one here.
565         return Objects.requireNonNull(obj);
566     }
567 
568     static class StaticAccessor extends DirectMethodHandle {
569         final Class&lt;?&gt; fieldType;
570         final Object staticBase;
571         final long staticOffset;
572 
573         private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
574                                boolean crackable, Object staticBase, long staticOffset) {
575             super(mtype, form, member, crackable);
576             this.fieldType    = member.getFieldType();
577             this.staticBase   = staticBase;
578             this.staticOffset = staticOffset;
579         }
580 
581         @Override Object checkCast(Object obj) {
582             return fieldType.cast(obj);
583         }
584         @Override
585         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
586             return new StaticAccessor(mt, lf, member, crackable, staticBase, staticOffset);
587         }
588         @Override
589         MethodHandle viewAsType(MethodType newType, boolean strict) {
590             assert(viewAsTypeChecks(newType, strict));
591             return new StaticAccessor(newType, form, member, false, staticBase, staticOffset);
592         }
593     }
594 
<a name="4" id="anc4"></a>






















595     @ForceInline
596     /*non-public*/
597     static Object nullCheck(Object obj) {
598         return Objects.requireNonNull(obj);
599     }
600 
601     @ForceInline
602     /*non-public*/
603     static Object staticBase(Object accessorObj) {
604         return ((StaticAccessor)accessorObj).staticBase;
605     }
606 
607     @ForceInline
608     /*non-public*/
609     static long staticOffset(Object accessorObj) {
610         return ((StaticAccessor)accessorObj).staticOffset;
611     }
612 
613     @ForceInline
614     /*non-public*/
615     static Object checkCast(Object mh, Object obj) {
616         return ((DirectMethodHandle) mh).checkCast(obj);
617     }
618 
619     @ForceInline
620     /*non-public*/ static Class&lt;?&gt; fieldType(Object accessorObj) {
621         return ((Accessor) accessorObj).fieldType;
622     }
623 
624     @ForceInline
625     /*non-public*/ static Class&lt;?&gt; staticFieldType(Object accessorObj) {
626         return ((StaticAccessor) accessorObj).fieldType;
627     }
628 
629     Object checkCast(Object obj) {
630         return member.getReturnType().cast(obj);
631     }
632 
633     // Caching machinery for field accessors:
634     static final byte
635             AF_GETFIELD        = 0,
636             AF_PUTFIELD        = 1,
637             AF_GETSTATIC       = 2,
638             AF_PUTSTATIC       = 3,
639             AF_GETSTATIC_INIT  = 4,
640             AF_PUTSTATIC_INIT  = 5,
641             AF_LIMIT           = 6;
642     // Enumerate the different field kinds using Wrapper,
643     // with an extra case added for checked references and value field access
644     static final int
645             FT_LAST_WRAPPER     = Wrapper.COUNT-1,
646             FT_UNCHECKED_REF    = Wrapper.OBJECT.ordinal(),
647             FT_CHECKED_REF      = FT_LAST_WRAPPER+1,
648             FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  // flattened and non-flattened
649             FT_LIMIT            = FT_LAST_WRAPPER+4;
650     private static int afIndex(byte formOp, boolean isVolatile, boolean isFlatValue, int ftypeKind) {
651         return ((formOp * FT_LIMIT * 2)
652                 + (isVolatile ? FT_LIMIT : 0)
653                 + (isFlatValue ? 1 : 0)
654                 + ftypeKind);
655     }
656     @Stable
657     private static final LambdaForm[] ACCESSOR_FORMS
658             = new LambdaForm[afIndex(AF_LIMIT, false, false, 0)];
659     static int ftypeKind(Class&lt;?&gt; ftype, boolean isValue) {
660         if (ftype.isPrimitive())
661             return Wrapper.forPrimitiveType(ftype).ordinal();
662         else if (VerifyType.isNullReferenceConversion(Object.class, ftype)) {
663             return FT_UNCHECKED_REF;
664         } else
665             // null check for value type in addition to check cast
666             return isValue ? FT_CHECKED_VALUE : FT_CHECKED_REF;
667     }
668 
669     /**
670      * Create a LF which can access the given field.
671      * Cache and share this structure among all fields with
672      * the same basicType and refKind.
673      */
674     private static LambdaForm preparedFieldLambdaForm(MemberName m) {
675         Class&lt;?&gt; ftype = m.getFieldType();
676         byte formOp;
677         switch (m.getReferenceKind()) {
678         case REF_getField:      formOp = AF_GETFIELD;    break;
679         case REF_putField:      formOp = AF_PUTFIELD;    break;
680         case REF_getStatic:     formOp = AF_GETSTATIC;   break;
681         case REF_putStatic:     formOp = AF_PUTSTATIC;   break;
682         default:  throw new InternalError(m.toString());
683         }
684         if (shouldBeInitialized(m)) {
685             // precompute the barrier-free version:
686             preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);
687             assert((AF_GETSTATIC_INIT - AF_GETSTATIC) ==
688                    (AF_PUTSTATIC_INIT - AF_PUTSTATIC));
689             formOp += (AF_GETSTATIC_INIT - AF_GETSTATIC);
690         }
691         LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);
692         maybeCompile(lform, m);
693         assert(lform.methodType().dropParameterTypes(0, 1)
694                 .equals(m.getInvocationType().basicType()))
695                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
696         return lform;
697     }
698 
699     private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, Class&lt;?&gt; ftype) {
700         int ftypeKind = ftypeKind(ftype, isValue);
701         int afIndex = afIndex(formOp, isVolatile, isFlatValue, ftypeKind);
702         LambdaForm lform = ACCESSOR_FORMS[afIndex];
703         if (lform != null)  return lform;
704         lform = makePreparedFieldLambdaForm(formOp, isVolatile, isValue, isFlatValue, ftypeKind);
705         ACCESSOR_FORMS[afIndex] = lform;  // don&#39;t bother with a CAS
706         return lform;
707     }
708 
709     private static final Wrapper[] ALL_WRAPPERS = Wrapper.values();
710 
711     private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlatValue, Wrapper wrapper) {
712         if (isGetter) {
713             if (isVolatile) {
714                 switch (wrapper) {
715                     case BOOLEAN: return GET_BOOLEAN_VOLATILE;
716                     case BYTE:    return GET_BYTE_VOLATILE;
717                     case SHORT:   return GET_SHORT_VOLATILE;
718                     case CHAR:    return GET_CHAR_VOLATILE;
719                     case INT:     return GET_INT_VOLATILE;
720                     case LONG:    return GET_LONG_VOLATILE;
721                     case FLOAT:   return GET_FLOAT_VOLATILE;
722                     case DOUBLE:  return GET_DOUBLE_VOLATILE;
723                     case OBJECT:  return isFlatValue ? GET_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;
724                 }
725             } else {
726                 switch (wrapper) {
727                     case BOOLEAN: return GET_BOOLEAN;
728                     case BYTE:    return GET_BYTE;
729                     case SHORT:   return GET_SHORT;
730                     case CHAR:    return GET_CHAR;
731                     case INT:     return GET_INT;
732                     case LONG:    return GET_LONG;
733                     case FLOAT:   return GET_FLOAT;
734                     case DOUBLE:  return GET_DOUBLE;
735                     case OBJECT:  return isFlatValue ? GET_VALUE : GET_REFERENCE;
736                 }
737             }
738         } else {
739             if (isVolatile) {
740                 switch (wrapper) {
741                     case BOOLEAN: return PUT_BOOLEAN_VOLATILE;
742                     case BYTE:    return PUT_BYTE_VOLATILE;
743                     case SHORT:   return PUT_SHORT_VOLATILE;
744                     case CHAR:    return PUT_CHAR_VOLATILE;
745                     case INT:     return PUT_INT_VOLATILE;
746                     case LONG:    return PUT_LONG_VOLATILE;
747                     case FLOAT:   return PUT_FLOAT_VOLATILE;
748                     case DOUBLE:  return PUT_DOUBLE_VOLATILE;
749                     case OBJECT:  return isFlatValue ? PUT_VALUE_VOLATILE : PUT_REFERENCE_VOLATILE;
750                 }
751             } else {
752                 switch (wrapper) {
753                     case BOOLEAN: return PUT_BOOLEAN;
754                     case BYTE:    return PUT_BYTE;
755                     case SHORT:   return PUT_SHORT;
756                     case CHAR:    return PUT_CHAR;
757                     case INT:     return PUT_INT;
758                     case LONG:    return PUT_LONG;
759                     case FLOAT:   return PUT_FLOAT;
760                     case DOUBLE:  return PUT_DOUBLE;
761                     case OBJECT:  return isFlatValue ? PUT_VALUE : PUT_REFERENCE;
762                 }
763             }
764         }
765         throw new AssertionError(&quot;Invalid arguments&quot;);
766     }
767 
768     /** invoked by GenerateJLIClassesHelper */
769     static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftype) {
770         return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, ftype);
771     }
772 
773     private static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, int ftypeKind) {
774         boolean isGetter  = (formOp &amp; 1) == (AF_GETFIELD &amp; 1);
775         boolean isStatic  = (formOp &gt;= AF_GETSTATIC);
776         boolean needsInit = (formOp &gt;= AF_GETSTATIC_INIT);
777         boolean needsCast = (ftypeKind == FT_CHECKED_REF || ftypeKind == FT_CHECKED_VALUE);
778         Wrapper fw = (needsCast ? Wrapper.OBJECT : ALL_WRAPPERS[ftypeKind]);
779         Class&lt;?&gt; ft = fw.primitiveType();
780         assert(needsCast ? true : ftypeKind(ft, isValue) == ftypeKind);
781 
782         // getObject, putIntVolatile, etc.
783         Kind kind = getFieldKind(isGetter, isVolatile, isFlatValue, fw);
784 
785         MethodType linkerType;
786         boolean hasValueTypeArg = isGetter ? isValue : isFlatValue;
787         if (isGetter) {
788             linkerType = isValue ? MethodType.methodType(ft, Object.class, long.class, Class.class)
789                                  : MethodType.methodType(ft, Object.class, long.class);
790         } else {
791             linkerType = isFlatValue ? MethodType.methodType(void.class, Object.class, long.class, Class.class, ft)
792                                      : MethodType.methodType(void.class, Object.class, long.class, ft);
793         }
794         MemberName linker = new MemberName(Unsafe.class, kind.methodName, linkerType, REF_invokeVirtual);
795         try {
796             linker = IMPL_NAMES.resolveOrFail(REF_invokeVirtual, linker, null, NoSuchMethodException.class);
797         } catch (ReflectiveOperationException ex) {
798             throw newInternalError(ex);
799         }
800 
801         // What is the external type of the lambda form?
802         MethodType mtype;
803         if (isGetter)
804             mtype = MethodType.methodType(ft);
805         else
806             mtype = MethodType.methodType(void.class, ft);
807         mtype = mtype.basicType();  // erase short to int, etc.
808         if (!isStatic)
809             mtype = mtype.insertParameterTypes(0, Object.class);
810         final int DMH_THIS  = 0;
811         final int ARG_BASE  = 1;
812         final int ARG_LIMIT = ARG_BASE + mtype.parameterCount();
813         // if this is for non-static access, the base pointer is stored at this index:
814         final int OBJ_BASE  = isStatic ? -1 : ARG_BASE;
815         // if this is for write access, the value to be written is stored at this index:
816         final int SET_VALUE  = isGetter ? -1 : ARG_LIMIT - 1;
817         int nameCursor = ARG_LIMIT;
818         final int F_HOLDER  = (isStatic ? nameCursor++ : -1);  // static base if any
819         final int F_OFFSET  = nameCursor++;  // Either static offset or field offset.
820         final int OBJ_CHECK = (OBJ_BASE &gt;= 0 ? nameCursor++ : -1);
821         final int U_HOLDER  = nameCursor++;  // UNSAFE holder
822         final int INIT_BAR  = (needsInit ? nameCursor++ : -1);
823         final int VALUE_TYPE = (hasValueTypeArg ? nameCursor++ : -1);
824         final int PRE_CAST  = (needsCast &amp;&amp; !isGetter ? nameCursor++ : -1);
825         final int LINKER_CALL = nameCursor++;
826         final int POST_CAST = (needsCast &amp;&amp; isGetter ? nameCursor++ : -1);
827         final int RESULT    = nameCursor-1;  // either the call or the cast
828         Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
829         if (needsInit)
830             names[INIT_BAR] = new Name(getFunction(NF_ensureInitialized), names[DMH_THIS]);
831         if (needsCast &amp;&amp; !isGetter)
832             names[PRE_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[SET_VALUE]);
833         Object[] outArgs = new Object[1 + linkerType.parameterCount()];
834         assert (outArgs.length == (isGetter ? 3 : 4) + (hasValueTypeArg ? 1 : 0));
835         outArgs[0] = names[U_HOLDER] = new Name(getFunction(NF_UNSAFE));
836         if (isStatic) {
837             outArgs[1] = names[F_HOLDER]  = new Name(getFunction(NF_staticBase), names[DMH_THIS]);
838             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_staticOffset), names[DMH_THIS]);
839         } else {
840             outArgs[1] = names[OBJ_CHECK] = new Name(getFunction(NF_checkBase), names[OBJ_BASE]);
841             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_fieldOffset), names[DMH_THIS]);
842         }
843         int x = 3;
844         if (hasValueTypeArg) {
845             outArgs[x++] = names[VALUE_TYPE] = isStatic ? new Name(getFunction(NF_staticFieldType), names[DMH_THIS])
846                                                         : new Name(getFunction(NF_fieldType), names[DMH_THIS]);
847         }
848         if (!isGetter) {
849             outArgs[x] = (needsCast ? names[PRE_CAST] : names[SET_VALUE]);
850         }
851         for (Object a : outArgs)  assert(a != null);
852         names[LINKER_CALL] = new Name(linker, outArgs);
853         if (needsCast &amp;&amp; isGetter)
854             names[POST_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[LINKER_CALL]);
855         for (Name n : names)  assert(n != null);
856 
857         LambdaForm form;
858         if (needsCast || needsInit) {
859             // can&#39;t use the pre-generated form when casting and/or initializing
860             form = new LambdaForm(ARG_LIMIT, names, RESULT);
861         } else {
862             form = new LambdaForm(ARG_LIMIT, names, RESULT, kind);
863         }
864 
865         if (LambdaForm.debugNames()) {
866             // add some detail to the lambdaForm debugname,
867             // significant only for debugging
868             StringBuilder nameBuilder = new StringBuilder(kind.methodName);
869             if (isStatic) {
870                 nameBuilder.append(&quot;Static&quot;);
871             } else {
872                 nameBuilder.append(&quot;Field&quot;);
873             }
874             if (needsCast) {
875                 nameBuilder.append(&quot;Cast&quot;);
876             }
877             if (needsInit) {
878                 nameBuilder.append(&quot;Init&quot;);
879             }
880             LambdaForm.associateWithDebugName(form, nameBuilder.toString());
881         }
882         return form;
883     }
884 
885     /**
886      * Pre-initialized NamedFunctions for bootstrapping purposes.
887      */
888     static final byte NF_internalMemberName = 0,
889             NF_internalMemberNameEnsureInit = 1,
890             NF_ensureInitialized = 2,
891             NF_fieldOffset = 3,
892             NF_checkBase = 4,
893             NF_staticBase = 5,
894             NF_staticOffset = 6,
895             NF_checkCast = 7,
896             NF_allocateInstance = 8,
897             NF_constructorMethod = 9,
898             NF_UNSAFE = 10,
899             NF_checkReceiver = 11,
900             NF_fieldType = 12,
901             NF_staticFieldType = 13,
902             NF_LIMIT = 14;
903 
904     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
905 
906     private static NamedFunction getFunction(byte func) {
907         NamedFunction nf = NFS[func];
908         if (nf != null) {
909             return nf;
910         }
911         // Each nf must be statically invocable or we get tied up in our bootstraps.
912         nf = NFS[func] = createFunction(func);
913         assert(InvokerBytecodeGenerator.isStaticallyInvocable(nf));
914         return nf;
915     }
916 
917     private static final MethodType CLS_OBJ_TYPE = MethodType.methodType(Class.class, Object.class);
918 
919     private static final MethodType OBJ_OBJ_TYPE = MethodType.methodType(Object.class, Object.class);
920 
921     private static final MethodType LONG_OBJ_TYPE = MethodType.methodType(long.class, Object.class);
922 
923     private static NamedFunction createFunction(byte func) {
924         try {
925             switch (func) {
926                 case NF_internalMemberName:
927                     return getNamedFunction(&quot;internalMemberName&quot;, OBJ_OBJ_TYPE);
928                 case NF_internalMemberNameEnsureInit:
929                     return getNamedFunction(&quot;internalMemberNameEnsureInit&quot;, OBJ_OBJ_TYPE);
930                 case NF_ensureInitialized:
931                     return getNamedFunction(&quot;ensureInitialized&quot;, MethodType.methodType(void.class, Object.class));
932                 case NF_fieldOffset:
933                     return getNamedFunction(&quot;fieldOffset&quot;, LONG_OBJ_TYPE);
934                 case NF_checkBase:
935                     return getNamedFunction(&quot;checkBase&quot;, OBJ_OBJ_TYPE);
936                 case NF_staticBase:
937                     return getNamedFunction(&quot;staticBase&quot;, OBJ_OBJ_TYPE);
938                 case NF_staticOffset:
939                     return getNamedFunction(&quot;staticOffset&quot;, LONG_OBJ_TYPE);
940                 case NF_checkCast:
941                     return getNamedFunction(&quot;checkCast&quot;, MethodType.methodType(Object.class, Object.class, Object.class));
942                 case NF_allocateInstance:
943                     return getNamedFunction(&quot;allocateInstance&quot;, OBJ_OBJ_TYPE);
944                 case NF_constructorMethod:
945                     return getNamedFunction(&quot;constructorMethod&quot;, OBJ_OBJ_TYPE);
946                 case NF_UNSAFE:
947                     MemberName member = new MemberName(MethodHandleStatics.class, &quot;UNSAFE&quot;, Unsafe.class, REF_getField);
948                     return new NamedFunction(
949                             MemberName.getFactory()
950                                     .resolveOrFail(REF_getField, member, DirectMethodHandle.class, NoSuchMethodException.class));
951                 case NF_checkReceiver:
952                     member = new MemberName(DirectMethodHandle.class, &quot;checkReceiver&quot;, OBJ_OBJ_TYPE, REF_invokeVirtual);
953                     return new NamedFunction(
954                         MemberName.getFactory()
955                             .resolveOrFail(REF_invokeVirtual, member, DirectMethodHandle.class, NoSuchMethodException.class));
956                 case NF_fieldType:
957                     return getNamedFunction(&quot;fieldType&quot;, CLS_OBJ_TYPE);
958                 case NF_staticFieldType:
959                     return getNamedFunction(&quot;staticFieldType&quot;, CLS_OBJ_TYPE);
960                 default:
961                     throw newInternalError(&quot;Unknown function: &quot; + func);
962             }
963         } catch (ReflectiveOperationException ex) {
964             throw newInternalError(ex);
965         }
966     }
967 
968     private static NamedFunction getNamedFunction(String name, MethodType type)
969         throws ReflectiveOperationException
970     {
971         MemberName member = new MemberName(DirectMethodHandle.class, name, type, REF_invokeStatic);
972         return new NamedFunction(
973             MemberName.getFactory()
974                 .resolveOrFail(REF_invokeStatic, member, DirectMethodHandle.class, NoSuchMethodException.class));
975     }
976 
977     static {
978         // The Holder class will contain pre-generated DirectMethodHandles resolved
979         // speculatively using MemberName.getFactory().resolveOrNull. However, that
980         // doesn&#39;t initialize the class, which subtly breaks inlining etc. By forcing
981         // initialization of the Holder class we avoid these issues.
982         UNSAFE.ensureClassInitialized(Holder.class);
983     }
984 
985     /* Placeholder class for DirectMethodHandles generated ahead of time */
986     final class Holder {}
987 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>