<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/gc/g1/g1BarrierSetAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/cpu/x86/gc/g1/g1BarrierSetAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
185   // Is the previous value null?
186   __ cmpptr(pre_val, (int32_t) NULL_WORD);
187   __ jcc(Assembler::equal, done);
188 
189   // Can we store original value in the thread&#39;s buffer?
190   // Is index == 0?
191   // (The index field is typed as size_t.)
192   __ movptr(tmp, index);                   // tmp := *index_adr
193   __ cmpptr(tmp, 0);                       // tmp == 0?
194   __ jcc(Assembler::equal, runtime);       // If yes, goto runtime
195 
196   __ subptr(tmp, wordSize);                // tmp := tmp - wordSize
197   __ movptr(index, tmp);                   // *index_adr := tmp
198   __ addptr(tmp, buffer);                  // tmp := tmp + *buffer_adr
199 
200   // Record the previous value
201   __ movptr(Address(tmp, 0), pre_val);
202   __ jmp(done);
203 
204   __ bind(runtime);
<span class="line-removed">205   // FIXME</span>
206   // Barriers might be emitted when converting between (scalarized) calling conventions for inline
<span class="line-modified">207   // types. Save all registers until JDK-8232094 is fixed to avoid overwriting argument registers.</span>
208   __ pusha();









209 
210   // Calling the runtime using the regular call_VM_leaf mechanism generates
211   // code (generated by InterpreterMacroAssember::call_VM_leaf_base)
212   // that checks that the *(ebp+frame::interpreter_frame_last_sp) == NULL.
213   //
214   // If we care generating the pre-barrier without a frame (e.g. in the
215   // intrinsified Reference.get() routine) then ebp might be pointing to
216   // the caller frame and so this check will most likely fail at runtime.
217   //
218   // Expanding the call directly bypasses the generation of the check.
219   // So when we do not have have a full interpreter frame on the stack
220   // expand_call should be passed true.
221 
222   if (expand_call) {
223     LP64_ONLY( assert(pre_val != c_rarg1, &quot;smashed arg&quot;); )
224 #ifdef _LP64
225     if (c_rarg1 != thread) {
226       __ mov(c_rarg1, thread);
227     }
228     if (c_rarg0 != pre_val) {
229       __ mov(c_rarg0, pre_val);
230     }
231 #else
232     __ push(thread);
233     __ push(pre_val);
234 #endif
235     __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), 2);
236   } else {
237     __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), pre_val, thread);
238   }
239 










240   __ popa();

241   __ bind(done);
242 }
243 
244 void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm,
245                                                   Register store_addr,
246                                                   Register new_val,
247                                                   Register thread,
248                                                   Register tmp,
249                                                   Register tmp2) {
250 #ifdef _LP64
251   assert(thread == r15_thread, &quot;must be&quot;);
252 #endif // _LP64
253 
254   Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));
255   Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));
256 
257   CardTableBarrierSet* ct =
258     barrier_set_cast&lt;CardTableBarrierSet&gt;(BarrierSet::barrier_set());
259 
260   Label done;
</pre>
<hr />
<pre>
295   // storing a region crossing, non-NULL oop, card is clean.
296   // dirty card and log.
297 
298   __ movb(Address(card_addr, 0), (int)G1CardTable::dirty_card_val());
299 
300   __ cmpl(queue_index, 0);
301   __ jcc(Assembler::equal, runtime);
302   __ subl(queue_index, wordSize);
303   __ movptr(tmp2, buffer);
304 #ifdef _LP64
305   __ movslq(rscratch1, queue_index);
306   __ addq(tmp2, rscratch1);
307   __ movq(Address(tmp2, 0), card_addr);
308 #else
309   __ addl(tmp2, queue_index);
310   __ movl(Address(tmp2, 0), card_addr);
311 #endif
312   __ jmp(done);
313 
314   __ bind(runtime);
<span class="line-removed">315   // FIXME</span>
316   // Barriers might be emitted when converting between (scalarized) calling conventions for inline
<span class="line-modified">317   // types. Save all registers until JDK-8232094 is fixed to avoid overwriting argument registers.</span>
318   __ pusha();









319 
320 #ifdef _LP64
321   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, r15_thread);
322 #else
323   __ push(thread);
324   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);
325   __ pop(thread);
326 #endif
327 










328   __ popa();

329   __ bind(done);
330 }
331 
332 void G1BarrierSetAssembler::oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
333                                          Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {
334   bool in_heap = (decorators &amp; IN_HEAP) != 0;
335   bool as_normal = (decorators &amp; AS_NORMAL) != 0;
336   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
337 
338   bool needs_pre_barrier = as_normal &amp;&amp; !dest_uninitialized;
339   bool needs_post_barrier = val != noreg &amp;&amp; in_heap;
340 
341   if (tmp3 == noreg) {
342     tmp3 = LP64_ONLY(r8) NOT_LP64(rsi);
343   }
344   Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
345   // flatten object address if needed
346   // We do it regardless of precise because we need the registers
347   if (dst.index() == noreg &amp;&amp; dst.disp() == 0) {
348     if (dst.base() != tmp1) {
</pre>
</td>
<td>
<hr />
<pre>
185   // Is the previous value null?
186   __ cmpptr(pre_val, (int32_t) NULL_WORD);
187   __ jcc(Assembler::equal, done);
188 
189   // Can we store original value in the thread&#39;s buffer?
190   // Is index == 0?
191   // (The index field is typed as size_t.)
192   __ movptr(tmp, index);                   // tmp := *index_adr
193   __ cmpptr(tmp, 0);                       // tmp == 0?
194   __ jcc(Assembler::equal, runtime);       // If yes, goto runtime
195 
196   __ subptr(tmp, wordSize);                // tmp := tmp - wordSize
197   __ movptr(index, tmp);                   // *index_adr := tmp
198   __ addptr(tmp, buffer);                  // tmp := tmp + *buffer_adr
199 
200   // Record the previous value
201   __ movptr(Address(tmp, 0), pre_val);
202   __ jmp(done);
203 
204   __ bind(runtime);

205   // Barriers might be emitted when converting between (scalarized) calling conventions for inline
<span class="line-modified">206   // types. Save all argument registers before calling into the runtime.</span>
207   __ pusha();
<span class="line-added">208   __ subptr(rsp, 64);</span>
<span class="line-added">209   __ movdbl(Address(rsp, 0),  j_farg0);</span>
<span class="line-added">210   __ movdbl(Address(rsp, 8),  j_farg1);</span>
<span class="line-added">211   __ movdbl(Address(rsp, 16), j_farg2);</span>
<span class="line-added">212   __ movdbl(Address(rsp, 24), j_farg3);</span>
<span class="line-added">213   __ movdbl(Address(rsp, 32), j_farg4);</span>
<span class="line-added">214   __ movdbl(Address(rsp, 40), j_farg5);</span>
<span class="line-added">215   __ movdbl(Address(rsp, 48), j_farg6);</span>
<span class="line-added">216   __ movdbl(Address(rsp, 56), j_farg7);</span>
217 
218   // Calling the runtime using the regular call_VM_leaf mechanism generates
219   // code (generated by InterpreterMacroAssember::call_VM_leaf_base)
220   // that checks that the *(ebp+frame::interpreter_frame_last_sp) == NULL.
221   //
222   // If we care generating the pre-barrier without a frame (e.g. in the
223   // intrinsified Reference.get() routine) then ebp might be pointing to
224   // the caller frame and so this check will most likely fail at runtime.
225   //
226   // Expanding the call directly bypasses the generation of the check.
227   // So when we do not have have a full interpreter frame on the stack
228   // expand_call should be passed true.
229 
230   if (expand_call) {
231     LP64_ONLY( assert(pre_val != c_rarg1, &quot;smashed arg&quot;); )
232 #ifdef _LP64
233     if (c_rarg1 != thread) {
234       __ mov(c_rarg1, thread);
235     }
236     if (c_rarg0 != pre_val) {
237       __ mov(c_rarg0, pre_val);
238     }
239 #else
240     __ push(thread);
241     __ push(pre_val);
242 #endif
243     __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), 2);
244   } else {
245     __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), pre_val, thread);
246   }
247 
<span class="line-added">248   // Restore registers</span>
<span class="line-added">249   __ movdbl(j_farg0, Address(rsp, 0));</span>
<span class="line-added">250   __ movdbl(j_farg1, Address(rsp, 8));</span>
<span class="line-added">251   __ movdbl(j_farg2, Address(rsp, 16));</span>
<span class="line-added">252   __ movdbl(j_farg3, Address(rsp, 24));</span>
<span class="line-added">253   __ movdbl(j_farg4, Address(rsp, 32));</span>
<span class="line-added">254   __ movdbl(j_farg5, Address(rsp, 40));</span>
<span class="line-added">255   __ movdbl(j_farg6, Address(rsp, 48));</span>
<span class="line-added">256   __ movdbl(j_farg7, Address(rsp, 56));</span>
<span class="line-added">257   __ addptr(rsp, 64);</span>
258   __ popa();
<span class="line-added">259 </span>
260   __ bind(done);
261 }
262 
263 void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm,
264                                                   Register store_addr,
265                                                   Register new_val,
266                                                   Register thread,
267                                                   Register tmp,
268                                                   Register tmp2) {
269 #ifdef _LP64
270   assert(thread == r15_thread, &quot;must be&quot;);
271 #endif // _LP64
272 
273   Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));
274   Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));
275 
276   CardTableBarrierSet* ct =
277     barrier_set_cast&lt;CardTableBarrierSet&gt;(BarrierSet::barrier_set());
278 
279   Label done;
</pre>
<hr />
<pre>
314   // storing a region crossing, non-NULL oop, card is clean.
315   // dirty card and log.
316 
317   __ movb(Address(card_addr, 0), (int)G1CardTable::dirty_card_val());
318 
319   __ cmpl(queue_index, 0);
320   __ jcc(Assembler::equal, runtime);
321   __ subl(queue_index, wordSize);
322   __ movptr(tmp2, buffer);
323 #ifdef _LP64
324   __ movslq(rscratch1, queue_index);
325   __ addq(tmp2, rscratch1);
326   __ movq(Address(tmp2, 0), card_addr);
327 #else
328   __ addl(tmp2, queue_index);
329   __ movl(Address(tmp2, 0), card_addr);
330 #endif
331   __ jmp(done);
332 
333   __ bind(runtime);

334   // Barriers might be emitted when converting between (scalarized) calling conventions for inline
<span class="line-modified">335   // types. Save all argument registers before calling into the runtime.</span>
336   __ pusha();
<span class="line-added">337   __ subptr(rsp, 64);</span>
<span class="line-added">338   __ movdbl(Address(rsp, 0),  j_farg0);</span>
<span class="line-added">339   __ movdbl(Address(rsp, 8),  j_farg1);</span>
<span class="line-added">340   __ movdbl(Address(rsp, 16), j_farg2);</span>
<span class="line-added">341   __ movdbl(Address(rsp, 24), j_farg3);</span>
<span class="line-added">342   __ movdbl(Address(rsp, 32), j_farg4);</span>
<span class="line-added">343   __ movdbl(Address(rsp, 40), j_farg5);</span>
<span class="line-added">344   __ movdbl(Address(rsp, 48), j_farg6);</span>
<span class="line-added">345   __ movdbl(Address(rsp, 56), j_farg7);</span>
346 
347 #ifdef _LP64
348   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, r15_thread);
349 #else
350   __ push(thread);
351   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);
352   __ pop(thread);
353 #endif
354 
<span class="line-added">355   // Restore registers</span>
<span class="line-added">356   __ movdbl(j_farg0, Address(rsp, 0));</span>
<span class="line-added">357   __ movdbl(j_farg1, Address(rsp, 8));</span>
<span class="line-added">358   __ movdbl(j_farg2, Address(rsp, 16));</span>
<span class="line-added">359   __ movdbl(j_farg3, Address(rsp, 24));</span>
<span class="line-added">360   __ movdbl(j_farg4, Address(rsp, 32));</span>
<span class="line-added">361   __ movdbl(j_farg5, Address(rsp, 40));</span>
<span class="line-added">362   __ movdbl(j_farg6, Address(rsp, 48));</span>
<span class="line-added">363   __ movdbl(j_farg7, Address(rsp, 56));</span>
<span class="line-added">364   __ addptr(rsp, 64);</span>
365   __ popa();
<span class="line-added">366 </span>
367   __ bind(done);
368 }
369 
370 void G1BarrierSetAssembler::oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
371                                          Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {
372   bool in_heap = (decorators &amp; IN_HEAP) != 0;
373   bool as_normal = (decorators &amp; AS_NORMAL) != 0;
374   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
375 
376   bool needs_pre_barrier = as_normal &amp;&amp; !dest_uninitialized;
377   bool needs_post_barrier = val != noreg &amp;&amp; in_heap;
378 
379   if (tmp3 == noreg) {
380     tmp3 = LP64_ONLY(r8) NOT_LP64(rsi);
381   }
382   Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
383   // flatten object address if needed
384   // We do it regardless of precise because we need the registers
385   if (dst.index() == noreg &amp;&amp; dst.disp() == 0) {
386     if (dst.base() != tmp1) {
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>