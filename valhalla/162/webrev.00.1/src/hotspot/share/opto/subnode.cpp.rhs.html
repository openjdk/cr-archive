<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/subnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;gc/shared/barrierSet.hpp&quot;
  28 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/cfgnode.hpp&quot;
  33 #include &quot;opto/loopnode.hpp&quot;
  34 #include &quot;opto/matcher.hpp&quot;
  35 #include &quot;opto/movenode.hpp&quot;
  36 #include &quot;opto/mulnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/phaseX.hpp&quot;
  39 #include &quot;opto/subnode.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 
  42 // Portions of code courtesy of Clifford Click
  43 
  44 // Optimization - Graph Style
  45 
  46 #include &quot;math.h&quot;
  47 
  48 //=============================================================================
  49 //------------------------------Identity---------------------------------------
  50 // If right input is a constant 0, return the left input.
  51 Node* SubNode::Identity(PhaseGVN* phase) {
  52   assert(in(1) != this, &quot;Must already have called Value&quot;);
  53   assert(in(2) != this, &quot;Must already have called Value&quot;);
  54 
  55   // Remove double negation
  56   const Type *zero = add_id();
  57   if( phase-&gt;type( in(1) )-&gt;higher_equal( zero ) &amp;&amp;
  58       in(2)-&gt;Opcode() == Opcode() &amp;&amp;
  59       phase-&gt;type( in(2)-&gt;in(1) )-&gt;higher_equal( zero ) ) {
  60     return in(2)-&gt;in(2);
  61   }
  62 
  63   // Convert &quot;(X+Y) - Y&quot; into X and &quot;(X+Y) - X&quot; into Y
  64   if( in(1)-&gt;Opcode() == Op_AddI ) {
  65     if( phase-&gt;eqv(in(1)-&gt;in(2),in(2)) )
  66       return in(1)-&gt;in(1);
  67     if (phase-&gt;eqv(in(1)-&gt;in(1),in(2)))
  68       return in(1)-&gt;in(2);
  69 
  70     // Also catch: &quot;(X + Opaque2(Y)) - Y&quot;.  In this case, &#39;Y&#39; is a loop-varying
  71     // trip counter and X is likely to be loop-invariant (that&#39;s how O2 Nodes
  72     // are originally used, although the optimizer sometimes jiggers things).
  73     // This folding through an O2 removes a loop-exit use of a loop-varying
  74     // value and generally lowers register pressure in and around the loop.
  75     if( in(1)-&gt;in(2)-&gt;Opcode() == Op_Opaque2 &amp;&amp;
  76         phase-&gt;eqv(in(1)-&gt;in(2)-&gt;in(1),in(2)) )
  77       return in(1)-&gt;in(1);
  78   }
  79 
  80   return ( phase-&gt;type( in(2) )-&gt;higher_equal( zero ) ) ? in(1) : this;
  81 }
  82 
  83 //------------------------------Value------------------------------------------
  84 // A subtract node differences it&#39;s two inputs.
  85 const Type* SubNode::Value_common(PhaseTransform *phase) const {
  86   const Node* in1 = in(1);
  87   const Node* in2 = in(2);
  88   // Either input is TOP ==&gt; the result is TOP
  89   const Type* t1 = (in1 == this) ? Type::TOP : phase-&gt;type(in1);
  90   if( t1 == Type::TOP ) return Type::TOP;
  91   const Type* t2 = (in2 == this) ? Type::TOP : phase-&gt;type(in2);
  92   if( t2 == Type::TOP ) return Type::TOP;
  93 
  94   // Not correct for SubFnode and AddFNode (must check for infinity)
  95   // Equal?  Subtract is zero
  96   if (in1-&gt;eqv_uncast(in2))  return add_id();
  97 
  98   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
  99   if( t1 == Type::BOTTOM || t2 == Type::BOTTOM )
 100     return bottom_type();
 101 
 102   return NULL;
 103 }
 104 
 105 const Type* SubNode::Value(PhaseGVN* phase) const {
 106   const Type* t = Value_common(phase);
 107   if (t != NULL) {
 108     return t;
 109   }
 110   const Type* t1 = phase-&gt;type(in(1));
 111   const Type* t2 = phase-&gt;type(in(2));
 112   return sub(t1,t2);            // Local flavor of type subtraction
 113 
 114 }
 115 
 116 //=============================================================================
 117 //------------------------------Helper function--------------------------------
 118 
 119 static bool is_cloop_increment(Node* inc) {
 120   precond(inc-&gt;Opcode() == Op_AddI || inc-&gt;Opcode() == Op_AddL);
 121 
 122   if (!inc-&gt;in(1)-&gt;is_Phi()) {
 123     return false;
 124   }
 125   const PhiNode* phi = inc-&gt;in(1)-&gt;as_Phi();
 126 
 127   if (phi-&gt;is_copy() || !phi-&gt;region()-&gt;is_CountedLoop()) {
 128     return false;
 129   }
 130 
 131   return inc == phi-&gt;region()-&gt;as_CountedLoop()-&gt;incr();
 132 }
 133 
 134 // Given the expression &#39;(x + C) - v&#39;, or
 135 //                      &#39;v - (x + C)&#39;, we examine nodes &#39;+&#39; and &#39;v&#39;:
 136 //
 137 //  1. Do not convert if &#39;+&#39; is a counted-loop increment, because the &#39;-&#39; is
 138 //     loop invariant and converting extends the live-range of &#39;x&#39; to overlap
 139 //     with the &#39;+&#39;, forcing another register to be used in the loop.
 140 //
 141 //  2. Do not convert if &#39;v&#39; is a counted-loop induction variable, because
 142 //     &#39;x&#39; might be invariant.
 143 //
 144 static bool ok_to_convert(Node* inc, Node* var) {
 145   return !(is_cloop_increment(inc) || var-&gt;is_cloop_ind_var());
 146 }
 147 
 148 //------------------------------Ideal------------------------------------------
 149 Node *SubINode::Ideal(PhaseGVN *phase, bool can_reshape){
 150   Node *in1 = in(1);
 151   Node *in2 = in(2);
 152   uint op1 = in1-&gt;Opcode();
 153   uint op2 = in2-&gt;Opcode();
 154 
 155 #ifdef ASSERT
 156   // Check for dead loop
 157   if( phase-&gt;eqv( in1, this ) || phase-&gt;eqv( in2, this ) ||
 158       ( ( op1 == Op_AddI || op1 == Op_SubI ) &amp;&amp;
 159         ( phase-&gt;eqv( in1-&gt;in(1), this ) || phase-&gt;eqv( in1-&gt;in(2), this ) ||
 160           phase-&gt;eqv( in1-&gt;in(1), in1  ) || phase-&gt;eqv( in1-&gt;in(2), in1 ) ) ) )
 161     assert(false, &quot;dead loop in SubINode::Ideal&quot;);
 162 #endif
 163 
 164   const Type *t2 = phase-&gt;type( in2 );
 165   if( t2 == Type::TOP ) return NULL;
 166   // Convert &quot;x-c0&quot; into &quot;x+ -c0&quot;.
 167   if( t2-&gt;base() == Type::Int ){        // Might be bottom or top...
 168     const TypeInt *i = t2-&gt;is_int();
 169     if( i-&gt;is_con() )
 170       return new AddINode(in1, phase-&gt;intcon(-i-&gt;get_con()));
 171   }
 172 
 173   // Convert &quot;(x+c0) - y&quot; into (x-y) + c0&quot;
 174   // Do not collapse (x+c0)-y if &quot;+&quot; is a loop increment or
 175   // if &quot;y&quot; is a loop induction variable.
 176   if( op1 == Op_AddI &amp;&amp; ok_to_convert(in1, in2) ) {
 177     const Type *tadd = phase-&gt;type( in1-&gt;in(2) );
 178     if( tadd-&gt;singleton() &amp;&amp; tadd != Type::TOP ) {
 179       Node *sub2 = phase-&gt;transform( new SubINode( in1-&gt;in(1), in2 ));
 180       return new AddINode( sub2, in1-&gt;in(2) );
 181     }
 182   }
 183 
 184 
 185   // Convert &quot;x - (y+c0)&quot; into &quot;(x-y) - c0&quot;
 186   // Need the same check as in above optimization but reversed.
 187   if (op2 == Op_AddI &amp;&amp; ok_to_convert(in2, in1)) {
 188     Node* in21 = in2-&gt;in(1);
 189     Node* in22 = in2-&gt;in(2);
 190     const TypeInt* tcon = phase-&gt;type(in22)-&gt;isa_int();
 191     if (tcon != NULL &amp;&amp; tcon-&gt;is_con()) {
 192       Node* sub2 = phase-&gt;transform( new SubINode(in1, in21) );
 193       Node* neg_c0 = phase-&gt;intcon(- tcon-&gt;get_con());
 194       return new AddINode(sub2, neg_c0);
 195     }
 196   }
 197 
 198   const Type *t1 = phase-&gt;type( in1 );
 199   if( t1 == Type::TOP ) return NULL;
 200 
 201 #ifdef ASSERT
 202   // Check for dead loop
 203   if( ( op2 == Op_AddI || op2 == Op_SubI ) &amp;&amp;
 204       ( phase-&gt;eqv( in2-&gt;in(1), this ) || phase-&gt;eqv( in2-&gt;in(2), this ) ||
 205         phase-&gt;eqv( in2-&gt;in(1), in2  ) || phase-&gt;eqv( in2-&gt;in(2), in2  ) ) )
 206     assert(false, &quot;dead loop in SubINode::Ideal&quot;);
 207 #endif
 208 
 209   // Convert &quot;x - (x+y)&quot; into &quot;-y&quot;
 210   if( op2 == Op_AddI &amp;&amp;
 211       phase-&gt;eqv( in1, in2-&gt;in(1) ) )
 212     return new SubINode( phase-&gt;intcon(0),in2-&gt;in(2));
 213   // Convert &quot;(x-y) - x&quot; into &quot;-y&quot;
 214   if( op1 == Op_SubI &amp;&amp;
 215       phase-&gt;eqv( in1-&gt;in(1), in2 ) )
 216     return new SubINode( phase-&gt;intcon(0),in1-&gt;in(2));
 217   // Convert &quot;x - (y+x)&quot; into &quot;-y&quot;
 218   if( op2 == Op_AddI &amp;&amp;
 219       phase-&gt;eqv( in1, in2-&gt;in(2) ) )
 220     return new SubINode( phase-&gt;intcon(0),in2-&gt;in(1));
 221 
 222   // Convert &quot;0 - (x-y)&quot; into &quot;y-x&quot;
 223   if( t1 == TypeInt::ZERO &amp;&amp; op2 == Op_SubI )
 224     return new SubINode( in2-&gt;in(2), in2-&gt;in(1) );
 225 
 226   // Convert &quot;0 - (x+con)&quot; into &quot;-con-x&quot;
 227   jint con;
 228   if( t1 == TypeInt::ZERO &amp;&amp; op2 == Op_AddI &amp;&amp;
 229       (con = in2-&gt;in(2)-&gt;find_int_con(0)) != 0 )
 230     return new SubINode( phase-&gt;intcon(-con), in2-&gt;in(1) );
 231 
 232   // Convert &quot;(X+A) - (X+B)&quot; into &quot;A - B&quot;
 233   if( op1 == Op_AddI &amp;&amp; op2 == Op_AddI &amp;&amp; in1-&gt;in(1) == in2-&gt;in(1) )
 234     return new SubINode( in1-&gt;in(2), in2-&gt;in(2) );
 235 
 236   // Convert &quot;(A+X) - (B+X)&quot; into &quot;A - B&quot;
 237   if( op1 == Op_AddI &amp;&amp; op2 == Op_AddI &amp;&amp; in1-&gt;in(2) == in2-&gt;in(2) )
 238     return new SubINode( in1-&gt;in(1), in2-&gt;in(1) );
 239 
 240   // Convert &quot;(A+X) - (X+B)&quot; into &quot;A - B&quot;
 241   if( op1 == Op_AddI &amp;&amp; op2 == Op_AddI &amp;&amp; in1-&gt;in(2) == in2-&gt;in(1) )
 242     return new SubINode( in1-&gt;in(1), in2-&gt;in(2) );
 243 
 244   // Convert &quot;(X+A) - (B+X)&quot; into &quot;A - B&quot;
 245   if( op1 == Op_AddI &amp;&amp; op2 == Op_AddI &amp;&amp; in1-&gt;in(1) == in2-&gt;in(2) )
 246     return new SubINode( in1-&gt;in(2), in2-&gt;in(1) );
 247 
 248   // Convert &quot;A-(B-C)&quot; into (A+C)-B&quot;, since add is commutative and generally
 249   // nicer to optimize than subtract.
 250   if( op2 == Op_SubI &amp;&amp; in2-&gt;outcnt() == 1) {
 251     Node *add1 = phase-&gt;transform( new AddINode( in1, in2-&gt;in(2) ) );
 252     return new SubINode( add1, in2-&gt;in(1) );
 253   }
 254 
 255   // Convert &quot;0-(A&gt;&gt;31)&quot; into &quot;(A&gt;&gt;&gt;31)&quot;
 256   if ( op2 == Op_RShiftI ) {
 257     Node *in21 = in2-&gt;in(1);
 258     Node *in22 = in2-&gt;in(2);
 259     const TypeInt *zero = phase-&gt;type(in1)-&gt;isa_int();
 260     const TypeInt *t21 = phase-&gt;type(in21)-&gt;isa_int();
 261     const TypeInt *t22 = phase-&gt;type(in22)-&gt;isa_int();
 262     if ( t21 &amp;&amp; t22 &amp;&amp; zero == TypeInt::ZERO &amp;&amp; t22-&gt;is_con(31) ) {
 263       return new URShiftINode(in21, in22);
 264     }
 265   }
 266 
 267   return NULL;
 268 }
 269 
 270 //------------------------------sub--------------------------------------------
 271 // A subtract node differences it&#39;s two inputs.
 272 const Type *SubINode::sub( const Type *t1, const Type *t2 ) const {
 273   const TypeInt *r0 = t1-&gt;is_int(); // Handy access
 274   const TypeInt *r1 = t2-&gt;is_int();
 275   int32_t lo = java_subtract(r0-&gt;_lo, r1-&gt;_hi);
 276   int32_t hi = java_subtract(r0-&gt;_hi, r1-&gt;_lo);
 277 
 278   // We next check for 32-bit overflow.
 279   // If that happens, we just assume all integers are possible.
 280   if( (((r0-&gt;_lo ^ r1-&gt;_hi) &gt;= 0) ||    // lo ends have same signs OR
 281        ((r0-&gt;_lo ^      lo) &gt;= 0)) &amp;&amp;   // lo results have same signs AND
 282       (((r0-&gt;_hi ^ r1-&gt;_lo) &gt;= 0) ||    // hi ends have same signs OR
 283        ((r0-&gt;_hi ^      hi) &gt;= 0)) )    // hi results have same signs
 284     return TypeInt::make(lo,hi,MAX2(r0-&gt;_widen,r1-&gt;_widen));
 285   else                          // Overflow; assume all integers
 286     return TypeInt::INT;
 287 }
 288 
 289 //=============================================================================
 290 //------------------------------Ideal------------------------------------------
 291 Node *SubLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 292   Node *in1 = in(1);
 293   Node *in2 = in(2);
 294   uint op1 = in1-&gt;Opcode();
 295   uint op2 = in2-&gt;Opcode();
 296 
 297 #ifdef ASSERT
 298   // Check for dead loop
 299   if( phase-&gt;eqv( in1, this ) || phase-&gt;eqv( in2, this ) ||
 300       ( ( op1 == Op_AddL || op1 == Op_SubL ) &amp;&amp;
 301         ( phase-&gt;eqv( in1-&gt;in(1), this ) || phase-&gt;eqv( in1-&gt;in(2), this ) ||
 302           phase-&gt;eqv( in1-&gt;in(1), in1  ) || phase-&gt;eqv( in1-&gt;in(2), in1  ) ) ) )
 303     assert(false, &quot;dead loop in SubLNode::Ideal&quot;);
 304 #endif
 305 
 306   if( phase-&gt;type( in2 ) == Type::TOP ) return NULL;
 307   const TypeLong *i = phase-&gt;type( in2 )-&gt;isa_long();
 308   // Convert &quot;x-c0&quot; into &quot;x+ -c0&quot;.
 309   if( i &amp;&amp;                      // Might be bottom or top...
 310       i-&gt;is_con() )
 311     return new AddLNode(in1, phase-&gt;longcon(-i-&gt;get_con()));
 312 
 313   // Convert &quot;(x+c0) - y&quot; into (x-y) + c0&quot;
 314   // Do not collapse (x+c0)-y if &quot;+&quot; is a loop increment or
 315   // if &quot;y&quot; is a loop induction variable.
 316   if( op1 == Op_AddL &amp;&amp; ok_to_convert(in1, in2) ) {
 317     Node *in11 = in1-&gt;in(1);
 318     const Type *tadd = phase-&gt;type( in1-&gt;in(2) );
 319     if( tadd-&gt;singleton() &amp;&amp; tadd != Type::TOP ) {
 320       Node *sub2 = phase-&gt;transform( new SubLNode( in11, in2 ));
 321       return new AddLNode( sub2, in1-&gt;in(2) );
 322     }
 323   }
 324 
 325   // Convert &quot;x - (y+c0)&quot; into &quot;(x-y) - c0&quot;
 326   // Need the same check as in above optimization but reversed.
 327   if (op2 == Op_AddL &amp;&amp; ok_to_convert(in2, in1)) {
 328     Node* in21 = in2-&gt;in(1);
 329     Node* in22 = in2-&gt;in(2);
 330     const TypeLong* tcon = phase-&gt;type(in22)-&gt;isa_long();
 331     if (tcon != NULL &amp;&amp; tcon-&gt;is_con()) {
 332       Node* sub2 = phase-&gt;transform( new SubLNode(in1, in21) );
 333       Node* neg_c0 = phase-&gt;longcon(- tcon-&gt;get_con());
 334       return new AddLNode(sub2, neg_c0);
 335     }
 336   }
 337 
 338   const Type *t1 = phase-&gt;type( in1 );
 339   if( t1 == Type::TOP ) return NULL;
 340 
 341 #ifdef ASSERT
 342   // Check for dead loop
 343   if( ( op2 == Op_AddL || op2 == Op_SubL ) &amp;&amp;
 344       ( phase-&gt;eqv( in2-&gt;in(1), this ) || phase-&gt;eqv( in2-&gt;in(2), this ) ||
 345         phase-&gt;eqv( in2-&gt;in(1), in2  ) || phase-&gt;eqv( in2-&gt;in(2), in2  ) ) )
 346     assert(false, &quot;dead loop in SubLNode::Ideal&quot;);
 347 #endif
 348 
 349   // Convert &quot;x - (x+y)&quot; into &quot;-y&quot;
 350   if( op2 == Op_AddL &amp;&amp;
 351       phase-&gt;eqv( in1, in2-&gt;in(1) ) )
 352     return new SubLNode( phase-&gt;makecon(TypeLong::ZERO), in2-&gt;in(2));
 353   // Convert &quot;x - (y+x)&quot; into &quot;-y&quot;
 354   if( op2 == Op_AddL &amp;&amp;
 355       phase-&gt;eqv( in1, in2-&gt;in(2) ) )
 356     return new SubLNode( phase-&gt;makecon(TypeLong::ZERO),in2-&gt;in(1));
 357 
 358   // Convert &quot;0 - (x-y)&quot; into &quot;y-x&quot;
 359   if( phase-&gt;type( in1 ) == TypeLong::ZERO &amp;&amp; op2 == Op_SubL )
 360     return new SubLNode( in2-&gt;in(2), in2-&gt;in(1) );
 361 
 362   // Convert &quot;(X+A) - (X+B)&quot; into &quot;A - B&quot;
 363   if( op1 == Op_AddL &amp;&amp; op2 == Op_AddL &amp;&amp; in1-&gt;in(1) == in2-&gt;in(1) )
 364     return new SubLNode( in1-&gt;in(2), in2-&gt;in(2) );
 365 
 366   // Convert &quot;(A+X) - (B+X)&quot; into &quot;A - B&quot;
 367   if( op1 == Op_AddL &amp;&amp; op2 == Op_AddL &amp;&amp; in1-&gt;in(2) == in2-&gt;in(2) )
 368     return new SubLNode( in1-&gt;in(1), in2-&gt;in(1) );
 369 
 370   // Convert &quot;A-(B-C)&quot; into (A+C)-B&quot;
 371   if( op2 == Op_SubL &amp;&amp; in2-&gt;outcnt() == 1) {
 372     Node *add1 = phase-&gt;transform( new AddLNode( in1, in2-&gt;in(2) ) );
 373     return new SubLNode( add1, in2-&gt;in(1) );
 374   }
 375 
 376   // Convert &quot;0L-(A&gt;&gt;63)&quot; into &quot;(A&gt;&gt;&gt;63)&quot;
 377   if ( op2 == Op_RShiftL ) {
 378     Node *in21 = in2-&gt;in(1);
 379     Node *in22 = in2-&gt;in(2);
 380     const TypeLong *zero = phase-&gt;type(in1)-&gt;isa_long();
 381     const TypeLong *t21 = phase-&gt;type(in21)-&gt;isa_long();
 382     const TypeInt *t22 = phase-&gt;type(in22)-&gt;isa_int();
 383     if ( t21 &amp;&amp; t22 &amp;&amp; zero == TypeLong::ZERO &amp;&amp; t22-&gt;is_con(63) ) {
 384       return new URShiftLNode(in21, in22);
 385     }
 386   }
 387 
 388   return NULL;
 389 }
 390 
 391 //------------------------------sub--------------------------------------------
 392 // A subtract node differences it&#39;s two inputs.
 393 const Type *SubLNode::sub( const Type *t1, const Type *t2 ) const {
 394   const TypeLong *r0 = t1-&gt;is_long(); // Handy access
 395   const TypeLong *r1 = t2-&gt;is_long();
 396   jlong lo = java_subtract(r0-&gt;_lo, r1-&gt;_hi);
 397   jlong hi = java_subtract(r0-&gt;_hi, r1-&gt;_lo);
 398 
 399   // We next check for 32-bit overflow.
 400   // If that happens, we just assume all integers are possible.
 401   if( (((r0-&gt;_lo ^ r1-&gt;_hi) &gt;= 0) ||    // lo ends have same signs OR
 402        ((r0-&gt;_lo ^      lo) &gt;= 0)) &amp;&amp;   // lo results have same signs AND
 403       (((r0-&gt;_hi ^ r1-&gt;_lo) &gt;= 0) ||    // hi ends have same signs OR
 404        ((r0-&gt;_hi ^      hi) &gt;= 0)) )    // hi results have same signs
 405     return TypeLong::make(lo,hi,MAX2(r0-&gt;_widen,r1-&gt;_widen));
 406   else                          // Overflow; assume all integers
 407     return TypeLong::LONG;
 408 }
 409 
 410 //=============================================================================
 411 //------------------------------Value------------------------------------------
 412 // A subtract node differences its two inputs.
 413 const Type* SubFPNode::Value(PhaseGVN* phase) const {
 414   const Node* in1 = in(1);
 415   const Node* in2 = in(2);
 416   // Either input is TOP ==&gt; the result is TOP
 417   const Type* t1 = (in1 == this) ? Type::TOP : phase-&gt;type(in1);
 418   if( t1 == Type::TOP ) return Type::TOP;
 419   const Type* t2 = (in2 == this) ? Type::TOP : phase-&gt;type(in2);
 420   if( t2 == Type::TOP ) return Type::TOP;
 421 
 422   // if both operands are infinity of same sign, the result is NaN; do
 423   // not replace with zero
 424   if( (t1-&gt;is_finite() &amp;&amp; t2-&gt;is_finite()) ) {
 425     if( phase-&gt;eqv(in1, in2) ) return add_id();
 426   }
 427 
 428   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 429   const Type *bot = bottom_type();
 430   if( (t1 == bot) || (t2 == bot) ||
 431       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 432     return bot;
 433 
 434   return sub(t1,t2);            // Local flavor of type subtraction
 435 }
 436 
 437 
 438 //=============================================================================
 439 //------------------------------Ideal------------------------------------------
 440 Node *SubFNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 441   const Type *t2 = phase-&gt;type( in(2) );
 442   // Convert &quot;x-c0&quot; into &quot;x+ -c0&quot;.
 443   if( t2-&gt;base() == Type::FloatCon ) {  // Might be bottom or top...
 444     // return new (phase-&gt;C, 3) AddFNode(in(1), phase-&gt;makecon( TypeF::make(-t2-&gt;getf()) ) );
 445   }
 446 
 447   // Not associative because of boundary conditions (infinity)
 448   if( IdealizedNumerics &amp;&amp; !phase-&gt;C-&gt;method()-&gt;is_strict() ) {
 449     // Convert &quot;x - (x+y)&quot; into &quot;-y&quot;
 450     if( in(2)-&gt;is_Add() &amp;&amp;
 451         phase-&gt;eqv(in(1),in(2)-&gt;in(1) ) )
 452       return new SubFNode( phase-&gt;makecon(TypeF::ZERO),in(2)-&gt;in(2));
 453   }
 454 
 455   // Cannot replace 0.0-X with -X because a &#39;fsub&#39; bytecode computes
 456   // 0.0-0.0 as +0.0, while a &#39;fneg&#39; bytecode computes -0.0.
 457   //if( phase-&gt;type(in(1)) == TypeF::ZERO )
 458   //return new (phase-&gt;C, 2) NegFNode(in(2));
 459 
 460   return NULL;
 461 }
 462 
 463 //------------------------------sub--------------------------------------------
 464 // A subtract node differences its two inputs.
 465 const Type *SubFNode::sub( const Type *t1, const Type *t2 ) const {
 466   // no folding if one of operands is infinity or NaN, do not do constant folding
 467   if( g_isfinite(t1-&gt;getf()) &amp;&amp; g_isfinite(t2-&gt;getf()) ) {
 468     return TypeF::make( t1-&gt;getf() - t2-&gt;getf() );
 469   }
 470   else if( g_isnan(t1-&gt;getf()) ) {
 471     return t1;
 472   }
 473   else if( g_isnan(t2-&gt;getf()) ) {
 474     return t2;
 475   }
 476   else {
 477     return Type::FLOAT;
 478   }
 479 }
 480 
 481 //=============================================================================
 482 //------------------------------Ideal------------------------------------------
 483 Node *SubDNode::Ideal(PhaseGVN *phase, bool can_reshape){
 484   const Type *t2 = phase-&gt;type( in(2) );
 485   // Convert &quot;x-c0&quot; into &quot;x+ -c0&quot;.
 486   if( t2-&gt;base() == Type::DoubleCon ) { // Might be bottom or top...
 487     // return new (phase-&gt;C, 3) AddDNode(in(1), phase-&gt;makecon( TypeD::make(-t2-&gt;getd()) ) );
 488   }
 489 
 490   // Not associative because of boundary conditions (infinity)
 491   if( IdealizedNumerics &amp;&amp; !phase-&gt;C-&gt;method()-&gt;is_strict() ) {
 492     // Convert &quot;x - (x+y)&quot; into &quot;-y&quot;
 493     if( in(2)-&gt;is_Add() &amp;&amp;
 494         phase-&gt;eqv(in(1),in(2)-&gt;in(1) ) )
 495       return new SubDNode( phase-&gt;makecon(TypeD::ZERO),in(2)-&gt;in(2));
 496   }
 497 
 498   // Cannot replace 0.0-X with -X because a &#39;dsub&#39; bytecode computes
 499   // 0.0-0.0 as +0.0, while a &#39;dneg&#39; bytecode computes -0.0.
 500   //if( phase-&gt;type(in(1)) == TypeD::ZERO )
 501   //return new (phase-&gt;C, 2) NegDNode(in(2));
 502 
 503   return NULL;
 504 }
 505 
 506 //------------------------------sub--------------------------------------------
 507 // A subtract node differences its two inputs.
 508 const Type *SubDNode::sub( const Type *t1, const Type *t2 ) const {
 509   // no folding if one of operands is infinity or NaN, do not do constant folding
 510   if( g_isfinite(t1-&gt;getd()) &amp;&amp; g_isfinite(t2-&gt;getd()) ) {
 511     return TypeD::make( t1-&gt;getd() - t2-&gt;getd() );
 512   }
 513   else if( g_isnan(t1-&gt;getd()) ) {
 514     return t1;
 515   }
 516   else if( g_isnan(t2-&gt;getd()) ) {
 517     return t2;
 518   }
 519   else {
 520     return Type::DOUBLE;
 521   }
 522 }
 523 
 524 //=============================================================================
 525 //------------------------------Idealize---------------------------------------
 526 // Unlike SubNodes, compare must still flatten return value to the
 527 // range -1, 0, 1.
 528 // And optimizations like those for (X + Y) - X fail if overflow happens.
 529 Node* CmpNode::Identity(PhaseGVN* phase) {
 530   return this;
 531 }
 532 
 533 #ifndef PRODUCT
 534 //----------------------------related------------------------------------------
 535 // Related nodes of comparison nodes include all data inputs (until hitting a
 536 // control boundary) as well as all outputs until and including control nodes
 537 // as well as their projections. In compact mode, data inputs till depth 1 and
 538 // all outputs till depth 1 are considered.
 539 void CmpNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
 540   if (compact) {
 541     this-&gt;collect_nodes(in_rel, 1, false, true);
 542     this-&gt;collect_nodes(out_rel, -1, false, false);
 543   } else {
 544     this-&gt;collect_nodes_in_all_data(in_rel, false);
 545     this-&gt;collect_nodes_out_all_ctrl_boundary(out_rel);
 546     // Now, find all control nodes in out_rel, and include their projections
 547     // and projection targets (if any) in the result.
 548     GrowableArray&lt;Node*&gt; proj(Compile::current()-&gt;unique());
 549     for (GrowableArrayIterator&lt;Node*&gt; it = out_rel-&gt;begin(); it != out_rel-&gt;end(); ++it) {
 550       Node* n = *it;
 551       if (n-&gt;is_CFG() &amp;&amp; !n-&gt;is_Proj()) {
 552         // Assume projections and projection targets are found at levels 1 and 2.
 553         n-&gt;collect_nodes(&amp;proj, -2, false, false);
 554         for (GrowableArrayIterator&lt;Node*&gt; p = proj.begin(); p != proj.end(); ++p) {
 555           out_rel-&gt;append_if_missing(*p);
 556         }
 557         proj.clear();
 558       }
 559     }
 560   }
 561 }
 562 #endif
 563 
 564 //=============================================================================
 565 //------------------------------cmp--------------------------------------------
 566 // Simplify a CmpI (compare 2 integers) node, based on local information.
 567 // If both inputs are constants, compare them.
 568 const Type *CmpINode::sub( const Type *t1, const Type *t2 ) const {
 569   const TypeInt *r0 = t1-&gt;is_int(); // Handy access
 570   const TypeInt *r1 = t2-&gt;is_int();
 571 
 572   if( r0-&gt;_hi &lt; r1-&gt;_lo )       // Range is always low?
 573     return TypeInt::CC_LT;
 574   else if( r0-&gt;_lo &gt; r1-&gt;_hi )  // Range is always high?
 575     return TypeInt::CC_GT;
 576 
 577   else if( r0-&gt;is_con() &amp;&amp; r1-&gt;is_con() ) { // comparing constants?
 578     assert(r0-&gt;get_con() == r1-&gt;get_con(), &quot;must be equal&quot;);
 579     return TypeInt::CC_EQ;      // Equal results.
 580   } else if( r0-&gt;_hi == r1-&gt;_lo ) // Range is never high?
 581     return TypeInt::CC_LE;
 582   else if( r0-&gt;_lo == r1-&gt;_hi ) // Range is never low?
 583     return TypeInt::CC_GE;
 584   return TypeInt::CC;           // else use worst case results
 585 }
 586 
 587 // Simplify a CmpU (compare 2 integers) node, based on local information.
 588 // If both inputs are constants, compare them.
 589 const Type *CmpUNode::sub( const Type *t1, const Type *t2 ) const {
 590   assert(!t1-&gt;isa_ptr(), &quot;obsolete usage of CmpU&quot;);
 591 
 592   // comparing two unsigned ints
 593   const TypeInt *r0 = t1-&gt;is_int();   // Handy access
 594   const TypeInt *r1 = t2-&gt;is_int();
 595 
 596   // Current installed version
 597   // Compare ranges for non-overlap
 598   juint lo0 = r0-&gt;_lo;
 599   juint hi0 = r0-&gt;_hi;
 600   juint lo1 = r1-&gt;_lo;
 601   juint hi1 = r1-&gt;_hi;
 602 
 603   // If either one has both negative and positive values,
 604   // it therefore contains both 0 and -1, and since [0..-1] is the
 605   // full unsigned range, the type must act as an unsigned bottom.
 606   bool bot0 = ((jint)(lo0 ^ hi0) &lt; 0);
 607   bool bot1 = ((jint)(lo1 ^ hi1) &lt; 0);
 608 
 609   if (bot0 || bot1) {
 610     // All unsigned values are LE -1 and GE 0.
 611     if (lo0 == 0 &amp;&amp; hi0 == 0) {
 612       return TypeInt::CC_LE;            //   0 &lt;= bot
 613     } else if ((jint)lo0 == -1 &amp;&amp; (jint)hi0 == -1) {
 614       return TypeInt::CC_GE;            // -1 &gt;= bot
 615     } else if (lo1 == 0 &amp;&amp; hi1 == 0) {
 616       return TypeInt::CC_GE;            // bot &gt;= 0
 617     } else if ((jint)lo1 == -1 &amp;&amp; (jint)hi1 == -1) {
 618       return TypeInt::CC_LE;            // bot &lt;= -1
 619     }
 620   } else {
 621     // We can use ranges of the form [lo..hi] if signs are the same.
 622     assert(lo0 &lt;= hi0 &amp;&amp; lo1 &lt;= hi1, &quot;unsigned ranges are valid&quot;);
 623     // results are reversed, &#39;-&#39; &gt; &#39;+&#39; for unsigned compare
 624     if (hi0 &lt; lo1) {
 625       return TypeInt::CC_LT;            // smaller
 626     } else if (lo0 &gt; hi1) {
 627       return TypeInt::CC_GT;            // greater
 628     } else if (hi0 == lo1 &amp;&amp; lo0 == hi1) {
 629       return TypeInt::CC_EQ;            // Equal results
 630     } else if (lo0 &gt;= hi1) {
 631       return TypeInt::CC_GE;
 632     } else if (hi0 &lt;= lo1) {
 633       // Check for special case in Hashtable::get.  (See below.)
 634       if ((jint)lo0 &gt;= 0 &amp;&amp; (jint)lo1 &gt;= 0 &amp;&amp; is_index_range_check())
 635         return TypeInt::CC_LT;
 636       return TypeInt::CC_LE;
 637     }
 638   }
 639   // Check for special case in Hashtable::get - the hash index is
 640   // mod&#39;ed to the table size so the following range check is useless.
 641   // Check for: (X Mod Y) CmpU Y, where the mod result and Y both have
 642   // to be positive.
 643   // (This is a gross hack, since the sub method never
 644   // looks at the structure of the node in any other case.)
 645   if ((jint)lo0 &gt;= 0 &amp;&amp; (jint)lo1 &gt;= 0 &amp;&amp; is_index_range_check())
 646     return TypeInt::CC_LT;
 647   return TypeInt::CC;                   // else use worst case results
 648 }
 649 
 650 const Type* CmpUNode::Value(PhaseGVN* phase) const {
 651   const Type* t = SubNode::Value_common(phase);
 652   if (t != NULL) {
 653     return t;
 654   }
 655   const Node* in1 = in(1);
 656   const Node* in2 = in(2);
 657   const Type* t1 = phase-&gt;type(in1);
 658   const Type* t2 = phase-&gt;type(in2);
 659   assert(t1-&gt;isa_int(), &quot;CmpU has only Int type inputs&quot;);
 660   if (t2 == TypeInt::INT) { // Compare to bottom?
 661     return bottom_type();
 662   }
 663   uint in1_op = in1-&gt;Opcode();
 664   if (in1_op == Op_AddI || in1_op == Op_SubI) {
 665     // The problem rise when result of AddI(SubI) may overflow
 666     // signed integer value. Let say the input type is
 667     // [256, maxint] then +128 will create 2 ranges due to
 668     // overflow: [minint, minint+127] and [384, maxint].
 669     // But C2 type system keep only 1 type range and as result
 670     // it use general [minint, maxint] for this case which we
 671     // can&#39;t optimize.
 672     //
 673     // Make 2 separate type ranges based on types of AddI(SubI) inputs
 674     // and compare results of their compare. If results are the same
 675     // CmpU node can be optimized.
 676     const Node* in11 = in1-&gt;in(1);
 677     const Node* in12 = in1-&gt;in(2);
 678     const Type* t11 = (in11 == in1) ? Type::TOP : phase-&gt;type(in11);
 679     const Type* t12 = (in12 == in1) ? Type::TOP : phase-&gt;type(in12);
 680     // Skip cases when input types are top or bottom.
 681     if ((t11 != Type::TOP) &amp;&amp; (t11 != TypeInt::INT) &amp;&amp;
 682         (t12 != Type::TOP) &amp;&amp; (t12 != TypeInt::INT)) {
 683       const TypeInt *r0 = t11-&gt;is_int();
 684       const TypeInt *r1 = t12-&gt;is_int();
 685       jlong lo_r0 = r0-&gt;_lo;
 686       jlong hi_r0 = r0-&gt;_hi;
 687       jlong lo_r1 = r1-&gt;_lo;
 688       jlong hi_r1 = r1-&gt;_hi;
 689       if (in1_op == Op_SubI) {
 690         jlong tmp = hi_r1;
 691         hi_r1 = -lo_r1;
 692         lo_r1 = -tmp;
 693         // Note, for substructing [minint,x] type range
 694         // long arithmetic provides correct overflow answer.
 695         // The confusion come from the fact that in 32-bit
 696         // -minint == minint but in 64-bit -minint == maxint+1.
 697       }
 698       jlong lo_long = lo_r0 + lo_r1;
 699       jlong hi_long = hi_r0 + hi_r1;
 700       int lo_tr1 = min_jint;
 701       int hi_tr1 = (int)hi_long;
 702       int lo_tr2 = (int)lo_long;
 703       int hi_tr2 = max_jint;
 704       bool underflow = lo_long != (jlong)lo_tr2;
 705       bool overflow  = hi_long != (jlong)hi_tr1;
 706       // Use sub(t1, t2) when there is no overflow (one type range)
 707       // or when both overflow and underflow (too complex).
 708       if ((underflow != overflow) &amp;&amp; (hi_tr1 &lt; lo_tr2)) {
 709         // Overflow only on one boundary, compare 2 separate type ranges.
 710         int w = MAX2(r0-&gt;_widen, r1-&gt;_widen); // _widen does not matter here
 711         const TypeInt* tr1 = TypeInt::make(lo_tr1, hi_tr1, w);
 712         const TypeInt* tr2 = TypeInt::make(lo_tr2, hi_tr2, w);
 713         const Type* cmp1 = sub(tr1, t2);
 714         const Type* cmp2 = sub(tr2, t2);
 715         if (cmp1 == cmp2) {
 716           return cmp1; // Hit!
 717         }
 718       }
 719     }
 720   }
 721 
 722   return sub(t1, t2);            // Local flavor of type subtraction
 723 }
 724 
 725 bool CmpUNode::is_index_range_check() const {
 726   // Check for the &quot;(X ModI Y) CmpU Y&quot; shape
 727   return (in(1)-&gt;Opcode() == Op_ModI &amp;&amp;
 728           in(1)-&gt;in(2)-&gt;eqv_uncast(in(2)));
 729 }
 730 
 731 //------------------------------Idealize---------------------------------------
 732 Node *CmpINode::Ideal( PhaseGVN *phase, bool can_reshape ) {
 733   if (phase-&gt;type(in(2))-&gt;higher_equal(TypeInt::ZERO)) {
 734     switch (in(1)-&gt;Opcode()) {
 735     case Op_CmpL3:              // Collapse a CmpL3/CmpI into a CmpL
 736       return new CmpLNode(in(1)-&gt;in(1),in(1)-&gt;in(2));
 737     case Op_CmpF3:              // Collapse a CmpF3/CmpI into a CmpF
 738       return new CmpFNode(in(1)-&gt;in(1),in(1)-&gt;in(2));
 739     case Op_CmpD3:              // Collapse a CmpD3/CmpI into a CmpD
 740       return new CmpDNode(in(1)-&gt;in(1),in(1)-&gt;in(2));
 741     //case Op_SubI:
 742       // If (x - y) cannot overflow, then ((x - y) &lt;?&gt; 0)
 743       // can be turned into (x &lt;?&gt; y).
 744       // This is handled (with more general cases) by Ideal_sub_algebra.
 745     }
 746   }
 747   return NULL;                  // No change
 748 }
 749 
<a name="1" id="anc1"></a><span class="line-modified"> 750 //------------------------------Ideal------------------------------------------</span>
<span class="line-added"> 751 Node* CmpLNode::Ideal(PhaseGVN* phase, bool can_reshape) {</span>
<span class="line-added"> 752   Node* a = NULL;</span>
<span class="line-added"> 753   Node* b = NULL;</span>
<span class="line-added"> 754   if (is_double_null_check(phase, a, b) &amp;&amp; (phase-&gt;type(a)-&gt;is_zero_type() || phase-&gt;type(b)-&gt;is_zero_type())) {</span>
<span class="line-added"> 755     // Degraded to a simple null check, use old acmp</span>
<span class="line-added"> 756     return new CmpPNode(a, b);</span>
<span class="line-added"> 757   }</span>
 758   const TypeLong *t2 = phase-&gt;type(in(2))-&gt;isa_long();
 759   if (Opcode() == Op_CmpL &amp;&amp; in(1)-&gt;Opcode() == Op_ConvI2L &amp;&amp; t2 &amp;&amp; t2-&gt;is_con()) {
 760     const jlong con = t2-&gt;get_con();
 761     if (con &gt;= min_jint &amp;&amp; con &lt;= max_jint) {
 762       return new CmpINode(in(1)-&gt;in(1), phase-&gt;intcon((jint)con));
 763     }
 764   }
 765   return NULL;
 766 }
 767 
<a name="2" id="anc2"></a><span class="line-added"> 768 // Match double null check emitted by Compile::optimize_acmp()</span>
<span class="line-added"> 769 bool CmpLNode::is_double_null_check(PhaseGVN* phase, Node*&amp; a, Node*&amp; b) const {</span>
<span class="line-added"> 770   if (in(1)-&gt;Opcode() == Op_OrL &amp;&amp;</span>
<span class="line-added"> 771       in(1)-&gt;in(1)-&gt;Opcode() == Op_CastP2X &amp;&amp;</span>
<span class="line-added"> 772       in(1)-&gt;in(2)-&gt;Opcode() == Op_CastP2X &amp;&amp;</span>
<span class="line-added"> 773       in(2)-&gt;bottom_type()-&gt;is_zero_type()) {</span>
<span class="line-added"> 774     assert(EnableValhalla, &quot;unexpected double null check&quot;);</span>
<span class="line-added"> 775     a = in(1)-&gt;in(1)-&gt;in(1);</span>
<span class="line-added"> 776     b = in(1)-&gt;in(2)-&gt;in(1);</span>
<span class="line-added"> 777     return true;</span>
<span class="line-added"> 778   }</span>
<span class="line-added"> 779   return false;</span>
<span class="line-added"> 780 }</span>
<span class="line-added"> 781 </span>
<span class="line-added"> 782 //------------------------------Value------------------------------------------</span>
<span class="line-added"> 783 const Type* CmpLNode::Value(PhaseGVN* phase) const {</span>
<span class="line-added"> 784   Node* a = NULL;</span>
<span class="line-added"> 785   Node* b = NULL;</span>
<span class="line-added"> 786   if (is_double_null_check(phase, a, b) &amp;&amp; (!phase-&gt;type(a)-&gt;maybe_null() || !phase-&gt;type(b)-&gt;maybe_null())) {</span>
<span class="line-added"> 787     // One operand is never NULL, emit constant false</span>
<span class="line-added"> 788     return TypeInt::CC_GT;</span>
<span class="line-added"> 789   }</span>
<span class="line-added"> 790   return SubNode::Value(phase);</span>
<span class="line-added"> 791 }</span>
<span class="line-added"> 792 </span>
 793 //=============================================================================
 794 // Simplify a CmpL (compare 2 longs ) node, based on local information.
 795 // If both inputs are constants, compare them.
 796 const Type *CmpLNode::sub( const Type *t1, const Type *t2 ) const {
 797   const TypeLong *r0 = t1-&gt;is_long(); // Handy access
 798   const TypeLong *r1 = t2-&gt;is_long();
 799 
 800   if( r0-&gt;_hi &lt; r1-&gt;_lo )       // Range is always low?
 801     return TypeInt::CC_LT;
 802   else if( r0-&gt;_lo &gt; r1-&gt;_hi )  // Range is always high?
 803     return TypeInt::CC_GT;
 804 
 805   else if( r0-&gt;is_con() &amp;&amp; r1-&gt;is_con() ) { // comparing constants?
 806     assert(r0-&gt;get_con() == r1-&gt;get_con(), &quot;must be equal&quot;);
 807     return TypeInt::CC_EQ;      // Equal results.
 808   } else if( r0-&gt;_hi == r1-&gt;_lo ) // Range is never high?
 809     return TypeInt::CC_LE;
 810   else if( r0-&gt;_lo == r1-&gt;_hi ) // Range is never low?
 811     return TypeInt::CC_GE;
 812   return TypeInt::CC;           // else use worst case results
 813 }
 814 
 815 
 816 // Simplify a CmpUL (compare 2 unsigned longs) node, based on local information.
 817 // If both inputs are constants, compare them.
 818 const Type* CmpULNode::sub(const Type* t1, const Type* t2) const {
 819   assert(!t1-&gt;isa_ptr(), &quot;obsolete usage of CmpUL&quot;);
 820 
 821   // comparing two unsigned longs
 822   const TypeLong* r0 = t1-&gt;is_long();   // Handy access
 823   const TypeLong* r1 = t2-&gt;is_long();
 824 
 825   // Current installed version
 826   // Compare ranges for non-overlap
 827   julong lo0 = r0-&gt;_lo;
 828   julong hi0 = r0-&gt;_hi;
 829   julong lo1 = r1-&gt;_lo;
 830   julong hi1 = r1-&gt;_hi;
 831 
 832   // If either one has both negative and positive values,
 833   // it therefore contains both 0 and -1, and since [0..-1] is the
 834   // full unsigned range, the type must act as an unsigned bottom.
 835   bool bot0 = ((jlong)(lo0 ^ hi0) &lt; 0);
 836   bool bot1 = ((jlong)(lo1 ^ hi1) &lt; 0);
 837 
 838   if (bot0 || bot1) {
 839     // All unsigned values are LE -1 and GE 0.
 840     if (lo0 == 0 &amp;&amp; hi0 == 0) {
 841       return TypeInt::CC_LE;            //   0 &lt;= bot
 842     } else if ((jlong)lo0 == -1 &amp;&amp; (jlong)hi0 == -1) {
 843       return TypeInt::CC_GE;            // -1 &gt;= bot
 844     } else if (lo1 == 0 &amp;&amp; hi1 == 0) {
 845       return TypeInt::CC_GE;            // bot &gt;= 0
 846     } else if ((jlong)lo1 == -1 &amp;&amp; (jlong)hi1 == -1) {
 847       return TypeInt::CC_LE;            // bot &lt;= -1
 848     }
 849   } else {
 850     // We can use ranges of the form [lo..hi] if signs are the same.
 851     assert(lo0 &lt;= hi0 &amp;&amp; lo1 &lt;= hi1, &quot;unsigned ranges are valid&quot;);
 852     // results are reversed, &#39;-&#39; &gt; &#39;+&#39; for unsigned compare
 853     if (hi0 &lt; lo1) {
 854       return TypeInt::CC_LT;            // smaller
 855     } else if (lo0 &gt; hi1) {
 856       return TypeInt::CC_GT;            // greater
 857     } else if (hi0 == lo1 &amp;&amp; lo0 == hi1) {
 858       return TypeInt::CC_EQ;            // Equal results
 859     } else if (lo0 &gt;= hi1) {
 860       return TypeInt::CC_GE;
 861     } else if (hi0 &lt;= lo1) {
 862       return TypeInt::CC_LE;
 863     }
 864   }
 865 
 866   return TypeInt::CC;                   // else use worst case results
 867 }
 868 
 869 //=============================================================================
 870 //------------------------------sub--------------------------------------------
 871 // Simplify an CmpP (compare 2 pointers) node, based on local information.
 872 // If both inputs are constants, compare them.
 873 const Type *CmpPNode::sub( const Type *t1, const Type *t2 ) const {
 874   const TypePtr *r0 = t1-&gt;is_ptr(); // Handy access
 875   const TypePtr *r1 = t2-&gt;is_ptr();
 876 
 877   // Undefined inputs makes for an undefined result
 878   if( TypePtr::above_centerline(r0-&gt;_ptr) ||
 879       TypePtr::above_centerline(r1-&gt;_ptr) )
 880     return Type::TOP;
 881 
 882   if (r0 == r1 &amp;&amp; r0-&gt;singleton()) {
 883     // Equal pointer constants (klasses, nulls, etc.)
 884     return TypeInt::CC_EQ;
 885   }
 886 
 887   // See if it is 2 unrelated classes.
 888   const TypeOopPtr* oop_p0 = r0-&gt;isa_oopptr();
 889   const TypeOopPtr* oop_p1 = r1-&gt;isa_oopptr();
 890   bool both_oop_ptr = oop_p0 &amp;&amp; oop_p1;
 891 
 892   if (both_oop_ptr) {
 893     Node* in1 = in(1)-&gt;uncast();
 894     Node* in2 = in(2)-&gt;uncast();
 895     AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, NULL);
 896     AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, NULL);
 897     if (MemNode::detect_ptr_independence(in1, alloc1, in2, alloc2, NULL)) {
 898       return TypeInt::CC_GT;  // different pointers
 899     }
 900   }
 901 
 902   const TypeKlassPtr* klass_p0 = r0-&gt;isa_klassptr();
 903   const TypeKlassPtr* klass_p1 = r1-&gt;isa_klassptr();
 904 
 905   if (both_oop_ptr || (klass_p0 &amp;&amp; klass_p1)) { // both or neither are klass pointers
 906     ciKlass* klass0 = NULL;
 907     bool    xklass0 = false;
 908     ciKlass* klass1 = NULL;
 909     bool    xklass1 = false;
 910 
 911     if (oop_p0) {
 912       klass0 = oop_p0-&gt;klass();
 913       xklass0 = oop_p0-&gt;klass_is_exact();
 914     } else {
 915       assert(klass_p0, &quot;must be non-null if oop_p0 is null&quot;);
 916       klass0 = klass_p0-&gt;klass();
 917       xklass0 = klass_p0-&gt;klass_is_exact();
 918     }
 919 
 920     if (oop_p1) {
 921       klass1 = oop_p1-&gt;klass();
 922       xklass1 = oop_p1-&gt;klass_is_exact();
 923     } else {
 924       assert(klass_p1, &quot;must be non-null if oop_p1 is null&quot;);
 925       klass1 = klass_p1-&gt;klass();
 926       xklass1 = klass_p1-&gt;klass_is_exact();
 927     }
 928 
 929     if (klass0 &amp;&amp; klass1 &amp;&amp;
 930         klass0-&gt;is_loaded() &amp;&amp; !klass0-&gt;is_interface() &amp;&amp; // do not trust interfaces
 931         klass1-&gt;is_loaded() &amp;&amp; !klass1-&gt;is_interface() &amp;&amp;
 932         (!klass0-&gt;is_obj_array_klass() ||
 933          !klass0-&gt;as_obj_array_klass()-&gt;base_element_klass()-&gt;is_interface()) &amp;&amp;
 934         (!klass1-&gt;is_obj_array_klass() ||
 935          !klass1-&gt;as_obj_array_klass()-&gt;base_element_klass()-&gt;is_interface())) {
 936       bool unrelated_classes = false;
 937       // See if neither subclasses the other, or if the class on top
 938       // is precise.  In either of these cases, the compare is known
 939       // to fail if at least one of the pointers is provably not null.
 940       if (klass0-&gt;equals(klass1)) {  // if types are unequal but klasses are equal
 941         // Do nothing; we know nothing for imprecise types
 942       } else if (klass0-&gt;is_subtype_of(klass1)) {
 943         // If klass1&#39;s type is PRECISE, then classes are unrelated.
 944         unrelated_classes = xklass1;
 945       } else if (klass1-&gt;is_subtype_of(klass0)) {
 946         // If klass0&#39;s type is PRECISE, then classes are unrelated.
 947         unrelated_classes = xklass0;
 948       } else {                  // Neither subtypes the other
 949         unrelated_classes = true;
 950       }
<a name="3" id="anc3"></a><span class="line-added"> 951       if (!unrelated_classes) {</span>
<span class="line-added"> 952         // Handle inline type arrays</span>
<span class="line-added"> 953         if ((r0-&gt;flatten_array() &amp;&amp; (!r1-&gt;can_be_inline_type() || (klass1-&gt;is_inlinetype() &amp;&amp; !klass1-&gt;flatten_array()))) ||</span>
<span class="line-added"> 954             (r1-&gt;flatten_array() &amp;&amp; (!r0-&gt;can_be_inline_type() || (klass0-&gt;is_inlinetype() &amp;&amp; !klass0-&gt;flatten_array())))) {</span>
<span class="line-added"> 955           // One type is flattened in arrays but the other type is not. Must be unrelated.</span>
<span class="line-added"> 956           unrelated_classes = true;</span>
<span class="line-added"> 957         }</span>
<span class="line-added"> 958       }</span>
 959       if (unrelated_classes) {
 960         // The oops classes are known to be unrelated. If the joined PTRs of
 961         // two oops is not Null and not Bottom, then we are sure that one
 962         // of the two oops is non-null, and the comparison will always fail.
 963         TypePtr::PTR jp = r0-&gt;join_ptr(r1-&gt;_ptr);
 964         if (jp != TypePtr::Null &amp;&amp; jp != TypePtr::BotPTR) {
 965           return TypeInt::CC_GT;
 966         }
 967       }
 968     }
 969   }
 970 
 971   // Known constants can be compared exactly
 972   // Null can be distinguished from any NotNull pointers
 973   // Unknown inputs makes an unknown result
 974   if( r0-&gt;singleton() ) {
 975     intptr_t bits0 = r0-&gt;get_con();
 976     if( r1-&gt;singleton() )
 977       return bits0 == r1-&gt;get_con() ? TypeInt::CC_EQ : TypeInt::CC_GT;
 978     return ( r1-&gt;_ptr == TypePtr::NotNull &amp;&amp; bits0==0 ) ? TypeInt::CC_GT : TypeInt::CC;
 979   } else if( r1-&gt;singleton() ) {
 980     intptr_t bits1 = r1-&gt;get_con();
 981     return ( r0-&gt;_ptr == TypePtr::NotNull &amp;&amp; bits1==0 ) ? TypeInt::CC_GT : TypeInt::CC;
 982   } else
 983     return TypeInt::CC;
 984 }
 985 
 986 static inline Node* isa_java_mirror_load(PhaseGVN* phase, Node* n) {
 987   // Return the klass node for (indirect load from OopHandle)
 988   //   LoadBarrier?(LoadP(LoadP(AddP(foo:Klass, #java_mirror))))
 989   //   or NULL if not matching.
 990   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 991     n = bs-&gt;step_over_gc_barrier(n);
 992 
 993   if (n-&gt;Opcode() != Op_LoadP) return NULL;
 994 
 995   const TypeInstPtr* tp = phase-&gt;type(n)-&gt;isa_instptr();
 996   if (!tp || tp-&gt;klass() != phase-&gt;C-&gt;env()-&gt;Class_klass()) return NULL;
 997 
 998   Node* adr = n-&gt;in(MemNode::Address);
 999   // First load from OopHandle: ((OopHandle)mirror)-&gt;resolve(); may need barrier.
1000   if (adr-&gt;Opcode() != Op_LoadP || !phase-&gt;type(adr)-&gt;isa_rawptr()) return NULL;
1001   adr = adr-&gt;in(MemNode::Address);
1002 
1003   intptr_t off = 0;
1004   Node* k = AddPNode::Ideal_base_and_offset(adr, phase, off);
1005   if (k == NULL)  return NULL;
1006   const TypeKlassPtr* tkp = phase-&gt;type(k)-&gt;isa_klassptr();
1007   if (!tkp || off != in_bytes(Klass::java_mirror_offset())) return NULL;
1008 
1009   // We&#39;ve found the klass node of a Java mirror load.
1010   return k;
1011 }
1012 
1013 static inline Node* isa_const_java_mirror(PhaseGVN* phase, Node* n) {
1014   // for ConP(Foo.class) return ConP(Foo.klass)
1015   // otherwise return NULL
1016   if (!n-&gt;is_Con()) return NULL;
1017 
1018   const TypeInstPtr* tp = phase-&gt;type(n)-&gt;isa_instptr();
1019   if (!tp) return NULL;
1020 
1021   ciType* mirror_type = tp-&gt;java_mirror_type();
1022   // TypeInstPtr::java_mirror_type() returns non-NULL for compile-
1023   // time Class constants only.
1024   if (!mirror_type) return NULL;
1025 
1026   // x.getClass() == int.class can never be true (for all primitive types)
1027   // Return a ConP(NULL) node for this case.
1028   if (mirror_type-&gt;is_classless()) {
1029     return phase-&gt;makecon(TypePtr::NULL_PTR);
1030   }
1031 
1032   // return the ConP(Foo.klass)
1033   assert(mirror_type-&gt;is_klass(), &quot;mirror_type should represent a Klass*&quot;);
1034   return phase-&gt;makecon(TypeKlassPtr::make(mirror_type-&gt;as_klass()));
1035 }
1036 
1037 //------------------------------Ideal------------------------------------------
1038 // Normalize comparisons between Java mirror loads to compare the klass instead.
1039 //
1040 // Also check for the case of comparing an unknown klass loaded from the primary
1041 // super-type array vs a known klass with no subtypes.  This amounts to
1042 // checking to see an unknown klass subtypes a known klass with no subtypes;
1043 // this only happens on an exact match.  We can shorten this test by 1 load.
<a name="4" id="anc4"></a><span class="line-modified">1044 Node* CmpPNode::Ideal(PhaseGVN *phase, bool can_reshape) {</span>
1045   // Normalize comparisons between Java mirrors into comparisons of the low-
1046   // level klass, where a dependent load could be shortened.
1047   //
1048   // The new pattern has a nice effect of matching the same pattern used in the
1049   // fast path of instanceof/checkcast/Class.isInstance(), which allows
1050   // redundant exact type check be optimized away by GVN.
1051   // For example, in
1052   //   if (x.getClass() == Foo.class) {
1053   //     Foo foo = (Foo) x;
1054   //     // ... use a ...
1055   //   }
1056   // a CmpPNode could be shared between if_acmpne and checkcast
1057   {
1058     Node* k1 = isa_java_mirror_load(phase, in(1));
1059     Node* k2 = isa_java_mirror_load(phase, in(2));
1060     Node* conk2 = isa_const_java_mirror(phase, in(2));
1061 
1062     if (k1 &amp;&amp; (k2 || conk2)) {
1063       Node* lhs = k1;
1064       Node* rhs = (k2 != NULL) ? k2 : conk2;
1065       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1066       if (igvn != NULL) {
1067         set_req_X(1, lhs, igvn);
1068         set_req_X(2, rhs, igvn);
1069       } else {
1070         set_req(1, lhs);
1071         set_req(2, rhs);
1072       }
1073       return this;
1074     }
1075   }
1076 
1077   // Constant pointer on right?
1078   const TypeKlassPtr* t2 = phase-&gt;type(in(2))-&gt;isa_klassptr();
1079   if (t2 == NULL || !t2-&gt;klass_is_exact())
1080     return NULL;
1081   // Get the constant klass we are comparing to.
1082   ciKlass* superklass = t2-&gt;klass();
1083 
1084   // Now check for LoadKlass on left.
1085   Node* ldk1 = in(1);
1086   if (ldk1-&gt;is_DecodeNKlass()) {
1087     ldk1 = ldk1-&gt;in(1);
1088     if (ldk1-&gt;Opcode() != Op_LoadNKlass )
1089       return NULL;
1090   } else if (ldk1-&gt;Opcode() != Op_LoadKlass )
1091     return NULL;
1092   // Take apart the address of the LoadKlass:
1093   Node* adr1 = ldk1-&gt;in(MemNode::Address);
1094   intptr_t con2 = 0;
1095   Node* ldk2 = AddPNode::Ideal_base_and_offset(adr1, phase, con2);
1096   if (ldk2 == NULL)
1097     return NULL;
1098   if (con2 == oopDesc::klass_offset_in_bytes()) {
1099     // We are inspecting an object&#39;s concrete class.
1100     // Short-circuit the check if the query is abstract.
1101     if (superklass-&gt;is_interface() ||
1102         superklass-&gt;is_abstract()) {
1103       // Make it come out always false:
1104       this-&gt;set_req(2, phase-&gt;makecon(TypePtr::NULL_PTR));
1105       return this;
1106     }
1107   }
1108 
1109   // Check for a LoadKlass from primary supertype array.
1110   // Any nested loadklass from loadklass+con must be from the p.s. array.
1111   if (ldk2-&gt;is_DecodeNKlass()) {
1112     // Keep ldk2 as DecodeN since it could be used in CmpP below.
1113     if (ldk2-&gt;in(1)-&gt;Opcode() != Op_LoadNKlass )
1114       return NULL;
1115   } else if (ldk2-&gt;Opcode() != Op_LoadKlass)
1116     return NULL;
1117 
1118   // Verify that we understand the situation
1119   if (con2 != (intptr_t) superklass-&gt;super_check_offset())
1120     return NULL;                // Might be element-klass loading from array klass
1121 
1122   // If &#39;superklass&#39; has no subklasses and is not an interface, then we are
1123   // assured that the only input which will pass the type check is
1124   // &#39;superklass&#39; itself.
1125   //
1126   // We could be more liberal here, and allow the optimization on interfaces
1127   // which have a single implementor.  This would require us to increase the
1128   // expressiveness of the add_dependency() mechanism.
1129   // %%% Do this after we fix TypeOopPtr:  Deps are expressive enough now.
1130 
1131   // Object arrays must have their base element have no subtypes
1132   while (superklass-&gt;is_obj_array_klass()) {
1133     ciType* elem = superklass-&gt;as_obj_array_klass()-&gt;element_type();
1134     superklass = elem-&gt;as_klass();
1135   }
1136   if (superklass-&gt;is_instance_klass()) {
1137     ciInstanceKlass* ik = superklass-&gt;as_instance_klass();
1138     if (ik-&gt;has_subklass() || ik-&gt;is_interface())  return NULL;
1139     // Add a dependency if there is a chance that a subclass will be added later.
1140     if (!ik-&gt;is_final()) {
1141       phase-&gt;C-&gt;dependencies()-&gt;assert_leaf_type(ik);
1142     }
1143   }
1144 
1145   // Bypass the dependent load, and compare directly
1146   this-&gt;set_req(1,ldk2);
1147 
1148   return this;
1149 }
1150 
1151 //=============================================================================
1152 //------------------------------sub--------------------------------------------
1153 // Simplify an CmpN (compare 2 pointers) node, based on local information.
1154 // If both inputs are constants, compare them.
1155 const Type *CmpNNode::sub( const Type *t1, const Type *t2 ) const {
1156   ShouldNotReachHere();
1157   return bottom_type();
1158 }
1159 
1160 //------------------------------Ideal------------------------------------------
1161 Node *CmpNNode::Ideal( PhaseGVN *phase, bool can_reshape ) {
1162   return NULL;
1163 }
1164 
1165 //=============================================================================
1166 //------------------------------Value------------------------------------------
1167 // Simplify an CmpF (compare 2 floats ) node, based on local information.
1168 // If both inputs are constants, compare them.
1169 const Type* CmpFNode::Value(PhaseGVN* phase) const {
1170   const Node* in1 = in(1);
1171   const Node* in2 = in(2);
1172   // Either input is TOP ==&gt; the result is TOP
1173   const Type* t1 = (in1 == this) ? Type::TOP : phase-&gt;type(in1);
1174   if( t1 == Type::TOP ) return Type::TOP;
1175   const Type* t2 = (in2 == this) ? Type::TOP : phase-&gt;type(in2);
1176   if( t2 == Type::TOP ) return Type::TOP;
1177 
1178   // Not constants?  Don&#39;t know squat - even if they are the same
1179   // value!  If they are NaN&#39;s they compare to LT instead of EQ.
1180   const TypeF *tf1 = t1-&gt;isa_float_constant();
1181   const TypeF *tf2 = t2-&gt;isa_float_constant();
1182   if( !tf1 || !tf2 ) return TypeInt::CC;
1183 
1184   // This implements the Java bytecode fcmpl, so unordered returns -1.
1185   if( tf1-&gt;is_nan() || tf2-&gt;is_nan() )
1186     return TypeInt::CC_LT;
1187 
1188   if( tf1-&gt;_f &lt; tf2-&gt;_f ) return TypeInt::CC_LT;
1189   if( tf1-&gt;_f &gt; tf2-&gt;_f ) return TypeInt::CC_GT;
1190   assert( tf1-&gt;_f == tf2-&gt;_f, &quot;do not understand FP behavior&quot; );
1191   return TypeInt::CC_EQ;
1192 }
1193 
1194 
1195 //=============================================================================
1196 //------------------------------Value------------------------------------------
1197 // Simplify an CmpD (compare 2 doubles ) node, based on local information.
1198 // If both inputs are constants, compare them.
1199 const Type* CmpDNode::Value(PhaseGVN* phase) const {
1200   const Node* in1 = in(1);
1201   const Node* in2 = in(2);
1202   // Either input is TOP ==&gt; the result is TOP
1203   const Type* t1 = (in1 == this) ? Type::TOP : phase-&gt;type(in1);
1204   if( t1 == Type::TOP ) return Type::TOP;
1205   const Type* t2 = (in2 == this) ? Type::TOP : phase-&gt;type(in2);
1206   if( t2 == Type::TOP ) return Type::TOP;
1207 
1208   // Not constants?  Don&#39;t know squat - even if they are the same
1209   // value!  If they are NaN&#39;s they compare to LT instead of EQ.
1210   const TypeD *td1 = t1-&gt;isa_double_constant();
1211   const TypeD *td2 = t2-&gt;isa_double_constant();
1212   if( !td1 || !td2 ) return TypeInt::CC;
1213 
1214   // This implements the Java bytecode dcmpl, so unordered returns -1.
1215   if( td1-&gt;is_nan() || td2-&gt;is_nan() )
1216     return TypeInt::CC_LT;
1217 
1218   if( td1-&gt;_d &lt; td2-&gt;_d ) return TypeInt::CC_LT;
1219   if( td1-&gt;_d &gt; td2-&gt;_d ) return TypeInt::CC_GT;
1220   assert( td1-&gt;_d == td2-&gt;_d, &quot;do not understand FP behavior&quot; );
1221   return TypeInt::CC_EQ;
1222 }
1223 
1224 //------------------------------Ideal------------------------------------------
1225 Node *CmpDNode::Ideal(PhaseGVN *phase, bool can_reshape){
1226   // Check if we can change this to a CmpF and remove a ConvD2F operation.
1227   // Change  (CMPD (F2D (float)) (ConD value))
1228   // To      (CMPF      (float)  (ConF value))
1229   // Valid when &#39;value&#39; does not lose precision as a float.
1230   // Benefits: eliminates conversion, does not require 24-bit mode
1231 
1232   // NaNs prevent commuting operands.  This transform works regardless of the
1233   // order of ConD and ConvF2D inputs by preserving the original order.
1234   int idx_f2d = 1;              // ConvF2D on left side?
1235   if( in(idx_f2d)-&gt;Opcode() != Op_ConvF2D )
1236     idx_f2d = 2;                // No, swap to check for reversed args
1237   int idx_con = 3-idx_f2d;      // Check for the constant on other input
1238 
1239   if( ConvertCmpD2CmpF &amp;&amp;
1240       in(idx_f2d)-&gt;Opcode() == Op_ConvF2D &amp;&amp;
1241       in(idx_con)-&gt;Opcode() == Op_ConD ) {
1242     const TypeD *t2 = in(idx_con)-&gt;bottom_type()-&gt;is_double_constant();
1243     double t2_value_as_double = t2-&gt;_d;
1244     float  t2_value_as_float  = (float)t2_value_as_double;
1245     if( t2_value_as_double == (double)t2_value_as_float ) {
1246       // Test value can be represented as a float
1247       // Eliminate the conversion to double and create new comparison
1248       Node *new_in1 = in(idx_f2d)-&gt;in(1);
1249       Node *new_in2 = phase-&gt;makecon( TypeF::make(t2_value_as_float) );
1250       if( idx_f2d != 1 ) {      // Must flip args to match original order
1251         Node *tmp = new_in1;
1252         new_in1 = new_in2;
1253         new_in2 = tmp;
1254       }
1255       CmpFNode *new_cmp = (Opcode() == Op_CmpD3)
1256         ? new CmpF3Node( new_in1, new_in2 )
1257         : new CmpFNode ( new_in1, new_in2 ) ;
1258       return new_cmp;           // Changed to CmpFNode
1259     }
1260     // Testing value required the precision of a double
1261   }
1262   return NULL;                  // No change
1263 }
1264 
1265 
1266 //=============================================================================
1267 //------------------------------cc2logical-------------------------------------
1268 // Convert a condition code type to a logical type
1269 const Type *BoolTest::cc2logical( const Type *CC ) const {
1270   if( CC == Type::TOP ) return Type::TOP;
1271   if( CC-&gt;base() != Type::Int ) return TypeInt::BOOL; // Bottom or worse
1272   const TypeInt *ti = CC-&gt;is_int();
1273   if( ti-&gt;is_con() ) {          // Only 1 kind of condition codes set?
1274     // Match low order 2 bits
1275     int tmp = ((ti-&gt;get_con()&amp;3) == (_test&amp;3)) ? 1 : 0;
1276     if( _test &amp; 4 ) tmp = 1-tmp;     // Optionally complement result
1277     return TypeInt::make(tmp);       // Boolean result
1278   }
1279 
1280   if( CC == TypeInt::CC_GE ) {
1281     if( _test == ge ) return TypeInt::ONE;
1282     if( _test == lt ) return TypeInt::ZERO;
1283   }
1284   if( CC == TypeInt::CC_LE ) {
1285     if( _test == le ) return TypeInt::ONE;
1286     if( _test == gt ) return TypeInt::ZERO;
1287   }
1288 
1289   return TypeInt::BOOL;
1290 }
1291 
1292 //------------------------------dump_spec-------------------------------------
1293 // Print special per-node info
1294 void BoolTest::dump_on(outputStream *st) const {
1295   const char *msg[] = {&quot;eq&quot;,&quot;gt&quot;,&quot;of&quot;,&quot;lt&quot;,&quot;ne&quot;,&quot;le&quot;,&quot;nof&quot;,&quot;ge&quot;};
1296   st-&gt;print(&quot;%s&quot;, msg[_test]);
1297 }
1298 
1299 // Returns the logical AND of two tests (or &#39;never&#39; if both tests can never be true).
1300 // For example, a test for &#39;le&#39; followed by a test for &#39;lt&#39; is equivalent with &#39;lt&#39;.
1301 BoolTest::mask BoolTest::merge(BoolTest other) const {
1302   const mask res[illegal+1][illegal+1] = {
1303     // eq,      gt,      of,      lt,      ne,      le,      nof,     ge,      never,   illegal
1304       {eq,      never,   illegal, never,   never,   eq,      illegal, eq,      never,   illegal},  // eq
1305       {never,   gt,      illegal, never,   gt,      never,   illegal, gt,      never,   illegal},  // gt
1306       {illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, never,   illegal},  // of
1307       {never,   never,   illegal, lt,      lt,      lt,      illegal, never,   never,   illegal},  // lt
1308       {never,   gt,      illegal, lt,      ne,      lt,      illegal, gt,      never,   illegal},  // ne
1309       {eq,      never,   illegal, lt,      lt,      le,      illegal, eq,      never,   illegal},  // le
1310       {illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, never,   illegal},  // nof
1311       {eq,      gt,      illegal, never,   gt,      eq,      illegal, ge,      never,   illegal},  // ge
1312       {never,   never,   never,   never,   never,   never,   never,   never,   never,   illegal},  // never
1313       {illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal}}; // illegal
1314   return res[_test][other._test];
1315 }
1316 
1317 //=============================================================================
1318 uint BoolNode::hash() const { return (Node::hash() &lt;&lt; 3)|(_test._test+1); }
1319 uint BoolNode::size_of() const { return sizeof(BoolNode); }
1320 
1321 //------------------------------operator==-------------------------------------
1322 bool BoolNode::cmp( const Node &amp;n ) const {
1323   const BoolNode *b = (const BoolNode *)&amp;n; // Cast up
1324   return (_test._test == b-&gt;_test._test);
1325 }
1326 
1327 //-------------------------------make_predicate--------------------------------
1328 Node* BoolNode::make_predicate(Node* test_value, PhaseGVN* phase) {
1329   if (test_value-&gt;is_Con())   return test_value;
1330   if (test_value-&gt;is_Bool())  return test_value;
1331   if (test_value-&gt;is_CMove() &amp;&amp;
1332       test_value-&gt;in(CMoveNode::Condition)-&gt;is_Bool()) {
1333     BoolNode*   bol   = test_value-&gt;in(CMoveNode::Condition)-&gt;as_Bool();
1334     const Type* ftype = phase-&gt;type(test_value-&gt;in(CMoveNode::IfFalse));
1335     const Type* ttype = phase-&gt;type(test_value-&gt;in(CMoveNode::IfTrue));
1336     if (ftype == TypeInt::ZERO &amp;&amp; !TypeInt::ZERO-&gt;higher_equal(ttype)) {
1337       return bol;
1338     } else if (ttype == TypeInt::ZERO &amp;&amp; !TypeInt::ZERO-&gt;higher_equal(ftype)) {
1339       return phase-&gt;transform( bol-&gt;negate(phase) );
1340     }
1341     // Else fall through.  The CMove gets in the way of the test.
1342     // It should be the case that make_predicate(bol-&gt;as_int_value()) == bol.
1343   }
1344   Node* cmp = new CmpINode(test_value, phase-&gt;intcon(0));
1345   cmp = phase-&gt;transform(cmp);
1346   Node* bol = new BoolNode(cmp, BoolTest::ne);
1347   return phase-&gt;transform(bol);
1348 }
1349 
1350 //--------------------------------as_int_value---------------------------------
1351 Node* BoolNode::as_int_value(PhaseGVN* phase) {
1352   // Inverse to make_predicate.  The CMove probably boils down to a Conv2B.
1353   Node* cmov = CMoveNode::make(NULL, this,
1354                                phase-&gt;intcon(0), phase-&gt;intcon(1),
1355                                TypeInt::BOOL);
1356   return phase-&gt;transform(cmov);
1357 }
1358 
1359 //----------------------------------negate-------------------------------------
1360 BoolNode* BoolNode::negate(PhaseGVN* phase) {
1361   return new BoolNode(in(1), _test.negate());
1362 }
1363 
1364 // Change &quot;bool eq/ne (cmp (add/sub A B) C)&quot; into false/true if add/sub
1365 // overflows and we can prove that C is not in the two resulting ranges.
1366 // This optimization is similar to the one performed by CmpUNode::Value().
1367 Node* BoolNode::fold_cmpI(PhaseGVN* phase, SubNode* cmp, Node* cmp1, int cmp_op,
1368                           int cmp1_op, const TypeInt* cmp2_type) {
1369   // Only optimize eq/ne integer comparison of add/sub
1370   if((_test._test == BoolTest::eq || _test._test == BoolTest::ne) &amp;&amp;
1371      (cmp_op == Op_CmpI) &amp;&amp; (cmp1_op == Op_AddI || cmp1_op == Op_SubI)) {
1372     // Skip cases were inputs of add/sub are not integers or of bottom type
1373     const TypeInt* r0 = phase-&gt;type(cmp1-&gt;in(1))-&gt;isa_int();
1374     const TypeInt* r1 = phase-&gt;type(cmp1-&gt;in(2))-&gt;isa_int();
1375     if ((r0 != NULL) &amp;&amp; (r0 != TypeInt::INT) &amp;&amp;
1376         (r1 != NULL) &amp;&amp; (r1 != TypeInt::INT) &amp;&amp;
1377         (cmp2_type != TypeInt::INT)) {
1378       // Compute exact (long) type range of add/sub result
1379       jlong lo_long = r0-&gt;_lo;
1380       jlong hi_long = r0-&gt;_hi;
1381       if (cmp1_op == Op_AddI) {
1382         lo_long += r1-&gt;_lo;
1383         hi_long += r1-&gt;_hi;
1384       } else {
1385         lo_long -= r1-&gt;_hi;
1386         hi_long -= r1-&gt;_lo;
1387       }
1388       // Check for over-/underflow by casting to integer
1389       int lo_int = (int)lo_long;
1390       int hi_int = (int)hi_long;
1391       bool underflow = lo_long != (jlong)lo_int;
1392       bool overflow  = hi_long != (jlong)hi_int;
1393       if ((underflow != overflow) &amp;&amp; (hi_int &lt; lo_int)) {
1394         // Overflow on one boundary, compute resulting type ranges:
1395         // tr1 [MIN_INT, hi_int] and tr2 [lo_int, MAX_INT]
1396         int w = MAX2(r0-&gt;_widen, r1-&gt;_widen); // _widen does not matter here
1397         const TypeInt* tr1 = TypeInt::make(min_jint, hi_int, w);
1398         const TypeInt* tr2 = TypeInt::make(lo_int, max_jint, w);
1399         // Compare second input of cmp to both type ranges
1400         const Type* sub_tr1 = cmp-&gt;sub(tr1, cmp2_type);
1401         const Type* sub_tr2 = cmp-&gt;sub(tr2, cmp2_type);
1402         if (sub_tr1 == TypeInt::CC_LT &amp;&amp; sub_tr2 == TypeInt::CC_GT) {
1403           // The result of the add/sub will never equal cmp2. Replace BoolNode
1404           // by false (0) if it tests for equality and by true (1) otherwise.
1405           return ConINode::make((_test._test == BoolTest::eq) ? 0 : 1);
1406         }
1407       }
1408     }
1409   }
1410   return NULL;
1411 }
1412 
1413 static bool is_counted_loop_cmp(Node *cmp) {
1414   Node *n = cmp-&gt;in(1)-&gt;in(1);
1415   return n != NULL &amp;&amp;
1416          n-&gt;is_Phi() &amp;&amp;
1417          n-&gt;in(0) != NULL &amp;&amp;
1418          n-&gt;in(0)-&gt;is_CountedLoop() &amp;&amp;
1419          n-&gt;in(0)-&gt;as_CountedLoop()-&gt;phi() == n;
1420 }
1421 
1422 //------------------------------Ideal------------------------------------------
1423 Node *BoolNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1424   // Change &quot;bool tst (cmp con x)&quot; into &quot;bool ~tst (cmp x con)&quot;.
1425   // This moves the constant to the right.  Helps value-numbering.
1426   Node *cmp = in(1);
1427   if( !cmp-&gt;is_Sub() ) return NULL;
1428   int cop = cmp-&gt;Opcode();
1429   if( cop == Op_FastLock || cop == Op_FastUnlock || cmp-&gt;is_SubTypeCheck()) return NULL;
1430   Node *cmp1 = cmp-&gt;in(1);
1431   Node *cmp2 = cmp-&gt;in(2);
1432   if( !cmp1 ) return NULL;
1433 
1434   if (_test._test == BoolTest::overflow || _test._test == BoolTest::no_overflow) {
1435     return NULL;
1436   }
1437 
1438   // Constant on left?
1439   Node *con = cmp1;
1440   uint op2 = cmp2-&gt;Opcode();
1441   // Move constants to the right of compare&#39;s to canonicalize.
1442   // Do not muck with Opaque1 nodes, as this indicates a loop
1443   // guard that cannot change shape.
1444   if( con-&gt;is_Con() &amp;&amp; !cmp2-&gt;is_Con() &amp;&amp; op2 != Op_Opaque1 &amp;&amp;
1445       // Because of NaN&#39;s, CmpD and CmpF are not commutative
1446       cop != Op_CmpD &amp;&amp; cop != Op_CmpF &amp;&amp;
1447       // Protect against swapping inputs to a compare when it is used by a
1448       // counted loop exit, which requires maintaining the loop-limit as in(2)
1449       !is_counted_loop_exit_test() ) {
1450     // Ok, commute the constant to the right of the cmp node.
1451     // Clone the Node, getting a new Node of the same class
1452     cmp = cmp-&gt;clone();
1453     // Swap inputs to the clone
1454     cmp-&gt;swap_edges(1, 2);
1455     cmp = phase-&gt;transform( cmp );
1456     return new BoolNode( cmp, _test.commute() );
1457   }
1458 
1459   // Change &quot;bool eq/ne (cmp (and X 16) 16)&quot; into &quot;bool ne/eq (cmp (and X 16) 0)&quot;.
1460   if (cop == Op_CmpI &amp;&amp;
1461       (_test._test == BoolTest::eq || _test._test == BoolTest::ne) &amp;&amp;
1462       cmp1-&gt;Opcode() == Op_AndI &amp;&amp; cmp2-&gt;Opcode() == Op_ConI &amp;&amp;
1463       cmp1-&gt;in(2)-&gt;Opcode() == Op_ConI) {
1464     const TypeInt *t12 = phase-&gt;type(cmp2)-&gt;isa_int();
1465     const TypeInt *t112 = phase-&gt;type(cmp1-&gt;in(2))-&gt;isa_int();
1466     if (t12 &amp;&amp; t12-&gt;is_con() &amp;&amp; t112 &amp;&amp; t112-&gt;is_con() &amp;&amp;
1467         t12-&gt;get_con() == t112-&gt;get_con() &amp;&amp; is_power_of_2(t12-&gt;get_con())) {
1468       Node *ncmp = phase-&gt;transform(new CmpINode(cmp1, phase-&gt;intcon(0)));
1469       return new BoolNode(ncmp, _test.negate());
1470     }
1471   }
1472 
1473   // Same for long type: change &quot;bool eq/ne (cmp (and X 16) 16)&quot; into &quot;bool ne/eq (cmp (and X 16) 0)&quot;.
1474   if (cop == Op_CmpL &amp;&amp;
1475       (_test._test == BoolTest::eq || _test._test == BoolTest::ne) &amp;&amp;
1476       cmp1-&gt;Opcode() == Op_AndL &amp;&amp; cmp2-&gt;Opcode() == Op_ConL &amp;&amp;
1477       cmp1-&gt;in(2)-&gt;Opcode() == Op_ConL) {
1478     const TypeLong *t12 = phase-&gt;type(cmp2)-&gt;isa_long();
1479     const TypeLong *t112 = phase-&gt;type(cmp1-&gt;in(2))-&gt;isa_long();
1480     if (t12 &amp;&amp; t12-&gt;is_con() &amp;&amp; t112 &amp;&amp; t112-&gt;is_con() &amp;&amp;
1481         t12-&gt;get_con() == t112-&gt;get_con() &amp;&amp; is_power_of_2(t12-&gt;get_con())) {
1482       Node *ncmp = phase-&gt;transform(new CmpLNode(cmp1, phase-&gt;longcon(0)));
1483       return new BoolNode(ncmp, _test.negate());
1484     }
1485   }
1486 
1487   // Change &quot;bool eq/ne (cmp (xor X 1) 0)&quot; into &quot;bool ne/eq (cmp X 0)&quot;.
1488   // The XOR-1 is an idiom used to flip the sense of a bool.  We flip the
1489   // test instead.
1490   int cmp1_op = cmp1-&gt;Opcode();
1491   const TypeInt* cmp2_type = phase-&gt;type(cmp2)-&gt;isa_int();
1492   if (cmp2_type == NULL)  return NULL;
1493   Node* j_xor = cmp1;
1494   if( cmp2_type == TypeInt::ZERO &amp;&amp;
1495       cmp1_op == Op_XorI &amp;&amp;
1496       j_xor-&gt;in(1) != j_xor &amp;&amp;          // An xor of itself is dead
1497       phase-&gt;type( j_xor-&gt;in(1) ) == TypeInt::BOOL &amp;&amp;
1498       phase-&gt;type( j_xor-&gt;in(2) ) == TypeInt::ONE &amp;&amp;
1499       (_test._test == BoolTest::eq ||
1500        _test._test == BoolTest::ne) ) {
1501     Node *ncmp = phase-&gt;transform(new CmpINode(j_xor-&gt;in(1),cmp2));
1502     return new BoolNode( ncmp, _test.negate() );
1503   }
1504 
1505   // Change ((x &amp; m) u&lt;= m) or ((m &amp; x) u&lt;= m) to always true
1506   // Same with ((x &amp; m) u&lt; m+1) and ((m &amp; x) u&lt; m+1)
1507   if (cop == Op_CmpU &amp;&amp;
1508       cmp1_op == Op_AndI) {
1509     Node* bound = NULL;
1510     if (_test._test == BoolTest::le) {
1511       bound = cmp2;
1512     } else if (_test._test == BoolTest::lt &amp;&amp;
1513                cmp2-&gt;Opcode() == Op_AddI &amp;&amp;
1514                cmp2-&gt;in(2)-&gt;find_int_con(0) == 1) {
1515       bound = cmp2-&gt;in(1);
1516     }
1517     if (cmp1-&gt;in(2) == bound || cmp1-&gt;in(1) == bound) {
1518       return ConINode::make(1);
1519     }
1520   }
1521 
1522   // Change ((x &amp; (m - 1)) u&lt; m) into (m &gt; 0)
1523   // This is the off-by-one variant of the above
1524   if (cop == Op_CmpU &amp;&amp;
1525       _test._test == BoolTest::lt &amp;&amp;
1526       cmp1_op == Op_AndI) {
1527     Node* l = cmp1-&gt;in(1);
1528     Node* r = cmp1-&gt;in(2);
1529     for (int repeat = 0; repeat &lt; 2; repeat++) {
1530       bool match = r-&gt;Opcode() == Op_AddI &amp;&amp; r-&gt;in(2)-&gt;find_int_con(0) == -1 &amp;&amp;
1531                    r-&gt;in(1) == cmp2;
1532       if (match) {
1533         // arraylength known to be non-negative, so a (arraylength != 0) is sufficient,
1534         // but to be compatible with the array range check pattern, use (arraylength u&gt; 0)
1535         Node* ncmp = cmp2-&gt;Opcode() == Op_LoadRange
1536                      ? phase-&gt;transform(new CmpUNode(cmp2, phase-&gt;intcon(0)))
1537                      : phase-&gt;transform(new CmpINode(cmp2, phase-&gt;intcon(0)));
1538         return new BoolNode(ncmp, BoolTest::gt);
1539       } else {
1540         // commute and try again
1541         l = cmp1-&gt;in(2);
1542         r = cmp1-&gt;in(1);
1543       }
1544     }
1545   }
1546 
1547   // Change x u&lt; 1 or x u&lt;= 0 to x == 0
1548   if (cop == Op_CmpU &amp;&amp;
1549       cmp1_op != Op_LoadRange &amp;&amp;
1550       ((_test._test == BoolTest::lt &amp;&amp;
1551         cmp2-&gt;find_int_con(-1) == 1) ||
1552        (_test._test == BoolTest::le &amp;&amp;
1553         cmp2-&gt;find_int_con(-1) == 0))) {
1554     Node* ncmp = phase-&gt;transform(new CmpINode(cmp1, phase-&gt;intcon(0)));
1555     return new BoolNode(ncmp, BoolTest::eq);
1556   }
1557 
1558   // Change (arraylength &lt;= 0) or (arraylength == 0)
1559   //   into (arraylength u&lt;= 0)
1560   // Also change (arraylength != 0) into (arraylength u&gt; 0)
1561   // The latter version matches the code pattern generated for
1562   // array range checks, which will more likely be optimized later.
1563   if (cop == Op_CmpI &amp;&amp;
1564       cmp1_op == Op_LoadRange &amp;&amp;
1565       cmp2-&gt;find_int_con(-1) == 0) {
1566     if (_test._test == BoolTest::le || _test._test == BoolTest::eq) {
1567       Node* ncmp = phase-&gt;transform(new CmpUNode(cmp1, cmp2));
1568       return new BoolNode(ncmp, BoolTest::le);
1569     } else if (_test._test == BoolTest::ne) {
1570       Node* ncmp = phase-&gt;transform(new CmpUNode(cmp1, cmp2));
1571       return new BoolNode(ncmp, BoolTest::gt);
1572     }
1573   }
1574 
1575   // Change &quot;bool eq/ne (cmp (Conv2B X) 0)&quot; into &quot;bool eq/ne (cmp X 0)&quot;.
1576   // This is a standard idiom for branching on a boolean value.
1577   Node *c2b = cmp1;
1578   if( cmp2_type == TypeInt::ZERO &amp;&amp;
1579       cmp1_op == Op_Conv2B &amp;&amp;
1580       (_test._test == BoolTest::eq ||
1581        _test._test == BoolTest::ne) ) {
1582     Node *ncmp = phase-&gt;transform(phase-&gt;type(c2b-&gt;in(1))-&gt;isa_int()
1583        ? (Node*)new CmpINode(c2b-&gt;in(1),cmp2)
1584        : (Node*)new CmpPNode(c2b-&gt;in(1),phase-&gt;makecon(TypePtr::NULL_PTR))
1585     );
1586     return new BoolNode( ncmp, _test._test );
1587   }
1588 
1589   // Comparing a SubI against a zero is equal to comparing the SubI
1590   // arguments directly.  This only works for eq and ne comparisons
1591   // due to possible integer overflow.
1592   if ((_test._test == BoolTest::eq || _test._test == BoolTest::ne) &amp;&amp;
1593         (cop == Op_CmpI) &amp;&amp;
1594         (cmp1_op == Op_SubI) &amp;&amp;
1595         ( cmp2_type == TypeInt::ZERO ) ) {
1596     Node *ncmp = phase-&gt;transform( new CmpINode(cmp1-&gt;in(1),cmp1-&gt;in(2)));
1597     return new BoolNode( ncmp, _test._test );
1598   }
1599 
1600   // Same as above but with and AddI of a constant
1601   if ((_test._test == BoolTest::eq || _test._test == BoolTest::ne) &amp;&amp;
1602       cop == Op_CmpI &amp;&amp;
1603       cmp1_op == Op_AddI &amp;&amp;
1604       cmp1-&gt;in(2) != NULL &amp;&amp;
1605       phase-&gt;type(cmp1-&gt;in(2))-&gt;isa_int() &amp;&amp;
1606       phase-&gt;type(cmp1-&gt;in(2))-&gt;is_int()-&gt;is_con() &amp;&amp;
1607       cmp2_type == TypeInt::ZERO &amp;&amp;
1608       !is_counted_loop_cmp(cmp) // modifying the exit test of a counted loop messes the counted loop shape
1609       ) {
1610     const TypeInt* cmp1_in2 = phase-&gt;type(cmp1-&gt;in(2))-&gt;is_int();
1611     Node *ncmp = phase-&gt;transform( new CmpINode(cmp1-&gt;in(1),phase-&gt;intcon(-cmp1_in2-&gt;_hi)));
1612     return new BoolNode( ncmp, _test._test );
1613   }
1614 
1615   // Change &quot;bool eq/ne (cmp (phi (X -X) 0))&quot; into &quot;bool eq/ne (cmp X 0)&quot;
1616   // since zero check of conditional negation of an integer is equal to
1617   // zero check of the integer directly.
1618   if ((_test._test == BoolTest::eq || _test._test == BoolTest::ne) &amp;&amp;
1619       (cop == Op_CmpI) &amp;&amp;
1620       (cmp2_type == TypeInt::ZERO) &amp;&amp;
1621       (cmp1_op == Op_Phi)) {
1622     // There should be a diamond phi with true path at index 1 or 2
1623     PhiNode *phi = cmp1-&gt;as_Phi();
1624     int idx_true = phi-&gt;is_diamond_phi();
1625     if (idx_true != 0) {
1626       // True input is in(idx_true) while false input is in(3 - idx_true)
1627       Node *tin = phi-&gt;in(idx_true);
1628       Node *fin = phi-&gt;in(3 - idx_true);
1629       if ((tin-&gt;Opcode() == Op_SubI) &amp;&amp;
1630           (phase-&gt;type(tin-&gt;in(1)) == TypeInt::ZERO) &amp;&amp;
1631           (tin-&gt;in(2) == fin)) {
1632         // Found conditional negation at true path, create a new CmpINode without that
1633         Node *ncmp = phase-&gt;transform(new CmpINode(fin, cmp2));
1634         return new BoolNode(ncmp, _test._test);
1635       }
1636       if ((fin-&gt;Opcode() == Op_SubI) &amp;&amp;
1637           (phase-&gt;type(fin-&gt;in(1)) == TypeInt::ZERO) &amp;&amp;
1638           (fin-&gt;in(2) == tin)) {
1639         // Found conditional negation at false path, create a new CmpINode without that
1640         Node *ncmp = phase-&gt;transform(new CmpINode(tin, cmp2));
1641         return new BoolNode(ncmp, _test._test);
1642       }
1643     }
1644   }
1645 
1646   // Change (-A vs 0) into (A vs 0) by commuting the test.  Disallow in the
1647   // most general case because negating 0x80000000 does nothing.  Needed for
1648   // the CmpF3/SubI/CmpI idiom.
1649   if( cop == Op_CmpI &amp;&amp;
1650       cmp1_op == Op_SubI &amp;&amp;
1651       cmp2_type == TypeInt::ZERO &amp;&amp;
1652       phase-&gt;type( cmp1-&gt;in(1) ) == TypeInt::ZERO &amp;&amp;
1653       phase-&gt;type( cmp1-&gt;in(2) )-&gt;higher_equal(TypeInt::SYMINT) ) {
1654     Node *ncmp = phase-&gt;transform( new CmpINode(cmp1-&gt;in(2),cmp2));
1655     return new BoolNode( ncmp, _test.commute() );
1656   }
1657 
1658   // Try to optimize signed integer comparison
1659   return fold_cmpI(phase, cmp-&gt;as_Sub(), cmp1, cop, cmp1_op, cmp2_type);
1660 
1661   //  The transformation below is not valid for either signed or unsigned
1662   //  comparisons due to wraparound concerns at MAX_VALUE and MIN_VALUE.
1663   //  This transformation can be resurrected when we are able to
1664   //  make inferences about the range of values being subtracted from
1665   //  (or added to) relative to the wraparound point.
1666   //
1667   //    // Remove +/-1&#39;s if possible.
1668   //    // &quot;X &lt;= Y-1&quot; becomes &quot;X &lt;  Y&quot;
1669   //    // &quot;X+1 &lt;= Y&quot; becomes &quot;X &lt;  Y&quot;
1670   //    // &quot;X &lt;  Y+1&quot; becomes &quot;X &lt;= Y&quot;
1671   //    // &quot;X-1 &lt;  Y&quot; becomes &quot;X &lt;= Y&quot;
1672   //    // Do not this to compares off of the counted-loop-end.  These guys are
1673   //    // checking the trip counter and they want to use the post-incremented
1674   //    // counter.  If they use the PRE-incremented counter, then the counter has
1675   //    // to be incremented in a private block on a loop backedge.
1676   //    if( du &amp;&amp; du-&gt;cnt(this) &amp;&amp; du-&gt;out(this)[0]-&gt;Opcode() == Op_CountedLoopEnd )
1677   //      return NULL;
1678   //  #ifndef PRODUCT
1679   //    // Do not do this in a wash GVN pass during verification.
1680   //    // Gets triggered by too many simple optimizations to be bothered with
1681   //    // re-trying it again and again.
1682   //    if( !phase-&gt;allow_progress() ) return NULL;
1683   //  #endif
1684   //    // Not valid for unsigned compare because of corner cases in involving zero.
1685   //    // For example, replacing &quot;X-1 &lt;u Y&quot; with &quot;X &lt;=u Y&quot; fails to throw an
1686   //    // exception in case X is 0 (because 0-1 turns into 4billion unsigned but
1687   //    // &quot;0 &lt;=u Y&quot; is always true).
1688   //    if( cmp-&gt;Opcode() == Op_CmpU ) return NULL;
1689   //    int cmp2_op = cmp2-&gt;Opcode();
1690   //    if( _test._test == BoolTest::le ) {
1691   //      if( cmp1_op == Op_AddI &amp;&amp;
1692   //          phase-&gt;type( cmp1-&gt;in(2) ) == TypeInt::ONE )
1693   //        return clone_cmp( cmp, cmp1-&gt;in(1), cmp2, phase, BoolTest::lt );
1694   //      else if( cmp2_op == Op_AddI &amp;&amp;
1695   //         phase-&gt;type( cmp2-&gt;in(2) ) == TypeInt::MINUS_1 )
1696   //        return clone_cmp( cmp, cmp1, cmp2-&gt;in(1), phase, BoolTest::lt );
1697   //    } else if( _test._test == BoolTest::lt ) {
1698   //      if( cmp1_op == Op_AddI &amp;&amp;
1699   //          phase-&gt;type( cmp1-&gt;in(2) ) == TypeInt::MINUS_1 )
1700   //        return clone_cmp( cmp, cmp1-&gt;in(1), cmp2, phase, BoolTest::le );
1701   //      else if( cmp2_op == Op_AddI &amp;&amp;
1702   //         phase-&gt;type( cmp2-&gt;in(2) ) == TypeInt::ONE )
1703   //        return clone_cmp( cmp, cmp1, cmp2-&gt;in(1), phase, BoolTest::le );
1704   //    }
1705 }
1706 
1707 //------------------------------Value------------------------------------------
1708 // Simplify a Bool (convert condition codes to boolean (1 or 0)) node,
1709 // based on local information.   If the input is constant, do it.
1710 const Type* BoolNode::Value(PhaseGVN* phase) const {
1711   return _test.cc2logical( phase-&gt;type( in(1) ) );
1712 }
1713 
1714 #ifndef PRODUCT
1715 //------------------------------dump_spec--------------------------------------
1716 // Dump special per-node info
1717 void BoolNode::dump_spec(outputStream *st) const {
1718   st-&gt;print(&quot;[&quot;);
1719   _test.dump_on(st);
1720   st-&gt;print(&quot;]&quot;);
1721 }
1722 
1723 //-------------------------------related---------------------------------------
1724 // A BoolNode&#39;s related nodes are all of its data inputs, and all of its
1725 // outputs until control nodes are hit, which are included. In compact
1726 // representation, inputs till level 3 and immediate outputs are included.
1727 void BoolNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1728   if (compact) {
1729     this-&gt;collect_nodes(in_rel, 3, false, true);
1730     this-&gt;collect_nodes(out_rel, -1, false, false);
1731   } else {
1732     this-&gt;collect_nodes_in_all_data(in_rel, false);
1733     this-&gt;collect_nodes_out_all_ctrl_boundary(out_rel);
1734   }
1735 }
1736 #endif
1737 
1738 //----------------------is_counted_loop_exit_test------------------------------
1739 // Returns true if node is used by a counted loop node.
1740 bool BoolNode::is_counted_loop_exit_test() {
1741   for( DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++ ) {
1742     Node* use = fast_out(i);
1743     if (use-&gt;is_CountedLoopEnd()) {
1744       return true;
1745     }
1746   }
1747   return false;
1748 }
1749 
1750 //=============================================================================
1751 //------------------------------Value------------------------------------------
1752 // Compute sqrt
1753 const Type* SqrtDNode::Value(PhaseGVN* phase) const {
1754   const Type *t1 = phase-&gt;type( in(1) );
1755   if( t1 == Type::TOP ) return Type::TOP;
1756   if( t1-&gt;base() != Type::DoubleCon ) return Type::DOUBLE;
1757   double d = t1-&gt;getd();
1758   if( d &lt; 0.0 ) return Type::DOUBLE;
1759   return TypeD::make( sqrt( d ) );
1760 }
1761 
1762 const Type* SqrtFNode::Value(PhaseGVN* phase) const {
1763   const Type *t1 = phase-&gt;type( in(1) );
1764   if( t1 == Type::TOP ) return Type::TOP;
1765   if( t1-&gt;base() != Type::FloatCon ) return Type::FLOAT;
1766   float f = t1-&gt;getf();
1767   if( f &lt; 0.0f ) return Type::FLOAT;
1768   return TypeF::make( (float)sqrt( (double)f ) );
1769 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>