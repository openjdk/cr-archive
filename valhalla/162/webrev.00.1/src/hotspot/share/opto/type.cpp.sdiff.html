<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="subnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;



  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;ci/ciTypeFlow.hpp&quot;
  28 #include &quot;classfile/javaClasses.hpp&quot;
  29 #include &quot;classfile/symbolTable.hpp&quot;
  30 #include &quot;compiler/compileLog.hpp&quot;
  31 #include &quot;libadt/dict.hpp&quot;
  32 #include &quot;memory/oopFactory.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/instanceKlass.hpp&quot;
  35 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/typeArrayKlass.hpp&quot;
  38 #include &quot;opto/matcher.hpp&quot;
  39 #include &quot;opto/node.hpp&quot;
  40 #include &quot;opto/opcodes.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 
  44 // Portions of code courtesy of Clifford Click
  45 
  46 // Optimization - Graph Style
  47 
  48 // Dictionary of types shared among compilations.
  49 Dict* Type::_shared_type_dict = NULL;














































  50 
  51 // Array which maps compiler types to Basic Types
  52 const Type::TypeInfo Type::_type_info[Type::lastype] = {
  53   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
  54   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
  55   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
  56   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
  57   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
  58   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
  59   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
  60   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
  61   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
  62   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
  63 
  64 #if defined(PPC64)
  65   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  66   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  67   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  68   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  69   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  70 #elif defined(S390)
  71   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  72   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  73   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
  74   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  75   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  76 #else // all other
  77   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
  78   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
  79   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  80   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
  81   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
  82 #endif

  83   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
  84   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
  85   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
  86   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
  87   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
  88   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
  89   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
  90   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
  91   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
  92   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
  93   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
  94   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
  95   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
  96   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
  97   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
  98   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
  99   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 100   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 101 };
 102 
</pre>
<hr />
<pre>
 193   case ciTypeFlow::StateVector::T_NULL:
 194     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 195     return TypePtr::NULL_PTR;
 196 
 197   case ciTypeFlow::StateVector::T_LONG2:
 198     // The ciTypeFlow pass pushes a long, then the half.
 199     // We do the same.
 200     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 201     return TypeInt::TOP;
 202 
 203   case ciTypeFlow::StateVector::T_DOUBLE2:
 204     // The ciTypeFlow pass pushes double, then the half.
 205     // Our convention is the same.
 206     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 207     return Type::TOP;
 208 
 209   case T_ADDRESS:
 210     assert(type-&gt;is_return_address(), &quot;&quot;);
 211     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 212 









 213   default:
 214     // make sure we did not mix up the cases:
 215     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 216     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 217     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 218     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 219     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 220     assert(!type-&gt;is_return_address(), &quot;&quot;);
 221 
 222     return Type::get_const_type(type);
 223   }
 224 }
 225 
 226 
 227 //-----------------------make_from_constant------------------------------------
 228 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 229                                      int stable_dimension, bool is_narrow_oop,
 230                                      bool is_autobox_cache) {
 231   switch (constant.basic_type()) {
 232     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 233     case T_CHAR:     return TypeInt::make(constant.as_char());
 234     case T_BYTE:     return TypeInt::make(constant.as_byte());
 235     case T_SHORT:    return TypeInt::make(constant.as_short());
 236     case T_INT:      return TypeInt::make(constant.as_int());
 237     case T_LONG:     return TypeLong::make(constant.as_long());
 238     case T_FLOAT:    return TypeF::make(constant.as_float());
 239     case T_DOUBLE:   return TypeD::make(constant.as_double());
 240     case T_ARRAY:

 241     case T_OBJECT: {
 242         const Type* con_type = NULL;
 243         ciObject* oop_constant = constant.as_object();
 244         if (oop_constant-&gt;is_null_object()) {
 245           con_type = Type::get_zero_type(T_OBJECT);
 246         } else {
 247           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 248           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 249           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 250             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 251           }
 252           if (stable_dimension &gt; 0) {
 253             assert(FoldStableValues, &quot;sanity&quot;);
 254             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 255             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 256           }
 257         }
 258         if (is_narrow_oop) {
 259           con_type = con_type-&gt;make_narrowoop();
 260         }
 261         return con_type;
 262       }
 263     case T_ILLEGAL:
 264       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 265       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 266       return NULL;
 267     default:
 268       // Fall through to failure
 269       return NULL;
 270   }
 271 }
 272 
 273 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 274   BasicType conbt = con.basic_type();
 275   switch (conbt) {
 276     case T_BOOLEAN: conbt = T_BYTE;   break;
 277     case T_ARRAY:   conbt = T_OBJECT; break;

 278     default:                          break;
 279   }
 280   switch (loadbt) {
 281     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 282     case T_NARROWOOP: loadbt = T_OBJECT; break;
 283     case T_ARRAY:     loadbt = T_OBJECT; break;

 284     case T_ADDRESS:   loadbt = T_OBJECT; break;
 285     default:                             break;
 286   }
 287   if (conbt == loadbt) {
 288     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 289       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 290       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 291     } else {
 292       return con;
 293     }
 294   }
 295   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 296     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 297     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 298   }
 299   return ciConstant(); // T_ILLEGAL
 300 }
 301 
 302 // Try to constant-fold a stable array element.
 303 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
</pre>
<hr />
<pre>
 491   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 492   ffalse[0] = Type::CONTROL;
 493   ffalse[1] = Type::TOP;
 494   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 495 
 496   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 497   fneither[0] = Type::TOP;
 498   fneither[1] = Type::TOP;
 499   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 500 
 501   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 502   ftrue[0] = Type::TOP;
 503   ftrue[1] = Type::CONTROL;
 504   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 505 
 506   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 507   floop[0] = Type::CONTROL;
 508   floop[1] = TypeInt::INT;
 509   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 510 
<span class="line-modified"> 511   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, 0);</span>
<span class="line-modified"> 512   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, OffsetBot);</span>
<span class="line-modified"> 513   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, OffsetBot);</span>
 514 
 515   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 516   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 517 
 518   const Type **fmembar = TypeTuple::fields(0);
 519   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 520 
 521   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 522   fsc[0] = TypeInt::CC;
 523   fsc[1] = Type::MEMORY;
 524   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 525 
 526   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 527   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 528   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 529   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified"> 530                                            false, 0, oopDesc::mark_offset_in_bytes());</span>
 531   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified"> 532                                            false, 0, oopDesc::klass_offset_in_bytes());</span>
<span class="line-modified"> 533   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, OffsetBot, TypeOopPtr::InstanceBot);</span>


 534 
<span class="line-modified"> 535   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, OffsetBot);</span>
 536 
 537   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 538   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 539 
 540   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 541 
 542   mreg2type[Op_Node] = Type::BOTTOM;
 543   mreg2type[Op_Set ] = 0;
 544   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 545   mreg2type[Op_RegI] = TypeInt::INT;
 546   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 547   mreg2type[Op_RegF] = Type::FLOAT;
 548   mreg2type[Op_RegD] = Type::DOUBLE;
 549   mreg2type[Op_RegL] = TypeLong::LONG;
 550   mreg2type[Op_RegFlags] = TypeInt::CC;
 551 
<span class="line-modified"> 552   TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, arrayOopDesc::length_offset_in_bytes());</span>
 553 
<span class="line-modified"> 554   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);</span>
 555 
 556 #ifdef _LP64
 557   if (UseCompressedOops) {
 558     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 559     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 560   } else
 561 #endif
 562   {
 563     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
<span class="line-modified"> 564     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);</span>
 565   }
<span class="line-modified"> 566   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Type::OffsetBot);</span>
<span class="line-modified"> 567   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Type::OffsetBot);</span>
<span class="line-modified"> 568   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Type::OffsetBot);</span>
<span class="line-modified"> 569   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Type::OffsetBot);</span>
<span class="line-modified"> 570   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Type::OffsetBot);</span>
<span class="line-modified"> 571   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Type::OffsetBot);</span>
<span class="line-modified"> 572   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Type::OffsetBot);</span>

 573 
 574   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 575   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 576   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;

 577   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 578   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 579   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 580   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 581   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 582   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 583   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 584   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 585   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 586 
<span class="line-modified"> 587   TypeKlassPtr::OBJECT = TypeKlassPtr::make( TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), 0 );</span>
<span class="line-modified"> 588   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make( TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), 0 );</span>
 589 
 590   const Type **fi2c = TypeTuple::fields(2);
 591   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 592   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 593   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 594 
 595   const Type **intpair = TypeTuple::fields(2);
 596   intpair[0] = TypeInt::INT;
 597   intpair[1] = TypeInt::INT;
 598   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 599 
 600   const Type **longpair = TypeTuple::fields(2);
 601   longpair[0] = TypeLong::LONG;
 602   longpair[1] = TypeLong::LONG;
 603   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 604 
 605   const Type **intccpair = TypeTuple::fields(2);
 606   intccpair[0] = TypeInt::INT;
 607   intccpair[1] = TypeInt::CC;
 608   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 609 
 610   const Type **longccpair = TypeTuple::fields(2);
 611   longccpair[0] = TypeLong::LONG;
 612   longccpair[1] = TypeInt::CC;
 613   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 614 
 615   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 616   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 617   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 618   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 619   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 620   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 621   _const_basic_type[T_INT]         = TypeInt::INT;
 622   _const_basic_type[T_LONG]        = TypeLong::LONG;
 623   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 624   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 625   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 626   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays

 627   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 628   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 629   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 630 
 631   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 632   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 633   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 634   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 635   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 636   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 637   _zero_type[T_INT]         = TypeInt::ZERO;
 638   _zero_type[T_LONG]        = TypeLong::ZERO;
 639   _zero_type[T_FLOAT]       = TypeF::ZERO;
 640   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 641   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 642   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop

 643   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 644   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 645 
 646   // get_zero_type() should not happen for T_CONFLICT
 647   _zero_type[T_CONFLICT]= NULL;
 648 
 649   // Vector predefined types, it needs initialized _const_basic_type[].
 650   if (Matcher::vector_size_supported(T_BYTE,4)) {
 651     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 652   }
 653   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 654     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 655   }
 656   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 657     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 658   }
 659   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 660     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 661   }
 662   if (Matcher::vector_size_supported(T_FLOAT,16)) {
</pre>
<hr />
<pre>
 798   }
 799   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 800     return true;
 801   }
 802   return false;
 803 }
 804 
 805 #endif
 806 
 807 void Type::check_symmetrical(const Type *t, const Type *mt) const {
 808 #ifdef ASSERT
 809   assert(mt == t-&gt;xmeet(this), &quot;meet not commutative&quot;);
 810   const Type* dual_join = mt-&gt;_dual;
 811   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 812   const Type *t2this = dual_join-&gt;xmeet(this-&gt;_dual);
 813 
 814   // Interface meet Oop is Not Symmetric:
 815   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 816   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 817 
<span class="line-modified"> 818   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual) ) {</span>
 819     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 820     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 821     tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();
 822     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 823 
 824     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 825     tty-&gt;print(&quot;this_dual=              &quot;);          _dual-&gt;dump(); tty-&gt;cr();
 826     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 827 
 828     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 829     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 830 
 831     fatal(&quot;meet not symmetric&quot; );
 832   }
 833 #endif
 834 }
 835 
 836 //------------------------------meet-------------------------------------------
 837 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 838 // commutative and the lattice is symmetric.
</pre>
<hr />
<pre>
 902 
 903   case OopPtr:
 904     return t-&gt;xmeet(this);
 905 
 906   case InstPtr:
 907     return t-&gt;xmeet(this);
 908 
 909   case MetadataPtr:
 910   case KlassPtr:
 911     return t-&gt;xmeet(this);
 912 
 913   case AryPtr:
 914     return t-&gt;xmeet(this);
 915 
 916   case NarrowOop:
 917     return t-&gt;xmeet(this);
 918 
 919   case NarrowKlass:
 920     return t-&gt;xmeet(this);
 921 



 922   case Bad:                     // Type check
 923   default:                      // Bogus type not in lattice
 924     typerr(t);
 925     return Type::BOTTOM;
 926 
 927   case Bottom:                  // Ye Olde Default
 928     return t;
 929 
 930   case FloatTop:
 931     if( _base == FloatTop ) return this;
 932   case FloatBot:                // Float
 933     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
 934     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
 935     typerr(t);
 936     return Type::BOTTOM;
 937 
 938   case DoubleTop:
 939     if( _base == DoubleTop ) return this;
 940   case DoubleBot:               // Double
 941     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
</pre>
<hr />
<pre>
 969 
 970 //------------------------------xdual------------------------------------------
 971 // Compute dual right now.
 972 const Type::TYPES Type::dual_type[Type::lastype] = {
 973   Bad,          // Bad
 974   Control,      // Control
 975   Bottom,       // Top
 976   Bad,          // Int - handled in v-call
 977   Bad,          // Long - handled in v-call
 978   Half,         // Half
 979   Bad,          // NarrowOop - handled in v-call
 980   Bad,          // NarrowKlass - handled in v-call
 981 
 982   Bad,          // Tuple - handled in v-call
 983   Bad,          // Array - handled in v-call
 984   Bad,          // VectorS - handled in v-call
 985   Bad,          // VectorD - handled in v-call
 986   Bad,          // VectorX - handled in v-call
 987   Bad,          // VectorY - handled in v-call
 988   Bad,          // VectorZ - handled in v-call

 989 
 990   Bad,          // AnyPtr - handled in v-call
 991   Bad,          // RawPtr - handled in v-call
 992   Bad,          // OopPtr - handled in v-call
 993   Bad,          // InstPtr - handled in v-call
 994   Bad,          // AryPtr - handled in v-call
 995 
 996   Bad,          //  MetadataPtr - handled in v-call
 997   Bad,          // KlassPtr - handled in v-call
 998 
 999   Bad,          // Function - handled in v-call
1000   Abio,         // Abio
1001   Return_Address,// Return_Address
1002   Memory,       // Memory
1003   FloatBot,     // FloatTop
1004   FloatCon,     // FloatCon
1005   FloatTop,     // FloatBot
1006   DoubleBot,    // DoubleTop
1007   DoubleCon,    // DoubleCon
1008   DoubleTop,    // DoubleBot
</pre>
<hr />
<pre>
1864 
1865 bool TypeLong::empty(void) const {
1866   return _lo &gt; _hi;
1867 }
1868 
1869 //=============================================================================
1870 // Convenience common pre-built types.
1871 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1872 const TypeTuple *TypeTuple::IFFALSE;
1873 const TypeTuple *TypeTuple::IFTRUE;
1874 const TypeTuple *TypeTuple::IFNEITHER;
1875 const TypeTuple *TypeTuple::LOOPBODY;
1876 const TypeTuple *TypeTuple::MEMBAR;
1877 const TypeTuple *TypeTuple::STORECONDITIONAL;
1878 const TypeTuple *TypeTuple::START_I2C;
1879 const TypeTuple *TypeTuple::INT_PAIR;
1880 const TypeTuple *TypeTuple::LONG_PAIR;
1881 const TypeTuple *TypeTuple::INT_CC_PAIR;
1882 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1883 


















1884 
1885 //------------------------------make-------------------------------------------
1886 // Make a TypeTuple from the range of a method signature
<span class="line-modified">1887 const TypeTuple *TypeTuple::make_range(ciSignature* sig) {</span>
1888   ciType* return_type = sig-&gt;return_type();
1889   uint arg_cnt = return_type-&gt;size();




1890   const Type **field_array = fields(arg_cnt);
1891   switch (return_type-&gt;basic_type()) {
1892   case T_LONG:
1893     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1894     field_array[TypeFunc::Parms+1] = Type::HALF;
1895     break;
1896   case T_DOUBLE:
1897     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1898     field_array[TypeFunc::Parms+1] = Type::HALF;
1899     break;
1900   case T_OBJECT:
1901   case T_ARRAY:
1902   case T_BOOLEAN:
1903   case T_CHAR:
1904   case T_FLOAT:
1905   case T_BYTE:
1906   case T_SHORT:
1907   case T_INT:
1908     field_array[TypeFunc::Parms] = get_const_type(return_type);
1909     break;











1910   case T_VOID:
1911     break;
1912   default:
1913     ShouldNotReachHere();
1914   }
1915   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1916 }
1917 
1918 // Make a TypeTuple from the domain of a method signature
<span class="line-modified">1919 const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {</span>
<span class="line-modified">1920   uint arg_cnt = sig-&gt;size();</span>









1921 
1922   uint pos = TypeFunc::Parms;
<span class="line-modified">1923   const Type **field_array;</span>
<span class="line-modified">1924   if (recv != NULL) {</span>
<span class="line-modified">1925     arg_cnt++;</span>
<span class="line-modified">1926     field_array = fields(arg_cnt);</span>
<span class="line-modified">1927     // Use get_const_type here because it respects UseUniqueSubclasses:</span>
<span class="line-modified">1928     field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="line-modified">1929   } else {</span>
<span class="line-modified">1930     field_array = fields(arg_cnt);</span>



1931   }
1932 
1933   int i = 0;
1934   while (pos &lt; TypeFunc::Parms + arg_cnt) {
1935     ciType* type = sig-&gt;type_at(i);


1936 
<span class="line-modified">1937     switch (type-&gt;basic_type()) {</span>
1938     case T_LONG:
1939       field_array[pos++] = TypeLong::LONG;
1940       field_array[pos++] = Type::HALF;
1941       break;
1942     case T_DOUBLE:
1943       field_array[pos++] = Type::DOUBLE;
1944       field_array[pos++] = Type::HALF;
1945       break;
1946     case T_OBJECT:
1947     case T_ARRAY:
1948     case T_FLOAT:
1949     case T_INT:
1950       field_array[pos++] = get_const_type(type);
1951       break;
1952     case T_BOOLEAN:
1953     case T_CHAR:
1954     case T_BYTE:
1955     case T_SHORT:
1956       field_array[pos++] = TypeInt::INT;
1957       break;









1958     default:
1959       ShouldNotReachHere();
1960     }







1961     i++;
1962   }

1963 
1964   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1965 }
1966 
1967 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
1968   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
1969 }
1970 
1971 //------------------------------fields-----------------------------------------
1972 // Subroutine call type with space allocated for argument types
1973 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
1974 const Type **TypeTuple::fields( uint arg_cnt ) {
1975   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
1976   flds[TypeFunc::Control  ] = Type::CONTROL;
1977   flds[TypeFunc::I_O      ] = Type::ABIO;
1978   flds[TypeFunc::Memory   ] = Type::MEMORY;
1979   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
1980   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
1981 
1982   return flds;
</pre>
<hr />
<pre>
2077     if (_fields[i]-&gt;empty())  return true;
2078   }
2079   return false;
2080 }
2081 
2082 //=============================================================================
2083 // Convenience common pre-built types.
2084 
2085 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2086   // Certain normalizations keep us sane when comparing types.
2087   // We do not want arrayOop variables to differ only by the wideness
2088   // of their index types.  Pick minimum wideness, since that is the
2089   // forced wideness of small ranges anyway.
2090   if (size-&gt;_widen != Type::WidenMin)
2091     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2092   else
2093     return size;
2094 }
2095 
2096 //------------------------------make-------------------------------------------
<span class="line-modified">2097 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable) {</span>

2098   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2099     elem = elem-&gt;make_narrowoop();
2100   }
2101   size = normalize_array_size(size);
<span class="line-modified">2102   return (TypeAry*)(new TypeAry(elem,size,stable))-&gt;hashcons();</span>
2103 }
2104 
2105 //------------------------------meet-------------------------------------------
2106 // Compute the MEET of two types.  It returns a new Type object.
2107 const Type *TypeAry::xmeet( const Type *t ) const {
2108   // Perform a fast test for common case; meeting the same types together.
2109   if( this == t ) return this;  // Meeting same type-rep?
2110 
2111   // Current &quot;this-&gt;_base&quot; is Ary
2112   switch (t-&gt;base()) {          // switch on original type
2113 
2114   case Bottom:                  // Ye Olde Default
2115     return t;
2116 
2117   default:                      // All else is a mistake
2118     typerr(t);
2119 
2120   case Array: {                 // Meeting 2 arrays?
2121     const TypeAry *a = t-&gt;is_ary();
2122     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2123                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
<span class="line-modified">2124                          _stable &amp;&amp; a-&gt;_stable);</span>


2125   }
2126   case Top:
2127     break;
2128   }
2129   return this;                  // Return the double constant
2130 }
2131 
2132 //------------------------------xdual------------------------------------------
2133 // Dual: compute field-by-field dual
2134 const Type *TypeAry::xdual() const {
2135   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2136   size_dual = normalize_array_size(size_dual);
<span class="line-modified">2137   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable);</span>
2138 }
2139 
2140 //------------------------------eq---------------------------------------------
2141 // Structural equality check for Type representations
2142 bool TypeAry::eq( const Type *t ) const {
2143   const TypeAry *a = (const TypeAry*)t;
2144   return _elem == a-&gt;_elem &amp;&amp;
2145     _stable == a-&gt;_stable &amp;&amp;
<span class="line-modified">2146     _size == a-&gt;_size;</span>



2147 }
2148 
2149 //------------------------------hash-------------------------------------------
2150 // Type-specific hashing function.
2151 int TypeAry::hash(void) const {
2152   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2153 }
2154 
2155 /**
2156  * Return same type without a speculative part in the element
2157  */
2158 const Type* TypeAry::remove_speculative() const {
<span class="line-modified">2159   return make(_elem-&gt;remove_speculative(), _size, _stable);</span>
2160 }
2161 
2162 /**
2163  * Return same type with cleaned up speculative part of element
2164  */
2165 const Type* TypeAry::cleanup_speculative() const {
<span class="line-modified">2166   return make(_elem-&gt;cleanup_speculative(), _size, _stable);</span>
2167 }
2168 
2169 /**
2170  * Return same type but with a different inline depth (used for speculation)
2171  *
2172  * @param depth  depth to meet with
2173  */
2174 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2175   if (!UseInlineDepthForSpeculativeTypes) {
2176     return this;
2177   }
2178   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2179 }
2180 
2181 //----------------------interface_vs_oop---------------------------------------
2182 #ifdef ASSERT
2183 bool TypeAry::interface_vs_oop(const Type *t) const {
2184   const TypeAry* t_ary = t-&gt;is_ary();
2185   if (t_ary) {
2186     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2187     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2188     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2189       return this_ptr-&gt;interface_vs_oop(t_ptr);
2190     }
2191   }
2192   return false;
2193 }
2194 #endif
2195 
2196 //------------------------------dump2------------------------------------------
2197 #ifndef PRODUCT
2198 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2199   if (_stable)  st-&gt;print(&quot;stable:&quot;);




2200   _elem-&gt;dump2(d, depth, st);
2201   st-&gt;print(&quot;[&quot;);
2202   _size-&gt;dump2(d, depth, st);
2203   st-&gt;print(&quot;]&quot;);
2204 }
2205 #endif
2206 
2207 //------------------------------singleton--------------------------------------
2208 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2209 // constants (Ldi nodes).  Singletons are integer, float or double constants
2210 // or a single symbol.
2211 bool TypeAry::singleton(void) const {
2212   return false;                 // Never a singleton
2213 }
2214 
2215 bool TypeAry::empty(void) const {
2216   return _elem-&gt;empty() || _size-&gt;empty();
2217 }
2218 
2219 //--------------------------ary_must_be_exact----------------------------------
</pre>
<hr />
<pre>
2233   ciKlass* tklass = toop-&gt;klass();
2234   if (tklass == NULL)       return false;  // unloaded class
2235   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2236   const TypeInstPtr* tinst;
2237   if (_elem-&gt;isa_narrowoop())
2238     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2239   else
2240     tinst = _elem-&gt;isa_instptr();
2241   if (tinst)
2242     return tklass-&gt;as_instance_klass()-&gt;is_final();
2243   const TypeAryPtr*  tap;
2244   if (_elem-&gt;isa_narrowoop())
2245     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2246   else
2247     tap = _elem-&gt;isa_aryptr();
2248   if (tap)
2249     return tap-&gt;ary()-&gt;ary_must_be_exact();
2250   return false;
2251 }
2252 




























































































































2253 //==============================TypeVect=======================================
2254 // Convenience common pre-built types.
2255 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2256 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2257 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2258 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2259 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2260 
2261 //------------------------------make-------------------------------------------
2262 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2263   BasicType elem_bt = elem-&gt;array_element_basic_type();
2264   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2265   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2266   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2267   int size = length * type2aelembytes(elem_bt);
2268   switch (Matcher::vector_ideal_reg(size)) {
2269   case Op_VecS:
2270     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2271   case Op_RegL:
2272   case Op_VecD:
</pre>
<hr />
<pre>
2374 
2375 //=============================================================================
2376 // Convenience common pre-built types.
2377 const TypePtr *TypePtr::NULL_PTR;
2378 const TypePtr *TypePtr::NOTNULL;
2379 const TypePtr *TypePtr::BOTTOM;
2380 
2381 //------------------------------meet-------------------------------------------
2382 // Meet over the PTR enum
2383 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2384   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2385   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2386   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2387   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2388   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2389   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2390   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2391 };
2392 
2393 //------------------------------make-------------------------------------------
<span class="line-modified">2394 const TypePtr *TypePtr::make(TYPES t, enum PTR ptr, int offset, const TypePtr* speculative, int inline_depth) {</span>
2395   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2396 }
2397 
2398 //------------------------------cast_to_ptr_type-------------------------------
2399 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2400   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2401   if( ptr == _ptr ) return this;
2402   return make(_base, ptr, _offset, _speculative, _inline_depth);
2403 }
2404 
2405 //------------------------------get_con----------------------------------------
2406 intptr_t TypePtr::get_con() const {
2407   assert( _ptr == Null, &quot;&quot; );
<span class="line-modified">2408   return _offset;</span>
2409 }
2410 
2411 //------------------------------meet-------------------------------------------
2412 // Compute the MEET of two types.  It returns a new Type object.
2413 const Type *TypePtr::xmeet(const Type *t) const {
2414   const Type* res = xmeet_helper(t);
2415   if (res-&gt;isa_ptr() == NULL) {
2416     return res;
2417   }
2418 
2419   const TypePtr* res_ptr = res-&gt;is_ptr();
2420   if (res_ptr-&gt;speculative() != NULL) {
2421     // type-&gt;speculative() == NULL means that speculation is no better
2422     // than type, i.e. type-&gt;speculative() == type. So there are 2
2423     // ways to represent the fact that we have no useful speculative
2424     // data and we should use a single one to be able to test for
2425     // equality between types. Check whether type-&gt;speculative() ==
2426     // type and set speculative to NULL if it is the case.
2427     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2428       return res_ptr-&gt;remove_speculative();
</pre>
<hr />
<pre>
2457     const TypePtr *tp = t-&gt;is_ptr();
2458     const TypePtr* speculative = xmeet_speculative(tp);
2459     int depth = meet_inline_depth(tp-&gt;inline_depth());
2460     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2461   }
2462   case RawPtr:                  // For these, flip the call around to cut down
2463   case OopPtr:
2464   case InstPtr:                 // on the cases I have to handle.
2465   case AryPtr:
2466   case MetadataPtr:
2467   case KlassPtr:
2468     return t-&gt;xmeet(this);      // Call in reverse direction
2469   default:                      // All else is a mistake
2470     typerr(t);
2471 
2472   }
2473   return this;
2474 }
2475 
2476 //------------------------------meet_offset------------------------------------
<span class="line-modified">2477 int TypePtr::meet_offset( int offset ) const {</span>
<span class="line-modified">2478   // Either is &#39;TOP&#39; offset?  Return the other offset!</span>
<span class="line-removed">2479   if( _offset == OffsetTop ) return offset;</span>
<span class="line-removed">2480   if( offset == OffsetTop ) return _offset;</span>
<span class="line-removed">2481   // If either is different, return &#39;BOTTOM&#39; offset</span>
<span class="line-removed">2482   if( _offset != offset ) return OffsetBot;</span>
<span class="line-removed">2483   return _offset;</span>
2484 }
2485 
2486 //------------------------------dual_offset------------------------------------
<span class="line-modified">2487 int TypePtr::dual_offset( ) const {</span>
<span class="line-modified">2488   if( _offset == OffsetTop ) return OffsetBot;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;</span>
<span class="line-removed">2489   if( _offset == OffsetBot ) return OffsetTop;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;</span>
<span class="line-removed">2490   return _offset;               // Map everything else into self</span>
2491 }
2492 
2493 //------------------------------xdual------------------------------------------
2494 // Dual: compute field-by-field dual
2495 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2496   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2497 };
2498 const Type *TypePtr::xdual() const {
2499   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2500 }
2501 
2502 //------------------------------xadd_offset------------------------------------
<span class="line-modified">2503 int TypePtr::xadd_offset( intptr_t offset ) const {</span>
<span class="line-modified">2504   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!</span>
<span class="line-removed">2505   if( _offset == OffsetTop || offset == OffsetTop ) return OffsetTop;</span>
<span class="line-removed">2506   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!</span>
<span class="line-removed">2507   if( _offset == OffsetBot || offset == OffsetBot ) return OffsetBot;</span>
<span class="line-removed">2508   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!</span>
<span class="line-removed">2509   offset += (intptr_t)_offset;</span>
<span class="line-removed">2510   if (offset != (int)offset || offset == OffsetTop) return OffsetBot;</span>
<span class="line-removed">2511 </span>
<span class="line-removed">2512   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );</span>
<span class="line-removed">2513   // It is possible to construct a negative offset during PhaseCCP</span>
<span class="line-removed">2514 </span>
<span class="line-removed">2515   return (int)offset;        // Sum valid offsets</span>
2516 }
2517 
2518 //------------------------------add_offset-------------------------------------
2519 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2520   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2521 }
2522 
2523 //------------------------------eq---------------------------------------------
2524 // Structural equality check for Type representations
2525 bool TypePtr::eq( const Type *t ) const {
2526   const TypePtr *a = (const TypePtr*)t;
<span class="line-modified">2527   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;offset() &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;</span>
2528 }
2529 
2530 //------------------------------hash-------------------------------------------
2531 // Type-specific hashing function.
2532 int TypePtr::hash(void) const {
<span class="line-modified">2533   return java_add(java_add((jint)_ptr, (jint)_offset), java_add((jint)hash_speculative(), (jint)_inline_depth));</span>
2534 ;
2535 }
2536 
2537 /**
2538  * Return same type without a speculative part
2539  */
2540 const Type* TypePtr::remove_speculative() const {
2541   if (_speculative == NULL) {
2542     return this;
2543   }
2544   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2545   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2546 }
2547 
2548 /**
2549  * Return same type but drop speculative part if we know we won&#39;t use
2550  * it
2551  */
2552 const Type* TypePtr::cleanup_speculative() const {
2553   if (speculative() == NULL) {
</pre>
<hr />
<pre>
2773   }
2774   // We already know the speculative type is always null
2775   if (speculative_always_null()) {
2776     return false;
2777   }
2778   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
2779     return false;
2780   }
2781   return true;
2782 }
2783 
2784 //------------------------------dump2------------------------------------------
2785 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
2786   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
2787 };
2788 
2789 #ifndef PRODUCT
2790 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2791   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
2792   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
<span class="line-modified">2793   if( _offset == OffsetTop ) st-&gt;print(&quot;+top&quot;);</span>
<span class="line-removed">2794   else if( _offset == OffsetBot ) st-&gt;print(&quot;+bot&quot;);</span>
<span class="line-removed">2795   else if( _offset ) st-&gt;print(&quot;+%d&quot;, _offset);</span>
2796   dump_inline_depth(st);
2797   dump_speculative(st);
2798 }
2799 
2800 /**
2801  *dump the speculative part of the type
2802  */
2803 void TypePtr::dump_speculative(outputStream *st) const {
2804   if (_speculative != NULL) {
2805     st-&gt;print(&quot; (speculative=&quot;);
2806     _speculative-&gt;dump_on(st);
2807     st-&gt;print(&quot;)&quot;);
2808   }
2809 }
2810 
2811 /**
2812  *dump the inline depth of the type
2813  */
2814 void TypePtr::dump_inline_depth(outputStream *st) const {
2815   if (_inline_depth != InlineDepthBottom) {
2816     if (_inline_depth == InlineDepthTop) {
2817       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
2818     } else {
2819       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
2820     }
2821   }
2822 }
2823 #endif
2824 
2825 //------------------------------singleton--------------------------------------
2826 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2827 // constants
2828 bool TypePtr::singleton(void) const {
2829   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">2830   return (_offset != OffsetBot) &amp;&amp; !below_centerline(_ptr);</span>
2831 }
2832 
2833 bool TypePtr::empty(void) const {
<span class="line-modified">2834   return (_offset == OffsetTop) || above_centerline(_ptr);</span>
2835 }
2836 
2837 //=============================================================================
2838 // Convenience common pre-built types.
2839 const TypeRawPtr *TypeRawPtr::BOTTOM;
2840 const TypeRawPtr *TypeRawPtr::NOTNULL;
2841 
2842 //------------------------------make-------------------------------------------
2843 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
2844   assert( ptr != Constant, &quot;what is the constant?&quot; );
2845   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
2846   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
2847 }
2848 
2849 const TypeRawPtr *TypeRawPtr::make( address bits ) {
2850   assert( bits, &quot;Use TypePtr for NULL&quot; );
2851   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
2852 }
2853 
2854 //------------------------------cast_to_ptr_type-------------------------------
</pre>
<hr />
<pre>
2956 // Type-specific hashing function.
2957 int TypeRawPtr::hash(void) const {
2958   return (intptr_t)_bits + TypePtr::hash();
2959 }
2960 
2961 //------------------------------dump2------------------------------------------
2962 #ifndef PRODUCT
2963 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2964   if( _ptr == Constant )
2965     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
2966   else
2967     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
2968 }
2969 #endif
2970 
2971 //=============================================================================
2972 // Convenience common pre-built type.
2973 const TypeOopPtr *TypeOopPtr::BOTTOM;
2974 
2975 //------------------------------TypeOopPtr-------------------------------------
<span class="line-modified">2976 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,</span>
2977                        int instance_id, const TypePtr* speculative, int inline_depth)
2978   : TypePtr(t, ptr, offset, speculative, inline_depth),
2979     _const_oop(o), _klass(k),
2980     _klass_is_exact(xk),
2981     _is_ptr_to_narrowoop(false),
2982     _is_ptr_to_narrowklass(false),
2983     _is_ptr_to_boxed_value(false),
2984     _instance_id(instance_id) {
2985   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
<span class="line-modified">2986       (offset &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {</span>
<span class="line-modified">2987     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset);</span>
2988   }
2989 #ifdef _LP64
<span class="line-modified">2990   if (_offset &gt; 0 || _offset == Type::OffsetTop || _offset == Type::OffsetBot) {</span>
<span class="line-modified">2991     if (_offset == oopDesc::klass_offset_in_bytes()) {</span>
2992       _is_ptr_to_narrowklass = UseCompressedClassPointers;
2993     } else if (klass() == NULL) {
2994       // Array with unknown body type
2995       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
2996       _is_ptr_to_narrowoop = UseCompressedOops;
<span class="line-modified">2997     } else if (this-&gt;isa_aryptr()) {</span>
<span class="line-modified">2998       _is_ptr_to_narrowoop = (UseCompressedOops &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp;</span>
<span class="line-modified">2999                              _offset != arrayOopDesc::length_offset_in_bytes());</span>









3000     } else if (klass()-&gt;is_instance_klass()) {
<span class="line-removed">3001       ciInstanceKlass* ik = klass()-&gt;as_instance_klass();</span>
<span class="line-removed">3002       ciField* field = NULL;</span>
3003       if (this-&gt;isa_klassptr()) {
3004         // Perm objects don&#39;t use compressed references
<span class="line-modified">3005       } else if (_offset == OffsetBot || _offset == OffsetTop) {</span>
3006         // unsafe access
3007         _is_ptr_to_narrowoop = UseCompressedOops;
3008       } else { // exclude unsafe ops
3009         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
<span class="line-modified">3010 </span>
<span class="line-modified">3011         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;</span>
<span class="line-removed">3012             (_offset == java_lang_Class::klass_offset() ||</span>
3013              _offset == java_lang_Class::array_klass_offset())) {
3014           // Special hidden fields from the Class.
3015           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3016           _is_ptr_to_narrowoop = false;
3017         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
<span class="line-modified">3018                    _offset &gt;= InstanceMirrorKlass::offset_of_static_fields()) {</span>
3019           // Static fields
3020           assert(o != NULL, &quot;must be constant&quot;);
<span class="line-modified">3021           ciInstanceKlass* k = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();</span>
<span class="line-modified">3022           ciField* field = k-&gt;get_field_by_offset(_offset, true);</span>
<span class="line-modified">3023           assert(field != NULL, &quot;missing field&quot;);</span>
<span class="line-modified">3024           BasicType basic_elem_type = field-&gt;layout_type();</span>






3025           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3026         } else {
3027           // Instance fields which contains a compressed oop references.
<span class="line-modified">3028           field = ik-&gt;get_field_by_offset(_offset, false);</span>

3029           if (field != NULL) {
3030             BasicType basic_elem_type = field-&gt;layout_type();
3031             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3032           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3033             // Compile::find_alias_type() cast exactness on all types to verify
3034             // that it does not affect alias type.
3035             _is_ptr_to_narrowoop = UseCompressedOops;
3036           } else {
3037             // Type for the copy start in LibraryCallKit::inline_native_clone().
3038             _is_ptr_to_narrowoop = UseCompressedOops;
3039           }
3040         }
3041       }
3042     }
3043   }
3044 #endif
3045 }
3046 
3047 //------------------------------make-------------------------------------------
<span class="line-modified">3048 const TypeOopPtr *TypeOopPtr::make(PTR ptr, int offset, int instance_id,</span>
<span class="line-modified">3049                                      const TypePtr* speculative, int inline_depth) {</span>
3050   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3051   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3052   bool      xk = false;
3053   ciObject* o = NULL;
<span class="line-modified">3054   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
3055 }
3056 
3057 
3058 //------------------------------cast_to_ptr_type-------------------------------
3059 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3060   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3061   if( ptr == _ptr ) return this;
3062   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3063 }
3064 
3065 //-----------------------------cast_to_instance_id----------------------------
3066 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3067   // There are no instances of a general oop.
3068   // Return self unchanged.
3069   return this;
3070 }
3071 
3072 //-----------------------------cast_to_exactness-------------------------------
3073 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3074   // There is no such thing as an exact general oop.
3075   // Return self unchanged.
3076   return this;
3077 }
3078 
<span class="line-removed">3079 </span>
<span class="line-removed">3080 //------------------------------as_klass_type----------------------------------</span>
<span class="line-removed">3081 // Return the klass type corresponding to this instance or array type.</span>
<span class="line-removed">3082 // It is the type that is loaded from an object of this type.</span>
<span class="line-removed">3083 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {</span>
<span class="line-removed">3084   ciKlass* k = klass();</span>
<span class="line-removed">3085   bool    xk = klass_is_exact();</span>
<span class="line-removed">3086   if (k == NULL)</span>
<span class="line-removed">3087     return TypeKlassPtr::OBJECT;</span>
<span class="line-removed">3088   else</span>
<span class="line-removed">3089     return TypeKlassPtr::make(xk? Constant: NotNull, k, 0);</span>
<span class="line-removed">3090 }</span>
<span class="line-removed">3091 </span>
3092 //------------------------------meet-------------------------------------------
3093 // Compute the MEET of two types.  It returns a new Type object.
3094 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3095   // Perform a fast test for common case; meeting the same types together.
3096   if( this == t ) return this;  // Meeting same type-rep?
3097 
3098   // Current &quot;this-&gt;_base&quot; is OopPtr
3099   switch (t-&gt;base()) {          // switch on original type
3100 
3101   case Int:                     // Mixing ints &amp; oops happens when javac
3102   case Long:                    // reuses local variables
3103   case FloatTop:
3104   case FloatCon:
3105   case FloatBot:
3106   case DoubleTop:
3107   case DoubleCon:
3108   case DoubleBot:
3109   case NarrowOop:
3110   case NarrowKlass:
3111   case Bottom:                  // Ye Olde Default
3112     return Type::BOTTOM;
3113   case Top:
3114     return this;
3115 
3116   default:                      // All else is a mistake
3117     typerr(t);
3118 
3119   case RawPtr:
3120   case MetadataPtr:
3121   case KlassPtr:
3122     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3123 
3124   case AnyPtr: {
3125     // Found an AnyPtr type vs self-OopPtr type
3126     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">3127     int offset = meet_offset(tp-&gt;offset());</span>
3128     PTR ptr = meet_ptr(tp-&gt;ptr());
3129     const TypePtr* speculative = xmeet_speculative(tp);
3130     int depth = meet_inline_depth(tp-&gt;inline_depth());
3131     switch (tp-&gt;ptr()) {
3132     case Null:
3133       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3134       // else fall through:
3135     case TopPTR:
3136     case AnyNull: {
3137       int instance_id = meet_instance_id(InstanceTop);
3138       return make(ptr, offset, instance_id, speculative, depth);
3139     }
3140     case BotPTR:
3141     case NotNull:
3142       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3143     default: typerr(t);
3144     }
3145   }
3146 
3147   case OopPtr: {                 // Meeting to other OopPtrs
</pre>
<hr />
<pre>
3149     int instance_id = meet_instance_id(tp-&gt;instance_id());
3150     const TypePtr* speculative = xmeet_speculative(tp);
3151     int depth = meet_inline_depth(tp-&gt;inline_depth());
3152     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3153   }
3154 
3155   case InstPtr:                  // For these, flip the call around to cut down
3156   case AryPtr:
3157     return t-&gt;xmeet(this);      // Call in reverse direction
3158 
3159   } // End of switch
3160   return this;                  // Return the double constant
3161 }
3162 
3163 
3164 //------------------------------xdual------------------------------------------
3165 // Dual of a pure heap pointer.  No relevant klass or oop information.
3166 const Type *TypeOopPtr::xdual() const {
3167   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3168   assert(const_oop() == NULL,             &quot;no constants here&quot;);
<span class="line-modified">3169   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
3170 }
3171 
3172 //--------------------------make_from_klass_common-----------------------------
3173 // Computes the element-type given a klass.
3174 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
<span class="line-modified">3175   if (klass-&gt;is_instance_klass()) {</span>
3176     Compile* C = Compile::current();
3177     Dependencies* deps = C-&gt;dependencies();
3178     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3179     // Element is an instance
3180     bool klass_is_exact = false;
3181     if (klass-&gt;is_loaded()) {
3182       // Try to set klass_is_exact.
3183       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3184       klass_is_exact = ik-&gt;is_final();
3185       if (!klass_is_exact &amp;&amp; klass_change
3186           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3187         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3188         if (sub != NULL) {
3189           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3190           klass = ik = sub;
3191           klass_is_exact = sub-&gt;is_final();
3192         }
3193       }
3194       if (!klass_is_exact &amp;&amp; try_for_exact &amp;&amp; deps != NULL &amp;&amp;
3195           !ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3196         // Add a dependence; if concrete subclass added we need to recompile
3197         deps-&gt;assert_leaf_type(ik);
3198         klass_is_exact = true;
3199       }
3200     }
<span class="line-modified">3201     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);</span>
3202   } else if (klass-&gt;is_obj_array_klass()) {
<span class="line-modified">3203     // Element is an object array. Recursively call ourself.</span>
<span class="line-modified">3204     const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_obj_array_klass()-&gt;element_klass(), false, try_for_exact);</span>












3205     bool xk = etype-&gt;klass_is_exact();
<span class="line-modified">3206     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);</span>
3207     // We used to pass NotNull in here, asserting that the sub-arrays
3208     // are all not-null.  This is not true in generally, as code can
3209     // slam NULLs down in the subarrays.
<span class="line-modified">3210     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);</span>
3211     return arr;
3212   } else if (klass-&gt;is_type_array_klass()) {
3213     // Element is an typeArray
3214     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
<span class="line-modified">3215     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);</span>

3216     // We used to pass NotNull in here, asserting that the array pointer
3217     // is not-null. That was not true in general.
<span class="line-modified">3218     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, 0);</span>





3219     return arr;
3220   } else {
3221     ShouldNotReachHere();
3222     return NULL;
3223   }
3224 }
3225 
3226 //------------------------------make_from_constant-----------------------------
3227 // Make a java pointer from an oop constant
3228 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3229   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3230 
3231   const bool make_constant = require_constant || o-&gt;should_be_constant();
3232 
3233   ciKlass* klass = o-&gt;klass();
<span class="line-modified">3234   if (klass-&gt;is_instance_klass()) {</span>
<span class="line-modified">3235     // Element is an instance</span>
3236     if (make_constant) {
3237       return TypeInstPtr::make(o);
3238     } else {
<span class="line-modified">3239       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, 0);</span>
3240     }
3241   } else if (klass-&gt;is_obj_array_klass()) {
3242     // Element is an object array. Recursively call ourself.
<span class="line-modified">3243     const TypeOopPtr *etype =</span>
<span class="line-modified">3244       TypeOopPtr::make_from_klass_raw(klass-&gt;as_obj_array_klass()-&gt;element_klass());</span>
<span class="line-modified">3245     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));</span>





3246     // We used to pass NotNull in here, asserting that the sub-arrays
3247     // are all not-null.  This is not true in generally, as code can
3248     // slam NULLs down in the subarrays.
3249     if (make_constant) {
<span class="line-modified">3250       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);</span>
3251     } else {
<span class="line-modified">3252       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);</span>
3253     }
3254   } else if (klass-&gt;is_type_array_klass()) {
3255     // Element is an typeArray
<span class="line-modified">3256     const Type* etype =</span>
<span class="line-modified">3257       (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());</span>
<span class="line-modified">3258     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));</span>
3259     // We used to pass NotNull in here, asserting that the array pointer
3260     // is not-null. That was not true in general.
3261     if (make_constant) {
<span class="line-modified">3262       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);</span>
3263     } else {
<span class="line-modified">3264       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);</span>











3265     }
3266   }
3267 
3268   fatal(&quot;unhandled object type&quot;);
3269   return NULL;
3270 }
3271 
3272 //------------------------------get_con----------------------------------------
3273 intptr_t TypeOopPtr::get_con() const {
3274   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-modified">3275   assert( _offset &gt;= 0, &quot;&quot; );</span>
3276 
<span class="line-modified">3277   if (_offset != 0) {</span>
3278     // After being ported to the compiler interface, the compiler no longer
3279     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3280     // to a handle at compile time.  This handle is embedded in the generated
3281     // code and dereferenced at the time the nmethod is made.  Until that time,
3282     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3283     // have access to the addresses!).  This does not seem to currently happen,
3284     // but this assertion here is to help prevent its occurence.
3285     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3286     ShouldNotReachHere();
3287   }
3288 
3289   return (intptr_t)const_oop()-&gt;constant_encoding();
3290 }
3291 
3292 
3293 //-----------------------------filter------------------------------------------
3294 // Do not allow interface-vs.-noninterface joins to collapse to top.
3295 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3296 
3297   const Type* ft = join_helper(kills, include_speculative);
</pre>
<hr />
<pre>
3350     return (one == two) &amp;&amp; TypePtr::eq(t);
3351   } else {
3352     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3353   }
3354 }
3355 
3356 //------------------------------hash-------------------------------------------
3357 // Type-specific hashing function.
3358 int TypeOopPtr::hash(void) const {
3359   return
3360     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3361              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3362 }
3363 
3364 //------------------------------dump2------------------------------------------
3365 #ifndef PRODUCT
3366 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3367   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3368   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3369   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
<span class="line-modified">3370   switch( _offset ) {</span>
<span class="line-removed">3371   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;</span>
<span class="line-removed">3372   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;</span>
<span class="line-removed">3373   case         0: break;</span>
<span class="line-removed">3374   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;</span>
<span class="line-removed">3375   }</span>
3376   if (_instance_id == InstanceTop)
3377     st-&gt;print(&quot;,iid=top&quot;);
3378   else if (_instance_id != InstanceBot)
3379     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3380 
3381   dump_inline_depth(st);
3382   dump_speculative(st);
3383 }
3384 #endif
3385 
3386 //------------------------------singleton--------------------------------------
3387 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3388 // constants
3389 bool TypeOopPtr::singleton(void) const {
3390   // detune optimizer to not generate constant oop + constant offset as a constant!
3391   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">3392   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);</span>
3393 }
3394 
3395 //------------------------------add_offset-------------------------------------
3396 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3397   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3398 }
3399 
3400 /**
3401  * Return same type without a speculative part
3402  */
3403 const Type* TypeOopPtr::remove_speculative() const {
3404   if (_speculative == NULL) {
3405     return this;
3406   }
3407   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3408   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3409 }
3410 
3411 /**
3412  * Return same type but drop speculative part if we know we won&#39;t use
</pre>
<hr />
<pre>
3464  *
3465  * @return  true if type profile is valuable
3466  */
3467 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3468   // no way to improve an already exact type
3469   if (klass_is_exact()) {
3470     return false;
3471   }
3472   return TypePtr::would_improve_type(exact_kls, inline_depth);
3473 }
3474 
3475 //=============================================================================
3476 // Convenience common pre-built types.
3477 const TypeInstPtr *TypeInstPtr::NOTNULL;
3478 const TypeInstPtr *TypeInstPtr::BOTTOM;
3479 const TypeInstPtr *TypeInstPtr::MIRROR;
3480 const TypeInstPtr *TypeInstPtr::MARK;
3481 const TypeInstPtr *TypeInstPtr::KLASS;
3482 
3483 //------------------------------TypeInstPtr-------------------------------------
<span class="line-modified">3484 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,</span>
<span class="line-modified">3485                          int instance_id, const TypePtr* speculative, int inline_depth)</span>
<span class="line-modified">3486   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth),</span>
<span class="line-modified">3487     _name(k-&gt;name()) {</span>
<span class="line-modified">3488    assert(k != NULL &amp;&amp;</span>
<span class="line-modified">3489           (k-&gt;is_loaded() || o == NULL),</span>
<span class="line-modified">3490           &quot;cannot have constants with non-loaded klass&quot;);</span>



3491 };
3492 
3493 //------------------------------make-------------------------------------------
3494 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3495                                      ciKlass* k,
3496                                      bool xk,
3497                                      ciObject* o,
<span class="line-modified">3498                                      int offset,</span>

3499                                      int instance_id,
3500                                      const TypePtr* speculative,
3501                                      int inline_depth) {
3502   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3503   // Either const_oop() is NULL or else ptr is Constant
3504   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3505           &quot;constant pointers must have a value supplied&quot; );
3506   // Ptr is never Null
3507   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3508 
3509   assert(instance_id &lt;= 0 || xk, &quot;instances are always exactly typed&quot;);
3510   if (ptr == Constant) {
3511     // Note:  This case includes meta-object constants, such as methods.
3512     xk = true;
3513   } else if (k-&gt;is_loaded()) {
3514     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3515     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3516     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3517   }
3518 



3519   // Now hash this baby
3520   TypeInstPtr *result =
<span class="line-modified">3521     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
3522 
3523   return result;
3524 }
3525 
3526 /**
3527  *  Create constant type for a constant boxed value
3528  */
3529 const Type* TypeInstPtr::get_const_boxed_value() const {
3530   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3531   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3532   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3533   BasicType bt = constant.basic_type();
3534   switch (bt) {
3535     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3536     case T_INT:      return TypeInt::make(constant.as_int());
3537     case T_CHAR:     return TypeInt::make(constant.as_char());
3538     case T_BYTE:     return TypeInt::make(constant.as_byte());
3539     case T_SHORT:    return TypeInt::make(constant.as_short());
3540     case T_FLOAT:    return TypeF::make(constant.as_float());
3541     case T_DOUBLE:   return TypeD::make(constant.as_double());
3542     case T_LONG:     return TypeLong::make(constant.as_long());
3543     default:         break;
3544   }
3545   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3546   return NULL;
3547 }
3548 
3549 //------------------------------cast_to_ptr_type-------------------------------
3550 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3551   if( ptr == _ptr ) return this;
3552   // Reconstruct _sig info here since not a problem with later lazy
3553   // construction, _sig will show up on demand.
<span class="line-modified">3554   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, _inline_depth);</span>
3555 }
3556 
3557 
3558 //-----------------------------cast_to_exactness-------------------------------
3559 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3560   if( klass_is_exact == _klass_is_exact ) return this;
3561   if (!_klass-&gt;is_loaded())  return this;
3562   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3563   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3564   if( ik-&gt;is_interface() )              return this;  // cannot set xk
<span class="line-modified">3565   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);</span>
3566 }
3567 
3568 //-----------------------------cast_to_instance_id----------------------------
3569 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3570   if( instance_id == _instance_id ) return this;
<span class="line-modified">3571   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);</span>
3572 }
3573 
3574 //------------------------------xmeet_unloaded---------------------------------
3575 // Compute the MEET of two InstPtrs when at least one is unloaded.
3576 // Assume classes are different since called after check for same name/class-loader
3577 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
<span class="line-modified">3578     int off = meet_offset(tinst-&gt;offset());</span>
3579     PTR ptr = meet_ptr(tinst-&gt;ptr());
3580     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3581     const TypePtr* speculative = xmeet_speculative(tinst);
3582     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3583 
3584     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3585     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3586     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3587       //
3588       // Meet unloaded class with java/lang/Object
3589       //
3590       // Meet
3591       //          |                     Unloaded Class
3592       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3593       //  ===================================================================
3594       //   TOP    | ..........................Unloaded......................|
3595       //  AnyNull |  U-AN    |................Unloaded......................|
3596       // Constant | ... O-NN .................................. |   O-BOT   |
3597       //  NotNull | ... O-NN .................................. |   O-BOT   |
3598       //  BOTTOM  | ........................Object-BOTTOM ..................|
3599       //
3600       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3601       //
3602       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
<span class="line-modified">3603       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, instance_id, speculative, depth); }</span>
3604       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3605       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3606         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3607         else                                      { return TypeInstPtr::NOTNULL; }
3608       }
3609       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3610 
3611       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3612     }
3613 
3614     // Both are unloaded, not the same class, not Object
3615     // Or meet unloaded with a different loaded class, not java/lang/Object
3616     if( ptr != TypePtr::BotPTR ) {
3617       return TypeInstPtr::NOTNULL;
3618     }
3619     return TypeInstPtr::BOTTOM;
3620 }
3621 
3622 
3623 //------------------------------meet-------------------------------------------
</pre>
<hr />
<pre>
3636   case FloatBot:
3637   case DoubleTop:
3638   case DoubleCon:
3639   case DoubleBot:
3640   case NarrowOop:
3641   case NarrowKlass:
3642   case Bottom:                  // Ye Olde Default
3643     return Type::BOTTOM;
3644   case Top:
3645     return this;
3646 
3647   default:                      // All else is a mistake
3648     typerr(t);
3649 
3650   case MetadataPtr:
3651   case KlassPtr:
3652   case RawPtr: return TypePtr::BOTTOM;
3653 
3654   case AryPtr: {                // All arrays inherit from Object class
3655     const TypeAryPtr *tp = t-&gt;is_aryptr();
<span class="line-modified">3656     int offset = meet_offset(tp-&gt;offset());</span>
3657     PTR ptr = meet_ptr(tp-&gt;ptr());
3658     int instance_id = meet_instance_id(tp-&gt;instance_id());
3659     const TypePtr* speculative = xmeet_speculative(tp);
3660     int depth = meet_inline_depth(tp-&gt;inline_depth());
3661     switch (ptr) {
3662     case TopPTR:
3663     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3664       // For instances when a subclass meets a superclass we fall
3665       // below the centerline when the superclass is exact. We need to
3666       // do the same here.
<span class="line-modified">3667       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {</span>
<span class="line-modified">3668         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);</span>
3669       } else {
3670         // cannot subclass, so the meet has to fall badly below the centerline
3671         ptr = NotNull;
3672         instance_id = InstanceBot;
<span class="line-modified">3673         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);</span>
3674       }
3675     case Constant:
3676     case NotNull:
3677     case BotPTR:                // Fall down to object klass
3678       // LCA is object_klass, but if we subclass from the top we can do better
3679       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3680         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3681         // then we can subclass in the Java class hierarchy.
3682         // For instances when a subclass meets a superclass we fall
3683         // below the centerline when the superclass is exact. We need
3684         // to do the same here.
<span class="line-modified">3685         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {</span>
3686           // that is, tp&#39;s array type is a subtype of my klass
3687           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
<span class="line-modified">3688                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);</span>
3689         }
3690       }
3691       // The other case cannot happen, since I cannot be a subtype of an array.
3692       // The meet falls down to Object class below centerline.
3693       if( ptr == Constant )
3694          ptr = NotNull;
3695       instance_id = InstanceBot;
<span class="line-modified">3696       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);</span>
3697     default: typerr(t);
3698     }
3699   }
3700 
3701   case OopPtr: {                // Meeting to OopPtrs
3702     // Found a OopPtr type vs self-InstPtr type
3703     const TypeOopPtr *tp = t-&gt;is_oopptr();
<span class="line-modified">3704     int offset = meet_offset(tp-&gt;offset());</span>
3705     PTR ptr = meet_ptr(tp-&gt;ptr());
3706     switch (tp-&gt;ptr()) {
3707     case TopPTR:
3708     case AnyNull: {
3709       int instance_id = meet_instance_id(InstanceTop);
3710       const TypePtr* speculative = xmeet_speculative(tp);
3711       int depth = meet_inline_depth(tp-&gt;inline_depth());
3712       return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">3713                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);</span>
3714     }
3715     case NotNull:
3716     case BotPTR: {
3717       int instance_id = meet_instance_id(tp-&gt;instance_id());
3718       const TypePtr* speculative = xmeet_speculative(tp);
3719       int depth = meet_inline_depth(tp-&gt;inline_depth());
3720       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
3721     }
3722     default: typerr(t);
3723     }
3724   }
3725 
3726   case AnyPtr: {                // Meeting to AnyPtrs
3727     // Found an AnyPtr type vs self-InstPtr type
3728     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">3729     int offset = meet_offset(tp-&gt;offset());</span>
3730     PTR ptr = meet_ptr(tp-&gt;ptr());
3731     int instance_id = meet_instance_id(InstanceTop);
3732     const TypePtr* speculative = xmeet_speculative(tp);
3733     int depth = meet_inline_depth(tp-&gt;inline_depth());
3734     switch (tp-&gt;ptr()) {
3735     case Null:
3736       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3737       // else fall through to AnyNull
3738     case TopPTR:
3739     case AnyNull: {
3740       return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">3741                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);</span>
3742     }
3743     case NotNull:
3744     case BotPTR:
3745       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
3746     default: typerr(t);
3747     }
3748   }
3749 
3750   /*
3751                  A-top         }
3752                /   |   \       }  Tops
3753            B-top A-any C-top   }
3754               | /  |  \ |      }  Any-nulls
3755            B-any   |   C-any   }
3756               |    |    |
3757            B-con A-con C-con   } constants; not comparable across classes
3758               |    |    |
3759            B-not   |   C-not   }
3760               | \  |  / |      }  not-nulls
3761            B-bot A-not C-bot   }
3762                \   |   /       }  Bottoms
3763                  A-bot         }
3764   */
3765 
3766   case InstPtr: {                // Meeting 2 Oops?
3767     // Found an InstPtr sub-type vs self-InstPtr type
3768     const TypeInstPtr *tinst = t-&gt;is_instptr();
<span class="line-modified">3769     int off = meet_offset( tinst-&gt;offset() );</span>
3770     PTR ptr = meet_ptr( tinst-&gt;ptr() );
3771     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3772     const TypePtr* speculative = xmeet_speculative(tinst);
3773     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3774 
3775     // Check for easy case; klasses are equal (and perhaps not loaded!)
3776     // If we have constants, then we created oops so classes are loaded
3777     // and we can handle the constants further down.  This case handles
3778     // both-not-loaded or both-loaded classes
<span class="line-modified">3779     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact()) {</span>
<span class="line-modified">3780       return make(ptr, klass(), klass_is_exact(), NULL, off, instance_id, speculative, depth);</span>

3781     }
3782 
3783     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
3784     ciKlass* tinst_klass = tinst-&gt;klass();
3785     ciKlass* this_klass  = this-&gt;klass();
3786     bool tinst_xk = tinst-&gt;klass_is_exact();
3787     bool this_xk  = this-&gt;klass_is_exact();


3788     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
3789       // One of these classes has not been loaded
3790       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
3791 #ifndef PRODUCT
3792       if( PrintOpto &amp;&amp; Verbose ) {
3793         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
3794         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
3795         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
3796       }
3797 #endif
3798       return unloaded_meet;
3799     }
3800 
3801     // Handle mixing oops and interfaces first.
3802     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
3803                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
3804       ciKlass *tmp = tinst_klass; // Swap interface around
3805       tinst_klass = this_klass;
3806       this_klass = tmp;
3807       bool tmp2 = tinst_xk;
3808       tinst_xk = this_xk;
3809       this_xk = tmp2;



3810     }
3811     if (tinst_klass-&gt;is_interface() &amp;&amp;
3812         !(this_klass-&gt;is_interface() ||
3813           // Treat java/lang/Object as an honorary interface,
3814           // because we need a bottom for the interface hierarchy.
3815           this_klass == ciEnv::current()-&gt;Object_klass())) {
3816       // Oop meets interface!
3817 
3818       // See if the oop subtypes (implements) interface.
3819       ciKlass *k;
3820       bool xk;

3821       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3822         // Oop indeed subtypes.  Now keep oop or interface depending
3823         // on whether we are both above the centerline or either is
3824         // below the centerline.  If we are on the centerline
3825         // (e.g., Constant vs. AnyNull interface), use the constant.
3826         k  = below_centerline(ptr) ? tinst_klass : this_klass;
3827         // If we are keeping this_klass, keep its exactness too.
3828         xk = below_centerline(ptr) ? tinst_xk    : this_xk;

3829       } else {                  // Does not implement, fall to Object
3830         // Oop does not implement interface, so mixing falls to Object
3831         // just like the verifier does (if both are above the
3832         // centerline fall to interface)
3833         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
3834         xk = above_centerline(ptr) ? tinst_xk : false;

3835         // Watch out for Constant vs. AnyNull interface.
3836         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
3837         instance_id = InstanceBot;
3838       }
3839       ciObject* o = NULL;  // the Constant value, if any
3840       if (ptr == Constant) {
3841         // Find out which constant.
3842         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
3843       }
<span class="line-modified">3844       return make(ptr, k, xk, o, off, instance_id, speculative, depth);</span>
3845     }
3846 
3847     // Either oop vs oop or interface vs interface or interface vs Object
3848 
3849     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
3850     // If we split one up &amp; one down AND they subtype, take the down man.
3851     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3852     // If both are up and they subtype, take the subtype class.
3853     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3854     // If both are down and they subtype, take the supertype class.
3855     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3856     // Constants treated as down.
3857 
3858     // Now, reorder the above list; observe that both-down+subtype is also
3859     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
3860     // If we split one up &amp; one down AND they subtype, take the down man.
3861     // If both are up and they subtype, take the subtype class.
3862 
3863     // If both are down and they subtype, &quot;fall hard&quot;.
3864     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3865     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3866     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3867 
3868     // If a proper subtype is exact, and we return it, we return it exactly.
3869     // If a proper supertype is exact, there can be no subtyping relationship!
3870     // If both types are equal to the subtype, exactness is and-ed below the
3871     // centerline and or-ed above it.  (N.B. Constants are always exact.)
3872 
3873     // Check for subtyping:
3874     ciKlass *subtype = NULL;
3875     bool subtype_exact = false;
<span class="line-modified">3876     if( tinst_klass-&gt;equals(this_klass) ) {</span>

3877       subtype = this_klass;
3878       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
<span class="line-modified">3879     } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {</span>

3880       subtype = this_klass;     // Pick subtyping class
3881       subtype_exact = this_xk;
<span class="line-modified">3882     } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {</span>

3883       subtype = tinst_klass;    // Pick subtyping class
3884       subtype_exact = tinst_xk;

3885     }
3886 
<span class="line-modified">3887     if( subtype ) {</span>
<span class="line-modified">3888       if( above_centerline(ptr) ) { // both are up?</span>
3889         this_klass = tinst_klass = subtype;
3890         this_xk = tinst_xk = subtype_exact;
<span class="line-modified">3891       } else if( above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr) ) {</span>

3892         this_klass = tinst_klass; // tinst is down; keep down man
3893         this_xk = tinst_xk;
<span class="line-modified">3894       } else if( above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr) ) {</span>

3895         tinst_klass = this_klass; // this is down; keep down man
3896         tinst_xk = this_xk;

3897       } else {
3898         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA

3899       }
3900     }
3901 
3902     // Check for classes now being equal
3903     if (tinst_klass-&gt;equals(this_klass)) {
3904       // If the klasses are equal, the constants may still differ.  Fall to
3905       // NotNull if they do (neither constant is NULL; that is a special case
3906       // handled elsewhere).
3907       ciObject* o = NULL;             // Assume not constant when done
3908       ciObject* this_oop  = const_oop();
3909       ciObject* tinst_oop = tinst-&gt;const_oop();
3910       if( ptr == Constant ) {
3911         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
3912             this_oop-&gt;equals(tinst_oop) )
3913           o = this_oop;
3914         else if (above_centerline(this -&gt;_ptr))
3915           o = tinst_oop;
3916         else if (above_centerline(tinst -&gt;_ptr))
3917           o = this_oop;
3918         else
3919           ptr = NotNull;
3920       }
<span class="line-modified">3921       return make(ptr, this_klass, this_xk, o, off, instance_id, speculative, depth);</span>
3922     } // Else classes are not equal
3923 
3924     // Since klasses are different, we require a LCA in the Java
3925     // class hierarchy - which means we have to fall to at least NotNull.
3926     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
3927       ptr = NotNull;
3928 
3929     instance_id = InstanceBot;
3930 
3931     // Now we find the LCA of Java classes
3932     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
<span class="line-modified">3933     return make(ptr, k, false, NULL, off, instance_id, speculative, depth);</span>
3934   } // End of case InstPtr
3935 





















3936   } // End of switch
3937   return this;                  // Return the double constant
3938 }
3939 
3940 
3941 //------------------------java_mirror_type--------------------------------------
3942 ciType* TypeInstPtr::java_mirror_type() const {
3943   // must be a singleton type
3944   if( const_oop() == NULL )  return NULL;
3945 
3946   // must be of type java.lang.Class
3947   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
<span class="line-removed">3948 </span>
3949   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
3950 }
3951 
3952 
3953 //------------------------------xdual------------------------------------------
3954 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
3955 // inheritance mechanism.
3956 const Type *TypeInstPtr::xdual() const {
<span class="line-modified">3957   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
3958 }
3959 
3960 //------------------------------eq---------------------------------------------
3961 // Structural equality check for Type representations
3962 bool TypeInstPtr::eq( const Type *t ) const {
3963   const TypeInstPtr *p = t-&gt;is_instptr();
3964   return
3965     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;

3966     TypeOopPtr::eq(p);          // Check sub-type stuff
3967 }
3968 
3969 //------------------------------hash-------------------------------------------
3970 // Type-specific hashing function.
3971 int TypeInstPtr::hash(void) const {
<span class="line-modified">3972   int hash = java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash());</span>
3973   return hash;
3974 }
3975 
3976 //------------------------------dump2------------------------------------------
3977 // Dump oop Type
3978 #ifndef PRODUCT
3979 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3980   // Print the name of the klass.
3981   klass()-&gt;print_name_on(st);
3982 
3983   switch( _ptr ) {
3984   case Constant:
3985     // TO DO: Make CI print the hex address of the underlying oop.
3986     if (WizardMode || Verbose) {
3987       const_oop()-&gt;print_oop(st);
3988     }
3989   case BotPTR:
3990     if (!WizardMode &amp;&amp; !Verbose) {
3991       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3992       break;
3993     }
3994   case TopPTR:
3995   case AnyNull:
3996   case NotNull:
3997     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
3998     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3999     break;
4000   default:
4001     break;
4002   }
4003 
<span class="line-modified">4004   if( _offset ) {               // Dump offset, if any</span>
<span class="line-removed">4005     if( _offset == OffsetBot )      st-&gt;print(&quot;+any&quot;);</span>
<span class="line-removed">4006     else if( _offset == OffsetTop ) st-&gt;print(&quot;+unknown&quot;);</span>
<span class="line-removed">4007     else st-&gt;print(&quot;+%d&quot;, _offset);</span>
<span class="line-removed">4008   }</span>
4009 
4010   st-&gt;print(&quot; *&quot;);





4011   if (_instance_id == InstanceTop)
4012     st-&gt;print(&quot;,iid=top&quot;);
4013   else if (_instance_id != InstanceBot)
4014     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4015 
4016   dump_inline_depth(st);
4017   dump_speculative(st);
4018 }
4019 #endif
4020 
4021 //------------------------------add_offset-------------------------------------
4022 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
<span class="line-modified">4023   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),</span>
4024               _instance_id, add_offset_speculative(offset), _inline_depth);
4025 }
4026 
4027 const Type *TypeInstPtr::remove_speculative() const {
4028   if (_speculative == NULL) {
4029     return this;
4030   }
4031   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="line-modified">4032   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,</span>
4033               _instance_id, NULL, _inline_depth);
4034 }
4035 
4036 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4037   if (!UseInlineDepthForSpeculativeTypes) {
4038     return this;
4039   }
<span class="line-modified">4040   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);</span>
4041 }
4042 
4043 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4044   assert(is_known_instance(), &quot;should be known&quot;);
<span class="line-modified">4045   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);</span>




4046 }
4047 

4048 //=============================================================================
4049 // Convenience common pre-built types.
4050 const TypeAryPtr *TypeAryPtr::RANGE;
4051 const TypeAryPtr *TypeAryPtr::OOPS;
4052 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4053 const TypeAryPtr *TypeAryPtr::BYTES;
4054 const TypeAryPtr *TypeAryPtr::SHORTS;
4055 const TypeAryPtr *TypeAryPtr::CHARS;
4056 const TypeAryPtr *TypeAryPtr::INTS;
4057 const TypeAryPtr *TypeAryPtr::LONGS;
4058 const TypeAryPtr *TypeAryPtr::FLOATS;
4059 const TypeAryPtr *TypeAryPtr::DOUBLES;

4060 
4061 //------------------------------make-------------------------------------------
<span class="line-modified">4062 const TypeAryPtr *TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,</span>
4063                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4064   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4065          &quot;integral arrays must be pre-equipped with a class&quot;);
4066   if (!xk)  xk = ary-&gt;ary_must_be_exact();
4067   assert(instance_id &lt;= 0 || xk, &quot;instances are always exactly typed&quot;);
<span class="line-modified">4068   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();</span>
4069 }
4070 
4071 //------------------------------make-------------------------------------------
<span class="line-modified">4072 const TypeAryPtr *TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,</span>
4073                                    int instance_id, const TypePtr* speculative, int inline_depth,
4074                                    bool is_autobox_cache) {
4075   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4076          &quot;integral arrays must be pre-equipped with a class&quot;);
4077   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4078   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4079   assert(instance_id &lt;= 0 || xk, &quot;instances are always exactly typed&quot;);
<span class="line-modified">4080   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();</span>
4081 }
4082 
4083 //------------------------------cast_to_ptr_type-------------------------------
4084 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4085   if( ptr == _ptr ) return this;
<span class="line-modified">4086   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);</span>
4087 }
4088 
4089 
4090 //-----------------------------cast_to_exactness-------------------------------
4091 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4092   if( klass_is_exact == _klass_is_exact ) return this;
4093   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
<span class="line-modified">4094   return make(ptr(), const_oop(), _ary, klass(), klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);</span>






4095 }
4096 
4097 //-----------------------------cast_to_instance_id----------------------------
4098 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4099   if( instance_id == _instance_id ) return this;
<span class="line-modified">4100   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);</span>
4101 }
4102 
4103 
4104 //-----------------------------max_array_length-------------------------------
4105 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
4106 jint TypeAryPtr::max_array_length(BasicType etype) {
4107   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {
4108     if (etype == T_NARROWOOP) {
4109       etype = T_OBJECT;
4110     } else if (etype == T_ILLEGAL) { // bottom[]
4111       etype = T_BYTE; // will produce conservatively high value
4112     } else {
4113       fatal(&quot;not an element type: %s&quot;, type2name(etype));
4114     }
4115   }
4116   return arrayOopDesc::max_array_length(etype);
4117 }
4118 
4119 //-----------------------------narrow_size_type-------------------------------
4120 // Narrow the given size type to the index range for the given array base type.
</pre>
<hr />
<pre>
4136   if (hi &gt; max_hi) {
4137     hi = max_hi;
4138     if (size-&gt;is_con()) {
4139       lo = hi;
4140     }
4141     chg = true;
4142   }
4143   // Negative length arrays will produce weird intermediate dead fast-path code
4144   if (lo &gt; hi)
4145     return TypeInt::ZERO;
4146   if (!chg)
4147     return size;
4148   return TypeInt::make(lo, hi, Type::WidenMin);
4149 }
4150 
4151 //-------------------------------cast_to_size----------------------------------
4152 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4153   assert(new_size != NULL, &quot;&quot;);
4154   new_size = narrow_size_type(new_size);
4155   if (new_size == size())  return this;
<span class="line-modified">4156   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable());</span>
<span class="line-modified">4157   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);</span>


































4158 }
4159 
4160 //------------------------------cast_to_stable---------------------------------
4161 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4162   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4163     return this;
4164 
4165   const Type* elem = this-&gt;elem();
4166   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4167 
4168   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4169     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4170     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4171   }
4172 
<span class="line-modified">4173   const TypeAry* new_ary = TypeAry::make(elem, size(), stable);</span>
4174 
<span class="line-modified">4175   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);</span>
4176 }
4177 
4178 //-----------------------------stable_dimension--------------------------------
4179 int TypeAryPtr::stable_dimension() const {
4180   if (!is_stable())  return 0;
4181   int dim = 1;
4182   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4183   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4184     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4185   return dim;
4186 }
4187 
4188 //----------------------cast_to_autobox_cache-----------------------------------
4189 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4190   if (is_autobox_cache() == cache)  return this;
4191   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4192   if (etype == NULL)  return this;
4193   // The pointers in the autobox arrays are always non-null.
4194   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4195   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-modified">4196   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable());</span>
<span class="line-modified">4197   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth, cache);</span>
4198 }
4199 
4200 //------------------------------eq---------------------------------------------
4201 // Structural equality check for Type representations
4202 bool TypeAryPtr::eq( const Type *t ) const {
4203   const TypeAryPtr *p = t-&gt;is_aryptr();
4204   return
4205     _ary == p-&gt;_ary &amp;&amp;  // Check array
<span class="line-modified">4206     TypeOopPtr::eq(p);  // Check sub-parts</span>

4207 }
4208 
4209 //------------------------------hash-------------------------------------------
4210 // Type-specific hashing function.
4211 int TypeAryPtr::hash(void) const {
<span class="line-modified">4212   return (intptr_t)_ary + TypeOopPtr::hash();</span>
4213 }
4214 
4215 //------------------------------meet-------------------------------------------
4216 // Compute the MEET of two types.  It returns a new Type object.
4217 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4218   // Perform a fast test for common case; meeting the same types together.
4219   if( this == t ) return this;  // Meeting same type-rep?
4220   // Current &quot;this-&gt;_base&quot; is Pointer
4221   switch (t-&gt;base()) {          // switch on original type
4222 
4223   // Mixing ints &amp; oops happens when javac reuses local variables
4224   case Int:
4225   case Long:
4226   case FloatTop:
4227   case FloatCon:
4228   case FloatBot:
4229   case DoubleTop:
4230   case DoubleCon:
4231   case DoubleBot:
4232   case NarrowOop:
4233   case NarrowKlass:
4234   case Bottom:                  // Ye Olde Default
4235     return Type::BOTTOM;
4236   case Top:
4237     return this;
4238 
4239   default:                      // All else is a mistake
4240     typerr(t);
4241 
4242   case OopPtr: {                // Meeting to OopPtrs
4243     // Found a OopPtr type vs self-AryPtr type
4244     const TypeOopPtr *tp = t-&gt;is_oopptr();
<span class="line-modified">4245     int offset = meet_offset(tp-&gt;offset());</span>
4246     PTR ptr = meet_ptr(tp-&gt;ptr());
4247     int depth = meet_inline_depth(tp-&gt;inline_depth());
4248     const TypePtr* speculative = xmeet_speculative(tp);
4249     switch (tp-&gt;ptr()) {
4250     case TopPTR:
4251     case AnyNull: {
4252       int instance_id = meet_instance_id(InstanceTop);
4253       return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="line-modified">4254                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);</span>
4255     }
4256     case BotPTR:
4257     case NotNull: {
4258       int instance_id = meet_instance_id(tp-&gt;instance_id());
4259       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4260     }
4261     default: ShouldNotReachHere();
4262     }
4263   }
4264 
4265   case AnyPtr: {                // Meeting two AnyPtrs
4266     // Found an AnyPtr type vs self-AryPtr type
4267     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">4268     int offset = meet_offset(tp-&gt;offset());</span>
4269     PTR ptr = meet_ptr(tp-&gt;ptr());
4270     const TypePtr* speculative = xmeet_speculative(tp);
4271     int depth = meet_inline_depth(tp-&gt;inline_depth());
4272     switch (tp-&gt;ptr()) {
4273     case TopPTR:
4274       return this;
4275     case BotPTR:
4276     case NotNull:
4277       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4278     case Null:
4279       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4280       // else fall through to AnyNull
4281     case AnyNull: {
4282       int instance_id = meet_instance_id(InstanceTop);
4283       return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="line-modified">4284                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);</span>
4285     }
4286     default: ShouldNotReachHere();
4287     }
4288   }
4289 
4290   case MetadataPtr:
4291   case KlassPtr:
4292   case RawPtr: return TypePtr::BOTTOM;
4293 
4294   case AryPtr: {                // Meeting 2 references?
4295     const TypeAryPtr *tap = t-&gt;is_aryptr();
<span class="line-modified">4296     int off = meet_offset(tap-&gt;offset());</span>

4297     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4298     PTR ptr = meet_ptr(tap-&gt;ptr());
4299     int instance_id = meet_instance_id(tap-&gt;instance_id());
4300     const TypePtr* speculative = xmeet_speculative(tap);
4301     int depth = meet_inline_depth(tap-&gt;inline_depth());
4302     ciKlass* lazy_klass = NULL;
4303     if (tary-&gt;_elem-&gt;isa_int()) {
4304       // Integral array element types have irrelevant lattice relations.
4305       // It is the klass that determines array layout, not the element type.
4306       if (_klass == NULL)
4307         lazy_klass = tap-&gt;_klass;
4308       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4309         lazy_klass = _klass;
4310       } else {
4311         // Something like byte[int+] meets char[int+].
4312         // This must fall to bottom, not (int[-128..65535])[int+].
4313         instance_id = InstanceBot;
<span class="line-modified">4314         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);</span>
4315       }
4316     } else // Non integral arrays.
4317       // Must fall to bottom if exact klasses in upper lattice
4318       // are not equal or super klass is exact.
4319       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4320           // meet with top[] and bottom[] are processed further down:
<span class="line-modified">4321           tap-&gt;_klass != NULL  &amp;&amp; this-&gt;_klass != NULL   &amp;&amp;</span>
4322           // both are exact and not equal:
4323           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
<span class="line-modified">4324            // &#39;tap&#39;  is exact and super or unrelated:</span>
4325            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4326            // &#39;this&#39; is exact and super or unrelated:
4327            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4328       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
<span class="line-modified">4329         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);</span>












4330       }
<span class="line-removed">4331       return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);</span>
4332     }
4333 
4334     bool xk = false;
4335     switch (tap-&gt;ptr()) {
4336     case AnyNull:
4337     case TopPTR:
4338       // Compute new klass on demand, do not use tap-&gt;_klass
4339       if (below_centerline(this-&gt;_ptr)) {
4340         xk = this-&gt;_klass_is_exact;
4341       } else {
4342         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4343       }
<span class="line-modified">4344       return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);</span>
4345     case Constant: {
4346       ciObject* o = const_oop();
4347       if( _ptr == Constant ) {
4348         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4349           xk = (klass() == tap-&gt;klass());
4350           ptr = NotNull;
4351           o = NULL;
4352           instance_id = InstanceBot;
4353         } else {
4354           xk = true;
4355         }
4356       } else if(above_centerline(_ptr)) {
4357         o = tap-&gt;const_oop();
4358         xk = true;
4359       } else {
4360         // Only precise for identical arrays
4361         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4362       }
<span class="line-modified">4363       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, instance_id, speculative, depth);</span>
4364     }
4365     case NotNull:
4366     case BotPTR:
4367       // Compute new klass on demand, do not use tap-&gt;_klass
4368       if (above_centerline(this-&gt;_ptr))
4369             xk = tap-&gt;_klass_is_exact;
4370       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4371               (klass() == tap-&gt;klass()); // Only precise for identical arrays
<span class="line-modified">4372       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);</span>
4373     default: ShouldNotReachHere();
4374     }
4375   }
4376 
4377   // All arrays inherit from Object class
4378   case InstPtr: {
4379     const TypeInstPtr *tp = t-&gt;is_instptr();
<span class="line-modified">4380     int offset = meet_offset(tp-&gt;offset());</span>
4381     PTR ptr = meet_ptr(tp-&gt;ptr());
4382     int instance_id = meet_instance_id(tp-&gt;instance_id());
4383     const TypePtr* speculative = xmeet_speculative(tp);
4384     int depth = meet_inline_depth(tp-&gt;inline_depth());
4385     switch (ptr) {
4386     case TopPTR:
4387     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4388       // For instances when a subclass meets a superclass we fall
4389       // below the centerline when the superclass is exact. We need to
4390       // do the same here.
<span class="line-modified">4391       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {</span>
<span class="line-modified">4392         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);</span>
4393       } else {
4394         // cannot subclass, so the meet has to fall badly below the centerline
4395         ptr = NotNull;
4396         instance_id = InstanceBot;
<span class="line-modified">4397         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);</span>
4398       }
4399     case Constant:
4400     case NotNull:
4401     case BotPTR:                // Fall down to object klass
4402       // LCA is object_klass, but if we subclass from the top we can do better
4403       if (above_centerline(tp-&gt;ptr())) {
4404         // If &#39;tp&#39;  is above the centerline and it is Object class
4405         // then we can subclass in the Java class hierarchy.
4406         // For instances when a subclass meets a superclass we fall
4407         // below the centerline when the superclass is exact. We need
4408         // to do the same here.
<span class="line-modified">4409         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {</span>
4410           // that is, my array type is a subtype of &#39;tp&#39; klass
4411           return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="line-modified">4412                       _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);</span>
4413         }
4414       }
4415       // The other case cannot happen, since t cannot be a subtype of an array.
4416       // The meet falls down to Object class below centerline.
4417       if( ptr == Constant )
4418          ptr = NotNull;
4419       instance_id = InstanceBot;
<span class="line-modified">4420       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);</span>
4421     default: typerr(t);
4422     }
4423   }













4424   }
4425   return this;                  // Lint noise
4426 }
4427 
4428 //------------------------------xdual------------------------------------------
4429 // Dual: compute field-by-field dual
4430 const Type *TypeAryPtr::xdual() const {
<span class="line-modified">4431   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(),_klass, _klass_is_exact, dual_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());</span>









4432 }
4433 
4434 //----------------------interface_vs_oop---------------------------------------
4435 #ifdef ASSERT
4436 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4437   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4438   if (t_aryptr) {
4439     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4440   }
4441   return false;
4442 }
4443 #endif
4444 
4445 //------------------------------dump2------------------------------------------
4446 #ifndef PRODUCT
4447 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4448   _ary-&gt;dump2(d,depth,st);
4449   switch( _ptr ) {
4450   case Constant:
4451     const_oop()-&gt;print(st);
4452     break;
4453   case BotPTR:
4454     if (!WizardMode &amp;&amp; !Verbose) {
4455       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4456       break;
4457     }
4458   case TopPTR:
4459   case AnyNull:
4460   case NotNull:
4461     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4462     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4463     break;
4464   default:
4465     break;
4466   }
4467 
<span class="line-modified">4468   if( _offset != 0 ) {</span>





4469     int header_size = objArrayOopDesc::header_size() * wordSize;
<span class="line-modified">4470     if( _offset == OffsetTop )       st-&gt;print(&quot;+undefined&quot;);</span>
<span class="line-modified">4471     else if( _offset == OffsetBot )  st-&gt;print(&quot;+any&quot;);</span>
<span class="line-modified">4472     else if( _offset &lt; header_size ) st-&gt;print(&quot;+%d&quot;, _offset);</span>
4473     else {
4474       BasicType basic_elem_type = elem()-&gt;basic_type();
4475       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4476       int elem_size = type2aelembytes(basic_elem_type);
<span class="line-modified">4477       st-&gt;print(&quot;[%d]&quot;, (_offset - array_base)/elem_size);</span>
4478     }
4479   }
4480   st-&gt;print(&quot; *&quot;);
4481   if (_instance_id == InstanceTop)
4482     st-&gt;print(&quot;,iid=top&quot;);
4483   else if (_instance_id != InstanceBot)
4484     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4485 
4486   dump_inline_depth(st);
4487   dump_speculative(st);
4488 }
4489 #endif
4490 
4491 bool TypeAryPtr::empty(void) const {
4492   if (_ary-&gt;empty())       return true;
4493   return TypeOopPtr::empty();
4494 }
4495 
4496 //------------------------------add_offset-------------------------------------
4497 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
<span class="line-modified">4498   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);</span>
4499 }
4500 
4501 const Type *TypeAryPtr::remove_speculative() const {
4502   if (_speculative == NULL) {
4503     return this;
4504   }
4505   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="line-modified">4506   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, NULL, _inline_depth);</span>












4507 }
4508 
4509 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4510   if (!UseInlineDepthForSpeculativeTypes) {
4511     return this;
4512   }
<span class="line-modified">4513   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, _speculative, depth);</span>



















































4514 }
4515 
4516 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4517   assert(is_known_instance(), &quot;should be known&quot;);
<span class="line-modified">4518   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);</span>
4519 }
4520 
4521 //=============================================================================
4522 

4523 //------------------------------hash-------------------------------------------
4524 // Type-specific hashing function.
4525 int TypeNarrowPtr::hash(void) const {
4526   return _ptrtype-&gt;hash() + 7;
4527 }
4528 
4529 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
4530   return _ptrtype-&gt;singleton();
4531 }
4532 
4533 bool TypeNarrowPtr::empty(void) const {
4534   return _ptrtype-&gt;empty();
4535 }
4536 
4537 intptr_t TypeNarrowPtr::get_con() const {
4538   return _ptrtype-&gt;get_con();
4539 }
4540 
4541 bool TypeNarrowPtr::eq( const Type *t ) const {
4542   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
</pre>
<hr />
<pre>
4591   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
4592   switch (t-&gt;base()) {          // switch on original type
4593 
4594   case Int:                     // Mixing ints &amp; oops happens when javac
4595   case Long:                    // reuses local variables
4596   case FloatTop:
4597   case FloatCon:
4598   case FloatBot:
4599   case DoubleTop:
4600   case DoubleCon:
4601   case DoubleBot:
4602   case AnyPtr:
4603   case RawPtr:
4604   case OopPtr:
4605   case InstPtr:
4606   case AryPtr:
4607   case MetadataPtr:
4608   case KlassPtr:
4609   case NarrowOop:
4610   case NarrowKlass:
<span class="line-removed">4611 </span>
4612   case Bottom:                  // Ye Olde Default
4613     return Type::BOTTOM;
4614   case Top:
4615     return this;
4616 



4617   default:                      // All else is a mistake
4618     typerr(t);
4619 
4620   } // End of switch
4621 
4622   return this;
4623 }
4624 
4625 #ifndef PRODUCT
4626 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4627   _ptrtype-&gt;dump2(d, depth, st);
4628 }
4629 #endif
4630 
4631 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
4632 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
4633 
4634 
4635 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
4636   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
</pre>
<hr />
<pre>
4675     return (one == two) &amp;&amp; TypePtr::eq(t);
4676   } else {
4677     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
4678   }
4679 }
4680 
4681 //------------------------------hash-------------------------------------------
4682 // Type-specific hashing function.
4683 int TypeMetadataPtr::hash(void) const {
4684   return
4685     (metadata() ? metadata()-&gt;hash() : 0) +
4686     TypePtr::hash();
4687 }
4688 
4689 //------------------------------singleton--------------------------------------
4690 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4691 // constants
4692 bool TypeMetadataPtr::singleton(void) const {
4693   // detune optimizer to not generate constant metadata + constant offset as a constant!
4694   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">4695   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);</span>
4696 }
4697 
4698 //------------------------------add_offset-------------------------------------
4699 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
4700   return make( _ptr, _metadata, xadd_offset(offset));
4701 }
4702 
4703 //-----------------------------filter------------------------------------------
4704 // Do not allow interface-vs.-noninterface joins to collapse to top.
4705 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
4706   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
4707   if (ft == NULL || ft-&gt;empty())
4708     return Type::TOP;           // Canonical empty value
4709   return ft;
4710 }
4711 
4712  //------------------------------get_con----------------------------------------
4713 intptr_t TypeMetadataPtr::get_con() const {
4714   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-modified">4715   assert( _offset &gt;= 0, &quot;&quot; );</span>
4716 
<span class="line-modified">4717   if (_offset != 0) {</span>
4718     // After being ported to the compiler interface, the compiler no longer
4719     // directly manipulates the addresses of oops.  Rather, it only has a pointer
4720     // to a handle at compile time.  This handle is embedded in the generated
4721     // code and dereferenced at the time the nmethod is made.  Until that time,
4722     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
4723     // have access to the addresses!).  This does not seem to currently happen,
4724     // but this assertion here is to help prevent its occurence.
4725     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
4726     ShouldNotReachHere();
4727   }
4728 
4729   return (intptr_t)metadata()-&gt;constant_encoding();
4730 }
4731 
4732 //------------------------------cast_to_ptr_type-------------------------------
4733 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
4734   if( ptr == _ptr ) return this;
4735   return make(ptr, metadata(), _offset);
4736 }
4737 
</pre>
<hr />
<pre>
4748   case Long:                    // reuses local variables
4749   case FloatTop:
4750   case FloatCon:
4751   case FloatBot:
4752   case DoubleTop:
4753   case DoubleCon:
4754   case DoubleBot:
4755   case NarrowOop:
4756   case NarrowKlass:
4757   case Bottom:                  // Ye Olde Default
4758     return Type::BOTTOM;
4759   case Top:
4760     return this;
4761 
4762   default:                      // All else is a mistake
4763     typerr(t);
4764 
4765   case AnyPtr: {
4766     // Found an AnyPtr type vs self-OopPtr type
4767     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">4768     int offset = meet_offset(tp-&gt;offset());</span>
4769     PTR ptr = meet_ptr(tp-&gt;ptr());
4770     switch (tp-&gt;ptr()) {
4771     case Null:
4772       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4773       // else fall through:
4774     case TopPTR:
4775     case AnyNull: {
4776       return make(ptr, _metadata, offset);
4777     }
4778     case BotPTR:
4779     case NotNull:
4780       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4781     default: typerr(t);
4782     }
4783   }
4784 
4785   case RawPtr:
4786   case KlassPtr:
4787   case OopPtr:
4788   case InstPtr:
4789   case AryPtr:
4790     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
4791 
4792   case MetadataPtr: {
4793     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
<span class="line-modified">4794     int offset = meet_offset(tp-&gt;offset());</span>
4795     PTR tptr = tp-&gt;ptr();
4796     PTR ptr = meet_ptr(tptr);
4797     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
4798     if (tptr == TopPTR || _ptr == TopPTR ||
4799         metadata()-&gt;equals(tp-&gt;metadata())) {
4800       return make(ptr, md, offset);
4801     }
4802     // metadata is different
4803     if( ptr == Constant ) {  // Cannot be equal constants, so...
4804       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
4805       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
4806       ptr = NotNull;            // Fall down in lattice
4807     }
4808     return make(ptr, NULL, offset);
4809     break;
4810   }
4811   } // End of switch
4812   return this;                  // Return the double constant
4813 }
4814 
4815 
4816 //------------------------------xdual------------------------------------------
4817 // Dual of a pure metadata pointer.
4818 const Type *TypeMetadataPtr::xdual() const {
4819   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
4820 }
4821 
4822 //------------------------------dump2------------------------------------------
4823 #ifndef PRODUCT
4824 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4825   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
4826   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
<span class="line-modified">4827   switch( _offset ) {</span>
4828   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
4829   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
4830   case         0: break;
<span class="line-modified">4831   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;</span>
4832   }
4833 }
4834 #endif
4835 
4836 
4837 //=============================================================================
4838 // Convenience common pre-built type.
4839 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
4840 
<span class="line-modified">4841 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset):</span>
4842   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
4843 }
4844 
4845 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
<span class="line-modified">4846   return make(Constant, m, 0);</span>
4847 }
4848 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
<span class="line-modified">4849   return make(Constant, m, 0);</span>
4850 }
4851 
4852 //------------------------------make-------------------------------------------
4853 // Create a meta data constant
<span class="line-modified">4854 const TypeMetadataPtr *TypeMetadataPtr::make(PTR ptr, ciMetadata* m, int offset) {</span>
4855   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
4856   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
4857 }
4858 
4859 
4860 //=============================================================================
4861 // Convenience common pre-built types.
4862 
4863 // Not-null object klass or below
4864 const TypeKlassPtr *TypeKlassPtr::OBJECT;
4865 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
4866 
4867 //------------------------------TypeKlassPtr-----------------------------------
<span class="line-modified">4868 TypeKlassPtr::TypeKlassPtr( PTR ptr, ciKlass* klass, int offset )</span>
<span class="line-modified">4869   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant) {</span>


4870 }
4871 
4872 //------------------------------make-------------------------------------------
4873 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
<span class="line-modified">4874 const TypeKlassPtr *TypeKlassPtr::make( PTR ptr, ciKlass* k, int offset ) {</span>
<span class="line-modified">4875   assert( k != NULL, &quot;Expect a non-NULL klass&quot;);</span>
<span class="line-modified">4876   assert(k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);</span>
<span class="line-modified">4877   TypeKlassPtr *r =</span>
<span class="line-modified">4878     (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset))-&gt;hashcons();</span>
<span class="line-removed">4879 </span>
<span class="line-removed">4880   return r;</span>
4881 }
4882 
4883 //------------------------------eq---------------------------------------------
4884 // Structural equality check for Type representations
4885 bool TypeKlassPtr::eq( const Type *t ) const {
4886   const TypeKlassPtr *p = t-&gt;is_klassptr();
<span class="line-modified">4887   return</span>
<span class="line-removed">4888     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;</span>
<span class="line-removed">4889     TypePtr::eq(p);</span>
4890 }
4891 
4892 //------------------------------hash-------------------------------------------
4893 // Type-specific hashing function.
4894 int TypeKlassPtr::hash(void) const {
<span class="line-modified">4895   return java_add((jint)klass()-&gt;hash(), (jint)TypePtr::hash());</span>
4896 }
4897 
4898 //------------------------------singleton--------------------------------------
4899 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4900 // constants
4901 bool TypeKlassPtr::singleton(void) const {
4902   // detune optimizer to not generate constant klass + constant offset as a constant!
4903   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">4904   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);</span>
4905 }
4906 
4907 // Do not allow interface-vs.-noninterface joins to collapse to top.
4908 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
4909   // logic here mirrors the one from TypeOopPtr::filter. See comments
4910   // there.
4911   const Type* ft = join_helper(kills, include_speculative);
4912   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
4913   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
4914 
4915   if (ft-&gt;empty()) {
<span class="line-modified">4916     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;klass()-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())</span>
4917       return kills;             // Uplift to interface
4918 
4919     return Type::TOP;           // Canonical empty value
4920   }
4921 
4922   // Interface klass type could be exact in opposite to interface type,
4923   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
4924   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
4925       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
4926       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
4927       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
4928     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
4929   }
4930 
4931   return ft;
4932 }
4933 
4934 //----------------------compute_klass------------------------------------------
4935 // Compute the defining klass for this class
4936 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
4937   // Compute _klass based on element type.
4938   ciKlass* k_ary = NULL;
<span class="line-removed">4939   const TypeInstPtr *tinst;</span>
4940   const TypeAryPtr *tary;
4941   const Type* el = elem();
4942   if (el-&gt;isa_narrowoop()) {
4943     el = el-&gt;make_ptr();
4944   }
4945 
4946   // Get element klass
<span class="line-modified">4947   if ((tinst = el-&gt;isa_instptr()) != NULL) {</span>
<span class="line-modified">4948     // Compute array klass from element klass</span>
<span class="line-modified">4949     k_ary = ciObjArrayKlass::make(tinst-&gt;klass());</span>





4950   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
4951     // Compute array klass from element klass
4952     ciKlass* k_elem = tary-&gt;klass();
4953     // If element type is something like bottom[], k_elem will be null.
4954     if (k_elem != NULL)
4955       k_ary = ciObjArrayKlass::make(k_elem);
4956   } else if ((el-&gt;base() == Type::Top) ||
4957              (el-&gt;base() == Type::Bottom)) {
4958     // element type of Bottom occurs from meet of basic type
4959     // and object; Top occurs when doing join on Bottom.
4960     // Leave k_ary at NULL.
4961   } else {
4962     // Cannot compute array klass directly from basic type,
4963     // since subtypes of TypeInt all have basic type T_INT.
4964 #ifdef ASSERT
4965     if (verify &amp;&amp; el-&gt;isa_int()) {
4966       // Check simple cases when verifying klass.
4967       BasicType bt = T_ILLEGAL;
4968       if (el == TypeInt::BYTE) {
4969         bt = T_BYTE;
</pre>
<hr />
<pre>
4994 
4995   // Oops, need to compute _klass and cache it
4996   ciKlass* k_ary = compute_klass();
4997 
4998   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
4999     // The _klass field acts as a cache of the underlying
5000     // ciKlass for this array type.  In order to set the field,
5001     // we need to cast away const-ness.
5002     //
5003     // IMPORTANT NOTE: we *never* set the _klass field for the
5004     // type TypeAryPtr::OOPS.  This Type is shared between all
5005     // active compilations.  However, the ciKlass which represents
5006     // this Type is *not* shared between compilations, so caching
5007     // this value would result in fetching a dangling pointer.
5008     //
5009     // Recomputing the underlying ciKlass for each request is
5010     // a bit less efficient than caching, but calls to
5011     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5012     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5013     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
<span class="line-modified">5014         _offset != 0 &amp;&amp; _offset != arrayOopDesc::length_offset_in_bytes()) {</span>
5015       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5016     }
5017   }
5018   return k_ary;
5019 }
5020 
5021 
5022 //------------------------------add_offset-------------------------------------
5023 // Access internals of klass object
5024 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
<span class="line-modified">5025   return make( _ptr, klass(), xadd_offset(offset) );</span>
5026 }
5027 
5028 //------------------------------cast_to_ptr_type-------------------------------
5029 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5030   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5031   if( ptr == _ptr ) return this;
<span class="line-modified">5032   return make(ptr, _klass, _offset);</span>
5033 }
5034 
5035 
5036 //-----------------------------cast_to_exactness-------------------------------
5037 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5038   if( klass_is_exact == _klass_is_exact ) return this;
<span class="line-modified">5039   return make(klass_is_exact ? Constant : NotNull, _klass, _offset);</span>
5040 }
5041 
5042 
5043 //-----------------------------as_instance_type--------------------------------
5044 // Corresponding type for an instance of the given class.
5045 // It will be NotNull, and exact if and only if the klass type is exact.
5046 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5047   ciKlass* k = klass();

5048   bool    xk = klass_is_exact();
5049   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5050   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5051   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5052   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();



5053   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5054 }
5055 
5056 
5057 //------------------------------xmeet------------------------------------------
5058 // Compute the MEET of two types, return a new Type object.
5059 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5060   // Perform a fast test for common case; meeting the same types together.
5061   if( this == t ) return this;  // Meeting same type-rep?
5062 
5063   // Current &quot;this-&gt;_base&quot; is Pointer
5064   switch (t-&gt;base()) {          // switch on original type
5065 
5066   case Int:                     // Mixing ints &amp; oops happens when javac
5067   case Long:                    // reuses local variables
5068   case FloatTop:
5069   case FloatCon:
5070   case FloatBot:
5071   case DoubleTop:
5072   case DoubleCon:
5073   case DoubleBot:
5074   case NarrowOop:
5075   case NarrowKlass:
5076   case Bottom:                  // Ye Olde Default
5077     return Type::BOTTOM;
5078   case Top:
5079     return this;
5080 
5081   default:                      // All else is a mistake
5082     typerr(t);
5083 
5084   case AnyPtr: {                // Meeting to AnyPtrs
5085     // Found an AnyPtr type vs self-KlassPtr type
5086     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">5087     int offset = meet_offset(tp-&gt;offset());</span>
5088     PTR ptr = meet_ptr(tp-&gt;ptr());
5089     switch (tp-&gt;ptr()) {
5090     case TopPTR:
5091       return this;
5092     case Null:
5093       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5094     case AnyNull:
<span class="line-modified">5095       return make( ptr, klass(), offset );</span>
5096     case BotPTR:
5097     case NotNull:
5098       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5099     default: typerr(t);
5100     }
5101   }
5102 
5103   case RawPtr:
5104   case MetadataPtr:
5105   case OopPtr:
5106   case AryPtr:                  // Meet with AryPtr
5107   case InstPtr:                 // Meet with InstPtr
5108     return TypePtr::BOTTOM;
5109 
5110   //
5111   //             A-top         }
5112   //           /   |   \       }  Tops
5113   //       B-top A-any C-top   }
5114   //          | /  |  \ |      }  Any-nulls
5115   //       B-any   |   C-any   }
5116   //          |    |    |
5117   //       B-con A-con C-con   } constants; not comparable across classes
5118   //          |    |    |
5119   //       B-not   |   C-not   }
5120   //          | \  |  / |      }  not-nulls
5121   //       B-bot A-not C-bot   }
5122   //           \   |   /       }  Bottoms
5123   //             A-bot         }
5124   //
5125 
5126   case KlassPtr: {  // Meet two KlassPtr types
5127     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
<span class="line-modified">5128     int  off     = meet_offset(tkls-&gt;offset());</span>
5129     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5130 








5131     // Check for easy case; klasses are equal (and perhaps not loaded!)
5132     // If we have constants, then we created oops so classes are loaded
5133     // and we can handle the constants further down.  This case handles
5134     // not-loaded classes
<span class="line-modified">5135     if( ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) ) {</span>
<span class="line-modified">5136       return make( ptr, klass(), off );</span>
5137     }
5138 
5139     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5140     ciKlass* tkls_klass = tkls-&gt;klass();
5141     ciKlass* this_klass = this-&gt;klass();
5142     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5143     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);



5144 
5145     // If &#39;this&#39; type is above the centerline and is a superclass of the
5146     // other, we can treat &#39;this&#39; as having the same type as the other.
5147     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5148         tkls_klass-&gt;is_subtype_of(this_klass)) {
5149       this_klass = tkls_klass;
5150     }
5151     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5152     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5153     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5154         this_klass-&gt;is_subtype_of(tkls_klass)) {
5155       tkls_klass = this_klass;
5156     }
5157 
5158     // Check for classes now being equal
5159     if (tkls_klass-&gt;equals(this_klass)) {
5160       // If the klasses are equal, the constants may still differ.  Fall to
5161       // NotNull if they do (neither constant is NULL; that is a special case
5162       // handled elsewhere).
5163       if( ptr == Constant ) {
5164         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5165             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5166         else if (above_centerline(this-&gt;ptr()));
5167         else if (above_centerline(tkls-&gt;ptr()));
5168         else
5169           ptr = NotNull;
5170       }
<span class="line-modified">5171       return make( ptr, this_klass, off );</span>
5172     } // Else classes are not equal
5173 
5174     // Since klasses are different, we require the LCA in the Java
5175     // class hierarchy - which means we have to fall to at least NotNull.
5176     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5177       ptr = NotNull;
5178     // Now we find the LCA of Java classes
5179     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="line-modified">5180     return   make( ptr, k, off );</span>
5181   } // End of case KlassPtr
5182 
5183   } // End of switch
5184   return this;                  // Return the double constant
5185 }
5186 
5187 //------------------------------xdual------------------------------------------
5188 // Dual: compute field-by-field dual
5189 const Type    *TypeKlassPtr::xdual() const {
<span class="line-modified">5190   return new TypeKlassPtr( dual_ptr(), klass(), dual_offset() );</span>
5191 }
5192 
5193 //------------------------------get_con----------------------------------------
5194 intptr_t TypeKlassPtr::get_con() const {
5195   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-modified">5196   assert( _offset &gt;= 0, &quot;&quot; );</span>
5197 
<span class="line-modified">5198   if (_offset != 0) {</span>
5199     // After being ported to the compiler interface, the compiler no longer
5200     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5201     // to a handle at compile time.  This handle is embedded in the generated
5202     // code and dereferenced at the time the nmethod is made.  Until that time,
5203     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5204     // have access to the addresses!).  This does not seem to currently happen,
5205     // but this assertion here is to help prevent its occurence.
5206     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5207     ShouldNotReachHere();
5208   }
5209 
5210   return (intptr_t)klass()-&gt;constant_encoding();
5211 }
5212 //------------------------------dump2------------------------------------------
5213 // Dump Klass Type
5214 #ifndef PRODUCT
5215 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5216   switch( _ptr ) {
5217   case Constant:
5218     st-&gt;print(&quot;precise &quot;);
5219   case NotNull:
5220     {
<span class="line-modified">5221       const char *name = klass()-&gt;name()-&gt;as_utf8();</span>
<span class="line-modified">5222       if( name ) {</span>
5223         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5224       } else {
<span class="line-modified">5225         ShouldNotReachHere();</span>
5226       }
5227     }
5228   case BotPTR:
5229     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5230   case TopPTR:
5231   case AnyNull:
5232     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5233     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5234     break;
5235   default:
5236     break;
5237   }
5238 
<span class="line-modified">5239   if( _offset ) {               // Dump offset, if any</span>
<span class="line-removed">5240     if( _offset == OffsetBot )      { st-&gt;print(&quot;+any&quot;); }</span>
<span class="line-removed">5241     else if( _offset == OffsetTop ) { st-&gt;print(&quot;+unknown&quot;); }</span>
<span class="line-removed">5242     else                            { st-&gt;print(&quot;+%d&quot;, _offset); }</span>
<span class="line-removed">5243   }</span>
5244 
5245   st-&gt;print(&quot; *&quot;);
5246 }
5247 #endif
5248 
5249 
5250 
5251 //=============================================================================
5252 // Convenience common pre-built types.
5253 
5254 //------------------------------make-------------------------------------------
<span class="line-modified">5255 const TypeFunc *TypeFunc::make( const TypeTuple *domain, const TypeTuple *range ) {</span>
<span class="line-modified">5256   return (TypeFunc*)(new TypeFunc(domain,range))-&gt;hashcons();</span>












5257 }
5258 
5259 //------------------------------make-------------------------------------------
<span class="line-modified">5260 const TypeFunc *TypeFunc::make(ciMethod* method) {</span>
5261   Compile* C = Compile::current();
<span class="line-modified">5262   const TypeFunc* tf = C-&gt;last_tf(method); // check cache</span>
<span class="line-modified">5263   if (tf != NULL)  return tf;  // The hit rate here is almost 50%.</span>
<span class="line-modified">5264   const TypeTuple *domain;</span>
<span class="line-modified">5265   if (method-&gt;is_static()) {</span>
<span class="line-modified">5266     domain = TypeTuple::make_domain(NULL, method-&gt;signature());</span>
<span class="line-modified">5267   } else {</span>
<span class="line-modified">5268     domain = TypeTuple::make_domain(method-&gt;holder(), method-&gt;signature());</span>













5269   }
<span class="line-removed">5270   const TypeTuple *range  = TypeTuple::make_range(method-&gt;signature());</span>
<span class="line-removed">5271   tf = TypeFunc::make(domain, range);</span>
<span class="line-removed">5272   C-&gt;set_last_tf(method, tf);  // fill cache</span>
5273   return tf;
5274 }
5275 
5276 //------------------------------meet-------------------------------------------
5277 // Compute the MEET of two types.  It returns a new Type object.
5278 const Type *TypeFunc::xmeet( const Type *t ) const {
5279   // Perform a fast test for common case; meeting the same types together.
5280   if( this == t ) return this;  // Meeting same type-rep?
5281 
5282   // Current &quot;this-&gt;_base&quot; is Func
5283   switch (t-&gt;base()) {          // switch on original type
5284 
5285   case Bottom:                  // Ye Olde Default
5286     return t;
5287 
5288   default:                      // All else is a mistake
5289     typerr(t);
5290 
5291   case Top:
5292     break;
5293   }
5294   return this;                  // Return the double constant
5295 }
5296 
5297 //------------------------------xdual------------------------------------------
5298 // Dual: compute field-by-field dual
5299 const Type *TypeFunc::xdual() const {
5300   return this;
5301 }
5302 
5303 //------------------------------eq---------------------------------------------
5304 // Structural equality check for Type representations
5305 bool TypeFunc::eq( const Type *t ) const {
5306   const TypeFunc *a = (const TypeFunc*)t;
<span class="line-modified">5307   return _domain == a-&gt;_domain &amp;&amp;</span>
<span class="line-modified">5308     _range == a-&gt;_range;</span>


5309 }
5310 
5311 //------------------------------hash-------------------------------------------
5312 // Type-specific hashing function.
5313 int TypeFunc::hash(void) const {
<span class="line-modified">5314   return (intptr_t)_domain + (intptr_t)_range;</span>
5315 }
5316 
5317 //------------------------------dump2------------------------------------------
5318 // Dump Function Type
5319 #ifndef PRODUCT
5320 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
<span class="line-modified">5321   if( _range-&gt;cnt() &lt;= Parms )</span>
5322     st-&gt;print(&quot;void&quot;);
5323   else {
5324     uint i;
<span class="line-modified">5325     for (i = Parms; i &lt; _range-&gt;cnt()-1; i++) {</span>
<span class="line-modified">5326       _range-&gt;field_at(i)-&gt;dump2(d,depth,st);</span>
5327       st-&gt;print(&quot;/&quot;);
5328     }
<span class="line-modified">5329     _range-&gt;field_at(i)-&gt;dump2(d,depth,st);</span>
5330   }
5331   st-&gt;print(&quot; &quot;);
5332   st-&gt;print(&quot;( &quot;);
5333   if( !depth || d[this] ) {     // Check for recursive dump
5334     st-&gt;print(&quot;...)&quot;);
5335     return;
5336   }
5337   d.Insert((void*)this,(void*)this);    // Stop recursion
<span class="line-modified">5338   if (Parms &lt; _domain-&gt;cnt())</span>
<span class="line-modified">5339     _domain-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);</span>
<span class="line-modified">5340   for (uint i = Parms+1; i &lt; _domain-&gt;cnt(); i++) {</span>
5341     st-&gt;print(&quot;, &quot;);
<span class="line-modified">5342     _domain-&gt;field_at(i)-&gt;dump2(d,depth-1,st);</span>
5343   }
5344   st-&gt;print(&quot; )&quot;);
5345 }
5346 #endif
5347 
5348 //------------------------------singleton--------------------------------------
5349 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5350 // constants (Ldi nodes).  Singletons are integer, float or double constants
5351 // or a single symbol.
5352 bool TypeFunc::singleton(void) const {
5353   return false;                 // Never a singleton
5354 }
5355 
5356 bool TypeFunc::empty(void) const {
5357   return false;                 // Never empty
5358 }
5359 
5360 
5361 BasicType TypeFunc::return_type() const{
<span class="line-modified">5362   if (range()-&gt;cnt() == TypeFunc::Parms) {</span>
5363     return T_VOID;
5364   }
<span class="line-modified">5365   return range()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();</span>
5366 }
</pre>
</td>
<td>
<hr />
<pre>
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
<span class="line-added">  26 #include &quot;ci/ciFlatArrayKlass.hpp&quot;</span>
<span class="line-added">  27 #include &quot;ci/ciField.hpp&quot;</span>
<span class="line-added">  28 #include &quot;ci/ciInlineKlass.hpp&quot;</span>
  29 #include &quot;ci/ciMethodData.hpp&quot;
  30 #include &quot;ci/ciTypeFlow.hpp&quot;
  31 #include &quot;classfile/javaClasses.hpp&quot;
  32 #include &quot;classfile/symbolTable.hpp&quot;
  33 #include &quot;compiler/compileLog.hpp&quot;
  34 #include &quot;libadt/dict.hpp&quot;
  35 #include &quot;memory/oopFactory.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/instanceKlass.hpp&quot;
  38 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/typeArrayKlass.hpp&quot;
  41 #include &quot;opto/matcher.hpp&quot;
  42 #include &quot;opto/node.hpp&quot;
  43 #include &quot;opto/opcodes.hpp&quot;
  44 #include &quot;opto/type.hpp&quot;
  45 #include &quot;utilities/powerOfTwo.hpp&quot;
  46 
  47 // Portions of code courtesy of Clifford Click
  48 
  49 // Optimization - Graph Style
  50 
  51 // Dictionary of types shared among compilations.
  52 Dict* Type::_shared_type_dict = NULL;
<span class="line-added">  53 const Type::Offset Type::Offset::top(Type::OffsetTop);</span>
<span class="line-added">  54 const Type::Offset Type::Offset::bottom(Type::OffsetBot);</span>
<span class="line-added">  55 </span>
<span class="line-added">  56 const Type::Offset Type::Offset::meet(const Type::Offset other) const {</span>
<span class="line-added">  57   // Either is &#39;TOP&#39; offset?  Return the other offset!</span>
<span class="line-added">  58   int offset = other._offset;</span>
<span class="line-added">  59   if (_offset == OffsetTop) return Offset(offset);</span>
<span class="line-added">  60   if (offset == OffsetTop) return Offset(_offset);</span>
<span class="line-added">  61   // If either is different, return &#39;BOTTOM&#39; offset</span>
<span class="line-added">  62   if (_offset != offset) return bottom;</span>
<span class="line-added">  63   return Offset(_offset);</span>
<span class="line-added">  64 }</span>
<span class="line-added">  65 </span>
<span class="line-added">  66 const Type::Offset Type::Offset::dual() const {</span>
<span class="line-added">  67   if (_offset == OffsetTop) return bottom;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;</span>
<span class="line-added">  68   if (_offset == OffsetBot) return top;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;</span>
<span class="line-added">  69   return Offset(_offset);               // Map everything else into self</span>
<span class="line-added">  70 }</span>
<span class="line-added">  71 </span>
<span class="line-added">  72 const Type::Offset Type::Offset::add(intptr_t offset) const {</span>
<span class="line-added">  73   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!</span>
<span class="line-added">  74   if (_offset == OffsetTop || offset == OffsetTop) return top;</span>
<span class="line-added">  75   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!</span>
<span class="line-added">  76   if (_offset == OffsetBot || offset == OffsetBot) return bottom;</span>
<span class="line-added">  77   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!</span>
<span class="line-added">  78   offset += (intptr_t)_offset;</span>
<span class="line-added">  79   if (offset != (int)offset || offset == OffsetTop) return bottom;</span>
<span class="line-added">  80 </span>
<span class="line-added">  81   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );</span>
<span class="line-added">  82   // It is possible to construct a negative offset during PhaseCCP</span>
<span class="line-added">  83 </span>
<span class="line-added">  84   return Offset((int)offset);        // Sum valid offsets</span>
<span class="line-added">  85 }</span>
<span class="line-added">  86 </span>
<span class="line-added">  87 void Type::Offset::dump2(outputStream *st) const {</span>
<span class="line-added">  88   if (_offset == 0) {</span>
<span class="line-added">  89     return;</span>
<span class="line-added">  90   } else if (_offset == OffsetTop) {</span>
<span class="line-added">  91     st-&gt;print(&quot;+top&quot;);</span>
<span class="line-added">  92   }</span>
<span class="line-added">  93   else if (_offset == OffsetBot) {</span>
<span class="line-added">  94     st-&gt;print(&quot;+bot&quot;);</span>
<span class="line-added">  95   } else if (_offset) {</span>
<span class="line-added">  96     st-&gt;print(&quot;+%d&quot;, _offset);</span>
<span class="line-added">  97   }</span>
<span class="line-added">  98 }</span>
  99 
 100 // Array which maps compiler types to Basic Types
 101 const Type::TypeInfo Type::_type_info[Type::lastype] = {
 102   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
 103   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
 104   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
 105   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
 106   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
 107   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
 108   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
 109   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
 110   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
 111   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
 112 
 113 #if defined(PPC64)
 114   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 115   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 116   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 117   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 118   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 119 #elif defined(S390)
 120   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 121   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 122   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
 123   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 124   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 125 #else // all other
 126   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
 127   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
 128   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 129   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
 130   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
 131 #endif
<span class="line-added"> 132   { Bad,             T_INLINE_TYPE, &quot;inline:&quot;,      false, Node::NotAMachineReg, relocInfo::none          },  // InlineType</span>
 133   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
 134   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
 135   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
 136   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
 137   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
 138   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
 139   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
 140   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
 141   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
 142   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
 143   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
 144   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 145   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 146   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 147   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 148   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 149   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 150   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 151 };
 152 
</pre>
<hr />
<pre>
 243   case ciTypeFlow::StateVector::T_NULL:
 244     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 245     return TypePtr::NULL_PTR;
 246 
 247   case ciTypeFlow::StateVector::T_LONG2:
 248     // The ciTypeFlow pass pushes a long, then the half.
 249     // We do the same.
 250     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 251     return TypeInt::TOP;
 252 
 253   case ciTypeFlow::StateVector::T_DOUBLE2:
 254     // The ciTypeFlow pass pushes double, then the half.
 255     // Our convention is the same.
 256     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 257     return Type::TOP;
 258 
 259   case T_ADDRESS:
 260     assert(type-&gt;is_return_address(), &quot;&quot;);
 261     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 262 
<span class="line-added"> 263   case T_INLINE_TYPE: {</span>
<span class="line-added"> 264     ciInlineKlass* vk = type-&gt;as_inline_klass();</span>
<span class="line-added"> 265     if (vk-&gt;is_scalarizable()) {</span>
<span class="line-added"> 266       return TypeInlineType::make(vk);</span>
<span class="line-added"> 267     } else {</span>
<span class="line-added"> 268       return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="line-added"> 269     }</span>
<span class="line-added"> 270   }</span>
<span class="line-added"> 271 </span>
 272   default:
 273     // make sure we did not mix up the cases:
 274     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 275     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 276     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 277     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 278     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 279     assert(!type-&gt;is_return_address(), &quot;&quot;);
 280 
 281     return Type::get_const_type(type);
 282   }
 283 }
 284 
 285 
 286 //-----------------------make_from_constant------------------------------------
 287 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 288                                      int stable_dimension, bool is_narrow_oop,
 289                                      bool is_autobox_cache) {
 290   switch (constant.basic_type()) {
 291     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 292     case T_CHAR:     return TypeInt::make(constant.as_char());
 293     case T_BYTE:     return TypeInt::make(constant.as_byte());
 294     case T_SHORT:    return TypeInt::make(constant.as_short());
 295     case T_INT:      return TypeInt::make(constant.as_int());
 296     case T_LONG:     return TypeLong::make(constant.as_long());
 297     case T_FLOAT:    return TypeF::make(constant.as_float());
 298     case T_DOUBLE:   return TypeD::make(constant.as_double());
 299     case T_ARRAY:
<span class="line-added"> 300     case T_INLINE_TYPE:</span>
 301     case T_OBJECT: {
 302         const Type* con_type = NULL;
 303         ciObject* oop_constant = constant.as_object();
 304         if (oop_constant-&gt;is_null_object()) {
 305           con_type = Type::get_zero_type(T_OBJECT);
 306         } else {
 307           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 308           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 309           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 310             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 311           }
 312           if (stable_dimension &gt; 0) {
 313             assert(FoldStableValues, &quot;sanity&quot;);
 314             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 315             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 316           }
 317         }
 318         if (is_narrow_oop) {
 319           con_type = con_type-&gt;make_narrowoop();
 320         }
 321         return con_type;
 322       }
 323     case T_ILLEGAL:
 324       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 325       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 326       return NULL;
 327     default:
 328       // Fall through to failure
 329       return NULL;
 330   }
 331 }
 332 
 333 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 334   BasicType conbt = con.basic_type();
 335   switch (conbt) {
 336     case T_BOOLEAN: conbt = T_BYTE;   break;
 337     case T_ARRAY:   conbt = T_OBJECT; break;
<span class="line-added"> 338     case T_INLINE_TYPE: conbt = T_OBJECT; break;</span>
 339     default:                          break;
 340   }
 341   switch (loadbt) {
 342     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 343     case T_NARROWOOP: loadbt = T_OBJECT; break;
 344     case T_ARRAY:     loadbt = T_OBJECT; break;
<span class="line-added"> 345     case T_INLINE_TYPE: loadbt = T_OBJECT; break;</span>
 346     case T_ADDRESS:   loadbt = T_OBJECT; break;
 347     default:                             break;
 348   }
 349   if (conbt == loadbt) {
 350     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 351       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 352       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 353     } else {
 354       return con;
 355     }
 356   }
 357   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 358     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 359     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 360   }
 361   return ciConstant(); // T_ILLEGAL
 362 }
 363 
 364 // Try to constant-fold a stable array element.
 365 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
</pre>
<hr />
<pre>
 553   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 554   ffalse[0] = Type::CONTROL;
 555   ffalse[1] = Type::TOP;
 556   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 557 
 558   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 559   fneither[0] = Type::TOP;
 560   fneither[1] = Type::TOP;
 561   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 562 
 563   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 564   ftrue[0] = Type::TOP;
 565   ftrue[1] = Type::CONTROL;
 566   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 567 
 568   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 569   floop[0] = Type::CONTROL;
 570   floop[1] = TypeInt::INT;
 571   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 572 
<span class="line-modified"> 573   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, Offset(0));</span>
<span class="line-modified"> 574   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, Offset::bottom);</span>
<span class="line-modified"> 575   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, Offset::bottom);</span>
 576 
 577   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 578   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 579 
 580   const Type **fmembar = TypeTuple::fields(0);
 581   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 582 
 583   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 584   fsc[0] = TypeInt::CC;
 585   fsc[1] = Type::MEMORY;
 586   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 587 
 588   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 589   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 590   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 591   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified"> 592                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()));</span>
 593   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified"> 594                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()));</span>
<span class="line-modified"> 595   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);</span>
<span class="line-added"> 596 </span>
<span class="line-added"> 597   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);</span>
 598 
<span class="line-modified"> 599   TypeInlineType::BOTTOM = TypeInlineType::make(NULL);</span>
 600 
 601   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 602   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 603 
 604   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 605 
 606   mreg2type[Op_Node] = Type::BOTTOM;
 607   mreg2type[Op_Set ] = 0;
 608   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 609   mreg2type[Op_RegI] = TypeInt::INT;
 610   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 611   mreg2type[Op_RegF] = Type::FLOAT;
 612   mreg2type[Op_RegD] = Type::DOUBLE;
 613   mreg2type[Op_RegL] = TypeLong::LONG;
 614   mreg2type[Op_RegFlags] = TypeInt::CC;
 615 
<span class="line-modified"> 616   TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, Offset(arrayOopDesc::length_offset_in_bytes()));</span>
 617 
<span class="line-modified"> 618   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);</span>
 619 
 620 #ifdef _LP64
 621   if (UseCompressedOops) {
 622     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 623     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 624   } else
 625 #endif
 626   {
 627     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
<span class="line-modified"> 628     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);</span>
 629   }
<span class="line-modified"> 630   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);</span>
<span class="line-modified"> 631   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);</span>
<span class="line-modified"> 632   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);</span>
<span class="line-modified"> 633   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);</span>
<span class="line-modified"> 634   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);</span>
<span class="line-modified"> 635   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);</span>
<span class="line-modified"> 636   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);</span>
<span class="line-added"> 637   TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInlineType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);</span>
 638 
 639   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 640   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 641   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
<span class="line-added"> 642   TypeAryPtr::_array_body_type[T_INLINE_TYPE] = TypeAryPtr::OOPS;</span>
 643   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 644   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 645   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 646   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 647   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 648   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 649   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 650   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 651   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 652 
<span class="line-modified"> 653   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0));</span>
<span class="line-modified"> 654   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0));</span>
 655 
 656   const Type **fi2c = TypeTuple::fields(2);
 657   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 658   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 659   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 660 
 661   const Type **intpair = TypeTuple::fields(2);
 662   intpair[0] = TypeInt::INT;
 663   intpair[1] = TypeInt::INT;
 664   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 665 
 666   const Type **longpair = TypeTuple::fields(2);
 667   longpair[0] = TypeLong::LONG;
 668   longpair[1] = TypeLong::LONG;
 669   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 670 
 671   const Type **intccpair = TypeTuple::fields(2);
 672   intccpair[0] = TypeInt::INT;
 673   intccpair[1] = TypeInt::CC;
 674   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 675 
 676   const Type **longccpair = TypeTuple::fields(2);
 677   longccpair[0] = TypeLong::LONG;
 678   longccpair[1] = TypeInt::CC;
 679   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 680 
 681   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 682   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 683   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 684   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 685   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 686   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 687   _const_basic_type[T_INT]         = TypeInt::INT;
 688   _const_basic_type[T_LONG]        = TypeLong::LONG;
 689   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 690   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 691   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 692   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
<span class="line-added"> 693   _const_basic_type[T_INLINE_TYPE] = TypeInstPtr::BOTTOM;</span>
 694   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 695   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 696   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 697 
 698   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 699   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 700   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 701   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 702   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 703   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 704   _zero_type[T_INT]         = TypeInt::ZERO;
 705   _zero_type[T_LONG]        = TypeLong::ZERO;
 706   _zero_type[T_FLOAT]       = TypeF::ZERO;
 707   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 708   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 709   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
<span class="line-added"> 710   _zero_type[T_INLINE_TYPE] = TypePtr::NULL_PTR;</span>
 711   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 712   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 713 
 714   // get_zero_type() should not happen for T_CONFLICT
 715   _zero_type[T_CONFLICT]= NULL;
 716 
 717   // Vector predefined types, it needs initialized _const_basic_type[].
 718   if (Matcher::vector_size_supported(T_BYTE,4)) {
 719     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 720   }
 721   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 722     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 723   }
 724   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 725     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 726   }
 727   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 728     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 729   }
 730   if (Matcher::vector_size_supported(T_FLOAT,16)) {
</pre>
<hr />
<pre>
 866   }
 867   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 868     return true;
 869   }
 870   return false;
 871 }
 872 
 873 #endif
 874 
 875 void Type::check_symmetrical(const Type *t, const Type *mt) const {
 876 #ifdef ASSERT
 877   assert(mt == t-&gt;xmeet(this), &quot;meet not commutative&quot;);
 878   const Type* dual_join = mt-&gt;_dual;
 879   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 880   const Type *t2this = dual_join-&gt;xmeet(this-&gt;_dual);
 881 
 882   // Interface meet Oop is Not Symmetric:
 883   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 884   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 885 
<span class="line-modified"> 886   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual)) {</span>
 887     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 888     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 889     tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();
 890     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 891 
 892     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 893     tty-&gt;print(&quot;this_dual=              &quot;);          _dual-&gt;dump(); tty-&gt;cr();
 894     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 895 
 896     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 897     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 898 
 899     fatal(&quot;meet not symmetric&quot; );
 900   }
 901 #endif
 902 }
 903 
 904 //------------------------------meet-------------------------------------------
 905 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 906 // commutative and the lattice is symmetric.
</pre>
<hr />
<pre>
 970 
 971   case OopPtr:
 972     return t-&gt;xmeet(this);
 973 
 974   case InstPtr:
 975     return t-&gt;xmeet(this);
 976 
 977   case MetadataPtr:
 978   case KlassPtr:
 979     return t-&gt;xmeet(this);
 980 
 981   case AryPtr:
 982     return t-&gt;xmeet(this);
 983 
 984   case NarrowOop:
 985     return t-&gt;xmeet(this);
 986 
 987   case NarrowKlass:
 988     return t-&gt;xmeet(this);
 989 
<span class="line-added"> 990   case InlineType:</span>
<span class="line-added"> 991     return t-&gt;xmeet(this);</span>
<span class="line-added"> 992 </span>
 993   case Bad:                     // Type check
 994   default:                      // Bogus type not in lattice
 995     typerr(t);
 996     return Type::BOTTOM;
 997 
 998   case Bottom:                  // Ye Olde Default
 999     return t;
1000 
1001   case FloatTop:
1002     if( _base == FloatTop ) return this;
1003   case FloatBot:                // Float
1004     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
1005     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
1006     typerr(t);
1007     return Type::BOTTOM;
1008 
1009   case DoubleTop:
1010     if( _base == DoubleTop ) return this;
1011   case DoubleBot:               // Double
1012     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
</pre>
<hr />
<pre>
1040 
1041 //------------------------------xdual------------------------------------------
1042 // Compute dual right now.
1043 const Type::TYPES Type::dual_type[Type::lastype] = {
1044   Bad,          // Bad
1045   Control,      // Control
1046   Bottom,       // Top
1047   Bad,          // Int - handled in v-call
1048   Bad,          // Long - handled in v-call
1049   Half,         // Half
1050   Bad,          // NarrowOop - handled in v-call
1051   Bad,          // NarrowKlass - handled in v-call
1052 
1053   Bad,          // Tuple - handled in v-call
1054   Bad,          // Array - handled in v-call
1055   Bad,          // VectorS - handled in v-call
1056   Bad,          // VectorD - handled in v-call
1057   Bad,          // VectorX - handled in v-call
1058   Bad,          // VectorY - handled in v-call
1059   Bad,          // VectorZ - handled in v-call
<span class="line-added">1060   Bad,          // InlineType - handled in v-call</span>
1061 
1062   Bad,          // AnyPtr - handled in v-call
1063   Bad,          // RawPtr - handled in v-call
1064   Bad,          // OopPtr - handled in v-call
1065   Bad,          // InstPtr - handled in v-call
1066   Bad,          // AryPtr - handled in v-call
1067 
1068   Bad,          //  MetadataPtr - handled in v-call
1069   Bad,          // KlassPtr - handled in v-call
1070 
1071   Bad,          // Function - handled in v-call
1072   Abio,         // Abio
1073   Return_Address,// Return_Address
1074   Memory,       // Memory
1075   FloatBot,     // FloatTop
1076   FloatCon,     // FloatCon
1077   FloatTop,     // FloatBot
1078   DoubleBot,    // DoubleTop
1079   DoubleCon,    // DoubleCon
1080   DoubleTop,    // DoubleBot
</pre>
<hr />
<pre>
1936 
1937 bool TypeLong::empty(void) const {
1938   return _lo &gt; _hi;
1939 }
1940 
1941 //=============================================================================
1942 // Convenience common pre-built types.
1943 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1944 const TypeTuple *TypeTuple::IFFALSE;
1945 const TypeTuple *TypeTuple::IFTRUE;
1946 const TypeTuple *TypeTuple::IFNEITHER;
1947 const TypeTuple *TypeTuple::LOOPBODY;
1948 const TypeTuple *TypeTuple::MEMBAR;
1949 const TypeTuple *TypeTuple::STORECONDITIONAL;
1950 const TypeTuple *TypeTuple::START_I2C;
1951 const TypeTuple *TypeTuple::INT_PAIR;
1952 const TypeTuple *TypeTuple::LONG_PAIR;
1953 const TypeTuple *TypeTuple::INT_CC_PAIR;
1954 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1955 
<span class="line-added">1956 static void collect_inline_fields(ciInlineKlass* vk, const Type** field_array, uint&amp; pos, ExtendedSignature&amp; sig_cc) {</span>
<span class="line-added">1957   for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {</span>
<span class="line-added">1958     ciField* field = vk-&gt;nonstatic_field_at(j);</span>
<span class="line-added">1959     BasicType bt = field-&gt;type()-&gt;basic_type();</span>
<span class="line-added">1960     const Type* ft = Type::get_const_type(field-&gt;type());</span>
<span class="line-added">1961     field_array[pos++] = ft;</span>
<span class="line-added">1962     if (type2size[bt] == 2) {</span>
<span class="line-added">1963       field_array[pos++] = Type::HALF;</span>
<span class="line-added">1964     }</span>
<span class="line-added">1965     // Skip reserved arguments</span>
<span class="line-added">1966     while (SigEntry::next_is_reserved(sig_cc, bt)) {</span>
<span class="line-added">1967       field_array[pos++] = Type::get_const_basic_type(bt);</span>
<span class="line-added">1968       if (type2size[bt] == 2) {</span>
<span class="line-added">1969         field_array[pos++] = Type::HALF;</span>
<span class="line-added">1970       }</span>
<span class="line-added">1971     }</span>
<span class="line-added">1972   }</span>
<span class="line-added">1973 }</span>
1974 
1975 //------------------------------make-------------------------------------------
1976 // Make a TypeTuple from the range of a method signature
<span class="line-modified">1977 const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {</span>
1978   ciType* return_type = sig-&gt;return_type();
1979   uint arg_cnt = return_type-&gt;size();
<span class="line-added">1980   if (ret_vt_fields) {</span>
<span class="line-added">1981     arg_cnt = return_type-&gt;as_inline_klass()-&gt;inline_arg_slots() + 1;</span>
<span class="line-added">1982   }</span>
<span class="line-added">1983 </span>
1984   const Type **field_array = fields(arg_cnt);
1985   switch (return_type-&gt;basic_type()) {
1986   case T_LONG:
1987     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1988     field_array[TypeFunc::Parms+1] = Type::HALF;
1989     break;
1990   case T_DOUBLE:
1991     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1992     field_array[TypeFunc::Parms+1] = Type::HALF;
1993     break;
1994   case T_OBJECT:
1995   case T_ARRAY:
1996   case T_BOOLEAN:
1997   case T_CHAR:
1998   case T_FLOAT:
1999   case T_BYTE:
2000   case T_SHORT:
2001   case T_INT:
2002     field_array[TypeFunc::Parms] = get_const_type(return_type);
2003     break;
<span class="line-added">2004   case T_INLINE_TYPE:</span>
<span class="line-added">2005     if (ret_vt_fields) {</span>
<span class="line-added">2006       uint pos = TypeFunc::Parms;</span>
<span class="line-added">2007       field_array[pos] = TypePtr::BOTTOM;</span>
<span class="line-added">2008       pos++;</span>
<span class="line-added">2009       ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());</span>
<span class="line-added">2010       collect_inline_fields(return_type-&gt;as_inline_klass(), field_array, pos, sig);</span>
<span class="line-added">2011     } else {</span>
<span class="line-added">2012       field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="line-added">2013     }</span>
<span class="line-added">2014     break;</span>
2015   case T_VOID:
2016     break;
2017   default:
2018     ShouldNotReachHere();
2019   }
2020   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2021 }
2022 
2023 // Make a TypeTuple from the domain of a method signature
<span class="line-modified">2024 const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {</span>
<span class="line-modified">2025   ciSignature* sig = method-&gt;signature();</span>
<span class="line-added">2026   ExtendedSignature sig_cc = ExtendedSignature(vt_fields_as_args ? method-&gt;get_sig_cc() : NULL, SigEntryFilter());</span>
<span class="line-added">2027 </span>
<span class="line-added">2028   uint arg_cnt = sig-&gt;size() + (method-&gt;is_static() ? 0 : 1);</span>
<span class="line-added">2029   if (vt_fields_as_args) {</span>
<span class="line-added">2030     for (arg_cnt = 0; !sig_cc.at_end(); ++sig_cc) {</span>
<span class="line-added">2031       arg_cnt += type2size[(*sig_cc)._bt];</span>
<span class="line-added">2032     }</span>
<span class="line-added">2033     sig_cc = ExtendedSignature(method-&gt;get_sig_cc(), SigEntryFilter());</span>
<span class="line-added">2034   }</span>
2035 
2036   uint pos = TypeFunc::Parms;
<span class="line-modified">2037   const Type** field_array = fields(arg_cnt);</span>
<span class="line-modified">2038   if (!method-&gt;is_static()) {</span>
<span class="line-modified">2039     ciInstanceKlass* recv = method-&gt;holder();</span>
<span class="line-modified">2040     if (vt_fields_as_args &amp;&amp; recv-&gt;is_inlinetype() &amp;&amp; recv-&gt;as_inline_klass()-&gt;can_be_passed_as_fields()) {</span>
<span class="line-modified">2041       collect_inline_fields(recv-&gt;as_inline_klass(), field_array, pos, sig_cc);</span>
<span class="line-modified">2042     } else {</span>
<span class="line-modified">2043       field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="line-modified">2044       if (vt_fields_as_args) {</span>
<span class="line-added">2045         ++sig_cc;</span>
<span class="line-added">2046       }</span>
<span class="line-added">2047     }</span>
2048   }
2049 
2050   int i = 0;
2051   while (pos &lt; TypeFunc::Parms + arg_cnt) {
2052     ciType* type = sig-&gt;type_at(i);
<span class="line-added">2053     BasicType bt = type-&gt;basic_type();</span>
<span class="line-added">2054     bool is_flattened = false;</span>
2055 
<span class="line-modified">2056     switch (bt) {</span>
2057     case T_LONG:
2058       field_array[pos++] = TypeLong::LONG;
2059       field_array[pos++] = Type::HALF;
2060       break;
2061     case T_DOUBLE:
2062       field_array[pos++] = Type::DOUBLE;
2063       field_array[pos++] = Type::HALF;
2064       break;
2065     case T_OBJECT:
2066     case T_ARRAY:
2067     case T_FLOAT:
2068     case T_INT:
2069       field_array[pos++] = get_const_type(type);
2070       break;
2071     case T_BOOLEAN:
2072     case T_CHAR:
2073     case T_BYTE:
2074     case T_SHORT:
2075       field_array[pos++] = TypeInt::INT;
2076       break;
<span class="line-added">2077     case T_INLINE_TYPE: {</span>
<span class="line-added">2078       if (vt_fields_as_args &amp;&amp; type-&gt;as_inline_klass()-&gt;can_be_passed_as_fields()) {</span>
<span class="line-added">2079         is_flattened = true;</span>
<span class="line-added">2080         collect_inline_fields(type-&gt;as_inline_klass(), field_array, pos, sig_cc);</span>
<span class="line-added">2081       } else {</span>
<span class="line-added">2082         field_array[pos++] = get_const_type(type)-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="line-added">2083       }</span>
<span class="line-added">2084       break;</span>
<span class="line-added">2085     }</span>
2086     default:
2087       ShouldNotReachHere();
2088     }
<span class="line-added">2089     // Skip reserved arguments</span>
<span class="line-added">2090     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {</span>
<span class="line-added">2091       field_array[pos++] = Type::get_const_basic_type(bt);</span>
<span class="line-added">2092       if (type2size[bt] == 2) {</span>
<span class="line-added">2093         field_array[pos++] = Type::HALF;</span>
<span class="line-added">2094       }</span>
<span class="line-added">2095     }</span>
2096     i++;
2097   }
<span class="line-added">2098   assert(pos == TypeFunc::Parms + arg_cnt, &quot;wrong number of arguments&quot;);</span>
2099 
2100   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2101 }
2102 
2103 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
2104   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
2105 }
2106 
2107 //------------------------------fields-----------------------------------------
2108 // Subroutine call type with space allocated for argument types
2109 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
2110 const Type **TypeTuple::fields( uint arg_cnt ) {
2111   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
2112   flds[TypeFunc::Control  ] = Type::CONTROL;
2113   flds[TypeFunc::I_O      ] = Type::ABIO;
2114   flds[TypeFunc::Memory   ] = Type::MEMORY;
2115   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
2116   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
2117 
2118   return flds;
</pre>
<hr />
<pre>
2213     if (_fields[i]-&gt;empty())  return true;
2214   }
2215   return false;
2216 }
2217 
2218 //=============================================================================
2219 // Convenience common pre-built types.
2220 
2221 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2222   // Certain normalizations keep us sane when comparing types.
2223   // We do not want arrayOop variables to differ only by the wideness
2224   // of their index types.  Pick minimum wideness, since that is the
2225   // forced wideness of small ranges anyway.
2226   if (size-&gt;_widen != Type::WidenMin)
2227     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2228   else
2229     return size;
2230 }
2231 
2232 //------------------------------make-------------------------------------------
<span class="line-modified">2233 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable,</span>
<span class="line-added">2234                              bool not_flat, bool not_null_free) {</span>
2235   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2236     elem = elem-&gt;make_narrowoop();
2237   }
2238   size = normalize_array_size(size);
<span class="line-modified">2239   return (TypeAry*)(new TypeAry(elem, size, stable, not_flat, not_null_free))-&gt;hashcons();</span>
2240 }
2241 
2242 //------------------------------meet-------------------------------------------
2243 // Compute the MEET of two types.  It returns a new Type object.
2244 const Type *TypeAry::xmeet( const Type *t ) const {
2245   // Perform a fast test for common case; meeting the same types together.
2246   if( this == t ) return this;  // Meeting same type-rep?
2247 
2248   // Current &quot;this-&gt;_base&quot; is Ary
2249   switch (t-&gt;base()) {          // switch on original type
2250 
2251   case Bottom:                  // Ye Olde Default
2252     return t;
2253 
2254   default:                      // All else is a mistake
2255     typerr(t);
2256 
2257   case Array: {                 // Meeting 2 arrays?
2258     const TypeAry *a = t-&gt;is_ary();
2259     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2260                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
<span class="line-modified">2261                          _stable &amp;&amp; a-&gt;_stable,</span>
<span class="line-added">2262                          _not_flat &amp;&amp; a-&gt;_not_flat,</span>
<span class="line-added">2263                          _not_null_free &amp;&amp; a-&gt;_not_null_free);</span>
2264   }
2265   case Top:
2266     break;
2267   }
2268   return this;                  // Return the double constant
2269 }
2270 
2271 //------------------------------xdual------------------------------------------
2272 // Dual: compute field-by-field dual
2273 const Type *TypeAry::xdual() const {
2274   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2275   size_dual = normalize_array_size(size_dual);
<span class="line-modified">2276   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable, !_not_flat, !_not_null_free);</span>
2277 }
2278 
2279 //------------------------------eq---------------------------------------------
2280 // Structural equality check for Type representations
2281 bool TypeAry::eq( const Type *t ) const {
2282   const TypeAry *a = (const TypeAry*)t;
2283   return _elem == a-&gt;_elem &amp;&amp;
2284     _stable == a-&gt;_stable &amp;&amp;
<span class="line-modified">2285     _size == a-&gt;_size &amp;&amp;</span>
<span class="line-added">2286     _not_flat == a-&gt;_not_flat &amp;&amp;</span>
<span class="line-added">2287     _not_null_free == a-&gt;_not_null_free;</span>
<span class="line-added">2288 </span>
2289 }
2290 
2291 //------------------------------hash-------------------------------------------
2292 // Type-specific hashing function.
2293 int TypeAry::hash(void) const {
2294   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2295 }
2296 
2297 /**
2298  * Return same type without a speculative part in the element
2299  */
2300 const Type* TypeAry::remove_speculative() const {
<span class="line-modified">2301   return make(_elem-&gt;remove_speculative(), _size, _stable, _not_flat, _not_null_free);</span>
2302 }
2303 
2304 /**
2305  * Return same type with cleaned up speculative part of element
2306  */
2307 const Type* TypeAry::cleanup_speculative() const {
<span class="line-modified">2308   return make(_elem-&gt;cleanup_speculative(), _size, _stable, _not_flat, _not_null_free);</span>
2309 }
2310 
2311 /**
2312  * Return same type but with a different inline depth (used for speculation)
2313  *
2314  * @param depth  depth to meet with
2315  */
2316 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2317   if (!UseInlineDepthForSpeculativeTypes) {
2318     return this;
2319   }
2320   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2321 }
2322 
2323 //----------------------interface_vs_oop---------------------------------------
2324 #ifdef ASSERT
2325 bool TypeAry::interface_vs_oop(const Type *t) const {
2326   const TypeAry* t_ary = t-&gt;is_ary();
2327   if (t_ary) {
2328     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2329     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2330     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2331       return this_ptr-&gt;interface_vs_oop(t_ptr);
2332     }
2333   }
2334   return false;
2335 }
2336 #endif
2337 
2338 //------------------------------dump2------------------------------------------
2339 #ifndef PRODUCT
2340 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2341   if (_stable)  st-&gt;print(&quot;stable:&quot;);
<span class="line-added">2342   if (Verbose) {</span>
<span class="line-added">2343     if (_not_flat) st-&gt;print(&quot;not flat:&quot;);</span>
<span class="line-added">2344     if (_not_null_free) st-&gt;print(&quot;not null free:&quot;);</span>
<span class="line-added">2345   }</span>
2346   _elem-&gt;dump2(d, depth, st);
2347   st-&gt;print(&quot;[&quot;);
2348   _size-&gt;dump2(d, depth, st);
2349   st-&gt;print(&quot;]&quot;);
2350 }
2351 #endif
2352 
2353 //------------------------------singleton--------------------------------------
2354 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2355 // constants (Ldi nodes).  Singletons are integer, float or double constants
2356 // or a single symbol.
2357 bool TypeAry::singleton(void) const {
2358   return false;                 // Never a singleton
2359 }
2360 
2361 bool TypeAry::empty(void) const {
2362   return _elem-&gt;empty() || _size-&gt;empty();
2363 }
2364 
2365 //--------------------------ary_must_be_exact----------------------------------
</pre>
<hr />
<pre>
2379   ciKlass* tklass = toop-&gt;klass();
2380   if (tklass == NULL)       return false;  // unloaded class
2381   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2382   const TypeInstPtr* tinst;
2383   if (_elem-&gt;isa_narrowoop())
2384     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2385   else
2386     tinst = _elem-&gt;isa_instptr();
2387   if (tinst)
2388     return tklass-&gt;as_instance_klass()-&gt;is_final();
2389   const TypeAryPtr*  tap;
2390   if (_elem-&gt;isa_narrowoop())
2391     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2392   else
2393     tap = _elem-&gt;isa_aryptr();
2394   if (tap)
2395     return tap-&gt;ary()-&gt;ary_must_be_exact();
2396   return false;
2397 }
2398 
<span class="line-added">2399 //==============================TypeInlineType=======================================</span>
<span class="line-added">2400 </span>
<span class="line-added">2401 const TypeInlineType* TypeInlineType::BOTTOM;</span>
<span class="line-added">2402 </span>
<span class="line-added">2403 //------------------------------make-------------------------------------------</span>
<span class="line-added">2404 const TypeInlineType* TypeInlineType::make(ciInlineKlass* vk, bool larval) {</span>
<span class="line-added">2405   return (TypeInlineType*)(new TypeInlineType(vk, larval))-&gt;hashcons();</span>
<span class="line-added">2406 }</span>
<span class="line-added">2407 </span>
<span class="line-added">2408 //------------------------------meet-------------------------------------------</span>
<span class="line-added">2409 // Compute the MEET of two types.  It returns a new Type object.</span>
<span class="line-added">2410 const Type* TypeInlineType::xmeet(const Type* t) const {</span>
<span class="line-added">2411   // Perform a fast test for common case; meeting the same types together.</span>
<span class="line-added">2412   if(this == t) return this;  // Meeting same type-rep?</span>
<span class="line-added">2413 </span>
<span class="line-added">2414   // Current &quot;this-&gt;_base&quot; is InlineType</span>
<span class="line-added">2415   switch (t-&gt;base()) {          // switch on original type</span>
<span class="line-added">2416 </span>
<span class="line-added">2417   case Int:</span>
<span class="line-added">2418   case Long:</span>
<span class="line-added">2419   case FloatTop:</span>
<span class="line-added">2420   case FloatCon:</span>
<span class="line-added">2421   case FloatBot:</span>
<span class="line-added">2422   case DoubleTop:</span>
<span class="line-added">2423   case DoubleCon:</span>
<span class="line-added">2424   case DoubleBot:</span>
<span class="line-added">2425   case NarrowKlass:</span>
<span class="line-added">2426   case Bottom:</span>
<span class="line-added">2427     return Type::BOTTOM;</span>
<span class="line-added">2428 </span>
<span class="line-added">2429   case OopPtr:</span>
<span class="line-added">2430   case MetadataPtr:</span>
<span class="line-added">2431   case KlassPtr:</span>
<span class="line-added">2432   case RawPtr:</span>
<span class="line-added">2433     return TypePtr::BOTTOM;</span>
<span class="line-added">2434 </span>
<span class="line-added">2435   case Top:</span>
<span class="line-added">2436     return this;</span>
<span class="line-added">2437 </span>
<span class="line-added">2438   case NarrowOop: {</span>
<span class="line-added">2439     const Type* res = t-&gt;make_ptr()-&gt;xmeet(this);</span>
<span class="line-added">2440     if (res-&gt;isa_ptr()) {</span>
<span class="line-added">2441       return res-&gt;make_narrowoop();</span>
<span class="line-added">2442     }</span>
<span class="line-added">2443     return res;</span>
<span class="line-added">2444   }</span>
<span class="line-added">2445 </span>
<span class="line-added">2446   case AryPtr:</span>
<span class="line-added">2447   case InstPtr: {</span>
<span class="line-added">2448     return t-&gt;xmeet(this);</span>
<span class="line-added">2449   }</span>
<span class="line-added">2450 </span>
<span class="line-added">2451   case InlineType: {</span>
<span class="line-added">2452     // All inline types inherit from Object</span>
<span class="line-added">2453     const TypeInlineType* other = t-&gt;is_inlinetype();</span>
<span class="line-added">2454     if (_vk == NULL) {</span>
<span class="line-added">2455       return this;</span>
<span class="line-added">2456     } else if (other-&gt;_vk == NULL) {</span>
<span class="line-added">2457       return other;</span>
<span class="line-added">2458     } else if (_vk == other-&gt;_vk) {</span>
<span class="line-added">2459       if (_larval == other-&gt;_larval ||</span>
<span class="line-added">2460           !_larval) {</span>
<span class="line-added">2461         return this;</span>
<span class="line-added">2462       } else {</span>
<span class="line-added">2463         return t;</span>
<span class="line-added">2464       }</span>
<span class="line-added">2465     }</span>
<span class="line-added">2466     return TypeInstPtr::NOTNULL;</span>
<span class="line-added">2467   }</span>
<span class="line-added">2468 </span>
<span class="line-added">2469   default:                      // All else is a mistake</span>
<span class="line-added">2470     typerr(t);</span>
<span class="line-added">2471 </span>
<span class="line-added">2472   }</span>
<span class="line-added">2473   return this;</span>
<span class="line-added">2474 }</span>
<span class="line-added">2475 </span>
<span class="line-added">2476 //------------------------------xdual------------------------------------------</span>
<span class="line-added">2477 const Type* TypeInlineType::xdual() const {</span>
<span class="line-added">2478   return this;</span>
<span class="line-added">2479 }</span>
<span class="line-added">2480 </span>
<span class="line-added">2481 //------------------------------eq---------------------------------------------</span>
<span class="line-added">2482 // Structural equality check for Type representations</span>
<span class="line-added">2483 bool TypeInlineType::eq(const Type* t) const {</span>
<span class="line-added">2484   const TypeInlineType* vt = t-&gt;is_inlinetype();</span>
<span class="line-added">2485   return (_vk == vt-&gt;inline_klass() &amp;&amp; _larval == vt-&gt;larval());</span>
<span class="line-added">2486 }</span>
<span class="line-added">2487 </span>
<span class="line-added">2488 //------------------------------hash-------------------------------------------</span>
<span class="line-added">2489 // Type-specific hashing function.</span>
<span class="line-added">2490 int TypeInlineType::hash(void) const {</span>
<span class="line-added">2491   return (intptr_t)_vk;</span>
<span class="line-added">2492 }</span>
<span class="line-added">2493 </span>
<span class="line-added">2494 //------------------------------singleton--------------------------------------</span>
<span class="line-added">2495 // TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.</span>
<span class="line-added">2496 bool TypeInlineType::singleton(void) const {</span>
<span class="line-added">2497   return false;</span>
<span class="line-added">2498 }</span>
<span class="line-added">2499 </span>
<span class="line-added">2500 //------------------------------empty------------------------------------------</span>
<span class="line-added">2501 // TRUE if Type is a type with no values, FALSE otherwise.</span>
<span class="line-added">2502 bool TypeInlineType::empty(void) const {</span>
<span class="line-added">2503   return false;</span>
<span class="line-added">2504 }</span>
<span class="line-added">2505 </span>
<span class="line-added">2506 //------------------------------dump2------------------------------------------</span>
<span class="line-added">2507 #ifndef PRODUCT</span>
<span class="line-added">2508 void TypeInlineType::dump2(Dict &amp;d, uint depth, outputStream* st) const {</span>
<span class="line-added">2509   if (_vk == NULL) {</span>
<span class="line-added">2510     st-&gt;print(&quot;BOTTOM inlinetype&quot;);</span>
<span class="line-added">2511     return;</span>
<span class="line-added">2512   }</span>
<span class="line-added">2513   int count = _vk-&gt;nof_declared_nonstatic_fields();</span>
<span class="line-added">2514   st-&gt;print(&quot;inlinetype[%d]:{&quot;, count);</span>
<span class="line-added">2515   st-&gt;print(&quot;%s&quot;, count != 0 ? _vk-&gt;declared_nonstatic_field_at(0)-&gt;type()-&gt;name() : &quot;empty&quot;);</span>
<span class="line-added">2516   for (int i = 1; i &lt; count; ++i) {</span>
<span class="line-added">2517     st-&gt;print(&quot;, %s&quot;, _vk-&gt;declared_nonstatic_field_at(i)-&gt;type()-&gt;name());</span>
<span class="line-added">2518   }</span>
<span class="line-added">2519   st-&gt;print(&quot;}%s&quot;, _larval?&quot; : larval&quot;:&quot;&quot;);</span>
<span class="line-added">2520 }</span>
<span class="line-added">2521 #endif</span>
<span class="line-added">2522 </span>
2523 //==============================TypeVect=======================================
2524 // Convenience common pre-built types.
2525 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2526 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2527 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2528 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2529 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2530 
2531 //------------------------------make-------------------------------------------
2532 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2533   BasicType elem_bt = elem-&gt;array_element_basic_type();
2534   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2535   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2536   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2537   int size = length * type2aelembytes(elem_bt);
2538   switch (Matcher::vector_ideal_reg(size)) {
2539   case Op_VecS:
2540     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2541   case Op_RegL:
2542   case Op_VecD:
</pre>
<hr />
<pre>
2644 
2645 //=============================================================================
2646 // Convenience common pre-built types.
2647 const TypePtr *TypePtr::NULL_PTR;
2648 const TypePtr *TypePtr::NOTNULL;
2649 const TypePtr *TypePtr::BOTTOM;
2650 
2651 //------------------------------meet-------------------------------------------
2652 // Meet over the PTR enum
2653 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2654   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2655   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2656   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2657   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2658   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2659   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2660   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2661 };
2662 
2663 //------------------------------make-------------------------------------------
<span class="line-modified">2664 const TypePtr* TypePtr::make(TYPES t, enum PTR ptr, Offset offset, const TypePtr* speculative, int inline_depth) {</span>
2665   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2666 }
2667 
2668 //------------------------------cast_to_ptr_type-------------------------------
2669 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2670   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2671   if( ptr == _ptr ) return this;
2672   return make(_base, ptr, _offset, _speculative, _inline_depth);
2673 }
2674 
2675 //------------------------------get_con----------------------------------------
2676 intptr_t TypePtr::get_con() const {
2677   assert( _ptr == Null, &quot;&quot; );
<span class="line-modified">2678   return offset();</span>
2679 }
2680 
2681 //------------------------------meet-------------------------------------------
2682 // Compute the MEET of two types.  It returns a new Type object.
2683 const Type *TypePtr::xmeet(const Type *t) const {
2684   const Type* res = xmeet_helper(t);
2685   if (res-&gt;isa_ptr() == NULL) {
2686     return res;
2687   }
2688 
2689   const TypePtr* res_ptr = res-&gt;is_ptr();
2690   if (res_ptr-&gt;speculative() != NULL) {
2691     // type-&gt;speculative() == NULL means that speculation is no better
2692     // than type, i.e. type-&gt;speculative() == type. So there are 2
2693     // ways to represent the fact that we have no useful speculative
2694     // data and we should use a single one to be able to test for
2695     // equality between types. Check whether type-&gt;speculative() ==
2696     // type and set speculative to NULL if it is the case.
2697     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2698       return res_ptr-&gt;remove_speculative();
</pre>
<hr />
<pre>
2727     const TypePtr *tp = t-&gt;is_ptr();
2728     const TypePtr* speculative = xmeet_speculative(tp);
2729     int depth = meet_inline_depth(tp-&gt;inline_depth());
2730     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2731   }
2732   case RawPtr:                  // For these, flip the call around to cut down
2733   case OopPtr:
2734   case InstPtr:                 // on the cases I have to handle.
2735   case AryPtr:
2736   case MetadataPtr:
2737   case KlassPtr:
2738     return t-&gt;xmeet(this);      // Call in reverse direction
2739   default:                      // All else is a mistake
2740     typerr(t);
2741 
2742   }
2743   return this;
2744 }
2745 
2746 //------------------------------meet_offset------------------------------------
<span class="line-modified">2747 Type::Offset TypePtr::meet_offset(int offset) const {</span>
<span class="line-modified">2748   return _offset.meet(Offset(offset));</span>





2749 }
2750 
2751 //------------------------------dual_offset------------------------------------
<span class="line-modified">2752 Type::Offset TypePtr::dual_offset() const {</span>
<span class="line-modified">2753   return _offset.dual();</span>


2754 }
2755 
2756 //------------------------------xdual------------------------------------------
2757 // Dual: compute field-by-field dual
2758 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2759   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2760 };
2761 const Type *TypePtr::xdual() const {
2762   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2763 }
2764 
2765 //------------------------------xadd_offset------------------------------------
<span class="line-modified">2766 Type::Offset TypePtr::xadd_offset(intptr_t offset) const {</span>
<span class="line-modified">2767   return _offset.add(offset);</span>











2768 }
2769 
2770 //------------------------------add_offset-------------------------------------
2771 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2772   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2773 }
2774 
2775 //------------------------------eq---------------------------------------------
2776 // Structural equality check for Type representations
2777 bool TypePtr::eq( const Type *t ) const {
2778   const TypePtr *a = (const TypePtr*)t;
<span class="line-modified">2779   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;_offset &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;</span>
2780 }
2781 
2782 //------------------------------hash-------------------------------------------
2783 // Type-specific hashing function.
2784 int TypePtr::hash(void) const {
<span class="line-modified">2785   return java_add(java_add((jint)_ptr, (jint)offset()), java_add((jint)hash_speculative(), (jint)_inline_depth));</span>
2786 ;
2787 }
2788 
2789 /**
2790  * Return same type without a speculative part
2791  */
2792 const Type* TypePtr::remove_speculative() const {
2793   if (_speculative == NULL) {
2794     return this;
2795   }
2796   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2797   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2798 }
2799 
2800 /**
2801  * Return same type but drop speculative part if we know we won&#39;t use
2802  * it
2803  */
2804 const Type* TypePtr::cleanup_speculative() const {
2805   if (speculative() == NULL) {
</pre>
<hr />
<pre>
3025   }
3026   // We already know the speculative type is always null
3027   if (speculative_always_null()) {
3028     return false;
3029   }
3030   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
3031     return false;
3032   }
3033   return true;
3034 }
3035 
3036 //------------------------------dump2------------------------------------------
3037 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
3038   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
3039 };
3040 
3041 #ifndef PRODUCT
3042 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3043   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
3044   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
<span class="line-modified">3045   _offset.dump2(st);</span>


3046   dump_inline_depth(st);
3047   dump_speculative(st);
3048 }
3049 
3050 /**
3051  *dump the speculative part of the type
3052  */
3053 void TypePtr::dump_speculative(outputStream *st) const {
3054   if (_speculative != NULL) {
3055     st-&gt;print(&quot; (speculative=&quot;);
3056     _speculative-&gt;dump_on(st);
3057     st-&gt;print(&quot;)&quot;);
3058   }
3059 }
3060 
3061 /**
3062  *dump the inline depth of the type
3063  */
3064 void TypePtr::dump_inline_depth(outputStream *st) const {
3065   if (_inline_depth != InlineDepthBottom) {
3066     if (_inline_depth == InlineDepthTop) {
3067       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
3068     } else {
3069       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
3070     }
3071   }
3072 }
3073 #endif
3074 
3075 //------------------------------singleton--------------------------------------
3076 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3077 // constants
3078 bool TypePtr::singleton(void) const {
3079   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">3080   return (_offset != Offset::bottom) &amp;&amp; !below_centerline(_ptr);</span>
3081 }
3082 
3083 bool TypePtr::empty(void) const {
<span class="line-modified">3084   return (_offset == Offset::top) || above_centerline(_ptr);</span>
3085 }
3086 
3087 //=============================================================================
3088 // Convenience common pre-built types.
3089 const TypeRawPtr *TypeRawPtr::BOTTOM;
3090 const TypeRawPtr *TypeRawPtr::NOTNULL;
3091 
3092 //------------------------------make-------------------------------------------
3093 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
3094   assert( ptr != Constant, &quot;what is the constant?&quot; );
3095   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
3096   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
3097 }
3098 
3099 const TypeRawPtr *TypeRawPtr::make( address bits ) {
3100   assert( bits, &quot;Use TypePtr for NULL&quot; );
3101   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
3102 }
3103 
3104 //------------------------------cast_to_ptr_type-------------------------------
</pre>
<hr />
<pre>
3206 // Type-specific hashing function.
3207 int TypeRawPtr::hash(void) const {
3208   return (intptr_t)_bits + TypePtr::hash();
3209 }
3210 
3211 //------------------------------dump2------------------------------------------
3212 #ifndef PRODUCT
3213 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3214   if( _ptr == Constant )
3215     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
3216   else
3217     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
3218 }
3219 #endif
3220 
3221 //=============================================================================
3222 // Convenience common pre-built type.
3223 const TypeOopPtr *TypeOopPtr::BOTTOM;
3224 
3225 //------------------------------TypeOopPtr-------------------------------------
<span class="line-modified">3226 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,</span>
3227                        int instance_id, const TypePtr* speculative, int inline_depth)
3228   : TypePtr(t, ptr, offset, speculative, inline_depth),
3229     _const_oop(o), _klass(k),
3230     _klass_is_exact(xk),
3231     _is_ptr_to_narrowoop(false),
3232     _is_ptr_to_narrowklass(false),
3233     _is_ptr_to_boxed_value(false),
3234     _instance_id(instance_id) {
3235   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
<span class="line-modified">3236       (offset.get() &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {</span>
<span class="line-modified">3237     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset.get());</span>
3238   }
3239 #ifdef _LP64
<span class="line-modified">3240   if (this-&gt;offset() &gt; 0 || this-&gt;offset() == Type::OffsetTop || this-&gt;offset() == Type::OffsetBot) {</span>
<span class="line-modified">3241     if (this-&gt;offset() == oopDesc::klass_offset_in_bytes()) {</span>
3242       _is_ptr_to_narrowklass = UseCompressedClassPointers;
3243     } else if (klass() == NULL) {
3244       // Array with unknown body type
3245       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
3246       _is_ptr_to_narrowoop = UseCompressedOops;
<span class="line-modified">3247     } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {</span>
<span class="line-modified">3248       if (klass()-&gt;is_obj_array_klass()) {</span>
<span class="line-modified">3249         _is_ptr_to_narrowoop = true;</span>
<span class="line-added">3250       } else if (klass()-&gt;is_flat_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {</span>
<span class="line-added">3251         // Check if the field of the inline type array element contains oops</span>
<span class="line-added">3252         ciInlineKlass* vk = klass()-&gt;as_flat_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="line-added">3253         int foffset = field_offset.get() + vk-&gt;first_field_offset();</span>
<span class="line-added">3254         ciField* field = vk-&gt;get_field_by_offset(foffset, false);</span>
<span class="line-added">3255         assert(field != NULL, &quot;missing field&quot;);</span>
<span class="line-added">3256         BasicType bt = field-&gt;layout_type();</span>
<span class="line-added">3257         _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_INLINE_TYPE);</span>
<span class="line-added">3258       }</span>
3259     } else if (klass()-&gt;is_instance_klass()) {


3260       if (this-&gt;isa_klassptr()) {
3261         // Perm objects don&#39;t use compressed references
<span class="line-modified">3262       } else if (_offset == Offset::bottom || _offset == Offset::top) {</span>
3263         // unsafe access
3264         _is_ptr_to_narrowoop = UseCompressedOops;
3265       } else { // exclude unsafe ops
3266         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
<span class="line-modified">3267         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;</span>
<span class="line-modified">3268             (this-&gt;offset() == java_lang_Class::klass_offset() ||</span>

3269              this-&gt;offset() == java_lang_Class::array_klass_offset())) {
3270           // Special hidden fields from the Class.
3271           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3272           _is_ptr_to_narrowoop = false;
3273         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
<span class="line-modified">3274                    this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {</span>
3275           // Static fields
3276           assert(o != NULL, &quot;must be constant&quot;);
<span class="line-modified">3277           ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();</span>
<span class="line-modified">3278           BasicType basic_elem_type;</span>
<span class="line-modified">3279           if (ik-&gt;is_inlinetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_inline_klass()-&gt;default_value_offset()) {</span>
<span class="line-modified">3280             // Special hidden field that contains the oop of the default inline type</span>
<span class="line-added">3281             basic_elem_type = T_INLINE_TYPE;</span>
<span class="line-added">3282           } else {</span>
<span class="line-added">3283             ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);</span>
<span class="line-added">3284             assert(field != NULL, &quot;missing field&quot;);</span>
<span class="line-added">3285             basic_elem_type = field-&gt;layout_type();</span>
<span class="line-added">3286           }</span>
3287           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3288         } else {
3289           // Instance fields which contains a compressed oop references.
<span class="line-modified">3290           ciInstanceKlass* ik = klass()-&gt;as_instance_klass();</span>
<span class="line-added">3291           ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), false);</span>
3292           if (field != NULL) {
3293             BasicType basic_elem_type = field-&gt;layout_type();
3294             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3295           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3296             // Compile::find_alias_type() cast exactness on all types to verify
3297             // that it does not affect alias type.
3298             _is_ptr_to_narrowoop = UseCompressedOops;
3299           } else {
3300             // Type for the copy start in LibraryCallKit::inline_native_clone().
3301             _is_ptr_to_narrowoop = UseCompressedOops;
3302           }
3303         }
3304       }
3305     }
3306   }
3307 #endif
3308 }
3309 
3310 //------------------------------make-------------------------------------------
<span class="line-modified">3311 const TypeOopPtr *TypeOopPtr::make(PTR ptr, Offset offset, int instance_id,</span>
<span class="line-modified">3312                                    const TypePtr* speculative, int inline_depth) {</span>
3313   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3314   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3315   bool      xk = false;
3316   ciObject* o = NULL;
<span class="line-modified">3317   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, Offset::bottom, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
3318 }
3319 
3320 
3321 //------------------------------cast_to_ptr_type-------------------------------
3322 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3323   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3324   if( ptr == _ptr ) return this;
3325   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3326 }
3327 
3328 //-----------------------------cast_to_instance_id----------------------------
3329 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3330   // There are no instances of a general oop.
3331   // Return self unchanged.
3332   return this;
3333 }
3334 
3335 //-----------------------------cast_to_exactness-------------------------------
3336 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3337   // There is no such thing as an exact general oop.
3338   // Return self unchanged.
3339   return this;
3340 }
3341 













3342 //------------------------------meet-------------------------------------------
3343 // Compute the MEET of two types.  It returns a new Type object.
3344 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3345   // Perform a fast test for common case; meeting the same types together.
3346   if( this == t ) return this;  // Meeting same type-rep?
3347 
3348   // Current &quot;this-&gt;_base&quot; is OopPtr
3349   switch (t-&gt;base()) {          // switch on original type
3350 
3351   case Int:                     // Mixing ints &amp; oops happens when javac
3352   case Long:                    // reuses local variables
3353   case FloatTop:
3354   case FloatCon:
3355   case FloatBot:
3356   case DoubleTop:
3357   case DoubleCon:
3358   case DoubleBot:
3359   case NarrowOop:
3360   case NarrowKlass:
3361   case Bottom:                  // Ye Olde Default
3362     return Type::BOTTOM;
3363   case Top:
3364     return this;
3365 
3366   default:                      // All else is a mistake
3367     typerr(t);
3368 
3369   case RawPtr:
3370   case MetadataPtr:
3371   case KlassPtr:
3372     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3373 
3374   case AnyPtr: {
3375     // Found an AnyPtr type vs self-OopPtr type
3376     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">3377     Offset offset = meet_offset(tp-&gt;offset());</span>
3378     PTR ptr = meet_ptr(tp-&gt;ptr());
3379     const TypePtr* speculative = xmeet_speculative(tp);
3380     int depth = meet_inline_depth(tp-&gt;inline_depth());
3381     switch (tp-&gt;ptr()) {
3382     case Null:
3383       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3384       // else fall through:
3385     case TopPTR:
3386     case AnyNull: {
3387       int instance_id = meet_instance_id(InstanceTop);
3388       return make(ptr, offset, instance_id, speculative, depth);
3389     }
3390     case BotPTR:
3391     case NotNull:
3392       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3393     default: typerr(t);
3394     }
3395   }
3396 
3397   case OopPtr: {                 // Meeting to other OopPtrs
</pre>
<hr />
<pre>
3399     int instance_id = meet_instance_id(tp-&gt;instance_id());
3400     const TypePtr* speculative = xmeet_speculative(tp);
3401     int depth = meet_inline_depth(tp-&gt;inline_depth());
3402     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3403   }
3404 
3405   case InstPtr:                  // For these, flip the call around to cut down
3406   case AryPtr:
3407     return t-&gt;xmeet(this);      // Call in reverse direction
3408 
3409   } // End of switch
3410   return this;                  // Return the double constant
3411 }
3412 
3413 
3414 //------------------------------xdual------------------------------------------
3415 // Dual of a pure heap pointer.  No relevant klass or oop information.
3416 const Type *TypeOopPtr::xdual() const {
3417   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3418   assert(const_oop() == NULL,             &quot;no constants here&quot;);
<span class="line-modified">3419   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), Offset::bottom, dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
3420 }
3421 
3422 //--------------------------make_from_klass_common-----------------------------
3423 // Computes the element-type given a klass.
3424 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
<span class="line-modified">3425   if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {</span>
3426     Compile* C = Compile::current();
3427     Dependencies* deps = C-&gt;dependencies();
3428     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3429     // Element is an instance
3430     bool klass_is_exact = false;
3431     if (klass-&gt;is_loaded()) {
3432       // Try to set klass_is_exact.
3433       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3434       klass_is_exact = ik-&gt;is_final();
3435       if (!klass_is_exact &amp;&amp; klass_change
3436           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3437         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3438         if (sub != NULL) {
3439           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3440           klass = ik = sub;
3441           klass_is_exact = sub-&gt;is_final();
3442         }
3443       }
3444       if (!klass_is_exact &amp;&amp; try_for_exact &amp;&amp; deps != NULL &amp;&amp;
3445           !ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3446         // Add a dependence; if concrete subclass added we need to recompile
3447         deps-&gt;assert_leaf_type(ik);
3448         klass_is_exact = true;
3449       }
3450     }
<span class="line-modified">3451     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0));</span>
3452   } else if (klass-&gt;is_obj_array_klass()) {
<span class="line-modified">3453     // Element is an object or inline type array. Recursively call ourself.</span>
<span class="line-modified">3454     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);</span>
<span class="line-added">3455     if (etype-&gt;is_inlinetypeptr()) {</span>
<span class="line-added">3456       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();</span>
<span class="line-added">3457     }</span>
<span class="line-added">3458     // Determine null-free/flattened properties</span>
<span class="line-added">3459     const TypeOopPtr* exact_etype = etype;</span>
<span class="line-added">3460     if (etype-&gt;can_be_inline_type()) {</span>
<span class="line-added">3461       // Use exact type if element can be an inline type</span>
<span class="line-added">3462       exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);</span>
<span class="line-added">3463     }</span>
<span class="line-added">3464     bool not_null_free = !exact_etype-&gt;can_be_inline_type();</span>
<span class="line-added">3465     bool not_flat = !UseFlatArray || not_null_free || (exact_etype-&gt;is_inlinetypeptr() &amp;&amp; !exact_etype-&gt;inline_klass()-&gt;flatten_array());</span>
<span class="line-added">3466 </span>
3467     bool xk = etype-&gt;klass_is_exact();
<span class="line-modified">3468     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);</span>
3469     // We used to pass NotNull in here, asserting that the sub-arrays
3470     // are all not-null.  This is not true in generally, as code can
3471     // slam NULLs down in the subarrays.
<span class="line-modified">3472     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));</span>
3473     return arr;
3474   } else if (klass-&gt;is_type_array_klass()) {
3475     // Element is an typeArray
3476     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
<span class="line-modified">3477     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS,</span>
<span class="line-added">3478                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);</span>
3479     // We used to pass NotNull in here, asserting that the array pointer
3480     // is not-null. That was not true in general.
<span class="line-modified">3481     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));</span>
<span class="line-added">3482     return arr;</span>
<span class="line-added">3483   } else if (klass-&gt;is_flat_array_klass()) {</span>
<span class="line-added">3484     ciInlineKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="line-added">3485     const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::POS);</span>
<span class="line-added">3486     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));</span>
3487     return arr;
3488   } else {
3489     ShouldNotReachHere();
3490     return NULL;
3491   }
3492 }
3493 
3494 //------------------------------make_from_constant-----------------------------
3495 // Make a java pointer from an oop constant
3496 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3497   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3498 
3499   const bool make_constant = require_constant || o-&gt;should_be_constant();
3500 
3501   ciKlass* klass = o-&gt;klass();
<span class="line-modified">3502   if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {</span>
<span class="line-modified">3503     // Element is an instance or inline type</span>
3504     if (make_constant) {
3505       return TypeInstPtr::make(o);
3506     } else {
<span class="line-modified">3507       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0));</span>
3508     }
3509   } else if (klass-&gt;is_obj_array_klass()) {
3510     // Element is an object array. Recursively call ourself.
<span class="line-modified">3511     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());</span>
<span class="line-modified">3512     bool null_free = false;</span>
<span class="line-modified">3513     if (etype-&gt;is_inlinetypeptr()) {</span>
<span class="line-added">3514       null_free = true;</span>
<span class="line-added">3515       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();</span>
<span class="line-added">3516     }</span>
<span class="line-added">3517     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),</span>
<span class="line-added">3518                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);</span>
3519     // We used to pass NotNull in here, asserting that the sub-arrays
3520     // are all not-null.  This is not true in generally, as code can
3521     // slam NULLs down in the subarrays.
3522     if (make_constant) {
<span class="line-modified">3523       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));</span>
3524     } else {
<span class="line-modified">3525       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));</span>
3526     }
3527   } else if (klass-&gt;is_type_array_klass()) {
3528     // Element is an typeArray
<span class="line-modified">3529     const Type* etype = (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());</span>
<span class="line-modified">3530     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),</span>
<span class="line-modified">3531                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);</span>
3532     // We used to pass NotNull in here, asserting that the array pointer
3533     // is not-null. That was not true in general.
3534     if (make_constant) {
<span class="line-modified">3535       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));</span>
3536     } else {
<span class="line-modified">3537       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));</span>
<span class="line-added">3538     }</span>
<span class="line-added">3539   } else if (klass-&gt;is_flat_array_klass()) {</span>
<span class="line-added">3540     ciInlineKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="line-added">3541     const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::make(o-&gt;as_array()-&gt;length()));</span>
<span class="line-added">3542     // We used to pass NotNull in here, asserting that the sub-arrays</span>
<span class="line-added">3543     // are all not-null.  This is not true in generally, as code can</span>
<span class="line-added">3544     // slam NULLs down in the subarrays.</span>
<span class="line-added">3545     if (make_constant) {</span>
<span class="line-added">3546       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));</span>
<span class="line-added">3547     } else {</span>
<span class="line-added">3548       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));</span>
3549     }
3550   }
3551 
3552   fatal(&quot;unhandled object type&quot;);
3553   return NULL;
3554 }
3555 
3556 //------------------------------get_con----------------------------------------
3557 intptr_t TypeOopPtr::get_con() const {
3558   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-modified">3559   assert(offset() &gt;= 0, &quot;&quot;);</span>
3560 
<span class="line-modified">3561   if (offset() != 0) {</span>
3562     // After being ported to the compiler interface, the compiler no longer
3563     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3564     // to a handle at compile time.  This handle is embedded in the generated
3565     // code and dereferenced at the time the nmethod is made.  Until that time,
3566     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3567     // have access to the addresses!).  This does not seem to currently happen,
3568     // but this assertion here is to help prevent its occurence.
3569     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3570     ShouldNotReachHere();
3571   }
3572 
3573   return (intptr_t)const_oop()-&gt;constant_encoding();
3574 }
3575 
3576 
3577 //-----------------------------filter------------------------------------------
3578 // Do not allow interface-vs.-noninterface joins to collapse to top.
3579 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3580 
3581   const Type* ft = join_helper(kills, include_speculative);
</pre>
<hr />
<pre>
3634     return (one == two) &amp;&amp; TypePtr::eq(t);
3635   } else {
3636     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3637   }
3638 }
3639 
3640 //------------------------------hash-------------------------------------------
3641 // Type-specific hashing function.
3642 int TypeOopPtr::hash(void) const {
3643   return
3644     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3645              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3646 }
3647 
3648 //------------------------------dump2------------------------------------------
3649 #ifndef PRODUCT
3650 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3651   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3652   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3653   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
<span class="line-modified">3654   _offset.dump2(st);</span>





3655   if (_instance_id == InstanceTop)
3656     st-&gt;print(&quot;,iid=top&quot;);
3657   else if (_instance_id != InstanceBot)
3658     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3659 
3660   dump_inline_depth(st);
3661   dump_speculative(st);
3662 }
3663 #endif
3664 
3665 //------------------------------singleton--------------------------------------
3666 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3667 // constants
3668 bool TypeOopPtr::singleton(void) const {
3669   // detune optimizer to not generate constant oop + constant offset as a constant!
3670   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">3671   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);</span>
3672 }
3673 
3674 //------------------------------add_offset-------------------------------------
3675 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3676   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3677 }
3678 
3679 /**
3680  * Return same type without a speculative part
3681  */
3682 const Type* TypeOopPtr::remove_speculative() const {
3683   if (_speculative == NULL) {
3684     return this;
3685   }
3686   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3687   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3688 }
3689 
3690 /**
3691  * Return same type but drop speculative part if we know we won&#39;t use
</pre>
<hr />
<pre>
3743  *
3744  * @return  true if type profile is valuable
3745  */
3746 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3747   // no way to improve an already exact type
3748   if (klass_is_exact()) {
3749     return false;
3750   }
3751   return TypePtr::would_improve_type(exact_kls, inline_depth);
3752 }
3753 
3754 //=============================================================================
3755 // Convenience common pre-built types.
3756 const TypeInstPtr *TypeInstPtr::NOTNULL;
3757 const TypeInstPtr *TypeInstPtr::BOTTOM;
3758 const TypeInstPtr *TypeInstPtr::MIRROR;
3759 const TypeInstPtr *TypeInstPtr::MARK;
3760 const TypeInstPtr *TypeInstPtr::KLASS;
3761 
3762 //------------------------------TypeInstPtr-------------------------------------
<span class="line-modified">3763 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,</span>
<span class="line-modified">3764                          bool flatten_array, int instance_id, const TypePtr* speculative,</span>
<span class="line-modified">3765                          int inline_depth)</span>
<span class="line-modified">3766   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),</span>
<span class="line-modified">3767     _name(k-&gt;name()), _flatten_array(flatten_array) {</span>
<span class="line-modified">3768   assert(k != NULL &amp;&amp;</span>
<span class="line-modified">3769          (k-&gt;is_loaded() || o == NULL),</span>
<span class="line-added">3770          &quot;cannot have constants with non-loaded klass&quot;);</span>
<span class="line-added">3771   assert(!klass()-&gt;flatten_array() || flatten_array, &quot;Should be flat in array&quot;);</span>
<span class="line-added">3772   assert(!flatten_array || can_be_inline_type(), &quot;Only inline types can be flat in array&quot;);</span>
3773 };
3774 
3775 //------------------------------make-------------------------------------------
3776 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3777                                      ciKlass* k,
3778                                      bool xk,
3779                                      ciObject* o,
<span class="line-modified">3780                                      Offset offset,</span>
<span class="line-added">3781                                      bool flatten_array,</span>
3782                                      int instance_id,
3783                                      const TypePtr* speculative,
3784                                      int inline_depth) {
3785   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3786   // Either const_oop() is NULL or else ptr is Constant
3787   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3788           &quot;constant pointers must have a value supplied&quot; );
3789   // Ptr is never Null
3790   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3791 
3792   assert(instance_id &lt;= 0 || xk, &quot;instances are always exactly typed&quot;);
3793   if (ptr == Constant) {
3794     // Note:  This case includes meta-object constants, such as methods.
3795     xk = true;
3796   } else if (k-&gt;is_loaded()) {
3797     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3798     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3799     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3800   }
3801 
<span class="line-added">3802   // Check if this type is known to be flat in arrays</span>
<span class="line-added">3803   flatten_array = flatten_array || k-&gt;flatten_array();</span>
<span class="line-added">3804 </span>
3805   // Now hash this baby
3806   TypeInstPtr *result =
<span class="line-modified">3807     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o, offset, flatten_array, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
3808 
3809   return result;
3810 }
3811 
3812 /**
3813  *  Create constant type for a constant boxed value
3814  */
3815 const Type* TypeInstPtr::get_const_boxed_value() const {
3816   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3817   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3818   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3819   BasicType bt = constant.basic_type();
3820   switch (bt) {
3821     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3822     case T_INT:      return TypeInt::make(constant.as_int());
3823     case T_CHAR:     return TypeInt::make(constant.as_char());
3824     case T_BYTE:     return TypeInt::make(constant.as_byte());
3825     case T_SHORT:    return TypeInt::make(constant.as_short());
3826     case T_FLOAT:    return TypeF::make(constant.as_float());
3827     case T_DOUBLE:   return TypeD::make(constant.as_double());
3828     case T_LONG:     return TypeLong::make(constant.as_long());
3829     default:         break;
3830   }
3831   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3832   return NULL;
3833 }
3834 
3835 //------------------------------cast_to_ptr_type-------------------------------
3836 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3837   if( ptr == _ptr ) return this;
3838   // Reconstruct _sig info here since not a problem with later lazy
3839   // construction, _sig will show up on demand.
<span class="line-modified">3840   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flatten_array, _instance_id, _speculative, _inline_depth);</span>
3841 }
3842 
3843 
3844 //-----------------------------cast_to_exactness-------------------------------
3845 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3846   if( klass_is_exact == _klass_is_exact ) return this;
3847   if (!_klass-&gt;is_loaded())  return this;
3848   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3849   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3850   if( ik-&gt;is_interface() )              return this;  // cannot set xk
<span class="line-modified">3851   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flatten_array, _instance_id, _speculative, _inline_depth);</span>
3852 }
3853 
3854 //-----------------------------cast_to_instance_id----------------------------
3855 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3856   if( instance_id == _instance_id ) return this;
<span class="line-modified">3857   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flatten_array, instance_id, _speculative, _inline_depth);</span>
3858 }
3859 
3860 //------------------------------xmeet_unloaded---------------------------------
3861 // Compute the MEET of two InstPtrs when at least one is unloaded.
3862 // Assume classes are different since called after check for same name/class-loader
3863 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
<span class="line-modified">3864     Offset off = meet_offset(tinst-&gt;offset());</span>
3865     PTR ptr = meet_ptr(tinst-&gt;ptr());
3866     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3867     const TypePtr* speculative = xmeet_speculative(tinst);
3868     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3869 
3870     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3871     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3872     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3873       //
3874       // Meet unloaded class with java/lang/Object
3875       //
3876       // Meet
3877       //          |                     Unloaded Class
3878       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3879       //  ===================================================================
3880       //   TOP    | ..........................Unloaded......................|
3881       //  AnyNull |  U-AN    |................Unloaded......................|
3882       // Constant | ... O-NN .................................. |   O-BOT   |
3883       //  NotNull | ... O-NN .................................. |   O-BOT   |
3884       //  BOTTOM  | ........................Object-BOTTOM ..................|
3885       //
3886       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3887       //
3888       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
<span class="line-modified">3889       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, false, instance_id, speculative, depth); }</span>
3890       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3891       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3892         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3893         else                                      { return TypeInstPtr::NOTNULL; }
3894       }
3895       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3896 
3897       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3898     }
3899 
3900     // Both are unloaded, not the same class, not Object
3901     // Or meet unloaded with a different loaded class, not java/lang/Object
3902     if( ptr != TypePtr::BotPTR ) {
3903       return TypeInstPtr::NOTNULL;
3904     }
3905     return TypeInstPtr::BOTTOM;
3906 }
3907 
3908 
3909 //------------------------------meet-------------------------------------------
</pre>
<hr />
<pre>
3922   case FloatBot:
3923   case DoubleTop:
3924   case DoubleCon:
3925   case DoubleBot:
3926   case NarrowOop:
3927   case NarrowKlass:
3928   case Bottom:                  // Ye Olde Default
3929     return Type::BOTTOM;
3930   case Top:
3931     return this;
3932 
3933   default:                      // All else is a mistake
3934     typerr(t);
3935 
3936   case MetadataPtr:
3937   case KlassPtr:
3938   case RawPtr: return TypePtr::BOTTOM;
3939 
3940   case AryPtr: {                // All arrays inherit from Object class
3941     const TypeAryPtr *tp = t-&gt;is_aryptr();
<span class="line-modified">3942     Offset offset = meet_offset(tp-&gt;offset());</span>
3943     PTR ptr = meet_ptr(tp-&gt;ptr());
3944     int instance_id = meet_instance_id(tp-&gt;instance_id());
3945     const TypePtr* speculative = xmeet_speculative(tp);
3946     int depth = meet_inline_depth(tp-&gt;inline_depth());
3947     switch (ptr) {
3948     case TopPTR:
3949     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3950       // For instances when a subclass meets a superclass we fall
3951       // below the centerline when the superclass is exact. We need to
3952       // do the same here.
<span class="line-modified">3953       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flatten_array()) {</span>
<span class="line-modified">3954         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);</span>
3955       } else {
3956         // cannot subclass, so the meet has to fall badly below the centerline
3957         ptr = NotNull;
3958         instance_id = InstanceBot;
<span class="line-modified">3959         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);</span>
3960       }
3961     case Constant:
3962     case NotNull:
3963     case BotPTR:                // Fall down to object klass
3964       // LCA is object_klass, but if we subclass from the top we can do better
3965       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3966         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3967         // then we can subclass in the Java class hierarchy.
3968         // For instances when a subclass meets a superclass we fall
3969         // below the centerline when the superclass is exact. We need
3970         // to do the same here.
<span class="line-modified">3971         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flatten_array()) {</span>
3972           // that is, tp&#39;s array type is a subtype of my klass
3973           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
<span class="line-modified">3974                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);</span>
3975         }
3976       }
3977       // The other case cannot happen, since I cannot be a subtype of an array.
3978       // The meet falls down to Object class below centerline.
3979       if( ptr == Constant )
3980          ptr = NotNull;
3981       instance_id = InstanceBot;
<span class="line-modified">3982       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);</span>
3983     default: typerr(t);
3984     }
3985   }
3986 
3987   case OopPtr: {                // Meeting to OopPtrs
3988     // Found a OopPtr type vs self-InstPtr type
3989     const TypeOopPtr *tp = t-&gt;is_oopptr();
<span class="line-modified">3990     Offset offset = meet_offset(tp-&gt;offset());</span>
3991     PTR ptr = meet_ptr(tp-&gt;ptr());
3992     switch (tp-&gt;ptr()) {
3993     case TopPTR:
3994     case AnyNull: {
3995       int instance_id = meet_instance_id(InstanceTop);
3996       const TypePtr* speculative = xmeet_speculative(tp);
3997       int depth = meet_inline_depth(tp-&gt;inline_depth());
3998       return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">3999                   (ptr == Constant ? const_oop() : NULL), offset, flatten_array(), instance_id, speculative, depth);</span>
4000     }
4001     case NotNull:
4002     case BotPTR: {
4003       int instance_id = meet_instance_id(tp-&gt;instance_id());
4004       const TypePtr* speculative = xmeet_speculative(tp);
4005       int depth = meet_inline_depth(tp-&gt;inline_depth());
4006       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4007     }
4008     default: typerr(t);
4009     }
4010   }
4011 
4012   case AnyPtr: {                // Meeting to AnyPtrs
4013     // Found an AnyPtr type vs self-InstPtr type
4014     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">4015     Offset offset = meet_offset(tp-&gt;offset());</span>
4016     PTR ptr = meet_ptr(tp-&gt;ptr());
4017     int instance_id = meet_instance_id(InstanceTop);
4018     const TypePtr* speculative = xmeet_speculative(tp);
4019     int depth = meet_inline_depth(tp-&gt;inline_depth());
4020     switch (tp-&gt;ptr()) {
4021     case Null:
4022       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4023       // else fall through to AnyNull
4024     case TopPTR:
4025     case AnyNull: {
4026       return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">4027                   (ptr == Constant ? const_oop() : NULL), offset, flatten_array(), instance_id, speculative, depth);</span>
4028     }
4029     case NotNull:
4030     case BotPTR:
4031       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
4032     default: typerr(t);
4033     }
4034   }
4035 
4036   /*
4037                  A-top         }
4038                /   |   \       }  Tops
4039            B-top A-any C-top   }
4040               | /  |  \ |      }  Any-nulls
4041            B-any   |   C-any   }
4042               |    |    |
4043            B-con A-con C-con   } constants; not comparable across classes
4044               |    |    |
4045            B-not   |   C-not   }
4046               | \  |  / |      }  not-nulls
4047            B-bot A-not C-bot   }
4048                \   |   /       }  Bottoms
4049                  A-bot         }
4050   */
4051 
4052   case InstPtr: {                // Meeting 2 Oops?
4053     // Found an InstPtr sub-type vs self-InstPtr type
4054     const TypeInstPtr *tinst = t-&gt;is_instptr();
<span class="line-modified">4055     Offset off = meet_offset( tinst-&gt;offset() );</span>
4056     PTR ptr = meet_ptr( tinst-&gt;ptr() );
4057     int instance_id = meet_instance_id(tinst-&gt;instance_id());
4058     const TypePtr* speculative = xmeet_speculative(tinst);
4059     int depth = meet_inline_depth(tinst-&gt;inline_depth());
4060 
4061     // Check for easy case; klasses are equal (and perhaps not loaded!)
4062     // If we have constants, then we created oops so classes are loaded
4063     // and we can handle the constants further down.  This case handles
4064     // both-not-loaded or both-loaded classes
<span class="line-modified">4065     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact() &amp;&amp;</span>
<span class="line-modified">4066         flatten_array() == tinst-&gt;flatten_array()) {</span>
<span class="line-added">4067       return make(ptr, klass(), klass_is_exact(), NULL, off, flatten_array(), instance_id, speculative, depth);</span>
4068     }
4069 
4070     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
4071     ciKlass* tinst_klass = tinst-&gt;klass();
4072     ciKlass* this_klass  = this-&gt;klass();
4073     bool tinst_xk = tinst-&gt;klass_is_exact();
4074     bool this_xk  = this-&gt;klass_is_exact();
<span class="line-added">4075     bool tinst_flatten_array = tinst-&gt;flatten_array();</span>
<span class="line-added">4076     bool this_flatten_array  = this-&gt;flatten_array();</span>
4077     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
4078       // One of these classes has not been loaded
4079       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
4080 #ifndef PRODUCT
4081       if( PrintOpto &amp;&amp; Verbose ) {
4082         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
4083         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
4084         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
4085       }
4086 #endif
4087       return unloaded_meet;
4088     }
4089 
4090     // Handle mixing oops and interfaces first.
4091     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
4092                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
4093       ciKlass *tmp = tinst_klass; // Swap interface around
4094       tinst_klass = this_klass;
4095       this_klass = tmp;
4096       bool tmp2 = tinst_xk;
4097       tinst_xk = this_xk;
4098       this_xk = tmp2;
<span class="line-added">4099       tmp2 = tinst_flatten_array;</span>
<span class="line-added">4100       tinst_flatten_array = this_flatten_array;</span>
<span class="line-added">4101       this_flatten_array = tmp2;</span>
4102     }
4103     if (tinst_klass-&gt;is_interface() &amp;&amp;
4104         !(this_klass-&gt;is_interface() ||
4105           // Treat java/lang/Object as an honorary interface,
4106           // because we need a bottom for the interface hierarchy.
4107           this_klass == ciEnv::current()-&gt;Object_klass())) {
4108       // Oop meets interface!
4109 
4110       // See if the oop subtypes (implements) interface.
4111       ciKlass *k;
4112       bool xk;
<span class="line-added">4113       bool flat_array;</span>
4114       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
4115         // Oop indeed subtypes.  Now keep oop or interface depending
4116         // on whether we are both above the centerline or either is
4117         // below the centerline.  If we are on the centerline
4118         // (e.g., Constant vs. AnyNull interface), use the constant.
4119         k  = below_centerline(ptr) ? tinst_klass : this_klass;
4120         // If we are keeping this_klass, keep its exactness too.
4121         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
<span class="line-added">4122         flat_array = below_centerline(ptr) ? tinst_flatten_array    : this_flatten_array;</span>
4123       } else {                  // Does not implement, fall to Object
4124         // Oop does not implement interface, so mixing falls to Object
4125         // just like the verifier does (if both are above the
4126         // centerline fall to interface)
4127         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
4128         xk = above_centerline(ptr) ? tinst_xk : false;
<span class="line-added">4129         flat_array = above_centerline(ptr) ? tinst_flatten_array : false;</span>
4130         // Watch out for Constant vs. AnyNull interface.
4131         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
4132         instance_id = InstanceBot;
4133       }
4134       ciObject* o = NULL;  // the Constant value, if any
4135       if (ptr == Constant) {
4136         // Find out which constant.
4137         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
4138       }
<span class="line-modified">4139       return make(ptr, k, xk, o, off, flat_array, instance_id, speculative, depth);</span>
4140     }
4141 
4142     // Either oop vs oop or interface vs interface or interface vs Object
4143 
4144     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
4145     // If we split one up &amp; one down AND they subtype, take the down man.
4146     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4147     // If both are up and they subtype, take the subtype class.
4148     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4149     // If both are down and they subtype, take the supertype class.
4150     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4151     // Constants treated as down.
4152 
4153     // Now, reorder the above list; observe that both-down+subtype is also
4154     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
4155     // If we split one up &amp; one down AND they subtype, take the down man.
4156     // If both are up and they subtype, take the subtype class.
4157 
4158     // If both are down and they subtype, &quot;fall hard&quot;.
4159     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4160     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4161     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4162 
4163     // If a proper subtype is exact, and we return it, we return it exactly.
4164     // If a proper supertype is exact, there can be no subtyping relationship!
4165     // If both types are equal to the subtype, exactness is and-ed below the
4166     // centerline and or-ed above it.  (N.B. Constants are always exact.)
4167 
4168     // Check for subtyping:
4169     ciKlass *subtype = NULL;
4170     bool subtype_exact = false;
<span class="line-modified">4171     bool flat_array = false;</span>
<span class="line-added">4172     if (tinst_klass-&gt;equals(this_klass)) {</span>
4173       subtype = this_klass;
4174       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
<span class="line-modified">4175       flat_array = below_centerline(ptr) ? (this_flatten_array &amp;&amp; tinst_flatten_array) : (this_flatten_array || tinst_flatten_array);</span>
<span class="line-added">4176     } else if(!tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of(tinst_klass) &amp;&amp; (!tinst_flatten_array || this_flatten_array)) {</span>
4177       subtype = this_klass;     // Pick subtyping class
4178       subtype_exact = this_xk;
<span class="line-modified">4179       flat_array = this_flatten_array;</span>
<span class="line-added">4180     } else if(!this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of(this_klass) &amp;&amp; (!this_flatten_array || tinst_flatten_array)) {</span>
4181       subtype = tinst_klass;    // Pick subtyping class
4182       subtype_exact = tinst_xk;
<span class="line-added">4183       flat_array = tinst_flatten_array;</span>
4184     }
4185 
<span class="line-modified">4186     if (subtype) {</span>
<span class="line-modified">4187       if (above_centerline(ptr)) { // both are up?</span>
4188         this_klass = tinst_klass = subtype;
4189         this_xk = tinst_xk = subtype_exact;
<span class="line-modified">4190         this_flatten_array = tinst_flatten_array = flat_array;</span>
<span class="line-added">4191       } else if (above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr)) {</span>
4192         this_klass = tinst_klass; // tinst is down; keep down man
4193         this_xk = tinst_xk;
<span class="line-modified">4194         this_flatten_array = tinst_flatten_array;</span>
<span class="line-added">4195       } else if (above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr)) {</span>
4196         tinst_klass = this_klass; // this is down; keep down man
4197         tinst_xk = this_xk;
<span class="line-added">4198         tinst_flatten_array = this_flatten_array;</span>
4199       } else {
4200         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
<span class="line-added">4201         this_flatten_array = flat_array;</span>
4202       }
4203     }
4204 
4205     // Check for classes now being equal
4206     if (tinst_klass-&gt;equals(this_klass)) {
4207       // If the klasses are equal, the constants may still differ.  Fall to
4208       // NotNull if they do (neither constant is NULL; that is a special case
4209       // handled elsewhere).
4210       ciObject* o = NULL;             // Assume not constant when done
4211       ciObject* this_oop  = const_oop();
4212       ciObject* tinst_oop = tinst-&gt;const_oop();
4213       if( ptr == Constant ) {
4214         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
4215             this_oop-&gt;equals(tinst_oop) )
4216           o = this_oop;
4217         else if (above_centerline(this -&gt;_ptr))
4218           o = tinst_oop;
4219         else if (above_centerline(tinst -&gt;_ptr))
4220           o = this_oop;
4221         else
4222           ptr = NotNull;
4223       }
<span class="line-modified">4224       return make(ptr, this_klass, this_xk, o, off, this_flatten_array, instance_id, speculative, depth);</span>
4225     } // Else classes are not equal
4226 
4227     // Since klasses are different, we require a LCA in the Java
4228     // class hierarchy - which means we have to fall to at least NotNull.
4229     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
4230       ptr = NotNull;
4231 
4232     instance_id = InstanceBot;
4233 
4234     // Now we find the LCA of Java classes
4235     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
<span class="line-modified">4236     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);</span>
4237   } // End of case InstPtr
4238 
<span class="line-added">4239   case InlineType: {</span>
<span class="line-added">4240     const TypeInlineType* tv = t-&gt;is_inlinetype();</span>
<span class="line-added">4241     if (above_centerline(ptr())) {</span>
<span class="line-added">4242       if (tv-&gt;inline_klass()-&gt;is_subtype_of(_klass)) {</span>
<span class="line-added">4243         return t;</span>
<span class="line-added">4244       } else {</span>
<span class="line-added">4245         return TypeInstPtr::NOTNULL;</span>
<span class="line-added">4246       }</span>
<span class="line-added">4247     } else {</span>
<span class="line-added">4248       PTR ptr = this-&gt;_ptr;</span>
<span class="line-added">4249       if (ptr == Constant) {</span>
<span class="line-added">4250         ptr = NotNull;</span>
<span class="line-added">4251       }</span>
<span class="line-added">4252       if (tv-&gt;inline_klass()-&gt;is_subtype_of(_klass)) {</span>
<span class="line-added">4253         return TypeInstPtr::make(ptr, _klass);</span>
<span class="line-added">4254       } else {</span>
<span class="line-added">4255         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());</span>
<span class="line-added">4256       }</span>
<span class="line-added">4257     }</span>
<span class="line-added">4258   }</span>
<span class="line-added">4259 </span>
4260   } // End of switch
4261   return this;                  // Return the double constant
4262 }
4263 
4264 
4265 //------------------------java_mirror_type--------------------------------------
4266 ciType* TypeInstPtr::java_mirror_type() const {
4267   // must be a singleton type
4268   if( const_oop() == NULL )  return NULL;
4269 
4270   // must be of type java.lang.Class
4271   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;

4272   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
4273 }
4274 
4275 
4276 //------------------------------xdual------------------------------------------
4277 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
4278 // inheritance mechanism.
4279 const Type *TypeInstPtr::xdual() const {
<span class="line-modified">4280   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flatten_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
4281 }
4282 
4283 //------------------------------eq---------------------------------------------
4284 // Structural equality check for Type representations
4285 bool TypeInstPtr::eq( const Type *t ) const {
4286   const TypeInstPtr *p = t-&gt;is_instptr();
4287   return
4288     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
<span class="line-added">4289     flatten_array() == p-&gt;flatten_array() &amp;&amp;</span>
4290     TypeOopPtr::eq(p);          // Check sub-type stuff
4291 }
4292 
4293 //------------------------------hash-------------------------------------------
4294 // Type-specific hashing function.
4295 int TypeInstPtr::hash(void) const {
<span class="line-modified">4296   int hash = java_add(java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash()), (jint)flatten_array());</span>
4297   return hash;
4298 }
4299 
4300 //------------------------------dump2------------------------------------------
4301 // Dump oop Type
4302 #ifndef PRODUCT
4303 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4304   // Print the name of the klass.
4305   klass()-&gt;print_name_on(st);
4306 
4307   switch( _ptr ) {
4308   case Constant:
4309     // TO DO: Make CI print the hex address of the underlying oop.
4310     if (WizardMode || Verbose) {
4311       const_oop()-&gt;print_oop(st);
4312     }
4313   case BotPTR:
4314     if (!WizardMode &amp;&amp; !Verbose) {
4315       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4316       break;
4317     }
4318   case TopPTR:
4319   case AnyNull:
4320   case NotNull:
4321     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4322     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4323     break;
4324   default:
4325     break;
4326   }
4327 
<span class="line-modified">4328   _offset.dump2(st);</span>




4329 
4330   st-&gt;print(&quot; *&quot;);
<span class="line-added">4331 </span>
<span class="line-added">4332   if (flatten_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
<span class="line-added">4333     st-&gt;print(&quot; (flatten array)&quot;);</span>
<span class="line-added">4334   }</span>
<span class="line-added">4335 </span>
4336   if (_instance_id == InstanceTop)
4337     st-&gt;print(&quot;,iid=top&quot;);
4338   else if (_instance_id != InstanceBot)
4339     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4340 
4341   dump_inline_depth(st);
4342   dump_speculative(st);
4343 }
4344 #endif
4345 
4346 //------------------------------add_offset-------------------------------------
4347 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
<span class="line-modified">4348   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flatten_array(),</span>
4349               _instance_id, add_offset_speculative(offset), _inline_depth);
4350 }
4351 
4352 const Type *TypeInstPtr::remove_speculative() const {
4353   if (_speculative == NULL) {
4354     return this;
4355   }
4356   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="line-modified">4357   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(),</span>
4358               _instance_id, NULL, _inline_depth);
4359 }
4360 
4361 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4362   if (!UseInlineDepthForSpeculativeTypes) {
4363     return this;
4364   }
<span class="line-modified">4365   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(), _instance_id, _speculative, depth);</span>
4366 }
4367 
4368 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4369   assert(is_known_instance(), &quot;should be known&quot;);
<span class="line-modified">4370   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(), instance_id, _speculative, _inline_depth);</span>
<span class="line-added">4371 }</span>
<span class="line-added">4372 </span>
<span class="line-added">4373 const TypeInstPtr *TypeInstPtr::cast_to_flatten_array() const {</span>
<span class="line-added">4374   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);</span>
4375 }
4376 
<span class="line-added">4377 </span>
4378 //=============================================================================
4379 // Convenience common pre-built types.
4380 const TypeAryPtr *TypeAryPtr::RANGE;
4381 const TypeAryPtr *TypeAryPtr::OOPS;
4382 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4383 const TypeAryPtr *TypeAryPtr::BYTES;
4384 const TypeAryPtr *TypeAryPtr::SHORTS;
4385 const TypeAryPtr *TypeAryPtr::CHARS;
4386 const TypeAryPtr *TypeAryPtr::INTS;
4387 const TypeAryPtr *TypeAryPtr::LONGS;
4388 const TypeAryPtr *TypeAryPtr::FLOATS;
4389 const TypeAryPtr *TypeAryPtr::DOUBLES;
<span class="line-added">4390 const TypeAryPtr *TypeAryPtr::INLINES;</span>
4391 
4392 //------------------------------make-------------------------------------------
<span class="line-modified">4393 const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,</span>
4394                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4395   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4396          &quot;integral arrays must be pre-equipped with a class&quot;);
4397   if (!xk)  xk = ary-&gt;ary_must_be_exact();
4398   assert(instance_id &lt;= 0 || xk, &quot;instances are always exactly typed&quot;);
<span class="line-modified">4399   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, field_offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();</span>
4400 }
4401 
4402 //------------------------------make-------------------------------------------
<span class="line-modified">4403 const TypeAryPtr* TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,</span>
4404                                    int instance_id, const TypePtr* speculative, int inline_depth,
4405                                    bool is_autobox_cache) {
4406   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4407          &quot;integral arrays must be pre-equipped with a class&quot;);
4408   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4409   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4410   assert(instance_id &lt;= 0 || xk, &quot;instances are always exactly typed&quot;);
<span class="line-modified">4411   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, field_offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();</span>
4412 }
4413 
4414 //------------------------------cast_to_ptr_type-------------------------------
4415 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4416   if( ptr == _ptr ) return this;
<span class="line-modified">4417   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
4418 }
4419 
4420 
4421 //-----------------------------cast_to_exactness-------------------------------
4422 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4423   if( klass_is_exact == _klass_is_exact ) return this;
4424   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
<span class="line-modified">4425 </span>
<span class="line-added">4426   const TypeAry* new_ary = _ary;</span>
<span class="line-added">4427   if (klass() != NULL &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp; klass_is_exact) {</span>
<span class="line-added">4428     // An object array can&#39;t be flat or null-free if the klass is exact</span>
<span class="line-added">4429     new_ary = TypeAry::make(elem(), size(), is_stable(), /* not_flat= */ true, /* not_null_free= */ true);</span>
<span class="line-added">4430   }</span>
<span class="line-added">4431   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact, _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
4432 }
4433 
4434 //-----------------------------cast_to_instance_id----------------------------
4435 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4436   if( instance_id == _instance_id ) return this;
<span class="line-modified">4437   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
4438 }
4439 
4440 
4441 //-----------------------------max_array_length-------------------------------
4442 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
4443 jint TypeAryPtr::max_array_length(BasicType etype) {
4444   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {
4445     if (etype == T_NARROWOOP) {
4446       etype = T_OBJECT;
4447     } else if (etype == T_ILLEGAL) { // bottom[]
4448       etype = T_BYTE; // will produce conservatively high value
4449     } else {
4450       fatal(&quot;not an element type: %s&quot;, type2name(etype));
4451     }
4452   }
4453   return arrayOopDesc::max_array_length(etype);
4454 }
4455 
4456 //-----------------------------narrow_size_type-------------------------------
4457 // Narrow the given size type to the index range for the given array base type.
</pre>
<hr />
<pre>
4473   if (hi &gt; max_hi) {
4474     hi = max_hi;
4475     if (size-&gt;is_con()) {
4476       lo = hi;
4477     }
4478     chg = true;
4479   }
4480   // Negative length arrays will produce weird intermediate dead fast-path code
4481   if (lo &gt; hi)
4482     return TypeInt::ZERO;
4483   if (!chg)
4484     return size;
4485   return TypeInt::make(lo, hi, Type::WidenMin);
4486 }
4487 
4488 //-------------------------------cast_to_size----------------------------------
4489 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4490   assert(new_size != NULL, &quot;&quot;);
4491   new_size = narrow_size_type(new_size);
4492   if (new_size == size())  return this;
<span class="line-modified">4493   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable(), is_not_flat(), is_not_null_free());</span>
<span class="line-modified">4494   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
<span class="line-added">4495 }</span>
<span class="line-added">4496 </span>
<span class="line-added">4497 //-------------------------------cast_to_not_flat------------------------------</span>
<span class="line-added">4498 const TypeAryPtr* TypeAryPtr::cast_to_not_flat(bool not_flat) const {</span>
<span class="line-added">4499   if (not_flat == is_not_flat()) {</span>
<span class="line-added">4500     return this;</span>
<span class="line-added">4501   }</span>
<span class="line-added">4502   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_flat, is_not_null_free());</span>
<span class="line-added">4503   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
<span class="line-added">4504 }</span>
<span class="line-added">4505 </span>
<span class="line-added">4506 //-------------------------------cast_to_not_null_free-------------------------</span>
<span class="line-added">4507 const TypeAryPtr* TypeAryPtr::cast_to_not_null_free(bool not_null_free) const {</span>
<span class="line-added">4508   if (not_null_free == is_not_null_free()) {</span>
<span class="line-added">4509     return this;</span>
<span class="line-added">4510   }</span>
<span class="line-added">4511   // Not null free implies not flat</span>
<span class="line-added">4512   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);</span>
<span class="line-added">4513   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
<span class="line-added">4514 }</span>
<span class="line-added">4515 </span>
<span class="line-added">4516 //---------------------------------update_properties---------------------------</span>
<span class="line-added">4517 const TypeAryPtr* TypeAryPtr::update_properties(const TypeAryPtr* from) const {</span>
<span class="line-added">4518   if ((from-&gt;is_flat()          &amp;&amp; is_not_flat()) ||</span>
<span class="line-added">4519       (from-&gt;is_not_flat()      &amp;&amp; is_flat()) ||</span>
<span class="line-added">4520       (from-&gt;is_null_free()     &amp;&amp; is_not_null_free()) ||</span>
<span class="line-added">4521       (from-&gt;is_not_null_free() &amp;&amp; is_null_free())) {</span>
<span class="line-added">4522     return NULL; // Inconsistent properties</span>
<span class="line-added">4523   } else if (from-&gt;is_not_null_free()) {</span>
<span class="line-added">4524     return cast_to_not_null_free(); // Implies not flat</span>
<span class="line-added">4525   } else if (from-&gt;is_not_flat()) {</span>
<span class="line-added">4526     return cast_to_not_flat();</span>
<span class="line-added">4527   }</span>
<span class="line-added">4528   return this;</span>
4529 }
4530 
4531 //------------------------------cast_to_stable---------------------------------
4532 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4533   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4534     return this;
4535 
4536   const Type* elem = this-&gt;elem();
4537   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4538 
4539   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4540     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4541     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4542   }
4543 
<span class="line-modified">4544   const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_not_flat(), is_not_null_free());</span>
4545 
<span class="line-modified">4546   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
4547 }
4548 
4549 //-----------------------------stable_dimension--------------------------------
4550 int TypeAryPtr::stable_dimension() const {
4551   if (!is_stable())  return 0;
4552   int dim = 1;
4553   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4554   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4555     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4556   return dim;
4557 }
4558 
4559 //----------------------cast_to_autobox_cache-----------------------------------
4560 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4561   if (is_autobox_cache() == cache)  return this;
4562   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4563   if (etype == NULL)  return this;
4564   // The pointers in the autobox arrays are always non-null.
4565   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4566   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-modified">4567   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable(), is_not_flat(), is_not_null_free());</span>
<span class="line-modified">4568   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, cache);</span>
4569 }
4570 
4571 //------------------------------eq---------------------------------------------
4572 // Structural equality check for Type representations
4573 bool TypeAryPtr::eq( const Type *t ) const {
4574   const TypeAryPtr *p = t-&gt;is_aryptr();
4575   return
4576     _ary == p-&gt;_ary &amp;&amp;  // Check array
<span class="line-modified">4577     TypeOopPtr::eq(p) &amp;&amp;// Check sub-parts</span>
<span class="line-added">4578     _field_offset == p-&gt;_field_offset;</span>
4579 }
4580 
4581 //------------------------------hash-------------------------------------------
4582 // Type-specific hashing function.
4583 int TypeAryPtr::hash(void) const {
<span class="line-modified">4584   return (intptr_t)_ary + TypeOopPtr::hash() + _field_offset.get();</span>
4585 }
4586 
4587 //------------------------------meet-------------------------------------------
4588 // Compute the MEET of two types.  It returns a new Type object.
4589 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4590   // Perform a fast test for common case; meeting the same types together.
4591   if( this == t ) return this;  // Meeting same type-rep?
4592   // Current &quot;this-&gt;_base&quot; is Pointer
4593   switch (t-&gt;base()) {          // switch on original type
4594 
4595   // Mixing ints &amp; oops happens when javac reuses local variables
4596   case Int:
4597   case Long:
4598   case FloatTop:
4599   case FloatCon:
4600   case FloatBot:
4601   case DoubleTop:
4602   case DoubleCon:
4603   case DoubleBot:
4604   case NarrowOop:
4605   case NarrowKlass:
4606   case Bottom:                  // Ye Olde Default
4607     return Type::BOTTOM;
4608   case Top:
4609     return this;
4610 
4611   default:                      // All else is a mistake
4612     typerr(t);
4613 
4614   case OopPtr: {                // Meeting to OopPtrs
4615     // Found a OopPtr type vs self-AryPtr type
4616     const TypeOopPtr *tp = t-&gt;is_oopptr();
<span class="line-modified">4617     Offset offset = meet_offset(tp-&gt;offset());</span>
4618     PTR ptr = meet_ptr(tp-&gt;ptr());
4619     int depth = meet_inline_depth(tp-&gt;inline_depth());
4620     const TypePtr* speculative = xmeet_speculative(tp);
4621     switch (tp-&gt;ptr()) {
4622     case TopPTR:
4623     case AnyNull: {
4624       int instance_id = meet_instance_id(InstanceTop);
4625       return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="line-modified">4626                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);</span>
4627     }
4628     case BotPTR:
4629     case NotNull: {
4630       int instance_id = meet_instance_id(tp-&gt;instance_id());
4631       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4632     }
4633     default: ShouldNotReachHere();
4634     }
4635   }
4636 
4637   case AnyPtr: {                // Meeting two AnyPtrs
4638     // Found an AnyPtr type vs self-AryPtr type
4639     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">4640     Offset offset = meet_offset(tp-&gt;offset());</span>
4641     PTR ptr = meet_ptr(tp-&gt;ptr());
4642     const TypePtr* speculative = xmeet_speculative(tp);
4643     int depth = meet_inline_depth(tp-&gt;inline_depth());
4644     switch (tp-&gt;ptr()) {
4645     case TopPTR:
4646       return this;
4647     case BotPTR:
4648     case NotNull:
4649       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4650     case Null:
4651       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4652       // else fall through to AnyNull
4653     case AnyNull: {
4654       int instance_id = meet_instance_id(InstanceTop);
4655       return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="line-modified">4656                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);</span>
4657     }
4658     default: ShouldNotReachHere();
4659     }
4660   }
4661 
4662   case MetadataPtr:
4663   case KlassPtr:
4664   case RawPtr: return TypePtr::BOTTOM;
4665 
4666   case AryPtr: {                // Meeting 2 references?
4667     const TypeAryPtr *tap = t-&gt;is_aryptr();
<span class="line-modified">4668     Offset off = meet_offset(tap-&gt;offset());</span>
<span class="line-added">4669     Offset field_off = meet_field_offset(tap-&gt;field_offset());</span>
4670     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4671     PTR ptr = meet_ptr(tap-&gt;ptr());
4672     int instance_id = meet_instance_id(tap-&gt;instance_id());
4673     const TypePtr* speculative = xmeet_speculative(tap);
4674     int depth = meet_inline_depth(tap-&gt;inline_depth());
4675     ciKlass* lazy_klass = NULL;
4676     if (tary-&gt;_elem-&gt;isa_int()) {
4677       // Integral array element types have irrelevant lattice relations.
4678       // It is the klass that determines array layout, not the element type.
4679       if (_klass == NULL)
4680         lazy_klass = tap-&gt;_klass;
4681       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4682         lazy_klass = _klass;
4683       } else {
4684         // Something like byte[int+] meets char[int+].
4685         // This must fall to bottom, not (int[-128..65535])[int+].
4686         instance_id = InstanceBot;
<span class="line-modified">4687         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);</span>
4688       }
4689     } else // Non integral arrays.
4690       // Must fall to bottom if exact klasses in upper lattice
4691       // are not equal or super klass is exact.
4692       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4693           // meet with top[] and bottom[] are processed further down:
<span class="line-modified">4694           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;</span>
4695           // both are exact and not equal:
4696           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
<span class="line-modified">4697            // &#39;tap&#39; is exact and super or unrelated:</span>
4698            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4699            // &#39;this&#39; is exact and super or unrelated:
4700            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4701       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
<span class="line-modified">4702         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);</span>
<span class="line-added">4703       }</span>
<span class="line-added">4704       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);</span>
<span class="line-added">4705     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_flat_array_klass() != tap-&gt;klass()-&gt;is_flat_array_klass()) {</span>
<span class="line-added">4706       // Meeting flattened inline type array with non-flattened array. Adjust (field) offset accordingly.</span>
<span class="line-added">4707       if (tary-&gt;_elem-&gt;isa_inlinetype()) {</span>
<span class="line-added">4708         // Result is flattened</span>
<span class="line-added">4709         off = Offset(is_flat() ? offset() : tap-&gt;offset());</span>
<span class="line-added">4710         field_off = is_flat() ? field_offset() : tap-&gt;field_offset();</span>
<span class="line-added">4711       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {</span>
<span class="line-added">4712         // Result is non-flattened</span>
<span class="line-added">4713         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));</span>
<span class="line-added">4714         field_off = Offset::bottom;</span>
4715       }

4716     }
4717 
4718     bool xk = false;
4719     switch (tap-&gt;ptr()) {
4720     case AnyNull:
4721     case TopPTR:
4722       // Compute new klass on demand, do not use tap-&gt;_klass
4723       if (below_centerline(this-&gt;_ptr)) {
4724         xk = this-&gt;_klass_is_exact;
4725       } else {
4726         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4727       }
<span class="line-modified">4728       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);</span>
4729     case Constant: {
4730       ciObject* o = const_oop();
4731       if( _ptr == Constant ) {
4732         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4733           xk = (klass() == tap-&gt;klass());
4734           ptr = NotNull;
4735           o = NULL;
4736           instance_id = InstanceBot;
4737         } else {
4738           xk = true;
4739         }
4740       } else if(above_centerline(_ptr)) {
4741         o = tap-&gt;const_oop();
4742         xk = true;
4743       } else {
4744         // Only precise for identical arrays
4745         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4746       }
<span class="line-modified">4747       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);</span>
4748     }
4749     case NotNull:
4750     case BotPTR:
4751       // Compute new klass on demand, do not use tap-&gt;_klass
4752       if (above_centerline(this-&gt;_ptr))
4753             xk = tap-&gt;_klass_is_exact;
4754       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4755               (klass() == tap-&gt;klass()); // Only precise for identical arrays
<span class="line-modified">4756       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);</span>
4757     default: ShouldNotReachHere();
4758     }
4759   }
4760 
4761   // All arrays inherit from Object class
4762   case InstPtr: {
4763     const TypeInstPtr *tp = t-&gt;is_instptr();
<span class="line-modified">4764     Offset offset = meet_offset(tp-&gt;offset());</span>
4765     PTR ptr = meet_ptr(tp-&gt;ptr());
4766     int instance_id = meet_instance_id(tp-&gt;instance_id());
4767     const TypePtr* speculative = xmeet_speculative(tp);
4768     int depth = meet_inline_depth(tp-&gt;inline_depth());
4769     switch (ptr) {
4770     case TopPTR:
4771     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4772       // For instances when a subclass meets a superclass we fall
4773       // below the centerline when the superclass is exact. We need to
4774       // do the same here.
<span class="line-modified">4775       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flatten_array()) {</span>
<span class="line-modified">4776         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);</span>
4777       } else {
4778         // cannot subclass, so the meet has to fall badly below the centerline
4779         ptr = NotNull;
4780         instance_id = InstanceBot;
<span class="line-modified">4781         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);</span>
4782       }
4783     case Constant:
4784     case NotNull:
4785     case BotPTR:                // Fall down to object klass
4786       // LCA is object_klass, but if we subclass from the top we can do better
4787       if (above_centerline(tp-&gt;ptr())) {
4788         // If &#39;tp&#39;  is above the centerline and it is Object class
4789         // then we can subclass in the Java class hierarchy.
4790         // For instances when a subclass meets a superclass we fall
4791         // below the centerline when the superclass is exact. We need
4792         // to do the same here.
<span class="line-modified">4793         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flatten_array()) {</span>
4794           // that is, my array type is a subtype of &#39;tp&#39; klass
4795           return make(ptr, (ptr == Constant ? const_oop() : NULL),
<span class="line-modified">4796                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);</span>
4797         }
4798       }
4799       // The other case cannot happen, since t cannot be a subtype of an array.
4800       // The meet falls down to Object class below centerline.
4801       if( ptr == Constant )
4802          ptr = NotNull;
4803       instance_id = InstanceBot;
<span class="line-modified">4804       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);</span>
4805     default: typerr(t);
4806     }
4807   }
<span class="line-added">4808 </span>
<span class="line-added">4809   case InlineType: {</span>
<span class="line-added">4810     const TypeInlineType* tv = t-&gt;is_inlinetype();</span>
<span class="line-added">4811     if (above_centerline(ptr())) {</span>
<span class="line-added">4812       return TypeInstPtr::NOTNULL;</span>
<span class="line-added">4813     } else {</span>
<span class="line-added">4814       PTR ptr = this-&gt;_ptr;</span>
<span class="line-added">4815       if (ptr == Constant) {</span>
<span class="line-added">4816         ptr = NotNull;</span>
<span class="line-added">4817       }</span>
<span class="line-added">4818       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());</span>
<span class="line-added">4819     }</span>
<span class="line-added">4820   }</span>
4821   }
4822   return this;                  // Lint noise
4823 }
4824 
4825 //------------------------------xdual------------------------------------------
4826 // Dual: compute field-by-field dual
4827 const Type *TypeAryPtr::xdual() const {
<span class="line-modified">4828   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());</span>
<span class="line-added">4829 }</span>
<span class="line-added">4830 </span>
<span class="line-added">4831 Type::Offset TypeAryPtr::meet_field_offset(const Type::Offset offset) const {</span>
<span class="line-added">4832   return _field_offset.meet(offset);</span>
<span class="line-added">4833 }</span>
<span class="line-added">4834 </span>
<span class="line-added">4835 //------------------------------dual_offset------------------------------------</span>
<span class="line-added">4836 Type::Offset TypeAryPtr::dual_field_offset() const {</span>
<span class="line-added">4837   return _field_offset.dual();</span>
4838 }
4839 
4840 //----------------------interface_vs_oop---------------------------------------
4841 #ifdef ASSERT
4842 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4843   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4844   if (t_aryptr) {
4845     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4846   }
4847   return false;
4848 }
4849 #endif
4850 
4851 //------------------------------dump2------------------------------------------
4852 #ifndef PRODUCT
4853 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4854   _ary-&gt;dump2(d,depth,st);
4855   switch( _ptr ) {
4856   case Constant:
4857     const_oop()-&gt;print(st);
4858     break;
4859   case BotPTR:
4860     if (!WizardMode &amp;&amp; !Verbose) {
4861       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4862       break;
4863     }
4864   case TopPTR:
4865   case AnyNull:
4866   case NotNull:
4867     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4868     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4869     break;
4870   default:
4871     break;
4872   }
4873 
<span class="line-modified">4874   if (is_flat()) {</span>
<span class="line-added">4875     st-&gt;print(&quot;(&quot;);</span>
<span class="line-added">4876     _field_offset.dump2(st);</span>
<span class="line-added">4877     st-&gt;print(&quot;)&quot;);</span>
<span class="line-added">4878   }</span>
<span class="line-added">4879   if (offset() != 0) {</span>
4880     int header_size = objArrayOopDesc::header_size() * wordSize;
<span class="line-modified">4881     if( _offset == Offset::top )       st-&gt;print(&quot;+undefined&quot;);</span>
<span class="line-modified">4882     else if( _offset == Offset::bottom )  st-&gt;print(&quot;+any&quot;);</span>
<span class="line-modified">4883     else if( offset() &lt; header_size ) st-&gt;print(&quot;+%d&quot;, offset());</span>
4884     else {
4885       BasicType basic_elem_type = elem()-&gt;basic_type();
4886       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4887       int elem_size = type2aelembytes(basic_elem_type);
<span class="line-modified">4888       st-&gt;print(&quot;[%d]&quot;, (offset() - array_base)/elem_size);</span>
4889     }
4890   }
4891   st-&gt;print(&quot; *&quot;);
4892   if (_instance_id == InstanceTop)
4893     st-&gt;print(&quot;,iid=top&quot;);
4894   else if (_instance_id != InstanceBot)
4895     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4896 
4897   dump_inline_depth(st);
4898   dump_speculative(st);
4899 }
4900 #endif
4901 
4902 bool TypeAryPtr::empty(void) const {
4903   if (_ary-&gt;empty())       return true;
4904   return TypeOopPtr::empty();
4905 }
4906 
4907 //------------------------------add_offset-------------------------------------
4908 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
<span class="line-modified">4909   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _field_offset, _instance_id, add_offset_speculative(offset), _inline_depth, _is_autobox_cache);</span>
4910 }
4911 
4912 const Type *TypeAryPtr::remove_speculative() const {
4913   if (_speculative == NULL) {
4914     return this;
4915   }
4916   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="line-modified">4917   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, NULL, _inline_depth, _is_autobox_cache);</span>
<span class="line-added">4918 }</span>
<span class="line-added">4919 </span>
<span class="line-added">4920 const Type* TypeAryPtr::cleanup_speculative() const {</span>
<span class="line-added">4921   if (speculative() == NULL) {</span>
<span class="line-added">4922     return this;</span>
<span class="line-added">4923   }</span>
<span class="line-added">4924   // Keep speculative part if it contains information about flat-/nullability</span>
<span class="line-added">4925   const TypeAryPtr* spec_aryptr = speculative()-&gt;isa_aryptr();</span>
<span class="line-added">4926   if (spec_aryptr != NULL &amp;&amp; (spec_aryptr-&gt;is_not_flat() || spec_aryptr-&gt;is_not_null_free())) {</span>
<span class="line-added">4927     return this;</span>
<span class="line-added">4928   }</span>
<span class="line-added">4929   return TypeOopPtr::cleanup_speculative();</span>
4930 }
4931 
4932 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4933   if (!UseInlineDepthForSpeculativeTypes) {
4934     return this;
4935   }
<span class="line-modified">4936   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, _speculative, depth, _is_autobox_cache);</span>
<span class="line-added">4937 }</span>
<span class="line-added">4938 </span>
<span class="line-added">4939 const TypeAryPtr* TypeAryPtr::with_field_offset(int offset) const {</span>
<span class="line-added">4940   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, Offset(offset), _instance_id, _speculative, _inline_depth, _is_autobox_cache);</span>
<span class="line-added">4941 }</span>
<span class="line-added">4942 </span>
<span class="line-added">4943 const TypePtr* TypeAryPtr::add_field_offset_and_offset(intptr_t offset) const {</span>
<span class="line-added">4944   int adj = 0;</span>
<span class="line-added">4945   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop) {</span>
<span class="line-added">4946     const Type* elemtype = elem();</span>
<span class="line-added">4947     if (elemtype-&gt;isa_inlinetype()) {</span>
<span class="line-added">4948       if (_offset.get() != OffsetBot &amp;&amp; _offset.get() != OffsetTop) {</span>
<span class="line-added">4949         adj = _offset.get();</span>
<span class="line-added">4950         offset += _offset.get();</span>
<span class="line-added">4951       }</span>
<span class="line-added">4952       uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);</span>
<span class="line-added">4953       if (_field_offset.get() != OffsetBot &amp;&amp; _field_offset.get() != OffsetTop) {</span>
<span class="line-added">4954         offset += _field_offset.get();</span>
<span class="line-added">4955         if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {</span>
<span class="line-added">4956           offset += header;</span>
<span class="line-added">4957         }</span>
<span class="line-added">4958       }</span>
<span class="line-added">4959       if (offset &gt;= (intptr_t)header || offset &lt; 0) {</span>
<span class="line-added">4960         // Try to get the field of the inline type array element we are pointing to</span>
<span class="line-added">4961         ciKlass* arytype_klass = klass();</span>
<span class="line-added">4962         ciFlatArrayKlass* vak = arytype_klass-&gt;as_flat_array_klass();</span>
<span class="line-added">4963         ciInlineKlass* vk = vak-&gt;element_klass()-&gt;as_inline_klass();</span>
<span class="line-added">4964         int shift = vak-&gt;log2_element_size();</span>
<span class="line-added">4965         int mask = (1 &lt;&lt; shift) - 1;</span>
<span class="line-added">4966         intptr_t field_offset = ((offset - header) &amp; mask);</span>
<span class="line-added">4967         ciField* field = vk-&gt;get_field_by_offset(field_offset + vk-&gt;first_field_offset(), false);</span>
<span class="line-added">4968         if (field == NULL) {</span>
<span class="line-added">4969           // This may happen with nested AddP(base, AddP(base, base, offset), longcon(16))</span>
<span class="line-added">4970           return add_offset(offset);</span>
<span class="line-added">4971         } else {</span>
<span class="line-added">4972           return with_field_offset(field_offset)-&gt;add_offset(offset - field_offset - adj);</span>
<span class="line-added">4973         }</span>
<span class="line-added">4974       }</span>
<span class="line-added">4975     }</span>
<span class="line-added">4976   }</span>
<span class="line-added">4977   return add_offset(offset - adj);</span>
<span class="line-added">4978 }</span>
<span class="line-added">4979 </span>
<span class="line-added">4980 // Return offset incremented by field_offset for flattened inline type arrays</span>
<span class="line-added">4981 const int TypeAryPtr::flattened_offset() const {</span>
<span class="line-added">4982   int offset = _offset.get();</span>
<span class="line-added">4983   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop &amp;&amp;</span>
<span class="line-added">4984       _field_offset != Offset::bottom &amp;&amp; _field_offset != Offset::top) {</span>
<span class="line-added">4985     offset += _field_offset.get();</span>
<span class="line-added">4986   }</span>
<span class="line-added">4987   return offset;</span>
4988 }
4989 
4990 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4991   assert(is_known_instance(), &quot;should be known&quot;);
<span class="line-modified">4992   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth);</span>
4993 }
4994 
4995 //=============================================================================
4996 
<span class="line-added">4997 </span>
4998 //------------------------------hash-------------------------------------------
4999 // Type-specific hashing function.
5000 int TypeNarrowPtr::hash(void) const {
5001   return _ptrtype-&gt;hash() + 7;
5002 }
5003 
5004 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
5005   return _ptrtype-&gt;singleton();
5006 }
5007 
5008 bool TypeNarrowPtr::empty(void) const {
5009   return _ptrtype-&gt;empty();
5010 }
5011 
5012 intptr_t TypeNarrowPtr::get_con() const {
5013   return _ptrtype-&gt;get_con();
5014 }
5015 
5016 bool TypeNarrowPtr::eq( const Type *t ) const {
5017   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
</pre>
<hr />
<pre>
5066   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
5067   switch (t-&gt;base()) {          // switch on original type
5068 
5069   case Int:                     // Mixing ints &amp; oops happens when javac
5070   case Long:                    // reuses local variables
5071   case FloatTop:
5072   case FloatCon:
5073   case FloatBot:
5074   case DoubleTop:
5075   case DoubleCon:
5076   case DoubleBot:
5077   case AnyPtr:
5078   case RawPtr:
5079   case OopPtr:
5080   case InstPtr:
5081   case AryPtr:
5082   case MetadataPtr:
5083   case KlassPtr:
5084   case NarrowOop:
5085   case NarrowKlass:

5086   case Bottom:                  // Ye Olde Default
5087     return Type::BOTTOM;
5088   case Top:
5089     return this;
5090 
<span class="line-added">5091   case InlineType:</span>
<span class="line-added">5092     return t-&gt;xmeet(this);</span>
<span class="line-added">5093 </span>
5094   default:                      // All else is a mistake
5095     typerr(t);
5096 
5097   } // End of switch
5098 
5099   return this;
5100 }
5101 
5102 #ifndef PRODUCT
5103 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5104   _ptrtype-&gt;dump2(d, depth, st);
5105 }
5106 #endif
5107 
5108 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
5109 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
5110 
5111 
5112 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
5113   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
</pre>
<hr />
<pre>
5152     return (one == two) &amp;&amp; TypePtr::eq(t);
5153   } else {
5154     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
5155   }
5156 }
5157 
5158 //------------------------------hash-------------------------------------------
5159 // Type-specific hashing function.
5160 int TypeMetadataPtr::hash(void) const {
5161   return
5162     (metadata() ? metadata()-&gt;hash() : 0) +
5163     TypePtr::hash();
5164 }
5165 
5166 //------------------------------singleton--------------------------------------
5167 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5168 // constants
5169 bool TypeMetadataPtr::singleton(void) const {
5170   // detune optimizer to not generate constant metadata + constant offset as a constant!
5171   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">5172   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);</span>
5173 }
5174 
5175 //------------------------------add_offset-------------------------------------
5176 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
5177   return make( _ptr, _metadata, xadd_offset(offset));
5178 }
5179 
5180 //-----------------------------filter------------------------------------------
5181 // Do not allow interface-vs.-noninterface joins to collapse to top.
5182 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
5183   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
5184   if (ft == NULL || ft-&gt;empty())
5185     return Type::TOP;           // Canonical empty value
5186   return ft;
5187 }
5188 
5189  //------------------------------get_con----------------------------------------
5190 intptr_t TypeMetadataPtr::get_con() const {
5191   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-modified">5192   assert(offset() &gt;= 0, &quot;&quot;);</span>
5193 
<span class="line-modified">5194   if (offset() != 0) {</span>
5195     // After being ported to the compiler interface, the compiler no longer
5196     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5197     // to a handle at compile time.  This handle is embedded in the generated
5198     // code and dereferenced at the time the nmethod is made.  Until that time,
5199     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5200     // have access to the addresses!).  This does not seem to currently happen,
5201     // but this assertion here is to help prevent its occurence.
5202     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5203     ShouldNotReachHere();
5204   }
5205 
5206   return (intptr_t)metadata()-&gt;constant_encoding();
5207 }
5208 
5209 //------------------------------cast_to_ptr_type-------------------------------
5210 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
5211   if( ptr == _ptr ) return this;
5212   return make(ptr, metadata(), _offset);
5213 }
5214 
</pre>
<hr />
<pre>
5225   case Long:                    // reuses local variables
5226   case FloatTop:
5227   case FloatCon:
5228   case FloatBot:
5229   case DoubleTop:
5230   case DoubleCon:
5231   case DoubleBot:
5232   case NarrowOop:
5233   case NarrowKlass:
5234   case Bottom:                  // Ye Olde Default
5235     return Type::BOTTOM;
5236   case Top:
5237     return this;
5238 
5239   default:                      // All else is a mistake
5240     typerr(t);
5241 
5242   case AnyPtr: {
5243     // Found an AnyPtr type vs self-OopPtr type
5244     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">5245     Offset offset = meet_offset(tp-&gt;offset());</span>
5246     PTR ptr = meet_ptr(tp-&gt;ptr());
5247     switch (tp-&gt;ptr()) {
5248     case Null:
5249       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5250       // else fall through:
5251     case TopPTR:
5252     case AnyNull: {
5253       return make(ptr, _metadata, offset);
5254     }
5255     case BotPTR:
5256     case NotNull:
5257       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5258     default: typerr(t);
5259     }
5260   }
5261 
5262   case RawPtr:
5263   case KlassPtr:
5264   case OopPtr:
5265   case InstPtr:
5266   case AryPtr:
5267     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
5268 
5269   case MetadataPtr: {
5270     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
<span class="line-modified">5271     Offset offset = meet_offset(tp-&gt;offset());</span>
5272     PTR tptr = tp-&gt;ptr();
5273     PTR ptr = meet_ptr(tptr);
5274     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
5275     if (tptr == TopPTR || _ptr == TopPTR ||
5276         metadata()-&gt;equals(tp-&gt;metadata())) {
5277       return make(ptr, md, offset);
5278     }
5279     // metadata is different
5280     if( ptr == Constant ) {  // Cannot be equal constants, so...
5281       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
5282       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
5283       ptr = NotNull;            // Fall down in lattice
5284     }
5285     return make(ptr, NULL, offset);
5286     break;
5287   }
5288   } // End of switch
5289   return this;                  // Return the double constant
5290 }
5291 
5292 
5293 //------------------------------xdual------------------------------------------
5294 // Dual of a pure metadata pointer.
5295 const Type *TypeMetadataPtr::xdual() const {
5296   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
5297 }
5298 
5299 //------------------------------dump2------------------------------------------
5300 #ifndef PRODUCT
5301 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5302   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
5303   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
<span class="line-modified">5304   switch (offset()) {</span>
5305   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
5306   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
5307   case         0: break;
<span class="line-modified">5308   default:        st-&gt;print(&quot;+%d&quot;,offset()); break;</span>
5309   }
5310 }
5311 #endif
5312 
5313 
5314 //=============================================================================
5315 // Convenience common pre-built type.
5316 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
5317 
<span class="line-modified">5318 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset):</span>
5319   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
5320 }
5321 
5322 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
<span class="line-modified">5323   return make(Constant, m, Offset(0));</span>
5324 }
5325 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
<span class="line-modified">5326   return make(Constant, m, Offset(0));</span>
5327 }
5328 
5329 //------------------------------make-------------------------------------------
5330 // Create a meta data constant
<span class="line-modified">5331 const TypeMetadataPtr* TypeMetadataPtr::make(PTR ptr, ciMetadata* m, Offset offset) {</span>
5332   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
5333   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
5334 }
5335 
5336 
5337 //=============================================================================
5338 // Convenience common pre-built types.
5339 
5340 // Not-null object klass or below
5341 const TypeKlassPtr *TypeKlassPtr::OBJECT;
5342 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
5343 
5344 //------------------------------TypeKlassPtr-----------------------------------
<span class="line-modified">5345 TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flatten_array)</span>
<span class="line-modified">5346   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flatten_array(flatten_array) {</span>
<span class="line-added">5347   assert(!klass-&gt;flatten_array() || flatten_array, &quot;Should be flat in array&quot;);</span>
<span class="line-added">5348   assert(!flatten_array || can_be_inline_type(), &quot;Only inline types can be flat in array&quot;);</span>
5349 }
5350 
5351 //------------------------------make-------------------------------------------
5352 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
<span class="line-modified">5353 const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array) {</span>
<span class="line-modified">5354   assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);</span>
<span class="line-modified">5355   // Check if this type is known to be flat in arrays</span>
<span class="line-modified">5356   flatten_array = flatten_array || k-&gt;flatten_array();</span>
<span class="line-modified">5357   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flatten_array))-&gt;hashcons();</span>


5358 }
5359 
5360 //------------------------------eq---------------------------------------------
5361 // Structural equality check for Type representations
5362 bool TypeKlassPtr::eq( const Type *t ) const {
5363   const TypeKlassPtr *p = t-&gt;is_klassptr();
<span class="line-modified">5364   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flatten_array() == p-&gt;flatten_array();</span>


5365 }
5366 
5367 //------------------------------hash-------------------------------------------
5368 // Type-specific hashing function.
5369 int TypeKlassPtr::hash(void) const {
<span class="line-modified">5370   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flatten_array());</span>
5371 }
5372 
5373 //------------------------------singleton--------------------------------------
5374 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5375 // constants
5376 bool TypeKlassPtr::singleton(void) const {
5377   // detune optimizer to not generate constant klass + constant offset as a constant!
5378   // TopPTR, Null, AnyNull, Constant are all singletons
<span class="line-modified">5379   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);</span>
5380 }
5381 
5382 // Do not allow interface-vs.-noninterface joins to collapse to top.
5383 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
5384   // logic here mirrors the one from TypeOopPtr::filter. See comments
5385   // there.
5386   const Type* ft = join_helper(kills, include_speculative);
5387   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
5388   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
5389 
5390   if (ft-&gt;empty()) {
<span class="line-modified">5391     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())</span>
5392       return kills;             // Uplift to interface
5393 
5394     return Type::TOP;           // Canonical empty value
5395   }
5396 
5397   // Interface klass type could be exact in opposite to interface type,
5398   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
5399   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
5400       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
5401       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
5402       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
5403     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
5404   }
5405 
5406   return ft;
5407 }
5408 
5409 //----------------------compute_klass------------------------------------------
5410 // Compute the defining klass for this class
5411 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
5412   // Compute _klass based on element type.
5413   ciKlass* k_ary = NULL;

5414   const TypeAryPtr *tary;
5415   const Type* el = elem();
5416   if (el-&gt;isa_narrowoop()) {
5417     el = el-&gt;make_ptr();
5418   }
5419 
5420   // Get element klass
<span class="line-modified">5421   if (el-&gt;isa_instptr()) {</span>
<span class="line-modified">5422     // Compute object array klass from element klass</span>
<span class="line-modified">5423     k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass());</span>
<span class="line-added">5424   } else if (el-&gt;isa_inlinetype()) {</span>
<span class="line-added">5425     // If element type is TypeInlineType::BOTTOM, inline_klass() will be null.</span>
<span class="line-added">5426     if (el-&gt;inline_klass() != NULL) {</span>
<span class="line-added">5427       k_ary = ciArrayKlass::make(el-&gt;inline_klass());</span>
<span class="line-added">5428     }</span>
5429   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
5430     // Compute array klass from element klass
5431     ciKlass* k_elem = tary-&gt;klass();
5432     // If element type is something like bottom[], k_elem will be null.
5433     if (k_elem != NULL)
5434       k_ary = ciObjArrayKlass::make(k_elem);
5435   } else if ((el-&gt;base() == Type::Top) ||
5436              (el-&gt;base() == Type::Bottom)) {
5437     // element type of Bottom occurs from meet of basic type
5438     // and object; Top occurs when doing join on Bottom.
5439     // Leave k_ary at NULL.
5440   } else {
5441     // Cannot compute array klass directly from basic type,
5442     // since subtypes of TypeInt all have basic type T_INT.
5443 #ifdef ASSERT
5444     if (verify &amp;&amp; el-&gt;isa_int()) {
5445       // Check simple cases when verifying klass.
5446       BasicType bt = T_ILLEGAL;
5447       if (el == TypeInt::BYTE) {
5448         bt = T_BYTE;
</pre>
<hr />
<pre>
5473 
5474   // Oops, need to compute _klass and cache it
5475   ciKlass* k_ary = compute_klass();
5476 
5477   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
5478     // The _klass field acts as a cache of the underlying
5479     // ciKlass for this array type.  In order to set the field,
5480     // we need to cast away const-ness.
5481     //
5482     // IMPORTANT NOTE: we *never* set the _klass field for the
5483     // type TypeAryPtr::OOPS.  This Type is shared between all
5484     // active compilations.  However, the ciKlass which represents
5485     // this Type is *not* shared between compilations, so caching
5486     // this value would result in fetching a dangling pointer.
5487     //
5488     // Recomputing the underlying ciKlass for each request is
5489     // a bit less efficient than caching, but calls to
5490     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5491     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5492     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
<span class="line-modified">5493         offset() != 0 &amp;&amp; offset() != arrayOopDesc::length_offset_in_bytes()) {</span>
5494       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5495     }
5496   }
5497   return k_ary;
5498 }
5499 
5500 
5501 //------------------------------add_offset-------------------------------------
5502 // Access internals of klass object
5503 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
<span class="line-modified">5504   return make(_ptr, klass(), xadd_offset(offset), flatten_array());</span>
5505 }
5506 
5507 //------------------------------cast_to_ptr_type-------------------------------
5508 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5509   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5510   if( ptr == _ptr ) return this;
<span class="line-modified">5511   return make(ptr, _klass, _offset, _flatten_array);</span>
5512 }
5513 
5514 
5515 //-----------------------------cast_to_exactness-------------------------------
5516 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5517   if( klass_is_exact == _klass_is_exact ) return this;
<span class="line-modified">5518   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flatten_array);</span>
5519 }
5520 
5521 
5522 //-----------------------------as_instance_type--------------------------------
5523 // Corresponding type for an instance of the given class.
5524 // It will be NotNull, and exact if and only if the klass type is exact.
5525 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5526   ciKlass* k = klass();
<span class="line-added">5527   assert(k != NULL, &quot;klass should not be NULL&quot;);</span>
5528   bool    xk = klass_is_exact();
5529   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5530   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5531   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5532   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-added">5533   if (flatten_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
<span class="line-added">5534     toop = toop-&gt;is_instptr()-&gt;cast_to_flatten_array();</span>
<span class="line-added">5535   }</span>
5536   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5537 }
5538 
5539 
5540 //------------------------------xmeet------------------------------------------
5541 // Compute the MEET of two types, return a new Type object.
5542 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5543   // Perform a fast test for common case; meeting the same types together.
5544   if( this == t ) return this;  // Meeting same type-rep?
5545 
5546   // Current &quot;this-&gt;_base&quot; is Pointer
5547   switch (t-&gt;base()) {          // switch on original type
5548 
5549   case Int:                     // Mixing ints &amp; oops happens when javac
5550   case Long:                    // reuses local variables
5551   case FloatTop:
5552   case FloatCon:
5553   case FloatBot:
5554   case DoubleTop:
5555   case DoubleCon:
5556   case DoubleBot:
5557   case NarrowOop:
5558   case NarrowKlass:
5559   case Bottom:                  // Ye Olde Default
5560     return Type::BOTTOM;
5561   case Top:
5562     return this;
5563 
5564   default:                      // All else is a mistake
5565     typerr(t);
5566 
5567   case AnyPtr: {                // Meeting to AnyPtrs
5568     // Found an AnyPtr type vs self-KlassPtr type
5569     const TypePtr *tp = t-&gt;is_ptr();
<span class="line-modified">5570     Offset offset = meet_offset(tp-&gt;offset());</span>
5571     PTR ptr = meet_ptr(tp-&gt;ptr());
5572     switch (tp-&gt;ptr()) {
5573     case TopPTR:
5574       return this;
5575     case Null:
5576       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5577     case AnyNull:
<span class="line-modified">5578       return make(ptr, klass(), offset, flatten_array());</span>
5579     case BotPTR:
5580     case NotNull:
5581       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5582     default: typerr(t);
5583     }
5584   }
5585 
5586   case RawPtr:
5587   case MetadataPtr:
5588   case OopPtr:
5589   case AryPtr:                  // Meet with AryPtr
5590   case InstPtr:                 // Meet with InstPtr
5591     return TypePtr::BOTTOM;
5592 
5593   //
5594   //             A-top         }
5595   //           /   |   \       }  Tops
5596   //       B-top A-any C-top   }
5597   //          | /  |  \ |      }  Any-nulls
5598   //       B-any   |   C-any   }
5599   //          |    |    |
5600   //       B-con A-con C-con   } constants; not comparable across classes
5601   //          |    |    |
5602   //       B-not   |   C-not   }
5603   //          | \  |  / |      }  not-nulls
5604   //       B-bot A-not C-bot   }
5605   //           \   |   /       }  Bottoms
5606   //             A-bot         }
5607   //
5608 
5609   case KlassPtr: {  // Meet two KlassPtr types
5610     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
<span class="line-modified">5611     Offset  off  = meet_offset(tkls-&gt;offset());</span>
5612     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5613 
<span class="line-added">5614     if (klass() == NULL || tkls-&gt;klass() == NULL) {</span>
<span class="line-added">5615       ciKlass* k = NULL;</span>
<span class="line-added">5616       if (ptr == Constant) {</span>
<span class="line-added">5617         k = (klass() == NULL) ? tkls-&gt;klass() : klass();</span>
<span class="line-added">5618       }</span>
<span class="line-added">5619       return make(ptr, k, off);</span>
<span class="line-added">5620     }</span>
<span class="line-added">5621 </span>
5622     // Check for easy case; klasses are equal (and perhaps not loaded!)
5623     // If we have constants, then we created oops so classes are loaded
5624     // and we can handle the constants further down.  This case handles
5625     // not-loaded classes
<span class="line-modified">5626     if (ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) &amp;&amp; flatten_array() == tkls-&gt;flatten_array()) {</span>
<span class="line-modified">5627       return make(ptr, klass(), off, flatten_array());</span>
5628     }
5629 
5630     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5631     ciKlass* tkls_klass = tkls-&gt;klass();
5632     ciKlass* this_klass = this-&gt;klass();
5633     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5634     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
<span class="line-added">5635     bool tkls_flatten_array = tkls-&gt;flatten_array();</span>
<span class="line-added">5636     bool this_flatten_array  = this-&gt;flatten_array();</span>
<span class="line-added">5637     bool flatten_array = below_centerline(ptr) ? (this_flatten_array &amp;&amp; tkls_flatten_array) : (this_flatten_array || tkls_flatten_array);</span>
5638 
5639     // If &#39;this&#39; type is above the centerline and is a superclass of the
5640     // other, we can treat &#39;this&#39; as having the same type as the other.
5641     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5642         tkls_klass-&gt;is_subtype_of(this_klass)) {
5643       this_klass = tkls_klass;
5644     }
5645     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5646     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5647     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5648         this_klass-&gt;is_subtype_of(tkls_klass)) {
5649       tkls_klass = this_klass;
5650     }
5651 
5652     // Check for classes now being equal
5653     if (tkls_klass-&gt;equals(this_klass)) {
5654       // If the klasses are equal, the constants may still differ.  Fall to
5655       // NotNull if they do (neither constant is NULL; that is a special case
5656       // handled elsewhere).
5657       if( ptr == Constant ) {
5658         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5659             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5660         else if (above_centerline(this-&gt;ptr()));
5661         else if (above_centerline(tkls-&gt;ptr()));
5662         else
5663           ptr = NotNull;
5664       }
<span class="line-modified">5665       return make(ptr, this_klass, off, flatten_array);</span>
5666     } // Else classes are not equal
5667 
5668     // Since klasses are different, we require the LCA in the Java
5669     // class hierarchy - which means we have to fall to at least NotNull.
5670     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5671       ptr = NotNull;
5672     // Now we find the LCA of Java classes
5673     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="line-modified">5674     return   make(ptr, k, off);</span>
5675   } // End of case KlassPtr
5676 
5677   } // End of switch
5678   return this;                  // Return the double constant
5679 }
5680 
5681 //------------------------------xdual------------------------------------------
5682 // Dual: compute field-by-field dual
5683 const Type    *TypeKlassPtr::xdual() const {
<span class="line-modified">5684   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flatten_array());</span>
5685 }
5686 
5687 //------------------------------get_con----------------------------------------
5688 intptr_t TypeKlassPtr::get_con() const {
5689   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-modified">5690   assert(offset() &gt;= 0, &quot;&quot;);</span>
5691 
<span class="line-modified">5692   if (offset() != 0) {</span>
5693     // After being ported to the compiler interface, the compiler no longer
5694     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5695     // to a handle at compile time.  This handle is embedded in the generated
5696     // code and dereferenced at the time the nmethod is made.  Until that time,
5697     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5698     // have access to the addresses!).  This does not seem to currently happen,
5699     // but this assertion here is to help prevent its occurence.
5700     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5701     ShouldNotReachHere();
5702   }
5703 
5704   return (intptr_t)klass()-&gt;constant_encoding();
5705 }
5706 //------------------------------dump2------------------------------------------
5707 // Dump Klass Type
5708 #ifndef PRODUCT
5709 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5710   switch( _ptr ) {
5711   case Constant:
5712     st-&gt;print(&quot;precise &quot;);
5713   case NotNull:
5714     {
<span class="line-modified">5715       if (klass() != NULL) {</span>
<span class="line-modified">5716         const char* name = klass()-&gt;name()-&gt;as_utf8();</span>
5717         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5718       } else {
<span class="line-modified">5719         st-&gt;print(&quot;klass BOTTOM&quot;);</span>
5720       }
5721     }
5722   case BotPTR:
5723     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5724   case TopPTR:
5725   case AnyNull:
5726     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5727     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5728     break;
5729   default:
5730     break;
5731   }
5732 
<span class="line-modified">5733   _offset.dump2(st);</span>




5734 
5735   st-&gt;print(&quot; *&quot;);
5736 }
5737 #endif
5738 
5739 
5740 
5741 //=============================================================================
5742 // Convenience common pre-built types.
5743 
5744 //------------------------------make-------------------------------------------
<span class="line-modified">5745 const TypeFunc *TypeFunc::make(const TypeTuple *domain_sig, const TypeTuple* domain_cc,</span>
<span class="line-modified">5746                                const TypeTuple *range_sig, const TypeTuple *range_cc) {</span>
<span class="line-added">5747   return (TypeFunc*)(new TypeFunc(domain_sig, domain_cc, range_sig, range_cc))-&gt;hashcons();</span>
<span class="line-added">5748 }</span>
<span class="line-added">5749 </span>
<span class="line-added">5750 const TypeFunc *TypeFunc::make(const TypeTuple *domain, const TypeTuple *range) {</span>
<span class="line-added">5751   return make(domain, domain, range, range);</span>
<span class="line-added">5752 }</span>
<span class="line-added">5753 </span>
<span class="line-added">5754 //------------------------------osr_domain-----------------------------</span>
<span class="line-added">5755 const TypeTuple* osr_domain() {</span>
<span class="line-added">5756   const Type **fields = TypeTuple::fields(2);</span>
<span class="line-added">5757   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer</span>
<span class="line-added">5758   return TypeTuple::make(TypeFunc::Parms+1, fields);</span>
5759 }
5760 
5761 //------------------------------make-------------------------------------------
<span class="line-modified">5762 const TypeFunc* TypeFunc::make(ciMethod* method, bool is_osr_compilation) {</span>
5763   Compile* C = Compile::current();
<span class="line-modified">5764   const TypeFunc* tf = NULL;</span>
<span class="line-modified">5765   if (!is_osr_compilation) {</span>
<span class="line-modified">5766     tf = C-&gt;last_tf(method); // check cache</span>
<span class="line-modified">5767     if (tf != NULL)  return tf;  // The hit rate here is almost 50%.</span>
<span class="line-modified">5768   }</span>
<span class="line-modified">5769   // Inline types are not passed/returned by reference, instead each field of</span>
<span class="line-modified">5770   // the inline type is passed/returned as an argument. We maintain two views of</span>
<span class="line-added">5771   // the argument/return list here: one based on the signature (with an inline</span>
<span class="line-added">5772   // type argument/return as a single slot), one based on the actual calling</span>
<span class="line-added">5773   // convention (with an inline type argument/return as a list of its fields).</span>
<span class="line-added">5774   bool has_scalar_args = method-&gt;has_scalarized_args() &amp;&amp; !is_osr_compilation;</span>
<span class="line-added">5775   const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);</span>
<span class="line-added">5776   const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;</span>
<span class="line-added">5777   ciSignature* sig = method-&gt;signature();</span>
<span class="line-added">5778   bool has_scalar_ret = sig-&gt;return_type()-&gt;is_inlinetype() &amp;&amp; sig-&gt;return_type()-&gt;as_inline_klass()-&gt;can_be_returned_as_fields();</span>
<span class="line-added">5779   const TypeTuple* range_sig = TypeTuple::make_range(sig, false);</span>
<span class="line-added">5780   const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;</span>
<span class="line-added">5781   tf = TypeFunc::make(domain_sig, domain_cc, range_sig, range_cc);</span>
<span class="line-added">5782   if (!is_osr_compilation) {</span>
<span class="line-added">5783     C-&gt;set_last_tf(method, tf);  // fill cache</span>
5784   }



5785   return tf;
5786 }
5787 
5788 //------------------------------meet-------------------------------------------
5789 // Compute the MEET of two types.  It returns a new Type object.
5790 const Type *TypeFunc::xmeet( const Type *t ) const {
5791   // Perform a fast test for common case; meeting the same types together.
5792   if( this == t ) return this;  // Meeting same type-rep?
5793 
5794   // Current &quot;this-&gt;_base&quot; is Func
5795   switch (t-&gt;base()) {          // switch on original type
5796 
5797   case Bottom:                  // Ye Olde Default
5798     return t;
5799 
5800   default:                      // All else is a mistake
5801     typerr(t);
5802 
5803   case Top:
5804     break;
5805   }
5806   return this;                  // Return the double constant
5807 }
5808 
5809 //------------------------------xdual------------------------------------------
5810 // Dual: compute field-by-field dual
5811 const Type *TypeFunc::xdual() const {
5812   return this;
5813 }
5814 
5815 //------------------------------eq---------------------------------------------
5816 // Structural equality check for Type representations
5817 bool TypeFunc::eq( const Type *t ) const {
5818   const TypeFunc *a = (const TypeFunc*)t;
<span class="line-modified">5819   return _domain_sig == a-&gt;_domain_sig &amp;&amp;</span>
<span class="line-modified">5820     _domain_cc == a-&gt;_domain_cc &amp;&amp;</span>
<span class="line-added">5821     _range_sig == a-&gt;_range_sig &amp;&amp;</span>
<span class="line-added">5822     _range_cc == a-&gt;_range_cc;</span>
5823 }
5824 
5825 //------------------------------hash-------------------------------------------
5826 // Type-specific hashing function.
5827 int TypeFunc::hash(void) const {
<span class="line-modified">5828   return (intptr_t)_domain_sig + (intptr_t)_domain_cc + (intptr_t)_range_sig + (intptr_t)_range_cc;</span>
5829 }
5830 
5831 //------------------------------dump2------------------------------------------
5832 // Dump Function Type
5833 #ifndef PRODUCT
5834 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
<span class="line-modified">5835   if( _range_sig-&gt;cnt() &lt;= Parms )</span>
5836     st-&gt;print(&quot;void&quot;);
5837   else {
5838     uint i;
<span class="line-modified">5839     for (i = Parms; i &lt; _range_sig-&gt;cnt()-1; i++) {</span>
<span class="line-modified">5840       _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);</span>
5841       st-&gt;print(&quot;/&quot;);
5842     }
<span class="line-modified">5843     _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);</span>
5844   }
5845   st-&gt;print(&quot; &quot;);
5846   st-&gt;print(&quot;( &quot;);
5847   if( !depth || d[this] ) {     // Check for recursive dump
5848     st-&gt;print(&quot;...)&quot;);
5849     return;
5850   }
5851   d.Insert((void*)this,(void*)this);    // Stop recursion
<span class="line-modified">5852   if (Parms &lt; _domain_sig-&gt;cnt())</span>
<span class="line-modified">5853     _domain_sig-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);</span>
<span class="line-modified">5854   for (uint i = Parms+1; i &lt; _domain_sig-&gt;cnt(); i++) {</span>
5855     st-&gt;print(&quot;, &quot;);
<span class="line-modified">5856     _domain_sig-&gt;field_at(i)-&gt;dump2(d,depth-1,st);</span>
5857   }
5858   st-&gt;print(&quot; )&quot;);
5859 }
5860 #endif
5861 
5862 //------------------------------singleton--------------------------------------
5863 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5864 // constants (Ldi nodes).  Singletons are integer, float or double constants
5865 // or a single symbol.
5866 bool TypeFunc::singleton(void) const {
5867   return false;                 // Never a singleton
5868 }
5869 
5870 bool TypeFunc::empty(void) const {
5871   return false;                 // Never empty
5872 }
5873 
5874 
5875 BasicType TypeFunc::return_type() const{
<span class="line-modified">5876   if (range_sig()-&gt;cnt() == TypeFunc::Parms) {</span>
5877     return T_VOID;
5878   }
<span class="line-modified">5879   return range_sig()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();</span>
5880 }
</pre>
</td>
</tr>
</table>
<center><a href="subnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>