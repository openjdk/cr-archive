<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/thread.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  41 #include &quot;interpreter/interpreter.hpp&quot;
  42 #include &quot;interpreter/linkResolver.hpp&quot;
  43 #include &quot;interpreter/oopMapCache.hpp&quot;
  44 #include &quot;jfr/jfrEvents.hpp&quot;
  45 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  46 #include &quot;logging/log.hpp&quot;
  47 #include &quot;logging/logConfiguration.hpp&quot;
  48 #include &quot;logging/logStream.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/iterator.hpp&quot;
  51 #include &quot;memory/metaspaceShared.hpp&quot;
  52 #include &quot;memory/oopFactory.hpp&quot;
  53 #include &quot;memory/resourceArea.hpp&quot;
  54 #include &quot;memory/universe.hpp&quot;
  55 #include &quot;oops/access.inline.hpp&quot;
  56 #include &quot;oops/instanceKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;oops/typeArrayOop.inline.hpp&quot;

  61 #include &quot;oops/verifyOopClosure.hpp&quot;
  62 #include &quot;prims/jvm_misc.hpp&quot;
  63 #include &quot;prims/jvmtiExport.hpp&quot;
  64 #include &quot;prims/jvmtiThreadState.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/atomic.hpp&quot;
  67 #include &quot;runtime/biasedLocking.hpp&quot;
  68 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  69 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
  70 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  71 #include &quot;runtime/deoptimization.hpp&quot;
  72 #include &quot;runtime/frame.inline.hpp&quot;
  73 #include &quot;runtime/handles.inline.hpp&quot;
  74 #include &quot;runtime/handshake.hpp&quot;
  75 #include &quot;runtime/init.hpp&quot;
  76 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  77 #include &quot;runtime/java.hpp&quot;
  78 #include &quot;runtime/javaCalls.hpp&quot;
  79 #include &quot;runtime/jniHandles.inline.hpp&quot;
  80 #include &quot;runtime/jniPeriodicChecker.hpp&quot;
</pre>
<hr />
<pre>
1620 void JavaThread::resize_all_jvmci_counters(int new_size) {
1621   VM_JVMCIResizeCounters op(new_size);
1622   VMThread::execute(&amp;op);
1623 }
1624 
1625 #endif // INCLUDE_JVMCI
1626 
1627 // A JavaThread is a normal Java thread
1628 
1629 void JavaThread::initialize() {
1630   // Initialize fields
1631 
1632   set_saved_exception_pc(NULL);
1633   set_threadObj(NULL);
1634   _anchor.clear();
1635   set_entry_point(NULL);
1636   set_jni_functions(jni_functions());
1637   set_callee_target(NULL);
1638   set_vm_result(NULL);
1639   set_vm_result_2(NULL);

1640   set_vframe_array_head(NULL);
1641   set_vframe_array_last(NULL);
1642   set_deferred_locals(NULL);
1643   set_deopt_mark(NULL);
1644   set_deopt_compiled_method(NULL);
1645   set_monitor_chunks(NULL);
1646   _on_thread_list = false;
1647   _thread_state = _thread_new;
1648   _terminated = _not_terminated;
1649   _array_for_gc = NULL;
1650   _suspend_equivalent = false;
1651   _in_deopt_handler = 0;
1652   _doing_unsafe_access = false;
1653   _stack_guard_state = stack_guard_unused;
1654 #if INCLUDE_JVMCI
1655   _pending_monitorenter = false;
1656   _pending_deoptimization = -1;
1657   _pending_failed_speculation = 0;
1658   _pending_transfer_to_interpreter = false;
1659   _in_retryable_allocation = false;
</pre>
<hr />
<pre>
2825   guarantee(base &lt; os::current_stack_pointer(), &quot;Error calculating stack red zone&quot;);
2826 
2827   if (!os::guard_memory((char *) base, stack_red_zone_size())) {
2828     warning(&quot;Attempt to guard stack red zone failed.&quot;);
2829   }
2830 }
2831 
2832 void JavaThread::disable_stack_red_zone() {
2833   // The base notation is from the stacks point of view, growing downward.
2834   // We need to adjust it to work correctly with guard_memory()
2835   assert(_stack_guard_state != stack_guard_unused, &quot;must be using guard pages.&quot;);
2836   address base = stack_red_zone_base() - stack_red_zone_size();
2837   if (!os::unguard_memory((char *)base, stack_red_zone_size())) {
2838     warning(&quot;Attempt to unguard stack red zone failed.&quot;);
2839   }
2840 }
2841 
2842 void JavaThread::frames_do(void f(frame*, const RegisterMap* map)) {
2843   // ignore is there is no stack
2844   if (!has_last_Java_frame()) return;



2845   // traverse the stack frames. Starts from top frame.
2846   for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {
2847     frame* fr = fst.current();
2848     f(fr, fst.register_map());
2849   }
2850 }
2851 
2852 
2853 #ifndef PRODUCT
2854 // Deoptimization
2855 // Function for testing deoptimization
2856 void JavaThread::deoptimize() {
2857   StackFrameStream fst(this, false);
2858   bool deopt = false;           // Dump stack only if a deopt actually happens.
2859   bool only_at = strlen(DeoptimizeOnlyAt) &gt; 0;
2860   // Iterate over all frames in the thread and deoptimize
2861   for (; !fst.is_done(); fst.next()) {
2862     if (fst.current()-&gt;can_be_deoptimized()) {
2863 
2864       if (only_at) {
</pre>
</td>
<td>
<hr />
<pre>
  41 #include &quot;interpreter/interpreter.hpp&quot;
  42 #include &quot;interpreter/linkResolver.hpp&quot;
  43 #include &quot;interpreter/oopMapCache.hpp&quot;
  44 #include &quot;jfr/jfrEvents.hpp&quot;
  45 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  46 #include &quot;logging/log.hpp&quot;
  47 #include &quot;logging/logConfiguration.hpp&quot;
  48 #include &quot;logging/logStream.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/iterator.hpp&quot;
  51 #include &quot;memory/metaspaceShared.hpp&quot;
  52 #include &quot;memory/oopFactory.hpp&quot;
  53 #include &quot;memory/resourceArea.hpp&quot;
  54 #include &quot;memory/universe.hpp&quot;
  55 #include &quot;oops/access.inline.hpp&quot;
  56 #include &quot;oops/instanceKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  61 #include &quot;oops/inlineKlass.hpp&quot;</span>
  62 #include &quot;oops/verifyOopClosure.hpp&quot;
  63 #include &quot;prims/jvm_misc.hpp&quot;
  64 #include &quot;prims/jvmtiExport.hpp&quot;
  65 #include &quot;prims/jvmtiThreadState.hpp&quot;
  66 #include &quot;runtime/arguments.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/biasedLocking.hpp&quot;
  69 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  70 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
  71 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  72 #include &quot;runtime/deoptimization.hpp&quot;
  73 #include &quot;runtime/frame.inline.hpp&quot;
  74 #include &quot;runtime/handles.inline.hpp&quot;
  75 #include &quot;runtime/handshake.hpp&quot;
  76 #include &quot;runtime/init.hpp&quot;
  77 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  78 #include &quot;runtime/java.hpp&quot;
  79 #include &quot;runtime/javaCalls.hpp&quot;
  80 #include &quot;runtime/jniHandles.inline.hpp&quot;
  81 #include &quot;runtime/jniPeriodicChecker.hpp&quot;
</pre>
<hr />
<pre>
1621 void JavaThread::resize_all_jvmci_counters(int new_size) {
1622   VM_JVMCIResizeCounters op(new_size);
1623   VMThread::execute(&amp;op);
1624 }
1625 
1626 #endif // INCLUDE_JVMCI
1627 
1628 // A JavaThread is a normal Java thread
1629 
1630 void JavaThread::initialize() {
1631   // Initialize fields
1632 
1633   set_saved_exception_pc(NULL);
1634   set_threadObj(NULL);
1635   _anchor.clear();
1636   set_entry_point(NULL);
1637   set_jni_functions(jni_functions());
1638   set_callee_target(NULL);
1639   set_vm_result(NULL);
1640   set_vm_result_2(NULL);
<span class="line-added">1641   set_return_buffered_value(NULL);</span>
1642   set_vframe_array_head(NULL);
1643   set_vframe_array_last(NULL);
1644   set_deferred_locals(NULL);
1645   set_deopt_mark(NULL);
1646   set_deopt_compiled_method(NULL);
1647   set_monitor_chunks(NULL);
1648   _on_thread_list = false;
1649   _thread_state = _thread_new;
1650   _terminated = _not_terminated;
1651   _array_for_gc = NULL;
1652   _suspend_equivalent = false;
1653   _in_deopt_handler = 0;
1654   _doing_unsafe_access = false;
1655   _stack_guard_state = stack_guard_unused;
1656 #if INCLUDE_JVMCI
1657   _pending_monitorenter = false;
1658   _pending_deoptimization = -1;
1659   _pending_failed_speculation = 0;
1660   _pending_transfer_to_interpreter = false;
1661   _in_retryable_allocation = false;
</pre>
<hr />
<pre>
2827   guarantee(base &lt; os::current_stack_pointer(), &quot;Error calculating stack red zone&quot;);
2828 
2829   if (!os::guard_memory((char *) base, stack_red_zone_size())) {
2830     warning(&quot;Attempt to guard stack red zone failed.&quot;);
2831   }
2832 }
2833 
2834 void JavaThread::disable_stack_red_zone() {
2835   // The base notation is from the stacks point of view, growing downward.
2836   // We need to adjust it to work correctly with guard_memory()
2837   assert(_stack_guard_state != stack_guard_unused, &quot;must be using guard pages.&quot;);
2838   address base = stack_red_zone_base() - stack_red_zone_size();
2839   if (!os::unguard_memory((char *)base, stack_red_zone_size())) {
2840     warning(&quot;Attempt to unguard stack red zone failed.&quot;);
2841   }
2842 }
2843 
2844 void JavaThread::frames_do(void f(frame*, const RegisterMap* map)) {
2845   // ignore is there is no stack
2846   if (!has_last_Java_frame()) return;
<span class="line-added">2847   // Because this method is used to verify oops, it must support</span>
<span class="line-added">2848   // oops in buffered values</span>
<span class="line-added">2849 </span>
2850   // traverse the stack frames. Starts from top frame.
2851   for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {
2852     frame* fr = fst.current();
2853     f(fr, fst.register_map());
2854   }
2855 }
2856 
2857 
2858 #ifndef PRODUCT
2859 // Deoptimization
2860 // Function for testing deoptimization
2861 void JavaThread::deoptimize() {
2862   StackFrameStream fst(this, false);
2863   bool deopt = false;           // Dump stack only if a deopt actually happens.
2864   bool only_at = strlen(DeoptimizeOnlyAt) &gt; 0;
2865   // Iterate over all frames in the thread and deoptimize
2866   for (; !fst.is_done(); fst.next()) {
2867     if (fst.current()-&gt;can_be_deoptimized()) {
2868 
2869       if (only_at) {
</pre>
</td>
</tr>
</table>
<center><a href="globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>