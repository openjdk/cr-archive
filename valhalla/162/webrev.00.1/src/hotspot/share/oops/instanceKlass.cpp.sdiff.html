<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/metaspaceShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbol.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  48 #include &quot;logging/logStream.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/iterator.inline.hpp&quot;
  51 #include &quot;memory/metadataFactory.hpp&quot;
  52 #include &quot;memory/metaspaceClosure.hpp&quot;
  53 #include &quot;memory/metaspaceShared.hpp&quot;
  54 #include &quot;memory/oopFactory.hpp&quot;
  55 #include &quot;memory/resourceArea.hpp&quot;
  56 #include &quot;memory/universe.hpp&quot;
  57 #include &quot;oops/fieldStreams.inline.hpp&quot;
  58 #include &quot;oops/constantPool.hpp&quot;
  59 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  60 #include &quot;oops/instanceKlass.inline.hpp&quot;
  61 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  62 #include &quot;oops/instanceOop.hpp&quot;
  63 #include &quot;oops/klass.inline.hpp&quot;
  64 #include &quot;oops/method.hpp&quot;
  65 #include &quot;oops/oop.inline.hpp&quot;
  66 #include &quot;oops/recordComponent.hpp&quot;
  67 #include &quot;oops/symbol.hpp&quot;

  68 #include &quot;prims/jvmtiExport.hpp&quot;
  69 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  70 #include &quot;prims/jvmtiThreadState.hpp&quot;
  71 #include &quot;prims/methodComparator.hpp&quot;
  72 #include &quot;runtime/atomic.hpp&quot;
  73 #include &quot;runtime/biasedLocking.hpp&quot;
  74 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  75 #include &quot;runtime/handles.inline.hpp&quot;
  76 #include &quot;runtime/javaCalls.hpp&quot;
  77 #include &quot;runtime/mutexLocker.hpp&quot;
  78 #include &quot;runtime/orderAccess.hpp&quot;
  79 #include &quot;runtime/thread.inline.hpp&quot;
  80 #include &quot;services/classLoadingService.hpp&quot;
  81 #include &quot;services/threadService.hpp&quot;
  82 #include &quot;utilities/dtrace.hpp&quot;
  83 #include &quot;utilities/events.hpp&quot;
  84 #include &quot;utilities/macros.hpp&quot;
  85 #include &quot;utilities/stringUtils.hpp&quot;
  86 #ifdef COMPILER1
  87 #include &quot;c1/c1_Compiler.hpp&quot;
</pre>
<hr />
<pre>
 138 
 139 static inline bool is_class_loader(const Symbol* class_name,
 140                                    const ClassFileParser&amp; parser) {
 141   assert(class_name != NULL, &quot;invariant&quot;);
 142 
 143   if (class_name == vmSymbols::java_lang_ClassLoader()) {
 144     return true;
 145   }
 146 
 147   if (SystemDictionary::ClassLoader_klass_loaded()) {
 148     const Klass* const super_klass = parser.super_klass();
 149     if (super_klass != NULL) {
 150       if (super_klass-&gt;is_subtype_of(SystemDictionary::ClassLoader_klass())) {
 151         return true;
 152       }
 153     }
 154   }
 155   return false;
 156 }
 157 


 158 // private: called to verify that k is a static member of this nest.
 159 // We know that k is an instance class in the same package and hence the
 160 // same classloader.
 161 bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {
 162   assert(!is_hidden(), &quot;unexpected hidden class&quot;);
 163   if (_nest_members == NULL || _nest_members == Universe::the_empty_short_array()) {
 164     if (log_is_enabled(Trace, class, nestmates)) {
 165       ResourceMark rm(THREAD);
 166       log_trace(class, nestmates)(&quot;Checked nest membership of %s in non-nest-host class %s&quot;,
 167                                   k-&gt;external_name(), this-&gt;external_name());
 168     }
 169     return false;
 170   }
 171 
 172   if (log_is_enabled(Trace, class, nestmates)) {
 173     ResourceMark rm(THREAD);
 174     log_trace(class, nestmates)(&quot;Checking nest membership of %s in %s&quot;,
 175                                 k-&gt;external_name(), this-&gt;external_name());
 176   }
 177 
</pre>
<hr />
<pre>
 456                               k-&gt;external_name());
 457   return access;
 458 }
 459 
 460 const char* InstanceKlass::nest_host_error(TRAPS) {
 461   if (_nest_host_index == 0) {
 462     return NULL;
 463   } else {
 464     constantPoolHandle cph(THREAD, constants());
 465     return SystemDictionary::find_nest_host_error(cph, (int)_nest_host_index);
 466   }
 467 }
 468 
 469 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
 470   bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();
 471   const int size = InstanceKlass::size(parser.vtable_size(),
 472                                        parser.itable_size(),
 473                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 474                                        parser.is_interface(),
 475                                        parser.is_unsafe_anonymous(),
<span class="line-modified"> 476                                        should_store_fingerprint(is_hidden_or_anonymous));</span>


 477 
 478   const Symbol* const class_name = parser.class_name();
 479   assert(class_name != NULL, &quot;invariant&quot;);
 480   ClassLoaderData* loader_data = parser.loader_data();
 481   assert(loader_data != NULL, &quot;invariant&quot;);
 482 
 483   InstanceKlass* ik;
 484 
 485   // Allocation
 486   if (REF_NONE == parser.reference_type()) {
 487     if (class_name == vmSymbols::java_lang_Class()) {
 488       // mirror
 489       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
<span class="line-modified"> 490     }</span>
<span class="line-removed"> 491     else if (is_class_loader(class_name, parser)) {</span>
 492       // class loader
 493       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);



 494     } else {
 495       // normal
 496       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_kind_other);
 497     }
 498   } else {
 499     // reference
 500     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 501   }
 502 
 503   // Check for pending exception before adding to the loader data and incrementing
 504   // class count.  Can get OOM here.
 505   if (HAS_PENDING_EXCEPTION) {
 506     return NULL;
 507   }
 508 







 509   return ik;
 510 }
 511 























 512 
 513 // copy method ordering from resource area to Metaspace
 514 void InstanceKlass::copy_method_ordering(const intArray* m, TRAPS) {
 515   if (m != NULL) {
 516     // allocate a new array and copy contents (memcpy?)
 517     _method_ordering = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), m-&gt;length(), CHECK);
 518     for (int i = 0; i &lt; m-&gt;length(); i++) {
 519       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 520     }
 521   } else {
 522     _method_ordering = Universe::the_empty_int_array();
 523   }
 524 }
 525 
 526 // create a new array of vtable_indices for default methods
 527 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 528   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 529   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 530   set_default_vtable_indices(vtable_indices);
 531   return vtable_indices;
 532 }
 533 
 534 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 535   Klass(id),
 536   _nest_members(NULL),
 537   _nest_host(NULL),
 538   _permitted_subclasses(NULL),
 539   _record_components(NULL),
 540   _static_field_size(parser.static_field_size()),
 541   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 542   _itable_len(parser.itable_size()),
 543   _nest_host_index(0),
 544   _init_state(allocated),
 545   _reference_type(parser.reference_type()),
<span class="line-modified"> 546   _init_thread(NULL)</span>


 547 {
 548   set_vtable_length(parser.vtable_size());
 549   set_kind(kind);
 550   set_access_flags(parser.access_flags());
 551   if (parser.is_hidden()) set_is_hidden();
 552   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 553   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 554                                                     false));




 555 
<span class="line-modified"> 556   assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);</span>
<span class="line-modified"> 557   assert(is_instance_klass(), &quot;is layout incorrect?&quot;);</span>
<span class="line-modified"> 558   assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);</span>
 559 
 560   // Set biased locking bit for all instances of this class; it will be
 561   // cleared if revocation occurs too often for this type
 562   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 563     set_prototype_header(markWord::biased_locking_prototype());
 564   }



 565 }
 566 
 567 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 568                                        Array&lt;Method*&gt;* methods) {
 569   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 570       !methods-&gt;is_shared()) {
 571     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 572       Method* method = methods-&gt;at(i);
 573       if (method == NULL) continue;  // maybe null if error processing
 574       // Only want to delete methods that are not executing for RedefineClasses.
 575       // The previous version will point to them so they&#39;re not totally dangling
 576       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 577       MetadataFactory::free_metadata(loader_data, method);
 578     }
 579     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 580   }
 581 }
 582 
 583 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 584                                           const Klass* super_klass,
 585                                           Array&lt;InstanceKlass*&gt;* local_interfaces,
 586                                           Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 587   // Only deallocate transitive interfaces if not empty, same as super class
 588   // or same as local interfaces.  See code in parseClassFile.
 589   Array&lt;InstanceKlass*&gt;* ti = transitive_interfaces;
 590   if (ti != Universe::the_empty_instance_klass_array() &amp;&amp; ti != local_interfaces) {
 591     // check that the interfaces don&#39;t come from super class
 592     Array&lt;InstanceKlass*&gt;* sti = (super_klass == NULL) ? NULL :
 593                     InstanceKlass::cast(super_klass)-&gt;transitive_interfaces();
<span class="line-modified"> 594     if (ti != sti &amp;&amp; ti != NULL &amp;&amp; !ti-&gt;is_shared()) {</span>

 595       MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, ti);
 596     }
 597   }
 598 
 599   // local interfaces can be empty
 600   if (local_interfaces != Universe::the_empty_instance_klass_array() &amp;&amp;
<span class="line-modified"> 601       local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared()) {</span>

 602     MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
 603   }
 604 }
 605 
 606 void InstanceKlass::deallocate_record_components(ClassLoaderData* loader_data,
 607                                                  Array&lt;RecordComponent*&gt;* record_components) {
 608   if (record_components != NULL &amp;&amp; !record_components-&gt;is_shared()) {
 609     for (int i = 0; i &lt; record_components-&gt;length(); i++) {
 610       RecordComponent* record_component = record_components-&gt;at(i);
 611       MetadataFactory::free_metadata(loader_data, record_component);
 612     }
 613     MetadataFactory::free_array&lt;RecordComponent*&gt;(loader_data, record_components);
 614   }
 615 }
 616 
 617 // This function deallocates the metadata and C heap pointers that the
 618 // InstanceKlass points to.
 619 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 620 
 621   // Orphan the mirror first, CMS thinks it&#39;s still live.
</pre>
<hr />
<pre>
 909         vmSymbols::java_lang_IncompatibleClassChangeError(),
 910         &quot;class %s has interface %s as super class&quot;,
 911         external_name(),
 912         super_klass-&gt;external_name()
 913       );
 914       return false;
 915     }
 916 
 917     InstanceKlass* ik_super = InstanceKlass::cast(super_klass);
 918     ik_super-&gt;link_class_impl(CHECK_false);
 919   }
 920 
 921   // link all interfaces implemented by this class before linking this class
 922   Array&lt;InstanceKlass*&gt;* interfaces = local_interfaces();
 923   int num_interfaces = interfaces-&gt;length();
 924   for (int index = 0; index &lt; num_interfaces; index++) {
 925     InstanceKlass* interk = interfaces-&gt;at(index);
 926     interk-&gt;link_class_impl(CHECK_false);
 927   }
 928 
























































 929   // in case the class is linked in the process of linking its superclasses
 930   if (is_linked()) {
 931     return true;
 932   }
 933 
 934   // trace only the link time for this klass that includes
 935   // the verification time
 936   PerfClassTraceTime vmtimer(ClassLoader::perf_class_link_time(),
 937                              ClassLoader::perf_class_link_selftime(),
 938                              ClassLoader::perf_classes_linked(),
 939                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 940                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 941                              PerfClassTraceTime::CLASS_LINK);
 942 
 943   // verification &amp; rewriting
 944   {
 945     HandleMark hm(THREAD);
 946     Handle h_init_lock(THREAD, init_lock());
 947     ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);
 948     // rewritten will have been set if loader constraint error found
</pre>
<hr />
<pre>
 980       // fabricate new Method*s.
 981       // also does loader constraint checking
 982       //
 983       // initialize_vtable and initialize_itable need to be rerun
 984       // for a shared class if
 985       // 1) the class is loaded by custom class loader or
 986       // 2) the class is loaded by built-in class loader but failed to add archived loader constraints
 987       bool need_init_table = true;
 988       if (is_shared() &amp;&amp; SystemDictionaryShared::check_linking_constraints(this, THREAD)) {
 989         need_init_table = false;
 990       }
 991       if (need_init_table) {
 992         vtable().initialize_vtable(true, CHECK_false);
 993         itable().initialize_itable(true, CHECK_false);
 994       }
 995 #ifdef ASSERT
 996       vtable().verify(tty, true);
 997       // In case itable verification is ever added.
 998       // itable().verify(tty, true);
 999 #endif

1000       set_init_state(linked);
1001       if (JvmtiExport::should_post_class_prepare()) {
1002         Thread *thread = THREAD;
1003         assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1004         JvmtiExport::post_class_prepare((JavaThread *) thread, this);
1005       }
1006     }
1007   }
1008   return true;
1009 }
1010 
1011 // Rewrite the byte codes of all of the methods of a class.
1012 // The rewriter must be called exactly once. Rewriting must happen after
1013 // verification but before the first method of the class is executed.
1014 void InstanceKlass::rewrite_class(TRAPS) {
1015   assert(is_loaded(), &quot;must be loaded&quot;);
1016   if (is_rewritten()) {
1017     assert(is_shared(), &quot;rewriting an unshared class?&quot;);
1018     return;
1019   }
</pre>
<hr />
<pre>
1133     // having a superinterface that declares, non-static, concrete methods
1134     if (!HAS_PENDING_EXCEPTION &amp;&amp; has_nonstatic_concrete_methods()) {
1135       initialize_super_interfaces(THREAD);
1136     }
1137 
1138     // If any exceptions, complete abruptly, throwing the same exception as above.
1139     if (HAS_PENDING_EXCEPTION) {
1140       Handle e(THREAD, PENDING_EXCEPTION);
1141       CLEAR_PENDING_EXCEPTION;
1142       {
1143         EXCEPTION_MARK;
1144         // Locks object, set state, and notify all waiting threads
1145         set_initialization_state_and_notify(initialization_error, THREAD);
1146         CLEAR_PENDING_EXCEPTION;
1147       }
1148       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1149       THROW_OOP(e());
1150     }
1151   }
1152 





























1153 
1154   // Look for aot compiled methods for this klass, including class initializer.
1155   AOTLoader::load_for_klass(this, THREAD);
1156 
<span class="line-modified">1157   // Step 8</span>
1158   {
1159     DTRACE_CLASSINIT_PROBE_WAIT(clinit, -1, wait);
1160     if (class_initializer() != NULL) {
1161       // Timer includes any side effects of class initialization (resolution,
1162       // etc), but not recursive entry into call_class_initializer().
1163       PerfClassTraceTime timer(ClassLoader::perf_class_init_time(),
1164                                ClassLoader::perf_class_init_selftime(),
1165                                ClassLoader::perf_classes_inited(),
1166                                jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1167                                jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1168                                PerfClassTraceTime::CLASS_CLINIT);
1169       call_class_initializer(THREAD);
1170     } else {
1171       // The elapsed time is so small it&#39;s not worth counting.
1172       if (UsePerfData) {
1173         ClassLoader::perf_classes_inited()-&gt;inc();
1174       }
1175       call_class_initializer(THREAD);
1176     }
1177   }
1178 
<span class="line-modified">1179   // Step 9</span>
1180   if (!HAS_PENDING_EXCEPTION) {
1181     set_initialization_state_and_notify(fully_initialized, CHECK);
1182     {
1183       debug_only(vtable().verify(tty, true);)
1184     }
1185   }
1186   else {
<span class="line-modified">1187     // Step 10 and 11</span>
1188     Handle e(THREAD, PENDING_EXCEPTION);
1189     CLEAR_PENDING_EXCEPTION;
1190     // JVMTI has already reported the pending exception
1191     // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1192     JvmtiExport::clear_detected_exception(jt);
1193     {
1194       EXCEPTION_MARK;
1195       set_initialization_state_and_notify(initialization_error, THREAD);
1196       CLEAR_PENDING_EXCEPTION;   // ignore any exception thrown, class initialization error is thrown below
1197       // JVMTI has already reported the pending exception
1198       // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1199       JvmtiExport::clear_detected_exception(jt);
1200     }
1201     DTRACE_CLASSINIT_PROBE_WAIT(error, -1, wait);
1202     if (e-&gt;is_a(SystemDictionary::Error_klass())) {
1203       THROW_OOP(e());
1204     } else {
1205       JavaCallArguments args(e);
1206       THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),
1207                 vmSymbols::throwable_void_signature(),
</pre>
<hr />
<pre>
1455       }
1456     }
1457   }
1458   // _this will always be set at this point
1459   ObjArrayKlass* oak = array_klasses();
1460   if (or_null) {
1461     return oak-&gt;array_klass_or_null(n);
1462   }
1463   return oak-&gt;array_klass(n, THREAD);
1464 }
1465 
1466 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
1467   return array_klass_impl(or_null, 1, THREAD);
1468 }
1469 
1470 static int call_class_initializer_counter = 0;   // for debugging
1471 
1472 Method* InstanceKlass::class_initializer() const {
1473   Method* clinit = find_method(
1474       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
<span class="line-modified">1475   if (clinit != NULL &amp;&amp; clinit-&gt;has_valid_initializer_flags()) {</span>
1476     return clinit;
1477   }
1478   return NULL;
1479 }
1480 
1481 void InstanceKlass::call_class_initializer(TRAPS) {
1482   if (ReplayCompiles &amp;&amp;
1483       (ReplaySuppressInitializers == 1 ||
1484        (ReplaySuppressInitializers &gt;= 2 &amp;&amp; class_loader() != NULL))) {
1485     // Hide the existence of the initializer for the purpose of replaying the compile
1486     return;
1487   }
1488 
1489   methodHandle h_method(THREAD, class_initializer());
1490   assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
1491   LogTarget(Info, class, init) lt;
1492   if (lt.is_enabled()) {
1493     ResourceMark rm(THREAD);
1494     LogStream ls(lt);
1495     ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
1496     name()-&gt;print_value_on(&amp;ls);
1497     ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
1498   }
1499   if (h_method() != NULL) {
1500     JavaCallArguments args; // No arguments
1501     JavaValue result(T_VOID);
1502     JavaCalls::call(&amp;result, h_method, &amp;args, CHECK); // Static call (no args)
1503   }
1504 }
1505 
1506 
1507 void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
1508   InterpreterOopMap* entry_for) {
1509   // Lazily create the _oop_map_cache at first request
1510   // Lock-free access requires load_acquire.
1511   OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);
1512   if (oop_map_cache == NULL) {
<span class="line-modified">1513     MutexLocker x(OopMapCacheAlloc_lock);</span>
1514     // Check if _oop_map_cache was allocated while we were waiting for this lock
1515     if ((oop_map_cache = _oop_map_cache) == NULL) {
1516       oop_map_cache = new OopMapCache();
1517       // Ensure _oop_map_cache is stable, since it is examined without a lock
1518       Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);
1519     }
1520   }
1521   // _oop_map_cache is constant after init; lookup below does its own locking.
1522   oop_map_cache-&gt;lookup(method, bci, entry_for);
1523 }
1524 
<span class="line-removed">1525 bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-removed">1526   fieldDescriptor fd;</span>
<span class="line-removed">1527   return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-removed">1528 }</span>
<span class="line-removed">1529 </span>
1530 bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1531   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1532     Symbol* f_name = fs.name();
1533     Symbol* f_sig  = fs.signature();
1534     if (f_name == name &amp;&amp; f_sig == sig) {
1535       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1536       return true;
1537     }
1538   }
1539   return false;
1540 }
1541 
1542 
1543 Klass* InstanceKlass::find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1544   const int n = local_interfaces()-&gt;length();
1545   for (int i = 0; i &lt; n; i++) {
1546     Klass* intf1 = local_interfaces()-&gt;at(i);
1547     assert(intf1-&gt;is_interface(), &quot;just checking type&quot;);
1548     // search for field in current interface
1549     if (InstanceKlass::cast(intf1)-&gt;find_local_field(name, sig, fd)) {
</pre>
<hr />
<pre>
1580 
1581 Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {
1582   // search order according to newest JVM spec (5.4.3.2, p.167).
1583   // 1) search for field in current klass
1584   if (find_local_field(name, sig, fd)) {
1585     if (fd-&gt;is_static() == is_static) return const_cast&lt;InstanceKlass*&gt;(this);
1586   }
1587   // 2) search for field recursively in direct superinterfaces
1588   if (is_static) {
1589     Klass* intf = find_interface_field(name, sig, fd);
1590     if (intf != NULL) return intf;
1591   }
1592   // 3) apply field lookup recursively if superclass exists
1593   { Klass* supr = super();
1594     if (supr != NULL) return InstanceKlass::cast(supr)-&gt;find_field(name, sig, is_static, fd);
1595   }
1596   // 4) otherwise field lookup fails
1597   return NULL;
1598 }
1599 









1600 
1601 bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1602   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1603     if (fs.offset() == offset) {
1604       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1605       if (fd-&gt;is_static() == is_static) return true;
1606     }
1607   }
1608   return false;
1609 }
1610 
1611 
1612 bool InstanceKlass::find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1613   Klass* klass = const_cast&lt;InstanceKlass*&gt;(this);
1614   while (klass != NULL) {
1615     if (InstanceKlass::cast(klass)-&gt;find_local_field_from_offset(offset, is_static, fd)) {
1616       return true;
1617     }
1618     klass = klass-&gt;super();
1619   }
</pre>
<hr />
<pre>
1964 }
1965 
1966 // uncached_lookup_method searches both the local class methods array and all
1967 // superclasses methods arrays, skipping any overpass methods in superclasses,
1968 // and possibly skipping private methods.
1969 Method* InstanceKlass::uncached_lookup_method(const Symbol* name,
1970                                               const Symbol* signature,
1971                                               OverpassLookupMode overpass_mode,
1972                                               PrivateLookupMode private_mode) const {
1973   OverpassLookupMode overpass_local_mode = overpass_mode;
1974   const Klass* klass = this;
1975   while (klass != NULL) {
1976     Method* const method = InstanceKlass::cast(klass)-&gt;find_method_impl(name,
1977                                                                         signature,
1978                                                                         overpass_local_mode,
1979                                                                         find_static,
1980                                                                         private_mode);
1981     if (method != NULL) {
1982       return method;
1983     }



1984     klass = klass-&gt;super();
1985     overpass_local_mode = skip_overpass;   // Always ignore overpass methods in superclasses
1986   }
1987   return NULL;
1988 }
1989 
1990 #ifdef ASSERT
1991 // search through class hierarchy and return true if this class or
1992 // one of the superclasses was redefined
1993 bool InstanceKlass::has_redefined_this_or_super() const {
1994   const Klass* klass = this;
1995   while (klass != NULL) {
1996     if (InstanceKlass::cast(klass)-&gt;has_been_redefined()) {
1997       return true;
1998     }
1999     klass = klass-&gt;super();
2000   }
2001   return false;
2002 }
2003 #endif
</pre>
<hr />
<pre>
2472     itableOffsetEntry* ioe = (itableOffsetEntry*)start_of_itable();
2473     int method_table_offset_in_words = ioe-&gt;offset()/wordSize;
2474     int nof_interfaces = (method_table_offset_in_words - itable_offset_in_words())
2475                          / itableOffsetEntry::size();
2476 
2477     for (int i = 0; i &lt; nof_interfaces; i ++, ioe ++) {
2478       if (ioe-&gt;interface_klass() != NULL) {
2479         it-&gt;push(ioe-&gt;interface_klass_addr());
2480         itableMethodEntry* ime = ioe-&gt;first_method_entry(this);
2481         int n = klassItable::method_count_for_interface(ioe-&gt;interface_klass());
2482         for (int index = 0; index &lt; n; index ++) {
2483           it-&gt;push(ime[index].method_addr());
2484         }
2485       }
2486     }
2487   }
2488 
2489   it-&gt;push(&amp;_nest_members);
2490   it-&gt;push(&amp;_permitted_subclasses);
2491   it-&gt;push(&amp;_record_components);






2492 }
2493 
2494 void InstanceKlass::remove_unshareable_info() {
2495   Klass::remove_unshareable_info();
2496 
2497   if (SystemDictionaryShared::has_class_failed_verification(this)) {
2498     // Classes are attempted to link during dumping and may fail,
2499     // but these classes are still in the dictionary and class list in CLD.
2500     // If the class has failed verification, there is nothing else to remove.
2501     return;
2502   }
2503 
2504   // Reset to the &#39;allocated&#39; state to prevent any premature accessing to
2505   // a shared class at runtime while the class is still being loaded and
2506   // restored. A class&#39; init_state is set to &#39;loaded&#39; at runtime when it&#39;s
2507   // being added to class hierarchy (see SystemDictionary:::add_to_hierarchy()).
2508   _init_state = allocated;
2509 
2510   { // Otherwise this needs to take out the Compile_lock.
2511     assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
2512     init_implementor();
2513   }
2514 
2515   constants()-&gt;remove_unshareable_info();
2516 
2517   for (int i = 0; i &lt; methods()-&gt;length(); i++) {
2518     Method* m = methods()-&gt;at(i);
2519     m-&gt;remove_unshareable_info();
2520   }
2521 
2522   // do array classes also.
2523   if (array_klasses() != NULL) {
2524     array_klasses()-&gt;remove_unshareable_info();
2525   }
2526 








2527   // These are not allocated from metaspace. They are safe to set to NULL.
2528   _source_debug_extension = NULL;
2529   _dep_context = NULL;
2530   _osr_nmethods_head = NULL;
2531 #if INCLUDE_JVMTI
2532   _breakpoints = NULL;
2533   _previous_versions = NULL;
2534   _cached_class_file = NULL;
2535   _jvmti_cached_class_field_map = NULL;
2536 #endif
2537 
2538   _init_thread = NULL;
2539   _methods_jmethod_ids = NULL;
2540   _jni_ids = NULL;
2541   _oop_map_cache = NULL;
2542   // clear _nest_host to ensure re-load at runtime
2543   _nest_host = NULL;
2544   _package_entry = NULL;
2545   _dep_context_last_cleaned = 0;
2546 }
2547 
2548 void InstanceKlass::remove_java_mirror() {
2549   Klass::remove_java_mirror();
2550 
2551   // do array classes also.
2552   if (array_klasses() != NULL) {
2553     array_klasses()-&gt;remove_java_mirror();
2554   }
2555 }
2556 
2557 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,
2558                                              PackageEntry* pkg_entry, TRAPS) {
2559   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2560   // before the InstanceKlass is added to the SystemDictionary. Make
2561   // sure the current state is &lt;loaded.
2562   assert(!is_loaded(), &quot;invalid init state&quot;);
2563   set_package(loader_data, pkg_entry, CHECK);
2564   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2565 




2566   Array&lt;Method*&gt;* methods = this-&gt;methods();
2567   int num_methods = methods-&gt;length();
2568   for (int index = 0; index &lt; num_methods; ++index) {
2569     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2570   }
2571   if (JvmtiExport::has_redefined_a_class()) {
2572     // Reinitialize vtable because RedefineClasses may have changed some
2573     // entries in this vtable for super classes so the CDS vtable might
2574     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2575     // vtables in the shared system dictionary, only the main one.
2576     // It also redefines the itable too so fix that too.
2577     vtable().initialize_vtable(false, CHECK);
2578     itable().initialize_itable(false, CHECK);
2579   }
2580 
2581   // restore constant pool resolved references
2582   constants()-&gt;restore_unshareable_info(CHECK);
2583 
2584   if (array_klasses() != NULL) {
2585     // Array classes have null protection domain.
2586     // --&gt; see ArrayKlass::complete_create_array_klass()
2587     array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2588   }
2589 
2590   // Initialize current biased locking state.
<span class="line-modified">2591   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {</span>
2592     set_prototype_header(markWord::biased_locking_prototype());
2593   }
2594 }
2595 
2596 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2597   switch (loader_type) {
2598   case ClassLoader::BOOT_LOADER:
2599     _misc_flags |= _misc_is_shared_boot_class;
2600     break;
2601   case ClassLoader::PLATFORM_LOADER:
2602     _misc_flags |= _misc_is_shared_platform_class;
2603     break;
2604   case ClassLoader::APP_LOADER:
2605     _misc_flags |= _misc_is_shared_app_class;
2606     break;
2607   default:
2608     ShouldNotReachHere();
2609     break;
2610   }
2611 }
</pre>
<hr />
<pre>
2736   }
2737 }
2738 
2739 const char* InstanceKlass::signature_name() const {
2740   int hash_len = 0;
2741   char hash_buf[40];
2742 
2743   // If this is an unsafe anonymous class, append a hash to make the name unique
2744   if (is_unsafe_anonymous()) {
2745     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2746     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2747     hash_len = (int)strlen(hash_buf);
2748   }
2749 
2750   // Get the internal name as a c string
2751   const char* src = (const char*) (name()-&gt;as_C_string());
2752   const int src_length = (int)strlen(src);
2753 
2754   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2755 
<span class="line-modified">2756   // Add L as type indicator</span>
2757   int dest_index = 0;
<span class="line-modified">2758   dest[dest_index++] = JVM_SIGNATURE_CLASS;</span>
2759 
2760   // Add the actual class name
2761   for (int src_index = 0; src_index &lt; src_length; ) {
2762     dest[dest_index++] = src[src_index++];
2763   }
2764 
2765   if (is_hidden()) { // Replace the last &#39;+&#39; with a &#39;.&#39;.
2766     for (int index = (int)src_length; index &gt; 0; index--) {
2767       if (dest[index] == &#39;+&#39;) {
2768         dest[index] = JVM_SIGNATURE_DOT;
2769         break;
2770       }
2771     }
2772   }
2773 
2774   // If we have a hash, append it
2775   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2776     dest[dest_index++] = hash_buf[hash_index++];
2777   }
2778 
</pre>
<hr />
<pre>
3298   }
3299 
3300   assert(match_level == false || best == NULL, &quot;shouldn&#39;t pick up anything if match_level is set&quot;);
3301   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level) {
3302     return best;
3303   }
3304   return NULL;
3305 }
3306 
3307 // -----------------------------------------------------------------------------------------------------
3308 // Printing
3309 
3310 #ifndef PRODUCT
3311 
3312 #define BULLET  &quot; - &quot;
3313 
3314 static const char* state_names[] = {
3315   &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
3316 };
3317 
<span class="line-modified">3318 static void print_vtable(intptr_t* start, int len, outputStream* st) {</span>



3319   for (int i = 0; i &lt; len; i++) {
3320     intptr_t e = start[i];
3321     st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);





3322     if (MetaspaceObj::is_valid((Metadata*)e)) {
3323       st-&gt;print(&quot; &quot;);
3324       ((Metadata*)e)-&gt;print_value_on(st);






3325     }
3326     st-&gt;cr();
3327   }
3328 }
3329 
3330 static void print_vtable(vtableEntry* start, int len, outputStream* st) {
<span class="line-modified">3331   return print_vtable(reinterpret_cast&lt;intptr_t*&gt;(start), len, st);</span>





















3332 }
3333 
3334 void InstanceKlass::print_on(outputStream* st) const {
3335   assert(is_klass(), &quot;must be klass&quot;);
3336   Klass::print_on(st);
3337 
3338   st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
3339   st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
3340   st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();

3341   st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
3342   st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
3343   st-&gt;print(BULLET&quot;super:             &quot;); Metadata::print_value_on_maybe_null(st, super()); st-&gt;cr();
3344   st-&gt;print(BULLET&quot;sub:               &quot;);
3345   Klass* sub = subklass();
3346   int n;
3347   for (n = 0; sub != NULL; n++, sub = sub-&gt;next_sibling()) {
3348     if (n &lt; MaxSubklassPrintSize) {
3349       sub-&gt;print_value_on(st);
3350       st-&gt;print(&quot;   &quot;);
3351     }
3352   }
3353   if (n &gt;= MaxSubklassPrintSize) st-&gt;print(&quot;(&quot; INTX_FORMAT &quot; more klasses...)&quot;, n - MaxSubklassPrintSize);
3354   st-&gt;cr();
3355 
3356   if (is_interface()) {
3357     st-&gt;print_cr(BULLET&quot;nof implementors:  %d&quot;, nof_implementors());
3358     if (nof_implementors() == 1) {
3359       st-&gt;print_cr(BULLET&quot;implementor:    &quot;);
3360       st-&gt;print(&quot;   &quot;);
3361       implementor()-&gt;print_value_on(st);
3362       st-&gt;cr();
3363     }
3364   }
3365 
3366   st-&gt;print(BULLET&quot;arrays:            &quot;); Metadata::print_value_on_maybe_null(st, array_klasses()); st-&gt;cr();
<span class="line-modified">3367   st-&gt;print(BULLET&quot;methods:           &quot;); methods()-&gt;print_value_on(st);                  st-&gt;cr();</span>
<span class="line-modified">3368   if (Verbose || WizardMode) {</span>
<span class="line-modified">3369     Array&lt;Method*&gt;* method_array = methods();</span>
<span class="line-removed">3370     for (int i = 0; i &lt; method_array-&gt;length(); i++) {</span>
<span class="line-removed">3371       st-&gt;print(&quot;%d : &quot;, i); method_array-&gt;at(i)-&gt;print_value(); st-&gt;cr();</span>
<span class="line-removed">3372     }</span>
<span class="line-removed">3373   }</span>
<span class="line-removed">3374   st-&gt;print(BULLET&quot;method ordering:   &quot;); method_ordering()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-removed">3375   st-&gt;print(BULLET&quot;default_methods:   &quot;); default_methods()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-removed">3376   if (Verbose &amp;&amp; default_methods() != NULL) {</span>
<span class="line-removed">3377     Array&lt;Method*&gt;* method_array = default_methods();</span>
<span class="line-removed">3378     for (int i = 0; i &lt; method_array-&gt;length(); i++) {</span>
<span class="line-removed">3379       st-&gt;print(&quot;%d : &quot;, i); method_array-&gt;at(i)-&gt;print_value(); st-&gt;cr();</span>
<span class="line-removed">3380     }</span>
<span class="line-removed">3381   }</span>
3382   if (default_vtable_indices() != NULL) {
<span class="line-modified">3383     st-&gt;print(BULLET&quot;default vtable indices:   &quot;); default_vtable_indices()-&gt;print_value_on(st);       st-&gt;cr();</span>
3384   }
<span class="line-modified">3385   st-&gt;print(BULLET&quot;local interfaces:  &quot;); local_interfaces()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-modified">3386   st-&gt;print(BULLET&quot;trans. interfaces: &quot;); transitive_interfaces()-&gt;print_value_on(st); st-&gt;cr();</span>
3387   st-&gt;print(BULLET&quot;constants:         &quot;); constants()-&gt;print_value_on(st);         st-&gt;cr();
3388   if (class_loader_data() != NULL) {
3389     st-&gt;print(BULLET&quot;class loader data:  &quot;);
3390     class_loader_data()-&gt;print_value_on(st);
3391     st-&gt;cr();
3392   }
3393   st-&gt;print(BULLET&quot;unsafe anonymous host class:        &quot;); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st-&gt;cr();
3394   if (source_file_name() != NULL) {
3395     st-&gt;print(BULLET&quot;source file:       &quot;);
3396     source_file_name()-&gt;print_value_on(st);
3397     st-&gt;cr();
3398   }
3399   if (source_debug_extension() != NULL) {
3400     st-&gt;print(BULLET&quot;source debug extension:       &quot;);
3401     st-&gt;print(&quot;%s&quot;, source_debug_extension());
3402     st-&gt;cr();
3403   }
3404   st-&gt;print(BULLET&quot;class annotations:       &quot;); class_annotations()-&gt;print_value_on(st); st-&gt;cr();
3405   st-&gt;print(BULLET&quot;class type annotations:  &quot;); class_type_annotations()-&gt;print_value_on(st); st-&gt;cr();
3406   st-&gt;print(BULLET&quot;field annotations:       &quot;); fields_annotations()-&gt;print_value_on(st); st-&gt;cr();
</pre>
<hr />
<pre>
3423     st-&gt;print(BULLET&quot;generic signature: &quot;);
3424     generic_signature()-&gt;print_value_on(st);
3425     st-&gt;cr();
3426   }
3427   st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
3428   st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();
3429   if (record_components() != NULL) {
3430     st-&gt;print(BULLET&quot;record components:     &quot;); record_components()-&gt;print_value_on(st);     st-&gt;cr();
3431   }
3432   st-&gt;print(BULLET&quot;permitted subclasses:     &quot;); permitted_subclasses()-&gt;print_value_on(st);     st-&gt;cr();
3433   if (java_mirror() != NULL) {
3434     st-&gt;print(BULLET&quot;java mirror:       &quot;);
3435     java_mirror()-&gt;print_value_on(st);
3436     st-&gt;cr();
3437   } else {
3438     st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
3439   }
3440   st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
3441   if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
3442   st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
<span class="line-modified">3443   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_itable(), itable_length(), st);</span>
3444   st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
3445   FieldPrinter print_static_field(st);
3446   ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
3447   st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
3448   FieldPrinter print_nonstatic_field(st);
3449   InstanceKlass* ik = const_cast&lt;InstanceKlass*&gt;(this);
3450   ik-&gt;do_nonstatic_fields(&amp;print_nonstatic_field);
3451 
3452   st-&gt;print(BULLET&quot;non-static oop maps: &quot;);
3453   OopMapBlock* map     = start_of_nonstatic_oop_maps();
3454   OopMapBlock* end_map = map + nonstatic_oop_map_count();
3455   while (map &lt; end_map) {
3456     st-&gt;print(&quot;%d-%d &quot;, map-&gt;offset(), map-&gt;offset() + heapOopSize*(map-&gt;count() - 1));
3457     map++;
3458   }
3459   st-&gt;cr();
3460 }
3461 
3462 #endif //PRODUCT
3463 
</pre>
<hr />
<pre>
4159   if (holder == NULL) {
4160     return NULL; // The version of klass is gone, no method is found
4161   }
4162   Method* method = holder-&gt;method_with_orig_idnum(idnum);
4163   return method;
4164 }
4165 
4166 #if INCLUDE_JVMTI
4167 JvmtiCachedClassFileData* InstanceKlass::get_cached_class_file() {
4168   return _cached_class_file;
4169 }
4170 
4171 jint InstanceKlass::get_cached_class_file_len() {
4172   return VM_RedefineClasses::get_cached_class_file_len(_cached_class_file);
4173 }
4174 
4175 unsigned char * InstanceKlass::get_cached_class_file_bytes() {
4176   return VM_RedefineClasses::get_cached_class_file_bytes(_cached_class_file);
4177 }
4178 #endif





</pre>
</td>
<td>
<hr />
<pre>
  48 #include &quot;logging/logStream.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/iterator.inline.hpp&quot;
  51 #include &quot;memory/metadataFactory.hpp&quot;
  52 #include &quot;memory/metaspaceClosure.hpp&quot;
  53 #include &quot;memory/metaspaceShared.hpp&quot;
  54 #include &quot;memory/oopFactory.hpp&quot;
  55 #include &quot;memory/resourceArea.hpp&quot;
  56 #include &quot;memory/universe.hpp&quot;
  57 #include &quot;oops/fieldStreams.inline.hpp&quot;
  58 #include &quot;oops/constantPool.hpp&quot;
  59 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  60 #include &quot;oops/instanceKlass.inline.hpp&quot;
  61 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  62 #include &quot;oops/instanceOop.hpp&quot;
  63 #include &quot;oops/klass.inline.hpp&quot;
  64 #include &quot;oops/method.hpp&quot;
  65 #include &quot;oops/oop.inline.hpp&quot;
  66 #include &quot;oops/recordComponent.hpp&quot;
  67 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  68 #include &quot;oops/inlineKlass.hpp&quot;</span>
  69 #include &quot;prims/jvmtiExport.hpp&quot;
  70 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  71 #include &quot;prims/jvmtiThreadState.hpp&quot;
  72 #include &quot;prims/methodComparator.hpp&quot;
  73 #include &quot;runtime/atomic.hpp&quot;
  74 #include &quot;runtime/biasedLocking.hpp&quot;
  75 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  76 #include &quot;runtime/handles.inline.hpp&quot;
  77 #include &quot;runtime/javaCalls.hpp&quot;
  78 #include &quot;runtime/mutexLocker.hpp&quot;
  79 #include &quot;runtime/orderAccess.hpp&quot;
  80 #include &quot;runtime/thread.inline.hpp&quot;
  81 #include &quot;services/classLoadingService.hpp&quot;
  82 #include &quot;services/threadService.hpp&quot;
  83 #include &quot;utilities/dtrace.hpp&quot;
  84 #include &quot;utilities/events.hpp&quot;
  85 #include &quot;utilities/macros.hpp&quot;
  86 #include &quot;utilities/stringUtils.hpp&quot;
  87 #ifdef COMPILER1
  88 #include &quot;c1/c1_Compiler.hpp&quot;
</pre>
<hr />
<pre>
 139 
 140 static inline bool is_class_loader(const Symbol* class_name,
 141                                    const ClassFileParser&amp; parser) {
 142   assert(class_name != NULL, &quot;invariant&quot;);
 143 
 144   if (class_name == vmSymbols::java_lang_ClassLoader()) {
 145     return true;
 146   }
 147 
 148   if (SystemDictionary::ClassLoader_klass_loaded()) {
 149     const Klass* const super_klass = parser.super_klass();
 150     if (super_klass != NULL) {
 151       if (super_klass-&gt;is_subtype_of(SystemDictionary::ClassLoader_klass())) {
 152         return true;
 153       }
 154     }
 155   }
 156   return false;
 157 }
 158 
<span class="line-added"> 159 bool InstanceKlass::field_is_inline_type(int index) const { return Signature::basic_type(field(index)-&gt;signature(constants())) == T_INLINE_TYPE; }</span>
<span class="line-added"> 160 </span>
 161 // private: called to verify that k is a static member of this nest.
 162 // We know that k is an instance class in the same package and hence the
 163 // same classloader.
 164 bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {
 165   assert(!is_hidden(), &quot;unexpected hidden class&quot;);
 166   if (_nest_members == NULL || _nest_members == Universe::the_empty_short_array()) {
 167     if (log_is_enabled(Trace, class, nestmates)) {
 168       ResourceMark rm(THREAD);
 169       log_trace(class, nestmates)(&quot;Checked nest membership of %s in non-nest-host class %s&quot;,
 170                                   k-&gt;external_name(), this-&gt;external_name());
 171     }
 172     return false;
 173   }
 174 
 175   if (log_is_enabled(Trace, class, nestmates)) {
 176     ResourceMark rm(THREAD);
 177     log_trace(class, nestmates)(&quot;Checking nest membership of %s in %s&quot;,
 178                                 k-&gt;external_name(), this-&gt;external_name());
 179   }
 180 
</pre>
<hr />
<pre>
 459                               k-&gt;external_name());
 460   return access;
 461 }
 462 
 463 const char* InstanceKlass::nest_host_error(TRAPS) {
 464   if (_nest_host_index == 0) {
 465     return NULL;
 466   } else {
 467     constantPoolHandle cph(THREAD, constants());
 468     return SystemDictionary::find_nest_host_error(cph, (int)_nest_host_index);
 469   }
 470 }
 471 
 472 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
 473   bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();
 474   const int size = InstanceKlass::size(parser.vtable_size(),
 475                                        parser.itable_size(),
 476                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 477                                        parser.is_interface(),
 478                                        parser.is_unsafe_anonymous(),
<span class="line-modified"> 479                                        should_store_fingerprint(is_hidden_or_anonymous),</span>
<span class="line-added"> 480                                        parser.has_inline_fields() ? parser.java_fields_count() : 0,</span>
<span class="line-added"> 481                                        parser.is_inline_type());</span>
 482 
 483   const Symbol* const class_name = parser.class_name();
 484   assert(class_name != NULL, &quot;invariant&quot;);
 485   ClassLoaderData* loader_data = parser.loader_data();
 486   assert(loader_data != NULL, &quot;invariant&quot;);
 487 
 488   InstanceKlass* ik;
 489 
 490   // Allocation
 491   if (REF_NONE == parser.reference_type()) {
 492     if (class_name == vmSymbols::java_lang_Class()) {
 493       // mirror
 494       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
<span class="line-modified"> 495     } else if (is_class_loader(class_name, parser)) {</span>

 496       // class loader
 497       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);
<span class="line-added"> 498     } else if (parser.is_inline_type()) {</span>
<span class="line-added"> 499       // inline type</span>
<span class="line-added"> 500       ik = new (loader_data, size, THREAD) InlineKlass(parser);</span>
 501     } else {
 502       // normal
 503       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_kind_other);
 504     }
 505   } else {
 506     // reference
 507     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 508   }
 509 
 510   // Check for pending exception before adding to the loader data and incrementing
 511   // class count.  Can get OOM here.
 512   if (HAS_PENDING_EXCEPTION) {
 513     return NULL;
 514   }
 515 
<span class="line-added"> 516 #ifdef ASSERT</span>
<span class="line-added"> 517   assert(ik-&gt;size() == size, &quot;&quot;);</span>
<span class="line-added"> 518   ik-&gt;bounds_check((address) ik-&gt;start_of_vtable(), false, size);</span>
<span class="line-added"> 519   ik-&gt;bounds_check((address) ik-&gt;start_of_itable(), false, size);</span>
<span class="line-added"> 520   ik-&gt;bounds_check((address) ik-&gt;end_of_itable(), true, size);</span>
<span class="line-added"> 521   ik-&gt;bounds_check((address) ik-&gt;end_of_nonstatic_oop_maps(), true, size);</span>
<span class="line-added"> 522 #endif //ASSERT</span>
 523   return ik;
 524 }
 525 
<span class="line-added"> 526 #ifndef PRODUCT</span>
<span class="line-added"> 527 bool InstanceKlass::bounds_check(address addr, bool edge_ok, intptr_t size_in_bytes) const {</span>
<span class="line-added"> 528   const char* bad = NULL;</span>
<span class="line-added"> 529   address end = NULL;</span>
<span class="line-added"> 530   if (addr &lt; (address)this) {</span>
<span class="line-added"> 531     bad = &quot;before&quot;;</span>
<span class="line-added"> 532   } else if (addr == (address)this) {</span>
<span class="line-added"> 533     if (edge_ok)  return true;</span>
<span class="line-added"> 534     bad = &quot;just before&quot;;</span>
<span class="line-added"> 535   } else if (addr == (end = (address)this + sizeof(intptr_t) * (size_in_bytes &lt; 0 ? size() : size_in_bytes))) {</span>
<span class="line-added"> 536     if (edge_ok)  return true;</span>
<span class="line-added"> 537     bad = &quot;just after&quot;;</span>
<span class="line-added"> 538   } else if (addr &gt; end) {</span>
<span class="line-added"> 539     bad = &quot;after&quot;;</span>
<span class="line-added"> 540   } else {</span>
<span class="line-added"> 541     return true;</span>
<span class="line-added"> 542   }</span>
<span class="line-added"> 543   tty-&gt;print_cr(&quot;%s object bounds: &quot; INTPTR_FORMAT &quot; [&quot; INTPTR_FORMAT &quot;..&quot; INTPTR_FORMAT &quot;]&quot;,</span>
<span class="line-added"> 544       bad, (intptr_t)addr, (intptr_t)this, (intptr_t)end);</span>
<span class="line-added"> 545   Verbose = WizardMode = true; this-&gt;print(); //@@</span>
<span class="line-added"> 546   return false;</span>
<span class="line-added"> 547 }</span>
<span class="line-added"> 548 #endif //PRODUCT</span>
 549 
 550 // copy method ordering from resource area to Metaspace
 551 void InstanceKlass::copy_method_ordering(const intArray* m, TRAPS) {
 552   if (m != NULL) {
 553     // allocate a new array and copy contents (memcpy?)
 554     _method_ordering = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), m-&gt;length(), CHECK);
 555     for (int i = 0; i &lt; m-&gt;length(); i++) {
 556       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 557     }
 558   } else {
 559     _method_ordering = Universe::the_empty_int_array();
 560   }
 561 }
 562 
 563 // create a new array of vtable_indices for default methods
 564 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 565   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 566   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 567   set_default_vtable_indices(vtable_indices);
 568   return vtable_indices;
 569 }
 570 
 571 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 572   Klass(id),
 573   _nest_members(NULL),
 574   _nest_host(NULL),
 575   _permitted_subclasses(NULL),
 576   _record_components(NULL),
 577   _static_field_size(parser.static_field_size()),
 578   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 579   _itable_len(parser.itable_size()),
 580   _nest_host_index(0),
 581   _init_state(allocated),
 582   _reference_type(parser.reference_type()),
<span class="line-modified"> 583   _init_thread(NULL),</span>
<span class="line-added"> 584   _inline_type_field_klasses(NULL),</span>
<span class="line-added"> 585   _adr_inlineklass_fixed_block(NULL)</span>
 586 {
 587   set_vtable_length(parser.vtable_size());
 588   set_kind(kind);
 589   set_access_flags(parser.access_flags());
 590   if (parser.is_hidden()) set_is_hidden();
 591   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 592   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 593                                                     false));
<span class="line-added"> 594     if (parser.has_inline_fields()) {</span>
<span class="line-added"> 595       set_has_inline_type_fields();</span>
<span class="line-added"> 596     }</span>
<span class="line-added"> 597     _java_fields_count = parser.java_fields_count();</span>
 598 
<span class="line-modified"> 599     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);</span>
<span class="line-modified"> 600     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);</span>
<span class="line-modified"> 601     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);</span>
 602 
 603   // Set biased locking bit for all instances of this class; it will be
 604   // cleared if revocation occurs too often for this type
 605   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 606     set_prototype_header(markWord::biased_locking_prototype());
 607   }
<span class="line-added"> 608   if (has_inline_type_fields()) {</span>
<span class="line-added"> 609     _inline_type_field_klasses = (const Klass**) adr_inline_type_field_klasses();</span>
<span class="line-added"> 610   }</span>
 611 }
 612 
 613 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 614                                        Array&lt;Method*&gt;* methods) {
 615   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 616       !methods-&gt;is_shared()) {
 617     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 618       Method* method = methods-&gt;at(i);
 619       if (method == NULL) continue;  // maybe null if error processing
 620       // Only want to delete methods that are not executing for RedefineClasses.
 621       // The previous version will point to them so they&#39;re not totally dangling
 622       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 623       MetadataFactory::free_metadata(loader_data, method);
 624     }
 625     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 626   }
 627 }
 628 
 629 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 630                                           const Klass* super_klass,
 631                                           Array&lt;InstanceKlass*&gt;* local_interfaces,
 632                                           Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 633   // Only deallocate transitive interfaces if not empty, same as super class
 634   // or same as local interfaces.  See code in parseClassFile.
 635   Array&lt;InstanceKlass*&gt;* ti = transitive_interfaces;
 636   if (ti != Universe::the_empty_instance_klass_array() &amp;&amp; ti != local_interfaces) {
 637     // check that the interfaces don&#39;t come from super class
 638     Array&lt;InstanceKlass*&gt;* sti = (super_klass == NULL) ? NULL :
 639                     InstanceKlass::cast(super_klass)-&gt;transitive_interfaces();
<span class="line-modified"> 640     if (ti != sti &amp;&amp; ti != NULL &amp;&amp; !ti-&gt;is_shared() &amp;&amp;</span>
<span class="line-added"> 641         ti != Universe::the_single_IdentityObject_klass_array()) {</span>
 642       MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, ti);
 643     }
 644   }
 645 
 646   // local interfaces can be empty
 647   if (local_interfaces != Universe::the_empty_instance_klass_array() &amp;&amp;
<span class="line-modified"> 648       local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared() &amp;&amp;</span>
<span class="line-added"> 649       local_interfaces != Universe::the_single_IdentityObject_klass_array()) {</span>
 650     MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
 651   }
 652 }
 653 
 654 void InstanceKlass::deallocate_record_components(ClassLoaderData* loader_data,
 655                                                  Array&lt;RecordComponent*&gt;* record_components) {
 656   if (record_components != NULL &amp;&amp; !record_components-&gt;is_shared()) {
 657     for (int i = 0; i &lt; record_components-&gt;length(); i++) {
 658       RecordComponent* record_component = record_components-&gt;at(i);
 659       MetadataFactory::free_metadata(loader_data, record_component);
 660     }
 661     MetadataFactory::free_array&lt;RecordComponent*&gt;(loader_data, record_components);
 662   }
 663 }
 664 
 665 // This function deallocates the metadata and C heap pointers that the
 666 // InstanceKlass points to.
 667 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 668 
 669   // Orphan the mirror first, CMS thinks it&#39;s still live.
</pre>
<hr />
<pre>
 957         vmSymbols::java_lang_IncompatibleClassChangeError(),
 958         &quot;class %s has interface %s as super class&quot;,
 959         external_name(),
 960         super_klass-&gt;external_name()
 961       );
 962       return false;
 963     }
 964 
 965     InstanceKlass* ik_super = InstanceKlass::cast(super_klass);
 966     ik_super-&gt;link_class_impl(CHECK_false);
 967   }
 968 
 969   // link all interfaces implemented by this class before linking this class
 970   Array&lt;InstanceKlass*&gt;* interfaces = local_interfaces();
 971   int num_interfaces = interfaces-&gt;length();
 972   for (int index = 0; index &lt; num_interfaces; index++) {
 973     InstanceKlass* interk = interfaces-&gt;at(index);
 974     interk-&gt;link_class_impl(CHECK_false);
 975   }
 976 
<span class="line-added"> 977 </span>
<span class="line-added"> 978   // If a class declares a method that uses an inline class as an argument</span>
<span class="line-added"> 979   // type or return inline type, this inline class must be loaded during the</span>
<span class="line-added"> 980   // linking of this class because size and properties of the inline class</span>
<span class="line-added"> 981   // must be known in order to be able to perform inline type optimizations.</span>
<span class="line-added"> 982   // The implementation below is an approximation of this rule, the code</span>
<span class="line-added"> 983   // iterates over all methods of the current class (including overridden</span>
<span class="line-added"> 984   // methods), not only the methods declared by this class. This</span>
<span class="line-added"> 985   // approximation makes the code simpler, and doesn&#39;t change the semantic</span>
<span class="line-added"> 986   // because classes declaring methods overridden by the current class are</span>
<span class="line-added"> 987   // linked (and have performed their own pre-loading) before the linking</span>
<span class="line-added"> 988   // of the current class.</span>
<span class="line-added"> 989 </span>
<span class="line-added"> 990 </span>
<span class="line-added"> 991   // Note:</span>
<span class="line-added"> 992   // Inline class types are loaded during</span>
<span class="line-added"> 993   // the loading phase (see ClassFileParser::post_process_parsed_stream()).</span>
<span class="line-added"> 994   // Inline class types used as element types for array creation</span>
<span class="line-added"> 995   // are not pre-loaded. Their loading is triggered by either anewarray</span>
<span class="line-added"> 996   // or multianewarray bytecodes.</span>
<span class="line-added"> 997 </span>
<span class="line-added"> 998   // Could it be possible to do the following processing only if the</span>
<span class="line-added"> 999   // class uses inline types?</span>
<span class="line-added">1000   {</span>
<span class="line-added">1001     ResourceMark rm(THREAD);</span>
<span class="line-added">1002     for (int i = 0; i &lt; methods()-&gt;length(); i++) {</span>
<span class="line-added">1003       Method* m = methods()-&gt;at(i);</span>
<span class="line-added">1004       for (SignatureStream ss(m-&gt;signature()); !ss.is_done(); ss.next()) {</span>
<span class="line-added">1005         if (ss.is_reference()) {</span>
<span class="line-added">1006           if (ss.is_array()) {</span>
<span class="line-added">1007             ss.skip_array_prefix();</span>
<span class="line-added">1008           }</span>
<span class="line-added">1009           if (ss.type() == T_INLINE_TYPE) {</span>
<span class="line-added">1010             Symbol* symb = ss.as_symbol();</span>
<span class="line-added">1011 </span>
<span class="line-added">1012             oop loader = class_loader();</span>
<span class="line-added">1013             oop protection_domain = this-&gt;protection_domain();</span>
<span class="line-added">1014             Klass* klass = SystemDictionary::resolve_or_fail(symb,</span>
<span class="line-added">1015                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,</span>
<span class="line-added">1016                                                              CHECK_false);</span>
<span class="line-added">1017             if (klass == NULL) {</span>
<span class="line-added">1018               THROW_(vmSymbols::java_lang_LinkageError(), false);</span>
<span class="line-added">1019             }</span>
<span class="line-added">1020             if (!klass-&gt;is_inline_klass()) {</span>
<span class="line-added">1021               Exceptions::fthrow(</span>
<span class="line-added">1022                 THREAD_AND_LOCATION,</span>
<span class="line-added">1023                 vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">1024                 &quot;class %s is not an inline type&quot;,</span>
<span class="line-added">1025                 klass-&gt;external_name());</span>
<span class="line-added">1026             }</span>
<span class="line-added">1027           }</span>
<span class="line-added">1028         }</span>
<span class="line-added">1029       }</span>
<span class="line-added">1030     }</span>
<span class="line-added">1031   }</span>
<span class="line-added">1032 </span>
1033   // in case the class is linked in the process of linking its superclasses
1034   if (is_linked()) {
1035     return true;
1036   }
1037 
1038   // trace only the link time for this klass that includes
1039   // the verification time
1040   PerfClassTraceTime vmtimer(ClassLoader::perf_class_link_time(),
1041                              ClassLoader::perf_class_link_selftime(),
1042                              ClassLoader::perf_classes_linked(),
1043                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1044                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1045                              PerfClassTraceTime::CLASS_LINK);
1046 
1047   // verification &amp; rewriting
1048   {
1049     HandleMark hm(THREAD);
1050     Handle h_init_lock(THREAD, init_lock());
1051     ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);
1052     // rewritten will have been set if loader constraint error found
</pre>
<hr />
<pre>
1084       // fabricate new Method*s.
1085       // also does loader constraint checking
1086       //
1087       // initialize_vtable and initialize_itable need to be rerun
1088       // for a shared class if
1089       // 1) the class is loaded by custom class loader or
1090       // 2) the class is loaded by built-in class loader but failed to add archived loader constraints
1091       bool need_init_table = true;
1092       if (is_shared() &amp;&amp; SystemDictionaryShared::check_linking_constraints(this, THREAD)) {
1093         need_init_table = false;
1094       }
1095       if (need_init_table) {
1096         vtable().initialize_vtable(true, CHECK_false);
1097         itable().initialize_itable(true, CHECK_false);
1098       }
1099 #ifdef ASSERT
1100       vtable().verify(tty, true);
1101       // In case itable verification is ever added.
1102       // itable().verify(tty, true);
1103 #endif
<span class="line-added">1104 </span>
1105       set_init_state(linked);
1106       if (JvmtiExport::should_post_class_prepare()) {
1107         Thread *thread = THREAD;
1108         assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1109         JvmtiExport::post_class_prepare((JavaThread *) thread, this);
1110       }
1111     }
1112   }
1113   return true;
1114 }
1115 
1116 // Rewrite the byte codes of all of the methods of a class.
1117 // The rewriter must be called exactly once. Rewriting must happen after
1118 // verification but before the first method of the class is executed.
1119 void InstanceKlass::rewrite_class(TRAPS) {
1120   assert(is_loaded(), &quot;must be loaded&quot;);
1121   if (is_rewritten()) {
1122     assert(is_shared(), &quot;rewriting an unshared class?&quot;);
1123     return;
1124   }
</pre>
<hr />
<pre>
1238     // having a superinterface that declares, non-static, concrete methods
1239     if (!HAS_PENDING_EXCEPTION &amp;&amp; has_nonstatic_concrete_methods()) {
1240       initialize_super_interfaces(THREAD);
1241     }
1242 
1243     // If any exceptions, complete abruptly, throwing the same exception as above.
1244     if (HAS_PENDING_EXCEPTION) {
1245       Handle e(THREAD, PENDING_EXCEPTION);
1246       CLEAR_PENDING_EXCEPTION;
1247       {
1248         EXCEPTION_MARK;
1249         // Locks object, set state, and notify all waiting threads
1250         set_initialization_state_and_notify(initialization_error, THREAD);
1251         CLEAR_PENDING_EXCEPTION;
1252       }
1253       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1254       THROW_OOP(e());
1255     }
1256   }
1257 
<span class="line-added">1258   // Step 8</span>
<span class="line-added">1259   // Initialize classes of inline fields</span>
<span class="line-added">1260   {</span>
<span class="line-added">1261     for (AllFieldStream fs(this); !fs.done(); fs.next()) {</span>
<span class="line-added">1262       if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE) {</span>
<span class="line-added">1263         Klass* klass = get_inline_type_field_klass_or_null(fs.index());</span>
<span class="line-added">1264         if (fs.access_flags().is_static() &amp;&amp; klass == NULL) {</span>
<span class="line-added">1265           klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())-&gt;fundamental_name(THREAD),</span>
<span class="line-added">1266               Handle(THREAD, class_loader()),</span>
<span class="line-added">1267               Handle(THREAD, protection_domain()),</span>
<span class="line-added">1268               true, CHECK);</span>
<span class="line-added">1269           if (klass == NULL) {</span>
<span class="line-added">1270             THROW(vmSymbols::java_lang_NoClassDefFoundError());</span>
<span class="line-added">1271           }</span>
<span class="line-added">1272           if (!klass-&gt;is_inline_klass()) {</span>
<span class="line-added">1273             THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added">1274           }</span>
<span class="line-added">1275           set_inline_type_field_klass(fs.index(), klass);</span>
<span class="line-added">1276         }</span>
<span class="line-added">1277         InstanceKlass::cast(klass)-&gt;initialize(CHECK);</span>
<span class="line-added">1278         if (fs.access_flags().is_static()) {</span>
<span class="line-added">1279           if (java_mirror()-&gt;obj_field(fs.offset()) == NULL) {</span>
<span class="line-added">1280             java_mirror()-&gt;obj_field_put(fs.offset(), InlineKlass::cast(klass)-&gt;default_value());</span>
<span class="line-added">1281           }</span>
<span class="line-added">1282         }</span>
<span class="line-added">1283       }</span>
<span class="line-added">1284     }</span>
<span class="line-added">1285   }</span>
<span class="line-added">1286 </span>
1287 
1288   // Look for aot compiled methods for this klass, including class initializer.
1289   AOTLoader::load_for_klass(this, THREAD);
1290 
<span class="line-modified">1291   // Step 9</span>
1292   {
1293     DTRACE_CLASSINIT_PROBE_WAIT(clinit, -1, wait);
1294     if (class_initializer() != NULL) {
1295       // Timer includes any side effects of class initialization (resolution,
1296       // etc), but not recursive entry into call_class_initializer().
1297       PerfClassTraceTime timer(ClassLoader::perf_class_init_time(),
1298                                ClassLoader::perf_class_init_selftime(),
1299                                ClassLoader::perf_classes_inited(),
1300                                jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1301                                jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1302                                PerfClassTraceTime::CLASS_CLINIT);
1303       call_class_initializer(THREAD);
1304     } else {
1305       // The elapsed time is so small it&#39;s not worth counting.
1306       if (UsePerfData) {
1307         ClassLoader::perf_classes_inited()-&gt;inc();
1308       }
1309       call_class_initializer(THREAD);
1310     }
1311   }
1312 
<span class="line-modified">1313   // Step 10</span>
1314   if (!HAS_PENDING_EXCEPTION) {
1315     set_initialization_state_and_notify(fully_initialized, CHECK);
1316     {
1317       debug_only(vtable().verify(tty, true);)
1318     }
1319   }
1320   else {
<span class="line-modified">1321     // Step 11 and 12</span>
1322     Handle e(THREAD, PENDING_EXCEPTION);
1323     CLEAR_PENDING_EXCEPTION;
1324     // JVMTI has already reported the pending exception
1325     // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1326     JvmtiExport::clear_detected_exception(jt);
1327     {
1328       EXCEPTION_MARK;
1329       set_initialization_state_and_notify(initialization_error, THREAD);
1330       CLEAR_PENDING_EXCEPTION;   // ignore any exception thrown, class initialization error is thrown below
1331       // JVMTI has already reported the pending exception
1332       // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1333       JvmtiExport::clear_detected_exception(jt);
1334     }
1335     DTRACE_CLASSINIT_PROBE_WAIT(error, -1, wait);
1336     if (e-&gt;is_a(SystemDictionary::Error_klass())) {
1337       THROW_OOP(e());
1338     } else {
1339       JavaCallArguments args(e);
1340       THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),
1341                 vmSymbols::throwable_void_signature(),
</pre>
<hr />
<pre>
1589       }
1590     }
1591   }
1592   // _this will always be set at this point
1593   ObjArrayKlass* oak = array_klasses();
1594   if (or_null) {
1595     return oak-&gt;array_klass_or_null(n);
1596   }
1597   return oak-&gt;array_klass(n, THREAD);
1598 }
1599 
1600 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
1601   return array_klass_impl(or_null, 1, THREAD);
1602 }
1603 
1604 static int call_class_initializer_counter = 0;   // for debugging
1605 
1606 Method* InstanceKlass::class_initializer() const {
1607   Method* clinit = find_method(
1608       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
<span class="line-modified">1609   if (clinit != NULL &amp;&amp; clinit-&gt;is_class_initializer()) {</span>
1610     return clinit;
1611   }
1612   return NULL;
1613 }
1614 
1615 void InstanceKlass::call_class_initializer(TRAPS) {
1616   if (ReplayCompiles &amp;&amp;
1617       (ReplaySuppressInitializers == 1 ||
1618        (ReplaySuppressInitializers &gt;= 2 &amp;&amp; class_loader() != NULL))) {
1619     // Hide the existence of the initializer for the purpose of replaying the compile
1620     return;
1621   }
1622 
1623   methodHandle h_method(THREAD, class_initializer());
1624   assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
1625   LogTarget(Info, class, init) lt;
1626   if (lt.is_enabled()) {
1627     ResourceMark rm(THREAD);
1628     LogStream ls(lt);
1629     ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
1630     name()-&gt;print_value_on(&amp;ls);
1631     ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
1632   }
1633   if (h_method() != NULL) {
1634     JavaCallArguments args; // No arguments
1635     JavaValue result(T_VOID);
1636     JavaCalls::call(&amp;result, h_method, &amp;args, CHECK); // Static call (no args)
1637   }
1638 }
1639 
1640 
1641 void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
1642   InterpreterOopMap* entry_for) {
1643   // Lazily create the _oop_map_cache at first request
1644   // Lock-free access requires load_acquire.
1645   OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);
1646   if (oop_map_cache == NULL) {
<span class="line-modified">1647     MutexLocker x(OopMapCacheAlloc_lock,  Mutex::_no_safepoint_check_flag);</span>
1648     // Check if _oop_map_cache was allocated while we were waiting for this lock
1649     if ((oop_map_cache = _oop_map_cache) == NULL) {
1650       oop_map_cache = new OopMapCache();
1651       // Ensure _oop_map_cache is stable, since it is examined without a lock
1652       Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);
1653     }
1654   }
1655   // _oop_map_cache is constant after init; lookup below does its own locking.
1656   oop_map_cache-&gt;lookup(method, bci, entry_for);
1657 }
1658 





1659 bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1660   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1661     Symbol* f_name = fs.name();
1662     Symbol* f_sig  = fs.signature();
1663     if (f_name == name &amp;&amp; f_sig == sig) {
1664       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1665       return true;
1666     }
1667   }
1668   return false;
1669 }
1670 
1671 
1672 Klass* InstanceKlass::find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1673   const int n = local_interfaces()-&gt;length();
1674   for (int i = 0; i &lt; n; i++) {
1675     Klass* intf1 = local_interfaces()-&gt;at(i);
1676     assert(intf1-&gt;is_interface(), &quot;just checking type&quot;);
1677     // search for field in current interface
1678     if (InstanceKlass::cast(intf1)-&gt;find_local_field(name, sig, fd)) {
</pre>
<hr />
<pre>
1709 
1710 Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {
1711   // search order according to newest JVM spec (5.4.3.2, p.167).
1712   // 1) search for field in current klass
1713   if (find_local_field(name, sig, fd)) {
1714     if (fd-&gt;is_static() == is_static) return const_cast&lt;InstanceKlass*&gt;(this);
1715   }
1716   // 2) search for field recursively in direct superinterfaces
1717   if (is_static) {
1718     Klass* intf = find_interface_field(name, sig, fd);
1719     if (intf != NULL) return intf;
1720   }
1721   // 3) apply field lookup recursively if superclass exists
1722   { Klass* supr = super();
1723     if (supr != NULL) return InstanceKlass::cast(supr)-&gt;find_field(name, sig, is_static, fd);
1724   }
1725   // 4) otherwise field lookup fails
1726   return NULL;
1727 }
1728 
<span class="line-added">1729 bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-added">1730   if (this-&gt;is_inline_klass()) {</span>
<span class="line-added">1731     InlineKlass* vk = InlineKlass::cast(this);</span>
<span class="line-added">1732     return offset &gt;= vk-&gt;first_field_offset() &amp;&amp; offset &lt; (vk-&gt;first_field_offset() + vk-&gt;get_exact_size_in_bytes());</span>
<span class="line-added">1733   } else {</span>
<span class="line-added">1734     fieldDescriptor fd;</span>
<span class="line-added">1735     return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-added">1736   }</span>
<span class="line-added">1737 }</span>
1738 
1739 bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1740   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1741     if (fs.offset() == offset) {
1742       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1743       if (fd-&gt;is_static() == is_static) return true;
1744     }
1745   }
1746   return false;
1747 }
1748 
1749 
1750 bool InstanceKlass::find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1751   Klass* klass = const_cast&lt;InstanceKlass*&gt;(this);
1752   while (klass != NULL) {
1753     if (InstanceKlass::cast(klass)-&gt;find_local_field_from_offset(offset, is_static, fd)) {
1754       return true;
1755     }
1756     klass = klass-&gt;super();
1757   }
</pre>
<hr />
<pre>
2102 }
2103 
2104 // uncached_lookup_method searches both the local class methods array and all
2105 // superclasses methods arrays, skipping any overpass methods in superclasses,
2106 // and possibly skipping private methods.
2107 Method* InstanceKlass::uncached_lookup_method(const Symbol* name,
2108                                               const Symbol* signature,
2109                                               OverpassLookupMode overpass_mode,
2110                                               PrivateLookupMode private_mode) const {
2111   OverpassLookupMode overpass_local_mode = overpass_mode;
2112   const Klass* klass = this;
2113   while (klass != NULL) {
2114     Method* const method = InstanceKlass::cast(klass)-&gt;find_method_impl(name,
2115                                                                         signature,
2116                                                                         overpass_local_mode,
2117                                                                         find_static,
2118                                                                         private_mode);
2119     if (method != NULL) {
2120       return method;
2121     }
<span class="line-added">2122     if (name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">2123       break;  // &lt;init&gt; is never inherited, not even as a static factory</span>
<span class="line-added">2124     }</span>
2125     klass = klass-&gt;super();
2126     overpass_local_mode = skip_overpass;   // Always ignore overpass methods in superclasses
2127   }
2128   return NULL;
2129 }
2130 
2131 #ifdef ASSERT
2132 // search through class hierarchy and return true if this class or
2133 // one of the superclasses was redefined
2134 bool InstanceKlass::has_redefined_this_or_super() const {
2135   const Klass* klass = this;
2136   while (klass != NULL) {
2137     if (InstanceKlass::cast(klass)-&gt;has_been_redefined()) {
2138       return true;
2139     }
2140     klass = klass-&gt;super();
2141   }
2142   return false;
2143 }
2144 #endif
</pre>
<hr />
<pre>
2613     itableOffsetEntry* ioe = (itableOffsetEntry*)start_of_itable();
2614     int method_table_offset_in_words = ioe-&gt;offset()/wordSize;
2615     int nof_interfaces = (method_table_offset_in_words - itable_offset_in_words())
2616                          / itableOffsetEntry::size();
2617 
2618     for (int i = 0; i &lt; nof_interfaces; i ++, ioe ++) {
2619       if (ioe-&gt;interface_klass() != NULL) {
2620         it-&gt;push(ioe-&gt;interface_klass_addr());
2621         itableMethodEntry* ime = ioe-&gt;first_method_entry(this);
2622         int n = klassItable::method_count_for_interface(ioe-&gt;interface_klass());
2623         for (int index = 0; index &lt; n; index ++) {
2624           it-&gt;push(ime[index].method_addr());
2625         }
2626       }
2627     }
2628   }
2629 
2630   it-&gt;push(&amp;_nest_members);
2631   it-&gt;push(&amp;_permitted_subclasses);
2632   it-&gt;push(&amp;_record_components);
<span class="line-added">2633 </span>
<span class="line-added">2634   if (has_inline_type_fields()) {</span>
<span class="line-added">2635     for (int i = 0; i &lt; java_fields_count(); i++) {</span>
<span class="line-added">2636       it-&gt;push(&amp;((Klass**)adr_inline_type_field_klasses())[i]);</span>
<span class="line-added">2637     }</span>
<span class="line-added">2638   }</span>
2639 }
2640 
2641 void InstanceKlass::remove_unshareable_info() {
2642   Klass::remove_unshareable_info();
2643 
2644   if (SystemDictionaryShared::has_class_failed_verification(this)) {
2645     // Classes are attempted to link during dumping and may fail,
2646     // but these classes are still in the dictionary and class list in CLD.
2647     // If the class has failed verification, there is nothing else to remove.
2648     return;
2649   }
2650 
2651   // Reset to the &#39;allocated&#39; state to prevent any premature accessing to
2652   // a shared class at runtime while the class is still being loaded and
2653   // restored. A class&#39; init_state is set to &#39;loaded&#39; at runtime when it&#39;s
2654   // being added to class hierarchy (see SystemDictionary:::add_to_hierarchy()).
2655   _init_state = allocated;
2656 
2657   { // Otherwise this needs to take out the Compile_lock.
2658     assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
2659     init_implementor();
2660   }
2661 
2662   constants()-&gt;remove_unshareable_info();
2663 
2664   for (int i = 0; i &lt; methods()-&gt;length(); i++) {
2665     Method* m = methods()-&gt;at(i);
2666     m-&gt;remove_unshareable_info();
2667   }
2668 
2669   // do array classes also.
2670   if (array_klasses() != NULL) {
2671     array_klasses()-&gt;remove_unshareable_info();
2672   }
2673 
<span class="line-added">2674   if (has_inline_type_fields()) {</span>
<span class="line-added">2675     for (AllFieldStream fs(fields(), constants()); !fs.done(); fs.next()) {</span>
<span class="line-added">2676       if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE) {</span>
<span class="line-added">2677         reset_inline_type_field_klass(fs.index());</span>
<span class="line-added">2678       }</span>
<span class="line-added">2679     }</span>
<span class="line-added">2680   }</span>
<span class="line-added">2681 </span>
2682   // These are not allocated from metaspace. They are safe to set to NULL.
2683   _source_debug_extension = NULL;
2684   _dep_context = NULL;
2685   _osr_nmethods_head = NULL;
2686 #if INCLUDE_JVMTI
2687   _breakpoints = NULL;
2688   _previous_versions = NULL;
2689   _cached_class_file = NULL;
2690   _jvmti_cached_class_field_map = NULL;
2691 #endif
2692 
2693   _init_thread = NULL;
2694   _methods_jmethod_ids = NULL;
2695   _jni_ids = NULL;
2696   _oop_map_cache = NULL;
2697   // clear _nest_host to ensure re-load at runtime
2698   _nest_host = NULL;
2699   _package_entry = NULL;
2700   _dep_context_last_cleaned = 0;
2701 }
2702 
2703 void InstanceKlass::remove_java_mirror() {
2704   Klass::remove_java_mirror();
2705 
2706   // do array classes also.
2707   if (array_klasses() != NULL) {
2708     array_klasses()-&gt;remove_java_mirror();
2709   }
2710 }
2711 
2712 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,
2713                                              PackageEntry* pkg_entry, TRAPS) {
2714   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2715   // before the InstanceKlass is added to the SystemDictionary. Make
2716   // sure the current state is &lt;loaded.
2717   assert(!is_loaded(), &quot;invalid init state&quot;);
2718   set_package(loader_data, pkg_entry, CHECK);
2719   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2720 
<span class="line-added">2721   if (is_inline_klass()) {</span>
<span class="line-added">2722     InlineKlass::cast(this)-&gt;initialize_calling_convention(CHECK);</span>
<span class="line-added">2723   }</span>
<span class="line-added">2724 </span>
2725   Array&lt;Method*&gt;* methods = this-&gt;methods();
2726   int num_methods = methods-&gt;length();
2727   for (int index = 0; index &lt; num_methods; ++index) {
2728     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2729   }
2730   if (JvmtiExport::has_redefined_a_class()) {
2731     // Reinitialize vtable because RedefineClasses may have changed some
2732     // entries in this vtable for super classes so the CDS vtable might
2733     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2734     // vtables in the shared system dictionary, only the main one.
2735     // It also redefines the itable too so fix that too.
2736     vtable().initialize_vtable(false, CHECK);
2737     itable().initialize_itable(false, CHECK);
2738   }
2739 
2740   // restore constant pool resolved references
2741   constants()-&gt;restore_unshareable_info(CHECK);
2742 
2743   if (array_klasses() != NULL) {
2744     // Array classes have null protection domain.
2745     // --&gt; see ArrayKlass::complete_create_array_klass()
2746     array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2747   }
2748 
2749   // Initialize current biased locking state.
<span class="line-modified">2750   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_inline_klass()) {</span>
2751     set_prototype_header(markWord::biased_locking_prototype());
2752   }
2753 }
2754 
2755 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2756   switch (loader_type) {
2757   case ClassLoader::BOOT_LOADER:
2758     _misc_flags |= _misc_is_shared_boot_class;
2759     break;
2760   case ClassLoader::PLATFORM_LOADER:
2761     _misc_flags |= _misc_is_shared_platform_class;
2762     break;
2763   case ClassLoader::APP_LOADER:
2764     _misc_flags |= _misc_is_shared_app_class;
2765     break;
2766   default:
2767     ShouldNotReachHere();
2768     break;
2769   }
2770 }
</pre>
<hr />
<pre>
2895   }
2896 }
2897 
2898 const char* InstanceKlass::signature_name() const {
2899   int hash_len = 0;
2900   char hash_buf[40];
2901 
2902   // If this is an unsafe anonymous class, append a hash to make the name unique
2903   if (is_unsafe_anonymous()) {
2904     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2905     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2906     hash_len = (int)strlen(hash_buf);
2907   }
2908 
2909   // Get the internal name as a c string
2910   const char* src = (const char*) (name()-&gt;as_C_string());
2911   const int src_length = (int)strlen(src);
2912 
2913   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2914 
<span class="line-modified">2915   // Add L or Q as type indicator</span>
2916   int dest_index = 0;
<span class="line-modified">2917   dest[dest_index++] = is_inline_klass() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;</span>
2918 
2919   // Add the actual class name
2920   for (int src_index = 0; src_index &lt; src_length; ) {
2921     dest[dest_index++] = src[src_index++];
2922   }
2923 
2924   if (is_hidden()) { // Replace the last &#39;+&#39; with a &#39;.&#39;.
2925     for (int index = (int)src_length; index &gt; 0; index--) {
2926       if (dest[index] == &#39;+&#39;) {
2927         dest[index] = JVM_SIGNATURE_DOT;
2928         break;
2929       }
2930     }
2931   }
2932 
2933   // If we have a hash, append it
2934   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2935     dest[dest_index++] = hash_buf[hash_index++];
2936   }
2937 
</pre>
<hr />
<pre>
3457   }
3458 
3459   assert(match_level == false || best == NULL, &quot;shouldn&#39;t pick up anything if match_level is set&quot;);
3460   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level) {
3461     return best;
3462   }
3463   return NULL;
3464 }
3465 
3466 // -----------------------------------------------------------------------------------------------------
3467 // Printing
3468 
3469 #ifndef PRODUCT
3470 
3471 #define BULLET  &quot; - &quot;
3472 
3473 static const char* state_names[] = {
3474   &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
3475 };
3476 
<span class="line-modified">3477 static void print_vtable(address self, intptr_t* start, int len, outputStream* st) {</span>
<span class="line-added">3478   ResourceMark rm;</span>
<span class="line-added">3479   int* forward_refs = NEW_RESOURCE_ARRAY(int, len);</span>
<span class="line-added">3480   for (int i = 0; i &lt; len; i++)  forward_refs[i] = 0;</span>
3481   for (int i = 0; i &lt; len; i++) {
3482     intptr_t e = start[i];
3483     st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);
<span class="line-added">3484     if (forward_refs[i] != 0) {</span>
<span class="line-added">3485       int from = forward_refs[i];</span>
<span class="line-added">3486       int off = (int) start[from];</span>
<span class="line-added">3487       st-&gt;print(&quot; (offset %d &lt;= [%d])&quot;, off, from);</span>
<span class="line-added">3488     }</span>
3489     if (MetaspaceObj::is_valid((Metadata*)e)) {
3490       st-&gt;print(&quot; &quot;);
3491       ((Metadata*)e)-&gt;print_value_on(st);
<span class="line-added">3492     } else if (self != NULL &amp;&amp; e &gt; 0 &amp;&amp; e &lt; 0x10000) {</span>
<span class="line-added">3493       address location = self + e;</span>
<span class="line-added">3494       int index = (int)((intptr_t*)location - start);</span>
<span class="line-added">3495       st-&gt;print(&quot; (offset %d =&gt; [%d])&quot;, (int)e, index);</span>
<span class="line-added">3496       if (index &gt;= 0 &amp;&amp; index &lt; len)</span>
<span class="line-added">3497         forward_refs[index] = i;</span>
3498     }
3499     st-&gt;cr();
3500   }
3501 }
3502 
3503 static void print_vtable(vtableEntry* start, int len, outputStream* st) {
<span class="line-modified">3504   return print_vtable(NULL, reinterpret_cast&lt;intptr_t*&gt;(start), len, st);</span>
<span class="line-added">3505 }</span>
<span class="line-added">3506 </span>
<span class="line-added">3507 template&lt;typename T&gt;</span>
<span class="line-added">3508  static void print_array_on(outputStream* st, Array&lt;T&gt;* array) {</span>
<span class="line-added">3509    if (array == NULL) { st-&gt;print_cr(&quot;NULL&quot;); return; }</span>
<span class="line-added">3510    array-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3511    if (Verbose || WizardMode) {</span>
<span class="line-added">3512      for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="line-added">3513        st-&gt;print(&quot;%d : &quot;, i); array-&gt;at(i)-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3514      }</span>
<span class="line-added">3515    }</span>
<span class="line-added">3516  }</span>
<span class="line-added">3517 </span>
<span class="line-added">3518 static void print_array_on(outputStream* st, Array&lt;int&gt;* array) {</span>
<span class="line-added">3519   if (array == NULL) { st-&gt;print_cr(&quot;NULL&quot;); return; }</span>
<span class="line-added">3520   array-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3521   if (Verbose || WizardMode) {</span>
<span class="line-added">3522     for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="line-added">3523       st-&gt;print(&quot;%d : %d&quot;, i, array-&gt;at(i)); st-&gt;cr();</span>
<span class="line-added">3524     }</span>
<span class="line-added">3525   }</span>
3526 }
3527 
3528 void InstanceKlass::print_on(outputStream* st) const {
3529   assert(is_klass(), &quot;must be klass&quot;);
3530   Klass::print_on(st);
3531 
3532   st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
3533   st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
3534   st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();
<span class="line-added">3535   st-&gt;print(BULLET&quot;misc flags:        0x%x&quot;, _misc_flags);                        st-&gt;cr();</span>
3536   st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
3537   st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
3538   st-&gt;print(BULLET&quot;super:             &quot;); Metadata::print_value_on_maybe_null(st, super()); st-&gt;cr();
3539   st-&gt;print(BULLET&quot;sub:               &quot;);
3540   Klass* sub = subklass();
3541   int n;
3542   for (n = 0; sub != NULL; n++, sub = sub-&gt;next_sibling()) {
3543     if (n &lt; MaxSubklassPrintSize) {
3544       sub-&gt;print_value_on(st);
3545       st-&gt;print(&quot;   &quot;);
3546     }
3547   }
3548   if (n &gt;= MaxSubklassPrintSize) st-&gt;print(&quot;(&quot; INTX_FORMAT &quot; more klasses...)&quot;, n - MaxSubklassPrintSize);
3549   st-&gt;cr();
3550 
3551   if (is_interface()) {
3552     st-&gt;print_cr(BULLET&quot;nof implementors:  %d&quot;, nof_implementors());
3553     if (nof_implementors() == 1) {
3554       st-&gt;print_cr(BULLET&quot;implementor:    &quot;);
3555       st-&gt;print(&quot;   &quot;);
3556       implementor()-&gt;print_value_on(st);
3557       st-&gt;cr();
3558     }
3559   }
3560 
3561   st-&gt;print(BULLET&quot;arrays:            &quot;); Metadata::print_value_on_maybe_null(st, array_klasses()); st-&gt;cr();
<span class="line-modified">3562   st-&gt;print(BULLET&quot;methods:           &quot;); print_array_on(st, methods());</span>
<span class="line-modified">3563   st-&gt;print(BULLET&quot;method ordering:   &quot;); print_array_on(st, method_ordering());</span>
<span class="line-modified">3564   st-&gt;print(BULLET&quot;default_methods:   &quot;); print_array_on(st, default_methods());</span>












3565   if (default_vtable_indices() != NULL) {
<span class="line-modified">3566     st-&gt;print(BULLET&quot;default vtable indices:   &quot;); print_array_on(st, default_vtable_indices());</span>
3567   }
<span class="line-modified">3568   st-&gt;print(BULLET&quot;local interfaces:  &quot;); print_array_on(st, local_interfaces());</span>
<span class="line-modified">3569   st-&gt;print(BULLET&quot;trans. interfaces: &quot;); print_array_on(st, transitive_interfaces());</span>
3570   st-&gt;print(BULLET&quot;constants:         &quot;); constants()-&gt;print_value_on(st);         st-&gt;cr();
3571   if (class_loader_data() != NULL) {
3572     st-&gt;print(BULLET&quot;class loader data:  &quot;);
3573     class_loader_data()-&gt;print_value_on(st);
3574     st-&gt;cr();
3575   }
3576   st-&gt;print(BULLET&quot;unsafe anonymous host class:        &quot;); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st-&gt;cr();
3577   if (source_file_name() != NULL) {
3578     st-&gt;print(BULLET&quot;source file:       &quot;);
3579     source_file_name()-&gt;print_value_on(st);
3580     st-&gt;cr();
3581   }
3582   if (source_debug_extension() != NULL) {
3583     st-&gt;print(BULLET&quot;source debug extension:       &quot;);
3584     st-&gt;print(&quot;%s&quot;, source_debug_extension());
3585     st-&gt;cr();
3586   }
3587   st-&gt;print(BULLET&quot;class annotations:       &quot;); class_annotations()-&gt;print_value_on(st); st-&gt;cr();
3588   st-&gt;print(BULLET&quot;class type annotations:  &quot;); class_type_annotations()-&gt;print_value_on(st); st-&gt;cr();
3589   st-&gt;print(BULLET&quot;field annotations:       &quot;); fields_annotations()-&gt;print_value_on(st); st-&gt;cr();
</pre>
<hr />
<pre>
3606     st-&gt;print(BULLET&quot;generic signature: &quot;);
3607     generic_signature()-&gt;print_value_on(st);
3608     st-&gt;cr();
3609   }
3610   st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
3611   st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();
3612   if (record_components() != NULL) {
3613     st-&gt;print(BULLET&quot;record components:     &quot;); record_components()-&gt;print_value_on(st);     st-&gt;cr();
3614   }
3615   st-&gt;print(BULLET&quot;permitted subclasses:     &quot;); permitted_subclasses()-&gt;print_value_on(st);     st-&gt;cr();
3616   if (java_mirror() != NULL) {
3617     st-&gt;print(BULLET&quot;java mirror:       &quot;);
3618     java_mirror()-&gt;print_value_on(st);
3619     st-&gt;cr();
3620   } else {
3621     st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
3622   }
3623   st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
3624   if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
3625   st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
<span class="line-modified">3626   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(NULL, start_of_itable(), itable_length(), st);</span>
3627   st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
3628   FieldPrinter print_static_field(st);
3629   ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
3630   st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
3631   FieldPrinter print_nonstatic_field(st);
3632   InstanceKlass* ik = const_cast&lt;InstanceKlass*&gt;(this);
3633   ik-&gt;do_nonstatic_fields(&amp;print_nonstatic_field);
3634 
3635   st-&gt;print(BULLET&quot;non-static oop maps: &quot;);
3636   OopMapBlock* map     = start_of_nonstatic_oop_maps();
3637   OopMapBlock* end_map = map + nonstatic_oop_map_count();
3638   while (map &lt; end_map) {
3639     st-&gt;print(&quot;%d-%d &quot;, map-&gt;offset(), map-&gt;offset() + heapOopSize*(map-&gt;count() - 1));
3640     map++;
3641   }
3642   st-&gt;cr();
3643 }
3644 
3645 #endif //PRODUCT
3646 
</pre>
<hr />
<pre>
4342   if (holder == NULL) {
4343     return NULL; // The version of klass is gone, no method is found
4344   }
4345   Method* method = holder-&gt;method_with_orig_idnum(idnum);
4346   return method;
4347 }
4348 
4349 #if INCLUDE_JVMTI
4350 JvmtiCachedClassFileData* InstanceKlass::get_cached_class_file() {
4351   return _cached_class_file;
4352 }
4353 
4354 jint InstanceKlass::get_cached_class_file_len() {
4355   return VM_RedefineClasses::get_cached_class_file_len(_cached_class_file);
4356 }
4357 
4358 unsigned char * InstanceKlass::get_cached_class_file_bytes() {
4359   return VM_RedefineClasses::get_cached_class_file_bytes(_cached_class_file);
4360 }
4361 #endif
<span class="line-added">4362 </span>
<span class="line-added">4363 #define THROW_DVT_ERROR(s) \</span>
<span class="line-added">4364   Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), \</span>
<span class="line-added">4365       &quot;ValueCapableClass class &#39;%s&#39; %s&quot;, external_name(),(s)); \</span>
<span class="line-added">4366       return</span>
</pre>
</td>
</tr>
</table>
<center><a href="../memory/metaspaceShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbol.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>