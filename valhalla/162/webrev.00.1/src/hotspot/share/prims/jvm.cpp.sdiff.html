<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/stringTable.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  43 #include &quot;jfr/jfrEvents.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/referenceType.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;oops/access.inline.hpp&quot;
  52 #include &quot;oops/constantPool.hpp&quot;
  53 #include &quot;oops/fieldStreams.inline.hpp&quot;

  54 #include &quot;oops/instanceKlass.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/recordComponent.hpp&quot;
  57 #include &quot;oops/objArrayKlass.hpp&quot;
  58 #include &quot;oops/objArrayOop.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;prims/jvm_misc.hpp&quot;
  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;prims/nativeLookup.hpp&quot;
  64 #include &quot;prims/stackwalk.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/atomic.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/init.hpp&quot;
  69 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  70 #include &quot;runtime/deoptimization.hpp&quot;
  71 #include &quot;runtime/handshake.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
</pre>
<hr />
<pre>
 637   // be null.
 638   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 639   objArrayHandle frames_array_h(THREAD, fa);
 640 
 641   int limit = start_index+frame_count;
 642   if (frames_array_h-&gt;length() &lt; limit) {
 643     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 644   }
 645 
 646   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 647   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 648                                    start_index, frames_array_h, THREAD);
 649 JVM_END
 650 
 651 // java.lang.Object ///////////////////////////////////////////////
 652 
 653 
 654 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 655   JVMWrapper(&quot;JVM_IHashCode&quot;);
 656   // as implemented in the classic virtual machine; return 0 if object is NULL
<span class="line-modified"> 657   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;</span>





















 658 JVM_END
 659 
 660 
 661 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 662   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 663   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 664   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 665   if (JvmtiExport::should_post_monitor_wait()) {
 666     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 667 
 668     // The current thread already owns the monitor and it has not yet
 669     // been added to the wait queue so the current thread cannot be
 670     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 671     // event handler cannot accidentally consume an unpark() meant for
 672     // the ParkEvent associated with this ObjectMonitor.
 673   }
 674   ObjectSynchronizer::wait(obj, ms, CHECK);
 675 JVM_END
 676 
 677 
</pre>
<hr />
<pre>
 693   JVMWrapper(&quot;JVM_Clone&quot;);
 694   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 695   Klass* klass = obj-&gt;klass();
 696   JvmtiVMObjectAllocEventCollector oam;
 697 
 698 #ifdef ASSERT
 699   // Just checking that the cloneable flag is set correct
 700   if (obj-&gt;is_array()) {
 701     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 702   } else {
 703     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 704     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 705     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 706   }
 707 #endif
 708 
 709   // Check if class of obj supports the Cloneable interface.
 710   // All arrays are considered to be cloneable (See JLS 20.1.5).
 711   // All j.l.r.Reference classes are considered non-cloneable.
 712   if (!klass-&gt;is_cloneable() ||

 713       (klass-&gt;is_instance_klass() &amp;&amp;
 714        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 715     ResourceMark rm(THREAD);
 716     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 717   }
 718 
 719   // Make shallow object copy
 720   const int size = obj-&gt;size();
 721   oop new_obj_oop = NULL;
 722   if (obj-&gt;is_array()) {
 723     const int length = ((arrayOop)obj())-&gt;length();
 724     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 725                                                    /* do_zero */ true, CHECK_NULL);
 726   } else {
 727     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 728   }
 729 
 730   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 731 
 732   Handle new_obj(THREAD, new_obj_oop);
</pre>
<hr />
<pre>
1236   return (jstring) JNIHandles::make_local(env, result);
1237 JVM_END
1238 
1239 
1240 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1241   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1242   JvmtiVMObjectAllocEventCollector oam;
1243   oop mirror = JNIHandles::resolve_non_null(cls);
1244 
1245   // Special handling for primitive objects
1246   if (java_lang_Class::is_primitive(mirror)) {
1247     // Primitive objects does not have any interfaces
1248     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1249     return (jobjectArray) JNIHandles::make_local(env, r);
1250   }
1251 
1252   Klass* klass = java_lang_Class::as_Klass(mirror);
1253   // Figure size of result array
1254   int size;
1255   if (klass-&gt;is_instance_klass()) {
<span class="line-modified">1256     size = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;length();</span>




1257   } else {
1258     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
<span class="line-modified">1259     size = 2;</span>
1260   }
1261 
1262   // Allocate result array
1263   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1264   objArrayHandle result (THREAD, r);
1265   // Fill in result
1266   if (klass-&gt;is_instance_klass()) {
1267     // Regular instance klass, fill in all local interfaces

1268     for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1269       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-modified">1270       result-&gt;obj_at_put(index, k-&gt;java_mirror());</span>



1271     }
1272   } else {
<span class="line-modified">1273     // All arrays implement java.lang.Cloneable and java.io.Serializable</span>
1274     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1275     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());

1276   }
1277   return (jobjectArray) JNIHandles::make_local(env, result());
1278 JVM_END
1279 
1280 
1281 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1282   JVMWrapper(&quot;JVM_IsInterface&quot;);
1283   oop mirror = JNIHandles::resolve_non_null(cls);
1284   if (java_lang_Class::is_primitive(mirror)) {
1285     return JNI_FALSE;
1286   }
1287   Klass* k = java_lang_Class::as_Klass(mirror);
1288   jboolean result = k-&gt;is_interface();
1289   assert(!result || k-&gt;is_instance_klass(),
1290          &quot;all interfaces are instance types&quot;);
1291   // The compiler intrinsic for isInterface tests the
1292   // Klass::_access_flags bits in the same way.
1293   return result;
1294 JVM_END
1295 
</pre>
<hr />
<pre>
1875         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1876       objArrayHandle components_h (THREAD, record_components);
1877 
1878       for (int x = 0; x &lt; length; x++) {
1879         RecordComponent* component = components-&gt;at(x);
1880         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1881         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1882         components_h-&gt;obj_at_put(x, component_oop);
1883       }
1884       return (jobjectArray)JNIHandles::make_local(components_h());
1885     }
1886   }
1887 
1888   // Return empty array if ofClass is not a record.
1889   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1890   return (jobjectArray)JNIHandles::make_local(env, result);
1891 }
1892 JVM_END
1893 
1894 static bool select_method(const methodHandle&amp; method, bool want_constructor) {


1895   if (want_constructor) {
<span class="line-modified">1896     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());</span>
1897   } else {
<span class="line-modified">1898     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());</span>


1899   }
1900 }
1901 
1902 static jobjectArray get_class_declared_methods_helper(
1903                                   JNIEnv *env,
1904                                   jclass ofClass, jboolean publicOnly,
1905                                   bool want_constructor,
1906                                   Klass* klass, TRAPS) {
1907 
1908   JvmtiVMObjectAllocEventCollector oam;
1909 
1910   // Exclude primitive types and array types
1911   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1912       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1913     // Return empty array
1914     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1915     return (jobjectArray) JNIHandles::make_local(env, res);
1916   }
1917 
1918   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
</pre>
<hr />
<pre>
1940     }
1941   }
1942 
1943   // Allocate result
1944   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1945   objArrayHandle result (THREAD, r);
1946 
1947   // Now just put the methods that we selected above, but go by their idnum
1948   // in case of redefinition.  The methods can be redefined at any safepoint,
1949   // so above when allocating the oop array and below when creating reflect
1950   // objects.
1951   for (int i = 0; i &lt; num_methods; i++) {
1952     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1953     if (method.is_null()) {
1954       // Method may have been deleted and seems this API can handle null
1955       // Otherwise should probably put a method that throws NSME
1956       result-&gt;obj_at_put(i, NULL);
1957     } else {
1958       oop m;
1959       if (want_constructor) {


1960         m = Reflection::new_constructor(method, CHECK_NULL);
1961       } else {
1962         m = Reflection::new_method(method, false, CHECK_NULL);
1963       }
1964       result-&gt;obj_at_put(i, m);
1965     }
1966   }
1967 
1968   return (jobjectArray) JNIHandles::make_local(env, result());
1969 }
1970 
1971 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1972 {
1973   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1974   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1975                                            /*want_constructor*/ false,
1976                                            SystemDictionary::reflect_Method_klass(), THREAD);
1977 }
1978 JVM_END
1979 
</pre>
<hr />
<pre>
2197   constantTag tag = cp-&gt;tag_at(index);
2198   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2199     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2200   }
2201   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2202   Klass* k_o;
2203   if (force_resolution) {
2204     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2205   } else {
2206     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2207     if (k_o == NULL) return NULL;
2208   }
2209   InstanceKlass* k = InstanceKlass::cast(k_o);
2210   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2211   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2212   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2213   if (m.is_null()) {
2214     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2215   }
2216   oop method;
<span class="line-modified">2217   if (!m-&gt;is_initializer() || m-&gt;is_static()) {</span>
<span class="line-removed">2218     method = Reflection::new_method(m, true, CHECK_NULL);</span>
<span class="line-removed">2219   } else {</span>
2220     method = Reflection::new_constructor(m, CHECK_NULL);


2221   }
2222   return JNIHandles::make_local(method);
2223 }
2224 
2225 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2226 {
2227   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2228   JvmtiVMObjectAllocEventCollector oam;
2229   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2230   bounds_check(cp, index, CHECK_NULL);
2231   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2232   return res;
2233 }
2234 JVM_END
2235 
2236 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2237 {
2238   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2239   JvmtiVMObjectAllocEventCollector oam;
2240   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
</pre>
<hr />
<pre>
2488   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2489   if (!k-&gt;is_instance_klass()) return false;
2490 
2491   ResourceMark rm(THREAD);
2492   const char* name = k-&gt;name()-&gt;as_C_string();
2493   bool system_class = k-&gt;class_loader() == NULL;
2494   return JavaAssertions::enabled(name, system_class);
2495 
2496 JVM_END
2497 
2498 
2499 // Return a new AssertionStatusDirectives object with the fields filled in with
2500 // command-line assertion arguments (i.e., -ea, -da).
2501 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2502   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2503   JvmtiVMObjectAllocEventCollector oam;
2504   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2505   return JNIHandles::make_local(env, asd);
2506 JVM_END
2507 







































2508 // Verification ////////////////////////////////////////////////////////////////////////////////
2509 
2510 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2511 
2512 // RedefineClasses support: bug 6214132 caused verification to fail.
2513 // All functions from this section should call the jvmtiThreadSate function:
2514 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2515 // The function returns a Klass* of the _scratch_class if the verifier
2516 // was invoked in the middle of the class redefinition.
2517 // Otherwise it returns its argument value which is the _the_class Klass*.
2518 // Please, refer to the description in the jvmtiThreadSate.hpp.
2519 
2520 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2521   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2522   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2523   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2524   return k-&gt;name()-&gt;as_utf8();
2525 JVM_END
2526 
2527 
</pre>
<hr />
<pre>
2667   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2668   return method-&gt;size_of_parameters();
2669 JVM_END
2670 
2671 
2672 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2673   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2674   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2675   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2676   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2677   return method-&gt;verifier_max_stack();
2678 JVM_END
2679 
2680 
2681 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2682   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2683   ResourceMark rm(THREAD);
2684   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2685   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2686   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-modified">2687   return method-&gt;name() == vmSymbols::object_initializer_name();</span>
2688 JVM_END
2689 
2690 
2691 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2692   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2693   ResourceMark rm(THREAD);
2694   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2695   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2696   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2697   return method-&gt;is_overpass();
2698 JVM_END
2699 
2700 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2701   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2702   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2703   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2704   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2705   return method-&gt;name()-&gt;as_utf8();
2706 JVM_END
2707 
</pre>
<hr />
<pre>
3662   //   protection_domain. The protection_domain is passed as NULL by the java code
3663   //   if there is no security manager in 3-arg Class.forName().
3664   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3665 
3666   // Check if we should initialize the class
3667   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3668     klass-&gt;initialize(CHECK_NULL);
3669   }
3670   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3671 }
3672 
3673 
3674 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3675 
3676 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3677   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3678   Handle method_handle;
3679   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3680     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3681     Handle receiver(THREAD, JNIHandles::resolve(obj));
<span class="line-modified">3682     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</span>
3683     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3684     jobject res = JNIHandles::make_local(env, result);
3685     if (JvmtiExport::should_post_vm_object_alloc()) {
3686       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3687       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3688       if (java_lang_Class::is_primitive(ret_type)) {
3689         // Only for primitive type vm allocates memory for java object.
3690         // See box() method.
3691         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3692       }
3693     }
3694     return res;
3695   } else {
3696     THROW_0(vmSymbols::java_lang_StackOverflowError());
3697   }
3698 JVM_END
3699 
3700 
3701 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3702   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);

3703   oop constructor_mirror = JNIHandles::resolve(c);
<span class="line-removed">3704   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</span>
3705   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3706   jobject res = JNIHandles::make_local(env, result);
3707   if (JvmtiExport::should_post_vm_object_alloc()) {
3708     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3709   }
3710   return res;
3711 JVM_END
3712 
3713 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3714 
3715 JVM_LEAF(jboolean, JVM_SupportsCX8())
3716   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3717   return VM_Version::supports_cx8();
3718 JVM_END
3719 
3720 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3721   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3722   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3723   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3724   HeapShared::initialize_from_archived_subgraph(k);
</pre>
</td>
<td>
<hr />
<pre>
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/stringTable.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  43 #include &quot;jfr/jfrEvents.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/referenceType.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;oops/access.inline.hpp&quot;
  52 #include &quot;oops/constantPool.hpp&quot;
  53 #include &quot;oops/fieldStreams.inline.hpp&quot;
<span class="line-added">  54 #include &quot;oops/flatArrayKlass.hpp&quot;</span>
  55 #include &quot;oops/instanceKlass.hpp&quot;
  56 #include &quot;oops/method.hpp&quot;
  57 #include &quot;oops/recordComponent.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.inline.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;prims/jvm_misc.hpp&quot;
  62 #include &quot;prims/jvmtiExport.hpp&quot;
  63 #include &quot;prims/jvmtiThreadState.hpp&quot;
  64 #include &quot;prims/nativeLookup.hpp&quot;
  65 #include &quot;prims/stackwalk.hpp&quot;
  66 #include &quot;runtime/arguments.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/handles.inline.hpp&quot;
  69 #include &quot;runtime/init.hpp&quot;
  70 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  71 #include &quot;runtime/deoptimization.hpp&quot;
  72 #include &quot;runtime/handshake.hpp&quot;
  73 #include &quot;runtime/java.hpp&quot;
  74 #include &quot;runtime/javaCalls.hpp&quot;
</pre>
<hr />
<pre>
 638   // be null.
 639   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 640   objArrayHandle frames_array_h(THREAD, fa);
 641 
 642   int limit = start_index+frame_count;
 643   if (frames_array_h-&gt;length() &lt; limit) {
 644     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 645   }
 646 
 647   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 648   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 649                                    start_index, frames_array_h, THREAD);
 650 JVM_END
 651 
 652 // java.lang.Object ///////////////////////////////////////////////
 653 
 654 
 655 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 656   JVMWrapper(&quot;JVM_IHashCode&quot;);
 657   // as implemented in the classic virtual machine; return 0 if object is NULL
<span class="line-modified"> 658   if (handle == NULL) {</span>
<span class="line-added"> 659     return 0;</span>
<span class="line-added"> 660   }</span>
<span class="line-added"> 661   oop obj = JNIHandles::resolve_non_null(handle);</span>
<span class="line-added"> 662   if (EnableValhalla &amp;&amp; obj-&gt;klass()-&gt;is_inline_klass()) {</span>
<span class="line-added"> 663       JavaValue result(T_INT);</span>
<span class="line-added"> 664       JavaCallArguments args;</span>
<span class="line-added"> 665       Handle ho(THREAD, obj);</span>
<span class="line-added"> 666       args.push_oop(ho);</span>
<span class="line-added"> 667       methodHandle method(THREAD, Universe::inline_type_hash_code_method());</span>
<span class="line-added"> 668       JavaCalls::call(&amp;result, method, &amp;args, THREAD);</span>
<span class="line-added"> 669       if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added"> 670         if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::Error_klass())) {</span>
<span class="line-added"> 671           Handle e(THREAD, PENDING_EXCEPTION);</span>
<span class="line-added"> 672           CLEAR_PENDING_EXCEPTION;</span>
<span class="line-added"> 673           THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), &quot;Internal error in hashCode&quot;, e, false);</span>
<span class="line-added"> 674         }</span>
<span class="line-added"> 675       }</span>
<span class="line-added"> 676       return result.get_jint();</span>
<span class="line-added"> 677   } else {</span>
<span class="line-added"> 678     return ObjectSynchronizer::FastHashCode(THREAD, obj);</span>
<span class="line-added"> 679   }</span>
 680 JVM_END
 681 
 682 
 683 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 684   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 685   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 686   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 687   if (JvmtiExport::should_post_monitor_wait()) {
 688     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 689 
 690     // The current thread already owns the monitor and it has not yet
 691     // been added to the wait queue so the current thread cannot be
 692     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 693     // event handler cannot accidentally consume an unpark() meant for
 694     // the ParkEvent associated with this ObjectMonitor.
 695   }
 696   ObjectSynchronizer::wait(obj, ms, CHECK);
 697 JVM_END
 698 
 699 
</pre>
<hr />
<pre>
 715   JVMWrapper(&quot;JVM_Clone&quot;);
 716   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 717   Klass* klass = obj-&gt;klass();
 718   JvmtiVMObjectAllocEventCollector oam;
 719 
 720 #ifdef ASSERT
 721   // Just checking that the cloneable flag is set correct
 722   if (obj-&gt;is_array()) {
 723     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 724   } else {
 725     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 726     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 727     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 728   }
 729 #endif
 730 
 731   // Check if class of obj supports the Cloneable interface.
 732   // All arrays are considered to be cloneable (See JLS 20.1.5).
 733   // All j.l.r.Reference classes are considered non-cloneable.
 734   if (!klass-&gt;is_cloneable() ||
<span class="line-added"> 735        klass-&gt;is_inline_klass() ||</span>
 736       (klass-&gt;is_instance_klass() &amp;&amp;
 737        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 738     ResourceMark rm(THREAD);
 739     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 740   }
 741 
 742   // Make shallow object copy
 743   const int size = obj-&gt;size();
 744   oop new_obj_oop = NULL;
 745   if (obj-&gt;is_array()) {
 746     const int length = ((arrayOop)obj())-&gt;length();
 747     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 748                                                    /* do_zero */ true, CHECK_NULL);
 749   } else {
 750     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 751   }
 752 
 753   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 754 
 755   Handle new_obj(THREAD, new_obj_oop);
</pre>
<hr />
<pre>
1259   return (jstring) JNIHandles::make_local(env, result);
1260 JVM_END
1261 
1262 
1263 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1264   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1265   JvmtiVMObjectAllocEventCollector oam;
1266   oop mirror = JNIHandles::resolve_non_null(cls);
1267 
1268   // Special handling for primitive objects
1269   if (java_lang_Class::is_primitive(mirror)) {
1270     // Primitive objects does not have any interfaces
1271     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1272     return (jobjectArray) JNIHandles::make_local(env, r);
1273   }
1274 
1275   Klass* klass = java_lang_Class::as_Klass(mirror);
1276   // Figure size of result array
1277   int size;
1278   if (klass-&gt;is_instance_klass()) {
<span class="line-modified">1279     InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-added">1280     size = ik-&gt;local_interfaces()-&gt;length();</span>
<span class="line-added">1281     if (ik-&gt;has_injected_identityObject()) {</span>
<span class="line-added">1282       size--;</span>
<span class="line-added">1283     }</span>
1284   } else {
1285     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
<span class="line-modified">1286     size = 3;</span>
1287   }
1288 
1289   // Allocate result array
1290   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1291   objArrayHandle result (THREAD, r);
1292   // Fill in result
1293   if (klass-&gt;is_instance_klass()) {
1294     // Regular instance klass, fill in all local interfaces
<span class="line-added">1295     int cursor = 0;</span>
1296     for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1297       InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-modified">1298       Klass* k = ik-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-added">1299       if (!ik-&gt;has_injected_identityObject() || k != SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">1300         result-&gt;obj_at_put(cursor++, k-&gt;java_mirror());</span>
<span class="line-added">1301       }</span>
1302     }
1303   } else {
<span class="line-modified">1304     // All arrays implement java.lang.Cloneable, java.io.Serializable and java.lang.IdentityObject</span>
1305     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1306     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
<span class="line-added">1307     result-&gt;obj_at_put(2, SystemDictionary::IdentityObject_klass()-&gt;java_mirror());</span>
1308   }
1309   return (jobjectArray) JNIHandles::make_local(env, result());
1310 JVM_END
1311 
1312 
1313 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1314   JVMWrapper(&quot;JVM_IsInterface&quot;);
1315   oop mirror = JNIHandles::resolve_non_null(cls);
1316   if (java_lang_Class::is_primitive(mirror)) {
1317     return JNI_FALSE;
1318   }
1319   Klass* k = java_lang_Class::as_Klass(mirror);
1320   jboolean result = k-&gt;is_interface();
1321   assert(!result || k-&gt;is_instance_klass(),
1322          &quot;all interfaces are instance types&quot;);
1323   // The compiler intrinsic for isInterface tests the
1324   // Klass::_access_flags bits in the same way.
1325   return result;
1326 JVM_END
1327 
</pre>
<hr />
<pre>
1907         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1908       objArrayHandle components_h (THREAD, record_components);
1909 
1910       for (int x = 0; x &lt; length; x++) {
1911         RecordComponent* component = components-&gt;at(x);
1912         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1913         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1914         components_h-&gt;obj_at_put(x, component_oop);
1915       }
1916       return (jobjectArray)JNIHandles::make_local(components_h());
1917     }
1918   }
1919 
1920   // Return empty array if ofClass is not a record.
1921   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1922   return (jobjectArray)JNIHandles::make_local(env, result);
1923 }
1924 JVM_END
1925 
1926 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
<span class="line-added">1927   bool is_ctor = (method-&gt;is_object_constructor() ||</span>
<span class="line-added">1928                   method-&gt;is_static_init_factory());</span>
1929   if (want_constructor) {
<span class="line-modified">1930     return is_ctor;</span>
1931   } else {
<span class="line-modified">1932     return (!is_ctor &amp;&amp;</span>
<span class="line-added">1933             !method-&gt;is_class_initializer() &amp;&amp;</span>
<span class="line-added">1934             !method-&gt;is_overpass());</span>
1935   }
1936 }
1937 
1938 static jobjectArray get_class_declared_methods_helper(
1939                                   JNIEnv *env,
1940                                   jclass ofClass, jboolean publicOnly,
1941                                   bool want_constructor,
1942                                   Klass* klass, TRAPS) {
1943 
1944   JvmtiVMObjectAllocEventCollector oam;
1945 
1946   // Exclude primitive types and array types
1947   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1948       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1949     // Return empty array
1950     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1951     return (jobjectArray) JNIHandles::make_local(env, res);
1952   }
1953 
1954   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
</pre>
<hr />
<pre>
1976     }
1977   }
1978 
1979   // Allocate result
1980   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1981   objArrayHandle result (THREAD, r);
1982 
1983   // Now just put the methods that we selected above, but go by their idnum
1984   // in case of redefinition.  The methods can be redefined at any safepoint,
1985   // so above when allocating the oop array and below when creating reflect
1986   // objects.
1987   for (int i = 0; i &lt; num_methods; i++) {
1988     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1989     if (method.is_null()) {
1990       // Method may have been deleted and seems this API can handle null
1991       // Otherwise should probably put a method that throws NSME
1992       result-&gt;obj_at_put(i, NULL);
1993     } else {
1994       oop m;
1995       if (want_constructor) {
<span class="line-added">1996         assert(method-&gt;is_object_constructor() ||</span>
<span class="line-added">1997                method-&gt;is_static_init_factory(), &quot;must be&quot;);</span>
1998         m = Reflection::new_constructor(method, CHECK_NULL);
1999       } else {
2000         m = Reflection::new_method(method, false, CHECK_NULL);
2001       }
2002       result-&gt;obj_at_put(i, m);
2003     }
2004   }
2005 
2006   return (jobjectArray) JNIHandles::make_local(env, result());
2007 }
2008 
2009 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
2010 {
2011   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
2012   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2013                                            /*want_constructor*/ false,
2014                                            SystemDictionary::reflect_Method_klass(), THREAD);
2015 }
2016 JVM_END
2017 
</pre>
<hr />
<pre>
2235   constantTag tag = cp-&gt;tag_at(index);
2236   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2237     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2238   }
2239   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2240   Klass* k_o;
2241   if (force_resolution) {
2242     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2243   } else {
2244     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2245     if (k_o == NULL) return NULL;
2246   }
2247   InstanceKlass* k = InstanceKlass::cast(k_o);
2248   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2249   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2250   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2251   if (m.is_null()) {
2252     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2253   }
2254   oop method;
<span class="line-modified">2255   if (m-&gt;is_object_constructor() || m-&gt;is_static_init_factory()) {</span>


2256     method = Reflection::new_constructor(m, CHECK_NULL);
<span class="line-added">2257   } else {</span>
<span class="line-added">2258     method = Reflection::new_method(m, true, CHECK_NULL);</span>
2259   }
2260   return JNIHandles::make_local(method);
2261 }
2262 
2263 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2264 {
2265   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2266   JvmtiVMObjectAllocEventCollector oam;
2267   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2268   bounds_check(cp, index, CHECK_NULL);
2269   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2270   return res;
2271 }
2272 JVM_END
2273 
2274 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2275 {
2276   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2277   JvmtiVMObjectAllocEventCollector oam;
2278   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
</pre>
<hr />
<pre>
2526   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2527   if (!k-&gt;is_instance_klass()) return false;
2528 
2529   ResourceMark rm(THREAD);
2530   const char* name = k-&gt;name()-&gt;as_C_string();
2531   bool system_class = k-&gt;class_loader() == NULL;
2532   return JavaAssertions::enabled(name, system_class);
2533 
2534 JVM_END
2535 
2536 
2537 // Return a new AssertionStatusDirectives object with the fields filled in with
2538 // command-line assertion arguments (i.e., -ea, -da).
2539 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2540   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2541   JvmtiVMObjectAllocEventCollector oam;
2542   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2543   return JNIHandles::make_local(env, asd);
2544 JVM_END
2545 
<span class="line-added">2546 // Arrays support /////////////////////////////////////////////////////////////</span>
<span class="line-added">2547 </span>
<span class="line-added">2548 JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))</span>
<span class="line-added">2549   JVMWrapper(&quot;JVM_ArrayIsAccessAtomic&quot;);</span>
<span class="line-added">2550   oop o = JNIHandles::resolve(array);</span>
<span class="line-added">2551   Klass* k = o-&gt;klass();</span>
<span class="line-added">2552   if ((o == NULL) || (!k-&gt;is_array_klass())) {</span>
<span class="line-added">2553     THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span>
<span class="line-added">2554   }</span>
<span class="line-added">2555   return ArrayKlass::cast(k)-&gt;element_access_is_atomic();</span>
<span class="line-added">2556 JVM_END</span>
<span class="line-added">2557 </span>
<span class="line-added">2558 JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))</span>
<span class="line-added">2559   JVMWrapper(&quot;JVM_ArrayEnsureAccessAtomic&quot;);</span>
<span class="line-added">2560   oop o = JNIHandles::resolve(array);</span>
<span class="line-added">2561   Klass* k = o-&gt;klass();</span>
<span class="line-added">2562   if ((o == NULL) || (!k-&gt;is_array_klass())) {</span>
<span class="line-added">2563     THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span>
<span class="line-added">2564   }</span>
<span class="line-added">2565   if (k-&gt;is_flatArray_klass()) {</span>
<span class="line-added">2566     FlatArrayKlass* vk = FlatArrayKlass::cast(k);</span>
<span class="line-added">2567     if (!vk-&gt;element_access_is_atomic()) {</span>
<span class="line-added">2568       /**</span>
<span class="line-added">2569        * Need to decide how to implement:</span>
<span class="line-added">2570        *</span>
<span class="line-added">2571        * 1) Change to objArrayOop layout, therefore oop-&gt;klass() differs so</span>
<span class="line-added">2572        * then &quot;&lt;atomic&gt;[Qfoo;&quot; klass needs to subclass &quot;[Qfoo;&quot; to pass through</span>
<span class="line-added">2573        * &quot;checkcast&quot; &amp; &quot;instanceof&quot;</span>
<span class="line-added">2574        *</span>
<span class="line-added">2575        * 2) Use extra header in the flatArrayOop to flag atomicity required and</span>
<span class="line-added">2576        * possibly per instance lock structure. Said info, could be placed in</span>
<span class="line-added">2577        * &quot;trailer&quot; rather than disturb the current arrayOop</span>
<span class="line-added">2578        */</span>
<span class="line-added">2579       Unimplemented();</span>
<span class="line-added">2580     }</span>
<span class="line-added">2581   }</span>
<span class="line-added">2582   return array;</span>
<span class="line-added">2583 JVM_END</span>
<span class="line-added">2584 </span>
2585 // Verification ////////////////////////////////////////////////////////////////////////////////
2586 
2587 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2588 
2589 // RedefineClasses support: bug 6214132 caused verification to fail.
2590 // All functions from this section should call the jvmtiThreadSate function:
2591 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2592 // The function returns a Klass* of the _scratch_class if the verifier
2593 // was invoked in the middle of the class redefinition.
2594 // Otherwise it returns its argument value which is the _the_class Klass*.
2595 // Please, refer to the description in the jvmtiThreadSate.hpp.
2596 
2597 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2598   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2599   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2600   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2601   return k-&gt;name()-&gt;as_utf8();
2602 JVM_END
2603 
2604 
</pre>
<hr />
<pre>
2744   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2745   return method-&gt;size_of_parameters();
2746 JVM_END
2747 
2748 
2749 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2750   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2751   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2752   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2753   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2754   return method-&gt;verifier_max_stack();
2755 JVM_END
2756 
2757 
2758 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2759   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2760   ResourceMark rm(THREAD);
2761   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2762   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2763   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-modified">2764   return method-&gt;is_object_constructor();</span>
2765 JVM_END
2766 
2767 
2768 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2769   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2770   ResourceMark rm(THREAD);
2771   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2772   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2773   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2774   return method-&gt;is_overpass();
2775 JVM_END
2776 
2777 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2778   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2779   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2780   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2781   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2782   return method-&gt;name()-&gt;as_utf8();
2783 JVM_END
2784 
</pre>
<hr />
<pre>
3739   //   protection_domain. The protection_domain is passed as NULL by the java code
3740   //   if there is no security manager in 3-arg Class.forName().
3741   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3742 
3743   // Check if we should initialize the class
3744   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3745     klass-&gt;initialize(CHECK_NULL);
3746   }
3747   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3748 }
3749 
3750 
3751 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3752 
3753 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3754   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3755   Handle method_handle;
3756   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3757     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3758     Handle receiver(THREAD, JNIHandles::resolve(obj));
<span class="line-modified">3759     objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);</span>
3760     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3761     jobject res = JNIHandles::make_local(env, result);
3762     if (JvmtiExport::should_post_vm_object_alloc()) {
3763       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3764       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3765       if (java_lang_Class::is_primitive(ret_type)) {
3766         // Only for primitive type vm allocates memory for java object.
3767         // See box() method.
3768         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3769       }
3770     }
3771     return res;
3772   } else {
3773     THROW_0(vmSymbols::java_lang_StackOverflowError());
3774   }
3775 JVM_END
3776 
3777 
3778 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3779   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
<span class="line-added">3780   objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);</span>
3781   oop constructor_mirror = JNIHandles::resolve(c);

3782   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3783   jobject res = JNIHandles::make_local(env, result);
3784   if (JvmtiExport::should_post_vm_object_alloc()) {
3785     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3786   }
3787   return res;
3788 JVM_END
3789 
3790 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3791 
3792 JVM_LEAF(jboolean, JVM_SupportsCX8())
3793   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3794   return VM_Version::supports_cx8();
3795 JVM_END
3796 
3797 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3798   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3799   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3800   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3801   HeapShared::initialize_from_archived_subgraph(k);
</pre>
</td>
</tr>
</table>
<center><a href="../opto/type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>