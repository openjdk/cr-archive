<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/services/diagnosticCommand.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderHierarchyDCmd.hpp&quot;
  28 #include &quot;classfile/classLoaderStats.hpp&quot;
  29 #include &quot;code/codeCache.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;
  31 #include &quot;compiler/directivesParser.hpp&quot;
  32 #include &quot;gc/shared/gcVMOperations.hpp&quot;
  33 #include &quot;memory/metaspace/metaspaceDCmd.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/objArrayOop.inline.hpp&quot;
  37 #include &quot;oops/oop.inline.hpp&quot;
  38 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  39 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  40 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  41 #include &quot;runtime/handles.inline.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/javaCalls.hpp&quot;
  44 #include &quot;runtime/os.hpp&quot;
  45 #include &quot;services/diagnosticArgument.hpp&quot;
  46 #include &quot;services/diagnosticCommand.hpp&quot;
  47 #include &quot;services/diagnosticFramework.hpp&quot;
  48 #include &quot;services/heapDumper.hpp&quot;
  49 #include &quot;services/management.hpp&quot;
  50 #include &quot;services/writeableFlags.hpp&quot;
  51 #include &quot;utilities/debug.hpp&quot;
  52 #include &quot;utilities/events.hpp&quot;
  53 #include &quot;utilities/formatBuffer.hpp&quot;
  54 #include &quot;utilities/macros.hpp&quot;
  55 
  56 
  57 static void loadAgentModule(TRAPS) {
  58   ResourceMark rm(THREAD);
  59   HandleMark hm(THREAD);
  60 
  61   JavaValue result(T_OBJECT);
  62   Handle h_module_name = java_lang_String::create_from_str(&quot;jdk.management.agent&quot;, CHECK);
  63   JavaCalls::call_static(&amp;result,
  64                          SystemDictionary::module_Modules_klass(),
  65                          vmSymbols::loadModule_name(),
  66                          vmSymbols::loadModule_signature(),
  67                          h_module_name,
  68                          THREAD);
  69 }
  70 
  71 void DCmdRegistrant::register_dcmds(){
  72   // Registration of the diagnostic commands
  73   // First argument specifies which interfaces will export the command
  74   // Second argument specifies if the command is enabled
  75   // Third  argument specifies if the command is hidden
  76   uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI
  77                          | DCmd_Source_MBean;
  78   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HelpDCmd&gt;(full_export, true, false));
  79   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VersionDCmd&gt;(full_export, true, false));
  80   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CommandLineDCmd&gt;(full_export, true, false));
  81   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintSystemPropertiesDCmd&gt;(full_export, true, false));
  82   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintVMFlagsDCmd&gt;(full_export, true, false));
  83   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SetVMFlagDCmd&gt;(full_export, true, false));
  84   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMDynamicLibrariesDCmd&gt;(full_export, true, false));
  85   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMUptimeDCmd&gt;(full_export, true, false));
  86   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMInfoDCmd&gt;(full_export, true, false));
  87   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SystemGCDCmd&gt;(full_export, true, false));
  88   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;RunFinalizationDCmd&gt;(full_export, true, false));
  89   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HeapInfoDCmd&gt;(full_export, true, false));
  90   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;FinalizerInfoDCmd&gt;(full_export, true, false));
  91 #if INCLUDE_SERVICES
  92   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HeapDumpDCmd&gt;(DCmd_Source_Internal | DCmd_Source_AttachAPI, true, false));
  93   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassHistogramDCmd&gt;(full_export, true, false));
  94   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SystemDictionaryDCmd&gt;(full_export, true, false));
  95   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassHierarchyDCmd&gt;(full_export, true, false));
  96   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SymboltableDCmd&gt;(full_export, true, false));
  97   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;StringtableDCmd&gt;(full_export, true, false));
  98   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;metaspace::MetaspaceDCmd&gt;(full_export, true, false));
  99   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintClassLayoutDCmd&gt;(full_export, true, false));
 100   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;EventLogDCmd&gt;(full_export, true, false));
 101 #if INCLUDE_JVMTI // Both JVMTI and SERVICES have to be enabled to have this dcmd
 102   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JVMTIAgentLoadDCmd&gt;(full_export, true, false));
 103 #endif // INCLUDE_JVMTI
 104 #endif // INCLUDE_SERVICES
 105 #if INCLUDE_JVMTI
 106   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JVMTIDataDumpDCmd&gt;(full_export, true, false));
 107 #endif // INCLUDE_JVMTI
 108   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ThreadDumpDCmd&gt;(full_export, true, false));
 109   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassLoaderStatsDCmd&gt;(full_export, true, false));
 110   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassLoaderHierarchyDCmd&gt;(full_export, true, false));
 111   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompileQueueDCmd&gt;(full_export, true, false));
 112   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeListDCmd&gt;(full_export, true, false));
 113   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeCacheDCmd&gt;(full_export, true, false));
 114   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;TouchedMethodsDCmd&gt;(full_export, true, false));
 115   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeHeapAnalyticsDCmd&gt;(full_export, true, false));
 116 
 117   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesPrintDCmd&gt;(full_export, true, false));
 118   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesAddDCmd&gt;(full_export, true, false));
 119   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesRemoveDCmd&gt;(full_export, true, false));
 120   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesClearDCmd&gt;(full_export, true, false));
 121 
 122   // Enhanced JMX Agent Support
 123   // These commands won&#39;t be exported via the DiagnosticCommandMBean until an
 124   // appropriate permission is created for them
 125   uint32_t jmx_agent_export_flags = DCmd_Source_Internal | DCmd_Source_AttachAPI;
 126   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStartRemoteDCmd&gt;(jmx_agent_export_flags, true,false));
 127   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStartLocalDCmd&gt;(jmx_agent_export_flags, true,false));
 128   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStopRemoteDCmd&gt;(jmx_agent_export_flags, true,false));
 129   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStatusDCmd&gt;(jmx_agent_export_flags, true,false));
 130   // Debug on cmd (only makes sense with JVMTI since the agentlib needs it).
 131 #if INCLUDE_JVMTI
 132   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;DebugOnCmdStartDCmd&gt;(full_export, true, true));
 133 #endif // INCLUDE_JVMTI
 134 
 135 }
 136 
 137 #ifndef HAVE_EXTRA_DCMD
 138 void DCmdRegistrant::register_dcmds_ext(){
 139    // Do nothing here
 140 }
 141 #endif
 142 
 143 
 144 HelpDCmd::HelpDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap),
 145   _all(&quot;-all&quot;, &quot;Show help for all commands&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 146   _cmd(&quot;command name&quot;, &quot;The name of the command for which we want help&quot;,
 147         &quot;STRING&quot;, false) {
 148   _dcmdparser.add_dcmd_option(&amp;_all);
 149   _dcmdparser.add_dcmd_argument(&amp;_cmd);
 150 };
 151 
 152 
 153 static int compare_strings(const char** s1, const char** s2) {
 154   return ::strcmp(*s1, *s2);
 155 }
 156 
 157 void HelpDCmd::execute(DCmdSource source, TRAPS) {
 158   if (_all.value()) {
 159     GrowableArray&lt;const char*&gt;* cmd_list = DCmdFactory::DCmd_list(source);
 160     cmd_list-&gt;sort(compare_strings);
 161     for (int i = 0; i &lt; cmd_list-&gt;length(); i++) {
 162       DCmdFactory* factory = DCmdFactory::factory(source, cmd_list-&gt;at(i),
 163                                                   strlen(cmd_list-&gt;at(i)));
 164       output()-&gt;print_cr(&quot;%s%s&quot;, factory-&gt;name(),
 165                          factory-&gt;is_enabled() ? &quot;&quot; : &quot; [disabled]&quot;);
 166       output()-&gt;print_cr(&quot;\t%s&quot;, factory-&gt;description());
 167       output()-&gt;cr();
 168       factory = factory-&gt;next();
 169     }
 170   } else if (_cmd.has_value()) {
 171     DCmd* cmd = NULL;
 172     DCmdFactory* factory = DCmdFactory::factory(source, _cmd.value(),
 173                                                 strlen(_cmd.value()));
 174     if (factory != NULL) {
 175       output()-&gt;print_cr(&quot;%s%s&quot;, factory-&gt;name(),
 176                          factory-&gt;is_enabled() ? &quot;&quot; : &quot; [disabled]&quot;);
 177       output()-&gt;print_cr(&quot;%s&quot;, factory-&gt;description());
 178       output()-&gt;print_cr(&quot;\nImpact: %s&quot;, factory-&gt;impact());
 179       JavaPermission p = factory-&gt;permission();
 180       if(p._class != NULL) {
 181         if(p._action != NULL) {
 182           output()-&gt;print_cr(&quot;\nPermission: %s(%s, %s)&quot;,
 183                   p._class, p._name == NULL ? &quot;null&quot; : p._name, p._action);
 184         } else {
 185           output()-&gt;print_cr(&quot;\nPermission: %s(%s)&quot;,
 186                   p._class, p._name == NULL ? &quot;null&quot; : p._name);
 187         }
 188       }
 189       output()-&gt;cr();
 190       cmd = factory-&gt;create_resource_instance(output());
 191       if (cmd != NULL) {
 192         DCmdMark mark(cmd);
 193         cmd-&gt;print_help(factory-&gt;name());
 194       }
 195     } else {
 196       output()-&gt;print_cr(&quot;Help unavailable : &#39;%s&#39; : No such command&quot;, _cmd.value());
 197     }
 198   } else {
 199     output()-&gt;print_cr(&quot;The following commands are available:&quot;);
 200     GrowableArray&lt;const char *&gt;* cmd_list = DCmdFactory::DCmd_list(source);
 201     cmd_list-&gt;sort(compare_strings);
 202     for (int i = 0; i &lt; cmd_list-&gt;length(); i++) {
 203       DCmdFactory* factory = DCmdFactory::factory(source, cmd_list-&gt;at(i),
 204                                                   strlen(cmd_list-&gt;at(i)));
 205       output()-&gt;print_cr(&quot;%s%s&quot;, factory-&gt;name(),
 206                          factory-&gt;is_enabled() ? &quot;&quot; : &quot; [disabled]&quot;);
 207       factory = factory-&gt;_next;
 208     }
 209     output()-&gt;print_cr(&quot;\nFor more information about a specific command use &#39;help &lt;command&gt;&#39;.&quot;);
 210   }
 211 }
 212 
 213 int HelpDCmd::num_arguments() {
 214   ResourceMark rm;
 215   HelpDCmd* dcmd = new HelpDCmd(NULL, false);
 216   if (dcmd != NULL) {
 217     DCmdMark mark(dcmd);
 218     return dcmd-&gt;_dcmdparser.num_arguments();
 219   } else {
 220     return 0;
 221   }
 222 }
 223 
 224 void VersionDCmd::execute(DCmdSource source, TRAPS) {
 225   output()-&gt;print_cr(&quot;%s version %s&quot;, VM_Version::vm_name(),
 226           VM_Version::vm_release());
 227   JDK_Version jdk_version = JDK_Version::current();
 228   if (jdk_version.patch_version() &gt; 0) {
 229     output()-&gt;print_cr(&quot;JDK %d.%d.%d.%d&quot;, jdk_version.major_version(),
 230             jdk_version.minor_version(), jdk_version.security_version(),
 231             jdk_version.patch_version());
 232   } else {
 233     output()-&gt;print_cr(&quot;JDK %d.%d.%d&quot;, jdk_version.major_version(),
 234             jdk_version.minor_version(), jdk_version.security_version());
 235   }
 236 }
 237 
 238 PrintVMFlagsDCmd::PrintVMFlagsDCmd(outputStream* output, bool heap) :
 239                                    DCmdWithParser(output, heap),
 240   _all(&quot;-all&quot;, &quot;Print all flags supported by the VM&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 241   _dcmdparser.add_dcmd_option(&amp;_all);
 242 }
 243 
 244 void PrintVMFlagsDCmd::execute(DCmdSource source, TRAPS) {
 245   if (_all.value()) {
 246     JVMFlag::printFlags(output(), true);
 247   } else {
 248     JVMFlag::printSetFlags(output());
 249   }
 250 }
 251 
 252 int PrintVMFlagsDCmd::num_arguments() {
 253     ResourceMark rm;
 254     PrintVMFlagsDCmd* dcmd = new PrintVMFlagsDCmd(NULL, false);
 255     if (dcmd != NULL) {
 256       DCmdMark mark(dcmd);
 257       return dcmd-&gt;_dcmdparser.num_arguments();
 258     } else {
 259       return 0;
 260     }
 261 }
 262 
 263 SetVMFlagDCmd::SetVMFlagDCmd(outputStream* output, bool heap) :
 264                                    DCmdWithParser(output, heap),
 265   _flag(&quot;flag name&quot;, &quot;The name of the flag we want to set&quot;,
 266         &quot;STRING&quot;, true),
 267   _value(&quot;string value&quot;, &quot;The value we want to set&quot;, &quot;STRING&quot;, false) {
 268   _dcmdparser.add_dcmd_argument(&amp;_flag);
 269   _dcmdparser.add_dcmd_argument(&amp;_value);
 270 }
 271 
 272 void SetVMFlagDCmd::execute(DCmdSource source, TRAPS) {
 273   const char* val = NULL;
 274   if (_value.value() != NULL) {
 275     val = _value.value();
 276   }
 277 
 278   FormatBuffer&lt;80&gt; err_msg(&quot;%s&quot;, &quot;&quot;);
 279   int ret = WriteableFlags::set_flag(_flag.value(), val, JVMFlag::MANAGEMENT, err_msg);
 280 
 281   if (ret != JVMFlag::SUCCESS) {
 282     output()-&gt;print_cr(&quot;%s&quot;, err_msg.buffer());
 283   }
 284 }
 285 
 286 int SetVMFlagDCmd::num_arguments() {
 287   ResourceMark rm;
 288   SetVMFlagDCmd* dcmd = new SetVMFlagDCmd(NULL, false);
 289   if (dcmd != NULL) {
 290     DCmdMark mark(dcmd);
 291     return dcmd-&gt;_dcmdparser.num_arguments();
 292   } else {
 293     return 0;
 294   }
 295 }
 296 
 297 void JVMTIDataDumpDCmd::execute(DCmdSource source, TRAPS) {
 298   if (JvmtiExport::should_post_data_dump()) {
 299     JvmtiExport::post_data_dump();
 300   }
 301 }
 302 
 303 #if INCLUDE_SERVICES
 304 JVMTIAgentLoadDCmd::JVMTIAgentLoadDCmd(outputStream* output, bool heap) :
 305                                        DCmdWithParser(output, heap),
 306   _libpath(&quot;library path&quot;, &quot;Absolute path of the JVMTI agent to load.&quot;,
 307            &quot;STRING&quot;, true),
 308   _option(&quot;agent option&quot;, &quot;Option string to pass the agent.&quot;, &quot;STRING&quot;, false) {
 309   _dcmdparser.add_dcmd_argument(&amp;_libpath);
 310   _dcmdparser.add_dcmd_argument(&amp;_option);
 311 }
 312 
 313 void JVMTIAgentLoadDCmd::execute(DCmdSource source, TRAPS) {
 314 
 315   if (_libpath.value() == NULL) {
 316     output()-&gt;print_cr(&quot;JVMTI.agent_load dcmd needs library path.&quot;);
 317     return;
 318   }
 319 
 320   char *suffix = strrchr(_libpath.value(), &#39;.&#39;);
 321   bool is_java_agent = (suffix != NULL) &amp;&amp; (strncmp(&quot;.jar&quot;, suffix, 4) == 0);
 322 
 323   if (is_java_agent) {
 324     if (_option.value() == NULL) {
 325       JvmtiExport::load_agent_library(&quot;instrument&quot;, &quot;false&quot;,
 326                                       _libpath.value(), output());
 327     } else {
 328       size_t opt_len = strlen(_libpath.value()) + strlen(_option.value()) + 2;
 329       if (opt_len &gt; 4096) {
 330         output()-&gt;print_cr(&quot;JVMTI agent attach failed: Options is too long.&quot;);
 331         return;
 332       }
 333 
 334       char *opt = (char *)os::malloc(opt_len, mtInternal);
 335       if (opt == NULL) {
 336         output()-&gt;print_cr(&quot;JVMTI agent attach failed: &quot;
 337                            &quot;Could not allocate &quot; SIZE_FORMAT &quot; bytes for argument.&quot;,
 338                            opt_len);
 339         return;
 340       }
 341 
 342       jio_snprintf(opt, opt_len, &quot;%s=%s&quot;, _libpath.value(), _option.value());
 343       JvmtiExport::load_agent_library(&quot;instrument&quot;, &quot;false&quot;, opt, output());
 344 
 345       os::free(opt);
 346     }
 347   } else {
 348     JvmtiExport::load_agent_library(_libpath.value(), &quot;true&quot;,
 349                                     _option.value(), output());
 350   }
 351 }
 352 
 353 int JVMTIAgentLoadDCmd::num_arguments() {
 354   ResourceMark rm;
 355   JVMTIAgentLoadDCmd* dcmd = new JVMTIAgentLoadDCmd(NULL, false);
 356   if (dcmd != NULL) {
 357     DCmdMark mark(dcmd);
 358     return dcmd-&gt;_dcmdparser.num_arguments();
 359   } else {
 360     return 0;
 361   }
 362 }
 363 #endif // INCLUDE_SERVICES
 364 
 365 void PrintSystemPropertiesDCmd::execute(DCmdSource source, TRAPS) {
 366   // load VMSupport
 367   Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();
 368   Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK);
 369   InstanceKlass* ik = InstanceKlass::cast(k);
 370   if (ik-&gt;should_be_initialized()) {
 371     ik-&gt;initialize(THREAD);
 372   }
 373   if (HAS_PENDING_EXCEPTION) {
 374     java_lang_Throwable::print(PENDING_EXCEPTION, output());
 375     output()-&gt;cr();
 376     CLEAR_PENDING_EXCEPTION;
 377     return;
 378   }
 379 
 380   // invoke the serializePropertiesToByteArray method
 381   JavaValue result(T_OBJECT);
 382   JavaCallArguments args;
 383 
 384   Symbol* signature = vmSymbols::serializePropertiesToByteArray_signature();
 385   JavaCalls::call_static(&amp;result,
 386                          ik,
 387                          vmSymbols::serializePropertiesToByteArray_name(),
 388                          signature,
 389                          &amp;args,
 390                          THREAD);
 391   if (HAS_PENDING_EXCEPTION) {
 392     java_lang_Throwable::print(PENDING_EXCEPTION, output());
 393     output()-&gt;cr();
 394     CLEAR_PENDING_EXCEPTION;
 395     return;
 396   }
 397 
 398   // The result should be a [B
 399   oop res = (oop)result.get_jobject();
 400   assert(res-&gt;is_typeArray(), &quot;just checking&quot;);
 401   assert(TypeArrayKlass::cast(res-&gt;klass())-&gt;element_type() == T_BYTE, &quot;just checking&quot;);
 402 
 403   // copy the bytes to the output stream
 404   typeArrayOop ba = typeArrayOop(res);
 405   jbyte* addr = typeArrayOop(res)-&gt;byte_at_addr(0);
 406   output()-&gt;print_raw((const char*)addr, ba-&gt;length());
 407 }
 408 
 409 VMUptimeDCmd::VMUptimeDCmd(outputStream* output, bool heap) :
 410                            DCmdWithParser(output, heap),
 411   _date(&quot;-date&quot;, &quot;Add a prefix with current date&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 412   _dcmdparser.add_dcmd_option(&amp;_date);
 413 }
 414 
 415 void VMUptimeDCmd::execute(DCmdSource source, TRAPS) {
 416   if (_date.value()) {
 417     output()-&gt;date_stamp(true, &quot;&quot;, &quot;: &quot;);
 418   }
 419   output()-&gt;time_stamp().update_to(tty-&gt;time_stamp().ticks());
 420   output()-&gt;stamp();
 421   output()-&gt;print_cr(&quot; s&quot;);
 422 }
 423 
 424 int VMUptimeDCmd::num_arguments() {
 425   ResourceMark rm;
 426   VMUptimeDCmd* dcmd = new VMUptimeDCmd(NULL, false);
 427   if (dcmd != NULL) {
 428     DCmdMark mark(dcmd);
 429     return dcmd-&gt;_dcmdparser.num_arguments();
 430   } else {
 431     return 0;
 432   }
 433 }
 434 
 435 void VMInfoDCmd::execute(DCmdSource source, TRAPS) {
 436   VMError::print_vm_info(_output);
 437 }
 438 
 439 void SystemGCDCmd::execute(DCmdSource source, TRAPS) {
 440   Universe::heap()-&gt;collect(GCCause::_dcmd_gc_run);
 441 }
 442 
 443 void RunFinalizationDCmd::execute(DCmdSource source, TRAPS) {
 444   Klass* k = SystemDictionary::System_klass();
 445   JavaValue result(T_VOID);
 446   JavaCalls::call_static(&amp;result, k,
 447                          vmSymbols::run_finalization_name(),
 448                          vmSymbols::void_method_signature(), CHECK);
 449 }
 450 
 451 void HeapInfoDCmd::execute(DCmdSource source, TRAPS) {
 452   MutexLocker hl(THREAD, Heap_lock);
 453   Universe::heap()-&gt;print_on(output());
 454 }
 455 
 456 void FinalizerInfoDCmd::execute(DCmdSource source, TRAPS) {
 457   ResourceMark rm(THREAD);
 458 
 459   Klass* k = SystemDictionary::resolve_or_fail(
 460     vmSymbols::finalizer_histogram_klass(), true, CHECK);
 461 
 462   JavaValue result(T_ARRAY);
 463 
 464   // We are calling lang.ref.FinalizerHistogram.getFinalizerHistogram() method
 465   // and expect it to return array of FinalizerHistogramEntry as Object[]
 466 
 467   JavaCalls::call_static(&amp;result, k,
 468                          vmSymbols::get_finalizer_histogram_name(),
 469                          vmSymbols::void_finalizer_histogram_entry_array_signature(), CHECK);
 470 
 471   objArrayOop result_oop = (objArrayOop) result.get_jobject();
 472   if (result_oop-&gt;length() == 0) {
 473     output()-&gt;print_cr(&quot;No instances waiting for finalization found&quot;);
 474     return;
 475   }
 476 
 477   oop foop = result_oop-&gt;obj_at(0);
 478   InstanceKlass* ik = InstanceKlass::cast(foop-&gt;klass());
 479 
 480   fieldDescriptor count_fd, name_fd;
 481 
 482   Klass* count_res = ik-&gt;find_field(
 483     vmSymbols::finalizer_histogram_entry_count_field(), vmSymbols::int_signature(), &amp;count_fd);
 484 
 485   Klass* name_res = ik-&gt;find_field(
 486     vmSymbols::finalizer_histogram_entry_name_field(), vmSymbols::string_signature(), &amp;name_fd);
 487 
 488   assert(count_res != NULL &amp;&amp; name_res != NULL, &quot;Unexpected layout of FinalizerHistogramEntry&quot;);
 489 
 490   output()-&gt;print_cr(&quot;Unreachable instances waiting for finalization&quot;);
 491   output()-&gt;print_cr(&quot;#instances  class name&quot;);
 492   output()-&gt;print_cr(&quot;-----------------------&quot;);
 493 
 494   for (int i = 0; i &lt; result_oop-&gt;length(); ++i) {
 495     oop element_oop = result_oop-&gt;obj_at(i);
 496     oop str_oop = element_oop-&gt;obj_field(name_fd.offset());
 497     char *name = java_lang_String::as_utf8_string(str_oop);
 498     int count = element_oop-&gt;int_field(count_fd.offset());
 499     output()-&gt;print_cr(&quot;%10d  %s&quot;, count, name);
 500   }
 501 }
 502 
 503 #if INCLUDE_SERVICES // Heap dumping/inspection supported
 504 HeapDumpDCmd::HeapDumpDCmd(outputStream* output, bool heap) :
 505                            DCmdWithParser(output, heap),
 506   _filename(&quot;filename&quot;,&quot;Name of the dump file&quot;, &quot;STRING&quot;,true),
 507   _all(&quot;-all&quot;, &quot;Dump all objects, including unreachable objects&quot;,
 508        &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 509   _gzip(&quot;-gz&quot;, &quot;If specified, the heap dump is written in gzipped format &quot;
 510                &quot;using the given compression level. 1 (recommended) is the fastest, &quot;
 511                &quot;9 the strongest compression.&quot;, &quot;INT&quot;, false, &quot;1&quot;) {
 512   _dcmdparser.add_dcmd_option(&amp;_all);
 513   _dcmdparser.add_dcmd_argument(&amp;_filename);
 514   _dcmdparser.add_dcmd_option(&amp;_gzip);
 515 }
 516 
 517 void HeapDumpDCmd::execute(DCmdSource source, TRAPS) {
 518   jlong level = -1; // -1 means no compression.
 519 
 520   if (_gzip.is_set()) {
 521     level = _gzip.value();
 522 
 523     if (level &lt; 1 || level &gt; 9) {
 524       output()-&gt;print_cr(&quot;Compression level out of range (1-9): &quot; JLONG_FORMAT, level);
 525       return;
 526     }
 527   }
 528 
 529   // Request a full GC before heap dump if _all is false
 530   // This helps reduces the amount of unreachable objects in the dump
 531   // and makes it easier to browse.
 532   HeapDumper dumper(!_all.value() /* request GC if _all is false*/);
 533   dumper.dump(_filename.value(), output(), (int) level);
 534 }
 535 
 536 int HeapDumpDCmd::num_arguments() {
 537   ResourceMark rm;
 538   HeapDumpDCmd* dcmd = new HeapDumpDCmd(NULL, false);
 539   if (dcmd != NULL) {
 540     DCmdMark mark(dcmd);
 541     return dcmd-&gt;_dcmdparser.num_arguments();
 542   } else {
 543     return 0;
 544   }
 545 }
 546 
 547 ClassHistogramDCmd::ClassHistogramDCmd(outputStream* output, bool heap) :
 548                                        DCmdWithParser(output, heap),
 549   _all(&quot;-all&quot;, &quot;Inspect all objects, including unreachable objects&quot;,
 550        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 551   _dcmdparser.add_dcmd_option(&amp;_all);
 552 }
 553 
 554 void ClassHistogramDCmd::execute(DCmdSource source, TRAPS) {
 555   VM_GC_HeapInspection heapop(output(),
 556                               !_all.value() /* request full gc if false */);
 557   VMThread::execute(&amp;heapop);
 558 }
 559 
 560 int ClassHistogramDCmd::num_arguments() {
 561   ResourceMark rm;
 562   ClassHistogramDCmd* dcmd = new ClassHistogramDCmd(NULL, false);
 563   if (dcmd != NULL) {
 564     DCmdMark mark(dcmd);
 565     return dcmd-&gt;_dcmdparser.num_arguments();
 566   } else {
 567     return 0;
 568   }
 569 }
 570 
 571 #endif // INCLUDE_SERVICES
 572 
 573 ThreadDumpDCmd::ThreadDumpDCmd(outputStream* output, bool heap) :
 574                                DCmdWithParser(output, heap),
 575   _locks(&quot;-l&quot;, &quot;print java.util.concurrent locks&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 576   _extended(&quot;-e&quot;, &quot;print extended thread information&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 577   _dcmdparser.add_dcmd_option(&amp;_locks);
 578   _dcmdparser.add_dcmd_option(&amp;_extended);
 579 }
 580 
 581 void ThreadDumpDCmd::execute(DCmdSource source, TRAPS) {
 582   // thread stacks
 583   VM_PrintThreads op1(output(), _locks.value(), _extended.value());
 584   VMThread::execute(&amp;op1);
 585 
 586   // JNI global handles
 587   VM_PrintJNI op2(output());
 588   VMThread::execute(&amp;op2);
 589 
 590   // Deadlock detection
 591   VM_FindDeadlocks op3(output());
 592   VMThread::execute(&amp;op3);
 593 }
 594 
 595 int ThreadDumpDCmd::num_arguments() {
 596   ResourceMark rm;
 597   ThreadDumpDCmd* dcmd = new ThreadDumpDCmd(NULL, false);
 598   if (dcmd != NULL) {
 599     DCmdMark mark(dcmd);
 600     return dcmd-&gt;_dcmdparser.num_arguments();
 601   } else {
 602     return 0;
 603   }
 604 }
 605 
 606 // Enhanced JMX Agent support
 607 
 608 JMXStartRemoteDCmd::JMXStartRemoteDCmd(outputStream *output, bool heap_allocated) :
 609 
 610   DCmdWithParser(output, heap_allocated),
 611 
 612   _config_file
 613   (&quot;config.file&quot;,
 614    &quot;set com.sun.management.config.file&quot;, &quot;STRING&quot;, false),
 615 
 616   _jmxremote_host
 617   (&quot;jmxremote.host&quot;,
 618    &quot;set com.sun.management.jmxremote.host&quot;, &quot;STRING&quot;, false),
 619 
 620   _jmxremote_port
 621   (&quot;jmxremote.port&quot;,
 622    &quot;set com.sun.management.jmxremote.port&quot;, &quot;STRING&quot;, false),
 623 
 624   _jmxremote_rmi_port
 625   (&quot;jmxremote.rmi.port&quot;,
 626    &quot;set com.sun.management.jmxremote.rmi.port&quot;, &quot;STRING&quot;, false),
 627 
 628   _jmxremote_ssl
 629   (&quot;jmxremote.ssl&quot;,
 630    &quot;set com.sun.management.jmxremote.ssl&quot;, &quot;STRING&quot;, false),
 631 
 632   _jmxremote_registry_ssl
 633   (&quot;jmxremote.registry.ssl&quot;,
 634    &quot;set com.sun.management.jmxremote.registry.ssl&quot;, &quot;STRING&quot;, false),
 635 
 636   _jmxremote_authenticate
 637   (&quot;jmxremote.authenticate&quot;,
 638    &quot;set com.sun.management.jmxremote.authenticate&quot;, &quot;STRING&quot;, false),
 639 
 640   _jmxremote_password_file
 641   (&quot;jmxremote.password.file&quot;,
 642    &quot;set com.sun.management.jmxremote.password.file&quot;, &quot;STRING&quot;, false),
 643 
 644   _jmxremote_access_file
 645   (&quot;jmxremote.access.file&quot;,
 646    &quot;set com.sun.management.jmxremote.access.file&quot;, &quot;STRING&quot;, false),
 647 
 648   _jmxremote_login_config
 649   (&quot;jmxremote.login.config&quot;,
 650    &quot;set com.sun.management.jmxremote.login.config&quot;, &quot;STRING&quot;, false),
 651 
 652   _jmxremote_ssl_enabled_cipher_suites
 653   (&quot;jmxremote.ssl.enabled.cipher.suites&quot;,
 654    &quot;set com.sun.management.jmxremote.ssl.enabled.cipher.suite&quot;, &quot;STRING&quot;, false),
 655 
 656   _jmxremote_ssl_enabled_protocols
 657   (&quot;jmxremote.ssl.enabled.protocols&quot;,
 658    &quot;set com.sun.management.jmxremote.ssl.enabled.protocols&quot;, &quot;STRING&quot;, false),
 659 
 660   _jmxremote_ssl_need_client_auth
 661   (&quot;jmxremote.ssl.need.client.auth&quot;,
 662    &quot;set com.sun.management.jmxremote.need.client.auth&quot;, &quot;STRING&quot;, false),
 663 
 664   _jmxremote_ssl_config_file
 665   (&quot;jmxremote.ssl.config.file&quot;,
 666    &quot;set com.sun.management.jmxremote.ssl.config.file&quot;, &quot;STRING&quot;, false),
 667 
 668 // JDP Protocol support
 669   _jmxremote_autodiscovery
 670   (&quot;jmxremote.autodiscovery&quot;,
 671    &quot;set com.sun.management.jmxremote.autodiscovery&quot;, &quot;STRING&quot;, false),
 672 
 673    _jdp_port
 674   (&quot;jdp.port&quot;,
 675    &quot;set com.sun.management.jdp.port&quot;, &quot;INT&quot;, false),
 676 
 677    _jdp_address
 678   (&quot;jdp.address&quot;,
 679    &quot;set com.sun.management.jdp.address&quot;, &quot;STRING&quot;, false),
 680 
 681    _jdp_source_addr
 682   (&quot;jdp.source_addr&quot;,
 683    &quot;set com.sun.management.jdp.source_addr&quot;, &quot;STRING&quot;, false),
 684 
 685    _jdp_ttl
 686   (&quot;jdp.ttl&quot;,
 687    &quot;set com.sun.management.jdp.ttl&quot;, &quot;INT&quot;, false),
 688 
 689    _jdp_pause
 690   (&quot;jdp.pause&quot;,
 691    &quot;set com.sun.management.jdp.pause&quot;, &quot;INT&quot;, false),
 692 
 693    _jdp_name
 694   (&quot;jdp.name&quot;,
 695    &quot;set com.sun.management.jdp.name&quot;, &quot;STRING&quot;, false)
 696 
 697   {
 698     _dcmdparser.add_dcmd_option(&amp;_config_file);
 699     _dcmdparser.add_dcmd_option(&amp;_jmxremote_host);
 700     _dcmdparser.add_dcmd_option(&amp;_jmxremote_port);
 701     _dcmdparser.add_dcmd_option(&amp;_jmxremote_rmi_port);
 702     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl);
 703     _dcmdparser.add_dcmd_option(&amp;_jmxremote_registry_ssl);
 704     _dcmdparser.add_dcmd_option(&amp;_jmxremote_authenticate);
 705     _dcmdparser.add_dcmd_option(&amp;_jmxremote_password_file);
 706     _dcmdparser.add_dcmd_option(&amp;_jmxremote_access_file);
 707     _dcmdparser.add_dcmd_option(&amp;_jmxremote_login_config);
 708     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_enabled_cipher_suites);
 709     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_enabled_protocols);
 710     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_need_client_auth);
 711     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_config_file);
 712     _dcmdparser.add_dcmd_option(&amp;_jmxremote_autodiscovery);
 713     _dcmdparser.add_dcmd_option(&amp;_jdp_port);
 714     _dcmdparser.add_dcmd_option(&amp;_jdp_address);
 715     _dcmdparser.add_dcmd_option(&amp;_jdp_source_addr);
 716     _dcmdparser.add_dcmd_option(&amp;_jdp_ttl);
 717     _dcmdparser.add_dcmd_option(&amp;_jdp_pause);
 718     _dcmdparser.add_dcmd_option(&amp;_jdp_name);
 719 }
 720 
 721 
 722 int JMXStartRemoteDCmd::num_arguments() {
 723   ResourceMark rm;
 724   JMXStartRemoteDCmd* dcmd = new JMXStartRemoteDCmd(NULL, false);
 725   if (dcmd != NULL) {
 726     DCmdMark mark(dcmd);
 727     return dcmd-&gt;_dcmdparser.num_arguments();
 728   } else {
 729     return 0;
 730   }
 731 }
 732 
 733 
 734 void JMXStartRemoteDCmd::execute(DCmdSource source, TRAPS) {
 735     ResourceMark rm(THREAD);
 736     HandleMark hm(THREAD);
 737 
 738     // Load and initialize the jdk.internal.agent.Agent class
 739     // invoke startRemoteManagementAgent(string) method to start
 740     // the remote management server.
 741     // throw java.lang.NoSuchMethodError if the method doesn&#39;t exist
 742 
 743     loadAgentModule(CHECK);
 744     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 745     Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 746 
 747     JavaValue result(T_VOID);
 748 
 749     // Pass all command line arguments to java as key=value,...
 750     // All checks are done on java side
 751 
 752     int len = 0;
 753     stringStream options;
 754     char comma[2] = {0,0};
 755 
 756     // Leave default values on Agent.class side and pass only
 757     // agruments explicitly set by user. All arguments passed
 758     // to jcmd override properties with the same name set by
 759     // command line with -D or by managmenent.properties
 760     // file.
 761 #define PUT_OPTION(a) \
 762     do { \
 763         if ( (a).is_set() ){ \
 764             if ( *((a).type()) == &#39;I&#39; ) { \
 765                 options.print(&quot;%scom.sun.management.%s=&quot; JLONG_FORMAT, comma, (a).name(), (jlong)((a).value())); \
 766             } else { \
 767                 options.print(&quot;%scom.sun.management.%s=%s&quot;, comma, (a).name(), (char*)((a).value())); \
 768             } \
 769             comma[0] = &#39;,&#39;; \
 770         }\
 771     } while(0);
 772 
 773 
 774     PUT_OPTION(_config_file);
 775     PUT_OPTION(_jmxremote_host);
 776     PUT_OPTION(_jmxremote_port);
 777     PUT_OPTION(_jmxremote_rmi_port);
 778     PUT_OPTION(_jmxremote_ssl);
 779     PUT_OPTION(_jmxremote_registry_ssl);
 780     PUT_OPTION(_jmxremote_authenticate);
 781     PUT_OPTION(_jmxremote_password_file);
 782     PUT_OPTION(_jmxremote_access_file);
 783     PUT_OPTION(_jmxremote_login_config);
 784     PUT_OPTION(_jmxremote_ssl_enabled_cipher_suites);
 785     PUT_OPTION(_jmxremote_ssl_enabled_protocols);
 786     PUT_OPTION(_jmxremote_ssl_need_client_auth);
 787     PUT_OPTION(_jmxremote_ssl_config_file);
 788     PUT_OPTION(_jmxremote_autodiscovery);
 789     PUT_OPTION(_jdp_port);
 790     PUT_OPTION(_jdp_address);
 791     PUT_OPTION(_jdp_source_addr);
 792     PUT_OPTION(_jdp_ttl);
 793     PUT_OPTION(_jdp_pause);
 794     PUT_OPTION(_jdp_name);
 795 
 796 #undef PUT_OPTION
 797 
 798     Handle str = java_lang_String::create_from_str(options.as_string(), CHECK);
 799     JavaCalls::call_static(&amp;result, k, vmSymbols::startRemoteAgent_name(), vmSymbols::string_void_signature(), str, CHECK);
 800 }
 801 
 802 JMXStartLocalDCmd::JMXStartLocalDCmd(outputStream *output, bool heap_allocated) :
 803   DCmd(output, heap_allocated) {
 804   // do nothing
 805 }
 806 
 807 void JMXStartLocalDCmd::execute(DCmdSource source, TRAPS) {
 808     ResourceMark rm(THREAD);
 809     HandleMark hm(THREAD);
 810 
 811     // Load and initialize the jdk.internal.agent.Agent class
 812     // invoke startLocalManagementAgent(void) method to start
 813     // the local management server
 814     // throw java.lang.NoSuchMethodError if method doesn&#39;t exist
 815 
 816     loadAgentModule(CHECK);
 817     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 818     Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 819 
 820     JavaValue result(T_VOID);
 821     JavaCalls::call_static(&amp;result, k, vmSymbols::startLocalAgent_name(), vmSymbols::void_method_signature(), CHECK);
 822 }
 823 
 824 void JMXStopRemoteDCmd::execute(DCmdSource source, TRAPS) {
 825     ResourceMark rm(THREAD);
 826     HandleMark hm(THREAD);
 827 
 828     // Load and initialize the jdk.internal.agent.Agent class
 829     // invoke stopRemoteManagementAgent method to stop the
 830     // management server
 831     // throw java.lang.NoSuchMethodError if method doesn&#39;t exist
 832 
 833     loadAgentModule(CHECK);
 834     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 835     Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 836 
 837     JavaValue result(T_VOID);
 838     JavaCalls::call_static(&amp;result, k, vmSymbols::stopRemoteAgent_name(), vmSymbols::void_method_signature(), CHECK);
 839 }
 840 
 841 JMXStatusDCmd::JMXStatusDCmd(outputStream *output, bool heap_allocated) :
 842   DCmd(output, heap_allocated) {
 843   // do nothing
 844 }
 845 
 846 void JMXStatusDCmd::execute(DCmdSource source, TRAPS) {
 847   ResourceMark rm(THREAD);
 848   HandleMark hm(THREAD);
 849 
 850   // Load and initialize the jdk.internal.agent.Agent class
 851   // invoke getManagementAgentStatus() method to generate the status info
 852   // throw java.lang.NoSuchMethodError if method doesn&#39;t exist
 853 
 854   loadAgentModule(CHECK);
 855   Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 856   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 857 
 858   JavaValue result(T_OBJECT);
 859   JavaCalls::call_static(&amp;result, k, vmSymbols::getAgentStatus_name(), vmSymbols::void_string_signature(), CHECK);
 860 
 861   jvalue* jv = (jvalue*) result.get_value_addr();
 862   oop str = (oop) jv-&gt;l;
 863   if (str != NULL) {
 864       char* out = java_lang_String::as_utf8_string(str);
 865       if (out) {
 866           output()-&gt;print_cr(&quot;%s&quot;, out);
 867           return;
 868       }
 869   }
 870   output()-&gt;print_cr(&quot;Error obtaining management agent status&quot;);
 871 }
 872 
 873 VMDynamicLibrariesDCmd::VMDynamicLibrariesDCmd(outputStream *output, bool heap_allocated) :
 874   DCmd(output, heap_allocated) {
 875   // do nothing
 876 }
 877 
 878 void VMDynamicLibrariesDCmd::execute(DCmdSource source, TRAPS) {
 879   os::print_dll_info(output());
 880   output()-&gt;cr();
 881 }
 882 
 883 void CompileQueueDCmd::execute(DCmdSource source, TRAPS) {
 884   VM_PrintCompileQueue printCompileQueueOp(output());
 885   VMThread::execute(&amp;printCompileQueueOp);
 886 }
 887 
 888 void CodeListDCmd::execute(DCmdSource source, TRAPS) {
 889   CodeCache::print_codelist(output());
 890 }
 891 
 892 void CodeCacheDCmd::execute(DCmdSource source, TRAPS) {
 893   CodeCache::print_layout(output());
 894 }
 895 
 896 //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
 897 CodeHeapAnalyticsDCmd::CodeHeapAnalyticsDCmd(outputStream* output, bool heap) :
 898                                              DCmdWithParser(output, heap),
 899   _function(&quot;function&quot;, &quot;Function to be performed (aggregate, UsedSpace, FreeSpace, MethodCount, MethodSpace, MethodAge, MethodNames, discard&quot;, &quot;STRING&quot;, false, &quot;all&quot;),
 900   _granularity(&quot;granularity&quot;, &quot;Detail level - smaller value -&gt; more detail&quot;, &quot;INT&quot;, false, &quot;4096&quot;) {
 901   _dcmdparser.add_dcmd_argument(&amp;_function);
 902   _dcmdparser.add_dcmd_argument(&amp;_granularity);
 903 }
 904 
 905 void CodeHeapAnalyticsDCmd::execute(DCmdSource source, TRAPS) {
 906   jlong granularity = _granularity.value();
 907   if (granularity &lt; 1) {
 908     Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IllegalArgumentException(),
 909                        &quot;Invalid granularity value &quot; JLONG_FORMAT  &quot;. Should be positive.\n&quot;, granularity);
 910     return;
 911   }
 912 
 913   CompileBroker::print_heapinfo(output(), _function.value(), granularity);
 914 }
 915 
 916 int CodeHeapAnalyticsDCmd::num_arguments() {
 917   ResourceMark rm;
 918   CodeHeapAnalyticsDCmd* dcmd = new CodeHeapAnalyticsDCmd(NULL, false);
 919   if (dcmd != NULL) {
 920     DCmdMark mark(dcmd);
 921     return dcmd-&gt;_dcmdparser.num_arguments();
 922   } else {
 923     return 0;
 924   }
 925 }
 926 //---&lt;  END  &gt;--- CodeHeap State Analytics.
 927 
 928 EventLogDCmd::EventLogDCmd(outputStream* output, bool heap) :
 929   DCmdWithParser(output, heap),
 930   _log(&quot;log&quot;, &quot;Name of log to be printed. If omitted, all logs are printed.&quot;, &quot;STRING&quot;, false, NULL),
 931   _max(&quot;max&quot;, &quot;Maximum number of events to be printed (newest first). If omitted, all events are printed.&quot;, &quot;STRING&quot;, false, NULL)
 932 {
 933   _dcmdparser.add_dcmd_option(&amp;_log);
 934   _dcmdparser.add_dcmd_option(&amp;_max);
 935 }
 936 
 937 void EventLogDCmd::execute(DCmdSource source, TRAPS) {
 938   const char* max_value = _max.value();
 939   long max = -1;
 940   if (max_value != NULL) {
 941     char* endptr = NULL;
 942     max = ::strtol(max_value, &amp;endptr, 10);
 943     if (max == 0 &amp;&amp; max_value == endptr) {
 944       output()-&gt;print_cr(&quot;Invalid max option: \&quot;%s\&quot;.&quot;, max_value);
 945       return;
 946     }
 947   }
 948   const char* log_name = _log.value();
 949   if (log_name != NULL) {
 950     Events::print_one(output(), log_name, max);
 951   } else {
 952     Events::print_all(output(), max);
 953   }
 954 }
 955 
 956 int EventLogDCmd::num_arguments() {
 957   ResourceMark rm;
 958   EventLogDCmd* dcmd = new EventLogDCmd(NULL, false);
 959   if (dcmd != NULL) {
 960     DCmdMark mark(dcmd);
 961     return dcmd-&gt;_dcmdparser.num_arguments();
 962   } else {
 963     return 0;
 964   }
 965 }
 966 
 967 void CompilerDirectivesPrintDCmd::execute(DCmdSource source, TRAPS) {
 968   DirectivesStack::print(output());
 969 }
 970 
 971 CompilerDirectivesAddDCmd::CompilerDirectivesAddDCmd(outputStream* output, bool heap) :
 972                            DCmdWithParser(output, heap),
 973   _filename(&quot;filename&quot;,&quot;Name of the directives file&quot;, &quot;STRING&quot;,true) {
 974   _dcmdparser.add_dcmd_argument(&amp;_filename);
 975 }
 976 
 977 void CompilerDirectivesAddDCmd::execute(DCmdSource source, TRAPS) {
 978   DirectivesParser::parse_from_file(_filename.value(), output());
 979 }
 980 
 981 int CompilerDirectivesAddDCmd::num_arguments() {
 982   ResourceMark rm;
 983   CompilerDirectivesAddDCmd* dcmd = new CompilerDirectivesAddDCmd(NULL, false);
 984   if (dcmd != NULL) {
 985     DCmdMark mark(dcmd);
 986     return dcmd-&gt;_dcmdparser.num_arguments();
 987   } else {
 988     return 0;
 989   }
 990 }
 991 
 992 void CompilerDirectivesRemoveDCmd::execute(DCmdSource source, TRAPS) {
 993   DirectivesStack::pop(1);
 994 }
 995 
 996 void CompilerDirectivesClearDCmd::execute(DCmdSource source, TRAPS) {
 997   DirectivesStack::clear();
 998 }
 999 #if INCLUDE_SERVICES
1000 ClassHierarchyDCmd::ClassHierarchyDCmd(outputStream* output, bool heap) :
1001                                        DCmdWithParser(output, heap),
1002   _print_interfaces(&quot;-i&quot;, &quot;Inherited interfaces should be printed.&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
1003   _print_subclasses(&quot;-s&quot;, &quot;If a classname is specified, print its subclasses. &quot;
1004                     &quot;Otherwise only its superclasses are printed.&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
1005   _classname(&quot;classname&quot;, &quot;Name of class whose hierarchy should be printed. &quot;
1006              &quot;If not specified, all class hierarchies are printed.&quot;,
1007              &quot;STRING&quot;, false) {
1008   _dcmdparser.add_dcmd_option(&amp;_print_interfaces);
1009   _dcmdparser.add_dcmd_option(&amp;_print_subclasses);
1010   _dcmdparser.add_dcmd_argument(&amp;_classname);
1011 }
1012 
1013 void ClassHierarchyDCmd::execute(DCmdSource source, TRAPS) {
1014   VM_PrintClassHierarchy printClassHierarchyOp(output(), _print_interfaces.value(),
1015                                                _print_subclasses.value(), _classname.value());
1016   VMThread::execute(&amp;printClassHierarchyOp);
1017 }
1018 
1019 int ClassHierarchyDCmd::num_arguments() {
1020   ResourceMark rm;
1021   ClassHierarchyDCmd* dcmd = new ClassHierarchyDCmd(NULL, false);
1022   if (dcmd != NULL) {
1023     DCmdMark mark(dcmd);
1024     return dcmd-&gt;_dcmdparser.num_arguments();
1025   } else {
1026     return 0;
1027   }
1028 }
1029 
1030 #endif
1031 
1032 PrintClassLayoutDCmd::PrintClassLayoutDCmd(outputStream* output, bool heap) :
1033                                        DCmdWithParser(output, heap),
1034   _classname(&quot;classname&quot;, &quot;Name of class whose layout should be printed. &quot;,
1035              &quot;STRING&quot;, true) {
1036   _dcmdparser.add_dcmd_argument(&amp;_classname);
1037 }
1038 
1039 void PrintClassLayoutDCmd::execute(DCmdSource source, TRAPS) {
1040   VM_PrintClassLayout printClassLayoutOp(output(), _classname.value());
1041   VMThread::execute(&amp;printClassLayoutOp);
1042 }
1043 
1044 int PrintClassLayoutDCmd::num_arguments() {
1045   ResourceMark rm;
1046   PrintClassLayoutDCmd* dcmd = new PrintClassLayoutDCmd(NULL, false);
1047   if (dcmd != NULL) {
1048     DCmdMark mark(dcmd);
1049     return dcmd-&gt;_dcmdparser.num_arguments();
1050   } else {
1051     return 0;
1052   }
1053 }
1054 
1055 class VM_DumpTouchedMethods : public VM_Operation {
1056 private:
1057   outputStream* _out;
1058 public:
1059   VM_DumpTouchedMethods(outputStream* out) {
1060     _out = out;
1061   }
1062 
1063   virtual VMOp_Type type() const { return VMOp_DumpTouchedMethods; }
1064 
1065   virtual void doit() {
1066     Method::print_touched_methods(_out);
1067   }
1068 };
1069 
1070 TouchedMethodsDCmd::TouchedMethodsDCmd(outputStream* output, bool heap) :
1071                                        DCmdWithParser(output, heap)
1072 {}
1073 
1074 void TouchedMethodsDCmd::execute(DCmdSource source, TRAPS) {
1075   if (!LogTouchedMethods) {
1076     output()-&gt;print_cr(&quot;VM.print_touched_methods command requires -XX:+LogTouchedMethods&quot;);
1077     return;
1078   }
1079   VM_DumpTouchedMethods dumper(output());
1080   VMThread::execute(&amp;dumper);
1081 }
1082 
1083 int TouchedMethodsDCmd::num_arguments() {
1084   return 0;
1085 }
1086 
1087 #if INCLUDE_JVMTI
1088 extern &quot;C&quot; typedef char const* (JNICALL *debugInit_startDebuggingViaCommandPtr)(JNIEnv* env, jthread thread, char const** transport_name,
1089                                                                                 char const** address, jboolean* first_start);
1090 static debugInit_startDebuggingViaCommandPtr dvc_start_ptr = NULL;
1091 
1092 DebugOnCmdStartDCmd::DebugOnCmdStartDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap) {
1093 }
1094 
1095 void DebugOnCmdStartDCmd::execute(DCmdSource source, TRAPS) {
1096   char const* transport = NULL;
1097   char const* addr = NULL;
1098   jboolean is_first_start = JNI_FALSE;
1099   JavaThread* thread = (JavaThread*) THREAD;
1100   jthread jt = JNIHandles::make_local(thread-&gt;threadObj());
1101   ThreadToNativeFromVM ttn(thread);
1102   const char *error = &quot;Could not find jdwp agent.&quot;;
1103 
1104   if (!dvc_start_ptr) {
1105     for (AgentLibrary* agent = Arguments::agents(); agent != NULL; agent = agent-&gt;next()) {
1106       if ((strcmp(&quot;jdwp&quot;, agent-&gt;name()) == 0) &amp;&amp; (dvc_start_ptr == NULL)) {
1107         char const* func = &quot;debugInit_startDebuggingViaCommand&quot;;
1108         dvc_start_ptr = (debugInit_startDebuggingViaCommandPtr) os::find_agent_function(agent, false, &amp;func, 1);
1109       }
1110     }
1111   }
1112 
1113   if (dvc_start_ptr) {
1114     error = dvc_start_ptr(thread-&gt;jni_environment(), jt, &amp;transport, &amp;addr, &amp;is_first_start);
1115   }
1116 
1117   if (error != NULL) {
1118     output()-&gt;print_cr(&quot;Debugging has not been started: %s&quot;, error);
1119   } else {
1120     output()-&gt;print_cr(is_first_start ? &quot;Debugging has been started.&quot; : &quot;Debugging is already active.&quot;);
1121     output()-&gt;print_cr(&quot;Transport : %s&quot;, transport ? transport : &quot;#unknown&quot;);
1122     output()-&gt;print_cr(&quot;Address : %s&quot;, addr ? addr : &quot;#unknown&quot;);
1123   }
1124 }
1125 #endif // INCLUDE_JVMTI
    </pre>
  </body>
</html>