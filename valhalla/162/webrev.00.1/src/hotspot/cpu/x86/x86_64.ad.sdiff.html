<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_CodeStubs_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/adlc/main.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 
<span class="line-removed">  870   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-removed">  871   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
<span class="line-removed">  872 </span>
  873   if (C-&gt;clinit_barrier_on_entry()) {
  874     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  875     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  876 
  877     Label L_skip_barrier;
  878     Register klass = rscratch1;
  879 
  880     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  881     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  882 
  883     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  884 
  885     __ bind(L_skip_barrier);
  886   }
  887 
<span class="line-modified">  888   __ verified_entry(framesize, C-&gt;output()-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);</span>






  889 
  890   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  891 
  892   if (C-&gt;has_mach_constant_base_node()) {
  893     // NOTE: We set the table base offset here because users might be
  894     // emitted before MachConstantBaseNode.
  895     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  896     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  897   }
  898 }
  899 
<span class="line-removed">  900 uint MachPrologNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed">  901 {</span>
<span class="line-removed">  902   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed">  903                               // the hard way</span>
<span class="line-removed">  904 }</span>
<span class="line-removed">  905 </span>
  906 int MachPrologNode::reloc() const
  907 {
  908   return 0; // a large enough number
  909 }
  910 
  911 //=============================================================================
  912 #ifndef PRODUCT
  913 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  914 {
  915   Compile* C = ra_-&gt;C;
  916   if (generate_vzeroupper(C)) {
  917     st-&gt;print(&quot;vzeroupper&quot;);
  918     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  919   }
  920 
  921   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  922   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  923   // Remove word for return adr already pushed
  924   // and RBP
  925   framesize -= 2*wordSize;
</pre>
<hr />
<pre>
  933   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  934     st-&gt;print(&quot;\t&quot;);
  935     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  936                  &quot;testl   rax, [rscratch1]\t&quot;
  937                  &quot;# Safepoint: poll for GC&quot;);
  938   }
  939 }
  940 #endif
  941 
  942 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  943 {
  944   Compile* C = ra_-&gt;C;
  945   MacroAssembler _masm(&amp;cbuf);
  946 
  947   if (generate_vzeroupper(C)) {
  948     // Clear upper bits of YMM registers when current compiled code uses
  949     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  950     __ vzeroupper();
  951   }
  952 
<span class="line-modified">  953   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  954   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);</span>
<span class="line-modified">  955   // Remove word for return adr already pushed</span>
<span class="line-removed">  956   // and RBP</span>
<span class="line-removed">  957   framesize -= 2*wordSize;</span>
<span class="line-removed">  958 </span>
<span class="line-removed">  959   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here</span>
<span class="line-removed">  960 </span>
<span class="line-removed">  961   if (framesize) {</span>
<span class="line-removed">  962     emit_opcode(cbuf, Assembler::REX_W);</span>
<span class="line-removed">  963     if (framesize &lt; 0x80) {</span>
<span class="line-removed">  964       emit_opcode(cbuf, 0x83); // addq rsp, #framesize</span>
<span class="line-removed">  965       emit_rm(cbuf, 0x3, 0x00, RSP_enc);</span>
<span class="line-removed">  966       emit_d8(cbuf, framesize);</span>
<span class="line-removed">  967     } else {</span>
<span class="line-removed">  968       emit_opcode(cbuf, 0x81); // addq rsp, #framesize</span>
<span class="line-removed">  969       emit_rm(cbuf, 0x3, 0x00, RSP_enc);</span>
<span class="line-removed">  970       emit_d32(cbuf, framesize);</span>
<span class="line-removed">  971     }</span>
<span class="line-removed">  972   }</span>
<span class="line-removed">  973 </span>
<span class="line-removed">  974   // popq rbp</span>
<span class="line-removed">  975   emit_opcode(cbuf, 0x58 | RBP_enc);</span>
  976 
  977   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  978     __ reserved_stack_check();
  979   }
  980 
  981   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  982     MacroAssembler _masm(&amp;cbuf);
  983     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  984     __ relocate(relocInfo::poll_return_type);
  985     __ testl(rax, Address(rscratch1, 0));
  986   }
  987 }
  988 
<span class="line-removed">  989 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed">  990 {</span>
<span class="line-removed">  991   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed">  992                               // the hard way</span>
<span class="line-removed">  993 }</span>
<span class="line-removed">  994 </span>
  995 int MachEpilogNode::reloc() const
  996 {
  997   return 2; // a large enough number
  998 }
  999 
 1000 const Pipeline* MachEpilogNode::pipeline() const
 1001 {
 1002   return MachNode::pipeline_class();
 1003 }
 1004 
 1005 //=============================================================================
 1006 
 1007 enum RC {
 1008   rc_bad,
 1009   rc_int,
 1010   rc_float,
 1011   rc_stack
 1012 };
 1013 
 1014 static enum RC rc_class(OptoReg::Name reg)
</pre>
<hr />
<pre>
 1510     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1511     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1512     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1513     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1514     emit_d32(cbuf, offset);
 1515   } else {
 1516     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1517     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1518     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1519     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1520     emit_d8(cbuf, offset);
 1521   }
 1522 }
 1523 
 1524 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1525 {
 1526   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1527   return (offset &lt; 0x80) ? 5 : 8; // REX
 1528 }
 1529 




























 1530 //=============================================================================
 1531 #ifndef PRODUCT
 1532 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1533 {
 1534   if (UseCompressedClassPointers) {
 1535     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1536     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1537     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1538   } else {
 1539     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1540                  &quot;# Inline cache check&quot;);
 1541   }
 1542   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1543   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1544 }
 1545 #endif
 1546 
 1547 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1548 {
 1549   MacroAssembler masm(&amp;cbuf);
</pre>
<hr />
<pre>
 1552     masm.load_klass(rscratch1, j_rarg0, rscratch2);
 1553     masm.cmpptr(rax, rscratch1);
 1554   } else {
 1555     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1556   }
 1557 
 1558   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1559 
 1560   /* WARNING these NOPs are critical so that verified entry point is properly
 1561      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1562   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1563   if (OptoBreakpoint) {
 1564     // Leave space for int3
 1565     nops_cnt -= 1;
 1566   }
 1567   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1568   if (nops_cnt &gt; 0)
 1569     masm.nop(nops_cnt);
 1570 }
 1571 
<span class="line-removed"> 1572 uint MachUEPNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed"> 1573 {</span>
<span class="line-removed"> 1574   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed"> 1575                               // the hard way</span>
<span class="line-removed"> 1576 }</span>
<span class="line-removed"> 1577 </span>
<span class="line-removed"> 1578 </span>
 1579 //=============================================================================
 1580 
 1581 int Matcher::regnum_to_fpu_offset(int regnum)
 1582 {
 1583   return regnum - 32; // The FP registers are in the second chunk
 1584 }
 1585 
 1586 // This is UltraSparc specific, true just means we have fast l2f conversion
 1587 const bool Matcher::convL2FSupported(void) {
 1588   return true;
 1589 }
 1590 
 1591 // Is this branch offset short enough that a short branch can be used?
 1592 //
 1593 // NOTE: If the platform does not provide any short branch variants, then
 1594 //       this method should return false for offset 0.
 1595 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1596   // The passed offset is relative to address of the branch.
 1597   // On 86 a branch displacement is calculated relative to address
 1598   // of a next instruction.
</pre>
<hr />
<pre>
 3841   %}
 3842 %}
 3843 
 3844 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3845 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3846 %{
 3847   constraint(ALLOC_IN_RC(ptr_reg));
 3848   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3849   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3850 
 3851   op_cost(10);
 3852   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3853   interface(MEMORY_INTER) %{
 3854     base($reg);
 3855     index($idx);
 3856     scale($scale);
 3857     disp($off);
 3858   %}
 3859 %}
 3860 
















 3861 // Indirect Narrow Oop Plus Offset Operand
 3862 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3863 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3864 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3865   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3866   constraint(ALLOC_IN_RC(ptr_reg));
 3867   match(AddP (DecodeN reg) off);
 3868 
 3869   op_cost(10);
 3870   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3871   interface(MEMORY_INTER) %{
 3872     base(0xc); // R12
 3873     index($reg);
 3874     scale(0x3);
 3875     disp($off);
 3876   %}
 3877 %}
 3878 
 3879 // Indirect Memory Operand
 3880 operand indirectNarrow(rRegN reg)
</pre>
<hr />
<pre>
 4183     equal(0x4, &quot;e&quot;);
 4184     not_equal(0x5, &quot;ne&quot;);
 4185     less(0x2, &quot;b&quot;);
 4186     greater_equal(0x3, &quot;nb&quot;);
 4187     less_equal(0x6, &quot;be&quot;);
 4188     greater(0x7, &quot;nbe&quot;);
 4189     overflow(0x0, &quot;o&quot;);
 4190     no_overflow(0x1, &quot;no&quot;);
 4191   %}
 4192 %}
 4193 
 4194 //----------OPERAND CLASSES----------------------------------------------------
 4195 // Operand Classes are groups of operands that are used as to simplify
 4196 // instruction definitions by not requiring the AD writer to specify separate
 4197 // instructions for every form of operand when the instruction accepts
 4198 // multiple operand types with the same basic encoding and format.  The classic
 4199 // case of this is memory operands.
 4200 
 4201 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4202                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
<span class="line-modified"> 4203                indCompressedOopOffset,</span>
 4204                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4205                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4206                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4207 
 4208 //----------PIPELINE-----------------------------------------------------------
 4209 // Rules which define the behavior of the target architectures pipeline.
 4210 pipeline %{
 4211 
 4212 //----------ATTRIBUTES---------------------------------------------------------
 4213 attributes %{
 4214   variable_size_instructions;        // Fixed size instructions
 4215   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4216   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4217   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4218   instruction_fetch_units = 1;       // of 16 bytes
 4219 
 4220   // List of nop instructions
 4221   nops( MachNop );
 4222 %}
 4223 
</pre>
<hr />
<pre>
 6667   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6668   ins_encode( );
 6669   ins_pipe(empty);
 6670 %}
 6671 
 6672 //----------Move Instructions--------------------------------------------------
 6673 
 6674 instruct castX2P(rRegP dst, rRegL src)
 6675 %{
 6676   match(Set dst (CastX2P src));
 6677 
 6678   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6679   ins_encode %{
 6680     if ($dst$$reg != $src$$reg) {
 6681       __ movptr($dst$$Register, $src$$Register);
 6682     }
 6683   %}
 6684   ins_pipe(ialu_reg_reg); // XXX
 6685 %}
 6686 













 6687 instruct castP2X(rRegL dst, rRegP src)
 6688 %{
 6689   match(Set dst (CastP2X src));
 6690 
 6691   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6692   ins_encode %{
 6693     if ($dst$$reg != $src$$reg) {
 6694       __ movptr($dst$$Register, $src$$Register);
 6695     }
 6696   %}
 6697   ins_pipe(ialu_reg_reg); // XXX
 6698 %}
 6699 



























 6700 // Convert oop into int for vectors alignment masking
 6701 instruct convP2I(rRegI dst, rRegP src)
 6702 %{
 6703   match(Set dst (ConvL2I (CastP2X src)));
 6704 
 6705   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6706   ins_encode %{
 6707     __ movl($dst$$Register, $src$$Register);
 6708   %}
 6709   ins_pipe(ialu_reg_reg); // XXX
 6710 %}
 6711 
 6712 // Convert compressed oop into int for vectors alignment masking
 6713 // in case of 32bit oops (heap &lt; 4Gb).
 6714 instruct convN2I(rRegI dst, rRegN src)
 6715 %{
 6716   predicate(CompressedOops::shift() == 0);
 6717   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6718 
 6719   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
</pre>
<hr />
<pre>
10893   ins_encode %{
10894     __ movdl($dst$$XMMRegister, $src$$Register);
10895   %}
10896   ins_pipe( pipe_slow );
10897 %}
10898 
10899 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10900   match(Set dst (MoveL2D src));
10901   effect(DEF dst, USE src);
10902   ins_cost(100);
10903   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10904   ins_encode %{
10905      __ movdq($dst$$XMMRegister, $src$$Register);
10906   %}
10907   ins_pipe( pipe_slow );
10908 %}
10909 
10910 
10911 // =======================================================================
10912 // fast clearing of an array
<span class="line-modified">10913 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,</span>
10914                   Universe dummy, rFlagsReg cr)
10915 %{
<span class="line-modified">10916   predicate(!((ClearArrayNode*)n)-&gt;is_large());</span>
<span class="line-modified">10917   match(Set dummy (ClearArray cnt base));</span>
<span class="line-modified">10918   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);</span>
10919 
10920   format %{ $$template
<span class="line-removed">10921     $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
10922     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10923     $$emit$$&quot;jg      LARGE\n\t&quot;
10924     $$emit$$&quot;dec     rcx\n\t&quot;
10925     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10926     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10927     $$emit$$&quot;dec     rcx\n\t&quot;
10928     $$emit$$&quot;jge     LOOP\n\t&quot;
10929     $$emit$$&quot;jmp     DONE\n\t&quot;
10930     $$emit$$&quot;# LARGE:\n\t&quot;
10931     if (UseFastStosb) {
10932        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10933        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10934     } else if (UseXMMForObjInit) {
<span class="line-modified">10935        $$emit$$&quot;mov     rdi,rax\n\t&quot;</span>
<span class="line-modified">10936        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;</span>

10937        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10938        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">10939        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
<span class="line-modified">10940        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;</span>
10941        $$emit$$&quot;add     0x40,rax\n\t&quot;
10942        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10943        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10944        $$emit$$&quot;jge     L_loop\n\t&quot;
10945        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10946        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">10947        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
10948        $$emit$$&quot;add     0x20,rax\n\t&quot;
10949        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
10950        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
10951        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10952        $$emit$$&quot;jle     L_end\n\t&quot;
10953        $$emit$$&quot;dec     rcx\n\t&quot;
10954        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
10955        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
10956        $$emit$$&quot;add     0x8,rax\n\t&quot;
10957        $$emit$$&quot;dec     rcx\n\t&quot;
10958        $$emit$$&quot;jge     L_sloop\n\t&quot;
10959        $$emit$$&quot;# L_end:\n\t&quot;
10960     } else {
10961        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
10962     }
10963     $$emit$$&quot;# DONE&quot;
10964   %}
10965   ins_encode %{
<span class="line-modified">10966     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,</span>
<span class="line-modified">10967                  $tmp$$XMMRegister, false);</span>
10968   %}
10969   ins_pipe(pipe_slow);
10970 %}
10971 
<span class="line-modified">10972 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,</span>
























































10973                         Universe dummy, rFlagsReg cr)
10974 %{
<span class="line-modified">10975   predicate(((ClearArrayNode*)n)-&gt;is_large());</span>
<span class="line-modified">10976   match(Set dummy (ClearArray cnt base));</span>
<span class="line-modified">10977   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);</span>
10978 
10979   format %{ $$template
10980     if (UseFastStosb) {
<span class="line-removed">10981        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
10982        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10983        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
10984     } else if (UseXMMForObjInit) {
<span class="line-modified">10985        $$emit$$&quot;mov     rdi,rax\t# ClearArray:\n\t&quot;</span>
<span class="line-modified">10986        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;</span>

10987        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10988        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">10989        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
<span class="line-modified">10990        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;</span>
10991        $$emit$$&quot;add     0x40,rax\n\t&quot;
10992        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10993        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10994        $$emit$$&quot;jge     L_loop\n\t&quot;
10995        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10996        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">10997        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
10998        $$emit$$&quot;add     0x20,rax\n\t&quot;
10999        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11000        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11001        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11002        $$emit$$&quot;jle     L_end\n\t&quot;
11003        $$emit$$&quot;dec     rcx\n\t&quot;
11004        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11005        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11006        $$emit$$&quot;add     0x8,rax\n\t&quot;
11007        $$emit$$&quot;dec     rcx\n\t&quot;
11008        $$emit$$&quot;jge     L_sloop\n\t&quot;
11009        $$emit$$&quot;# L_end:\n\t&quot;
11010     } else {
<span class="line-removed">11011        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
11012        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11013     }
11014   %}
11015   ins_encode %{
<span class="line-modified">11016     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,</span>
<span class="line-modified">11017                  $tmp$$XMMRegister, true);</span>














































11018   %}
11019   ins_pipe(pipe_slow);
11020 %}
11021 
11022 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11023                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11024 %{
11025   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11026   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11027   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11028 
11029   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11030   ins_encode %{
11031     __ string_compare($str1$$Register, $str2$$Register,
11032                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11033                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11034   %}
11035   ins_pipe( pipe_slow );
11036 %}
11037 
</pre>
<hr />
<pre>
11562 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11563 %{
11564   match(Set cr (CmpI (AndI src con) zero));
11565 
11566   format %{ &quot;testl   $src, $con&quot; %}
11567   opcode(0xF7, 0x00);
11568   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11569   ins_pipe(ialu_cr_reg_imm);
11570 %}
11571 
11572 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11573 %{
11574   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11575 
11576   format %{ &quot;testl   $src, $mem&quot; %}
11577   opcode(0x85);
11578   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11579   ins_pipe(ialu_cr_reg_mem);
11580 %}
11581 











11582 // Unsigned compare Instructions; really, same as signed except they
11583 // produce an rFlagsRegU instead of rFlagsReg.
11584 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11585 %{
11586   match(Set cr (CmpU op1 op2));
11587 
11588   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11589   opcode(0x3B); /* Opcode 3B /r */
11590   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11591   ins_pipe(ialu_cr_reg_reg);
11592 %}
11593 
11594 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11595 %{
11596   match(Set cr (CmpU op1 op2));
11597 
11598   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11599   opcode(0x81,0x07); /* Opcode 81 /7 */
11600   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11601   ins_pipe(ialu_cr_reg_imm);
</pre>
<hr />
<pre>
11874 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11875 %{
11876   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11877 
11878   format %{ &quot;testq   $src, $mem&quot; %}
11879   opcode(0x85);
11880   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11881   ins_pipe(ialu_cr_reg_mem);
11882 %}
11883 
11884 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
11885 %{
11886   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
11887 
11888   format %{ &quot;testq   $src, $mem&quot; %}
11889   opcode(0x85);
11890   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11891   ins_pipe(ialu_cr_reg_mem);
11892 %}
11893 











11894 // Manifest a CmpL result in an integer register.  Very painful.
11895 // This is the test to avoid.
11896 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11897 %{
11898   match(Set dst (CmpL3 src1 src2));
11899   effect(KILL flags);
11900 
11901   ins_cost(275); // XXX
11902   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
11903             &quot;movl    $dst, -1\n\t&quot;
11904             &quot;jl,s    done\n\t&quot;
11905             &quot;setne   $dst\n\t&quot;
11906             &quot;movzbl  $dst, $dst\n\t&quot;
11907     &quot;done:&quot; %}
11908   ins_encode(cmpl3_flag(src1, src2, dst));
11909   ins_pipe(pipe_slow);
11910 %}
11911 
11912 // Unsigned long compare Instructions; really, same as signed long except they
11913 // produce an rFlagsRegU instead of rFlagsReg.
</pre>
<hr />
<pre>
12541 
12542   ins_cost(300);
12543   format %{ &quot;call,runtime &quot; %}
12544   ins_encode(clear_avx, Java_To_Runtime(meth));
12545   ins_pipe(pipe_slow);
12546 %}
12547 
12548 // Call runtime without safepoint
12549 instruct CallLeafDirect(method meth)
12550 %{
12551   match(CallLeaf);
12552   effect(USE meth);
12553 
12554   ins_cost(300);
12555   format %{ &quot;call_leaf,runtime &quot; %}
12556   ins_encode(clear_avx, Java_To_Runtime(meth));
12557   ins_pipe(pipe_slow);
12558 %}
12559 
12560 // Call runtime without safepoint















12561 instruct CallLeafNoFPDirect(method meth)
12562 %{

12563   match(CallLeafNoFP);
12564   effect(USE meth);
12565 
12566   ins_cost(300);
12567   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12568   ins_encode(clear_avx, Java_To_Runtime(meth));
12569   ins_pipe(pipe_slow);
12570 %}
12571 
12572 // Return Instruction
12573 // Remove the return address &amp; jump to it.
12574 // Notice: We always emit a nop after a ret to make sure there is room
12575 // for safepoint patching
12576 instruct Ret()
12577 %{
12578   match(Return);
12579 
12580   format %{ &quot;ret&quot; %}
12581   opcode(0xC3);
12582   ins_encode(OpcP);
</pre>
</td>
<td>
<hr />
<pre>
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 



  870   if (C-&gt;clinit_barrier_on_entry()) {
  871     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  872     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  873 
  874     Label L_skip_barrier;
  875     Register klass = rscratch1;
  876 
  877     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  878     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  879 
  880     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  881 
  882     __ bind(L_skip_barrier);
  883   }
  884 
<span class="line-modified">  885   __ verified_entry(C);</span>
<span class="line-added">  886   __ bind(*_verified_entry);</span>
<span class="line-added">  887 </span>
<span class="line-added">  888   if (C-&gt;stub_function() == NULL) {</span>
<span class="line-added">  889     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="line-added">  890     bs-&gt;nmethod_entry_barrier(&amp;_masm);</span>
<span class="line-added">  891   }</span>
  892 
  893   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  894 
  895   if (C-&gt;has_mach_constant_base_node()) {
  896     // NOTE: We set the table base offset here because users might be
  897     // emitted before MachConstantBaseNode.
  898     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  899     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  900   }
  901 }
  902 






  903 int MachPrologNode::reloc() const
  904 {
  905   return 0; // a large enough number
  906 }
  907 
  908 //=============================================================================
  909 #ifndef PRODUCT
  910 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  911 {
  912   Compile* C = ra_-&gt;C;
  913   if (generate_vzeroupper(C)) {
  914     st-&gt;print(&quot;vzeroupper&quot;);
  915     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  916   }
  917 
  918   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  919   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  920   // Remove word for return adr already pushed
  921   // and RBP
  922   framesize -= 2*wordSize;
</pre>
<hr />
<pre>
  930   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  931     st-&gt;print(&quot;\t&quot;);
  932     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  933                  &quot;testl   rax, [rscratch1]\t&quot;
  934                  &quot;# Safepoint: poll for GC&quot;);
  935   }
  936 }
  937 #endif
  938 
  939 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  940 {
  941   Compile* C = ra_-&gt;C;
  942   MacroAssembler _masm(&amp;cbuf);
  943 
  944   if (generate_vzeroupper(C)) {
  945     // Clear upper bits of YMM registers when current compiled code uses
  946     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  947     __ vzeroupper();
  948   }
  949 
<span class="line-modified">  950   // Subtract two words to account for return address and rbp</span>
<span class="line-modified">  951   int initial_framesize = C-&gt;output()-&gt;frame_size_in_bytes() - 2*wordSize;</span>
<span class="line-modified">  952   __ remove_frame(initial_framesize, C-&gt;needs_stack_repair(), C-&gt;output()-&gt;sp_inc_offset());</span>




















  953 
  954   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  955     __ reserved_stack_check();
  956   }
  957 
  958   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  959     MacroAssembler _masm(&amp;cbuf);
  960     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  961     __ relocate(relocInfo::poll_return_type);
  962     __ testl(rax, Address(rscratch1, 0));
  963   }
  964 }
  965 






  966 int MachEpilogNode::reloc() const
  967 {
  968   return 2; // a large enough number
  969 }
  970 
  971 const Pipeline* MachEpilogNode::pipeline() const
  972 {
  973   return MachNode::pipeline_class();
  974 }
  975 
  976 //=============================================================================
  977 
  978 enum RC {
  979   rc_bad,
  980   rc_int,
  981   rc_float,
  982   rc_stack
  983 };
  984 
  985 static enum RC rc_class(OptoReg::Name reg)
</pre>
<hr />
<pre>
 1481     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1482     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1483     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1484     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1485     emit_d32(cbuf, offset);
 1486   } else {
 1487     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1488     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1489     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1490     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1491     emit_d8(cbuf, offset);
 1492   }
 1493 }
 1494 
 1495 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1496 {
 1497   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1498   return (offset &lt; 0x80) ? 5 : 8; // REX
 1499 }
 1500 
<span class="line-added"> 1501 //=============================================================================</span>
<span class="line-added"> 1502 #ifndef PRODUCT</span>
<span class="line-added"> 1503 void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const</span>
<span class="line-added"> 1504 {</span>
<span class="line-added"> 1505   st-&gt;print_cr(&quot;MachVEPNode&quot;);</span>
<span class="line-added"> 1506 }</span>
<span class="line-added"> 1507 #endif</span>
<span class="line-added"> 1508 </span>
<span class="line-added"> 1509 void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const</span>
<span class="line-added"> 1510 {</span>
<span class="line-added"> 1511   MacroAssembler masm(&amp;cbuf);</span>
<span class="line-added"> 1512   if (!_verified) {  </span>
<span class="line-added"> 1513     uint insts_size = cbuf.insts_size();</span>
<span class="line-added"> 1514     if (UseCompressedClassPointers) {</span>
<span class="line-added"> 1515       masm.load_klass(rscratch1, j_rarg0, rscratch2);</span>
<span class="line-added"> 1516       masm.cmpptr(rax, rscratch1);</span>
<span class="line-added"> 1517     } else {</span>
<span class="line-added"> 1518       masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));</span>
<span class="line-added"> 1519     }</span>
<span class="line-added"> 1520     masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));</span>
<span class="line-added"> 1521   } else {</span>
<span class="line-added"> 1522     // Unpack inline type args passed as oop and then jump to</span>
<span class="line-added"> 1523     // the verified entry point (skipping the unverified entry).</span>
<span class="line-added"> 1524     masm.unpack_inline_args(ra_-&gt;C, _receiver_only);</span>
<span class="line-added"> 1525     masm.jmp(*_verified_entry);</span>
<span class="line-added"> 1526   }</span>
<span class="line-added"> 1527 }</span>
<span class="line-added"> 1528 </span>
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1532 {
 1533   if (UseCompressedClassPointers) {
 1534     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1535     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1536     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1537   } else {
 1538     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1539                  &quot;# Inline cache check&quot;);
 1540   }
 1541   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1542   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1543 }
 1544 #endif
 1545 
 1546 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1547 {
 1548   MacroAssembler masm(&amp;cbuf);
</pre>
<hr />
<pre>
 1551     masm.load_klass(rscratch1, j_rarg0, rscratch2);
 1552     masm.cmpptr(rax, rscratch1);
 1553   } else {
 1554     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1555   }
 1556 
 1557   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1558 
 1559   /* WARNING these NOPs are critical so that verified entry point is properly
 1560      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1561   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1562   if (OptoBreakpoint) {
 1563     // Leave space for int3
 1564     nops_cnt -= 1;
 1565   }
 1566   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1567   if (nops_cnt &gt; 0)
 1568     masm.nop(nops_cnt);
 1569 }
 1570 







 1571 //=============================================================================
 1572 
 1573 int Matcher::regnum_to_fpu_offset(int regnum)
 1574 {
 1575   return regnum - 32; // The FP registers are in the second chunk
 1576 }
 1577 
 1578 // This is UltraSparc specific, true just means we have fast l2f conversion
 1579 const bool Matcher::convL2FSupported(void) {
 1580   return true;
 1581 }
 1582 
 1583 // Is this branch offset short enough that a short branch can be used?
 1584 //
 1585 // NOTE: If the platform does not provide any short branch variants, then
 1586 //       this method should return false for offset 0.
 1587 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1588   // The passed offset is relative to address of the branch.
 1589   // On 86 a branch displacement is calculated relative to address
 1590   // of a next instruction.
</pre>
<hr />
<pre>
 3833   %}
 3834 %}
 3835 
 3836 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3837 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3838 %{
 3839   constraint(ALLOC_IN_RC(ptr_reg));
 3840   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3841   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3842 
 3843   op_cost(10);
 3844   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3845   interface(MEMORY_INTER) %{
 3846     base($reg);
 3847     index($idx);
 3848     scale($scale);
 3849     disp($off);
 3850   %}
 3851 %}
 3852 
<span class="line-added"> 3853 // Indirect Narrow Oop Operand</span>
<span class="line-added"> 3854 operand indCompressedOop(rRegN reg) %{</span>
<span class="line-added"> 3855   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));</span>
<span class="line-added"> 3856   constraint(ALLOC_IN_RC(ptr_reg));</span>
<span class="line-added"> 3857   match(DecodeN reg);</span>
<span class="line-added"> 3858 </span>
<span class="line-added"> 3859   op_cost(10);</span>
<span class="line-added"> 3860   format %{&quot;[R12 + $reg &lt;&lt; 3] (compressed oop addressing)&quot; %}</span>
<span class="line-added"> 3861   interface(MEMORY_INTER) %{</span>
<span class="line-added"> 3862     base(0xc); // R12</span>
<span class="line-added"> 3863     index($reg);</span>
<span class="line-added"> 3864     scale(0x3);</span>
<span class="line-added"> 3865     disp(0x0);</span>
<span class="line-added"> 3866   %}</span>
<span class="line-added"> 3867 %}</span>
<span class="line-added"> 3868 </span>
 3869 // Indirect Narrow Oop Plus Offset Operand
 3870 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3871 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3872 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3873   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3874   constraint(ALLOC_IN_RC(ptr_reg));
 3875   match(AddP (DecodeN reg) off);
 3876 
 3877   op_cost(10);
 3878   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3879   interface(MEMORY_INTER) %{
 3880     base(0xc); // R12
 3881     index($reg);
 3882     scale(0x3);
 3883     disp($off);
 3884   %}
 3885 %}
 3886 
 3887 // Indirect Memory Operand
 3888 operand indirectNarrow(rRegN reg)
</pre>
<hr />
<pre>
 4191     equal(0x4, &quot;e&quot;);
 4192     not_equal(0x5, &quot;ne&quot;);
 4193     less(0x2, &quot;b&quot;);
 4194     greater_equal(0x3, &quot;nb&quot;);
 4195     less_equal(0x6, &quot;be&quot;);
 4196     greater(0x7, &quot;nbe&quot;);
 4197     overflow(0x0, &quot;o&quot;);
 4198     no_overflow(0x1, &quot;no&quot;);
 4199   %}
 4200 %}
 4201 
 4202 //----------OPERAND CLASSES----------------------------------------------------
 4203 // Operand Classes are groups of operands that are used as to simplify
 4204 // instruction definitions by not requiring the AD writer to specify separate
 4205 // instructions for every form of operand when the instruction accepts
 4206 // multiple operand types with the same basic encoding and format.  The classic
 4207 // case of this is memory operands.
 4208 
 4209 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4210                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
<span class="line-modified"> 4211                indCompressedOop, indCompressedOopOffset,</span>
 4212                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4213                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4214                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4215 
 4216 //----------PIPELINE-----------------------------------------------------------
 4217 // Rules which define the behavior of the target architectures pipeline.
 4218 pipeline %{
 4219 
 4220 //----------ATTRIBUTES---------------------------------------------------------
 4221 attributes %{
 4222   variable_size_instructions;        // Fixed size instructions
 4223   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4224   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4225   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4226   instruction_fetch_units = 1;       // of 16 bytes
 4227 
 4228   // List of nop instructions
 4229   nops( MachNop );
 4230 %}
 4231 
</pre>
<hr />
<pre>
 6675   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6676   ins_encode( );
 6677   ins_pipe(empty);
 6678 %}
 6679 
 6680 //----------Move Instructions--------------------------------------------------
 6681 
 6682 instruct castX2P(rRegP dst, rRegL src)
 6683 %{
 6684   match(Set dst (CastX2P src));
 6685 
 6686   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6687   ins_encode %{
 6688     if ($dst$$reg != $src$$reg) {
 6689       __ movptr($dst$$Register, $src$$Register);
 6690     }
 6691   %}
 6692   ins_pipe(ialu_reg_reg); // XXX
 6693 %}
 6694 
<span class="line-added"> 6695 instruct castN2X(rRegL dst, rRegN src)</span>
<span class="line-added"> 6696 %{</span>
<span class="line-added"> 6697   match(Set dst (CastP2X src));</span>
<span class="line-added"> 6698 </span>
<span class="line-added"> 6699   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}</span>
<span class="line-added"> 6700   ins_encode %{</span>
<span class="line-added"> 6701     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 6702       __ movptr($dst$$Register, $src$$Register);</span>
<span class="line-added"> 6703     }</span>
<span class="line-added"> 6704   %}</span>
<span class="line-added"> 6705   ins_pipe(ialu_reg_reg); // XXX</span>
<span class="line-added"> 6706 %}</span>
<span class="line-added"> 6707 </span>
 6708 instruct castP2X(rRegL dst, rRegP src)
 6709 %{
 6710   match(Set dst (CastP2X src));
 6711 
 6712   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6713   ins_encode %{
 6714     if ($dst$$reg != $src$$reg) {
 6715       __ movptr($dst$$Register, $src$$Register);
 6716     }
 6717   %}
 6718   ins_pipe(ialu_reg_reg); // XXX
 6719 %}
 6720 
<span class="line-added"> 6721 instruct castN2I(rRegI dst, rRegN src)</span>
<span class="line-added"> 6722 %{</span>
<span class="line-added"> 6723   match(Set dst (CastN2I src));</span>
<span class="line-added"> 6724 </span>
<span class="line-added"> 6725   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}</span>
<span class="line-added"> 6726   ins_encode %{</span>
<span class="line-added"> 6727     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 6728       __ movl($dst$$Register, $src$$Register);</span>
<span class="line-added"> 6729     }</span>
<span class="line-added"> 6730   %}</span>
<span class="line-added"> 6731   ins_pipe(ialu_reg_reg); // XXX</span>
<span class="line-added"> 6732 %}</span>
<span class="line-added"> 6733 </span>
<span class="line-added"> 6734 instruct castI2N(rRegN dst, rRegI src)</span>
<span class="line-added"> 6735 %{</span>
<span class="line-added"> 6736   match(Set dst (CastI2N src));</span>
<span class="line-added"> 6737 </span>
<span class="line-added"> 6738   format %{ &quot;movl    $dst, $src\t# int -&gt; compressed ptr&quot; %}</span>
<span class="line-added"> 6739   ins_encode %{</span>
<span class="line-added"> 6740     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 6741       __ movl($dst$$Register, $src$$Register);</span>
<span class="line-added"> 6742     }</span>
<span class="line-added"> 6743   %}</span>
<span class="line-added"> 6744   ins_pipe(ialu_reg_reg); // XXX</span>
<span class="line-added"> 6745 %}</span>
<span class="line-added"> 6746 </span>
<span class="line-added"> 6747 </span>
 6748 // Convert oop into int for vectors alignment masking
 6749 instruct convP2I(rRegI dst, rRegP src)
 6750 %{
 6751   match(Set dst (ConvL2I (CastP2X src)));
 6752 
 6753   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6754   ins_encode %{
 6755     __ movl($dst$$Register, $src$$Register);
 6756   %}
 6757   ins_pipe(ialu_reg_reg); // XXX
 6758 %}
 6759 
 6760 // Convert compressed oop into int for vectors alignment masking
 6761 // in case of 32bit oops (heap &lt; 4Gb).
 6762 instruct convN2I(rRegI dst, rRegN src)
 6763 %{
 6764   predicate(CompressedOops::shift() == 0);
 6765   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6766 
 6767   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
</pre>
<hr />
<pre>
10941   ins_encode %{
10942     __ movdl($dst$$XMMRegister, $src$$Register);
10943   %}
10944   ins_pipe( pipe_slow );
10945 %}
10946 
10947 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10948   match(Set dst (MoveL2D src));
10949   effect(DEF dst, USE src);
10950   ins_cost(100);
10951   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10952   ins_encode %{
10953      __ movdq($dst$$XMMRegister, $src$$Register);
10954   %}
10955   ins_pipe( pipe_slow );
10956 %}
10957 
10958 
10959 // =======================================================================
10960 // fast clearing of an array
<span class="line-modified">10961 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,</span>
10962                   Universe dummy, rFlagsReg cr)
10963 %{
<span class="line-modified">10964   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-modified">10965   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-modified">10966   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
10967 
10968   format %{ $$template

10969     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10970     $$emit$$&quot;jg      LARGE\n\t&quot;
10971     $$emit$$&quot;dec     rcx\n\t&quot;
10972     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10973     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10974     $$emit$$&quot;dec     rcx\n\t&quot;
10975     $$emit$$&quot;jge     LOOP\n\t&quot;
10976     $$emit$$&quot;jmp     DONE\n\t&quot;
10977     $$emit$$&quot;# LARGE:\n\t&quot;
10978     if (UseFastStosb) {
10979        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10980        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10981     } else if (UseXMMForObjInit) {
<span class="line-modified">10982        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-modified">10983        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">10984        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
10985        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10986        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">10987        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-modified">10988        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
10989        $$emit$$&quot;add     0x40,rax\n\t&quot;
10990        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10991        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10992        $$emit$$&quot;jge     L_loop\n\t&quot;
10993        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10994        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">10995        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
10996        $$emit$$&quot;add     0x20,rax\n\t&quot;
10997        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
10998        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
10999        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11000        $$emit$$&quot;jle     L_end\n\t&quot;
11001        $$emit$$&quot;dec     rcx\n\t&quot;
11002        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11003        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11004        $$emit$$&quot;add     0x8,rax\n\t&quot;
11005        $$emit$$&quot;dec     rcx\n\t&quot;
11006        $$emit$$&quot;jge     L_sloop\n\t&quot;
11007        $$emit$$&quot;# L_end:\n\t&quot;
11008     } else {
11009        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11010     }
11011     $$emit$$&quot;# DONE&quot;
11012   %}
11013   ins_encode %{
<span class="line-modified">11014     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,</span>
<span class="line-modified">11015                  $tmp$$XMMRegister, false, false);</span>
11016   %}
11017   ins_pipe(pipe_slow);
11018 %}
11019 
<span class="line-modified">11020 instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,</span>
<span class="line-added">11021                   Universe dummy, rFlagsReg cr)</span>
<span class="line-added">11022 %{</span>
<span class="line-added">11023   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-added">11024   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-added">11025   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
<span class="line-added">11026 </span>
<span class="line-added">11027   format %{ $$template</span>
<span class="line-added">11028     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;</span>
<span class="line-added">11029     $$emit$$&quot;jg      LARGE\n\t&quot;</span>
<span class="line-added">11030     $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11031     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;</span>
<span class="line-added">11032     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;</span>
<span class="line-added">11033     $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11034     $$emit$$&quot;jge     LOOP\n\t&quot;</span>
<span class="line-added">11035     $$emit$$&quot;jmp     DONE\n\t&quot;</span>
<span class="line-added">11036     $$emit$$&quot;# LARGE:\n\t&quot;</span>
<span class="line-added">11037     if (UseXMMForObjInit) {</span>
<span class="line-added">11038        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-added">11039        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11040        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11041        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;</span>
<span class="line-added">11042        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;</span>
<span class="line-added">11043        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11044        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
<span class="line-added">11045        $$emit$$&quot;add     0x40,rax\n\t&quot;</span>
<span class="line-added">11046        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;</span>
<span class="line-added">11047        $$emit$$&quot;sub     0x8,rcx\n\t&quot;</span>
<span class="line-added">11048        $$emit$$&quot;jge     L_loop\n\t&quot;</span>
<span class="line-added">11049        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11050        $$emit$$&quot;jl      L_tail\n\t&quot;</span>
<span class="line-added">11051        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11052        $$emit$$&quot;add     0x20,rax\n\t&quot;</span>
<span class="line-added">11053        $$emit$$&quot;sub     0x4,rcx\n\t&quot;</span>
<span class="line-added">11054        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;</span>
<span class="line-added">11055        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11056        $$emit$$&quot;jle     L_end\n\t&quot;</span>
<span class="line-added">11057        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11058        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;</span>
<span class="line-added">11059        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;</span>
<span class="line-added">11060        $$emit$$&quot;add     0x8,rax\n\t&quot;</span>
<span class="line-added">11061        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11062        $$emit$$&quot;jge     L_sloop\n\t&quot;</span>
<span class="line-added">11063        $$emit$$&quot;# L_end:\n\t&quot;</span>
<span class="line-added">11064     } else {</span>
<span class="line-added">11065        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;</span>
<span class="line-added">11066     }</span>
<span class="line-added">11067     $$emit$$&quot;# DONE&quot;</span>
<span class="line-added">11068   %}</span>
<span class="line-added">11069   ins_encode %{</span>
<span class="line-added">11070     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,</span>
<span class="line-added">11071                  $tmp$$XMMRegister, false, true);</span>
<span class="line-added">11072   %}</span>
<span class="line-added">11073   ins_pipe(pipe_slow);</span>
<span class="line-added">11074 %}</span>
<span class="line-added">11075 </span>
<span class="line-added">11076 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,</span>
11077                         Universe dummy, rFlagsReg cr)
11078 %{
<span class="line-modified">11079   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-modified">11080   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-modified">11081   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
11082 
11083   format %{ $$template
11084     if (UseFastStosb) {

11085        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11086        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
11087     } else if (UseXMMForObjInit) {
<span class="line-modified">11088        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-modified">11089        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11090        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
11091        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11092        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">11093        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-modified">11094        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
11095        $$emit$$&quot;add     0x40,rax\n\t&quot;
11096        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11097        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11098        $$emit$$&quot;jge     L_loop\n\t&quot;
11099        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11100        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">11101        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
11102        $$emit$$&quot;add     0x20,rax\n\t&quot;
11103        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11104        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11105        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11106        $$emit$$&quot;jle     L_end\n\t&quot;
11107        $$emit$$&quot;dec     rcx\n\t&quot;
11108        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11109        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11110        $$emit$$&quot;add     0x8,rax\n\t&quot;
11111        $$emit$$&quot;dec     rcx\n\t&quot;
11112        $$emit$$&quot;jge     L_sloop\n\t&quot;
11113        $$emit$$&quot;# L_end:\n\t&quot;
11114     } else {

11115        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11116     }
11117   %}
11118   ins_encode %{
<span class="line-modified">11119     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,</span>
<span class="line-modified">11120                  $tmp$$XMMRegister, true, false);</span>
<span class="line-added">11121   %}</span>
<span class="line-added">11122   ins_pipe(pipe_slow);</span>
<span class="line-added">11123 %}</span>
<span class="line-added">11124 </span>
<span class="line-added">11125 instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val, </span>
<span class="line-added">11126                         Universe dummy, rFlagsReg cr)</span>
<span class="line-added">11127 %{</span>
<span class="line-added">11128   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-added">11129   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-added">11130   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
<span class="line-added">11131 </span>
<span class="line-added">11132   format %{ $$template</span>
<span class="line-added">11133     if (UseXMMForObjInit) {</span>
<span class="line-added">11134        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-added">11135        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11136        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11137        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;</span>
<span class="line-added">11138        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;</span>
<span class="line-added">11139        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11140        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
<span class="line-added">11141        $$emit$$&quot;add     0x40,rax\n\t&quot;</span>
<span class="line-added">11142        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;</span>
<span class="line-added">11143        $$emit$$&quot;sub     0x8,rcx\n\t&quot;</span>
<span class="line-added">11144        $$emit$$&quot;jge     L_loop\n\t&quot;</span>
<span class="line-added">11145        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11146        $$emit$$&quot;jl      L_tail\n\t&quot;</span>
<span class="line-added">11147        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11148        $$emit$$&quot;add     0x20,rax\n\t&quot;</span>
<span class="line-added">11149        $$emit$$&quot;sub     0x4,rcx\n\t&quot;</span>
<span class="line-added">11150        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;</span>
<span class="line-added">11151        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11152        $$emit$$&quot;jle     L_end\n\t&quot;</span>
<span class="line-added">11153        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11154        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;</span>
<span class="line-added">11155        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;</span>
<span class="line-added">11156        $$emit$$&quot;add     0x8,rax\n\t&quot;</span>
<span class="line-added">11157        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11158        $$emit$$&quot;jge     L_sloop\n\t&quot;</span>
<span class="line-added">11159        $$emit$$&quot;# L_end:\n\t&quot;</span>
<span class="line-added">11160     } else {</span>
<span class="line-added">11161        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;</span>
<span class="line-added">11162     }</span>
<span class="line-added">11163   %}</span>
<span class="line-added">11164   ins_encode %{</span>
<span class="line-added">11165     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register, </span>
<span class="line-added">11166                  $tmp$$XMMRegister, true, true);</span>
11167   %}
11168   ins_pipe(pipe_slow);
11169 %}
11170 
11171 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11172                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11173 %{
11174   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11175   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11176   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11177 
11178   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11179   ins_encode %{
11180     __ string_compare($str1$$Register, $str2$$Register,
11181                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11182                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11183   %}
11184   ins_pipe( pipe_slow );
11185 %}
11186 
</pre>
<hr />
<pre>
11711 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11712 %{
11713   match(Set cr (CmpI (AndI src con) zero));
11714 
11715   format %{ &quot;testl   $src, $con&quot; %}
11716   opcode(0xF7, 0x00);
11717   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11718   ins_pipe(ialu_cr_reg_imm);
11719 %}
11720 
11721 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11722 %{
11723   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11724 
11725   format %{ &quot;testl   $src, $mem&quot; %}
11726   opcode(0x85);
11727   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11728   ins_pipe(ialu_cr_reg_mem);
11729 %}
11730 
<span class="line-added">11731 // Fold array properties check</span>
<span class="line-added">11732 instruct testI_mem_imm(rFlagsReg cr, memory mem, immI con, immI0 zero)</span>
<span class="line-added">11733 %{</span>
<span class="line-added">11734   match(Set cr (CmpI (AndI (CastN2I (LoadNKlass mem)) con) zero));</span>
<span class="line-added">11735 </span>
<span class="line-added">11736   format %{ &quot;testl   $mem, $con&quot; %}</span>
<span class="line-added">11737   opcode(0xF7, 0x00);</span>
<span class="line-added">11738   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(con));</span>
<span class="line-added">11739   ins_pipe(ialu_mem_imm);</span>
<span class="line-added">11740 %}</span>
<span class="line-added">11741 </span>
11742 // Unsigned compare Instructions; really, same as signed except they
11743 // produce an rFlagsRegU instead of rFlagsReg.
11744 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11745 %{
11746   match(Set cr (CmpU op1 op2));
11747 
11748   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11749   opcode(0x3B); /* Opcode 3B /r */
11750   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11751   ins_pipe(ialu_cr_reg_reg);
11752 %}
11753 
11754 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11755 %{
11756   match(Set cr (CmpU op1 op2));
11757 
11758   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11759   opcode(0x81,0x07); /* Opcode 81 /7 */
11760   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11761   ins_pipe(ialu_cr_reg_imm);
</pre>
<hr />
<pre>
12034 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
12035 %{
12036   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
12037 
12038   format %{ &quot;testq   $src, $mem&quot; %}
12039   opcode(0x85);
12040   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12041   ins_pipe(ialu_cr_reg_mem);
12042 %}
12043 
12044 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
12045 %{
12046   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
12047 
12048   format %{ &quot;testq   $src, $mem&quot; %}
12049   opcode(0x85);
12050   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12051   ins_pipe(ialu_cr_reg_mem);
12052 %}
12053 
<span class="line-added">12054 // Fold array properties check</span>
<span class="line-added">12055 instruct testL_reg_mem3(rFlagsReg cr, memory mem, rRegL src, immL0 zero)</span>
<span class="line-added">12056 %{</span>
<span class="line-added">12057   match(Set cr (CmpL (AndL (CastP2X (LoadKlass mem)) src) zero));</span>
<span class="line-added">12058 </span>
<span class="line-added">12059   format %{ &quot;testq   $src, $mem\t# test array properties&quot; %}</span>
<span class="line-added">12060   opcode(0x85);</span>
<span class="line-added">12061   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));</span>
<span class="line-added">12062   ins_pipe(ialu_cr_reg_mem);</span>
<span class="line-added">12063 %}</span>
<span class="line-added">12064 </span>
12065 // Manifest a CmpL result in an integer register.  Very painful.
12066 // This is the test to avoid.
12067 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
12068 %{
12069   match(Set dst (CmpL3 src1 src2));
12070   effect(KILL flags);
12071 
12072   ins_cost(275); // XXX
12073   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
12074             &quot;movl    $dst, -1\n\t&quot;
12075             &quot;jl,s    done\n\t&quot;
12076             &quot;setne   $dst\n\t&quot;
12077             &quot;movzbl  $dst, $dst\n\t&quot;
12078     &quot;done:&quot; %}
12079   ins_encode(cmpl3_flag(src1, src2, dst));
12080   ins_pipe(pipe_slow);
12081 %}
12082 
12083 // Unsigned long compare Instructions; really, same as signed long except they
12084 // produce an rFlagsRegU instead of rFlagsReg.
</pre>
<hr />
<pre>
12712 
12713   ins_cost(300);
12714   format %{ &quot;call,runtime &quot; %}
12715   ins_encode(clear_avx, Java_To_Runtime(meth));
12716   ins_pipe(pipe_slow);
12717 %}
12718 
12719 // Call runtime without safepoint
12720 instruct CallLeafDirect(method meth)
12721 %{
12722   match(CallLeaf);
12723   effect(USE meth);
12724 
12725   ins_cost(300);
12726   format %{ &quot;call_leaf,runtime &quot; %}
12727   ins_encode(clear_avx, Java_To_Runtime(meth));
12728   ins_pipe(pipe_slow);
12729 %}
12730 
12731 // Call runtime without safepoint
<span class="line-added">12732 // entry point is null, target holds the address to call</span>
<span class="line-added">12733 instruct CallLeafNoFPInDirect(rRegP target)</span>
<span class="line-added">12734 %{</span>
<span class="line-added">12735   predicate(n-&gt;as_Call()-&gt;entry_point() == NULL);</span>
<span class="line-added">12736   match(CallLeafNoFP target);</span>
<span class="line-added">12737 </span>
<span class="line-added">12738   ins_cost(300);</span>
<span class="line-added">12739   format %{ &quot;call_leaf_nofp,runtime indirect &quot; %}</span>
<span class="line-added">12740   ins_encode %{</span>
<span class="line-added">12741      __ call($target$$Register);</span>
<span class="line-added">12742   %}</span>
<span class="line-added">12743 </span>
<span class="line-added">12744   ins_pipe(pipe_slow);</span>
<span class="line-added">12745 %}</span>
<span class="line-added">12746 </span>
12747 instruct CallLeafNoFPDirect(method meth)
12748 %{
<span class="line-added">12749   predicate(n-&gt;as_Call()-&gt;entry_point() != NULL);</span>
12750   match(CallLeafNoFP);
12751   effect(USE meth);
12752 
12753   ins_cost(300);
12754   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12755   ins_encode(clear_avx, Java_To_Runtime(meth));
12756   ins_pipe(pipe_slow);
12757 %}
12758 
12759 // Return Instruction
12760 // Remove the return address &amp; jump to it.
12761 // Notice: We always emit a nop after a ret to make sure there is room
12762 // for safepoint patching
12763 instruct Ret()
12764 %{
12765   match(Return);
12766 
12767   format %{ &quot;ret&quot; %}
12768   opcode(0xC3);
12769   ins_encode(OpcP);
</pre>
</td>
</tr>
</table>
<center><a href="c1_CodeStubs_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/adlc/main.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>