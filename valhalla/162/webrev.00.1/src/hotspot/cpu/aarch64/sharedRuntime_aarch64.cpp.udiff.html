<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_CodeStubs_aarch64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_aarch64.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -24,10 +24,11 @@</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;asm/macroAssembler.hpp&quot;
  #include &quot;asm/macroAssembler.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/debugInfoRec.hpp&quot;
  #include &quot;code/icBuffer.hpp&quot;
  #include &quot;code/vtableStubs.hpp&quot;
  #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -289,10 +290,11 @@</span>
        assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
        // fall through
      case T_OBJECT:
      case T_ARRAY:
      case T_ADDRESS:
<span class="udiff-line-added">+     case T_INLINE_TYPE:</span>
        if (int_args &lt; Argument::n_int_register_parameters_j) {
          regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
        } else {
          regs[i].set2(VMRegImpl::stack2reg(stk_args));
          stk_args += 2;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -322,10 +324,94 @@</span>
    }
  
    return align_up(stk_args, 2);
  }
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // const uint SharedRuntime::java_return_convention_max_int = Argument::n_int_register_parameters_j+1;</span>
<span class="udiff-line-added">+ const uint SharedRuntime::java_return_convention_max_int = 6;</span>
<span class="udiff-line-added">+ const uint SharedRuntime::java_return_convention_max_float = Argument::n_float_register_parameters_j;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int SharedRuntime::java_return_convention(const BasicType *sig_bt, VMRegPair *regs, int total_args_passed) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Create the mapping between argument positions and</span>
<span class="udiff-line-added">+   // registers.</span>
<span class="udiff-line-added">+   // r1, r2 used to address klasses and states, exclude it from return convention to avoid colision</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static const Register INT_ArgReg[java_return_convention_max_int] = {</span>
<span class="udiff-line-added">+      r0 /* j_rarg7 */, j_rarg6, j_rarg5, j_rarg4, j_rarg3, j_rarg2</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static const FloatRegister FP_ArgReg[java_return_convention_max_float] = {</span>
<span class="udiff-line-added">+     j_farg0, j_farg1, j_farg2, j_farg3, j_farg4, j_farg5, j_farg6, j_farg7</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uint int_args = 0;</span>
<span class="udiff-line-added">+   uint fp_args = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; total_args_passed; i++) {</span>
<span class="udiff-line-added">+     switch (sig_bt[i]) {</span>
<span class="udiff-line-added">+     case T_BOOLEAN:</span>
<span class="udiff-line-added">+     case T_CHAR:</span>
<span class="udiff-line-added">+     case T_BYTE:</span>
<span class="udiff-line-added">+     case T_SHORT:</span>
<span class="udiff-line-added">+     case T_INT:</span>
<span class="udiff-line-added">+       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {</span>
<span class="udiff-line-added">+         regs[i].set1(INT_ArgReg[int_args]-&gt;as_VMReg());</span>
<span class="udiff-line-added">+         int_args ++;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         // Should we have gurantee here?</span>
<span class="udiff-line-added">+         return -1;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case T_VOID:</span>
<span class="udiff-line-added">+       // halves of T_LONG or T_DOUBLE</span>
<span class="udiff-line-added">+       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);</span>
<span class="udiff-line-added">+       regs[i].set_bad();</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case T_LONG:</span>
<span class="udiff-line-added">+       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);</span>
<span class="udiff-line-added">+       // fall through</span>
<span class="udiff-line-added">+     case T_OBJECT:</span>
<span class="udiff-line-added">+     case T_ARRAY:</span>
<span class="udiff-line-added">+     case T_ADDRESS:</span>
<span class="udiff-line-added">+       // Should T_METADATA be added to java_calling_convention as well ?</span>
<span class="udiff-line-added">+     case T_METADATA:</span>
<span class="udiff-line-added">+     case T_INLINE_TYPE:</span>
<span class="udiff-line-added">+       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {</span>
<span class="udiff-line-added">+         regs[i].set2(INT_ArgReg[int_args]-&gt;as_VMReg());</span>
<span class="udiff-line-added">+         int_args ++;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         return -1;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case T_FLOAT:</span>
<span class="udiff-line-added">+       if (fp_args &lt; SharedRuntime::java_return_convention_max_float) {</span>
<span class="udiff-line-added">+         regs[i].set1(FP_ArgReg[fp_args]-&gt;as_VMReg());</span>
<span class="udiff-line-added">+         fp_args ++;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         return -1;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case T_DOUBLE:</span>
<span class="udiff-line-added">+       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);</span>
<span class="udiff-line-added">+       if (fp_args &lt; Argument::n_float_register_parameters_j) {</span>
<span class="udiff-line-added">+         regs[i].set2(FP_ArgReg[fp_args]-&gt;as_VMReg());</span>
<span class="udiff-line-added">+         fp_args ++;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         return -1;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       ShouldNotReachHere();</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return int_args + fp_args;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Patch the callers callsite with entry to compiled code if it exists.
  static void patch_callers_callsite(MacroAssembler *masm) {
    Label L;
    __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
    __ cbz(rscratch1, L);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -352,50 +438,60 @@</span>
    // restore sp
    __ leave();
    __ bind(L);
  }
  
<span class="udiff-line-modified-removed">- static void gen_c2i_adapter(MacroAssembler *masm,</span>
<span class="udiff-line-modified-removed">-                             int total_args_passed,</span>
<span class="udiff-line-modified-removed">-                             int comp_args_on_stack,</span>
<span class="udiff-line-modified-removed">-                             const BasicType *sig_bt,</span>
<span class="udiff-line-modified-removed">-                             const VMRegPair *regs,</span>
<span class="udiff-line-modified-removed">-                             Label&amp; skip_fixup) {</span>
<span class="udiff-line-modified-removed">-   // Before we get into the guts of the C2I adapter, see if we should be here</span>
<span class="udiff-line-modified-removed">-   // at all.  We&#39;ve come from compiled code and are attempting to jump to the</span>
<span class="udiff-line-modified-removed">-   // interpreter, which means the caller made a static call to get here</span>
<span class="udiff-line-modified-removed">-   // (vcalls always get a compiled target if there is one).  Check for a</span>
<span class="udiff-line-modified-removed">-   // compiled target.  If there is one, we need to patch the caller&#39;s call.</span>
<span class="udiff-line-modified-removed">-   patch_callers_callsite(masm);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   __ bind(skip_fixup);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   int words_pushed = 0;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   // Since all args are passed on the stack, total_args_passed *</span>
<span class="udiff-line-modified-removed">-   // Interpreter::stackElementSize is the space we need.</span>
<span class="udiff-line-modified-added">+ // For each inline type argument, sig includes the list of fields of</span>
<span class="udiff-line-modified-added">+ // the inline type. This utility function computes the number of</span>
<span class="udiff-line-modified-added">+ // arguments for the call if inline types are passed by reference (the</span>
<span class="udiff-line-modified-added">+ // calling convention the interpreter expects).</span>
<span class="udiff-line-modified-added">+ static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {</span>
<span class="udiff-line-modified-added">+   int total_args_passed = 0;</span>
<span class="udiff-line-modified-added">+   if (InlineTypePassFieldsAsArgs) {</span>
<span class="udiff-line-modified-added">+      for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {</span>
<span class="udiff-line-modified-added">+        BasicType bt = sig_extended-&gt;at(i)._bt;</span>
<span class="udiff-line-modified-added">+        if (SigEntry::is_reserved_entry(sig_extended, i)) {</span>
<span class="udiff-line-modified-added">+          // Ignore reserved entry</span>
<span class="udiff-line-modified-added">+        } else if (bt == T_INLINE_TYPE) {</span>
<span class="udiff-line-modified-added">+          // In sig_extended, an inline type argument starts with:</span>
<span class="udiff-line-modified-added">+          // T_INLINE_TYPE, followed by the types of the fields of the</span>
<span class="udiff-line-modified-added">+          // inline type and T_VOID to mark the end of the value</span>
<span class="udiff-line-modified-added">+          // type. Inline types are flattened so, for instance, in the</span>
<span class="udiff-line-modified-added">+          // case of an inline type with an int field and an inline type</span>
<span class="udiff-line-modified-added">+          // field that itself has 2 fields, an int and a long:</span>
<span class="udiff-line-modified-added">+          // T_INLINE_TYPE T_INT T_INLINE_TYPE T_INT T_LONG T_VOID (second</span>
<span class="udiff-line-added">+          // slot for the T_LONG) T_VOID (inner T_INLINE_TYPE) T_VOID</span>
<span class="udiff-line-added">+          // (outer T_INLINE_TYPE)</span>
<span class="udiff-line-added">+          total_args_passed++;</span>
<span class="udiff-line-added">+          int vt = 1;</span>
<span class="udiff-line-added">+          do {</span>
<span class="udiff-line-added">+            i++;</span>
<span class="udiff-line-added">+            BasicType bt = sig_extended-&gt;at(i)._bt;</span>
<span class="udiff-line-added">+            BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;</span>
<span class="udiff-line-added">+            if (bt == T_INLINE_TYPE) {</span>
<span class="udiff-line-added">+              vt++;</span>
<span class="udiff-line-added">+            } else if (bt == T_VOID &amp;&amp;</span>
<span class="udiff-line-added">+                       prev_bt != T_LONG &amp;&amp;</span>
<span class="udiff-line-added">+                       prev_bt != T_DOUBLE) {</span>
<span class="udiff-line-added">+              vt--;</span>
<span class="udiff-line-added">+            }</span>
<span class="udiff-line-added">+          } while (vt != 0);</span>
<span class="udiff-line-added">+        } else {</span>
<span class="udiff-line-added">+          total_args_passed++;</span>
<span class="udiff-line-added">+        }</span>
<span class="udiff-line-added">+      }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     total_args_passed = sig_extended-&gt;length();</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   int extraspace = total_args_passed * Interpreter::stackElementSize;</span>
<span class="udiff-line-modified-added">+   return total_args_passed;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   __ mov(r13, sp);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // stack is aligned, keep it that way</span>
<span class="udiff-line-modified-added">+ </span>
  static void gen_c2i_adapter_helper(MacroAssembler* masm, BasicType bt, const VMRegPair&amp; reg_pair, int extraspace, const Address&amp; to) {
  
<span class="udiff-line-modified-removed">-   if (extraspace)</span>
<span class="udiff-line-removed">-     __ sub(sp, sp, extraspace);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Now write the args into the outgoing interpreter space</span>
<span class="udiff-line-removed">-   for (int i = 0; i &lt; total_args_passed; i++) {</span>
<span class="udiff-line-removed">-     if (sig_bt[i] == T_VOID) {</span>
<span class="udiff-line-removed">-       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);</span>
<span class="udiff-line-removed">-       continue;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // offset to start parameters</span>
<span class="udiff-line-removed">-     int st_off   = (total_args_passed - i - 1) * Interpreter::stackElementSize;</span>
<span class="udiff-line-removed">-     int next_off = st_off - Interpreter::stackElementSize;</span>
<span class="udiff-line-modified-added">+     assert(bt != T_INLINE_TYPE || !InlineTypePassFieldsAsArgs, &quot;no inline type here&quot;);</span>
  
      // Say 4 args:
      // i   st_off
      // 0   32 T_LONG
      // 1   24 T_VOID
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -406,94 +502,222 @@</span>
      // However to make thing extra confusing. Because we can fit a long/double in
      // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
      // leaves one slot empty and only stores to a single slot. In this case the
      // slot that is occupied is the T_VOID slot. See I said it was confusing.
  
<span class="udiff-line-modified-removed">-     VMReg r_1 = regs[i].first();</span>
<span class="udiff-line-modified-removed">-     VMReg r_2 = regs[i].second();</span>
<span class="udiff-line-modified-added">+     // int next_off = st_off - Interpreter::stackElementSize;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     VMReg r_1 = reg_pair.first();</span>
<span class="udiff-line-added">+     VMReg r_2 = reg_pair.second();</span>
<span class="udiff-line-added">+ </span>
      if (!r_1-&gt;is_valid()) {
        assert(!r_2-&gt;is_valid(), &quot;&quot;);
<span class="udiff-line-modified-removed">-       continue;</span>
<span class="udiff-line-modified-added">+       return;</span>
      }
<span class="udiff-line-added">+ </span>
      if (r_1-&gt;is_stack()) {
        // memory to memory use rscratch1
<span class="udiff-line-modified-removed">-       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size</span>
<span class="udiff-line-modified-removed">-                     + extraspace</span>
<span class="udiff-line-removed">-                     + words_pushed * wordSize);</span>
<span class="udiff-line-modified-added">+       // words_pushed is always 0 so we don&#39;t use it.</span>
<span class="udiff-line-modified-added">+       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extraspace /* + word_pushed * wordSize */);</span>
        if (!r_2-&gt;is_valid()) {
          // sign extend??
          __ ldrw(rscratch1, Address(sp, ld_off));
<span class="udiff-line-modified-removed">-         __ str(rscratch1, Address(sp, st_off));</span>
<span class="udiff-line-modified-added">+         __ str(rscratch1, to);</span>
  
        } else {
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-         __ ldr(rscratch1, Address(sp, ld_off));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG</span>
<span class="udiff-line-removed">-         // T_DOUBLE and T_LONG use two slots in the interpreter</span>
<span class="udiff-line-removed">-         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {</span>
<span class="udiff-line-removed">-           // ld_off == LSW, ld_off+wordSize == MSW</span>
<span class="udiff-line-removed">-           // st_off == MSW, next_off == LSW</span>
<span class="udiff-line-removed">-           __ str(rscratch1, Address(sp, next_off));</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-           // Overwrite the unused slot with known junk</span>
<span class="udiff-line-removed">-           __ mov(rscratch1, 0xdeadffffdeadaaaaul);</span>
<span class="udiff-line-removed">-           __ str(rscratch1, Address(sp, st_off));</span>
<span class="udiff-line-removed">- #endif /* ASSERT */</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           __ str(rscratch1, Address(sp, st_off));</span>
<span class="udiff-line-modified-added">+         __ ldr(rscratch1, Address(sp, ld_off));</span>
          __ str(rscratch1, to);
        }
      } else if (r_1-&gt;is_Register()) {
        Register r = r_1-&gt;as_Register();
<span class="udiff-line-modified-removed">-       if (!r_2-&gt;is_valid()) {</span>
<span class="udiff-line-removed">-         // must be only an int (or less ) so move only 32bits to slot</span>
<span class="udiff-line-removed">-         // why not sign extend??</span>
<span class="udiff-line-removed">-         __ str(r, Address(sp, st_off));</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG</span>
<span class="udiff-line-removed">-         // T_DOUBLE and T_LONG use two slots in the interpreter</span>
<span class="udiff-line-removed">-         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {</span>
<span class="udiff-line-removed">-           // long/double in gpr</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-           // Overwrite the unused slot with known junk</span>
<span class="udiff-line-removed">-           __ mov(rscratch1, 0xdeadffffdeadaaabul);</span>
<span class="udiff-line-removed">-           __ str(rscratch1, Address(sp, st_off));</span>
<span class="udiff-line-removed">- #endif /* ASSERT */</span>
<span class="udiff-line-removed">-           __ str(r, Address(sp, next_off));</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           __ str(r, Address(sp, st_off));</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+       __ str(r, to);</span>
      } else {
        assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
        if (!r_2-&gt;is_valid()) {
          // only a float use just part of the slot
<span class="udiff-line-modified-removed">-         __ strs(r_1-&gt;as_FloatRegister(), Address(sp, st_off));</span>
<span class="udiff-line-modified-added">+         __ strs(r_1-&gt;as_FloatRegister(), to);</span>
        } else {
<span class="udiff-line-modified-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-         // Overwrite the unused slot with known junk</span>
<span class="udiff-line-removed">-         __ mov(rscratch1, 0xdeadffffdeadaaacul);</span>
<span class="udiff-line-removed">-         __ str(rscratch1, Address(sp, st_off));</span>
<span class="udiff-line-removed">- #endif /* ASSERT */</span>
<span class="udiff-line-removed">-         __ strd(r_1-&gt;as_FloatRegister(), Address(sp, next_off));</span>
<span class="udiff-line-modified-added">+         __ strd(r_1-&gt;as_FloatRegister(), to);</span>
        }
<span class="udiff-line-added">+    }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void gen_c2i_adapter(MacroAssembler *masm,</span>
<span class="udiff-line-added">+                             const GrowableArray&lt;SigEntry&gt;* sig_extended,</span>
<span class="udiff-line-added">+                             const VMRegPair *regs,</span>
<span class="udiff-line-added">+                             Label&amp; skip_fixup,</span>
<span class="udiff-line-added">+                             address start,</span>
<span class="udiff-line-added">+                             OopMapSet* oop_maps,</span>
<span class="udiff-line-added">+                             int&amp; frame_complete,</span>
<span class="udiff-line-added">+                             int&amp; frame_size_in_words,</span>
<span class="udiff-line-added">+                             bool alloc_inline_receiver) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Before we get into the guts of the C2I adapter, see if we should be here</span>
<span class="udiff-line-added">+   // at all.  We&#39;ve come from compiled code and are attempting to jump to the</span>
<span class="udiff-line-added">+   // interpreter, which means the caller made a static call to get here</span>
<span class="udiff-line-added">+   // (vcalls always get a compiled target if there is one).  Check for a</span>
<span class="udiff-line-added">+   // compiled target.  If there is one, we need to patch the caller&#39;s call.</span>
<span class="udiff-line-added">+   patch_callers_callsite(masm);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ bind(skip_fixup);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool has_inline_argument = false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (InlineTypePassFieldsAsArgs) {</span>
<span class="udiff-line-added">+       // Is there an inline type argument?</span>
<span class="udiff-line-added">+      for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_inline_argument; i++) {</span>
<span class="udiff-line-added">+        has_inline_argument = (sig_extended-&gt;at(i)._bt == T_INLINE_TYPE);</span>
<span class="udiff-line-added">+      }</span>
<span class="udiff-line-added">+      if (has_inline_argument) {</span>
<span class="udiff-line-added">+       // There is at least an inline type argument: we&#39;re coming from</span>
<span class="udiff-line-added">+       // compiled code so we have no buffers to back the inline types</span>
<span class="udiff-line-added">+       // Allocate the buffers here with a runtime call.</span>
<span class="udiff-line-added">+       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       frame_complete = __ offset();</span>
<span class="udiff-line-added">+       address the_pc = __ pc();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       __ mov(c_rarg0, rthread);</span>
<span class="udiff-line-added">+       __ mov(c_rarg1, r1);</span>
<span class="udiff-line-added">+       __ mov(c_rarg2, (int64_t)alloc_inline_receiver);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_inline_types)));</span>
<span class="udiff-line-added">+       __ blr(rscratch1);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);</span>
<span class="udiff-line-added">+       __ reset_last_Java_frame(false);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       RegisterSaver::restore_live_registers(masm);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       Label no_exception;</span>
<span class="udiff-line-added">+       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));</span>
<span class="udiff-line-added">+       __ cbz(r0, no_exception);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       __ str(zr, Address(rthread, JavaThread::vm_result_offset()));</span>
<span class="udiff-line-added">+       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));</span>
<span class="udiff-line-added">+       __ b(RuntimeAddress(StubRoutines::forward_exception_entry()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       __ bind(no_exception);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       // We get an array of objects from the runtime call</span>
<span class="udiff-line-added">+       __ get_vm_result(r10, rthread);</span>
<span class="udiff-line-added">+       __ get_vm_result_2(r1, rthread); // TODO: required to keep the callee Method live?</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int words_pushed = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Since all args are passed on the stack, total_args_passed *</span>
<span class="udiff-line-added">+   // Interpreter::stackElementSize is the space we need.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int total_args_passed = compute_total_args_passed_int(sig_extended);</span>
<span class="udiff-line-added">+   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // stack is aligned, keep it that way</span>
<span class="udiff-line-added">+   extraspace = align_up(extraspace, 2 * wordSize);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ mov(r13, sp);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (extraspace)</span>
<span class="udiff-line-added">+     __ sub(sp, sp, extraspace);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Now write the args into the outgoing interpreter space</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int ignored = 0, next_vt_arg = 0, next_arg_int = 0;</span>
<span class="udiff-line-added">+   bool has_oop_field = false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int next_arg_comp = 0; next_arg_comp &lt; total_args_passed; next_arg_comp++) {</span>
<span class="udiff-line-added">+     BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;</span>
<span class="udiff-line-added">+     // offset to start parameters</span>
<span class="udiff-line-added">+     int st_off   = (total_args_passed - next_arg_int - 1) * Interpreter::stackElementSize;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!InlineTypePassFieldsAsArgs || bt != T_INLINE_TYPE) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {</span>
<span class="udiff-line-added">+                continue; // Ignore reserved entry</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (bt == T_VOID) {</span>
<span class="udiff-line-added">+                assert(next_arg_comp &gt; 0 &amp;&amp; (sig_extended-&gt;at(next_arg_comp - 1)._bt == T_LONG || sig_extended-&gt;at(next_arg_comp - 1)._bt == T_DOUBLE), &quot;missing half&quot;);</span>
<span class="udiff-line-added">+                next_arg_int ++;</span>
<span class="udiff-line-added">+                continue;</span>
<span class="udiff-line-added">+              }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+              int next_off = st_off - Interpreter::stackElementSize;</span>
<span class="udiff-line-added">+              int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+              gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp], extraspace, Address(sp, offset));</span>
<span class="udiff-line-added">+              next_arg_int ++;</span>
<span class="udiff-line-added">+    } else {</span>
<span class="udiff-line-added">+        ignored++;</span>
<span class="udiff-line-added">+       // get the buffer from the just allocated pool of buffers</span>
<span class="udiff-line-added">+       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_INLINE_TYPE);</span>
<span class="udiff-line-added">+       __ load_heap_oop(rscratch1, Address(r10, index));</span>
<span class="udiff-line-added">+       next_vt_arg++;</span>
<span class="udiff-line-added">+       next_arg_int++;</span>
<span class="udiff-line-added">+       int vt = 1;</span>
<span class="udiff-line-added">+       // write fields we get from compiled code in registers/stack</span>
<span class="udiff-line-added">+       // slots to the buffer: we know we are done with that inline type</span>
<span class="udiff-line-added">+       // argument when we hit the T_VOID that acts as an end of value</span>
<span class="udiff-line-added">+       // type delimiter for this inline type. Inline types are flattened</span>
<span class="udiff-line-added">+       // so we might encounter embedded inline types. Each entry in</span>
<span class="udiff-line-added">+       // sig_extended contains a field offset in the buffer.</span>
<span class="udiff-line-added">+       do {</span>
<span class="udiff-line-added">+         next_arg_comp++;</span>
<span class="udiff-line-added">+         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;</span>
<span class="udiff-line-added">+         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp - 1)._bt;</span>
<span class="udiff-line-added">+         if (bt == T_INLINE_TYPE) {</span>
<span class="udiff-line-added">+           vt++;</span>
<span class="udiff-line-added">+           ignored++;</span>
<span class="udiff-line-added">+         } else if (bt == T_VOID &amp;&amp; prev_bt != T_LONG &amp;&amp; prev_bt != T_DOUBLE) {</span>
<span class="udiff-line-added">+           vt--;</span>
<span class="udiff-line-added">+           ignored++;</span>
<span class="udiff-line-added">+         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {</span>
<span class="udiff-line-added">+           // Ignore reserved entry</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           int off = sig_extended-&gt;at(next_arg_comp)._offset;</span>
<span class="udiff-line-added">+           assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);</span>
<span class="udiff-line-added">+           has_oop_field = has_oop_field || is_oop;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp - ignored], extraspace, Address(r11, off));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } while (vt != 0);</span>
<span class="udiff-line-added">+       // pass the buffer to the interpreter</span>
<span class="udiff-line-added">+       __ str(rscratch1, Address(sp, st_off));</span>
<span class="udiff-line-added">+    }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // If an inline type was allocated and initialized, apply post barrier to all oop fields</span>
<span class="udiff-line-added">+   if (has_inline_argument &amp;&amp; has_oop_field) {</span>
<span class="udiff-line-added">+     __ push(r13); // save senderSP</span>
<span class="udiff-line-added">+     __ push(r1); // save callee</span>
<span class="udiff-line-added">+     // Allocate argument register save area</span>
<span class="udiff-line-added">+     if (frame::arg_reg_save_area_bytes != 0) {</span>
<span class="udiff-line-added">+       __ sub(sp, sp, frame::arg_reg_save_area_bytes);</span>
      }
<span class="udiff-line-added">+     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::apply_post_barriers), rthread, r10);</span>
<span class="udiff-line-added">+     // De-allocate argument register save area</span>
<span class="udiff-line-added">+     if (frame::arg_reg_save_area_bytes != 0) {</span>
<span class="udiff-line-added">+       __ add(sp, sp, frame::arg_reg_save_area_bytes);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     __ pop(r1); // restore callee</span>
<span class="udiff-line-added">+     __ pop(r13); // restore sender SP</span>
    }
  
    __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
  
    __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
    __ br(rscratch1);
  }
  
<span class="udiff-line-added">+ void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm, int comp_args_on_stack, const GrowableArray&lt;SigEntry&gt;* sig, const VMRegPair *regs) {</span>
  
<span class="udiff-line-removed">- void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,</span>
<span class="udiff-line-removed">-                                     int total_args_passed,</span>
<span class="udiff-line-removed">-                                     int comp_args_on_stack,</span>
<span class="udiff-line-removed">-                                     const BasicType *sig_bt,</span>
<span class="udiff-line-removed">-                                     const VMRegPair *regs) {</span>
  
    // Note: r13 contains the senderSP on entry. We must preserve it since
    // we may do a i2c -&gt; c2i transition if we lose a race where compiled
    // code goes non-entrant while we get args ready.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -549,14 +773,15 @@</span>
      __ block_comment(&quot;} verify_i2ce &quot;);
  #endif
    }
  
    // Cut-out for having no stack args.
<span class="udiff-line-modified-removed">-   int comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;</span>
<span class="udiff-line-modified-added">+   int comp_words_on_stack = 0;</span>
    if (comp_args_on_stack) {
<span class="udiff-line-modified-removed">-     __ sub(rscratch1, sp, comp_words_on_stack * wordSize);</span>
<span class="udiff-line-modified-removed">-     __ andr(sp, rscratch1, -16);</span>
<span class="udiff-line-modified-added">+      comp_words_on_stack = align_up(comp_args_on_stack * VMRegImpl::stack_slot_size, wordSize) &gt;&gt; LogBytesPerWord;</span>
<span class="udiff-line-modified-added">+      __ sub(rscratch1, sp, comp_words_on_stack * wordSize);</span>
<span class="udiff-line-added">+      __ andr(sp, rscratch1, -16);</span>
    }
  
    // Will jump to the compiled code just as if compiled code was doing it.
    // Pre-load the register-jump target early, to schedule it better.
    __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -571,22 +796,26 @@</span>
      __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
      __ bind(no_alternative_target);
    }
  #endif // INCLUDE_JVMCI
  
<span class="udiff-line-added">+   int total_args_passed = sig-&gt;length();</span>
<span class="udiff-line-added">+ </span>
    // Now generate the shuffle code.
    for (int i = 0; i &lt; total_args_passed; i++) {
<span class="udiff-line-modified-removed">-     if (sig_bt[i] == T_VOID) {</span>
<span class="udiff-line-modified-removed">-       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);</span>
<span class="udiff-line-modified-added">+     BasicType bt = sig-&gt;at(i)._bt;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     assert(bt != T_INLINE_TYPE, &quot;i2c adapter doesn&#39;t unpack inline typ args&quot;);</span>
<span class="udiff-line-added">+     if (bt == T_VOID) {</span>
<span class="udiff-line-added">+       assert(i &gt; 0 &amp;&amp; (sig-&gt;at(i - 1)._bt == T_LONG || sig-&gt;at(i - 1)._bt == T_DOUBLE), &quot;missing half&quot;);</span>
        continue;
      }
  
      // Pick up 0, 1 or 2 words from SP+offset.
<span class="udiff-line-added">+     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(), &quot;scrambled load targets?&quot;);</span>
  
<span class="udiff-line-modified-removed">-     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),</span>
<span class="udiff-line-removed">-             &quot;scrambled load targets?&quot;);</span>
<span class="udiff-line-removed">-     // Load in argument order going down.</span>
<span class="udiff-line-modified-added">+     // Load in argument order going down.</span>
      int ld_off = (total_args_passed - i - 1) * Interpreter::stackElementSize;
      // Point to interpreter value (vs. tag)
      int next_off = ld_off - Interpreter::stackElementSize;
      //
      //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -597,11 +826,11 @@</span>
        assert(!r_2-&gt;is_valid(), &quot;&quot;);
        continue;
      }
      if (r_1-&gt;is_stack()) {
        // Convert stack slot to an SP offset (+ wordSize to account for return address )
<span class="udiff-line-modified-removed">-       int st_off = regs[i].first()-&gt;reg2stack()*VMRegImpl::stack_slot_size;</span>
<span class="udiff-line-modified-added">+       int st_off = regs[i].first()-&gt;reg2stack() * VMRegImpl::stack_slot_size;</span>
        if (!r_2-&gt;is_valid()) {
          // sign extend???
          __ ldrsw(rscratch2, Address(esp, ld_off));
          __ str(rscratch2, Address(sp, st_off));
        } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -614,43 +843,42 @@</span>
          //
          // Interpreter local[n] == MSW, local[n+1] == LSW however locals
          // are accessed as negative so LSW is at LOW address
  
          // ld_off is MSW so get LSW
<span class="udiff-line-modified-removed">-         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?</span>
<span class="udiff-line-removed">-                            next_off : ld_off;</span>
<span class="udiff-line-modified-added">+         const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;</span>
          __ ldr(rscratch2, Address(esp, offset));
          // st_off is LSW (i.e. reg.first())
<span class="udiff-line-modified-removed">-         __ str(rscratch2, Address(sp, st_off));</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-removed">-     } else if (r_1-&gt;is_Register()) {  // Register argument</span>
<span class="udiff-line-modified-removed">-       Register r = r_1-&gt;as_Register();</span>
<span class="udiff-line-modified-removed">-       if (r_2-&gt;is_valid()) {</span>
<span class="udiff-line-modified-removed">-         //</span>
<span class="udiff-line-modified-removed">-         // We are using two VMRegs. This can be either T_OBJECT,</span>
<span class="udiff-line-modified-removed">-         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates</span>
<span class="udiff-line-modified-removed">-         // two slots but only uses one for thr T_LONG or T_DOUBLE case</span>
<span class="udiff-line-modified-removed">-         // So we must adjust where to pick up the data to match the</span>
<span class="udiff-line-modified-removed">-         // interpreter.</span>
<span class="udiff-line-modified-added">+          __ str(rscratch2, Address(sp, st_off));</span>
<span class="udiff-line-modified-added">+        }</span>
<span class="udiff-line-modified-added">+      } else if (r_1-&gt;is_Register()) {  // Register argument</span>
<span class="udiff-line-modified-added">+        Register r = r_1-&gt;as_Register();</span>
<span class="udiff-line-modified-added">+        if (r_2-&gt;is_valid()) {</span>
<span class="udiff-line-modified-added">+          //</span>
<span class="udiff-line-modified-added">+          // We are using two VMRegs. This can be either T_OBJECT,</span>
<span class="udiff-line-modified-added">+          // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates</span>
<span class="udiff-line-modified-added">+          // two slots but only uses one for thr T_LONG or T_DOUBLE case</span>
<span class="udiff-line-modified-added">+          // So we must adjust where to pick up the data to match the</span>
<span class="udiff-line-modified-added">+          // interpreter.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+          // this can be a misaligned move</span>
<span class="udiff-line-added">+          __ ldr(r, Address(esp, offset));</span>
<span class="udiff-line-added">+        } else {</span>
<span class="udiff-line-added">+          // sign extend and use a full word?</span>
<span class="udiff-line-added">+          __ ldrw(r, Address(esp, ld_off));</span>
<span class="udiff-line-added">+        }</span>
<span class="udiff-line-added">+      } else {</span>
<span class="udiff-line-added">+        if (!r_2-&gt;is_valid()) {</span>
<span class="udiff-line-added">+          __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));</span>
<span class="udiff-line-added">+        } else {</span>
<span class="udiff-line-added">+          __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));</span>
<span class="udiff-line-added">+        }</span>
<span class="udiff-line-added">+      }</span>
<span class="udiff-line-added">+    }</span>
  
<span class="udiff-line-removed">-         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?</span>
<span class="udiff-line-removed">-                            next_off : ld_off;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // this can be a misaligned move</span>
<span class="udiff-line-removed">-         __ ldr(r, Address(esp, offset));</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         // sign extend and use a full word?</span>
<span class="udiff-line-removed">-         __ ldrw(r, Address(esp, ld_off));</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       if (!r_2-&gt;is_valid()) {</span>
<span class="udiff-line-removed">-         __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
  
    // 6243940 We might end up in handle_wrong_method if
    // the callee is deoptimized as we race thru here. If that
    // happens we don&#39;t want to take a safepoint because the
    // caller frame will look interpreted and arguments are now
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -659,27 +887,14 @@</span>
    // we try and find the callee by normal means a safepoint
    // is possible. So we stash the desired callee in the thread
    // and the vm will find there should this case occur.
  
    __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));
<span class="udiff-line-removed">- </span>
    __ br(rscratch1);
  }
  
<span class="udiff-line-modified-removed">- // ---------------------------------------------------------------</span>
<span class="udiff-line-removed">- AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,</span>
<span class="udiff-line-removed">-                                                             int total_args_passed,</span>
<span class="udiff-line-removed">-                                                             int comp_args_on_stack,</span>
<span class="udiff-line-removed">-                                                             const BasicType *sig_bt,</span>
<span class="udiff-line-removed">-                                                             const VMRegPair *regs,</span>
<span class="udiff-line-removed">-                                                             AdapterFingerPrint* fingerprint) {</span>
<span class="udiff-line-removed">-   address i2c_entry = __ pc();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   address c2i_unverified_entry = __ pc();</span>
<span class="udiff-line-removed">-   Label skip_fixup;</span>
<span class="udiff-line-modified-added">+ static void gen_inline_cache_check(MacroAssembler *masm, Label&amp; skip_fixup) {</span>
  
    Label ok;
  
    Register holder = rscratch2;
    Register receiver = j_rarg0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -710,39 +925,99 @@</span>
      __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
      __ cbz(rscratch1, skip_fixup);
      __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
      __ block_comment(&quot;} c2i_unverified_entry&quot;);
    }
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // ---------------------------------------------------------------</span>
<span class="udiff-line-added">+ AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,</span>
<span class="udiff-line-added">+                                                             int comp_args_on_stack,</span>
<span class="udiff-line-added">+                                                             const GrowableArray&lt;SigEntry&gt;* sig,</span>
<span class="udiff-line-added">+                                                             const VMRegPair* regs,</span>
<span class="udiff-line-added">+                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="udiff-line-added">+                                                             const VMRegPair* regs_cc,</span>
<span class="udiff-line-added">+                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc_ro,</span>
<span class="udiff-line-added">+                                                             const VMRegPair* regs_cc_ro,</span>
<span class="udiff-line-added">+                                                             AdapterFingerPrint* fingerprint,</span>
<span class="udiff-line-added">+                                                             AdapterBlob*&amp; new_adapter) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   address i2c_entry = __ pc();</span>
<span class="udiff-line-added">+   gen_i2c_adapter(masm, comp_args_on_stack, sig, regs);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   address c2i_unverified_entry = __ pc();</span>
<span class="udiff-line-added">+   Label skip_fixup;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   gen_inline_cache_check(masm, skip_fixup);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   OopMapSet* oop_maps = new OopMapSet();</span>
<span class="udiff-line-added">+   int frame_complete = CodeOffsets::frame_never_safe;</span>
<span class="udiff-line-added">+   int frame_size_in_words = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Scalarized c2i adapter with non-scalarized receiver (i.e., don&#39;t pack receiver)</span>
<span class="udiff-line-added">+   address c2i_inline_ro_entry = __ pc();</span>
<span class="udiff-line-added">+   if (regs_cc != regs_cc_ro) {</span>
<span class="udiff-line-added">+     Label unused;</span>
<span class="udiff-line-added">+     gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);</span>
<span class="udiff-line-added">+     skip_fixup = unused;</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-added">+   // Scalarized c2i adapter</span>
    address c2i_entry = __ pc();
  
    // Class initialization barrier for static methods
    address c2i_no_clinit_check_entry = NULL;
<span class="udiff-line-added">+ </span>
    if (VM_Version::supports_fast_class_init_checks()) {
      Label L_skip_barrier;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     { // Bypass the barrier for non-static methods</span>
<span class="udiff-line-modified-removed">-       __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));</span>
<span class="udiff-line-modified-removed">-       __ andsw(zr, rscratch1, JVM_ACC_STATIC);</span>
<span class="udiff-line-modified-added">+     { // Bypass the barrier for non-static methods</span>
<span class="udiff-line-modified-added">+         Register flags  = rscratch1;</span>
<span class="udiff-line-modified-added">+       __ ldrw(flags, Address(rmethod, Method::access_flags_offset()));</span>
<span class="udiff-line-modified-added">+       __ tst(flags, JVM_ACC_STATIC);</span>
        __ br(Assembler::NE, L_skip_barrier); // non-static
      }
  
<span class="udiff-line-modified-removed">-     __ load_method_holder(rscratch2, rmethod);</span>
<span class="udiff-line-modified-removed">-     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);</span>
<span class="udiff-line-modified-removed">-     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>
<span class="udiff-line-modified-added">+     Register klass = rscratch1;</span>
<span class="udiff-line-modified-added">+     __ load_method_holder(klass, rmethod);</span>
<span class="udiff-line-modified-added">+     // We pass rthread to this function on x86</span>
<span class="udiff-line-added">+     __ clinit_barrier(klass, rscratch2, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path</span>
  
      __ bind(L_skip_barrier);
      c2i_no_clinit_check_entry = __ pc();
    }
  
    BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
    bs-&gt;c2i_entry_barrier(masm);
  
    gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
  
<span class="udiff-line-added">+   address c2i_unverified_inline_entry = c2i_unverified_entry;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+  // Non-scalarized c2i adapter</span>
<span class="udiff-line-added">+   address c2i_inline_entry = c2i_entry;</span>
<span class="udiff-line-added">+   if (regs != regs_cc) {</span>
<span class="udiff-line-added">+     Label inline_entry_skip_fixup;</span>
<span class="udiff-line-added">+     c2i_unverified_inline_entry = __ pc();</span>
<span class="udiff-line-added">+     gen_inline_cache_check(masm, inline_entry_skip_fixup);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     c2i_inline_entry = __ pc();</span>
<span class="udiff-line-added">+     Label unused;</span>
<span class="udiff-line-added">+     gen_c2i_adapter(masm, sig, regs, inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    __ flush();
<span class="udiff-line-modified-removed">-   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   // The c2i adapter might safepoint and trigger a GC. The caller must make sure that</span>
<span class="udiff-line-added">+   // the GC knows about the location of oop argument locations passed to the c2i adapter.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool caller_must_gc_arguments = (regs != regs_cc);</span>
<span class="udiff-line-added">+   new_adapter = AdapterBlob::create(masm-&gt;code(), frame_complete, frame_size_in_words + 10, oop_maps, caller_must_gc_arguments);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);</span>
  }
  
  int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
                                           VMRegPair *regs,
                                           VMRegPair *regs2,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -781,10 +1056,11 @@</span>
        case T_LONG:
          assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
          // fall through
        case T_OBJECT:
        case T_ARRAY:
<span class="udiff-line-added">+       case T_INLINE_TYPE:</span>
        case T_ADDRESS:
        case T_METADATA:
          if (int_args &lt; Argument::n_int_register_parameters_c) {
            regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
          } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1632,10 +1908,11 @@</span>
            }
  #endif
            int_args++;
            break;
          }
<span class="udiff-line-added">+       case T_INLINE_TYPE:</span>
        case T_OBJECT:
          assert(!is_critical_native, &quot;no oop arguments&quot;);
          object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
                      ((i == 0) &amp;&amp; (!is_static)),
                      &amp;receiver_offset);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1819,10 +2096,11 @@</span>
    case T_DOUBLE :
    case T_FLOAT  :
      // Result is in v0 we&#39;ll save as needed
      break;
    case T_ARRAY:                 // Really a handle
<span class="udiff-line-added">+   case T_INLINE_TYPE:</span>
    case T_OBJECT:                // Really a handle
        break; // can&#39;t de-handlize until after safepoint check
    case T_VOID: break;
    case T_LONG: break;
    default       : ShouldNotReachHere();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3044,6 +3322,111 @@</span>
    masm-&gt;flush();
  
    // Set exception blob
    _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ BufferedInlineTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {</span>
<span class="udiff-line-added">+   BufferBlob* buf = BufferBlob::create(&quot;inline types pack/unpack&quot;, 16 * K);</span>
<span class="udiff-line-added">+   CodeBuffer buffer(buf);</span>
<span class="udiff-line-added">+   short buffer_locs[20];</span>
<span class="udiff-line-added">+   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,</span>
<span class="udiff-line-added">+                                          sizeof(buffer_locs)/sizeof(relocInfo));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   MacroAssembler _masm(&amp;buffer);</span>
<span class="udiff-line-added">+   MacroAssembler* masm = &amp;_masm;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();</span>
<span class="udiff-line-added">+   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int pack_fields_off = __ offset();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int j = 1;</span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {</span>
<span class="udiff-line-added">+     BasicType bt = sig_vk-&gt;at(i)._bt;</span>
<span class="udiff-line-added">+     if (bt == T_INLINE_TYPE) {</span>
<span class="udiff-line-added">+       continue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (bt == T_VOID) {</span>
<span class="udiff-line-added">+       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||</span>
<span class="udiff-line-added">+           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {</span>
<span class="udiff-line-added">+         j++;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       continue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     int off = sig_vk-&gt;at(i)._offset;</span>
<span class="udiff-line-added">+     VMRegPair pair = regs-&gt;at(j);</span>
<span class="udiff-line-added">+     VMReg r_1 = pair.first();</span>
<span class="udiff-line-added">+     VMReg r_2 = pair.second();</span>
<span class="udiff-line-added">+     Address to(r0, off);</span>
<span class="udiff-line-added">+     if (bt == T_FLOAT) {</span>
<span class="udiff-line-added">+       __ strs(r_1-&gt;as_FloatRegister(), to);</span>
<span class="udiff-line-added">+     } else if (bt == T_DOUBLE) {</span>
<span class="udiff-line-added">+       __ strd(r_1-&gt;as_FloatRegister(), to);</span>
<span class="udiff-line-added">+     } else if (bt == T_OBJECT || bt == T_ARRAY) {</span>
<span class="udiff-line-added">+       Register val = r_1-&gt;as_Register();</span>
<span class="udiff-line-added">+       assert_different_registers(r0, val);</span>
<span class="udiff-line-added">+       // We don&#39;t need barriers because the destination is a newly allocated object.</span>
<span class="udiff-line-added">+       // Also, we cannot use store_heap_oop(to, val) because it uses r8 as tmp.</span>
<span class="udiff-line-added">+       if (UseCompressedOops) {</span>
<span class="udiff-line-added">+         __ encode_heap_oop(val);</span>
<span class="udiff-line-added">+         __ str(val, to);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         __ str(val, to);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);</span>
<span class="udiff-line-added">+       assert_different_registers(r0, r_1-&gt;as_Register());</span>
<span class="udiff-line-added">+       size_t size_in_bytes = type2aelembytes(bt);</span>
<span class="udiff-line-added">+       __ store_sized_value(to, r_1-&gt;as_Register(), size_in_bytes);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     j++;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ ret(lr);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int unpack_fields_off = __ offset();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   j = 1;</span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {</span>
<span class="udiff-line-added">+     BasicType bt = sig_vk-&gt;at(i)._bt;</span>
<span class="udiff-line-added">+     if (bt == T_INLINE_TYPE) {</span>
<span class="udiff-line-added">+       continue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (bt == T_VOID) {</span>
<span class="udiff-line-added">+       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||</span>
<span class="udiff-line-added">+           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {</span>
<span class="udiff-line-added">+         j++;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       continue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     int off = sig_vk-&gt;at(i)._offset;</span>
<span class="udiff-line-added">+     VMRegPair pair = regs-&gt;at(j);</span>
<span class="udiff-line-added">+     VMReg r_1 = pair.first();</span>
<span class="udiff-line-added">+     VMReg r_2 = pair.second();</span>
<span class="udiff-line-added">+     Address from(r0, off);</span>
<span class="udiff-line-added">+     if (bt == T_FLOAT) {</span>
<span class="udiff-line-added">+       __ ldrs(r_1-&gt;as_FloatRegister(), from);</span>
<span class="udiff-line-added">+     } else if (bt == T_DOUBLE) {</span>
<span class="udiff-line-added">+       __ ldrd(r_1-&gt;as_FloatRegister(), from);</span>
<span class="udiff-line-added">+     } else if (bt == T_OBJECT || bt == T_ARRAY) {</span>
<span class="udiff-line-added">+        assert_different_registers(r0, r_1-&gt;as_Register());</span>
<span class="udiff-line-added">+        __ load_heap_oop(r_1-&gt;as_Register(), from);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);</span>
<span class="udiff-line-added">+       assert_different_registers(r0, r_1-&gt;as_Register());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       size_t size_in_bytes = type2aelembytes(bt);</span>
<span class="udiff-line-added">+       __ load_sized_value(r_1-&gt;as_Register(), from, size_in_bytes, bt != T_CHAR &amp;&amp; bt != T_BOOLEAN);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     j++;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ ret(lr);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ flush();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return BufferedInlineTypeBlob::create(&amp;buffer, pack_fields_off, unpack_fields_off);</span>
<span class="udiff-line-added">+ }</span>
  #endif // COMPILER2
</pre>
<center><a href="c1_CodeStubs_aarch64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_aarch64.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>