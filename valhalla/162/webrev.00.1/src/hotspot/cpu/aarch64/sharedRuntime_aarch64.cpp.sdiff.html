<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_CodeStubs_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;

  29 #include &quot;code/codeCache.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;code/icBuffer.hpp&quot;
  32 #include &quot;code/vtableStubs.hpp&quot;
  33 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;interpreter/interp_masm.hpp&quot;
  36 #include &quot;logging/log.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;nativeInst_aarch64.hpp&quot;
  39 #include &quot;oops/compiledICHolder.hpp&quot;
  40 #include &quot;oops/klass.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;runtime/vframeArray.hpp&quot;
  44 #include &quot;utilities/align.hpp&quot;
  45 #include &quot;vmreg_aarch64.inline.hpp&quot;
  46 #ifdef COMPILER1
  47 #include &quot;c1/c1_Runtime1.hpp&quot;
  48 #endif
</pre>
<hr />
<pre>
 274     case T_SHORT:
 275     case T_INT:
 276       if (int_args &lt; Argument::n_int_register_parameters_j) {
 277         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 278       } else {
 279         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 280         stk_args += 2;
 281       }
 282       break;
 283     case T_VOID:
 284       // halves of T_LONG or T_DOUBLE
 285       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 286       regs[i].set_bad();
 287       break;
 288     case T_LONG:
 289       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 290       // fall through
 291     case T_OBJECT:
 292     case T_ARRAY:
 293     case T_ADDRESS:

 294       if (int_args &lt; Argument::n_int_register_parameters_j) {
 295         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 296       } else {
 297         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 298         stk_args += 2;
 299       }
 300       break;
 301     case T_FLOAT:
 302       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 303         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 304       } else {
 305         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 306         stk_args += 2;
 307       }
 308       break;
 309     case T_DOUBLE:
 310       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 311       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 312         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 313       } else {
 314         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 315         stk_args += 2;
 316       }
 317       break;
 318     default:
 319       ShouldNotReachHere();
 320       break;
 321     }
 322   }
 323 
 324   return align_up(stk_args, 2);
 325 }
 326 




















































































 327 // Patch the callers callsite with entry to compiled code if it exists.
 328 static void patch_callers_callsite(MacroAssembler *masm) {
 329   Label L;
 330   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 331   __ cbz(rscratch1, L);
 332 
 333   __ enter();
 334   __ push_CPU_state();
 335 
 336   // VM needs caller&#39;s callsite
 337   // VM needs target method
 338   // This needs to be a long call since we will relocate this adapter to
 339   // the codeBuffer and it may not reach
 340 
 341 #ifndef PRODUCT
 342   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 343 #endif
 344 
 345   __ mov(c_rarg0, rmethod);
 346   __ mov(c_rarg1, lr);
 347   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 348   __ blr(rscratch1);
 349   __ maybe_isb();
 350 
 351   __ pop_CPU_state();
 352   // restore sp
 353   __ leave();
 354   __ bind(L);
 355 }
 356 
<span class="line-modified"> 357 static void gen_c2i_adapter(MacroAssembler *masm,</span>
<span class="line-modified"> 358                             int total_args_passed,</span>
<span class="line-modified"> 359                             int comp_args_on_stack,</span>
<span class="line-modified"> 360                             const BasicType *sig_bt,</span>
<span class="line-modified"> 361                             const VMRegPair *regs,</span>
<span class="line-modified"> 362                             Label&amp; skip_fixup) {</span>
<span class="line-modified"> 363   // Before we get into the guts of the C2I adapter, see if we should be here</span>
<span class="line-modified"> 364   // at all.  We&#39;ve come from compiled code and are attempting to jump to the</span>
<span class="line-modified"> 365   // interpreter, which means the caller made a static call to get here</span>
<span class="line-modified"> 366   // (vcalls always get a compiled target if there is one).  Check for a</span>
<span class="line-modified"> 367   // compiled target.  If there is one, we need to patch the caller&#39;s call.</span>
<span class="line-modified"> 368   patch_callers_callsite(masm);</span>
<span class="line-modified"> 369 </span>
<span class="line-modified"> 370   __ bind(skip_fixup);</span>
<span class="line-modified"> 371 </span>
<span class="line-modified"> 372   int words_pushed = 0;</span>
<span class="line-modified"> 373 </span>
<span class="line-modified"> 374   // Since all args are passed on the stack, total_args_passed *</span>
<span class="line-modified"> 375   // Interpreter::stackElementSize is the space we need.</span>























 376 
<span class="line-modified"> 377   int extraspace = total_args_passed * Interpreter::stackElementSize;</span>

 378 
<span class="line-modified"> 379   __ mov(r13, sp);</span>
<span class="line-removed"> 380 </span>
<span class="line-removed"> 381   // stack is aligned, keep it that way</span>
 382   extraspace = align_up(extraspace, 2*wordSize);
 383 
<span class="line-modified"> 384   if (extraspace)</span>
<span class="line-removed"> 385     __ sub(sp, sp, extraspace);</span>
<span class="line-removed"> 386 </span>
<span class="line-removed"> 387   // Now write the args into the outgoing interpreter space</span>
<span class="line-removed"> 388   for (int i = 0; i &lt; total_args_passed; i++) {</span>
<span class="line-removed"> 389     if (sig_bt[i] == T_VOID) {</span>
<span class="line-removed"> 390       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);</span>
<span class="line-removed"> 391       continue;</span>
<span class="line-removed"> 392     }</span>
<span class="line-removed"> 393 </span>
<span class="line-removed"> 394     // offset to start parameters</span>
<span class="line-removed"> 395     int st_off   = (total_args_passed - i - 1) * Interpreter::stackElementSize;</span>
<span class="line-removed"> 396     int next_off = st_off - Interpreter::stackElementSize;</span>
 397 
 398     // Say 4 args:
 399     // i   st_off
 400     // 0   32 T_LONG
 401     // 1   24 T_VOID
 402     // 2   16 T_OBJECT
 403     // 3    8 T_BOOL
 404     // -    0 return address
 405     //
 406     // However to make thing extra confusing. Because we can fit a long/double in
 407     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 408     // leaves one slot empty and only stores to a single slot. In this case the
 409     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 410 
<span class="line-modified"> 411     VMReg r_1 = regs[i].first();</span>
<span class="line-modified"> 412     VMReg r_2 = regs[i].second();</span>



 413     if (!r_1-&gt;is_valid()) {
 414       assert(!r_2-&gt;is_valid(), &quot;&quot;);
<span class="line-modified"> 415       continue;</span>
 416     }

 417     if (r_1-&gt;is_stack()) {
 418       // memory to memory use rscratch1
<span class="line-modified"> 419       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size</span>
<span class="line-modified"> 420                     + extraspace</span>
<span class="line-removed"> 421                     + words_pushed * wordSize);</span>
 422       if (!r_2-&gt;is_valid()) {
 423         // sign extend??
 424         __ ldrw(rscratch1, Address(sp, ld_off));
<span class="line-modified"> 425         __ str(rscratch1, Address(sp, st_off));</span>
 426 
 427       } else {
<span class="line-modified"> 428 </span>
<span class="line-removed"> 429         __ ldr(rscratch1, Address(sp, ld_off));</span>
<span class="line-removed"> 430 </span>
<span class="line-removed"> 431         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG</span>
<span class="line-removed"> 432         // T_DOUBLE and T_LONG use two slots in the interpreter</span>
<span class="line-removed"> 433         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {</span>
<span class="line-removed"> 434           // ld_off == LSW, ld_off+wordSize == MSW</span>
<span class="line-removed"> 435           // st_off == MSW, next_off == LSW</span>
<span class="line-removed"> 436           __ str(rscratch1, Address(sp, next_off));</span>
<span class="line-removed"> 437 #ifdef ASSERT</span>
<span class="line-removed"> 438           // Overwrite the unused slot with known junk</span>
<span class="line-removed"> 439           __ mov(rscratch1, 0xdeadffffdeadaaaaul);</span>
<span class="line-removed"> 440           __ str(rscratch1, Address(sp, st_off));</span>
<span class="line-removed"> 441 #endif /* ASSERT */</span>
<span class="line-removed"> 442         } else {</span>
<span class="line-removed"> 443           __ str(rscratch1, Address(sp, st_off));</span>
 444         }
 445       }
 446     } else if (r_1-&gt;is_Register()) {
 447       Register r = r_1-&gt;as_Register();
<span class="line-modified"> 448       if (!r_2-&gt;is_valid()) {</span>
<span class="line-removed"> 449         // must be only an int (or less ) so move only 32bits to slot</span>
<span class="line-removed"> 450         // why not sign extend??</span>
<span class="line-removed"> 451         __ str(r, Address(sp, st_off));</span>
<span class="line-removed"> 452       } else {</span>
<span class="line-removed"> 453         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG</span>
<span class="line-removed"> 454         // T_DOUBLE and T_LONG use two slots in the interpreter</span>
<span class="line-removed"> 455         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {</span>
<span class="line-removed"> 456           // long/double in gpr</span>
<span class="line-removed"> 457 #ifdef ASSERT</span>
<span class="line-removed"> 458           // Overwrite the unused slot with known junk</span>
<span class="line-removed"> 459           __ mov(rscratch1, 0xdeadffffdeadaaabul);</span>
<span class="line-removed"> 460           __ str(rscratch1, Address(sp, st_off));</span>
<span class="line-removed"> 461 #endif /* ASSERT */</span>
<span class="line-removed"> 462           __ str(r, Address(sp, next_off));</span>
<span class="line-removed"> 463         } else {</span>
<span class="line-removed"> 464           __ str(r, Address(sp, st_off));</span>
<span class="line-removed"> 465         }</span>
<span class="line-removed"> 466       }</span>
 467     } else {
 468       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 469       if (!r_2-&gt;is_valid()) {
 470         // only a float use just part of the slot
<span class="line-modified"> 471         __ strs(r_1-&gt;as_FloatRegister(), Address(sp, st_off));</span>
 472       } else {
<span class="line-modified"> 473 #ifdef ASSERT</span>
<span class="line-removed"> 474         // Overwrite the unused slot with known junk</span>
<span class="line-removed"> 475         __ mov(rscratch1, 0xdeadffffdeadaaacul);</span>
<span class="line-removed"> 476         __ str(rscratch1, Address(sp, st_off));</span>
<span class="line-removed"> 477 #endif /* ASSERT */</span>
<span class="line-removed"> 478         __ strd(r_1-&gt;as_FloatRegister(), Address(sp, next_off));</span>
 479       }
































































































































































 480     }







 481   }
 482 
 483   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 484 
 485   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 486   __ br(rscratch1);
 487 }
 488 

 489 
<span class="line-removed"> 490 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,</span>
<span class="line-removed"> 491                                     int total_args_passed,</span>
<span class="line-removed"> 492                                     int comp_args_on_stack,</span>
<span class="line-removed"> 493                                     const BasicType *sig_bt,</span>
<span class="line-removed"> 494                                     const VMRegPair *regs) {</span>
 495 
 496   // Note: r13 contains the senderSP on entry. We must preserve it since
 497   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 498   // code goes non-entrant while we get args ready.
 499 
 500   // In addition we use r13 to locate all the interpreter args because
 501   // we must align the stack to 16 bytes.
 502 
 503   // Adapters are frameless.
 504 
 505   // An i2c adapter is frameless because the *caller* frame, which is
 506   // interpreted, routinely repairs its own esp (from
 507   // interpreter_frame_last_sp), even if a callee has modified the
 508   // stack pointer.  It also recalculates and aligns sp.
 509 
 510   // A c2i adapter is frameless because the *callee* frame, which is
 511   // interpreted, routinely repairs its caller&#39;s sp (from sender_sp,
 512   // which is set up via the senderSP register).
 513 
 514   // In other words, if *either* the caller or callee is interpreted, we can
</pre>
<hr />
<pre>
 534       range_check(masm, rax, r11,
 535                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 536                   L_ok);
 537     if (StubRoutines::code1() != NULL)
 538       range_check(masm, rax, r11,
 539                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 540                   L_ok);
 541     if (StubRoutines::code2() != NULL)
 542       range_check(masm, rax, r11,
 543                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 544                   L_ok);
 545     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 546     __ block_comment(msg);
 547     __ stop(msg);
 548     __ bind(L_ok);
 549     __ block_comment(&quot;} verify_i2ce &quot;);
 550 #endif
 551   }
 552 
 553   // Cut-out for having no stack args.
<span class="line-modified"> 554   int comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;</span>
 555   if (comp_args_on_stack) {
<span class="line-modified"> 556     __ sub(rscratch1, sp, comp_words_on_stack * wordSize);</span>
<span class="line-modified"> 557     __ andr(sp, rscratch1, -16);</span>

 558   }
 559 
 560   // Will jump to the compiled code just as if compiled code was doing it.
 561   // Pre-load the register-jump target early, to schedule it better.
 562   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 563 
 564 #if INCLUDE_JVMCI
 565   if (EnableJVMCI || UseAOT) {
 566     // check if this call should be routed towards a specific entry point
 567     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 568     Label no_alternative_target;
 569     __ cbz(rscratch2, no_alternative_target);
 570     __ mov(rscratch1, rscratch2);
 571     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 572     __ bind(no_alternative_target);
 573   }
 574 #endif // INCLUDE_JVMCI
 575 


 576   // Now generate the shuffle code.
 577   for (int i = 0; i &lt; total_args_passed; i++) {
<span class="line-modified"> 578     if (sig_bt[i] == T_VOID) {</span>
<span class="line-modified"> 579       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);</span>



 580       continue;
 581     }
 582 
 583     // Pick up 0, 1 or 2 words from SP+offset.

 584 
<span class="line-modified"> 585     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),</span>
<span class="line-removed"> 586             &quot;scrambled load targets?&quot;);</span>
<span class="line-removed"> 587     // Load in argument order going down.</span>
 588     int ld_off = (total_args_passed - i - 1)*Interpreter::stackElementSize;
 589     // Point to interpreter value (vs. tag)
 590     int next_off = ld_off - Interpreter::stackElementSize;
 591     //
 592     //
 593     //
 594     VMReg r_1 = regs[i].first();
 595     VMReg r_2 = regs[i].second();
 596     if (!r_1-&gt;is_valid()) {
 597       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 598       continue;
 599     }
 600     if (r_1-&gt;is_stack()) {
 601       // Convert stack slot to an SP offset (+ wordSize to account for return address )
<span class="line-modified"> 602       int st_off = regs[i].first()-&gt;reg2stack()*VMRegImpl::stack_slot_size;</span>
 603       if (!r_2-&gt;is_valid()) {
 604         // sign extend???
 605         __ ldrsw(rscratch2, Address(esp, ld_off));
 606         __ str(rscratch2, Address(sp, st_off));
 607       } else {
 608         //
 609         // We are using two optoregs. This can be either T_OBJECT,
 610         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 611         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 612         // So we must adjust where to pick up the data to match the
 613         // interpreter.
 614         //
 615         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 616         // are accessed as negative so LSW is at LOW address
 617 
 618         // ld_off is MSW so get LSW
<span class="line-modified"> 619         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?</span>
<span class="line-removed"> 620                            next_off : ld_off;</span>
 621         __ ldr(rscratch2, Address(esp, offset));
 622         // st_off is LSW (i.e. reg.first())
<span class="line-modified"> 623         __ str(rscratch2, Address(sp, st_off));</span>
<span class="line-modified"> 624       }</span>
<span class="line-modified"> 625     } else if (r_1-&gt;is_Register()) {  // Register argument</span>
<span class="line-modified"> 626       Register r = r_1-&gt;as_Register();</span>
<span class="line-modified"> 627       if (r_2-&gt;is_valid()) {</span>
<span class="line-modified"> 628         //</span>
<span class="line-modified"> 629         // We are using two VMRegs. This can be either T_OBJECT,</span>
<span class="line-modified"> 630         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates</span>
<span class="line-modified"> 631         // two slots but only uses one for thr T_LONG or T_DOUBLE case</span>
<span class="line-modified"> 632         // So we must adjust where to pick up the data to match the</span>
<span class="line-modified"> 633         // interpreter.</span>

















 634 
<span class="line-removed"> 635         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?</span>
<span class="line-removed"> 636                            next_off : ld_off;</span>
<span class="line-removed"> 637 </span>
<span class="line-removed"> 638         // this can be a misaligned move</span>
<span class="line-removed"> 639         __ ldr(r, Address(esp, offset));</span>
<span class="line-removed"> 640       } else {</span>
<span class="line-removed"> 641         // sign extend and use a full word?</span>
<span class="line-removed"> 642         __ ldrw(r, Address(esp, ld_off));</span>
<span class="line-removed"> 643       }</span>
<span class="line-removed"> 644     } else {</span>
<span class="line-removed"> 645       if (!r_2-&gt;is_valid()) {</span>
<span class="line-removed"> 646         __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));</span>
<span class="line-removed"> 647       } else {</span>
<span class="line-removed"> 648         __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));</span>
<span class="line-removed"> 649       }</span>
<span class="line-removed"> 650     }</span>
<span class="line-removed"> 651   }</span>
 652 
 653   // 6243940 We might end up in handle_wrong_method if
 654   // the callee is deoptimized as we race thru here. If that
 655   // happens we don&#39;t want to take a safepoint because the
 656   // caller frame will look interpreted and arguments are now
 657   // &quot;compiled&quot; so it is much better to make this transition
 658   // invisible to the stack walking code. Unfortunately if
 659   // we try and find the callee by normal means a safepoint
 660   // is possible. So we stash the desired callee in the thread
 661   // and the vm will find there should this case occur.
 662 
 663   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));
<span class="line-removed"> 664 </span>
 665   __ br(rscratch1);
 666 }
 667 
<span class="line-modified"> 668 // ---------------------------------------------------------------</span>
<span class="line-removed"> 669 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,</span>
<span class="line-removed"> 670                                                             int total_args_passed,</span>
<span class="line-removed"> 671                                                             int comp_args_on_stack,</span>
<span class="line-removed"> 672                                                             const BasicType *sig_bt,</span>
<span class="line-removed"> 673                                                             const VMRegPair *regs,</span>
<span class="line-removed"> 674                                                             AdapterFingerPrint* fingerprint) {</span>
<span class="line-removed"> 675   address i2c_entry = __ pc();</span>
<span class="line-removed"> 676 </span>
<span class="line-removed"> 677   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);</span>
<span class="line-removed"> 678 </span>
<span class="line-removed"> 679   address c2i_unverified_entry = __ pc();</span>
<span class="line-removed"> 680   Label skip_fixup;</span>
 681 
 682   Label ok;
 683 
 684   Register holder = rscratch2;
 685   Register receiver = j_rarg0;
 686   Register tmp = r10;  // A call-clobbered register not used for arg passing
 687 
 688   // -------------------------------------------------------------------------
 689   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 690   // to the interpreter.  The args start out packed in the compiled layout.  They
 691   // need to be unpacked into the interpreter layout.  This will almost always
 692   // require some stack space.  We grow the current (compiled) stack, then repack
 693   // the args.  We  finally end in a jump to the generic interpreter entry point.
 694   // On exit from the interpreter, the interpreter will restore our SP (lest the
 695   // compiled code, which relys solely on SP and not FP, get sick).
 696 
 697   {
 698     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 699     __ load_klass(rscratch1, receiver);
 700     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 701     __ cmp(rscratch1, tmp);
 702     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 703     __ br(Assembler::EQ, ok);
 704     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 705 
 706     __ bind(ok);
 707     // Method might have been compiled since the call site was patched to
 708     // interpreted; if that is the case treat it as a miss so we can get
 709     // the call site corrected.
 710     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 711     __ cbz(rscratch1, skip_fixup);
 712     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 713     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 714   }


































 715 

 716   address c2i_entry = __ pc();
 717 
 718   // Class initialization barrier for static methods
 719   address c2i_no_clinit_check_entry = NULL;

 720   if (VM_Version::supports_fast_class_init_checks()) {
 721     Label L_skip_barrier;
<span class="line-modified"> 722 </span>
<span class="line-modified"> 723     { // Bypass the barrier for non-static methods</span>
<span class="line-modified"> 724       __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));</span>
<span class="line-modified"> 725       __ andsw(zr, rscratch1, JVM_ACC_STATIC);</span>
 726       __ br(Assembler::EQ, L_skip_barrier); // non-static
 727     }
 728 
<span class="line-modified"> 729     __ load_method_holder(rscratch2, rmethod);</span>
<span class="line-modified"> 730     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);</span>
<span class="line-modified"> 731     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>



 732 
 733     __ bind(L_skip_barrier);
 734     c2i_no_clinit_check_entry = __ pc();
 735   }
 736 
 737   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 738   bs-&gt;c2i_entry_barrier(masm);
 739 
 740   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 741 














 742   __ flush();
<span class="line-modified"> 743   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>







 744 }
 745 
 746 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 747                                          VMRegPair *regs,
 748                                          VMRegPair *regs2,
 749                                          int total_args_passed) {
 750   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
 751 
 752 // We return the amount of VMRegImpl stack slots we need to reserve for all
 753 // the arguments NOT counting out_preserve_stack_slots.
 754 
 755     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
 756       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
 757     };
 758     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
 759       c_farg0, c_farg1, c_farg2, c_farg3,
 760       c_farg4, c_farg5, c_farg6, c_farg7
 761     };
 762 
 763     uint int_args = 0;
</pre>
<hr />
<pre>
 766 
 767     for (int i = 0; i &lt; total_args_passed; i++) {
 768       switch (sig_bt[i]) {
 769       case T_BOOLEAN:
 770       case T_CHAR:
 771       case T_BYTE:
 772       case T_SHORT:
 773       case T_INT:
 774         if (int_args &lt; Argument::n_int_register_parameters_c) {
 775           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 776         } else {
 777           regs[i].set1(VMRegImpl::stack2reg(stk_args));
 778           stk_args += 2;
 779         }
 780         break;
 781       case T_LONG:
 782         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 783         // fall through
 784       case T_OBJECT:
 785       case T_ARRAY:

 786       case T_ADDRESS:
 787       case T_METADATA:
 788         if (int_args &lt; Argument::n_int_register_parameters_c) {
 789           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 790         } else {
 791           regs[i].set2(VMRegImpl::stack2reg(stk_args));
 792           stk_args += 2;
 793         }
 794         break;
 795       case T_FLOAT:
 796         if (fp_args &lt; Argument::n_float_register_parameters_c) {
 797           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 798         } else {
 799           regs[i].set1(VMRegImpl::stack2reg(stk_args));
 800           stk_args += 2;
 801         }
 802         break;
 803       case T_DOUBLE:
 804         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 805         if (fp_args &lt; Argument::n_float_register_parameters_c) {
</pre>
<hr />
<pre>
1617       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1618     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1619       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1620     }
1621 #endif /* ASSERT */
1622     switch (in_sig_bt[i]) {
1623       case T_ARRAY:
1624         if (is_critical_native) {
1625           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1626           c_arg++;
1627 #ifdef ASSERT
1628           if (out_regs[c_arg].first()-&gt;is_Register()) {
1629             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1630           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1631             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1632           }
1633 #endif
1634           int_args++;
1635           break;
1636         }

1637       case T_OBJECT:
1638         assert(!is_critical_native, &quot;no oop arguments&quot;);
1639         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1640                     ((i == 0) &amp;&amp; (!is_static)),
1641                     &amp;receiver_offset);
1642         int_args++;
1643         break;
1644       case T_VOID:
1645         break;
1646 
1647       case T_FLOAT:
1648         float_move(masm, in_regs[i], out_regs[c_arg]);
1649         float_args++;
1650         break;
1651 
1652       case T_DOUBLE:
1653         assert( i + 1 &lt; total_in_args &amp;&amp;
1654                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1655                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1656         double_move(masm, in_regs[i], out_regs[c_arg]);
</pre>
<hr />
<pre>
1804 
1805   rt_call(masm, native_func);
1806 
1807   __ bind(native_return);
1808 
1809   intptr_t return_pc = (intptr_t) __ pc();
1810   oop_maps-&gt;add_gc_map(return_pc - start, map);
1811 
1812   // Unpack native results.
1813   switch (ret_type) {
1814   case T_BOOLEAN: __ c2bool(r0);                     break;
1815   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
1816   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
1817   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
1818   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
1819   case T_DOUBLE :
1820   case T_FLOAT  :
1821     // Result is in v0 we&#39;ll save as needed
1822     break;
1823   case T_ARRAY:                 // Really a handle

1824   case T_OBJECT:                // Really a handle
1825       break; // can&#39;t de-handlize until after safepoint check
1826   case T_VOID: break;
1827   case T_LONG: break;
1828   default       : ShouldNotReachHere();
1829   }
1830 
1831   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
1832   // This additional state is necessary because reading and testing the synchronization
1833   // state is not atomic w.r.t. GC, as this scenario demonstrates:
1834   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
1835   //     VM thread changes sync state to synchronizing and suspends threads for GC.
1836   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
1837   //     didn&#39;t see any synchronization is progress, and escapes.
1838   __ mov(rscratch1, _thread_in_native_trans);
1839 
1840   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
1841 
1842   // Force this write out before the read below
1843   __ dmb(Assembler::ISH);
</pre>
<hr />
<pre>
3029 #ifdef ASSERT
3030   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3031   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3032 #endif
3033   // Clear the exception oop so GC no longer processes it as a root.
3034   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3035 
3036   // r0: exception oop
3037   // r8:  exception handler
3038   // r4: exception pc
3039   // Jump to handler
3040 
3041   __ br(r8);
3042 
3043   // Make sure all code is generated
3044   masm-&gt;flush();
3045 
3046   // Set exception blob
3047   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3048 }









































































































3049 #endif // COMPILER2
</pre>
</td>
<td>
<hr />
<pre>
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
<span class="line-added">  29 #include &quot;classfile/symbolTable.hpp&quot;</span>
  30 #include &quot;code/codeCache.hpp&quot;
  31 #include &quot;code/debugInfoRec.hpp&quot;
  32 #include &quot;code/icBuffer.hpp&quot;
  33 #include &quot;code/vtableStubs.hpp&quot;
  34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  35 #include &quot;interpreter/interpreter.hpp&quot;
  36 #include &quot;interpreter/interp_masm.hpp&quot;
  37 #include &quot;logging/log.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;nativeInst_aarch64.hpp&quot;
  40 #include &quot;oops/compiledICHolder.hpp&quot;
  41 #include &quot;oops/klass.inline.hpp&quot;
  42 #include &quot;runtime/safepointMechanism.hpp&quot;
  43 #include &quot;runtime/sharedRuntime.hpp&quot;
  44 #include &quot;runtime/vframeArray.hpp&quot;
  45 #include &quot;utilities/align.hpp&quot;
  46 #include &quot;vmreg_aarch64.inline.hpp&quot;
  47 #ifdef COMPILER1
  48 #include &quot;c1/c1_Runtime1.hpp&quot;
  49 #endif
</pre>
<hr />
<pre>
 275     case T_SHORT:
 276     case T_INT:
 277       if (int_args &lt; Argument::n_int_register_parameters_j) {
 278         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 279       } else {
 280         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 281         stk_args += 2;
 282       }
 283       break;
 284     case T_VOID:
 285       // halves of T_LONG or T_DOUBLE
 286       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 287       regs[i].set_bad();
 288       break;
 289     case T_LONG:
 290       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 291       // fall through
 292     case T_OBJECT:
 293     case T_ARRAY:
 294     case T_ADDRESS:
<span class="line-added"> 295     case T_INLINE_TYPE:</span>
 296       if (int_args &lt; Argument::n_int_register_parameters_j) {
 297         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 298       } else {
 299         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 300         stk_args += 2;
 301       }
 302       break;
 303     case T_FLOAT:
 304       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 305         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 306       } else {
 307         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 308         stk_args += 2;
 309       }
 310       break;
 311     case T_DOUBLE:
 312       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 313       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 314         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 315       } else {
 316         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 317         stk_args += 2;
 318       }
 319       break;
 320     default:
 321       ShouldNotReachHere();
 322       break;
 323     }
 324   }
 325 
 326   return align_up(stk_args, 2);
 327 }
 328 
<span class="line-added"> 329 </span>
<span class="line-added"> 330 // const uint SharedRuntime::java_return_convention_max_int = Argument::n_int_register_parameters_j+1;</span>
<span class="line-added"> 331 const uint SharedRuntime::java_return_convention_max_int = 6;</span>
<span class="line-added"> 332 const uint SharedRuntime::java_return_convention_max_float = Argument::n_float_register_parameters_j;</span>
<span class="line-added"> 333 </span>
<span class="line-added"> 334 int SharedRuntime::java_return_convention(const BasicType *sig_bt, VMRegPair *regs, int total_args_passed) {</span>
<span class="line-added"> 335 </span>
<span class="line-added"> 336   // Create the mapping between argument positions and</span>
<span class="line-added"> 337   // registers.</span>
<span class="line-added"> 338   // r1, r2 used to address klasses and states, exclude it from return convention to avoid colision</span>
<span class="line-added"> 339 </span>
<span class="line-added"> 340   static const Register INT_ArgReg[java_return_convention_max_int] = {</span>
<span class="line-added"> 341      r0 /* j_rarg7 */, j_rarg6, j_rarg5, j_rarg4, j_rarg3, j_rarg2</span>
<span class="line-added"> 342   };</span>
<span class="line-added"> 343 </span>
<span class="line-added"> 344   static const FloatRegister FP_ArgReg[java_return_convention_max_float] = {</span>
<span class="line-added"> 345     j_farg0, j_farg1, j_farg2, j_farg3, j_farg4, j_farg5, j_farg6, j_farg7</span>
<span class="line-added"> 346   };</span>
<span class="line-added"> 347 </span>
<span class="line-added"> 348   uint int_args = 0;</span>
<span class="line-added"> 349   uint fp_args = 0;</span>
<span class="line-added"> 350 </span>
<span class="line-added"> 351   for (int i = 0; i &lt; total_args_passed; i++) {</span>
<span class="line-added"> 352     switch (sig_bt[i]) {</span>
<span class="line-added"> 353     case T_BOOLEAN:</span>
<span class="line-added"> 354     case T_CHAR:</span>
<span class="line-added"> 355     case T_BYTE:</span>
<span class="line-added"> 356     case T_SHORT:</span>
<span class="line-added"> 357     case T_INT:</span>
<span class="line-added"> 358       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {</span>
<span class="line-added"> 359         regs[i].set1(INT_ArgReg[int_args]-&gt;as_VMReg());</span>
<span class="line-added"> 360         int_args ++;</span>
<span class="line-added"> 361       } else {</span>
<span class="line-added"> 362         // Should we have gurantee here?</span>
<span class="line-added"> 363         return -1;</span>
<span class="line-added"> 364       }</span>
<span class="line-added"> 365       break;</span>
<span class="line-added"> 366     case T_VOID:</span>
<span class="line-added"> 367       // halves of T_LONG or T_DOUBLE</span>
<span class="line-added"> 368       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);</span>
<span class="line-added"> 369       regs[i].set_bad();</span>
<span class="line-added"> 370       break;</span>
<span class="line-added"> 371     case T_LONG:</span>
<span class="line-added"> 372       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);</span>
<span class="line-added"> 373       // fall through</span>
<span class="line-added"> 374     case T_OBJECT:</span>
<span class="line-added"> 375     case T_ARRAY:</span>
<span class="line-added"> 376     case T_ADDRESS:</span>
<span class="line-added"> 377       // Should T_METADATA be added to java_calling_convention as well ?</span>
<span class="line-added"> 378     case T_METADATA:</span>
<span class="line-added"> 379     case T_INLINE_TYPE:</span>
<span class="line-added"> 380       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {</span>
<span class="line-added"> 381         regs[i].set2(INT_ArgReg[int_args]-&gt;as_VMReg());</span>
<span class="line-added"> 382         int_args ++;</span>
<span class="line-added"> 383       } else {</span>
<span class="line-added"> 384         return -1;</span>
<span class="line-added"> 385       }</span>
<span class="line-added"> 386       break;</span>
<span class="line-added"> 387     case T_FLOAT:</span>
<span class="line-added"> 388       if (fp_args &lt; SharedRuntime::java_return_convention_max_float) {</span>
<span class="line-added"> 389         regs[i].set1(FP_ArgReg[fp_args]-&gt;as_VMReg());</span>
<span class="line-added"> 390         fp_args ++;</span>
<span class="line-added"> 391       } else {</span>
<span class="line-added"> 392         return -1;</span>
<span class="line-added"> 393       }</span>
<span class="line-added"> 394       break;</span>
<span class="line-added"> 395     case T_DOUBLE:</span>
<span class="line-added"> 396       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);</span>
<span class="line-added"> 397       if (fp_args &lt; Argument::n_float_register_parameters_j) {</span>
<span class="line-added"> 398         regs[i].set2(FP_ArgReg[fp_args]-&gt;as_VMReg());</span>
<span class="line-added"> 399         fp_args ++;</span>
<span class="line-added"> 400       } else {</span>
<span class="line-added"> 401         return -1;</span>
<span class="line-added"> 402       }</span>
<span class="line-added"> 403       break;</span>
<span class="line-added"> 404     default:</span>
<span class="line-added"> 405       ShouldNotReachHere();</span>
<span class="line-added"> 406       break;</span>
<span class="line-added"> 407     }</span>
<span class="line-added"> 408   }</span>
<span class="line-added"> 409 </span>
<span class="line-added"> 410   return int_args + fp_args;</span>
<span class="line-added"> 411 }</span>
<span class="line-added"> 412 </span>
 413 // Patch the callers callsite with entry to compiled code if it exists.
 414 static void patch_callers_callsite(MacroAssembler *masm) {
 415   Label L;
 416   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 417   __ cbz(rscratch1, L);
 418 
 419   __ enter();
 420   __ push_CPU_state();
 421 
 422   // VM needs caller&#39;s callsite
 423   // VM needs target method
 424   // This needs to be a long call since we will relocate this adapter to
 425   // the codeBuffer and it may not reach
 426 
 427 #ifndef PRODUCT
 428   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 429 #endif
 430 
 431   __ mov(c_rarg0, rmethod);
 432   __ mov(c_rarg1, lr);
 433   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 434   __ blr(rscratch1);
 435   __ maybe_isb();
 436 
 437   __ pop_CPU_state();
 438   // restore sp
 439   __ leave();
 440   __ bind(L);
 441 }
 442 
<span class="line-modified"> 443 // For each inline type argument, sig includes the list of fields of</span>
<span class="line-modified"> 444 // the inline type. This utility function computes the number of</span>
<span class="line-modified"> 445 // arguments for the call if inline types are passed by reference (the</span>
<span class="line-modified"> 446 // calling convention the interpreter expects).</span>
<span class="line-modified"> 447 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {</span>
<span class="line-modified"> 448   int total_args_passed = 0;</span>
<span class="line-modified"> 449   if (InlineTypePassFieldsAsArgs) {</span>
<span class="line-modified"> 450      for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {</span>
<span class="line-modified"> 451        BasicType bt = sig_extended-&gt;at(i)._bt;</span>
<span class="line-modified"> 452        if (SigEntry::is_reserved_entry(sig_extended, i)) {</span>
<span class="line-modified"> 453          // Ignore reserved entry</span>
<span class="line-modified"> 454        } else if (bt == T_INLINE_TYPE) {</span>
<span class="line-modified"> 455          // In sig_extended, an inline type argument starts with:</span>
<span class="line-modified"> 456          // T_INLINE_TYPE, followed by the types of the fields of the</span>
<span class="line-modified"> 457          // inline type and T_VOID to mark the end of the value</span>
<span class="line-modified"> 458          // type. Inline types are flattened so, for instance, in the</span>
<span class="line-modified"> 459          // case of an inline type with an int field and an inline type</span>
<span class="line-modified"> 460          // field that itself has 2 fields, an int and a long:</span>
<span class="line-modified"> 461          // T_INLINE_TYPE T_INT T_INLINE_TYPE T_INT T_LONG T_VOID (second</span>
<span class="line-added"> 462          // slot for the T_LONG) T_VOID (inner T_INLINE_TYPE) T_VOID</span>
<span class="line-added"> 463          // (outer T_INLINE_TYPE)</span>
<span class="line-added"> 464          total_args_passed++;</span>
<span class="line-added"> 465          int vt = 1;</span>
<span class="line-added"> 466          do {</span>
<span class="line-added"> 467            i++;</span>
<span class="line-added"> 468            BasicType bt = sig_extended-&gt;at(i)._bt;</span>
<span class="line-added"> 469            BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;</span>
<span class="line-added"> 470            if (bt == T_INLINE_TYPE) {</span>
<span class="line-added"> 471              vt++;</span>
<span class="line-added"> 472            } else if (bt == T_VOID &amp;&amp;</span>
<span class="line-added"> 473                       prev_bt != T_LONG &amp;&amp;</span>
<span class="line-added"> 474                       prev_bt != T_DOUBLE) {</span>
<span class="line-added"> 475              vt--;</span>
<span class="line-added"> 476            }</span>
<span class="line-added"> 477          } while (vt != 0);</span>
<span class="line-added"> 478        } else {</span>
<span class="line-added"> 479          total_args_passed++;</span>
<span class="line-added"> 480        }</span>
<span class="line-added"> 481      }</span>
<span class="line-added"> 482   } else {</span>
<span class="line-added"> 483     total_args_passed = sig_extended-&gt;length();</span>
<span class="line-added"> 484   }</span>
 485 
<span class="line-modified"> 486   return total_args_passed;</span>
<span class="line-added"> 487 }</span>
 488 
<span class="line-modified"> 489 </span>


 490 static void gen_c2i_adapter_helper(MacroAssembler* masm, BasicType bt, const VMRegPair&amp; reg_pair, int extraspace, const Address&amp; to) {
 491 
<span class="line-modified"> 492     assert(bt != T_INLINE_TYPE || !InlineTypePassFieldsAsArgs, &quot;no inline type here&quot;);</span>












 493 
 494     // Say 4 args:
 495     // i   st_off
 496     // 0   32 T_LONG
 497     // 1   24 T_VOID
 498     // 2   16 T_OBJECT
 499     // 3    8 T_BOOL
 500     // -    0 return address
 501     //
 502     // However to make thing extra confusing. Because we can fit a long/double in
 503     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 504     // leaves one slot empty and only stores to a single slot. In this case the
 505     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 506 
<span class="line-modified"> 507     // int next_off = st_off - Interpreter::stackElementSize;</span>
<span class="line-modified"> 508 </span>
<span class="line-added"> 509     VMReg r_1 = reg_pair.first();</span>
<span class="line-added"> 510     VMReg r_2 = reg_pair.second();</span>
<span class="line-added"> 511 </span>
 512     if (!r_1-&gt;is_valid()) {
 513       assert(!r_2-&gt;is_valid(), &quot;&quot;);
<span class="line-modified"> 514       return;</span>
 515     }
<span class="line-added"> 516 </span>
 517     if (r_1-&gt;is_stack()) {
 518       // memory to memory use rscratch1
<span class="line-modified"> 519       // words_pushed is always 0 so we don&#39;t use it.</span>
<span class="line-modified"> 520       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extraspace /* + word_pushed * wordSize */);</span>

 521       if (!r_2-&gt;is_valid()) {
 522         // sign extend??
 523         __ ldrw(rscratch1, Address(sp, ld_off));
<span class="line-modified"> 524         __ str(rscratch1, to);</span>
 525 
 526       } else {
<span class="line-modified"> 527         __ ldr(rscratch1, Address(sp, ld_off));</span>















 528         __ str(rscratch1, to);
 529       }
 530     } else if (r_1-&gt;is_Register()) {
 531       Register r = r_1-&gt;as_Register();
<span class="line-modified"> 532       __ str(r, to);</span>


















 533     } else {
 534       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 535       if (!r_2-&gt;is_valid()) {
 536         // only a float use just part of the slot
<span class="line-modified"> 537         __ strs(r_1-&gt;as_FloatRegister(), to);</span>
 538       } else {
<span class="line-modified"> 539         __ strd(r_1-&gt;as_FloatRegister(), to);</span>





 540       }
<span class="line-added"> 541    }</span>
<span class="line-added"> 542 }</span>
<span class="line-added"> 543 </span>
<span class="line-added"> 544 static void gen_c2i_adapter(MacroAssembler *masm,</span>
<span class="line-added"> 545                             const GrowableArray&lt;SigEntry&gt;* sig_extended,</span>
<span class="line-added"> 546                             const VMRegPair *regs,</span>
<span class="line-added"> 547                             Label&amp; skip_fixup,</span>
<span class="line-added"> 548                             address start,</span>
<span class="line-added"> 549                             OopMapSet* oop_maps,</span>
<span class="line-added"> 550                             int&amp; frame_complete,</span>
<span class="line-added"> 551                             int&amp; frame_size_in_words,</span>
<span class="line-added"> 552                             bool alloc_inline_receiver) {</span>
<span class="line-added"> 553 </span>
<span class="line-added"> 554   // Before we get into the guts of the C2I adapter, see if we should be here</span>
<span class="line-added"> 555   // at all.  We&#39;ve come from compiled code and are attempting to jump to the</span>
<span class="line-added"> 556   // interpreter, which means the caller made a static call to get here</span>
<span class="line-added"> 557   // (vcalls always get a compiled target if there is one).  Check for a</span>
<span class="line-added"> 558   // compiled target.  If there is one, we need to patch the caller&#39;s call.</span>
<span class="line-added"> 559   patch_callers_callsite(masm);</span>
<span class="line-added"> 560 </span>
<span class="line-added"> 561   __ bind(skip_fixup);</span>
<span class="line-added"> 562 </span>
<span class="line-added"> 563   bool has_inline_argument = false;</span>
<span class="line-added"> 564 </span>
<span class="line-added"> 565   if (InlineTypePassFieldsAsArgs) {</span>
<span class="line-added"> 566       // Is there an inline type argument?</span>
<span class="line-added"> 567      for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_inline_argument; i++) {</span>
<span class="line-added"> 568        has_inline_argument = (sig_extended-&gt;at(i)._bt == T_INLINE_TYPE);</span>
<span class="line-added"> 569      }</span>
<span class="line-added"> 570      if (has_inline_argument) {</span>
<span class="line-added"> 571       // There is at least an inline type argument: we&#39;re coming from</span>
<span class="line-added"> 572       // compiled code so we have no buffers to back the inline types</span>
<span class="line-added"> 573       // Allocate the buffers here with a runtime call.</span>
<span class="line-added"> 574       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);</span>
<span class="line-added"> 575 </span>
<span class="line-added"> 576       frame_complete = __ offset();</span>
<span class="line-added"> 577       address the_pc = __ pc();</span>
<span class="line-added"> 578 </span>
<span class="line-added"> 579       __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);</span>
<span class="line-added"> 580 </span>
<span class="line-added"> 581       __ mov(c_rarg0, rthread);</span>
<span class="line-added"> 582       __ mov(c_rarg1, r1);</span>
<span class="line-added"> 583       __ mov(c_rarg2, (int64_t)alloc_inline_receiver);</span>
<span class="line-added"> 584 </span>
<span class="line-added"> 585       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_inline_types)));</span>
<span class="line-added"> 586       __ blr(rscratch1);</span>
<span class="line-added"> 587 </span>
<span class="line-added"> 588       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);</span>
<span class="line-added"> 589       __ reset_last_Java_frame(false);</span>
<span class="line-added"> 590 </span>
<span class="line-added"> 591       RegisterSaver::restore_live_registers(masm);</span>
<span class="line-added"> 592 </span>
<span class="line-added"> 593       Label no_exception;</span>
<span class="line-added"> 594       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));</span>
<span class="line-added"> 595       __ cbz(r0, no_exception);</span>
<span class="line-added"> 596 </span>
<span class="line-added"> 597       __ str(zr, Address(rthread, JavaThread::vm_result_offset()));</span>
<span class="line-added"> 598       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));</span>
<span class="line-added"> 599       __ b(RuntimeAddress(StubRoutines::forward_exception_entry()));</span>
<span class="line-added"> 600 </span>
<span class="line-added"> 601       __ bind(no_exception);</span>
<span class="line-added"> 602 </span>
<span class="line-added"> 603       // We get an array of objects from the runtime call</span>
<span class="line-added"> 604       __ get_vm_result(r10, rthread);</span>
<span class="line-added"> 605       __ get_vm_result_2(r1, rthread); // TODO: required to keep the callee Method live?</span>
<span class="line-added"> 606     }</span>
<span class="line-added"> 607   }</span>
<span class="line-added"> 608 </span>
<span class="line-added"> 609   int words_pushed = 0;</span>
<span class="line-added"> 610 </span>
<span class="line-added"> 611   // Since all args are passed on the stack, total_args_passed *</span>
<span class="line-added"> 612   // Interpreter::stackElementSize is the space we need.</span>
<span class="line-added"> 613 </span>
<span class="line-added"> 614   int total_args_passed = compute_total_args_passed_int(sig_extended);</span>
<span class="line-added"> 615   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;</span>
<span class="line-added"> 616 </span>
<span class="line-added"> 617   // stack is aligned, keep it that way</span>
<span class="line-added"> 618   extraspace = align_up(extraspace, 2 * wordSize);</span>
<span class="line-added"> 619 </span>
<span class="line-added"> 620   __ mov(r13, sp);</span>
<span class="line-added"> 621 </span>
<span class="line-added"> 622   if (extraspace)</span>
<span class="line-added"> 623     __ sub(sp, sp, extraspace);</span>
<span class="line-added"> 624 </span>
<span class="line-added"> 625   // Now write the args into the outgoing interpreter space</span>
<span class="line-added"> 626 </span>
<span class="line-added"> 627   int ignored = 0, next_vt_arg = 0, next_arg_int = 0;</span>
<span class="line-added"> 628   bool has_oop_field = false;</span>
<span class="line-added"> 629 </span>
<span class="line-added"> 630   for (int next_arg_comp = 0; next_arg_comp &lt; total_args_passed; next_arg_comp++) {</span>
<span class="line-added"> 631     BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;</span>
<span class="line-added"> 632     // offset to start parameters</span>
<span class="line-added"> 633     int st_off   = (total_args_passed - next_arg_int - 1) * Interpreter::stackElementSize;</span>
<span class="line-added"> 634 </span>
<span class="line-added"> 635     if (!InlineTypePassFieldsAsArgs || bt != T_INLINE_TYPE) {</span>
<span class="line-added"> 636 </span>
<span class="line-added"> 637             if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {</span>
<span class="line-added"> 638                continue; // Ignore reserved entry</span>
<span class="line-added"> 639             }</span>
<span class="line-added"> 640 </span>
<span class="line-added"> 641             if (bt == T_VOID) {</span>
<span class="line-added"> 642                assert(next_arg_comp &gt; 0 &amp;&amp; (sig_extended-&gt;at(next_arg_comp - 1)._bt == T_LONG || sig_extended-&gt;at(next_arg_comp - 1)._bt == T_DOUBLE), &quot;missing half&quot;);</span>
<span class="line-added"> 643                next_arg_int ++;</span>
<span class="line-added"> 644                continue;</span>
<span class="line-added"> 645              }</span>
<span class="line-added"> 646 </span>
<span class="line-added"> 647              int next_off = st_off - Interpreter::stackElementSize;</span>
<span class="line-added"> 648              int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;</span>
<span class="line-added"> 649 </span>
<span class="line-added"> 650              gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp], extraspace, Address(sp, offset));</span>
<span class="line-added"> 651              next_arg_int ++;</span>
<span class="line-added"> 652    } else {</span>
<span class="line-added"> 653        ignored++;</span>
<span class="line-added"> 654       // get the buffer from the just allocated pool of buffers</span>
<span class="line-added"> 655       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_INLINE_TYPE);</span>
<span class="line-added"> 656       __ load_heap_oop(rscratch1, Address(r10, index));</span>
<span class="line-added"> 657       next_vt_arg++;</span>
<span class="line-added"> 658       next_arg_int++;</span>
<span class="line-added"> 659       int vt = 1;</span>
<span class="line-added"> 660       // write fields we get from compiled code in registers/stack</span>
<span class="line-added"> 661       // slots to the buffer: we know we are done with that inline type</span>
<span class="line-added"> 662       // argument when we hit the T_VOID that acts as an end of value</span>
<span class="line-added"> 663       // type delimiter for this inline type. Inline types are flattened</span>
<span class="line-added"> 664       // so we might encounter embedded inline types. Each entry in</span>
<span class="line-added"> 665       // sig_extended contains a field offset in the buffer.</span>
<span class="line-added"> 666       do {</span>
<span class="line-added"> 667         next_arg_comp++;</span>
<span class="line-added"> 668         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;</span>
<span class="line-added"> 669         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp - 1)._bt;</span>
<span class="line-added"> 670         if (bt == T_INLINE_TYPE) {</span>
<span class="line-added"> 671           vt++;</span>
<span class="line-added"> 672           ignored++;</span>
<span class="line-added"> 673         } else if (bt == T_VOID &amp;&amp; prev_bt != T_LONG &amp;&amp; prev_bt != T_DOUBLE) {</span>
<span class="line-added"> 674           vt--;</span>
<span class="line-added"> 675           ignored++;</span>
<span class="line-added"> 676         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {</span>
<span class="line-added"> 677           // Ignore reserved entry</span>
<span class="line-added"> 678         } else {</span>
<span class="line-added"> 679           int off = sig_extended-&gt;at(next_arg_comp)._offset;</span>
<span class="line-added"> 680           assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="line-added"> 681 </span>
<span class="line-added"> 682           bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);</span>
<span class="line-added"> 683           has_oop_field = has_oop_field || is_oop;</span>
<span class="line-added"> 684 </span>
<span class="line-added"> 685           gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp - ignored], extraspace, Address(r11, off));</span>
<span class="line-added"> 686         }</span>
<span class="line-added"> 687       } while (vt != 0);</span>
<span class="line-added"> 688       // pass the buffer to the interpreter</span>
<span class="line-added"> 689       __ str(rscratch1, Address(sp, st_off));</span>
<span class="line-added"> 690    }</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692   }</span>
<span class="line-added"> 693 </span>
<span class="line-added"> 694 // If an inline type was allocated and initialized, apply post barrier to all oop fields</span>
<span class="line-added"> 695   if (has_inline_argument &amp;&amp; has_oop_field) {</span>
<span class="line-added"> 696     __ push(r13); // save senderSP</span>
<span class="line-added"> 697     __ push(r1); // save callee</span>
<span class="line-added"> 698     // Allocate argument register save area</span>
<span class="line-added"> 699     if (frame::arg_reg_save_area_bytes != 0) {</span>
<span class="line-added"> 700       __ sub(sp, sp, frame::arg_reg_save_area_bytes);</span>
 701     }
<span class="line-added"> 702     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::apply_post_barriers), rthread, r10);</span>
<span class="line-added"> 703     // De-allocate argument register save area</span>
<span class="line-added"> 704     if (frame::arg_reg_save_area_bytes != 0) {</span>
<span class="line-added"> 705       __ add(sp, sp, frame::arg_reg_save_area_bytes);</span>
<span class="line-added"> 706     }</span>
<span class="line-added"> 707     __ pop(r1); // restore callee</span>
<span class="line-added"> 708     __ pop(r13); // restore sender SP</span>
 709   }
 710 
 711   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 712 
 713   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 714   __ br(rscratch1);
 715 }
 716 
<span class="line-added"> 717 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm, int comp_args_on_stack, const GrowableArray&lt;SigEntry&gt;* sig, const VMRegPair *regs) {</span>
 718 





 719 
 720   // Note: r13 contains the senderSP on entry. We must preserve it since
 721   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 722   // code goes non-entrant while we get args ready.
 723 
 724   // In addition we use r13 to locate all the interpreter args because
 725   // we must align the stack to 16 bytes.
 726 
 727   // Adapters are frameless.
 728 
 729   // An i2c adapter is frameless because the *caller* frame, which is
 730   // interpreted, routinely repairs its own esp (from
 731   // interpreter_frame_last_sp), even if a callee has modified the
 732   // stack pointer.  It also recalculates and aligns sp.
 733 
 734   // A c2i adapter is frameless because the *callee* frame, which is
 735   // interpreted, routinely repairs its caller&#39;s sp (from sender_sp,
 736   // which is set up via the senderSP register).
 737 
 738   // In other words, if *either* the caller or callee is interpreted, we can
</pre>
<hr />
<pre>
 758       range_check(masm, rax, r11,
 759                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 760                   L_ok);
 761     if (StubRoutines::code1() != NULL)
 762       range_check(masm, rax, r11,
 763                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 764                   L_ok);
 765     if (StubRoutines::code2() != NULL)
 766       range_check(masm, rax, r11,
 767                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 768                   L_ok);
 769     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 770     __ block_comment(msg);
 771     __ stop(msg);
 772     __ bind(L_ok);
 773     __ block_comment(&quot;} verify_i2ce &quot;);
 774 #endif
 775   }
 776 
 777   // Cut-out for having no stack args.
<span class="line-modified"> 778   int comp_words_on_stack = 0;</span>
 779   if (comp_args_on_stack) {
<span class="line-modified"> 780      comp_words_on_stack = align_up(comp_args_on_stack * VMRegImpl::stack_slot_size, wordSize) &gt;&gt; LogBytesPerWord;</span>
<span class="line-modified"> 781      __ sub(rscratch1, sp, comp_words_on_stack * wordSize);</span>
<span class="line-added"> 782      __ andr(sp, rscratch1, -16);</span>
 783   }
 784 
 785   // Will jump to the compiled code just as if compiled code was doing it.
 786   // Pre-load the register-jump target early, to schedule it better.
 787   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 788 
 789 #if INCLUDE_JVMCI
 790   if (EnableJVMCI || UseAOT) {
 791     // check if this call should be routed towards a specific entry point
 792     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 793     Label no_alternative_target;
 794     __ cbz(rscratch2, no_alternative_target);
 795     __ mov(rscratch1, rscratch2);
 796     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 797     __ bind(no_alternative_target);
 798   }
 799 #endif // INCLUDE_JVMCI
 800 
<span class="line-added"> 801   int total_args_passed = sig-&gt;length();</span>
<span class="line-added"> 802 </span>
 803   // Now generate the shuffle code.
 804   for (int i = 0; i &lt; total_args_passed; i++) {
<span class="line-modified"> 805     BasicType bt = sig-&gt;at(i)._bt;</span>
<span class="line-modified"> 806 </span>
<span class="line-added"> 807     assert(bt != T_INLINE_TYPE, &quot;i2c adapter doesn&#39;t unpack inline typ args&quot;);</span>
<span class="line-added"> 808     if (bt == T_VOID) {</span>
<span class="line-added"> 809       assert(i &gt; 0 &amp;&amp; (sig-&gt;at(i - 1)._bt == T_LONG || sig-&gt;at(i - 1)._bt == T_DOUBLE), &quot;missing half&quot;);</span>
 810       continue;
 811     }
 812 
 813     // Pick up 0, 1 or 2 words from SP+offset.
<span class="line-added"> 814     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(), &quot;scrambled load targets?&quot;);</span>
 815 
<span class="line-modified"> 816     // Load in argument order going down.</span>


 817     int ld_off = (total_args_passed - i - 1) * Interpreter::stackElementSize;
 818     // Point to interpreter value (vs. tag)
 819     int next_off = ld_off - Interpreter::stackElementSize;
 820     //
 821     //
 822     //
 823     VMReg r_1 = regs[i].first();
 824     VMReg r_2 = regs[i].second();
 825     if (!r_1-&gt;is_valid()) {
 826       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 827       continue;
 828     }
 829     if (r_1-&gt;is_stack()) {
 830       // Convert stack slot to an SP offset (+ wordSize to account for return address )
<span class="line-modified"> 831       int st_off = regs[i].first()-&gt;reg2stack() * VMRegImpl::stack_slot_size;</span>
 832       if (!r_2-&gt;is_valid()) {
 833         // sign extend???
 834         __ ldrsw(rscratch2, Address(esp, ld_off));
 835         __ str(rscratch2, Address(sp, st_off));
 836       } else {
 837         //
 838         // We are using two optoregs. This can be either T_OBJECT,
 839         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 840         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 841         // So we must adjust where to pick up the data to match the
 842         // interpreter.
 843         //
 844         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 845         // are accessed as negative so LSW is at LOW address
 846 
 847         // ld_off is MSW so get LSW
<span class="line-modified"> 848         const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;</span>

 849         __ ldr(rscratch2, Address(esp, offset));
 850         // st_off is LSW (i.e. reg.first())
<span class="line-modified"> 851          __ str(rscratch2, Address(sp, st_off));</span>
<span class="line-modified"> 852        }</span>
<span class="line-modified"> 853      } else if (r_1-&gt;is_Register()) {  // Register argument</span>
<span class="line-modified"> 854        Register r = r_1-&gt;as_Register();</span>
<span class="line-modified"> 855        if (r_2-&gt;is_valid()) {</span>
<span class="line-modified"> 856          //</span>
<span class="line-modified"> 857          // We are using two VMRegs. This can be either T_OBJECT,</span>
<span class="line-modified"> 858          // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates</span>
<span class="line-modified"> 859          // two slots but only uses one for thr T_LONG or T_DOUBLE case</span>
<span class="line-modified"> 860          // So we must adjust where to pick up the data to match the</span>
<span class="line-modified"> 861          // interpreter.</span>
<span class="line-added"> 862 </span>
<span class="line-added"> 863         const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;</span>
<span class="line-added"> 864 </span>
<span class="line-added"> 865          // this can be a misaligned move</span>
<span class="line-added"> 866          __ ldr(r, Address(esp, offset));</span>
<span class="line-added"> 867        } else {</span>
<span class="line-added"> 868          // sign extend and use a full word?</span>
<span class="line-added"> 869          __ ldrw(r, Address(esp, ld_off));</span>
<span class="line-added"> 870        }</span>
<span class="line-added"> 871      } else {</span>
<span class="line-added"> 872        if (!r_2-&gt;is_valid()) {</span>
<span class="line-added"> 873          __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));</span>
<span class="line-added"> 874        } else {</span>
<span class="line-added"> 875          __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));</span>
<span class="line-added"> 876        }</span>
<span class="line-added"> 877      }</span>
<span class="line-added"> 878    }</span>
 879 

















 880 
 881   // 6243940 We might end up in handle_wrong_method if
 882   // the callee is deoptimized as we race thru here. If that
 883   // happens we don&#39;t want to take a safepoint because the
 884   // caller frame will look interpreted and arguments are now
 885   // &quot;compiled&quot; so it is much better to make this transition
 886   // invisible to the stack walking code. Unfortunately if
 887   // we try and find the callee by normal means a safepoint
 888   // is possible. So we stash the desired callee in the thread
 889   // and the vm will find there should this case occur.
 890 
 891   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));

 892   __ br(rscratch1);
 893 }
 894 
<span class="line-modified"> 895 static void gen_inline_cache_check(MacroAssembler *masm, Label&amp; skip_fixup) {</span>












 896 
 897   Label ok;
 898 
 899   Register holder = rscratch2;
 900   Register receiver = j_rarg0;
 901   Register tmp = r10;  // A call-clobbered register not used for arg passing
 902 
 903   // -------------------------------------------------------------------------
 904   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 905   // to the interpreter.  The args start out packed in the compiled layout.  They
 906   // need to be unpacked into the interpreter layout.  This will almost always
 907   // require some stack space.  We grow the current (compiled) stack, then repack
 908   // the args.  We  finally end in a jump to the generic interpreter entry point.
 909   // On exit from the interpreter, the interpreter will restore our SP (lest the
 910   // compiled code, which relys solely on SP and not FP, get sick).
 911 
 912   {
 913     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 914     __ load_klass(rscratch1, receiver);
 915     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 916     __ cmp(rscratch1, tmp);
 917     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 918     __ br(Assembler::EQ, ok);
 919     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 920 
 921     __ bind(ok);
 922     // Method might have been compiled since the call site was patched to
 923     // interpreted; if that is the case treat it as a miss so we can get
 924     // the call site corrected.
 925     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 926     __ cbz(rscratch1, skip_fixup);
 927     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 928     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 929   }
<span class="line-added"> 930 }</span>
<span class="line-added"> 931 </span>
<span class="line-added"> 932 </span>
<span class="line-added"> 933 // ---------------------------------------------------------------</span>
<span class="line-added"> 934 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,</span>
<span class="line-added"> 935                                                             int comp_args_on_stack,</span>
<span class="line-added"> 936                                                             const GrowableArray&lt;SigEntry&gt;* sig,</span>
<span class="line-added"> 937                                                             const VMRegPair* regs,</span>
<span class="line-added"> 938                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-added"> 939                                                             const VMRegPair* regs_cc,</span>
<span class="line-added"> 940                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc_ro,</span>
<span class="line-added"> 941                                                             const VMRegPair* regs_cc_ro,</span>
<span class="line-added"> 942                                                             AdapterFingerPrint* fingerprint,</span>
<span class="line-added"> 943                                                             AdapterBlob*&amp; new_adapter) {</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945   address i2c_entry = __ pc();</span>
<span class="line-added"> 946   gen_i2c_adapter(masm, comp_args_on_stack, sig, regs);</span>
<span class="line-added"> 947 </span>
<span class="line-added"> 948   address c2i_unverified_entry = __ pc();</span>
<span class="line-added"> 949   Label skip_fixup;</span>
<span class="line-added"> 950 </span>
<span class="line-added"> 951   gen_inline_cache_check(masm, skip_fixup);</span>
<span class="line-added"> 952 </span>
<span class="line-added"> 953   OopMapSet* oop_maps = new OopMapSet();</span>
<span class="line-added"> 954   int frame_complete = CodeOffsets::frame_never_safe;</span>
<span class="line-added"> 955   int frame_size_in_words = 0;</span>
<span class="line-added"> 956 </span>
<span class="line-added"> 957   // Scalarized c2i adapter with non-scalarized receiver (i.e., don&#39;t pack receiver)</span>
<span class="line-added"> 958   address c2i_inline_ro_entry = __ pc();</span>
<span class="line-added"> 959   if (regs_cc != regs_cc_ro) {</span>
<span class="line-added"> 960     Label unused;</span>
<span class="line-added"> 961     gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);</span>
<span class="line-added"> 962     skip_fixup = unused;</span>
<span class="line-added"> 963   }</span>
 964 
<span class="line-added"> 965   // Scalarized c2i adapter</span>
 966   address c2i_entry = __ pc();
 967 
 968   // Class initialization barrier for static methods
 969   address c2i_no_clinit_check_entry = NULL;
<span class="line-added"> 970 </span>
 971   if (VM_Version::supports_fast_class_init_checks()) {
 972     Label L_skip_barrier;
<span class="line-modified"> 973     { // Bypass the barrier for non-static methods</span>
<span class="line-modified"> 974         Register flags  = rscratch1;</span>
<span class="line-modified"> 975       __ ldrw(flags, Address(rmethod, Method::access_flags_offset()));</span>
<span class="line-modified"> 976       __ tst(flags, JVM_ACC_STATIC);</span>
 977       __ br(Assembler::NE, L_skip_barrier); // non-static
 978     }
 979 
<span class="line-modified"> 980     Register klass = rscratch1;</span>
<span class="line-modified"> 981     __ load_method_holder(klass, rmethod);</span>
<span class="line-modified"> 982     // We pass rthread to this function on x86</span>
<span class="line-added"> 983     __ clinit_barrier(klass, rscratch2, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added"> 984 </span>
<span class="line-added"> 985     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path</span>
 986 
 987     __ bind(L_skip_barrier);
 988     c2i_no_clinit_check_entry = __ pc();
 989   }
 990 
 991   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 992   bs-&gt;c2i_entry_barrier(masm);
 993 
 994   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 995 
<span class="line-added"> 996   address c2i_unverified_inline_entry = c2i_unverified_entry;</span>
<span class="line-added"> 997 </span>
<span class="line-added"> 998  // Non-scalarized c2i adapter</span>
<span class="line-added"> 999   address c2i_inline_entry = c2i_entry;</span>
<span class="line-added">1000   if (regs != regs_cc) {</span>
<span class="line-added">1001     Label inline_entry_skip_fixup;</span>
<span class="line-added">1002     c2i_unverified_inline_entry = __ pc();</span>
<span class="line-added">1003     gen_inline_cache_check(masm, inline_entry_skip_fixup);</span>
<span class="line-added">1004 </span>
<span class="line-added">1005     c2i_inline_entry = __ pc();</span>
<span class="line-added">1006     Label unused;</span>
<span class="line-added">1007     gen_c2i_adapter(masm, sig, regs, inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);</span>
<span class="line-added">1008   }</span>
<span class="line-added">1009 </span>
1010   __ flush();
<span class="line-modified">1011 </span>
<span class="line-added">1012   // The c2i adapter might safepoint and trigger a GC. The caller must make sure that</span>
<span class="line-added">1013   // the GC knows about the location of oop argument locations passed to the c2i adapter.</span>
<span class="line-added">1014 </span>
<span class="line-added">1015   bool caller_must_gc_arguments = (regs != regs_cc);</span>
<span class="line-added">1016   new_adapter = AdapterBlob::create(masm-&gt;code(), frame_complete, frame_size_in_words + 10, oop_maps, caller_must_gc_arguments);</span>
<span class="line-added">1017 </span>
<span class="line-added">1018   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);</span>
1019 }
1020 
1021 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
1022                                          VMRegPair *regs,
1023                                          VMRegPair *regs2,
1024                                          int total_args_passed) {
1025   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
1026 
1027 // We return the amount of VMRegImpl stack slots we need to reserve for all
1028 // the arguments NOT counting out_preserve_stack_slots.
1029 
1030     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
1031       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
1032     };
1033     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
1034       c_farg0, c_farg1, c_farg2, c_farg3,
1035       c_farg4, c_farg5, c_farg6, c_farg7
1036     };
1037 
1038     uint int_args = 0;
</pre>
<hr />
<pre>
1041 
1042     for (int i = 0; i &lt; total_args_passed; i++) {
1043       switch (sig_bt[i]) {
1044       case T_BOOLEAN:
1045       case T_CHAR:
1046       case T_BYTE:
1047       case T_SHORT:
1048       case T_INT:
1049         if (int_args &lt; Argument::n_int_register_parameters_c) {
1050           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
1051         } else {
1052           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1053           stk_args += 2;
1054         }
1055         break;
1056       case T_LONG:
1057         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1058         // fall through
1059       case T_OBJECT:
1060       case T_ARRAY:
<span class="line-added">1061       case T_INLINE_TYPE:</span>
1062       case T_ADDRESS:
1063       case T_METADATA:
1064         if (int_args &lt; Argument::n_int_register_parameters_c) {
1065           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
1066         } else {
1067           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1068           stk_args += 2;
1069         }
1070         break;
1071       case T_FLOAT:
1072         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1073           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1074         } else {
1075           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1076           stk_args += 2;
1077         }
1078         break;
1079       case T_DOUBLE:
1080         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1081         if (fp_args &lt; Argument::n_float_register_parameters_c) {
</pre>
<hr />
<pre>
1893       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1894     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1895       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1896     }
1897 #endif /* ASSERT */
1898     switch (in_sig_bt[i]) {
1899       case T_ARRAY:
1900         if (is_critical_native) {
1901           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1902           c_arg++;
1903 #ifdef ASSERT
1904           if (out_regs[c_arg].first()-&gt;is_Register()) {
1905             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1906           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1907             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1908           }
1909 #endif
1910           int_args++;
1911           break;
1912         }
<span class="line-added">1913       case T_INLINE_TYPE:</span>
1914       case T_OBJECT:
1915         assert(!is_critical_native, &quot;no oop arguments&quot;);
1916         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1917                     ((i == 0) &amp;&amp; (!is_static)),
1918                     &amp;receiver_offset);
1919         int_args++;
1920         break;
1921       case T_VOID:
1922         break;
1923 
1924       case T_FLOAT:
1925         float_move(masm, in_regs[i], out_regs[c_arg]);
1926         float_args++;
1927         break;
1928 
1929       case T_DOUBLE:
1930         assert( i + 1 &lt; total_in_args &amp;&amp;
1931                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1932                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1933         double_move(masm, in_regs[i], out_regs[c_arg]);
</pre>
<hr />
<pre>
2081 
2082   rt_call(masm, native_func);
2083 
2084   __ bind(native_return);
2085 
2086   intptr_t return_pc = (intptr_t) __ pc();
2087   oop_maps-&gt;add_gc_map(return_pc - start, map);
2088 
2089   // Unpack native results.
2090   switch (ret_type) {
2091   case T_BOOLEAN: __ c2bool(r0);                     break;
2092   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
2093   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
2094   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
2095   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
2096   case T_DOUBLE :
2097   case T_FLOAT  :
2098     // Result is in v0 we&#39;ll save as needed
2099     break;
2100   case T_ARRAY:                 // Really a handle
<span class="line-added">2101   case T_INLINE_TYPE:</span>
2102   case T_OBJECT:                // Really a handle
2103       break; // can&#39;t de-handlize until after safepoint check
2104   case T_VOID: break;
2105   case T_LONG: break;
2106   default       : ShouldNotReachHere();
2107   }
2108 
2109   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
2110   // This additional state is necessary because reading and testing the synchronization
2111   // state is not atomic w.r.t. GC, as this scenario demonstrates:
2112   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
2113   //     VM thread changes sync state to synchronizing and suspends threads for GC.
2114   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
2115   //     didn&#39;t see any synchronization is progress, and escapes.
2116   __ mov(rscratch1, _thread_in_native_trans);
2117 
2118   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
2119 
2120   // Force this write out before the read below
2121   __ dmb(Assembler::ISH);
</pre>
<hr />
<pre>
3307 #ifdef ASSERT
3308   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3309   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3310 #endif
3311   // Clear the exception oop so GC no longer processes it as a root.
3312   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3313 
3314   // r0: exception oop
3315   // r8:  exception handler
3316   // r4: exception pc
3317   // Jump to handler
3318 
3319   __ br(r8);
3320 
3321   // Make sure all code is generated
3322   masm-&gt;flush();
3323 
3324   // Set exception blob
3325   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3326 }
<span class="line-added">3327 </span>
<span class="line-added">3328 BufferedInlineTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {</span>
<span class="line-added">3329   BufferBlob* buf = BufferBlob::create(&quot;inline types pack/unpack&quot;, 16 * K);</span>
<span class="line-added">3330   CodeBuffer buffer(buf);</span>
<span class="line-added">3331   short buffer_locs[20];</span>
<span class="line-added">3332   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,</span>
<span class="line-added">3333                                          sizeof(buffer_locs)/sizeof(relocInfo));</span>
<span class="line-added">3334 </span>
<span class="line-added">3335   MacroAssembler _masm(&amp;buffer);</span>
<span class="line-added">3336   MacroAssembler* masm = &amp;_masm;</span>
<span class="line-added">3337 </span>
<span class="line-added">3338   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();</span>
<span class="line-added">3339   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();</span>
<span class="line-added">3340 </span>
<span class="line-added">3341   int pack_fields_off = __ offset();</span>
<span class="line-added">3342 </span>
<span class="line-added">3343   int j = 1;</span>
<span class="line-added">3344   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {</span>
<span class="line-added">3345     BasicType bt = sig_vk-&gt;at(i)._bt;</span>
<span class="line-added">3346     if (bt == T_INLINE_TYPE) {</span>
<span class="line-added">3347       continue;</span>
<span class="line-added">3348     }</span>
<span class="line-added">3349     if (bt == T_VOID) {</span>
<span class="line-added">3350       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||</span>
<span class="line-added">3351           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {</span>
<span class="line-added">3352         j++;</span>
<span class="line-added">3353       }</span>
<span class="line-added">3354       continue;</span>
<span class="line-added">3355     }</span>
<span class="line-added">3356     int off = sig_vk-&gt;at(i)._offset;</span>
<span class="line-added">3357     VMRegPair pair = regs-&gt;at(j);</span>
<span class="line-added">3358     VMReg r_1 = pair.first();</span>
<span class="line-added">3359     VMReg r_2 = pair.second();</span>
<span class="line-added">3360     Address to(r0, off);</span>
<span class="line-added">3361     if (bt == T_FLOAT) {</span>
<span class="line-added">3362       __ strs(r_1-&gt;as_FloatRegister(), to);</span>
<span class="line-added">3363     } else if (bt == T_DOUBLE) {</span>
<span class="line-added">3364       __ strd(r_1-&gt;as_FloatRegister(), to);</span>
<span class="line-added">3365     } else if (bt == T_OBJECT || bt == T_ARRAY) {</span>
<span class="line-added">3366       Register val = r_1-&gt;as_Register();</span>
<span class="line-added">3367       assert_different_registers(r0, val);</span>
<span class="line-added">3368       // We don&#39;t need barriers because the destination is a newly allocated object.</span>
<span class="line-added">3369       // Also, we cannot use store_heap_oop(to, val) because it uses r8 as tmp.</span>
<span class="line-added">3370       if (UseCompressedOops) {</span>
<span class="line-added">3371         __ encode_heap_oop(val);</span>
<span class="line-added">3372         __ str(val, to);</span>
<span class="line-added">3373       } else {</span>
<span class="line-added">3374         __ str(val, to);</span>
<span class="line-added">3375       }</span>
<span class="line-added">3376     } else {</span>
<span class="line-added">3377       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);</span>
<span class="line-added">3378       assert_different_registers(r0, r_1-&gt;as_Register());</span>
<span class="line-added">3379       size_t size_in_bytes = type2aelembytes(bt);</span>
<span class="line-added">3380       __ store_sized_value(to, r_1-&gt;as_Register(), size_in_bytes);</span>
<span class="line-added">3381     }</span>
<span class="line-added">3382     j++;</span>
<span class="line-added">3383   }</span>
<span class="line-added">3384   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);</span>
<span class="line-added">3385 </span>
<span class="line-added">3386   __ ret(lr);</span>
<span class="line-added">3387 </span>
<span class="line-added">3388   int unpack_fields_off = __ offset();</span>
<span class="line-added">3389 </span>
<span class="line-added">3390   j = 1;</span>
<span class="line-added">3391   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {</span>
<span class="line-added">3392     BasicType bt = sig_vk-&gt;at(i)._bt;</span>
<span class="line-added">3393     if (bt == T_INLINE_TYPE) {</span>
<span class="line-added">3394       continue;</span>
<span class="line-added">3395     }</span>
<span class="line-added">3396     if (bt == T_VOID) {</span>
<span class="line-added">3397       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||</span>
<span class="line-added">3398           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {</span>
<span class="line-added">3399         j++;</span>
<span class="line-added">3400       }</span>
<span class="line-added">3401       continue;</span>
<span class="line-added">3402     }</span>
<span class="line-added">3403     int off = sig_vk-&gt;at(i)._offset;</span>
<span class="line-added">3404     VMRegPair pair = regs-&gt;at(j);</span>
<span class="line-added">3405     VMReg r_1 = pair.first();</span>
<span class="line-added">3406     VMReg r_2 = pair.second();</span>
<span class="line-added">3407     Address from(r0, off);</span>
<span class="line-added">3408     if (bt == T_FLOAT) {</span>
<span class="line-added">3409       __ ldrs(r_1-&gt;as_FloatRegister(), from);</span>
<span class="line-added">3410     } else if (bt == T_DOUBLE) {</span>
<span class="line-added">3411       __ ldrd(r_1-&gt;as_FloatRegister(), from);</span>
<span class="line-added">3412     } else if (bt == T_OBJECT || bt == T_ARRAY) {</span>
<span class="line-added">3413        assert_different_registers(r0, r_1-&gt;as_Register());</span>
<span class="line-added">3414        __ load_heap_oop(r_1-&gt;as_Register(), from);</span>
<span class="line-added">3415     } else {</span>
<span class="line-added">3416       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);</span>
<span class="line-added">3417       assert_different_registers(r0, r_1-&gt;as_Register());</span>
<span class="line-added">3418 </span>
<span class="line-added">3419       size_t size_in_bytes = type2aelembytes(bt);</span>
<span class="line-added">3420       __ load_sized_value(r_1-&gt;as_Register(), from, size_in_bytes, bt != T_CHAR &amp;&amp; bt != T_BOOLEAN);</span>
<span class="line-added">3421     }</span>
<span class="line-added">3422     j++;</span>
<span class="line-added">3423   }</span>
<span class="line-added">3424   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);</span>
<span class="line-added">3425 </span>
<span class="line-added">3426   __ ret(lr);</span>
<span class="line-added">3427 </span>
<span class="line-added">3428   __ flush();</span>
<span class="line-added">3429 </span>
<span class="line-added">3430   return BufferedInlineTypeBlob::create(&amp;buffer, pack_fields_off, unpack_fields_off);</span>
<span class="line-added">3431 }</span>
3432 #endif // COMPILER2
</pre>
</td>
</tr>
</table>
<center><a href="c1_CodeStubs_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>