<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.InitTimer.timer;
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;
  27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  29 
  30 import java.io.IOException;
  31 import java.io.OutputStream;
  32 import java.io.PrintStream;
  33 import java.io.Serializable;
  34 import java.lang.invoke.CallSite;
  35 import java.lang.invoke.ConstantCallSite;
  36 import java.lang.invoke.MethodHandle;
  37 import java.lang.ref.WeakReference;
  38 import java.util.ArrayList;
  39 import java.util.Collections;
  40 import java.util.Formatter;
  41 import java.util.HashMap;
  42 import java.util.List;
  43 import java.util.Map;
  44 import java.util.Objects;
  45 import java.util.ServiceLoader;
  46 import java.util.function.Predicate;
  47 
  48 import jdk.vm.ci.code.Architecture;
  49 import jdk.vm.ci.code.CompilationRequestResult;
  50 import jdk.vm.ci.code.CompiledCode;
  51 import jdk.vm.ci.code.InstalledCode;
  52 import jdk.vm.ci.common.InitTimer;
  53 import jdk.vm.ci.common.JVMCIError;
  54 import jdk.vm.ci.common.NativeImageReinitialize;
  55 import jdk.vm.ci.meta.JavaKind;
  56 import jdk.vm.ci.meta.JavaType;
  57 import jdk.vm.ci.meta.ResolvedJavaType;
  58 import jdk.vm.ci.meta.UnresolvedJavaType;
  59 import jdk.vm.ci.runtime.JVMCI;
  60 import jdk.vm.ci.runtime.JVMCIBackend;
  61 import jdk.vm.ci.runtime.JVMCICompiler;
  62 import jdk.vm.ci.runtime.JVMCICompilerFactory;
  63 import jdk.vm.ci.runtime.JVMCIRuntime;
  64 import jdk.vm.ci.services.JVMCIServiceLocator;
  65 import jdk.vm.ci.services.Services;
  66 
  67 /**
  68  * HotSpot implementation of a JVMCI runtime.
  69  */
  70 public final class HotSpotJVMCIRuntime implements JVMCIRuntime {
  71 
  72     /**
  73      * Singleton instance lazily initialized via double-checked locking.
  74      */
  75     @NativeImageReinitialize private static volatile HotSpotJVMCIRuntime instance;
  76 
  77     private HotSpotResolvedObjectTypeImpl javaLangObject;
  78     private HotSpotResolvedObjectTypeImpl javaLangInvokeMethodHandle;
  79     private HotSpotResolvedObjectTypeImpl constantCallSiteType;
  80     private HotSpotResolvedObjectTypeImpl callSiteType;
  81     private HotSpotResolvedObjectTypeImpl javaLangString;
  82     private HotSpotResolvedObjectTypeImpl javaLangClass;
  83     private HotSpotResolvedObjectTypeImpl throwableType;
  84     private HotSpotResolvedObjectTypeImpl serializableType;
  85     private HotSpotResolvedObjectTypeImpl cloneableType;
  86     private HotSpotResolvedObjectTypeImpl enumType;
<a name="1" id="anc1"></a><span class="line-added">  87     private HotSpotResolvedObjectTypeImpl identityObjectType;</span>
  88 
  89     HotSpotResolvedObjectTypeImpl getJavaLangObject() {
  90         if (javaLangObject == null) {
  91             javaLangObject = (HotSpotResolvedObjectTypeImpl) fromClass(Object.class);
  92         }
  93         return javaLangObject;
  94     }
  95 
  96     HotSpotResolvedObjectTypeImpl getJavaLangString() {
  97         if (javaLangString == null) {
  98             javaLangString = (HotSpotResolvedObjectTypeImpl) fromClass(String.class);
  99         }
 100         return javaLangString;
 101     }
 102 
 103     HotSpotResolvedObjectTypeImpl getJavaLangClass() {
 104         if (javaLangClass == null) {
 105             javaLangClass = (HotSpotResolvedObjectTypeImpl) fromClass(Class.class);
 106         }
 107         return javaLangClass;
 108     }
 109 
 110     HotSpotResolvedObjectTypeImpl getJavaLangCloneable() {
 111         if (cloneableType == null) {
 112             cloneableType = (HotSpotResolvedObjectTypeImpl) fromClass(Cloneable.class);
 113         }
 114         return cloneableType;
 115     }
 116 
 117     HotSpotResolvedObjectTypeImpl getJavaLangSerializable() {
 118         if (serializableType == null) {
 119             serializableType = (HotSpotResolvedObjectTypeImpl) fromClass(Serializable.class);
 120         }
 121         return serializableType;
 122     }
 123 
<a name="2" id="anc2"></a><span class="line-added"> 124     HotSpotResolvedObjectTypeImpl getJavaLangIdentityObject() {</span>
<span class="line-added"> 125         if (identityObjectType == null) {</span>
<span class="line-added"> 126             identityObjectType = (HotSpotResolvedObjectTypeImpl) fromClass(IdentityObject.class);</span>
<span class="line-added"> 127         }</span>
<span class="line-added"> 128         return identityObjectType;</span>
<span class="line-added"> 129     }</span>
<span class="line-added"> 130 </span>
 131     HotSpotResolvedObjectTypeImpl getJavaLangThrowable() {
 132         if (throwableType == null) {
 133             throwableType = (HotSpotResolvedObjectTypeImpl) fromClass(Throwable.class);
 134         }
 135         return throwableType;
 136     }
 137 
 138     HotSpotResolvedObjectTypeImpl getJavaLangEnum() {
 139         if (enumType == null) {
 140             enumType = (HotSpotResolvedObjectTypeImpl) fromClass(Enum.class);
 141         }
 142         return enumType;
 143     }
 144 
 145     HotSpotResolvedObjectTypeImpl getConstantCallSite() {
 146         if (constantCallSiteType == null) {
 147             constantCallSiteType = (HotSpotResolvedObjectTypeImpl) fromClass(ConstantCallSite.class);
 148         }
 149         return constantCallSiteType;
 150     }
 151 
 152     HotSpotResolvedObjectTypeImpl getCallSite() {
 153         if (callSiteType == null) {
 154             callSiteType = (HotSpotResolvedObjectTypeImpl) fromClass(CallSite.class);
 155         }
 156         return callSiteType;
 157     }
 158 
 159     HotSpotResolvedObjectType getMethodHandleClass() {
 160         if (javaLangInvokeMethodHandle == null) {
 161             javaLangInvokeMethodHandle = (HotSpotResolvedObjectTypeImpl) fromClass(MethodHandle.class);
 162         }
 163         return javaLangInvokeMethodHandle;
 164     }
 165 
 166     /**
 167      * Gets the singleton {@link HotSpotJVMCIRuntime} object.
 168      */
 169     @VMEntryPoint
 170     @SuppressWarnings(&quot;try&quot;)
 171     public static HotSpotJVMCIRuntime runtime() {
 172         HotSpotJVMCIRuntime result = instance;
 173         if (result == null) {
 174             // Synchronize on JVMCI.class to avoid deadlock
 175             // between the two JVMCI initialization paths:
 176             // HotSpotJVMCIRuntime.runtime() and JVMCI.getRuntime().
 177             synchronized (JVMCI.class) {
 178                 result = instance;
 179                 if (result == null) {
 180                     try (InitTimer t = timer(&quot;HotSpotJVMCIRuntime.&lt;init&gt;&quot;)) {
 181                         instance = result = new HotSpotJVMCIRuntime();
 182 
 183                         // Can only do eager initialization of the JVMCI compiler
 184                         // once the singleton instance is available.
 185                         if (result.config.getFlag(&quot;EagerJVMCI&quot;, Boolean.class)) {
 186                             result.getCompiler();
 187                         }
 188                     }
 189                     // Ensures JVMCIRuntime::_HotSpotJVMCIRuntime_instance is
 190                     // initialized.
 191                     JVMCI.getRuntime();
 192                 }
 193                 // Make sure all the primitive box caches are populated (required to properly
 194                 // materialize boxed primitives
 195                 // during deoptimization).
 196                 Boolean.valueOf(false);
 197                 Byte.valueOf((byte) 0);
 198                 Short.valueOf((short) 0);
 199                 Character.valueOf((char) 0);
 200                 Integer.valueOf(0);
 201                 Long.valueOf(0);
 202             }
 203         }
 204         return result;
 205     }
 206 
 207     @VMEntryPoint
 208     static Throwable decodeThrowable(String encodedThrowable) throws Throwable {
 209         return TranslatedException.decodeThrowable(encodedThrowable);
 210     }
 211 
 212     @VMEntryPoint
 213     static String encodeThrowable(Throwable throwable) throws Throwable {
 214         return TranslatedException.encodeThrowable(throwable);
 215     }
 216 
 217     @VMEntryPoint
 218     static String callToString(Object o) {
 219         return o.toString();
 220     }
 221 
 222     /**
 223      * Set of recognized {@code &quot;jvmci.*&quot;} system properties. Entries not associated with an
 224      * {@link Option} have this object as their value.
 225      */
 226     static final Map&lt;String, Object&gt; options = new HashMap&lt;&gt;();
 227     static {
 228         options.put(&quot;jvmci.class.path.append&quot;, options);
 229     }
 230 
 231     /**
 232      * A list of all supported JVMCI options.
 233      */
 234     public enum Option {
 235         // @formatter:off
 236         Compiler(String.class, null, &quot;Selects the system compiler. This must match the getCompilerName() value returned &quot; +
 237                 &quot;by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. &quot; +
 238                 &quot;An empty string or the value \&quot;null\&quot; selects a compiler &quot; +
 239                 &quot;that will raise an exception upon receiving a compilation request.&quot;),
 240         // Note: The following one is not used (see InitTimer.ENABLED). It is added here
 241         // so that -XX:+JVMCIPrintProperties shows the option.
 242         InitTimer(Boolean.class, false, &quot;Specifies if initialization timing is enabled.&quot;),
 243         PrintConfig(Boolean.class, false, &quot;Prints VM configuration available via JVMCI.&quot;),
 244         AuditHandles(Boolean.class, false, &quot;Record stack trace along with scoped foreign object reference wrappers &quot; +
 245                 &quot;to debug issue with a wrapper being used after its scope has closed.&quot;),
 246         TraceMethodDataFilter(String.class, null,
 247                 &quot;Enables tracing of profiling info when read by JVMCI.&quot;,
 248                 &quot;Empty value: trace all methods&quot;,
 249                         &quot;Non-empty value: trace methods whose fully qualified name contains the value.&quot;),
 250         UseProfilingInformation(Boolean.class, true, &quot;&quot;);
 251         // @formatter:on
 252 
 253         /**
 254          * The prefix for system properties that are JVMCI options.
 255          */
 256         private static final String JVMCI_OPTION_PROPERTY_PREFIX = &quot;jvmci.&quot;;
 257 
 258         /**
 259          * Sentinel for value initialized to {@code null} since {@code null} means uninitialized.
 260          */
 261         private static final String NULL_VALUE = &quot;NULL&quot;;
 262 
 263         private final Class&lt;?&gt; type;
 264         @NativeImageReinitialize private Object value;
 265         private final Object defaultValue;
 266         private boolean isDefault = true;
 267         private final String[] helpLines;
 268 
 269         Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
 270             assert Character.isUpperCase(name().charAt(0)) : &quot;Option name must start with upper-case letter: &quot; + name();
 271             this.type = type;
 272             this.defaultValue = defaultValue;
 273             this.helpLines = helpLines;
 274             Object existing = options.put(getPropertyName(), this);
 275             assert existing == null : getPropertyName();
 276         }
 277 
 278         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
 279         private void init(String propertyValue) {
 280             assert value == null : &quot;cannot re-initialize &quot; + name();
 281             if (propertyValue == null) {
 282                 this.value = defaultValue == null ? NULL_VALUE : defaultValue;
 283                 this.isDefault = true;
 284             } else {
 285                 if (type == Boolean.class) {
 286                     this.value = Boolean.parseBoolean(propertyValue);
 287                 } else if (type == String.class) {
 288                     this.value = propertyValue;
 289                 } else {
 290                     throw new JVMCIError(&quot;Unexpected option type &quot; + type);
 291                 }
 292                 this.isDefault = false;
 293             }
 294         }
 295 
 296         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
 297         private Object getValue() {
 298             if (value == NULL_VALUE) {
 299                 return null;
 300             }
 301             if (value == null) {
 302                 return defaultValue;
 303             }
 304             return value;
 305         }
 306 
 307         /**
 308          * Gets the name of system property from which this option gets its value.
 309          */
 310         public String getPropertyName() {
 311             return JVMCI_OPTION_PROPERTY_PREFIX + name();
 312         }
 313 
 314         /**
 315          * Returns the option&#39;s value as boolean.
 316          *
 317          * @return option&#39;s value
 318          */
 319         public boolean getBoolean() {
 320             return (boolean) getValue();
 321         }
 322 
 323         /**
 324          * Returns the option&#39;s value as String.
 325          *
 326          * @return option&#39;s value
 327          */
 328         public String getString() {
 329             return (String) getValue();
 330         }
 331 
 332         private static final int PROPERTY_LINE_WIDTH = 80;
 333         private static final int PROPERTY_HELP_INDENT = 10;
 334 
 335         /**
 336          * Prints a description of the properties used to configure shared JVMCI code.
 337          *
 338          * @param out stream to print to
 339          */
 340         public static void printProperties(PrintStream out) {
 341             out.println(&quot;[JVMCI properties]&quot;);
 342             Option[] values = values();
 343             for (Option option : values) {
 344                 Object value = option.getValue();
 345                 if (value instanceof String) {
 346                     value = &#39;&quot;&#39; + String.valueOf(value) + &#39;&quot;&#39;;
 347                 }
 348 
 349                 String name = option.getPropertyName();
 350                 String assign = option.isDefault ? &quot;=&quot; : &quot;:=&quot;;
 351                 String typeName = option.type.getSimpleName();
 352                 String linePrefix = String.format(&quot;%s %s %s &quot;, name, assign, value);
 353                 int typeStartPos = PROPERTY_LINE_WIDTH - typeName.length();
 354                 int linePad = typeStartPos - linePrefix.length();
 355                 if (linePad &gt; 0) {
 356                     out.printf(&quot;%s%-&quot; + linePad + &quot;s[%s]%n&quot;, linePrefix, &quot;&quot;, typeName);
 357                 } else {
 358                     out.printf(&quot;%s[%s]%n&quot;, linePrefix, typeName);
 359                 }
 360                 for (String line : option.helpLines) {
 361                     out.printf(&quot;%&quot; + PROPERTY_HELP_INDENT + &quot;s%s%n&quot;, &quot;&quot;, line);
 362                 }
 363             }
 364         }
 365 
 366         /**
 367          * Compute string similarity based on Dice&#39;s coefficient.
 368          *
 369          * Ported from str_similar() in globals.cpp.
 370          */
 371         static float stringSimiliarity(String str1, String str2) {
 372             int hit = 0;
 373             for (int i = 0; i &lt; str1.length() - 1; ++i) {
 374                 for (int j = 0; j &lt; str2.length() - 1; ++j) {
 375                     if ((str1.charAt(i) == str2.charAt(j)) &amp;&amp; (str1.charAt(i + 1) == str2.charAt(j + 1))) {
 376                         ++hit;
 377                         break;
 378                     }
 379                 }
 380             }
 381             return 2.0f * hit / (str1.length() + str2.length());
 382         }
 383 
 384         private static final float FUZZY_MATCH_THRESHOLD = 0.7F;
 385 
 386         /**
 387          * Parses all system properties starting with {@value #JVMCI_OPTION_PROPERTY_PREFIX} and
 388          * initializes the options based on their values.
 389          */
 390         static void parse() {
 391             Map&lt;String, String&gt; savedProps = jdk.vm.ci.services.Services.getSavedProperties();
 392             for (Map.Entry&lt;String, String&gt; e : savedProps.entrySet()) {
 393                 String name = e.getKey();
 394                 if (name.startsWith(Option.JVMCI_OPTION_PROPERTY_PREFIX)) {
 395                     Object value = options.get(name);
 396                     if (value == null) {
 397                         List&lt;String&gt; matches = new ArrayList&lt;&gt;();
 398                         for (String pn : options.keySet()) {
 399                             float score = stringSimiliarity(pn, name);
 400                             if (score &gt;= FUZZY_MATCH_THRESHOLD) {
 401                                 matches.add(pn);
 402                             }
 403                         }
 404                         Formatter msg = new Formatter();
 405                         msg.format(&quot;Could not find option %s&quot;, name);
 406                         if (!matches.isEmpty()) {
 407                             msg.format(&quot;%nDid you mean one of the following?&quot;);
 408                             for (String match : matches) {
 409                                 msg.format(&quot;%n    %s=&lt;value&gt;&quot;, match);
 410                             }
 411                         }
 412                         throw new IllegalArgumentException(msg.toString());
 413                     } else if (value instanceof Option) {
 414                         Option option = (Option) value;
 415                         option.init(e.getValue());
 416                     }
 417                 }
 418             }
 419         }
 420     }
 421 
 422     private static HotSpotJVMCIBackendFactory findFactory(String architecture) {
 423         Iterable&lt;HotSpotJVMCIBackendFactory&gt; factories = getHotSpotJVMCIBackendFactories();
 424         assert factories != null : &quot;sanity&quot;;
 425         for (HotSpotJVMCIBackendFactory factory : factories) {
 426             if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
 427                 return factory;
 428             }
 429         }
 430 
 431         throw new JVMCIError(&quot;No JVMCI runtime available for the %s architecture&quot;, architecture);
 432     }
 433 
 434     private static volatile List&lt;HotSpotJVMCIBackendFactory&gt; cachedHotSpotJVMCIBackendFactories;
 435 
 436     @SuppressFBWarnings(value = &quot;LI_LAZY_INIT_UPDATE_STATIC&quot;, justification = &quot;not sure about this&quot;)
 437     private static Iterable&lt;HotSpotJVMCIBackendFactory&gt; getHotSpotJVMCIBackendFactories() {
 438         if (IS_IN_NATIVE_IMAGE || cachedHotSpotJVMCIBackendFactories != null) {
 439             return cachedHotSpotJVMCIBackendFactories;
 440         }
 441         Iterable&lt;HotSpotJVMCIBackendFactory&gt; result = ServiceLoader.load(HotSpotJVMCIBackendFactory.class, ClassLoader.getSystemClassLoader());
 442         if (IS_BUILDING_NATIVE_IMAGE) {
 443             cachedHotSpotJVMCIBackendFactories = new ArrayList&lt;&gt;();
 444             for (HotSpotJVMCIBackendFactory factory : result) {
 445                 cachedHotSpotJVMCIBackendFactories.add(factory);
 446             }
 447         }
 448         return result;
 449     }
 450 
 451     /**
 452      * Gets the kind of a word value on the {@linkplain #getHostJVMCIBackend() host} backend.
 453      */
 454     public static JavaKind getHostWordKind() {
 455         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
 456     }
 457 
 458     protected final CompilerToVM compilerToVm;
 459 
 460     protected final HotSpotVMConfigStore configStore;
 461     protected final HotSpotVMConfig config;
 462     private final JVMCIBackend hostBackend;
 463 
 464     private final JVMCICompilerFactory compilerFactory;
 465     private final HotSpotJVMCICompilerFactory hsCompilerFactory;
 466     private volatile JVMCICompiler compiler;
 467     protected final HotSpotJVMCIReflection reflection;
 468 
 469     @NativeImageReinitialize private volatile boolean creatingCompiler;
 470 
 471     /**
 472      * Cache for speeding up {@link #fromClass(Class)}.
 473      */
 474     @NativeImageReinitialize private volatile ClassValue&lt;WeakReferenceHolder&lt;HotSpotResolvedJavaType&gt;&gt; resolvedJavaType;
 475 
 476     /**
 477      * To avoid calling ClassValue.remove to refresh the weak reference, which under certain
 478      * circumstances can lead to an infinite loop, we use a permanent holder with a mutable field
 479      * that we refresh.
 480      */
 481     private static class WeakReferenceHolder&lt;T&gt; {
 482         private volatile WeakReference&lt;T&gt; ref;
 483 
 484         WeakReferenceHolder(T value) {
 485             set(value);
 486         }
 487 
 488         void set(T value) {
 489             ref = new WeakReference&lt;&gt;(value);
 490         }
 491 
 492         T get() {
 493             return ref.get();
 494         }
 495     }
 496 
 497     @NativeImageReinitialize private HashMap&lt;Long, WeakReference&lt;ResolvedJavaType&gt;&gt; resolvedJavaTypes;
 498 
 499     /**
 500      * Stores the value set by {@link #excludeFromJVMCICompilation(Module...)} so that it can be
 501      * read from the VM.
 502      */
 503     @SuppressWarnings(&quot;unused&quot;)//
 504     @NativeImageReinitialize private Module[] excludeFromJVMCICompilation;
 505 
 506     private final Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; backends = new HashMap&lt;&gt;();
 507 
 508     private volatile List&lt;HotSpotVMEventListener&gt; vmEventListeners;
 509 
 510     private Iterable&lt;HotSpotVMEventListener&gt; getVmEventListeners() {
 511         if (vmEventListeners == null) {
 512             synchronized (this) {
 513                 if (vmEventListeners == null) {
 514                     vmEventListeners = JVMCIServiceLocator.getProviders(HotSpotVMEventListener.class);
 515                 }
 516             }
 517         }
 518         return vmEventListeners;
 519     }
 520 
 521     @SuppressWarnings(&quot;try&quot;)
 522     private HotSpotJVMCIRuntime() {
 523         compilerToVm = new CompilerToVM();
 524 
 525         try (InitTimer t = timer(&quot;HotSpotVMConfig&lt;init&gt;&quot;)) {
 526             configStore = new HotSpotVMConfigStore(compilerToVm);
 527             config = new HotSpotVMConfig(configStore);
 528         }
 529 
 530         reflection = IS_IN_NATIVE_IMAGE ? new SharedLibraryJVMCIReflection() : new HotSpotJDKReflection();
 531 
 532         PrintStream vmLogStream = null;
 533         if (IS_IN_NATIVE_IMAGE) {
 534             // Redirect System.out and System.err to HotSpot&#39;s TTY stream
 535             vmLogStream = new PrintStream(getLogStream());
 536             System.setOut(vmLogStream);
 537             System.setErr(vmLogStream);
 538         }
 539 
 540         // Initialize the Option values.
 541         Option.parse();
 542 
 543         String hostArchitecture = config.getHostArchitectureName();
 544 
 545         HotSpotJVMCIBackendFactory factory;
 546         try (InitTimer t = timer(&quot;find factory:&quot;, hostArchitecture)) {
 547             factory = findFactory(hostArchitecture);
 548         }
 549 
 550         try (InitTimer t = timer(&quot;create JVMCI backend:&quot;, hostArchitecture)) {
 551             hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
 552         }
 553 
 554         compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
 555         if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
 556             hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
 557             if (hsCompilerFactory.getCompilationLevelAdjustment() != None) {
 558                 String name = HotSpotJVMCICompilerFactory.class.getName();
 559                 String msg = String.format(&quot;%s.getCompilationLevelAdjustment() is no longer supported. &quot; +
 560                                 &quot;Use %s.excludeFromJVMCICompilation() instead.&quot;, name, name);
 561                 throw new UnsupportedOperationException(msg);
 562             }
 563         } else {
 564             hsCompilerFactory = null;
 565         }
 566 
 567         if (config.getFlag(&quot;JVMCIPrintProperties&quot;, Boolean.class)) {
 568             if (vmLogStream == null) {
 569                 vmLogStream = new PrintStream(getLogStream());
 570             }
 571             Option.printProperties(vmLogStream);
 572             compilerFactory.printProperties(vmLogStream);
 573             System.exit(0);
 574         }
 575 
 576         if (Option.PrintConfig.getBoolean()) {
 577             configStore.printConfig();
 578         }
 579     }
 580 
 581     HotSpotResolvedJavaType createClass(Class&lt;?&gt; javaClass) {
 582         if (javaClass.isPrimitive()) {
 583             return HotSpotResolvedPrimitiveType.forKind(JavaKind.fromJavaClass(javaClass));
 584         }
 585         if (IS_IN_NATIVE_IMAGE) {
 586             try {
 587                 return compilerToVm.lookupType(javaClass.getName().replace(&#39;.&#39;, &#39;/&#39;), null, true);
 588             } catch (ClassNotFoundException e) {
 589                 throw new JVMCIError(e);
 590             }
 591         }
 592         return compilerToVm.lookupClass(javaClass);
 593     }
 594 
 595     private HotSpotResolvedJavaType fromClass0(Class&lt;?&gt; javaClass) {
 596         if (resolvedJavaType == null) {
 597             synchronized (this) {
 598                 if (resolvedJavaType == null) {
 599                     resolvedJavaType = new ClassValue&lt;&gt;() {
 600                         @Override
 601                         protected WeakReferenceHolder&lt;HotSpotResolvedJavaType&gt; computeValue(Class&lt;?&gt; type) {
 602                             return new WeakReferenceHolder&lt;&gt;(createClass(type));
 603                         }
 604                     };
 605                 }
 606             }
 607         }
 608 
 609         WeakReferenceHolder&lt;HotSpotResolvedJavaType&gt; ref = resolvedJavaType.get(javaClass);
 610         HotSpotResolvedJavaType javaType = ref.get();
 611         if (javaType == null) {
 612             /*
 613              * If the referent has become null, create a new value and update cached weak reference.
 614              */
 615             javaType = createClass(javaClass);
 616             ref.set(javaType);
 617         }
 618         return javaType;
 619     }
 620 
 621     /**
 622      * Gets the JVMCI mirror for a {@link Class} object.
 623      *
 624      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
 625      */
 626     HotSpotResolvedJavaType fromClass(Class&lt;?&gt; javaClass) {
 627         if (javaClass == null) {
 628             return null;
 629         }
 630         return fromClass0(javaClass);
 631     }
 632 
 633     synchronized HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer, String signature) {
 634         if (resolvedJavaTypes == null) {
 635             resolvedJavaTypes = new HashMap&lt;&gt;();
 636         }
 637         assert klassPointer != 0;
 638         WeakReference&lt;ResolvedJavaType&gt; klassReference = resolvedJavaTypes.get(klassPointer);
 639         HotSpotResolvedObjectTypeImpl javaType = null;
 640         if (klassReference != null) {
 641             javaType = (HotSpotResolvedObjectTypeImpl) klassReference.get();
 642         }
 643         if (javaType == null) {
 644             javaType = new HotSpotResolvedObjectTypeImpl(klassPointer, signature);
 645             resolvedJavaTypes.put(klassPointer, new WeakReference&lt;&gt;(javaType));
 646         }
 647         return javaType;
 648     }
 649 
 650     private JVMCIBackend registerBackend(JVMCIBackend backend) {
 651         Class&lt;? extends Architecture&gt; arch = backend.getCodeCache().getTarget().arch.getClass();
 652         JVMCIBackend oldValue = backends.put(arch, backend);
 653         assert oldValue == null : &quot;cannot overwrite existing backend for architecture &quot; + arch.getSimpleName();
 654         return backend;
 655     }
 656 
 657     public HotSpotVMConfigStore getConfigStore() {
 658         return configStore;
 659     }
 660 
 661     public HotSpotVMConfig getConfig() {
 662         return config;
 663     }
 664 
 665     public CompilerToVM getCompilerToVM() {
 666         return compilerToVm;
 667     }
 668 
 669     HotSpotJVMCIReflection getReflection() {
 670         return reflection;
 671     }
 672 
 673     /**
 674      * Gets a predicate that determines if a given type can be considered trusted for the purpose of
 675      * intrinsifying methods it declares.
 676      *
 677      * @param compilerLeafClasses classes in the leaves of the module graph comprising the JVMCI
 678      *            compiler.
 679      */
 680     public Predicate&lt;ResolvedJavaType&gt; getIntrinsificationTrustPredicate(Class&lt;?&gt;... compilerLeafClasses) {
 681         return new Predicate&lt;&gt;() {
 682             @Override
 683             public boolean test(ResolvedJavaType type) {
 684                 if (type instanceof HotSpotResolvedObjectTypeImpl) {
 685                     HotSpotResolvedObjectTypeImpl hsType = (HotSpotResolvedObjectTypeImpl) type;
 686                     return compilerToVm.isTrustedForIntrinsics(hsType);
 687                 } else {
 688                     return false;
 689                 }
 690             }
 691         };
 692     }
 693 
 694     /**
 695      * Get the {@link Class} corresponding to {@code type}.
 696      *
 697      * @param type the type for which a {@link Class} is requested
 698      * @return the original Java class corresponding to {@code type} or {@code null} if this runtime
 699      *         does not support mapping {@link ResolvedJavaType} instances to {@link Class}
 700      *         instances
 701      */
 702     public Class&lt;?&gt; getMirror(ResolvedJavaType type) {
 703         if (type instanceof HotSpotResolvedJavaType &amp;&amp; reflection instanceof HotSpotJDKReflection) {
 704             return ((HotSpotJDKReflection) reflection).getMirror((HotSpotResolvedJavaType) type);
 705         }
 706         return null;
 707     }
 708 
 709     @Override
 710     public JVMCICompiler getCompiler() {
 711         if (compiler == null) {
 712             synchronized (this) {
 713                 if (compiler == null) {
 714                     assert !creatingCompiler : &quot;recursive compiler creation&quot;;
 715                     creatingCompiler = true;
 716                     compiler = compilerFactory.createCompiler(this);
 717                     creatingCompiler = false;
 718                 }
 719             }
 720         }
 721         return compiler;
 722     }
 723 
 724     /**
 725      * Converts a name to a Java type. This method attempts to resolve {@code name} to a
 726      * {@link ResolvedJavaType}.
 727      *
 728      * @param name a well formed Java type in {@linkplain JavaType#getName() internal} format
 729      * @param accessingType the context of resolution which must be non-null
 730      * @param resolve specifies whether resolution failure results in an unresolved type being
 731      *            return or a {@link LinkageError} being thrown
 732      * @return a Java type for {@code name} which is guaranteed to be of type
 733      *         {@link ResolvedJavaType} if {@code resolve == true}
 734      * @throws LinkageError if {@code resolve == true} and the resolution failed
 735      * @throws NullPointerException if {@code accessingClass} is {@code null}
 736      */
 737     public JavaType lookupType(String name, HotSpotResolvedObjectType accessingType, boolean resolve) {
 738         Objects.requireNonNull(accessingType, &quot;cannot resolve type without an accessing class&quot;);
 739         return lookupTypeInternal(name, accessingType, resolve);
 740     }
 741 
 742     JavaType lookupTypeInternal(String name, HotSpotResolvedObjectType accessingType, boolean resolve) {
 743         // If the name represents a primitive type we can short-circuit the lookup.
 744         if (name.length() == 1) {
 745             JavaKind kind = JavaKind.fromPrimitiveOrVoidTypeChar(name.charAt(0));
 746             return HotSpotResolvedPrimitiveType.forKind(kind);
 747         }
 748 
 749         // Resolve non-primitive types in the VM.
 750         HotSpotResolvedObjectTypeImpl hsAccessingType = (HotSpotResolvedObjectTypeImpl) accessingType;
 751         try {
 752             final HotSpotResolvedJavaType klass = compilerToVm.lookupType(name, hsAccessingType, resolve);
 753 
 754             if (klass == null) {
 755                 assert resolve == false : name;
 756                 return UnresolvedJavaType.create(name);
 757             }
 758             return klass;
 759         } catch (ClassNotFoundException e) {
 760             throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);
 761         }
 762     }
 763 
 764     @Override
 765     public JVMCIBackend getHostJVMCIBackend() {
 766         return hostBackend;
 767     }
 768 
 769     @Override
 770     public &lt;T extends Architecture&gt; JVMCIBackend getJVMCIBackend(Class&lt;T&gt; arch) {
 771         assert arch != Architecture.class;
 772         return backends.get(arch);
 773     }
 774 
 775     public Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; getJVMCIBackends() {
 776         return Collections.unmodifiableMap(backends);
 777     }
 778 
 779     @SuppressWarnings(&quot;try&quot;)
 780     @VMEntryPoint
 781     private HotSpotCompilationRequestResult compileMethod(HotSpotResolvedJavaMethod method, int entryBCI, long compileState, int id) {
 782         HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, compileState, id);
 783         CompilationRequestResult result = getCompiler().compileMethod(request);
 784         assert result != null : &quot;compileMethod must always return something&quot;;
 785         HotSpotCompilationRequestResult hsResult;
 786         if (result instanceof HotSpotCompilationRequestResult) {
 787             hsResult = (HotSpotCompilationRequestResult) result;
 788         } else {
 789             Object failure = result.getFailure();
 790             if (failure != null) {
 791                 boolean retry = false; // Be conservative with unknown compiler
 792                 hsResult = HotSpotCompilationRequestResult.failure(failure.toString(), retry);
 793             } else {
 794                 int inlinedBytecodes = -1;
 795                 hsResult = HotSpotCompilationRequestResult.success(inlinedBytecodes);
 796             }
 797         }
 798         return hsResult;
 799     }
 800 
 801     /**
 802      * Guard to ensure shut down actions are performed at most once.
 803      */
 804     private boolean isShutdown;
 805 
 806     /**
 807      * Shuts down the runtime.
 808      */
 809     @VMEntryPoint
 810     private synchronized void shutdown() throws Exception {
 811         if (!isShutdown) {
 812             isShutdown = true;
 813             // Cleaners are normally only processed when a new Cleaner is
 814             // instantiated so process all remaining cleaners now.
 815             Cleaner.clean();
 816 
 817             for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 818                 vmEventListener.notifyShutdown();
 819             }
 820         }
 821     }
 822 
 823     /**
 824      * Notify on completion of a bootstrap.
 825      */
 826     @VMEntryPoint
 827     private void bootstrapFinished() throws Exception {
 828         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 829             vmEventListener.notifyBootstrapFinished();
 830         }
 831     }
 832 
 833     /**
 834      * Notify on successful install into the CodeCache.
 835      *
 836      * @param hotSpotCodeCacheProvider
 837      * @param installedCode
 838      * @param compiledCode
 839      */
 840     void notifyInstall(HotSpotCodeCacheProvider hotSpotCodeCacheProvider, InstalledCode installedCode, CompiledCode compiledCode) {
 841         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 842             vmEventListener.notifyInstall(hotSpotCodeCacheProvider, installedCode, compiledCode);
 843         }
 844     }
 845 
 846     /**
 847      * Writes {@code length} bytes from {@code bytes} starting at offset {@code offset} to HotSpot&#39;s
 848      * log stream.
 849      *
 850      * @param flush specifies if the log stream should be flushed after writing
 851      * @param canThrow specifies if an error in the {@code bytes}, {@code offset} or {@code length}
 852      *            arguments should result in an exception or a negative return value. If
 853      *            {@code false}, this call will not perform any heap allocation
 854      * @return 0 on success, -1 if {@code bytes == null &amp;&amp; !canThrow}, -2 if {@code !canThrow} and
 855      *         copying would cause access of data outside array bounds
 856      * @throws NullPointerException if {@code bytes == null}
 857      * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
 858      */
 859     public int writeDebugOutput(byte[] bytes, int offset, int length, boolean flush, boolean canThrow) {
 860         return compilerToVm.writeDebugOutput(bytes, offset, length, flush, canThrow);
 861     }
 862 
 863     /**
 864      * Gets an output stream that writes to HotSpot&#39;s {@code tty} stream.
 865      */
 866     public OutputStream getLogStream() {
 867         return new OutputStream() {
 868 
 869             @Override
 870             public void write(byte[] b, int off, int len) throws IOException {
 871                 if (b == null) {
 872                     throw new NullPointerException();
 873                 } else if (off &lt; 0 || off &gt; b.length || len &lt; 0 || (off + len) &gt; b.length || (off + len) &lt; 0) {
 874                     throw new IndexOutOfBoundsException();
 875                 } else if (len == 0) {
 876                     return;
 877                 }
 878                 compilerToVm.writeDebugOutput(b, off, len, false, true);
 879             }
 880 
 881             @Override
 882             public void write(int b) throws IOException {
 883                 write(new byte[]{(byte) b}, 0, 1);
 884             }
 885 
 886             @Override
 887             public void flush() throws IOException {
 888                 compilerToVm.flushDebugOutput();
 889             }
 890         };
 891     }
 892 
 893     /**
 894      * Collects the current values of all JVMCI benchmark counters, summed up over all threads.
 895      */
 896     public long[] collectCounters() {
 897         return compilerToVm.collectCounters();
 898     }
 899 
 900     /**
 901      * @return the current number of per thread counters. May be set through
 902      *         {@code -XX:JVMCICompilerSize=} command line option or the
 903      *         {@link #setCountersSize(int)} call.
 904      */
 905     public int getCountersSize() {
 906         return compilerToVm.getCountersSize();
 907     }
 908 
 909     /**
 910      * Enlarge the number of per thread counters available. Requires a safepoint so
 911      * resizing should be rare to avoid performance effects.
 912      *
 913      * @param newSize
 914      */
 915     public void setCountersSize(int newSize) {
 916         compilerToVm.setCountersSize(newSize);
 917     }
 918 
 919     /**
 920      * The offset from the origin of an array to the first element.
 921      *
 922      * @return the offset in bytes
 923      */
 924     public int getArrayBaseOffset(JavaKind kind) {
 925         switch (kind) {
 926             case Boolean:
 927                 return compilerToVm.ARRAY_BOOLEAN_BASE_OFFSET;
 928             case Byte:
 929                 return compilerToVm.ARRAY_BYTE_BASE_OFFSET;
 930             case Char:
 931                 return compilerToVm.ARRAY_CHAR_BASE_OFFSET;
 932             case Short:
 933                 return compilerToVm.ARRAY_SHORT_BASE_OFFSET;
 934             case Int:
 935                 return compilerToVm.ARRAY_INT_BASE_OFFSET;
 936             case Long:
 937                 return compilerToVm.ARRAY_LONG_BASE_OFFSET;
 938             case Float:
 939                 return compilerToVm.ARRAY_FLOAT_BASE_OFFSET;
 940             case Double:
 941                 return compilerToVm.ARRAY_DOUBLE_BASE_OFFSET;
 942             case Object:
 943                 return compilerToVm.ARRAY_OBJECT_BASE_OFFSET;
 944             default:
 945                 throw new JVMCIError(&quot;%s&quot;, kind);
 946         }
 947 
 948     }
 949 
 950     /**
 951      * The scale used for the index when accessing elements of an array of this kind.
 952      *
 953      * @return the scale in order to convert the index into a byte offset
 954      */
 955     public int getArrayIndexScale(JavaKind kind) {
 956         switch (kind) {
 957             case Boolean:
 958                 return compilerToVm.ARRAY_BOOLEAN_INDEX_SCALE;
 959             case Byte:
 960                 return compilerToVm.ARRAY_BYTE_INDEX_SCALE;
 961             case Char:
 962                 return compilerToVm.ARRAY_CHAR_INDEX_SCALE;
 963             case Short:
 964                 return compilerToVm.ARRAY_SHORT_INDEX_SCALE;
 965             case Int:
 966                 return compilerToVm.ARRAY_INT_INDEX_SCALE;
 967             case Long:
 968                 return compilerToVm.ARRAY_LONG_INDEX_SCALE;
 969             case Float:
 970                 return compilerToVm.ARRAY_FLOAT_INDEX_SCALE;
 971             case Double:
 972                 return compilerToVm.ARRAY_DOUBLE_INDEX_SCALE;
 973             case Object:
 974                 return compilerToVm.ARRAY_OBJECT_INDEX_SCALE;
 975             default:
 976                 throw new JVMCIError(&quot;%s&quot;, kind);
 977 
 978         }
 979     }
 980 
 981     /**
 982      * Links each native method in {@code clazz} to an implementation in the JVMCI shared library.
 983      * &lt;p&gt;
 984      * A use case for this is a JVMCI compiler implementation that offers an API to Java code
 985      * executing in HotSpot to exercise functionality (mostly) in the JVMCI shared library. For
 986      * example:
 987      *
 988      * &lt;pre&gt;
 989      * package com.jcompile;
 990      *
 991      * import java.lang.reflect.Method;
 992      *
 993      * public static class JCompile {
 994      *     static {
 995      *         HotSpotJVMCIRuntime.runtime().registerNativeMethods(JCompile.class);
 996      *     }
 997      *     public static boolean compile(Method method, String[] options) {
 998      *         // Convert to simpler data types for passing/serializing across native interface
 999      *         long metaspaceMethodHandle = getHandle(method);
1000      *         char[] opts = convertToCharArray(options);
1001      *         return compile(metaspaceMethodHandle, opts);
1002      *     }
1003      *     private static native boolean compile0(long metaspaceMethodHandle, char[] options);
1004      *
1005      *     private static long getHandle(Method method) { ... }
1006      *     private static char[] convertToCharArray(String[] a) { ... }
1007      * }
1008      * &lt;/pre&gt;
1009      *
1010      * The implementation of the native {@code JCompile.compile0} method would be in the JVMCI
1011      * shared library that contains the JVMCI compiler. The {@code JCompile.compile0} implementation
1012      * must be exported as the following JNI-compatible symbol:
1013      *
1014      * &lt;pre&gt;
1015      * Java_com_jcompile_JCompile_compile0
1016      * &lt;/pre&gt;
1017      *
1018      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#resolving_native_method_names&quot;
1019      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#creating_the_vm&quot;
1020      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#invocation_api_functions&quot;
1021      *
1022      *
1023      * @return info about the Java VM in the JVMCI shared library {@code JavaVM*}. The info is
1024      *         encoded in a long array as follows:
1025      *
1026      *         &lt;pre&gt;
1027      *     long[] info = {
1028      *         javaVM, // the {@code JavaVM*} value
1029      *         javaVM-&gt;functions-&gt;reserved0,
1030      *         javaVM-&gt;functions-&gt;reserved1,
1031      *         javaVM-&gt;functions-&gt;reserved2
1032      *     }
1033      *         &lt;/pre&gt;
1034      *
1035      * @throws NullPointerException if {@code clazz == null}
1036      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1037      *             {@code -XX:-UseJVMCINativeLibrary})
1038      * @throws IllegalStateException if the current execution context is the JVMCI shared library
1039      * @throws IllegalArgumentException if {@code clazz} is {@link Class#isPrimitive()}
1040      * @throws UnsatisfiedLinkError if there&#39;s a problem linking a native method in {@code clazz}
1041      *             (no matching JNI symbol or the native method is already linked to a different
1042      *             address)
1043      */
1044     public long[] registerNativeMethods(Class&lt;?&gt; clazz) {
1045         return compilerToVm.registerNativeMethods(clazz);
1046     }
1047 
1048     /**
1049      * Creates or retrieves an object in the peer runtime that mirrors {@code obj}. The types whose
1050      * objects can be translated are:
1051      * &lt;ul&gt;
1052      * &lt;li&gt;{@link HotSpotResolvedJavaMethodImpl},&lt;/li&gt;
1053      * &lt;li&gt;{@link HotSpotResolvedObjectTypeImpl},&lt;/li&gt;
1054      * &lt;li&gt;{@link HotSpotResolvedPrimitiveType},&lt;/li&gt;
1055      * &lt;li&gt;{@link IndirectHotSpotObjectConstantImpl},&lt;/li&gt;
1056      * &lt;li&gt;{@link DirectHotSpotObjectConstantImpl} and&lt;/li&gt;
1057      * &lt;li&gt;{@link HotSpotNmethod}&lt;/li&gt;
1058      * &lt;/ul&gt;
1059      *
1060      * This mechanism can be used to pass and return values between the HotSpot and JVMCI shared
1061      * library runtimes. In the receiving runtime, the value can be converted back to an object with
1062      * {@link #unhand(Class, long)}.
1063      *
1064      * @param obj an object for which an equivalent instance in the peer runtime is requested
1065      * @return a JNI global reference to the mirror of {@code obj} in the peer runtime
1066      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1067      *             {@code -XX:-UseJVMCINativeLibrary})
1068      * @throws IllegalArgumentException if {@code obj} is not of a translatable type
1069      *
1070      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#global_and_local_references&quot;
1071      */
1072     public long translate(Object obj) {
1073         return compilerToVm.translate(obj);
1074     }
1075 
1076     /**
1077      * Dereferences and returns the object referred to by the JNI global reference {@code handle}.
1078      * The global reference is deleted prior to returning. Any further use of {@code handle} is
1079      * invalid.
1080      *
1081      * @param handle a JNI global reference to an object in the current runtime
1082      * @return the object referred to by {@code handle}
1083      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1084      *             {@code -XX:-UseJVMCINativeLibrary})
1085      * @throws ClassCastException if the returned object cannot be cast to {@code type}
1086      *
1087      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#global_and_local_references&quot;
1088      *
1089      */
1090     public &lt;T&gt; T unhand(Class&lt;T&gt; type, long handle) {
1091         return type.cast(compilerToVm.unhand(handle));
1092     }
1093 
1094     /**
1095      * Determines if the current thread is attached to the peer runtime.
1096      *
1097      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1098      *             {@code -XX:-UseJVMCINativeLibrary})
1099      * @throws IllegalStateException if the peer runtime has not been initialized
1100      */
1101     public boolean isCurrentThreadAttached() {
1102         return compilerToVm.isCurrentThreadAttached();
1103     }
1104 
1105     /**
1106      * Gets the address of the HotSpot {@code JavaThread} C++ object for the current thread. This
1107      * will return {@code 0} if called from an unattached JVMCI shared library thread.
1108      */
1109     public long getCurrentJavaThread() {
1110         return compilerToVm.getCurrentJavaThread();
1111     }
1112 
1113     /**
1114      * Ensures the current thread is attached to the peer runtime.
1115      *
1116      * @param asDaemon if the thread is not yet attached, should it be attached as a daemon
1117      * @return {@code true} if this call attached the current thread, {@code false} if the current
1118      *         thread was already attached
1119      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1120      *             {@code -XX:-UseJVMCINativeLibrary})
1121      * @throws IllegalStateException if the peer runtime has not been initialized or there is an
1122      *             error while trying to attach the thread
1123      * @throws ArrayIndexOutOfBoundsException if {@code javaVMInfo} is non-null and is shorter than
1124      *             the length of the array returned by {@link #registerNativeMethods}
1125      */
1126     public boolean attachCurrentThread(boolean asDaemon) {
1127         return compilerToVm.attachCurrentThread(asDaemon);
1128     }
1129 
1130     /**
1131      * Detaches the current thread from the peer runtime.
1132      *
1133      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1134      *             {@code -XX:-UseJVMCINativeLibrary})
1135      * @throws IllegalStateException if the peer runtime has not been initialized or if the current
1136      *             thread is not attached or if there is an error while trying to detach the thread
1137      */
1138     public void detachCurrentThread() {
1139         compilerToVm.detachCurrentThread();
1140     }
1141 
1142     /**
1143      * Informs HotSpot that no method whose module is in {@code modules} is to be compiled
1144      * with {@link #compileMethod}.
1145      *
1146      * @param modules the set of modules containing JVMCI compiler classes
1147      */
1148     public void excludeFromJVMCICompilation(Module...modules) {
1149         this.excludeFromJVMCICompilation = modules.clone();
1150     }
1151 
1152     /**
1153      * Calls {@link System#exit(int)} in HotSpot&#39;s runtime.
1154      */
1155     public void exitHotSpot(int status) {
1156         if (!IS_IN_NATIVE_IMAGE) {
1157             System.exit(status);
1158         }
1159         compilerToVm.callSystemExit(status);
1160     }
1161 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>