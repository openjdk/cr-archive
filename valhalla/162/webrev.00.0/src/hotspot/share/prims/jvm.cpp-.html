<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/javaAssertions.hpp&quot;
  32 #include &quot;classfile/javaClasses.inline.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/stringTable.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  43 #include &quot;jfr/jfrEvents.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/referenceType.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;oops/access.inline.hpp&quot;
  52 #include &quot;oops/constantPool.hpp&quot;
  53 #include &quot;oops/fieldStreams.inline.hpp&quot;
  54 #include &quot;oops/flatArrayKlass.hpp&quot;
  55 #include &quot;oops/instanceKlass.hpp&quot;
  56 #include &quot;oops/method.hpp&quot;
  57 #include &quot;oops/recordComponent.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.inline.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;prims/jvm_misc.hpp&quot;
  62 #include &quot;prims/jvmtiExport.hpp&quot;
  63 #include &quot;prims/jvmtiThreadState.hpp&quot;
  64 #include &quot;prims/nativeLookup.hpp&quot;
  65 #include &quot;prims/stackwalk.hpp&quot;
  66 #include &quot;runtime/arguments.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/handles.inline.hpp&quot;
  69 #include &quot;runtime/init.hpp&quot;
  70 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  71 #include &quot;runtime/deoptimization.hpp&quot;
  72 #include &quot;runtime/handshake.hpp&quot;
  73 #include &quot;runtime/java.hpp&quot;
  74 #include &quot;runtime/javaCalls.hpp&quot;
  75 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  76 #include &quot;runtime/jniHandles.inline.hpp&quot;
  77 #include &quot;runtime/os.inline.hpp&quot;
  78 #include &quot;runtime/perfData.hpp&quot;
  79 #include &quot;runtime/reflection.hpp&quot;
  80 #include &quot;runtime/synchronizer.hpp&quot;
  81 #include &quot;runtime/thread.inline.hpp&quot;
  82 #include &quot;runtime/threadSMR.hpp&quot;
  83 #include &quot;runtime/vframe.inline.hpp&quot;
  84 #include &quot;runtime/vmOperations.hpp&quot;
  85 #include &quot;runtime/vm_version.hpp&quot;
  86 #include &quot;services/attachListener.hpp&quot;
  87 #include &quot;services/management.hpp&quot;
  88 #include &quot;services/threadService.hpp&quot;
  89 #include &quot;utilities/copy.hpp&quot;
  90 #include &quot;utilities/defaultStream.hpp&quot;
  91 #include &quot;utilities/dtrace.hpp&quot;
  92 #include &quot;utilities/events.hpp&quot;
  93 #include &quot;utilities/histogram.hpp&quot;
  94 #include &quot;utilities/macros.hpp&quot;
  95 #include &quot;utilities/utf8.hpp&quot;
  96 #if INCLUDE_CDS
  97 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  98 #endif
  99 
 100 #include &lt;errno.h&gt;
 101 #include &lt;jfr/recorder/jfrRecorder.hpp&gt;
 102 
 103 /*
 104   NOTE about use of any ctor or function call that can trigger a safepoint/GC:
 105   such ctors and calls MUST NOT come between an oop declaration/init and its
 106   usage because if objects are move this may cause various memory stomps, bus
 107   errors and segfaults. Here is a cookbook for causing so called &quot;naked oop
 108   failures&quot;:
 109 
 110       JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields&lt;etc&gt; {
 111           JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
 112 
 113           // Object address to be held directly in mirror &amp; not visible to GC
 114           oop mirror = JNIHandles::resolve_non_null(ofClass);
 115 
 116           // If this ctor can hit a safepoint, moving objects around, then
 117           ComplexConstructor foo;
 118 
 119           // Boom! mirror may point to JUNK instead of the intended object
 120           (some dereference of mirror)
 121 
 122           // Here&#39;s another call that may block for GC, making mirror stale
 123           MutexLocker ml(some_lock);
 124 
 125           // And here&#39;s an initializer that can result in a stale oop
 126           // all in one step.
 127           oop o = call_that_can_throw_exception(TRAPS);
 128 
 129 
 130   The solution is to keep the oop declaration BELOW the ctor or function
 131   call that might cause a GC, do another resolve to reassign the oop, or
 132   consider use of a Handle instead of an oop so there is immunity from object
 133   motion. But note that the &quot;QUICK&quot; entries below do not have a handlemark
 134   and thus can only support use of handles passed in.
 135 */
 136 
 137 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 138   ResourceMark rm;
 139   int line_number = -1;
 140   const char * source_file = NULL;
 141   const char * trace = &quot;explicit&quot;;
 142   InstanceKlass* caller = NULL;
 143   JavaThread* jthread = JavaThread::current();
 144   if (jthread-&gt;has_last_Java_frame()) {
 145     vframeStream vfst(jthread);
 146 
 147     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
 148     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;);
 149     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
 150     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;);
 151     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 152 
 153     Method* last_caller = NULL;
 154 
 155     while (!vfst.at_end()) {
 156       Method* m = vfst.method();
 157       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 158           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 159           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 160         break;
 161       }
 162       last_caller = m;
 163       vfst.next();
 164     }
 165     // if this is called from Class.forName0 and that is called from Class.forName,
 166     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 167     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 168     bool found_it = false;
 169     if (!vfst.at_end() &amp;&amp;
 170         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 171         vfst.method()-&gt;name() == vmSymbols::forName0_name()) {
 172       vfst.next();
 173       if (!vfst.at_end() &amp;&amp;
 174           vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 175           vfst.method()-&gt;name() == vmSymbols::forName_name()) {
 176         vfst.next();
 177         found_it = true;
 178       }
 179     } else if (last_caller != NULL &amp;&amp;
 180                last_caller-&gt;method_holder()-&gt;name() ==
 181                  vmSymbols::java_lang_ClassLoader() &amp;&amp;
 182                last_caller-&gt;name() == vmSymbols::loadClass_name()) {
 183       found_it = true;
 184     } else if (!vfst.at_end()) {
 185       if (vfst.method()-&gt;is_native()) {
 186         // JNI call
 187         found_it = true;
 188       }
 189     }
 190     if (found_it &amp;&amp; !vfst.at_end()) {
 191       // found the caller
 192       caller = vfst.method()-&gt;method_holder();
 193       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 194       if (line_number == -1) {
 195         // show method name if it&#39;s a native method
 196         trace = vfst.method()-&gt;name_and_sig_as_C_string();
 197       }
 198       Symbol* s = caller-&gt;source_file_name();
 199       if (s != NULL) {
 200         source_file = s-&gt;as_C_string();
 201       }
 202     }
 203   }
 204   if (caller != NULL) {
 205     if (to_class != caller) {
 206       const char * from = caller-&gt;external_name();
 207       const char * to = to_class-&gt;external_name();
 208       // print in a single call to reduce interleaving between threads
 209       if (source_file != NULL) {
 210         log_debug(class, resolve)(&quot;%s %s %s:%d (%s)&quot;, from, to, source_file, line_number, trace);
 211       } else {
 212         log_debug(class, resolve)(&quot;%s %s (%s)&quot;, from, to, trace);
 213       }
 214     }
 215   }
 216 }
 217 
 218 void trace_class_resolution(Klass* to_class) {
 219   EXCEPTION_MARK;
 220   trace_class_resolution_impl(to_class, THREAD);
 221   if (HAS_PENDING_EXCEPTION) {
 222     CLEAR_PENDING_EXCEPTION;
 223   }
 224 }
 225 
 226 // Wrapper to trace JVM functions
 227 
 228 #ifdef ASSERT
 229   Histogram* JVMHistogram;
 230   volatile int JVMHistogram_lock = 0;
 231 
 232   class JVMHistogramElement : public HistogramElement {
 233     public:
 234      JVMHistogramElement(const char* name);
 235   };
 236 
 237   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 238     _name = elementName;
 239     uintx count = 0;
 240 
 241     while (Atomic::cmpxchg(&amp;JVMHistogram_lock, 0, 1) != 0) {
 242       while (Atomic::load_acquire(&amp;JVMHistogram_lock) != 0) {
 243         count +=1;
 244         if ( (WarnOnStalledSpinLock &gt; 0)
 245           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 246           warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
 247         }
 248       }
 249      }
 250 
 251     if(JVMHistogram == NULL)
 252       JVMHistogram = new Histogram(&quot;JVM Call Counts&quot;,100);
 253 
 254     JVMHistogram-&gt;add_element(this);
 255     Atomic::dec(&amp;JVMHistogram_lock);
 256   }
 257 
 258   #define JVMCountWrapper(arg) \
 259       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 260       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 261 
 262   #define JVMWrapper(arg) JVMCountWrapper(arg);
 263 #else
 264   #define JVMWrapper(arg)
 265 #endif
 266 
 267 
 268 // Interface version /////////////////////////////////////////////////////////////////////
 269 
 270 
 271 JVM_LEAF(jint, JVM_GetInterfaceVersion())
 272   return JVM_INTERFACE_VERSION;
 273 JVM_END
 274 
 275 
 276 // java.lang.System //////////////////////////////////////////////////////////////////////
 277 
 278 
 279 JVM_LEAF(jlong, JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored))
 280   JVMWrapper(&quot;JVM_CurrentTimeMillis&quot;);
 281   return os::javaTimeMillis();
 282 JVM_END
 283 
 284 JVM_LEAF(jlong, JVM_NanoTime(JNIEnv *env, jclass ignored))
 285   JVMWrapper(&quot;JVM_NanoTime&quot;);
 286   return os::javaTimeNanos();
 287 JVM_END
 288 
 289 // The function below is actually exposed by jdk.internal.misc.VM and not
 290 // java.lang.System, but we choose to keep it here so that it stays next
 291 // to JVM_CurrentTimeMillis and JVM_NanoTime
 292 
 293 const jlong MAX_DIFF_SECS = CONST64(0x0100000000); //  2^32
 294 const jlong MIN_DIFF_SECS = -MAX_DIFF_SECS; // -2^32
 295 
 296 JVM_LEAF(jlong, JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs))
 297   JVMWrapper(&quot;JVM_GetNanoTimeAdjustment&quot;);
 298   jlong seconds;
 299   jlong nanos;
 300 
 301   os::javaTimeSystemUTC(seconds, nanos);
 302 
 303   // We&#39;re going to verify that the result can fit in a long.
 304   // For that we need the difference in seconds between &#39;seconds&#39;
 305   // and &#39;offset_secs&#39; to be such that:
 306   //     |seconds - offset_secs| &lt; (2^63/10^9)
 307   // We&#39;re going to approximate 10^9 ~&lt; 2^30 (1000^3 ~&lt; 1024^3)
 308   // which makes |seconds - offset_secs| &lt; 2^33
 309   // and we will prefer +/- 2^32 as the maximum acceptable diff
 310   // as 2^32 has a more natural feel than 2^33...
 311   //
 312   // So if |seconds - offset_secs| &gt;= 2^32 - we return a special
 313   // sentinel value (-1) which the caller should take as an
 314   // exception value indicating that the offset given to us is
 315   // too far from range of the current time - leading to too big
 316   // a nano adjustment. The caller is expected to recover by
 317   // computing a more accurate offset and calling this method
 318   // again. (For the record 2^32 secs is ~136 years, so that
 319   // should rarely happen)
 320   //
 321   jlong diff = seconds - offset_secs;
 322   if (diff &gt;= MAX_DIFF_SECS || diff &lt;= MIN_DIFF_SECS) {
 323      return -1; // sentinel value: the offset is too far off the target
 324   }
 325 
 326   // return the adjustment. If you compute a time by adding
 327   // this number of nanoseconds along with the number of seconds
 328   // in the offset you should get the current UTC time.
 329   return (diff * (jlong)1000000000) + nanos;
 330 JVM_END
 331 
 332 JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 333                                jobject dst, jint dst_pos, jint length))
 334   JVMWrapper(&quot;JVM_ArrayCopy&quot;);
 335   // Check if we have null pointers
 336   if (src == NULL || dst == NULL) {
 337     THROW(vmSymbols::java_lang_NullPointerException());
 338   }
 339   arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));
 340   arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));
 341   assert(oopDesc::is_oop(s), &quot;JVM_ArrayCopy: src not an oop&quot;);
 342   assert(oopDesc::is_oop(d), &quot;JVM_ArrayCopy: dst not an oop&quot;);
 343   // Do copy
 344   s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);
 345 JVM_END
 346 
 347 
 348 static void set_property(Handle props, const char* key, const char* value, TRAPS) {
 349   JavaValue r(T_OBJECT);
 350   // public synchronized Object put(Object key, Object value);
 351   HandleMark hm(THREAD);
 352   Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK);
 353   Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK);
 354   JavaCalls::call_virtual(&amp;r,
 355                           props,
 356                           SystemDictionary::Properties_klass(),
 357                           vmSymbols::put_name(),
 358                           vmSymbols::object_object_object_signature(),
 359                           key_str,
 360                           value_str,
 361                           THREAD);
 362 }
 363 
 364 
 365 #define PUTPROP(props, name, value) set_property((props), (name), (value), CHECK_(properties));
 366 
 367 /*
 368  * Return all of the system properties in a Java String array with alternating
 369  * names and values from the jvm SystemProperty.
 370  * Which includes some internal and all commandline -D defined properties.
 371  */
 372 JVM_ENTRY(jobjectArray, JVM_GetProperties(JNIEnv *env))
 373   JVMWrapper(&quot;JVM_GetProperties&quot;);
 374   ResourceMark rm(THREAD);
 375   HandleMark hm(THREAD);
 376   int ndx = 0;
 377   int fixedCount = 2;
 378 
 379   SystemProperty* p = Arguments::system_properties();
 380   int count = Arguments::PropertyList_count(p);
 381 
 382   // Allocate result String array
 383   InstanceKlass* ik = SystemDictionary::String_klass();
 384   objArrayOop r = oopFactory::new_objArray(ik, (count + fixedCount) * 2, CHECK_NULL);
 385   objArrayHandle result_h(THREAD, r);
 386 
 387   while (p != NULL) {
 388     const char * key = p-&gt;key();
 389     if (strcmp(key, &quot;sun.nio.MaxDirectMemorySize&quot;) != 0) {
 390         const char * value = p-&gt;value();
 391         Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK_NULL);
 392         Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK_NULL);
 393         result_h-&gt;obj_at_put(ndx * 2,  key_str());
 394         result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 395         ndx++;
 396     }
 397     p = p-&gt;next();
 398   }
 399 
 400   // Convert the -XX:MaxDirectMemorySize= command line flag
 401   // to the sun.nio.MaxDirectMemorySize property.
 402   // Do this after setting user properties to prevent people
 403   // from setting the value with a -D option, as requested.
 404   // Leave empty if not supplied
 405   if (!FLAG_IS_DEFAULT(MaxDirectMemorySize)) {
 406     char as_chars[256];
 407     jio_snprintf(as_chars, sizeof(as_chars), JULONG_FORMAT, MaxDirectMemorySize);
 408     Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.nio.MaxDirectMemorySize&quot;, CHECK_NULL);
 409     Handle value_str  = java_lang_String::create_from_platform_dependent_str(as_chars, CHECK_NULL);
 410     result_h-&gt;obj_at_put(ndx * 2,  key_str());
 411     result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 412     ndx++;
 413   }
 414 
 415   // JVM monitoring and management support
 416   // Add the sun.management.compiler property for the compiler&#39;s name
 417   {
 418 #undef CSIZE
 419 #if defined(_LP64) || defined(_WIN64)
 420   #define CSIZE &quot;64-Bit &quot;
 421 #else
 422   #define CSIZE
 423 #endif // 64bit
 424 
 425 #ifdef TIERED
 426     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Tiered Compilers&quot;;
 427 #else
 428 #if defined(COMPILER1)
 429     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Client Compiler&quot;;
 430 #elif defined(COMPILER2)
 431     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Server Compiler&quot;;
 432 #elif INCLUDE_JVMCI
 433     #error &quot;INCLUDE_JVMCI should imply TIERED&quot;
 434 #else
 435     const char* compiler_name = &quot;&quot;;
 436 #endif // compilers
 437 #endif // TIERED
 438 
 439     if (*compiler_name != &#39;\0&#39; &amp;&amp;
 440         (Arguments::mode() != Arguments::_int)) {
 441       Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.management.compiler&quot;, CHECK_NULL);
 442       Handle value_str  = java_lang_String::create_from_platform_dependent_str(compiler_name, CHECK_NULL);
 443       result_h-&gt;obj_at_put(ndx * 2,  key_str());
 444       result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 445       ndx++;
 446     }
 447   }
 448 
 449   return (jobjectArray) JNIHandles::make_local(env, result_h());
 450 JVM_END
 451 
 452 
 453 /*
 454  * Return the temporary directory that the VM uses for the attach
 455  * and perf data files.
 456  *
 457  * It is important that this directory is well-known and the
 458  * same for all VM instances. It cannot be affected by configuration
 459  * variables such as java.io.tmpdir.
 460  */
 461 JVM_ENTRY(jstring, JVM_GetTemporaryDirectory(JNIEnv *env))
 462   JVMWrapper(&quot;JVM_GetTemporaryDirectory&quot;);
 463   HandleMark hm(THREAD);
 464   const char* temp_dir = os::get_temp_directory();
 465   Handle h = java_lang_String::create_from_platform_dependent_str(temp_dir, CHECK_NULL);
 466   return (jstring) JNIHandles::make_local(env, h());
 467 JVM_END
 468 
 469 
 470 // java.lang.Runtime /////////////////////////////////////////////////////////////////////////
 471 
 472 extern volatile jint vm_created;
 473 
 474 JVM_ENTRY_NO_ENV(void, JVM_BeforeHalt())
 475   JVMWrapper(&quot;JVM_BeforeHalt&quot;);
 476   // Link all classes for dynamic CDS dumping before vm exit.
 477   if (DynamicDumpSharedSpaces) {
 478     MetaspaceShared::link_and_cleanup_shared_classes(THREAD);
 479   }
 480   EventShutdown event;
 481   if (event.should_commit()) {
 482     event.set_reason(&quot;Shutdown requested from Java&quot;);
 483     event.commit();
 484   }
 485 JVM_END
 486 
 487 
 488 JVM_ENTRY_NO_ENV(void, JVM_Halt(jint code))
 489   before_exit(thread);
 490   vm_exit(code);
 491 JVM_END
 492 
 493 
 494 JVM_ENTRY_NO_ENV(void, JVM_GC(void))
 495   JVMWrapper(&quot;JVM_GC&quot;);
 496   if (!DisableExplicitGC) {
 497     Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);
 498   }
 499 JVM_END
 500 
 501 
 502 JVM_LEAF(jlong, JVM_MaxObjectInspectionAge(void))
 503   JVMWrapper(&quot;JVM_MaxObjectInspectionAge&quot;);
 504   return Universe::heap()-&gt;millis_since_last_gc();
 505 JVM_END
 506 
 507 
 508 static inline jlong convert_size_t_to_jlong(size_t val) {
 509   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 510   NOT_LP64 (return (jlong)val;)
 511   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 512 }
 513 
 514 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 515   JVMWrapper(&quot;JVM_TotalMemory&quot;);
 516   size_t n = Universe::heap()-&gt;capacity();
 517   return convert_size_t_to_jlong(n);
 518 JVM_END
 519 
 520 
 521 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 522   JVMWrapper(&quot;JVM_FreeMemory&quot;);
 523   size_t n = Universe::heap()-&gt;unused();
 524   return convert_size_t_to_jlong(n);
 525 JVM_END
 526 
 527 
 528 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 529   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 530   size_t n = Universe::heap()-&gt;max_capacity();
 531   return convert_size_t_to_jlong(n);
 532 JVM_END
 533 
 534 
 535 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 536   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 537   return os::active_processor_count();
 538 JVM_END
 539 
 540 
 541 
 542 // java.lang.Throwable //////////////////////////////////////////////////////
 543 
 544 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 545   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 546   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 547   java_lang_Throwable::fill_in_stack_trace(exception);
 548 JVM_END
 549 
 550 // java.lang.NullPointerException ///////////////////////////////////////////
 551 
 552 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))
 553   if (!ShowCodeDetailsInExceptionMessages) return NULL;
 554 
 555   oop exc = JNIHandles::resolve_non_null(throwable);
 556 
 557   Method* method;
 558   int bci;
 559   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {
 560     return NULL;
 561   }
 562   if (method-&gt;is_native()) {
 563     return NULL;
 564   }
 565 
 566   stringStream ss;
 567   bool ok = BytecodeUtils::get_NPE_message_at(&amp;ss, method, bci);
 568   if (ok) {
 569     oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_NULL);
 570     return (jstring) JNIHandles::make_local(env, result);
 571   } else {
 572     return NULL;
 573   }
 574 JVM_END
 575 
 576 // java.lang.StackTraceElement //////////////////////////////////////////////
 577 
 578 
 579 JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
 580   JVMWrapper(&quot;JVM_InitStackTraceElementArray&quot;);
 581   Handle exception(THREAD, JNIHandles::resolve(throwable));
 582   objArrayOop st = objArrayOop(JNIHandles::resolve(elements));
 583   objArrayHandle stack_trace(THREAD, st);
 584   // Fill in the allocated stack trace
 585   java_lang_Throwable::get_stack_trace_elements(exception, stack_trace, CHECK);
 586 JVM_END
 587 
 588 
 589 JVM_ENTRY(void, JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo))
 590   JVMWrapper(&quot;JVM_InitStackTraceElement&quot;);
 591   Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(stackFrameInfo));
 592   Handle stack_trace_element(THREAD, JNIHandles::resolve_non_null(element));
 593   java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);
 594 JVM_END
 595 
 596 
 597 // java.lang.StackWalker //////////////////////////////////////////////////////
 598 
 599 
 600 JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 601                                      jint skip_frames, jint frame_count, jint start_index,
 602                                      jobjectArray frames))
 603   JVMWrapper(&quot;JVM_CallStackWalk&quot;);
 604   JavaThread* jt = (JavaThread*) THREAD;
 605   if (!jt-&gt;is_Java_thread() || !jt-&gt;has_last_Java_frame()) {
 606     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;doStackWalk: no stack trace&quot;, NULL);
 607   }
 608 
 609   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 610 
 611   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 612   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 613   // be null.
 614   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 615   objArrayHandle frames_array_h(THREAD, fa);
 616 
 617   int limit = start_index + frame_count;
 618   if (frames_array_h-&gt;length() &lt; limit) {
 619     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;, NULL);
 620   }
 621 
 622   oop result = StackWalk::walk(stackStream_h, mode, skip_frames, frame_count,
 623                                start_index, frames_array_h, CHECK_NULL);
 624   return JNIHandles::make_local(env, result);
 625 JVM_END
 626 
 627 
 628 JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 629                                   jint frame_count, jint start_index,
 630                                   jobjectArray frames))
 631   JVMWrapper(&quot;JVM_MoreStackWalk&quot;);
 632   JavaThread* jt = (JavaThread*) THREAD;
 633 
 634   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 635   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 636   // be null.
 637   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 638   objArrayHandle frames_array_h(THREAD, fa);
 639 
 640   int limit = start_index+frame_count;
 641   if (frames_array_h-&gt;length() &lt; limit) {
 642     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 643   }
 644 
 645   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 646   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 647                                    start_index, frames_array_h, THREAD);
 648 JVM_END
 649 
 650 // java.lang.Object ///////////////////////////////////////////////
 651 
 652 
 653 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 654   JVMWrapper(&quot;JVM_IHashCode&quot;);
 655   // as implemented in the classic virtual machine; return 0 if object is NULL
 656   if (handle == NULL) {
 657     return 0;
 658   }
 659   oop obj = JNIHandles::resolve_non_null(handle);
 660   if (EnableValhalla &amp;&amp; obj-&gt;klass()-&gt;is_inline_klass()) {
 661       JavaValue result(T_INT);
 662       JavaCallArguments args;
 663       Handle ho(THREAD, obj);
 664       args.push_oop(ho);
 665       methodHandle method(THREAD, Universe::inline_type_hash_code_method());
 666       JavaCalls::call(&amp;result, method, &amp;args, THREAD);
 667       if (HAS_PENDING_EXCEPTION) {
 668         if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::Error_klass())) {
 669           Handle e(THREAD, PENDING_EXCEPTION);
 670           CLEAR_PENDING_EXCEPTION;
 671           THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), &quot;Internal error in hashCode&quot;, e, false);
 672         }
 673       }
 674       return result.get_jint();
 675   } else {
 676     return ObjectSynchronizer::FastHashCode(THREAD, obj);
 677   }
 678 JVM_END
 679 
 680 
 681 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 682   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 683   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 684   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 685   if (JvmtiExport::should_post_monitor_wait()) {
 686     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 687 
 688     // The current thread already owns the monitor and it has not yet
 689     // been added to the wait queue so the current thread cannot be
 690     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 691     // event handler cannot accidentally consume an unpark() meant for
 692     // the ParkEvent associated with this ObjectMonitor.
 693   }
 694   ObjectSynchronizer::wait(obj, ms, CHECK);
 695 JVM_END
 696 
 697 
 698 JVM_ENTRY(void, JVM_MonitorNotify(JNIEnv* env, jobject handle))
 699   JVMWrapper(&quot;JVM_MonitorNotify&quot;);
 700   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 701   ObjectSynchronizer::notify(obj, CHECK);
 702 JVM_END
 703 
 704 
 705 JVM_ENTRY(void, JVM_MonitorNotifyAll(JNIEnv* env, jobject handle))
 706   JVMWrapper(&quot;JVM_MonitorNotifyAll&quot;);
 707   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 708   ObjectSynchronizer::notifyall(obj, CHECK);
 709 JVM_END
 710 
 711 
 712 JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))
 713   JVMWrapper(&quot;JVM_Clone&quot;);
 714   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 715   Klass* klass = obj-&gt;klass();
 716   JvmtiVMObjectAllocEventCollector oam;
 717 
 718 #ifdef ASSERT
 719   // Just checking that the cloneable flag is set correct
 720   if (obj-&gt;is_array()) {
 721     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 722   } else {
 723     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 724     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 725     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 726   }
 727 #endif
 728 
 729   // Check if class of obj supports the Cloneable interface.
 730   // All arrays are considered to be cloneable (See JLS 20.1.5).
 731   // All j.l.r.Reference classes are considered non-cloneable.
 732   if (!klass-&gt;is_cloneable() ||
 733        klass-&gt;is_inline_klass() ||
 734       (klass-&gt;is_instance_klass() &amp;&amp;
 735        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 736     ResourceMark rm(THREAD);
 737     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 738   }
 739 
 740   // Make shallow object copy
 741   const int size = obj-&gt;size();
 742   oop new_obj_oop = NULL;
 743   if (obj-&gt;is_array()) {
 744     const int length = ((arrayOop)obj())-&gt;length();
 745     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 746                                                    /* do_zero */ true, CHECK_NULL);
 747   } else {
 748     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 749   }
 750 
 751   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 752 
 753   Handle new_obj(THREAD, new_obj_oop);
 754   // Caution: this involves a java upcall, so the clone should be
 755   // &quot;gc-robust&quot; by this stage.
 756   if (klass-&gt;has_finalizer()) {
 757     assert(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 758     new_obj_oop = InstanceKlass::register_finalizer(instanceOop(new_obj()), CHECK_NULL);
 759     new_obj = Handle(THREAD, new_obj_oop);
 760   }
 761 
 762   return JNIHandles::make_local(env, new_obj());
 763 JVM_END
 764 
 765 // java.io.File ///////////////////////////////////////////////////////////////
 766 
 767 JVM_LEAF(char*, JVM_NativePath(char* path))
 768   JVMWrapper(&quot;JVM_NativePath&quot;);
 769   return os::native_path(path);
 770 JVM_END
 771 
 772 
 773 // Misc. class handling ///////////////////////////////////////////////////////////
 774 
 775 
 776 JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env))
 777   JVMWrapper(&quot;JVM_GetCallerClass&quot;);
 778 
 779   // Getting the class of the caller frame.
 780   //
 781   // The call stack at this point looks something like this:
 782   //
 783   // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
 784   // [1] [ @CallerSensitive API.method                                   ]
 785   // [.] [ (skipped intermediate frames)                                 ]
 786   // [n] [ caller                                                        ]
 787   vframeStream vfst(thread);
 788   // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
 789   for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
 790     Method* m = vfst.method();
 791     assert(m != NULL, &quot;sanity&quot;);
 792     switch (n) {
 793     case 0:
 794       // This must only be called from Reflection.getCallerClass
 795       if (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
 796         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetCallerClass must only be called from Reflection.getCallerClass&quot;);
 797       }
 798       // fall-through
 799     case 1:
 800       // Frame 0 and 1 must be caller sensitive.
 801       if (!m-&gt;caller_sensitive()) {
 802         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&quot;CallerSensitive annotation expected at frame %d&quot;, n));
 803       }
 804       break;
 805     default:
 806       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 807         // We have reached the desired frame; return the holder class.
 808         return (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());
 809       }
 810       break;
 811     }
 812   }
 813   return NULL;
 814 JVM_END
 815 
 816 
 817 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 818   JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
 819   oop mirror = NULL;
 820   BasicType t = name2type(utf);
 821   if (t != T_ILLEGAL &amp;&amp; !is_reference_type(t)) {
 822     mirror = Universe::java_mirror(t);
 823   }
 824   if (mirror == NULL) {
 825     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 826   } else {
 827     return (jclass) JNIHandles::make_local(env, mirror);
 828   }
 829 JVM_END
 830 
 831 
 832 // Returns a class loaded by the bootstrap class loader; or null
 833 // if not found.  ClassNotFoundException is not thrown.
 834 // FindClassFromBootLoader is exported to the launcher for windows.
 835 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 836                                               const char* name))
 837   JVMWrapper(&quot;JVM_FindClassFromBootLoader&quot;);
 838 
 839   // Java libraries should ensure that name is never null or illegal.
 840   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 841     // It&#39;s impossible to create this class;  the name cannot fit
 842     // into the constant pool.
 843     return NULL;
 844   }
 845   assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false), &quot;illegal UTF name&quot;);
 846 
 847   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 848   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 849   if (k == NULL) {
 850     return NULL;
 851   }
 852 
 853   if (log_is_enabled(Debug, class, resolve)) {
 854     trace_class_resolution(k);
 855   }
 856   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 857 JVM_END
 858 
 859 // Find a class with this name in this loader, using the caller&#39;s protection domain.
 860 JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
 861                                           jboolean init, jobject loader,
 862                                           jclass caller))
 863   JVMWrapper(&quot;JVM_FindClassFromCaller throws ClassNotFoundException&quot;);
 864 
 865   TempNewSymbol h_name =
 866        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),
 867                                            CHECK_NULL);
 868 
 869   oop loader_oop = JNIHandles::resolve(loader);
 870   oop from_class = JNIHandles::resolve(caller);
 871   oop protection_domain = NULL;
 872   // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
 873   // NPE. Put it in another way, the bootstrap class loader has all permission and
 874   // thus no checkPackageAccess equivalence in the VM class loader.
 875   // The caller is also passed as NULL by the java code if there is no security
 876   // manager to avoid the performance cost of getting the calling class.
 877   if (from_class != NULL &amp;&amp; loader_oop != NULL) {
 878     protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain();
 879   }
 880 
 881   Handle h_loader(THREAD, loader_oop);
 882   Handle h_prot(THREAD, protection_domain);
 883   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 884                                                h_prot, false, THREAD);
 885 
 886   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 887     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 888   }
 889   return result;
 890 JVM_END
 891 
 892 // Currently only called from the old verifier.
 893 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 894                                          jboolean init, jclass from))
 895   JVMWrapper(&quot;JVM_FindClassFromClass&quot;);
 896   TempNewSymbol h_name =
 897        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),
 898                                            CHECK_NULL);
 899   oop from_class_oop = JNIHandles::resolve(from);
 900   Klass* from_class = (from_class_oop == NULL)
 901                            ? (Klass*)NULL
 902                            : java_lang_Class::as_Klass(from_class_oop);
 903   oop class_loader = NULL;
 904   oop protection_domain = NULL;
 905   if (from_class != NULL) {
 906     class_loader = from_class-&gt;class_loader();
 907     protection_domain = from_class-&gt;protection_domain();
 908   }
 909   Handle h_loader(THREAD, class_loader);
 910   Handle h_prot  (THREAD, protection_domain);
 911   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 912                                                h_prot, true, thread);
 913 
 914   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 915     // this function is generally only used for class loading during verification.
 916     ResourceMark rm;
 917     oop from_mirror = JNIHandles::resolve_non_null(from);
 918     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
 919     const char * from_name = from_class-&gt;external_name();
 920 
 921     oop mirror = JNIHandles::resolve_non_null(result);
 922     Klass* to_class = java_lang_Class::as_Klass(mirror);
 923     const char * to = to_class-&gt;external_name();
 924     log_debug(class, resolve)(&quot;%s %s (verification)&quot;, from_name, to);
 925   }
 926 
 927   return result;
 928 JVM_END
 929 
 930 static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {
 931   if (loader.is_null()) {
 932     return;
 933   }
 934 
 935   // check whether the current caller thread holds the lock or not.
 936   // If not, increment the corresponding counter
 937   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=
 938       ObjectSynchronizer::owner_self) {
 939     counter-&gt;inc();
 940   }
 941 }
 942 
 943 // common code for JVM_DefineClass() and JVM_DefineClassWithSource()
 944 static jclass jvm_define_class_common(JNIEnv *env, const char *name,
 945                                       jobject loader, const jbyte *buf,
 946                                       jsize len, jobject pd, const char *source,
 947                                       TRAPS) {
 948   if (source == NULL)  source = &quot;__JVM_DefineClass__&quot;;
 949 
 950   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 951   JavaThread* jt = (JavaThread*) THREAD;
 952 
 953   PerfClassTraceTime vmtimer(ClassLoader::perf_define_appclass_time(),
 954                              ClassLoader::perf_define_appclass_selftime(),
 955                              ClassLoader::perf_define_appclasses(),
 956                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 957                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 958                              PerfClassTraceTime::DEFINE_CLASS);
 959 
 960   if (UsePerfData) {
 961     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 962   }
 963 
 964   // Class resolution will get the class name from the .class stream if the name is null.
 965   TempNewSymbol class_name = name == NULL ? NULL :
 966        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
 967                                            CHECK_NULL);
 968 
 969   ResourceMark rm(THREAD);
 970   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
 971   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 972   if (UsePerfData) {
 973     is_lock_held_by_thread(class_loader,
 974                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 975                            THREAD);
 976   }
 977   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 978   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 979                                                    class_loader,
 980                                                    protection_domain,
 981                                                    &amp;st,
 982                                                    CHECK_NULL);
 983 
 984   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 985     trace_class_resolution(k);
 986   }
 987 
 988   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 989 }
 990 
 991 enum {
 992   NESTMATE              = java_lang_invoke_MemberName::MN_NESTMATE_CLASS,
 993   HIDDEN_CLASS          = java_lang_invoke_MemberName::MN_HIDDEN_CLASS,
 994   STRONG_LOADER_LINK    = java_lang_invoke_MemberName::MN_STRONG_LOADER_LINK,
 995   ACCESS_VM_ANNOTATIONS = java_lang_invoke_MemberName::MN_ACCESS_VM_ANNOTATIONS
 996 };
 997 
 998 /*
 999  * Define a class with the specified flags that indicates if it&#39;s a nestmate,
1000  * hidden, or strongly referenced from class loader.
1001  */
1002 static jclass jvm_lookup_define_class(JNIEnv *env, jclass lookup, const char *name,
1003                                       const jbyte *buf, jsize len, jobject pd,
1004                                       jboolean init, int flags, jobject classData, TRAPS) {
1005   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1006   JavaThread* jt = (JavaThread*) THREAD;
1007   ResourceMark rm(THREAD);
1008 
1009   Klass* lookup_k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(lookup));
1010   // Lookup class must be a non-null instance
1011   if (lookup_k == NULL) {
1012     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Lookup class is null&quot;);
1013   }
1014   assert(lookup_k-&gt;is_instance_klass(), &quot;Lookup class must be an instance klass&quot;);
1015 
1016   Handle class_loader (THREAD, lookup_k-&gt;class_loader());
1017 
1018   bool is_nestmate = (flags &amp; NESTMATE) == NESTMATE;
1019   bool is_hidden = (flags &amp; HIDDEN_CLASS) == HIDDEN_CLASS;
1020   bool is_strong = (flags &amp; STRONG_LOADER_LINK) == STRONG_LOADER_LINK;
1021   bool vm_annotations = (flags &amp; ACCESS_VM_ANNOTATIONS) == ACCESS_VM_ANNOTATIONS;
1022 
1023   InstanceKlass* host_class = NULL;
1024   if (is_nestmate) {
1025     host_class = InstanceKlass::cast(lookup_k)-&gt;nest_host(CHECK_NULL);
1026   }
1027 
1028   log_info(class, nestmates)(&quot;LookupDefineClass: %s - %s%s, %s, %s, %s&quot;,
1029                              name,
1030                              is_nestmate ? &quot;with dynamic nest-host &quot; : &quot;non-nestmate&quot;,
1031                              is_nestmate ? host_class-&gt;external_name() : &quot;&quot;,
1032                              is_hidden ? &quot;hidden&quot; : &quot;not hidden&quot;,
1033                              is_strong ? &quot;strong&quot; : &quot;weak&quot;,
1034                              vm_annotations ? &quot;with vm annotations&quot; : &quot;without vm annotation&quot;);
1035 
1036   if (!is_hidden) {
1037     // classData is only applicable for hidden classes
1038     if (classData != NULL) {
1039       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;classData is only applicable for hidden classes&quot;);
1040     }
1041     if (is_nestmate) {
1042       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;dynamic nestmate is only applicable for hidden classes&quot;);
1043     }
1044     if (!is_strong) {
1045       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;an ordinary class must be strongly referenced by its defining loader&quot;);
1046     }
1047     if (vm_annotations) {
1048       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;vm annotations only allowed for hidden classes&quot;);
1049     }
1050     if (flags != STRONG_LOADER_LINK) {
1051       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1052                   err_msg(&quot;invalid flag 0x%x&quot;, flags));
1053     }
1054   }
1055 
1056   // Class resolution will get the class name from the .class stream if the name is null.
1057   TempNewSymbol class_name = name == NULL ? NULL :
1058        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
1059                                            CHECK_NULL);
1060 
1061   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
1062   const char* source = is_nestmate ? host_class-&gt;external_name() : &quot;__JVM_LookupDefineClass__&quot;;
1063   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
1064 
1065   Klass* defined_k;
1066   InstanceKlass* ik = NULL;
1067   if (!is_hidden) {
1068     defined_k = SystemDictionary::resolve_from_stream(class_name,
1069                                                       class_loader,
1070                                                       protection_domain,
1071                                                       &amp;st,
1072                                                       CHECK_NULL);
1073 
1074     if (log_is_enabled(Debug, class, resolve) &amp;&amp; defined_k != NULL) {
1075       trace_class_resolution(defined_k);
1076     }
1077     ik = InstanceKlass::cast(defined_k);
1078   } else { // hidden
1079     Handle classData_h(THREAD, JNIHandles::resolve(classData));
1080     ClassLoadInfo cl_info(protection_domain,
1081                           NULL, // unsafe_anonymous_host
1082                           NULL, // cp_patches
1083                           host_class,
1084                           classData_h,
1085                           is_hidden,
1086                           is_strong,
1087                           vm_annotations);
1088     defined_k = SystemDictionary::parse_stream(class_name,
1089                                                class_loader,
1090                                                &amp;st,
1091                                                cl_info,
1092                                                CHECK_NULL);
1093     if (defined_k == NULL) {
1094       THROW_MSG_0(vmSymbols::java_lang_Error(), &quot;Failure to define a hidden class&quot;);
1095     }
1096 
1097     ik = InstanceKlass::cast(defined_k);
1098 
1099     // The hidden class loader data has been artificially been kept alive to
1100     // this point. The mirror and any instances of this class have to keep
1101     // it alive afterwards.
1102     ik-&gt;class_loader_data()-&gt;dec_keep_alive();
1103 
1104     if (is_nestmate &amp;&amp; log_is_enabled(Debug, class, nestmates)) {
1105       ModuleEntry* module = ik-&gt;module();
1106       const char * module_name = module-&gt;is_named() ? module-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
1107       log_debug(class, nestmates)(&quot;Dynamic nestmate: %s/%s, nest_host %s, %s&quot;,
1108                                   module_name,
1109                                   ik-&gt;external_name(),
1110                                   host_class-&gt;external_name(),
1111                                   ik-&gt;is_hidden() ? &quot;is hidden&quot; : &quot;is not hidden&quot;);
1112     }
1113   }
1114   assert(Reflection::is_same_class_package(lookup_k, defined_k),
1115          &quot;lookup class and defined class are in different packages&quot;);
1116 
1117   if (init) {
1118     ik-&gt;initialize(CHECK_NULL);
1119   } else {
1120     ik-&gt;link_class(CHECK_NULL);
1121   }
1122 
1123   return (jclass) JNIHandles::make_local(env, defined_k-&gt;java_mirror());
1124 }
1125 
1126 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
1127   JVMWrapper(&quot;JVM_DefineClass&quot;);
1128 
1129   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);
1130 JVM_END
1131 
1132 /*
1133  * Define a class with the specified lookup class.
1134  *  lookup:  Lookup class
1135  *  name:    the name of the class
1136  *  buf:     class bytes
1137  *  len:     length of class bytes
1138  *  pd:      protection domain
1139  *  init:    initialize the class
1140  *  flags:   properties of the class
1141  *  classData: private static pre-initialized field
1142  */
1143 JVM_ENTRY(jclass, JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,
1144           jsize len, jobject pd, jboolean initialize, int flags, jobject classData))
1145   JVMWrapper(&quot;JVM_LookupDefineClass&quot;);
1146 
1147   if (lookup == NULL) {
1148     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Lookup class is null&quot;);
1149   }
1150 
1151   assert(buf != NULL, &quot;buf must not be NULL&quot;);
1152 
1153   return jvm_lookup_define_class(env, lookup, name, buf, len, pd, initialize, flags, classData, THREAD);
1154 JVM_END
1155 
1156 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
1157   JVMWrapper(&quot;JVM_DefineClassWithSource&quot;);
1158 
1159   return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);
1160 JVM_END
1161 
1162 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
1163   JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
1164   ResourceMark rm(THREAD);
1165 
1166   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
1167   char* str = java_lang_String::as_utf8_string(h_name());
1168 
1169   // Sanity check, don&#39;t expect null
1170   if (str == NULL) return NULL;
1171 
1172   // Internalize the string, converting &#39;.&#39; to &#39;/&#39; in string.
1173   char* p = (char*)str;
1174   while (*p != &#39;\0&#39;) {
1175       if (*p == &#39;.&#39;) {
1176           *p = &#39;/&#39;;
1177       }
1178       p++;
1179   }
1180 
1181   const int str_len = (int)(p - str);
1182   if (str_len &gt; Symbol::max_length()) {
1183     // It&#39;s impossible to create this class;  the name cannot fit
1184     // into the constant pool.
1185     return NULL;
1186   }
1187   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len);
1188 
1189   // Security Note:
1190   //   The Java level wrapper will perform the necessary security check allowing
1191   //   us to pass the NULL as the initiating class loader.
1192   Handle h_loader(THREAD, JNIHandles::resolve(loader));
1193   if (UsePerfData) {
1194     is_lock_held_by_thread(h_loader,
1195                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
1196                            THREAD);
1197   }
1198 
1199   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
1200                                                               h_loader,
1201                                                               Handle(),
1202                                                               CHECK_NULL);
1203 #if INCLUDE_CDS
1204   if (k == NULL) {
1205     // If the class is not already loaded, try to see if it&#39;s in the shared
1206     // archive for the current classloader (h_loader).
1207     k = SystemDictionaryShared::find_or_load_shared_class(klass_name, h_loader, CHECK_NULL);
1208   }
1209 #endif
1210   return (k == NULL) ? NULL :
1211             (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1212 JVM_END
1213 
1214 // Module support //////////////////////////////////////////////////////////////////////////////
1215 
1216 JVM_ENTRY(void, JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
1217                                  jstring location, jobjectArray packages))
1218   JVMWrapper(&quot;JVM_DefineModule&quot;);
1219   Modules::define_module(module, is_open, version, location, packages, CHECK);
1220 JVM_END
1221 
1222 JVM_ENTRY(void, JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module))
1223   JVMWrapper(&quot;JVM_SetBootLoaderUnnamedModule&quot;);
1224   Modules::set_bootloader_unnamed_module(module, CHECK);
1225 JVM_END
1226 
1227 JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module))
1228   JVMWrapper(&quot;JVM_AddModuleExports&quot;);
1229   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1230 JVM_END
1231 
1232 JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package))
1233   JVMWrapper(&quot;JVM_AddModuleExportsToAllUnnamed&quot;);
1234   Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);
1235 JVM_END
1236 
1237 JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package))
1238   JVMWrapper(&quot;JVM_AddModuleExportsToAll&quot;);
1239   Modules::add_module_exports(from_module, package, NULL, CHECK);
1240 JVM_END
1241 
1242 JVM_ENTRY (void, JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module))
1243   JVMWrapper(&quot;JVM_AddReadsModule&quot;);
1244   Modules::add_reads_module(from_module, source_module, CHECK);
1245 JVM_END
1246 
1247 // Reflection support //////////////////////////////////////////////////////////////////////////////
1248 
1249 JVM_ENTRY(jstring, JVM_InitClassName(JNIEnv *env, jclass cls))
1250   assert (cls != NULL, &quot;illegal class&quot;);
1251   JVMWrapper(&quot;JVM_InitClassName&quot;);
1252   JvmtiVMObjectAllocEventCollector oam;
1253   ResourceMark rm(THREAD);
1254   HandleMark hm(THREAD);
1255   Handle java_class(THREAD, JNIHandles::resolve(cls));
1256   oop result = java_lang_Class::name(java_class, CHECK_NULL);
1257   return (jstring) JNIHandles::make_local(env, result);
1258 JVM_END
1259 
1260 
1261 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1262   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1263   JvmtiVMObjectAllocEventCollector oam;
1264   oop mirror = JNIHandles::resolve_non_null(cls);
1265 
1266   // Special handling for primitive objects
1267   if (java_lang_Class::is_primitive(mirror)) {
1268     // Primitive objects does not have any interfaces
1269     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1270     return (jobjectArray) JNIHandles::make_local(env, r);
1271   }
1272 
1273   Klass* klass = java_lang_Class::as_Klass(mirror);
1274   // Figure size of result array
1275   int size;
1276   if (klass-&gt;is_instance_klass()) {
1277     InstanceKlass* ik = InstanceKlass::cast(klass);
1278     size = ik-&gt;local_interfaces()-&gt;length();
1279     if (ik-&gt;has_injected_identityObject()) {
1280       size--;
1281     }
1282   } else {
1283     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
1284     size = 3;
1285   }
1286 
1287   // Allocate result array
1288   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1289   objArrayHandle result (THREAD, r);
1290   // Fill in result
1291   if (klass-&gt;is_instance_klass()) {
1292     // Regular instance klass, fill in all local interfaces
1293     int cursor = 0;
1294     for (int index = 0; index &lt; size; index++) {
1295       InstanceKlass* ik = InstanceKlass::cast(klass);
1296       Klass* k = ik-&gt;local_interfaces()-&gt;at(index);
1297       if (!ik-&gt;has_injected_identityObject() || k != SystemDictionary::IdentityObject_klass()) {
1298         result-&gt;obj_at_put(cursor++, k-&gt;java_mirror());
1299       }
1300     }
1301   } else {
1302     // All arrays implement java.lang.Cloneable, java.io.Serializable and java.lang.IdentityObject
1303     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1304     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1305     result-&gt;obj_at_put(2, SystemDictionary::IdentityObject_klass()-&gt;java_mirror());
1306   }
1307   return (jobjectArray) JNIHandles::make_local(env, result());
1308 JVM_END
1309 
1310 
1311 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1312   JVMWrapper(&quot;JVM_IsInterface&quot;);
1313   oop mirror = JNIHandles::resolve_non_null(cls);
1314   if (java_lang_Class::is_primitive(mirror)) {
1315     return JNI_FALSE;
1316   }
1317   Klass* k = java_lang_Class::as_Klass(mirror);
1318   jboolean result = k-&gt;is_interface();
1319   assert(!result || k-&gt;is_instance_klass(),
1320          &quot;all interfaces are instance types&quot;);
1321   // The compiler intrinsic for isInterface tests the
1322   // Klass::_access_flags bits in the same way.
1323   return result;
1324 JVM_END
1325 
1326 JVM_ENTRY(jboolean, JVM_IsHiddenClass(JNIEnv *env, jclass cls))
1327   JVMWrapper(&quot;JVM_IsHiddenClass&quot;);
1328   oop mirror = JNIHandles::resolve_non_null(cls);
1329   if (java_lang_Class::is_primitive(mirror)) {
1330     return JNI_FALSE;
1331   }
1332   Klass* k = java_lang_Class::as_Klass(mirror);
1333   return k-&gt;is_hidden();
1334 JVM_END
1335 
1336 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1337   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1338   JvmtiVMObjectAllocEventCollector oam;
1339   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1340     // There are no signers for primitive types
1341     return NULL;
1342   }
1343 
1344   objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));
1345 
1346   // If there are no signers set in the class, or if the class
1347   // is an array, return NULL.
1348   if (signers == NULL) return NULL;
1349 
1350   // copy of the signers array
1351   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1352   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1353   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1354     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1355   }
1356 
1357   // return the copy
1358   return (jobjectArray) JNIHandles::make_local(env, signers_copy);
1359 JVM_END
1360 
1361 
1362 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1363   JVMWrapper(&quot;JVM_SetClassSigners&quot;);
1364   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1365     // This call is ignored for primitive types and arrays.
1366     // Signers are only set once, ClassLoader.java, and thus shouldn&#39;t
1367     // be called with an array.  Only the bootstrap loader creates arrays.
1368     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1369     if (k-&gt;is_instance_klass()) {
1370       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1371     }
1372   }
1373 JVM_END
1374 
1375 
1376 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1377   JVMWrapper(&quot;JVM_GetProtectionDomain&quot;);
1378   if (JNIHandles::resolve(cls) == NULL) {
1379     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1380   }
1381 
1382   if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1383     // Primitive types does not have a protection domain.
1384     return NULL;
1385   }
1386 
1387   oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));
1388   return (jobject) JNIHandles::make_local(env, pd);
1389 JVM_END
1390 
1391 
1392 // Returns the inherited_access_control_context field of the running thread.
1393 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1394   JVMWrapper(&quot;JVM_GetInheritedAccessControlContext&quot;);
1395   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1396   return JNIHandles::make_local(env, result);
1397 JVM_END
1398 
1399 class RegisterArrayForGC {
1400  private:
1401   JavaThread *_thread;
1402  public:
1403   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1404     _thread = thread;
1405     _thread-&gt;register_array_for_gc(array);
1406   }
1407 
1408   ~RegisterArrayForGC() {
1409     _thread-&gt;register_array_for_gc(NULL);
1410   }
1411 };
1412 
1413 
1414 JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))
1415   JVMWrapper(&quot;JVM_GetStackAccessControlContext&quot;);
1416   if (!UsePrivilegedStack) return NULL;
1417 
1418   ResourceMark rm(THREAD);
1419   GrowableArray&lt;oop&gt;* local_array = new GrowableArray&lt;oop&gt;(12);
1420   JvmtiVMObjectAllocEventCollector oam;
1421 
1422   // count the protection domains on the execution stack. We collapse
1423   // duplicate consecutive protection domains into a single one, as
1424   // well as stopping when we hit a privileged frame.
1425 
1426   oop previous_protection_domain = NULL;
1427   Handle privileged_context(thread, NULL);
1428   bool is_privileged = false;
1429   oop protection_domain = NULL;
1430 
1431   // Iterate through Java frames
1432   vframeStream vfst(thread);
1433   for(; !vfst.at_end(); vfst.next()) {
1434     // get method of frame
1435     Method* method = vfst.method();
1436 
1437     // stop at the first privileged frame
1438     if (method-&gt;method_holder() == SystemDictionary::AccessController_klass() &amp;&amp;
1439       method-&gt;name() == vmSymbols::executePrivileged_name())
1440     {
1441       // this frame is privileged
1442       is_privileged = true;
1443 
1444       javaVFrame *priv = vfst.asJavaVFrame();       // executePrivileged
1445 
1446       StackValueCollection* locals = priv-&gt;locals();
1447       StackValue* ctx_sv = locals-&gt;at(1); // AccessControlContext context
1448       StackValue* clr_sv = locals-&gt;at(2); // Class&lt;?&gt; caller
1449       assert(!ctx_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1450       assert(!clr_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1451       privileged_context    = ctx_sv-&gt;get_obj();
1452       Handle caller         = clr_sv-&gt;get_obj();
1453 
1454       Klass *caller_klass = java_lang_Class::as_Klass(caller());
1455       protection_domain  = caller_klass-&gt;protection_domain();
1456     } else {
1457       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1458     }
1459 
1460     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {
1461       local_array-&gt;push(protection_domain);
1462       previous_protection_domain = protection_domain;
1463     }
1464 
1465     if (is_privileged) break;
1466   }
1467 
1468 
1469   // either all the domains on the stack were system domains, or
1470   // we had a privileged system domain
1471   if (local_array-&gt;is_empty()) {
1472     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1473 
1474     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1475     return JNIHandles::make_local(env, result);
1476   }
1477 
1478   // the resource area must be registered in case of a gc
1479   RegisterArrayForGC ragc(thread, local_array);
1480   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1481                                                  local_array-&gt;length(), CHECK_NULL);
1482   objArrayHandle h_context(thread, context);
1483   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1484     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1485   }
1486 
1487   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1488 
1489   return JNIHandles::make_local(env, result);
1490 JVM_END
1491 
1492 
1493 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1494   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1495   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1496   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1497 JVM_END
1498 
1499 
1500 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1501   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1502   oop mirror = JNIHandles::resolve_non_null(cls);
1503   return (jboolean) java_lang_Class::is_primitive(mirror);
1504 JVM_END
1505 
1506 
1507 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1508   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
1509   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1510     // Primitive type
1511     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1512   }
1513 
1514   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1515   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1516   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1517   return k-&gt;modifier_flags();
1518 JVM_END
1519 
1520 
1521 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1522 
1523 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1524   JvmtiVMObjectAllocEventCollector oam;
1525   // ofClass is a reference to a java_lang_Class object. The mirror object
1526   // of an InstanceKlass
1527 
1528   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1529       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1530     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1531     return (jobjectArray)JNIHandles::make_local(env, result);
1532   }
1533 
1534   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1535   InnerClassesIterator iter(k);
1536 
1537   if (iter.length() == 0) {
1538     // Neither an inner nor outer class
1539     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1540     return (jobjectArray)JNIHandles::make_local(env, result);
1541   }
1542 
1543   // find inner class info
1544   constantPoolHandle cp(thread, k-&gt;constants());
1545   int length = iter.length();
1546 
1547   // Allocate temp. result array
1548   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1549   objArrayHandle result (THREAD, r);
1550   int members = 0;
1551 
1552   for (; !iter.done(); iter.next()) {
1553     int ioff = iter.inner_class_info_index();
1554     int ooff = iter.outer_class_info_index();
1555 
1556     if (ioff != 0 &amp;&amp; ooff != 0) {
1557       // Check to see if the name matches the class we&#39;re looking for
1558       // before attempting to find the class.
1559       if (cp-&gt;klass_name_at_matches(k, ooff)) {
1560         Klass* outer_klass = cp-&gt;klass_at(ooff, CHECK_NULL);
1561         if (outer_klass == k) {
1562            Klass* ik = cp-&gt;klass_at(ioff, CHECK_NULL);
1563            InstanceKlass* inner_klass = InstanceKlass::cast(ik);
1564 
1565            // Throws an exception if outer klass has not declared k as
1566            // an inner klass
1567            Reflection::check_for_inner_class(k, inner_klass, true, CHECK_NULL);
1568 
1569            result-&gt;obj_at_put(members, inner_klass-&gt;java_mirror());
1570            members++;
1571         }
1572       }
1573     }
1574   }
1575 
1576   if (members != length) {
1577     // Return array of right length
1578     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1579     for(int i = 0; i &lt; members; i++) {
1580       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1581     }
1582     return (jobjectArray)JNIHandles::make_local(env, res);
1583   }
1584 
1585   return (jobjectArray)JNIHandles::make_local(env, result());
1586 JVM_END
1587 
1588 
1589 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1590 {
1591   // ofClass is a reference to a java_lang_Class object.
1592   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1593       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1594     return NULL;
1595   }
1596 
1597   bool inner_is_member = false;
1598   Klass* outer_klass
1599     = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))
1600                           )-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);
1601   if (outer_klass == NULL)  return NULL;  // already a top-level class
1602   if (!inner_is_member)  return NULL;     // a hidden or unsafe anonymous class (inside a method)
1603   return (jclass) JNIHandles::make_local(env, outer_klass-&gt;java_mirror());
1604 }
1605 JVM_END
1606 
1607 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
1608 {
1609   oop mirror = JNIHandles::resolve_non_null(cls);
1610   if (java_lang_Class::is_primitive(mirror) ||
1611       !java_lang_Class::as_Klass(mirror)-&gt;is_instance_klass()) {
1612     return NULL;
1613   }
1614   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1615   int ooff = 0, noff = 0;
1616   if (k-&gt;find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD)) {
1617     if (noff != 0) {
1618       constantPoolHandle i_cp(thread, k-&gt;constants());
1619       Symbol* name = i_cp-&gt;symbol_at(noff);
1620       Handle str = java_lang_String::create_from_symbol(name, CHECK_NULL);
1621       return (jstring) JNIHandles::make_local(env, str());
1622     }
1623   }
1624   return NULL;
1625 }
1626 JVM_END
1627 
1628 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1629   assert (cls != NULL, &quot;illegal class&quot;);
1630   JVMWrapper(&quot;JVM_GetClassSignature&quot;);
1631   JvmtiVMObjectAllocEventCollector oam;
1632   ResourceMark rm(THREAD);
1633   // Return null for arrays and primatives
1634   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1635     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1636     if (k-&gt;is_instance_klass()) {
1637       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1638       if (sym == NULL) return NULL;
1639       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1640       return (jstring) JNIHandles::make_local(env, str());
1641     }
1642   }
1643   return NULL;
1644 JVM_END
1645 
1646 
1647 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1648   assert (cls != NULL, &quot;illegal class&quot;);
1649   JVMWrapper(&quot;JVM_GetClassAnnotations&quot;);
1650 
1651   // Return null for arrays and primitives
1652   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1653     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1654     if (k-&gt;is_instance_klass()) {
1655       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1656       return (jbyteArray) JNIHandles::make_local(env, a);
1657     }
1658   }
1659   return NULL;
1660 JVM_END
1661 
1662 
1663 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1664   // some of this code was adapted from from jni_FromReflectedField
1665 
1666   oop reflected = JNIHandles::resolve_non_null(field);
1667   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1668   Klass* k    = java_lang_Class::as_Klass(mirror);
1669   int slot      = java_lang_reflect_Field::slot(reflected);
1670   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1671 
1672   InstanceKlass* ik = InstanceKlass::cast(k);
1673   intptr_t offset = ik-&gt;field_offset(slot);
1674 
1675   if (modifiers &amp; JVM_ACC_STATIC) {
1676     // for static fields we only look in the current class
1677     if (!ik-&gt;find_local_field_from_offset(offset, true, &amp;fd)) {
1678       assert(false, &quot;cannot find static field&quot;);
1679       return false;
1680     }
1681   } else {
1682     // for instance fields we start with the current class and work
1683     // our way up through the superclass chain
1684     if (!ik-&gt;find_field_from_offset(offset, false, &amp;fd)) {
1685       assert(false, &quot;cannot find instance field&quot;);
1686       return false;
1687     }
1688   }
1689   return true;
1690 }
1691 
1692 static Method* jvm_get_method_common(jobject method) {
1693   // some of this code was adapted from from jni_FromReflectedMethod
1694 
1695   oop reflected = JNIHandles::resolve_non_null(method);
1696   oop mirror    = NULL;
1697   int slot      = 0;
1698 
1699   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
1700     mirror = java_lang_reflect_Constructor::clazz(reflected);
1701     slot   = java_lang_reflect_Constructor::slot(reflected);
1702   } else {
1703     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(),
1704            &quot;wrong type&quot;);
1705     mirror = java_lang_reflect_Method::clazz(reflected);
1706     slot   = java_lang_reflect_Method::slot(reflected);
1707   }
1708   Klass* k = java_lang_Class::as_Klass(mirror);
1709 
1710   Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
1711   assert(m != NULL, &quot;cannot find method&quot;);
1712   return m;  // caller has to deal with NULL in product mode
1713 }
1714 
1715 /* Type use annotations support (JDK 1.8) */
1716 
1717 JVM_ENTRY(jbyteArray, JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls))
1718   assert (cls != NULL, &quot;illegal class&quot;);
1719   JVMWrapper(&quot;JVM_GetClassTypeAnnotations&quot;);
1720   ResourceMark rm(THREAD);
1721   // Return null for arrays and primitives
1722   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1723     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1724     if (k-&gt;is_instance_klass()) {
1725       AnnotationArray* type_annotations = InstanceKlass::cast(k)-&gt;class_type_annotations();
1726       if (type_annotations != NULL) {
1727         typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1728         return (jbyteArray) JNIHandles::make_local(env, a);
1729       }
1730     }
1731   }
1732   return NULL;
1733 JVM_END
1734 
1735 JVM_ENTRY(jbyteArray, JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method))
1736   assert (method != NULL, &quot;illegal method&quot;);
1737   JVMWrapper(&quot;JVM_GetMethodTypeAnnotations&quot;);
1738 
1739   // method is a handle to a java.lang.reflect.Method object
1740   Method* m = jvm_get_method_common(method);
1741   if (m == NULL) {
1742     return NULL;
1743   }
1744 
1745   AnnotationArray* type_annotations = m-&gt;type_annotations();
1746   if (type_annotations != NULL) {
1747     typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1748     return (jbyteArray) JNIHandles::make_local(env, a);
1749   }
1750 
1751   return NULL;
1752 JVM_END
1753 
1754 JVM_ENTRY(jbyteArray, JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field))
1755   assert (field != NULL, &quot;illegal field&quot;);
1756   JVMWrapper(&quot;JVM_GetFieldTypeAnnotations&quot;);
1757 
1758   fieldDescriptor fd;
1759   bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);
1760   if (!gotFd) {
1761     return NULL;
1762   }
1763 
1764   return (jbyteArray) JNIHandles::make_local(env, Annotations::make_java_array(fd.type_annotations(), THREAD));
1765 JVM_END
1766 
1767 static void bounds_check(const constantPoolHandle&amp; cp, jint index, TRAPS) {
1768   if (!cp-&gt;is_within_bounds(index)) {
1769     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool index out of bounds&quot;);
1770   }
1771 }
1772 
1773 JVM_ENTRY(jobjectArray, JVM_GetMethodParameters(JNIEnv *env, jobject method))
1774 {
1775   JVMWrapper(&quot;JVM_GetMethodParameters&quot;);
1776   // method is a handle to a java.lang.reflect.Method object
1777   Method* method_ptr = jvm_get_method_common(method);
1778   methodHandle mh (THREAD, method_ptr);
1779   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1780   const int num_params = mh-&gt;method_parameters_length();
1781 
1782   if (num_params &lt; 0) {
1783     // A -1 return value from method_parameters_length means there is no
1784     // parameter data.  Return null to indicate this to the reflection
1785     // API.
1786     assert(num_params == -1, &quot;num_params should be -1 if it is less than zero&quot;);
1787     return (jobjectArray)NULL;
1788   } else {
1789     // Otherwise, we return something up to reflection, even if it is
1790     // a zero-length array.  Why?  Because in some cases this can
1791     // trigger a MalformedParametersException.
1792 
1793     // make sure all the symbols are properly formatted
1794     for (int i = 0; i &lt; num_params; i++) {
1795       MethodParametersElement* params = mh-&gt;method_parameters_start();
1796       int index = params[i].name_cp_index;
1797       constantPoolHandle cp(THREAD, mh-&gt;constants());
1798       bounds_check(cp, index, CHECK_NULL);
1799 
1800       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1801         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1802                     &quot;Wrong type at constant pool index&quot;);
1803       }
1804 
1805     }
1806 
1807     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1808     objArrayHandle result (THREAD, result_oop);
1809 
1810     for (int i = 0; i &lt; num_params; i++) {
1811       MethodParametersElement* params = mh-&gt;method_parameters_start();
1812       // For a 0 index, give a NULL symbol
1813       Symbol* sym = 0 != params[i].name_cp_index ?
1814         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1815       int flags = params[i].flags;
1816       oop param = Reflection::new_parameter(reflected_method, i, sym,
1817                                             flags, CHECK_NULL);
1818       result-&gt;obj_at_put(i, param);
1819     }
1820     return (jobjectArray)JNIHandles::make_local(env, result());
1821   }
1822 }
1823 JVM_END
1824 
1825 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1826 
1827 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1828 {
1829   JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
1830   JvmtiVMObjectAllocEventCollector oam;
1831 
1832   // Exclude primitive types and array types
1833   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1834       java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1835     // Return empty array
1836     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1837     return (jobjectArray) JNIHandles::make_local(env, res);
1838   }
1839 
1840   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1841   constantPoolHandle cp(THREAD, k-&gt;constants());
1842 
1843   // Ensure class is linked
1844   k-&gt;link_class(CHECK_NULL);
1845 
1846   // Allocate result
1847   int num_fields;
1848 
1849   if (publicOnly) {
1850     num_fields = 0;
1851     for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1852       if (fs.access_flags().is_public()) ++num_fields;
1853     }
1854   } else {
1855     num_fields = k-&gt;java_fields_count();
1856   }
1857 
1858   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1859   objArrayHandle result (THREAD, r);
1860 
1861   int out_idx = 0;
1862   fieldDescriptor fd;
1863   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1864     if (!publicOnly || fs.access_flags().is_public()) {
1865       fd.reinitialize(k, fs.index());
1866       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1867       result-&gt;obj_at_put(out_idx, field);
1868       ++out_idx;
1869     }
1870   }
1871   assert(out_idx == num_fields, &quot;just checking&quot;);
1872   return (jobjectArray) JNIHandles::make_local(env, result());
1873 }
1874 JVM_END
1875 
1876 JVM_ENTRY(jboolean, JVM_IsRecord(JNIEnv *env, jclass cls))
1877 {
1878   JVMWrapper(&quot;JVM_IsRecord&quot;);
1879   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1880   if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
1881     InstanceKlass* ik = InstanceKlass::cast(k);
1882     return ik-&gt;is_record();
1883   } else {
1884     return false;
1885   }
1886 }
1887 JVM_END
1888 
1889 JVM_ENTRY(jobjectArray, JVM_GetRecordComponents(JNIEnv* env, jclass ofClass))
1890 {
1891   JVMWrapper(&quot;JVM_GetRecordComponents&quot;);
1892   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));
1893   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1894   InstanceKlass* ik = InstanceKlass::cast(c);
1895 
1896   if (ik-&gt;is_record()) {
1897     Array&lt;RecordComponent*&gt;* components = ik-&gt;record_components();
1898     assert(components != NULL, &quot;components should not be NULL&quot;);
1899     {
1900       JvmtiVMObjectAllocEventCollector oam;
1901       constantPoolHandle cp(THREAD, ik-&gt;constants());
1902       int length = components-&gt;length();
1903       assert(length &gt;= 0, &quot;unexpected record_components length&quot;);
1904       objArrayOop record_components =
1905         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1906       objArrayHandle components_h (THREAD, record_components);
1907 
1908       for (int x = 0; x &lt; length; x++) {
1909         RecordComponent* component = components-&gt;at(x);
1910         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1911         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1912         components_h-&gt;obj_at_put(x, component_oop);
1913       }
1914       return (jobjectArray)JNIHandles::make_local(components_h());
1915     }
1916   }
1917 
1918   // Return empty array if ofClass is not a record.
1919   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1920   return (jobjectArray)JNIHandles::make_local(env, result);
1921 }
1922 JVM_END
1923 
1924 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1925   bool is_ctor = (method-&gt;is_object_constructor() ||
1926                   method-&gt;is_static_init_factory());
1927   if (want_constructor) {
1928     return is_ctor;
1929   } else {
1930     return (!is_ctor &amp;&amp;
1931             !method-&gt;is_class_initializer() &amp;&amp;
1932             !method-&gt;is_overpass());
1933   }
1934 }
1935 
1936 static jobjectArray get_class_declared_methods_helper(
1937                                   JNIEnv *env,
1938                                   jclass ofClass, jboolean publicOnly,
1939                                   bool want_constructor,
1940                                   Klass* klass, TRAPS) {
1941 
1942   JvmtiVMObjectAllocEventCollector oam;
1943 
1944   // Exclude primitive types and array types
1945   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1946       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1947     // Return empty array
1948     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1949     return (jobjectArray) JNIHandles::make_local(env, res);
1950   }
1951 
1952   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1953 
1954   // Ensure class is linked
1955   k-&gt;link_class(CHECK_NULL);
1956 
1957   Array&lt;Method*&gt;* methods = k-&gt;methods();
1958   int methods_length = methods-&gt;length();
1959 
1960   // Save original method_idnum in case of redefinition, which can change
1961   // the idnum of obsolete methods.  The new method will have the same idnum
1962   // but if we refresh the methods array, the counts will be wrong.
1963   ResourceMark rm(THREAD);
1964   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1965   int num_methods = 0;
1966 
1967   for (int i = 0; i &lt; methods_length; i++) {
1968     methodHandle method(THREAD, methods-&gt;at(i));
1969     if (select_method(method, want_constructor)) {
1970       if (!publicOnly || method-&gt;is_public()) {
1971         idnums-&gt;push(method-&gt;method_idnum());
1972         ++num_methods;
1973       }
1974     }
1975   }
1976 
1977   // Allocate result
1978   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1979   objArrayHandle result (THREAD, r);
1980 
1981   // Now just put the methods that we selected above, but go by their idnum
1982   // in case of redefinition.  The methods can be redefined at any safepoint,
1983   // so above when allocating the oop array and below when creating reflect
1984   // objects.
1985   for (int i = 0; i &lt; num_methods; i++) {
1986     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1987     if (method.is_null()) {
1988       // Method may have been deleted and seems this API can handle null
1989       // Otherwise should probably put a method that throws NSME
1990       result-&gt;obj_at_put(i, NULL);
1991     } else {
1992       oop m;
1993       if (want_constructor) {
1994         assert(method-&gt;is_object_constructor() ||
1995                method-&gt;is_static_init_factory(), &quot;must be&quot;);
1996         m = Reflection::new_constructor(method, CHECK_NULL);
1997       } else {
1998         m = Reflection::new_method(method, false, CHECK_NULL);
1999       }
2000       result-&gt;obj_at_put(i, m);
2001     }
2002   }
2003 
2004   return (jobjectArray) JNIHandles::make_local(env, result());
2005 }
2006 
2007 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
2008 {
2009   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
2010   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2011                                            /*want_constructor*/ false,
2012                                            SystemDictionary::reflect_Method_klass(), THREAD);
2013 }
2014 JVM_END
2015 
2016 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
2017 {
2018   JVMWrapper(&quot;JVM_GetClassDeclaredConstructors&quot;);
2019   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2020                                            /*want_constructor*/ true,
2021                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
2022 }
2023 JVM_END
2024 
2025 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
2026 {
2027   JVMWrapper(&quot;JVM_GetClassAccessFlags&quot;);
2028   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
2029     // Primitive type
2030     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
2031   }
2032 
2033   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2034   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
2035 }
2036 JVM_END
2037 
2038 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
2039 {
2040   JVMWrapper(&quot;JVM_AreNestMates&quot;);
2041   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2042   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2043   InstanceKlass* ck = InstanceKlass::cast(c);
2044   Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));
2045   assert(m-&gt;is_instance_klass(), &quot;must be&quot;);
2046   InstanceKlass* mk = InstanceKlass::cast(m);
2047   return ck-&gt;has_nestmate_access_to(mk, THREAD);
2048 }
2049 JVM_END
2050 
2051 JVM_ENTRY(jclass, JVM_GetNestHost(JNIEnv* env, jclass current))
2052 {
2053   // current is not a primitive or array class
2054   JVMWrapper(&quot;JVM_GetNestHost&quot;);
2055   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2056   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2057   InstanceKlass* ck = InstanceKlass::cast(c);
2058   InstanceKlass* host = ck-&gt;nest_host(THREAD);
2059   return (jclass) (host == NULL ? NULL :
2060                    JNIHandles::make_local(THREAD, host-&gt;java_mirror()));
2061 }
2062 JVM_END
2063 
2064 JVM_ENTRY(jobjectArray, JVM_GetNestMembers(JNIEnv* env, jclass current))
2065 {
2066   // current is not a primitive or array class
2067   JVMWrapper(&quot;JVM_GetNestMembers&quot;);
2068   ResourceMark rm(THREAD);
2069   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2070   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2071   InstanceKlass* ck = InstanceKlass::cast(c);
2072   InstanceKlass* host = ck-&gt;nest_host(THREAD);
2073 
2074   log_trace(class, nestmates)(&quot;Calling GetNestMembers for type %s with nest-host %s&quot;,
2075                               ck-&gt;external_name(), host-&gt;external_name());
2076   {
2077     JvmtiVMObjectAllocEventCollector oam;
2078     Array&lt;u2&gt;* members = host-&gt;nest_members();
2079     int length = members == NULL ? 0 : members-&gt;length();
2080 
2081     log_trace(class, nestmates)(&quot; - host has %d listed nest members&quot;, length);
2082 
2083     // nest host is first in the array so make it one bigger
2084     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2085                                              length + 1, CHECK_NULL);
2086     objArrayHandle result(THREAD, r);
2087     result-&gt;obj_at_put(0, host-&gt;java_mirror());
2088     if (length != 0) {
2089       int count = 0;
2090       for (int i = 0; i &lt; length; i++) {
2091         int cp_index = members-&gt;at(i);
2092         Klass* k = host-&gt;constants()-&gt;klass_at(cp_index, THREAD);
2093         if (HAS_PENDING_EXCEPTION) {
2094           if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass())) {
2095             return NULL; // propagate VMEs
2096           }
2097           if (log_is_enabled(Trace, class, nestmates)) {
2098             stringStream ss;
2099             char* target_member_class = host-&gt;constants()-&gt;klass_name_at(cp_index)-&gt;as_C_string();
2100             ss.print(&quot; - resolution of nest member %s failed: &quot;, target_member_class);
2101             java_lang_Throwable::print(PENDING_EXCEPTION, &amp;ss);
2102             log_trace(class, nestmates)(&quot;%s&quot;, ss.as_string());
2103           }
2104           CLEAR_PENDING_EXCEPTION;
2105           continue;
2106         }
2107         if (k-&gt;is_instance_klass()) {
2108           InstanceKlass* ik = InstanceKlass::cast(k);
2109           InstanceKlass* nest_host_k = ik-&gt;nest_host(CHECK_NULL);
2110           if (nest_host_k == host) {
2111             result-&gt;obj_at_put(count+1, k-&gt;java_mirror());
2112             count++;
2113             log_trace(class, nestmates)(&quot; - [%d] = %s&quot;, count, ik-&gt;external_name());
2114           } else {
2115             log_trace(class, nestmates)(&quot; - skipping member %s with different host %s&quot;,
2116                                         ik-&gt;external_name(), nest_host_k-&gt;external_name());
2117           }
2118         } else {
2119           log_trace(class, nestmates)(&quot; - skipping member %s that is not an instance class&quot;,
2120                                       k-&gt;external_name());
2121         }
2122       }
2123       if (count &lt; length) {
2124         // we had invalid entries so we need to compact the array
2125         log_trace(class, nestmates)(&quot; - compacting array from length %d to %d&quot;,
2126                                     length + 1, count + 1);
2127 
2128         objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2129                                                   count + 1, CHECK_NULL);
2130         objArrayHandle result2(THREAD, r2);
2131         for (int i = 0; i &lt; count + 1; i++) {
2132           result2-&gt;obj_at_put(i, result-&gt;obj_at(i));
2133         }
2134         return (jobjectArray)JNIHandles::make_local(THREAD, result2());
2135       }
2136     }
2137     else {
2138       assert(host == ck || ck-&gt;is_hidden(), &quot;must be singleton nest or dynamic nestmate&quot;);
2139     }
2140     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2141   }
2142 }
2143 JVM_END
2144 
2145 JVM_ENTRY(jobjectArray, JVM_GetPermittedSubclasses(JNIEnv* env, jclass current))
2146 {
2147   JVMWrapper(&quot;JVM_GetPermittedSubclasses&quot;);
2148   assert(!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(current)), &quot;should not be&quot;);
2149   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2150   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2151   InstanceKlass* ik = InstanceKlass::cast(c);
2152   {
2153     JvmtiVMObjectAllocEventCollector oam;
2154     Array&lt;u2&gt;* subclasses = ik-&gt;permitted_subclasses();
2155     int length = subclasses == NULL ? 0 : subclasses-&gt;length();
2156     objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
2157                                              length, CHECK_NULL);
2158     objArrayHandle result(THREAD, r);
2159     for (int i = 0; i &lt; length; i++) {
2160       int cp_index = subclasses-&gt;at(i);
2161       // This returns &lt;package-name&gt;/&lt;class-name&gt;.
2162       Symbol* klass_name = ik-&gt;constants()-&gt;klass_name_at(cp_index);
2163       assert(klass_name != NULL, &quot;Unexpected null klass_name&quot;);
2164       Handle perm_subtype_h = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2165       result-&gt;obj_at_put(i, perm_subtype_h());
2166     }
2167     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2168   }
2169 }
2170 JVM_END
2171 
2172 // Constant pool access //////////////////////////////////////////////////////////
2173 
2174 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
2175 {
2176   JVMWrapper(&quot;JVM_GetClassConstantPool&quot;);
2177   JvmtiVMObjectAllocEventCollector oam;
2178 
2179   // Return null for primitives and arrays
2180   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
2181     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2182     if (k-&gt;is_instance_klass()) {
2183       InstanceKlass* k_h = InstanceKlass::cast(k);
2184       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
2185       reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
2186       return JNIHandles::make_local(jcp());
2187     }
2188   }
2189   return NULL;
2190 }
2191 JVM_END
2192 
2193 
2194 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
2195 {
2196   JVMWrapper(&quot;JVM_ConstantPoolGetSize&quot;);
2197   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2198   return cp-&gt;length();
2199 }
2200 JVM_END
2201 
2202 
2203 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2204 {
2205   JVMWrapper(&quot;JVM_ConstantPoolGetClassAt&quot;);
2206   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2207   bounds_check(cp, index, CHECK_NULL);
2208   constantTag tag = cp-&gt;tag_at(index);
2209   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2210     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2211   }
2212   Klass* k = cp-&gt;klass_at(index, CHECK_NULL);
2213   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2214 }
2215 JVM_END
2216 
2217 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2218 {
2219   JVMWrapper(&quot;JVM_ConstantPoolGetClassAtIfLoaded&quot;);
2220   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2221   bounds_check(cp, index, CHECK_NULL);
2222   constantTag tag = cp-&gt;tag_at(index);
2223   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2224     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2225   }
2226   Klass* k = ConstantPool::klass_at_if_loaded(cp, index);
2227   if (k == NULL) return NULL;
2228   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2229 }
2230 JVM_END
2231 
2232 static jobject get_method_at_helper(const constantPoolHandle&amp; cp, jint index, bool force_resolution, TRAPS) {
2233   constantTag tag = cp-&gt;tag_at(index);
2234   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2235     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2236   }
2237   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2238   Klass* k_o;
2239   if (force_resolution) {
2240     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2241   } else {
2242     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2243     if (k_o == NULL) return NULL;
2244   }
2245   InstanceKlass* k = InstanceKlass::cast(k_o);
2246   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2247   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2248   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2249   if (m.is_null()) {
2250     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2251   }
2252   oop method;
2253   if (m-&gt;is_object_constructor() || m-&gt;is_static_init_factory()) {
2254     method = Reflection::new_constructor(m, CHECK_NULL);
2255   } else {
2256     method = Reflection::new_method(m, true, CHECK_NULL);
2257   }
2258   return JNIHandles::make_local(method);
2259 }
2260 
2261 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2262 {
2263   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2264   JvmtiVMObjectAllocEventCollector oam;
2265   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2266   bounds_check(cp, index, CHECK_NULL);
2267   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2268   return res;
2269 }
2270 JVM_END
2271 
2272 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2273 {
2274   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2275   JvmtiVMObjectAllocEventCollector oam;
2276   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2277   bounds_check(cp, index, CHECK_NULL);
2278   jobject res = get_method_at_helper(cp, index, false, CHECK_NULL);
2279   return res;
2280 }
2281 JVM_END
2282 
2283 static jobject get_field_at_helper(constantPoolHandle cp, jint index, bool force_resolution, TRAPS) {
2284   constantTag tag = cp-&gt;tag_at(index);
2285   if (!tag.is_field()) {
2286     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2287   }
2288   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2289   Klass* k_o;
2290   if (force_resolution) {
2291     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2292   } else {
2293     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2294     if (k_o == NULL) return NULL;
2295   }
2296   InstanceKlass* k = InstanceKlass::cast(k_o);
2297   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2298   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2299   fieldDescriptor fd;
2300   Klass* target_klass = k-&gt;find_field(name, sig, &amp;fd);
2301   if (target_klass == NULL) {
2302     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up field in target class&quot;);
2303   }
2304   oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
2305   return JNIHandles::make_local(field);
2306 }
2307 
2308 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))
2309 {
2310   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAt&quot;);
2311   JvmtiVMObjectAllocEventCollector oam;
2312   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2313   bounds_check(cp, index, CHECK_NULL);
2314   jobject res = get_field_at_helper(cp, index, true, CHECK_NULL);
2315   return res;
2316 }
2317 JVM_END
2318 
2319 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2320 {
2321   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAtIfLoaded&quot;);
2322   JvmtiVMObjectAllocEventCollector oam;
2323   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2324   bounds_check(cp, index, CHECK_NULL);
2325   jobject res = get_field_at_helper(cp, index, false, CHECK_NULL);
2326   return res;
2327 }
2328 JVM_END
2329 
2330 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2331 {
2332   JVMWrapper(&quot;JVM_ConstantPoolGetMemberRefInfoAt&quot;);
2333   JvmtiVMObjectAllocEventCollector oam;
2334   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2335   bounds_check(cp, index, CHECK_NULL);
2336   constantTag tag = cp-&gt;tag_at(index);
2337   if (!tag.is_field_or_method()) {
2338     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2339   }
2340   int klass_ref = cp-&gt;uncached_klass_ref_index_at(index);
2341   Symbol*  klass_name  = cp-&gt;klass_name_at(klass_ref);
2342   Symbol*  member_name = cp-&gt;uncached_name_ref_at(index);
2343   Symbol*  member_sig  = cp-&gt;uncached_signature_ref_at(index);
2344   objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);
2345   objArrayHandle dest(THREAD, dest_o);
2346   Handle str = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2347   dest-&gt;obj_at_put(0, str());
2348   str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2349   dest-&gt;obj_at_put(1, str());
2350   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2351   dest-&gt;obj_at_put(2, str());
2352   return (jobjectArray) JNIHandles::make_local(dest());
2353 }
2354 JVM_END
2355 
2356 JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2357 {
2358   JVMWrapper(&quot;JVM_ConstantPoolGetClassRefIndexAt&quot;);
2359   JvmtiVMObjectAllocEventCollector oam;
2360   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2361   bounds_check(cp, index, CHECK_0);
2362   constantTag tag = cp-&gt;tag_at(index);
2363   if (!tag.is_field_or_method()) {
2364     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2365   }
2366   return (jint) cp-&gt;uncached_klass_ref_index_at(index);
2367 }
2368 JVM_END
2369 
2370 JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2371 {
2372   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefIndexAt&quot;);
2373   JvmtiVMObjectAllocEventCollector oam;
2374   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2375   bounds_check(cp, index, CHECK_0);
2376   constantTag tag = cp-&gt;tag_at(index);
2377   if (!tag.is_invoke_dynamic() &amp;&amp; !tag.is_field_or_method()) {
2378     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2379   }
2380   return (jint) cp-&gt;uncached_name_and_type_ref_index_at(index);
2381 }
2382 JVM_END
2383 
2384 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2385 {
2386   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefInfoAt&quot;);
2387   JvmtiVMObjectAllocEventCollector oam;
2388   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2389   bounds_check(cp, index, CHECK_NULL);
2390   constantTag tag = cp-&gt;tag_at(index);
2391   if (!tag.is_name_and_type()) {
2392     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2393   }
2394   Symbol* member_name = cp-&gt;symbol_at(cp-&gt;name_ref_index_at(index));
2395   Symbol* member_sig = cp-&gt;symbol_at(cp-&gt;signature_ref_index_at(index));
2396   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
2397   objArrayHandle dest(THREAD, dest_o);
2398   Handle str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2399   dest-&gt;obj_at_put(0, str());
2400   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2401   dest-&gt;obj_at_put(1, str());
2402   return (jobjectArray) JNIHandles::make_local(dest());
2403 }
2404 JVM_END
2405 
2406 JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2407 {
2408   JVMWrapper(&quot;JVM_ConstantPoolGetIntAt&quot;);
2409   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2410   bounds_check(cp, index, CHECK_0);
2411   constantTag tag = cp-&gt;tag_at(index);
2412   if (!tag.is_int()) {
2413     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2414   }
2415   return cp-&gt;int_at(index);
2416 }
2417 JVM_END
2418 
2419 JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2420 {
2421   JVMWrapper(&quot;JVM_ConstantPoolGetLongAt&quot;);
2422   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2423   bounds_check(cp, index, CHECK_(0L));
2424   constantTag tag = cp-&gt;tag_at(index);
2425   if (!tag.is_long()) {
2426     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2427   }
2428   return cp-&gt;long_at(index);
2429 }
2430 JVM_END
2431 
2432 JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2433 {
2434   JVMWrapper(&quot;JVM_ConstantPoolGetFloatAt&quot;);
2435   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2436   bounds_check(cp, index, CHECK_(0.0f));
2437   constantTag tag = cp-&gt;tag_at(index);
2438   if (!tag.is_float()) {
2439     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2440   }
2441   return cp-&gt;float_at(index);
2442 }
2443 JVM_END
2444 
2445 JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2446 {
2447   JVMWrapper(&quot;JVM_ConstantPoolGetDoubleAt&quot;);
2448   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2449   bounds_check(cp, index, CHECK_(0.0));
2450   constantTag tag = cp-&gt;tag_at(index);
2451   if (!tag.is_double()) {
2452     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2453   }
2454   return cp-&gt;double_at(index);
2455 }
2456 JVM_END
2457 
2458 JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2459 {
2460   JVMWrapper(&quot;JVM_ConstantPoolGetStringAt&quot;);
2461   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2462   bounds_check(cp, index, CHECK_NULL);
2463   constantTag tag = cp-&gt;tag_at(index);
2464   if (!tag.is_string()) {
2465     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2466   }
2467   oop str = cp-&gt;string_at(index, CHECK_NULL);
2468   return (jstring) JNIHandles::make_local(str);
2469 }
2470 JVM_END
2471 
2472 JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))
2473 {
2474   JVMWrapper(&quot;JVM_ConstantPoolGetUTF8At&quot;);
2475   JvmtiVMObjectAllocEventCollector oam;
2476   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2477   bounds_check(cp, index, CHECK_NULL);
2478   constantTag tag = cp-&gt;tag_at(index);
2479   if (!tag.is_symbol()) {
2480     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2481   }
2482   Symbol* sym = cp-&gt;symbol_at(index);
2483   Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
2484   return (jstring) JNIHandles::make_local(str());
2485 }
2486 JVM_END
2487 
2488 JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2489 {
2490   JVMWrapper(&quot;JVM_ConstantPoolGetTagAt&quot;);
2491   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2492   bounds_check(cp, index, CHECK_0);
2493   constantTag tag = cp-&gt;tag_at(index);
2494   jbyte result = tag.value();
2495   // If returned tag values are not from the JVM spec, e.g. tags from 100 to 105,
2496   // they are changed to the corresponding tags from the JVM spec, so that java code in
2497   // sun.reflect.ConstantPool will return only tags from the JVM spec, not internal ones.
2498   if (tag.is_klass_or_reference()) {
2499       result = JVM_CONSTANT_Class;
2500   } else if (tag.is_string_index()) {
2501       result = JVM_CONSTANT_String;
2502   } else if (tag.is_method_type_in_error()) {
2503       result = JVM_CONSTANT_MethodType;
2504   } else if (tag.is_method_handle_in_error()) {
2505       result = JVM_CONSTANT_MethodHandle;
2506   } else if (tag.is_dynamic_constant_in_error()) {
2507       result = JVM_CONSTANT_Dynamic;
2508   }
2509   return result;
2510 }
2511 JVM_END
2512 
2513 // Assertion support. //////////////////////////////////////////////////////////
2514 
2515 JVM_ENTRY(jboolean, JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls))
2516   JVMWrapper(&quot;JVM_DesiredAssertionStatus&quot;);
2517   assert(cls != NULL, &quot;bad class&quot;);
2518 
2519   oop r = JNIHandles::resolve(cls);
2520   assert(! java_lang_Class::is_primitive(r), &quot;primitive classes not allowed&quot;);
2521   if (java_lang_Class::is_primitive(r)) return false;
2522 
2523   Klass* k = java_lang_Class::as_Klass(r);
2524   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2525   if (!k-&gt;is_instance_klass()) return false;
2526 
2527   ResourceMark rm(THREAD);
2528   const char* name = k-&gt;name()-&gt;as_C_string();
2529   bool system_class = k-&gt;class_loader() == NULL;
2530   return JavaAssertions::enabled(name, system_class);
2531 
2532 JVM_END
2533 
2534 
2535 // Return a new AssertionStatusDirectives object with the fields filled in with
2536 // command-line assertion arguments (i.e., -ea, -da).
2537 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2538   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2539   JvmtiVMObjectAllocEventCollector oam;
2540   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2541   return JNIHandles::make_local(env, asd);
2542 JVM_END
2543 
2544 // Arrays support /////////////////////////////////////////////////////////////
2545 
2546 JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))
2547   JVMWrapper(&quot;JVM_ArrayIsAccessAtomic&quot;);
2548   oop o = JNIHandles::resolve(array);
2549   Klass* k = o-&gt;klass();
2550   if ((o == NULL) || (!k-&gt;is_array_klass())) {
2551     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
2552   }
2553   return ArrayKlass::cast(k)-&gt;element_access_is_atomic();
2554 JVM_END
2555 
2556 JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))
2557   JVMWrapper(&quot;JVM_ArrayEnsureAccessAtomic&quot;);
2558   oop o = JNIHandles::resolve(array);
2559   Klass* k = o-&gt;klass();
2560   if ((o == NULL) || (!k-&gt;is_array_klass())) {
2561     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
2562   }
2563   if (k-&gt;is_flatArray_klass()) {
2564     FlatArrayKlass* vk = FlatArrayKlass::cast(k);
2565     if (!vk-&gt;element_access_is_atomic()) {
2566       /**
2567        * Need to decide how to implement:
2568        *
2569        * 1) Change to objArrayOop layout, therefore oop-&gt;klass() differs so
2570        * then &quot;&lt;atomic&gt;[Qfoo;&quot; klass needs to subclass &quot;[Qfoo;&quot; to pass through
2571        * &quot;checkcast&quot; &amp; &quot;instanceof&quot;
2572        *
2573        * 2) Use extra header in the flatArrayOop to flag atomicity required and
2574        * possibly per instance lock structure. Said info, could be placed in
2575        * &quot;trailer&quot; rather than disturb the current arrayOop
2576        */
2577       Unimplemented();
2578     }
2579   }
2580   return array;
2581 JVM_END
2582 
2583 // Verification ////////////////////////////////////////////////////////////////////////////////
2584 
2585 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2586 
2587 // RedefineClasses support: bug 6214132 caused verification to fail.
2588 // All functions from this section should call the jvmtiThreadSate function:
2589 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2590 // The function returns a Klass* of the _scratch_class if the verifier
2591 // was invoked in the middle of the class redefinition.
2592 // Otherwise it returns its argument value which is the _the_class Klass*.
2593 // Please, refer to the description in the jvmtiThreadSate.hpp.
2594 
2595 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2596   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2597   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2598   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2599   return k-&gt;name()-&gt;as_utf8();
2600 JVM_END
2601 
2602 
2603 JVM_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))
2604   JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
2605   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2606   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2607   // types will have length zero if this is not an InstanceKlass
2608   // (length is determined by call to JVM_GetClassCPEntriesCount)
2609   if (k-&gt;is_instance_klass()) {
2610     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2611     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2612       constantTag tag = cp-&gt;tag_at(index);
2613       types[index] = (tag.is_unresolved_klass()) ? (unsigned char) JVM_CONSTANT_Class : tag.value();
2614     }
2615   }
2616 JVM_END
2617 
2618 
2619 JVM_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))
2620   JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
2621   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2622   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2623   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2624 JVM_END
2625 
2626 
2627 JVM_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))
2628   JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
2629   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2630   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2631   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
2632 JVM_END
2633 
2634 
2635 JVM_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))
2636   JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
2637   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2638   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2639   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2640 JVM_END
2641 
2642 
2643 // The following methods, used for the verifier, are never called with
2644 // array klasses, so a direct cast to InstanceKlass is safe.
2645 // Typically, these methods are called in a loop with bounds determined
2646 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2647 // zero for arrays.
2648 JVM_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))
2649   JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
2650   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2651   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2652   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2653   int length = method-&gt;checked_exceptions_length();
2654   if (length &gt; 0) {
2655     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2656     for (int i = 0; i &lt; length; i++) {
2657       exceptions[i] = table[i].class_cp_index;
2658     }
2659   }
2660 JVM_END
2661 
2662 
2663 JVM_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))
2664   JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
2665   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2666   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2667   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2668   return method-&gt;checked_exceptions_length();
2669 JVM_END
2670 
2671 
2672 JVM_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))
2673   JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
2674   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2675   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2676   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2677   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2678 JVM_END
2679 
2680 
2681 JVM_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))
2682   JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
2683   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2684   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2685   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2686   return method-&gt;code_size();
2687 JVM_END
2688 
2689 
2690 JVM_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))
2691   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
2692   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2693   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2694   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2695   ExceptionTable extable(method);
2696   entry-&gt;start_pc   = extable.start_pc(entry_index);
2697   entry-&gt;end_pc     = extable.end_pc(entry_index);
2698   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2699   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2700 JVM_END
2701 
2702 
2703 JVM_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))
2704   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
2705   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2706   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2707   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2708   return method-&gt;exception_table_length();
2709 JVM_END
2710 
2711 
2712 JVM_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))
2713   JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
2714   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2715   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2716   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2717   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2718 JVM_END
2719 
2720 
2721 JVM_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))
2722   JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
2723   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2724   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2725   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2726 JVM_END
2727 
2728 
2729 JVM_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))
2730   JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
2731   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2732   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2733   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2734   return method-&gt;max_locals();
2735 JVM_END
2736 
2737 
2738 JVM_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))
2739   JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
2740   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2741   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2742   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2743   return method-&gt;size_of_parameters();
2744 JVM_END
2745 
2746 
2747 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2748   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2749   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2750   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2751   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2752   return method-&gt;verifier_max_stack();
2753 JVM_END
2754 
2755 
2756 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2757   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2758   ResourceMark rm(THREAD);
2759   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2760   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2761   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2762   return method-&gt;is_object_constructor();
2763 JVM_END
2764 
2765 
2766 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2767   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2768   ResourceMark rm(THREAD);
2769   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2770   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2771   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2772   return method-&gt;is_overpass();
2773 JVM_END
2774 
2775 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2776   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2777   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2778   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2779   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2780   return method-&gt;name()-&gt;as_utf8();
2781 JVM_END
2782 
2783 
2784 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2785   JVMWrapper(&quot;JVM_GetMethodIxSignatureUTF&quot;);
2786   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2787   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2788   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2789   return method-&gt;signature()-&gt;as_utf8();
2790 JVM_END
2791 
2792 /**
2793  * All of these JVM_GetCP-xxx methods are used by the old verifier to
2794  * read entries in the constant pool.  Since the old verifier always
2795  * works on a copy of the code, it will not see any rewriting that
2796  * may possibly occur in the middle of verification.  So it is important
2797  * that nothing it calls tries to use the cpCache instead of the raw
2798  * constant pool, so we must use cp-&gt;uncached_x methods when appropriate.
2799  */
2800 JVM_ENTRY(const char*, JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2801   JVMWrapper(&quot;JVM_GetCPFieldNameUTF&quot;);
2802   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2803   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2804   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2805   switch (cp-&gt;tag_at(cp_index).value()) {
2806     case JVM_CONSTANT_Fieldref:
2807       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2808     default:
2809       fatal(&quot;JVM_GetCPFieldNameUTF: illegal constant&quot;);
2810   }
2811   ShouldNotReachHere();
2812   return NULL;
2813 JVM_END
2814 
2815 
2816 JVM_ENTRY(const char*, JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2817   JVMWrapper(&quot;JVM_GetCPMethodNameUTF&quot;);
2818   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2819   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2820   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2821   switch (cp-&gt;tag_at(cp_index).value()) {
2822     case JVM_CONSTANT_InterfaceMethodref:
2823     case JVM_CONSTANT_Methodref:
2824       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2825     default:
2826       fatal(&quot;JVM_GetCPMethodNameUTF: illegal constant&quot;);
2827   }
2828   ShouldNotReachHere();
2829   return NULL;
2830 JVM_END
2831 
2832 
2833 JVM_ENTRY(const char*, JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2834   JVMWrapper(&quot;JVM_GetCPMethodSignatureUTF&quot;);
2835   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2836   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2837   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2838   switch (cp-&gt;tag_at(cp_index).value()) {
2839     case JVM_CONSTANT_InterfaceMethodref:
2840     case JVM_CONSTANT_Methodref:
2841       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2842     default:
2843       fatal(&quot;JVM_GetCPMethodSignatureUTF: illegal constant&quot;);
2844   }
2845   ShouldNotReachHere();
2846   return NULL;
2847 JVM_END
2848 
2849 
2850 JVM_ENTRY(const char*, JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2851   JVMWrapper(&quot;JVM_GetCPFieldSignatureUTF&quot;);
2852   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2853   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2854   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2855   switch (cp-&gt;tag_at(cp_index).value()) {
2856     case JVM_CONSTANT_Fieldref:
2857       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2858     default:
2859       fatal(&quot;JVM_GetCPFieldSignatureUTF: illegal constant&quot;);
2860   }
2861   ShouldNotReachHere();
2862   return NULL;
2863 JVM_END
2864 
2865 
2866 JVM_ENTRY(const char*, JVM_GetCPClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2867   JVMWrapper(&quot;JVM_GetCPClassNameUTF&quot;);
2868   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2869   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2870   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2871   Symbol* classname = cp-&gt;klass_name_at(cp_index);
2872   return classname-&gt;as_utf8();
2873 JVM_END
2874 
2875 
2876 JVM_ENTRY(const char*, JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2877   JVMWrapper(&quot;JVM_GetCPFieldClassNameUTF&quot;);
2878   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2879   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2880   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2881   switch (cp-&gt;tag_at(cp_index).value()) {
2882     case JVM_CONSTANT_Fieldref: {
2883       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2884       Symbol* classname = cp-&gt;klass_name_at(class_index);
2885       return classname-&gt;as_utf8();
2886     }
2887     default:
2888       fatal(&quot;JVM_GetCPFieldClassNameUTF: illegal constant&quot;);
2889   }
2890   ShouldNotReachHere();
2891   return NULL;
2892 JVM_END
2893 
2894 
2895 JVM_ENTRY(const char*, JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2896   JVMWrapper(&quot;JVM_GetCPMethodClassNameUTF&quot;);
2897   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2898   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2899   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2900   switch (cp-&gt;tag_at(cp_index).value()) {
2901     case JVM_CONSTANT_Methodref:
2902     case JVM_CONSTANT_InterfaceMethodref: {
2903       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2904       Symbol* classname = cp-&gt;klass_name_at(class_index);
2905       return classname-&gt;as_utf8();
2906     }
2907     default:
2908       fatal(&quot;JVM_GetCPMethodClassNameUTF: illegal constant&quot;);
2909   }
2910   ShouldNotReachHere();
2911   return NULL;
2912 JVM_END
2913 
2914 
2915 JVM_ENTRY(jint, JVM_GetCPFieldModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2916   JVMWrapper(&quot;JVM_GetCPFieldModifiers&quot;);
2917   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2918   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2919   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2920   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2921   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2922   ConstantPool* cp_called = InstanceKlass::cast(k_called)-&gt;constants();
2923   switch (cp-&gt;tag_at(cp_index).value()) {
2924     case JVM_CONSTANT_Fieldref: {
2925       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2926       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2927       InstanceKlass* ik = InstanceKlass::cast(k_called);
2928       for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {
2929         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2930           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2931         }
2932       }
2933       return -1;
2934     }
2935     default:
2936       fatal(&quot;JVM_GetCPFieldModifiers: illegal constant&quot;);
2937   }
2938   ShouldNotReachHere();
2939   return 0;
2940 JVM_END
2941 
2942 
2943 JVM_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2944   JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
2945   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2946   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2947   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2948   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2949   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2950   switch (cp-&gt;tag_at(cp_index).value()) {
2951     case JVM_CONSTANT_Methodref:
2952     case JVM_CONSTANT_InterfaceMethodref: {
2953       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2954       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2955       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2956       int methods_count = methods-&gt;length();
2957       for (int i = 0; i &lt; methods_count; i++) {
2958         Method* method = methods-&gt;at(i);
2959         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2960             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2961         }
2962       }
2963       return -1;
2964     }
2965     default:
2966       fatal(&quot;JVM_GetCPMethodModifiers: illegal constant&quot;);
2967   }
2968   ShouldNotReachHere();
2969   return 0;
2970 JVM_END
2971 
2972 
2973 // Misc //////////////////////////////////////////////////////////////////////////////////////////////
2974 
2975 JVM_LEAF(void, JVM_ReleaseUTF(const char *utf))
2976   // So long as UTF8::convert_to_utf8 returns resource strings, we don&#39;t have to do anything
2977 JVM_END
2978 
2979 
2980 JVM_ENTRY(jboolean, JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2))
2981   JVMWrapper(&quot;JVM_IsSameClassPackage&quot;);
2982   oop class1_mirror = JNIHandles::resolve_non_null(class1);
2983   oop class2_mirror = JNIHandles::resolve_non_null(class2);
2984   Klass* klass1 = java_lang_Class::as_Klass(class1_mirror);
2985   Klass* klass2 = java_lang_Class::as_Klass(class2_mirror);
2986   return (jboolean) Reflection::is_same_class_package(klass1, klass2);
2987 JVM_END
2988 
2989 // Printing support //////////////////////////////////////////////////
2990 extern &quot;C&quot; {
2991 
2992 ATTRIBUTE_PRINTF(3, 0)
2993 int jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args) {
2994   // Reject count values that are negative signed values converted to
2995   // unsigned; see bug 4399518, 4417214
2996   if ((intptr_t)count &lt;= 0) return -1;
2997 
2998   int result = os::vsnprintf(str, count, fmt, args);
2999   if (result &gt; 0 &amp;&amp; (size_t)result &gt;= count) {
3000     result = -1;
3001   }
3002 
3003   return result;
3004 }
3005 
3006 ATTRIBUTE_PRINTF(3, 4)
3007 int jio_snprintf(char *str, size_t count, const char *fmt, ...) {
3008   va_list args;
3009   int len;
3010   va_start(args, fmt);
3011   len = jio_vsnprintf(str, count, fmt, args);
3012   va_end(args);
3013   return len;
3014 }
3015 
3016 ATTRIBUTE_PRINTF(2, 3)
3017 int jio_fprintf(FILE* f, const char *fmt, ...) {
3018   int len;
3019   va_list args;
3020   va_start(args, fmt);
3021   len = jio_vfprintf(f, fmt, args);
3022   va_end(args);
3023   return len;
3024 }
3025 
3026 ATTRIBUTE_PRINTF(2, 0)
3027 int jio_vfprintf(FILE* f, const char *fmt, va_list args) {
3028   if (Arguments::vfprintf_hook() != NULL) {
3029      return Arguments::vfprintf_hook()(f, fmt, args);
3030   } else {
3031     return vfprintf(f, fmt, args);
3032   }
3033 }
3034 
3035 ATTRIBUTE_PRINTF(1, 2)
3036 JNIEXPORT int jio_printf(const char *fmt, ...) {
3037   int len;
3038   va_list args;
3039   va_start(args, fmt);
3040   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
3041   va_end(args);
3042   return len;
3043 }
3044 
3045 // HotSpot specific jio method
3046 void jio_print(const char* s, size_t len) {
3047   // Try to make this function as atomic as possible.
3048   if (Arguments::vfprintf_hook() != NULL) {
3049     jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
3050   } else {
3051     // Make an unused local variable to avoid warning from gcc compiler.
3052     size_t count = ::write(defaultStream::output_fd(), s, (int)len);
3053   }
3054 }
3055 
3056 } // Extern C
3057 
3058 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
3059 
3060 // In most of the JVM thread support functions we need to access the
3061 // thread through a ThreadsListHandle to prevent it from exiting and
3062 // being reclaimed while we try to operate on it. The exceptions to this
3063 // rule are when operating on the current thread, or if the monitor of
3064 // the target java.lang.Thread is locked at the Java level - in both
3065 // cases the target cannot exit.
3066 
3067 static void thread_entry(JavaThread* thread, TRAPS) {
3068   HandleMark hm(THREAD);
3069   Handle obj(THREAD, thread-&gt;threadObj());
3070   JavaValue result(T_VOID);
3071   JavaCalls::call_virtual(&amp;result,
3072                           obj,
3073                           SystemDictionary::Thread_klass(),
3074                           vmSymbols::run_method_name(),
3075                           vmSymbols::void_method_signature(),
3076                           THREAD);
3077 }
3078 
3079 
3080 JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
3081   JVMWrapper(&quot;JVM_StartThread&quot;);
3082   JavaThread *native_thread = NULL;
3083 
3084   // We cannot hold the Threads_lock when we throw an exception,
3085   // due to rank ordering issues. Example:  we might need to grab the
3086   // Heap_lock while we construct the exception.
3087   bool throw_illegal_thread_state = false;
3088 
3089   // We must release the Threads_lock before we can post a jvmti event
3090   // in Thread::start.
3091   {
3092     // Ensure that the C++ Thread and OSThread structures aren&#39;t freed before
3093     // we operate.
3094     MutexLocker mu(Threads_lock);
3095 
3096     // Since JDK 5 the java.lang.Thread threadStatus is used to prevent
3097     // re-starting an already started thread, so we should usually find
3098     // that the JavaThread is null. However for a JNI attached thread
3099     // there is a small window between the Thread object being created
3100     // (with its JavaThread set) and the update to its threadStatus, so we
3101     // have to check for this
3102     if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {
3103       throw_illegal_thread_state = true;
3104     } else {
3105       // We could also check the stillborn flag to see if this thread was already stopped, but
3106       // for historical reasons we let the thread detect that itself when it starts running
3107 
3108       jlong size =
3109              java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
3110       // Allocate the C++ Thread structure and create the native thread.  The
3111       // stack size retrieved from java is 64-bit signed, but the constructor takes
3112       // size_t (an unsigned type), which may be 32 or 64-bit depending on the platform.
3113       //  - Avoid truncating on 32-bit platforms if size is greater than UINT_MAX.
3114       //  - Avoid passing negative values which would result in really large stacks.
3115       NOT_LP64(if (size &gt; SIZE_MAX) size = SIZE_MAX;)
3116       size_t sz = size &gt; 0 ? (size_t) size : 0;
3117       native_thread = new JavaThread(&amp;thread_entry, sz);
3118 
3119       // At this point it may be possible that no osthread was created for the
3120       // JavaThread due to lack of memory. Check for this situation and throw
3121       // an exception if necessary. Eventually we may want to change this so
3122       // that we only grab the lock if the thread was created successfully -
3123       // then we can also do this check and throw the exception in the
3124       // JavaThread constructor.
3125       if (native_thread-&gt;osthread() != NULL) {
3126         // Note: the current thread is not being used within &quot;prepare&quot;.
3127         native_thread-&gt;prepare(jthread);
3128       }
3129     }
3130   }
3131 
3132   if (throw_illegal_thread_state) {
3133     THROW(vmSymbols::java_lang_IllegalThreadStateException());
3134   }
3135 
3136   assert(native_thread != NULL, &quot;Starting null thread?&quot;);
3137 
3138   if (native_thread-&gt;osthread() == NULL) {
3139     // No one should hold a reference to the &#39;native_thread&#39;.
3140     native_thread-&gt;smr_delete();
3141     if (JvmtiExport::should_post_resource_exhausted()) {
3142       JvmtiExport::post_resource_exhausted(
3143         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,
3144         os::native_thread_creation_failed_msg());
3145     }
3146     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
3147               os::native_thread_creation_failed_msg());
3148   }
3149 
3150 #if INCLUDE_JFR
3151   if (JfrRecorder::is_recording() &amp;&amp; EventThreadStart::is_enabled() &amp;&amp;
3152       EventThreadStart::is_stacktrace_enabled()) {
3153     JfrThreadLocal* tl = native_thread-&gt;jfr_thread_local();
3154     // skip Thread.start() and Thread.start0()
3155     tl-&gt;set_cached_stack_trace_id(JfrStackTraceRepository::record(thread, 2));
3156   }
3157 #endif
3158 
3159   Thread::start(native_thread);
3160 
3161 JVM_END
3162 
3163 
3164 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
3165 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
3166 // but is thought to be reliable and simple. In the case, where the receiver is the
3167 // same thread as the sender, no VM_Operation is needed.
3168 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
3169   JVMWrapper(&quot;JVM_StopThread&quot;);
3170 
3171   // A nested ThreadsListHandle will grab the Threads_lock so create
3172   // tlh before we resolve throwable.
3173   ThreadsListHandle tlh(thread);
3174   oop java_throwable = JNIHandles::resolve(throwable);
3175   if (java_throwable == NULL) {
3176     THROW(vmSymbols::java_lang_NullPointerException());
3177   }
3178   oop java_thread = NULL;
3179   JavaThread* receiver = NULL;
3180   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3181   Events::log_exception(thread,
3182                         &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
3183                         p2i(receiver), p2i(java_thread), p2i(throwable));
3184 
3185   if (is_alive) {
3186     // jthread refers to a live JavaThread.
3187     if (thread == receiver) {
3188       // Exception is getting thrown at self so no VM_Operation needed.
3189       THROW_OOP(java_throwable);
3190     } else {
3191       // Use a VM_Operation to throw the exception.
3192       Thread::send_async_exception(java_thread, java_throwable);
3193     }
3194   } else {
3195     // Either:
3196     // - target thread has not been started before being stopped, or
3197     // - target thread already terminated
3198     // We could read the threadStatus to determine which case it is
3199     // but that is overkill as it doesn&#39;t matter. We must set the
3200     // stillborn flag for the first case, and if the thread has already
3201     // exited setting this flag has no effect.
3202     java_lang_Thread::set_stillborn(java_thread);
3203   }
3204 JVM_END
3205 
3206 
3207 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
3208   JVMWrapper(&quot;JVM_IsThreadAlive&quot;);
3209 
3210   oop thread_oop = JNIHandles::resolve_non_null(jthread);
3211   return java_lang_Thread::is_alive(thread_oop);
3212 JVM_END
3213 
3214 
3215 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
3216   JVMWrapper(&quot;JVM_SuspendThread&quot;);
3217 
3218   ThreadsListHandle tlh(thread);
3219   JavaThread* receiver = NULL;
3220   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3221   if (is_alive) {
3222     // jthread refers to a live JavaThread.
3223     {
3224       MutexLocker ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);
3225       if (receiver-&gt;is_external_suspend()) {
3226         // Don&#39;t allow nested external suspend requests. We can&#39;t return
3227         // an error from this interface so just ignore the problem.
3228         return;
3229       }
3230       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
3231         return;
3232       }
3233       receiver-&gt;set_external_suspend();
3234     }
3235 
3236     // java_suspend() will catch threads in the process of exiting
3237     // and will ignore them.
3238     receiver-&gt;java_suspend();
3239 
3240     // It would be nice to have the following assertion in all the
3241     // time, but it is possible for a racing resume request to have
3242     // resumed this thread right after we suspended it. Temporarily
3243     // enable this assertion if you are chasing a different kind of
3244     // bug.
3245     //
3246     // assert(java_lang_Thread::thread(receiver-&gt;threadObj()) == NULL ||
3247     //   receiver-&gt;is_being_ext_suspended(), &quot;thread is not suspended&quot;);
3248   }
3249 JVM_END
3250 
3251 
3252 JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))
3253   JVMWrapper(&quot;JVM_ResumeThread&quot;);
3254 
3255   ThreadsListHandle tlh(thread);
3256   JavaThread* receiver = NULL;
3257   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3258   if (is_alive) {
3259     // jthread refers to a live JavaThread.
3260 
3261     // This is the original comment for this Threads_lock grab:
3262     //   We need to *always* get the threads lock here, since this operation cannot be allowed during
3263     //   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other
3264     //   threads randomly resumes threads, then a thread might not be suspended when the safepoint code
3265     //   looks at it.
3266     //
3267     // The above comment dates back to when we had both internal and
3268     // external suspend APIs that shared a common underlying mechanism.
3269     // External suspend is now entirely cooperative and doesn&#39;t share
3270     // anything with internal suspend. That said, there are some
3271     // assumptions in the VM that an external resume grabs the
3272     // Threads_lock. We can&#39;t drop the Threads_lock grab here until we
3273     // resolve the assumptions that exist elsewhere.
3274     //
3275     MutexLocker ml(Threads_lock);
3276     receiver-&gt;java_resume();
3277   }
3278 JVM_END
3279 
3280 
3281 JVM_ENTRY(void, JVM_SetThreadPriority(JNIEnv* env, jobject jthread, jint prio))
3282   JVMWrapper(&quot;JVM_SetThreadPriority&quot;);
3283 
3284   ThreadsListHandle tlh(thread);
3285   oop java_thread = NULL;
3286   JavaThread* receiver = NULL;
3287   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3288   java_lang_Thread::set_priority(java_thread, (ThreadPriority)prio);
3289 
3290   if (is_alive) {
3291     // jthread refers to a live JavaThread.
3292     Thread::set_priority(receiver, (ThreadPriority)prio);
3293   }
3294   // Implied else: If the JavaThread hasn&#39;t started yet, then the
3295   // priority set in the java.lang.Thread object above will be pushed
3296   // down when it does start.
3297 JVM_END
3298 
3299 
3300 JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))
3301   JVMWrapper(&quot;JVM_Yield&quot;);
3302   if (os::dont_yield()) return;
3303   HOTSPOT_THREAD_YIELD();
3304   os::naked_yield();
3305 JVM_END
3306 
3307 static void post_thread_sleep_event(EventThreadSleep* event, jlong millis) {
3308   assert(event != NULL, &quot;invariant&quot;);
3309   assert(event-&gt;should_commit(), &quot;invariant&quot;);
3310   event-&gt;set_time(millis);
3311   event-&gt;commit();
3312 }
3313 
3314 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
3315   JVMWrapper(&quot;JVM_Sleep&quot;);
3316 
3317   if (millis &lt; 0) {
3318     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
3319   }
3320 
3321   if (thread-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {
3322     THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3323   }
3324 
3325   // Save current thread state and restore it at the end of this block.
3326   // And set new thread state to SLEEPING.
3327   JavaThreadSleepState jtss(thread);
3328 
3329   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
3330   EventThreadSleep event;
3331 
3332   if (millis == 0) {
3333     os::naked_yield();
3334   } else {
3335     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3336     thread-&gt;osthread()-&gt;set_state(SLEEPING);
3337     if (!thread-&gt;sleep(millis)) { // interrupted
3338       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
3339       // us while we were sleeping. We do not overwrite those.
3340       if (!HAS_PENDING_EXCEPTION) {
3341         if (event.should_commit()) {
3342           post_thread_sleep_event(&amp;event, millis);
3343         }
3344         HOTSPOT_THREAD_SLEEP_END(1);
3345 
3346         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
3347         // to properly restore the thread state.  That&#39;s likely wrong.
3348         THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3349       }
3350     }
3351     thread-&gt;osthread()-&gt;set_state(old_state);
3352   }
3353   if (event.should_commit()) {
3354     post_thread_sleep_event(&amp;event, millis);
3355   }
3356   HOTSPOT_THREAD_SLEEP_END(0);
3357 JVM_END
3358 
3359 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3360   JVMWrapper(&quot;JVM_CurrentThread&quot;);
3361   oop jthread = thread-&gt;threadObj();
3362   assert (thread != NULL, &quot;no current thread!&quot;);
3363   return JNIHandles::make_local(env, jthread);
3364 JVM_END
3365 
3366 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3367   JVMWrapper(&quot;JVM_Interrupt&quot;);
3368 
3369   ThreadsListHandle tlh(thread);
3370   JavaThread* receiver = NULL;
3371   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3372   if (is_alive) {
3373     // jthread refers to a live JavaThread.
3374     receiver-&gt;interrupt();
3375   }
3376 JVM_END
3377 
3378 
3379 // Return true iff the current thread has locked the object passed in
3380 
3381 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3382   JVMWrapper(&quot;JVM_HoldsLock&quot;);
3383   assert(THREAD-&gt;is_Java_thread(), &quot;sanity check&quot;);
3384   if (obj == NULL) {
3385     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3386   }
3387   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3388   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3389 JVM_END
3390 
3391 
3392 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3393   JVMWrapper(&quot;JVM_DumpAllStacks&quot;);
3394   VM_PrintThreads op;
3395   VMThread::execute(&amp;op);
3396   if (JvmtiExport::should_post_data_dump()) {
3397     JvmtiExport::post_data_dump();
3398   }
3399 JVM_END
3400 
3401 JVM_ENTRY(void, JVM_SetNativeThreadName(JNIEnv* env, jobject jthread, jstring name))
3402   JVMWrapper(&quot;JVM_SetNativeThreadName&quot;);
3403 
3404   // We don&#39;t use a ThreadsListHandle here because the current thread
3405   // must be alive.
3406   oop java_thread = JNIHandles::resolve_non_null(jthread);
3407   JavaThread* thr = java_lang_Thread::thread(java_thread);
3408   if (thread == thr &amp;&amp; !thr-&gt;has_attached_via_jni()) {
3409     // Thread naming is only supported for the current thread and
3410     // we don&#39;t set the name of an attached thread to avoid stepping
3411     // on other programs.
3412     ResourceMark rm(thread);
3413     const char *thread_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3414     os::set_native_thread_name(thread_name);
3415   }
3416 JVM_END
3417 
3418 // java.lang.SecurityManager ///////////////////////////////////////////////////////////////////////
3419 
3420 JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))
3421   JVMWrapper(&quot;JVM_GetClassContext&quot;);
3422   ResourceMark rm(THREAD);
3423   JvmtiVMObjectAllocEventCollector oam;
3424   vframeStream vfst(thread);
3425 
3426   if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {
3427     // This must only be called from SecurityManager.getClassContext
3428     Method* m = vfst.method();
3429     if (!(m-&gt;method_holder() == SystemDictionary::SecurityManager_klass() &amp;&amp;
3430           m-&gt;name()          == vmSymbols::getClassContext_name() &amp;&amp;
3431           m-&gt;signature()     == vmSymbols::void_class_array_signature())) {
3432       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetClassContext must only be called from SecurityManager.getClassContext&quot;);
3433     }
3434   }
3435 
3436   // Collect method holders
3437   GrowableArray&lt;Klass*&gt;* klass_array = new GrowableArray&lt;Klass*&gt;();
3438   for (; !vfst.at_end(); vfst.security_next()) {
3439     Method* m = vfst.method();
3440     // Native frames are not returned
3441     if (!m-&gt;is_ignored_by_security_stack_walk() &amp;&amp; !m-&gt;is_native()) {
3442       Klass* holder = m-&gt;method_holder();
3443       assert(holder-&gt;is_klass(), &quot;just checking&quot;);
3444       klass_array-&gt;append(holder);
3445     }
3446   }
3447 
3448   // Create result array of type [Ljava/lang/Class;
3449   objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array-&gt;length(), CHECK_NULL);
3450   // Fill in mirrors corresponding to method holders
3451   for (int i = 0; i &lt; klass_array-&gt;length(); i++) {
3452     result-&gt;obj_at_put(i, klass_array-&gt;at(i)-&gt;java_mirror());
3453   }
3454 
3455   return (jobjectArray) JNIHandles::make_local(env, result);
3456 JVM_END
3457 
3458 
3459 // java.lang.Package ////////////////////////////////////////////////////////////////
3460 
3461 
3462 JVM_ENTRY(jstring, JVM_GetSystemPackage(JNIEnv *env, jstring name))
3463   JVMWrapper(&quot;JVM_GetSystemPackage&quot;);
3464   ResourceMark rm(THREAD);
3465   JvmtiVMObjectAllocEventCollector oam;
3466   char* str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3467   oop result = ClassLoader::get_system_package(str, CHECK_NULL);
3468   return (jstring) JNIHandles::make_local(result);
3469 JVM_END
3470 
3471 
3472 JVM_ENTRY(jobjectArray, JVM_GetSystemPackages(JNIEnv *env))
3473   JVMWrapper(&quot;JVM_GetSystemPackages&quot;);
3474   JvmtiVMObjectAllocEventCollector oam;
3475   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3476   return (jobjectArray) JNIHandles::make_local(result);
3477 JVM_END
3478 
3479 
3480 // java.lang.ref.Reference ///////////////////////////////////////////////////////////////
3481 
3482 
3483 JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
3484   JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
3485 
3486   MonitorLocker ml(Heap_lock);
3487   oop ref = Universe::reference_pending_list();
3488   if (ref != NULL) {
3489     Universe::set_reference_pending_list(NULL);
3490   }
3491   return JNIHandles::make_local(env, ref);
3492 JVM_END
3493 
3494 JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
3495   JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
3496   MonitorLocker ml(Heap_lock);
3497   return Universe::has_reference_pending_list();
3498 JVM_END
3499 
3500 JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
3501   JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
3502   MonitorLocker ml(Heap_lock);
3503   while (!Universe::has_reference_pending_list()) {
3504     ml.wait();
3505   }
3506 JVM_END
3507 
3508 
3509 // ObjectInputStream ///////////////////////////////////////////////////////////////
3510 
3511 // Return the first user-defined class loader up the execution stack, or null
3512 // if only code from the bootstrap or platform class loader is on the stack.
3513 
3514 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3515   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3516     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3517     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3518     if (loader != NULL &amp;&amp; !SystemDictionary::is_platform_class_loader(loader)) {
3519       return JNIHandles::make_local(env, loader);
3520     }
3521   }
3522   return NULL;
3523 JVM_END
3524 
3525 
3526 // Array ///////////////////////////////////////////////////////////////////////////////////////////
3527 
3528 
3529 // resolve array handle and check arguments
3530 static inline arrayOop check_array(JNIEnv *env, jobject arr, bool type_array_only, TRAPS) {
3531   if (arr == NULL) {
3532     THROW_0(vmSymbols::java_lang_NullPointerException());
3533   }
3534   oop a = JNIHandles::resolve_non_null(arr);
3535   if (!a-&gt;is_array()) {
3536     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array&quot;);
3537   } else if (type_array_only &amp;&amp; !a-&gt;is_typeArray()) {
3538     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array of primitive type&quot;);
3539   }
3540   return arrayOop(a);
3541 }
3542 
3543 
3544 JVM_ENTRY(jint, JVM_GetArrayLength(JNIEnv *env, jobject arr))
3545   JVMWrapper(&quot;JVM_GetArrayLength&quot;);
3546   arrayOop a = check_array(env, arr, false, CHECK_0);
3547   return a-&gt;length();
3548 JVM_END
3549 
3550 
3551 JVM_ENTRY(jobject, JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index))
3552   JVMWrapper(&quot;JVM_Array_Get&quot;);
3553   JvmtiVMObjectAllocEventCollector oam;
3554   arrayOop a = check_array(env, arr, false, CHECK_NULL);
3555   jvalue value;
3556   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_NULL);
3557   oop box = Reflection::box(&amp;value, type, CHECK_NULL);
3558   return JNIHandles::make_local(env, box);
3559 JVM_END
3560 
3561 
3562 JVM_ENTRY(jvalue, JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode))
3563   JVMWrapper(&quot;JVM_GetPrimitiveArrayElement&quot;);
3564   jvalue value;
3565   value.i = 0; // to initialize value before getting used in CHECK
3566   arrayOop a = check_array(env, arr, true, CHECK_(value));
3567   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3568   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_(value));
3569   BasicType wide_type = (BasicType) wCode;
3570   if (type != wide_type) {
3571     Reflection::widen(&amp;value, type, wide_type, CHECK_(value));
3572   }
3573   return value;
3574 JVM_END
3575 
3576 
3577 JVM_ENTRY(void, JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val))
3578   JVMWrapper(&quot;JVM_SetArrayElement&quot;);
3579   arrayOop a = check_array(env, arr, false, CHECK);
3580   oop box = JNIHandles::resolve(val);
3581   jvalue value;
3582   value.i = 0; // to initialize value before getting used in CHECK
3583   BasicType value_type;
3584   if (a-&gt;is_objArray()) {
3585     // Make sure we do no unbox e.g. java/lang/Integer instances when storing into an object array
3586     value_type = Reflection::unbox_for_regular_object(box, &amp;value);
3587   } else {
3588     value_type = Reflection::unbox_for_primitive(box, &amp;value, CHECK);
3589   }
3590   Reflection::array_set(&amp;value, a, index, value_type, CHECK);
3591 JVM_END
3592 
3593 
3594 JVM_ENTRY(void, JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v, unsigned char vCode))
3595   JVMWrapper(&quot;JVM_SetPrimitiveArrayElement&quot;);
3596   arrayOop a = check_array(env, arr, true, CHECK);
3597   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3598   BasicType value_type = (BasicType) vCode;
3599   Reflection::array_set(&amp;v, a, index, value_type, CHECK);
3600 JVM_END
3601 
3602 
3603 JVM_ENTRY(jobject, JVM_NewArray(JNIEnv *env, jclass eltClass, jint length))
3604   JVMWrapper(&quot;JVM_NewArray&quot;);
3605   JvmtiVMObjectAllocEventCollector oam;
3606   oop element_mirror = JNIHandles::resolve(eltClass);
3607   oop result = Reflection::reflect_new_array(element_mirror, length, CHECK_NULL);
3608   return JNIHandles::make_local(env, result);
3609 JVM_END
3610 
3611 
3612 JVM_ENTRY(jobject, JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim))
3613   JVMWrapper(&quot;JVM_NewMultiArray&quot;);
3614   JvmtiVMObjectAllocEventCollector oam;
3615   arrayOop dim_array = check_array(env, dim, true, CHECK_NULL);
3616   oop element_mirror = JNIHandles::resolve(eltClass);
3617   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
3618   oop result = Reflection::reflect_new_multi_array(element_mirror, typeArrayOop(dim_array), CHECK_NULL);
3619   return JNIHandles::make_local(env, result);
3620 JVM_END
3621 
3622 
3623 // Library support ///////////////////////////////////////////////////////////////////////////
3624 
3625 JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
3626   //%note jvm_ct
3627   JVMWrapper(&quot;JVM_LoadLibrary&quot;);
3628   char ebuf[1024];
3629   void *load_result;
3630   {
3631     ThreadToNativeFromVM ttnfvm(thread);
3632     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3633   }
3634   if (load_result == NULL) {
3635     char msg[1024];
3636     jio_snprintf(msg, sizeof msg, &quot;%s: %s&quot;, name, ebuf);
3637     // Since &#39;ebuf&#39; may contain a string encoded using
3638     // platform encoding scheme, we need to pass
3639     // Exceptions::unsafe_to_utf8 to the new_exception method
3640     // as the last argument. See bug 6367357.
3641     Handle h_exception =
3642       Exceptions::new_exception(thread,
3643                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3644                                 msg, Exceptions::unsafe_to_utf8);
3645 
3646     THROW_HANDLE_0(h_exception);
3647   }
3648   log_info(library)(&quot;Loaded library %s, handle &quot; INTPTR_FORMAT, name, p2i(load_result));
3649   return load_result;
3650 JVM_END
3651 
3652 
3653 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3654   JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
3655   os::dll_unload(handle);
3656   log_info(library)(&quot;Unloaded library with handle &quot; INTPTR_FORMAT, p2i(handle));
3657 JVM_END
3658 
3659 
3660 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3661   JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
3662   void* find_result = os::dll_lookup(handle, name);
3663   log_info(library)(&quot;%s %s in library with handle &quot; INTPTR_FORMAT,
3664                     find_result != NULL ? &quot;Found&quot; : &quot;Failed to find&quot;,
3665                     name, p2i(handle));
3666   return find_result;
3667 JVM_END
3668 
3669 
3670 // JNI version ///////////////////////////////////////////////////////////////////////////////
3671 
3672 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3673   JVMWrapper(&quot;JVM_IsSupportedJNIVersion&quot;);
3674   return Threads::is_supported_jni_version_including_1_1(version);
3675 JVM_END
3676 
3677 
3678 // String support ///////////////////////////////////////////////////////////////////////////
3679 
3680 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3681   JVMWrapper(&quot;JVM_InternString&quot;);
3682   JvmtiVMObjectAllocEventCollector oam;
3683   if (str == NULL) return NULL;
3684   oop string = JNIHandles::resolve_non_null(str);
3685   oop result = StringTable::intern(string, CHECK_NULL);
3686   return (jstring) JNIHandles::make_local(env, result);
3687 JVM_END
3688 
3689 
3690 // VM Raw monitor support //////////////////////////////////////////////////////////////////////
3691 
3692 // VM Raw monitors (not to be confused with JvmtiRawMonitors) are a simple mutual exclusion
3693 // lock (not actually monitors: no wait/notify) that is exported by the VM for use by JDK
3694 // library code. They may be used by JavaThreads and non-JavaThreads and do not participate
3695 // in the safepoint protocol, thread suspension, thread interruption, or anything of that
3696 // nature. JavaThreads will be &quot;in native&quot; when using this API from JDK code.
3697 
3698 
3699 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3700   VM_Exit::block_if_vm_exited();
3701   JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
3702   return new os::PlatformMutex();
3703 }
3704 
3705 
3706 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3707   VM_Exit::block_if_vm_exited();
3708   JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
3709   delete ((os::PlatformMutex*) mon);
3710 }
3711 
3712 
3713 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3714   VM_Exit::block_if_vm_exited();
3715   JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
3716   ((os::PlatformMutex*) mon)-&gt;lock();
3717   return 0;
3718 }
3719 
3720 
3721 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3722   VM_Exit::block_if_vm_exited();
3723   JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
3724   ((os::PlatformMutex*) mon)-&gt;unlock();
3725 }
3726 
3727 
3728 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3729 
3730 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
3731                                     Handle loader, Handle protection_domain,
3732                                     jboolean throwError, TRAPS) {
3733   // Security Note:
3734   //   The Java level wrapper will perform the necessary security check allowing
3735   //   us to pass the NULL as the initiating class loader.  The VM is responsible for
3736   //   the checkPackageAccess relative to the initiating class loader via the
3737   //   protection_domain. The protection_domain is passed as NULL by the java code
3738   //   if there is no security manager in 3-arg Class.forName().
3739   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3740 
3741   // Check if we should initialize the class
3742   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3743     klass-&gt;initialize(CHECK_NULL);
3744   }
3745   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3746 }
3747 
3748 
3749 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3750 
3751 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3752   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3753   Handle method_handle;
3754   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3755     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3756     Handle receiver(THREAD, JNIHandles::resolve(obj));
3757     objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);
3758     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3759     jobject res = JNIHandles::make_local(env, result);
3760     if (JvmtiExport::should_post_vm_object_alloc()) {
3761       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3762       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3763       if (java_lang_Class::is_primitive(ret_type)) {
3764         // Only for primitive type vm allocates memory for java object.
3765         // See box() method.
3766         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3767       }
3768     }
3769     return res;
3770   } else {
3771     THROW_0(vmSymbols::java_lang_StackOverflowError());
3772   }
3773 JVM_END
3774 
3775 
3776 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3777   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
3778   objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);
3779   oop constructor_mirror = JNIHandles::resolve(c);
3780   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3781   jobject res = JNIHandles::make_local(env, result);
3782   if (JvmtiExport::should_post_vm_object_alloc()) {
3783     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3784   }
3785   return res;
3786 JVM_END
3787 
3788 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3789 
3790 JVM_LEAF(jboolean, JVM_SupportsCX8())
3791   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3792   return VM_Version::supports_cx8();
3793 JVM_END
3794 
3795 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3796   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3797   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3798   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3799   HeapShared::initialize_from_archived_subgraph(k);
3800 JVM_END
3801 
3802 JVM_ENTRY(void, JVM_RegisterLambdaProxyClassForArchiving(JNIEnv* env,
3803                                               jclass caller,
3804                                               jstring invokedName,
3805                                               jobject invokedType,
3806                                               jobject methodType,
3807                                               jobject implMethodMember,
3808                                               jobject instantiatedMethodType,
3809                                               jclass lambdaProxyClass))
3810   JVMWrapper(&quot;JVM_RegisterLambdaProxyClassForArchiving&quot;);
3811 #if INCLUDE_CDS
3812   if (!DynamicDumpSharedSpaces) {
3813     return;
3814   }
3815 
3816   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));
3817   InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);
3818   if (caller_ik-&gt;is_hidden() || caller_ik-&gt;is_unsafe_anonymous()) {
3819     // VM anonymous classes and hidden classes not of type lambda proxy classes are currently not being archived.
3820     // If the caller_ik is of one of the above types, the corresponding lambda proxy class won&#39;t be
3821     // registered for archiving.
3822     return;
3823   }
3824   Klass* lambda_k = java_lang_Class::as_Klass(JNIHandles::resolve(lambdaProxyClass));
3825   InstanceKlass* lambda_ik = InstanceKlass::cast(lambda_k);
3826   assert(lambda_ik-&gt;is_hidden(), &quot;must be a hidden class&quot;);
3827   assert(!lambda_ik-&gt;is_non_strong_hidden(), &quot;expected a strong hidden class&quot;);
3828 
3829   Symbol* invoked_name = NULL;
3830   if (invokedName != NULL) {
3831     invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));
3832   }
3833   Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));
3834   Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);
3835 
3836   Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));
3837   Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);
3838 
3839   Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));
3840   assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), &quot;must be&quot;);
3841   Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());
3842 
3843   Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));
3844   Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);
3845 
3846   SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, invoked_name, invoked_type,
3847                                                  method_type, m, instantiated_method_type);
3848 #endif // INCLUDE_CDS
3849 JVM_END
3850 
3851 JVM_ENTRY(jclass, JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env,
3852                                                         jclass caller,
3853                                                         jstring invokedName,
3854                                                         jobject invokedType,
3855                                                         jobject methodType,
3856                                                         jobject implMethodMember,
3857                                                         jobject instantiatedMethodType,
3858                                                         jboolean initialize))
3859   JVMWrapper(&quot;JVM_LookupLambdaProxyClassFromArchive&quot;);
3860 #if INCLUDE_CDS
3861   if (!DynamicArchive::is_mapped()) {
3862     return NULL;
3863   }
3864 
3865   if (invokedName == NULL || invokedType == NULL || methodType == NULL ||
3866       implMethodMember == NULL || instantiatedMethodType == NULL) {
3867     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
3868   }
3869 
3870   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));
3871   InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);
3872   if (!caller_ik-&gt;is_shared()) {
3873     // there won&#39;t be a shared lambda class if the caller_ik is not in the shared archive.
3874     return NULL;
3875   }
3876 
3877   Symbol* invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));
3878   Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));
3879   Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);
3880 
3881   Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));
3882   Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);
3883 
3884   Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));
3885   assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), &quot;must be&quot;);
3886   Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());
3887 
3888   Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));
3889   Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);
3890 
3891   InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, invoked_name, invoked_type,
3892                                                                                    method_type, m, instantiated_method_type);
3893   jclass jcls = NULL;
3894   if (lambda_ik != NULL) {
3895     InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, initialize, THREAD);
3896     jcls = loaded_lambda == NULL ? NULL : (jclass) JNIHandles::make_local(env, loaded_lambda-&gt;java_mirror());
3897   }
3898   return jcls;
3899 #else
3900   return NULL;
3901 #endif // INCLUDE_CDS
3902 JVM_END
3903 
3904 JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))
3905     JVMWrapper(&quot;JVM_IsCDSDumpingEnable&quot;);
3906     return DynamicDumpSharedSpaces;
3907 JVM_END
3908 
3909 JVM_ENTRY(jboolean, JVM_IsCDSSharingEnabled(JNIEnv* env))
3910     JVMWrapper(&quot;JVM_IsCDSSharingEnable&quot;);
3911     return UseSharedSpaces;
3912 JVM_END
3913 
3914 JVM_ENTRY_NO_ENV(jlong, JVM_GetRandomSeedForCDSDump())
3915   JVMWrapper(&quot;JVM_GetRandomSeedForCDSDump&quot;);
3916   if (DumpSharedSpaces) {
3917     const char* release = Abstract_VM_Version::vm_release();
3918     const char* dbg_level = Abstract_VM_Version::jdk_debug_level();
3919     const char* version = VM_Version::internal_vm_info_string();
3920     jlong seed = (jlong)(java_lang_String::hash_code((const jbyte*)release, (int)strlen(release)) ^
3921                          java_lang_String::hash_code((const jbyte*)dbg_level, (int)strlen(dbg_level)) ^
3922                          java_lang_String::hash_code((const jbyte*)version, (int)strlen(version)));
3923     seed += (jlong)Abstract_VM_Version::vm_major_version();
3924     seed += (jlong)Abstract_VM_Version::vm_minor_version();
3925     seed += (jlong)Abstract_VM_Version::vm_security_version();
3926     seed += (jlong)Abstract_VM_Version::vm_patch_version();
3927     if (seed == 0) { // don&#39;t let this ever be zero.
3928       seed = 0x87654321;
3929     }
3930     log_debug(cds)(&quot;JVM_GetRandomSeedForCDSDump() = &quot; JLONG_FORMAT, seed);
3931     return seed;
3932   } else {
3933     return 0;
3934   }
3935 JVM_END
3936 
3937 // Returns an array of all live Thread objects (VM internal JavaThreads,
3938 // jvmti agent threads, and JNI attaching threads  are skipped)
3939 // See CR 6404306 regarding JNI attaching threads
3940 JVM_ENTRY(jobjectArray, JVM_GetAllThreads(JNIEnv *env, jclass dummy))
3941   ResourceMark rm(THREAD);
3942   ThreadsListEnumerator tle(THREAD, false, false);
3943   JvmtiVMObjectAllocEventCollector oam;
3944 
3945   int num_threads = tle.num_threads();
3946   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);
3947   objArrayHandle threads_ah(THREAD, r);
3948 
3949   for (int i = 0; i &lt; num_threads; i++) {
3950     Handle h = tle.get_threadObj(i);
3951     threads_ah-&gt;obj_at_put(i, h());
3952   }
3953 
3954   return (jobjectArray) JNIHandles::make_local(env, threads_ah());
3955 JVM_END
3956 
3957 
3958 // Support for java.lang.Thread.getStackTrace() and getAllStackTraces() methods
3959 // Return StackTraceElement[][], each element is the stack trace of a thread in
3960 // the corresponding entry in the given threads array
3961 JVM_ENTRY(jobjectArray, JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads))
3962   JVMWrapper(&quot;JVM_DumpThreads&quot;);
3963   JvmtiVMObjectAllocEventCollector oam;
3964 
3965   // Check if threads is null
3966   if (threads == NULL) {
3967     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
3968   }
3969 
3970   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(threads));
3971   objArrayHandle ah(THREAD, a);
3972   int num_threads = ah-&gt;length();
3973   // check if threads is non-empty array
3974   if (num_threads == 0) {
3975     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3976   }
3977 
3978   // check if threads is not an array of objects of Thread class
3979   Klass* k = ObjArrayKlass::cast(ah-&gt;klass())-&gt;element_klass();
3980   if (k != SystemDictionary::Thread_klass()) {
3981     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3982   }
3983 
3984   ResourceMark rm(THREAD);
3985 
3986   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
3987   for (int i = 0; i &lt; num_threads; i++) {
3988     oop thread_obj = ah-&gt;obj_at(i);
3989     instanceHandle h(THREAD, (instanceOop) thread_obj);
3990     thread_handle_array-&gt;append(h);
3991   }
3992 
3993   // The JavaThread references in thread_handle_array are validated
3994   // in VM_ThreadDump::doit().
3995   Handle stacktraces = ThreadService::dump_stack_traces(thread_handle_array, num_threads, CHECK_NULL);
3996   return (jobjectArray)JNIHandles::make_local(env, stacktraces());
3997 
3998 JVM_END
3999 
4000 // JVM monitoring and management support
4001 JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))
4002   return Management::get_jmm_interface(version);
4003 JVM_END
4004 
4005 // com.sun.tools.attach.VirtualMachine agent properties support
4006 //
4007 // Initialize the agent properties with the properties maintained in the VM
4008 JVM_ENTRY(jobject, JVM_InitAgentProperties(JNIEnv *env, jobject properties))
4009   JVMWrapper(&quot;JVM_InitAgentProperties&quot;);
4010   ResourceMark rm;
4011 
4012   Handle props(THREAD, JNIHandles::resolve_non_null(properties));
4013 
4014   PUTPROP(props, &quot;sun.java.command&quot;, Arguments::java_command());
4015   PUTPROP(props, &quot;sun.jvm.flags&quot;, Arguments::jvm_flags());
4016   PUTPROP(props, &quot;sun.jvm.args&quot;, Arguments::jvm_args());
4017   return properties;
4018 JVM_END
4019 
4020 JVM_ENTRY(jobjectArray, JVM_GetEnclosingMethodInfo(JNIEnv *env, jclass ofClass))
4021 {
4022   JVMWrapper(&quot;JVM_GetEnclosingMethodInfo&quot;);
4023   JvmtiVMObjectAllocEventCollector oam;
4024 
4025   if (ofClass == NULL) {
4026     return NULL;
4027   }
4028   Handle mirror(THREAD, JNIHandles::resolve_non_null(ofClass));
4029   // Special handling for primitive objects
4030   if (java_lang_Class::is_primitive(mirror())) {
4031     return NULL;
4032   }
4033   Klass* k = java_lang_Class::as_Klass(mirror());
4034   if (!k-&gt;is_instance_klass()) {
4035     return NULL;
4036   }
4037   InstanceKlass* ik = InstanceKlass::cast(k);
4038   int encl_method_class_idx = ik-&gt;enclosing_method_class_index();
4039   if (encl_method_class_idx == 0) {
4040     return NULL;
4041   }
4042   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);
4043   objArrayHandle dest(THREAD, dest_o);
4044   Klass* enc_k = ik-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
4045   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
4046   int encl_method_method_idx = ik-&gt;enclosing_method_method_index();
4047   if (encl_method_method_idx != 0) {
4048     Symbol* sym = ik-&gt;constants()-&gt;symbol_at(
4049                         extract_low_short_from_int(
4050                           ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
4051     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
4052     dest-&gt;obj_at_put(1, str());
4053     sym = ik-&gt;constants()-&gt;symbol_at(
4054               extract_high_short_from_int(
4055                 ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
4056     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
4057     dest-&gt;obj_at_put(2, str());
4058   }
4059   return (jobjectArray) JNIHandles::make_local(dest());
4060 }
4061 JVM_END
4062 
4063 // Returns an array of java.lang.String objects containing the input arguments to the VM.
4064 JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
4065   ResourceMark rm(THREAD);
4066 
4067   if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
4068     return NULL;
4069   }
4070 
4071   char** vm_flags = Arguments::jvm_flags_array();
4072   char** vm_args = Arguments::jvm_args_array();
4073   int num_flags = Arguments::num_jvm_flags();
4074   int num_args = Arguments::num_jvm_args();
4075 
4076   InstanceKlass* ik = SystemDictionary::String_klass();
4077   objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);
4078   objArrayHandle result_h(THREAD, r);
4079 
4080   int index = 0;
4081   for (int j = 0; j &lt; num_flags; j++, index++) {
4082     Handle h = java_lang_String::create_from_platform_dependent_str(vm_flags[j], CHECK_NULL);
4083     result_h-&gt;obj_at_put(index, h());
4084   }
4085   for (int i = 0; i &lt; num_args; i++, index++) {
4086     Handle h = java_lang_String::create_from_platform_dependent_str(vm_args[i], CHECK_NULL);
4087     result_h-&gt;obj_at_put(index, h());
4088   }
4089   return (jobjectArray) JNIHandles::make_local(env, result_h());
4090 JVM_END
4091 
4092 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
4093   return os::get_signal_number(name);
4094 JVM_END
    </pre>
  </body>
</html>