<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCompiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs_jvmci.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  86     thread-&gt;set_active_handles(compile_handles);
  87   }
  88 }
  89 
  90 void JNIHandleMark::pop_jni_handle_block(JavaThread* thread) {
  91   if (thread != NULL) {
  92     // Release our JNI handle block
  93     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  94     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  95     thread-&gt;set_active_handles(java_handles);
  96     compile_handles-&gt;set_pop_frame_link(NULL);
  97     JNIHandleBlock::release_block(compile_handles, thread); // may block
  98   }
  99 }
 100 
 101 class JVMCITraceMark : public StackObj {
 102   const char* _msg;
 103  public:
 104   JVMCITraceMark(const char* msg) {
 105     _msg = msg;
<span class="line-modified"> 106     if (JVMCITraceLevel &gt;= 1) {</span>
<span class="line-removed"> 107       tty-&gt;print_cr(PTR_FORMAT &quot; JVMCITrace-1: Enter %s&quot;, p2i(JavaThread::current()), _msg);</span>
<span class="line-removed"> 108     }</span>
 109   }
 110   ~JVMCITraceMark() {
<span class="line-modified"> 111     if (JVMCITraceLevel &gt;= 1) {</span>
<span class="line-removed"> 112       tty-&gt;print_cr(PTR_FORMAT &quot; JVMCITrace-1: Exit %s&quot;, p2i(JavaThread::current()), _msg);</span>
<span class="line-removed"> 113     }</span>
 114   }
 115 };
 116 
 117 
 118 Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 119   assert(_index &lt; _args-&gt;length(), &quot;out of bounds&quot;);
 120   oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
 121   assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), &quot;arg type mismatch&quot;);
 122   return Handle(Thread::current(), arg);
 123 }
 124 
 125 // Bring the JVMCI compiler thread into the VM state.
 126 #define JVMCI_VM_ENTRY_MARK                   \
 127   ThreadInVMfromNative __tiv(thread);         \
 128   ResetNoHandleMark rnhm;                     \
 129   HandleMarkCleaner __hm(thread);             \
 130   Thread* THREAD = thread;                    \
 131   debug_only(VMNativeEntryWrapper __vew;)
 132 
 133 // Native method block that transitions current thread to &#39;_thread_in_vm&#39;.
 134 #define C2V_BLOCK(result_type, name, signature)      \
 135   TRACE_CALL(result_type, jvmci_ ## name signature)  \
 136   JVMCI_VM_ENTRY_MARK;                               \
 137   ResourceMark rm;                                   \
 138   JNI_JVMCIENV(thread, env);
 139 
<span class="line-modified"> 140 static Thread* get_current_thread() {</span>
<span class="line-modified"> 141   return Thread::current_or_null_safe();</span>






 142 }
 143 
 144 // Entry to native method implementation that transitions
 145 // current thread to &#39;_thread_in_vm&#39;.
 146 #define C2V_VMENTRY(result_type, name, signature)        \
 147   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
<span class="line-modified"> 148   Thread* base_thread = get_current_thread();            \</span>
<span class="line-modified"> 149   if (base_thread == NULL) {                             \</span>
 150     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 151         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \
 152     return;                                              \
 153   }                                                      \
<span class="line-removed"> 154   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\</span>
<span class="line-removed"> 155   JavaThread* thread = (JavaThread*) base_thread;        \</span>
 156   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \
 157   C2V_BLOCK(result_type, name, signature)
 158 
 159 #define C2V_VMENTRY_(result_type, name, signature, result) \
 160   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
<span class="line-modified"> 161   Thread* base_thread = get_current_thread();            \</span>
<span class="line-modified"> 162   if (base_thread == NULL) {                             \</span>
 163     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 164         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \
 165     return result;                                       \
 166   }                                                      \
<span class="line-removed"> 167   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\</span>
<span class="line-removed"> 168   JavaThread* thread = (JavaThread*) base_thread;        \</span>
 169   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \
 170   C2V_BLOCK(result_type, name, signature)
 171 
 172 #define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)
 173 #define C2V_VMENTRY_0(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, 0)
 174 
 175 // Entry to native method implementation that does not transition
 176 // current thread to &#39;_thread_in_vm&#39;.
 177 #define C2V_VMENTRY_PREFIX(result_type, name, signature) \
 178   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
<span class="line-modified"> 179   Thread* base_thread = get_current_thread();</span>
 180 
 181 #define C2V_END }
 182 
 183 #define JNI_THROW(caller, name, msg) do {                                         \
 184     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 185     if (__throw_res != JNI_OK) {                                                  \
 186       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \
 187     }                                                                             \
 188     return;                                                                       \
 189   } while (0);
 190 
 191 #define JNI_THROW_(caller, name, msg, result) do {                                \
 192     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 193     if (__throw_res != JNI_OK) {                                                  \
 194       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \
 195     }                                                                             \
 196     return result;                                                                \
 197   } while (0)
 198 
 199 jobjectArray readConfiguration0(JNIEnv *env, JVMCI_TRAPS);
</pre>
<hr />
<pre>
1562   // all locals are materialized by now
1563   JVMCIENV-&gt;set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);
1564   // update the locals array
1565   JVMCIObjectArray array = JVMCIENV-&gt;get_HotSpotStackFrameReference_locals(hs_frame);
1566   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1567   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1568     StackValue* var = locals-&gt;at(i);
1569     if (var-&gt;type() == T_OBJECT) {
1570       JVMCIENV-&gt;put_object_at(array, i, HotSpotJVMCI::wrap(locals-&gt;at(i)-&gt;get_obj()()));
1571     }
1572   }
1573   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);
1574 C2V_END
1575 
1576 // Creates a scope where the current thread is attached and detached
1577 // from HotSpot if it wasn&#39;t already attached when entering the scope.
1578 extern &quot;C&quot; void jio_printf(const char *fmt, ...);
1579 class AttachDetach : public StackObj {
1580  public:
1581   bool _attached;
<span class="line-modified">1582   AttachDetach(JNIEnv* env, Thread* current_thread) {</span>
1583     if (current_thread == NULL) {
1584       extern struct JavaVM_ main_vm;
1585       JNIEnv* hotspotEnv;
1586       jint res = main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
1587       _attached = res == JNI_OK;
1588       static volatile int report_attach_error = 0;
1589       if (res != JNI_OK &amp;&amp; report_attach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_attach_error, 0, 1) == 0) {
1590         // Only report an attach error once
1591         jio_printf(&quot;Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\n&quot;, res);
1592       }
1593     } else {
1594       _attached = false;
1595     }
1596   }
1597   ~AttachDetach() {
1598     if (_attached &amp;&amp; get_current_thread() != NULL) {
1599       extern struct JavaVM_ main_vm;
1600       jint res = main_vm.DetachCurrentThread();
1601       static volatile int report_detach_error = 0;
1602       if (res != JNI_OK &amp;&amp; report_detach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_detach_error, 0, 1) == 0) {
1603         // Only report an attach error once
1604         jio_printf(&quot;Warning: detaching current thread from VM failed with %d (future attach errors are suppressed)\n&quot;, res);
1605       }
1606     }
1607   }
1608 };
1609 
1610 C2V_VMENTRY_PREFIX(jint, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length, bool flush, bool can_throw))
<span class="line-modified">1611   AttachDetach ad(env, base_thread);</span>
1612   bool use_tty = true;
<span class="line-modified">1613   if (base_thread == NULL) {</span>
1614     if (!ad._attached) {
1615       // Can only use tty if the current thread is attached

1616       return 0;
1617     }
<span class="line-modified">1618     base_thread = get_current_thread();</span>
1619   }
1620   JVMCITraceMark jtm(&quot;writeDebugOutput&quot;);
<span class="line-removed">1621   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);</span>
<span class="line-removed">1622   JavaThread* thread = (JavaThread*) base_thread;</span>
1623   C2V_BLOCK(void, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length))
1624   if (bytes == NULL) {
1625     if (can_throw) {
1626       JVMCI_THROW_0(NullPointerException);
1627     }
1628     return -1;
1629   }
1630   JVMCIPrimitiveArray array = JVMCIENV-&gt;wrap(bytes);
1631 
1632   // Check if offset and length are non negative.
1633   if (offset &lt; 0 || length &lt; 0) {
1634     if (can_throw) {
1635       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);
1636     }
1637     return -2;
1638   }
1639   // Check if the range is valid.
1640   int array_length = JVMCIENV-&gt;get_length(array);
1641   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array_length)) {
1642     if (can_throw) {
</pre>
<hr />
<pre>
2212   if (x == NULL) {
2213     JVMCI_THROW_0(NullPointerException);
2214   }
2215   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2216   return xobj-&gt;long_field(displacement);
2217 }
2218 
2219 C2V_VMENTRY_NULL(jobject, getObject, (JNIEnv* env, jobject, jobject x, long displacement))
2220   if (x == NULL) {
2221     JVMCI_THROW_0(NullPointerException);
2222   }
2223   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2224   oop res = xobj-&gt;obj_field(displacement);
2225   JVMCIObject result = JVMCIENV-&gt;get_object_constant(res);
2226   return JVMCIENV-&gt;get_jobject(result);
2227 }
2228 
2229 C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong h))
2230   jobject handle = (jobject)(address)h;
2231   if (handle != NULL) {
<span class="line-modified">2232     JVMCI::destroy_global(handle);</span>
2233   }
2234 }
2235 
2236 static void requireJVMCINativeLibrary(JVMCI_TRAPS) {
2237   if (!UseJVMCINativeLibrary) {
2238     JVMCI_THROW_MSG(UnsupportedOperationException, &quot;JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)&quot;);
2239   }
2240 }
2241 
<span class="line-removed">2242 static JavaVM* requireNativeLibraryJavaVM(const char* caller, JVMCI_TRAPS) {</span>
<span class="line-removed">2243   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();</span>
<span class="line-removed">2244   if (javaVM == NULL) {</span>
<span class="line-removed">2245     JVMCI_THROW_MSG_NULL(IllegalStateException, err_msg(&quot;Require JVMCI shared library to be initialized in %s&quot;, caller));</span>
<span class="line-removed">2246   }</span>
<span class="line-removed">2247   return javaVM;</span>
<span class="line-removed">2248 }</span>
<span class="line-removed">2249 </span>
2250 C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))
2251   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2252   requireInHotSpot(&quot;registerNativeMethods&quot;, JVMCI_CHECK_NULL);
<span class="line-modified">2253   void* shared_library = JVMCIEnv::get_shared_library_handle();</span>
<span class="line-modified">2254   if (shared_library == NULL) {</span>


2255     // Ensure the JVMCI shared library runtime is initialized.
2256     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);
2257     JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2258     HandleMark hm;
<span class="line-removed">2259     JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
2260     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(peerEnv);
2261     if (peerEnv-&gt;has_pending_exception()) {
2262       peerEnv-&gt;describe_pending_exception(true);
2263     }
<span class="line-modified">2264     shared_library = JVMCIEnv::get_shared_library_handle();</span>
<span class="line-modified">2265     if (shared_library == NULL) {</span>
<span class="line-modified">2266       JVMCI_THROW_MSG_0(InternalError, &quot;Error initializing JVMCI runtime&quot;);</span>
2267     }
2268   }
2269 
2270   if (mirror == NULL) {
2271     JVMCI_THROW_0(NullPointerException);
2272   }
2273   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2274   if (klass == NULL || !klass-&gt;is_instance_klass()) {
2275     JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;clazz is for primitive type&quot;);
2276   }
2277 
2278   InstanceKlass* iklass = InstanceKlass::cast(klass);
2279   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
2280     methodHandle method(THREAD, iklass-&gt;methods()-&gt;at(i));
2281     if (method-&gt;is_native()) {
2282 
2283       // Compute argument size
2284       int args_size = 1                             // JNIEnv
2285                     + (method-&gt;is_static() ? 1 : 0) // class for static methods
2286                     + method-&gt;size_of_parameters(); // actual parameters
2287 
2288       // 1) Try JNI short style
2289       stringStream st;
2290       char* pure_name = NativeLookup::pure_jni_name(method);
2291       os::print_jni_name_prefix_on(&amp;st, args_size);
2292       st.print_raw(pure_name);
2293       os::print_jni_name_suffix_on(&amp;st, args_size);
2294       char* jni_name = st.as_string();
2295 
<span class="line-modified">2296       address entry = (address) os::dll_lookup(shared_library, jni_name);</span>
2297       if (entry == NULL) {
2298         // 2) Try JNI long style
2299         st.reset();
2300         char* long_name = NativeLookup::long_jni_name(method);
2301         os::print_jni_name_prefix_on(&amp;st, args_size);
2302         st.print_raw(pure_name);
2303         st.print_raw(long_name);
2304         os::print_jni_name_suffix_on(&amp;st, args_size);
2305         char* jni_long_name = st.as_string();
<span class="line-modified">2306         entry = (address) os::dll_lookup(shared_library, jni_long_name);</span>
2307         if (entry == NULL) {
2308           JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [neither %s nor %s exist in %s]&quot;,
2309               method-&gt;name_and_sig_as_C_string(),
<span class="line-modified">2310               jni_name, jni_long_name, JVMCIEnv::get_shared_library_path()));</span>
2311         }
2312       }
2313 
2314       if (method-&gt;has_native_function() &amp;&amp; entry != method-&gt;native_function()) {
2315         JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [cannot re-link from &quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT &quot;]&quot;,
2316             method-&gt;name_and_sig_as_C_string(), p2i(method-&gt;native_function()), p2i(entry)));
2317       }
2318       method-&gt;set_native_function(entry, Method::native_bind_event_is_interesting);
<span class="line-modified">2319       log_debug(jni, resolve)(&quot;[Dynamic-linking native method %s.%s ... JNI]&quot;,</span>
2320                               method-&gt;method_holder()-&gt;external_name(),
<span class="line-modified">2321                               method-&gt;name()-&gt;as_C_string());</span>

2322     }
2323   }
2324 
<span class="line-modified">2325   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();</span>
<span class="line-modified">2326   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(4, JVMCI_CHECK_NULL);</span>
<span class="line-modified">2327   JVMCIENV-&gt;put_long_at(result, 0, (jlong) (address) javaVM);</span>
<span class="line-modified">2328   JVMCIENV-&gt;put_long_at(result, 1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);</span>
<span class="line-removed">2329   JVMCIENV-&gt;put_long_at(result, 2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);</span>
<span class="line-removed">2330   JVMCIENV-&gt;put_long_at(result, 3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);</span>
<span class="line-removed">2331   return (jlongArray) JVMCIENV-&gt;get_jobject(result);</span>
2332 }
2333 
2334 C2V_VMENTRY_PREFIX(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject c2vm))
<span class="line-modified">2335   if (base_thread == NULL) {</span>
2336     // Called from unattached JVMCI shared library thread
2337     return false;
2338   }
2339   JVMCITraceMark jtm(&quot;isCurrentThreadAttached&quot;);
<span class="line-removed">2340   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);</span>
<span class="line-removed">2341   JavaThread* thread = (JavaThread*) base_thread;</span>
2342   if (thread-&gt;jni_environment() == env) {
2343     C2V_BLOCK(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject))
2344     requireJVMCINativeLibrary(JVMCI_CHECK_0);
<span class="line-modified">2345     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;isCurrentThreadAttached&quot;, JVMCI_CHECK_0);</span>



2346     JNIEnv* peerEnv;
<span class="line-modified">2347     return javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK;</span>
2348   }
2349   return true;
2350 C2V_END
2351 
2352 C2V_VMENTRY_PREFIX(jlong, getCurrentJavaThread, (JNIEnv* env, jobject c2vm))
<span class="line-modified">2353   if (base_thread == NULL) {</span>
2354     // Called from unattached JVMCI shared library thread
2355     return 0L;
2356   }
2357   JVMCITraceMark jtm(&quot;getCurrentJavaThread&quot;);
<span class="line-modified">2358   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);</span>
<span class="line-removed">2359   return (jlong) p2i(base_thread);</span>
2360 C2V_END
2361 
2362 C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jboolean as_daemon))
<span class="line-modified">2363   if (base_thread == NULL) {</span>
2364     // Called from unattached JVMCI shared library thread
2365     extern struct JavaVM_ main_vm;
2366     JNIEnv* hotspotEnv;
<span class="line-modified">2367     jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**)&amp;hotspotEnv, NULL) :</span>
<span class="line-modified">2368                            main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);</span>
2369     if (res != JNI_OK) {
2370       JNI_THROW_(&quot;attachCurrentThread&quot;, InternalError, err_msg(&quot;Trying to attach thread returned %d&quot;, res), false);
2371     }
2372     return true;
2373   }
2374   JVMCITraceMark jtm(&quot;attachCurrentThread&quot;);
<span class="line-removed">2375   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\</span>
<span class="line-removed">2376   JavaThread* thread = (JavaThread*) base_thread;</span>
2377   if (thread-&gt;jni_environment() == env) {
2378     // Called from HotSpot
2379     C2V_BLOCK(jboolean, attachCurrentThread, (JNIEnv* env, jobject, jboolean))
2380     requireJVMCINativeLibrary(JVMCI_CHECK_0);
<span class="line-modified">2381     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;attachCurrentThread&quot;, JVMCI_CHECK_0);</span>




2382     JavaVMAttachArgs attach_args;
2383     attach_args.version = JNI_VERSION_1_2;
2384     attach_args.name = thread-&gt;name();
2385     attach_args.group = NULL;
<span class="line-modified">2386     JNIEnv* peerEnv;</span>
<span class="line-modified">2387     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK) {</span>
2388       return false;
2389     }
<span class="line-modified">2390     jint res = as_daemon ? javaVM-&gt;AttachCurrentThreadAsDaemon((void**)&amp;peerEnv, &amp;attach_args) :</span>
<span class="line-modified">2391                            javaVM-&gt;AttachCurrentThread((void**)&amp;peerEnv, &amp;attach_args);</span>

2392     if (res == JNI_OK) {
<span class="line-modified">2393       guarantee(peerEnv != NULL, &quot;must be&quot;);</span>

2394       return true;
2395     }
2396     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, attach_args.name));
2397   }
2398   // Called from JVMCI shared library
2399   return false;
2400 C2V_END
2401 
2402 C2V_VMENTRY_PREFIX(void, detachCurrentThread, (JNIEnv* env, jobject c2vm))
<span class="line-modified">2403   if (base_thread == NULL) {</span>
2404     // Called from unattached JVMCI shared library thread
<span class="line-modified">2405     JNI_THROW(&quot;detachCurrentThread&quot;, IllegalStateException, err_msg(&quot;Cannot detach non-attached thread&quot;));</span>
2406   }
2407   JVMCITraceMark jtm(&quot;detachCurrentThread&quot;);
<span class="line-removed">2408   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\</span>
<span class="line-removed">2409   JavaThread* thread = (JavaThread*) base_thread;</span>
2410   if (thread-&gt;jni_environment() == env) {
2411     // Called from HotSpot
2412     C2V_BLOCK(void, detachCurrentThread, (JNIEnv* env, jobject))
2413     requireJVMCINativeLibrary(JVMCI_CHECK);
2414     requireInHotSpot(&quot;detachCurrentThread&quot;, JVMCI_CHECK);
<span class="line-modified">2415     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;detachCurrentThread&quot;, JVMCI_CHECK);</span>
<span class="line-modified">2416     JNIEnv* peerEnv;</span>
<span class="line-modified">2417     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) != JNI_OK) {</span>



2418       JVMCI_THROW_MSG(IllegalStateException, err_msg(&quot;Cannot detach non-attached thread: %s&quot;, thread-&gt;name()));
2419     }
<span class="line-modified">2420     jint res = javaVM-&gt;DetachCurrentThread();</span>
2421     if (res != JNI_OK) {
2422       JVMCI_THROW_MSG(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, thread-&gt;name()));
2423     }
2424   } else {
2425     // Called from attached JVMCI shared library thread
2426     extern struct JavaVM_ main_vm;
2427     jint res = main_vm.DetachCurrentThread();
2428     if (res != JNI_OK) {
<span class="line-modified">2429       JNI_THROW(&quot;detachCurrentThread&quot;, InternalError, err_msg(&quot;Cannot detach non-attached thread&quot;));</span>
2430     }
2431   }
2432 C2V_END
2433 
2434 C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))
2435   requireJVMCINativeLibrary(JVMCI_CHECK_0);
2436   if (obj_handle == NULL) {
2437     return 0L;
2438   }
2439   JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV-&gt;is_hotspot(), __FILE__, __LINE__);
2440   JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2441   JVMCIEnv* thisEnv = JVMCIENV;
2442 
2443   JVMCIObject obj = thisEnv-&gt;wrap(obj_handle);
2444   JVMCIObject result;
2445   if (thisEnv-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {
2446     methodHandle method(THREAD, thisEnv-&gt;asMethod(obj));
2447     result = peerEnv-&gt;get_jvmci_method(method, JVMCI_CHECK_0);
2448   } else if (thisEnv-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {
2449     Klass* klass = thisEnv-&gt;asKlass(obj);
</pre>
</td>
<td>
<hr />
<pre>
  86     thread-&gt;set_active_handles(compile_handles);
  87   }
  88 }
  89 
  90 void JNIHandleMark::pop_jni_handle_block(JavaThread* thread) {
  91   if (thread != NULL) {
  92     // Release our JNI handle block
  93     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  94     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  95     thread-&gt;set_active_handles(java_handles);
  96     compile_handles-&gt;set_pop_frame_link(NULL);
  97     JNIHandleBlock::release_block(compile_handles, thread); // may block
  98   }
  99 }
 100 
 101 class JVMCITraceMark : public StackObj {
 102   const char* _msg;
 103  public:
 104   JVMCITraceMark(const char* msg) {
 105     _msg = msg;
<span class="line-modified"> 106     JVMCI_event_2(&quot;Enter %s&quot;, _msg);</span>


 107   }
 108   ~JVMCITraceMark() {
<span class="line-modified"> 109     JVMCI_event_2(&quot; Exit %s&quot;, _msg);</span>


 110   }
 111 };
 112 
 113 
 114 Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 115   assert(_index &lt; _args-&gt;length(), &quot;out of bounds&quot;);
 116   oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
 117   assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), &quot;arg type mismatch&quot;);
 118   return Handle(Thread::current(), arg);
 119 }
 120 
 121 // Bring the JVMCI compiler thread into the VM state.
 122 #define JVMCI_VM_ENTRY_MARK                   \
 123   ThreadInVMfromNative __tiv(thread);         \
 124   ResetNoHandleMark rnhm;                     \
 125   HandleMarkCleaner __hm(thread);             \
 126   Thread* THREAD = thread;                    \
 127   debug_only(VMNativeEntryWrapper __vew;)
 128 
 129 // Native method block that transitions current thread to &#39;_thread_in_vm&#39;.
 130 #define C2V_BLOCK(result_type, name, signature)      \
 131   TRACE_CALL(result_type, jvmci_ ## name signature)  \
 132   JVMCI_VM_ENTRY_MARK;                               \
 133   ResourceMark rm;                                   \
 134   JNI_JVMCIENV(thread, env);
 135 
<span class="line-modified"> 136 static JavaThread* get_current_thread(bool allow_null=true) {</span>
<span class="line-modified"> 137   Thread* thread = Thread::current_or_null_safe();</span>
<span class="line-added"> 138   if (thread == NULL) {</span>
<span class="line-added"> 139     assert(allow_null, &quot;npe&quot;);</span>
<span class="line-added"> 140     return NULL;</span>
<span class="line-added"> 141   }</span>
<span class="line-added"> 142   assert(thread-&gt;is_Java_thread(), &quot;must be&quot;);</span>
<span class="line-added"> 143   return (JavaThread*) thread;</span>
 144 }
 145 
 146 // Entry to native method implementation that transitions
 147 // current thread to &#39;_thread_in_vm&#39;.
 148 #define C2V_VMENTRY(result_type, name, signature)        \
 149   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
<span class="line-modified"> 150   JavaThread* thread = get_current_thread();             \</span>
<span class="line-modified"> 151   if (thread == NULL) {                                  \</span>
 152     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 153         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \
 154     return;                                              \
 155   }                                                      \


 156   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \
 157   C2V_BLOCK(result_type, name, signature)
 158 
 159 #define C2V_VMENTRY_(result_type, name, signature, result) \
 160   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
<span class="line-modified"> 161   JavaThread* thread = get_current_thread();             \</span>
<span class="line-modified"> 162   if (thread == NULL) {                                  \</span>
 163     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 164         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \
 165     return result;                                       \
 166   }                                                      \


 167   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \
 168   C2V_BLOCK(result_type, name, signature)
 169 
 170 #define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)
 171 #define C2V_VMENTRY_0(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, 0)
 172 
 173 // Entry to native method implementation that does not transition
 174 // current thread to &#39;_thread_in_vm&#39;.
 175 #define C2V_VMENTRY_PREFIX(result_type, name, signature) \
 176   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
<span class="line-modified"> 177   JavaThread* thread = get_current_thread();</span>
 178 
 179 #define C2V_END }
 180 
 181 #define JNI_THROW(caller, name, msg) do {                                         \
 182     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 183     if (__throw_res != JNI_OK) {                                                  \
 184       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \
 185     }                                                                             \
 186     return;                                                                       \
 187   } while (0);
 188 
 189 #define JNI_THROW_(caller, name, msg, result) do {                                \
 190     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 191     if (__throw_res != JNI_OK) {                                                  \
 192       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \
 193     }                                                                             \
 194     return result;                                                                \
 195   } while (0)
 196 
 197 jobjectArray readConfiguration0(JNIEnv *env, JVMCI_TRAPS);
</pre>
<hr />
<pre>
1560   // all locals are materialized by now
1561   JVMCIENV-&gt;set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);
1562   // update the locals array
1563   JVMCIObjectArray array = JVMCIENV-&gt;get_HotSpotStackFrameReference_locals(hs_frame);
1564   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1565   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1566     StackValue* var = locals-&gt;at(i);
1567     if (var-&gt;type() == T_OBJECT) {
1568       JVMCIENV-&gt;put_object_at(array, i, HotSpotJVMCI::wrap(locals-&gt;at(i)-&gt;get_obj()()));
1569     }
1570   }
1571   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);
1572 C2V_END
1573 
1574 // Creates a scope where the current thread is attached and detached
1575 // from HotSpot if it wasn&#39;t already attached when entering the scope.
1576 extern &quot;C&quot; void jio_printf(const char *fmt, ...);
1577 class AttachDetach : public StackObj {
1578  public:
1579   bool _attached;
<span class="line-modified">1580   AttachDetach(JNIEnv* env, JavaThread* current_thread) {</span>
1581     if (current_thread == NULL) {
1582       extern struct JavaVM_ main_vm;
1583       JNIEnv* hotspotEnv;
1584       jint res = main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
1585       _attached = res == JNI_OK;
1586       static volatile int report_attach_error = 0;
1587       if (res != JNI_OK &amp;&amp; report_attach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_attach_error, 0, 1) == 0) {
1588         // Only report an attach error once
1589         jio_printf(&quot;Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\n&quot;, res);
1590       }
1591     } else {
1592       _attached = false;
1593     }
1594   }
1595   ~AttachDetach() {
1596     if (_attached &amp;&amp; get_current_thread() != NULL) {
1597       extern struct JavaVM_ main_vm;
1598       jint res = main_vm.DetachCurrentThread();
1599       static volatile int report_detach_error = 0;
1600       if (res != JNI_OK &amp;&amp; report_detach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_detach_error, 0, 1) == 0) {
1601         // Only report an attach error once
1602         jio_printf(&quot;Warning: detaching current thread from VM failed with %d (future attach errors are suppressed)\n&quot;, res);
1603       }
1604     }
1605   }
1606 };
1607 
1608 C2V_VMENTRY_PREFIX(jint, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length, bool flush, bool can_throw))
<span class="line-modified">1609   AttachDetach ad(env, thread);</span>
1610   bool use_tty = true;
<span class="line-modified">1611   if (thread == NULL) {</span>
1612     if (!ad._attached) {
1613       // Can only use tty if the current thread is attached
<span class="line-added">1614       JVMCI_event_1(&quot;Cannot write to tty on unattached thread&quot;);</span>
1615       return 0;
1616     }
<span class="line-modified">1617     thread = get_current_thread();</span>
1618   }
1619   JVMCITraceMark jtm(&quot;writeDebugOutput&quot;);


1620   C2V_BLOCK(void, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length))
1621   if (bytes == NULL) {
1622     if (can_throw) {
1623       JVMCI_THROW_0(NullPointerException);
1624     }
1625     return -1;
1626   }
1627   JVMCIPrimitiveArray array = JVMCIENV-&gt;wrap(bytes);
1628 
1629   // Check if offset and length are non negative.
1630   if (offset &lt; 0 || length &lt; 0) {
1631     if (can_throw) {
1632       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);
1633     }
1634     return -2;
1635   }
1636   // Check if the range is valid.
1637   int array_length = JVMCIENV-&gt;get_length(array);
1638   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array_length)) {
1639     if (can_throw) {
</pre>
<hr />
<pre>
2209   if (x == NULL) {
2210     JVMCI_THROW_0(NullPointerException);
2211   }
2212   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2213   return xobj-&gt;long_field(displacement);
2214 }
2215 
2216 C2V_VMENTRY_NULL(jobject, getObject, (JNIEnv* env, jobject, jobject x, long displacement))
2217   if (x == NULL) {
2218     JVMCI_THROW_0(NullPointerException);
2219   }
2220   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2221   oop res = xobj-&gt;obj_field(displacement);
2222   JVMCIObject result = JVMCIENV-&gt;get_object_constant(res);
2223   return JVMCIENV-&gt;get_jobject(result);
2224 }
2225 
2226 C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong h))
2227   jobject handle = (jobject)(address)h;
2228   if (handle != NULL) {
<span class="line-modified">2229     JVMCIENV-&gt;runtime()-&gt;destroy_global(handle);</span>
2230   }
2231 }
2232 
2233 static void requireJVMCINativeLibrary(JVMCI_TRAPS) {
2234   if (!UseJVMCINativeLibrary) {
2235     JVMCI_THROW_MSG(UnsupportedOperationException, &quot;JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)&quot;);
2236   }
2237 }
2238 








2239 C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))
2240   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2241   requireInHotSpot(&quot;registerNativeMethods&quot;, JVMCI_CHECK_NULL);
<span class="line-modified">2242   char* sl_path;</span>
<span class="line-modified">2243   void* sl_handle;</span>
<span class="line-added">2244   JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
<span class="line-added">2245   {</span>
2246     // Ensure the JVMCI shared library runtime is initialized.
2247     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);
2248     JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2249     HandleMark hm;

2250     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(peerEnv);
2251     if (peerEnv-&gt;has_pending_exception()) {
2252       peerEnv-&gt;describe_pending_exception(true);
2253     }
<span class="line-modified">2254     sl_handle = JVMCI::get_shared_library(sl_path, false);</span>
<span class="line-modified">2255     if (sl_handle == NULL) {</span>
<span class="line-modified">2256       JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Error initializing JVMCI runtime %d&quot;, runtime-&gt;id()));</span>
2257     }
2258   }
2259 
2260   if (mirror == NULL) {
2261     JVMCI_THROW_0(NullPointerException);
2262   }
2263   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2264   if (klass == NULL || !klass-&gt;is_instance_klass()) {
2265     JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;clazz is for primitive type&quot;);
2266   }
2267 
2268   InstanceKlass* iklass = InstanceKlass::cast(klass);
2269   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
2270     methodHandle method(THREAD, iklass-&gt;methods()-&gt;at(i));
2271     if (method-&gt;is_native()) {
2272 
2273       // Compute argument size
2274       int args_size = 1                             // JNIEnv
2275                     + (method-&gt;is_static() ? 1 : 0) // class for static methods
2276                     + method-&gt;size_of_parameters(); // actual parameters
2277 
2278       // 1) Try JNI short style
2279       stringStream st;
2280       char* pure_name = NativeLookup::pure_jni_name(method);
2281       os::print_jni_name_prefix_on(&amp;st, args_size);
2282       st.print_raw(pure_name);
2283       os::print_jni_name_suffix_on(&amp;st, args_size);
2284       char* jni_name = st.as_string();
2285 
<span class="line-modified">2286       address entry = (address) os::dll_lookup(sl_handle, jni_name);</span>
2287       if (entry == NULL) {
2288         // 2) Try JNI long style
2289         st.reset();
2290         char* long_name = NativeLookup::long_jni_name(method);
2291         os::print_jni_name_prefix_on(&amp;st, args_size);
2292         st.print_raw(pure_name);
2293         st.print_raw(long_name);
2294         os::print_jni_name_suffix_on(&amp;st, args_size);
2295         char* jni_long_name = st.as_string();
<span class="line-modified">2296         entry = (address) os::dll_lookup(sl_handle, jni_long_name);</span>
2297         if (entry == NULL) {
2298           JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [neither %s nor %s exist in %s]&quot;,
2299               method-&gt;name_and_sig_as_C_string(),
<span class="line-modified">2300               jni_name, jni_long_name, sl_path));</span>
2301         }
2302       }
2303 
2304       if (method-&gt;has_native_function() &amp;&amp; entry != method-&gt;native_function()) {
2305         JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [cannot re-link from &quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT &quot;]&quot;,
2306             method-&gt;name_and_sig_as_C_string(), p2i(method-&gt;native_function()), p2i(entry)));
2307       }
2308       method-&gt;set_native_function(entry, Method::native_bind_event_is_interesting);
<span class="line-modified">2309       log_debug(jni, resolve)(&quot;[Dynamic-linking native method %s.%s ... JNI] @ &quot; PTR_FORMAT,</span>
2310                               method-&gt;method_holder()-&gt;external_name(),
<span class="line-modified">2311                               method-&gt;name()-&gt;as_C_string(),</span>
<span class="line-added">2312                               p2i((void*) entry));</span>
2313     }
2314   }
2315 
<span class="line-modified">2316   typeArrayOop info_oop = oopFactory::new_longArray(4, CHECK_0);</span>
<span class="line-modified">2317   jlongArray info = (jlongArray) JNIHandles::make_local(info_oop);</span>
<span class="line-modified">2318   runtime-&gt;init_JavaVM_info(info, JVMCI_CHECK_0);</span>
<span class="line-modified">2319   return info;</span>



2320 }
2321 
2322 C2V_VMENTRY_PREFIX(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject c2vm))
<span class="line-modified">2323   if (thread == NULL) {</span>
2324     // Called from unattached JVMCI shared library thread
2325     return false;
2326   }
2327   JVMCITraceMark jtm(&quot;isCurrentThreadAttached&quot;);


2328   if (thread-&gt;jni_environment() == env) {
2329     C2V_BLOCK(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject))
2330     requireJVMCINativeLibrary(JVMCI_CHECK_0);
<span class="line-modified">2331     JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
<span class="line-added">2332     if (runtime == NULL || !runtime-&gt;has_shared_library_javavm()) {</span>
<span class="line-added">2333       JVMCI_THROW_MSG_0(IllegalStateException, &quot;Require JVMCI shared library JavaVM to be initialized in isCurrentThreadAttached&quot;);</span>
<span class="line-added">2334     }</span>
2335     JNIEnv* peerEnv;
<span class="line-modified">2336     return runtime-&gt;GetEnv(thread, (void**) &amp;peerEnv, JNI_VERSION_1_2) == JNI_OK;</span>
2337   }
2338   return true;
2339 C2V_END
2340 
2341 C2V_VMENTRY_PREFIX(jlong, getCurrentJavaThread, (JNIEnv* env, jobject c2vm))
<span class="line-modified">2342   if (thread == NULL) {</span>
2343     // Called from unattached JVMCI shared library thread
2344     return 0L;
2345   }
2346   JVMCITraceMark jtm(&quot;getCurrentJavaThread&quot;);
<span class="line-modified">2347   return (jlong) p2i(thread);</span>

2348 C2V_END
2349 
2350 C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jboolean as_daemon))
<span class="line-modified">2351   if (thread == NULL) {</span>
2352     // Called from unattached JVMCI shared library thread
2353     extern struct JavaVM_ main_vm;
2354     JNIEnv* hotspotEnv;
<span class="line-modified">2355     jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**) &amp;hotspotEnv, NULL) :</span>
<span class="line-modified">2356                            main_vm.AttachCurrentThread((void**) &amp;hotspotEnv, NULL);</span>
2357     if (res != JNI_OK) {
2358       JNI_THROW_(&quot;attachCurrentThread&quot;, InternalError, err_msg(&quot;Trying to attach thread returned %d&quot;, res), false);
2359     }
2360     return true;
2361   }
2362   JVMCITraceMark jtm(&quot;attachCurrentThread&quot;);


2363   if (thread-&gt;jni_environment() == env) {
2364     // Called from HotSpot
2365     C2V_BLOCK(jboolean, attachCurrentThread, (JNIEnv* env, jobject, jboolean))
2366     requireJVMCINativeLibrary(JVMCI_CHECK_0);
<span class="line-modified">2367     JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
<span class="line-added">2368     if (runtime == NULL || !runtime-&gt;has_shared_library_javavm()) {</span>
<span class="line-added">2369         JVMCI_THROW_MSG_0(IllegalStateException, &quot;Require JVMCI shared library JavaVM to be initialized in attachCurrentThread&quot;);</span>
<span class="line-added">2370     }</span>
<span class="line-added">2371 </span>
2372     JavaVMAttachArgs attach_args;
2373     attach_args.version = JNI_VERSION_1_2;
2374     attach_args.name = thread-&gt;name();
2375     attach_args.group = NULL;
<span class="line-modified">2376     JNIEnv* peerJNIEnv;</span>
<span class="line-modified">2377     if (runtime-&gt;GetEnv(thread, (void**) &amp;peerJNIEnv, JNI_VERSION_1_2) == JNI_OK) {</span>
2378       return false;
2379     }
<span class="line-modified">2380     jint res = as_daemon ? runtime-&gt;AttachCurrentThreadAsDaemon(thread, (void**) &amp;peerJNIEnv, &amp;attach_args) :</span>
<span class="line-modified">2381                            runtime-&gt;AttachCurrentThread(thread, (void**) &amp;peerJNIEnv, &amp;attach_args);</span>
<span class="line-added">2382 </span>
2383     if (res == JNI_OK) {
<span class="line-modified">2384       guarantee(peerJNIEnv != NULL, &quot;must be&quot;);</span>
<span class="line-added">2385       JVMCI_event_1(&quot;attached to JavaVM for JVMCI runtime %d&quot;, runtime-&gt;id());</span>
2386       return true;
2387     }
2388     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, attach_args.name));
2389   }
2390   // Called from JVMCI shared library
2391   return false;
2392 C2V_END
2393 
2394 C2V_VMENTRY_PREFIX(void, detachCurrentThread, (JNIEnv* env, jobject c2vm))
<span class="line-modified">2395   if (thread == NULL) {</span>
2396     // Called from unattached JVMCI shared library thread
<span class="line-modified">2397     JNI_THROW(&quot;detachCurrentThread&quot;, IllegalStateException, &quot;Cannot detach non-attached thread&quot;);</span>
2398   }
2399   JVMCITraceMark jtm(&quot;detachCurrentThread&quot;);


2400   if (thread-&gt;jni_environment() == env) {
2401     // Called from HotSpot
2402     C2V_BLOCK(void, detachCurrentThread, (JNIEnv* env, jobject))
2403     requireJVMCINativeLibrary(JVMCI_CHECK);
2404     requireInHotSpot(&quot;detachCurrentThread&quot;, JVMCI_CHECK);
<span class="line-modified">2405     JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
<span class="line-modified">2406     if (runtime == NULL || !runtime-&gt;has_shared_library_javavm()) {</span>
<span class="line-modified">2407       JVMCI_THROW_MSG(IllegalStateException, &quot;Require JVMCI shared library JavaVM to be initialized in detachCurrentThread&quot;);</span>
<span class="line-added">2408     }</span>
<span class="line-added">2409     JNIEnv* peerJNIEnv;</span>
<span class="line-added">2410     if (runtime-&gt;GetEnv(thread, (void**) &amp;peerJNIEnv, JNI_VERSION_1_2) != JNI_OK) {</span>
2411       JVMCI_THROW_MSG(IllegalStateException, err_msg(&quot;Cannot detach non-attached thread: %s&quot;, thread-&gt;name()));
2412     }
<span class="line-modified">2413     jint res = runtime-&gt;DetachCurrentThread(thread);</span>
2414     if (res != JNI_OK) {
2415       JVMCI_THROW_MSG(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, thread-&gt;name()));
2416     }
2417   } else {
2418     // Called from attached JVMCI shared library thread
2419     extern struct JavaVM_ main_vm;
2420     jint res = main_vm.DetachCurrentThread();
2421     if (res != JNI_OK) {
<span class="line-modified">2422       JNI_THROW(&quot;detachCurrentThread&quot;, InternalError, &quot;Cannot detach non-attached thread&quot;);</span>
2423     }
2424   }
2425 C2V_END
2426 
2427 C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))
2428   requireJVMCINativeLibrary(JVMCI_CHECK_0);
2429   if (obj_handle == NULL) {
2430     return 0L;
2431   }
2432   JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV-&gt;is_hotspot(), __FILE__, __LINE__);
2433   JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2434   JVMCIEnv* thisEnv = JVMCIENV;
2435 
2436   JVMCIObject obj = thisEnv-&gt;wrap(obj_handle);
2437   JVMCIObject result;
2438   if (thisEnv-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {
2439     methodHandle method(THREAD, thisEnv-&gt;asMethod(obj));
2440     result = peerEnv-&gt;get_jvmci_method(method, JVMCI_CHECK_0);
2441   } else if (thisEnv-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {
2442     Klass* klass = thisEnv-&gt;asKlass(obj);
</pre>
</td>
</tr>
</table>
<center><a href="jvmciCompiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs_jvmci.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>