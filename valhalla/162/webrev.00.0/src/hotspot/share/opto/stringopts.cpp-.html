<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/stringopts.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/callGenerator.hpp&quot;
  29 #include &quot;opto/callnode.hpp&quot;
  30 #include &quot;opto/divnode.hpp&quot;
  31 #include &quot;opto/graphKit.hpp&quot;
  32 #include &quot;opto/idealKit.hpp&quot;
  33 #include &quot;opto/rootnode.hpp&quot;
  34 #include &quot;opto/runtime.hpp&quot;
  35 #include &quot;opto/stringopts.hpp&quot;
  36 #include &quot;opto/subnode.hpp&quot;
  37 #include &quot;runtime/sharedRuntime.hpp&quot;
  38 
  39 #define __ kit.
  40 
  41 class StringConcat : public ResourceObj {
  42  private:
  43   PhaseStringOpts*    _stringopts;
  44   Node*               _string_alloc;
  45   AllocateNode*       _begin;          // The allocation the begins the pattern
  46   CallStaticJavaNode* _end;            // The final call of the pattern.  Will either be
  47                                        // SB.toString or or String.&lt;init&gt;(SB.toString)
  48   bool                _multiple;       // indicates this is a fusion of two or more
  49                                        // separate StringBuilders
  50 
  51   Node*               _arguments;      // The list of arguments to be concatenated
  52   GrowableArray&lt;int&gt;  _mode;           // into a String along with a mode flag
  53                                        // indicating how to treat the value.
  54   Node_List           _constructors;   // List of constructors (many in case of stacked concat)
  55   Node_List           _control;        // List of control nodes that will be deleted
  56   Node_List           _uncommon_traps; // Uncommon traps that needs to be rewritten
  57                                        // to restart at the initial JVMState.
  58 
  59  public:
  60   // Mode for converting arguments to Strings
  61   enum {
  62     StringMode,
  63     IntMode,
  64     CharMode,
  65     StringNullCheckMode
  66   };
  67 
  68   StringConcat(PhaseStringOpts* stringopts, CallStaticJavaNode* end):
  69     _stringopts(stringopts),
  70     _string_alloc(NULL),
  71     _begin(NULL),
  72     _end(end),
  73     _multiple(false) {
  74     _arguments = new Node(1);
  75     _arguments-&gt;del_req(0);
  76   }
  77 
  78   bool validate_mem_flow();
  79   bool validate_control_flow();
  80 
  81   void merge_add() {
  82 #if 0
  83     // XXX This is place holder code for reusing an existing String
  84     // allocation but the logic for checking the state safety is
  85     // probably inadequate at the moment.
  86     CallProjections endprojs;
  87     sc-&gt;end()-&gt;extract_projections(&amp;endprojs, false);
  88     if (endprojs.resproj != NULL) {
  89       for (SimpleDUIterator i(endprojs.resproj); i.has_next(); i.next()) {
  90         CallStaticJavaNode *use = i.get()-&gt;isa_CallStaticJava();
  91         if (use != NULL &amp;&amp; use-&gt;method() != NULL &amp;&amp;
  92             use-&gt;method()-&gt;intrinsic_id() == vmIntrinsics::_String_String &amp;&amp;
  93             use-&gt;in(TypeFunc::Parms + 1) == endprojs.resproj) {
  94           // Found useless new String(sb.toString()) so reuse the newly allocated String
  95           // when creating the result instead of allocating a new one.
  96           sc-&gt;set_string_alloc(use-&gt;in(TypeFunc::Parms));
  97           sc-&gt;set_end(use);
  98         }
  99       }
 100     }
 101 #endif
 102   }
 103 
 104   StringConcat* merge(StringConcat* other, Node* arg);
 105 
 106   void set_allocation(AllocateNode* alloc) {
 107     _begin = alloc;
 108   }
 109 
 110   void append(Node* value, int mode) {
 111     _arguments-&gt;add_req(value);
 112     _mode.append(mode);
 113   }
 114   void push(Node* value, int mode) {
 115     _arguments-&gt;ins_req(0, value);
 116     _mode.insert_before(0, mode);
 117   }
 118 
 119   void push_string(Node* value) {
 120     push(value, StringMode);
 121   }
 122   void push_string_null_check(Node* value) {
 123     push(value, StringNullCheckMode);
 124   }
 125   void push_int(Node* value) {
 126     push(value, IntMode);
 127   }
 128   void push_char(Node* value) {
 129     push(value, CharMode);
 130   }
 131 
 132   static bool is_SB_toString(Node* call) {
 133     if (call-&gt;is_CallStaticJava()) {
 134       CallStaticJavaNode* csj = call-&gt;as_CallStaticJava();
 135       ciMethod* m = csj-&gt;method();
 136       if (m != NULL &amp;&amp;
 137           (m-&gt;intrinsic_id() == vmIntrinsics::_StringBuilder_toString ||
 138            m-&gt;intrinsic_id() == vmIntrinsics::_StringBuffer_toString)) {
 139         return true;
 140       }
 141     }
 142     return false;
 143   }
 144 
 145   static Node* skip_string_null_check(Node* value) {
 146     // Look for a diamond shaped Null check of toString() result
 147     // (could be code from String.valueOf()):
 148     // (Proj == NULL) ? &quot;null&quot;:&quot;CastPP(Proj)#NotNULL
 149     if (value-&gt;is_Phi()) {
 150       int true_path = value-&gt;as_Phi()-&gt;is_diamond_phi();
 151       if (true_path != 0) {
 152         // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool
 153         BoolNode* b = value-&gt;in(0)-&gt;in(1)-&gt;in(0)-&gt;in(1)-&gt;as_Bool();
 154         Node* cmp = b-&gt;in(1);
 155         Node* v1 = cmp-&gt;in(1);
 156         Node* v2 = cmp-&gt;in(2);
 157         // Null check of the return of toString which can simply be skipped.
 158         if (b-&gt;_test._test == BoolTest::ne &amp;&amp;
 159             v2-&gt;bottom_type() == TypePtr::NULL_PTR &amp;&amp;
 160             value-&gt;in(true_path)-&gt;Opcode() == Op_CastPP &amp;&amp;
 161             value-&gt;in(true_path)-&gt;in(1) == v1 &amp;&amp;
 162             v1-&gt;is_Proj() &amp;&amp; is_SB_toString(v1-&gt;in(0))) {
 163           return v1;
 164         }
 165       }
 166     }
 167     return value;
 168   }
 169 
 170   Node* argument(int i) {
 171     return _arguments-&gt;in(i);
 172   }
 173   Node* argument_uncast(int i) {
 174     Node* arg = argument(i);
 175     int amode = mode(i);
 176     if (amode == StringConcat::StringMode ||
 177         amode == StringConcat::StringNullCheckMode) {
 178       arg = skip_string_null_check(arg);
 179     }
 180     return arg;
 181   }
 182   void set_argument(int i, Node* value) {
 183     _arguments-&gt;set_req(i, value);
 184   }
 185   int num_arguments() {
 186     return _mode.length();
 187   }
 188   int mode(int i) {
 189     return _mode.at(i);
 190   }
 191   void add_control(Node* ctrl) {
 192     assert(!_control.contains(ctrl), &quot;only push once&quot;);
 193     _control.push(ctrl);
 194   }
 195   void add_constructor(Node* init) {
 196     assert(!_constructors.contains(init), &quot;only push once&quot;);
 197     _constructors.push(init);
 198   }
 199   CallStaticJavaNode* end() { return _end; }
 200   AllocateNode* begin() { return _begin; }
 201   Node* string_alloc() { return _string_alloc; }
 202 
 203   void eliminate_unneeded_control();
 204   void eliminate_initialize(InitializeNode* init);
 205   void eliminate_call(CallNode* call);
 206 
 207   void maybe_log_transform() {
 208     CompileLog* log = _stringopts-&gt;C-&gt;log();
 209     if (log != NULL) {
 210       log-&gt;head(&quot;replace_string_concat arguments=&#39;%d&#39; string_alloc=&#39;%d&#39; multiple=&#39;%d&#39;&quot;,
 211                 num_arguments(),
 212                 _string_alloc != NULL,
 213                 _multiple);
 214       JVMState* p = _begin-&gt;jvms();
 215       while (p != NULL) {
 216         log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
 217         p = p-&gt;caller();
 218       }
 219       log-&gt;tail(&quot;replace_string_concat&quot;);
 220     }
 221   }
 222 
 223   void convert_uncommon_traps(GraphKit&amp; kit, const JVMState* jvms) {
 224     for (uint u = 0; u &lt; _uncommon_traps.size(); u++) {
 225       Node* uct = _uncommon_traps.at(u);
 226 
 227       // Build a new call using the jvms state of the allocate
 228       address call_addr = SharedRuntime::uncommon_trap_blob()-&gt;entry_point();
 229       const TypeFunc* call_type = OptoRuntime::uncommon_trap_Type();
 230       const TypePtr* no_memory_effects = NULL;
 231       Compile* C = _stringopts-&gt;C;
 232       CallStaticJavaNode* call = new CallStaticJavaNode(call_type, call_addr, &quot;uncommon_trap&quot;,
 233                                                         jvms-&gt;bci(), no_memory_effects);
 234       for (int e = 0; e &lt; TypeFunc::Parms; e++) {
 235         call-&gt;init_req(e, uct-&gt;in(e));
 236       }
 237       // Set the trap request to record intrinsic failure if this trap
 238       // is taken too many times.  Ideally we would handle then traps by
 239       // doing the original bookkeeping in the MDO so that if it caused
 240       // the code to be thrown out we could still recompile and use the
 241       // optimization.  Failing the uncommon traps doesn&#39;t really mean
 242       // that the optimization is a bad idea but there&#39;s no other way to
 243       // do the MDO updates currently.
 244       int trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_intrinsic,
 245                                                            Deoptimization::Action_make_not_entrant);
 246       call-&gt;init_req(TypeFunc::Parms, __ intcon(trap_request));
 247       kit.add_safepoint_edges(call);
 248 
 249       _stringopts-&gt;gvn()-&gt;transform(call);
 250       C-&gt;gvn_replace_by(uct, call);
 251       uct-&gt;disconnect_inputs(NULL, C);
 252     }
 253   }
 254 
 255   void cleanup() {
 256     // disconnect the hook node
 257     _arguments-&gt;disconnect_inputs(NULL, _stringopts-&gt;C);
 258   }
 259 };
 260 
 261 
 262 void StringConcat::eliminate_unneeded_control() {
 263   for (uint i = 0; i &lt; _control.size(); i++) {
 264     Node* n = _control.at(i);
 265     if (n-&gt;is_Allocate()) {
 266       eliminate_initialize(n-&gt;as_Allocate()-&gt;initialization());
 267     }
 268     if (n-&gt;is_Call()) {
 269       if (n != _end) {
 270         eliminate_call(n-&gt;as_Call());
 271       }
 272     } else if (n-&gt;is_IfTrue()) {
 273       Compile* C = _stringopts-&gt;C;
 274       C-&gt;gvn_replace_by(n, n-&gt;in(0)-&gt;in(0));
 275       // get rid of the other projection
 276       C-&gt;gvn_replace_by(n-&gt;in(0)-&gt;as_If()-&gt;proj_out(false), C-&gt;top());
 277     }
 278   }
 279 }
 280 
 281 
 282 StringConcat* StringConcat::merge(StringConcat* other, Node* arg) {
 283   StringConcat* result = new StringConcat(_stringopts, _end);
 284   for (uint x = 0; x &lt; _control.size(); x++) {
 285     Node* n = _control.at(x);
 286     if (n-&gt;is_Call()) {
 287       result-&gt;_control.push(n);
 288     }
 289   }
 290   for (uint x = 0; x &lt; other-&gt;_control.size(); x++) {
 291     Node* n = other-&gt;_control.at(x);
 292     if (n-&gt;is_Call()) {
 293       result-&gt;_control.push(n);
 294     }
 295   }
 296   assert(result-&gt;_control.contains(other-&gt;_end), &quot;what?&quot;);
 297   assert(result-&gt;_control.contains(_begin), &quot;what?&quot;);
 298   for (int x = 0; x &lt; num_arguments(); x++) {
 299     Node* argx = argument_uncast(x);
 300     if (argx == arg) {
 301       // replace the toString result with the all the arguments that
 302       // made up the other StringConcat
 303       for (int y = 0; y &lt; other-&gt;num_arguments(); y++) {
 304         result-&gt;append(other-&gt;argument(y), other-&gt;mode(y));
 305       }
 306     } else {
 307       result-&gt;append(argx, mode(x));
 308     }
 309   }
 310   result-&gt;set_allocation(other-&gt;_begin);
 311   for (uint i = 0; i &lt; _constructors.size(); i++) {
 312     result-&gt;add_constructor(_constructors.at(i));
 313   }
 314   for (uint i = 0; i &lt; other-&gt;_constructors.size(); i++) {
 315     result-&gt;add_constructor(other-&gt;_constructors.at(i));
 316   }
 317   result-&gt;_multiple = true;
 318   return result;
 319 }
 320 
 321 
 322 void StringConcat::eliminate_call(CallNode* call) {
 323   Compile* C = _stringopts-&gt;C;
 324   CallProjections* projs = call-&gt;extract_projections(false);
 325   if (projs-&gt;fallthrough_catchproj != NULL) {
 326     C-&gt;gvn_replace_by(projs-&gt;fallthrough_catchproj, call-&gt;in(TypeFunc::Control));
 327   }
 328   if (projs-&gt;fallthrough_memproj != NULL) {
 329     C-&gt;gvn_replace_by(projs-&gt;fallthrough_memproj, call-&gt;in(TypeFunc::Memory));
 330   }
 331   if (projs-&gt;catchall_memproj != NULL) {
 332     C-&gt;gvn_replace_by(projs-&gt;catchall_memproj, C-&gt;top());
 333   }
 334   if (projs-&gt;fallthrough_ioproj != NULL) {
 335     C-&gt;gvn_replace_by(projs-&gt;fallthrough_ioproj, call-&gt;in(TypeFunc::I_O));
 336   }
 337   if (projs-&gt;catchall_ioproj != NULL) {
 338     C-&gt;gvn_replace_by(projs-&gt;catchall_ioproj, C-&gt;top());
 339   }
 340   if (projs-&gt;catchall_catchproj != NULL) {
 341     // EA can&#39;t cope with the partially collapsed graph this
 342     // creates so put it on the worklist to be collapsed later.
 343     for (SimpleDUIterator i(projs-&gt;catchall_catchproj); i.has_next(); i.next()) {
 344       Node *use = i.get();
 345       int opc = use-&gt;Opcode();
 346       if (opc == Op_CreateEx || opc == Op_Region) {
 347         _stringopts-&gt;record_dead_node(use);
 348       }
 349     }
 350     C-&gt;gvn_replace_by(projs-&gt;catchall_catchproj, C-&gt;top());
 351   }
 352   if (projs-&gt;resproj[0] != NULL) {
 353     assert(projs-&gt;nb_resproj == 1, &quot;unexpected number of results&quot;);
 354     C-&gt;gvn_replace_by(projs-&gt;resproj[0], C-&gt;top());
 355   }
 356   C-&gt;gvn_replace_by(call, C-&gt;top());
 357 }
 358 
 359 void StringConcat::eliminate_initialize(InitializeNode* init) {
 360   Compile* C = _stringopts-&gt;C;
 361 
 362   // Eliminate Initialize node.
 363   assert(init-&gt;outcnt() &lt;= 2, &quot;only a control and memory projection expected&quot;);
 364   assert(init-&gt;req() &lt;= InitializeNode::RawStores, &quot;no pending inits&quot;);
 365   Node *ctrl_proj = init-&gt;proj_out_or_null(TypeFunc::Control);
 366   if (ctrl_proj != NULL) {
 367     C-&gt;gvn_replace_by(ctrl_proj, init-&gt;in(TypeFunc::Control));
 368   }
 369   Node *mem_proj = init-&gt;proj_out_or_null(TypeFunc::Memory);
 370   if (mem_proj != NULL) {
 371     Node *mem = init-&gt;in(TypeFunc::Memory);
 372     C-&gt;gvn_replace_by(mem_proj, mem);
 373   }
 374   C-&gt;gvn_replace_by(init, C-&gt;top());
 375   init-&gt;disconnect_inputs(NULL, C);
 376 }
 377 
 378 Node_List PhaseStringOpts::collect_toString_calls() {
 379   Node_List string_calls;
 380   Node_List worklist;
 381 
 382   _visited.clear();
 383 
 384   // Prime the worklist
 385   for (uint i = 1; i &lt; C-&gt;root()-&gt;len(); i++) {
 386     Node* n = C-&gt;root()-&gt;in(i);
 387     if (n != NULL &amp;&amp; !_visited.test_set(n-&gt;_idx)) {
 388       worklist.push(n);
 389     }
 390   }
 391 
 392   while (worklist.size() &gt; 0) {
 393     Node* ctrl = worklist.pop();
 394     if (StringConcat::is_SB_toString(ctrl)) {
 395       CallStaticJavaNode* csj = ctrl-&gt;as_CallStaticJava();
 396       string_calls.push(csj);
 397     }
 398     if (ctrl-&gt;in(0) != NULL &amp;&amp; !_visited.test_set(ctrl-&gt;in(0)-&gt;_idx)) {
 399       worklist.push(ctrl-&gt;in(0));
 400     }
 401     if (ctrl-&gt;is_Region()) {
 402       for (uint i = 1; i &lt; ctrl-&gt;len(); i++) {
 403         if (ctrl-&gt;in(i) != NULL &amp;&amp; !_visited.test_set(ctrl-&gt;in(i)-&gt;_idx)) {
 404           worklist.push(ctrl-&gt;in(i));
 405         }
 406       }
 407     }
 408   }
 409   return string_calls;
 410 }
 411 
 412 
 413 StringConcat* PhaseStringOpts::build_candidate(CallStaticJavaNode* call) {
 414   ciMethod* m = call-&gt;method();
 415   ciSymbol* string_sig;
 416   ciSymbol* int_sig;
 417   ciSymbol* char_sig;
 418   if (m-&gt;holder() == C-&gt;env()-&gt;StringBuilder_klass()) {
 419     string_sig = ciSymbol::String_StringBuilder_signature();
 420     int_sig = ciSymbol::int_StringBuilder_signature();
 421     char_sig = ciSymbol::char_StringBuilder_signature();
 422   } else if (m-&gt;holder() == C-&gt;env()-&gt;StringBuffer_klass()) {
 423     string_sig = ciSymbol::String_StringBuffer_signature();
 424     int_sig = ciSymbol::int_StringBuffer_signature();
 425     char_sig = ciSymbol::char_StringBuffer_signature();
 426   } else {
 427     return NULL;
 428   }
 429 #ifndef PRODUCT
 430   if (PrintOptimizeStringConcat) {
 431     tty-&gt;print(&quot;considering toString call in &quot;);
 432     call-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 433   }
 434 #endif
 435 
 436   StringConcat* sc = new StringConcat(this, call);
 437 
 438   AllocateNode* alloc = NULL;
 439   InitializeNode* init = NULL;
 440 
 441   // possible opportunity for StringBuilder fusion
 442   CallStaticJavaNode* cnode = call;
 443   while (cnode) {
 444     Node* recv = cnode-&gt;in(TypeFunc::Parms)-&gt;uncast();
 445     if (recv-&gt;is_Proj()) {
 446       recv = recv-&gt;in(0);
 447     }
 448     cnode = recv-&gt;isa_CallStaticJava();
 449     if (cnode == NULL) {
 450       alloc = recv-&gt;isa_Allocate();
 451       if (alloc == NULL) {
 452         break;
 453       }
 454       // Find the constructor call
 455       Node* result = alloc-&gt;result_cast();
 456       if (result == NULL || !result-&gt;is_CheckCastPP() || alloc-&gt;in(TypeFunc::Memory)-&gt;is_top()) {
 457         // strange looking allocation
 458 #ifndef PRODUCT
 459         if (PrintOptimizeStringConcat) {
 460           tty-&gt;print(&quot;giving up because allocation looks strange &quot;);
 461           alloc-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 462         }
 463 #endif
 464         break;
 465       }
 466       Node* constructor = NULL;
 467       for (SimpleDUIterator i(result); i.has_next(); i.next()) {
 468         CallStaticJavaNode *use = i.get()-&gt;isa_CallStaticJava();
 469         if (use != NULL &amp;&amp;
 470             use-&gt;method() != NULL &amp;&amp;
 471             !use-&gt;method()-&gt;is_static() &amp;&amp;
 472             use-&gt;method()-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
 473             use-&gt;method()-&gt;holder() == m-&gt;holder()) {
 474           // Matched the constructor.
 475           ciSymbol* sig = use-&gt;method()-&gt;signature()-&gt;as_symbol();
 476           if (sig == ciSymbol::void_method_signature() ||
 477               sig == ciSymbol::int_void_signature() ||
 478               sig == ciSymbol::string_void_signature()) {
 479             if (sig == ciSymbol::string_void_signature()) {
 480               // StringBuilder(String) so pick this up as the first argument
 481               assert(use-&gt;in(TypeFunc::Parms + 1) != NULL, &quot;what?&quot;);
 482               const Type* type = _gvn-&gt;type(use-&gt;in(TypeFunc::Parms + 1));
 483               if (type == TypePtr::NULL_PTR) {
 484                 // StringBuilder(null) throws exception.
 485 #ifndef PRODUCT
 486                 if (PrintOptimizeStringConcat) {
 487                   tty-&gt;print(&quot;giving up because StringBuilder(null) throws exception&quot;);
 488                   alloc-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 489                 }
 490 #endif
 491                 return NULL;
 492               }
 493               // StringBuilder(str) argument needs null check.
 494               sc-&gt;push_string_null_check(use-&gt;in(TypeFunc::Parms + 1));
 495             }
 496             // The int variant takes an initial size for the backing
 497             // array so just treat it like the void version.
 498             constructor = use;
 499           } else {
 500 #ifndef PRODUCT
 501             if (PrintOptimizeStringConcat) {
 502               tty-&gt;print(&quot;unexpected constructor signature: %s&quot;, sig-&gt;as_utf8());
 503             }
 504 #endif
 505           }
 506           break;
 507         }
 508       }
 509       if (constructor == NULL) {
 510         // couldn&#39;t find constructor
 511 #ifndef PRODUCT
 512         if (PrintOptimizeStringConcat) {
 513           tty-&gt;print(&quot;giving up because couldn&#39;t find constructor &quot;);
 514           alloc-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 515         }
 516 #endif
 517         break;
 518       }
 519 
 520       // Walked all the way back and found the constructor call so see
 521       // if this call converted into a direct string concatenation.
 522       sc-&gt;add_control(call);
 523       sc-&gt;add_control(constructor);
 524       sc-&gt;add_control(alloc);
 525       sc-&gt;set_allocation(alloc);
 526       sc-&gt;add_constructor(constructor);
 527       if (sc-&gt;validate_control_flow() &amp;&amp; sc-&gt;validate_mem_flow()) {
 528         return sc;
 529       } else {
 530         return NULL;
 531       }
 532     } else if (cnode-&gt;method() == NULL) {
 533       break;
 534     } else if (!cnode-&gt;method()-&gt;is_static() &amp;&amp;
 535                cnode-&gt;method()-&gt;holder() == m-&gt;holder() &amp;&amp;
 536                cnode-&gt;method()-&gt;name() == ciSymbol::append_name() &amp;&amp;
 537                (cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == string_sig ||
 538                 cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == char_sig ||
 539                 cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == int_sig)) {
 540       sc-&gt;add_control(cnode);
 541       Node* arg = cnode-&gt;in(TypeFunc::Parms + 1);
 542       if (cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == int_sig) {
 543         sc-&gt;push_int(arg);
 544       } else if (cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == char_sig) {
 545         sc-&gt;push_char(arg);
 546       } else {
 547         if (arg-&gt;is_Proj() &amp;&amp; arg-&gt;in(0)-&gt;is_CallStaticJava()) {
 548           CallStaticJavaNode* csj = arg-&gt;in(0)-&gt;as_CallStaticJava();
 549           if (csj-&gt;method() != NULL &amp;&amp;
 550               csj-&gt;method()-&gt;intrinsic_id() == vmIntrinsics::_Integer_toString &amp;&amp;
 551               arg-&gt;outcnt() == 1) {
 552             // _control is the list of StringBuilder calls nodes which
 553             // will be replaced by new String code after this optimization.
 554             // Integer::toString() call is not part of StringBuilder calls
 555             // chain. It could be eliminated only if its result is used
 556             // only by this SB calls chain.
 557             // Another limitation: it should be used only once because
 558             // it is unknown that it is used only by this SB calls chain
 559             // until all related SB calls nodes are collected.
 560             assert(arg-&gt;unique_out() == cnode, &quot;sanity&quot;);
 561             sc-&gt;add_control(csj);
 562             sc-&gt;push_int(csj-&gt;in(TypeFunc::Parms));
 563             continue;
 564           }
 565         }
 566         sc-&gt;push_string(arg);
 567       }
 568       continue;
 569     } else {
 570       // some unhandled signature
 571 #ifndef PRODUCT
 572       if (PrintOptimizeStringConcat) {
 573         tty-&gt;print(&quot;giving up because encountered unexpected signature &quot;);
 574         cnode-&gt;tf()-&gt;dump(); tty-&gt;cr();
 575         cnode-&gt;in(TypeFunc::Parms + 1)-&gt;dump();
 576       }
 577 #endif
 578       break;
 579     }
 580   }
 581   return NULL;
 582 }
 583 
 584 
 585 PhaseStringOpts::PhaseStringOpts(PhaseGVN* gvn, Unique_Node_List*):
 586   Phase(StringOpts),
 587   _gvn(gvn) {
 588 
 589   assert(OptimizeStringConcat, &quot;shouldn&#39;t be here&quot;);
 590 
 591   size_table_field = C-&gt;env()-&gt;Integer_klass()-&gt;get_field_by_name(ciSymbol::make(&quot;sizeTable&quot;),
 592                                                                   ciSymbol::make(&quot;[I&quot;), true);
 593   if (size_table_field == NULL) {
 594     // Something wrong so give up.
 595     assert(false, &quot;why can&#39;t we find Integer.sizeTable?&quot;);
 596     return;
 597   }
 598 
 599   // Collect the types needed to talk about the various slices of memory
 600   byte_adr_idx = C-&gt;get_alias_index(TypeAryPtr::BYTES);
 601 
 602   // For each locally allocated StringBuffer see if the usages can be
 603   // collapsed into a single String construction.
 604 
 605   // Run through the list of allocation looking for SB.toString to see
 606   // if it&#39;s possible to fuse the usage of the SB into a single String
 607   // construction.
 608   GrowableArray&lt;StringConcat*&gt; concats;
 609   Node_List toStrings = collect_toString_calls();
 610   while (toStrings.size() &gt; 0) {
 611     StringConcat* sc = build_candidate(toStrings.pop()-&gt;as_CallStaticJava());
 612     if (sc != NULL) {
 613       concats.push(sc);
 614     }
 615   }
 616 
 617   // try to coalesce separate concats
 618  restart:
 619   for (int c = 0; c &lt; concats.length(); c++) {
 620     StringConcat* sc = concats.at(c);
 621     for (int i = 0; i &lt; sc-&gt;num_arguments(); i++) {
 622       Node* arg = sc-&gt;argument_uncast(i);
 623       if (arg-&gt;is_Proj() &amp;&amp; StringConcat::is_SB_toString(arg-&gt;in(0))) {
 624         CallStaticJavaNode* csj = arg-&gt;in(0)-&gt;as_CallStaticJava();
 625         for (int o = 0; o &lt; concats.length(); o++) {
 626           if (c == o) continue;
 627           StringConcat* other = concats.at(o);
 628           if (other-&gt;end() == csj) {
 629 #ifndef PRODUCT
 630             if (PrintOptimizeStringConcat) {
 631               tty-&gt;print_cr(&quot;considering stacked concats&quot;);
 632             }
 633 #endif
 634 
 635             StringConcat* merged = sc-&gt;merge(other, arg);
 636             if (merged-&gt;validate_control_flow() &amp;&amp; merged-&gt;validate_mem_flow()) {
 637 #ifndef PRODUCT
 638               if (PrintOptimizeStringConcat) {
 639                 tty-&gt;print_cr(&quot;stacking would succeed&quot;);
 640               }
 641 #endif
 642               if (c &lt; o) {
 643                 concats.remove_at(o);
 644                 concats.at_put(c, merged);
 645               } else {
 646                 concats.remove_at(c);
 647                 concats.at_put(o, merged);
 648               }
 649               goto restart;
 650             } else {
 651 #ifndef PRODUCT
 652               if (PrintOptimizeStringConcat) {
 653                 tty-&gt;print_cr(&quot;stacking would fail&quot;);
 654               }
 655 #endif
 656             }
 657           }
 658         }
 659       }
 660     }
 661   }
 662 
 663 
 664   for (int c = 0; c &lt; concats.length(); c++) {
 665     StringConcat* sc = concats.at(c);
 666     replace_string_concat(sc);
 667   }
 668 
 669   remove_dead_nodes();
 670 }
 671 
 672 void PhaseStringOpts::record_dead_node(Node* dead) {
 673   dead_worklist.push(dead);
 674 }
 675 
 676 void PhaseStringOpts::remove_dead_nodes() {
 677   // Delete any dead nodes to make things clean enough that escape
 678   // analysis doesn&#39;t get unhappy.
 679   while (dead_worklist.size() &gt; 0) {
 680     Node* use = dead_worklist.pop();
 681     int opc = use-&gt;Opcode();
 682     switch (opc) {
 683       case Op_Region: {
 684         uint i = 1;
 685         for (i = 1; i &lt; use-&gt;req(); i++) {
 686           if (use-&gt;in(i) != C-&gt;top()) {
 687             break;
 688           }
 689         }
 690         if (i &gt;= use-&gt;req()) {
 691           for (SimpleDUIterator i(use); i.has_next(); i.next()) {
 692             Node* m = i.get();
 693             if (m-&gt;is_Phi()) {
 694               dead_worklist.push(m);
 695             }
 696           }
 697           C-&gt;gvn_replace_by(use, C-&gt;top());
 698         }
 699         break;
 700       }
 701       case Op_AddP:
 702       case Op_CreateEx: {
 703         // Recurisvely clean up references to CreateEx so EA doesn&#39;t
 704         // get unhappy about the partially collapsed graph.
 705         for (SimpleDUIterator i(use); i.has_next(); i.next()) {
 706           Node* m = i.get();
 707           if (m-&gt;is_AddP()) {
 708             dead_worklist.push(m);
 709           }
 710         }
 711         C-&gt;gvn_replace_by(use, C-&gt;top());
 712         break;
 713       }
 714       case Op_Phi:
 715         if (use-&gt;in(0) == C-&gt;top()) {
 716           C-&gt;gvn_replace_by(use, C-&gt;top());
 717         }
 718         break;
 719     }
 720   }
 721 }
 722 
 723 
 724 bool StringConcat::validate_mem_flow() {
 725   Compile* C = _stringopts-&gt;C;
 726 
 727   for (uint i = 0; i &lt; _control.size(); i++) {
 728 #ifndef PRODUCT
 729     Node_List path;
 730 #endif
 731     Node* curr = _control.at(i);
 732     if (curr-&gt;is_Call() &amp;&amp; curr != _begin) { // For all calls except the first allocation
 733       // Now here&#39;s the main invariant in our case:
 734       // For memory between the constructor, and appends, and toString we should only see bottom memory,
 735       // produced by the previous call we know about.
 736       if (!_constructors.contains(curr)) {
 737         NOT_PRODUCT(path.push(curr);)
 738         Node* mem = curr-&gt;in(TypeFunc::Memory);
 739         assert(mem != NULL, &quot;calls should have memory edge&quot;);
 740         assert(!mem-&gt;is_Phi(), &quot;should be handled by control flow validation&quot;);
 741         NOT_PRODUCT(path.push(mem);)
 742         while (mem-&gt;is_MergeMem()) {
 743           for (uint i = 1; i &lt; mem-&gt;req(); i++) {
 744             if (i != Compile::AliasIdxBot &amp;&amp; mem-&gt;in(i) != C-&gt;top()) {
 745 #ifndef PRODUCT
 746               if (PrintOptimizeStringConcat) {
 747                 tty-&gt;print(&quot;fusion has incorrect memory flow (side effects) for &quot;);
 748                 _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 749                 path.dump();
 750               }
 751 #endif
 752               return false;
 753             }
 754           }
 755           // skip through a potential MergeMem chain, linked through Bot
 756           mem = mem-&gt;in(Compile::AliasIdxBot);
 757           NOT_PRODUCT(path.push(mem);)
 758         }
 759         // now let it fall through, and see if we have a projection
 760         if (mem-&gt;is_Proj()) {
 761           // Should point to a previous known call
 762           Node *prev = mem-&gt;in(0);
 763           NOT_PRODUCT(path.push(prev);)
 764           if (!prev-&gt;is_Call() || !_control.contains(prev)) {
 765 #ifndef PRODUCT
 766             if (PrintOptimizeStringConcat) {
 767               tty-&gt;print(&quot;fusion has incorrect memory flow (unknown call) for &quot;);
 768               _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 769               path.dump();
 770             }
 771 #endif
 772             return false;
 773           }
 774         } else {
 775           assert(mem-&gt;is_Store() || mem-&gt;is_LoadStore(), &quot;unexpected node type: %s&quot;, mem-&gt;Name());
 776 #ifndef PRODUCT
 777           if (PrintOptimizeStringConcat) {
 778             tty-&gt;print(&quot;fusion has incorrect memory flow (unexpected source) for &quot;);
 779             _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 780             path.dump();
 781           }
 782 #endif
 783           return false;
 784         }
 785       } else {
 786         // For memory that feeds into constructors it&#39;s more complicated.
 787         // However the advantage is that any side effect that happens between the Allocate/Initialize and
 788         // the constructor will have to be control-dependent on Initialize.
 789         // So we actually don&#39;t have to do anything, since it&#39;s going to be caught by the control flow
 790         // analysis.
 791 #ifdef ASSERT
 792         // Do a quick verification of the control pattern between the constructor and the initialize node
 793         assert(curr-&gt;is_Call(), &quot;constructor should be a call&quot;);
 794         // Go up the control starting from the constructor call
 795         Node* ctrl = curr-&gt;in(0);
 796         IfNode* iff = NULL;
 797         RegionNode* copy = NULL;
 798 
 799         while (true) {
 800           // skip known check patterns
 801           if (ctrl-&gt;is_Region()) {
 802             if (ctrl-&gt;as_Region()-&gt;is_copy()) {
 803               copy = ctrl-&gt;as_Region();
 804               ctrl = copy-&gt;is_copy();
 805             } else { // a cast
 806               assert(ctrl-&gt;req() == 3 &amp;&amp;
 807                      ctrl-&gt;in(1) != NULL &amp;&amp; ctrl-&gt;in(1)-&gt;is_Proj() &amp;&amp;
 808                      ctrl-&gt;in(2) != NULL &amp;&amp; ctrl-&gt;in(2)-&gt;is_Proj() &amp;&amp;
 809                      ctrl-&gt;in(1)-&gt;in(0) == ctrl-&gt;in(2)-&gt;in(0) &amp;&amp;
 810                      ctrl-&gt;in(1)-&gt;in(0) != NULL &amp;&amp; ctrl-&gt;in(1)-&gt;in(0)-&gt;is_If(),
 811                      &quot;must be a simple diamond&quot;);
 812               Node* true_proj = ctrl-&gt;in(1)-&gt;is_IfTrue() ? ctrl-&gt;in(1) : ctrl-&gt;in(2);
 813               for (SimpleDUIterator i(true_proj); i.has_next(); i.next()) {
 814                 Node* use = i.get();
 815                 assert(use == ctrl || use-&gt;is_ConstraintCast(),
 816                        &quot;unexpected user: %s&quot;, use-&gt;Name());
 817               }
 818 
 819               iff = ctrl-&gt;in(1)-&gt;in(0)-&gt;as_If();
 820               ctrl = iff-&gt;in(0);
 821             }
 822           } else if (ctrl-&gt;is_IfTrue()) { // null checks, class checks
 823             iff = ctrl-&gt;in(0)-&gt;as_If();
 824             // Verify that the other arm is an uncommon trap
 825             Node* otherproj = iff-&gt;proj_out(1 - ctrl-&gt;as_Proj()-&gt;_con);
 826             CallStaticJavaNode* call = otherproj-&gt;unique_out()-&gt;isa_CallStaticJava();
 827             assert(strcmp(call-&gt;_name, &quot;uncommon_trap&quot;) == 0, &quot;must be uncommon trap&quot;);
 828             ctrl = iff-&gt;in(0);
 829           } else {
 830             break;
 831           }
 832         }
 833 
 834         assert(ctrl-&gt;is_Proj(), &quot;must be a projection&quot;);
 835         assert(ctrl-&gt;in(0)-&gt;is_Initialize(), &quot;should be initialize&quot;);
 836         for (SimpleDUIterator i(ctrl); i.has_next(); i.next()) {
 837           Node* use = i.get();
 838           assert(use == copy || use == iff || use == curr || use-&gt;is_CheckCastPP() || use-&gt;is_Load(),
 839                  &quot;unexpected user: %s&quot;, use-&gt;Name());
 840         }
 841 #endif // ASSERT
 842       }
 843     }
 844   }
 845 
 846 #ifndef PRODUCT
 847   if (PrintOptimizeStringConcat) {
 848     tty-&gt;print(&quot;fusion has correct memory flow for &quot;);
 849     _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 850     tty-&gt;cr();
 851   }
 852 #endif
 853   return true;
 854 }
 855 
 856 bool StringConcat::validate_control_flow() {
 857   // We found all the calls and arguments now lets see if it&#39;s
 858   // safe to transform the graph as we would expect.
 859 
 860   // Check to see if this resulted in too many uncommon traps previously
 861   if (Compile::current()-&gt;too_many_traps(_begin-&gt;jvms()-&gt;method(), _begin-&gt;jvms()-&gt;bci(),
 862                         Deoptimization::Reason_intrinsic)) {
 863     return false;
 864   }
 865 
 866   // Walk backwards over the control flow from toString to the
 867   // allocation and make sure all the control flow is ok.  This
 868   // means it&#39;s either going to be eliminated once the calls are
 869   // removed or it can safely be transformed into an uncommon
 870   // trap.
 871 
 872   int null_check_count = 0;
 873   Unique_Node_List ctrl_path;
 874 
 875   assert(_control.contains(_begin), &quot;missing&quot;);
 876   assert(_control.contains(_end), &quot;missing&quot;);
 877 
 878   // Collect the nodes that we know about and will eliminate into ctrl_path
 879   for (uint i = 0; i &lt; _control.size(); i++) {
 880     // Push the call and it&#39;s control projection
 881     Node* n = _control.at(i);
 882     if (n-&gt;is_Allocate()) {
 883       AllocateNode* an = n-&gt;as_Allocate();
 884       InitializeNode* init = an-&gt;initialization();
 885       ctrl_path.push(init);
 886       ctrl_path.push(init-&gt;as_Multi()-&gt;proj_out(0));
 887     }
 888     if (n-&gt;is_Call()) {
 889       CallNode* cn = n-&gt;as_Call();
 890       ctrl_path.push(cn);
 891       ctrl_path.push(cn-&gt;proj_out(0));
 892       ctrl_path.push(cn-&gt;proj_out(0)-&gt;unique_out());
 893       Node* catchproj = cn-&gt;proj_out(0)-&gt;unique_out()-&gt;as_Catch()-&gt;proj_out_or_null(0);
 894       if (catchproj != NULL) {
 895         ctrl_path.push(catchproj);
 896       }
 897     } else {
 898       ShouldNotReachHere();
 899     }
 900   }
 901 
 902   // Skip backwards through the control checking for unexpected control flow
 903   Node* ptr = _end;
 904   bool fail = false;
 905   while (ptr != _begin) {
 906     if (ptr-&gt;is_Call() &amp;&amp; ctrl_path.member(ptr)) {
 907       ptr = ptr-&gt;in(0);
 908     } else if (ptr-&gt;is_CatchProj() &amp;&amp; ctrl_path.member(ptr)) {
 909       ptr = ptr-&gt;in(0)-&gt;in(0)-&gt;in(0);
 910       assert(ctrl_path.member(ptr), &quot;should be a known piece of control&quot;);
 911     } else if (ptr-&gt;is_IfTrue()) {
 912       IfNode* iff = ptr-&gt;in(0)-&gt;as_If();
 913       BoolNode* b = iff-&gt;in(1)-&gt;isa_Bool();
 914 
 915       if (b == NULL) {
 916 #ifndef PRODUCT
 917         if (PrintOptimizeStringConcat) {
 918           tty-&gt;print_cr(&quot;unexpected input to IfNode&quot;);
 919           iff-&gt;in(1)-&gt;dump();
 920           tty-&gt;cr();
 921         }
 922 #endif
 923         fail = true;
 924         break;
 925       }
 926 
 927       Node* cmp = b-&gt;in(1);
 928       Node* v1 = cmp-&gt;in(1);
 929       Node* v2 = cmp-&gt;in(2);
 930       Node* otherproj = iff-&gt;proj_out(1 - ptr-&gt;as_Proj()-&gt;_con);
 931 
 932       // Null check of the return of append which can simply be eliminated
 933       if (b-&gt;_test._test == BoolTest::ne &amp;&amp;
 934           v2-&gt;bottom_type() == TypePtr::NULL_PTR &amp;&amp;
 935           v1-&gt;is_Proj() &amp;&amp; ctrl_path.member(v1-&gt;in(0))) {
 936         // NULL check of the return value of the append
 937         null_check_count++;
 938         if (otherproj-&gt;outcnt() == 1) {
 939           CallStaticJavaNode* call = otherproj-&gt;unique_out()-&gt;isa_CallStaticJava();
 940           if (call != NULL &amp;&amp; call-&gt;_name != NULL &amp;&amp; strcmp(call-&gt;_name, &quot;uncommon_trap&quot;) == 0) {
 941             ctrl_path.push(call);
 942           }
 943         }
 944         _control.push(ptr);
 945         ptr = ptr-&gt;in(0)-&gt;in(0);
 946         continue;
 947       }
 948 
 949       // A test which leads to an uncommon trap which should be safe.
 950       // Later this trap will be converted into a trap that restarts
 951       // at the beginning.
 952       if (otherproj-&gt;outcnt() == 1) {
 953         CallStaticJavaNode* call = otherproj-&gt;unique_out()-&gt;isa_CallStaticJava();
 954         if (call != NULL &amp;&amp; call-&gt;_name != NULL &amp;&amp; strcmp(call-&gt;_name, &quot;uncommon_trap&quot;) == 0) {
 955           // control flow leads to uct so should be ok
 956           _uncommon_traps.push(call);
 957           ctrl_path.push(call);
 958           ptr = ptr-&gt;in(0)-&gt;in(0);
 959           continue;
 960         }
 961       }
 962 
 963 #ifndef PRODUCT
 964       // Some unexpected control flow we don&#39;t know how to handle.
 965       if (PrintOptimizeStringConcat) {
 966         tty-&gt;print_cr(&quot;failing with unknown test&quot;);
 967         b-&gt;dump();
 968         cmp-&gt;dump();
 969         v1-&gt;dump();
 970         v2-&gt;dump();
 971         tty-&gt;cr();
 972       }
 973 #endif
 974       fail = true;
 975       break;
 976     } else if (ptr-&gt;is_Proj() &amp;&amp; ptr-&gt;in(0)-&gt;is_Initialize()) {
 977       ptr = ptr-&gt;in(0)-&gt;in(0);
 978     } else if (ptr-&gt;is_Region()) {
 979       Node* copy = ptr-&gt;as_Region()-&gt;is_copy();
 980       if (copy != NULL) {
 981         ptr = copy;
 982         continue;
 983       }
 984       if (ptr-&gt;req() == 3 &amp;&amp;
 985           ptr-&gt;in(1) != NULL &amp;&amp; ptr-&gt;in(1)-&gt;is_Proj() &amp;&amp;
 986           ptr-&gt;in(2) != NULL &amp;&amp; ptr-&gt;in(2)-&gt;is_Proj() &amp;&amp;
 987           ptr-&gt;in(1)-&gt;in(0) == ptr-&gt;in(2)-&gt;in(0) &amp;&amp;
 988           ptr-&gt;in(1)-&gt;in(0) != NULL &amp;&amp; ptr-&gt;in(1)-&gt;in(0)-&gt;is_If()) {
 989         // Simple diamond.
 990         // XXX should check for possibly merging stores.  simple data merges are ok.
 991         // The IGVN will make this simple diamond go away when it
 992         // transforms the Region. Make sure it sees it.
 993         Compile::current()-&gt;record_for_igvn(ptr);
 994         ptr = ptr-&gt;in(1)-&gt;in(0)-&gt;in(0);
 995         continue;
 996       }
 997 #ifndef PRODUCT
 998       if (PrintOptimizeStringConcat) {
 999         tty-&gt;print_cr(&quot;fusion would fail for region&quot;);
1000         _begin-&gt;dump();
1001         ptr-&gt;dump(2);
1002       }
1003 #endif
1004       fail = true;
1005       break;
1006     } else {
1007       // other unknown control
1008       if (!fail) {
1009 #ifndef PRODUCT
1010         if (PrintOptimizeStringConcat) {
1011           tty-&gt;print_cr(&quot;fusion would fail for&quot;);
1012           _begin-&gt;dump();
1013         }
1014 #endif
1015         fail = true;
1016       }
1017 #ifndef PRODUCT
1018       if (PrintOptimizeStringConcat) {
1019         ptr-&gt;dump();
1020       }
1021 #endif
1022       ptr = ptr-&gt;in(0);
1023     }
1024   }
1025 #ifndef PRODUCT
1026   if (PrintOptimizeStringConcat &amp;&amp; fail) {
1027     tty-&gt;cr();
1028   }
1029 #endif
1030   if (fail) return !fail;
1031 
1032   // Validate that all these results produced are contained within
1033   // this cluster of objects.  First collect all the results produced
1034   // by calls in the region.
1035   _stringopts-&gt;_visited.clear();
1036   Node_List worklist;
1037   Node* final_result = _end-&gt;proj_out_or_null(TypeFunc::Parms);
1038   for (uint i = 0; i &lt; _control.size(); i++) {
1039     CallNode* cnode = _control.at(i)-&gt;isa_Call();
1040     if (cnode != NULL) {
1041       _stringopts-&gt;_visited.test_set(cnode-&gt;_idx);
1042     }
1043     Node* result = cnode != NULL ? cnode-&gt;proj_out_or_null(TypeFunc::Parms) : NULL;
1044     if (result != NULL &amp;&amp; result != final_result) {
1045       worklist.push(result);
1046     }
1047   }
1048 
1049   Node* last_result = NULL;
1050   while (worklist.size() &gt; 0) {
1051     Node* result = worklist.pop();
1052     if (_stringopts-&gt;_visited.test_set(result-&gt;_idx))
1053       continue;
1054     for (SimpleDUIterator i(result); i.has_next(); i.next()) {
1055       Node *use = i.get();
1056       if (ctrl_path.member(use)) {
1057         // already checked this
1058         continue;
1059       }
1060       int opc = use-&gt;Opcode();
1061       if (opc == Op_CmpP || opc == Op_Node) {
1062         ctrl_path.push(use);
1063         continue;
1064       }
1065       if (opc == Op_CastPP || opc == Op_CheckCastPP) {
1066         for (SimpleDUIterator j(use); j.has_next(); j.next()) {
1067           worklist.push(j.get());
1068         }
1069         worklist.push(use-&gt;in(1));
1070         ctrl_path.push(use);
1071         continue;
1072       }
1073 #ifndef PRODUCT
1074       if (PrintOptimizeStringConcat) {
1075         if (result != last_result) {
1076           last_result = result;
1077           tty-&gt;print_cr(&quot;extra uses for result:&quot;);
1078           last_result-&gt;dump();
1079         }
1080         use-&gt;dump();
1081       }
1082 #endif
1083       fail = true;
1084       break;
1085     }
1086   }
1087 
1088 #ifndef PRODUCT
1089   if (PrintOptimizeStringConcat &amp;&amp; !fail) {
1090     ttyLocker ttyl;
1091     tty-&gt;cr();
1092     tty-&gt;print(&quot;fusion has correct control flow (%d %d) for &quot;, null_check_count, _uncommon_traps.size());
1093     _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
1094     for (int i = 0; i &lt; num_arguments(); i++) {
1095       argument(i)-&gt;dump();
1096     }
1097     _control.dump();
1098     tty-&gt;cr();
1099   }
1100 #endif
1101 
1102   return !fail;
1103 }
1104 
1105 Node* PhaseStringOpts::fetch_static_field(GraphKit&amp; kit, ciField* field) {
1106   const TypeInstPtr* mirror_type = TypeInstPtr::make(field-&gt;holder()-&gt;java_mirror());
1107   Node* klass_node = __ makecon(mirror_type);
1108   BasicType bt = field-&gt;layout_type();
1109   ciType* field_klass = field-&gt;type();
1110 
1111   const Type *type;
1112   if( bt == T_OBJECT ) {
1113     if (!field-&gt;type()-&gt;is_loaded()) {
1114       type = TypeInstPtr::BOTTOM;
1115     } else if (field-&gt;is_static_constant()) {
1116       // This can happen if the constant oop is non-perm.
1117       ciObject* con = field-&gt;constant_value().as_object();
1118       // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
1119       // and may yield a vacuous result if the field is of interface type.
1120       type = TypeOopPtr::make_from_constant(con, true)-&gt;isa_oopptr();
1121       assert(type != NULL, &quot;field singleton type must be consistent&quot;);
1122       return __ makecon(type);
1123     } else {
1124       type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
1125     }
1126   } else {
1127     type = Type::get_const_basic_type(bt);
1128   }
1129 
1130   return kit.make_load(NULL, kit.basic_plus_adr(klass_node, field-&gt;offset_in_bytes()),
1131                        type, T_OBJECT,
1132                        C-&gt;get_alias_index(mirror_type-&gt;add_offset(field-&gt;offset_in_bytes())),
1133                        MemNode::unordered);
1134 }
1135 
1136 Node* PhaseStringOpts::int_stringSize(GraphKit&amp; kit, Node* arg) {
1137   if (arg-&gt;is_Con()) {
1138     // Constant integer. Compute constant length using Integer.sizeTable
1139     int arg_val = arg-&gt;get_int();
1140     int count = 1;
1141     if (arg_val &lt; 0) {
1142       arg_val = -arg_val;
1143       count++;
1144     }
1145 
1146     ciArray* size_table = (ciArray*)size_table_field-&gt;constant_value().as_object();
1147     for (int i = 0; i &lt; size_table-&gt;length(); i++) {
1148       if (arg_val &lt;= size_table-&gt;element_value(i).as_int()) {
1149         count += i;
1150         break;
1151       }
1152     }
1153     return __ intcon(count);
1154   }
1155 
1156   RegionNode *final_merge = new RegionNode(3);
1157   kit.gvn().set_type(final_merge, Type::CONTROL);
1158   Node* final_size = new PhiNode(final_merge, TypeInt::INT);
1159   kit.gvn().set_type(final_size, TypeInt::INT);
1160 
1161   IfNode* iff = kit.create_and_map_if(kit.control(),
1162                                       __ Bool(__ CmpI(arg, __ intcon(0x80000000)), BoolTest::ne),
1163                                       PROB_FAIR, COUNT_UNKNOWN);
1164   Node* is_min = __ IfFalse(iff);
1165   final_merge-&gt;init_req(1, is_min);
1166   final_size-&gt;init_req(1, __ intcon(11));
1167 
1168   kit.set_control(__ IfTrue(iff));
1169   if (kit.stopped()) {
1170     final_merge-&gt;init_req(2, C-&gt;top());
1171     final_size-&gt;init_req(2, C-&gt;top());
1172   } else {
1173 
1174     // int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i);
1175     RegionNode *r = new RegionNode(3);
1176     kit.gvn().set_type(r, Type::CONTROL);
1177     Node *phi = new PhiNode(r, TypeInt::INT);
1178     kit.gvn().set_type(phi, TypeInt::INT);
1179     Node *size = new PhiNode(r, TypeInt::INT);
1180     kit.gvn().set_type(size, TypeInt::INT);
1181     Node* chk = __ CmpI(arg, __ intcon(0));
1182     Node* p = __ Bool(chk, BoolTest::lt);
1183     IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_FAIR, COUNT_UNKNOWN);
1184     Node* lessthan = __ IfTrue(iff);
1185     Node* greaterequal = __ IfFalse(iff);
1186     r-&gt;init_req(1, lessthan);
1187     phi-&gt;init_req(1, __ SubI(__ intcon(0), arg));
1188     size-&gt;init_req(1, __ intcon(1));
1189     r-&gt;init_req(2, greaterequal);
1190     phi-&gt;init_req(2, arg);
1191     size-&gt;init_req(2, __ intcon(0));
1192     kit.set_control(r);
1193     C-&gt;record_for_igvn(r);
1194     C-&gt;record_for_igvn(phi);
1195     C-&gt;record_for_igvn(size);
1196 
1197     // for (int i=0; ; i++)
1198     //   if (x &lt;= sizeTable[i])
1199     //     return i+1;
1200 
1201     // Add loop predicate first.
1202     kit.add_empty_predicates();
1203 
1204     RegionNode *loop = new RegionNode(3);
1205     loop-&gt;init_req(1, kit.control());
1206     kit.gvn().set_type(loop, Type::CONTROL);
1207 
1208     Node *index = new PhiNode(loop, TypeInt::INT);
1209     index-&gt;init_req(1, __ intcon(0));
1210     kit.gvn().set_type(index, TypeInt::INT);
1211     kit.set_control(loop);
1212     Node* sizeTable = fetch_static_field(kit, size_table_field);
1213 
1214     Node* value = kit.load_array_element(NULL, sizeTable, index, TypeAryPtr::INTS);
1215     C-&gt;record_for_igvn(value);
1216     Node* limit = __ CmpI(phi, value);
1217     Node* limitb = __ Bool(limit, BoolTest::le);
1218     IfNode* iff2 = kit.create_and_map_if(kit.control(), limitb, PROB_MIN, COUNT_UNKNOWN);
1219     Node* lessEqual = __ IfTrue(iff2);
1220     Node* greater = __ IfFalse(iff2);
1221 
1222     loop-&gt;init_req(2, greater);
1223     index-&gt;init_req(2, __ AddI(index, __ intcon(1)));
1224 
1225     kit.set_control(lessEqual);
1226     C-&gt;record_for_igvn(loop);
1227     C-&gt;record_for_igvn(index);
1228 
1229     final_merge-&gt;init_req(2, kit.control());
1230     final_size-&gt;init_req(2, __ AddI(__ AddI(index, size), __ intcon(1)));
1231   }
1232 
1233   kit.set_control(final_merge);
1234   C-&gt;record_for_igvn(final_merge);
1235   C-&gt;record_for_igvn(final_size);
1236 
1237   return final_size;
1238 }
1239 
1240 // Simplified version of Integer.getChars
1241 void PhaseStringOpts::getChars(GraphKit&amp; kit, Node* arg, Node* dst_array, BasicType bt, Node* end, Node* final_merge, Node* final_mem, int merge_index) {
1242   // if (i &lt; 0) {
1243   //     sign = &#39;-&#39;;
1244   //     i = -i;
1245   // }
1246   IfNode* iff = kit.create_and_map_if(kit.control(), __ Bool(__ CmpI(arg, __ intcon(0)), BoolTest::lt),
1247                                       PROB_FAIR, COUNT_UNKNOWN);
1248 
1249   RegionNode* merge = new RegionNode(3);
1250   kit.gvn().set_type(merge, Type::CONTROL);
1251   Node* i = new PhiNode(merge, TypeInt::INT);
1252   kit.gvn().set_type(i, TypeInt::INT);
1253   Node* sign = new PhiNode(merge, TypeInt::INT);
1254   kit.gvn().set_type(sign, TypeInt::INT);
1255 
1256   merge-&gt;init_req(1, __ IfTrue(iff));
1257   i-&gt;init_req(1, __ SubI(__ intcon(0), arg));
1258   sign-&gt;init_req(1, __ intcon(&#39;-&#39;));
1259   merge-&gt;init_req(2, __ IfFalse(iff));
1260   i-&gt;init_req(2, arg);
1261   sign-&gt;init_req(2, __ intcon(0));
1262 
1263   kit.set_control(merge);
1264 
1265   C-&gt;record_for_igvn(merge);
1266   C-&gt;record_for_igvn(i);
1267   C-&gt;record_for_igvn(sign);
1268 
1269   // for (;;) {
1270   //     q = i / 10;
1271   //     r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1));  // r = i-(q*10) ...
1272   //     buf [--charPos] = digits [r];
1273   //     i = q;
1274   //     if (i == 0) break;
1275   // }
1276 
1277   // Add loop predicate first.
1278   kit.add_empty_predicates();
1279 
1280   RegionNode* head = new RegionNode(3);
1281   head-&gt;init_req(1, kit.control());
1282 
1283   kit.gvn().set_type(head, Type::CONTROL);
1284   Node* i_phi = new PhiNode(head, TypeInt::INT);
1285   i_phi-&gt;init_req(1, i);
1286   kit.gvn().set_type(i_phi, TypeInt::INT);
1287   Node* charPos = new PhiNode(head, TypeInt::INT);
1288   charPos-&gt;init_req(1, end);
1289   kit.gvn().set_type(charPos, TypeInt::INT);
1290   Node* mem = PhiNode::make(head, kit.memory(byte_adr_idx), Type::MEMORY, TypeAryPtr::BYTES);
1291   kit.gvn().set_type(mem, Type::MEMORY);
1292 
1293   kit.set_control(head);
1294   kit.set_memory(mem, byte_adr_idx);
1295 
1296   Node* q = __ DivI(kit.null(), i_phi, __ intcon(10));
1297   Node* r = __ SubI(i_phi, __ AddI(__ LShiftI(q, __ intcon(3)),
1298                                    __ LShiftI(q, __ intcon(1))));
1299   Node* index = __ SubI(charPos, __ intcon((bt == T_BYTE) ? 1 : 2));
1300   Node* ch = __ AddI(r, __ intcon(&#39;0&#39;));
1301   Node* st = __ store_to_memory(kit.control(), kit.array_element_address(dst_array, index, T_BYTE),
1302                                 ch, bt, byte_adr_idx, MemNode::unordered, (bt != T_BYTE) /* mismatched */);
1303 
1304   iff = kit.create_and_map_if(head, __ Bool(__ CmpI(q, __ intcon(0)), BoolTest::ne),
1305                               PROB_FAIR, COUNT_UNKNOWN);
1306   Node* ne = __ IfTrue(iff);
1307   Node* eq = __ IfFalse(iff);
1308 
1309   head-&gt;init_req(2, ne);
1310   mem-&gt;init_req(2, st);
1311 
1312   i_phi-&gt;init_req(2, q);
1313   charPos-&gt;init_req(2, index);
1314   charPos = index;
1315 
1316   kit.set_control(eq);
1317   kit.set_memory(st, byte_adr_idx);
1318 
1319   C-&gt;record_for_igvn(head);
1320   C-&gt;record_for_igvn(mem);
1321   C-&gt;record_for_igvn(i_phi);
1322   C-&gt;record_for_igvn(charPos);
1323 
1324   // if (sign != 0) {
1325   //     buf [--charPos] = sign;
1326   // }
1327   iff = kit.create_and_map_if(kit.control(), __ Bool(__ CmpI(sign, __ intcon(0)), BoolTest::ne),
1328                               PROB_FAIR, COUNT_UNKNOWN);
1329 
1330   final_merge-&gt;init_req(merge_index + 2, __ IfFalse(iff));
1331   final_mem-&gt;init_req(merge_index + 2, kit.memory(byte_adr_idx));
1332 
1333   kit.set_control(__ IfTrue(iff));
1334   if (kit.stopped()) {
1335     final_merge-&gt;init_req(merge_index + 1, C-&gt;top());
1336     final_mem-&gt;init_req(merge_index + 1, C-&gt;top());
1337   } else {
1338     Node* index = __ SubI(charPos, __ intcon((bt == T_BYTE) ? 1 : 2));
1339     st = __ store_to_memory(kit.control(), kit.array_element_address(dst_array, index, T_BYTE),
1340                             sign, bt, byte_adr_idx, MemNode::unordered, (bt != T_BYTE) /* mismatched */);
1341 
1342     final_merge-&gt;init_req(merge_index + 1, kit.control());
1343     final_mem-&gt;init_req(merge_index + 1, st);
1344   }
1345 }
1346 
1347 // Copy the characters representing arg into dst_array starting at start
1348 Node* PhaseStringOpts::int_getChars(GraphKit&amp; kit, Node* arg, Node* dst_array, Node* dst_coder, Node* start, Node* size) {
1349   bool dcon = dst_coder-&gt;is_Con();
1350   bool dbyte = dcon ? (dst_coder-&gt;get_int() == java_lang_String::CODER_LATIN1) : false;
1351   Node* end = __ AddI(start, __ LShiftI(size, dst_coder));
1352 
1353   // The final_merge node has 4 entries in case the encoding is known:
1354   // (0) Control, (1) result w/ sign, (2) result w/o sign, (3) result for Integer.min_value
1355   // or 6 entries in case the encoding is not known:
1356   // (0) Control, (1) Latin1 w/ sign, (2) Latin1 w/o sign, (3) min_value, (4) UTF16 w/ sign, (5) UTF16 w/o sign
1357   RegionNode* final_merge = new RegionNode(dcon ? 4 : 6);
1358   kit.gvn().set_type(final_merge, Type::CONTROL);
1359 
1360   Node* final_mem = PhiNode::make(final_merge, kit.memory(byte_adr_idx), Type::MEMORY, TypeAryPtr::BYTES);
1361   kit.gvn().set_type(final_mem, Type::MEMORY);
1362 
1363   // need to handle arg == Integer.MIN_VALUE specially because negating doesn&#39;t make it positive
1364   IfNode* iff = kit.create_and_map_if(kit.control(), __ Bool(__ CmpI(arg, __ intcon(0x80000000)), BoolTest::ne),
1365                                       PROB_FAIR, COUNT_UNKNOWN);
1366 
1367   Node* old_mem = kit.memory(byte_adr_idx);
1368 
1369   kit.set_control(__ IfFalse(iff));
1370   if (kit.stopped()) {
1371     // Statically not equal to MIN_VALUE so this path is dead
1372     final_merge-&gt;init_req(3, kit.control());
1373   } else {
1374     copy_string(kit, __ makecon(TypeInstPtr::make(C-&gt;env()-&gt;the_min_jint_string())),
1375                 dst_array, dst_coder, start);
1376     final_merge-&gt;init_req(3, kit.control());
1377     final_mem-&gt;init_req(3, kit.memory(byte_adr_idx));
1378   }
1379 
1380   kit.set_control(__ IfTrue(iff));
1381   kit.set_memory(old_mem, byte_adr_idx);
1382 
1383   if (!dcon) {
1384     // Check encoding of destination
1385     iff = kit.create_and_map_if(kit.control(), __ Bool(__ CmpI(dst_coder, __ intcon(0)), BoolTest::eq),
1386                                 PROB_FAIR, COUNT_UNKNOWN);
1387     old_mem = kit.memory(byte_adr_idx);
1388   }
1389   if (!dcon || dbyte) {
1390     // Destination is Latin1,
1391     if (!dcon) {
1392       kit.set_control(__ IfTrue(iff));
1393     }
1394     getChars(kit, arg, dst_array, T_BYTE, end, final_merge, final_mem);
1395   }
1396   if (!dcon || !dbyte) {
1397     // Destination is UTF16
1398     int merge_index = 0;
1399     if (!dcon) {
1400       kit.set_control(__ IfFalse(iff));
1401       kit.set_memory(old_mem, byte_adr_idx);
1402       merge_index = 3; // Account for Latin1 case
1403     }
1404     getChars(kit, arg, dst_array, T_CHAR, end, final_merge, final_mem, merge_index);
1405   }
1406 
1407   // Final merge point for Latin1 and UTF16 case
1408   kit.set_control(final_merge);
1409   kit.set_memory(final_mem, byte_adr_idx);
1410 
1411   C-&gt;record_for_igvn(final_merge);
1412   C-&gt;record_for_igvn(final_mem);
1413   return end;
1414 }
1415 
1416 // Copy &#39;count&#39; bytes/chars from src_array to dst_array starting at index start
1417 void PhaseStringOpts::arraycopy(GraphKit&amp; kit, IdealKit&amp; ideal, Node* src_array, Node* dst_array, BasicType elembt, Node* start, Node* count) {
1418   assert(elembt == T_BYTE || elembt == T_CHAR, &quot;Invalid type for arraycopy&quot;);
1419 
1420   if (elembt == T_CHAR) {
1421     // Get number of chars
1422     count = __ RShiftI(count, __ intcon(1));
1423   }
1424 
1425   Node* extra = NULL;
1426 #ifdef _LP64
1427   count = __ ConvI2L(count);
1428   extra = C-&gt;top();
1429 #endif
1430 
1431   Node* src_ptr = __ array_element_address(src_array, __ intcon(0), T_BYTE);
1432   Node* dst_ptr = __ array_element_address(dst_array, start, T_BYTE);
1433   // Check if destination address is aligned to HeapWordSize
1434   const TypeInt* tdst = __ gvn().type(start)-&gt;is_int();
1435   bool aligned = tdst-&gt;is_con() &amp;&amp; ((tdst-&gt;get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0);
1436   // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1437   const char* copyfunc_name = &quot;arraycopy&quot;;
1438   address     copyfunc_addr = StubRoutines::select_arraycopy_function(elembt, aligned, true, copyfunc_name, true);
1439   ideal.make_leaf_call_no_fp(OptoRuntime::fast_arraycopy_Type(), copyfunc_addr, copyfunc_name,
1440                              TypeAryPtr::BYTES, src_ptr, dst_ptr, count, extra);
1441 }
1442 
1443 #undef __
1444 #define __ ideal.
1445 
1446 // Copy contents of a Latin1 encoded string from src_array to dst_array
1447 void PhaseStringOpts::copy_latin1_string(GraphKit&amp; kit, IdealKit&amp; ideal, Node* src_array, IdealVariable&amp; count,
1448                                          Node* dst_array, Node* dst_coder, Node* start) {
1449   bool dcon = dst_coder-&gt;is_Con();
1450   bool dbyte = dcon ? (dst_coder-&gt;get_int() == java_lang_String::CODER_LATIN1) : false;
1451 
1452   if (!dcon) {
1453     __ if_then(dst_coder, BoolTest::eq, __ ConI(java_lang_String::CODER_LATIN1));
1454   }
1455   if (!dcon || dbyte) {
1456     // Destination is Latin1. Simply emit a byte arraycopy.
1457     arraycopy(kit, ideal, src_array, dst_array, T_BYTE, start, __ value(count));
1458   }
1459   if (!dcon) {
1460     __ else_();
1461   }
1462   if (!dcon || !dbyte) {
1463     // Destination is UTF16. Inflate src_array into dst_array.
1464     kit.sync_kit(ideal);
1465     if (Matcher::match_rule_supported(Op_StrInflatedCopy)) {
1466       // Use fast intrinsic
1467       Node* src = kit.array_element_address(src_array, kit.intcon(0), T_BYTE);
1468       Node* dst = kit.array_element_address(dst_array, start, T_BYTE);
1469       kit.inflate_string(src, dst, TypeAryPtr::BYTES, __ value(count));
1470     } else {
1471       // No intrinsic available, use slow method
1472       kit.inflate_string_slow(src_array, dst_array, start, __ value(count));
1473     }
1474     ideal.sync_kit(&amp;kit);
1475     // Multiply count by two since we now need two bytes per char
1476     __ set(count, __ LShiftI(__ value(count), __ ConI(1)));
1477   }
1478   if (!dcon) {
1479     __ end_if();
1480   }
1481 }
1482 
1483 // Read two bytes from index and index+1 and convert them to a char
1484 static jchar readChar(ciTypeArray* array, int index) {
1485   int shift_high, shift_low;
1486 #ifdef VM_LITTLE_ENDIAN
1487     shift_high = 0;
1488     shift_low = 8;
1489 #else
1490     shift_high = 8;
1491     shift_low = 0;
1492 #endif
1493 
1494   jchar b1 = ((jchar) array-&gt;byte_at(index)) &amp; 0xff;
1495   jchar b2 = ((jchar) array-&gt;byte_at(index+1)) &amp; 0xff;
1496   return (b1 &lt;&lt; shift_high) | (b2 &lt;&lt; shift_low);
1497 }
1498 
1499 // Copy contents of constant src_array to dst_array by emitting individual stores
1500 void PhaseStringOpts::copy_constant_string(GraphKit&amp; kit, IdealKit&amp; ideal, ciTypeArray* src_array, IdealVariable&amp; count,
1501                                            bool src_is_byte, Node* dst_array, Node* dst_coder, Node* start) {
1502   bool dcon = dst_coder-&gt;is_Con();
1503   bool dbyte = dcon ? (dst_coder-&gt;get_int() == java_lang_String::CODER_LATIN1) : false;
1504   int length = src_array-&gt;length();
1505 
1506   if (!dcon) {
1507     __ if_then(dst_coder, BoolTest::eq, __ ConI(java_lang_String::CODER_LATIN1));
1508   }
1509   if (!dcon || dbyte) {
1510     // Destination is Latin1. Copy each byte of src_array into dst_array.
1511     Node* index = start;
1512     for (int i = 0; i &lt; length; i++) {
1513       Node* adr = kit.array_element_address(dst_array, index, T_BYTE);
1514       Node* val = __ ConI(src_array-&gt;byte_at(i));
1515       __ store(__ ctrl(), adr, val, T_BYTE, byte_adr_idx, MemNode::unordered);
1516       index = __ AddI(index, __ ConI(1));
1517     }
1518   }
1519   if (!dcon) {
1520     __ else_();
1521   }
1522   if (!dcon || !dbyte) {
1523     // Destination is UTF16. Copy each char of src_array into dst_array.
1524     Node* index = start;
1525     for (int i = 0; i &lt; length; i++) {
1526       Node* adr = kit.array_element_address(dst_array, index, T_BYTE);
1527       jchar val;
1528       if (src_is_byte) {
1529         val = src_array-&gt;byte_at(i) &amp; 0xff;
1530       } else {
1531         val = readChar(src_array, i++);
1532       }
1533       __ store(__ ctrl(), adr, __ ConI(val), T_CHAR, byte_adr_idx, MemNode::unordered, true /* mismatched */);
1534       index = __ AddI(index, __ ConI(2));
1535     }
1536     if (src_is_byte) {
1537       // Multiply count by two since we now need two bytes per char
1538       __ set(count, __ ConI(2 * length));
1539     }
1540   }
1541   if (!dcon) {
1542     __ end_if();
1543   }
1544 }
1545 
1546 // Compress copy contents of the byte/char String str into dst_array starting at index start.
1547 Node* PhaseStringOpts::copy_string(GraphKit&amp; kit, Node* str, Node* dst_array, Node* dst_coder, Node* start) {
1548   Node* src_array = kit.load_String_value(str, true);
1549 
1550   IdealKit ideal(&amp;kit, true, true);
1551   IdealVariable count(ideal); __ declarations_done();
1552 
1553   if (str-&gt;is_Con()) {
1554     // Constant source string
1555     ciTypeArray* src_array_type = get_constant_value(kit, str);
1556 
1557     // Check encoding of constant string
1558     bool src_is_byte = (get_constant_coder(kit, str) == java_lang_String::CODER_LATIN1);
1559 
1560     // For small constant strings just emit individual stores.
1561     // A length of 6 seems like a good space/speed tradeof.
1562     __ set(count, __ ConI(src_array_type-&gt;length()));
1563     int src_len = src_array_type-&gt;length() / (src_is_byte ? 1 : 2);
1564     if (src_len &lt; unroll_string_copy_length) {
1565       // Small constant string
1566       copy_constant_string(kit, ideal, src_array_type, count, src_is_byte, dst_array, dst_coder, start);
1567     } else if (src_is_byte) {
1568       // Source is Latin1
1569       copy_latin1_string(kit, ideal, src_array, count, dst_array, dst_coder, start);
1570     } else {
1571       // Source is UTF16 (destination too). Simply emit a char arraycopy.
1572       arraycopy(kit, ideal, src_array, dst_array, T_CHAR, start, __ value(count));
1573     }
1574   } else {
1575     Node* size = kit.load_array_length(src_array);
1576     __ set(count, size);
1577     // Non-constant source string
1578     if (CompactStrings) {
1579       // Emit runtime check for coder
1580       Node* coder = kit.load_String_coder(str, true);
1581       __ if_then(coder, BoolTest::eq, __ ConI(java_lang_String::CODER_LATIN1)); {
1582         // Source is Latin1
1583         copy_latin1_string(kit, ideal, src_array, count, dst_array, dst_coder, start);
1584       } __ else_();
1585     }
1586     // Source is UTF16 (destination too). Simply emit a char arraycopy.
1587     arraycopy(kit, ideal, src_array, dst_array, T_CHAR, start, __ value(count));
1588 
1589     if (CompactStrings) {
1590       __ end_if();
1591     }
1592   }
1593 
1594   // Finally sync IdealKit and GraphKit.
1595   kit.sync_kit(ideal);
1596   return __ AddI(start, __ value(count));
1597 }
1598 
1599 // Compress copy the char into dst_array at index start.
1600 Node* PhaseStringOpts::copy_char(GraphKit&amp; kit, Node* val, Node* dst_array, Node* dst_coder, Node* start) {
1601   bool dcon = (dst_coder != NULL) &amp;&amp; dst_coder-&gt;is_Con();
1602   bool dbyte = dcon ? (dst_coder-&gt;get_int() == java_lang_String::CODER_LATIN1) : false;
1603 
1604   IdealKit ideal(&amp;kit, true, true);
1605   IdealVariable end(ideal); __ declarations_done();
1606   Node* adr = kit.array_element_address(dst_array, start, T_BYTE);
1607   if (!dcon){
1608     __ if_then(dst_coder, BoolTest::eq, __ ConI(java_lang_String::CODER_LATIN1));
1609   }
1610   if (!dcon || dbyte) {
1611     // Destination is Latin1. Store a byte.
1612     __ store(__ ctrl(), adr, val, T_BYTE, byte_adr_idx, MemNode::unordered);
1613     __ set(end, __ AddI(start, __ ConI(1)));
1614   }
1615   if (!dcon) {
1616     __ else_();
1617   }
1618   if (!dcon || !dbyte) {
1619     // Destination is UTF16. Store a char.
1620     __ store(__ ctrl(), adr, val, T_CHAR, byte_adr_idx, MemNode::unordered, true /* mismatched */);
1621     __ set(end, __ AddI(start, __ ConI(2)));
1622   }
1623   if (!dcon) {
1624     __ end_if();
1625   }
1626   // Finally sync IdealKit and GraphKit.
1627   kit.sync_kit(ideal);
1628   return __ value(end);
1629 }
1630 
1631 #undef __
1632 #define __ kit.
1633 
1634 // Allocate a byte array of specified length.
1635 Node* PhaseStringOpts::allocate_byte_array(GraphKit&amp; kit, IdealKit* ideal, Node* length) {
1636   if (ideal != NULL) {
1637     // Sync IdealKit and graphKit.
1638     kit.sync_kit(*ideal);
1639   }
1640   Node* byte_array = NULL;
1641   {
1642     PreserveReexecuteState preexecs(&amp;kit);
1643     // The original jvms is for an allocation of either a String or
1644     // StringBuffer so no stack adjustment is necessary for proper
1645     // reexecution.  If we deoptimize in the slow path the bytecode
1646     // will be reexecuted and the char[] allocation will be thrown away.
1647     kit.jvms()-&gt;set_should_reexecute(true);
1648     byte_array = kit.new_array(__ makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_BYTE))),
1649                                length, 1);
1650   }
1651 
1652   // Mark the allocation so that zeroing is skipped since the code
1653   // below will overwrite the entire array
1654   AllocateArrayNode* byte_alloc = AllocateArrayNode::Ideal_array_allocation(byte_array, _gvn);
1655   byte_alloc-&gt;maybe_set_complete(_gvn);
1656 
1657   if (ideal != NULL) {
1658     // Sync IdealKit and graphKit.
1659     ideal-&gt;sync_kit(&amp;kit);
1660   }
1661   return byte_array;
1662 }
1663 
1664 jbyte PhaseStringOpts::get_constant_coder(GraphKit&amp; kit, Node* str) {
1665   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1666   const TypeOopPtr* str_type = kit.gvn().type(str)-&gt;isa_oopptr();
1667   ciInstance* str_instance = str_type-&gt;const_oop()-&gt;as_instance();
1668   jbyte coder = str_instance-&gt;field_value_by_offset(java_lang_String::coder_offset()).as_byte();
1669   assert(CompactStrings || (coder == java_lang_String::CODER_UTF16), &quot;Strings must be UTF16 encoded&quot;);
1670   return coder;
1671 }
1672 
1673 int PhaseStringOpts::get_constant_length(GraphKit&amp; kit, Node* str) {
1674   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1675   return get_constant_value(kit, str)-&gt;length();
1676 }
1677 
1678 ciTypeArray* PhaseStringOpts::get_constant_value(GraphKit&amp; kit, Node* str) {
1679   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1680   const TypeOopPtr* str_type = kit.gvn().type(str)-&gt;isa_oopptr();
1681   ciInstance* str_instance = str_type-&gt;const_oop()-&gt;as_instance();
1682   ciObject* src_array = str_instance-&gt;field_value_by_offset(java_lang_String::value_offset()).as_object();
1683   return src_array-&gt;as_type_array();
1684 }
1685 
1686 void PhaseStringOpts::replace_string_concat(StringConcat* sc) {
1687   // Log a little info about the transformation
1688   sc-&gt;maybe_log_transform();
1689 
1690   // pull the JVMState of the allocation into a SafePointNode to serve as
1691   // as a shim for the insertion of the new code.
1692   JVMState* jvms     = sc-&gt;begin()-&gt;jvms()-&gt;clone_shallow(C);
1693   uint size = sc-&gt;begin()-&gt;req();
1694   SafePointNode* map = new SafePointNode(size, jvms);
1695 
1696   // copy the control and memory state from the final call into our
1697   // new starting state.  This allows any preceeding tests to feed
1698   // into the new section of code.
1699   for (uint i1 = 0; i1 &lt; TypeFunc::Parms; i1++) {
1700     map-&gt;init_req(i1, sc-&gt;end()-&gt;in(i1));
1701   }
1702   // blow away old allocation arguments
1703   for (uint i1 = TypeFunc::Parms; i1 &lt; jvms-&gt;debug_start(); i1++) {
1704     map-&gt;init_req(i1, C-&gt;top());
1705   }
1706   // Copy the rest of the inputs for the JVMState
1707   for (uint i1 = jvms-&gt;debug_start(); i1 &lt; sc-&gt;begin()-&gt;req(); i1++) {
1708     map-&gt;init_req(i1, sc-&gt;begin()-&gt;in(i1));
1709   }
1710   // Make sure the memory state is a MergeMem for parsing.
1711   if (!map-&gt;in(TypeFunc::Memory)-&gt;is_MergeMem()) {
1712     map-&gt;set_req(TypeFunc::Memory, MergeMemNode::make(map-&gt;in(TypeFunc::Memory)));
1713   }
1714 
1715   jvms-&gt;set_map(map);
1716   map-&gt;ensure_stack(jvms, jvms-&gt;method()-&gt;max_stack());
1717 
1718   // disconnect all the old StringBuilder calls from the graph
1719   sc-&gt;eliminate_unneeded_control();
1720 
1721   // At this point all the old work has been completely removed from
1722   // the graph and the saved JVMState exists at the point where the
1723   // final toString call used to be.
1724   GraphKit kit(jvms);
1725 
1726   // There may be uncommon traps which are still using the
1727   // intermediate states and these need to be rewritten to point at
1728   // the JVMState at the beginning of the transformation.
1729   sc-&gt;convert_uncommon_traps(kit, jvms);
1730 
1731   // Now insert the logic to compute the size of the string followed
1732   // by all the logic to construct array and resulting string.
1733 
1734   Node* null_string = __ makecon(TypeInstPtr::make(C-&gt;env()-&gt;the_null_string()));
1735 
1736   // Create a region for the overflow checks to merge into.
1737   int args = MAX2(sc-&gt;num_arguments(), 1);
1738   RegionNode* overflow = new RegionNode(args);
1739   kit.gvn().set_type(overflow, Type::CONTROL);
1740 
1741   // Create a hook node to hold onto the individual sizes since they
1742   // are need for the copying phase.
1743   Node* string_sizes = new Node(args);
1744 
1745   Node* coder = __ intcon(0);
1746   Node* length = __ intcon(0);
1747   // If at least one argument is UTF16 encoded, we can fix the encoding.
1748   bool coder_fixed = false;
1749 
1750   if (!CompactStrings) {
1751     // Fix encoding of result string to UTF16
1752     coder_fixed = true;
1753     coder = __ intcon(java_lang_String::CODER_UTF16);
1754   }
1755 
1756   for (int argi = 0; argi &lt; sc-&gt;num_arguments(); argi++) {
1757     Node* arg = sc-&gt;argument(argi);
1758     switch (sc-&gt;mode(argi)) {
1759       case StringConcat::IntMode: {
1760         Node* string_size = int_stringSize(kit, arg);
1761 
1762         // accumulate total
1763         length = __ AddI(length, string_size);
1764 
1765         // Cache this value for the use by int_toString
1766         string_sizes-&gt;init_req(argi, string_size);
1767         break;
1768       }
1769       case StringConcat::StringNullCheckMode: {
1770         const Type* type = kit.gvn().type(arg);
1771         assert(type != TypePtr::NULL_PTR, &quot;missing check&quot;);
1772         if (!type-&gt;higher_equal(TypeInstPtr::NOTNULL)) {
1773           // Null check with uncommon trap since
1774           // StringBuilder(null) throws exception.
1775           // Use special uncommon trap instead of
1776           // calling normal do_null_check().
1777           Node* p = __ Bool(__ CmpP(arg, kit.null()), BoolTest::ne);
1778           IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_MIN, COUNT_UNKNOWN);
1779           overflow-&gt;add_req(__ IfFalse(iff));
1780           Node* notnull = __ IfTrue(iff);
1781           kit.set_control(notnull); // set control for the cast_not_null
1782           arg = kit.cast_not_null(arg, false);
1783           sc-&gt;set_argument(argi, arg);
1784         }
1785         assert(kit.gvn().type(arg)-&gt;higher_equal(TypeInstPtr::NOTNULL), &quot;sanity&quot;);
1786         // Fallthrough to add string length.
1787       }
1788       case StringConcat::StringMode: {
1789         const Type* type = kit.gvn().type(arg);
1790         Node* count = NULL;
1791         Node* arg_coder = NULL;
1792         if (type == TypePtr::NULL_PTR) {
1793           // replace the argument with the null checked version
1794           arg = null_string;
1795           sc-&gt;set_argument(argi, arg);
1796           count = kit.load_String_length(arg, true);
1797           arg_coder = kit.load_String_coder(arg, true);
1798         } else if (!type-&gt;higher_equal(TypeInstPtr::NOTNULL)) {
1799           // s = s != null ? s : &quot;null&quot;;
1800           // length = length + (s.count - s.offset);
1801           RegionNode *r = new RegionNode(3);
1802           kit.gvn().set_type(r, Type::CONTROL);
1803           Node *phi = new PhiNode(r, type);
1804           kit.gvn().set_type(phi, phi-&gt;bottom_type());
1805           Node* p = __ Bool(__ CmpP(arg, kit.null()), BoolTest::ne);
1806           IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_MIN, COUNT_UNKNOWN);
1807           Node* notnull = __ IfTrue(iff);
1808           Node* isnull =  __ IfFalse(iff);
1809           kit.set_control(notnull); // set control for the cast_not_null
1810           r-&gt;init_req(1, notnull);
1811           phi-&gt;init_req(1, kit.cast_not_null(arg, false));
1812           r-&gt;init_req(2, isnull);
1813           phi-&gt;init_req(2, null_string);
1814           kit.set_control(r);
1815           C-&gt;record_for_igvn(r);
1816           C-&gt;record_for_igvn(phi);
1817           // replace the argument with the null checked version
1818           arg = phi;
1819           sc-&gt;set_argument(argi, arg);
1820           count = kit.load_String_length(arg, true);
1821           arg_coder = kit.load_String_coder(arg, true);
1822         } else {
1823           // A corresponding nullcheck will be connected during IGVN MemNode::Ideal_common_DU_postCCP
1824           // kit.control might be a different test, that can be hoisted above the actual nullcheck
1825           // in case, that the control input is not null, Ideal_common_DU_postCCP will not look for a nullcheck.
1826           count = kit.load_String_length(arg, false);
1827           arg_coder = kit.load_String_coder(arg, false);
1828         }
1829         if (arg-&gt;is_Con()) {
1830           // Constant string. Get constant coder and length.
1831           jbyte const_coder = get_constant_coder(kit, arg);
1832           int const_length = get_constant_length(kit, arg);
1833           if (const_coder == java_lang_String::CODER_LATIN1) {
1834             // Can be latin1 encoded
1835             arg_coder = __ intcon(const_coder);
1836             count = __ intcon(const_length);
1837           } else {
1838             // Found UTF16 encoded string. Fix result array encoding to UTF16.
1839             coder_fixed = true;
1840             coder = __ intcon(const_coder);
1841             count = __ intcon(const_length / 2);
1842           }
1843         }
1844 
1845         if (!coder_fixed) {
1846           coder = __ OrI(coder, arg_coder);
1847         }
1848         length = __ AddI(length, count);
1849         string_sizes-&gt;init_req(argi, NULL);
1850         break;
1851       }
1852       case StringConcat::CharMode: {
1853         // one character only
1854         const TypeInt* t = kit.gvn().type(arg)-&gt;is_int();
1855         if (!coder_fixed &amp;&amp; t-&gt;is_con()) {
1856           // Constant char
1857           if (t-&gt;get_con() &lt;= 255) {
1858             // Can be latin1 encoded
1859             coder = __ OrI(coder, __ intcon(java_lang_String::CODER_LATIN1));
1860           } else {
1861             // Must be UTF16 encoded. Fix result array encoding to UTF16.
1862             coder_fixed = true;
1863             coder = __ intcon(java_lang_String::CODER_UTF16);
1864           }
1865         } else if (!coder_fixed) {
1866           // Not constant
1867 #undef __
1868 #define __ ideal.
1869           IdealKit ideal(&amp;kit, true, true);
1870           IdealVariable char_coder(ideal); __ declarations_done();
1871           // Check if character can be latin1 encoded
1872           __ if_then(arg, BoolTest::le, __ ConI(0xFF));
1873             __ set(char_coder, __ ConI(java_lang_String::CODER_LATIN1));
1874           __ else_();
1875             __ set(char_coder, __ ConI(java_lang_String::CODER_UTF16));
1876           __ end_if();
1877           kit.sync_kit(ideal);
1878           coder = __ OrI(coder, __ value(char_coder));
1879 #undef __
1880 #define __ kit.
1881         }
1882         length = __ AddI(length, __ intcon(1));
1883         break;
1884       }
1885       default:
1886         ShouldNotReachHere();
1887     }
1888     if (argi &gt; 0) {
1889       // Check that the sum hasn&#39;t overflowed
1890       IfNode* iff = kit.create_and_map_if(kit.control(),
1891                                           __ Bool(__ CmpI(length, __ intcon(0)), BoolTest::lt),
1892                                           PROB_MIN, COUNT_UNKNOWN);
1893       kit.set_control(__ IfFalse(iff));
1894       overflow-&gt;set_req(argi, __ IfTrue(iff));
1895     }
1896   }
1897 
1898   {
1899     // Hook
1900     PreserveJVMState pjvms(&amp;kit);
1901     kit.set_control(overflow);
1902     C-&gt;record_for_igvn(overflow);
1903     kit.uncommon_trap(Deoptimization::Reason_intrinsic,
1904                       Deoptimization::Action_make_not_entrant);
1905   }
1906 
1907   Node* result;
1908   if (!kit.stopped()) {
1909     assert(CompactStrings || (coder-&gt;is_Con() &amp;&amp; coder-&gt;get_int() == java_lang_String::CODER_UTF16),
1910            &quot;Result string must be UTF16 encoded if CompactStrings is disabled&quot;);
1911 
1912     Node* dst_array = NULL;
1913     if (sc-&gt;num_arguments() == 1 &amp;&amp;
1914         (sc-&gt;mode(0) == StringConcat::StringMode ||
1915          sc-&gt;mode(0) == StringConcat::StringNullCheckMode)) {
1916       // Handle the case when there is only a single String argument.
1917       // In this case, we can just pull the value from the String itself.
1918       dst_array = kit.load_String_value(sc-&gt;argument(0), true);
1919     } else {
1920       // Allocate destination byte array according to coder
1921       dst_array = allocate_byte_array(kit, NULL, __ LShiftI(length, coder));
1922 
1923       // Now copy the string representations into the final byte[]
1924       Node* start = __ intcon(0);
1925       for (int argi = 0; argi &lt; sc-&gt;num_arguments(); argi++) {
1926         Node* arg = sc-&gt;argument(argi);
1927         switch (sc-&gt;mode(argi)) {
1928           case StringConcat::IntMode: {
1929             start = int_getChars(kit, arg, dst_array, coder, start, string_sizes-&gt;in(argi));
1930             break;
1931           }
1932           case StringConcat::StringNullCheckMode:
1933           case StringConcat::StringMode: {
1934             start = copy_string(kit, arg, dst_array, coder, start);
1935             break;
1936           }
1937           case StringConcat::CharMode: {
1938             start = copy_char(kit, arg, dst_array, coder, start);
1939           break;
1940           }
1941           default:
1942             ShouldNotReachHere();
1943         }
1944       }
1945     }
1946 
1947     // If we&#39;re not reusing an existing String allocation then allocate one here.
1948     result = sc-&gt;string_alloc();
1949     if (result == NULL) {
1950       PreserveReexecuteState preexecs(&amp;kit);
1951       // The original jvms is for an allocation of either a String or
1952       // StringBuffer so no stack adjustment is necessary for proper
1953       // reexecution.
1954       kit.jvms()-&gt;set_should_reexecute(true);
1955       result = kit.new_instance(__ makecon(TypeKlassPtr::make(C-&gt;env()-&gt;String_klass())));
1956     }
1957 
1958     // Initialize the string
1959     kit.store_String_value(result, dst_array);
1960     kit.store_String_coder(result, coder);
1961 
1962     // The value field is final. Emit a barrier here to ensure that the effect
1963     // of the initialization is committed to memory before any code publishes
1964     // a reference to the newly constructed object (see Parse::do_exits()).
1965     assert(AllocateNode::Ideal_allocation(result, _gvn) != NULL, &quot;should be newly allocated&quot;);
1966     kit.insert_mem_bar(Op_MemBarRelease, result);
1967   } else {
1968     result = C-&gt;top();
1969   }
1970   // hook up the outgoing control and result
1971   kit.replace_call(sc-&gt;end(), result);
1972 
1973   // Unhook any hook nodes
1974   string_sizes-&gt;disconnect_inputs(NULL, C);
1975   sc-&gt;cleanup();
1976 }
    </pre>
  </body>
</html>