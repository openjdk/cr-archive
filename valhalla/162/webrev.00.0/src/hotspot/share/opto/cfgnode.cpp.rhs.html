<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/cfgnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;gc/shared/barrierSet.hpp&quot;
  28 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;oops/objArrayKlass.hpp&quot;
  32 #include &quot;opto/addnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/cfgnode.hpp&quot;
  35 #include &quot;opto/connode.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/inlinetypenode.hpp&quot;
  38 #include &quot;opto/loopnode.hpp&quot;
  39 #include &quot;opto/machnode.hpp&quot;
  40 #include &quot;opto/movenode.hpp&quot;
  41 #include &quot;opto/narrowptrnode.hpp&quot;
  42 #include &quot;opto/mulnode.hpp&quot;
  43 #include &quot;opto/phaseX.hpp&quot;
  44 #include &quot;opto/regmask.hpp&quot;
  45 #include &quot;opto/runtime.hpp&quot;
  46 #include &quot;opto/subnode.hpp&quot;
  47 #include &quot;utilities/vmError.hpp&quot;
  48 
  49 // Portions of code courtesy of Clifford Click
  50 
  51 // Optimization - Graph Style
  52 
  53 //=============================================================================
  54 //------------------------------Value------------------------------------------
  55 // Compute the type of the RegionNode.
  56 const Type* RegionNode::Value(PhaseGVN* phase) const {
  57   for( uint i=1; i&lt;req(); ++i ) {       // For all paths in
  58     Node *n = in(i);            // Get Control source
  59     if( !n ) continue;          // Missing inputs are TOP
  60     if( phase-&gt;type(n) == Type::CONTROL )
  61       return Type::CONTROL;
  62   }
  63   return Type::TOP;             // All paths dead?  Then so are we
  64 }
  65 
  66 //------------------------------Identity---------------------------------------
  67 // Check for Region being Identity.
  68 Node* RegionNode::Identity(PhaseGVN* phase) {
  69   // Cannot have Region be an identity, even if it has only 1 input.
  70   // Phi users cannot have their Region input folded away for them,
  71   // since they need to select the proper data input
  72   return this;
  73 }
  74 
  75 //------------------------------merge_region-----------------------------------
  76 // If a Region flows into a Region, merge into one big happy merge.  This is
  77 // hard to do if there is stuff that has to happen
  78 static Node *merge_region(RegionNode *region, PhaseGVN *phase) {
  79   if( region-&gt;Opcode() != Op_Region ) // Do not do to LoopNodes
  80     return NULL;
  81   Node *progress = NULL;        // Progress flag
  82   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
  83 
  84   uint rreq = region-&gt;req();
  85   for( uint i = 1; i &lt; rreq; i++ ) {
  86     Node *r = region-&gt;in(i);
  87     if( r &amp;&amp; r-&gt;Opcode() == Op_Region &amp;&amp; // Found a region?
  88         r-&gt;in(0) == r &amp;&amp;        // Not already collapsed?
  89         r != region &amp;&amp;          // Avoid stupid situations
  90         r-&gt;outcnt() == 2 ) {    // Self user and &#39;region&#39; user only?
  91       assert(!r-&gt;as_Region()-&gt;has_phi(), &quot;no phi users&quot;);
  92       if( !progress ) {         // No progress
  93         if (region-&gt;has_phi()) {
  94           return NULL;        // Only flatten if no Phi users
  95           // igvn-&gt;hash_delete( phi );
  96         }
  97         igvn-&gt;hash_delete( region );
  98         progress = region;      // Making progress
  99       }
 100       igvn-&gt;hash_delete( r );
 101 
 102       // Append inputs to &#39;r&#39; onto &#39;region&#39;
 103       for( uint j = 1; j &lt; r-&gt;req(); j++ ) {
 104         // Move an input from &#39;r&#39; to &#39;region&#39;
 105         region-&gt;add_req(r-&gt;in(j));
 106         r-&gt;set_req(j, phase-&gt;C-&gt;top());
 107         // Update phis of &#39;region&#39;
 108         //for( uint k = 0; k &lt; max; k++ ) {
 109         //  Node *phi = region-&gt;out(k);
 110         //  if( phi-&gt;is_Phi() ) {
 111         //    phi-&gt;add_req(phi-&gt;in(i));
 112         //  }
 113         //}
 114 
 115         rreq++;                 // One more input to Region
 116       } // Found a region to merge into Region
 117       igvn-&gt;_worklist.push(r);
 118       // Clobber pointer to the now dead &#39;r&#39;
 119       region-&gt;set_req(i, phase-&gt;C-&gt;top());
 120     }
 121   }
 122 
 123   return progress;
 124 }
 125 
 126 
 127 
 128 //--------------------------------has_phi--------------------------------------
 129 // Helper function: Return any PhiNode that uses this region or NULL
 130 PhiNode* RegionNode::has_phi() const {
 131   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 132     Node* phi = fast_out(i);
 133     if (phi-&gt;is_Phi()) {   // Check for Phi users
 134       assert(phi-&gt;in(0) == (Node*)this, &quot;phi uses region only via in(0)&quot;);
 135       return phi-&gt;as_Phi();  // this one is good enough
 136     }
 137   }
 138 
 139   return NULL;
 140 }
 141 
 142 
 143 //-----------------------------has_unique_phi----------------------------------
 144 // Helper function: Return the only PhiNode that uses this region or NULL
 145 PhiNode* RegionNode::has_unique_phi() const {
 146   // Check that only one use is a Phi
 147   PhiNode* only_phi = NULL;
 148   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 149     Node* phi = fast_out(i);
 150     if (phi-&gt;is_Phi()) {   // Check for Phi users
 151       assert(phi-&gt;in(0) == (Node*)this, &quot;phi uses region only via in(0)&quot;);
 152       if (only_phi == NULL) {
 153         only_phi = phi-&gt;as_Phi();
 154       } else {
 155         return NULL;  // multiple phis
 156       }
 157     }
 158   }
 159 
 160   return only_phi;
 161 }
 162 
 163 
 164 //------------------------------check_phi_clipping-----------------------------
 165 // Helper function for RegionNode&#39;s identification of FP clipping
 166 // Check inputs to the Phi
 167 static bool check_phi_clipping( PhiNode *phi, ConNode * &amp;min, uint &amp;min_idx, ConNode * &amp;max, uint &amp;max_idx, Node * &amp;val, uint &amp;val_idx ) {
 168   min     = NULL;
 169   max     = NULL;
 170   val     = NULL;
 171   min_idx = 0;
 172   max_idx = 0;
 173   val_idx = 0;
 174   uint  phi_max = phi-&gt;req();
 175   if( phi_max == 4 ) {
 176     for( uint j = 1; j &lt; phi_max; ++j ) {
 177       Node *n = phi-&gt;in(j);
 178       int opcode = n-&gt;Opcode();
 179       switch( opcode ) {
 180       case Op_ConI:
 181         {
 182           if( min == NULL ) {
 183             min     = n-&gt;Opcode() == Op_ConI ? (ConNode*)n : NULL;
 184             min_idx = j;
 185           } else {
 186             max     = n-&gt;Opcode() == Op_ConI ? (ConNode*)n : NULL;
 187             max_idx = j;
 188             if( min-&gt;get_int() &gt; max-&gt;get_int() ) {
 189               // Swap min and max
 190               ConNode *temp;
 191               uint     temp_idx;
 192               temp     = min;     min     = max;     max     = temp;
 193               temp_idx = min_idx; min_idx = max_idx; max_idx = temp_idx;
 194             }
 195           }
 196         }
 197         break;
 198       default:
 199         {
 200           val = n;
 201           val_idx = j;
 202         }
 203         break;
 204       }
 205     }
 206   }
 207   return ( min &amp;&amp; max &amp;&amp; val &amp;&amp; (min-&gt;get_int() &lt;= 0) &amp;&amp; (max-&gt;get_int() &gt;=0) );
 208 }
 209 
 210 
 211 //------------------------------check_if_clipping------------------------------
 212 // Helper function for RegionNode&#39;s identification of FP clipping
 213 // Check that inputs to Region come from two IfNodes,
 214 //
 215 //            If
 216 //      False    True
 217 //       If        |
 218 //  False  True    |
 219 //    |      |     |
 220 //  RegionNode_inputs
 221 //
 222 static bool check_if_clipping( const RegionNode *region, IfNode * &amp;bot_if, IfNode * &amp;top_if ) {
 223   top_if = NULL;
 224   bot_if = NULL;
 225 
 226   // Check control structure above RegionNode for (if  ( if  ) )
 227   Node *in1 = region-&gt;in(1);
 228   Node *in2 = region-&gt;in(2);
 229   Node *in3 = region-&gt;in(3);
 230   // Check that all inputs are projections
 231   if( in1-&gt;is_Proj() &amp;&amp; in2-&gt;is_Proj() &amp;&amp; in3-&gt;is_Proj() ) {
 232     Node *in10 = in1-&gt;in(0);
 233     Node *in20 = in2-&gt;in(0);
 234     Node *in30 = in3-&gt;in(0);
 235     // Check that #1 and #2 are ifTrue and ifFalse from same If
 236     if( in10 != NULL &amp;&amp; in10-&gt;is_If() &amp;&amp;
 237         in20 != NULL &amp;&amp; in20-&gt;is_If() &amp;&amp;
 238         in30 != NULL &amp;&amp; in30-&gt;is_If() &amp;&amp; in10 == in20 &amp;&amp;
 239         (in1-&gt;Opcode() != in2-&gt;Opcode()) ) {
 240       Node  *in100 = in10-&gt;in(0);
 241       Node *in1000 = (in100 != NULL &amp;&amp; in100-&gt;is_Proj()) ? in100-&gt;in(0) : NULL;
 242       // Check that control for in10 comes from other branch of IF from in3
 243       if( in1000 != NULL &amp;&amp; in1000-&gt;is_If() &amp;&amp;
 244           in30 == in1000 &amp;&amp; (in3-&gt;Opcode() != in100-&gt;Opcode()) ) {
 245         // Control pattern checks
 246         top_if = (IfNode*)in1000;
 247         bot_if = (IfNode*)in10;
 248       }
 249     }
 250   }
 251 
 252   return (top_if != NULL);
 253 }
 254 
 255 
 256 //------------------------------check_convf2i_clipping-------------------------
 257 // Helper function for RegionNode&#39;s identification of FP clipping
 258 // Verify that the value input to the phi comes from &quot;ConvF2I; LShift; RShift&quot;
 259 static bool check_convf2i_clipping( PhiNode *phi, uint idx, ConvF2INode * &amp;convf2i, Node *min, Node *max) {
 260   convf2i = NULL;
 261 
 262   // Check for the RShiftNode
 263   Node *rshift = phi-&gt;in(idx);
 264   assert( rshift, &quot;Previous checks ensure phi input is present&quot;);
 265   if( rshift-&gt;Opcode() != Op_RShiftI )  { return false; }
 266 
 267   // Check for the LShiftNode
 268   Node *lshift = rshift-&gt;in(1);
 269   assert( lshift, &quot;Previous checks ensure phi input is present&quot;);
 270   if( lshift-&gt;Opcode() != Op_LShiftI )  { return false; }
 271 
 272   // Check for the ConvF2INode
 273   Node *conv = lshift-&gt;in(1);
 274   if( conv-&gt;Opcode() != Op_ConvF2I ) { return false; }
 275 
 276   // Check that shift amounts are only to get sign bits set after F2I
 277   jint max_cutoff     = max-&gt;get_int();
 278   jint min_cutoff     = min-&gt;get_int();
 279   jint left_shift     = lshift-&gt;in(2)-&gt;get_int();
 280   jint right_shift    = rshift-&gt;in(2)-&gt;get_int();
 281   jint max_post_shift = nth_bit(BitsPerJavaInteger - left_shift - 1);
 282   if( left_shift != right_shift ||
 283       0 &gt; left_shift || left_shift &gt;= BitsPerJavaInteger ||
 284       max_post_shift &lt; max_cutoff ||
 285       max_post_shift &lt; -min_cutoff ) {
 286     // Shifts are necessary but current transformation eliminates them
 287     return false;
 288   }
 289 
 290   // OK to return the result of ConvF2I without shifting
 291   convf2i = (ConvF2INode*)conv;
 292   return true;
 293 }
 294 
 295 
 296 //------------------------------check_compare_clipping-------------------------
 297 // Helper function for RegionNode&#39;s identification of FP clipping
 298 static bool check_compare_clipping( bool less_than, IfNode *iff, ConNode *limit, Node * &amp; input ) {
 299   Node *i1 = iff-&gt;in(1);
 300   if ( !i1-&gt;is_Bool() ) { return false; }
 301   BoolNode *bool1 = i1-&gt;as_Bool();
 302   if(       less_than &amp;&amp; bool1-&gt;_test._test != BoolTest::le ) { return false; }
 303   else if( !less_than &amp;&amp; bool1-&gt;_test._test != BoolTest::lt ) { return false; }
 304   const Node *cmpF = bool1-&gt;in(1);
 305   if( cmpF-&gt;Opcode() != Op_CmpF )      { return false; }
 306   // Test that the float value being compared against
 307   // is equivalent to the int value used as a limit
 308   Node *nodef = cmpF-&gt;in(2);
 309   if( nodef-&gt;Opcode() != Op_ConF ) { return false; }
 310   jfloat conf = nodef-&gt;getf();
 311   jint   coni = limit-&gt;get_int();
 312   if( ((int)conf) != coni )        { return false; }
 313   input = cmpF-&gt;in(1);
 314   return true;
 315 }
 316 
 317 //------------------------------is_unreachable_region--------------------------
 318 // Find if the Region node is reachable from the root.
 319 bool RegionNode::is_unreachable_region(PhaseGVN *phase) const {
 320   assert(req() == 2, &quot;&quot;);
 321 
 322   // First, cut the simple case of fallthrough region when NONE of
 323   // region&#39;s phis references itself directly or through a data node.
 324   uint max = outcnt();
 325   uint i;
 326   for (i = 0; i &lt; max; i++) {
 327     Node* phi = raw_out(i);
 328     if (phi != NULL &amp;&amp; phi-&gt;is_Phi()) {
 329       assert(phase-&gt;eqv(phi-&gt;in(0), this) &amp;&amp; phi-&gt;req() == 2, &quot;&quot;);
 330       if (phi-&gt;outcnt() == 0)
 331         continue; // Safe case - no loops
 332       if (phi-&gt;outcnt() == 1) {
 333         Node* u = phi-&gt;raw_out(0);
 334         // Skip if only one use is an other Phi or Call or Uncommon trap.
 335         // It is safe to consider this case as fallthrough.
 336         if (u != NULL &amp;&amp; (u-&gt;is_Phi() || u-&gt;is_CFG()))
 337           continue;
 338       }
 339       // Check when phi references itself directly or through an other node.
 340       if (phi-&gt;as_Phi()-&gt;simple_data_loop_check(phi-&gt;in(1)) &gt;= PhiNode::Unsafe)
 341         break; // Found possible unsafe data loop.
 342     }
 343   }
 344   if (i &gt;= max)
 345     return false; // An unsafe case was NOT found - don&#39;t need graph walk.
 346 
 347   // Unsafe case - check if the Region node is reachable from root.
 348   ResourceMark rm;
 349 
 350   Node_List nstack;
 351   VectorSet visited;
 352 
 353   // Mark all control nodes reachable from root outputs
 354   Node *n = (Node*)phase-&gt;C-&gt;root();
 355   nstack.push(n);
 356   visited.set(n-&gt;_idx);
 357   while (nstack.size() != 0) {
 358     n = nstack.pop();
 359     uint max = n-&gt;outcnt();
 360     for (uint i = 0; i &lt; max; i++) {
 361       Node* m = n-&gt;raw_out(i);
 362       if (m != NULL &amp;&amp; m-&gt;is_CFG()) {
 363         if (phase-&gt;eqv(m, this)) {
 364           return false; // We reached the Region node - it is not dead.
 365         }
 366         if (!visited.test_set(m-&gt;_idx))
 367           nstack.push(m);
 368       }
 369     }
 370   }
 371 
 372   return true; // The Region node is unreachable - it is dead.
 373 }
 374 
 375 Node* PhiNode::try_clean_mem_phi(PhaseGVN *phase) {
 376   // Incremental inlining + PhaseStringOpts sometimes produce:
 377   //
 378   // cmpP with 1 top input
 379   //           |
 380   //          If
 381   //         /  \
 382   //   IfFalse  IfTrue  /- Some Node
 383   //         \  /      /    /
 384   //        Region    / /-MergeMem
 385   //             \---Phi
 386   //
 387   //
 388   // It&#39;s expected by PhaseStringOpts that the Region goes away and is
 389   // replaced by If&#39;s control input but because there&#39;s still a Phi,
 390   // the Region stays in the graph. The top input from the cmpP is
 391   // propagated forward and a subgraph that is useful goes away. The
 392   // code below replaces the Phi with the MergeMem so that the Region
 393   // is simplified.
 394 
 395   if (type() == Type::MEMORY &amp;&amp; is_diamond_phi(true)) {
 396     MergeMemNode* m = NULL;
 397     assert(req() == 3, &quot;same as region&quot;);
 398     Node* r = in(0);
 399     for (uint i = 1; i &lt; 3; ++i) {
 400       Node *mem = in(i);
 401       if (mem &amp;&amp; mem-&gt;is_MergeMem() &amp;&amp; r-&gt;in(i)-&gt;outcnt() == 1) {
 402         // Nothing is control-dependent on path #i except the region itself.
 403         m = mem-&gt;as_MergeMem();
 404         uint j = 3 - i;
 405         Node* other = in(j);
 406         if (other &amp;&amp; other == m-&gt;base_memory()) {
 407           // m is a successor memory to other, and is not pinned inside the diamond, so push it out.
 408           // This will allow the diamond to collapse completely.
 409           return m;
 410         }
 411       }
 412     }
 413   }
 414   return NULL;
 415 }
 416 
 417 //------------------------------Ideal------------------------------------------
 418 // Return a node which is more &quot;ideal&quot; than the current node.  Must preserve
 419 // the CFG, but we can still strip out dead paths.
 420 Node *RegionNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 421   if( !can_reshape &amp;&amp; !in(0) ) return NULL;     // Already degraded to a Copy
 422   assert(!in(0) || !in(0)-&gt;is_Root(), &quot;not a specially hidden merge&quot;);
 423 
 424   // Check for RegionNode with no Phi users and both inputs come from either
 425   // arm of the same IF.  If found, then the control-flow split is useless.
 426   bool has_phis = false;
 427   if (can_reshape) {            // Need DU info to check for Phi users
 428     has_phis = (has_phi() != NULL);       // Cache result
 429     if (has_phis) {
 430       PhiNode* phi = has_unique_phi();
 431       if (phi != NULL) {
 432         Node* m = phi-&gt;try_clean_mem_phi(phase);
 433         if (m != NULL) {
 434           phase-&gt;is_IterGVN()-&gt;replace_node(phi, m);
 435           has_phis = false;
 436         }
 437       }
 438     }
 439 
 440     if (!has_phis) {            // No Phi users?  Nothing merging?
 441       for (uint i = 1; i &lt; req()-1; i++) {
 442         Node *if1 = in(i);
 443         if( !if1 ) continue;
 444         Node *iff = if1-&gt;in(0);
 445         if( !iff || !iff-&gt;is_If() ) continue;
 446         for( uint j=i+1; j&lt;req(); j++ ) {
 447           if( in(j) &amp;&amp; in(j)-&gt;in(0) == iff &amp;&amp;
 448               if1-&gt;Opcode() != in(j)-&gt;Opcode() ) {
 449             // Add the IF Projections to the worklist. They (and the IF itself)
 450             // will be eliminated if dead.
 451             phase-&gt;is_IterGVN()-&gt;add_users_to_worklist(iff);
 452             set_req(i, iff-&gt;in(0));// Skip around the useless IF diamond
 453             set_req(j, NULL);
 454             return this;      // Record progress
 455           }
 456         }
 457       }
 458     }
 459   }
 460 
 461   // Remove TOP or NULL input paths. If only 1 input path remains, this Region
 462   // degrades to a copy.
 463   bool add_to_worklist = false;
 464   bool modified = false;
 465   int cnt = 0;                  // Count of values merging
 466   DEBUG_ONLY( int cnt_orig = req(); ) // Save original inputs count
 467   int del_it = 0;               // The last input path we delete
 468   // For all inputs...
 469   for( uint i=1; i&lt;req(); ++i ){// For all paths in
 470     Node *n = in(i);            // Get the input
 471     if( n != NULL ) {
 472       // Remove useless control copy inputs
 473       if( n-&gt;is_Region() &amp;&amp; n-&gt;as_Region()-&gt;is_copy() ) {
 474         set_req(i, n-&gt;nonnull_req());
 475         modified = true;
 476         i--;
 477         continue;
 478       }
 479       if( n-&gt;is_Proj() ) {      // Remove useless rethrows
 480         Node *call = n-&gt;in(0);
 481         if (call-&gt;is_Call() &amp;&amp; call-&gt;as_Call()-&gt;entry_point() == OptoRuntime::rethrow_stub()) {
 482           set_req(i, call-&gt;in(0));
 483           modified = true;
 484           i--;
 485           continue;
 486         }
 487       }
 488       if( phase-&gt;type(n) == Type::TOP ) {
 489         set_req(i, NULL);       // Ignore TOP inputs
 490         modified = true;
 491         i--;
 492         continue;
 493       }
 494       cnt++;                    // One more value merging
 495 
 496     } else if (can_reshape) {   // Else found dead path with DU info
 497       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 498       del_req(i);               // Yank path from self
 499       del_it = i;
 500       uint max = outcnt();
 501       DUIterator j;
 502       bool progress = true;
 503       while(progress) {         // Need to establish property over all users
 504         progress = false;
 505         for (j = outs(); has_out(j); j++) {
 506           Node *n = out(j);
 507           if( n-&gt;req() != req() &amp;&amp; n-&gt;is_Phi() ) {
 508             assert( n-&gt;in(0) == this, &quot;&quot; );
 509             igvn-&gt;hash_delete(n); // Yank from hash before hacking edges
 510             n-&gt;set_req_X(i,NULL,igvn);// Correct DU info
 511             n-&gt;del_req(i);        // Yank path from Phis
 512             if( max != outcnt() ) {
 513               progress = true;
 514               j = refresh_out_pos(j);
 515               max = outcnt();
 516             }
 517           }
 518         }
 519       }
 520       add_to_worklist = true;
 521       i--;
 522     }
 523   }
 524 
 525   if (can_reshape &amp;&amp; cnt == 1) {
 526     // Is it dead loop?
 527     // If it is LoopNopde it had 2 (+1 itself) inputs and
 528     // one of them was cut. The loop is dead if it was EntryContol.
 529     // Loop node may have only one input because entry path
 530     // is removed in PhaseIdealLoop::Dominators().
 531     assert(!this-&gt;is_Loop() || cnt_orig &lt;= 3, &quot;Loop node should have 3 or less inputs&quot;);
 532     if ((this-&gt;is_Loop() &amp;&amp; (del_it == LoopNode::EntryControl ||
 533                              (del_it == 0 &amp;&amp; is_unreachable_region(phase)))) ||
 534         (!this-&gt;is_Loop() &amp;&amp; has_phis &amp;&amp; is_unreachable_region(phase))) {
 535       // Yes,  the region will be removed during the next step below.
 536       // Cut the backedge input and remove phis since no data paths left.
 537       // We don&#39;t cut outputs to other nodes here since we need to put them
 538       // on the worklist.
 539       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 540       if (in(1)-&gt;outcnt() == 1) {
 541         igvn-&gt;_worklist.push(in(1));
 542       }
 543       del_req(1);
 544       cnt = 0;
 545       assert( req() == 1, &quot;no more inputs expected&quot; );
 546       uint max = outcnt();
 547       bool progress = true;
 548       Node *top = phase-&gt;C-&gt;top();
 549       DUIterator j;
 550       while(progress) {
 551         progress = false;
 552         for (j = outs(); has_out(j); j++) {
 553           Node *n = out(j);
 554           if( n-&gt;is_Phi() ) {
 555             assert( igvn-&gt;eqv(n-&gt;in(0), this), &quot;&quot; );
 556             assert( n-&gt;req() == 2 &amp;&amp;  n-&gt;in(1) != NULL, &quot;Only one data input expected&quot; );
 557             // Break dead loop data path.
 558             // Eagerly replace phis with top to avoid phis copies generation.
 559             igvn-&gt;replace_node(n, top);
 560             if( max != outcnt() ) {
 561               progress = true;
 562               j = refresh_out_pos(j);
 563               max = outcnt();
 564             }
 565           }
 566         }
 567       }
 568       add_to_worklist = true;
 569     }
 570   }
 571   if (add_to_worklist) {
 572     phase-&gt;is_IterGVN()-&gt;add_users_to_worklist(this); // Revisit collapsed Phis
 573   }
 574 
 575   if( cnt &lt;= 1 ) {              // Only 1 path in?
 576     set_req(0, NULL);           // Null control input for region copy
 577     if( cnt == 0 &amp;&amp; !can_reshape) { // Parse phase - leave the node as it is.
 578       // No inputs or all inputs are NULL.
 579       return NULL;
 580     } else if (can_reshape) {   // Optimization phase - remove the node
 581       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 582       // Strip mined (inner) loop is going away, remove outer loop.
 583       if (is_CountedLoop() &amp;&amp;
 584           as_Loop()-&gt;is_strip_mined()) {
 585         Node* outer_sfpt = as_CountedLoop()-&gt;outer_safepoint();
 586         Node* outer_out = as_CountedLoop()-&gt;outer_loop_exit();
 587         if (outer_sfpt != NULL &amp;&amp; outer_out != NULL) {
 588           Node* in = outer_sfpt-&gt;in(0);
 589           igvn-&gt;replace_node(outer_out, in);
 590           LoopNode* outer = as_CountedLoop()-&gt;outer_loop();
 591           igvn-&gt;replace_input_of(outer, LoopNode::LoopBackControl, igvn-&gt;C-&gt;top());
 592         }
 593       }
 594       Node *parent_ctrl;
 595       if( cnt == 0 ) {
 596         assert( req() == 1, &quot;no inputs expected&quot; );
 597         // During IGVN phase such region will be subsumed by TOP node
 598         // so region&#39;s phis will have TOP as control node.
 599         // Kill phis here to avoid it. PhiNode::is_copy() will be always false.
 600         // Also set other user&#39;s input to top.
 601         parent_ctrl = phase-&gt;C-&gt;top();
 602       } else {
 603         // The fallthrough case since we already checked dead loops above.
 604         parent_ctrl = in(1);
 605         assert(parent_ctrl != NULL, &quot;Region is a copy of some non-null control&quot;);
 606         assert(!igvn-&gt;eqv(parent_ctrl, this), &quot;Close dead loop&quot;);
 607       }
 608       if (!add_to_worklist)
 609         igvn-&gt;add_users_to_worklist(this); // Check for further allowed opts
 610       for (DUIterator_Last imin, i = last_outs(imin); i &gt;= imin; --i) {
 611         Node* n = last_out(i);
 612         igvn-&gt;hash_delete(n); // Remove from worklist before modifying edges
 613         if( n-&gt;is_Phi() ) {   // Collapse all Phis
 614           // Eagerly replace phis to avoid copies generation.
 615           Node* in;
 616           if( cnt == 0 ) {
 617             assert( n-&gt;req() == 1, &quot;No data inputs expected&quot; );
 618             in = parent_ctrl; // replaced by top
 619           } else {
 620             assert( n-&gt;req() == 2 &amp;&amp;  n-&gt;in(1) != NULL, &quot;Only one data input expected&quot; );
 621             in = n-&gt;in(1);               // replaced by unique input
 622             if( n-&gt;as_Phi()-&gt;is_unsafe_data_reference(in) )
 623               in = phase-&gt;C-&gt;top();      // replaced by top
 624           }
 625           igvn-&gt;replace_node(n, in);
 626         }
 627         else if( n-&gt;is_Region() ) { // Update all incoming edges
 628           assert( !igvn-&gt;eqv(n, this), &quot;Must be removed from DefUse edges&quot;);
 629           uint uses_found = 0;
 630           for( uint k=1; k &lt; n-&gt;req(); k++ ) {
 631             if( n-&gt;in(k) == this ) {
 632               n-&gt;set_req(k, parent_ctrl);
 633               uses_found++;
 634             }
 635           }
 636           if( uses_found &gt; 1 ) { // (--i) done at the end of the loop.
 637             i -= (uses_found - 1);
 638           }
 639         }
 640         else {
 641           assert( igvn-&gt;eqv(n-&gt;in(0), this), &quot;Expect RegionNode to be control parent&quot;);
 642           n-&gt;set_req(0, parent_ctrl);
 643         }
 644 #ifdef ASSERT
 645         for( uint k=0; k &lt; n-&gt;req(); k++ ) {
 646           assert( !igvn-&gt;eqv(n-&gt;in(k), this), &quot;All uses of RegionNode should be gone&quot;);
 647         }
 648 #endif
 649       }
 650       // Remove the RegionNode itself from DefUse info
 651       igvn-&gt;remove_dead_node(this);
 652       return NULL;
 653     }
 654     return this;                // Record progress
 655   }
 656 
 657 
 658   // If a Region flows into a Region, merge into one big happy merge.
 659   if (can_reshape) {
 660     Node *m = merge_region(this, phase);
 661     if (m != NULL)  return m;
 662   }
 663 
 664   // Check if this region is the root of a clipping idiom on floats
 665   if( ConvertFloat2IntClipping &amp;&amp; can_reshape &amp;&amp; req() == 4 ) {
 666     // Check that only one use is a Phi and that it simplifies to two constants +
 667     PhiNode* phi = has_unique_phi();
 668     if (phi != NULL) {          // One Phi user
 669       // Check inputs to the Phi
 670       ConNode *min;
 671       ConNode *max;
 672       Node    *val;
 673       uint     min_idx;
 674       uint     max_idx;
 675       uint     val_idx;
 676       if( check_phi_clipping( phi, min, min_idx, max, max_idx, val, val_idx )  ) {
 677         IfNode *top_if;
 678         IfNode *bot_if;
 679         if( check_if_clipping( this, bot_if, top_if ) ) {
 680           // Control pattern checks, now verify compares
 681           Node   *top_in = NULL;   // value being compared against
 682           Node   *bot_in = NULL;
 683           if( check_compare_clipping( true,  bot_if, min, bot_in ) &amp;&amp;
 684               check_compare_clipping( false, top_if, max, top_in ) ) {
 685             if( bot_in == top_in ) {
 686               PhaseIterGVN *gvn = phase-&gt;is_IterGVN();
 687               assert( gvn != NULL, &quot;Only had DefUse info in IterGVN&quot;);
 688               // Only remaining check is that bot_in == top_in == (Phi&#39;s val + mods)
 689 
 690               // Check for the ConvF2INode
 691               ConvF2INode *convf2i;
 692               if( check_convf2i_clipping( phi, val_idx, convf2i, min, max ) &amp;&amp;
 693                 convf2i-&gt;in(1) == bot_in ) {
 694                 // Matched pattern, including LShiftI; RShiftI, replace with integer compares
 695                 // max test
 696                 Node *cmp   = gvn-&gt;register_new_node_with_optimizer(new CmpINode( convf2i, min ));
 697                 Node *boo   = gvn-&gt;register_new_node_with_optimizer(new BoolNode( cmp, BoolTest::lt ));
 698                 IfNode *iff = (IfNode*)gvn-&gt;register_new_node_with_optimizer(new IfNode( top_if-&gt;in(0), boo, PROB_UNLIKELY_MAG(5), top_if-&gt;_fcnt ));
 699                 Node *if_min= gvn-&gt;register_new_node_with_optimizer(new IfTrueNode (iff));
 700                 Node *ifF   = gvn-&gt;register_new_node_with_optimizer(new IfFalseNode(iff));
 701                 // min test
 702                 cmp         = gvn-&gt;register_new_node_with_optimizer(new CmpINode( convf2i, max ));
 703                 boo         = gvn-&gt;register_new_node_with_optimizer(new BoolNode( cmp, BoolTest::gt ));
 704                 iff         = (IfNode*)gvn-&gt;register_new_node_with_optimizer(new IfNode( ifF, boo, PROB_UNLIKELY_MAG(5), bot_if-&gt;_fcnt ));
 705                 Node *if_max= gvn-&gt;register_new_node_with_optimizer(new IfTrueNode (iff));
 706                 ifF         = gvn-&gt;register_new_node_with_optimizer(new IfFalseNode(iff));
 707                 // update input edges to region node
 708                 set_req_X( min_idx, if_min, gvn );
 709                 set_req_X( max_idx, if_max, gvn );
 710                 set_req_X( val_idx, ifF,    gvn );
 711                 // remove unnecessary &#39;LShiftI; RShiftI&#39; idiom
 712                 gvn-&gt;hash_delete(phi);
 713                 phi-&gt;set_req_X( val_idx, convf2i, gvn );
 714                 gvn-&gt;hash_find_insert(phi);
 715                 // Return transformed region node
 716                 return this;
 717               }
 718             }
 719           }
 720         }
 721       }
 722     }
 723   }
 724 
 725   if (can_reshape) {
 726     modified |= optimize_trichotomy(phase-&gt;is_IterGVN());
 727   }
 728 
 729   return modified ? this : NULL;
 730 }
 731 
 732 //------------------------------optimize_trichotomy--------------------------
 733 // Optimize nested comparisons of the following kind:
 734 //
 735 // int compare(int a, int b) {
 736 //   return (a &lt; b) ? -1 : (a == b) ? 0 : 1;
 737 // }
 738 //
 739 // Shape 1:
 740 // if (compare(a, b) == 1) { ... } -&gt; if (a &gt; b) { ... }
 741 //
 742 // Shape 2:
 743 // if (compare(a, b) == 0) { ... } -&gt; if (a == b) { ... }
 744 //
 745 // Above code leads to the following IR shapes where both Ifs compare the
 746 // same value and two out of three region inputs idx1 and idx2 map to
 747 // the same value and control flow.
 748 //
 749 // (1)   If                 (2)   If
 750 //      /  \                     /  \
 751 //   Proj  Proj               Proj  Proj
 752 //     |      \                |      \
 753 //     |       If              |      If                      If
 754 //     |      /  \             |     /  \                    /  \
 755 //     |   Proj  Proj          |  Proj  Proj      ==&gt;     Proj  Proj
 756 //     |   /      /            \    |    /                  |    /
 757 //    Region     /              \   |   /                   |   /
 758 //         \    /                \  |  /                    |  /
 759 //         Region                Region                    Region
 760 //
 761 // The method returns true if &#39;this&#39; is modified and false otherwise.
 762 bool RegionNode::optimize_trichotomy(PhaseIterGVN* igvn) {
 763   int idx1 = 1, idx2 = 2;
 764   Node* region = NULL;
 765   if (req() == 3 &amp;&amp; in(1) != NULL &amp;&amp; in(2) != NULL) {
 766     // Shape 1: Check if one of the inputs is a region that merges two control
 767     // inputs and has no other users (especially no Phi users).
 768     region = in(1)-&gt;isa_Region() ? in(1) : in(2)-&gt;isa_Region();
 769     if (region == NULL || region-&gt;outcnt() != 2 || region-&gt;req() != 3) {
 770       return false; // No suitable region input found
 771     }
 772   } else if (req() == 4) {
 773     // Shape 2: Check if two control inputs map to the same value of the unique phi
 774     // user and treat these as if they would come from another region (shape (1)).
 775     PhiNode* phi = has_unique_phi();
 776     if (phi == NULL) {
 777       return false; // No unique phi user
 778     }
 779     if (phi-&gt;in(idx1) != phi-&gt;in(idx2)) {
 780       idx2 = 3;
 781       if (phi-&gt;in(idx1) != phi-&gt;in(idx2)) {
 782         idx1 = 2;
 783         if (phi-&gt;in(idx1) != phi-&gt;in(idx2)) {
 784           return false; // No equal phi inputs found
 785         }
 786       }
 787     }
 788     assert(phi-&gt;in(idx1) == phi-&gt;in(idx2), &quot;must be&quot;); // Region is merging same value
 789     region = this;
 790   }
 791   if (region == NULL || region-&gt;in(idx1) == NULL || region-&gt;in(idx2) == NULL) {
 792     return false; // Region does not merge two control inputs
 793   }
 794   // At this point we know that region-&gt;in(idx1) and region-&gt;(idx2) map to the same
 795   // value and control flow. Now search for ifs that feed into these region inputs.
 796   ProjNode* proj1 = region-&gt;in(idx1)-&gt;isa_Proj();
 797   ProjNode* proj2 = region-&gt;in(idx2)-&gt;isa_Proj();
 798   if (proj1 == NULL || proj1-&gt;outcnt() != 1 ||
 799       proj2 == NULL || proj2-&gt;outcnt() != 1) {
 800     return false; // No projection inputs with region as unique user found
 801   }
 802   assert(proj1 != proj2, &quot;should be different projections&quot;);
 803   IfNode* iff1 = proj1-&gt;in(0)-&gt;isa_If();
 804   IfNode* iff2 = proj2-&gt;in(0)-&gt;isa_If();
 805   if (iff1 == NULL || iff1-&gt;outcnt() != 2 ||
 806       iff2 == NULL || iff2-&gt;outcnt() != 2) {
 807     return false; // No ifs found
 808   }
 809   if (iff1 == iff2) {
 810     igvn-&gt;add_users_to_worklist(iff1); // Make sure dead if is eliminated
 811     igvn-&gt;replace_input_of(region, idx1, iff1-&gt;in(0));
 812     igvn-&gt;replace_input_of(region, idx2, igvn-&gt;C-&gt;top());
 813     return (region == this); // Remove useless if (both projections map to the same control/value)
 814   }
 815   BoolNode* bol1 = iff1-&gt;in(1)-&gt;isa_Bool();
 816   BoolNode* bol2 = iff2-&gt;in(1)-&gt;isa_Bool();
 817   if (bol1 == NULL || bol2 == NULL) {
 818     return false; // No bool inputs found
 819   }
 820   Node* cmp1 = bol1-&gt;in(1);
 821   Node* cmp2 = bol2-&gt;in(1);
 822   bool commute = false;
 823   if (!cmp1-&gt;is_Cmp() || !cmp2-&gt;is_Cmp()) {
 824     return false; // No comparison
 825   } else if (cmp1-&gt;Opcode() == Op_CmpF || cmp1-&gt;Opcode() == Op_CmpD ||
 826              cmp2-&gt;Opcode() == Op_CmpF || cmp2-&gt;Opcode() == Op_CmpD ||
 827              cmp1-&gt;Opcode() == Op_CmpP || cmp1-&gt;Opcode() == Op_CmpN ||
 828              cmp2-&gt;Opcode() == Op_CmpP || cmp2-&gt;Opcode() == Op_CmpN) {
 829     // Floats and pointers don&#39;t exactly obey trichotomy. To be on the safe side, don&#39;t transform their tests.
 830     return false;
 831   } else if (cmp1 != cmp2) {
 832     if (cmp1-&gt;in(1) == cmp2-&gt;in(2) &amp;&amp;
 833         cmp1-&gt;in(2) == cmp2-&gt;in(1)) {
 834       commute = true; // Same but swapped inputs, commute the test
 835     } else {
 836       return false; // Ifs are not comparing the same values
 837     }
 838   }
 839   proj1 = proj1-&gt;other_if_proj();
 840   proj2 = proj2-&gt;other_if_proj();
 841   if (!((proj1-&gt;unique_ctrl_out() == iff2 &amp;&amp;
 842          proj2-&gt;unique_ctrl_out() == this) ||
 843         (proj2-&gt;unique_ctrl_out() == iff1 &amp;&amp;
 844          proj1-&gt;unique_ctrl_out() == this))) {
 845     return false; // Ifs are not connected through other projs
 846   }
 847   // Found &#39;iff -&gt; proj -&gt; iff -&gt; proj -&gt; this&#39; shape where all other projs are merged
 848   // through &#39;region&#39; and map to the same value. Merge the boolean tests and replace
 849   // the ifs by a single comparison.
 850   BoolTest test1 = (proj1-&gt;_con == 1) ? bol1-&gt;_test : bol1-&gt;_test.negate();
 851   BoolTest test2 = (proj2-&gt;_con == 1) ? bol2-&gt;_test : bol2-&gt;_test.negate();
 852   test1 = commute ? test1.commute() : test1;
 853   // After possibly commuting test1, if we can merge test1 &amp; test2, then proj2/iff2/bol2 are the nodes to refine.
 854   BoolTest::mask res = test1.merge(test2);
 855   if (res == BoolTest::illegal) {
 856     return false; // Unable to merge tests
 857   }
 858   // Adjust iff1 to always pass (only iff2 will remain)
 859   igvn-&gt;replace_input_of(iff1, 1, igvn-&gt;intcon(proj1-&gt;_con));
 860   if (res == BoolTest::never) {
 861     // Merged test is always false, adjust iff2 to always fail
 862     igvn-&gt;replace_input_of(iff2, 1, igvn-&gt;intcon(1 - proj2-&gt;_con));
 863   } else {
 864     // Replace bool input of iff2 with merged test
 865     BoolNode* new_bol = new BoolNode(bol2-&gt;in(1), res);
 866     igvn-&gt;replace_input_of(iff2, 1, igvn-&gt;transform((proj2-&gt;_con == 1) ? new_bol : new_bol-&gt;negate(igvn)));
 867   }
 868   return false;
 869 }
 870 
 871 const RegMask &amp;RegionNode::out_RegMask() const {
 872   return RegMask::Empty;
 873 }
 874 
 875 // Find the one non-null required input.  RegionNode only
 876 Node *Node::nonnull_req() const {
 877   assert( is_Region(), &quot;&quot; );
 878   for( uint i = 1; i &lt; _cnt; i++ )
 879     if( in(i) )
 880       return in(i);
 881   ShouldNotReachHere();
 882   return NULL;
 883 }
 884 
 885 
 886 //=============================================================================
 887 // note that these functions assume that the _adr_type field is flattened
 888 uint PhiNode::hash() const {
 889   const Type* at = _adr_type;
 890   return TypeNode::hash() + (at ? at-&gt;hash() : 0);
 891 }
 892 bool PhiNode::cmp( const Node &amp;n ) const {
 893   return TypeNode::cmp(n) &amp;&amp; _adr_type == ((PhiNode&amp;)n)._adr_type;
 894 }
 895 static inline
 896 const TypePtr* flatten_phi_adr_type(const TypePtr* at) {
 897   if (at == NULL || at == TypePtr::BOTTOM)  return at;
 898   return Compile::current()-&gt;alias_type(at)-&gt;adr_type();
 899 }
 900 
 901 //----------------------------make---------------------------------------------
 902 // create a new phi with edges matching r and set (initially) to x
 903 PhiNode* PhiNode::make(Node* r, Node* x, const Type *t, const TypePtr* at) {
 904   uint preds = r-&gt;req();   // Number of predecessor paths
 905   assert(t != Type::MEMORY || at == flatten_phi_adr_type(at) || (flatten_phi_adr_type(at) == TypeAryPtr::INLINES &amp;&amp; Compile::current()-&gt;flattened_accesses_share_alias()), &quot;flatten at&quot;);
 906   PhiNode* p = new PhiNode(r, t, at);
 907   for (uint j = 1; j &lt; preds; j++) {
 908     // Fill in all inputs, except those which the region does not yet have
 909     if (r-&gt;in(j) != NULL)
 910       p-&gt;init_req(j, x);
 911   }
 912   return p;
 913 }
 914 PhiNode* PhiNode::make(Node* r, Node* x) {
 915   const Type*    t  = x-&gt;bottom_type();
 916   const TypePtr* at = NULL;
 917   if (t == Type::MEMORY)  at = flatten_phi_adr_type(x-&gt;adr_type());
 918   return make(r, x, t, at);
 919 }
 920 PhiNode* PhiNode::make_blank(Node* r, Node* x) {
 921   const Type*    t  = x-&gt;bottom_type();
 922   const TypePtr* at = NULL;
 923   if (t == Type::MEMORY)  at = flatten_phi_adr_type(x-&gt;adr_type());
 924   return new PhiNode(r, t, at);
 925 }
 926 
 927 
 928 //------------------------slice_memory-----------------------------------------
 929 // create a new phi with narrowed memory type
 930 PhiNode* PhiNode::slice_memory(const TypePtr* adr_type) const {
 931   PhiNode* mem = (PhiNode*) clone();
 932   *(const TypePtr**)&amp;mem-&gt;_adr_type = adr_type;
 933   // convert self-loops, or else we get a bad graph
 934   for (uint i = 1; i &lt; req(); i++) {
 935     if ((const Node*)in(i) == this)  mem-&gt;set_req(i, mem);
 936   }
 937   mem-&gt;verify_adr_type();
 938   return mem;
 939 }
 940 
 941 //------------------------split_out_instance-----------------------------------
 942 // Split out an instance type from a bottom phi.
 943 PhiNode* PhiNode::split_out_instance(const TypePtr* at, PhaseIterGVN *igvn) const {
 944   const TypeOopPtr *t_oop = at-&gt;isa_oopptr();
 945   assert(t_oop != NULL &amp;&amp; t_oop-&gt;is_known_instance(), &quot;expecting instance oopptr&quot;);
 946   const TypePtr *t = adr_type();
 947   assert(type() == Type::MEMORY &amp;&amp;
 948          (t == TypePtr::BOTTOM || t == TypeRawPtr::BOTTOM ||
 949           t-&gt;isa_oopptr() &amp;&amp; !t-&gt;is_oopptr()-&gt;is_known_instance() &amp;&amp;
 950           t-&gt;is_oopptr()-&gt;cast_to_exactness(true)
 951            -&gt;is_oopptr()-&gt;cast_to_ptr_type(t_oop-&gt;ptr())
 952            -&gt;is_oopptr()-&gt;cast_to_instance_id(t_oop-&gt;instance_id()) == t_oop),
 953          &quot;bottom or raw memory required&quot;);
 954 
 955   // Check if an appropriate node already exists.
 956   Node *region = in(0);
 957   for (DUIterator_Fast kmax, k = region-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 958     Node* use = region-&gt;fast_out(k);
 959     if( use-&gt;is_Phi()) {
 960       PhiNode *phi2 = use-&gt;as_Phi();
 961       if (phi2-&gt;type() == Type::MEMORY &amp;&amp; phi2-&gt;adr_type() == at) {
 962         return phi2;
 963       }
 964     }
 965   }
 966   Compile *C = igvn-&gt;C;
 967   Arena *a = Thread::current()-&gt;resource_area();
 968   Node_Array node_map = new Node_Array(a);
 969   Node_Stack stack(a, C-&gt;live_nodes() &gt;&gt; 4);
 970   PhiNode *nphi = slice_memory(at);
 971   igvn-&gt;register_new_node_with_optimizer( nphi );
 972   node_map.map(_idx, nphi);
 973   stack.push((Node *)this, 1);
 974   while(!stack.is_empty()) {
 975     PhiNode *ophi = stack.node()-&gt;as_Phi();
 976     uint i = stack.index();
 977     assert(i &gt;= 1, &quot;not control edge&quot;);
 978     stack.pop();
 979     nphi = node_map[ophi-&gt;_idx]-&gt;as_Phi();
 980     for (; i &lt; ophi-&gt;req(); i++) {
 981       Node *in = ophi-&gt;in(i);
 982       if (in == NULL || igvn-&gt;type(in) == Type::TOP)
 983         continue;
 984       Node *opt = MemNode::optimize_simple_memory_chain(in, t_oop, NULL, igvn);
 985       PhiNode *optphi = opt-&gt;is_Phi() ? opt-&gt;as_Phi() : NULL;
 986       if (optphi != NULL &amp;&amp; optphi-&gt;adr_type() == TypePtr::BOTTOM) {
 987         opt = node_map[optphi-&gt;_idx];
 988         if (opt == NULL) {
 989           stack.push(ophi, i);
 990           nphi = optphi-&gt;slice_memory(at);
 991           igvn-&gt;register_new_node_with_optimizer( nphi );
 992           node_map.map(optphi-&gt;_idx, nphi);
 993           ophi = optphi;
 994           i = 0; // will get incremented at top of loop
 995           continue;
 996         }
 997       }
 998       nphi-&gt;set_req(i, opt);
 999     }
1000   }
1001   return nphi;
1002 }
1003 
1004 //------------------------verify_adr_type--------------------------------------
1005 #ifdef ASSERT
1006 void PhiNode::verify_adr_type(VectorSet&amp; visited, const TypePtr* at) const {
1007   if (visited.test_set(_idx))  return;  //already visited
1008 
1009   // recheck constructor invariants:
1010   verify_adr_type(false);
1011 
1012   // recheck local phi/phi consistency:
1013   assert(_adr_type == at || _adr_type == TypePtr::BOTTOM,
1014          &quot;adr_type must be consistent across phi nest&quot;);
1015 
1016   // walk around
1017   for (uint i = 1; i &lt; req(); i++) {
1018     Node* n = in(i);
1019     if (n == NULL)  continue;
1020     const Node* np = in(i);
1021     if (np-&gt;is_Phi()) {
1022       np-&gt;as_Phi()-&gt;verify_adr_type(visited, at);
1023     } else if (n-&gt;bottom_type() == Type::TOP
1024                || (n-&gt;is_Mem() &amp;&amp; n-&gt;in(MemNode::Address)-&gt;bottom_type() == Type::TOP)) {
1025       // ignore top inputs
1026     } else {
1027       const TypePtr* nat = flatten_phi_adr_type(n-&gt;adr_type());
1028       // recheck phi/non-phi consistency at leaves:
1029       assert((nat != NULL) == (at != NULL), &quot;&quot;);
1030       assert(nat == at || nat == TypePtr::BOTTOM,
1031              &quot;adr_type must be consistent at leaves of phi nest&quot;);
1032     }
1033   }
1034 }
1035 
1036 // Verify a whole nest of phis rooted at this one.
1037 void PhiNode::verify_adr_type(bool recursive) const {
1038   if (VMError::is_error_reported())  return;  // muzzle asserts when debugging an error
1039   if (Node::in_dump())               return;  // muzzle asserts when printing
1040 
1041   assert((_type == Type::MEMORY) == (_adr_type != NULL), &quot;adr_type for memory phis only&quot;);
1042 
1043   if (!VerifyAliases)       return;  // verify thoroughly only if requested
1044 
1045   assert(_adr_type == flatten_phi_adr_type(_adr_type),
1046          &quot;Phi::adr_type must be pre-normalized&quot;);
1047 
1048   if (recursive) {
1049     VectorSet visited;
1050     verify_adr_type(visited, _adr_type);
1051   }
1052 }
1053 #endif
1054 
1055 
1056 //------------------------------Value------------------------------------------
1057 // Compute the type of the PhiNode
1058 const Type* PhiNode::Value(PhaseGVN* phase) const {
1059   Node *r = in(0);              // RegionNode
1060   if( !r )                      // Copy or dead
1061     return in(1) ? phase-&gt;type(in(1)) : Type::TOP;
1062 
1063   // Note: During parsing, phis are often transformed before their regions.
1064   // This means we have to use type_or_null to defend against untyped regions.
1065   if( phase-&gt;type_or_null(r) == Type::TOP )  // Dead code?
1066     return Type::TOP;
1067 
1068   // Check for trip-counted loop.  If so, be smarter.
1069   CountedLoopNode* l = r-&gt;is_CountedLoop() ? r-&gt;as_CountedLoop() : NULL;
1070   if (l &amp;&amp; ((const Node*)l-&gt;phi() == this)) { // Trip counted loop!
1071     // protect against init_trip() or limit() returning NULL
1072     if (l-&gt;can_be_counted_loop(phase)) {
1073       const Node *init   = l-&gt;init_trip();
1074       const Node *limit  = l-&gt;limit();
1075       const Node* stride = l-&gt;stride();
1076       if (init != NULL &amp;&amp; limit != NULL &amp;&amp; stride != NULL) {
1077         const TypeInt* lo = phase-&gt;type(init)-&gt;isa_int();
1078         const TypeInt* hi = phase-&gt;type(limit)-&gt;isa_int();
1079         const TypeInt* stride_t = phase-&gt;type(stride)-&gt;isa_int();
1080         if (lo != NULL &amp;&amp; hi != NULL &amp;&amp; stride_t != NULL) { // Dying loops might have TOP here
1081           assert(stride_t-&gt;_hi &gt;= stride_t-&gt;_lo, &quot;bad stride type&quot;);
1082           BoolTest::mask bt = l-&gt;loopexit()-&gt;test_trip();
1083           // If the loop exit condition is &quot;not equal&quot;, the condition
1084           // would not trigger if init &gt; limit (if stride &gt; 0) or if
1085           // init &lt; limit if (stride &gt; 0) so we can&#39;t deduce bounds
1086           // for the iv from the exit condition.
1087           if (bt != BoolTest::ne) {
1088             if (stride_t-&gt;_hi &lt; 0) {          // Down-counter loop
1089               swap(lo, hi);
1090               return TypeInt::make(MIN2(lo-&gt;_lo, hi-&gt;_lo) , hi-&gt;_hi, 3);
1091             } else if (stride_t-&gt;_lo &gt;= 0) {
1092               return TypeInt::make(lo-&gt;_lo, MAX2(lo-&gt;_hi, hi-&gt;_hi), 3);
1093             }
1094           }
1095         }
1096       }
1097     } else if (l-&gt;in(LoopNode::LoopBackControl) != NULL &amp;&amp;
1098                in(LoopNode::EntryControl) != NULL &amp;&amp;
1099                phase-&gt;type(l-&gt;in(LoopNode::LoopBackControl)) == Type::TOP) {
1100       // During CCP, if we saturate the type of a counted loop&#39;s Phi
1101       // before the special code for counted loop above has a chance
1102       // to run (that is as long as the type of the backedge&#39;s control
1103       // is top), we might end up with non monotonic types
1104       return phase-&gt;type(in(LoopNode::EntryControl))-&gt;filter_speculative(_type);
1105     }
1106   }
1107 
1108   // Until we have harmony between classes and interfaces in the type
1109   // lattice, we must tread carefully around phis which implicitly
1110   // convert the one to the other.
1111   const TypePtr* ttp = _type-&gt;make_ptr();
1112   const TypeInstPtr* ttip = (ttp != NULL) ? ttp-&gt;isa_instptr() : NULL;
1113   const TypeKlassPtr* ttkp = (ttp != NULL) ? ttp-&gt;isa_klassptr() : NULL;
1114   bool is_intf = false;
1115   if (ttip != NULL &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {
1116     is_intf = true;
1117   } else if (ttkp != NULL &amp;&amp; ttkp-&gt;is_loaded() &amp;&amp; ttkp-&gt;klass()-&gt;is_interface()) {
1118     is_intf = true;
1119   }
1120 
1121   // Default case: merge all inputs
1122   const Type *t = Type::TOP;        // Merged type starting value
1123   for (uint i = 1; i &lt; req(); ++i) {// For all paths in
1124     // Reachable control path?
1125     if (r-&gt;in(i) &amp;&amp; phase-&gt;type(r-&gt;in(i)) == Type::CONTROL) {
1126       const Type* ti = phase-&gt;type(in(i));
1127       // We assume that each input of an interface-valued Phi is a true
1128       // subtype of that interface.  This might not be true of the meet
1129       // of all the input types.  The lattice is not distributive in
1130       // such cases.  Ward off asserts in type.cpp by refusing to do
1131       // meets between interfaces and proper classes.
1132       const TypePtr* tip = ti-&gt;make_ptr();
1133       const TypeInstPtr* tiip = (tip != NULL) ? tip-&gt;isa_instptr() : NULL;
1134       if (tiip) {
1135         bool ti_is_intf = false;
1136         ciKlass* k = tiip-&gt;klass();
1137         if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_interface())
1138           ti_is_intf = true;
1139         if (is_intf != ti_is_intf)
1140           { t = _type; break; }
1141       }
1142       t = t-&gt;meet_speculative(ti);
1143     }
1144   }
1145 
1146   // The worst-case type (from ciTypeFlow) should be consistent with &quot;t&quot;.
1147   // That is, we expect that &quot;t-&gt;higher_equal(_type)&quot; holds true.
1148   // There are various exceptions:
1149   // - Inputs which are phis might in fact be widened unnecessarily.
1150   //   For example, an input might be a widened int while the phi is a short.
1151   // - Inputs might be BotPtrs but this phi is dependent on a null check,
1152   //   and postCCP has removed the cast which encodes the result of the check.
1153   // - The type of this phi is an interface, and the inputs are classes.
1154   // - Value calls on inputs might produce fuzzy results.
1155   //   (Occurrences of this case suggest improvements to Value methods.)
1156   //
1157   // It is not possible to see Type::BOTTOM values as phi inputs,
1158   // because the ciTypeFlow pre-pass produces verifier-quality types.
1159   const Type* ft = t-&gt;filter_speculative(_type);  // Worst case type
1160 
1161 #ifdef ASSERT
1162   // The following logic has been moved into TypeOopPtr::filter.
1163   const Type* jt = t-&gt;join_speculative(_type);
1164   if (jt-&gt;empty()) {           // Emptied out???
1165 
1166     // Check for evil case of &#39;t&#39; being a class and &#39;_type&#39; expecting an
1167     // interface.  This can happen because the bytecodes do not contain
1168     // enough type info to distinguish a Java-level interface variable
1169     // from a Java-level object variable.  If we meet 2 classes which
1170     // both implement interface I, but their meet is at &#39;j/l/O&#39; which
1171     // doesn&#39;t implement I, we have no way to tell if the result should
1172     // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
1173     // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
1174     // uplift the type.
1175     if (!t-&gt;empty() &amp;&amp; ttip != NULL &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {
1176       assert(ft == _type, &quot;&quot;); // Uplift to interface
1177     } else if (!t-&gt;empty() &amp;&amp; ttkp != NULL &amp;&amp; ttkp-&gt;is_loaded() &amp;&amp; ttkp-&gt;klass()-&gt;is_interface()) {
1178       assert(ft == _type, &quot;&quot;); // Uplift to interface
1179     } else {
1180       // We also have to handle &#39;evil cases&#39; of interface- vs. class-arrays
1181       Type::get_arrays_base_elements(jt, _type, NULL, &amp;ttip);
1182       if (!t-&gt;empty() &amp;&amp; ttip != NULL &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {
1183           assert(ft == _type, &quot;&quot;);   // Uplift to array of interface
1184       } else {
1185         // Otherwise it&#39;s something stupid like non-overlapping int ranges
1186         // found on dying counted loops.
1187         assert(ft == Type::TOP, &quot;&quot;); // Canonical empty value
1188       }
1189     }
1190   }
1191 
1192   else {
1193 
1194     // If we have an interface-typed Phi and we narrow to a class type, the join
1195     // should report back the class.  However, if we have a J/L/Object
1196     // class-typed Phi and an interface flows in, it&#39;s possible that the meet &amp;
1197     // join report an interface back out.  This isn&#39;t possible but happens
1198     // because the type system doesn&#39;t interact well with interfaces.
1199     const TypePtr *jtp = jt-&gt;make_ptr();
1200     const TypeInstPtr *jtip = (jtp != NULL) ? jtp-&gt;isa_instptr() : NULL;
1201     const TypeKlassPtr *jtkp = (jtp != NULL) ? jtp-&gt;isa_klassptr() : NULL;
1202     if( jtip &amp;&amp; ttip ) {
1203       if( jtip-&gt;is_loaded() &amp;&amp;  jtip-&gt;klass()-&gt;is_interface() &amp;&amp;
1204           ttip-&gt;is_loaded() &amp;&amp; !ttip-&gt;klass()-&gt;is_interface() ) {
1205         assert(ft == ttip-&gt;cast_to_ptr_type(jtip-&gt;ptr()) ||
1206                ft-&gt;isa_narrowoop() &amp;&amp; ft-&gt;make_ptr() == ttip-&gt;cast_to_ptr_type(jtip-&gt;ptr()), &quot;&quot;);
1207         jt = ft;
1208       }
1209     }
1210     if( jtkp &amp;&amp; ttkp ) {
1211       if( jtkp-&gt;is_loaded() &amp;&amp;  jtkp-&gt;klass()-&gt;is_interface() &amp;&amp;
1212           !jtkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass (6894807)
1213           ttkp-&gt;is_loaded() &amp;&amp; !ttkp-&gt;klass()-&gt;is_interface() ) {
1214         assert(ft == ttkp-&gt;cast_to_ptr_type(jtkp-&gt;ptr()) ||
1215                ft-&gt;isa_narrowklass() &amp;&amp; ft-&gt;make_ptr() == ttkp-&gt;cast_to_ptr_type(jtkp-&gt;ptr()), &quot;&quot;);
1216         jt = ft;
1217       }
1218     }
1219     if (jt != ft &amp;&amp; jt-&gt;base() == ft-&gt;base()) {
1220       if (jt-&gt;isa_int() &amp;&amp;
1221           jt-&gt;is_int()-&gt;_lo == ft-&gt;is_int()-&gt;_lo &amp;&amp;
1222           jt-&gt;is_int()-&gt;_hi == ft-&gt;is_int()-&gt;_hi)
1223         jt = ft;
1224       if (jt-&gt;isa_long() &amp;&amp;
1225           jt-&gt;is_long()-&gt;_lo == ft-&gt;is_long()-&gt;_lo &amp;&amp;
1226           jt-&gt;is_long()-&gt;_hi == ft-&gt;is_long()-&gt;_hi)
1227         jt = ft;
1228     }
1229     if (jt != ft) {
1230       tty-&gt;print(&quot;merge type:  &quot;); t-&gt;dump(); tty-&gt;cr();
1231       tty-&gt;print(&quot;kill type:   &quot;); _type-&gt;dump(); tty-&gt;cr();
1232       tty-&gt;print(&quot;join type:   &quot;); jt-&gt;dump(); tty-&gt;cr();
1233       tty-&gt;print(&quot;filter type: &quot;); ft-&gt;dump(); tty-&gt;cr();
1234     }
1235     assert(jt == ft, &quot;&quot;);
1236   }
1237 #endif //ASSERT
1238 
1239   // Deal with conversion problems found in data loops.
1240   ft = phase-&gt;saturate(ft, phase-&gt;type_or_null(this), _type);
1241 
1242   return ft;
1243 }
1244 
1245 
1246 //------------------------------is_diamond_phi---------------------------------
1247 // Does this Phi represent a simple well-shaped diamond merge?  Return the
1248 // index of the true path or 0 otherwise.
1249 // If check_control_only is true, do not inspect the If node at the
1250 // top, and return -1 (not an edge number) on success.
1251 int PhiNode::is_diamond_phi(bool check_control_only) const {
1252   // Check for a 2-path merge
1253   Node *region = in(0);
1254   if( !region ) return 0;
1255   if( region-&gt;req() != 3 ) return 0;
1256   if(         req() != 3 ) return 0;
1257   // Check that both paths come from the same If
1258   Node *ifp1 = region-&gt;in(1);
1259   Node *ifp2 = region-&gt;in(2);
1260   if( !ifp1 || !ifp2 ) return 0;
1261   Node *iff = ifp1-&gt;in(0);
1262   if( !iff || !iff-&gt;is_If() ) return 0;
1263   if( iff != ifp2-&gt;in(0) ) return 0;
1264   if (check_control_only)  return -1;
1265   // Check for a proper bool/cmp
1266   const Node *b = iff-&gt;in(1);
1267   if( !b-&gt;is_Bool() ) return 0;
1268   const Node *cmp = b-&gt;in(1);
1269   if( !cmp-&gt;is_Cmp() ) return 0;
1270 
1271   // Check for branching opposite expected
1272   if( ifp2-&gt;Opcode() == Op_IfTrue ) {
1273     assert( ifp1-&gt;Opcode() == Op_IfFalse, &quot;&quot; );
1274     return 2;
1275   } else {
1276     assert( ifp1-&gt;Opcode() == Op_IfTrue, &quot;&quot; );
1277     return 1;
1278   }
1279 }
1280 
1281 //----------------------------check_cmove_id-----------------------------------
1282 // Check for CMove&#39;ing a constant after comparing against the constant.
1283 // Happens all the time now, since if we compare equality vs a constant in
1284 // the parser, we &quot;know&quot; the variable is constant on one path and we force
1285 // it.  Thus code like &quot;if( x==0 ) {/*EMPTY*/}&quot; ends up inserting a
1286 // conditional move: &quot;x = (x==0)?0:x;&quot;.  Yucko.  This fix is slightly more
1287 // general in that we don&#39;t need constants.  Since CMove&#39;s are only inserted
1288 // in very special circumstances, we do it here on generic Phi&#39;s.
1289 Node* PhiNode::is_cmove_id(PhaseTransform* phase, int true_path) {
1290   assert(true_path !=0, &quot;only diamond shape graph expected&quot;);
1291 
1292   // is_diamond_phi() has guaranteed the correctness of the nodes sequence:
1293   // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool-&gt;cmp
1294   Node*     region = in(0);
1295   Node*     iff    = region-&gt;in(1)-&gt;in(0);
1296   BoolNode* b      = iff-&gt;in(1)-&gt;as_Bool();
1297   Node*     cmp    = b-&gt;in(1);
1298   Node*     tval   = in(true_path);
1299   Node*     fval   = in(3-true_path);
1300   Node*     id     = CMoveNode::is_cmove_id(phase, cmp, tval, fval, b);
1301   if (id == NULL)
1302     return NULL;
1303 
1304   // Either value might be a cast that depends on a branch of &#39;iff&#39;.
1305   // Since the &#39;id&#39; value will float free of the diamond, either
1306   // decast or return failure.
1307   Node* ctl = id-&gt;in(0);
1308   if (ctl != NULL &amp;&amp; ctl-&gt;in(0) == iff) {
1309     if (id-&gt;is_ConstraintCast()) {
1310       return id-&gt;in(1);
1311     } else {
1312       // Don&#39;t know how to disentangle this value.
1313       return NULL;
1314     }
1315   }
1316 
1317   return id;
1318 }
1319 
1320 //------------------------------Identity---------------------------------------
1321 // Check for Region being Identity.
1322 Node* PhiNode::Identity(PhaseGVN* phase) {
1323   // Check for no merging going on
1324   // (There used to be special-case code here when this-&gt;region-&gt;is_Loop.
1325   // It would check for a tributary phi on the backedge that the main phi
1326   // trivially, perhaps with a single cast.  The unique_input method
1327   // does all this and more, by reducing such tributaries to &#39;this&#39;.)
1328   Node* uin = unique_input(phase, false);
1329   if (uin != NULL) {
1330     return uin;
1331   }
1332 
1333   int true_path = is_diamond_phi();
1334   if (true_path != 0) {
1335     Node* id = is_cmove_id(phase, true_path);
1336     if (id != NULL)  return id;
1337   }
1338 
1339   if (phase-&gt;is_IterGVN()) {
1340     Node* m = try_clean_mem_phi(phase);
1341     if (m != NULL) {
1342       return m;
1343     }
1344   }
1345 
1346 
<a name="1" id="anc1"></a><span class="line-added">1347   // Looking for phis with identical inputs.  If we find one that has</span>
<span class="line-added">1348   // type TypePtr::BOTTOM, replace the current phi with the bottom phi.</span>
<span class="line-added">1349   if (phase-&gt;is_IterGVN() &amp;&amp; type() == Type::MEMORY &amp;&amp; adr_type() !=</span>
<span class="line-added">1350       TypePtr::BOTTOM &amp;&amp; !adr_type()-&gt;is_known_instance()) {</span>
<span class="line-added">1351     uint phi_len = req();</span>
<span class="line-added">1352     Node* phi_reg = region();</span>
<span class="line-added">1353     for (DUIterator_Fast imax, i = phi_reg-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">1354       Node* u = phi_reg-&gt;fast_out(i);</span>
<span class="line-added">1355       if (u-&gt;is_Phi() &amp;&amp; u-&gt;as_Phi()-&gt;type() == Type::MEMORY &amp;&amp;</span>
<span class="line-added">1356           u-&gt;adr_type() == TypePtr::BOTTOM &amp;&amp; u-&gt;in(0) == phi_reg &amp;&amp;</span>
<span class="line-added">1357           u-&gt;req() == phi_len) {</span>
<span class="line-added">1358         for (uint j = 1; j &lt; phi_len; j++) {</span>
<span class="line-added">1359           if (in(j) != u-&gt;in(j)) {</span>
<span class="line-added">1360             u = NULL;</span>
<span class="line-added">1361             break;</span>
<span class="line-added">1362           }</span>
<span class="line-added">1363         }</span>
<span class="line-added">1364         if (u != NULL) {</span>
<span class="line-added">1365           return u;</span>
<span class="line-added">1366         }</span>
<span class="line-added">1367       }</span>
<span class="line-added">1368     }</span>
<span class="line-added">1369   }</span>
<span class="line-added">1370 </span>
1371   return this;                     // No identity
1372 }
1373 
1374 //-----------------------------unique_input------------------------------------
1375 // Find the unique value, discounting top, self-loops, and casts.
1376 // Return top if there are no inputs, and self if there are multiple.
1377 Node* PhiNode::unique_input(PhaseTransform* phase, bool uncast) {
1378   //  1) One unique direct input,
1379   // or if uncast is true:
1380   //  2) some of the inputs have an intervening ConstraintCast
1381   //  3) an input is a self loop
1382   //
1383   //  1) input   or   2) input     or   3) input __
1384   //     /   \           /   \               \  /  \
1385   //     \   /          |    cast             phi  cast
1386   //      phi            \   /               /  \  /
1387   //                      phi               /    --
1388 
1389   Node* r = in(0);                      // RegionNode
1390   if (r == NULL)  return in(1);         // Already degraded to a Copy
1391   Node* input = NULL; // The unique direct input (maybe uncasted = ConstraintCasts removed)
1392 
1393   for (uint i = 1, cnt = req(); i &lt; cnt; ++i) {
1394     Node* rc = r-&gt;in(i);
1395     if (rc == NULL || phase-&gt;type(rc) == Type::TOP)
1396       continue;                 // ignore unreachable control path
1397     Node* n = in(i);
1398     if (n == NULL)
1399       continue;
1400     Node* un = n;
1401     if (uncast) {
1402 #ifdef ASSERT
1403       Node* m = un-&gt;uncast();
1404 #endif
1405       while (un != NULL &amp;&amp; un-&gt;req() == 2 &amp;&amp; un-&gt;is_ConstraintCast()) {
1406         Node* next = un-&gt;in(1);
1407         if (phase-&gt;type(next)-&gt;isa_rawptr() &amp;&amp; phase-&gt;type(un)-&gt;isa_oopptr()) {
1408           // risk exposing raw ptr at safepoint
1409           break;
1410         }
1411         un = next;
1412       }
1413       assert(m == un || un-&gt;in(1) == m, &quot;Only expected at CheckCastPP from allocation&quot;);
1414     }
1415     if (un == NULL || un == this || phase-&gt;type(un) == Type::TOP) {
1416       continue; // ignore if top, or in(i) and &quot;this&quot; are in a data cycle
1417     }
1418     // Check for a unique input (maybe uncasted)
1419     if (input == NULL) {
1420       input = un;
1421     } else if (input != un) {
1422       input = NodeSentinel; // no unique input
1423     }
1424   }
1425   if (input == NULL) {
1426     return phase-&gt;C-&gt;top();        // no inputs
1427   }
1428 
1429   if (input != NodeSentinel) {
1430     return input;           // one unique direct input
1431   }
1432 
1433   // Nothing.
1434   return NULL;
1435 }
1436 
1437 //------------------------------is_x2logic-------------------------------------
1438 // Check for simple convert-to-boolean pattern
1439 // If:(C Bool) Region:(IfF IfT) Phi:(Region 0 1)
1440 // Convert Phi to an ConvIB.
1441 static Node *is_x2logic( PhaseGVN *phase, PhiNode *phi, int true_path ) {
1442   assert(true_path !=0, &quot;only diamond shape graph expected&quot;);
1443   // Convert the true/false index into an expected 0/1 return.
1444   // Map 2-&gt;0 and 1-&gt;1.
1445   int flipped = 2-true_path;
1446 
1447   // is_diamond_phi() has guaranteed the correctness of the nodes sequence:
1448   // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool-&gt;cmp
1449   Node *region = phi-&gt;in(0);
1450   Node *iff = region-&gt;in(1)-&gt;in(0);
1451   BoolNode *b = (BoolNode*)iff-&gt;in(1);
1452   const CmpNode *cmp = (CmpNode*)b-&gt;in(1);
1453 
1454   Node *zero = phi-&gt;in(1);
1455   Node *one  = phi-&gt;in(2);
1456   const Type *tzero = phase-&gt;type( zero );
1457   const Type *tone  = phase-&gt;type( one  );
1458 
1459   // Check for compare vs 0
1460   const Type *tcmp = phase-&gt;type(cmp-&gt;in(2));
1461   if( tcmp != TypeInt::ZERO &amp;&amp; tcmp != TypePtr::NULL_PTR ) {
1462     // Allow cmp-vs-1 if the other input is bounded by 0-1
1463     if( !(tcmp == TypeInt::ONE &amp;&amp; phase-&gt;type(cmp-&gt;in(1)) == TypeInt::BOOL) )
1464       return NULL;
1465     flipped = 1-flipped;        // Test is vs 1 instead of 0!
1466   }
1467 
1468   // Check for setting zero/one opposite expected
1469   if( tzero == TypeInt::ZERO ) {
1470     if( tone == TypeInt::ONE ) {
1471     } else return NULL;
1472   } else if( tzero == TypeInt::ONE ) {
1473     if( tone == TypeInt::ZERO ) {
1474       flipped = 1-flipped;
1475     } else return NULL;
1476   } else return NULL;
1477 
1478   // Check for boolean test backwards
1479   if( b-&gt;_test._test == BoolTest::ne ) {
1480   } else if( b-&gt;_test._test == BoolTest::eq ) {
1481     flipped = 1-flipped;
1482   } else return NULL;
1483 
1484   // Build int-&gt;bool conversion
1485   Node *n = new Conv2BNode(cmp-&gt;in(1));
1486   if( flipped )
1487     n = new XorINode( phase-&gt;transform(n), phase-&gt;intcon(1) );
1488 
1489   return n;
1490 }
1491 
1492 //------------------------------is_cond_add------------------------------------
1493 // Check for simple conditional add pattern:  &quot;(P &lt; Q) ? X+Y : X;&quot;
1494 // To be profitable the control flow has to disappear; there can be no other
1495 // values merging here.  We replace the test-and-branch with:
1496 // &quot;(sgn(P-Q))&amp;Y) + X&quot;.  Basically, convert &quot;(P &lt; Q)&quot; into 0 or -1 by
1497 // moving the carry bit from (P-Q) into a register with &#39;sbb EAX,EAX&#39;.
1498 // Then convert Y to 0-or-Y and finally add.
1499 // This is a key transform for SpecJava _201_compress.
1500 static Node* is_cond_add(PhaseGVN *phase, PhiNode *phi, int true_path) {
1501   assert(true_path !=0, &quot;only diamond shape graph expected&quot;);
1502 
1503   // is_diamond_phi() has guaranteed the correctness of the nodes sequence:
1504   // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool-&gt;cmp
1505   RegionNode *region = (RegionNode*)phi-&gt;in(0);
1506   Node *iff = region-&gt;in(1)-&gt;in(0);
1507   BoolNode* b = iff-&gt;in(1)-&gt;as_Bool();
1508   const CmpNode *cmp = (CmpNode*)b-&gt;in(1);
1509 
1510   // Make sure only merging this one phi here
1511   if (region-&gt;has_unique_phi() != phi)  return NULL;
1512 
1513   // Make sure each arm of the diamond has exactly one output, which we assume
1514   // is the region.  Otherwise, the control flow won&#39;t disappear.
1515   if (region-&gt;in(1)-&gt;outcnt() != 1) return NULL;
1516   if (region-&gt;in(2)-&gt;outcnt() != 1) return NULL;
1517 
1518   // Check for &quot;(P &lt; Q)&quot; of type signed int
1519   if (b-&gt;_test._test != BoolTest::lt)  return NULL;
1520   if (cmp-&gt;Opcode() != Op_CmpI)        return NULL;
1521 
1522   Node *p = cmp-&gt;in(1);
1523   Node *q = cmp-&gt;in(2);
1524   Node *n1 = phi-&gt;in(  true_path);
1525   Node *n2 = phi-&gt;in(3-true_path);
1526 
1527   int op = n1-&gt;Opcode();
1528   if( op != Op_AddI           // Need zero as additive identity
1529       /*&amp;&amp;op != Op_SubI &amp;&amp;
1530       op != Op_AddP &amp;&amp;
1531       op != Op_XorI &amp;&amp;
1532       op != Op_OrI*/ )
1533     return NULL;
1534 
1535   Node *x = n2;
1536   Node *y = NULL;
1537   if( x == n1-&gt;in(1) ) {
1538     y = n1-&gt;in(2);
1539   } else if( x == n1-&gt;in(2) ) {
1540     y = n1-&gt;in(1);
1541   } else return NULL;
1542 
1543   // Not so profitable if compare and add are constants
1544   if( q-&gt;is_Con() &amp;&amp; phase-&gt;type(q) != TypeInt::ZERO &amp;&amp; y-&gt;is_Con() )
1545     return NULL;
1546 
1547   Node *cmplt = phase-&gt;transform( new CmpLTMaskNode(p,q) );
1548   Node *j_and   = phase-&gt;transform( new AndINode(cmplt,y) );
1549   return new AddINode(j_and,x);
1550 }
1551 
1552 //------------------------------is_absolute------------------------------------
1553 // Check for absolute value.
1554 static Node* is_absolute( PhaseGVN *phase, PhiNode *phi_root, int true_path) {
1555   assert(true_path !=0, &quot;only diamond shape graph expected&quot;);
1556 
1557   int  cmp_zero_idx = 0;        // Index of compare input where to look for zero
1558   int  phi_x_idx = 0;           // Index of phi input where to find naked x
1559 
1560   // ABS ends with the merge of 2 control flow paths.
1561   // Find the false path from the true path. With only 2 inputs, 3 - x works nicely.
1562   int false_path = 3 - true_path;
1563 
1564   // is_diamond_phi() has guaranteed the correctness of the nodes sequence:
1565   // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool-&gt;cmp
1566   BoolNode *bol = phi_root-&gt;in(0)-&gt;in(1)-&gt;in(0)-&gt;in(1)-&gt;as_Bool();
1567   Node *cmp = bol-&gt;in(1);
1568 
1569   // Check bool sense
1570   if (cmp-&gt;Opcode() == Op_CmpF || cmp-&gt;Opcode() == Op_CmpD) {
1571     switch (bol-&gt;_test._test) {
1572     case BoolTest::lt: cmp_zero_idx = 1; phi_x_idx = true_path;  break;
1573     case BoolTest::le: cmp_zero_idx = 2; phi_x_idx = false_path; break;
1574     case BoolTest::gt: cmp_zero_idx = 2; phi_x_idx = true_path;  break;
1575     case BoolTest::ge: cmp_zero_idx = 1; phi_x_idx = false_path; break;
1576     default:           return NULL;                              break;
1577     }
1578   } else if (cmp-&gt;Opcode() == Op_CmpI || cmp-&gt;Opcode() == Op_CmpL) {
1579     switch (bol-&gt;_test._test) {
1580     case BoolTest::lt:
1581     case BoolTest::le: cmp_zero_idx = 2; phi_x_idx = false_path; break;
1582     case BoolTest::gt:
1583     case BoolTest::ge: cmp_zero_idx = 2; phi_x_idx = true_path;  break;
1584     default:           return NULL;                              break;
1585     }
1586   }
1587 
1588   // Test is next
1589   const Type *tzero = NULL;
1590   switch (cmp-&gt;Opcode()) {
1591   case Op_CmpI:    tzero = TypeInt::ZERO; break;  // Integer ABS
1592   case Op_CmpL:    tzero = TypeLong::ZERO; break; // Long ABS
1593   case Op_CmpF:    tzero = TypeF::ZERO; break; // Float ABS
1594   case Op_CmpD:    tzero = TypeD::ZERO; break; // Double ABS
1595   default: return NULL;
1596   }
1597 
1598   // Find zero input of compare; the other input is being abs&#39;d
1599   Node *x = NULL;
1600   bool flip = false;
1601   if( phase-&gt;type(cmp-&gt;in(cmp_zero_idx)) == tzero ) {
1602     x = cmp-&gt;in(3 - cmp_zero_idx);
1603   } else if( phase-&gt;type(cmp-&gt;in(3 - cmp_zero_idx)) == tzero ) {
1604     // The test is inverted, we should invert the result...
1605     x = cmp-&gt;in(cmp_zero_idx);
1606     flip = true;
1607   } else {
1608     return NULL;
1609   }
1610 
1611   // Next get the 2 pieces being selected, one is the original value
1612   // and the other is the negated value.
1613   if( phi_root-&gt;in(phi_x_idx) != x ) return NULL;
1614 
1615   // Check other phi input for subtract node
1616   Node *sub = phi_root-&gt;in(3 - phi_x_idx);
1617 
1618   // Allow only Sub(0,X) and fail out for all others; Neg is not OK
1619   if( tzero == TypeF::ZERO ) {
1620     if( sub-&gt;Opcode() != Op_SubF ||
1621         sub-&gt;in(2) != x ||
1622         phase-&gt;type(sub-&gt;in(1)) != tzero ) return NULL;
1623     x = new AbsFNode(x);
1624     if (flip) {
1625       x = new SubFNode(sub-&gt;in(1), phase-&gt;transform(x));
1626     }
1627   } else if (tzero == TypeD::ZERO) {
1628     if( sub-&gt;Opcode() != Op_SubD ||
1629         sub-&gt;in(2) != x ||
1630         phase-&gt;type(sub-&gt;in(1)) != tzero ) return NULL;
1631     x = new AbsDNode(x);
1632     if (flip) {
1633       x = new SubDNode(sub-&gt;in(1), phase-&gt;transform(x));
1634     }
1635   } else if (tzero == TypeInt::ZERO) {
1636     if (sub-&gt;Opcode() != Op_SubI ||
1637         sub-&gt;in(2) != x ||
1638         phase-&gt;type(sub-&gt;in(1)) != tzero) return NULL;
1639     x = new AbsINode(x);
1640     if (flip) {
1641       x = new SubINode(sub-&gt;in(1), phase-&gt;transform(x));
1642     }
1643   } else {
1644     if (sub-&gt;Opcode() != Op_SubL ||
1645         sub-&gt;in(2) != x ||
1646         phase-&gt;type(sub-&gt;in(1)) != tzero) return NULL;
1647     x = new AbsLNode(x);
1648     if (flip) {
1649       x = new SubLNode(sub-&gt;in(1), phase-&gt;transform(x));
1650     }
1651   }
1652 
1653   return x;
1654 }
1655 
1656 //------------------------------split_once-------------------------------------
1657 // Helper for split_flow_path
1658 static void split_once(PhaseIterGVN *igvn, Node *phi, Node *val, Node *n, Node *newn) {
1659   igvn-&gt;hash_delete(n);         // Remove from hash before hacking edges
1660 
1661   uint j = 1;
1662   for (uint i = phi-&gt;req()-1; i &gt; 0; i--) {
1663     if (phi-&gt;in(i) == val) {   // Found a path with val?
1664       // Add to NEW Region/Phi, no DU info
1665       newn-&gt;set_req( j++, n-&gt;in(i) );
1666       // Remove from OLD Region/Phi
1667       n-&gt;del_req(i);
1668     }
1669   }
1670 
1671   // Register the new node but do not transform it.  Cannot transform until the
1672   // entire Region/Phi conglomerate has been hacked as a single huge transform.
1673   igvn-&gt;register_new_node_with_optimizer( newn );
1674 
1675   // Now I can point to the new node.
1676   n-&gt;add_req(newn);
1677   igvn-&gt;_worklist.push(n);
1678 }
1679 
1680 //------------------------------split_flow_path--------------------------------
1681 // Check for merging identical values and split flow paths
1682 static Node* split_flow_path(PhaseGVN *phase, PhiNode *phi) {
1683   BasicType bt = phi-&gt;type()-&gt;basic_type();
1684   if( bt == T_ILLEGAL || type2size[bt] &lt;= 0 )
1685     return NULL;                // Bail out on funny non-value stuff
1686   if( phi-&gt;req() &lt;= 3 )         // Need at least 2 matched inputs and a
1687     return NULL;                // third unequal input to be worth doing
1688 
1689   // Scan for a constant
1690   uint i;
1691   for( i = 1; i &lt; phi-&gt;req()-1; i++ ) {
1692     Node *n = phi-&gt;in(i);
1693     if( !n ) return NULL;
1694     if( phase-&gt;type(n) == Type::TOP ) return NULL;
1695     if( n-&gt;Opcode() == Op_ConP || n-&gt;Opcode() == Op_ConN || n-&gt;Opcode() == Op_ConNKlass )
1696       break;
1697   }
1698   if( i &gt;= phi-&gt;req() )         // Only split for constants
1699     return NULL;
1700 
1701   Node *val = phi-&gt;in(i);       // Constant to split for
1702   uint hit = 0;                 // Number of times it occurs
1703   Node *r = phi-&gt;region();
1704 
1705   for( ; i &lt; phi-&gt;req(); i++ ){ // Count occurrences of constant
1706     Node *n = phi-&gt;in(i);
1707     if( !n ) return NULL;
1708     if( phase-&gt;type(n) == Type::TOP ) return NULL;
1709     if( phi-&gt;in(i) == val ) {
1710       hit++;
1711       if (PhaseIdealLoop::find_predicate(r-&gt;in(i)) != NULL) {
1712         return NULL;            // don&#39;t split loop entry path
1713       }
1714     }
1715   }
1716 
1717   if( hit &lt;= 1 ||               // Make sure we find 2 or more
1718       hit == phi-&gt;req()-1 )     // and not ALL the same value
1719     return NULL;
1720 
1721   // Now start splitting out the flow paths that merge the same value.
1722   // Split first the RegionNode.
1723   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1724   RegionNode *newr = new RegionNode(hit+1);
1725   split_once(igvn, phi, val, r, newr);
1726 
1727   // Now split all other Phis than this one
1728   for (DUIterator_Fast kmax, k = r-&gt;fast_outs(kmax); k &lt; kmax; k++) {
1729     Node* phi2 = r-&gt;fast_out(k);
1730     if( phi2-&gt;is_Phi() &amp;&amp; phi2-&gt;as_Phi() != phi ) {
1731       PhiNode *newphi = PhiNode::make_blank(newr, phi2);
1732       split_once(igvn, phi, val, phi2, newphi);
1733     }
1734   }
1735 
1736   // Clean up this guy
1737   igvn-&gt;hash_delete(phi);
1738   for( i = phi-&gt;req()-1; i &gt; 0; i-- ) {
1739     if( phi-&gt;in(i) == val ) {
1740       phi-&gt;del_req(i);
1741     }
1742   }
1743   phi-&gt;add_req(val);
1744 
1745   return phi;
1746 }
1747 
1748 //=============================================================================
1749 //------------------------------simple_data_loop_check-------------------------
1750 //  Try to determining if the phi node in a simple safe/unsafe data loop.
1751 //  Returns:
1752 // enum LoopSafety { Safe = 0, Unsafe, UnsafeLoop };
1753 // Safe       - safe case when the phi and it&#39;s inputs reference only safe data
1754 //              nodes;
1755 // Unsafe     - the phi and it&#39;s inputs reference unsafe data nodes but there
1756 //              is no reference back to the phi - need a graph walk
1757 //              to determine if it is in a loop;
1758 // UnsafeLoop - unsafe case when the phi references itself directly or through
1759 //              unsafe data node.
1760 //  Note: a safe data node is a node which could/never reference itself during
1761 //  GVN transformations. For now it is Con, Proj, Phi, CastPP, CheckCastPP.
1762 //  I mark Phi nodes as safe node not only because they can reference itself
1763 //  but also to prevent mistaking the fallthrough case inside an outer loop
1764 //  as dead loop when the phi references itselfs through an other phi.
1765 PhiNode::LoopSafety PhiNode::simple_data_loop_check(Node *in) const {
1766   // It is unsafe loop if the phi node references itself directly.
1767   if (in == (Node*)this)
1768     return UnsafeLoop; // Unsafe loop
1769   // Unsafe loop if the phi node references itself through an unsafe data node.
1770   // Exclude cases with null inputs or data nodes which could reference
1771   // itself (safe for dead loops).
1772   if (in != NULL &amp;&amp; !in-&gt;is_dead_loop_safe()) {
1773     // Check inputs of phi&#39;s inputs also.
1774     // It is much less expensive then full graph walk.
1775     uint cnt = in-&gt;req();
1776     uint i = (in-&gt;is_Proj() &amp;&amp; !in-&gt;is_CFG())  ? 0 : 1;
1777     for (; i &lt; cnt; ++i) {
1778       Node* m = in-&gt;in(i);
1779       if (m == (Node*)this)
1780         return UnsafeLoop; // Unsafe loop
1781       if (m != NULL &amp;&amp; !m-&gt;is_dead_loop_safe()) {
1782         // Check the most common case (about 30% of all cases):
1783         // phi-&gt;Load/Store-&gt;AddP-&gt;(ConP ConP Con)/(Parm Parm Con).
1784         Node *m1 = (m-&gt;is_AddP() &amp;&amp; m-&gt;req() &gt; 3) ? m-&gt;in(1) : NULL;
1785         if (m1 == (Node*)this)
1786           return UnsafeLoop; // Unsafe loop
1787         if (m1 != NULL &amp;&amp; m1 == m-&gt;in(2) &amp;&amp;
1788             m1-&gt;is_dead_loop_safe() &amp;&amp; m-&gt;in(3)-&gt;is_Con()) {
1789           continue; // Safe case
1790         }
1791         // The phi references an unsafe node - need full analysis.
1792         return Unsafe;
1793       }
1794     }
1795   }
1796   return Safe; // Safe case - we can optimize the phi node.
1797 }
1798 
1799 //------------------------------is_unsafe_data_reference-----------------------
1800 // If phi can be reached through the data input - it is data loop.
1801 bool PhiNode::is_unsafe_data_reference(Node *in) const {
1802   assert(req() &gt; 1, &quot;&quot;);
1803   // First, check simple cases when phi references itself directly or
1804   // through an other node.
1805   LoopSafety safety = simple_data_loop_check(in);
1806   if (safety == UnsafeLoop)
1807     return true;  // phi references itself - unsafe loop
1808   else if (safety == Safe)
1809     return false; // Safe case - phi could be replaced with the unique input.
1810 
1811   // Unsafe case when we should go through data graph to determine
1812   // if the phi references itself.
1813 
1814   ResourceMark rm;
1815 
1816   Node_List nstack;
1817   VectorSet visited;
1818 
1819   nstack.push(in); // Start with unique input.
1820   visited.set(in-&gt;_idx);
1821   while (nstack.size() != 0) {
1822     Node* n = nstack.pop();
1823     uint cnt = n-&gt;req();
1824     uint i = (n-&gt;is_Proj() &amp;&amp; !n-&gt;is_CFG()) ? 0 : 1;
1825     for (; i &lt; cnt; i++) {
1826       Node* m = n-&gt;in(i);
1827       if (m == (Node*)this) {
1828         return true;    // Data loop
1829       }
1830       if (m != NULL &amp;&amp; !m-&gt;is_dead_loop_safe()) { // Only look for unsafe cases.
1831         if (!visited.test_set(m-&gt;_idx))
1832           nstack.push(m);
1833       }
1834     }
1835   }
1836   return false; // The phi is not reachable from its inputs
1837 }
1838 
1839 // Is this Phi&#39;s region or some inputs to the region enqueued for IGVN
1840 // and so could cause the region to be optimized out?
1841 bool PhiNode::wait_for_region_igvn(PhaseGVN* phase) {
1842   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1843   Unique_Node_List&amp; worklist = igvn-&gt;_worklist;
1844   bool delay = false;
1845   Node* r = in(0);
1846   for (uint j = 1; j &lt; req(); j++) {
1847     Node* rc = r-&gt;in(j);
1848     Node* n = in(j);
1849     if (rc != NULL &amp;&amp;
1850         rc-&gt;is_Proj()) {
1851       if (worklist.member(rc)) {
1852         delay = true;
1853       } else if (rc-&gt;in(0) != NULL &amp;&amp;
1854                  rc-&gt;in(0)-&gt;is_If()) {
1855         if (worklist.member(rc-&gt;in(0))) {
1856           delay = true;
1857         } else if (rc-&gt;in(0)-&gt;in(1) != NULL &amp;&amp;
1858                    rc-&gt;in(0)-&gt;in(1)-&gt;is_Bool()) {
1859           if (worklist.member(rc-&gt;in(0)-&gt;in(1))) {
1860             delay = true;
1861           } else if (rc-&gt;in(0)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
1862                      rc-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;is_Cmp()) {
1863             if (worklist.member(rc-&gt;in(0)-&gt;in(1)-&gt;in(1))) {
1864               delay = true;
1865             }
1866           }
1867         }
1868       }
1869     }
1870   }
1871   if (delay) {
1872     worklist.push(this);
1873   }
1874   return delay;
1875 }
1876 
1877 //------------------------------Ideal------------------------------------------
1878 // Return a node which is more &quot;ideal&quot; than the current node.  Must preserve
1879 // the CFG, but we can still strip out dead paths.
1880 Node *PhiNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1881   // The next should never happen after 6297035 fix.
1882   if( is_copy() )               // Already degraded to a Copy ?
1883     return NULL;                // No change
1884 
1885   Node *r = in(0);              // RegionNode
1886   assert(r-&gt;in(0) == NULL || !r-&gt;in(0)-&gt;is_Root(), &quot;not a specially hidden merge&quot;);
1887 
1888   // Note: During parsing, phis are often transformed before their regions.
1889   // This means we have to use type_or_null to defend against untyped regions.
1890   if( phase-&gt;type_or_null(r) == Type::TOP ) // Dead code?
1891     return NULL;                // No change
1892 
1893   // If all inputs are inline types of the same type, push the inline type node down
1894   // through the phi because inline type nodes should be merged through their input values.
1895   if (req() &gt; 2 &amp;&amp; in(1) != NULL &amp;&amp; in(1)-&gt;is_InlineTypeBase() &amp;&amp; (can_reshape || in(1)-&gt;is_InlineType())) {
1896     int opcode = in(1)-&gt;Opcode();
1897     uint i = 2;
1898     // Check if inputs are values of the same type
1899     for (; i &lt; req() &amp;&amp; in(i) &amp;&amp; in(i)-&gt;is_InlineTypeBase() &amp;&amp; in(i)-&gt;cmp(*in(1)); i++) {
1900       assert(in(i)-&gt;Opcode() == opcode, &quot;mixing pointers and values?&quot;);
1901     }
1902     if (i == req()) {
1903       InlineTypeBaseNode* vt = in(1)-&gt;as_InlineTypeBase()-&gt;clone_with_phis(phase, in(0));
1904       for (uint i = 2; i &lt; req(); ++i) {
1905         vt-&gt;merge_with(phase, in(i)-&gt;as_InlineTypeBase(), i, i == (req()-1));
1906       }
1907       return vt;
1908     }
1909   }
1910 
1911   Node *top = phase-&gt;C-&gt;top();
1912   bool new_phi = (outcnt() == 0); // transforming new Phi
1913   // No change for igvn if new phi is not hooked
1914   if (new_phi &amp;&amp; can_reshape)
1915     return NULL;
1916 
1917   // The are 2 situations when only one valid phi&#39;s input is left
1918   // (in addition to Region input).
1919   // One: region is not loop - replace phi with this input.
1920   // Two: region is loop - replace phi with top since this data path is dead
1921   //                       and we need to break the dead data loop.
1922   Node* progress = NULL;        // Record if any progress made
1923   for( uint j = 1; j &lt; req(); ++j ){ // For all paths in
1924     // Check unreachable control paths
1925     Node* rc = r-&gt;in(j);
1926     Node* n = in(j);            // Get the input
1927     if (rc == NULL || phase-&gt;type(rc) == Type::TOP) {
1928       if (n != top) {           // Not already top?
1929         PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1930         if (can_reshape &amp;&amp; igvn != NULL) {
1931           igvn-&gt;_worklist.push(r);
1932         }
1933         // Nuke it down
1934         if (can_reshape) {
1935           set_req_X(j, top, igvn);
1936         } else {
1937           set_req(j, top);
1938         }
1939         progress = this;        // Record progress
1940       }
1941     }
1942   }
1943 
1944   if (can_reshape &amp;&amp; outcnt() == 0) {
1945     // set_req() above may kill outputs if Phi is referenced
1946     // only by itself on the dead (top) control path.
1947     return top;
1948   }
1949 
1950   bool uncasted = false;
1951   Node* uin = unique_input(phase, false);
1952   if (uin == NULL &amp;&amp; can_reshape &amp;&amp;
1953       // If there is a chance that the region can be optimized out do
1954       // not add a cast node that we can&#39;t remove yet.
1955       !wait_for_region_igvn(phase)) {
1956     uncasted = true;
1957     uin = unique_input(phase, true);
1958   }
1959   if (uin == top) {             // Simplest case: no alive inputs.
1960     if (can_reshape)            // IGVN transformation
1961       return top;
1962     else
1963       return NULL;              // Identity will return TOP
1964   } else if (uin != NULL) {
1965     // Only one not-NULL unique input path is left.
1966     // Determine if this input is backedge of a loop.
1967     // (Skip new phis which have no uses and dead regions).
1968     if (outcnt() &gt; 0 &amp;&amp; r-&gt;in(0) != NULL) {
1969       // First, take the short cut when we know it is a loop and
1970       // the EntryControl data path is dead.
1971       // Loop node may have only one input because entry path
1972       // is removed in PhaseIdealLoop::Dominators().
1973       assert(!r-&gt;is_Loop() || r-&gt;req() &lt;= 3, &quot;Loop node should have 3 or less inputs&quot;);
1974       bool is_loop = (r-&gt;is_Loop() &amp;&amp; r-&gt;req() == 3);
1975       // Then, check if there is a data loop when phi references itself directly
1976       // or through other data nodes.
1977       if ((is_loop &amp;&amp; !uin-&gt;eqv_uncast(in(LoopNode::EntryControl))) ||
1978           (!is_loop &amp;&amp; is_unsafe_data_reference(uin))) {
1979         // Break this data loop to avoid creation of a dead loop.
1980         if (can_reshape) {
1981           return top;
1982         } else {
1983           // We can&#39;t return top if we are in Parse phase - cut inputs only
1984           // let Identity to handle the case.
1985           replace_edge(uin, top);
1986           return NULL;
1987         }
1988       }
1989     }
1990 
1991     if (uncasted) {
1992       // Add cast nodes between the phi to be removed and its unique input.
1993       // Wait until after parsing for the type information to propagate from the casts.
1994       assert(can_reshape, &quot;Invalid during parsing&quot;);
1995       const Type* phi_type = bottom_type();
1996       assert(phi_type-&gt;isa_int() || phi_type-&gt;isa_ptr(), &quot;bad phi type&quot;);
1997       // Add casts to carry the control dependency of the Phi that is
1998       // going away
1999       Node* cast = NULL;
2000       if (phi_type-&gt;isa_int()) {
2001         cast = ConstraintCastNode::make_cast(Op_CastII, r, uin, phi_type, true);
2002       } else {
2003         const Type* uin_type = phase-&gt;type(uin);
2004         if (!phi_type-&gt;isa_oopptr() &amp;&amp; !uin_type-&gt;isa_oopptr()) {
2005           cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, true);
2006         } else {
2007           // Use a CastPP for a cast to not null and a CheckCastPP for
2008           // a cast to a new klass (and both if both null-ness and
2009           // klass change).
2010 
2011           // If the type of phi is not null but the type of uin may be
2012           // null, uin&#39;s type must be casted to not null
2013           if (phi_type-&gt;join(TypePtr::NOTNULL) == phi_type-&gt;remove_speculative() &amp;&amp;
2014               uin_type-&gt;join(TypePtr::NOTNULL) != uin_type-&gt;remove_speculative()) {
2015             cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, TypePtr::NOTNULL, true);
2016           }
2017 
2018           // If the type of phi and uin, both casted to not null,
2019           // differ the klass of uin must be (check)cast&#39;ed to match
2020           // that of phi
2021           if (phi_type-&gt;join_speculative(TypePtr::NOTNULL) != uin_type-&gt;join_speculative(TypePtr::NOTNULL)) {
2022             Node* n = uin;
2023             if (cast != NULL) {
2024               cast = phase-&gt;transform(cast);
2025               n = cast;
2026             }
2027             cast = ConstraintCastNode::make_cast(Op_CheckCastPP, r, n, phi_type, true);
2028           }
2029           if (cast == NULL) {
2030             cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, true);
2031           }
2032         }
2033       }
2034       assert(cast != NULL, &quot;cast should be set&quot;);
2035       cast = phase-&gt;transform(cast);
2036       // set all inputs to the new cast(s) so the Phi is removed by Identity
2037       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
2038       for (uint i = 1; i &lt; req(); i++) {
2039         set_req_X(i, cast, igvn);
2040       }
2041       uin = cast;
2042     }
2043 
2044     // One unique input.
2045     debug_only(Node* ident = Identity(phase));
2046     // The unique input must eventually be detected by the Identity call.
2047 #ifdef ASSERT
2048     if (ident != uin &amp;&amp; !ident-&gt;is_top()) {
2049       // print this output before failing assert
2050       r-&gt;dump(3);
2051       this-&gt;dump(3);
2052       ident-&gt;dump();
2053       uin-&gt;dump();
2054     }
2055 #endif
2056     assert(ident == uin || ident-&gt;is_top(), &quot;Identity must clean this up&quot;);
2057     return NULL;
2058   }
2059 
2060   Node* opt = NULL;
2061   int true_path = is_diamond_phi();
2062   if( true_path != 0 ) {
2063     // Check for CMove&#39;ing identity. If it would be unsafe,
2064     // handle it here. In the safe case, let Identity handle it.
2065     Node* unsafe_id = is_cmove_id(phase, true_path);
2066     if( unsafe_id != NULL &amp;&amp; is_unsafe_data_reference(unsafe_id) )
2067       opt = unsafe_id;
2068 
2069     // Check for simple convert-to-boolean pattern
2070     if( opt == NULL )
2071       opt = is_x2logic(phase, this, true_path);
2072 
2073     // Check for absolute value
2074     if( opt == NULL )
2075       opt = is_absolute(phase, this, true_path);
2076 
2077     // Check for conditional add
2078     if( opt == NULL &amp;&amp; can_reshape )
2079       opt = is_cond_add(phase, this, true_path);
2080 
2081     // These 4 optimizations could subsume the phi:
2082     // have to check for a dead data loop creation.
2083     if( opt != NULL ) {
2084       if( opt == unsafe_id || is_unsafe_data_reference(opt) ) {
2085         // Found dead loop.
2086         if( can_reshape )
2087           return top;
2088         // We can&#39;t return top if we are in Parse phase - cut inputs only
2089         // to stop further optimizations for this phi. Identity will return TOP.
2090         assert(req() == 3, &quot;only diamond merge phi here&quot;);
2091         set_req(1, top);
2092         set_req(2, top);
2093         return NULL;
2094       } else {
2095         return opt;
2096       }
2097     }
2098   }
2099 
2100   // Check for merging identical values and split flow paths
2101   if (can_reshape) {
2102     opt = split_flow_path(phase, this);
2103     // This optimization only modifies phi - don&#39;t need to check for dead loop.
2104     assert(opt == NULL || phase-&gt;eqv(opt, this), &quot;do not elide phi&quot;);
2105     if (opt != NULL)  return opt;
2106   }
2107 
2108   if (in(1) != NULL &amp;&amp; in(1)-&gt;Opcode() == Op_AddP &amp;&amp; can_reshape) {
2109     // Try to undo Phi of AddP:
2110     // (Phi (AddP base address offset) (AddP base2 address2 offset2))
2111     // becomes:
2112     // newbase := (Phi base base2)
2113     // newaddress := (Phi address address2)
2114     // newoffset := (Phi offset offset2)
2115     // (AddP newbase newaddress newoffset)
2116     //
2117     // This occurs as a result of unsuccessful split_thru_phi and
2118     // interferes with taking advantage of addressing modes. See the
2119     // clone_shift_expressions code in matcher.cpp
2120     Node* addp = in(1);
2121     Node* base = addp-&gt;in(AddPNode::Base);
2122     Node* address = addp-&gt;in(AddPNode::Address);
2123     Node* offset = addp-&gt;in(AddPNode::Offset);
2124     if (base != NULL &amp;&amp; address != NULL &amp;&amp; offset != NULL &amp;&amp;
2125         !base-&gt;is_top() &amp;&amp; !address-&gt;is_top() &amp;&amp; !offset-&gt;is_top()) {
2126       const Type* base_type = base-&gt;bottom_type();
2127       const Type* address_type = address-&gt;bottom_type();
2128       // make sure that all the inputs are similar to the first one,
2129       // i.e. AddP with base == address and same offset as first AddP
2130       bool doit = true;
2131       for (uint i = 2; i &lt; req(); i++) {
2132         if (in(i) == NULL ||
2133             in(i)-&gt;Opcode() != Op_AddP ||
2134             in(i)-&gt;in(AddPNode::Base) == NULL ||
2135             in(i)-&gt;in(AddPNode::Address) == NULL ||
2136             in(i)-&gt;in(AddPNode::Offset) == NULL ||
2137             in(i)-&gt;in(AddPNode::Base)-&gt;is_top() ||
2138             in(i)-&gt;in(AddPNode::Address)-&gt;is_top() ||
2139             in(i)-&gt;in(AddPNode::Offset)-&gt;is_top()) {
2140           doit = false;
2141           break;
2142         }
2143         if (in(i)-&gt;in(AddPNode::Offset) != base) {
2144           base = NULL;
2145         }
2146         if (in(i)-&gt;in(AddPNode::Offset) != offset) {
2147           offset = NULL;
2148         }
2149         if (in(i)-&gt;in(AddPNode::Address) != address) {
2150           address = NULL;
2151         }
2152         // Accumulate type for resulting Phi
2153         base_type = base_type-&gt;meet_speculative(in(i)-&gt;in(AddPNode::Base)-&gt;bottom_type());
2154         address_type = address_type-&gt;meet_speculative(in(i)-&gt;in(AddPNode::Address)-&gt;bottom_type());
2155       }
2156       if (doit &amp;&amp; base == NULL) {
2157         // Check for neighboring AddP nodes in a tree.
2158         // If they have a base, use that it.
2159         for (DUIterator_Fast kmax, k = this-&gt;fast_outs(kmax); k &lt; kmax; k++) {
2160           Node* u = this-&gt;fast_out(k);
2161           if (u-&gt;is_AddP()) {
2162             Node* base2 = u-&gt;in(AddPNode::Base);
2163             if (base2 != NULL &amp;&amp; !base2-&gt;is_top()) {
2164               if (base == NULL)
2165                 base = base2;
2166               else if (base != base2)
2167                 { doit = false; break; }
2168             }
2169           }
2170         }
2171       }
2172       if (doit) {
2173         if (base == NULL) {
2174           base = new PhiNode(in(0), base_type, NULL);
2175           for (uint i = 1; i &lt; req(); i++) {
2176             base-&gt;init_req(i, in(i)-&gt;in(AddPNode::Base));
2177           }
2178           phase-&gt;is_IterGVN()-&gt;register_new_node_with_optimizer(base);
2179         }
2180         if (address == NULL) {
2181           address = new PhiNode(in(0), address_type, NULL);
2182           for (uint i = 1; i &lt; req(); i++) {
2183             address-&gt;init_req(i, in(i)-&gt;in(AddPNode::Address));
2184           }
2185           phase-&gt;is_IterGVN()-&gt;register_new_node_with_optimizer(address);
2186         }
2187         if (offset == NULL) {
2188           offset = new PhiNode(in(0), TypeX_X, NULL);
2189           for (uint i = 1; i &lt; req(); i++) {
2190             offset-&gt;init_req(i, in(i)-&gt;in(AddPNode::Offset));
2191           }
2192           phase-&gt;is_IterGVN()-&gt;register_new_node_with_optimizer(offset);
2193         }
2194         return new AddPNode(base, address, offset);
2195       }
2196     }
2197   }
2198 
2199   // Split phis through memory merges, so that the memory merges will go away.
2200   // Piggy-back this transformation on the search for a unique input....
2201   // It will be as if the merged memory is the unique value of the phi.
2202   // (Do not attempt this optimization unless parsing is complete.
2203   // It would make the parser&#39;s memory-merge logic sick.)
2204   // (MergeMemNode is not dead_loop_safe - need to check for dead loop.)
2205   if (progress == NULL &amp;&amp; can_reshape &amp;&amp; type() == Type::MEMORY) {
2206     // see if this phi should be sliced
2207     uint merge_width = 0;
2208     bool saw_self = false;
2209     // TODO revisit this with JDK-8247216
2210     bool mergemem_only = true;
2211     for( uint i=1; i&lt;req(); ++i ) {// For all paths in
2212       Node *ii = in(i);
2213       // TOP inputs should not be counted as safe inputs because if the
2214       // Phi references itself through all other inputs then splitting the
2215       // Phi through memory merges would create dead loop at later stage.
2216       if (ii == top) {
2217         return NULL; // Delay optimization until graph is cleaned.
2218       }
2219       if (ii-&gt;is_MergeMem()) {
2220         MergeMemNode* n = ii-&gt;as_MergeMem();
2221         merge_width = MAX2(merge_width, n-&gt;req());
2222         saw_self = saw_self || phase-&gt;eqv(n-&gt;base_memory(), this);
2223       } else {
2224         mergemem_only = false;
2225       }
2226     }
2227 
2228     // This restriction is temporarily necessary to ensure termination:
2229     if (!mergemem_only &amp;&amp; !saw_self &amp;&amp; adr_type() == TypePtr::BOTTOM)  merge_width = 0;
2230 
2231     if (merge_width &gt; Compile::AliasIdxRaw) {
2232       // found at least one non-empty MergeMem
2233       const TypePtr* at = adr_type();
2234       if (at != TypePtr::BOTTOM) {
2235         // Patch the existing phi to select an input from the merge:
2236         // Phi:AT1(...MergeMem(m0, m1, m2)...) into
2237         //     Phi:AT1(...m1...)
2238         int alias_idx = phase-&gt;C-&gt;get_alias_index(at);
2239         for (uint i=1; i&lt;req(); ++i) {
2240           Node *ii = in(i);
2241           if (ii-&gt;is_MergeMem()) {
2242             MergeMemNode* n = ii-&gt;as_MergeMem();
2243             // compress paths and change unreachable cycles to TOP
2244             // If not, we can update the input infinitely along a MergeMem cycle
2245             // Equivalent code is in MemNode::Ideal_common
2246             Node *m  = phase-&gt;transform(n);
2247             if (outcnt() == 0) {  // Above transform() may kill us!
2248               return top;
2249             }
2250             // If transformed to a MergeMem, get the desired slice
2251             // Otherwise the returned node represents memory for every slice
2252             Node *new_mem = (m-&gt;is_MergeMem()) ?
2253                              m-&gt;as_MergeMem()-&gt;memory_at(alias_idx) : m;
2254             // Update input if it is progress over what we have now
2255             if (new_mem != ii) {
2256               set_req(i, new_mem);
2257               progress = this;
2258             }
2259           }
2260         }
2261       } else {
2262         // We know that at least one MergeMem-&gt;base_memory() == this
2263         // (saw_self == true). If all other inputs also references this phi
2264         // (directly or through data nodes) - it is dead loop.
2265         bool saw_safe_input = false;
2266         for (uint j = 1; j &lt; req(); ++j) {
2267           Node *n = in(j);
2268           if (n-&gt;is_MergeMem() &amp;&amp; n-&gt;as_MergeMem()-&gt;base_memory() == this)
2269             continue;              // skip known cases
2270           if (!is_unsafe_data_reference(n)) {
2271             saw_safe_input = true; // found safe input
2272             break;
2273           }
2274         }
2275         if (!saw_safe_input)
2276           return top; // all inputs reference back to this phi - dead loop
2277 
2278         // Phi(...MergeMem(m0, m1:AT1, m2:AT2)...) into
2279         //     MergeMem(Phi(...m0...), Phi:AT1(...m1...), Phi:AT2(...m2...))
2280         PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
2281         Node* hook = new Node(1);
2282         PhiNode* new_base = (PhiNode*) clone();
2283         // Must eagerly register phis, since they participate in loops.
2284         if (igvn) {
2285           igvn-&gt;register_new_node_with_optimizer(new_base);
2286           hook-&gt;add_req(new_base);
2287         }
2288         MergeMemNode* result = MergeMemNode::make(new_base);
2289         for (uint i = 1; i &lt; req(); ++i) {
2290           Node *ii = in(i);
2291           if (ii-&gt;is_MergeMem()) {
2292             MergeMemNode* n = ii-&gt;as_MergeMem();
2293             for (MergeMemStream mms(result, n); mms.next_non_empty2(); ) {
2294               // If we have not seen this slice yet, make a phi for it.
2295               bool made_new_phi = false;
2296               if (mms.is_empty()) {
2297                 Node* new_phi = new_base-&gt;slice_memory(mms.adr_type(phase-&gt;C));
2298                 made_new_phi = true;
2299                 if (igvn) {
2300                   igvn-&gt;register_new_node_with_optimizer(new_phi);
2301                   hook-&gt;add_req(new_phi);
2302                 }
2303                 mms.set_memory(new_phi);
2304               }
2305               Node* phi = mms.memory();
2306               assert(made_new_phi || phi-&gt;in(i) == n, &quot;replace the i-th merge by a slice&quot;);
2307               phi-&gt;set_req(i, mms.memory2());
2308             }
2309           }
2310         }
2311         // Distribute all self-loops.
2312         { // (Extra braces to hide mms.)
2313           for (MergeMemStream mms(result); mms.next_non_empty(); ) {
2314             Node* phi = mms.memory();
2315             for (uint i = 1; i &lt; req(); ++i) {
2316               if (phi-&gt;in(i) == this)  phi-&gt;set_req(i, phi);
2317             }
2318           }
2319         }
2320         // now transform the new nodes, and return the mergemem
2321         for (MergeMemStream mms(result); mms.next_non_empty(); ) {
2322           Node* phi = mms.memory();
2323           mms.set_memory(phase-&gt;transform(phi));
2324         }
2325         if (igvn) { // Unhook.
2326           igvn-&gt;hash_delete(hook);
2327           for (uint i = 1; i &lt; hook-&gt;req(); i++) {
2328             hook-&gt;set_req(i, NULL);
2329           }
2330         }
2331         // Replace self with the result.
2332         return result;
2333       }
2334     }
2335     //
2336     // Other optimizations on the memory chain
2337     //
2338     const TypePtr* at = adr_type();
2339     for( uint i=1; i&lt;req(); ++i ) {// For all paths in
2340       Node *ii = in(i);
2341       Node *new_in = MemNode::optimize_memory_chain(ii, at, NULL, phase);
2342       if (ii != new_in ) {
2343         set_req(i, new_in);
2344         progress = this;
2345       }
2346     }
2347   }
2348 
2349 #ifdef _LP64
2350   // Push DecodeN/DecodeNKlass down through phi.
2351   // The rest of phi graph will transform by split EncodeP node though phis up.
2352   if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp; can_reshape &amp;&amp; progress == NULL) {
2353     bool may_push = true;
2354     bool has_decodeN = false;
2355     bool is_decodeN = false;
2356     for (uint i=1; i&lt;req(); ++i) {// For all paths in
2357       Node *ii = in(i);
2358       if (ii-&gt;is_DecodeNarrowPtr() &amp;&amp; ii-&gt;bottom_type() == bottom_type()) {
2359         // Do optimization if a non dead path exist.
2360         if (ii-&gt;in(1)-&gt;bottom_type() != Type::TOP) {
2361           has_decodeN = true;
2362           is_decodeN = ii-&gt;is_DecodeN();
2363         }
2364       } else if (!ii-&gt;is_Phi()) {
2365         may_push = false;
2366       }
2367     }
2368 
2369     if (has_decodeN &amp;&amp; may_push) {
2370       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
2371       // Make narrow type for new phi.
2372       const Type* narrow_t;
2373       if (is_decodeN) {
2374         narrow_t = TypeNarrowOop::make(this-&gt;bottom_type()-&gt;is_ptr());
2375       } else {
2376         narrow_t = TypeNarrowKlass::make(this-&gt;bottom_type()-&gt;is_ptr());
2377       }
2378       PhiNode* new_phi = new PhiNode(r, narrow_t);
2379       uint orig_cnt = req();
2380       for (uint i=1; i&lt;req(); ++i) {// For all paths in
2381         Node *ii = in(i);
2382         Node* new_ii = NULL;
2383         if (ii-&gt;is_DecodeNarrowPtr()) {
2384           assert(ii-&gt;bottom_type() == bottom_type(), &quot;sanity&quot;);
2385           new_ii = ii-&gt;in(1);
2386         } else {
2387           assert(ii-&gt;is_Phi(), &quot;sanity&quot;);
2388           if (ii-&gt;as_Phi() == this) {
2389             new_ii = new_phi;
2390           } else {
2391             if (is_decodeN) {
2392               new_ii = new EncodePNode(ii, narrow_t);
2393             } else {
2394               new_ii = new EncodePKlassNode(ii, narrow_t);
2395             }
2396             igvn-&gt;register_new_node_with_optimizer(new_ii);
2397           }
2398         }
2399         new_phi-&gt;set_req(i, new_ii);
2400       }
2401       igvn-&gt;register_new_node_with_optimizer(new_phi, this);
2402       if (is_decodeN) {
2403         progress = new DecodeNNode(new_phi, bottom_type());
2404       } else {
2405         progress = new DecodeNKlassNode(new_phi, bottom_type());
2406       }
2407     }
2408   }
2409 #endif
2410 
2411   return progress;              // Return any progress
2412 }
2413 
2414 //------------------------------is_tripcount-----------------------------------
2415 bool PhiNode::is_tripcount() const {
2416   return (in(0) != NULL &amp;&amp; in(0)-&gt;is_CountedLoop() &amp;&amp;
2417           in(0)-&gt;as_CountedLoop()-&gt;phi() == this);
2418 }
2419 
2420 //------------------------------out_RegMask------------------------------------
2421 const RegMask &amp;PhiNode::in_RegMask(uint i) const {
2422   return i ? out_RegMask() : RegMask::Empty;
2423 }
2424 
2425 const RegMask &amp;PhiNode::out_RegMask() const {
2426   uint ideal_reg = _type-&gt;ideal_reg();
2427   assert( ideal_reg != Node::NotAMachineReg, &quot;invalid type at Phi&quot; );
2428   if( ideal_reg == 0 ) return RegMask::Empty;
2429   assert(ideal_reg != Op_RegFlags, &quot;flags register is not spillable&quot;);
2430   return *(Compile::current()-&gt;matcher()-&gt;idealreg2spillmask[ideal_reg]);
2431 }
2432 
2433 #ifndef PRODUCT
2434 void PhiNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
2435   // For a PhiNode, the set of related nodes includes all inputs till level 2,
2436   // and all outputs till level 1. In compact mode, inputs till level 1 are
2437   // collected.
2438   this-&gt;collect_nodes(in_rel, compact ? 1 : 2, false, false);
2439   this-&gt;collect_nodes(out_rel, -1, false, false);
2440 }
2441 
2442 void PhiNode::dump_spec(outputStream *st) const {
2443   TypeNode::dump_spec(st);
2444   if (is_tripcount()) {
2445     st-&gt;print(&quot; #tripcount&quot;);
2446   }
2447 }
2448 #endif
2449 
2450 
2451 //=============================================================================
2452 const Type* GotoNode::Value(PhaseGVN* phase) const {
2453   // If the input is reachable, then we are executed.
2454   // If the input is not reachable, then we are not executed.
2455   return phase-&gt;type(in(0));
2456 }
2457 
2458 Node* GotoNode::Identity(PhaseGVN* phase) {
2459   return in(0);                // Simple copy of incoming control
2460 }
2461 
2462 const RegMask &amp;GotoNode::out_RegMask() const {
2463   return RegMask::Empty;
2464 }
2465 
2466 #ifndef PRODUCT
2467 //-----------------------------related-----------------------------------------
2468 // The related nodes of a GotoNode are all inputs at level 1, as well as the
2469 // outputs at level 1. This is regardless of compact mode.
2470 void GotoNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
2471   this-&gt;collect_nodes(in_rel, 1, false, false);
2472   this-&gt;collect_nodes(out_rel, -1, false, false);
2473 }
2474 #endif
2475 
2476 
2477 //=============================================================================
2478 const RegMask &amp;JumpNode::out_RegMask() const {
2479   return RegMask::Empty;
2480 }
2481 
2482 #ifndef PRODUCT
2483 //-----------------------------related-----------------------------------------
2484 // The related nodes of a JumpNode are all inputs at level 1, as well as the
2485 // outputs at level 2 (to include actual jump targets beyond projection nodes).
2486 // This is regardless of compact mode.
2487 void JumpNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
2488   this-&gt;collect_nodes(in_rel, 1, false, false);
2489   this-&gt;collect_nodes(out_rel, -2, false, false);
2490 }
2491 #endif
2492 
2493 //=============================================================================
2494 const RegMask &amp;JProjNode::out_RegMask() const {
2495   return RegMask::Empty;
2496 }
2497 
2498 //=============================================================================
2499 const RegMask &amp;CProjNode::out_RegMask() const {
2500   return RegMask::Empty;
2501 }
2502 
2503 
2504 
2505 //=============================================================================
2506 
2507 uint PCTableNode::hash() const { return Node::hash() + _size; }
2508 bool PCTableNode::cmp( const Node &amp;n ) const
2509 { return _size == ((PCTableNode&amp;)n)._size; }
2510 
2511 const Type *PCTableNode::bottom_type() const {
2512   const Type** f = TypeTuple::fields(_size);
2513   for( uint i = 0; i &lt; _size; i++ ) f[i] = Type::CONTROL;
2514   return TypeTuple::make(_size, f);
2515 }
2516 
2517 //------------------------------Value------------------------------------------
2518 // Compute the type of the PCTableNode.  If reachable it is a tuple of
2519 // Control, otherwise the table targets are not reachable
2520 const Type* PCTableNode::Value(PhaseGVN* phase) const {
2521   if( phase-&gt;type(in(0)) == Type::CONTROL )
2522     return bottom_type();
2523   return Type::TOP;             // All paths dead?  Then so are we
2524 }
2525 
2526 //------------------------------Ideal------------------------------------------
2527 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
2528 // control copies
2529 Node *PCTableNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2530   return remove_dead_region(phase, can_reshape) ? this : NULL;
2531 }
2532 
2533 //=============================================================================
2534 uint JumpProjNode::hash() const {
2535   return Node::hash() + _dest_bci;
2536 }
2537 
2538 bool JumpProjNode::cmp( const Node &amp;n ) const {
2539   return ProjNode::cmp(n) &amp;&amp;
2540     _dest_bci == ((JumpProjNode&amp;)n)._dest_bci;
2541 }
2542 
2543 #ifndef PRODUCT
2544 void JumpProjNode::dump_spec(outputStream *st) const {
2545   ProjNode::dump_spec(st);
2546   st-&gt;print(&quot;@bci %d &quot;,_dest_bci);
2547 }
2548 
2549 void JumpProjNode::dump_compact_spec(outputStream *st) const {
2550   ProjNode::dump_compact_spec(st);
2551   st-&gt;print(&quot;(%d)%d@%d&quot;, _switch_val, _proj_no, _dest_bci);
2552 }
2553 
2554 void JumpProjNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
2555   // The related nodes of a JumpProjNode are its inputs and outputs at level 1.
2556   this-&gt;collect_nodes(in_rel, 1, false, false);
2557   this-&gt;collect_nodes(out_rel, -1, false, false);
2558 }
2559 #endif
2560 
2561 //=============================================================================
2562 //------------------------------Value------------------------------------------
2563 // Check for being unreachable, or for coming from a Rethrow.  Rethrow&#39;s cannot
2564 // have the default &quot;fall_through_index&quot; path.
2565 const Type* CatchNode::Value(PhaseGVN* phase) const {
2566   // Unreachable?  Then so are all paths from here.
2567   if( phase-&gt;type(in(0)) == Type::TOP ) return Type::TOP;
2568   // First assume all paths are reachable
2569   const Type** f = TypeTuple::fields(_size);
2570   for( uint i = 0; i &lt; _size; i++ ) f[i] = Type::CONTROL;
2571   // Identify cases that will always throw an exception
2572   // () rethrow call
2573   // () virtual or interface call with NULL receiver
2574   // () call is a check cast with incompatible arguments
2575   if( in(1)-&gt;is_Proj() ) {
2576     Node *i10 = in(1)-&gt;in(0);
2577     if( i10-&gt;is_Call() ) {
2578       CallNode *call = i10-&gt;as_Call();
2579       // Rethrows always throw exceptions, never return
2580       if (call-&gt;entry_point() == OptoRuntime::rethrow_stub()) {
2581         f[CatchProjNode::fall_through_index] = Type::TOP;
2582       } else if( call-&gt;req() &gt; TypeFunc::Parms ) {
2583         const Type *arg0 = phase-&gt;type( call-&gt;in(TypeFunc::Parms) );
2584         // Check for null receiver to virtual or interface calls
2585         if( call-&gt;is_CallDynamicJava() &amp;&amp;
2586             arg0-&gt;higher_equal(TypePtr::NULL_PTR) ) {
2587           f[CatchProjNode::fall_through_index] = Type::TOP;
2588         }
2589       } // End of if not a runtime stub
2590     } // End of if have call above me
2591   } // End of slot 1 is not a projection
2592   return TypeTuple::make(_size, f);
2593 }
2594 
2595 //=============================================================================
2596 uint CatchProjNode::hash() const {
2597   return Node::hash() + _handler_bci;
2598 }
2599 
2600 
2601 bool CatchProjNode::cmp( const Node &amp;n ) const {
2602   return ProjNode::cmp(n) &amp;&amp;
2603     _handler_bci == ((CatchProjNode&amp;)n)._handler_bci;
2604 }
2605 
2606 
2607 //------------------------------Identity---------------------------------------
2608 // If only 1 target is possible, choose it if it is the main control
2609 Node* CatchProjNode::Identity(PhaseGVN* phase) {
2610   // If my value is control and no other value is, then treat as ID
2611   const TypeTuple *t = phase-&gt;type(in(0))-&gt;is_tuple();
2612   if (t-&gt;field_at(_con) != Type::CONTROL)  return this;
2613   // If we remove the last CatchProj and elide the Catch/CatchProj, then we
2614   // also remove any exception table entry.  Thus we must know the call
2615   // feeding the Catch will not really throw an exception.  This is ok for
2616   // the main fall-thru control (happens when we know a call can never throw
2617   // an exception) or for &quot;rethrow&quot;, because a further optimization will
2618   // yank the rethrow (happens when we inline a function that can throw an
2619   // exception and the caller has no handler).  Not legal, e.g., for passing
2620   // a NULL receiver to a v-call, or passing bad types to a slow-check-cast.
2621   // These cases MUST throw an exception via the runtime system, so the VM
2622   // will be looking for a table entry.
2623   Node *proj = in(0)-&gt;in(1);    // Expect a proj feeding CatchNode
2624   CallNode *call;
2625   if (_con != TypeFunc::Control &amp;&amp; // Bail out if not the main control.
2626       !(proj-&gt;is_Proj() &amp;&amp;      // AND NOT a rethrow
2627         proj-&gt;in(0)-&gt;is_Call() &amp;&amp;
2628         (call = proj-&gt;in(0)-&gt;as_Call()) &amp;&amp;
2629         call-&gt;entry_point() == OptoRuntime::rethrow_stub()))
2630     return this;
2631 
2632   // Search for any other path being control
2633   for (uint i = 0; i &lt; t-&gt;cnt(); i++) {
2634     if (i != _con &amp;&amp; t-&gt;field_at(i) == Type::CONTROL)
2635       return this;
2636   }
2637   // Only my path is possible; I am identity on control to the jump
2638   return in(0)-&gt;in(0);
2639 }
2640 
2641 
2642 #ifndef PRODUCT
2643 void CatchProjNode::dump_spec(outputStream *st) const {
2644   ProjNode::dump_spec(st);
2645   st-&gt;print(&quot;@bci %d &quot;,_handler_bci);
2646 }
2647 #endif
2648 
2649 //=============================================================================
2650 //------------------------------Identity---------------------------------------
2651 // Check for CreateEx being Identity.
2652 Node* CreateExNode::Identity(PhaseGVN* phase) {
2653   if( phase-&gt;type(in(1)) == Type::TOP ) return in(1);
2654   if( phase-&gt;type(in(0)) == Type::TOP ) return in(0);
2655   // We only come from CatchProj, unless the CatchProj goes away.
2656   // If the CatchProj is optimized away, then we just carry the
2657   // exception oop through.
2658 
2659   // CheckCastPPNode::Ideal() for inline types reuses the exception
2660   // paths of a call to perform an allocation: we can see a Phi here.
2661   if (in(1)-&gt;is_Phi()) {
2662     return this;
2663   }
2664   CallNode *call = in(1)-&gt;in(0)-&gt;as_Call();
2665 
2666   return ( in(0)-&gt;is_CatchProj() &amp;&amp; in(0)-&gt;in(0)-&gt;in(1) == in(1) )
2667     ? this
2668     : call-&gt;in(TypeFunc::Parms);
2669 }
2670 
2671 //=============================================================================
2672 //------------------------------Value------------------------------------------
2673 // Check for being unreachable.
2674 const Type* NeverBranchNode::Value(PhaseGVN* phase) const {
2675   if (!in(0) || in(0)-&gt;is_top()) return Type::TOP;
2676   return bottom_type();
2677 }
2678 
2679 //------------------------------Ideal------------------------------------------
2680 // Check for no longer being part of a loop
2681 Node *NeverBranchNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2682   if (can_reshape &amp;&amp; !in(0)-&gt;is_Loop()) {
2683     // Dead code elimination can sometimes delete this projection so
2684     // if it&#39;s not there, there&#39;s nothing to do.
2685     Node* fallthru = proj_out_or_null(0);
2686     if (fallthru != NULL) {
2687       phase-&gt;is_IterGVN()-&gt;replace_node(fallthru, in(0));
2688     }
2689     return phase-&gt;C-&gt;top();
2690   }
2691   return NULL;
2692 }
2693 
2694 #ifndef PRODUCT
2695 void NeverBranchNode::format( PhaseRegAlloc *ra_, outputStream *st) const {
2696   st-&gt;print(&quot;%s&quot;, Name());
2697 }
2698 #endif
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>