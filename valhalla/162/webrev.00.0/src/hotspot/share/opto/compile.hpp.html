<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/compile.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_COMPILE_HPP
  26 #define SHARE_OPTO_COMPILE_HPP
  27 
  28 #include &quot;asm/codeBuffer.hpp&quot;
  29 #include &quot;ci/compilerInterface.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compilerOracle.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/compilerEvent.hpp&quot;
  34 #include &quot;libadt/dict.hpp&quot;
  35 #include &quot;libadt/vectset.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/methodData.hpp&quot;
  38 #include &quot;opto/idealGraphPrinter.hpp&quot;
  39 #include &quot;opto/phasetype.hpp&quot;
  40 #include &quot;opto/phase.hpp&quot;
  41 #include &quot;opto/regmask.hpp&quot;
  42 #include &quot;runtime/deoptimization.hpp&quot;
  43 #include &quot;runtime/timerTrace.hpp&quot;
  44 #include &quot;runtime/vmThread.hpp&quot;
  45 #include &quot;utilities/ticks.hpp&quot;
  46 
  47 class AddPNode;
  48 class Block;
  49 class Bundle;
  50 class CallGenerator;
  51 class CallNode;
  52 class CloneMap;
  53 class ConnectionGraph;
  54 class IdealGraphPrinter;
  55 class InlineTree;
  56 class Int_Array;
  57 class Matcher;
  58 class MachConstantNode;
  59 class MachConstantBaseNode;
  60 class MachNode;
  61 class MachOper;
  62 class MachSafePointNode;
  63 class Node;
  64 class Node_Array;
  65 class Node_Notes;
  66 class NodeCloneInfo;
  67 class OptoReg;
  68 class PhaseCFG;
  69 class PhaseGVN;
  70 class PhaseIterGVN;
  71 class PhaseRegAlloc;
  72 class PhaseCCP;
  73 class PhaseCCP_DCE;
  74 class PhaseOutput;
  75 class RootNode;
  76 class relocInfo;
  77 class Scope;
  78 class StartNode;
  79 class SafePointNode;
  80 class JVMState;
  81 class Type;
  82 class TypeData;
  83 class TypeInt;
  84 class TypePtr;
  85 class TypeOopPtr;
  86 class TypeFunc;
  87 class TypeVect;
  88 class Unique_Node_List;
  89 class InlineTypeBaseNode;
  90 class nmethod;
  91 class WarmCallInfo;
  92 class Node_Stack;
  93 struct Final_Reshape_Counts;
  94 
  95 enum LoopOptsMode {
  96   LoopOptsDefault,
  97   LoopOptsNone,
  98   LoopOptsMaxUnroll,
  99   LoopOptsShenandoahExpand,
 100   LoopOptsShenandoahPostExpand,
 101   LoopOptsSkipSplitIf,
 102   LoopOptsVerify
 103 };
 104 
 105 typedef unsigned int node_idx_t;
 106 class NodeCloneInfo {
 107  private:
 108   uint64_t _idx_clone_orig;
 109  public:
 110 
 111   void set_idx(node_idx_t idx) {
 112     _idx_clone_orig = (_idx_clone_orig &amp; CONST64(0xFFFFFFFF00000000)) | idx;
 113   }
 114   node_idx_t idx() const { return (node_idx_t)(_idx_clone_orig &amp; 0xFFFFFFFF); }
 115 
 116   void set_gen(int generation) {
 117     uint64_t g = (uint64_t)generation &lt;&lt; 32;
 118     _idx_clone_orig = (_idx_clone_orig &amp; 0xFFFFFFFF) | g;
 119   }
 120   int gen() const { return (int)(_idx_clone_orig &gt;&gt; 32); }
 121 
 122   void set(uint64_t x) { _idx_clone_orig = x; }
 123   void set(node_idx_t x, int g) { set_idx(x); set_gen(g); }
 124   uint64_t get() const { return _idx_clone_orig; }
 125 
 126   NodeCloneInfo(uint64_t idx_clone_orig) : _idx_clone_orig(idx_clone_orig) {}
 127   NodeCloneInfo(node_idx_t x, int g) : _idx_clone_orig(0) { set(x, g); }
 128 
 129   void dump() const;
 130 };
 131 
 132 class CloneMap {
 133   friend class Compile;
 134  private:
 135   bool      _debug;
 136   Dict*     _dict;
 137   int       _clone_idx;   // current cloning iteration/generation in loop unroll
 138  public:
 139   void*     _2p(node_idx_t key)   const          { return (void*)(intptr_t)key; } // 2 conversion functions to make gcc happy
 140   node_idx_t _2_node_idx_t(const void* k) const  { return (node_idx_t)(intptr_t)k; }
 141   Dict*     dict()                const          { return _dict; }
 142   void insert(node_idx_t key, uint64_t val)      { assert(_dict-&gt;operator[](_2p(key)) == NULL, &quot;key existed&quot;); _dict-&gt;Insert(_2p(key), (void*)val); }
 143   void insert(node_idx_t key, NodeCloneInfo&amp; ci) { insert(key, ci.get()); }
 144   void remove(node_idx_t key)                    { _dict-&gt;Delete(_2p(key)); }
 145   uint64_t value(node_idx_t key)  const          { return (uint64_t)_dict-&gt;operator[](_2p(key)); }
 146   node_idx_t idx(node_idx_t key)  const          { return NodeCloneInfo(value(key)).idx(); }
 147   int gen(node_idx_t key)         const          { return NodeCloneInfo(value(key)).gen(); }
 148   int gen(const void* k)          const          { return gen(_2_node_idx_t(k)); }
 149   int max_gen()                   const;
 150   void clone(Node* old, Node* nnn, int gen);
 151   void verify_insert_and_clone(Node* old, Node* nnn, int gen);
 152   void dump(node_idx_t key)       const;
 153 
 154   int  clone_idx() const                         { return _clone_idx; }
 155   void set_clone_idx(int x)                      { _clone_idx = x; }
 156   bool is_debug()                 const          { return _debug; }
 157   void set_debug(bool debug)                     { _debug = debug; }
 158   static const char* debug_option_name;
 159 
 160   bool same_idx(node_idx_t k1, node_idx_t k2)  const { return idx(k1) == idx(k2); }
 161   bool same_gen(node_idx_t k1, node_idx_t k2)  const { return gen(k1) == gen(k2); }
 162 };
 163 
 164 //------------------------------Compile----------------------------------------
 165 // This class defines a top-level Compiler invocation.
 166 
 167 class Compile : public Phase {
 168   friend class VMStructs;
 169 
 170  public:
 171   // Fixed alias indexes.  (See also MergeMemNode.)
 172   enum {
 173     AliasIdxTop = 1,  // pseudo-index, aliases to nothing (used as sentinel value)
 174     AliasIdxBot = 2,  // pseudo-index, aliases to everything
 175     AliasIdxRaw = 3   // hard-wired index for TypeRawPtr::BOTTOM
 176   };
 177 
 178   // Variant of TraceTime(NULL, &amp;_t_accumulator, CITime);
 179   // Integrated with logging.  If logging is turned on, and CITimeVerbose is true,
 180   // then brackets are put into the log, with time stamps and node counts.
 181   // (The time collection itself is always conditionalized on CITime.)
 182   class TracePhase : public TraceTime {
 183    private:
 184     Compile*    C;
 185     CompileLog* _log;
 186     const char* _phase_name;
 187     bool _dolog;
 188    public:
 189     TracePhase(const char* name, elapsedTimer* accumulator);
 190     ~TracePhase();
 191   };
 192 
 193   // Information per category of alias (memory slice)
 194   class AliasType {
 195    private:
 196     friend class Compile;
 197 
 198     int             _index;         // unique index, used with MergeMemNode
 199     const TypePtr*  _adr_type;      // normalized address type
 200     ciField*        _field;         // relevant instance field, or null if none
 201     const Type*     _element;       // relevant array element type, or null if none
 202     bool            _is_rewritable; // false if the memory is write-once only
 203     int             _general_index; // if this is type is an instance, the general
 204                                     // type that this is an instance of
 205 
 206     void Init(int i, const TypePtr* at);
 207 
 208    public:
 209     int             index()         const { return _index; }
 210     const TypePtr*  adr_type()      const { return _adr_type; }
 211     ciField*        field()         const { return _field; }
 212     const Type*     element()       const { return _element; }
 213     bool            is_rewritable() const { return _is_rewritable; }
 214     bool            is_volatile()   const { return (_field ? _field-&gt;is_volatile() : false); }
 215     int             general_index() const { return (_general_index != 0) ? _general_index : _index; }
 216 
 217     void set_rewritable(bool z) { _is_rewritable = z; }
 218     void set_field(ciField* f) {
 219       assert(!_field,&quot;&quot;);
 220       _field = f;
 221       if (f-&gt;is_final() || f-&gt;is_stable()) {
 222         // In the case of @Stable, multiple writes are possible but may be assumed to be no-ops.
 223         _is_rewritable = false;
 224       }
 225     }
 226     void set_element(const Type* e) {
 227       assert(_element == NULL, &quot;&quot;);
 228       _element = e;
 229     }
 230 
 231     BasicType basic_type() const;
 232 
 233     void print_on(outputStream* st) PRODUCT_RETURN;
 234   };
 235 
 236   enum {
 237     logAliasCacheSize = 6,
 238     AliasCacheSize = (1&lt;&lt;logAliasCacheSize)
 239   };
 240   struct AliasCacheEntry { const TypePtr* _adr_type; int _index; };  // simple duple type
 241   enum {
 242     trapHistLength = MethodData::_trap_hist_limit
 243   };
 244 
 245  private:
 246   // Fixed parameters to this compilation.
 247   const int             _compile_id;
 248   const bool            _save_argument_registers; // save/restore arg regs for trampolines
 249   const bool            _subsume_loads;         // Load can be matched as part of a larger op.
 250   const bool            _do_escape_analysis;    // Do escape analysis.
 251   const bool            _install_code;          // Install the code that was compiled
 252   const bool            _eliminate_boxing;      // Do boxing elimination.
 253   ciMethod*             _method;                // The method being compiled.
 254   int                   _entry_bci;             // entry bci for osr methods.
 255   const TypeFunc*       _tf;                    // My kind of signature
 256   InlineTree*           _ilt;                   // Ditto (temporary).
 257   address               _stub_function;         // VM entry for stub being compiled, or NULL
 258   const char*           _stub_name;             // Name of stub or adapter being compiled, or NULL
 259   address               _stub_entry_point;      // Compile code entry for generated stub, or NULL
 260 
 261   // Control of this compilation.
 262   int                   _max_inline_size;       // Max inline size for this compilation
 263   int                   _freq_inline_size;      // Max hot method inline size for this compilation
 264   int                   _fixed_slots;           // count of frame slots not allocated by the register
 265                                                 // allocator i.e. locks, original deopt pc, etc.
 266   uintx                 _max_node_limit;        // Max unique node count during a single compilation.
 267 
 268   int                   _major_progress;        // Count of something big happening
 269   bool                  _inlining_progress;     // progress doing incremental inlining?
 270   bool                  _inlining_incrementally;// Are we doing incremental inlining (post parse)
 271   bool                  _do_cleanup;            // Cleanup is needed before proceeding with incremental inlining
 272   bool                  _has_loops;             // True if the method _may_ have some loops
 273   bool                  _has_split_ifs;         // True if the method _may_ have some split-if
 274   bool                  _has_unsafe_access;     // True if the method _may_ produce faults in unsafe loads or stores.
 275   bool                  _has_stringbuilder;     // True StringBuffers or StringBuilders are allocated
 276   bool                  _has_boxed_value;       // True if a boxed object is allocated
 277   bool                  _has_reserved_stack_access; // True if the method or an inlined method is annotated with ReservedStackAccess
 278   uint                  _max_vector_size;       // Maximum size of generated vectors
 279   bool                  _clear_upper_avx;       // Clear upper bits of ymm registers using vzeroupper
 280   uint                  _trap_hist[trapHistLength];  // Cumulative traps
 281   bool                  _trap_can_recompile;    // Have we emitted a recompiling trap?
 282   uint                  _decompile_count;       // Cumulative decompilation counts.
 283   bool                  _do_inlining;           // True if we intend to do inlining
 284   bool                  _do_scheduling;         // True if we intend to do scheduling
 285   bool                  _do_freq_based_layout;  // True if we intend to do frequency based block layout
 286   bool                  _do_count_invocations;  // True if we generate code to count invocations
 287   bool                  _do_method_data_update; // True if we generate code to update MethodData*s
 288   bool                  _do_vector_loop;        // True if allowed to execute loop in parallel iterations
 289   bool                  _use_cmove;             // True if CMove should be used without profitability analysis
 290   bool                  _age_code;              // True if we need to profile code age (decrement the aging counter)
 291   int                   _AliasLevel;            // Locally-adjusted version of AliasLevel flag.
 292   bool                  _print_assembly;        // True if we should dump assembly code for this compilation
 293   bool                  _print_inlining;        // True if we should print inlining for this compilation
 294   bool                  _print_intrinsics;      // True if we should print intrinsics for this compilation
 295 #ifndef PRODUCT
 296   bool                  _trace_opto_output;
 297   bool                  _print_ideal;
 298   bool                  _parsed_irreducible_loop; // True if ciTypeFlow detected irreducible loops during parsing
 299 #endif
 300   bool                  _has_irreducible_loop;  // Found irreducible loops
 301   // JSR 292
 302   bool                  _has_method_handle_invokes; // True if this method has MethodHandle invokes.
 303   RTMState              _rtm_state;             // State of Restricted Transactional Memory usage
 304   int                   _loop_opts_cnt;         // loop opts round
 305   bool                  _clinit_barrier_on_entry; // True if clinit barrier is needed on nmethod entry
 306   bool                  _has_flattened_accesses; // Any known flattened array accesses?
 307   bool                  _flattened_accesses_share_alias; // Initially all flattened array share a single slice
 308 
 309   // Compilation environment.
 310   Arena                 _comp_arena;            // Arena with lifetime equivalent to Compile
 311   void*                 _barrier_set_state;     // Potential GC barrier state for Compile
 312   ciEnv*                _env;                   // CI interface
 313   DirectiveSet*         _directive;             // Compiler directive
 314   CompileLog*           _log;                   // from CompilerThread
 315   const char*           _failure_reason;        // for record_failure/failing pattern
 316   GrowableArray&lt;CallGenerator*&gt;* _intrinsics;   // List of intrinsics.
 317   GrowableArray&lt;Node*&gt;* _macro_nodes;           // List of nodes which need to be expanded before matching.
 318   GrowableArray&lt;Node*&gt;* _predicate_opaqs;       // List of Opaque1 nodes for the loop predicates.
 319   GrowableArray&lt;Node*&gt;* _expensive_nodes;       // List of nodes that are expensive to compute and that we&#39;d better not let the GVN freely common
 320   GrowableArray&lt;Node*&gt;* _range_check_casts;     // List of CastII nodes with a range check dependency
 321   GrowableArray&lt;Node*&gt;* _opaque4_nodes;         // List of Opaque4 nodes that have a default value
 322   GrowableArray&lt;Node*&gt;* _inline_type_nodes;     // List of InlineType nodes
 323   ConnectionGraph*      _congraph;
 324 #ifndef PRODUCT
 325   IdealGraphPrinter*    _printer;
 326   static IdealGraphPrinter* _debug_file_printer;
 327   static IdealGraphPrinter* _debug_network_printer;
 328 #endif
 329 
 330 
 331   // Node management
 332   uint                  _unique;                // Counter for unique Node indices
 333   VectorSet             _dead_node_list;        // Set of dead nodes
 334   uint                  _dead_node_count;       // Number of dead nodes; VectorSet::Size() is O(N).
 335                                                 // So use this to keep count and make the call O(1).
 336   DEBUG_ONLY(Unique_Node_List* _modified_nodes;)   // List of nodes which inputs were modified
 337   DEBUG_ONLY(bool       _phase_optimize_finished;) // Used for live node verification while creating new nodes
 338 
 339   debug_only(static int _debug_idx;)            // Monotonic counter (not reset), use -XX:BreakAtNode=&lt;idx&gt;
 340   Arena                 _node_arena;            // Arena for new-space Nodes
 341   Arena                 _old_arena;             // Arena for old-space Nodes, lifetime during xform
 342   RootNode*             _root;                  // Unique root of compilation, or NULL after bail-out.
 343   Node*                 _top;                   // Unique top node.  (Reset by various phases.)
 344 
 345   Node*                 _immutable_memory;      // Initial memory state
 346 
 347   Node*                 _recent_alloc_obj;
 348   Node*                 _recent_alloc_ctl;
 349 
 350   // Constant table
 351   MachConstantBaseNode* _mach_constant_base_node;  // Constant table base node singleton.
 352 
 353 
 354   // Blocked array of debugging and profiling information,
 355   // tracked per node.
 356   enum { _log2_node_notes_block_size = 8,
 357          _node_notes_block_size = (1&lt;&lt;_log2_node_notes_block_size)
 358   };
 359   GrowableArray&lt;Node_Notes*&gt;* _node_note_array;
 360   Node_Notes*           _default_node_notes;  // default notes for new nodes
 361 
 362   // After parsing and every bulk phase we hang onto the Root instruction.
 363   // The RootNode instruction is where the whole program begins.  It produces
 364   // the initial Control and BOTTOM for everybody else.
 365 
 366   // Type management
 367   Arena                 _Compile_types;         // Arena for all types
 368   Arena*                _type_arena;            // Alias for _Compile_types except in Initialize_shared()
 369   Dict*                 _type_dict;             // Intern table
 370   CloneMap              _clone_map;             // used for recording history of cloned nodes
 371   size_t                _type_last_size;        // Last allocation size (see Type::operator new/delete)
 372   ciMethod*             _last_tf_m;             // Cache for
 373   const TypeFunc*       _last_tf;               //  TypeFunc::make
 374   AliasType**           _alias_types;           // List of alias types seen so far.
 375   int                   _num_alias_types;       // Logical length of _alias_types
 376   int                   _max_alias_types;       // Physical length of _alias_types
 377   AliasCacheEntry       _alias_cache[AliasCacheSize]; // Gets aliases w/o data structure walking
 378 
 379   // Parsing, optimization
 380   PhaseGVN*             _initial_gvn;           // Results of parse-time PhaseGVN
 381   Unique_Node_List*     _for_igvn;              // Initial work-list for next round of Iterative GVN
 382   WarmCallInfo*         _warm_calls;            // Sorted work-list for heat-based inlining.
 383 
 384   GrowableArray&lt;CallGenerator*&gt; _late_inlines;        // List of CallGenerators to be revisited after
 385                                                       // main parsing has finished.
 386   GrowableArray&lt;CallGenerator*&gt; _string_late_inlines; // same but for string operations
 387 
 388   GrowableArray&lt;CallGenerator*&gt; _boxing_late_inlines; // same but for boxing operations
 389 
 390   int                           _late_inlines_pos;    // Where in the queue should the next late inlining candidate go (emulate depth first inlining)
 391   uint                          _number_of_mh_late_inlines; // number of method handle late inlining still pending
 392 
 393 
 394   // Inlining may not happen in parse order which would make
 395   // PrintInlining output confusing. Keep track of PrintInlining
 396   // pieces in order.
 397   class PrintInliningBuffer : public ResourceObj {
 398    private:
 399     CallGenerator* _cg;
 400     stringStream* _ss;
 401 
 402    public:
 403     PrintInliningBuffer()
 404       : _cg(NULL) { _ss = new stringStream(); }
 405 
 406     void freeStream() { _ss-&gt;~stringStream(); _ss = NULL; }
 407 
 408     stringStream* ss() const { return _ss; }
 409     CallGenerator* cg() const { return _cg; }
 410     void set_cg(CallGenerator* cg) { _cg = cg; }
 411   };
 412 
 413   stringStream* _print_inlining_stream;
 414   GrowableArray&lt;PrintInliningBuffer&gt;* _print_inlining_list;
 415   int _print_inlining_idx;
 416   char* _print_inlining_output;
 417 
 418   // Only keep nodes in the expensive node list that need to be optimized
 419   void cleanup_expensive_nodes(PhaseIterGVN &amp;igvn);
 420   // Use for sorting expensive nodes to bring similar nodes together
 421   static int cmp_expensive_nodes(Node** n1, Node** n2);
 422   // Expensive nodes list already sorted?
 423   bool expensive_nodes_sorted() const;
 424   // Remove the speculative part of types and clean up the graph
 425   void remove_speculative_types(PhaseIterGVN &amp;igvn);
 426 
 427   void* _replay_inline_data; // Pointer to data loaded from file
 428 
 429   void print_inlining_stream_free();
 430   void print_inlining_init();
 431   void print_inlining_reinit();
 432   void print_inlining_commit();
 433   void print_inlining_push();
 434   PrintInliningBuffer&amp; print_inlining_current();
 435 
 436   void log_late_inline_failure(CallGenerator* cg, const char* msg);
 437 
 438  public:
 439 
 440   void* barrier_set_state() const { return _barrier_set_state; }
 441 
 442   outputStream* print_inlining_stream() const {
 443     assert(print_inlining() || print_intrinsics(), &quot;PrintInlining off?&quot;);
 444     return _print_inlining_stream;
 445   }
 446 
 447   void print_inlining_update(CallGenerator* cg);
 448   void print_inlining_update_delayed(CallGenerator* cg);
 449   void print_inlining_move_to(CallGenerator* cg);
 450   void print_inlining_assert_ready();
 451   void print_inlining_reset();
 452 
 453   void print_inlining(ciMethod* method, int inline_level, int bci, const char* msg = NULL) {
 454     stringStream ss;
 455     CompileTask::print_inlining_inner(&amp;ss, method, inline_level, bci, msg);
 456     print_inlining_stream()-&gt;print(&quot;%s&quot;, ss.as_string());
 457   }
 458 
 459 #ifndef PRODUCT
 460   IdealGraphPrinter* printer() { return _printer; }
 461 #endif
 462 
 463   void log_late_inline(CallGenerator* cg);
 464   void log_inline_id(CallGenerator* cg);
 465   void log_inline_failure(const char* msg);
 466 
 467   void* replay_inline_data() const { return _replay_inline_data; }
 468 
 469   // Dump inlining replay data to the stream.
 470   void dump_inline_data(outputStream* out);
 471 
 472  private:
 473   // Matching, CFG layout, allocation, code generation
 474   PhaseCFG*             _cfg;                   // Results of CFG finding
 475   int                   _java_calls;            // Number of java calls in the method
 476   int                   _inner_loops;           // Number of inner loops in the method
 477   Matcher*              _matcher;               // Engine to map ideal to machine instructions
 478   PhaseRegAlloc*        _regalloc;              // Results of register allocation.
 479   RegMask               _FIRST_STACK_mask;      // All stack slots usable for spills (depends on frame layout)
 480   Arena*                _indexSet_arena;        // control IndexSet allocation within PhaseChaitin
 481   void*                 _indexSet_free_block_list; // free list of IndexSet bit blocks
 482   int                   _interpreter_frame_size;
 483 
 484   PhaseOutput*          _output;
 485 
 486   void reshape_address(AddPNode* n);
 487 
 488  public:
 489   // Accessors
 490 
 491   // The Compile instance currently active in this (compiler) thread.
 492   static Compile* current() {
 493     return (Compile*) ciEnv::current()-&gt;compiler_data();
 494   }
 495 
 496   int interpreter_frame_size() const            { return _interpreter_frame_size; }
 497 
 498   PhaseOutput*      output() const              { return _output; }
 499   void              set_output(PhaseOutput* o)  { _output = o; }
 500 
 501   // ID for this compilation.  Useful for setting breakpoints in the debugger.
 502   int               compile_id() const          { return _compile_id; }
 503   DirectiveSet*     directive() const           { return _directive; }
 504 
 505   // Does this compilation allow instructions to subsume loads?  User
 506   // instructions that subsume a load may result in an unschedulable
 507   // instruction sequence.
 508   bool              subsume_loads() const       { return _subsume_loads; }
 509   /** Do escape analysis. */
 510   bool              do_escape_analysis() const  { return _do_escape_analysis; }
 511   /** Do boxing elimination. */
 512   bool              eliminate_boxing() const    { return _eliminate_boxing; }
 513   /** Do aggressive boxing elimination. */
 514   bool              aggressive_unboxing() const { return _eliminate_boxing &amp;&amp; AggressiveUnboxing; }
 515   bool              save_argument_registers() const { return _save_argument_registers; }
 516   bool              should_install_code() const { return _install_code; }
 517 
 518   // Other fixed compilation parameters.
 519   ciMethod*         method() const              { return _method; }
 520   int               entry_bci() const           { return _entry_bci; }
 521   bool              is_osr_compilation() const  { return _entry_bci != InvocationEntryBci; }
 522   bool              is_method_compilation() const { return (_method != NULL &amp;&amp; !_method-&gt;flags().is_native()); }
 523   const TypeFunc*   tf() const                  { assert(_tf!=NULL, &quot;&quot;); return _tf; }
 524   void         init_tf(const TypeFunc* tf)      { assert(_tf==NULL, &quot;&quot;); _tf = tf; }
 525   InlineTree*       ilt() const                 { return _ilt; }
 526   address           stub_function() const       { return _stub_function; }
 527   const char*       stub_name() const           { return _stub_name; }
 528   address           stub_entry_point() const    { return _stub_entry_point; }
 529   void          set_stub_entry_point(address z) { _stub_entry_point = z; }
 530 
 531   // Control of this compilation.
 532   int               fixed_slots() const         { assert(_fixed_slots &gt;= 0, &quot;&quot;);         return _fixed_slots; }
 533   void          set_fixed_slots(int n)          { _fixed_slots = n; }
 534   int               major_progress() const      { return _major_progress; }
 535   void          set_inlining_progress(bool z)   { _inlining_progress = z; }
 536   int               inlining_progress() const   { return _inlining_progress; }
 537   void          set_inlining_incrementally(bool z) { _inlining_incrementally = z; }
 538   int               inlining_incrementally() const { return _inlining_incrementally; }
 539   void          set_do_cleanup(bool z)          { _do_cleanup = z; }
 540   int               do_cleanup() const          { return _do_cleanup; }
 541   void          set_major_progress()            { _major_progress++; }
 542   void          restore_major_progress(int progress) { _major_progress += progress; }
 543   void        clear_major_progress()            { _major_progress = 0; }
 544   int               max_inline_size() const     { return _max_inline_size; }
 545   void          set_freq_inline_size(int n)     { _freq_inline_size = n; }
 546   int               freq_inline_size() const    { return _freq_inline_size; }
 547   void          set_max_inline_size(int n)      { _max_inline_size = n; }
 548   bool              has_loops() const           { return _has_loops; }
 549   void          set_has_loops(bool z)           { _has_loops = z; }
 550   bool              has_split_ifs() const       { return _has_split_ifs; }
 551   void          set_has_split_ifs(bool z)       { _has_split_ifs = z; }
 552   bool              has_unsafe_access() const   { return _has_unsafe_access; }
 553   void          set_has_unsafe_access(bool z)   { _has_unsafe_access = z; }
 554   bool              has_stringbuilder() const   { return _has_stringbuilder; }
 555   void          set_has_stringbuilder(bool z)   { _has_stringbuilder = z; }
 556   bool              has_boxed_value() const     { return _has_boxed_value; }
 557   void          set_has_boxed_value(bool z)     { _has_boxed_value = z; }
 558   bool              has_reserved_stack_access() const { return _has_reserved_stack_access; }
 559   void          set_has_reserved_stack_access(bool z) { _has_reserved_stack_access = z; }
 560   uint              max_vector_size() const     { return _max_vector_size; }
 561   void          set_max_vector_size(uint s)     { _max_vector_size = s; }
 562   bool              clear_upper_avx() const     { return _clear_upper_avx; }
 563   void          set_clear_upper_avx(bool s)     { _clear_upper_avx = s; }
 564   void          set_trap_count(uint r, uint c)  { assert(r &lt; trapHistLength, &quot;oob&quot;);        _trap_hist[r] = c; }
 565   uint              trap_count(uint r) const    { assert(r &lt; trapHistLength, &quot;oob&quot;); return _trap_hist[r]; }
 566   bool              trap_can_recompile() const  { return _trap_can_recompile; }
 567   void          set_trap_can_recompile(bool z)  { _trap_can_recompile = z; }
 568   uint              decompile_count() const     { return _decompile_count; }
 569   void          set_decompile_count(uint c)     { _decompile_count = c; }
 570   bool              allow_range_check_smearing() const;
 571   bool              do_inlining() const         { return _do_inlining; }
 572   void          set_do_inlining(bool z)         { _do_inlining = z; }
 573   bool              do_scheduling() const       { return _do_scheduling; }
 574   void          set_do_scheduling(bool z)       { _do_scheduling = z; }
 575   bool              do_freq_based_layout() const{ return _do_freq_based_layout; }
 576   void          set_do_freq_based_layout(bool z){ _do_freq_based_layout = z; }
 577   bool              do_count_invocations() const{ return _do_count_invocations; }
 578   void          set_do_count_invocations(bool z){ _do_count_invocations = z; }
 579   bool              do_method_data_update() const { return _do_method_data_update; }
 580   void          set_do_method_data_update(bool z) { _do_method_data_update = z; }
 581   bool              do_vector_loop() const      { return _do_vector_loop; }
 582   void          set_do_vector_loop(bool z)      { _do_vector_loop = z; }
 583   bool              use_cmove() const           { return _use_cmove; }
 584   void          set_use_cmove(bool z)           { _use_cmove = z; }
 585   bool              age_code() const             { return _age_code; }
 586   void          set_age_code(bool z)             { _age_code = z; }
 587   int               AliasLevel() const           { return _AliasLevel; }
 588   bool              print_assembly() const       { return _print_assembly; }
 589   void          set_print_assembly(bool z)       { _print_assembly = z; }
 590   bool              print_inlining() const       { return _print_inlining; }
 591   void          set_print_inlining(bool z)       { _print_inlining = z; }
 592   bool              print_intrinsics() const     { return _print_intrinsics; }
 593   void          set_print_intrinsics(bool z)     { _print_intrinsics = z; }
 594   RTMState          rtm_state()  const           { return _rtm_state; }
 595   void          set_rtm_state(RTMState s)        { _rtm_state = s; }
 596   bool              use_rtm() const              { return (_rtm_state &amp; NoRTM) == 0; }
 597   bool          profile_rtm() const              { return _rtm_state == ProfileRTM; }
 598   uint              max_node_limit() const       { return (uint)_max_node_limit; }
 599   void          set_max_node_limit(uint n)       { _max_node_limit = n; }
 600   bool              clinit_barrier_on_entry()       { return _clinit_barrier_on_entry; }
 601   void          set_clinit_barrier_on_entry(bool z) { _clinit_barrier_on_entry = z; }
 602   void          set_flattened_accesses()         { _has_flattened_accesses = true; }
 603   bool          flattened_accesses_share_alias() const { return _flattened_accesses_share_alias; }
 604   void          set_flattened_accesses_share_alias(bool z) { _flattened_accesses_share_alias = z; }
 605 
 606   // Support for scalarized inline type calling convention
 607   bool              has_scalarized_args() const  { return _method != NULL &amp;&amp; _method-&gt;has_scalarized_args(); }
 608   bool              needs_stack_repair()  const  { return _method != NULL &amp;&amp; _method-&gt;get_Method()-&gt;c2_needs_stack_repair(); }
 609 
 610   // check the CompilerOracle for special behaviours for this compile
 611   bool          method_has_option(const char * option) {
 612     return method() != NULL &amp;&amp; method()-&gt;has_option(option);
 613   }
 614 
 615 #ifndef PRODUCT
 616   bool          trace_opto_output() const       { return _trace_opto_output; }
 617   bool          print_ideal() const             { return _print_ideal; }
 618   bool              parsed_irreducible_loop() const { return _parsed_irreducible_loop; }
 619   void          set_parsed_irreducible_loop(bool z) { _parsed_irreducible_loop = z; }
 620   int _in_dump_cnt;  // Required for dumping ir nodes.
 621 #endif
 622   bool              has_irreducible_loop() const { return _has_irreducible_loop; }
 623   void          set_has_irreducible_loop(bool z) { _has_irreducible_loop = z; }
 624 
 625   // JSR 292
 626   bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }
 627   void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }
 628 
 629   Ticks _latest_stage_start_counter;
 630 
 631   void begin_method(int level = 1) {
 632 #ifndef PRODUCT
 633     if (_method != NULL &amp;&amp; should_print(level)) {
 634       _printer-&gt;begin_method();
 635     }
 636 #endif
 637     C-&gt;_latest_stage_start_counter.stamp();
 638   }
 639 
 640   bool should_print(int level = 1) {
 641 #ifndef PRODUCT
 642     if (PrintIdealGraphLevel &lt; 0) { // disabled by the user
 643       return false;
 644     }
 645 
 646     bool need = directive()-&gt;IGVPrintLevelOption &gt;= level;
 647     if (need &amp;&amp; !_printer) {
 648       _printer = IdealGraphPrinter::printer();
 649       assert(_printer != NULL, &quot;_printer is NULL when we need it!&quot;);
 650       _printer-&gt;set_compile(this);
 651     }
 652     return need;
 653 #else
 654     return false;
 655 #endif
 656   }
 657 
 658   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0);
 659 
 660 #ifndef PRODUCT
 661   void igv_print_method_to_file(const char* phase_name = &quot;Debug&quot;, bool append = false);
 662   void igv_print_method_to_network(const char* phase_name = &quot;Debug&quot;);
 663   static IdealGraphPrinter* debug_file_printer() { return _debug_file_printer; }
 664   static IdealGraphPrinter* debug_network_printer() { return _debug_network_printer; }
 665 #endif
 666 
 667   void end_method(int level = 1);
 668 
 669   int           macro_count()             const { return _macro_nodes-&gt;length(); }
 670   int           predicate_count()         const { return _predicate_opaqs-&gt;length();}
 671   int           expensive_count()         const { return _expensive_nodes-&gt;length(); }
 672   Node*         macro_node(int idx)       const { return _macro_nodes-&gt;at(idx); }
 673   Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs-&gt;at(idx);}
 674   Node*         expensive_node(int idx)   const { return _expensive_nodes-&gt;at(idx); }
 675   ConnectionGraph* congraph()                   { return _congraph;}
 676   void set_congraph(ConnectionGraph* congraph)  { _congraph = congraph;}
 677   void add_macro_node(Node * n) {
 678     //assert(n-&gt;is_macro(), &quot;must be a macro node&quot;);
 679     assert(!_macro_nodes-&gt;contains(n), &quot;duplicate entry in expand list&quot;);
 680     _macro_nodes-&gt;append(n);
 681   }
 682   void remove_macro_node(Node* n) {
 683     // this function may be called twice for a node so we can only remove it
 684     // if it&#39;s still existing.
 685     _macro_nodes-&gt;remove_if_existing(n);
 686     // remove from _predicate_opaqs list also if it is there
 687     if (predicate_count() &gt; 0) {
 688       _predicate_opaqs-&gt;remove_if_existing(n);
 689     }
 690   }
 691   void add_expensive_node(Node* n);
 692   void remove_expensive_node(Node* n) {
 693     _expensive_nodes-&gt;remove_if_existing(n);
 694   }
 695   void add_predicate_opaq(Node* n) {
 696     assert(!_predicate_opaqs-&gt;contains(n), &quot;duplicate entry in predicate opaque1&quot;);
 697     assert(_macro_nodes-&gt;contains(n), &quot;should have already been in macro list&quot;);
 698     _predicate_opaqs-&gt;append(n);
 699   }
 700 
 701   // Range check dependent CastII nodes that can be removed after loop optimizations
 702   void add_range_check_cast(Node* n);
 703   void remove_range_check_cast(Node* n) {
 704     _range_check_casts-&gt;remove_if_existing(n);
 705   }
 706   Node* range_check_cast_node(int idx) const { return _range_check_casts-&gt;at(idx);  }
 707   int   range_check_cast_count()       const { return _range_check_casts-&gt;length(); }
 708   // Remove all range check dependent CastIINodes.
 709   void  remove_range_check_casts(PhaseIterGVN &amp;igvn);
 710 
 711   void add_opaque4_node(Node* n);
 712   void remove_opaque4_node(Node* n) {
 713     _opaque4_nodes-&gt;remove_if_existing(n);
 714   }
 715   Node* opaque4_node(int idx) const { return _opaque4_nodes-&gt;at(idx);  }
 716   int   opaque4_count()       const { return _opaque4_nodes-&gt;length(); }
 717   void  remove_opaque4_nodes(PhaseIterGVN &amp;igvn);
 718 
 719   // Keep track of inline type nodes for later processing
 720   void add_inline_type(Node* n);
 721   void remove_inline_type(Node* n);
 722   void process_inline_types(PhaseIterGVN &amp;igvn, bool post_ea = false);
 723 
 724   void adjust_flattened_array_access_aliases(PhaseIterGVN&amp; igvn);
 725 
 726   void sort_macro_nodes();
 727 
 728   // remove the opaque nodes that protect the predicates so that the unused checks and
 729   // uncommon traps will be eliminated from the graph.
 730   void cleanup_loop_predicates(PhaseIterGVN &amp;igvn);
 731   bool is_predicate_opaq(Node * n) {
 732     return _predicate_opaqs-&gt;contains(n);
 733   }
 734 
 735   // Are there candidate expensive nodes for optimization?
 736   bool should_optimize_expensive_nodes(PhaseIterGVN &amp;igvn);
 737   // Check whether n1 and n2 are similar
 738   static int cmp_expensive_nodes(Node* n1, Node* n2);
 739   // Sort expensive nodes to locate similar expensive nodes
 740   void sort_expensive_nodes();
 741 
 742   // Compilation environment.
 743   Arena*      comp_arena()           { return &amp;_comp_arena; }
 744   ciEnv*      env() const            { return _env; }
 745   CompileLog* log() const            { return _log; }
 746   bool        failing() const        { return _env-&gt;failing() || _failure_reason != NULL; }
 747   const char* failure_reason() const { return (_env-&gt;failing()) ? _env-&gt;failure_reason() : _failure_reason; }
 748 
 749   bool failure_reason_is(const char* r) const {
 750     return (r == _failure_reason) || (r != NULL &amp;&amp; _failure_reason != NULL &amp;&amp; strcmp(r, _failure_reason) == 0);
 751   }
 752 
 753   void record_failure(const char* reason);
 754   void record_method_not_compilable(const char* reason) {
 755     // Bailouts cover &quot;all_tiers&quot; when TieredCompilation is off.
 756     env()-&gt;record_method_not_compilable(reason, !TieredCompilation);
 757     // Record failure reason.
 758     record_failure(reason);
 759   }
 760   bool check_node_count(uint margin, const char* reason) {
 761     if (live_nodes() + margin &gt; max_node_limit()) {
 762       record_method_not_compilable(reason);
 763       return true;
 764     } else {
 765       return false;
 766     }
 767   }
 768 
 769   // Node management
 770   uint         unique() const              { return _unique; }
 771   uint         next_unique()               { return _unique++; }
 772   void         set_unique(uint i)          { _unique = i; }
 773   static int   debug_idx()                 { return debug_only(_debug_idx)+0; }
 774   static void  set_debug_idx(int i)        { debug_only(_debug_idx = i); }
 775   Arena*       node_arena()                { return &amp;_node_arena; }
 776   Arena*       old_arena()                 { return &amp;_old_arena; }
 777   RootNode*    root() const                { return _root; }
 778   void         set_root(RootNode* r)       { _root = r; }
 779   StartNode*   start() const;              // (Derived from root.)
 780   void         init_start(StartNode* s);
 781   Node*        immutable_memory();
 782 
 783   Node*        recent_alloc_ctl() const    { return _recent_alloc_ctl; }
 784   Node*        recent_alloc_obj() const    { return _recent_alloc_obj; }
 785   void         set_recent_alloc(Node* ctl, Node* obj) {
 786                                                   _recent_alloc_ctl = ctl;
 787                                                   _recent_alloc_obj = obj;
 788                                            }
 789   void         record_dead_node(uint idx)  { if (_dead_node_list.test_set(idx)) return;
 790                                              _dead_node_count++;
 791                                            }
 792   void         reset_dead_node_list()      { _dead_node_list.reset();
 793                                              _dead_node_count = 0;
 794                                            }
 795   uint          live_nodes() const         {
 796     int  val = _unique - _dead_node_count;
 797     assert (val &gt;= 0, &quot;number of tracked dead nodes %d more than created nodes %d&quot;, _unique, _dead_node_count);
 798             return (uint) val;
 799                                            }
 800 #ifdef ASSERT
 801   void         set_phase_optimize_finished() { _phase_optimize_finished = true; }
 802   bool         phase_optimize_finished() const { return _phase_optimize_finished; }
 803   uint         count_live_nodes_by_graph_walk();
 804   void         print_missing_nodes();
 805 #endif
 806 
 807   // Record modified nodes to check that they are put on IGVN worklist
 808   void         record_modified_node(Node* n) NOT_DEBUG_RETURN;
 809   void         remove_modified_node(Node* n) NOT_DEBUG_RETURN;
 810   DEBUG_ONLY( Unique_Node_List*   modified_nodes() const { return _modified_nodes; } )
 811 
 812   MachConstantBaseNode*     mach_constant_base_node();
 813   bool                  has_mach_constant_base_node() const { return _mach_constant_base_node != NULL; }
 814   // Generated by adlc, true if CallNode requires MachConstantBase.
 815   bool                      needs_clone_jvms();
 816 
 817   // Handy undefined Node
 818   Node*             top() const                 { return _top; }
 819 
 820   // these are used by guys who need to know about creation and transformation of top:
 821   Node*             cached_top_node()           { return _top; }
 822   void          set_cached_top_node(Node* tn);
 823 
 824   GrowableArray&lt;Node_Notes*&gt;* node_note_array() const { return _node_note_array; }
 825   void set_node_note_array(GrowableArray&lt;Node_Notes*&gt;* arr) { _node_note_array = arr; }
 826   Node_Notes* default_node_notes() const        { return _default_node_notes; }
 827   void    set_default_node_notes(Node_Notes* n) { _default_node_notes = n; }
 828 
 829   Node_Notes*       node_notes_at(int idx) {
 830     return locate_node_notes(_node_note_array, idx, false);
 831   }
 832   inline bool   set_node_notes_at(int idx, Node_Notes* value);
 833 
 834   // Copy notes from source to dest, if they exist.
 835   // Overwrite dest only if source provides something.
 836   // Return true if information was moved.
 837   bool copy_node_notes_to(Node* dest, Node* source);
 838 
 839   // Workhorse function to sort out the blocked Node_Notes array:
 840   inline Node_Notes* locate_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr,
 841                                        int idx, bool can_grow = false);
 842 
 843   void grow_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr, int grow_by);
 844 
 845   // Type management
 846   Arena*            type_arena()                { return _type_arena; }
 847   Dict*             type_dict()                 { return _type_dict; }
 848   size_t            type_last_size()            { return _type_last_size; }
 849   int               num_alias_types()           { return _num_alias_types; }
 850 
 851   void          init_type_arena()                       { _type_arena = &amp;_Compile_types; }
 852   void          set_type_arena(Arena* a)                { _type_arena = a; }
 853   void          set_type_dict(Dict* d)                  { _type_dict = d; }
 854   void          set_type_last_size(size_t sz)           { _type_last_size = sz; }
 855 
 856   const TypeFunc* last_tf(ciMethod* m) {
 857     return (m == _last_tf_m) ? _last_tf : NULL;
 858   }
 859   void set_last_tf(ciMethod* m, const TypeFunc* tf) {
 860     assert(m != NULL || tf == NULL, &quot;&quot;);
 861     _last_tf_m = m;
 862     _last_tf = tf;
 863   }
 864 
 865   AliasType*        alias_type(int                idx)  { assert(idx &lt; num_alias_types(), &quot;oob&quot;); return _alias_types[idx]; }
 866   AliasType*        alias_type(const TypePtr* adr_type, ciField* field = NULL, bool uncached = false) { return find_alias_type(adr_type, false, field, uncached); }
 867   bool         have_alias_type(const TypePtr* adr_type);
 868   AliasType*        alias_type(ciField*         field);
 869 
 870   int               get_alias_index(const TypePtr* at, bool uncached = false) { return alias_type(at, NULL, uncached)-&gt;index(); }
 871   const TypePtr*    get_adr_type(uint aidx)             { return alias_type(aidx)-&gt;adr_type(); }
 872   int               get_general_index(uint aidx)        { return alias_type(aidx)-&gt;general_index(); }
 873 
 874   // Building nodes
 875   void              rethrow_exceptions(JVMState* jvms);
 876   void              return_values(JVMState* jvms);
 877   JVMState*         build_start_state(StartNode* start, const TypeFunc* tf);
 878 
 879   // Decide how to build a call.
 880   // The profile factor is a discount to apply to this site&#39;s interp. profile.
 881   CallGenerator*    call_generator(ciMethod* call_method, int vtable_index, bool call_does_dispatch,
 882                                    JVMState* jvms, bool allow_inline, float profile_factor, ciKlass* speculative_receiver_type = NULL,
 883                                    bool allow_intrinsics = true);
 884   bool should_delay_inlining(ciMethod* call_method, JVMState* jvms) {
 885     return should_delay_string_inlining(call_method, jvms) ||
 886            should_delay_boxing_inlining(call_method, jvms);
 887   }
 888   bool should_delay_string_inlining(ciMethod* call_method, JVMState* jvms);
 889   bool should_delay_boxing_inlining(ciMethod* call_method, JVMState* jvms);
 890 
 891   // Helper functions to identify inlining potential at call-site
 892   ciMethod* optimize_virtual_call(ciMethod* caller, int bci, ciInstanceKlass* klass,
 893                                   ciKlass* holder, ciMethod* callee,
 894                                   const TypeOopPtr* receiver_type, bool is_virtual,
 895                                   bool &amp;call_does_dispatch, int &amp;vtable_index,
 896                                   bool check_access = true);
 897   ciMethod* optimize_inlining(ciMethod* caller, int bci, ciInstanceKlass* klass,
 898                               ciMethod* callee, const TypeOopPtr* receiver_type,
 899                               bool check_access = true);
 900 
 901   // Report if there were too many traps at a current method and bci.
 902   // Report if a trap was recorded, and/or PerMethodTrapLimit was exceeded.
 903   // If there is no MDO at all, report no trap unless told to assume it.
 904   bool too_many_traps(ciMethod* method, int bci, Deoptimization::DeoptReason reason);
 905   // This version, unspecific to a particular bci, asks if
 906   // PerMethodTrapLimit was exceeded for all inlined methods seen so far.
 907   bool too_many_traps(Deoptimization::DeoptReason reason,
 908                       // Privately used parameter for logging:
 909                       ciMethodData* logmd = NULL);
 910   // Report if there were too many recompiles at a method and bci.
 911   bool too_many_recompiles(ciMethod* method, int bci, Deoptimization::DeoptReason reason);
 912   // Report if there were too many traps or recompiles at a method and bci.
 913   bool too_many_traps_or_recompiles(ciMethod* method, int bci, Deoptimization::DeoptReason reason) {
 914     return too_many_traps(method, bci, reason) ||
 915            too_many_recompiles(method, bci, reason);
 916   }
 917   // Return a bitset with the reasons where deoptimization is allowed,
 918   // i.e., where there were not too many uncommon traps.
 919   int _allowed_reasons;
 920   int      allowed_deopt_reasons() { return _allowed_reasons; }
 921   void set_allowed_deopt_reasons();
 922 
 923   // Parsing, optimization
 924   PhaseGVN*         initial_gvn()               { return _initial_gvn; }
 925   Unique_Node_List* for_igvn()                  { return _for_igvn; }
 926   inline void       record_for_igvn(Node* n);   // Body is after class Unique_Node_List.
 927   void          set_initial_gvn(PhaseGVN *gvn)           { _initial_gvn = gvn; }
 928   void          set_for_igvn(Unique_Node_List *for_igvn) { _for_igvn = for_igvn; }
 929 
 930   // Replace n by nn using initial_gvn, calling hash_delete and
 931   // record_for_igvn as needed.
 932   void gvn_replace_by(Node* n, Node* nn);
 933 
 934 
 935   void              identify_useful_nodes(Unique_Node_List &amp;useful);
 936   void              update_dead_node_list(Unique_Node_List &amp;useful);
 937   void              remove_useless_nodes (Unique_Node_List &amp;useful);
 938 
 939   WarmCallInfo*     warm_calls() const          { return _warm_calls; }
 940   void          set_warm_calls(WarmCallInfo* l) { _warm_calls = l; }
 941   WarmCallInfo* pop_warm_call();
 942 
 943   // Record this CallGenerator for inlining at the end of parsing.
 944   void              add_late_inline(CallGenerator* cg)        {
 945     _late_inlines.insert_before(_late_inlines_pos, cg);
 946     _late_inlines_pos++;
 947   }
 948 
 949   void              prepend_late_inline(CallGenerator* cg)    {
 950     _late_inlines.insert_before(0, cg);
 951   }
 952 
 953   void              add_string_late_inline(CallGenerator* cg) {
 954     _string_late_inlines.push(cg);
 955   }
 956 
 957   void              add_boxing_late_inline(CallGenerator* cg) {
 958     _boxing_late_inlines.push(cg);
 959   }
 960 
 961   void remove_useless_late_inlines(GrowableArray&lt;CallGenerator*&gt;* inlines, Unique_Node_List &amp;useful);
 962 
 963   void process_print_inlining();
 964   void dump_print_inlining();
 965 
 966   bool over_inlining_cutoff() const {
 967     if (!inlining_incrementally()) {
 968       return unique() &gt; (uint)NodeCountInliningCutoff;
 969     } else {
 970       // Give some room for incremental inlining algorithm to &quot;breathe&quot;
 971       // and avoid thrashing when live node count is close to the limit.
 972       // Keep in mind that live_nodes() isn&#39;t accurate during inlining until
 973       // dead node elimination step happens (see Compile::inline_incrementally).
 974       return live_nodes() &gt; (uint)LiveNodeCountInliningCutoff * 11 / 10;
 975     }
 976   }
 977 
 978   void inc_number_of_mh_late_inlines() { _number_of_mh_late_inlines++; }
 979   void dec_number_of_mh_late_inlines() { assert(_number_of_mh_late_inlines &gt; 0, &quot;_number_of_mh_late_inlines &lt; 0 !&quot;); _number_of_mh_late_inlines--; }
 980   bool has_mh_late_inlines() const     { return _number_of_mh_late_inlines &gt; 0; }
 981 
 982   bool inline_incrementally_one();
 983   void inline_incrementally_cleanup(PhaseIterGVN&amp; igvn);
 984   void inline_incrementally(PhaseIterGVN&amp; igvn);
 985   void inline_string_calls(bool parse_time);
 986   void inline_boxing_calls(PhaseIterGVN&amp; igvn);
 987   bool optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode);
 988   void remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn);
 989 
 990   // Matching, CFG layout, allocation, code generation
 991   PhaseCFG*         cfg()                       { return _cfg; }
 992   bool              has_java_calls() const      { return _java_calls &gt; 0; }
 993   int               java_calls() const          { return _java_calls; }
 994   int               inner_loops() const         { return _inner_loops; }
 995   Matcher*          matcher()                   { return _matcher; }
 996   PhaseRegAlloc*    regalloc()                  { return _regalloc; }
 997   RegMask&amp;          FIRST_STACK_mask()          { return _FIRST_STACK_mask; }
 998   Arena*            indexSet_arena()            { return _indexSet_arena; }
 999   void*             indexSet_free_block_list()  { return _indexSet_free_block_list; }
1000   DebugInformationRecorder* debug_info()        { return env()-&gt;debug_info(); }
1001 
1002   void  update_interpreter_frame_size(int size) {
1003     if (_interpreter_frame_size &lt; size) {
1004       _interpreter_frame_size = size;
1005     }
1006   }
1007 
1008   void          set_matcher(Matcher* m)                 { _matcher = m; }
1009 //void          set_regalloc(PhaseRegAlloc* ra)           { _regalloc = ra; }
1010   void          set_indexSet_arena(Arena* a)            { _indexSet_arena = a; }
1011   void          set_indexSet_free_block_list(void* p)   { _indexSet_free_block_list = p; }
1012 
1013   void  set_java_calls(int z) { _java_calls  = z; }
1014   void set_inner_loops(int z) { _inner_loops = z; }
1015 
1016   Dependencies* dependencies() { return env()-&gt;dependencies(); }
1017 
1018   // Major entry point.  Given a Scope, compile the associated method.
1019   // For normal compilations, entry_bci is InvocationEntryBci.  For on stack
1020   // replacement, entry_bci indicates the bytecode for which to compile a
1021   // continuation.
1022   Compile(ciEnv* ci_env, ciMethod* target,
1023           int entry_bci, bool subsume_loads, bool do_escape_analysis,
1024           bool eliminate_boxing, bool install_code, DirectiveSet* directive);
1025 
1026   // Second major entry point.  From the TypeFunc signature, generate code
1027   // to pass arguments from the Java calling convention to the C calling
1028   // convention.
1029   Compile(ciEnv* ci_env, const TypeFunc *(*gen)(),
1030           address stub_function, const char *stub_name,
1031           int is_fancy_jump, bool pass_tls,
1032           bool save_arg_registers, bool return_pc, DirectiveSet* directive);
1033 
1034   // From the TypeFunc signature, generate code to pass arguments
1035   // from Compiled calling convention to Interpreter&#39;s calling convention
1036   void Generate_Compiled_To_Interpreter_Graph(const TypeFunc *tf, address interpreter_entry);
1037 
1038   // From the TypeFunc signature, generate code to pass arguments
1039   // from Interpreter&#39;s calling convention to Compiler&#39;s calling convention
1040   void Generate_Interpreter_To_Compiled_Graph(const TypeFunc *tf);
1041 
1042   // Are we compiling a method?
1043   bool has_method() { return method() != NULL; }
1044 
1045   // Maybe print some information about this compile.
1046   void print_compile_messages();
1047 
1048   // Final graph reshaping, a post-pass after the regular optimizer is done.
1049   bool final_graph_reshaping();
1050 
1051   // returns true if adr is completely contained in the given alias category
1052   bool must_alias(const TypePtr* adr, int alias_idx);
1053 
1054   // returns true if adr overlaps with the given alias category
1055   bool can_alias(const TypePtr* adr, int alias_idx);
1056 
1057   // If &quot;objs&quot; contains an ObjectValue whose id is &quot;id&quot;, returns it, else NULL.
1058   static ObjectValue* sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id);
1059 
1060   // Stack slots that may be unused by the calling convention but must
1061   // otherwise be preserved.  On Intel this includes the return address.
1062   // On PowerPC it includes the 4 words holding the old TOC &amp; LR glue.
1063   uint in_preserve_stack_slots();
1064 
1065   // &quot;Top of Stack&quot; slots that may be unused by the calling convention but must
1066   // otherwise be preserved.
1067   // On Intel these are not necessary and the value can be zero.
1068   // On Sparc this describes the words reserved for storing a register window
1069   // when an interrupt occurs.
1070   static uint out_preserve_stack_slots();
1071 
1072   // Number of outgoing stack slots killed above the out_preserve_stack_slots
1073   // for calls to C.  Supports the var-args backing area for register parms.
1074   uint varargs_C_out_slots_killed() const;
1075 
1076   // Number of Stack Slots consumed by a synchronization entry
1077   int sync_stack_slots() const;
1078 
1079   // Compute the name of old_SP.  See &lt;arch&gt;.ad for frame layout.
1080   OptoReg::Name compute_old_SP();
1081 
1082  private:
1083   // Phase control:
1084   void Init(int aliaslevel);                     // Prepare for a single compilation
1085   int  Inline_Warm();                            // Find more inlining work.
1086   void Finish_Warm();                            // Give up on further inlines.
1087   void Optimize();                               // Given a graph, optimize it
1088   void Code_Gen();                               // Generate code from a graph
1089 
1090   // Management of the AliasType table.
1091   void grow_alias_types();
1092   AliasCacheEntry* probe_alias_cache(const TypePtr* adr_type);
1093   const TypePtr *flatten_alias_type(const TypePtr* adr_type) const;
1094   AliasType* find_alias_type(const TypePtr* adr_type, bool no_create, ciField* field, bool uncached = false);
1095 
1096   void verify_top(Node*) const PRODUCT_RETURN;
1097 
1098   // Intrinsic setup.
1099   void           register_library_intrinsics();                            // initializer
1100   CallGenerator* make_vm_intrinsic(ciMethod* m, bool is_virtual);          // constructor
1101   int            intrinsic_insertion_index(ciMethod* m, bool is_virtual, bool&amp; found);  // helper
1102   CallGenerator* find_intrinsic(ciMethod* m, bool is_virtual);             // query fn
1103   void           register_intrinsic(CallGenerator* cg);                    // update fn
1104 
1105 #ifndef PRODUCT
1106   static juint  _intrinsic_hist_count[vmIntrinsics::ID_LIMIT];
1107   static jubyte _intrinsic_hist_flags[vmIntrinsics::ID_LIMIT];
1108 #endif
1109   // Function calls made by the public function final_graph_reshaping.
1110   // No need to be made public as they are not called elsewhere.
1111   void final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &amp;frc);
1112   void final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts&amp; frc, uint nop);
1113   void final_graph_reshaping_walk( Node_Stack &amp;nstack, Node *root, Final_Reshape_Counts &amp;frc );
1114   void eliminate_redundant_card_marks(Node* n);
1115 
1116   // Logic cone optimization.
1117   void optimize_logic_cones(PhaseIterGVN &amp;igvn);
1118   void collect_logic_cone_roots(Unique_Node_List&amp; list);
1119   void process_logic_cone_root(PhaseIterGVN &amp;igvn, Node* n, VectorSet&amp; visited);
1120   bool compute_logic_cone(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs);
1121   uint compute_truth_table(Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs);
1122   uint eval_macro_logic_op(uint func, uint op1, uint op2, uint op3);
1123   Node* xform_to_MacroLogicV(PhaseIterGVN &amp;igvn, const TypeVect* vt, Unique_Node_List&amp; partitions, Unique_Node_List&amp; inputs);
1124 
1125  public:
1126 
1127   // Note:  Histogram array size is about 1 Kb.
1128   enum {                        // flag bits:
1129     _intrinsic_worked = 1,      // succeeded at least once
1130     _intrinsic_failed = 2,      // tried it but it failed
1131     _intrinsic_disabled = 4,    // was requested but disabled (e.g., -XX:-InlineUnsafeOps)
1132     _intrinsic_virtual = 8,     // was seen in the virtual form (rare)
1133     _intrinsic_both = 16        // was seen in the non-virtual form (usual)
1134   };
1135   // Update histogram.  Return boolean if this is a first-time occurrence.
1136   static bool gather_intrinsic_statistics(vmIntrinsics::ID id,
1137                                           bool is_virtual, int flags) PRODUCT_RETURN0;
1138   static void print_intrinsic_statistics() PRODUCT_RETURN;
1139 
1140   // Graph verification code
1141   // Walk the node list, verifying that there is a one-to-one
1142   // correspondence between Use-Def edges and Def-Use edges
1143   // The option no_dead_code enables stronger checks that the
1144   // graph is strongly connected from root in both directions.
1145   void verify_graph_edges(bool no_dead_code = false) PRODUCT_RETURN;
1146 
1147   // End-of-run dumps.
1148   static void print_statistics() PRODUCT_RETURN;
1149 
1150   // Verify ADLC assumptions during startup
1151   static void adlc_verification() PRODUCT_RETURN;
1152 
1153   // Definitions of pd methods
1154   static void pd_compiler2_init();
1155 
1156   // Static parse-time type checking logic for gen_subtype_check:
1157   enum { SSC_always_false, SSC_always_true, SSC_easy_test, SSC_full_test };
1158   int static_subtype_check(ciKlass* superk, ciKlass* subk);
1159 
1160   static Node* conv_I2X_index(PhaseGVN* phase, Node* offset, const TypeInt* sizetype,
1161                               // Optional control dependency (for example, on range check)
1162                               Node* ctrl = NULL);
1163 
1164   // Convert integer value to a narrowed long type dependent on ctrl (for example, a range check)
1165   static Node* constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl);
1166 
1167   Node* optimize_acmp(PhaseGVN* phase, Node* a, Node* b);
1168 
1169   // Auxiliary method for randomized fuzzing/stressing
1170   static bool randomized_select(int count);
1171 
1172   // supporting clone_map
1173   CloneMap&amp;     clone_map();
1174   void          set_clone_map(Dict* d);
1175 
1176   bool needs_clinit_barrier(ciField* ik,         ciMethod* accessing_method);
1177   bool needs_clinit_barrier(ciMethod* ik,        ciMethod* accessing_method);
1178   bool needs_clinit_barrier(ciInstanceKlass* ik, ciMethod* accessing_method);
1179 
1180 #ifdef IA32
1181  private:
1182   bool _select_24_bit_instr;   // We selected an instruction with a 24-bit result
1183   bool _in_24_bit_fp_mode;     // We are emitting instructions with 24-bit results
1184 
1185   // Remember if this compilation changes hardware mode to 24-bit precision.
1186   void set_24_bit_selection_and_mode(bool selection, bool mode) {
1187     _select_24_bit_instr = selection;
1188     _in_24_bit_fp_mode   = mode;
1189   }
1190 
1191  public:
1192   bool select_24_bit_instr() const { return _select_24_bit_instr; }
1193   bool in_24_bit_fp_mode() const   { return _in_24_bit_fp_mode; }
1194 #endif // IA32
1195 #ifdef ASSERT
1196   bool _type_verify_symmetry;
1197 #endif
1198 };
1199 
1200 #endif // SHARE_OPTO_COMPILE_HPP
    </pre>
  </body>
</html>