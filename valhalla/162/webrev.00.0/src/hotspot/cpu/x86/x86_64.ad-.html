<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // AMD64 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
   64 // used as byte registers)
   65 
   66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
   67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
   69 
   70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
   71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
   72 
   73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
   74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
   75 
   76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
   77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
   78 
   79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
   80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
   81 
   82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
   83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
   84 
   85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
   86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
   87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
   88 
   89 #ifdef _WIN64
   90 
   91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
   92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
   93 
   94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
   95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
   96 
   97 #else
   98 
   99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
  100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  101 
  102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
  103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  104 
  105 #endif
  106 
  107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
  108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
  109 
  110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
  111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
  112 
  113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
  114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
  115 
  116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
  117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
  118 
  119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
  120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
  121 
  122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
  123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
  124 
  125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
  126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
  127 
  128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
  129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
  130 
  131 
  132 // Floating Point Registers
  133 
  134 // Specify priority of register selection within phases of register
  135 // allocation.  Highest priority is first.  A useful heuristic is to
  136 // give registers a low priority when they are required by machine
  137 // instructions, like EAX and EDX on I486, and choose no-save registers
  138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
  139 // which participate in fixed calling sequences should come last.
  140 // Registers which are used as pairs must fall on an even boundary.
  141 
  142 alloc_class chunk0(R10,         R10_H,
  143                    R11,         R11_H,
  144                    R8,          R8_H,
  145                    R9,          R9_H,
  146                    R12,         R12_H,
  147                    RCX,         RCX_H,
  148                    RBX,         RBX_H,
  149                    RDI,         RDI_H,
  150                    RDX,         RDX_H,
  151                    RSI,         RSI_H,
  152                    RAX,         RAX_H,
  153                    RBP,         RBP_H,
  154                    R13,         R13_H,
  155                    R14,         R14_H,
  156                    R15,         R15_H,
  157                    RSP,         RSP_H);
  158 
  159 
  160 //----------Architecture Description Register Classes--------------------------
  161 // Several register classes are automatically defined based upon information in
  162 // this architecture description.
  163 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  164 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  165 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  166 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  167 //
  168 
  169 // Empty register class.
  170 reg_class no_reg();
  171 
  172 // Class for all pointer/long registers
  173 reg_class all_reg(RAX, RAX_H,
  174                   RDX, RDX_H,
  175                   RBP, RBP_H,
  176                   RDI, RDI_H,
  177                   RSI, RSI_H,
  178                   RCX, RCX_H,
  179                   RBX, RBX_H,
  180                   RSP, RSP_H,
  181                   R8,  R8_H,
  182                   R9,  R9_H,
  183                   R10, R10_H,
  184                   R11, R11_H,
  185                   R12, R12_H,
  186                   R13, R13_H,
  187                   R14, R14_H,
  188                   R15, R15_H);
  189 
  190 // Class for all int registers
  191 reg_class all_int_reg(RAX
  192                       RDX,
  193                       RBP,
  194                       RDI,
  195                       RSI,
  196                       RCX,
  197                       RBX,
  198                       R8,
  199                       R9,
  200                       R10,
  201                       R11,
  202                       R12,
  203                       R13,
  204                       R14);
  205 
  206 // Class for all pointer registers
  207 reg_class any_reg %{
  208   return _ANY_REG_mask;
  209 %}
  210 
  211 // Class for all pointer registers (excluding RSP)
  212 reg_class ptr_reg %{
  213   return _PTR_REG_mask;
  214 %}
  215 
  216 // Class for all pointer registers (excluding RSP and RBP)
  217 reg_class ptr_reg_no_rbp %{
  218   return _PTR_REG_NO_RBP_mask;
  219 %}
  220 
  221 // Class for all pointer registers (excluding RAX and RSP)
  222 reg_class ptr_no_rax_reg %{
  223   return _PTR_NO_RAX_REG_mask;
  224 %}
  225 
  226 // Class for all pointer registers (excluding RAX, RBX, and RSP)
  227 reg_class ptr_no_rax_rbx_reg %{
  228   return _PTR_NO_RAX_RBX_REG_mask;
  229 %}
  230 
  231 // Class for all long registers (excluding RSP)
  232 reg_class long_reg %{
  233   return _LONG_REG_mask;
  234 %}
  235 
  236 // Class for all long registers (excluding RAX, RDX and RSP)
  237 reg_class long_no_rax_rdx_reg %{
  238   return _LONG_NO_RAX_RDX_REG_mask;
  239 %}
  240 
  241 // Class for all long registers (excluding RCX and RSP)
  242 reg_class long_no_rcx_reg %{
  243   return _LONG_NO_RCX_REG_mask;
  244 %}
  245 
  246 // Class for all int registers (excluding RSP)
  247 reg_class int_reg %{
  248   return _INT_REG_mask;
  249 %}
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
  270 // Singleton class for RBP pointer register
  271 reg_class ptr_rbp_reg(RBP, RBP_H);
  272 
  273 // Singleton class for RDI pointer register
  274 reg_class ptr_rdi_reg(RDI, RDI_H);
  275 
  276 // Singleton class for stack pointer
  277 reg_class ptr_rsp_reg(RSP, RSP_H);
  278 
  279 // Singleton class for TLS pointer
  280 reg_class ptr_r15_reg(R15, R15_H);
  281 
  282 // Singleton class for RAX long register
  283 reg_class long_rax_reg(RAX, RAX_H);
  284 
  285 // Singleton class for RCX long register
  286 reg_class long_rcx_reg(RCX, RCX_H);
  287 
  288 // Singleton class for RDX long register
  289 reg_class long_rdx_reg(RDX, RDX_H);
  290 
  291 // Singleton class for RAX int register
  292 reg_class int_rax_reg(RAX);
  293 
  294 // Singleton class for RBX int register
  295 reg_class int_rbx_reg(RBX);
  296 
  297 // Singleton class for RCX int register
  298 reg_class int_rcx_reg(RCX);
  299 
  300 // Singleton class for RCX int register
  301 reg_class int_rdx_reg(RDX);
  302 
  303 // Singleton class for RCX int register
  304 reg_class int_rdi_reg(RDI);
  305 
  306 // Singleton class for instruction pointer
  307 // reg_class ip_reg(RIP);
  308 
  309 %}
  310 
  311 //----------SOURCE BLOCK-------------------------------------------------------
  312 // This is a block of C++ code which provides values, functions, and
  313 // definitions necessary in the rest of the architecture description
  314 source_hpp %{
  315 
  316 extern RegMask _ANY_REG_mask;
  317 extern RegMask _PTR_REG_mask;
  318 extern RegMask _PTR_REG_NO_RBP_mask;
  319 extern RegMask _PTR_NO_RAX_REG_mask;
  320 extern RegMask _PTR_NO_RAX_RBX_REG_mask;
  321 extern RegMask _LONG_REG_mask;
  322 extern RegMask _LONG_NO_RAX_RDX_REG_mask;
  323 extern RegMask _LONG_NO_RCX_REG_mask;
  324 extern RegMask _INT_REG_mask;
  325 extern RegMask _INT_NO_RAX_RDX_REG_mask;
  326 extern RegMask _INT_NO_RCX_REG_mask;
  327 
  328 extern RegMask _STACK_OR_PTR_REG_mask;
  329 extern RegMask _STACK_OR_LONG_REG_mask;
  330 extern RegMask _STACK_OR_INT_REG_mask;
  331 
  332 inline const RegMask&amp; STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
  333 inline const RegMask&amp; STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
  334 inline const RegMask&amp; STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
  335 
  336 %}
  337 
  338 source %{
  339 #define   RELOC_IMM64    Assembler::imm_operand
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
  360   return UseCompressedOops;
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
  381   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()-&gt;next()));
  382 
  383   _STACK_OR_PTR_REG_mask = _PTR_REG_mask;
  384   _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  385 
  386   _PTR_REG_NO_RBP_mask = _PTR_REG_mask;
  387   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  388   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  389 
  390   _PTR_NO_RAX_REG_mask = _PTR_REG_mask;
  391   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  392   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  393 
  394   _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;
  395   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()));
  396   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()-&gt;next()));
  397 
  398   _LONG_REG_mask = _PTR_REG_mask;
  399   _STACK_OR_LONG_REG_mask = _LONG_REG_mask;
  400   _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  401 
  402   _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;
  403   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  404   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  405   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  406   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()-&gt;next()));
  407 
  408   _LONG_NO_RCX_REG_mask = _LONG_REG_mask;
  409   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  410   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()-&gt;next()));
  411 
  412   _INT_REG_mask = _ALL_INT_REG_mask;
  413   if (PreserveFramePointer) {
  414     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  415   }
  416   if (need_r12_heapbase()) {
  417     _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  418   }
  419 
  420   _STACK_OR_INT_REG_mask = _INT_REG_mask;
  421   _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  422 
  423   _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;
  424   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  425   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  426 
  427   _INT_NO_RCX_REG_mask = _INT_REG_mask;
  428   _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  429 }
  430 
  431 static bool generate_vzeroupper(Compile* C) {
  432   return (VM_Version::supports_vzeroupper() &amp;&amp; (C-&gt;max_vector_size() &gt; 16 || C-&gt;clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
  433 }
  434 
  435 static int clear_avx_size() {
  436   return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
  437 }
  438 
  439 // !!!!! Special hack to get all types of calls to specify the byte offset
  440 //       from the start of the call to the point where the return address
  441 //       will point.
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 //
  463 // Compute padding required for nodes which need alignment
  464 //
  465 
  466 // The address of the call instruction needs to be 4-byte aligned to
  467 // ensure that it does not span a cache line so that it can be patched.
  468 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  469 {
  470   current_offset += clear_avx_size(); // skip vzeroupper
  471   current_offset += 1; // skip call opcode byte
  472   return align_up(current_offset, alignment_required()) - current_offset;
  473 }
  474 
  475 // The address of the call instruction needs to be 4-byte aligned to
  476 // ensure that it does not span a cache line so that it can be patched.
  477 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  478 {
  479   current_offset += clear_avx_size(); // skip vzeroupper
  480   current_offset += 11; // skip movq instruction + call opcode byte
  481   return align_up(current_offset, alignment_required()) - current_offset;
  482 }
  483 
  484 // EMIT_RM()
  485 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  486   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  487   cbuf.insts()-&gt;emit_int8(c);
  488 }
  489 
  490 // EMIT_CC()
  491 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  492   unsigned char c = (unsigned char) (f1 | f2);
  493   cbuf.insts()-&gt;emit_int8(c);
  494 }
  495 
  496 // EMIT_OPCODE()
  497 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  498   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  499 }
  500 
  501 // EMIT_OPCODE() w/ relocation information
  502 void emit_opcode(CodeBuffer &amp;cbuf,
  503                  int code, relocInfo::relocType reloc, int offset, int format)
  504 {
  505   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  506   emit_opcode(cbuf, code);
  507 }
  508 
  509 // EMIT_D8()
  510 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  511   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  512 }
  513 
  514 // EMIT_D16()
  515 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  516   cbuf.insts()-&gt;emit_int16(d16);
  517 }
  518 
  519 // EMIT_D32()
  520 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  521   cbuf.insts()-&gt;emit_int32(d32);
  522 }
  523 
  524 // EMIT_D64()
  525 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  526   cbuf.insts()-&gt;emit_int64(d64);
  527 }
  528 
  529 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  530 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  531                     int d32,
  532                     relocInfo::relocType reloc,
  533                     int format)
  534 {
  535   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  536   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  537   cbuf.insts()-&gt;emit_int32(d32);
  538 }
  539 
  540 // emit 32 bit value and construct relocation entry from RelocationHolder
  541 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  542 #ifdef ASSERT
  543   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  544       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
  545     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);
  546     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  547   }
  548 #endif
  549   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  550   cbuf.insts()-&gt;emit_int32(d32);
  551 }
  552 
  553 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  554   address next_ip = cbuf.insts_end() + 4;
  555   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  556                  external_word_Relocation::spec(addr),
  557                  RELOC_DISP32);
  558 }
  559 
  560 
  561 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  562 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  563   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  564   cbuf.insts()-&gt;emit_int64(d64);
  565 }
  566 
  567 // emit 64 bit value and construct relocation entry from RelocationHolder
  568 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  569 #ifdef ASSERT
  570   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  571       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
  572     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);
  573     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  574   }
  575 #endif
  576   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  577   cbuf.insts()-&gt;emit_int64(d64);
  578 }
  579 
  580 // Access stack slot for load or store
  581 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  582 {
  583   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  584   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  585     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  586     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  587     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  588   } else {
  589     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  590     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  591     emit_d32(cbuf, disp);     // Displacement // R/M byte
  592   }
  593 }
  594 
  595    // rRegI ereg, memory mem) %{    // emit_reg_mem
  596 void encode_RegMem(CodeBuffer &amp;cbuf,
  597                    int reg,
  598                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
  599 {
  600   assert(disp_reloc == relocInfo::none, &quot;cannot have disp&quot;);
  601   int regenc = reg &amp; 7;
  602   int baseenc = base &amp; 7;
  603   int indexenc = index &amp; 7;
  604 
  605   // There is no index &amp; no scale, use form without SIB byte
  606   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
  607     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  608     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  609       emit_rm(cbuf, 0x0, regenc, baseenc); // *
  610     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  611       // If 8-bit displacement, mode 0x1
  612       emit_rm(cbuf, 0x1, regenc, baseenc); // *
  613       emit_d8(cbuf, disp);
  614     } else {
  615       // If 32-bit displacement
  616       if (base == -1) { // Special flag for absolute address
  617         emit_rm(cbuf, 0x0, regenc, 0x5); // *
  618         if (disp_reloc != relocInfo::none) {
  619           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  620         } else {
  621           emit_d32(cbuf, disp);
  622         }
  623       } else {
  624         // Normal base + offset
  625         emit_rm(cbuf, 0x2, regenc, baseenc); // *
  626         if (disp_reloc != relocInfo::none) {
  627           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  628         } else {
  629           emit_d32(cbuf, disp);
  630         }
  631       }
  632     }
  633   } else {
  634     // Else, encode with the SIB byte
  635     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  636     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  637       // If no displacement
  638       emit_rm(cbuf, 0x0, regenc, 0x4); // *
  639       emit_rm(cbuf, scale, indexenc, baseenc);
  640     } else {
  641       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  642         // If 8-bit displacement, mode 0x1
  643         emit_rm(cbuf, 0x1, regenc, 0x4); // *
  644         emit_rm(cbuf, scale, indexenc, baseenc);
  645         emit_d8(cbuf, disp);
  646       } else {
  647         // If 32-bit displacement
  648         if (base == 0x04 ) {
  649           emit_rm(cbuf, 0x2, regenc, 0x4);
  650           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
  651         } else {
  652           emit_rm(cbuf, 0x2, regenc, 0x4);
  653           emit_rm(cbuf, scale, indexenc, baseenc); // *
  654         }
  655         if (disp_reloc != relocInfo::none) {
  656           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  657         } else {
  658           emit_d32(cbuf, disp);
  659         }
  660       }
  661     }
  662   }
  663 }
  664 
  665 // This could be in MacroAssembler but it&#39;s fairly C2 specific
  666 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  667   Label exit;
  668   __ jccb(Assembler::noParity, exit);
  669   __ pushf();
  670   //
  671   // comiss/ucomiss instructions set ZF,PF,CF flags and
  672   // zero OF,AF,SF for NaN values.
  673   // Fixup flags by zeroing ZF,PF so that compare of NaN
  674   // values returns &#39;less than&#39; result (CF is set).
  675   // Leave the rest of flags unchanged.
  676   //
  677   //    7 6 5 4 3 2 1 0
  678   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  679   //    0 0 1 0 1 0 1 1   (0x2B)
  680   //
  681   __ andq(Address(rsp, 0), 0xffffff2b);
  682   __ popf();
  683   __ bind(exit);
  684 }
  685 
  686 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  687   Label done;
  688   __ movl(dst, -1);
  689   __ jcc(Assembler::parity, done);
  690   __ jcc(Assembler::below, done);
  691   __ setb(Assembler::notEqual, dst);
  692   __ movzbl(dst, dst);
  693   __ bind(done);
  694 }
  695 
  696 // Math.min()    # Math.max()
  697 // --------------------------
  698 // ucomis[s/d]   #
  699 // ja   -&gt; b     # a
  700 // jp   -&gt; NaN   # NaN
  701 // jb   -&gt; a     # b
  702 // je            #
  703 // |-jz -&gt; a | b # a &amp; b
  704 // |    -&gt; a     #
  705 void emit_fp_min_max(MacroAssembler&amp; _masm, XMMRegister dst,
  706                      XMMRegister a, XMMRegister b,
  707                      XMMRegister xmmt, Register rt,
  708                      bool min, bool single) {
  709 
  710   Label nan, zero, below, above, done;
  711 
  712   if (single)
  713     __ ucomiss(a, b);
  714   else
  715     __ ucomisd(a, b);
  716 
  717   if (dst-&gt;encoding() != (min ? b : a)-&gt;encoding())
  718     __ jccb(Assembler::above, above); // CF=0 &amp; ZF=0
  719   else
  720     __ jccb(Assembler::above, done);
  721 
  722   __ jccb(Assembler::parity, nan);  // PF=1
  723   __ jccb(Assembler::below, below); // CF=1
  724 
  725   // equal
  726   __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);
  727   if (single) {
  728     __ ucomiss(a, xmmt);
  729     __ jccb(Assembler::equal, zero);
  730 
  731     __ movflt(dst, a);
  732     __ jmp(done);
  733   }
  734   else {
  735     __ ucomisd(a, xmmt);
  736     __ jccb(Assembler::equal, zero);
  737 
  738     __ movdbl(dst, a);
  739     __ jmp(done);
  740   }
  741 
  742   __ bind(zero);
  743   if (min)
  744     __ vpor(dst, a, b, Assembler::AVX_128bit);
  745   else
  746     __ vpand(dst, a, b, Assembler::AVX_128bit);
  747 
  748   __ jmp(done);
  749 
  750   __ bind(above);
  751   if (single)
  752     __ movflt(dst, min ? b : a);
  753   else
  754     __ movdbl(dst, min ? b : a);
  755 
  756   __ jmp(done);
  757 
  758   __ bind(nan);
  759   if (single) {
  760     __ movl(rt, 0x7fc00000); // Float.NaN
  761     __ movdl(dst, rt);
  762   }
  763   else {
  764     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  765     __ movdq(dst, rt);
  766   }
  767   __ jmp(done);
  768 
  769   __ bind(below);
  770   if (single)
  771     __ movflt(dst, min ? a : b);
  772   else
  773     __ movdbl(dst, min ? a : b);
  774 
  775   __ bind(done);
  776 }
  777 
  778 //=============================================================================
  779 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  780 
  781 int ConstantTable::calculate_table_base_offset() const {
  782   return 0;  // absolute addressing, no offset
  783 }
  784 
  785 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  786 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  787   ShouldNotReachHere();
  788 }
  789 
  790 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  791   // Empty encoding
  792 }
  793 
  794 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  795   return 0;
  796 }
  797 
  798 #ifndef PRODUCT
  799 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  800   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  801 }
  802 #endif
  803 
  804 
  805 //=============================================================================
  806 #ifndef PRODUCT
  807 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  808   Compile* C = ra_-&gt;C;
  809 
  810   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  811   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  812   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  813   // Remove wordSize for return addr which is already pushed.
  814   framesize -= wordSize;
  815 
  816   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
  817     framesize -= wordSize;
  818     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  819     st-&gt;print(&quot;\n\t&quot;);
  820     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  821     if (PreserveFramePointer) {
  822         st-&gt;print(&quot;\n\t&quot;);
  823         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  824     }
  825     if (framesize) {
  826       st-&gt;print(&quot;\n\t&quot;);
  827       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  828     }
  829   } else {
  830     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  831     st-&gt;print(&quot;\n\t&quot;);
  832     framesize -= wordSize;
  833     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  834     if (PreserveFramePointer) {
  835       st-&gt;print(&quot;\n\t&quot;);
  836       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  837       if (framesize &gt; 0) {
  838         st-&gt;print(&quot;\n\t&quot;);
  839         st-&gt;print(&quot;addq    rbp, #%d&quot;, framesize);
  840       }
  841     }
  842   }
  843 
  844   if (VerifyStackAtCalls) {
  845     st-&gt;print(&quot;\n\t&quot;);
  846     framesize -= wordSize;
  847     st-&gt;print(&quot;movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check&quot;,framesize);
  848 #ifdef ASSERT
  849     st-&gt;print(&quot;\n\t&quot;);
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 
  870   if (C-&gt;clinit_barrier_on_entry()) {
  871     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  872     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  873 
  874     Label L_skip_barrier;
  875     Register klass = rscratch1;
  876 
  877     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  878     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  879 
  880     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  881 
  882     __ bind(L_skip_barrier);
  883   }
  884 
  885   __ verified_entry(C);
  886   __ bind(*_verified_entry);
  887 
  888   if (C-&gt;stub_function() == NULL) {
  889     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
  890     bs-&gt;nmethod_entry_barrier(&amp;_masm);
  891   }
  892 
  893   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  894 
  895   if (C-&gt;has_mach_constant_base_node()) {
  896     // NOTE: We set the table base offset here because users might be
  897     // emitted before MachConstantBaseNode.
  898     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  899     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  900   }
  901 }
  902 
  903 int MachPrologNode::reloc() const
  904 {
  905   return 0; // a large enough number
  906 }
  907 
  908 //=============================================================================
  909 #ifndef PRODUCT
  910 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  911 {
  912   Compile* C = ra_-&gt;C;
  913   if (generate_vzeroupper(C)) {
  914     st-&gt;print(&quot;vzeroupper&quot;);
  915     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  916   }
  917 
  918   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  919   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  920   // Remove word for return adr already pushed
  921   // and RBP
  922   framesize -= 2*wordSize;
  923 
  924   if (framesize) {
  925     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  926     st-&gt;print(&quot;\t&quot;);
  927   }
  928 
  929   st-&gt;print_cr(&quot;popq    rbp&quot;);
  930   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  931     st-&gt;print(&quot;\t&quot;);
  932     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  933                  &quot;testl   rax, [rscratch1]\t&quot;
  934                  &quot;# Safepoint: poll for GC&quot;);
  935   }
  936 }
  937 #endif
  938 
  939 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  940 {
  941   Compile* C = ra_-&gt;C;
  942   MacroAssembler _masm(&amp;cbuf);
  943 
  944   if (generate_vzeroupper(C)) {
  945     // Clear upper bits of YMM registers when current compiled code uses
  946     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  947     __ vzeroupper();
  948   }
  949 
  950   // Subtract two words to account for return address and rbp
  951   int initial_framesize = C-&gt;output()-&gt;frame_size_in_bytes() - 2*wordSize;
  952   __ remove_frame(initial_framesize, C-&gt;needs_stack_repair(), C-&gt;output()-&gt;sp_inc_offset());
  953 
  954   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  955     __ reserved_stack_check();
  956   }
  957 
  958   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  959     MacroAssembler _masm(&amp;cbuf);
  960     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  961     __ relocate(relocInfo::poll_return_type);
  962     __ testl(rax, Address(rscratch1, 0));
  963   }
  964 }
  965 
  966 int MachEpilogNode::reloc() const
  967 {
  968   return 2; // a large enough number
  969 }
  970 
  971 const Pipeline* MachEpilogNode::pipeline() const
  972 {
  973   return MachNode::pipeline_class();
  974 }
  975 
  976 //=============================================================================
  977 
  978 enum RC {
  979   rc_bad,
  980   rc_int,
  981   rc_float,
  982   rc_stack
  983 };
  984 
  985 static enum RC rc_class(OptoReg::Name reg)
  986 {
  987   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  988 
  989   if (OptoReg::is_stack(reg)) return rc_stack;
  990 
  991   VMReg r = OptoReg::as_VMReg(reg);
  992 
  993   if (r-&gt;is_Register()) return rc_int;
  994 
  995   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  996   return rc_float;
  997 }
  998 
  999 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1000 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1001                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1002 
 1003 int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
 1004                      int stack_offset, int reg, uint ireg, outputStream* st);
 1005 
 1006 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1007                                       int dst_offset, uint ireg, outputStream* st) {
 1008   if (cbuf) {
 1009     MacroAssembler _masm(cbuf);
 1010     switch (ireg) {
 1011     case Op_VecS:
 1012       __ movq(Address(rsp, -8), rax);
 1013       __ movl(rax, Address(rsp, src_offset));
 1014       __ movl(Address(rsp, dst_offset), rax);
 1015       __ movq(rax, Address(rsp, -8));
 1016       break;
 1017     case Op_VecD:
 1018       __ pushq(Address(rsp, src_offset));
 1019       __ popq (Address(rsp, dst_offset));
 1020       break;
 1021     case Op_VecX:
 1022       __ pushq(Address(rsp, src_offset));
 1023       __ popq (Address(rsp, dst_offset));
 1024       __ pushq(Address(rsp, src_offset+8));
 1025       __ popq (Address(rsp, dst_offset+8));
 1026       break;
 1027     case Op_VecY:
 1028       __ vmovdqu(Address(rsp, -32), xmm0);
 1029       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1030       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1031       __ vmovdqu(xmm0, Address(rsp, -32));
 1032       break;
 1033     case Op_VecZ:
 1034       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1035       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1036       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1037       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1038       break;
 1039     default:
 1040       ShouldNotReachHere();
 1041     }
 1042 #ifndef PRODUCT
 1043   } else {
 1044     switch (ireg) {
 1045     case Op_VecS:
 1046       st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1047                 &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1048                 &quot;movl    [rsp + #%d], rax\n\t&quot;
 1049                 &quot;movq    rax, [rsp - #8]&quot;,
 1050                 src_offset, dst_offset);
 1051       break;
 1052     case Op_VecD:
 1053       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1054                 &quot;popq    [rsp + #%d]&quot;,
 1055                 src_offset, dst_offset);
 1056       break;
 1057      case Op_VecX:
 1058       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t&quot;
 1059                 &quot;popq    [rsp + #%d]\n\t&quot;
 1060                 &quot;pushq   [rsp + #%d]\n\t&quot;
 1061                 &quot;popq    [rsp + #%d]&quot;,
 1062                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 1063       break;
 1064     case Op_VecY:
 1065       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1066                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1067                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1068                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1069                 src_offset, dst_offset);
 1070       break;
 1071     case Op_VecZ:
 1072       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1073                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1074                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1075                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1076                 src_offset, dst_offset);
 1077       break;
 1078     default:
 1079       ShouldNotReachHere();
 1080     }
 1081 #endif
 1082   }
 1083 }
 1084 
 1085 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 1086                                        PhaseRegAlloc* ra_,
 1087                                        bool do_size,
 1088                                        outputStream* st) const {
 1089   assert(cbuf != NULL || st  != NULL, &quot;sanity&quot;);
 1090   // Get registers to move
 1091   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1092   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1093   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 1094   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 1095 
 1096   enum RC src_second_rc = rc_class(src_second);
 1097   enum RC src_first_rc = rc_class(src_first);
 1098   enum RC dst_second_rc = rc_class(dst_second);
 1099   enum RC dst_first_rc = rc_class(dst_first);
 1100 
 1101   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 1102          &quot;must move at least 1 register&quot; );
 1103 
 1104   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1105     // Self copy, no move
 1106     return 0;
 1107   }
 1108   if (bottom_type()-&gt;isa_vect() != NULL) {
 1109     uint ireg = ideal_reg();
 1110     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1111     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1112     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1113       // mem -&gt; mem
 1114       int src_offset = ra_-&gt;reg2offset(src_first);
 1115       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1116       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
 1117     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1118       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
 1119     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1120       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1121       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
 1122     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
 1123       int stack_offset = ra_-&gt;reg2offset(src_first);
 1124       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
 1125     } else {
 1126       ShouldNotReachHere();
 1127     }
 1128     return 0;
 1129   }
 1130   if (src_first_rc == rc_stack) {
 1131     // mem -&gt;
 1132     if (dst_first_rc == rc_stack) {
 1133       // mem -&gt; mem
 1134       assert(src_second != dst_first, &quot;overlap&quot;);
 1135       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1136           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1137         // 64-bit
 1138         int src_offset = ra_-&gt;reg2offset(src_first);
 1139         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1140         if (cbuf) {
 1141           MacroAssembler _masm(cbuf);
 1142           __ pushq(Address(rsp, src_offset));
 1143           __ popq (Address(rsp, dst_offset));
 1144 #ifndef PRODUCT
 1145         } else {
 1146           st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1147                     &quot;popq    [rsp + #%d]&quot;,
 1148                      src_offset, dst_offset);
 1149 #endif
 1150         }
 1151       } else {
 1152         // 32-bit
 1153         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1154         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1155         // No pushl/popl, so:
 1156         int src_offset = ra_-&gt;reg2offset(src_first);
 1157         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1158         if (cbuf) {
 1159           MacroAssembler _masm(cbuf);
 1160           __ movq(Address(rsp, -8), rax);
 1161           __ movl(rax, Address(rsp, src_offset));
 1162           __ movl(Address(rsp, dst_offset), rax);
 1163           __ movq(rax, Address(rsp, -8));
 1164 #ifndef PRODUCT
 1165         } else {
 1166           st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1167                     &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1168                     &quot;movl    [rsp + #%d], rax\n\t&quot;
 1169                     &quot;movq    rax, [rsp - #8]&quot;,
 1170                      src_offset, dst_offset);
 1171 #endif
 1172         }
 1173       }
 1174       return 0;
 1175     } else if (dst_first_rc == rc_int) {
 1176       // mem -&gt; gpr
 1177       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1178           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1179         // 64-bit
 1180         int offset = ra_-&gt;reg2offset(src_first);
 1181         if (cbuf) {
 1182           MacroAssembler _masm(cbuf);
 1183           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1184 #ifndef PRODUCT
 1185         } else {
 1186           st-&gt;print(&quot;movq    %s, [rsp + #%d]\t# spill&quot;,
 1187                      Matcher::regName[dst_first],
 1188                      offset);
 1189 #endif
 1190         }
 1191       } else {
 1192         // 32-bit
 1193         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1194         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1195         int offset = ra_-&gt;reg2offset(src_first);
 1196         if (cbuf) {
 1197           MacroAssembler _masm(cbuf);
 1198           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1199 #ifndef PRODUCT
 1200         } else {
 1201           st-&gt;print(&quot;movl    %s, [rsp + #%d]\t# spill&quot;,
 1202                      Matcher::regName[dst_first],
 1203                      offset);
 1204 #endif
 1205         }
 1206       }
 1207       return 0;
 1208     } else if (dst_first_rc == rc_float) {
 1209       // mem-&gt; xmm
 1210       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1211           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1212         // 64-bit
 1213         int offset = ra_-&gt;reg2offset(src_first);
 1214         if (cbuf) {
 1215           MacroAssembler _masm(cbuf);
 1216           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1217 #ifndef PRODUCT
 1218         } else {
 1219           st-&gt;print(&quot;%s  %s, [rsp + #%d]\t# spill&quot;,
 1220                      UseXmmLoadAndClearUpper ? &quot;movsd &quot; : &quot;movlpd&quot;,
 1221                      Matcher::regName[dst_first],
 1222                      offset);
 1223 #endif
 1224         }
 1225       } else {
 1226         // 32-bit
 1227         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1228         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1229         int offset = ra_-&gt;reg2offset(src_first);
 1230         if (cbuf) {
 1231           MacroAssembler _masm(cbuf);
 1232           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1233 #ifndef PRODUCT
 1234         } else {
 1235           st-&gt;print(&quot;movss   %s, [rsp + #%d]\t# spill&quot;,
 1236                      Matcher::regName[dst_first],
 1237                      offset);
 1238 #endif
 1239         }
 1240       }
 1241       return 0;
 1242     }
 1243   } else if (src_first_rc == rc_int) {
 1244     // gpr -&gt;
 1245     if (dst_first_rc == rc_stack) {
 1246       // gpr -&gt; mem
 1247       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1248           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1249         // 64-bit
 1250         int offset = ra_-&gt;reg2offset(dst_first);
 1251         if (cbuf) {
 1252           MacroAssembler _masm(cbuf);
 1253           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1254 #ifndef PRODUCT
 1255         } else {
 1256           st-&gt;print(&quot;movq    [rsp + #%d], %s\t# spill&quot;,
 1257                      offset,
 1258                      Matcher::regName[src_first]);
 1259 #endif
 1260         }
 1261       } else {
 1262         // 32-bit
 1263         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1264         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1265         int offset = ra_-&gt;reg2offset(dst_first);
 1266         if (cbuf) {
 1267           MacroAssembler _masm(cbuf);
 1268           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1269 #ifndef PRODUCT
 1270         } else {
 1271           st-&gt;print(&quot;movl    [rsp + #%d], %s\t# spill&quot;,
 1272                      offset,
 1273                      Matcher::regName[src_first]);
 1274 #endif
 1275         }
 1276       }
 1277       return 0;
 1278     } else if (dst_first_rc == rc_int) {
 1279       // gpr -&gt; gpr
 1280       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1281           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1282         // 64-bit
 1283         if (cbuf) {
 1284           MacroAssembler _masm(cbuf);
 1285           __ movq(as_Register(Matcher::_regEncode[dst_first]),
 1286                   as_Register(Matcher::_regEncode[src_first]));
 1287 #ifndef PRODUCT
 1288         } else {
 1289           st-&gt;print(&quot;movq    %s, %s\t# spill&quot;,
 1290                      Matcher::regName[dst_first],
 1291                      Matcher::regName[src_first]);
 1292 #endif
 1293         }
 1294         return 0;
 1295       } else {
 1296         // 32-bit
 1297         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1298         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1299         if (cbuf) {
 1300           MacroAssembler _masm(cbuf);
 1301           __ movl(as_Register(Matcher::_regEncode[dst_first]),
 1302                   as_Register(Matcher::_regEncode[src_first]));
 1303 #ifndef PRODUCT
 1304         } else {
 1305           st-&gt;print(&quot;movl    %s, %s\t# spill&quot;,
 1306                      Matcher::regName[dst_first],
 1307                      Matcher::regName[src_first]);
 1308 #endif
 1309         }
 1310         return 0;
 1311       }
 1312     } else if (dst_first_rc == rc_float) {
 1313       // gpr -&gt; xmm
 1314       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1315           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1316         // 64-bit
 1317         if (cbuf) {
 1318           MacroAssembler _masm(cbuf);
 1319           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1320 #ifndef PRODUCT
 1321         } else {
 1322           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1323                      Matcher::regName[dst_first],
 1324                      Matcher::regName[src_first]);
 1325 #endif
 1326         }
 1327       } else {
 1328         // 32-bit
 1329         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1330         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1331         if (cbuf) {
 1332           MacroAssembler _masm(cbuf);
 1333           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1334 #ifndef PRODUCT
 1335         } else {
 1336           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1337                      Matcher::regName[dst_first],
 1338                      Matcher::regName[src_first]);
 1339 #endif
 1340         }
 1341       }
 1342       return 0;
 1343     }
 1344   } else if (src_first_rc == rc_float) {
 1345     // xmm -&gt;
 1346     if (dst_first_rc == rc_stack) {
 1347       // xmm -&gt; mem
 1348       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1349           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1350         // 64-bit
 1351         int offset = ra_-&gt;reg2offset(dst_first);
 1352         if (cbuf) {
 1353           MacroAssembler _masm(cbuf);
 1354           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1355 #ifndef PRODUCT
 1356         } else {
 1357           st-&gt;print(&quot;movsd   [rsp + #%d], %s\t# spill&quot;,
 1358                      offset,
 1359                      Matcher::regName[src_first]);
 1360 #endif
 1361         }
 1362       } else {
 1363         // 32-bit
 1364         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1365         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1366         int offset = ra_-&gt;reg2offset(dst_first);
 1367         if (cbuf) {
 1368           MacroAssembler _masm(cbuf);
 1369           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1370 #ifndef PRODUCT
 1371         } else {
 1372           st-&gt;print(&quot;movss   [rsp + #%d], %s\t# spill&quot;,
 1373                      offset,
 1374                      Matcher::regName[src_first]);
 1375 #endif
 1376         }
 1377       }
 1378       return 0;
 1379     } else if (dst_first_rc == rc_int) {
 1380       // xmm -&gt; gpr
 1381       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1382           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1383         // 64-bit
 1384         if (cbuf) {
 1385           MacroAssembler _masm(cbuf);
 1386           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1387 #ifndef PRODUCT
 1388         } else {
 1389           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1390                      Matcher::regName[dst_first],
 1391                      Matcher::regName[src_first]);
 1392 #endif
 1393         }
 1394       } else {
 1395         // 32-bit
 1396         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1397         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1398         if (cbuf) {
 1399           MacroAssembler _masm(cbuf);
 1400           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1401 #ifndef PRODUCT
 1402         } else {
 1403           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1404                      Matcher::regName[dst_first],
 1405                      Matcher::regName[src_first]);
 1406 #endif
 1407         }
 1408       }
 1409       return 0;
 1410     } else if (dst_first_rc == rc_float) {
 1411       // xmm -&gt; xmm
 1412       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1413           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1414         // 64-bit
 1415         if (cbuf) {
 1416           MacroAssembler _masm(cbuf);
 1417           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1418 #ifndef PRODUCT
 1419         } else {
 1420           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1421                      UseXmmRegToRegMoveAll ? &quot;movapd&quot; : &quot;movsd &quot;,
 1422                      Matcher::regName[dst_first],
 1423                      Matcher::regName[src_first]);
 1424 #endif
 1425         }
 1426       } else {
 1427         // 32-bit
 1428         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1429         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1430         if (cbuf) {
 1431           MacroAssembler _masm(cbuf);
 1432           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1433 #ifndef PRODUCT
 1434         } else {
 1435           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1436                      UseXmmRegToRegMoveAll ? &quot;movaps&quot; : &quot;movss &quot;,
 1437                      Matcher::regName[dst_first],
 1438                      Matcher::regName[src_first]);
 1439 #endif
 1440         }
 1441       }
 1442       return 0;
 1443     }
 1444   }
 1445 
 1446   assert(0,&quot; foo &quot;);
 1447   Unimplemented();
 1448   return 0;
 1449 }
 1450 
 1451 #ifndef PRODUCT
 1452 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1453   implementation(NULL, ra_, false, st);
 1454 }
 1455 #endif
 1456 
 1457 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1458   implementation(&amp;cbuf, ra_, false, NULL);
 1459 }
 1460 
 1461 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1462   return MachNode::size(ra_);
 1463 }
 1464 
 1465 //=============================================================================
 1466 #ifndef PRODUCT
 1467 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1468 {
 1469   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1470   int reg = ra_-&gt;get_reg_first(this);
 1471   st-&gt;print(&quot;leaq    %s, [rsp + #%d]\t# box lock&quot;,
 1472             Matcher::regName[reg], offset);
 1473 }
 1474 #endif
 1475 
 1476 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1477 {
 1478   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1479   int reg = ra_-&gt;get_encode(this);
 1480   if (offset &gt;= 0x80) {
 1481     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1482     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1483     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1484     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1485     emit_d32(cbuf, offset);
 1486   } else {
 1487     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1488     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1489     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1490     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1491     emit_d8(cbuf, offset);
 1492   }
 1493 }
 1494 
 1495 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1496 {
 1497   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1498   return (offset &lt; 0x80) ? 5 : 8; // REX
 1499 }
 1500 
 1501 //=============================================================================
 1502 #ifndef PRODUCT
 1503 void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1504 {
 1505   st-&gt;print_cr(&quot;MachVEPNode&quot;);
 1506 }
 1507 #endif
 1508 
 1509 void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1510 {
 1511   MacroAssembler masm(&amp;cbuf);
 1512   if (!_verified) {  
 1513     uint insts_size = cbuf.insts_size();
 1514     if (UseCompressedClassPointers) {
 1515       masm.load_klass(rscratch1, j_rarg0, rscratch2);
 1516       masm.cmpptr(rax, rscratch1);
 1517     } else {
 1518       masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1519     }
 1520     masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1521   } else {
 1522     // Unpack inline type args passed as oop and then jump to
 1523     // the verified entry point (skipping the unverified entry).
 1524     masm.unpack_inline_args(ra_-&gt;C, _receiver_only);
 1525     masm.jmp(*_verified_entry);
 1526   }
 1527 }
 1528 
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1532 {
 1533   if (UseCompressedClassPointers) {
 1534     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1535     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1536     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1537   } else {
 1538     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1539                  &quot;# Inline cache check&quot;);
 1540   }
 1541   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1542   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1543 }
 1544 #endif
 1545 
 1546 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1547 {
 1548   MacroAssembler masm(&amp;cbuf);
 1549   uint insts_size = cbuf.insts_size();
 1550   if (UseCompressedClassPointers) {
 1551     masm.load_klass(rscratch1, j_rarg0, rscratch2);
 1552     masm.cmpptr(rax, rscratch1);
 1553   } else {
 1554     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1555   }
 1556 
 1557   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1558 
 1559   /* WARNING these NOPs are critical so that verified entry point is properly
 1560      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1561   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1562   if (OptoBreakpoint) {
 1563     // Leave space for int3
 1564     nops_cnt -= 1;
 1565   }
 1566   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1567   if (nops_cnt &gt; 0)
 1568     masm.nop(nops_cnt);
 1569 }
 1570 
 1571 //=============================================================================
 1572 
 1573 int Matcher::regnum_to_fpu_offset(int regnum)
 1574 {
 1575   return regnum - 32; // The FP registers are in the second chunk
 1576 }
 1577 
 1578 // This is UltraSparc specific, true just means we have fast l2f conversion
 1579 const bool Matcher::convL2FSupported(void) {
 1580   return true;
 1581 }
 1582 
 1583 // Is this branch offset short enough that a short branch can be used?
 1584 //
 1585 // NOTE: If the platform does not provide any short branch variants, then
 1586 //       this method should return false for offset 0.
 1587 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1588   // The passed offset is relative to address of the branch.
 1589   // On 86 a branch displacement is calculated relative to address
 1590   // of a next instruction.
 1591   offset -= br_size;
 1592 
 1593   // the short version of jmpConUCF2 contains multiple branches,
 1594   // making the reach slightly less
 1595   if (rule == jmpConUCF2_rule)
 1596     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1597   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1598 }
 1599 
 1600 const bool Matcher::isSimpleConstant64(jlong value) {
 1601   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1602   //return value == (int) value;  // Cf. storeImmL and immL32.
 1603 
 1604   // Probably always true, even if a temp register is required.
 1605   return true;
 1606 }
 1607 
 1608 // The ecx parameter to rep stosq for the ClearArray node is in words.
 1609 const bool Matcher::init_array_count_is_in_bytes = false;
 1610 
 1611 // No additional cost for CMOVL.
 1612 const int Matcher::long_cmove_cost() { return 0; }
 1613 
 1614 // No CMOVF/CMOVD with SSE2
 1615 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1616 
 1617 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1618 const bool Matcher::require_postalloc_expand = false;
 1619 
 1620 // Do we need to mask the count passed to shift instructions or does
 1621 // the cpu only look at the lower 5/6 bits anyway?
 1622 const bool Matcher::need_masked_shift_count = false;
 1623 
 1624 bool Matcher::narrow_oop_use_complex_address() {
 1625   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1626   return (LogMinObjAlignmentInBytes &lt;= 3);
 1627 }
 1628 
 1629 bool Matcher::narrow_klass_use_complex_address() {
 1630   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1631   return (LogKlassAlignmentInBytes &lt;= 3);
 1632 }
 1633 
 1634 bool Matcher::const_oop_prefer_decode() {
 1635   // Prefer ConN+DecodeN over ConP.
 1636   return true;
 1637 }
 1638 
 1639 bool Matcher::const_klass_prefer_decode() {
 1640   // TODO: Either support matching DecodeNKlass (heap-based) in operand
 1641   //       or condisider the following:
 1642   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1643   //return CompressedKlassPointers::base() == NULL;
 1644   return true;
 1645 }
 1646 
 1647 // Is it better to copy float constants, or load them directly from
 1648 // memory?  Intel can load a float constant from a direct address,
 1649 // requiring no extra registers.  Most RISCs will have to materialize
 1650 // an address into a register first, so they would do better to copy
 1651 // the constant from stack.
 1652 const bool Matcher::rematerialize_float_constants = true; // XXX
 1653 
 1654 // If CPU can load and store mis-aligned doubles directly then no
 1655 // fixup is needed.  Else we split the double into 2 integer pieces
 1656 // and move it piece-by-piece.  Only happens when passing doubles into
 1657 // C code as the Java calling convention forces doubles to be aligned.
 1658 const bool Matcher::misaligned_doubles_ok = true;
 1659 
 1660 // No-op on amd64
 1661 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1662 
 1663 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1664 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1665 
 1666 // Are floats conerted to double when stored to stack during deoptimization?
 1667 // On x64 it is stored without convertion so we can use normal access.
 1668 bool Matcher::float_in_double() { return false; }
 1669 
 1670 // Do ints take an entire long register or just half?
 1671 const bool Matcher::int_in_long = true;
 1672 
 1673 // Return whether or not this register is ever used as an argument.
 1674 // This function is used on startup to build the trampoline stubs in
 1675 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1676 // call in the trampoline, and arguments in those registers not be
 1677 // available to the callee.
 1678 bool Matcher::can_be_java_arg(int reg)
 1679 {
 1680   return
 1681     reg ==  RDI_num || reg == RDI_H_num ||
 1682     reg ==  RSI_num || reg == RSI_H_num ||
 1683     reg ==  RDX_num || reg == RDX_H_num ||
 1684     reg ==  RCX_num || reg == RCX_H_num ||
 1685     reg ==   R8_num || reg ==  R8_H_num ||
 1686     reg ==   R9_num || reg ==  R9_H_num ||
 1687     reg ==  R12_num || reg == R12_H_num ||
 1688     reg == XMM0_num || reg == XMM0b_num ||
 1689     reg == XMM1_num || reg == XMM1b_num ||
 1690     reg == XMM2_num || reg == XMM2b_num ||
 1691     reg == XMM3_num || reg == XMM3b_num ||
 1692     reg == XMM4_num || reg == XMM4b_num ||
 1693     reg == XMM5_num || reg == XMM5b_num ||
 1694     reg == XMM6_num || reg == XMM6b_num ||
 1695     reg == XMM7_num || reg == XMM7b_num;
 1696 }
 1697 
 1698 bool Matcher::is_spillable_arg(int reg)
 1699 {
 1700   return can_be_java_arg(reg);
 1701 }
 1702 
 1703 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1704   // In 64 bit mode a code which use multiply when
 1705   // devisor is constant is faster than hardware
 1706   // DIV instruction (it uses MulHiL).
 1707   return false;
 1708 }
 1709 
 1710 // Register for DIVI projection of divmodI
 1711 RegMask Matcher::divI_proj_mask() {
 1712   return INT_RAX_REG_mask();
 1713 }
 1714 
 1715 // Register for MODI projection of divmodI
 1716 RegMask Matcher::modI_proj_mask() {
 1717   return INT_RDX_REG_mask();
 1718 }
 1719 
 1720 // Register for DIVL projection of divmodL
 1721 RegMask Matcher::divL_proj_mask() {
 1722   return LONG_RAX_REG_mask();
 1723 }
 1724 
 1725 // Register for MODL projection of divmodL
 1726 RegMask Matcher::modL_proj_mask() {
 1727   return LONG_RDX_REG_mask();
 1728 }
 1729 
 1730 // Register for saving SP into on method handle invokes. Not used on x86_64.
 1731 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1732     return NO_REG_mask();
 1733 }
 1734 
 1735 %}
 1736 
 1737 //----------ENCODING BLOCK-----------------------------------------------------
 1738 // This block specifies the encoding classes used by the compiler to
 1739 // output byte streams.  Encoding classes are parameterized macros
 1740 // used by Machine Instruction Nodes in order to generate the bit
 1741 // encoding of the instruction.  Operands specify their base encoding
 1742 // interface with the interface keyword.  There are currently
 1743 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
 1744 // COND_INTER.  REG_INTER causes an operand to generate a function
 1745 // which returns its register number when queried.  CONST_INTER causes
 1746 // an operand to generate a function which returns the value of the
 1747 // constant when queried.  MEMORY_INTER causes an operand to generate
 1748 // four functions which return the Base Register, the Index Register,
 1749 // the Scale Value, and the Offset Value of the operand when queried.
 1750 // COND_INTER causes an operand to generate six functions which return
 1751 // the encoding code (ie - encoding bits for the instruction)
 1752 // associated with each basic boolean condition for a conditional
 1753 // instruction.
 1754 //
 1755 // Instructions specify two basic values for encoding.  Again, a
 1756 // function is available to check if the constant displacement is an
 1757 // oop. They use the ins_encode keyword to specify their encoding
 1758 // classes (which must be a sequence of enc_class names, and their
 1759 // parameters, specified in the encoding block), and they use the
 1760 // opcode keyword to specify, in order, their primary, secondary, and
 1761 // tertiary opcode.  Only the opcode sections which a particular
 1762 // instruction needs for encoding need to be specified.
 1763 encode %{
 1764   // Build emit functions for each basic byte or larger field in the
 1765   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 1766   // from C++ code in the enc_class source block.  Emit functions will
 1767   // live in the main source block for now.  In future, we can
 1768   // generalize this by adding a syntax that specifies the sizes of
 1769   // fields in an order, so that the adlc can build the emit functions
 1770   // automagically
 1771 
 1772   // Emit primary opcode
 1773   enc_class OpcP
 1774   %{
 1775     emit_opcode(cbuf, $primary);
 1776   %}
 1777 
 1778   // Emit secondary opcode
 1779   enc_class OpcS
 1780   %{
 1781     emit_opcode(cbuf, $secondary);
 1782   %}
 1783 
 1784   // Emit tertiary opcode
 1785   enc_class OpcT
 1786   %{
 1787     emit_opcode(cbuf, $tertiary);
 1788   %}
 1789 
 1790   // Emit opcode directly
 1791   enc_class Opcode(immI d8)
 1792   %{
 1793     emit_opcode(cbuf, $d8$$constant);
 1794   %}
 1795 
 1796   // Emit size prefix
 1797   enc_class SizePrefix
 1798   %{
 1799     emit_opcode(cbuf, 0x66);
 1800   %}
 1801 
 1802   enc_class reg(rRegI reg)
 1803   %{
 1804     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
 1805   %}
 1806 
 1807   enc_class reg_reg(rRegI dst, rRegI src)
 1808   %{
 1809     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1810   %}
 1811 
 1812   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
 1813   %{
 1814     emit_opcode(cbuf, $opcode$$constant);
 1815     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1816   %}
 1817 
 1818   enc_class cdql_enc(no_rax_rdx_RegI div)
 1819   %{
 1820     // Full implementation of Java idiv and irem; checks for
 1821     // special case as described in JVM spec., p.243 &amp; p.271.
 1822     //
 1823     //         normal case                           special case
 1824     //
 1825     // input : rax: dividend                         min_int
 1826     //         reg: divisor                          -1
 1827     //
 1828     // output: rax: quotient  (= rax idiv reg)       min_int
 1829     //         rdx: remainder (= rax irem reg)       0
 1830     //
 1831     //  Code sequnce:
 1832     //
 1833     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
 1834     //    5:   75 07/08                jne    e &lt;normal&gt;
 1835     //    7:   33 d2                   xor    %edx,%edx
 1836     //  [div &gt;= 8 -&gt; offset + 1]
 1837     //  [REX_B]
 1838     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
 1839     //    c:   74 03/04                je     11 &lt;done&gt;
 1840     // 000000000000000e &lt;normal&gt;:
 1841     //    e:   99                      cltd
 1842     //  [div &gt;= 8 -&gt; offset + 1]
 1843     //  [REX_B]
 1844     //    f:   f7 f9                   idiv   $div
 1845     // 0000000000000011 &lt;done&gt;:
 1846 
 1847     // cmp    $0x80000000,%eax
 1848     emit_opcode(cbuf, 0x3d);
 1849     emit_d8(cbuf, 0x00);
 1850     emit_d8(cbuf, 0x00);
 1851     emit_d8(cbuf, 0x00);
 1852     emit_d8(cbuf, 0x80);
 1853 
 1854     // jne    e &lt;normal&gt;
 1855     emit_opcode(cbuf, 0x75);
 1856     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
 1857 
 1858     // xor    %edx,%edx
 1859     emit_opcode(cbuf, 0x33);
 1860     emit_d8(cbuf, 0xD2);
 1861 
 1862     // cmp    $0xffffffffffffffff,%ecx
 1863     if ($div$$reg &gt;= 8) {
 1864       emit_opcode(cbuf, Assembler::REX_B);
 1865     }
 1866     emit_opcode(cbuf, 0x83);
 1867     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1868     emit_d8(cbuf, 0xFF);
 1869 
 1870     // je     11 &lt;done&gt;
 1871     emit_opcode(cbuf, 0x74);
 1872     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
 1873 
 1874     // &lt;normal&gt;
 1875     // cltd
 1876     emit_opcode(cbuf, 0x99);
 1877 
 1878     // idivl (note: must be emitted by the user of this rule)
 1879     // &lt;done&gt;
 1880   %}
 1881 
 1882   enc_class cdqq_enc(no_rax_rdx_RegL div)
 1883   %{
 1884     // Full implementation of Java ldiv and lrem; checks for
 1885     // special case as described in JVM spec., p.243 &amp; p.271.
 1886     //
 1887     //         normal case                           special case
 1888     //
 1889     // input : rax: dividend                         min_long
 1890     //         reg: divisor                          -1
 1891     //
 1892     // output: rax: quotient  (= rax idiv reg)       min_long
 1893     //         rdx: remainder (= rax irem reg)       0
 1894     //
 1895     //  Code sequnce:
 1896     //
 1897     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
 1898     //    7:   00 00 80
 1899     //    a:   48 39 d0                cmp    %rdx,%rax
 1900     //    d:   75 08                   jne    17 &lt;normal&gt;
 1901     //    f:   33 d2                   xor    %edx,%edx
 1902     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
 1903     //   15:   74 05                   je     1c &lt;done&gt;
 1904     // 0000000000000017 &lt;normal&gt;:
 1905     //   17:   48 99                   cqto
 1906     //   19:   48 f7 f9                idiv   $div
 1907     // 000000000000001c &lt;done&gt;:
 1908 
 1909     // mov    $0x8000000000000000,%rdx
 1910     emit_opcode(cbuf, Assembler::REX_W);
 1911     emit_opcode(cbuf, 0xBA);
 1912     emit_d8(cbuf, 0x00);
 1913     emit_d8(cbuf, 0x00);
 1914     emit_d8(cbuf, 0x00);
 1915     emit_d8(cbuf, 0x00);
 1916     emit_d8(cbuf, 0x00);
 1917     emit_d8(cbuf, 0x00);
 1918     emit_d8(cbuf, 0x00);
 1919     emit_d8(cbuf, 0x80);
 1920 
 1921     // cmp    %rdx,%rax
 1922     emit_opcode(cbuf, Assembler::REX_W);
 1923     emit_opcode(cbuf, 0x39);
 1924     emit_d8(cbuf, 0xD0);
 1925 
 1926     // jne    17 &lt;normal&gt;
 1927     emit_opcode(cbuf, 0x75);
 1928     emit_d8(cbuf, 0x08);
 1929 
 1930     // xor    %edx,%edx
 1931     emit_opcode(cbuf, 0x33);
 1932     emit_d8(cbuf, 0xD2);
 1933 
 1934     // cmp    $0xffffffffffffffff,$div
 1935     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
 1936     emit_opcode(cbuf, 0x83);
 1937     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1938     emit_d8(cbuf, 0xFF);
 1939 
 1940     // je     1e &lt;done&gt;
 1941     emit_opcode(cbuf, 0x74);
 1942     emit_d8(cbuf, 0x05);
 1943 
 1944     // &lt;normal&gt;
 1945     // cqto
 1946     emit_opcode(cbuf, Assembler::REX_W);
 1947     emit_opcode(cbuf, 0x99);
 1948 
 1949     // idivq (note: must be emitted by the user of this rule)
 1950     // &lt;done&gt;
 1951   %}
 1952 
 1953   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1954   enc_class OpcSE(immI imm)
 1955   %{
 1956     // Emit primary opcode and set sign-extend bit
 1957     // Check for 8-bit immediate, and set sign extend bit in opcode
 1958     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1959       emit_opcode(cbuf, $primary | 0x02);
 1960     } else {
 1961       // 32-bit immediate
 1962       emit_opcode(cbuf, $primary);
 1963     }
 1964   %}
 1965 
 1966   enc_class OpcSErm(rRegI dst, immI imm)
 1967   %{
 1968     // OpcSEr/m
 1969     int dstenc = $dst$$reg;
 1970     if (dstenc &gt;= 8) {
 1971       emit_opcode(cbuf, Assembler::REX_B);
 1972       dstenc -= 8;
 1973     }
 1974     // Emit primary opcode and set sign-extend bit
 1975     // Check for 8-bit immediate, and set sign extend bit in opcode
 1976     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1977       emit_opcode(cbuf, $primary | 0x02);
 1978     } else {
 1979       // 32-bit immediate
 1980       emit_opcode(cbuf, $primary);
 1981     }
 1982     // Emit r/m byte with secondary opcode, after primary opcode.
 1983     emit_rm(cbuf, 0x3, $secondary, dstenc);
 1984   %}
 1985 
 1986   enc_class OpcSErm_wide(rRegL dst, immI imm)
 1987   %{
 1988     // OpcSEr/m
 1989     int dstenc = $dst$$reg;
 1990     if (dstenc &lt; 8) {
 1991       emit_opcode(cbuf, Assembler::REX_W);
 1992     } else {
 1993       emit_opcode(cbuf, Assembler::REX_WB);
 1994       dstenc -= 8;
 1995     }
 1996     // Emit primary opcode and set sign-extend bit
 1997     // Check for 8-bit immediate, and set sign extend bit in opcode
 1998     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1999       emit_opcode(cbuf, $primary | 0x02);
 2000     } else {
 2001       // 32-bit immediate
 2002       emit_opcode(cbuf, $primary);
 2003     }
 2004     // Emit r/m byte with secondary opcode, after primary opcode.
 2005     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2006   %}
 2007 
 2008   enc_class Con8or32(immI imm)
 2009   %{
 2010     // Check for 8-bit immediate, and set sign extend bit in opcode
 2011     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2012       $$$emit8$imm$$constant;
 2013     } else {
 2014       // 32-bit immediate
 2015       $$$emit32$imm$$constant;
 2016     }
 2017   %}
 2018 
 2019   enc_class opc2_reg(rRegI dst)
 2020   %{
 2021     // BSWAP
 2022     emit_cc(cbuf, $secondary, $dst$$reg);
 2023   %}
 2024 
 2025   enc_class opc3_reg(rRegI dst)
 2026   %{
 2027     // BSWAP
 2028     emit_cc(cbuf, $tertiary, $dst$$reg);
 2029   %}
 2030 
 2031   enc_class reg_opc(rRegI div)
 2032   %{
 2033     // INC, DEC, IDIV, IMOD, JMP indirect, ...
 2034     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
 2035   %}
 2036 
 2037   enc_class enc_cmov(cmpOp cop)
 2038   %{
 2039     // CMOV
 2040     $$$emit8$primary;
 2041     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 2042   %}
 2043 
 2044   enc_class enc_PartialSubtypeCheck()
 2045   %{
 2046     Register Rrdi = as_Register(RDI_enc); // result register
 2047     Register Rrax = as_Register(RAX_enc); // super class
 2048     Register Rrcx = as_Register(RCX_enc); // killed
 2049     Register Rrsi = as_Register(RSI_enc); // sub class
 2050     Label miss;
 2051     const bool set_cond_codes = true;
 2052 
 2053     MacroAssembler _masm(&amp;cbuf);
 2054     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
 2055                                      NULL, &amp;miss,
 2056                                      /*set_cond_codes:*/ true);
 2057     if ($primary) {
 2058       __ xorptr(Rrdi, Rrdi);
 2059     }
 2060     __ bind(miss);
 2061   %}
 2062 
 2063   enc_class clear_avx %{
 2064     debug_only(int off0 = cbuf.insts_size());
 2065     if (generate_vzeroupper(Compile::current())) {
 2066       // Clear upper bits of YMM registers to avoid AVX &lt;-&gt; SSE transition penalty
 2067       // Clear upper bits of YMM registers when current compiled code uses
 2068       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 2069       MacroAssembler _masm(&amp;cbuf);
 2070       __ vzeroupper();
 2071     }
 2072     debug_only(int off1 = cbuf.insts_size());
 2073     assert(off1 - off0 == clear_avx_size(), &quot;correct size prediction&quot;);
 2074   %}
 2075 
 2076   enc_class Java_To_Runtime(method meth) %{
 2077     // No relocation needed
 2078     MacroAssembler _masm(&amp;cbuf);
 2079     __ mov64(r10, (int64_t) $meth$$method);
 2080     __ call(r10);
 2081   %}
 2082 
 2083   enc_class Java_To_Interpreter(method meth)
 2084   %{
 2085     // CALL Java_To_Interpreter
 2086     // This is the instruction starting address for relocation info.
 2087     cbuf.set_insts_mark();
 2088     $$$emit8$primary;
 2089     // CALL directly to the runtime
 2090     emit_d32_reloc(cbuf,
 2091                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2092                    runtime_call_Relocation::spec(),
 2093                    RELOC_DISP32);
 2094   %}
 2095 
 2096   enc_class Java_Static_Call(method meth)
 2097   %{
 2098     // JAVA STATIC CALL
 2099     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
 2100     // determine who we intended to call.
 2101     cbuf.set_insts_mark();
 2102     $$$emit8$primary;
 2103 
 2104     if (!_method) {
 2105       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2106                      runtime_call_Relocation::spec(),
 2107                      RELOC_DISP32);
 2108     } else {
 2109       int method_index = resolved_method_index(cbuf);
 2110       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2111                                                   : static_call_Relocation::spec(method_index);
 2112       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2113                      rspec, RELOC_DISP32);
 2114       // Emit stubs for static call.
 2115       address mark = cbuf.insts_mark();
 2116       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
 2117       if (stub == NULL) {
 2118         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2119         return;
 2120       }
 2121 #if INCLUDE_AOT
 2122       CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
 2123 #endif
 2124     }
 2125   %}
 2126 
 2127   enc_class Java_Dynamic_Call(method meth) %{
 2128     MacroAssembler _masm(&amp;cbuf);
 2129     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 2130   %}
 2131 
 2132   enc_class Java_Compiled_Call(method meth)
 2133   %{
 2134     // JAVA COMPILED CALL
 2135     int disp = in_bytes(Method:: from_compiled_offset());
 2136 
 2137     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
 2138     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, &quot;compiled_code_offset isn&#39;t small&quot;);
 2139 
 2140     // callq *disp(%rax)
 2141     cbuf.set_insts_mark();
 2142     $$$emit8$primary;
 2143     if (disp &lt; 0x80) {
 2144       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
 2145       emit_d8(cbuf, disp); // Displacement
 2146     } else {
 2147       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
 2148       emit_d32(cbuf, disp); // Displacement
 2149     }
 2150   %}
 2151 
 2152   enc_class reg_opc_imm(rRegI dst, immI8 shift)
 2153   %{
 2154     // SAL, SAR, SHR
 2155     int dstenc = $dst$$reg;
 2156     if (dstenc &gt;= 8) {
 2157       emit_opcode(cbuf, Assembler::REX_B);
 2158       dstenc -= 8;
 2159     }
 2160     $$$emit8$primary;
 2161     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2162     $$$emit8$shift$$constant;
 2163   %}
 2164 
 2165   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
 2166   %{
 2167     // SAL, SAR, SHR
 2168     int dstenc = $dst$$reg;
 2169     if (dstenc &lt; 8) {
 2170       emit_opcode(cbuf, Assembler::REX_W);
 2171     } else {
 2172       emit_opcode(cbuf, Assembler::REX_WB);
 2173       dstenc -= 8;
 2174     }
 2175     $$$emit8$primary;
 2176     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2177     $$$emit8$shift$$constant;
 2178   %}
 2179 
 2180   enc_class load_immI(rRegI dst, immI src)
 2181   %{
 2182     int dstenc = $dst$$reg;
 2183     if (dstenc &gt;= 8) {
 2184       emit_opcode(cbuf, Assembler::REX_B);
 2185       dstenc -= 8;
 2186     }
 2187     emit_opcode(cbuf, 0xB8 | dstenc);
 2188     $$$emit32$src$$constant;
 2189   %}
 2190 
 2191   enc_class load_immL(rRegL dst, immL src)
 2192   %{
 2193     int dstenc = $dst$$reg;
 2194     if (dstenc &lt; 8) {
 2195       emit_opcode(cbuf, Assembler::REX_W);
 2196     } else {
 2197       emit_opcode(cbuf, Assembler::REX_WB);
 2198       dstenc -= 8;
 2199     }
 2200     emit_opcode(cbuf, 0xB8 | dstenc);
 2201     emit_d64(cbuf, $src$$constant);
 2202   %}
 2203 
 2204   enc_class load_immUL32(rRegL dst, immUL32 src)
 2205   %{
 2206     // same as load_immI, but this time we care about zeroes in the high word
 2207     int dstenc = $dst$$reg;
 2208     if (dstenc &gt;= 8) {
 2209       emit_opcode(cbuf, Assembler::REX_B);
 2210       dstenc -= 8;
 2211     }
 2212     emit_opcode(cbuf, 0xB8 | dstenc);
 2213     $$$emit32$src$$constant;
 2214   %}
 2215 
 2216   enc_class load_immL32(rRegL dst, immL32 src)
 2217   %{
 2218     int dstenc = $dst$$reg;
 2219     if (dstenc &lt; 8) {
 2220       emit_opcode(cbuf, Assembler::REX_W);
 2221     } else {
 2222       emit_opcode(cbuf, Assembler::REX_WB);
 2223       dstenc -= 8;
 2224     }
 2225     emit_opcode(cbuf, 0xC7);
 2226     emit_rm(cbuf, 0x03, 0x00, dstenc);
 2227     $$$emit32$src$$constant;
 2228   %}
 2229 
 2230   enc_class load_immP31(rRegP dst, immP32 src)
 2231   %{
 2232     // same as load_immI, but this time we care about zeroes in the high word
 2233     int dstenc = $dst$$reg;
 2234     if (dstenc &gt;= 8) {
 2235       emit_opcode(cbuf, Assembler::REX_B);
 2236       dstenc -= 8;
 2237     }
 2238     emit_opcode(cbuf, 0xB8 | dstenc);
 2239     $$$emit32$src$$constant;
 2240   %}
 2241 
 2242   enc_class load_immP(rRegP dst, immP src)
 2243   %{
 2244     int dstenc = $dst$$reg;
 2245     if (dstenc &lt; 8) {
 2246       emit_opcode(cbuf, Assembler::REX_W);
 2247     } else {
 2248       emit_opcode(cbuf, Assembler::REX_WB);
 2249       dstenc -= 8;
 2250     }
 2251     emit_opcode(cbuf, 0xB8 | dstenc);
 2252     // This next line should be generated from ADLC
 2253     if ($src-&gt;constant_reloc() != relocInfo::none) {
 2254       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
 2255     } else {
 2256       emit_d64(cbuf, $src$$constant);
 2257     }
 2258   %}
 2259 
 2260   enc_class Con32(immI src)
 2261   %{
 2262     // Output immediate
 2263     $$$emit32$src$$constant;
 2264   %}
 2265 
 2266   enc_class Con32F_as_bits(immF src)
 2267   %{
 2268     // Output Float immediate bits
 2269     jfloat jf = $src$$constant;
 2270     jint jf_as_bits = jint_cast(jf);
 2271     emit_d32(cbuf, jf_as_bits);
 2272   %}
 2273 
 2274   enc_class Con16(immI src)
 2275   %{
 2276     // Output immediate
 2277     $$$emit16$src$$constant;
 2278   %}
 2279 
 2280   // How is this different from Con32??? XXX
 2281   enc_class Con_d32(immI src)
 2282   %{
 2283     emit_d32(cbuf,$src$$constant);
 2284   %}
 2285 
 2286   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
 2287     // Output immediate memory reference
 2288     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2289     emit_d32(cbuf, 0x00);
 2290   %}
 2291 
 2292   enc_class lock_prefix()
 2293   %{
 2294     emit_opcode(cbuf, 0xF0); // lock
 2295   %}
 2296 
 2297   enc_class REX_mem(memory mem)
 2298   %{
 2299     if ($mem$$base &gt;= 8) {
 2300       if ($mem$$index &lt; 8) {
 2301         emit_opcode(cbuf, Assembler::REX_B);
 2302       } else {
 2303         emit_opcode(cbuf, Assembler::REX_XB);
 2304       }
 2305     } else {
 2306       if ($mem$$index &gt;= 8) {
 2307         emit_opcode(cbuf, Assembler::REX_X);
 2308       }
 2309     }
 2310   %}
 2311 
 2312   enc_class REX_mem_wide(memory mem)
 2313   %{
 2314     if ($mem$$base &gt;= 8) {
 2315       if ($mem$$index &lt; 8) {
 2316         emit_opcode(cbuf, Assembler::REX_WB);
 2317       } else {
 2318         emit_opcode(cbuf, Assembler::REX_WXB);
 2319       }
 2320     } else {
 2321       if ($mem$$index &lt; 8) {
 2322         emit_opcode(cbuf, Assembler::REX_W);
 2323       } else {
 2324         emit_opcode(cbuf, Assembler::REX_WX);
 2325       }
 2326     }
 2327   %}
 2328 
 2329   // for byte regs
 2330   enc_class REX_breg(rRegI reg)
 2331   %{
 2332     if ($reg$$reg &gt;= 4) {
 2333       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2334     }
 2335   %}
 2336 
 2337   // for byte regs
 2338   enc_class REX_reg_breg(rRegI dst, rRegI src)
 2339   %{
 2340     if ($dst$$reg &lt; 8) {
 2341       if ($src$$reg &gt;= 4) {
 2342         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2343       }
 2344     } else {
 2345       if ($src$$reg &lt; 8) {
 2346         emit_opcode(cbuf, Assembler::REX_R);
 2347       } else {
 2348         emit_opcode(cbuf, Assembler::REX_RB);
 2349       }
 2350     }
 2351   %}
 2352 
 2353   // for byte regs
 2354   enc_class REX_breg_mem(rRegI reg, memory mem)
 2355   %{
 2356     if ($reg$$reg &lt; 8) {
 2357       if ($mem$$base &lt; 8) {
 2358         if ($mem$$index &gt;= 8) {
 2359           emit_opcode(cbuf, Assembler::REX_X);
 2360         } else if ($reg$$reg &gt;= 4) {
 2361           emit_opcode(cbuf, Assembler::REX);
 2362         }
 2363       } else {
 2364         if ($mem$$index &lt; 8) {
 2365           emit_opcode(cbuf, Assembler::REX_B);
 2366         } else {
 2367           emit_opcode(cbuf, Assembler::REX_XB);
 2368         }
 2369       }
 2370     } else {
 2371       if ($mem$$base &lt; 8) {
 2372         if ($mem$$index &lt; 8) {
 2373           emit_opcode(cbuf, Assembler::REX_R);
 2374         } else {
 2375           emit_opcode(cbuf, Assembler::REX_RX);
 2376         }
 2377       } else {
 2378         if ($mem$$index &lt; 8) {
 2379           emit_opcode(cbuf, Assembler::REX_RB);
 2380         } else {
 2381           emit_opcode(cbuf, Assembler::REX_RXB);
 2382         }
 2383       }
 2384     }
 2385   %}
 2386 
 2387   enc_class REX_reg(rRegI reg)
 2388   %{
 2389     if ($reg$$reg &gt;= 8) {
 2390       emit_opcode(cbuf, Assembler::REX_B);
 2391     }
 2392   %}
 2393 
 2394   enc_class REX_reg_wide(rRegI reg)
 2395   %{
 2396     if ($reg$$reg &lt; 8) {
 2397       emit_opcode(cbuf, Assembler::REX_W);
 2398     } else {
 2399       emit_opcode(cbuf, Assembler::REX_WB);
 2400     }
 2401   %}
 2402 
 2403   enc_class REX_reg_reg(rRegI dst, rRegI src)
 2404   %{
 2405     if ($dst$$reg &lt; 8) {
 2406       if ($src$$reg &gt;= 8) {
 2407         emit_opcode(cbuf, Assembler::REX_B);
 2408       }
 2409     } else {
 2410       if ($src$$reg &lt; 8) {
 2411         emit_opcode(cbuf, Assembler::REX_R);
 2412       } else {
 2413         emit_opcode(cbuf, Assembler::REX_RB);
 2414       }
 2415     }
 2416   %}
 2417 
 2418   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
 2419   %{
 2420     if ($dst$$reg &lt; 8) {
 2421       if ($src$$reg &lt; 8) {
 2422         emit_opcode(cbuf, Assembler::REX_W);
 2423       } else {
 2424         emit_opcode(cbuf, Assembler::REX_WB);
 2425       }
 2426     } else {
 2427       if ($src$$reg &lt; 8) {
 2428         emit_opcode(cbuf, Assembler::REX_WR);
 2429       } else {
 2430         emit_opcode(cbuf, Assembler::REX_WRB);
 2431       }
 2432     }
 2433   %}
 2434 
 2435   enc_class REX_reg_mem(rRegI reg, memory mem)
 2436   %{
 2437     if ($reg$$reg &lt; 8) {
 2438       if ($mem$$base &lt; 8) {
 2439         if ($mem$$index &gt;= 8) {
 2440           emit_opcode(cbuf, Assembler::REX_X);
 2441         }
 2442       } else {
 2443         if ($mem$$index &lt; 8) {
 2444           emit_opcode(cbuf, Assembler::REX_B);
 2445         } else {
 2446           emit_opcode(cbuf, Assembler::REX_XB);
 2447         }
 2448       }
 2449     } else {
 2450       if ($mem$$base &lt; 8) {
 2451         if ($mem$$index &lt; 8) {
 2452           emit_opcode(cbuf, Assembler::REX_R);
 2453         } else {
 2454           emit_opcode(cbuf, Assembler::REX_RX);
 2455         }
 2456       } else {
 2457         if ($mem$$index &lt; 8) {
 2458           emit_opcode(cbuf, Assembler::REX_RB);
 2459         } else {
 2460           emit_opcode(cbuf, Assembler::REX_RXB);
 2461         }
 2462       }
 2463     }
 2464   %}
 2465 
 2466   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
 2467   %{
 2468     if ($reg$$reg &lt; 8) {
 2469       if ($mem$$base &lt; 8) {
 2470         if ($mem$$index &lt; 8) {
 2471           emit_opcode(cbuf, Assembler::REX_W);
 2472         } else {
 2473           emit_opcode(cbuf, Assembler::REX_WX);
 2474         }
 2475       } else {
 2476         if ($mem$$index &lt; 8) {
 2477           emit_opcode(cbuf, Assembler::REX_WB);
 2478         } else {
 2479           emit_opcode(cbuf, Assembler::REX_WXB);
 2480         }
 2481       }
 2482     } else {
 2483       if ($mem$$base &lt; 8) {
 2484         if ($mem$$index &lt; 8) {
 2485           emit_opcode(cbuf, Assembler::REX_WR);
 2486         } else {
 2487           emit_opcode(cbuf, Assembler::REX_WRX);
 2488         }
 2489       } else {
 2490         if ($mem$$index &lt; 8) {
 2491           emit_opcode(cbuf, Assembler::REX_WRB);
 2492         } else {
 2493           emit_opcode(cbuf, Assembler::REX_WRXB);
 2494         }
 2495       }
 2496     }
 2497   %}
 2498 
 2499   enc_class reg_mem(rRegI ereg, memory mem)
 2500   %{
 2501     // High registers handle in encode_RegMem
 2502     int reg = $ereg$$reg;
 2503     int base = $mem$$base;
 2504     int index = $mem$$index;
 2505     int scale = $mem$$scale;
 2506     int disp = $mem$$disp;
 2507     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2508 
 2509     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
 2510   %}
 2511 
 2512   enc_class RM_opc_mem(immI rm_opcode, memory mem)
 2513   %{
 2514     int rm_byte_opcode = $rm_opcode$$constant;
 2515 
 2516     // High registers handle in encode_RegMem
 2517     int base = $mem$$base;
 2518     int index = $mem$$index;
 2519     int scale = $mem$$scale;
 2520     int displace = $mem$$disp;
 2521 
 2522     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
 2523                                             // working with static
 2524                                             // globals
 2525     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
 2526                   disp_reloc);
 2527   %}
 2528 
 2529   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
 2530   %{
 2531     int reg_encoding = $dst$$reg;
 2532     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2533     int index        = 0x04;            // 0x04 indicates no index
 2534     int scale        = 0x00;            // 0x00 indicates no scale
 2535     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2536     relocInfo::relocType disp_reloc = relocInfo::none;
 2537     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
 2538                   disp_reloc);
 2539   %}
 2540 
 2541   enc_class neg_reg(rRegI dst)
 2542   %{
 2543     int dstenc = $dst$$reg;
 2544     if (dstenc &gt;= 8) {
 2545       emit_opcode(cbuf, Assembler::REX_B);
 2546       dstenc -= 8;
 2547     }
 2548     // NEG $dst
 2549     emit_opcode(cbuf, 0xF7);
 2550     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2551   %}
 2552 
 2553   enc_class neg_reg_wide(rRegI dst)
 2554   %{
 2555     int dstenc = $dst$$reg;
 2556     if (dstenc &lt; 8) {
 2557       emit_opcode(cbuf, Assembler::REX_W);
 2558     } else {
 2559       emit_opcode(cbuf, Assembler::REX_WB);
 2560       dstenc -= 8;
 2561     }
 2562     // NEG $dst
 2563     emit_opcode(cbuf, 0xF7);
 2564     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2565   %}
 2566 
 2567   enc_class setLT_reg(rRegI dst)
 2568   %{
 2569     int dstenc = $dst$$reg;
 2570     if (dstenc &gt;= 8) {
 2571       emit_opcode(cbuf, Assembler::REX_B);
 2572       dstenc -= 8;
 2573     } else if (dstenc &gt;= 4) {
 2574       emit_opcode(cbuf, Assembler::REX);
 2575     }
 2576     // SETLT $dst
 2577     emit_opcode(cbuf, 0x0F);
 2578     emit_opcode(cbuf, 0x9C);
 2579     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2580   %}
 2581 
 2582   enc_class setNZ_reg(rRegI dst)
 2583   %{
 2584     int dstenc = $dst$$reg;
 2585     if (dstenc &gt;= 8) {
 2586       emit_opcode(cbuf, Assembler::REX_B);
 2587       dstenc -= 8;
 2588     } else if (dstenc &gt;= 4) {
 2589       emit_opcode(cbuf, Assembler::REX);
 2590     }
 2591     // SETNZ $dst
 2592     emit_opcode(cbuf, 0x0F);
 2593     emit_opcode(cbuf, 0x95);
 2594     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2595   %}
 2596 
 2597 
 2598   // Compare the lonogs and set -1, 0, or 1 into dst
 2599   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
 2600   %{
 2601     int src1enc = $src1$$reg;
 2602     int src2enc = $src2$$reg;
 2603     int dstenc = $dst$$reg;
 2604 
 2605     // cmpq $src1, $src2
 2606     if (src1enc &lt; 8) {
 2607       if (src2enc &lt; 8) {
 2608         emit_opcode(cbuf, Assembler::REX_W);
 2609       } else {
 2610         emit_opcode(cbuf, Assembler::REX_WB);
 2611       }
 2612     } else {
 2613       if (src2enc &lt; 8) {
 2614         emit_opcode(cbuf, Assembler::REX_WR);
 2615       } else {
 2616         emit_opcode(cbuf, Assembler::REX_WRB);
 2617       }
 2618     }
 2619     emit_opcode(cbuf, 0x3B);
 2620     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
 2621 
 2622     // movl $dst, -1
 2623     if (dstenc &gt;= 8) {
 2624       emit_opcode(cbuf, Assembler::REX_B);
 2625     }
 2626     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
 2627     emit_d32(cbuf, -1);
 2628 
 2629     // jl,s done
 2630     emit_opcode(cbuf, 0x7C);
 2631     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
 2632 
 2633     // setne $dst
 2634     if (dstenc &gt;= 4) {
 2635       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2636     }
 2637     emit_opcode(cbuf, 0x0F);
 2638     emit_opcode(cbuf, 0x95);
 2639     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
 2640 
 2641     // movzbl $dst, $dst
 2642     if (dstenc &gt;= 4) {
 2643       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
 2644     }
 2645     emit_opcode(cbuf, 0x0F);
 2646     emit_opcode(cbuf, 0xB6);
 2647     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
 2648   %}
 2649 
 2650   enc_class Push_ResultXD(regD dst) %{
 2651     MacroAssembler _masm(&amp;cbuf);
 2652     __ fstp_d(Address(rsp, 0));
 2653     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2654     __ addptr(rsp, 8);
 2655   %}
 2656 
 2657   enc_class Push_SrcXD(regD src) %{
 2658     MacroAssembler _masm(&amp;cbuf);
 2659     __ subptr(rsp, 8);
 2660     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2661     __ fld_d(Address(rsp, 0));
 2662   %}
 2663 
 2664 
 2665   enc_class enc_rethrow()
 2666   %{
 2667     cbuf.set_insts_mark();
 2668     emit_opcode(cbuf, 0xE9); // jmp entry
 2669     emit_d32_reloc(cbuf,
 2670                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
 2671                    runtime_call_Relocation::spec(),
 2672                    RELOC_DISP32);
 2673   %}
 2674 
 2675 %}
 2676 
 2677 
 2678 
 2679 //----------FRAME--------------------------------------------------------------
 2680 // Definition of frame structure and management information.
 2681 //
 2682 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2683 //                             |   (to get allocators register number
 2684 //  G  Owned by    |        |  v    add OptoReg::stack0())
 2685 //  r   CALLER     |        |
 2686 //  o     |        +--------+      pad to even-align allocators stack-slot
 2687 //  w     V        |  pad0  |        numbers; owned by CALLER
 2688 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2689 //  h     ^        |   in   |  5
 2690 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2691 //  |     |        |        |  3
 2692 //  |     |        +--------+
 2693 //  V     |        | old out|      Empty on Intel, window on Sparc
 2694 //        |    old |preserve|      Must be even aligned.
 2695 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 2696 //        |        |   in   |  3   area for Intel ret address
 2697 //     Owned by    |preserve|      Empty on Sparc.
 2698 //       SELF      +--------+
 2699 //        |        |  pad2  |  2   pad to align old SP
 2700 //        |        +--------+  1
 2701 //        |        | locks  |  0
 2702 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 2703 //        |        |  pad1  | 11   pad to align new SP
 2704 //        |        +--------+
 2705 //        |        |        | 10
 2706 //        |        | spills |  9   spills
 2707 //        V        |        |  8   (pad0 slot for callee)
 2708 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2709 //        ^        |  out   |  7
 2710 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2711 //     Owned by    +--------+
 2712 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2713 //        |    new |preserve|      Must be even-aligned.
 2714 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2715 //        |        |        |
 2716 //
 2717 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2718 //         known from SELF&#39;s arguments and the Java calling convention.
 2719 //         Region 6-7 is determined per call site.
 2720 // Note 2: If the calling convention leaves holes in the incoming argument
 2721 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2722 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2723 //         incoming area, as the Java calling convention is completely under
 2724 //         the control of the AD file.  Doubles can be sorted and packed to
 2725 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 2726 //         varargs C calling conventions.
 2727 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2728 //         even aligned with pad0 as needed.
 2729 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2730 //         region 6-11 is even aligned; it may be padded out more so that
 2731 //         the region from SP to FP meets the minimum stack alignment.
 2732 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
 2733 //         alignment.  Region 11, pad1, may be dynamically extended so that
 2734 //         SP meets the minimum alignment.
 2735 
 2736 frame
 2737 %{
 2738   // What direction does stack grow in (assumed to be same for C &amp; Java)
 2739   stack_direction(TOWARDS_LOW);
 2740 
 2741   // These three registers define part of the calling convention
 2742   // between compiled code and the interpreter.
 2743   inline_cache_reg(RAX);                // Inline Cache Register
 2744   interpreter_method_oop_reg(RBX);      // Method Oop Register when
 2745                                         // calling interpreter
 2746 
 2747   // Optional: name the operand used by cisc-spilling to access
 2748   // [stack_pointer + offset]
 2749   cisc_spilling_operand_name(indOffset32);
 2750 
 2751   // Number of stack slots consumed by locking an object
 2752   sync_stack_slots(2);
 2753 
 2754   // Compiled code&#39;s Frame Pointer
 2755   frame_pointer(RSP);
 2756 
 2757   // Interpreter stores its frame pointer in a register which is
 2758   // stored to the stack by I2CAdaptors.
 2759   // I2CAdaptors convert from interpreted java to compiled java.
 2760   interpreter_frame_pointer(RBP);
 2761 
 2762   // Stack alignment requirement
 2763   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
 2764 
 2765   // Number of stack slots between incoming argument block and the start of
 2766   // a new frame.  The PROLOG must add this many slots to the stack.  The
 2767   // EPILOG must remove this many slots.  amd64 needs two slots for
 2768   // return address.
 2769   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
 2770 
 2771   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 2772   // for calls to C.  Supports the var-args backing area for register parms.
 2773   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
 2774 
 2775   // The after-PROLOG location of the return address.  Location of
 2776   // return address specifies a type (REG or STACK) and a number
 2777   // representing the register number (i.e. - use a register name) or
 2778   // stack slot.
 2779   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 2780   // Otherwise, it is above the locks and verification slot and alignment word
 2781   return_addr(STACK - 2 +
 2782               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 2783                         Compile::current()-&gt;fixed_slots()),
 2784                        stack_alignment_in_slots()));
 2785 
 2786   // Body of function which returns an integer array locating
 2787   // arguments either in registers or in stack slots.  Passed an array
 2788   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 2789   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2790   // arguments for a CALLEE.  Incoming stack arguments are
 2791   // automatically biased by the preserve_stack_slots field above.
 2792 
 2793   calling_convention
 2794   %{
 2795     // No difference between ingoing/outgoing just pass false
 2796     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2797   %}
 2798 
 2799   c_calling_convention
 2800   %{
 2801     // This is obviously always outgoing
 2802     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2803   %}
 2804 
 2805   // Location of compiled Java return values.  Same as C for now.
 2806   return_value
 2807   %{
 2808     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 2809            &quot;only return normal values&quot;);
 2810 
 2811     static const int lo[Op_RegL + 1] = {
 2812       0,
 2813       0,
 2814       RAX_num,  // Op_RegN
 2815       RAX_num,  // Op_RegI
 2816       RAX_num,  // Op_RegP
 2817       XMM0_num, // Op_RegF
 2818       XMM0_num, // Op_RegD
 2819       RAX_num   // Op_RegL
 2820     };
 2821     static const int hi[Op_RegL + 1] = {
 2822       0,
 2823       0,
 2824       OptoReg::Bad, // Op_RegN
 2825       OptoReg::Bad, // Op_RegI
 2826       RAX_H_num,    // Op_RegP
 2827       OptoReg::Bad, // Op_RegF
 2828       XMM0b_num,    // Op_RegD
 2829       RAX_H_num     // Op_RegL
 2830     };
 2831     // Excluded flags and vector registers.
 2832     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, &quot;missing type&quot;);
 2833     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 2834   %}
 2835 %}
 2836 
 2837 //----------ATTRIBUTES---------------------------------------------------------
 2838 //----------Operand Attributes-------------------------------------------------
 2839 op_attrib op_cost(0);        // Required cost attribute
 2840 
 2841 //----------Instruction Attributes---------------------------------------------
 2842 ins_attrib ins_cost(100);       // Required cost attribute
 2843 ins_attrib ins_size(8);         // Required size attribute (in bits)
 2844 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 2845                                 // a non-matching short branch variant
 2846                                 // of some long branch?
 2847 ins_attrib ins_alignment(1);    // Required alignment attribute (must
 2848                                 // be a power of 2) specifies the
 2849                                 // alignment that some part of the
 2850                                 // instruction (not necessarily the
 2851                                 // start) requires.  If &gt; 1, a
 2852                                 // compute_padding() function must be
 2853                                 // provided for the instruction
 2854 
 2855 //----------OPERANDS-----------------------------------------------------------
 2856 // Operand definitions must precede instruction definitions for correct parsing
 2857 // in the ADLC because operands constitute user defined types which are used in
 2858 // instruction definitions.
 2859 
 2860 //----------Simple Operands----------------------------------------------------
 2861 // Immediate Operands
 2862 // Integer Immediate
 2863 operand immI()
 2864 %{
 2865   match(ConI);
 2866 
 2867   op_cost(10);
 2868   format %{ %}
 2869   interface(CONST_INTER);
 2870 %}
 2871 
 2872 // Constant for test vs zero
 2873 operand immI0()
 2874 %{
 2875   predicate(n-&gt;get_int() == 0);
 2876   match(ConI);
 2877 
 2878   op_cost(0);
 2879   format %{ %}
 2880   interface(CONST_INTER);
 2881 %}
 2882 
 2883 // Constant for increment
 2884 operand immI1()
 2885 %{
 2886   predicate(n-&gt;get_int() == 1);
 2887   match(ConI);
 2888 
 2889   op_cost(0);
 2890   format %{ %}
 2891   interface(CONST_INTER);
 2892 %}
 2893 
 2894 // Constant for decrement
 2895 operand immI_M1()
 2896 %{
 2897   predicate(n-&gt;get_int() == -1);
 2898   match(ConI);
 2899 
 2900   op_cost(0);
 2901   format %{ %}
 2902   interface(CONST_INTER);
 2903 %}
 2904 
 2905 // Valid scale values for addressing modes
 2906 operand immI2()
 2907 %{
 2908   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 2909   match(ConI);
 2910 
 2911   format %{ %}
 2912   interface(CONST_INTER);
 2913 %}
 2914 
 2915 operand immI8()
 2916 %{
 2917   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
 2918   match(ConI);
 2919 
 2920   op_cost(5);
 2921   format %{ %}
 2922   interface(CONST_INTER);
 2923 %}
 2924 
 2925 operand immU8()
 2926 %{
 2927   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 2928   match(ConI);
 2929 
 2930   op_cost(5);
 2931   format %{ %}
 2932   interface(CONST_INTER);
 2933 %}
 2934 
 2935 operand immI16()
 2936 %{
 2937   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 2938   match(ConI);
 2939 
 2940   op_cost(10);
 2941   format %{ %}
 2942   interface(CONST_INTER);
 2943 %}
 2944 
 2945 // Int Immediate non-negative
 2946 operand immU31()
 2947 %{
 2948   predicate(n-&gt;get_int() &gt;= 0);
 2949   match(ConI);
 2950 
 2951   op_cost(0);
 2952   format %{ %}
 2953   interface(CONST_INTER);
 2954 %}
 2955 
 2956 // Constant for long shifts
 2957 operand immI_32()
 2958 %{
 2959   predicate( n-&gt;get_int() == 32 );
 2960   match(ConI);
 2961 
 2962   op_cost(0);
 2963   format %{ %}
 2964   interface(CONST_INTER);
 2965 %}
 2966 
 2967 // Constant for long shifts
 2968 operand immI_64()
 2969 %{
 2970   predicate( n-&gt;get_int() == 64 );
 2971   match(ConI);
 2972 
 2973   op_cost(0);
 2974   format %{ %}
 2975   interface(CONST_INTER);
 2976 %}
 2977 
 2978 // Pointer Immediate
 2979 operand immP()
 2980 %{
 2981   match(ConP);
 2982 
 2983   op_cost(10);
 2984   format %{ %}
 2985   interface(CONST_INTER);
 2986 %}
 2987 
 2988 // NULL Pointer Immediate
 2989 operand immP0()
 2990 %{
 2991   predicate(n-&gt;get_ptr() == 0);
 2992   match(ConP);
 2993 
 2994   op_cost(5);
 2995   format %{ %}
 2996   interface(CONST_INTER);
 2997 %}
 2998 
 2999 // Pointer Immediate
 3000 operand immN() %{
 3001   match(ConN);
 3002 
 3003   op_cost(10);
 3004   format %{ %}
 3005   interface(CONST_INTER);
 3006 %}
 3007 
 3008 operand immNKlass() %{
 3009   match(ConNKlass);
 3010 
 3011   op_cost(10);
 3012   format %{ %}
 3013   interface(CONST_INTER);
 3014 %}
 3015 
 3016 // NULL Pointer Immediate
 3017 operand immN0() %{
 3018   predicate(n-&gt;get_narrowcon() == 0);
 3019   match(ConN);
 3020 
 3021   op_cost(5);
 3022   format %{ %}
 3023   interface(CONST_INTER);
 3024 %}
 3025 
 3026 operand immP31()
 3027 %{
 3028   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
 3029             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
 3030   match(ConP);
 3031 
 3032   op_cost(5);
 3033   format %{ %}
 3034   interface(CONST_INTER);
 3035 %}
 3036 
 3037 
 3038 // Long Immediate
 3039 operand immL()
 3040 %{
 3041   match(ConL);
 3042 
 3043   op_cost(20);
 3044   format %{ %}
 3045   interface(CONST_INTER);
 3046 %}
 3047 
 3048 // Long Immediate 8-bit
 3049 operand immL8()
 3050 %{
 3051   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
 3052   match(ConL);
 3053 
 3054   op_cost(5);
 3055   format %{ %}
 3056   interface(CONST_INTER);
 3057 %}
 3058 
 3059 // Long Immediate 32-bit unsigned
 3060 operand immUL32()
 3061 %{
 3062   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3063   match(ConL);
 3064 
 3065   op_cost(10);
 3066   format %{ %}
 3067   interface(CONST_INTER);
 3068 %}
 3069 
 3070 // Long Immediate 32-bit signed
 3071 operand immL32()
 3072 %{
 3073   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3074   match(ConL);
 3075 
 3076   op_cost(15);
 3077   format %{ %}
 3078   interface(CONST_INTER);
 3079 %}
 3080 
 3081 operand immL_Pow2()
 3082 %{
 3083   predicate(is_power_of_2((julong)n-&gt;get_long()));
 3084   match(ConL);
 3085 
 3086   op_cost(15);
 3087   format %{ %}
 3088   interface(CONST_INTER);
 3089 %}
 3090 
 3091 operand immL_NotPow2()
 3092 %{
 3093   predicate(is_power_of_2((julong)~n-&gt;get_long()));
 3094   match(ConL);
 3095 
 3096   op_cost(15);
 3097   format %{ %}
 3098   interface(CONST_INTER);
 3099 %}
 3100 
 3101 // Long Immediate zero
 3102 operand immL0()
 3103 %{
 3104   predicate(n-&gt;get_long() == 0L);
 3105   match(ConL);
 3106 
 3107   op_cost(10);
 3108   format %{ %}
 3109   interface(CONST_INTER);
 3110 %}
 3111 
 3112 // Constant for increment
 3113 operand immL1()
 3114 %{
 3115   predicate(n-&gt;get_long() == 1);
 3116   match(ConL);
 3117 
 3118   format %{ %}
 3119   interface(CONST_INTER);
 3120 %}
 3121 
 3122 // Constant for decrement
 3123 operand immL_M1()
 3124 %{
 3125   predicate(n-&gt;get_long() == -1);
 3126   match(ConL);
 3127 
 3128   format %{ %}
 3129   interface(CONST_INTER);
 3130 %}
 3131 
 3132 // Long Immediate: the value 10
 3133 operand immL10()
 3134 %{
 3135   predicate(n-&gt;get_long() == 10);
 3136   match(ConL);
 3137 
 3138   format %{ %}
 3139   interface(CONST_INTER);
 3140 %}
 3141 
 3142 // Long immediate from 0 to 127.
 3143 // Used for a shorter form of long mul by 10.
 3144 operand immL_127()
 3145 %{
 3146   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
 3147   match(ConL);
 3148 
 3149   op_cost(10);
 3150   format %{ %}
 3151   interface(CONST_INTER);
 3152 %}
 3153 
 3154 // Long Immediate: low 32-bit mask
 3155 operand immL_32bits()
 3156 %{
 3157   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3158   match(ConL);
 3159   op_cost(20);
 3160 
 3161   format %{ %}
 3162   interface(CONST_INTER);
 3163 %}
 3164 
 3165 // Float Immediate zero
 3166 operand immF0()
 3167 %{
 3168   predicate(jint_cast(n-&gt;getf()) == 0);
 3169   match(ConF);
 3170 
 3171   op_cost(5);
 3172   format %{ %}
 3173   interface(CONST_INTER);
 3174 %}
 3175 
 3176 // Float Immediate
 3177 operand immF()
 3178 %{
 3179   match(ConF);
 3180 
 3181   op_cost(15);
 3182   format %{ %}
 3183   interface(CONST_INTER);
 3184 %}
 3185 
 3186 // Double Immediate zero
 3187 operand immD0()
 3188 %{
 3189   predicate(jlong_cast(n-&gt;getd()) == 0);
 3190   match(ConD);
 3191 
 3192   op_cost(5);
 3193   format %{ %}
 3194   interface(CONST_INTER);
 3195 %}
 3196 
 3197 // Double Immediate
 3198 operand immD()
 3199 %{
 3200   match(ConD);
 3201 
 3202   op_cost(15);
 3203   format %{ %}
 3204   interface(CONST_INTER);
 3205 %}
 3206 
 3207 // Immediates for special shifts (sign extend)
 3208 
 3209 // Constants for increment
 3210 operand immI_16()
 3211 %{
 3212   predicate(n-&gt;get_int() == 16);
 3213   match(ConI);
 3214 
 3215   format %{ %}
 3216   interface(CONST_INTER);
 3217 %}
 3218 
 3219 operand immI_24()
 3220 %{
 3221   predicate(n-&gt;get_int() == 24);
 3222   match(ConI);
 3223 
 3224   format %{ %}
 3225   interface(CONST_INTER);
 3226 %}
 3227 
 3228 // Constant for byte-wide masking
 3229 operand immI_255()
 3230 %{
 3231   predicate(n-&gt;get_int() == 255);
 3232   match(ConI);
 3233 
 3234   format %{ %}
 3235   interface(CONST_INTER);
 3236 %}
 3237 
 3238 // Constant for short-wide masking
 3239 operand immI_65535()
 3240 %{
 3241   predicate(n-&gt;get_int() == 65535);
 3242   match(ConI);
 3243 
 3244   format %{ %}
 3245   interface(CONST_INTER);
 3246 %}
 3247 
 3248 // Constant for byte-wide masking
 3249 operand immL_255()
 3250 %{
 3251   predicate(n-&gt;get_long() == 255);
 3252   match(ConL);
 3253 
 3254   format %{ %}
 3255   interface(CONST_INTER);
 3256 %}
 3257 
 3258 // Constant for short-wide masking
 3259 operand immL_65535()
 3260 %{
 3261   predicate(n-&gt;get_long() == 65535);
 3262   match(ConL);
 3263 
 3264   format %{ %}
 3265   interface(CONST_INTER);
 3266 %}
 3267 
 3268 // Register Operands
 3269 // Integer Register
 3270 operand rRegI()
 3271 %{
 3272   constraint(ALLOC_IN_RC(int_reg));
 3273   match(RegI);
 3274 
 3275   match(rax_RegI);
 3276   match(rbx_RegI);
 3277   match(rcx_RegI);
 3278   match(rdx_RegI);
 3279   match(rdi_RegI);
 3280 
 3281   format %{ %}
 3282   interface(REG_INTER);
 3283 %}
 3284 
 3285 // Special Registers
 3286 operand rax_RegI()
 3287 %{
 3288   constraint(ALLOC_IN_RC(int_rax_reg));
 3289   match(RegI);
 3290   match(rRegI);
 3291 
 3292   format %{ &quot;RAX&quot; %}
 3293   interface(REG_INTER);
 3294 %}
 3295 
 3296 // Special Registers
 3297 operand rbx_RegI()
 3298 %{
 3299   constraint(ALLOC_IN_RC(int_rbx_reg));
 3300   match(RegI);
 3301   match(rRegI);
 3302 
 3303   format %{ &quot;RBX&quot; %}
 3304   interface(REG_INTER);
 3305 %}
 3306 
 3307 operand rcx_RegI()
 3308 %{
 3309   constraint(ALLOC_IN_RC(int_rcx_reg));
 3310   match(RegI);
 3311   match(rRegI);
 3312 
 3313   format %{ &quot;RCX&quot; %}
 3314   interface(REG_INTER);
 3315 %}
 3316 
 3317 operand rdx_RegI()
 3318 %{
 3319   constraint(ALLOC_IN_RC(int_rdx_reg));
 3320   match(RegI);
 3321   match(rRegI);
 3322 
 3323   format %{ &quot;RDX&quot; %}
 3324   interface(REG_INTER);
 3325 %}
 3326 
 3327 operand rdi_RegI()
 3328 %{
 3329   constraint(ALLOC_IN_RC(int_rdi_reg));
 3330   match(RegI);
 3331   match(rRegI);
 3332 
 3333   format %{ &quot;RDI&quot; %}
 3334   interface(REG_INTER);
 3335 %}
 3336 
 3337 operand no_rcx_RegI()
 3338 %{
 3339   constraint(ALLOC_IN_RC(int_no_rcx_reg));
 3340   match(RegI);
 3341   match(rax_RegI);
 3342   match(rbx_RegI);
 3343   match(rdx_RegI);
 3344   match(rdi_RegI);
 3345 
 3346   format %{ %}
 3347   interface(REG_INTER);
 3348 %}
 3349 
 3350 operand no_rax_rdx_RegI()
 3351 %{
 3352   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
 3353   match(RegI);
 3354   match(rbx_RegI);
 3355   match(rcx_RegI);
 3356   match(rdi_RegI);
 3357 
 3358   format %{ %}
 3359   interface(REG_INTER);
 3360 %}
 3361 
 3362 // Pointer Register
 3363 operand any_RegP()
 3364 %{
 3365   constraint(ALLOC_IN_RC(any_reg));
 3366   match(RegP);
 3367   match(rax_RegP);
 3368   match(rbx_RegP);
 3369   match(rdi_RegP);
 3370   match(rsi_RegP);
 3371   match(rbp_RegP);
 3372   match(r15_RegP);
 3373   match(rRegP);
 3374 
 3375   format %{ %}
 3376   interface(REG_INTER);
 3377 %}
 3378 
 3379 operand rRegP()
 3380 %{
 3381   constraint(ALLOC_IN_RC(ptr_reg));
 3382   match(RegP);
 3383   match(rax_RegP);
 3384   match(rbx_RegP);
 3385   match(rdi_RegP);
 3386   match(rsi_RegP);
 3387   match(rbp_RegP);  // See Q&amp;A below about
 3388   match(r15_RegP);  // r15_RegP and rbp_RegP.
 3389 
 3390   format %{ %}
 3391   interface(REG_INTER);
 3392 %}
 3393 
 3394 operand rRegN() %{
 3395   constraint(ALLOC_IN_RC(int_reg));
 3396   match(RegN);
 3397 
 3398   format %{ %}
 3399   interface(REG_INTER);
 3400 %}
 3401 
 3402 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
 3403 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
 3404 // It&#39;s fine for an instruction input that expects rRegP to match a r15_RegP.
 3405 // The output of an instruction is controlled by the allocator, which respects
 3406 // register class masks, not match rules.  Unless an instruction mentions
 3407 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
 3408 // by the allocator as an input.
 3409 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
 3410 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
 3411 // result, RBP is not included in the output of the instruction either.
 3412 
 3413 operand no_rax_RegP()
 3414 %{
 3415   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
 3416   match(RegP);
 3417   match(rbx_RegP);
 3418   match(rsi_RegP);
 3419   match(rdi_RegP);
 3420 
 3421   format %{ %}
 3422   interface(REG_INTER);
 3423 %}
 3424 
 3425 // This operand is not allowed to use RBP even if
 3426 // RBP is not used to hold the frame pointer.
 3427 operand no_rbp_RegP()
 3428 %{
 3429   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
 3430   match(RegP);
 3431   match(rbx_RegP);
 3432   match(rsi_RegP);
 3433   match(rdi_RegP);
 3434 
 3435   format %{ %}
 3436   interface(REG_INTER);
 3437 %}
 3438 
 3439 operand no_rax_rbx_RegP()
 3440 %{
 3441   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
 3442   match(RegP);
 3443   match(rsi_RegP);
 3444   match(rdi_RegP);
 3445 
 3446   format %{ %}
 3447   interface(REG_INTER);
 3448 %}
 3449 
 3450 // Special Registers
 3451 // Return a pointer value
 3452 operand rax_RegP()
 3453 %{
 3454   constraint(ALLOC_IN_RC(ptr_rax_reg));
 3455   match(RegP);
 3456   match(rRegP);
 3457 
 3458   format %{ %}
 3459   interface(REG_INTER);
 3460 %}
 3461 
 3462 // Special Registers
 3463 // Return a compressed pointer value
 3464 operand rax_RegN()
 3465 %{
 3466   constraint(ALLOC_IN_RC(int_rax_reg));
 3467   match(RegN);
 3468   match(rRegN);
 3469 
 3470   format %{ %}
 3471   interface(REG_INTER);
 3472 %}
 3473 
 3474 // Used in AtomicAdd
 3475 operand rbx_RegP()
 3476 %{
 3477   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3478   match(RegP);
 3479   match(rRegP);
 3480 
 3481   format %{ %}
 3482   interface(REG_INTER);
 3483 %}
 3484 
 3485 operand rsi_RegP()
 3486 %{
 3487   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3488   match(RegP);
 3489   match(rRegP);
 3490 
 3491   format %{ %}
 3492   interface(REG_INTER);
 3493 %}
 3494 
 3495 operand rbp_RegP()
 3496 %{
 3497   constraint(ALLOC_IN_RC(ptr_rbp_reg));
 3498   match(RegP);
 3499   match(rRegP);
 3500 
 3501   format %{ %}
 3502   interface(REG_INTER);
 3503 %}
 3504 
 3505 // Used in rep stosq
 3506 operand rdi_RegP()
 3507 %{
 3508   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3509   match(RegP);
 3510   match(rRegP);
 3511 
 3512   format %{ %}
 3513   interface(REG_INTER);
 3514 %}
 3515 
 3516 operand r15_RegP()
 3517 %{
 3518   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3519   match(RegP);
 3520   match(rRegP);
 3521 
 3522   format %{ %}
 3523   interface(REG_INTER);
 3524 %}
 3525 
 3526 operand rRegL()
 3527 %{
 3528   constraint(ALLOC_IN_RC(long_reg));
 3529   match(RegL);
 3530   match(rax_RegL);
 3531   match(rdx_RegL);
 3532 
 3533   format %{ %}
 3534   interface(REG_INTER);
 3535 %}
 3536 
 3537 // Special Registers
 3538 operand no_rax_rdx_RegL()
 3539 %{
 3540   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3541   match(RegL);
 3542   match(rRegL);
 3543 
 3544   format %{ %}
 3545   interface(REG_INTER);
 3546 %}
 3547 
 3548 operand no_rax_RegL()
 3549 %{
 3550   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3551   match(RegL);
 3552   match(rRegL);
 3553   match(rdx_RegL);
 3554 
 3555   format %{ %}
 3556   interface(REG_INTER);
 3557 %}
 3558 
 3559 operand no_rcx_RegL()
 3560 %{
 3561   constraint(ALLOC_IN_RC(long_no_rcx_reg));
 3562   match(RegL);
 3563   match(rRegL);
 3564 
 3565   format %{ %}
 3566   interface(REG_INTER);
 3567 %}
 3568 
 3569 operand rax_RegL()
 3570 %{
 3571   constraint(ALLOC_IN_RC(long_rax_reg));
 3572   match(RegL);
 3573   match(rRegL);
 3574 
 3575   format %{ &quot;RAX&quot; %}
 3576   interface(REG_INTER);
 3577 %}
 3578 
 3579 operand rcx_RegL()
 3580 %{
 3581   constraint(ALLOC_IN_RC(long_rcx_reg));
 3582   match(RegL);
 3583   match(rRegL);
 3584 
 3585   format %{ %}
 3586   interface(REG_INTER);
 3587 %}
 3588 
 3589 operand rdx_RegL()
 3590 %{
 3591   constraint(ALLOC_IN_RC(long_rdx_reg));
 3592   match(RegL);
 3593   match(rRegL);
 3594 
 3595   format %{ %}
 3596   interface(REG_INTER);
 3597 %}
 3598 
 3599 // Flags register, used as output of compare instructions
 3600 operand rFlagsReg()
 3601 %{
 3602   constraint(ALLOC_IN_RC(int_flags));
 3603   match(RegFlags);
 3604 
 3605   format %{ &quot;RFLAGS&quot; %}
 3606   interface(REG_INTER);
 3607 %}
 3608 
 3609 // Flags register, used as output of FLOATING POINT compare instructions
 3610 operand rFlagsRegU()
 3611 %{
 3612   constraint(ALLOC_IN_RC(int_flags));
 3613   match(RegFlags);
 3614 
 3615   format %{ &quot;RFLAGS_U&quot; %}
 3616   interface(REG_INTER);
 3617 %}
 3618 
 3619 operand rFlagsRegUCF() %{
 3620   constraint(ALLOC_IN_RC(int_flags));
 3621   match(RegFlags);
 3622   predicate(false);
 3623 
 3624   format %{ &quot;RFLAGS_U_CF&quot; %}
 3625   interface(REG_INTER);
 3626 %}
 3627 
 3628 // Float register operands
 3629 operand regF() %{
 3630    constraint(ALLOC_IN_RC(float_reg));
 3631    match(RegF);
 3632 
 3633    format %{ %}
 3634    interface(REG_INTER);
 3635 %}
 3636 
 3637 // Float register operands
 3638 operand legRegF() %{
 3639    constraint(ALLOC_IN_RC(float_reg_legacy));
 3640    match(RegF);
 3641 
 3642    format %{ %}
 3643    interface(REG_INTER);
 3644 %}
 3645 
 3646 // Float register operands
 3647 operand vlRegF() %{
 3648    constraint(ALLOC_IN_RC(float_reg_vl));
 3649    match(RegF);
 3650 
 3651    format %{ %}
 3652    interface(REG_INTER);
 3653 %}
 3654 
 3655 // Double register operands
 3656 operand regD() %{
 3657    constraint(ALLOC_IN_RC(double_reg));
 3658    match(RegD);
 3659 
 3660    format %{ %}
 3661    interface(REG_INTER);
 3662 %}
 3663 
 3664 // Double register operands
 3665 operand legRegD() %{
 3666    constraint(ALLOC_IN_RC(double_reg_legacy));
 3667    match(RegD);
 3668 
 3669    format %{ %}
 3670    interface(REG_INTER);
 3671 %}
 3672 
 3673 // Double register operands
 3674 operand vlRegD() %{
 3675    constraint(ALLOC_IN_RC(double_reg_vl));
 3676    match(RegD);
 3677 
 3678    format %{ %}
 3679    interface(REG_INTER);
 3680 %}
 3681 
 3682 //----------Memory Operands----------------------------------------------------
 3683 // Direct Memory Operand
 3684 // operand direct(immP addr)
 3685 // %{
 3686 //   match(addr);
 3687 
 3688 //   format %{ &quot;[$addr]&quot; %}
 3689 //   interface(MEMORY_INTER) %{
 3690 //     base(0xFFFFFFFF);
 3691 //     index(0x4);
 3692 //     scale(0x0);
 3693 //     disp($addr);
 3694 //   %}
 3695 // %}
 3696 
 3697 // Indirect Memory Operand
 3698 operand indirect(any_RegP reg)
 3699 %{
 3700   constraint(ALLOC_IN_RC(ptr_reg));
 3701   match(reg);
 3702 
 3703   format %{ &quot;[$reg]&quot; %}
 3704   interface(MEMORY_INTER) %{
 3705     base($reg);
 3706     index(0x4);
 3707     scale(0x0);
 3708     disp(0x0);
 3709   %}
 3710 %}
 3711 
 3712 // Indirect Memory Plus Short Offset Operand
 3713 operand indOffset8(any_RegP reg, immL8 off)
 3714 %{
 3715   constraint(ALLOC_IN_RC(ptr_reg));
 3716   match(AddP reg off);
 3717 
 3718   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3719   interface(MEMORY_INTER) %{
 3720     base($reg);
 3721     index(0x4);
 3722     scale(0x0);
 3723     disp($off);
 3724   %}
 3725 %}
 3726 
 3727 // Indirect Memory Plus Long Offset Operand
 3728 operand indOffset32(any_RegP reg, immL32 off)
 3729 %{
 3730   constraint(ALLOC_IN_RC(ptr_reg));
 3731   match(AddP reg off);
 3732 
 3733   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3734   interface(MEMORY_INTER) %{
 3735     base($reg);
 3736     index(0x4);
 3737     scale(0x0);
 3738     disp($off);
 3739   %}
 3740 %}
 3741 
 3742 // Indirect Memory Plus Index Register Plus Offset Operand
 3743 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
 3744 %{
 3745   constraint(ALLOC_IN_RC(ptr_reg));
 3746   match(AddP (AddP reg lreg) off);
 3747 
 3748   op_cost(10);
 3749   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3750   interface(MEMORY_INTER) %{
 3751     base($reg);
 3752     index($lreg);
 3753     scale(0x0);
 3754     disp($off);
 3755   %}
 3756 %}
 3757 
 3758 // Indirect Memory Plus Index Register Plus Offset Operand
 3759 operand indIndex(any_RegP reg, rRegL lreg)
 3760 %{
 3761   constraint(ALLOC_IN_RC(ptr_reg));
 3762   match(AddP reg lreg);
 3763 
 3764   op_cost(10);
 3765   format %{&quot;[$reg + $lreg]&quot; %}
 3766   interface(MEMORY_INTER) %{
 3767     base($reg);
 3768     index($lreg);
 3769     scale(0x0);
 3770     disp(0x0);
 3771   %}
 3772 %}
 3773 
 3774 // Indirect Memory Times Scale Plus Index Register
 3775 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
 3776 %{
 3777   constraint(ALLOC_IN_RC(ptr_reg));
 3778   match(AddP reg (LShiftL lreg scale));
 3779 
 3780   op_cost(10);
 3781   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3782   interface(MEMORY_INTER) %{
 3783     base($reg);
 3784     index($lreg);
 3785     scale($scale);
 3786     disp(0x0);
 3787   %}
 3788 %}
 3789 
 3790 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
 3791 %{
 3792   constraint(ALLOC_IN_RC(ptr_reg));
 3793   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3794   match(AddP reg (LShiftL (ConvI2L idx) scale));
 3795 
 3796   op_cost(10);
 3797   format %{&quot;[$reg + pos $idx &lt;&lt; $scale]&quot; %}
 3798   interface(MEMORY_INTER) %{
 3799     base($reg);
 3800     index($idx);
 3801     scale($scale);
 3802     disp(0x0);
 3803   %}
 3804 %}
 3805 
 3806 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3807 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
 3808 %{
 3809   constraint(ALLOC_IN_RC(ptr_reg));
 3810   match(AddP (AddP reg (LShiftL lreg scale)) off);
 3811 
 3812   op_cost(10);
 3813   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3814   interface(MEMORY_INTER) %{
 3815     base($reg);
 3816     index($lreg);
 3817     scale($scale);
 3818     disp($off);
 3819   %}
 3820 %}
 3821 
 3822 // Indirect Memory Plus Positive Index Register Plus Offset Operand
 3823 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
 3824 %{
 3825   constraint(ALLOC_IN_RC(ptr_reg));
 3826   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3827   match(AddP (AddP reg (ConvI2L idx)) off);
 3828 
 3829   op_cost(10);
 3830   format %{&quot;[$reg + $off + $idx]&quot; %}
 3831   interface(MEMORY_INTER) %{
 3832     base($reg);
 3833     index($idx);
 3834     scale(0x0);
 3835     disp($off);
 3836   %}
 3837 %}
 3838 
 3839 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3840 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3841 %{
 3842   constraint(ALLOC_IN_RC(ptr_reg));
 3843   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3844   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3845 
 3846   op_cost(10);
 3847   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3848   interface(MEMORY_INTER) %{
 3849     base($reg);
 3850     index($idx);
 3851     scale($scale);
 3852     disp($off);
 3853   %}
 3854 %}
 3855 
 3856 // Indirect Narrow Oop Operand
 3857 operand indCompressedOop(rRegN reg) %{
 3858   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3859   constraint(ALLOC_IN_RC(ptr_reg));
 3860   match(DecodeN reg);
 3861 
 3862   op_cost(10);
 3863   format %{&quot;[R12 + $reg &lt;&lt; 3] (compressed oop addressing)&quot; %}
 3864   interface(MEMORY_INTER) %{
 3865     base(0xc); // R12
 3866     index($reg);
 3867     scale(0x3);
 3868     disp(0x0);
 3869   %}
 3870 %}
 3871 
 3872 // Indirect Narrow Oop Plus Offset Operand
 3873 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3874 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3875 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3876   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3877   constraint(ALLOC_IN_RC(ptr_reg));
 3878   match(AddP (DecodeN reg) off);
 3879 
 3880   op_cost(10);
 3881   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3882   interface(MEMORY_INTER) %{
 3883     base(0xc); // R12
 3884     index($reg);
 3885     scale(0x3);
 3886     disp($off);
 3887   %}
 3888 %}
 3889 
 3890 // Indirect Memory Operand
 3891 operand indirectNarrow(rRegN reg)
 3892 %{
 3893   predicate(CompressedOops::shift() == 0);
 3894   constraint(ALLOC_IN_RC(ptr_reg));
 3895   match(DecodeN reg);
 3896 
 3897   format %{ &quot;[$reg]&quot; %}
 3898   interface(MEMORY_INTER) %{
 3899     base($reg);
 3900     index(0x4);
 3901     scale(0x0);
 3902     disp(0x0);
 3903   %}
 3904 %}
 3905 
 3906 // Indirect Memory Plus Short Offset Operand
 3907 operand indOffset8Narrow(rRegN reg, immL8 off)
 3908 %{
 3909   predicate(CompressedOops::shift() == 0);
 3910   constraint(ALLOC_IN_RC(ptr_reg));
 3911   match(AddP (DecodeN reg) off);
 3912 
 3913   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3914   interface(MEMORY_INTER) %{
 3915     base($reg);
 3916     index(0x4);
 3917     scale(0x0);
 3918     disp($off);
 3919   %}
 3920 %}
 3921 
 3922 // Indirect Memory Plus Long Offset Operand
 3923 operand indOffset32Narrow(rRegN reg, immL32 off)
 3924 %{
 3925   predicate(CompressedOops::shift() == 0);
 3926   constraint(ALLOC_IN_RC(ptr_reg));
 3927   match(AddP (DecodeN reg) off);
 3928 
 3929   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3930   interface(MEMORY_INTER) %{
 3931     base($reg);
 3932     index(0x4);
 3933     scale(0x0);
 3934     disp($off);
 3935   %}
 3936 %}
 3937 
 3938 // Indirect Memory Plus Index Register Plus Offset Operand
 3939 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3940 %{
 3941   predicate(CompressedOops::shift() == 0);
 3942   constraint(ALLOC_IN_RC(ptr_reg));
 3943   match(AddP (AddP (DecodeN reg) lreg) off);
 3944 
 3945   op_cost(10);
 3946   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3947   interface(MEMORY_INTER) %{
 3948     base($reg);
 3949     index($lreg);
 3950     scale(0x0);
 3951     disp($off);
 3952   %}
 3953 %}
 3954 
 3955 // Indirect Memory Plus Index Register Plus Offset Operand
 3956 operand indIndexNarrow(rRegN reg, rRegL lreg)
 3957 %{
 3958   predicate(CompressedOops::shift() == 0);
 3959   constraint(ALLOC_IN_RC(ptr_reg));
 3960   match(AddP (DecodeN reg) lreg);
 3961 
 3962   op_cost(10);
 3963   format %{&quot;[$reg + $lreg]&quot; %}
 3964   interface(MEMORY_INTER) %{
 3965     base($reg);
 3966     index($lreg);
 3967     scale(0x0);
 3968     disp(0x0);
 3969   %}
 3970 %}
 3971 
 3972 // Indirect Memory Times Scale Plus Index Register
 3973 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 3974 %{
 3975   predicate(CompressedOops::shift() == 0);
 3976   constraint(ALLOC_IN_RC(ptr_reg));
 3977   match(AddP (DecodeN reg) (LShiftL lreg scale));
 3978 
 3979   op_cost(10);
 3980   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3981   interface(MEMORY_INTER) %{
 3982     base($reg);
 3983     index($lreg);
 3984     scale($scale);
 3985     disp(0x0);
 3986   %}
 3987 %}
 3988 
 3989 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3990 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 3991 %{
 3992   predicate(CompressedOops::shift() == 0);
 3993   constraint(ALLOC_IN_RC(ptr_reg));
 3994   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 3995 
 3996   op_cost(10);
 3997   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3998   interface(MEMORY_INTER) %{
 3999     base($reg);
 4000     index($lreg);
 4001     scale($scale);
 4002     disp($off);
 4003   %}
 4004 %}
 4005 
 4006 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 4007 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4008 %{
 4009   constraint(ALLOC_IN_RC(ptr_reg));
 4010   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4011   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4012 
 4013   op_cost(10);
 4014   format %{&quot;[$reg + $off + $idx]&quot; %}
 4015   interface(MEMORY_INTER) %{
 4016     base($reg);
 4017     index($idx);
 4018     scale(0x0);
 4019     disp($off);
 4020   %}
 4021 %}
 4022 
 4023 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4024 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4025 %{
 4026   constraint(ALLOC_IN_RC(ptr_reg));
 4027   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4028   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4029 
 4030   op_cost(10);
 4031   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4032   interface(MEMORY_INTER) %{
 4033     base($reg);
 4034     index($idx);
 4035     scale($scale);
 4036     disp($off);
 4037   %}
 4038 %}
 4039 
 4040 //----------Special Memory Operands--------------------------------------------
 4041 // Stack Slot Operand - This operand is used for loading and storing temporary
 4042 //                      values on the stack where a match requires a value to
 4043 //                      flow through memory.
 4044 operand stackSlotP(sRegP reg)
 4045 %{
 4046   constraint(ALLOC_IN_RC(stack_slots));
 4047   // No match rule because this operand is only generated in matching
 4048 
 4049   format %{ &quot;[$reg]&quot; %}
 4050   interface(MEMORY_INTER) %{
 4051     base(0x4);   // RSP
 4052     index(0x4);  // No Index
 4053     scale(0x0);  // No Scale
 4054     disp($reg);  // Stack Offset
 4055   %}
 4056 %}
 4057 
 4058 operand stackSlotI(sRegI reg)
 4059 %{
 4060   constraint(ALLOC_IN_RC(stack_slots));
 4061   // No match rule because this operand is only generated in matching
 4062 
 4063   format %{ &quot;[$reg]&quot; %}
 4064   interface(MEMORY_INTER) %{
 4065     base(0x4);   // RSP
 4066     index(0x4);  // No Index
 4067     scale(0x0);  // No Scale
 4068     disp($reg);  // Stack Offset
 4069   %}
 4070 %}
 4071 
 4072 operand stackSlotF(sRegF reg)
 4073 %{
 4074   constraint(ALLOC_IN_RC(stack_slots));
 4075   // No match rule because this operand is only generated in matching
 4076 
 4077   format %{ &quot;[$reg]&quot; %}
 4078   interface(MEMORY_INTER) %{
 4079     base(0x4);   // RSP
 4080     index(0x4);  // No Index
 4081     scale(0x0);  // No Scale
 4082     disp($reg);  // Stack Offset
 4083   %}
 4084 %}
 4085 
 4086 operand stackSlotD(sRegD reg)
 4087 %{
 4088   constraint(ALLOC_IN_RC(stack_slots));
 4089   // No match rule because this operand is only generated in matching
 4090 
 4091   format %{ &quot;[$reg]&quot; %}
 4092   interface(MEMORY_INTER) %{
 4093     base(0x4);   // RSP
 4094     index(0x4);  // No Index
 4095     scale(0x0);  // No Scale
 4096     disp($reg);  // Stack Offset
 4097   %}
 4098 %}
 4099 operand stackSlotL(sRegL reg)
 4100 %{
 4101   constraint(ALLOC_IN_RC(stack_slots));
 4102   // No match rule because this operand is only generated in matching
 4103 
 4104   format %{ &quot;[$reg]&quot; %}
 4105   interface(MEMORY_INTER) %{
 4106     base(0x4);   // RSP
 4107     index(0x4);  // No Index
 4108     scale(0x0);  // No Scale
 4109     disp($reg);  // Stack Offset
 4110   %}
 4111 %}
 4112 
 4113 //----------Conditional Branch Operands----------------------------------------
 4114 // Comparison Op  - This is the operation of the comparison, and is limited to
 4115 //                  the following set of codes:
 4116 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4117 //
 4118 // Other attributes of the comparison, such as unsignedness, are specified
 4119 // by the comparison instruction that sets a condition code flags register.
 4120 // That result is represented by a flags operand whose subtype is appropriate
 4121 // to the unsignedness (etc.) of the comparison.
 4122 //
 4123 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4124 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4125 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4126 
 4127 // Comparision Code
 4128 operand cmpOp()
 4129 %{
 4130   match(Bool);
 4131 
 4132   format %{ &quot;&quot; %}
 4133   interface(COND_INTER) %{
 4134     equal(0x4, &quot;e&quot;);
 4135     not_equal(0x5, &quot;ne&quot;);
 4136     less(0xC, &quot;l&quot;);
 4137     greater_equal(0xD, &quot;ge&quot;);
 4138     less_equal(0xE, &quot;le&quot;);
 4139     greater(0xF, &quot;g&quot;);
 4140     overflow(0x0, &quot;o&quot;);
 4141     no_overflow(0x1, &quot;no&quot;);
 4142   %}
 4143 %}
 4144 
 4145 // Comparison Code, unsigned compare.  Used by FP also, with
 4146 // C2 (unordered) turned into GT or LT already.  The other bits
 4147 // C0 and C3 are turned into Carry &amp; Zero flags.
 4148 operand cmpOpU()
 4149 %{
 4150   match(Bool);
 4151 
 4152   format %{ &quot;&quot; %}
 4153   interface(COND_INTER) %{
 4154     equal(0x4, &quot;e&quot;);
 4155     not_equal(0x5, &quot;ne&quot;);
 4156     less(0x2, &quot;b&quot;);
 4157     greater_equal(0x3, &quot;nb&quot;);
 4158     less_equal(0x6, &quot;be&quot;);
 4159     greater(0x7, &quot;nbe&quot;);
 4160     overflow(0x0, &quot;o&quot;);
 4161     no_overflow(0x1, &quot;no&quot;);
 4162   %}
 4163 %}
 4164 
 4165 
 4166 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4167 operand cmpOpUCF() %{
 4168   match(Bool);
 4169   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4170             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4171             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4172             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4173   format %{ &quot;&quot; %}
 4174   interface(COND_INTER) %{
 4175     equal(0x4, &quot;e&quot;);
 4176     not_equal(0x5, &quot;ne&quot;);
 4177     less(0x2, &quot;b&quot;);
 4178     greater_equal(0x3, &quot;nb&quot;);
 4179     less_equal(0x6, &quot;be&quot;);
 4180     greater(0x7, &quot;nbe&quot;);
 4181     overflow(0x0, &quot;o&quot;);
 4182     no_overflow(0x1, &quot;no&quot;);
 4183   %}
 4184 %}
 4185 
 4186 
 4187 // Floating comparisons that can be fixed up with extra conditional jumps
 4188 operand cmpOpUCF2() %{
 4189   match(Bool);
 4190   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4191             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4192   format %{ &quot;&quot; %}
 4193   interface(COND_INTER) %{
 4194     equal(0x4, &quot;e&quot;);
 4195     not_equal(0x5, &quot;ne&quot;);
 4196     less(0x2, &quot;b&quot;);
 4197     greater_equal(0x3, &quot;nb&quot;);
 4198     less_equal(0x6, &quot;be&quot;);
 4199     greater(0x7, &quot;nbe&quot;);
 4200     overflow(0x0, &quot;o&quot;);
 4201     no_overflow(0x1, &quot;no&quot;);
 4202   %}
 4203 %}
 4204 
 4205 //----------OPERAND CLASSES----------------------------------------------------
 4206 // Operand Classes are groups of operands that are used as to simplify
 4207 // instruction definitions by not requiring the AD writer to specify separate
 4208 // instructions for every form of operand when the instruction accepts
 4209 // multiple operand types with the same basic encoding and format.  The classic
 4210 // case of this is memory operands.
 4211 
 4212 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4213                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4214                indCompressedOop, indCompressedOopOffset,
 4215                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4216                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4217                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4218 
 4219 //----------PIPELINE-----------------------------------------------------------
 4220 // Rules which define the behavior of the target architectures pipeline.
 4221 pipeline %{
 4222 
 4223 //----------ATTRIBUTES---------------------------------------------------------
 4224 attributes %{
 4225   variable_size_instructions;        // Fixed size instructions
 4226   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4227   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4228   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4229   instruction_fetch_units = 1;       // of 16 bytes
 4230 
 4231   // List of nop instructions
 4232   nops( MachNop );
 4233 %}
 4234 
 4235 //----------RESOURCES----------------------------------------------------------
 4236 // Resources are the functional units available to the machine
 4237 
 4238 // Generic P2/P3 pipeline
 4239 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4240 // 3 instructions decoded per cycle.
 4241 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4242 // 3 ALU op, only ALU0 handles mul instructions.
 4243 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4244            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
 4245            BR, FPU,
 4246            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
 4247 
 4248 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4249 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4250 
 4251 // Generic P2/P3 pipeline
 4252 pipe_desc(S0, S1, S2, S3, S4, S5);
 4253 
 4254 //----------PIPELINE CLASSES---------------------------------------------------
 4255 // Pipeline Classes describe the stages in which input and output are
 4256 // referenced by the hardware pipeline.
 4257 
 4258 // Naming convention: ialu or fpu
 4259 // Then: _reg
 4260 // Then: _reg if there is a 2nd register
 4261 // Then: _long if it&#39;s a pair of instructions implementing a long
 4262 // Then: _fat if it requires the big decoder
 4263 //   Or: _mem if it requires the big decoder and a memory unit.
 4264 
 4265 // Integer ALU reg operation
 4266 pipe_class ialu_reg(rRegI dst)
 4267 %{
 4268     single_instruction;
 4269     dst    : S4(write);
 4270     dst    : S3(read);
 4271     DECODE : S0;        // any decoder
 4272     ALU    : S3;        // any alu
 4273 %}
 4274 
 4275 // Long ALU reg operation
 4276 pipe_class ialu_reg_long(rRegL dst)
 4277 %{
 4278     instruction_count(2);
 4279     dst    : S4(write);
 4280     dst    : S3(read);
 4281     DECODE : S0(2);     // any 2 decoders
 4282     ALU    : S3(2);     // both alus
 4283 %}
 4284 
 4285 // Integer ALU reg operation using big decoder
 4286 pipe_class ialu_reg_fat(rRegI dst)
 4287 %{
 4288     single_instruction;
 4289     dst    : S4(write);
 4290     dst    : S3(read);
 4291     D0     : S0;        // big decoder only
 4292     ALU    : S3;        // any alu
 4293 %}
 4294 
 4295 // Long ALU reg operation using big decoder
 4296 pipe_class ialu_reg_long_fat(rRegL dst)
 4297 %{
 4298     instruction_count(2);
 4299     dst    : S4(write);
 4300     dst    : S3(read);
 4301     D0     : S0(2);     // big decoder only; twice
 4302     ALU    : S3(2);     // any 2 alus
 4303 %}
 4304 
 4305 // Integer ALU reg-reg operation
 4306 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
 4307 %{
 4308     single_instruction;
 4309     dst    : S4(write);
 4310     src    : S3(read);
 4311     DECODE : S0;        // any decoder
 4312     ALU    : S3;        // any alu
 4313 %}
 4314 
 4315 // Long ALU reg-reg operation
 4316 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
 4317 %{
 4318     instruction_count(2);
 4319     dst    : S4(write);
 4320     src    : S3(read);
 4321     DECODE : S0(2);     // any 2 decoders
 4322     ALU    : S3(2);     // both alus
 4323 %}
 4324 
 4325 // Integer ALU reg-reg operation
 4326 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
 4327 %{
 4328     single_instruction;
 4329     dst    : S4(write);
 4330     src    : S3(read);
 4331     D0     : S0;        // big decoder only
 4332     ALU    : S3;        // any alu
 4333 %}
 4334 
 4335 // Long ALU reg-reg operation
 4336 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
 4337 %{
 4338     instruction_count(2);
 4339     dst    : S4(write);
 4340     src    : S3(read);
 4341     D0     : S0(2);     // big decoder only; twice
 4342     ALU    : S3(2);     // both alus
 4343 %}
 4344 
 4345 // Integer ALU reg-mem operation
 4346 pipe_class ialu_reg_mem(rRegI dst, memory mem)
 4347 %{
 4348     single_instruction;
 4349     dst    : S5(write);
 4350     mem    : S3(read);
 4351     D0     : S0;        // big decoder only
 4352     ALU    : S4;        // any alu
 4353     MEM    : S3;        // any mem
 4354 %}
 4355 
 4356 // Integer mem operation (prefetch)
 4357 pipe_class ialu_mem(memory mem)
 4358 %{
 4359     single_instruction;
 4360     mem    : S3(read);
 4361     D0     : S0;        // big decoder only
 4362     MEM    : S3;        // any mem
 4363 %}
 4364 
 4365 // Integer Store to Memory
 4366 pipe_class ialu_mem_reg(memory mem, rRegI src)
 4367 %{
 4368     single_instruction;
 4369     mem    : S3(read);
 4370     src    : S5(read);
 4371     D0     : S0;        // big decoder only
 4372     ALU    : S4;        // any alu
 4373     MEM    : S3;
 4374 %}
 4375 
 4376 // // Long Store to Memory
 4377 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
 4378 // %{
 4379 //     instruction_count(2);
 4380 //     mem    : S3(read);
 4381 //     src    : S5(read);
 4382 //     D0     : S0(2);          // big decoder only; twice
 4383 //     ALU    : S4(2);     // any 2 alus
 4384 //     MEM    : S3(2);  // Both mems
 4385 // %}
 4386 
 4387 // Integer Store to Memory
 4388 pipe_class ialu_mem_imm(memory mem)
 4389 %{
 4390     single_instruction;
 4391     mem    : S3(read);
 4392     D0     : S0;        // big decoder only
 4393     ALU    : S4;        // any alu
 4394     MEM    : S3;
 4395 %}
 4396 
 4397 // Integer ALU0 reg-reg operation
 4398 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
 4399 %{
 4400     single_instruction;
 4401     dst    : S4(write);
 4402     src    : S3(read);
 4403     D0     : S0;        // Big decoder only
 4404     ALU0   : S3;        // only alu0
 4405 %}
 4406 
 4407 // Integer ALU0 reg-mem operation
 4408 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
 4409 %{
 4410     single_instruction;
 4411     dst    : S5(write);
 4412     mem    : S3(read);
 4413     D0     : S0;        // big decoder only
 4414     ALU0   : S4;        // ALU0 only
 4415     MEM    : S3;        // any mem
 4416 %}
 4417 
 4418 // Integer ALU reg-reg operation
 4419 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
 4420 %{
 4421     single_instruction;
 4422     cr     : S4(write);
 4423     src1   : S3(read);
 4424     src2   : S3(read);
 4425     DECODE : S0;        // any decoder
 4426     ALU    : S3;        // any alu
 4427 %}
 4428 
 4429 // Integer ALU reg-imm operation
 4430 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
 4431 %{
 4432     single_instruction;
 4433     cr     : S4(write);
 4434     src1   : S3(read);
 4435     DECODE : S0;        // any decoder
 4436     ALU    : S3;        // any alu
 4437 %}
 4438 
 4439 // Integer ALU reg-mem operation
 4440 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
 4441 %{
 4442     single_instruction;
 4443     cr     : S4(write);
 4444     src1   : S3(read);
 4445     src2   : S3(read);
 4446     D0     : S0;        // big decoder only
 4447     ALU    : S4;        // any alu
 4448     MEM    : S3;
 4449 %}
 4450 
 4451 // Conditional move reg-reg
 4452 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
 4453 %{
 4454     instruction_count(4);
 4455     y      : S4(read);
 4456     q      : S3(read);
 4457     p      : S3(read);
 4458     DECODE : S0(4);     // any decoder
 4459 %}
 4460 
 4461 // Conditional move reg-reg
 4462 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
 4463 %{
 4464     single_instruction;
 4465     dst    : S4(write);
 4466     src    : S3(read);
 4467     cr     : S3(read);
 4468     DECODE : S0;        // any decoder
 4469 %}
 4470 
 4471 // Conditional move reg-mem
 4472 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
 4473 %{
 4474     single_instruction;
 4475     dst    : S4(write);
 4476     src    : S3(read);
 4477     cr     : S3(read);
 4478     DECODE : S0;        // any decoder
 4479     MEM    : S3;
 4480 %}
 4481 
 4482 // Conditional move reg-reg long
 4483 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
 4484 %{
 4485     single_instruction;
 4486     dst    : S4(write);
 4487     src    : S3(read);
 4488     cr     : S3(read);
 4489     DECODE : S0(2);     // any 2 decoders
 4490 %}
 4491 
 4492 // XXX
 4493 // // Conditional move double reg-reg
 4494 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
 4495 // %{
 4496 //     single_instruction;
 4497 //     dst    : S4(write);
 4498 //     src    : S3(read);
 4499 //     cr     : S3(read);
 4500 //     DECODE : S0;     // any decoder
 4501 // %}
 4502 
 4503 // Float reg-reg operation
 4504 pipe_class fpu_reg(regD dst)
 4505 %{
 4506     instruction_count(2);
 4507     dst    : S3(read);
 4508     DECODE : S0(2);     // any 2 decoders
 4509     FPU    : S3;
 4510 %}
 4511 
 4512 // Float reg-reg operation
 4513 pipe_class fpu_reg_reg(regD dst, regD src)
 4514 %{
 4515     instruction_count(2);
 4516     dst    : S4(write);
 4517     src    : S3(read);
 4518     DECODE : S0(2);     // any 2 decoders
 4519     FPU    : S3;
 4520 %}
 4521 
 4522 // Float reg-reg operation
 4523 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
 4524 %{
 4525     instruction_count(3);
 4526     dst    : S4(write);
 4527     src1   : S3(read);
 4528     src2   : S3(read);
 4529     DECODE : S0(3);     // any 3 decoders
 4530     FPU    : S3(2);
 4531 %}
 4532 
 4533 // Float reg-reg operation
 4534 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
 4535 %{
 4536     instruction_count(4);
 4537     dst    : S4(write);
 4538     src1   : S3(read);
 4539     src2   : S3(read);
 4540     src3   : S3(read);
 4541     DECODE : S0(4);     // any 3 decoders
 4542     FPU    : S3(2);
 4543 %}
 4544 
 4545 // Float reg-reg operation
 4546 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
 4547 %{
 4548     instruction_count(4);
 4549     dst    : S4(write);
 4550     src1   : S3(read);
 4551     src2   : S3(read);
 4552     src3   : S3(read);
 4553     DECODE : S1(3);     // any 3 decoders
 4554     D0     : S0;        // Big decoder only
 4555     FPU    : S3(2);
 4556     MEM    : S3;
 4557 %}
 4558 
 4559 // Float reg-mem operation
 4560 pipe_class fpu_reg_mem(regD dst, memory mem)
 4561 %{
 4562     instruction_count(2);
 4563     dst    : S5(write);
 4564     mem    : S3(read);
 4565     D0     : S0;        // big decoder only
 4566     DECODE : S1;        // any decoder for FPU POP
 4567     FPU    : S4;
 4568     MEM    : S3;        // any mem
 4569 %}
 4570 
 4571 // Float reg-mem operation
 4572 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
 4573 %{
 4574     instruction_count(3);
 4575     dst    : S5(write);
 4576     src1   : S3(read);
 4577     mem    : S3(read);
 4578     D0     : S0;        // big decoder only
 4579     DECODE : S1(2);     // any decoder for FPU POP
 4580     FPU    : S4;
 4581     MEM    : S3;        // any mem
 4582 %}
 4583 
 4584 // Float mem-reg operation
 4585 pipe_class fpu_mem_reg(memory mem, regD src)
 4586 %{
 4587     instruction_count(2);
 4588     src    : S5(read);
 4589     mem    : S3(read);
 4590     DECODE : S0;        // any decoder for FPU PUSH
 4591     D0     : S1;        // big decoder only
 4592     FPU    : S4;
 4593     MEM    : S3;        // any mem
 4594 %}
 4595 
 4596 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
 4597 %{
 4598     instruction_count(3);
 4599     src1   : S3(read);
 4600     src2   : S3(read);
 4601     mem    : S3(read);
 4602     DECODE : S0(2);     // any decoder for FPU PUSH
 4603     D0     : S1;        // big decoder only
 4604     FPU    : S4;
 4605     MEM    : S3;        // any mem
 4606 %}
 4607 
 4608 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
 4609 %{
 4610     instruction_count(3);
 4611     src1   : S3(read);
 4612     src2   : S3(read);
 4613     mem    : S4(read);
 4614     DECODE : S0;        // any decoder for FPU PUSH
 4615     D0     : S0(2);     // big decoder only
 4616     FPU    : S4;
 4617     MEM    : S3(2);     // any mem
 4618 %}
 4619 
 4620 pipe_class fpu_mem_mem(memory dst, memory src1)
 4621 %{
 4622     instruction_count(2);
 4623     src1   : S3(read);
 4624     dst    : S4(read);
 4625     D0     : S0(2);     // big decoder only
 4626     MEM    : S3(2);     // any mem
 4627 %}
 4628 
 4629 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
 4630 %{
 4631     instruction_count(3);
 4632     src1   : S3(read);
 4633     src2   : S3(read);
 4634     dst    : S4(read);
 4635     D0     : S0(3);     // big decoder only
 4636     FPU    : S4;
 4637     MEM    : S3(3);     // any mem
 4638 %}
 4639 
 4640 pipe_class fpu_mem_reg_con(memory mem, regD src1)
 4641 %{
 4642     instruction_count(3);
 4643     src1   : S4(read);
 4644     mem    : S4(read);
 4645     DECODE : S0;        // any decoder for FPU PUSH
 4646     D0     : S0(2);     // big decoder only
 4647     FPU    : S4;
 4648     MEM    : S3(2);     // any mem
 4649 %}
 4650 
 4651 // Float load constant
 4652 pipe_class fpu_reg_con(regD dst)
 4653 %{
 4654     instruction_count(2);
 4655     dst    : S5(write);
 4656     D0     : S0;        // big decoder only for the load
 4657     DECODE : S1;        // any decoder for FPU POP
 4658     FPU    : S4;
 4659     MEM    : S3;        // any mem
 4660 %}
 4661 
 4662 // Float load constant
 4663 pipe_class fpu_reg_reg_con(regD dst, regD src)
 4664 %{
 4665     instruction_count(3);
 4666     dst    : S5(write);
 4667     src    : S3(read);
 4668     D0     : S0;        // big decoder only for the load
 4669     DECODE : S1(2);     // any decoder for FPU POP
 4670     FPU    : S4;
 4671     MEM    : S3;        // any mem
 4672 %}
 4673 
 4674 // UnConditional branch
 4675 pipe_class pipe_jmp(label labl)
 4676 %{
 4677     single_instruction;
 4678     BR   : S3;
 4679 %}
 4680 
 4681 // Conditional branch
 4682 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
 4683 %{
 4684     single_instruction;
 4685     cr    : S1(read);
 4686     BR    : S3;
 4687 %}
 4688 
 4689 // Allocation idiom
 4690 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
 4691 %{
 4692     instruction_count(1); force_serialization;
 4693     fixed_latency(6);
 4694     heap_ptr : S3(read);
 4695     DECODE   : S0(3);
 4696     D0       : S2;
 4697     MEM      : S3;
 4698     ALU      : S3(2);
 4699     dst      : S5(write);
 4700     BR       : S5;
 4701 %}
 4702 
 4703 // Generic big/slow expanded idiom
 4704 pipe_class pipe_slow()
 4705 %{
 4706     instruction_count(10); multiple_bundles; force_serialization;
 4707     fixed_latency(100);
 4708     D0  : S0(2);
 4709     MEM : S3(2);
 4710 %}
 4711 
 4712 // The real do-nothing guy
 4713 pipe_class empty()
 4714 %{
 4715     instruction_count(0);
 4716 %}
 4717 
 4718 // Define the class for the Nop node
 4719 define
 4720 %{
 4721    MachNop = empty;
 4722 %}
 4723 
 4724 %}
 4725 
 4726 //----------INSTRUCTIONS-------------------------------------------------------
 4727 //
 4728 // match      -- States which machine-independent subtree may be replaced
 4729 //               by this instruction.
 4730 // ins_cost   -- The estimated cost of this instruction is used by instruction
 4731 //               selection to identify a minimum cost tree of machine
 4732 //               instructions that matches a tree of machine-independent
 4733 //               instructions.
 4734 // format     -- A string providing the disassembly for this instruction.
 4735 //               The value of an instruction&#39;s operand may be inserted
 4736 //               by referring to it with a &#39;$&#39; prefix.
 4737 // opcode     -- Three instruction opcodes may be provided.  These are referred
 4738 //               to within an encode class as $primary, $secondary, and $tertiary
 4739 //               rrspectively.  The primary opcode is commonly used to
 4740 //               indicate the type of machine instruction, while secondary
 4741 //               and tertiary are often used for prefix options or addressing
 4742 //               modes.
 4743 // ins_encode -- A list of encode classes with parameters. The encode class
 4744 //               name must have been defined in an &#39;enc_class&#39; specification
 4745 //               in the encode section of the architecture description.
 4746 
 4747 
 4748 //----------Load/Store/Move Instructions---------------------------------------
 4749 //----------Load Instructions--------------------------------------------------
 4750 
 4751 // Load Byte (8 bit signed)
 4752 instruct loadB(rRegI dst, memory mem)
 4753 %{
 4754   match(Set dst (LoadB mem));
 4755 
 4756   ins_cost(125);
 4757   format %{ &quot;movsbl  $dst, $mem\t# byte&quot; %}
 4758 
 4759   ins_encode %{
 4760     __ movsbl($dst$$Register, $mem$$Address);
 4761   %}
 4762 
 4763   ins_pipe(ialu_reg_mem);
 4764 %}
 4765 
 4766 // Load Byte (8 bit signed) into Long Register
 4767 instruct loadB2L(rRegL dst, memory mem)
 4768 %{
 4769   match(Set dst (ConvI2L (LoadB mem)));
 4770 
 4771   ins_cost(125);
 4772   format %{ &quot;movsbq  $dst, $mem\t# byte -&gt; long&quot; %}
 4773 
 4774   ins_encode %{
 4775     __ movsbq($dst$$Register, $mem$$Address);
 4776   %}
 4777 
 4778   ins_pipe(ialu_reg_mem);
 4779 %}
 4780 
 4781 // Load Unsigned Byte (8 bit UNsigned)
 4782 instruct loadUB(rRegI dst, memory mem)
 4783 %{
 4784   match(Set dst (LoadUB mem));
 4785 
 4786   ins_cost(125);
 4787   format %{ &quot;movzbl  $dst, $mem\t# ubyte&quot; %}
 4788 
 4789   ins_encode %{
 4790     __ movzbl($dst$$Register, $mem$$Address);
 4791   %}
 4792 
 4793   ins_pipe(ialu_reg_mem);
 4794 %}
 4795 
 4796 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 4797 instruct loadUB2L(rRegL dst, memory mem)
 4798 %{
 4799   match(Set dst (ConvI2L (LoadUB mem)));
 4800 
 4801   ins_cost(125);
 4802   format %{ &quot;movzbq  $dst, $mem\t# ubyte -&gt; long&quot; %}
 4803 
 4804   ins_encode %{
 4805     __ movzbq($dst$$Register, $mem$$Address);
 4806   %}
 4807 
 4808   ins_pipe(ialu_reg_mem);
 4809 %}
 4810 
 4811 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 4812 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4813   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 4814   effect(KILL cr);
 4815 
 4816   format %{ &quot;movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 4817             &quot;andl    $dst, right_n_bits($mask, 8)&quot; %}
 4818   ins_encode %{
 4819     Register Rdst = $dst$$Register;
 4820     __ movzbq(Rdst, $mem$$Address);
 4821     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 4822   %}
 4823   ins_pipe(ialu_reg_mem);
 4824 %}
 4825 
 4826 // Load Short (16 bit signed)
 4827 instruct loadS(rRegI dst, memory mem)
 4828 %{
 4829   match(Set dst (LoadS mem));
 4830 
 4831   ins_cost(125);
 4832   format %{ &quot;movswl $dst, $mem\t# short&quot; %}
 4833 
 4834   ins_encode %{
 4835     __ movswl($dst$$Register, $mem$$Address);
 4836   %}
 4837 
 4838   ins_pipe(ialu_reg_mem);
 4839 %}
 4840 
 4841 // Load Short (16 bit signed) to Byte (8 bit signed)
 4842 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4843   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 4844 
 4845   ins_cost(125);
 4846   format %{ &quot;movsbl $dst, $mem\t# short -&gt; byte&quot; %}
 4847   ins_encode %{
 4848     __ movsbl($dst$$Register, $mem$$Address);
 4849   %}
 4850   ins_pipe(ialu_reg_mem);
 4851 %}
 4852 
 4853 // Load Short (16 bit signed) into Long Register
 4854 instruct loadS2L(rRegL dst, memory mem)
 4855 %{
 4856   match(Set dst (ConvI2L (LoadS mem)));
 4857 
 4858   ins_cost(125);
 4859   format %{ &quot;movswq $dst, $mem\t# short -&gt; long&quot; %}
 4860 
 4861   ins_encode %{
 4862     __ movswq($dst$$Register, $mem$$Address);
 4863   %}
 4864 
 4865   ins_pipe(ialu_reg_mem);
 4866 %}
 4867 
 4868 // Load Unsigned Short/Char (16 bit UNsigned)
 4869 instruct loadUS(rRegI dst, memory mem)
 4870 %{
 4871   match(Set dst (LoadUS mem));
 4872 
 4873   ins_cost(125);
 4874   format %{ &quot;movzwl  $dst, $mem\t# ushort/char&quot; %}
 4875 
 4876   ins_encode %{
 4877     __ movzwl($dst$$Register, $mem$$Address);
 4878   %}
 4879 
 4880   ins_pipe(ialu_reg_mem);
 4881 %}
 4882 
 4883 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 4884 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4885   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 4886 
 4887   ins_cost(125);
 4888   format %{ &quot;movsbl $dst, $mem\t# ushort -&gt; byte&quot; %}
 4889   ins_encode %{
 4890     __ movsbl($dst$$Register, $mem$$Address);
 4891   %}
 4892   ins_pipe(ialu_reg_mem);
 4893 %}
 4894 
 4895 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 4896 instruct loadUS2L(rRegL dst, memory mem)
 4897 %{
 4898   match(Set dst (ConvI2L (LoadUS mem)));
 4899 
 4900   ins_cost(125);
 4901   format %{ &quot;movzwq  $dst, $mem\t# ushort/char -&gt; long&quot; %}
 4902 
 4903   ins_encode %{
 4904     __ movzwq($dst$$Register, $mem$$Address);
 4905   %}
 4906 
 4907   ins_pipe(ialu_reg_mem);
 4908 %}
 4909 
 4910 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 4911 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 4912   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4913 
 4914   format %{ &quot;movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long&quot; %}
 4915   ins_encode %{
 4916     __ movzbq($dst$$Register, $mem$$Address);
 4917   %}
 4918   ins_pipe(ialu_reg_mem);
 4919 %}
 4920 
 4921 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
 4922 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4923   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4924   effect(KILL cr);
 4925 
 4926   format %{ &quot;movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 4927             &quot;andl    $dst, right_n_bits($mask, 16)&quot; %}
 4928   ins_encode %{
 4929     Register Rdst = $dst$$Register;
 4930     __ movzwq(Rdst, $mem$$Address);
 4931     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 4932   %}
 4933   ins_pipe(ialu_reg_mem);
 4934 %}
 4935 
 4936 // Load Integer
 4937 instruct loadI(rRegI dst, memory mem)
 4938 %{
 4939   match(Set dst (LoadI mem));
 4940 
 4941   ins_cost(125);
 4942   format %{ &quot;movl    $dst, $mem\t# int&quot; %}
 4943 
 4944   ins_encode %{
 4945     __ movl($dst$$Register, $mem$$Address);
 4946   %}
 4947 
 4948   ins_pipe(ialu_reg_mem);
 4949 %}
 4950 
 4951 // Load Integer (32 bit signed) to Byte (8 bit signed)
 4952 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4953   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 4954 
 4955   ins_cost(125);
 4956   format %{ &quot;movsbl  $dst, $mem\t# int -&gt; byte&quot; %}
 4957   ins_encode %{
 4958     __ movsbl($dst$$Register, $mem$$Address);
 4959   %}
 4960   ins_pipe(ialu_reg_mem);
 4961 %}
 4962 
 4963 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 4964 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 4965   match(Set dst (AndI (LoadI mem) mask));
 4966 
 4967   ins_cost(125);
 4968   format %{ &quot;movzbl  $dst, $mem\t# int -&gt; ubyte&quot; %}
 4969   ins_encode %{
 4970     __ movzbl($dst$$Register, $mem$$Address);
 4971   %}
 4972   ins_pipe(ialu_reg_mem);
 4973 %}
 4974 
 4975 // Load Integer (32 bit signed) to Short (16 bit signed)
 4976 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 4977   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 4978 
 4979   ins_cost(125);
 4980   format %{ &quot;movswl  $dst, $mem\t# int -&gt; short&quot; %}
 4981   ins_encode %{
 4982     __ movswl($dst$$Register, $mem$$Address);
 4983   %}
 4984   ins_pipe(ialu_reg_mem);
 4985 %}
 4986 
 4987 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 4988 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 4989   match(Set dst (AndI (LoadI mem) mask));
 4990 
 4991   ins_cost(125);
 4992   format %{ &quot;movzwl  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 4993   ins_encode %{
 4994     __ movzwl($dst$$Register, $mem$$Address);
 4995   %}
 4996   ins_pipe(ialu_reg_mem);
 4997 %}
 4998 
 4999 // Load Integer into Long Register
 5000 instruct loadI2L(rRegL dst, memory mem)
 5001 %{
 5002   match(Set dst (ConvI2L (LoadI mem)));
 5003 
 5004   ins_cost(125);
 5005   format %{ &quot;movslq  $dst, $mem\t# int -&gt; long&quot; %}
 5006 
 5007   ins_encode %{
 5008     __ movslq($dst$$Register, $mem$$Address);
 5009   %}
 5010 
 5011   ins_pipe(ialu_reg_mem);
 5012 %}
 5013 
 5014 // Load Integer with mask 0xFF into Long Register
 5015 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5016   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5017 
 5018   format %{ &quot;movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long&quot; %}
 5019   ins_encode %{
 5020     __ movzbq($dst$$Register, $mem$$Address);
 5021   %}
 5022   ins_pipe(ialu_reg_mem);
 5023 %}
 5024 
 5025 // Load Integer with mask 0xFFFF into Long Register
 5026 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
 5027   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5028 
 5029   format %{ &quot;movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long&quot; %}
 5030   ins_encode %{
 5031     __ movzwq($dst$$Register, $mem$$Address);
 5032   %}
 5033   ins_pipe(ialu_reg_mem);
 5034 %}
 5035 
 5036 // Load Integer with a 31-bit mask into Long Register
 5037 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
 5038   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5039   effect(KILL cr);
 5040 
 5041   format %{ &quot;movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5042             &quot;andl    $dst, $mask&quot; %}
 5043   ins_encode %{
 5044     Register Rdst = $dst$$Register;
 5045     __ movl(Rdst, $mem$$Address);
 5046     __ andl(Rdst, $mask$$constant);
 5047   %}
 5048   ins_pipe(ialu_reg_mem);
 5049 %}
 5050 
 5051 // Load Unsigned Integer into Long Register
 5052 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
 5053 %{
 5054   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5055 
 5056   ins_cost(125);
 5057   format %{ &quot;movl    $dst, $mem\t# uint -&gt; long&quot; %}
 5058 
 5059   ins_encode %{
 5060     __ movl($dst$$Register, $mem$$Address);
 5061   %}
 5062 
 5063   ins_pipe(ialu_reg_mem);
 5064 %}
 5065 
 5066 // Load Long
 5067 instruct loadL(rRegL dst, memory mem)
 5068 %{
 5069   match(Set dst (LoadL mem));
 5070 
 5071   ins_cost(125);
 5072   format %{ &quot;movq    $dst, $mem\t# long&quot; %}
 5073 
 5074   ins_encode %{
 5075     __ movq($dst$$Register, $mem$$Address);
 5076   %}
 5077 
 5078   ins_pipe(ialu_reg_mem); // XXX
 5079 %}
 5080 
 5081 // Load Range
 5082 instruct loadRange(rRegI dst, memory mem)
 5083 %{
 5084   match(Set dst (LoadRange mem));
 5085 
 5086   ins_cost(125); // XXX
 5087   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5088   opcode(0x8B);
 5089   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5090   ins_pipe(ialu_reg_mem);
 5091 %}
 5092 
 5093 // Load Pointer
 5094 instruct loadP(rRegP dst, memory mem)
 5095 %{
 5096   match(Set dst (LoadP mem));
 5097   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);
 5098 
 5099   ins_cost(125); // XXX
 5100   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5101   opcode(0x8B);
 5102   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5103   ins_pipe(ialu_reg_mem); // XXX
 5104 %}
 5105 
 5106 // Load Compressed Pointer
 5107 instruct loadN(rRegN dst, memory mem)
 5108 %{
 5109    match(Set dst (LoadN mem));
 5110 
 5111    ins_cost(125); // XXX
 5112    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5113    ins_encode %{
 5114      __ movl($dst$$Register, $mem$$Address);
 5115    %}
 5116    ins_pipe(ialu_reg_mem); // XXX
 5117 %}
 5118 
 5119 
 5120 // Load Klass Pointer
 5121 instruct loadKlass(rRegP dst, memory mem)
 5122 %{
 5123   match(Set dst (LoadKlass mem));
 5124 
 5125   ins_cost(125); // XXX
 5126   format %{ &quot;movq    $dst, $mem\t# class&quot; %}
 5127   opcode(0x8B);
 5128   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5129   ins_pipe(ialu_reg_mem); // XXX
 5130 %}
 5131 
 5132 // Load narrow Klass Pointer
 5133 instruct loadNKlass(rRegN dst, memory mem)
 5134 %{
 5135   match(Set dst (LoadNKlass mem));
 5136 
 5137   ins_cost(125); // XXX
 5138   format %{ &quot;movl    $dst, $mem\t# compressed klass ptr&quot; %}
 5139   ins_encode %{
 5140     __ movl($dst$$Register, $mem$$Address);
 5141   %}
 5142   ins_pipe(ialu_reg_mem); // XXX
 5143 %}
 5144 
 5145 // Load Float
 5146 instruct loadF(regF dst, memory mem)
 5147 %{
 5148   match(Set dst (LoadF mem));
 5149 
 5150   ins_cost(145); // XXX
 5151   format %{ &quot;movss   $dst, $mem\t# float&quot; %}
 5152   ins_encode %{
 5153     __ movflt($dst$$XMMRegister, $mem$$Address);
 5154   %}
 5155   ins_pipe(pipe_slow); // XXX
 5156 %}
 5157 
 5158 // Load Float
 5159 instruct MoveF2VL(vlRegF dst, regF src) %{
 5160   match(Set dst src);
 5161   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5162   ins_encode %{
 5163     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5164   %}
 5165   ins_pipe( fpu_reg_reg );
 5166 %}
 5167 
 5168 // Load Float
 5169 instruct MoveF2LEG(legRegF dst, regF src) %{
 5170   match(Set dst src);
 5171   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5172   ins_encode %{
 5173     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5174   %}
 5175   ins_pipe( fpu_reg_reg );
 5176 %}
 5177 
 5178 // Load Float
 5179 instruct MoveVL2F(regF dst, vlRegF src) %{
 5180   match(Set dst src);
 5181   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5182   ins_encode %{
 5183     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5184   %}
 5185   ins_pipe( fpu_reg_reg );
 5186 %}
 5187 
 5188 // Load Float
 5189 instruct MoveLEG2F(regF dst, legRegF src) %{
 5190   match(Set dst src);
 5191   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5192   ins_encode %{
 5193     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5194   %}
 5195   ins_pipe( fpu_reg_reg );
 5196 %}
 5197 
 5198 // Load Double
 5199 instruct loadD_partial(regD dst, memory mem)
 5200 %{
 5201   predicate(!UseXmmLoadAndClearUpper);
 5202   match(Set dst (LoadD mem));
 5203 
 5204   ins_cost(145); // XXX
 5205   format %{ &quot;movlpd  $dst, $mem\t# double&quot; %}
 5206   ins_encode %{
 5207     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5208   %}
 5209   ins_pipe(pipe_slow); // XXX
 5210 %}
 5211 
 5212 instruct loadD(regD dst, memory mem)
 5213 %{
 5214   predicate(UseXmmLoadAndClearUpper);
 5215   match(Set dst (LoadD mem));
 5216 
 5217   ins_cost(145); // XXX
 5218   format %{ &quot;movsd   $dst, $mem\t# double&quot; %}
 5219   ins_encode %{
 5220     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5221   %}
 5222   ins_pipe(pipe_slow); // XXX
 5223 %}
 5224 
 5225 // Load Double
 5226 instruct MoveD2VL(vlRegD dst, regD src) %{
 5227   match(Set dst src);
 5228   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5229   ins_encode %{
 5230     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5231   %}
 5232   ins_pipe( fpu_reg_reg );
 5233 %}
 5234 
 5235 // Load Double
 5236 instruct MoveD2LEG(legRegD dst, regD src) %{
 5237   match(Set dst src);
 5238   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5239   ins_encode %{
 5240     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5241   %}
 5242   ins_pipe( fpu_reg_reg );
 5243 %}
 5244 
 5245 // Load Double
 5246 instruct MoveVL2D(regD dst, vlRegD src) %{
 5247   match(Set dst src);
 5248   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5249   ins_encode %{
 5250     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5251   %}
 5252   ins_pipe( fpu_reg_reg );
 5253 %}
 5254 
 5255 // Load Double
 5256 instruct MoveLEG2D(regD dst, legRegD src) %{
 5257   match(Set dst src);
 5258   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5259   ins_encode %{
 5260     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5261   %}
 5262   ins_pipe( fpu_reg_reg );
 5263 %}
 5264 
 5265 // Following pseudo code describes the algorithm for max[FD]:
 5266 // Min algorithm is on similar lines
 5267 //  btmp = (b &lt; +0.0) ? a : b
 5268 //  atmp = (b &lt; +0.0) ? b : a
 5269 //  Tmp  = Max_Float(atmp , btmp)
 5270 //  Res  = (atmp == NaN) ? atmp : Tmp
 5271 
 5272 // max = java.lang.Math.max(float a, float b)
 5273 instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5274   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5275   match(Set dst (MaxF a b));
 5276   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5277   format %{
 5278      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5279      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5280      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5281      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5282      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5283   %}
 5284   ins_encode %{
 5285     int vector_len = Assembler::AVX_128bit;
 5286     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5287     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5288     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5289     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5290     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5291  %}
 5292   ins_pipe( pipe_slow );
 5293 %}
 5294 
 5295 instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5296   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5297   match(Set dst (MaxF a b));
 5298   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5299 
 5300   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5301   ins_encode %{
 5302     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5303                     false /*min*/, true /*single*/);
 5304   %}
 5305   ins_pipe( pipe_slow );
 5306 %}
 5307 
 5308 // max = java.lang.Math.max(double a, double b)
 5309 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5310   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5311   match(Set dst (MaxD a b));
 5312   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5313   format %{
 5314      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5315      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5316      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5317      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5318      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5319   %}
 5320   ins_encode %{
 5321     int vector_len = Assembler::AVX_128bit;
 5322     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5323     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5324     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5325     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5326     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5327   %}
 5328   ins_pipe( pipe_slow );
 5329 %}
 5330 
 5331 instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5332   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5333   match(Set dst (MaxD a b));
 5334   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5335 
 5336   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5337   ins_encode %{
 5338     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5339                     false /*min*/, false /*single*/);
 5340   %}
 5341   ins_pipe( pipe_slow );
 5342 %}
 5343 
 5344 // min = java.lang.Math.min(float a, float b)
 5345 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5346   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5347   match(Set dst (MinF a b));
 5348   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5349   format %{
 5350      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5351      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5352      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5353      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5354      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5355   %}
 5356   ins_encode %{
 5357     int vector_len = Assembler::AVX_128bit;
 5358     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5359     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5360     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5361     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5362     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5363   %}
 5364   ins_pipe( pipe_slow );
 5365 %}
 5366 
 5367 instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5368   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5369   match(Set dst (MinF a b));
 5370   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5371 
 5372   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5373   ins_encode %{
 5374     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5375                     true /*min*/, true /*single*/);
 5376   %}
 5377   ins_pipe( pipe_slow );
 5378 %}
 5379 
 5380 // min = java.lang.Math.min(double a, double b)
 5381 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5382   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5383   match(Set dst (MinD a b));
 5384   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5385   format %{
 5386      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5387      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5388      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5389      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5390      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5391   %}
 5392   ins_encode %{
 5393     int vector_len = Assembler::AVX_128bit;
 5394     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5395     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5396     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5397     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5398     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5399   %}
 5400   ins_pipe( pipe_slow );
 5401 %}
 5402 
 5403 instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5404   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5405   match(Set dst (MinD a b));
 5406   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5407 
 5408   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5409   ins_encode %{
 5410     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5411                     true /*min*/, false /*single*/);
 5412   %}
 5413   ins_pipe( pipe_slow );
 5414 %}
 5415 
 5416 // Load Effective Address
 5417 instruct leaP8(rRegP dst, indOffset8 mem)
 5418 %{
 5419   match(Set dst mem);
 5420 
 5421   ins_cost(110); // XXX
 5422   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5423   opcode(0x8D);
 5424   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5425   ins_pipe(ialu_reg_reg_fat);
 5426 %}
 5427 
 5428 instruct leaP32(rRegP dst, indOffset32 mem)
 5429 %{
 5430   match(Set dst mem);
 5431 
 5432   ins_cost(110);
 5433   format %{ &quot;leaq    $dst, $mem\t# ptr 32&quot; %}
 5434   opcode(0x8D);
 5435   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5436   ins_pipe(ialu_reg_reg_fat);
 5437 %}
 5438 
 5439 // instruct leaPIdx(rRegP dst, indIndex mem)
 5440 // %{
 5441 //   match(Set dst mem);
 5442 
 5443 //   ins_cost(110);
 5444 //   format %{ &quot;leaq    $dst, $mem\t# ptr idx&quot; %}
 5445 //   opcode(0x8D);
 5446 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5447 //   ins_pipe(ialu_reg_reg_fat);
 5448 // %}
 5449 
 5450 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
 5451 %{
 5452   match(Set dst mem);
 5453 
 5454   ins_cost(110);
 5455   format %{ &quot;leaq    $dst, $mem\t# ptr idxoff&quot; %}
 5456   opcode(0x8D);
 5457   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5458   ins_pipe(ialu_reg_reg_fat);
 5459 %}
 5460 
 5461 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
 5462 %{
 5463   match(Set dst mem);
 5464 
 5465   ins_cost(110);
 5466   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5467   opcode(0x8D);
 5468   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5469   ins_pipe(ialu_reg_reg_fat);
 5470 %}
 5471 
 5472 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
 5473 %{
 5474   match(Set dst mem);
 5475 
 5476   ins_cost(110);
 5477   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5478   opcode(0x8D);
 5479   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5480   ins_pipe(ialu_reg_reg_fat);
 5481 %}
 5482 
 5483 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
 5484 %{
 5485   match(Set dst mem);
 5486 
 5487   ins_cost(110);
 5488   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoff&quot; %}
 5489   opcode(0x8D);
 5490   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5491   ins_pipe(ialu_reg_reg_fat);
 5492 %}
 5493 
 5494 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
 5495 %{
 5496   match(Set dst mem);
 5497 
 5498   ins_cost(110);
 5499   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5500   opcode(0x8D);
 5501   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5502   ins_pipe(ialu_reg_reg_fat);
 5503 %}
 5504 
 5505 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5506 %{
 5507   match(Set dst mem);
 5508 
 5509   ins_cost(110);
 5510   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5511   opcode(0x8D);
 5512   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5513   ins_pipe(ialu_reg_reg_fat);
 5514 %}
 5515 
 5516 // Load Effective Address which uses Narrow (32-bits) oop
 5517 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5518 %{
 5519   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));
 5520   match(Set dst mem);
 5521 
 5522   ins_cost(110);
 5523   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5524   opcode(0x8D);
 5525   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5526   ins_pipe(ialu_reg_reg_fat);
 5527 %}
 5528 
 5529 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5530 %{
 5531   predicate(CompressedOops::shift() == 0);
 5532   match(Set dst mem);
 5533 
 5534   ins_cost(110); // XXX
 5535   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5536   opcode(0x8D);
 5537   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5538   ins_pipe(ialu_reg_reg_fat);
 5539 %}
 5540 
 5541 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5542 %{
 5543   predicate(CompressedOops::shift() == 0);
 5544   match(Set dst mem);
 5545 
 5546   ins_cost(110);
 5547   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5548   opcode(0x8D);
 5549   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5550   ins_pipe(ialu_reg_reg_fat);
 5551 %}
 5552 
 5553 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5554 %{
 5555   predicate(CompressedOops::shift() == 0);
 5556   match(Set dst mem);
 5557 
 5558   ins_cost(110);
 5559   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5560   opcode(0x8D);
 5561   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5562   ins_pipe(ialu_reg_reg_fat);
 5563 %}
 5564 
 5565 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5566 %{
 5567   predicate(CompressedOops::shift() == 0);
 5568   match(Set dst mem);
 5569 
 5570   ins_cost(110);
 5571   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5572   opcode(0x8D);
 5573   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5574   ins_pipe(ialu_reg_reg_fat);
 5575 %}
 5576 
 5577 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5578 %{
 5579   predicate(CompressedOops::shift() == 0);
 5580   match(Set dst mem);
 5581 
 5582   ins_cost(110);
 5583   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5584   opcode(0x8D);
 5585   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5586   ins_pipe(ialu_reg_reg_fat);
 5587 %}
 5588 
 5589 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5590 %{
 5591   predicate(CompressedOops::shift() == 0);
 5592   match(Set dst mem);
 5593 
 5594   ins_cost(110);
 5595   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5596   opcode(0x8D);
 5597   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5598   ins_pipe(ialu_reg_reg_fat);
 5599 %}
 5600 
 5601 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5602 %{
 5603   predicate(CompressedOops::shift() == 0);
 5604   match(Set dst mem);
 5605 
 5606   ins_cost(110);
 5607   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5608   opcode(0x8D);
 5609   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5610   ins_pipe(ialu_reg_reg_fat);
 5611 %}
 5612 
 5613 instruct loadConI(rRegI dst, immI src)
 5614 %{
 5615   match(Set dst src);
 5616 
 5617   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5618   ins_encode(load_immI(dst, src));
 5619   ins_pipe(ialu_reg_fat); // XXX
 5620 %}
 5621 
 5622 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5623 %{
 5624   match(Set dst src);
 5625   effect(KILL cr);
 5626 
 5627   ins_cost(50);
 5628   format %{ &quot;xorl    $dst, $dst\t# int&quot; %}
 5629   opcode(0x33); /* + rd */
 5630   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5631   ins_pipe(ialu_reg);
 5632 %}
 5633 
 5634 instruct loadConL(rRegL dst, immL src)
 5635 %{
 5636   match(Set dst src);
 5637 
 5638   ins_cost(150);
 5639   format %{ &quot;movq    $dst, $src\t# long&quot; %}
 5640   ins_encode(load_immL(dst, src));
 5641   ins_pipe(ialu_reg);
 5642 %}
 5643 
 5644 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
 5645 %{
 5646   match(Set dst src);
 5647   effect(KILL cr);
 5648 
 5649   ins_cost(50);
 5650   format %{ &quot;xorl    $dst, $dst\t# long&quot; %}
 5651   opcode(0x33); /* + rd */
 5652   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5653   ins_pipe(ialu_reg); // XXX
 5654 %}
 5655 
 5656 instruct loadConUL32(rRegL dst, immUL32 src)
 5657 %{
 5658   match(Set dst src);
 5659 
 5660   ins_cost(60);
 5661   format %{ &quot;movl    $dst, $src\t# long (unsigned 32-bit)&quot; %}
 5662   ins_encode(load_immUL32(dst, src));
 5663   ins_pipe(ialu_reg);
 5664 %}
 5665 
 5666 instruct loadConL32(rRegL dst, immL32 src)
 5667 %{
 5668   match(Set dst src);
 5669 
 5670   ins_cost(70);
 5671   format %{ &quot;movq    $dst, $src\t# long (32-bit)&quot; %}
 5672   ins_encode(load_immL32(dst, src));
 5673   ins_pipe(ialu_reg);
 5674 %}
 5675 
 5676 instruct loadConP(rRegP dst, immP con) %{
 5677   match(Set dst con);
 5678 
 5679   format %{ &quot;movq    $dst, $con\t# ptr&quot; %}
 5680   ins_encode(load_immP(dst, con));
 5681   ins_pipe(ialu_reg_fat); // XXX
 5682 %}
 5683 
 5684 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
 5685 %{
 5686   match(Set dst src);
 5687   effect(KILL cr);
 5688 
 5689   ins_cost(50);
 5690   format %{ &quot;xorl    $dst, $dst\t# ptr&quot; %}
 5691   opcode(0x33); /* + rd */
 5692   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5693   ins_pipe(ialu_reg);
 5694 %}
 5695 
 5696 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
 5697 %{
 5698   match(Set dst src);
 5699   effect(KILL cr);
 5700 
 5701   ins_cost(60);
 5702   format %{ &quot;movl    $dst, $src\t# ptr (positive 32-bit)&quot; %}
 5703   ins_encode(load_immP31(dst, src));
 5704   ins_pipe(ialu_reg);
 5705 %}
 5706 
 5707 instruct loadConF(regF dst, immF con) %{
 5708   match(Set dst con);
 5709   ins_cost(125);
 5710   format %{ &quot;movss   $dst, [$constantaddress]\t# load from constant table: float=$con&quot; %}
 5711   ins_encode %{
 5712     __ movflt($dst$$XMMRegister, $constantaddress($con));
 5713   %}
 5714   ins_pipe(pipe_slow);
 5715 %}
 5716 
 5717 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
 5718   match(Set dst src);
 5719   effect(KILL cr);
 5720   format %{ &quot;xorq    $dst, $src\t# compressed NULL ptr&quot; %}
 5721   ins_encode %{
 5722     __ xorq($dst$$Register, $dst$$Register);
 5723   %}
 5724   ins_pipe(ialu_reg);
 5725 %}
 5726 
 5727 instruct loadConN(rRegN dst, immN src) %{
 5728   match(Set dst src);
 5729 
 5730   ins_cost(125);
 5731   format %{ &quot;movl    $dst, $src\t# compressed ptr&quot; %}
 5732   ins_encode %{
 5733     address con = (address)$src$$constant;
 5734     if (con == NULL) {
 5735       ShouldNotReachHere();
 5736     } else {
 5737       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
 5738     }
 5739   %}
 5740   ins_pipe(ialu_reg_fat); // XXX
 5741 %}
 5742 
 5743 instruct loadConNKlass(rRegN dst, immNKlass src) %{
 5744   match(Set dst src);
 5745 
 5746   ins_cost(125);
 5747   format %{ &quot;movl    $dst, $src\t# compressed klass ptr&quot; %}
 5748   ins_encode %{
 5749     address con = (address)$src$$constant;
 5750     if (con == NULL) {
 5751       ShouldNotReachHere();
 5752     } else {
 5753       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
 5754     }
 5755   %}
 5756   ins_pipe(ialu_reg_fat); // XXX
 5757 %}
 5758 
 5759 instruct loadConF0(regF dst, immF0 src)
 5760 %{
 5761   match(Set dst src);
 5762   ins_cost(100);
 5763 
 5764   format %{ &quot;xorps   $dst, $dst\t# float 0.0&quot; %}
 5765   ins_encode %{
 5766     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 5767   %}
 5768   ins_pipe(pipe_slow);
 5769 %}
 5770 
 5771 // Use the same format since predicate() can not be used here.
 5772 instruct loadConD(regD dst, immD con) %{
 5773   match(Set dst con);
 5774   ins_cost(125);
 5775   format %{ &quot;movsd   $dst, [$constantaddress]\t# load from constant table: double=$con&quot; %}
 5776   ins_encode %{
 5777     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 5778   %}
 5779   ins_pipe(pipe_slow);
 5780 %}
 5781 
 5782 instruct loadConD0(regD dst, immD0 src)
 5783 %{
 5784   match(Set dst src);
 5785   ins_cost(100);
 5786 
 5787   format %{ &quot;xorpd   $dst, $dst\t# double 0.0&quot; %}
 5788   ins_encode %{
 5789     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 5790   %}
 5791   ins_pipe(pipe_slow);
 5792 %}
 5793 
 5794 instruct loadSSI(rRegI dst, stackSlotI src)
 5795 %{
 5796   match(Set dst src);
 5797 
 5798   ins_cost(125);
 5799   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 5800   opcode(0x8B);
 5801   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 5802   ins_pipe(ialu_reg_mem);
 5803 %}
 5804 
 5805 instruct loadSSL(rRegL dst, stackSlotL src)
 5806 %{
 5807   match(Set dst src);
 5808 
 5809   ins_cost(125);
 5810   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 5811   opcode(0x8B);
 5812   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5813   ins_pipe(ialu_reg_mem);
 5814 %}
 5815 
 5816 instruct loadSSP(rRegP dst, stackSlotP src)
 5817 %{
 5818   match(Set dst src);
 5819 
 5820   ins_cost(125);
 5821   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 5822   opcode(0x8B);
 5823   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5824   ins_pipe(ialu_reg_mem);
 5825 %}
 5826 
 5827 instruct loadSSF(regF dst, stackSlotF src)
 5828 %{
 5829   match(Set dst src);
 5830 
 5831   ins_cost(125);
 5832   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 5833   ins_encode %{
 5834     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
 5835   %}
 5836   ins_pipe(pipe_slow); // XXX
 5837 %}
 5838 
 5839 // Use the same format since predicate() can not be used here.
 5840 instruct loadSSD(regD dst, stackSlotD src)
 5841 %{
 5842   match(Set dst src);
 5843 
 5844   ins_cost(125);
 5845   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 5846   ins_encode  %{
 5847     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
 5848   %}
 5849   ins_pipe(pipe_slow); // XXX
 5850 %}
 5851 
 5852 // Prefetch instructions for allocation.
 5853 // Must be safe to execute with invalid address (cannot fault).
 5854 
 5855 instruct prefetchAlloc( memory mem ) %{
 5856   predicate(AllocatePrefetchInstr==3);
 5857   match(PrefetchAllocation mem);
 5858   ins_cost(125);
 5859 
 5860   format %{ &quot;PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified&quot; %}
 5861   ins_encode %{
 5862     __ prefetchw($mem$$Address);
 5863   %}
 5864   ins_pipe(ialu_mem);
 5865 %}
 5866 
 5867 instruct prefetchAllocNTA( memory mem ) %{
 5868   predicate(AllocatePrefetchInstr==0);
 5869   match(PrefetchAllocation mem);
 5870   ins_cost(125);
 5871 
 5872   format %{ &quot;PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write&quot; %}
 5873   ins_encode %{
 5874     __ prefetchnta($mem$$Address);
 5875   %}
 5876   ins_pipe(ialu_mem);
 5877 %}
 5878 
 5879 instruct prefetchAllocT0( memory mem ) %{
 5880   predicate(AllocatePrefetchInstr==1);
 5881   match(PrefetchAllocation mem);
 5882   ins_cost(125);
 5883 
 5884   format %{ &quot;PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write&quot; %}
 5885   ins_encode %{
 5886     __ prefetcht0($mem$$Address);
 5887   %}
 5888   ins_pipe(ialu_mem);
 5889 %}
 5890 
 5891 instruct prefetchAllocT2( memory mem ) %{
 5892   predicate(AllocatePrefetchInstr==2);
 5893   match(PrefetchAllocation mem);
 5894   ins_cost(125);
 5895 
 5896   format %{ &quot;PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write&quot; %}
 5897   ins_encode %{
 5898     __ prefetcht2($mem$$Address);
 5899   %}
 5900   ins_pipe(ialu_mem);
 5901 %}
 5902 
 5903 //----------Store Instructions-------------------------------------------------
 5904 
 5905 // Store Byte
 5906 instruct storeB(memory mem, rRegI src)
 5907 %{
 5908   match(Set mem (StoreB mem src));
 5909 
 5910   ins_cost(125); // XXX
 5911   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 5912   opcode(0x88);
 5913   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
 5914   ins_pipe(ialu_mem_reg);
 5915 %}
 5916 
 5917 // Store Char/Short
 5918 instruct storeC(memory mem, rRegI src)
 5919 %{
 5920   match(Set mem (StoreC mem src));
 5921 
 5922   ins_cost(125); // XXX
 5923   format %{ &quot;movw    $mem, $src\t# char/short&quot; %}
 5924   opcode(0x89);
 5925   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5926   ins_pipe(ialu_mem_reg);
 5927 %}
 5928 
 5929 // Store Integer
 5930 instruct storeI(memory mem, rRegI src)
 5931 %{
 5932   match(Set mem (StoreI mem src));
 5933 
 5934   ins_cost(125); // XXX
 5935   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 5936   opcode(0x89);
 5937   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5938   ins_pipe(ialu_mem_reg);
 5939 %}
 5940 
 5941 // Store Long
 5942 instruct storeL(memory mem, rRegL src)
 5943 %{
 5944   match(Set mem (StoreL mem src));
 5945 
 5946   ins_cost(125); // XXX
 5947   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5948   opcode(0x89);
 5949   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5950   ins_pipe(ialu_mem_reg); // XXX
 5951 %}
 5952 
 5953 // Store Pointer
 5954 instruct storeP(memory mem, any_RegP src)
 5955 %{
 5956   match(Set mem (StoreP mem src));
 5957 
 5958   ins_cost(125); // XXX
 5959   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5960   opcode(0x89);
 5961   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5962   ins_pipe(ialu_mem_reg);
 5963 %}
 5964 
 5965 instruct storeImmP0(memory mem, immP0 zero)
 5966 %{
 5967   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 5968   match(Set mem (StoreP mem zero));
 5969 
 5970   ins_cost(125); // XXX
 5971   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5972   ins_encode %{
 5973     __ movq($mem$$Address, r12);
 5974   %}
 5975   ins_pipe(ialu_mem_reg);
 5976 %}
 5977 
 5978 // Store NULL Pointer, mark word, or other simple pointer constant.
 5979 instruct storeImmP(memory mem, immP31 src)
 5980 %{
 5981   match(Set mem (StoreP mem src));
 5982 
 5983   ins_cost(150); // XXX
 5984   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5985   opcode(0xC7); /* C7 /0 */
 5986   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 5987   ins_pipe(ialu_mem_imm);
 5988 %}
 5989 
 5990 // Store Compressed Pointer
 5991 instruct storeN(memory mem, rRegN src)
 5992 %{
 5993   match(Set mem (StoreN mem src));
 5994 
 5995   ins_cost(125); // XXX
 5996   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 5997   ins_encode %{
 5998     __ movl($mem$$Address, $src$$Register);
 5999   %}
 6000   ins_pipe(ialu_mem_reg);
 6001 %}
 6002 
 6003 instruct storeNKlass(memory mem, rRegN src)
 6004 %{
 6005   match(Set mem (StoreNKlass mem src));
 6006 
 6007   ins_cost(125); // XXX
 6008   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6009   ins_encode %{
 6010     __ movl($mem$$Address, $src$$Register);
 6011   %}
 6012   ins_pipe(ialu_mem_reg);
 6013 %}
 6014 
 6015 instruct storeImmN0(memory mem, immN0 zero)
 6016 %{
 6017   predicate(CompressedOops::base() == NULL);
 6018   match(Set mem (StoreN mem zero));
 6019 
 6020   ins_cost(125); // XXX
 6021   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6022   ins_encode %{
 6023     __ movl($mem$$Address, r12);
 6024   %}
 6025   ins_pipe(ialu_mem_reg);
 6026 %}
 6027 
 6028 instruct storeImmN(memory mem, immN src)
 6029 %{
 6030   match(Set mem (StoreN mem src));
 6031 
 6032   ins_cost(150); // XXX
 6033   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6034   ins_encode %{
 6035     address con = (address)$src$$constant;
 6036     if (con == NULL) {
 6037       __ movl($mem$$Address, (int32_t)0);
 6038     } else {
 6039       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
 6040     }
 6041   %}
 6042   ins_pipe(ialu_mem_imm);
 6043 %}
 6044 
 6045 instruct storeImmNKlass(memory mem, immNKlass src)
 6046 %{
 6047   match(Set mem (StoreNKlass mem src));
 6048 
 6049   ins_cost(150); // XXX
 6050   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6051   ins_encode %{
 6052     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6053   %}
 6054   ins_pipe(ialu_mem_imm);
 6055 %}
 6056 
 6057 // Store Integer Immediate
 6058 instruct storeImmI0(memory mem, immI0 zero)
 6059 %{
 6060   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6061   match(Set mem (StoreI mem zero));
 6062 
 6063   ins_cost(125); // XXX
 6064   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6065   ins_encode %{
 6066     __ movl($mem$$Address, r12);
 6067   %}
 6068   ins_pipe(ialu_mem_reg);
 6069 %}
 6070 
 6071 instruct storeImmI(memory mem, immI src)
 6072 %{
 6073   match(Set mem (StoreI mem src));
 6074 
 6075   ins_cost(150);
 6076   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6077   opcode(0xC7); /* C7 /0 */
 6078   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6079   ins_pipe(ialu_mem_imm);
 6080 %}
 6081 
 6082 // Store Long Immediate
 6083 instruct storeImmL0(memory mem, immL0 zero)
 6084 %{
 6085   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6086   match(Set mem (StoreL mem zero));
 6087 
 6088   ins_cost(125); // XXX
 6089   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6090   ins_encode %{
 6091     __ movq($mem$$Address, r12);
 6092   %}
 6093   ins_pipe(ialu_mem_reg);
 6094 %}
 6095 
 6096 instruct storeImmL(memory mem, immL32 src)
 6097 %{
 6098   match(Set mem (StoreL mem src));
 6099 
 6100   ins_cost(150);
 6101   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6102   opcode(0xC7); /* C7 /0 */
 6103   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6104   ins_pipe(ialu_mem_imm);
 6105 %}
 6106 
 6107 // Store Short/Char Immediate
 6108 instruct storeImmC0(memory mem, immI0 zero)
 6109 %{
 6110   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6111   match(Set mem (StoreC mem zero));
 6112 
 6113   ins_cost(125); // XXX
 6114   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6115   ins_encode %{
 6116     __ movw($mem$$Address, r12);
 6117   %}
 6118   ins_pipe(ialu_mem_reg);
 6119 %}
 6120 
 6121 instruct storeImmI16(memory mem, immI16 src)
 6122 %{
 6123   predicate(UseStoreImmI16);
 6124   match(Set mem (StoreC mem src));
 6125 
 6126   ins_cost(150);
 6127   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6128   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6129   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6130   ins_pipe(ialu_mem_imm);
 6131 %}
 6132 
 6133 // Store Byte Immediate
 6134 instruct storeImmB0(memory mem, immI0 zero)
 6135 %{
 6136   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6137   match(Set mem (StoreB mem zero));
 6138 
 6139   ins_cost(125); // XXX
 6140   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6141   ins_encode %{
 6142     __ movb($mem$$Address, r12);
 6143   %}
 6144   ins_pipe(ialu_mem_reg);
 6145 %}
 6146 
 6147 instruct storeImmB(memory mem, immI8 src)
 6148 %{
 6149   match(Set mem (StoreB mem src));
 6150 
 6151   ins_cost(150); // XXX
 6152   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6153   opcode(0xC6); /* C6 /0 */
 6154   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6155   ins_pipe(ialu_mem_imm);
 6156 %}
 6157 
 6158 // Store CMS card-mark Immediate
 6159 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6160 %{
 6161   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6162   match(Set mem (StoreCM mem zero));
 6163 
 6164   ins_cost(125); // XXX
 6165   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6166   ins_encode %{
 6167     __ movb($mem$$Address, r12);
 6168   %}
 6169   ins_pipe(ialu_mem_reg);
 6170 %}
 6171 
 6172 instruct storeImmCM0(memory mem, immI0 src)
 6173 %{
 6174   match(Set mem (StoreCM mem src));
 6175 
 6176   ins_cost(150); // XXX
 6177   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6178   opcode(0xC6); /* C6 /0 */
 6179   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6180   ins_pipe(ialu_mem_imm);
 6181 %}
 6182 
 6183 // Store Float
 6184 instruct storeF(memory mem, regF src)
 6185 %{
 6186   match(Set mem (StoreF mem src));
 6187 
 6188   ins_cost(95); // XXX
 6189   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6190   ins_encode %{
 6191     __ movflt($mem$$Address, $src$$XMMRegister);
 6192   %}
 6193   ins_pipe(pipe_slow); // XXX
 6194 %}
 6195 
 6196 // Store immediate Float value (it is faster than store from XMM register)
 6197 instruct storeF0(memory mem, immF0 zero)
 6198 %{
 6199   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6200   match(Set mem (StoreF mem zero));
 6201 
 6202   ins_cost(25); // XXX
 6203   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6204   ins_encode %{
 6205     __ movl($mem$$Address, r12);
 6206   %}
 6207   ins_pipe(ialu_mem_reg);
 6208 %}
 6209 
 6210 instruct storeF_imm(memory mem, immF src)
 6211 %{
 6212   match(Set mem (StoreF mem src));
 6213 
 6214   ins_cost(50);
 6215   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6216   opcode(0xC7); /* C7 /0 */
 6217   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6218   ins_pipe(ialu_mem_imm);
 6219 %}
 6220 
 6221 // Store Double
 6222 instruct storeD(memory mem, regD src)
 6223 %{
 6224   match(Set mem (StoreD mem src));
 6225 
 6226   ins_cost(95); // XXX
 6227   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6228   ins_encode %{
 6229     __ movdbl($mem$$Address, $src$$XMMRegister);
 6230   %}
 6231   ins_pipe(pipe_slow); // XXX
 6232 %}
 6233 
 6234 // Store immediate double 0.0 (it is faster than store from XMM register)
 6235 instruct storeD0_imm(memory mem, immD0 src)
 6236 %{
 6237   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6238   match(Set mem (StoreD mem src));
 6239 
 6240   ins_cost(50);
 6241   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6242   opcode(0xC7); /* C7 /0 */
 6243   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6244   ins_pipe(ialu_mem_imm);
 6245 %}
 6246 
 6247 instruct storeD0(memory mem, immD0 zero)
 6248 %{
 6249   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6250   match(Set mem (StoreD mem zero));
 6251 
 6252   ins_cost(25); // XXX
 6253   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6254   ins_encode %{
 6255     __ movq($mem$$Address, r12);
 6256   %}
 6257   ins_pipe(ialu_mem_reg);
 6258 %}
 6259 
 6260 instruct storeSSI(stackSlotI dst, rRegI src)
 6261 %{
 6262   match(Set dst src);
 6263 
 6264   ins_cost(100);
 6265   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6266   opcode(0x89);
 6267   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6268   ins_pipe( ialu_mem_reg );
 6269 %}
 6270 
 6271 instruct storeSSL(stackSlotL dst, rRegL src)
 6272 %{
 6273   match(Set dst src);
 6274 
 6275   ins_cost(100);
 6276   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6277   opcode(0x89);
 6278   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6279   ins_pipe(ialu_mem_reg);
 6280 %}
 6281 
 6282 instruct storeSSP(stackSlotP dst, rRegP src)
 6283 %{
 6284   match(Set dst src);
 6285 
 6286   ins_cost(100);
 6287   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6288   opcode(0x89);
 6289   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6290   ins_pipe(ialu_mem_reg);
 6291 %}
 6292 
 6293 instruct storeSSF(stackSlotF dst, regF src)
 6294 %{
 6295   match(Set dst src);
 6296 
 6297   ins_cost(95); // XXX
 6298   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6299   ins_encode %{
 6300     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6301   %}
 6302   ins_pipe(pipe_slow); // XXX
 6303 %}
 6304 
 6305 instruct storeSSD(stackSlotD dst, regD src)
 6306 %{
 6307   match(Set dst src);
 6308 
 6309   ins_cost(95); // XXX
 6310   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6311   ins_encode %{
 6312     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6313   %}
 6314   ins_pipe(pipe_slow); // XXX
 6315 %}
 6316 
 6317 instruct cacheWB(indirect addr)
 6318 %{
 6319   predicate(VM_Version::supports_data_cache_line_flush());
 6320   match(CacheWB addr);
 6321 
 6322   ins_cost(100);
 6323   format %{&quot;cache wb $addr&quot; %}
 6324   ins_encode %{
 6325     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
 6326     assert($addr$$disp == 0, &quot;should be&quot;);
 6327     __ cache_wb(Address($addr$$base$$Register, 0));
 6328   %}
 6329   ins_pipe(pipe_slow); // XXX
 6330 %}
 6331 
 6332 instruct cacheWBPreSync()
 6333 %{
 6334   predicate(VM_Version::supports_data_cache_line_flush());
 6335   match(CacheWBPreSync);
 6336 
 6337   ins_cost(100);
 6338   format %{&quot;cache wb presync&quot; %}
 6339   ins_encode %{
 6340     __ cache_wbsync(true);
 6341   %}
 6342   ins_pipe(pipe_slow); // XXX
 6343 %}
 6344 
 6345 instruct cacheWBPostSync()
 6346 %{
 6347   predicate(VM_Version::supports_data_cache_line_flush());
 6348   match(CacheWBPostSync);
 6349 
 6350   ins_cost(100);
 6351   format %{&quot;cache wb postsync&quot; %}
 6352   ins_encode %{
 6353     __ cache_wbsync(false);
 6354   %}
 6355   ins_pipe(pipe_slow); // XXX
 6356 %}
 6357 
 6358 //----------BSWAP Instructions-------------------------------------------------
 6359 instruct bytes_reverse_int(rRegI dst) %{
 6360   match(Set dst (ReverseBytesI dst));
 6361 
 6362   format %{ &quot;bswapl  $dst&quot; %}
 6363   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6364   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6365   ins_pipe( ialu_reg );
 6366 %}
 6367 
 6368 instruct bytes_reverse_long(rRegL dst) %{
 6369   match(Set dst (ReverseBytesL dst));
 6370 
 6371   format %{ &quot;bswapq  $dst&quot; %}
 6372   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6373   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6374   ins_pipe( ialu_reg);
 6375 %}
 6376 
 6377 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
 6378   match(Set dst (ReverseBytesUS dst));
 6379   effect(KILL cr);
 6380 
 6381   format %{ &quot;bswapl  $dst\n\t&quot;
 6382             &quot;shrl    $dst,16\n\t&quot; %}
 6383   ins_encode %{
 6384     __ bswapl($dst$$Register);
 6385     __ shrl($dst$$Register, 16);
 6386   %}
 6387   ins_pipe( ialu_reg );
 6388 %}
 6389 
 6390 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
 6391   match(Set dst (ReverseBytesS dst));
 6392   effect(KILL cr);
 6393 
 6394   format %{ &quot;bswapl  $dst\n\t&quot;
 6395             &quot;sar     $dst,16\n\t&quot; %}
 6396   ins_encode %{
 6397     __ bswapl($dst$$Register);
 6398     __ sarl($dst$$Register, 16);
 6399   %}
 6400   ins_pipe( ialu_reg );
 6401 %}
 6402 
 6403 //---------- Zeros Count Instructions ------------------------------------------
 6404 
 6405 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6406   predicate(UseCountLeadingZerosInstruction);
 6407   match(Set dst (CountLeadingZerosI src));
 6408   effect(KILL cr);
 6409 
 6410   format %{ &quot;lzcntl  $dst, $src\t# count leading zeros (int)&quot; %}
 6411   ins_encode %{
 6412     __ lzcntl($dst$$Register, $src$$Register);
 6413   %}
 6414   ins_pipe(ialu_reg);
 6415 %}
 6416 
 6417 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
 6418   predicate(!UseCountLeadingZerosInstruction);
 6419   match(Set dst (CountLeadingZerosI src));
 6420   effect(KILL cr);
 6421 
 6422   format %{ &quot;bsrl    $dst, $src\t# count leading zeros (int)\n\t&quot;
 6423             &quot;jnz     skip\n\t&quot;
 6424             &quot;movl    $dst, -1\n&quot;
 6425       &quot;skip:\n\t&quot;
 6426             &quot;negl    $dst\n\t&quot;
 6427             &quot;addl    $dst, 31&quot; %}
 6428   ins_encode %{
 6429     Register Rdst = $dst$$Register;
 6430     Register Rsrc = $src$$Register;
 6431     Label skip;
 6432     __ bsrl(Rdst, Rsrc);
 6433     __ jccb(Assembler::notZero, skip);
 6434     __ movl(Rdst, -1);
 6435     __ bind(skip);
 6436     __ negl(Rdst);
 6437     __ addl(Rdst, BitsPerInt - 1);
 6438   %}
 6439   ins_pipe(ialu_reg);
 6440 %}
 6441 
 6442 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6443   predicate(UseCountLeadingZerosInstruction);
 6444   match(Set dst (CountLeadingZerosL src));
 6445   effect(KILL cr);
 6446 
 6447   format %{ &quot;lzcntq  $dst, $src\t# count leading zeros (long)&quot; %}
 6448   ins_encode %{
 6449     __ lzcntq($dst$$Register, $src$$Register);
 6450   %}
 6451   ins_pipe(ialu_reg);
 6452 %}
 6453 
 6454 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
 6455   predicate(!UseCountLeadingZerosInstruction);
 6456   match(Set dst (CountLeadingZerosL src));
 6457   effect(KILL cr);
 6458 
 6459   format %{ &quot;bsrq    $dst, $src\t# count leading zeros (long)\n\t&quot;
 6460             &quot;jnz     skip\n\t&quot;
 6461             &quot;movl    $dst, -1\n&quot;
 6462       &quot;skip:\n\t&quot;
 6463             &quot;negl    $dst\n\t&quot;
 6464             &quot;addl    $dst, 63&quot; %}
 6465   ins_encode %{
 6466     Register Rdst = $dst$$Register;
 6467     Register Rsrc = $src$$Register;
 6468     Label skip;
 6469     __ bsrq(Rdst, Rsrc);
 6470     __ jccb(Assembler::notZero, skip);
 6471     __ movl(Rdst, -1);
 6472     __ bind(skip);
 6473     __ negl(Rdst);
 6474     __ addl(Rdst, BitsPerLong - 1);
 6475   %}
 6476   ins_pipe(ialu_reg);
 6477 %}
 6478 
 6479 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6480   predicate(UseCountTrailingZerosInstruction);
 6481   match(Set dst (CountTrailingZerosI src));
 6482   effect(KILL cr);
 6483 
 6484   format %{ &quot;tzcntl    $dst, $src\t# count trailing zeros (int)&quot; %}
 6485   ins_encode %{
 6486     __ tzcntl($dst$$Register, $src$$Register);
 6487   %}
 6488   ins_pipe(ialu_reg);
 6489 %}
 6490 
 6491 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
 6492   predicate(!UseCountTrailingZerosInstruction);
 6493   match(Set dst (CountTrailingZerosI src));
 6494   effect(KILL cr);
 6495 
 6496   format %{ &quot;bsfl    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 6497             &quot;jnz     done\n\t&quot;
 6498             &quot;movl    $dst, 32\n&quot;
 6499       &quot;done:&quot; %}
 6500   ins_encode %{
 6501     Register Rdst = $dst$$Register;
 6502     Label done;
 6503     __ bsfl(Rdst, $src$$Register);
 6504     __ jccb(Assembler::notZero, done);
 6505     __ movl(Rdst, BitsPerInt);
 6506     __ bind(done);
 6507   %}
 6508   ins_pipe(ialu_reg);
 6509 %}
 6510 
 6511 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6512   predicate(UseCountTrailingZerosInstruction);
 6513   match(Set dst (CountTrailingZerosL src));
 6514   effect(KILL cr);
 6515 
 6516   format %{ &quot;tzcntq    $dst, $src\t# count trailing zeros (long)&quot; %}
 6517   ins_encode %{
 6518     __ tzcntq($dst$$Register, $src$$Register);
 6519   %}
 6520   ins_pipe(ialu_reg);
 6521 %}
 6522 
 6523 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
 6524   predicate(!UseCountTrailingZerosInstruction);
 6525   match(Set dst (CountTrailingZerosL src));
 6526   effect(KILL cr);
 6527 
 6528   format %{ &quot;bsfq    $dst, $src\t# count trailing zeros (long)\n\t&quot;
 6529             &quot;jnz     done\n\t&quot;
 6530             &quot;movl    $dst, 64\n&quot;
 6531       &quot;done:&quot; %}
 6532   ins_encode %{
 6533     Register Rdst = $dst$$Register;
 6534     Label done;
 6535     __ bsfq(Rdst, $src$$Register);
 6536     __ jccb(Assembler::notZero, done);
 6537     __ movl(Rdst, BitsPerLong);
 6538     __ bind(done);
 6539   %}
 6540   ins_pipe(ialu_reg);
 6541 %}
 6542 
 6543 
 6544 //---------- Population Count Instructions -------------------------------------
 6545 
 6546 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6547   predicate(UsePopCountInstruction);
 6548   match(Set dst (PopCountI src));
 6549   effect(KILL cr);
 6550 
 6551   format %{ &quot;popcnt  $dst, $src&quot; %}
 6552   ins_encode %{
 6553     __ popcntl($dst$$Register, $src$$Register);
 6554   %}
 6555   ins_pipe(ialu_reg);
 6556 %}
 6557 
 6558 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6559   predicate(UsePopCountInstruction);
 6560   match(Set dst (PopCountI (LoadI mem)));
 6561   effect(KILL cr);
 6562 
 6563   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6564   ins_encode %{
 6565     __ popcntl($dst$$Register, $mem$$Address);
 6566   %}
 6567   ins_pipe(ialu_reg);
 6568 %}
 6569 
 6570 // Note: Long.bitCount(long) returns an int.
 6571 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6572   predicate(UsePopCountInstruction);
 6573   match(Set dst (PopCountL src));
 6574   effect(KILL cr);
 6575 
 6576   format %{ &quot;popcnt  $dst, $src&quot; %}
 6577   ins_encode %{
 6578     __ popcntq($dst$$Register, $src$$Register);
 6579   %}
 6580   ins_pipe(ialu_reg);
 6581 %}
 6582 
 6583 // Note: Long.bitCount(long) returns an int.
 6584 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6585   predicate(UsePopCountInstruction);
 6586   match(Set dst (PopCountL (LoadL mem)));
 6587   effect(KILL cr);
 6588 
 6589   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6590   ins_encode %{
 6591     __ popcntq($dst$$Register, $mem$$Address);
 6592   %}
 6593   ins_pipe(ialu_reg);
 6594 %}
 6595 
 6596 
 6597 //----------MemBar Instructions-----------------------------------------------
 6598 // Memory barrier flavors
 6599 
 6600 instruct membar_acquire()
 6601 %{
 6602   match(MemBarAcquire);
 6603   match(LoadFence);
 6604   ins_cost(0);
 6605 
 6606   size(0);
 6607   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6608   ins_encode();
 6609   ins_pipe(empty);
 6610 %}
 6611 
 6612 instruct membar_acquire_lock()
 6613 %{
 6614   match(MemBarAcquireLock);
 6615   ins_cost(0);
 6616 
 6617   size(0);
 6618   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6619   ins_encode();
 6620   ins_pipe(empty);
 6621 %}
 6622 
 6623 instruct membar_release()
 6624 %{
 6625   match(MemBarRelease);
 6626   match(StoreFence);
 6627   ins_cost(0);
 6628 
 6629   size(0);
 6630   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6631   ins_encode();
 6632   ins_pipe(empty);
 6633 %}
 6634 
 6635 instruct membar_release_lock()
 6636 %{
 6637   match(MemBarReleaseLock);
 6638   ins_cost(0);
 6639 
 6640   size(0);
 6641   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6642   ins_encode();
 6643   ins_pipe(empty);
 6644 %}
 6645 
 6646 instruct membar_volatile(rFlagsReg cr) %{
 6647   match(MemBarVolatile);
 6648   effect(KILL cr);
 6649   ins_cost(400);
 6650 
 6651   format %{
 6652     $$template
 6653     $$emit$$&quot;lock addl [rsp + #0], 0\t! membar_volatile&quot;
 6654   %}
 6655   ins_encode %{
 6656     __ membar(Assembler::StoreLoad);
 6657   %}
 6658   ins_pipe(pipe_slow);
 6659 %}
 6660 
 6661 instruct unnecessary_membar_volatile()
 6662 %{
 6663   match(MemBarVolatile);
 6664   predicate(Matcher::post_store_load_barrier(n));
 6665   ins_cost(0);
 6666 
 6667   size(0);
 6668   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6669   ins_encode();
 6670   ins_pipe(empty);
 6671 %}
 6672 
 6673 instruct membar_storestore() %{
 6674   match(MemBarStoreStore);
 6675   ins_cost(0);
 6676 
 6677   size(0);
 6678   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6679   ins_encode( );
 6680   ins_pipe(empty);
 6681 %}
 6682 
 6683 //----------Move Instructions--------------------------------------------------
 6684 
 6685 instruct castX2P(rRegP dst, rRegL src)
 6686 %{
 6687   match(Set dst (CastX2P src));
 6688 
 6689   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6690   ins_encode %{
 6691     if ($dst$$reg != $src$$reg) {
 6692       __ movptr($dst$$Register, $src$$Register);
 6693     }
 6694   %}
 6695   ins_pipe(ialu_reg_reg); // XXX
 6696 %}
 6697 
 6698 instruct castN2X(rRegL dst, rRegN src)
 6699 %{
 6700   match(Set dst (CastP2X src));
 6701 
 6702   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6703   ins_encode %{
 6704     if ($dst$$reg != $src$$reg) {
 6705       __ movptr($dst$$Register, $src$$Register);
 6706     }
 6707   %}
 6708   ins_pipe(ialu_reg_reg); // XXX
 6709 %}
 6710 
 6711 instruct castP2X(rRegL dst, rRegP src)
 6712 %{
 6713   match(Set dst (CastP2X src));
 6714 
 6715   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6716   ins_encode %{
 6717     if ($dst$$reg != $src$$reg) {
 6718       __ movptr($dst$$Register, $src$$Register);
 6719     }
 6720   %}
 6721   ins_pipe(ialu_reg_reg); // XXX
 6722 %}
 6723 
 6724 instruct castN2I(rRegI dst, rRegN src)
 6725 %{
 6726   match(Set dst (CastN2I src));
 6727 
 6728   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6729   ins_encode %{
 6730     if ($dst$$reg != $src$$reg) {
 6731       __ movl($dst$$Register, $src$$Register);
 6732     }
 6733   %}
 6734   ins_pipe(ialu_reg_reg); // XXX
 6735 %}
 6736 
 6737 instruct castI2N(rRegN dst, rRegI src)
 6738 %{
 6739   match(Set dst (CastI2N src));
 6740 
 6741   format %{ &quot;movl    $dst, $src\t# int -&gt; compressed ptr&quot; %}
 6742   ins_encode %{
 6743     if ($dst$$reg != $src$$reg) {
 6744       __ movl($dst$$Register, $src$$Register);
 6745     }
 6746   %}
 6747   ins_pipe(ialu_reg_reg); // XXX
 6748 %}
 6749 
 6750 
 6751 // Convert oop into int for vectors alignment masking
 6752 instruct convP2I(rRegI dst, rRegP src)
 6753 %{
 6754   match(Set dst (ConvL2I (CastP2X src)));
 6755 
 6756   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6757   ins_encode %{
 6758     __ movl($dst$$Register, $src$$Register);
 6759   %}
 6760   ins_pipe(ialu_reg_reg); // XXX
 6761 %}
 6762 
 6763 // Convert compressed oop into int for vectors alignment masking
 6764 // in case of 32bit oops (heap &lt; 4Gb).
 6765 instruct convN2I(rRegI dst, rRegN src)
 6766 %{
 6767   predicate(CompressedOops::shift() == 0);
 6768   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6769 
 6770   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6771   ins_encode %{
 6772     __ movl($dst$$Register, $src$$Register);
 6773   %}
 6774   ins_pipe(ialu_reg_reg); // XXX
 6775 %}
 6776 
 6777 // Convert oop pointer into compressed form
 6778 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6779   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6780   match(Set dst (EncodeP src));
 6781   effect(KILL cr);
 6782   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6783   ins_encode %{
 6784     Register s = $src$$Register;
 6785     Register d = $dst$$Register;
 6786     if (s != d) {
 6787       __ movq(d, s);
 6788     }
 6789     __ encode_heap_oop(d);
 6790   %}
 6791   ins_pipe(ialu_reg_long);
 6792 %}
 6793 
 6794 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6795   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6796   match(Set dst (EncodeP src));
 6797   effect(KILL cr);
 6798   format %{ &quot;encode_heap_oop_not_null $dst,$src&quot; %}
 6799   ins_encode %{
 6800     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
 6801   %}
 6802   ins_pipe(ialu_reg_long);
 6803 %}
 6804 
 6805 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
 6806   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6807             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
 6808   match(Set dst (DecodeN src));
 6809   effect(KILL cr);
 6810   format %{ &quot;decode_heap_oop $dst,$src&quot; %}
 6811   ins_encode %{
 6812     Register s = $src$$Register;
 6813     Register d = $dst$$Register;
 6814     if (s != d) {
 6815       __ movq(d, s);
 6816     }
 6817     __ decode_heap_oop(d);
 6818   %}
 6819   ins_pipe(ialu_reg_long);
 6820 %}
 6821 
 6822 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6823   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6824             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6825   match(Set dst (DecodeN src));
 6826   effect(KILL cr);
 6827   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6828   ins_encode %{
 6829     Register s = $src$$Register;
 6830     Register d = $dst$$Register;
 6831     if (s != d) {
 6832       __ decode_heap_oop_not_null(d, s);
 6833     } else {
 6834       __ decode_heap_oop_not_null(d);
 6835     }
 6836   %}
 6837   ins_pipe(ialu_reg_long);
 6838 %}
 6839 
 6840 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6841   match(Set dst (EncodePKlass src));
 6842   effect(TEMP dst, KILL cr);
 6843   format %{ &quot;encode_and_move_klass_not_null $dst,$src&quot; %}
 6844   ins_encode %{
 6845     __ encode_and_move_klass_not_null($dst$$Register, $src$$Register);
 6846   %}
 6847   ins_pipe(ialu_reg_long);
 6848 %}
 6849 
 6850 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6851   match(Set dst (DecodeNKlass src));
 6852   effect(TEMP dst, KILL cr);
 6853   format %{ &quot;decode_and_move_klass_not_null $dst,$src&quot; %}
 6854   ins_encode %{
 6855     __ decode_and_move_klass_not_null($dst$$Register, $src$$Register);
 6856   %}
 6857   ins_pipe(ialu_reg_long);
 6858 %}
 6859 
 6860 //----------Conditional Move---------------------------------------------------
 6861 // Jump
 6862 // dummy instruction for generating temp registers
 6863 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6864   match(Jump (LShiftL switch_val shift));
 6865   ins_cost(350);
 6866   predicate(false);
 6867   effect(TEMP dest);
 6868 
 6869   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6870             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6871   ins_encode %{
 6872     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6873     // to do that and the compiler is using that register as one it can allocate.
 6874     // So we build it all by hand.
 6875     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6876     // ArrayAddress dispatch(table, index);
 6877     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6878     __ lea($dest$$Register, $constantaddress);
 6879     __ jmp(dispatch);
 6880   %}
 6881   ins_pipe(pipe_jmp);
 6882 %}
 6883 
 6884 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
 6885   match(Jump (AddL (LShiftL switch_val shift) offset));
 6886   ins_cost(350);
 6887   effect(TEMP dest);
 6888 
 6889   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6890             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t&quot; %}
 6891   ins_encode %{
 6892     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6893     // to do that and the compiler is using that register as one it can allocate.
 6894     // So we build it all by hand.
 6895     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6896     // ArrayAddress dispatch(table, index);
 6897     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6898     __ lea($dest$$Register, $constantaddress);
 6899     __ jmp(dispatch);
 6900   %}
 6901   ins_pipe(pipe_jmp);
 6902 %}
 6903 
 6904 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
 6905   match(Jump switch_val);
 6906   ins_cost(350);
 6907   effect(TEMP dest);
 6908 
 6909   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6910             &quot;jmp     [$dest + $switch_val]\n\t&quot; %}
 6911   ins_encode %{
 6912     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6913     // to do that and the compiler is using that register as one it can allocate.
 6914     // So we build it all by hand.
 6915     // Address index(noreg, switch_reg, Address::times_1);
 6916     // ArrayAddress dispatch(table, index);
 6917     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
 6918     __ lea($dest$$Register, $constantaddress);
 6919     __ jmp(dispatch);
 6920   %}
 6921   ins_pipe(pipe_jmp);
 6922 %}
 6923 
 6924 // Conditional move
 6925 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
 6926 %{
 6927   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6928 
 6929   ins_cost(200); // XXX
 6930   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6931   opcode(0x0F, 0x40);
 6932   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6933   ins_pipe(pipe_cmov_reg);
 6934 %}
 6935 
 6936 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
 6937   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6938 
 6939   ins_cost(200); // XXX
 6940   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6941   opcode(0x0F, 0x40);
 6942   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6943   ins_pipe(pipe_cmov_reg);
 6944 %}
 6945 
 6946 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
 6947   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6948   ins_cost(200);
 6949   expand %{
 6950     cmovI_regU(cop, cr, dst, src);
 6951   %}
 6952 %}
 6953 
 6954 // Conditional move
 6955 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
 6956   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6957 
 6958   ins_cost(250); // XXX
 6959   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6960   opcode(0x0F, 0x40);
 6961   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6962   ins_pipe(pipe_cmov_mem);
 6963 %}
 6964 
 6965 // Conditional move
 6966 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
 6967 %{
 6968   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6969 
 6970   ins_cost(250); // XXX
 6971   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6972   opcode(0x0F, 0x40);
 6973   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6974   ins_pipe(pipe_cmov_mem);
 6975 %}
 6976 
 6977 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
 6978   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6979   ins_cost(250);
 6980   expand %{
 6981     cmovI_memU(cop, cr, dst, src);
 6982   %}
 6983 %}
 6984 
 6985 // Conditional move
 6986 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
 6987 %{
 6988   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6989 
 6990   ins_cost(200); // XXX
 6991   format %{ &quot;cmovl$cop $dst, $src\t# signed, compressed ptr&quot; %}
 6992   opcode(0x0F, 0x40);
 6993   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6994   ins_pipe(pipe_cmov_reg);
 6995 %}
 6996 
 6997 // Conditional move
 6998 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
 6999 %{
 7000   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7001 
 7002   ins_cost(200); // XXX
 7003   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, compressed ptr&quot; %}
 7004   opcode(0x0F, 0x40);
 7005   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7006   ins_pipe(pipe_cmov_reg);
 7007 %}
 7008 
 7009 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
 7010   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7011   ins_cost(200);
 7012   expand %{
 7013     cmovN_regU(cop, cr, dst, src);
 7014   %}
 7015 %}
 7016 
 7017 // Conditional move
 7018 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
 7019 %{
 7020   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7021 
 7022   ins_cost(200); // XXX
 7023   format %{ &quot;cmovq$cop $dst, $src\t# signed, ptr&quot; %}
 7024   opcode(0x0F, 0x40);
 7025   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7026   ins_pipe(pipe_cmov_reg);  // XXX
 7027 %}
 7028 
 7029 // Conditional move
 7030 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
 7031 %{
 7032   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7033 
 7034   ins_cost(200); // XXX
 7035   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, ptr&quot; %}
 7036   opcode(0x0F, 0x40);
 7037   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7038   ins_pipe(pipe_cmov_reg); // XXX
 7039 %}
 7040 
 7041 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
 7042   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7043   ins_cost(200);
 7044   expand %{
 7045     cmovP_regU(cop, cr, dst, src);
 7046   %}
 7047 %}
 7048 
 7049 // DISABLED: Requires the ADLC to emit a bottom_type call that
 7050 // correctly meets the two pointer arguments; one is an incoming
 7051 // register but the other is a memory operand.  ALSO appears to
 7052 // be buggy with implicit null checks.
 7053 //
 7054 //// Conditional move
 7055 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
 7056 //%{
 7057 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7058 //  ins_cost(250);
 7059 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7060 //  opcode(0x0F,0x40);
 7061 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7062 //  ins_pipe( pipe_cmov_mem );
 7063 //%}
 7064 //
 7065 //// Conditional move
 7066 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
 7067 //%{
 7068 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7069 //  ins_cost(250);
 7070 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7071 //  opcode(0x0F,0x40);
 7072 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7073 //  ins_pipe( pipe_cmov_mem );
 7074 //%}
 7075 
 7076 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
 7077 %{
 7078   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7079 
 7080   ins_cost(200); // XXX
 7081   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7082   opcode(0x0F, 0x40);
 7083   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7084   ins_pipe(pipe_cmov_reg);  // XXX
 7085 %}
 7086 
 7087 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
 7088 %{
 7089   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7090 
 7091   ins_cost(200); // XXX
 7092   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7093   opcode(0x0F, 0x40);
 7094   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7095   ins_pipe(pipe_cmov_mem);  // XXX
 7096 %}
 7097 
 7098 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
 7099 %{
 7100   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7101 
 7102   ins_cost(200); // XXX
 7103   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7104   opcode(0x0F, 0x40);
 7105   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7106   ins_pipe(pipe_cmov_reg); // XXX
 7107 %}
 7108 
 7109 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
 7110   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7111   ins_cost(200);
 7112   expand %{
 7113     cmovL_regU(cop, cr, dst, src);
 7114   %}
 7115 %}
 7116 
 7117 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
 7118 %{
 7119   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7120 
 7121   ins_cost(200); // XXX
 7122   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7123   opcode(0x0F, 0x40);
 7124   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7125   ins_pipe(pipe_cmov_mem); // XXX
 7126 %}
 7127 
 7128 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
 7129   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7130   ins_cost(200);
 7131   expand %{
 7132     cmovL_memU(cop, cr, dst, src);
 7133   %}
 7134 %}
 7135 
 7136 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
 7137 %{
 7138   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7139 
 7140   ins_cost(200); // XXX
 7141   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7142             &quot;movss     $dst, $src\n&quot;
 7143     &quot;skip:&quot; %}
 7144   ins_encode %{
 7145     Label Lskip;
 7146     // Invert sense of branch from sense of CMOV
 7147     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7148     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7149     __ bind(Lskip);
 7150   %}
 7151   ins_pipe(pipe_slow);
 7152 %}
 7153 
 7154 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
 7155 // %{
 7156 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
 7157 
 7158 //   ins_cost(200); // XXX
 7159 //   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7160 //             &quot;movss     $dst, $src\n&quot;
 7161 //     &quot;skip:&quot; %}
 7162 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
 7163 //   ins_pipe(pipe_slow);
 7164 // %}
 7165 
 7166 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
 7167 %{
 7168   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7169 
 7170   ins_cost(200); // XXX
 7171   format %{ &quot;jn$cop    skip\t# unsigned cmove float\n\t&quot;
 7172             &quot;movss     $dst, $src\n&quot;
 7173     &quot;skip:&quot; %}
 7174   ins_encode %{
 7175     Label Lskip;
 7176     // Invert sense of branch from sense of CMOV
 7177     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7178     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7179     __ bind(Lskip);
 7180   %}
 7181   ins_pipe(pipe_slow);
 7182 %}
 7183 
 7184 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
 7185   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7186   ins_cost(200);
 7187   expand %{
 7188     cmovF_regU(cop, cr, dst, src);
 7189   %}
 7190 %}
 7191 
 7192 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
 7193 %{
 7194   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7195 
 7196   ins_cost(200); // XXX
 7197   format %{ &quot;jn$cop    skip\t# signed cmove double\n\t&quot;
 7198             &quot;movsd     $dst, $src\n&quot;
 7199     &quot;skip:&quot; %}
 7200   ins_encode %{
 7201     Label Lskip;
 7202     // Invert sense of branch from sense of CMOV
 7203     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7204     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7205     __ bind(Lskip);
 7206   %}
 7207   ins_pipe(pipe_slow);
 7208 %}
 7209 
 7210 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
 7211 %{
 7212   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7213 
 7214   ins_cost(200); // XXX
 7215   format %{ &quot;jn$cop    skip\t# unsigned cmove double\n\t&quot;
 7216             &quot;movsd     $dst, $src\n&quot;
 7217     &quot;skip:&quot; %}
 7218   ins_encode %{
 7219     Label Lskip;
 7220     // Invert sense of branch from sense of CMOV
 7221     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7222     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7223     __ bind(Lskip);
 7224   %}
 7225   ins_pipe(pipe_slow);
 7226 %}
 7227 
 7228 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
 7229   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7230   ins_cost(200);
 7231   expand %{
 7232     cmovD_regU(cop, cr, dst, src);
 7233   %}
 7234 %}
 7235 
 7236 //----------Arithmetic Instructions--------------------------------------------
 7237 //----------Addition Instructions----------------------------------------------
 7238 
 7239 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 7240 %{
 7241   match(Set dst (AddI dst src));
 7242   effect(KILL cr);
 7243 
 7244   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7245   opcode(0x03);
 7246   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 7247   ins_pipe(ialu_reg_reg);
 7248 %}
 7249 
 7250 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 7251 %{
 7252   match(Set dst (AddI dst src));
 7253   effect(KILL cr);
 7254 
 7255   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7256   opcode(0x81, 0x00); /* /0 id */
 7257   ins_encode(OpcSErm(dst, src), Con8or32(src));
 7258   ins_pipe( ialu_reg );
 7259 %}
 7260 
 7261 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 7262 %{
 7263   match(Set dst (AddI dst (LoadI src)));
 7264   effect(KILL cr);
 7265 
 7266   ins_cost(125); // XXX
 7267   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7268   opcode(0x03);
 7269   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 7270   ins_pipe(ialu_reg_mem);
 7271 %}
 7272 
 7273 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 7274 %{
 7275   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7276   effect(KILL cr);
 7277 
 7278   ins_cost(150); // XXX
 7279   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7280   opcode(0x01); /* Opcode 01 /r */
 7281   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 7282   ins_pipe(ialu_mem_reg);
 7283 %}
 7284 
 7285 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
 7286 %{
 7287   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7288   effect(KILL cr);
 7289 
 7290   ins_cost(125); // XXX
 7291   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7292   opcode(0x81); /* Opcode 81 /0 id */
 7293   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7294   ins_pipe(ialu_mem_imm);
 7295 %}
 7296 
 7297 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
 7298 %{
 7299   predicate(UseIncDec);
 7300   match(Set dst (AddI dst src));
 7301   effect(KILL cr);
 7302 
 7303   format %{ &quot;incl    $dst\t# int&quot; %}
 7304   opcode(0xFF, 0x00); // FF /0
 7305   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7306   ins_pipe(ialu_reg);
 7307 %}
 7308 
 7309 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
 7310 %{
 7311   predicate(UseIncDec);
 7312   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7313   effect(KILL cr);
 7314 
 7315   ins_cost(125); // XXX
 7316   format %{ &quot;incl    $dst\t# int&quot; %}
 7317   opcode(0xFF); /* Opcode FF /0 */
 7318   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
 7319   ins_pipe(ialu_mem_imm);
 7320 %}
 7321 
 7322 // XXX why does that use AddI
 7323 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
 7324 %{
 7325   predicate(UseIncDec);
 7326   match(Set dst (AddI dst src));
 7327   effect(KILL cr);
 7328 
 7329   format %{ &quot;decl    $dst\t# int&quot; %}
 7330   opcode(0xFF, 0x01); // FF /1
 7331   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7332   ins_pipe(ialu_reg);
 7333 %}
 7334 
 7335 // XXX why does that use AddI
 7336 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
 7337 %{
 7338   predicate(UseIncDec);
 7339   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7340   effect(KILL cr);
 7341 
 7342   ins_cost(125); // XXX
 7343   format %{ &quot;decl    $dst\t# int&quot; %}
 7344   opcode(0xFF); /* Opcode FF /1 */
 7345   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
 7346   ins_pipe(ialu_mem_imm);
 7347 %}
 7348 
 7349 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
 7350 %{
 7351   match(Set dst (AddI src0 src1));
 7352 
 7353   ins_cost(110);
 7354   format %{ &quot;addr32 leal $dst, [$src0 + $src1]\t# int&quot; %}
 7355   opcode(0x8D); /* 0x8D /r */
 7356   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7357   ins_pipe(ialu_reg_reg);
 7358 %}
 7359 
 7360 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 7361 %{
 7362   match(Set dst (AddL dst src));
 7363   effect(KILL cr);
 7364 
 7365   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7366   opcode(0x03);
 7367   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7368   ins_pipe(ialu_reg_reg);
 7369 %}
 7370 
 7371 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 7372 %{
 7373   match(Set dst (AddL dst src));
 7374   effect(KILL cr);
 7375 
 7376   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7377   opcode(0x81, 0x00); /* /0 id */
 7378   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7379   ins_pipe( ialu_reg );
 7380 %}
 7381 
 7382 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 7383 %{
 7384   match(Set dst (AddL dst (LoadL src)));
 7385   effect(KILL cr);
 7386 
 7387   ins_cost(125); // XXX
 7388   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7389   opcode(0x03);
 7390   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 7391   ins_pipe(ialu_reg_mem);
 7392 %}
 7393 
 7394 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 7395 %{
 7396   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7397   effect(KILL cr);
 7398 
 7399   ins_cost(150); // XXX
 7400   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7401   opcode(0x01); /* Opcode 01 /r */
 7402   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 7403   ins_pipe(ialu_mem_reg);
 7404 %}
 7405 
 7406 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 7407 %{
 7408   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7409   effect(KILL cr);
 7410 
 7411   ins_cost(125); // XXX
 7412   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7413   opcode(0x81); /* Opcode 81 /0 id */
 7414   ins_encode(REX_mem_wide(dst),
 7415              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7416   ins_pipe(ialu_mem_imm);
 7417 %}
 7418 
 7419 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
 7420 %{
 7421   predicate(UseIncDec);
 7422   match(Set dst (AddL dst src));
 7423   effect(KILL cr);
 7424 
 7425   format %{ &quot;incq    $dst\t# long&quot; %}
 7426   opcode(0xFF, 0x00); // FF /0
 7427   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7428   ins_pipe(ialu_reg);
 7429 %}
 7430 
 7431 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
 7432 %{
 7433   predicate(UseIncDec);
 7434   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7435   effect(KILL cr);
 7436 
 7437   ins_cost(125); // XXX
 7438   format %{ &quot;incq    $dst\t# long&quot; %}
 7439   opcode(0xFF); /* Opcode FF /0 */
 7440   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
 7441   ins_pipe(ialu_mem_imm);
 7442 %}
 7443 
 7444 // XXX why does that use AddL
 7445 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
 7446 %{
 7447   predicate(UseIncDec);
 7448   match(Set dst (AddL dst src));
 7449   effect(KILL cr);
 7450 
 7451   format %{ &quot;decq    $dst\t# long&quot; %}
 7452   opcode(0xFF, 0x01); // FF /1
 7453   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7454   ins_pipe(ialu_reg);
 7455 %}
 7456 
 7457 // XXX why does that use AddL
 7458 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
 7459 %{
 7460   predicate(UseIncDec);
 7461   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7462   effect(KILL cr);
 7463 
 7464   ins_cost(125); // XXX
 7465   format %{ &quot;decq    $dst\t# long&quot; %}
 7466   opcode(0xFF); /* Opcode FF /1 */
 7467   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
 7468   ins_pipe(ialu_mem_imm);
 7469 %}
 7470 
 7471 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
 7472 %{
 7473   match(Set dst (AddL src0 src1));
 7474 
 7475   ins_cost(110);
 7476   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# long&quot; %}
 7477   opcode(0x8D); /* 0x8D /r */
 7478   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7479   ins_pipe(ialu_reg_reg);
 7480 %}
 7481 
 7482 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
 7483 %{
 7484   match(Set dst (AddP dst src));
 7485   effect(KILL cr);
 7486 
 7487   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7488   opcode(0x03);
 7489   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7490   ins_pipe(ialu_reg_reg);
 7491 %}
 7492 
 7493 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
 7494 %{
 7495   match(Set dst (AddP dst src));
 7496   effect(KILL cr);
 7497 
 7498   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7499   opcode(0x81, 0x00); /* /0 id */
 7500   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7501   ins_pipe( ialu_reg );
 7502 %}
 7503 
 7504 // XXX addP mem ops ????
 7505 
 7506 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
 7507 %{
 7508   match(Set dst (AddP src0 src1));
 7509 
 7510   ins_cost(110);
 7511   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# ptr&quot; %}
 7512   opcode(0x8D); /* 0x8D /r */
 7513   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
 7514   ins_pipe(ialu_reg_reg);
 7515 %}
 7516 
 7517 instruct checkCastPP(rRegP dst)
 7518 %{
 7519   match(Set dst (CheckCastPP dst));
 7520 
 7521   size(0);
 7522   format %{ &quot;# checkcastPP of $dst&quot; %}
 7523   ins_encode(/* empty encoding */);
 7524   ins_pipe(empty);
 7525 %}
 7526 
 7527 instruct castPP(rRegP dst)
 7528 %{
 7529   match(Set dst (CastPP dst));
 7530 
 7531   size(0);
 7532   format %{ &quot;# castPP of $dst&quot; %}
 7533   ins_encode(/* empty encoding */);
 7534   ins_pipe(empty);
 7535 %}
 7536 
 7537 instruct castII(rRegI dst)
 7538 %{
 7539   match(Set dst (CastII dst));
 7540 
 7541   size(0);
 7542   format %{ &quot;# castII of $dst&quot; %}
 7543   ins_encode(/* empty encoding */);
 7544   ins_cost(0);
 7545   ins_pipe(empty);
 7546 %}
 7547 
 7548 // LoadP-locked same as a regular LoadP when used with compare-swap
 7549 instruct loadPLocked(rRegP dst, memory mem)
 7550 %{
 7551   match(Set dst (LoadPLocked mem));
 7552 
 7553   ins_cost(125); // XXX
 7554   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7555   opcode(0x8B);
 7556   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7557   ins_pipe(ialu_reg_mem); // XXX
 7558 %}
 7559 
 7560 // Conditional-store of the updated heap-top.
 7561 // Used during allocation of the shared heap.
 7562 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7563 
 7564 instruct storePConditional(memory heap_top_ptr,
 7565                            rax_RegP oldval, rRegP newval,
 7566                            rFlagsReg cr)
 7567 %{
 7568   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7569   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7570 
 7571   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7572             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7573   opcode(0x0F, 0xB1);
 7574   ins_encode(lock_prefix,
 7575              REX_reg_mem_wide(newval, heap_top_ptr),
 7576              OpcP, OpcS,
 7577              reg_mem(newval, heap_top_ptr));
 7578   ins_pipe(pipe_cmpxchg);
 7579 %}
 7580 
 7581 // Conditional-store of an int value.
 7582 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7583 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7584 %{
 7585   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7586   effect(KILL oldval);
 7587 
 7588   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7589   opcode(0x0F, 0xB1);
 7590   ins_encode(lock_prefix,
 7591              REX_reg_mem(newval, mem),
 7592              OpcP, OpcS,
 7593              reg_mem(newval, mem));
 7594   ins_pipe(pipe_cmpxchg);
 7595 %}
 7596 
 7597 // Conditional-store of a long value.
 7598 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7599 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
 7600 %{
 7601   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7602   effect(KILL oldval);
 7603 
 7604   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7605   opcode(0x0F, 0xB1);
 7606   ins_encode(lock_prefix,
 7607              REX_reg_mem_wide(newval, mem),
 7608              OpcP, OpcS,
 7609              reg_mem(newval, mem));
 7610   ins_pipe(pipe_cmpxchg);
 7611 %}
 7612 
 7613 
 7614 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7615 instruct compareAndSwapP(rRegI res,
 7616                          memory mem_ptr,
 7617                          rax_RegP oldval, rRegP newval,
 7618                          rFlagsReg cr)
 7619 %{
 7620   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7621   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7622   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7623   effect(KILL cr, KILL oldval);
 7624 
 7625   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7626             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7627             &quot;sete    $res\n\t&quot;
 7628             &quot;movzbl  $res, $res&quot; %}
 7629   opcode(0x0F, 0xB1);
 7630   ins_encode(lock_prefix,
 7631              REX_reg_mem_wide(newval, mem_ptr),
 7632              OpcP, OpcS,
 7633              reg_mem(newval, mem_ptr),
 7634              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7635              REX_reg_breg(res, res), // movzbl
 7636              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7637   ins_pipe( pipe_cmpxchg );
 7638 %}
 7639 
 7640 instruct compareAndSwapL(rRegI res,
 7641                          memory mem_ptr,
 7642                          rax_RegL oldval, rRegL newval,
 7643                          rFlagsReg cr)
 7644 %{
 7645   predicate(VM_Version::supports_cx8());
 7646   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7647   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7648   effect(KILL cr, KILL oldval);
 7649 
 7650   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7651             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7652             &quot;sete    $res\n\t&quot;
 7653             &quot;movzbl  $res, $res&quot; %}
 7654   opcode(0x0F, 0xB1);
 7655   ins_encode(lock_prefix,
 7656              REX_reg_mem_wide(newval, mem_ptr),
 7657              OpcP, OpcS,
 7658              reg_mem(newval, mem_ptr),
 7659              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7660              REX_reg_breg(res, res), // movzbl
 7661              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7662   ins_pipe( pipe_cmpxchg );
 7663 %}
 7664 
 7665 instruct compareAndSwapI(rRegI res,
 7666                          memory mem_ptr,
 7667                          rax_RegI oldval, rRegI newval,
 7668                          rFlagsReg cr)
 7669 %{
 7670   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7671   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7672   effect(KILL cr, KILL oldval);
 7673 
 7674   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7675             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7676             &quot;sete    $res\n\t&quot;
 7677             &quot;movzbl  $res, $res&quot; %}
 7678   opcode(0x0F, 0xB1);
 7679   ins_encode(lock_prefix,
 7680              REX_reg_mem(newval, mem_ptr),
 7681              OpcP, OpcS,
 7682              reg_mem(newval, mem_ptr),
 7683              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7684              REX_reg_breg(res, res), // movzbl
 7685              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7686   ins_pipe( pipe_cmpxchg );
 7687 %}
 7688 
 7689 instruct compareAndSwapB(rRegI res,
 7690                          memory mem_ptr,
 7691                          rax_RegI oldval, rRegI newval,
 7692                          rFlagsReg cr)
 7693 %{
 7694   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7695   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7696   effect(KILL cr, KILL oldval);
 7697 
 7698   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7699             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7700             &quot;sete    $res\n\t&quot;
 7701             &quot;movzbl  $res, $res&quot; %}
 7702   opcode(0x0F, 0xB0);
 7703   ins_encode(lock_prefix,
 7704              REX_breg_mem(newval, mem_ptr),
 7705              OpcP, OpcS,
 7706              reg_mem(newval, mem_ptr),
 7707              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7708              REX_reg_breg(res, res), // movzbl
 7709              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7710   ins_pipe( pipe_cmpxchg );
 7711 %}
 7712 
 7713 instruct compareAndSwapS(rRegI res,
 7714                          memory mem_ptr,
 7715                          rax_RegI oldval, rRegI newval,
 7716                          rFlagsReg cr)
 7717 %{
 7718   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7719   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7720   effect(KILL cr, KILL oldval);
 7721 
 7722   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7723             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7724             &quot;sete    $res\n\t&quot;
 7725             &quot;movzbl  $res, $res&quot; %}
 7726   opcode(0x0F, 0xB1);
 7727   ins_encode(lock_prefix,
 7728              SizePrefix,
 7729              REX_reg_mem(newval, mem_ptr),
 7730              OpcP, OpcS,
 7731              reg_mem(newval, mem_ptr),
 7732              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7733              REX_reg_breg(res, res), // movzbl
 7734              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7735   ins_pipe( pipe_cmpxchg );
 7736 %}
 7737 
 7738 instruct compareAndSwapN(rRegI res,
 7739                           memory mem_ptr,
 7740                           rax_RegN oldval, rRegN newval,
 7741                           rFlagsReg cr) %{
 7742   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7743   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7744   effect(KILL cr, KILL oldval);
 7745 
 7746   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7747             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7748             &quot;sete    $res\n\t&quot;
 7749             &quot;movzbl  $res, $res&quot; %}
 7750   opcode(0x0F, 0xB1);
 7751   ins_encode(lock_prefix,
 7752              REX_reg_mem(newval, mem_ptr),
 7753              OpcP, OpcS,
 7754              reg_mem(newval, mem_ptr),
 7755              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7756              REX_reg_breg(res, res), // movzbl
 7757              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7758   ins_pipe( pipe_cmpxchg );
 7759 %}
 7760 
 7761 instruct compareAndExchangeB(
 7762                          memory mem_ptr,
 7763                          rax_RegI oldval, rRegI newval,
 7764                          rFlagsReg cr)
 7765 %{
 7766   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7767   effect(KILL cr);
 7768 
 7769   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7770             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7771   opcode(0x0F, 0xB0);
 7772   ins_encode(lock_prefix,
 7773              REX_breg_mem(newval, mem_ptr),
 7774              OpcP, OpcS,
 7775              reg_mem(newval, mem_ptr) // lock cmpxchg
 7776              );
 7777   ins_pipe( pipe_cmpxchg );
 7778 %}
 7779 
 7780 instruct compareAndExchangeS(
 7781                          memory mem_ptr,
 7782                          rax_RegI oldval, rRegI newval,
 7783                          rFlagsReg cr)
 7784 %{
 7785   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7786   effect(KILL cr);
 7787 
 7788   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7789             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7790   opcode(0x0F, 0xB1);
 7791   ins_encode(lock_prefix,
 7792              SizePrefix,
 7793              REX_reg_mem(newval, mem_ptr),
 7794              OpcP, OpcS,
 7795              reg_mem(newval, mem_ptr) // lock cmpxchg
 7796              );
 7797   ins_pipe( pipe_cmpxchg );
 7798 %}
 7799 
 7800 instruct compareAndExchangeI(
 7801                          memory mem_ptr,
 7802                          rax_RegI oldval, rRegI newval,
 7803                          rFlagsReg cr)
 7804 %{
 7805   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7806   effect(KILL cr);
 7807 
 7808   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7809             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7810   opcode(0x0F, 0xB1);
 7811   ins_encode(lock_prefix,
 7812              REX_reg_mem(newval, mem_ptr),
 7813              OpcP, OpcS,
 7814              reg_mem(newval, mem_ptr) // lock cmpxchg
 7815              );
 7816   ins_pipe( pipe_cmpxchg );
 7817 %}
 7818 
 7819 instruct compareAndExchangeL(
 7820                          memory mem_ptr,
 7821                          rax_RegL oldval, rRegL newval,
 7822                          rFlagsReg cr)
 7823 %{
 7824   predicate(VM_Version::supports_cx8());
 7825   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7826   effect(KILL cr);
 7827 
 7828   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7829             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7830   opcode(0x0F, 0xB1);
 7831   ins_encode(lock_prefix,
 7832              REX_reg_mem_wide(newval, mem_ptr),
 7833              OpcP, OpcS,
 7834              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7835             );
 7836   ins_pipe( pipe_cmpxchg );
 7837 %}
 7838 
 7839 instruct compareAndExchangeN(
 7840                           memory mem_ptr,
 7841                           rax_RegN oldval, rRegN newval,
 7842                           rFlagsReg cr) %{
 7843   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7844   effect(KILL cr);
 7845 
 7846   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7847             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7848   opcode(0x0F, 0xB1);
 7849   ins_encode(lock_prefix,
 7850              REX_reg_mem(newval, mem_ptr),
 7851              OpcP, OpcS,
 7852              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7853           );
 7854   ins_pipe( pipe_cmpxchg );
 7855 %}
 7856 
 7857 instruct compareAndExchangeP(
 7858                          memory mem_ptr,
 7859                          rax_RegP oldval, rRegP newval,
 7860                          rFlagsReg cr)
 7861 %{
 7862   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7863   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7864   effect(KILL cr);
 7865 
 7866   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7867             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7868   opcode(0x0F, 0xB1);
 7869   ins_encode(lock_prefix,
 7870              REX_reg_mem_wide(newval, mem_ptr),
 7871              OpcP, OpcS,
 7872              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7873           );
 7874   ins_pipe( pipe_cmpxchg );
 7875 %}
 7876 
 7877 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7878   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7879   match(Set dummy (GetAndAddB mem add));
 7880   effect(KILL cr);
 7881   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7882   ins_encode %{
 7883     __ lock();
 7884     __ addb($mem$$Address, $add$$constant);
 7885   %}
 7886   ins_pipe( pipe_cmpxchg );
 7887 %}
 7888 
 7889 instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{
 7890   match(Set newval (GetAndAddB mem newval));
 7891   effect(KILL cr);
 7892   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7893   ins_encode %{
 7894     __ lock();
 7895     __ xaddb($mem$$Address, $newval$$Register);
 7896   %}
 7897   ins_pipe( pipe_cmpxchg );
 7898 %}
 7899 
 7900 instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7901   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7902   match(Set dummy (GetAndAddS mem add));
 7903   effect(KILL cr);
 7904   format %{ &quot;ADDW  [$mem],$add&quot; %}
 7905   ins_encode %{
 7906     __ lock();
 7907     __ addw($mem$$Address, $add$$constant);
 7908   %}
 7909   ins_pipe( pipe_cmpxchg );
 7910 %}
 7911 
 7912 instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{
 7913   match(Set newval (GetAndAddS mem newval));
 7914   effect(KILL cr);
 7915   format %{ &quot;XADDW  [$mem],$newval&quot; %}
 7916   ins_encode %{
 7917     __ lock();
 7918     __ xaddw($mem$$Address, $newval$$Register);
 7919   %}
 7920   ins_pipe( pipe_cmpxchg );
 7921 %}
 7922 
 7923 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7924   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7925   match(Set dummy (GetAndAddI mem add));
 7926   effect(KILL cr);
 7927   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7928   ins_encode %{
 7929     __ lock();
 7930     __ addl($mem$$Address, $add$$constant);
 7931   %}
 7932   ins_pipe( pipe_cmpxchg );
 7933 %}
 7934 
 7935 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
 7936   match(Set newval (GetAndAddI mem newval));
 7937   effect(KILL cr);
 7938   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7939   ins_encode %{
 7940     __ lock();
 7941     __ xaddl($mem$$Address, $newval$$Register);
 7942   %}
 7943   ins_pipe( pipe_cmpxchg );
 7944 %}
 7945 
 7946 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
 7947   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7948   match(Set dummy (GetAndAddL mem add));
 7949   effect(KILL cr);
 7950   format %{ &quot;ADDQ  [$mem],$add&quot; %}
 7951   ins_encode %{
 7952     __ lock();
 7953     __ addq($mem$$Address, $add$$constant);
 7954   %}
 7955   ins_pipe( pipe_cmpxchg );
 7956 %}
 7957 
 7958 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
 7959   match(Set newval (GetAndAddL mem newval));
 7960   effect(KILL cr);
 7961   format %{ &quot;XADDQ  [$mem],$newval&quot; %}
 7962   ins_encode %{
 7963     __ lock();
 7964     __ xaddq($mem$$Address, $newval$$Register);
 7965   %}
 7966   ins_pipe( pipe_cmpxchg );
 7967 %}
 7968 
 7969 instruct xchgB( memory mem, rRegI newval) %{
 7970   match(Set newval (GetAndSetB mem newval));
 7971   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7972   ins_encode %{
 7973     __ xchgb($newval$$Register, $mem$$Address);
 7974   %}
 7975   ins_pipe( pipe_cmpxchg );
 7976 %}
 7977 
 7978 instruct xchgS( memory mem, rRegI newval) %{
 7979   match(Set newval (GetAndSetS mem newval));
 7980   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7981   ins_encode %{
 7982     __ xchgw($newval$$Register, $mem$$Address);
 7983   %}
 7984   ins_pipe( pipe_cmpxchg );
 7985 %}
 7986 
 7987 instruct xchgI( memory mem, rRegI newval) %{
 7988   match(Set newval (GetAndSetI mem newval));
 7989   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7990   ins_encode %{
 7991     __ xchgl($newval$$Register, $mem$$Address);
 7992   %}
 7993   ins_pipe( pipe_cmpxchg );
 7994 %}
 7995 
 7996 instruct xchgL( memory mem, rRegL newval) %{
 7997   match(Set newval (GetAndSetL mem newval));
 7998   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7999   ins_encode %{
 8000     __ xchgq($newval$$Register, $mem$$Address);
 8001   %}
 8002   ins_pipe( pipe_cmpxchg );
 8003 %}
 8004 
 8005 instruct xchgP( memory mem, rRegP newval) %{
 8006   match(Set newval (GetAndSetP mem newval));
 8007   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 8008   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 8009   ins_encode %{
 8010     __ xchgq($newval$$Register, $mem$$Address);
 8011   %}
 8012   ins_pipe( pipe_cmpxchg );
 8013 %}
 8014 
 8015 instruct xchgN( memory mem, rRegN newval) %{
 8016   match(Set newval (GetAndSetN mem newval));
 8017   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 8018   ins_encode %{
 8019     __ xchgl($newval$$Register, $mem$$Address);
 8020   %}
 8021   ins_pipe( pipe_cmpxchg );
 8022 %}
 8023 
 8024 //----------Abs Instructions-------------------------------------------
 8025 
 8026 // Integer Absolute Instructions
 8027 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)
 8028 %{
 8029   match(Set dst (AbsI src));
 8030   effect(TEMP dst, TEMP tmp, KILL cr);
 8031   format %{ &quot;movl $tmp, $src\n\t&quot;
 8032             &quot;sarl $tmp, 31\n\t&quot;
 8033             &quot;movl $dst, $src\n\t&quot;
 8034             &quot;xorl $dst, $tmp\n\t&quot;
 8035             &quot;subl $dst, $tmp\n&quot;
 8036           %}
 8037   ins_encode %{
 8038     __ movl($tmp$$Register, $src$$Register);
 8039     __ sarl($tmp$$Register, 31);
 8040     __ movl($dst$$Register, $src$$Register);
 8041     __ xorl($dst$$Register, $tmp$$Register);
 8042     __ subl($dst$$Register, $tmp$$Register);
 8043   %}
 8044 
 8045   ins_pipe(ialu_reg_reg);
 8046 %}
 8047 
 8048 // Long Absolute Instructions
 8049 instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)
 8050 %{
 8051   match(Set dst (AbsL src));
 8052   effect(TEMP dst, TEMP tmp, KILL cr);
 8053   format %{ &quot;movq $tmp, $src\n\t&quot;
 8054             &quot;sarq $tmp, 63\n\t&quot;
 8055             &quot;movq $dst, $src\n\t&quot;
 8056             &quot;xorq $dst, $tmp\n\t&quot;
 8057             &quot;subq $dst, $tmp\n&quot;
 8058           %}
 8059   ins_encode %{
 8060     __ movq($tmp$$Register, $src$$Register);
 8061     __ sarq($tmp$$Register, 63);
 8062     __ movq($dst$$Register, $src$$Register);
 8063     __ xorq($dst$$Register, $tmp$$Register);
 8064     __ subq($dst$$Register, $tmp$$Register);
 8065   %}
 8066 
 8067   ins_pipe(ialu_reg_reg);
 8068 %}
 8069 
 8070 //----------Subtraction Instructions-------------------------------------------
 8071 
 8072 // Integer Subtraction Instructions
 8073 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8074 %{
 8075   match(Set dst (SubI dst src));
 8076   effect(KILL cr);
 8077 
 8078   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8079   opcode(0x2B);
 8080   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8081   ins_pipe(ialu_reg_reg);
 8082 %}
 8083 
 8084 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8085 %{
 8086   match(Set dst (SubI dst src));
 8087   effect(KILL cr);
 8088 
 8089   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8090   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8091   ins_encode(OpcSErm(dst, src), Con8or32(src));
 8092   ins_pipe(ialu_reg);
 8093 %}
 8094 
 8095 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 8096 %{
 8097   match(Set dst (SubI dst (LoadI src)));
 8098   effect(KILL cr);
 8099 
 8100   ins_cost(125);
 8101   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8102   opcode(0x2B);
 8103   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 8104   ins_pipe(ialu_reg_mem);
 8105 %}
 8106 
 8107 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 8108 %{
 8109   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8110   effect(KILL cr);
 8111 
 8112   ins_cost(150);
 8113   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8114   opcode(0x29); /* Opcode 29 /r */
 8115   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 8116   ins_pipe(ialu_mem_reg);
 8117 %}
 8118 
 8119 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
 8120 %{
 8121   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8122   effect(KILL cr);
 8123 
 8124   ins_cost(125); // XXX
 8125   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8126   opcode(0x81); /* Opcode 81 /5 id */
 8127   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8128   ins_pipe(ialu_mem_imm);
 8129 %}
 8130 
 8131 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8132 %{
 8133   match(Set dst (SubL dst src));
 8134   effect(KILL cr);
 8135 
 8136   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8137   opcode(0x2B);
 8138   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8139   ins_pipe(ialu_reg_reg);
 8140 %}
 8141 
 8142 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
 8143 %{
 8144   match(Set dst (SubL dst src));
 8145   effect(KILL cr);
 8146 
 8147   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8148   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8149   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 8150   ins_pipe(ialu_reg);
 8151 %}
 8152 
 8153 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 8154 %{
 8155   match(Set dst (SubL dst (LoadL src)));
 8156   effect(KILL cr);
 8157 
 8158   ins_cost(125);
 8159   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8160   opcode(0x2B);
 8161   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 8162   ins_pipe(ialu_reg_mem);
 8163 %}
 8164 
 8165 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 8166 %{
 8167   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8168   effect(KILL cr);
 8169 
 8170   ins_cost(150);
 8171   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8172   opcode(0x29); /* Opcode 29 /r */
 8173   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 8174   ins_pipe(ialu_mem_reg);
 8175 %}
 8176 
 8177 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 8178 %{
 8179   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8180   effect(KILL cr);
 8181 
 8182   ins_cost(125); // XXX
 8183   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8184   opcode(0x81); /* Opcode 81 /5 id */
 8185   ins_encode(REX_mem_wide(dst),
 8186              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8187   ins_pipe(ialu_mem_imm);
 8188 %}
 8189 
 8190 // Subtract from a pointer
 8191 // XXX hmpf???
 8192 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
 8193 %{
 8194   match(Set dst (AddP dst (SubI zero src)));
 8195   effect(KILL cr);
 8196 
 8197   format %{ &quot;subq    $dst, $src\t# ptr - int&quot; %}
 8198   opcode(0x2B);
 8199   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8200   ins_pipe(ialu_reg_reg);
 8201 %}
 8202 
 8203 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
 8204 %{
 8205   match(Set dst (SubI zero dst));
 8206   effect(KILL cr);
 8207 
 8208   format %{ &quot;negl    $dst\t# int&quot; %}
 8209   opcode(0xF7, 0x03);  // Opcode F7 /3
 8210   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8211   ins_pipe(ialu_reg);
 8212 %}
 8213 
 8214 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
 8215 %{
 8216   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
 8217   effect(KILL cr);
 8218 
 8219   format %{ &quot;negl    $dst\t# int&quot; %}
 8220   opcode(0xF7, 0x03);  // Opcode F7 /3
 8221   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8222   ins_pipe(ialu_reg);
 8223 %}
 8224 
 8225 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
 8226 %{
 8227   match(Set dst (SubL zero dst));
 8228   effect(KILL cr);
 8229 
 8230   format %{ &quot;negq    $dst\t# long&quot; %}
 8231   opcode(0xF7, 0x03);  // Opcode F7 /3
 8232   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8233   ins_pipe(ialu_reg);
 8234 %}
 8235 
 8236 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
 8237 %{
 8238   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
 8239   effect(KILL cr);
 8240 
 8241   format %{ &quot;negq    $dst\t# long&quot; %}
 8242   opcode(0xF7, 0x03);  // Opcode F7 /3
 8243   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8244   ins_pipe(ialu_reg);
 8245 %}
 8246 
 8247 //----------Multiplication/Division Instructions-------------------------------
 8248 // Integer Multiplication Instructions
 8249 // Multiply Register
 8250 
 8251 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8252 %{
 8253   match(Set dst (MulI dst src));
 8254   effect(KILL cr);
 8255 
 8256   ins_cost(300);
 8257   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8258   opcode(0x0F, 0xAF);
 8259   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8260   ins_pipe(ialu_reg_reg_alu0);
 8261 %}
 8262 
 8263 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
 8264 %{
 8265   match(Set dst (MulI src imm));
 8266   effect(KILL cr);
 8267 
 8268   ins_cost(300);
 8269   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8270   opcode(0x69); /* 69 /r id */
 8271   ins_encode(REX_reg_reg(dst, src),
 8272              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8273   ins_pipe(ialu_reg_reg_alu0);
 8274 %}
 8275 
 8276 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
 8277 %{
 8278   match(Set dst (MulI dst (LoadI src)));
 8279   effect(KILL cr);
 8280 
 8281   ins_cost(350);
 8282   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8283   opcode(0x0F, 0xAF);
 8284   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8285   ins_pipe(ialu_reg_mem_alu0);
 8286 %}
 8287 
 8288 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
 8289 %{
 8290   match(Set dst (MulI (LoadI src) imm));
 8291   effect(KILL cr);
 8292 
 8293   ins_cost(300);
 8294   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8295   opcode(0x69); /* 69 /r id */
 8296   ins_encode(REX_reg_mem(dst, src),
 8297              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8298   ins_pipe(ialu_reg_mem_alu0);
 8299 %}
 8300 
 8301 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)
 8302 %{
 8303   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 8304   effect(KILL cr, KILL src2);
 8305 
 8306   expand %{ mulI_rReg(dst, src1, cr);
 8307            mulI_rReg(src2, src3, cr);
 8308            addI_rReg(dst, src2, cr); %}
 8309 %}
 8310 
 8311 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8312 %{
 8313   match(Set dst (MulL dst src));
 8314   effect(KILL cr);
 8315 
 8316   ins_cost(300);
 8317   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8318   opcode(0x0F, 0xAF);
 8319   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8320   ins_pipe(ialu_reg_reg_alu0);
 8321 %}
 8322 
 8323 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
 8324 %{
 8325   match(Set dst (MulL src imm));
 8326   effect(KILL cr);
 8327 
 8328   ins_cost(300);
 8329   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8330   opcode(0x69); /* 69 /r id */
 8331   ins_encode(REX_reg_reg_wide(dst, src),
 8332              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8333   ins_pipe(ialu_reg_reg_alu0);
 8334 %}
 8335 
 8336 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
 8337 %{
 8338   match(Set dst (MulL dst (LoadL src)));
 8339   effect(KILL cr);
 8340 
 8341   ins_cost(350);
 8342   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8343   opcode(0x0F, 0xAF);
 8344   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8345   ins_pipe(ialu_reg_mem_alu0);
 8346 %}
 8347 
 8348 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
 8349 %{
 8350   match(Set dst (MulL (LoadL src) imm));
 8351   effect(KILL cr);
 8352 
 8353   ins_cost(300);
 8354   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8355   opcode(0x69); /* 69 /r id */
 8356   ins_encode(REX_reg_mem_wide(dst, src),
 8357              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8358   ins_pipe(ialu_reg_mem_alu0);
 8359 %}
 8360 
 8361 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8362 %{
 8363   match(Set dst (MulHiL src rax));
 8364   effect(USE_KILL rax, KILL cr);
 8365 
 8366   ins_cost(300);
 8367   format %{ &quot;imulq   RDX:RAX, RAX, $src\t# mulhi&quot; %}
 8368   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8369   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8370   ins_pipe(ialu_reg_reg_alu0);
 8371 %}
 8372 
 8373 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8374                    rFlagsReg cr)
 8375 %{
 8376   match(Set rax (DivI rax div));
 8377   effect(KILL rdx, KILL cr);
 8378 
 8379   ins_cost(30*100+10*100); // XXX
 8380   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8381             &quot;jne,s   normal\n\t&quot;
 8382             &quot;xorl    rdx, rdx\n\t&quot;
 8383             &quot;cmpl    $div, -1\n\t&quot;
 8384             &quot;je,s    done\n&quot;
 8385     &quot;normal: cdql\n\t&quot;
 8386             &quot;idivl   $div\n&quot;
 8387     &quot;done:&quot;        %}
 8388   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8389   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8390   ins_pipe(ialu_reg_reg_alu0);
 8391 %}
 8392 
 8393 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8394                    rFlagsReg cr)
 8395 %{
 8396   match(Set rax (DivL rax div));
 8397   effect(KILL rdx, KILL cr);
 8398 
 8399   ins_cost(30*100+10*100); // XXX
 8400   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8401             &quot;cmpq    rax, rdx\n\t&quot;
 8402             &quot;jne,s   normal\n\t&quot;
 8403             &quot;xorl    rdx, rdx\n\t&quot;
 8404             &quot;cmpq    $div, -1\n\t&quot;
 8405             &quot;je,s    done\n&quot;
 8406     &quot;normal: cdqq\n\t&quot;
 8407             &quot;idivq   $div\n&quot;
 8408     &quot;done:&quot;        %}
 8409   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8410   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8411   ins_pipe(ialu_reg_reg_alu0);
 8412 %}
 8413 
 8414 // Integer DIVMOD with Register, both quotient and mod results
 8415 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8416                              rFlagsReg cr)
 8417 %{
 8418   match(DivModI rax div);
 8419   effect(KILL cr);
 8420 
 8421   ins_cost(30*100+10*100); // XXX
 8422   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8423             &quot;jne,s   normal\n\t&quot;
 8424             &quot;xorl    rdx, rdx\n\t&quot;
 8425             &quot;cmpl    $div, -1\n\t&quot;
 8426             &quot;je,s    done\n&quot;
 8427     &quot;normal: cdql\n\t&quot;
 8428             &quot;idivl   $div\n&quot;
 8429     &quot;done:&quot;        %}
 8430   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8431   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8432   ins_pipe(pipe_slow);
 8433 %}
 8434 
 8435 // Long DIVMOD with Register, both quotient and mod results
 8436 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8437                              rFlagsReg cr)
 8438 %{
 8439   match(DivModL rax div);
 8440   effect(KILL cr);
 8441 
 8442   ins_cost(30*100+10*100); // XXX
 8443   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8444             &quot;cmpq    rax, rdx\n\t&quot;
 8445             &quot;jne,s   normal\n\t&quot;
 8446             &quot;xorl    rdx, rdx\n\t&quot;
 8447             &quot;cmpq    $div, -1\n\t&quot;
 8448             &quot;je,s    done\n&quot;
 8449     &quot;normal: cdqq\n\t&quot;
 8450             &quot;idivq   $div\n&quot;
 8451     &quot;done:&quot;        %}
 8452   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8453   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8454   ins_pipe(pipe_slow);
 8455 %}
 8456 
 8457 //----------- DivL-By-Constant-Expansions--------------------------------------
 8458 // DivI cases are handled by the compiler
 8459 
 8460 // Magic constant, reciprocal of 10
 8461 instruct loadConL_0x6666666666666667(rRegL dst)
 8462 %{
 8463   effect(DEF dst);
 8464 
 8465   format %{ &quot;movq    $dst, #0x666666666666667\t# Used in div-by-10&quot; %}
 8466   ins_encode(load_immL(dst, 0x6666666666666667));
 8467   ins_pipe(ialu_reg);
 8468 %}
 8469 
 8470 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8471 %{
 8472   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 8473 
 8474   format %{ &quot;imulq   rdx:rax, rax, $src\t# Used in div-by-10&quot; %}
 8475   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8476   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8477   ins_pipe(ialu_reg_reg_alu0);
 8478 %}
 8479 
 8480 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 8481 %{
 8482   effect(USE_DEF dst, KILL cr);
 8483 
 8484   format %{ &quot;sarq    $dst, #63\t# Used in div-by-10&quot; %}
 8485   opcode(0xC1, 0x7); /* C1 /7 ib */
 8486   ins_encode(reg_opc_imm_wide(dst, 0x3F));
 8487   ins_pipe(ialu_reg);
 8488 %}
 8489 
 8490 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 8491 %{
 8492   effect(USE_DEF dst, KILL cr);
 8493 
 8494   format %{ &quot;sarq    $dst, #2\t# Used in div-by-10&quot; %}
 8495   opcode(0xC1, 0x7); /* C1 /7 ib */
 8496   ins_encode(reg_opc_imm_wide(dst, 0x2));
 8497   ins_pipe(ialu_reg);
 8498 %}
 8499 
 8500 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
 8501 %{
 8502   match(Set dst (DivL src div));
 8503 
 8504   ins_cost((5+8)*100);
 8505   expand %{
 8506     rax_RegL rax;                     // Killed temp
 8507     rFlagsReg cr;                     // Killed
 8508     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
 8509     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
 8510     sarL_rReg_63(src, cr);            // sarq  src, 63
 8511     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
 8512     subL_rReg(dst, src, cr);          // subl  rdx, src
 8513   %}
 8514 %}
 8515 
 8516 //-----------------------------------------------------------------------------
 8517 
 8518 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
 8519                    rFlagsReg cr)
 8520 %{
 8521   match(Set rdx (ModI rax div));
 8522   effect(KILL rax, KILL cr);
 8523 
 8524   ins_cost(300); // XXX
 8525   format %{ &quot;cmpl    rax, 0x80000000\t# irem\n\t&quot;
 8526             &quot;jne,s   normal\n\t&quot;
 8527             &quot;xorl    rdx, rdx\n\t&quot;
 8528             &quot;cmpl    $div, -1\n\t&quot;
 8529             &quot;je,s    done\n&quot;
 8530     &quot;normal: cdql\n\t&quot;
 8531             &quot;idivl   $div\n&quot;
 8532     &quot;done:&quot;        %}
 8533   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8534   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8535   ins_pipe(ialu_reg_reg_alu0);
 8536 %}
 8537 
 8538 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
 8539                    rFlagsReg cr)
 8540 %{
 8541   match(Set rdx (ModL rax div));
 8542   effect(KILL rax, KILL cr);
 8543 
 8544   ins_cost(300); // XXX
 8545   format %{ &quot;movq    rdx, 0x8000000000000000\t# lrem\n\t&quot;
 8546             &quot;cmpq    rax, rdx\n\t&quot;
 8547             &quot;jne,s   normal\n\t&quot;
 8548             &quot;xorl    rdx, rdx\n\t&quot;
 8549             &quot;cmpq    $div, -1\n\t&quot;
 8550             &quot;je,s    done\n&quot;
 8551     &quot;normal: cdqq\n\t&quot;
 8552             &quot;idivq   $div\n&quot;
 8553     &quot;done:&quot;        %}
 8554   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8555   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8556   ins_pipe(ialu_reg_reg_alu0);
 8557 %}
 8558 
 8559 // Integer Shift Instructions
 8560 // Shift Left by one
 8561 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8562 %{
 8563   match(Set dst (LShiftI dst shift));
 8564   effect(KILL cr);
 8565 
 8566   format %{ &quot;sall    $dst, $shift&quot; %}
 8567   opcode(0xD1, 0x4); /* D1 /4 */
 8568   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8569   ins_pipe(ialu_reg);
 8570 %}
 8571 
 8572 // Shift Left by one
 8573 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8574 %{
 8575   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8576   effect(KILL cr);
 8577 
 8578   format %{ &quot;sall    $dst, $shift\t&quot; %}
 8579   opcode(0xD1, 0x4); /* D1 /4 */
 8580   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8581   ins_pipe(ialu_mem_imm);
 8582 %}
 8583 
 8584 // Shift Left by 8-bit immediate
 8585 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8586 %{
 8587   match(Set dst (LShiftI dst shift));
 8588   effect(KILL cr);
 8589 
 8590   format %{ &quot;sall    $dst, $shift&quot; %}
 8591   opcode(0xC1, 0x4); /* C1 /4 ib */
 8592   ins_encode(reg_opc_imm(dst, shift));
 8593   ins_pipe(ialu_reg);
 8594 %}
 8595 
 8596 // Shift Left by 8-bit immediate
 8597 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8598 %{
 8599   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8600   effect(KILL cr);
 8601 
 8602   format %{ &quot;sall    $dst, $shift&quot; %}
 8603   opcode(0xC1, 0x4); /* C1 /4 ib */
 8604   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8605   ins_pipe(ialu_mem_imm);
 8606 %}
 8607 
 8608 // Shift Left by variable
 8609 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8610 %{
 8611   match(Set dst (LShiftI dst shift));
 8612   effect(KILL cr);
 8613 
 8614   format %{ &quot;sall    $dst, $shift&quot; %}
 8615   opcode(0xD3, 0x4); /* D3 /4 */
 8616   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8617   ins_pipe(ialu_reg_reg);
 8618 %}
 8619 
 8620 // Shift Left by variable
 8621 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8622 %{
 8623   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8624   effect(KILL cr);
 8625 
 8626   format %{ &quot;sall    $dst, $shift&quot; %}
 8627   opcode(0xD3, 0x4); /* D3 /4 */
 8628   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8629   ins_pipe(ialu_mem_reg);
 8630 %}
 8631 
 8632 // Arithmetic shift right by one
 8633 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8634 %{
 8635   match(Set dst (RShiftI dst shift));
 8636   effect(KILL cr);
 8637 
 8638   format %{ &quot;sarl    $dst, $shift&quot; %}
 8639   opcode(0xD1, 0x7); /* D1 /7 */
 8640   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8641   ins_pipe(ialu_reg);
 8642 %}
 8643 
 8644 // Arithmetic shift right by one
 8645 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8646 %{
 8647   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8648   effect(KILL cr);
 8649 
 8650   format %{ &quot;sarl    $dst, $shift&quot; %}
 8651   opcode(0xD1, 0x7); /* D1 /7 */
 8652   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8653   ins_pipe(ialu_mem_imm);
 8654 %}
 8655 
 8656 // Arithmetic Shift Right by 8-bit immediate
 8657 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8658 %{
 8659   match(Set dst (RShiftI dst shift));
 8660   effect(KILL cr);
 8661 
 8662   format %{ &quot;sarl    $dst, $shift&quot; %}
 8663   opcode(0xC1, 0x7); /* C1 /7 ib */
 8664   ins_encode(reg_opc_imm(dst, shift));
 8665   ins_pipe(ialu_mem_imm);
 8666 %}
 8667 
 8668 // Arithmetic Shift Right by 8-bit immediate
 8669 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8670 %{
 8671   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8672   effect(KILL cr);
 8673 
 8674   format %{ &quot;sarl    $dst, $shift&quot; %}
 8675   opcode(0xC1, 0x7); /* C1 /7 ib */
 8676   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8677   ins_pipe(ialu_mem_imm);
 8678 %}
 8679 
 8680 // Arithmetic Shift Right by variable
 8681 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8682 %{
 8683   match(Set dst (RShiftI dst shift));
 8684   effect(KILL cr);
 8685 
 8686   format %{ &quot;sarl    $dst, $shift&quot; %}
 8687   opcode(0xD3, 0x7); /* D3 /7 */
 8688   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8689   ins_pipe(ialu_reg_reg);
 8690 %}
 8691 
 8692 // Arithmetic Shift Right by variable
 8693 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8694 %{
 8695   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8696   effect(KILL cr);
 8697 
 8698   format %{ &quot;sarl    $dst, $shift&quot; %}
 8699   opcode(0xD3, 0x7); /* D3 /7 */
 8700   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8701   ins_pipe(ialu_mem_reg);
 8702 %}
 8703 
 8704 // Logical shift right by one
 8705 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8706 %{
 8707   match(Set dst (URShiftI dst shift));
 8708   effect(KILL cr);
 8709 
 8710   format %{ &quot;shrl    $dst, $shift&quot; %}
 8711   opcode(0xD1, 0x5); /* D1 /5 */
 8712   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8713   ins_pipe(ialu_reg);
 8714 %}
 8715 
 8716 // Logical shift right by one
 8717 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8718 %{
 8719   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8720   effect(KILL cr);
 8721 
 8722   format %{ &quot;shrl    $dst, $shift&quot; %}
 8723   opcode(0xD1, 0x5); /* D1 /5 */
 8724   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8725   ins_pipe(ialu_mem_imm);
 8726 %}
 8727 
 8728 // Logical Shift Right by 8-bit immediate
 8729 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8730 %{
 8731   match(Set dst (URShiftI dst shift));
 8732   effect(KILL cr);
 8733 
 8734   format %{ &quot;shrl    $dst, $shift&quot; %}
 8735   opcode(0xC1, 0x5); /* C1 /5 ib */
 8736   ins_encode(reg_opc_imm(dst, shift));
 8737   ins_pipe(ialu_reg);
 8738 %}
 8739 
 8740 // Logical Shift Right by 8-bit immediate
 8741 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8742 %{
 8743   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8744   effect(KILL cr);
 8745 
 8746   format %{ &quot;shrl    $dst, $shift&quot; %}
 8747   opcode(0xC1, 0x5); /* C1 /5 ib */
 8748   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8749   ins_pipe(ialu_mem_imm);
 8750 %}
 8751 
 8752 // Logical Shift Right by variable
 8753 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8754 %{
 8755   match(Set dst (URShiftI dst shift));
 8756   effect(KILL cr);
 8757 
 8758   format %{ &quot;shrl    $dst, $shift&quot; %}
 8759   opcode(0xD3, 0x5); /* D3 /5 */
 8760   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8761   ins_pipe(ialu_reg_reg);
 8762 %}
 8763 
 8764 // Logical Shift Right by variable
 8765 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8766 %{
 8767   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8768   effect(KILL cr);
 8769 
 8770   format %{ &quot;shrl    $dst, $shift&quot; %}
 8771   opcode(0xD3, 0x5); /* D3 /5 */
 8772   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8773   ins_pipe(ialu_mem_reg);
 8774 %}
 8775 
 8776 // Long Shift Instructions
 8777 // Shift Left by one
 8778 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8779 %{
 8780   match(Set dst (LShiftL dst shift));
 8781   effect(KILL cr);
 8782 
 8783   format %{ &quot;salq    $dst, $shift&quot; %}
 8784   opcode(0xD1, 0x4); /* D1 /4 */
 8785   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8786   ins_pipe(ialu_reg);
 8787 %}
 8788 
 8789 // Shift Left by one
 8790 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8791 %{
 8792   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8793   effect(KILL cr);
 8794 
 8795   format %{ &quot;salq    $dst, $shift&quot; %}
 8796   opcode(0xD1, 0x4); /* D1 /4 */
 8797   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8798   ins_pipe(ialu_mem_imm);
 8799 %}
 8800 
 8801 // Shift Left by 8-bit immediate
 8802 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8803 %{
 8804   match(Set dst (LShiftL dst shift));
 8805   effect(KILL cr);
 8806 
 8807   format %{ &quot;salq    $dst, $shift&quot; %}
 8808   opcode(0xC1, 0x4); /* C1 /4 ib */
 8809   ins_encode(reg_opc_imm_wide(dst, shift));
 8810   ins_pipe(ialu_reg);
 8811 %}
 8812 
 8813 // Shift Left by 8-bit immediate
 8814 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8815 %{
 8816   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8817   effect(KILL cr);
 8818 
 8819   format %{ &quot;salq    $dst, $shift&quot; %}
 8820   opcode(0xC1, 0x4); /* C1 /4 ib */
 8821   ins_encode(REX_mem_wide(dst), OpcP,
 8822              RM_opc_mem(secondary, dst), Con8or32(shift));
 8823   ins_pipe(ialu_mem_imm);
 8824 %}
 8825 
 8826 // Shift Left by variable
 8827 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8828 %{
 8829   match(Set dst (LShiftL dst shift));
 8830   effect(KILL cr);
 8831 
 8832   format %{ &quot;salq    $dst, $shift&quot; %}
 8833   opcode(0xD3, 0x4); /* D3 /4 */
 8834   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8835   ins_pipe(ialu_reg_reg);
 8836 %}
 8837 
 8838 // Shift Left by variable
 8839 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8840 %{
 8841   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8842   effect(KILL cr);
 8843 
 8844   format %{ &quot;salq    $dst, $shift&quot; %}
 8845   opcode(0xD3, 0x4); /* D3 /4 */
 8846   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8847   ins_pipe(ialu_mem_reg);
 8848 %}
 8849 
 8850 // Arithmetic shift right by one
 8851 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8852 %{
 8853   match(Set dst (RShiftL dst shift));
 8854   effect(KILL cr);
 8855 
 8856   format %{ &quot;sarq    $dst, $shift&quot; %}
 8857   opcode(0xD1, 0x7); /* D1 /7 */
 8858   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8859   ins_pipe(ialu_reg);
 8860 %}
 8861 
 8862 // Arithmetic shift right by one
 8863 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8864 %{
 8865   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8866   effect(KILL cr);
 8867 
 8868   format %{ &quot;sarq    $dst, $shift&quot; %}
 8869   opcode(0xD1, 0x7); /* D1 /7 */
 8870   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8871   ins_pipe(ialu_mem_imm);
 8872 %}
 8873 
 8874 // Arithmetic Shift Right by 8-bit immediate
 8875 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8876 %{
 8877   match(Set dst (RShiftL dst shift));
 8878   effect(KILL cr);
 8879 
 8880   format %{ &quot;sarq    $dst, $shift&quot; %}
 8881   opcode(0xC1, 0x7); /* C1 /7 ib */
 8882   ins_encode(reg_opc_imm_wide(dst, shift));
 8883   ins_pipe(ialu_mem_imm);
 8884 %}
 8885 
 8886 // Arithmetic Shift Right by 8-bit immediate
 8887 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8888 %{
 8889   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8890   effect(KILL cr);
 8891 
 8892   format %{ &quot;sarq    $dst, $shift&quot; %}
 8893   opcode(0xC1, 0x7); /* C1 /7 ib */
 8894   ins_encode(REX_mem_wide(dst), OpcP,
 8895              RM_opc_mem(secondary, dst), Con8or32(shift));
 8896   ins_pipe(ialu_mem_imm);
 8897 %}
 8898 
 8899 // Arithmetic Shift Right by variable
 8900 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8901 %{
 8902   match(Set dst (RShiftL dst shift));
 8903   effect(KILL cr);
 8904 
 8905   format %{ &quot;sarq    $dst, $shift&quot; %}
 8906   opcode(0xD3, 0x7); /* D3 /7 */
 8907   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8908   ins_pipe(ialu_reg_reg);
 8909 %}
 8910 
 8911 // Arithmetic Shift Right by variable
 8912 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8913 %{
 8914   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8915   effect(KILL cr);
 8916 
 8917   format %{ &quot;sarq    $dst, $shift&quot; %}
 8918   opcode(0xD3, 0x7); /* D3 /7 */
 8919   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8920   ins_pipe(ialu_mem_reg);
 8921 %}
 8922 
 8923 // Logical shift right by one
 8924 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8925 %{
 8926   match(Set dst (URShiftL dst shift));
 8927   effect(KILL cr);
 8928 
 8929   format %{ &quot;shrq    $dst, $shift&quot; %}
 8930   opcode(0xD1, 0x5); /* D1 /5 */
 8931   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
 8932   ins_pipe(ialu_reg);
 8933 %}
 8934 
 8935 // Logical shift right by one
 8936 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8937 %{
 8938   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8939   effect(KILL cr);
 8940 
 8941   format %{ &quot;shrq    $dst, $shift&quot; %}
 8942   opcode(0xD1, 0x5); /* D1 /5 */
 8943   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8944   ins_pipe(ialu_mem_imm);
 8945 %}
 8946 
 8947 // Logical Shift Right by 8-bit immediate
 8948 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8949 %{
 8950   match(Set dst (URShiftL dst shift));
 8951   effect(KILL cr);
 8952 
 8953   format %{ &quot;shrq    $dst, $shift&quot; %}
 8954   opcode(0xC1, 0x5); /* C1 /5 ib */
 8955   ins_encode(reg_opc_imm_wide(dst, shift));
 8956   ins_pipe(ialu_reg);
 8957 %}
 8958 
 8959 
 8960 // Logical Shift Right by 8-bit immediate
 8961 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8962 %{
 8963   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8964   effect(KILL cr);
 8965 
 8966   format %{ &quot;shrq    $dst, $shift&quot; %}
 8967   opcode(0xC1, 0x5); /* C1 /5 ib */
 8968   ins_encode(REX_mem_wide(dst), OpcP,
 8969              RM_opc_mem(secondary, dst), Con8or32(shift));
 8970   ins_pipe(ialu_mem_imm);
 8971 %}
 8972 
 8973 // Logical Shift Right by variable
 8974 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8975 %{
 8976   match(Set dst (URShiftL dst shift));
 8977   effect(KILL cr);
 8978 
 8979   format %{ &quot;shrq    $dst, $shift&quot; %}
 8980   opcode(0xD3, 0x5); /* D3 /5 */
 8981   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8982   ins_pipe(ialu_reg_reg);
 8983 %}
 8984 
 8985 // Logical Shift Right by variable
 8986 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8987 %{
 8988   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8989   effect(KILL cr);
 8990 
 8991   format %{ &quot;shrq    $dst, $shift&quot; %}
 8992   opcode(0xD3, 0x5); /* D3 /5 */
 8993   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8994   ins_pipe(ialu_mem_reg);
 8995 %}
 8996 
 8997 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 8998 // This idiom is used by the compiler for the i2b bytecode.
 8999 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
 9000 %{
 9001   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 9002 
 9003   format %{ &quot;movsbl  $dst, $src\t# i2b&quot; %}
 9004   opcode(0x0F, 0xBE);
 9005   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9006   ins_pipe(ialu_reg_reg);
 9007 %}
 9008 
 9009 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 9010 // This idiom is used by the compiler the i2s bytecode.
 9011 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
 9012 %{
 9013   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 9014 
 9015   format %{ &quot;movswl  $dst, $src\t# i2s&quot; %}
 9016   opcode(0x0F, 0xBF);
 9017   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9018   ins_pipe(ialu_reg_reg);
 9019 %}
 9020 
 9021 // ROL/ROR instructions
 9022 
 9023 // ROL expand
 9024 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
 9025   effect(KILL cr, USE_DEF dst);
 9026 
 9027   format %{ &quot;roll    $dst&quot; %}
 9028   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9029   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9030   ins_pipe(ialu_reg);
 9031 %}
 9032 
 9033 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
 9034   effect(USE_DEF dst, USE shift, KILL cr);
 9035 
 9036   format %{ &quot;roll    $dst, $shift&quot; %}
 9037   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9038   ins_encode( reg_opc_imm(dst, shift) );
 9039   ins_pipe(ialu_reg);
 9040 %}
 9041 
 9042 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9043 %{
 9044   effect(USE_DEF dst, USE shift, KILL cr);
 9045 
 9046   format %{ &quot;roll    $dst, $shift&quot; %}
 9047   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9048   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9049   ins_pipe(ialu_reg_reg);
 9050 %}
 9051 // end of ROL expand
 9052 
 9053 // Rotate Left by one
 9054 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9055 %{
 9056   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9057 
 9058   expand %{
 9059     rolI_rReg_imm1(dst, cr);
 9060   %}
 9061 %}
 9062 
 9063 // Rotate Left by 8-bit immediate
 9064 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9065 %{
 9066   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9067   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9068 
 9069   expand %{
 9070     rolI_rReg_imm8(dst, lshift, cr);
 9071   %}
 9072 %}
 9073 
 9074 // Rotate Left by variable
 9075 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9076 %{
 9077   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 9078 
 9079   expand %{
 9080     rolI_rReg_CL(dst, shift, cr);
 9081   %}
 9082 %}
 9083 
 9084 // Rotate Left by variable
 9085 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9086 %{
 9087   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 9088 
 9089   expand %{
 9090     rolI_rReg_CL(dst, shift, cr);
 9091   %}
 9092 %}
 9093 
 9094 // ROR expand
 9095 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
 9096 %{
 9097   effect(USE_DEF dst, KILL cr);
 9098 
 9099   format %{ &quot;rorl    $dst&quot; %}
 9100   opcode(0xD1, 0x1); /* D1 /1 */
 9101   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9102   ins_pipe(ialu_reg);
 9103 %}
 9104 
 9105 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
 9106 %{
 9107   effect(USE_DEF dst, USE shift, KILL cr);
 9108 
 9109   format %{ &quot;rorl    $dst, $shift&quot; %}
 9110   opcode(0xC1, 0x1); /* C1 /1 ib */
 9111   ins_encode(reg_opc_imm(dst, shift));
 9112   ins_pipe(ialu_reg);
 9113 %}
 9114 
 9115 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9116 %{
 9117   effect(USE_DEF dst, USE shift, KILL cr);
 9118 
 9119   format %{ &quot;rorl    $dst, $shift&quot; %}
 9120   opcode(0xD3, 0x1); /* D3 /1 */
 9121   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9122   ins_pipe(ialu_reg_reg);
 9123 %}
 9124 // end of ROR expand
 9125 
 9126 // Rotate Right by one
 9127 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9128 %{
 9129   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9130 
 9131   expand %{
 9132     rorI_rReg_imm1(dst, cr);
 9133   %}
 9134 %}
 9135 
 9136 // Rotate Right by 8-bit immediate
 9137 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9138 %{
 9139   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9140   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9141 
 9142   expand %{
 9143     rorI_rReg_imm8(dst, rshift, cr);
 9144   %}
 9145 %}
 9146 
 9147 // Rotate Right by variable
 9148 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9149 %{
 9150   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 9151 
 9152   expand %{
 9153     rorI_rReg_CL(dst, shift, cr);
 9154   %}
 9155 %}
 9156 
 9157 // Rotate Right by variable
 9158 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9159 %{
 9160   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 9161 
 9162   expand %{
 9163     rorI_rReg_CL(dst, shift, cr);
 9164   %}
 9165 %}
 9166 
 9167 // for long rotate
 9168 // ROL expand
 9169 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
 9170   effect(USE_DEF dst, KILL cr);
 9171 
 9172   format %{ &quot;rolq    $dst&quot; %}
 9173   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9174   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9175   ins_pipe(ialu_reg);
 9176 %}
 9177 
 9178 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
 9179   effect(USE_DEF dst, USE shift, KILL cr);
 9180 
 9181   format %{ &quot;rolq    $dst, $shift&quot; %}
 9182   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9183   ins_encode( reg_opc_imm_wide(dst, shift) );
 9184   ins_pipe(ialu_reg);
 9185 %}
 9186 
 9187 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9188 %{
 9189   effect(USE_DEF dst, USE shift, KILL cr);
 9190 
 9191   format %{ &quot;rolq    $dst, $shift&quot; %}
 9192   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9193   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9194   ins_pipe(ialu_reg_reg);
 9195 %}
 9196 // end of ROL expand
 9197 
 9198 // Rotate Left by one
 9199 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9200 %{
 9201   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9202 
 9203   expand %{
 9204     rolL_rReg_imm1(dst, cr);
 9205   %}
 9206 %}
 9207 
 9208 // Rotate Left by 8-bit immediate
 9209 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9210 %{
 9211   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9212   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9213 
 9214   expand %{
 9215     rolL_rReg_imm8(dst, lshift, cr);
 9216   %}
 9217 %}
 9218 
 9219 // Rotate Left by variable
 9220 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9221 %{
 9222   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
 9223 
 9224   expand %{
 9225     rolL_rReg_CL(dst, shift, cr);
 9226   %}
 9227 %}
 9228 
 9229 // Rotate Left by variable
 9230 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9231 %{
 9232   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
 9233 
 9234   expand %{
 9235     rolL_rReg_CL(dst, shift, cr);
 9236   %}
 9237 %}
 9238 
 9239 // ROR expand
 9240 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
 9241 %{
 9242   effect(USE_DEF dst, KILL cr);
 9243 
 9244   format %{ &quot;rorq    $dst&quot; %}
 9245   opcode(0xD1, 0x1); /* D1 /1 */
 9246   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9247   ins_pipe(ialu_reg);
 9248 %}
 9249 
 9250 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
 9251 %{
 9252   effect(USE_DEF dst, USE shift, KILL cr);
 9253 
 9254   format %{ &quot;rorq    $dst, $shift&quot; %}
 9255   opcode(0xC1, 0x1); /* C1 /1 ib */
 9256   ins_encode(reg_opc_imm_wide(dst, shift));
 9257   ins_pipe(ialu_reg);
 9258 %}
 9259 
 9260 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9261 %{
 9262   effect(USE_DEF dst, USE shift, KILL cr);
 9263 
 9264   format %{ &quot;rorq    $dst, $shift&quot; %}
 9265   opcode(0xD3, 0x1); /* D3 /1 */
 9266   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9267   ins_pipe(ialu_reg_reg);
 9268 %}
 9269 // end of ROR expand
 9270 
 9271 // Rotate Right by one
 9272 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9273 %{
 9274   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9275 
 9276   expand %{
 9277     rorL_rReg_imm1(dst, cr);
 9278   %}
 9279 %}
 9280 
 9281 // Rotate Right by 8-bit immediate
 9282 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9283 %{
 9284   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9285   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9286 
 9287   expand %{
 9288     rorL_rReg_imm8(dst, rshift, cr);
 9289   %}
 9290 %}
 9291 
 9292 // Rotate Right by variable
 9293 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9294 %{
 9295   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
 9296 
 9297   expand %{
 9298     rorL_rReg_CL(dst, shift, cr);
 9299   %}
 9300 %}
 9301 
 9302 // Rotate Right by variable
 9303 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9304 %{
 9305   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
 9306 
 9307   expand %{
 9308     rorL_rReg_CL(dst, shift, cr);
 9309   %}
 9310 %}
 9311 
 9312 // Logical Instructions
 9313 
 9314 // Integer Logical Instructions
 9315 
 9316 // And Instructions
 9317 // And Register with Register
 9318 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9319 %{
 9320   match(Set dst (AndI dst src));
 9321   effect(KILL cr);
 9322 
 9323   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9324   opcode(0x23);
 9325   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9326   ins_pipe(ialu_reg_reg);
 9327 %}
 9328 
 9329 // And Register with Immediate 255
 9330 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
 9331 %{
 9332   match(Set dst (AndI dst src));
 9333 
 9334   format %{ &quot;movzbl  $dst, $dst\t# int &amp; 0xFF&quot; %}
 9335   opcode(0x0F, 0xB6);
 9336   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9337   ins_pipe(ialu_reg);
 9338 %}
 9339 
 9340 // And Register with Immediate 255 and promote to long
 9341 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
 9342 %{
 9343   match(Set dst (ConvI2L (AndI src mask)));
 9344 
 9345   format %{ &quot;movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long&quot; %}
 9346   opcode(0x0F, 0xB6);
 9347   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9348   ins_pipe(ialu_reg);
 9349 %}
 9350 
 9351 // And Register with Immediate 65535
 9352 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
 9353 %{
 9354   match(Set dst (AndI dst src));
 9355 
 9356   format %{ &quot;movzwl  $dst, $dst\t# int &amp; 0xFFFF&quot; %}
 9357   opcode(0x0F, 0xB7);
 9358   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9359   ins_pipe(ialu_reg);
 9360 %}
 9361 
 9362 // And Register with Immediate 65535 and promote to long
 9363 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
 9364 %{
 9365   match(Set dst (ConvI2L (AndI src mask)));
 9366 
 9367   format %{ &quot;movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long&quot; %}
 9368   opcode(0x0F, 0xB7);
 9369   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9370   ins_pipe(ialu_reg);
 9371 %}
 9372 
 9373 // And Register with Immediate
 9374 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9375 %{
 9376   match(Set dst (AndI dst src));
 9377   effect(KILL cr);
 9378 
 9379   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9380   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9381   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9382   ins_pipe(ialu_reg);
 9383 %}
 9384 
 9385 // And Register with Memory
 9386 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9387 %{
 9388   match(Set dst (AndI dst (LoadI src)));
 9389   effect(KILL cr);
 9390 
 9391   ins_cost(125);
 9392   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9393   opcode(0x23);
 9394   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9395   ins_pipe(ialu_reg_mem);
 9396 %}
 9397 
 9398 // And Memory with Register
 9399 instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9400 %{
 9401   match(Set dst (StoreB dst (AndI (LoadB dst) src)));
 9402   effect(KILL cr);
 9403 
 9404   ins_cost(150);
 9405   format %{ &quot;andb    $dst, $src\t# byte&quot; %}
 9406   opcode(0x20);
 9407   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9408   ins_pipe(ialu_mem_reg);
 9409 %}
 9410 
 9411 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9412 %{
 9413   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9414   effect(KILL cr);
 9415 
 9416   ins_cost(150);
 9417   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9418   opcode(0x21); /* Opcode 21 /r */
 9419   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9420   ins_pipe(ialu_mem_reg);
 9421 %}
 9422 
 9423 // And Memory with Immediate
 9424 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9425 %{
 9426   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9427   effect(KILL cr);
 9428 
 9429   ins_cost(125);
 9430   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9431   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9432   ins_encode(REX_mem(dst), OpcSE(src),
 9433              RM_opc_mem(secondary, dst), Con8or32(src));
 9434   ins_pipe(ialu_mem_imm);
 9435 %}
 9436 
 9437 // BMI1 instructions
 9438 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
 9439   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
 9440   predicate(UseBMI1Instructions);
 9441   effect(KILL cr);
 9442 
 9443   ins_cost(125);
 9444   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9445 
 9446   ins_encode %{
 9447     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 9448   %}
 9449   ins_pipe(ialu_reg_mem);
 9450 %}
 9451 
 9452 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
 9453   match(Set dst (AndI (XorI src1 minus_1) src2));
 9454   predicate(UseBMI1Instructions);
 9455   effect(KILL cr);
 9456 
 9457   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9458 
 9459   ins_encode %{
 9460     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 9461   %}
 9462   ins_pipe(ialu_reg);
 9463 %}
 9464 
 9465 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
 9466   match(Set dst (AndI (SubI imm_zero src) src));
 9467   predicate(UseBMI1Instructions);
 9468   effect(KILL cr);
 9469 
 9470   format %{ &quot;blsil  $dst, $src&quot; %}
 9471 
 9472   ins_encode %{
 9473     __ blsil($dst$$Register, $src$$Register);
 9474   %}
 9475   ins_pipe(ialu_reg);
 9476 %}
 9477 
 9478 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
 9479   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 9480   predicate(UseBMI1Instructions);
 9481   effect(KILL cr);
 9482 
 9483   ins_cost(125);
 9484   format %{ &quot;blsil  $dst, $src&quot; %}
 9485 
 9486   ins_encode %{
 9487     __ blsil($dst$$Register, $src$$Address);
 9488   %}
 9489   ins_pipe(ialu_reg_mem);
 9490 %}
 9491 
 9492 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9493 %{
 9494   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9495   predicate(UseBMI1Instructions);
 9496   effect(KILL cr);
 9497 
 9498   ins_cost(125);
 9499   format %{ &quot;blsmskl $dst, $src&quot; %}
 9500 
 9501   ins_encode %{
 9502     __ blsmskl($dst$$Register, $src$$Address);
 9503   %}
 9504   ins_pipe(ialu_reg_mem);
 9505 %}
 9506 
 9507 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9508 %{
 9509   match(Set dst (XorI (AddI src minus_1) src));
 9510   predicate(UseBMI1Instructions);
 9511   effect(KILL cr);
 9512 
 9513   format %{ &quot;blsmskl $dst, $src&quot; %}
 9514 
 9515   ins_encode %{
 9516     __ blsmskl($dst$$Register, $src$$Register);
 9517   %}
 9518 
 9519   ins_pipe(ialu_reg);
 9520 %}
 9521 
 9522 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9523 %{
 9524   match(Set dst (AndI (AddI src minus_1) src) );
 9525   predicate(UseBMI1Instructions);
 9526   effect(KILL cr);
 9527 
 9528   format %{ &quot;blsrl  $dst, $src&quot; %}
 9529 
 9530   ins_encode %{
 9531     __ blsrl($dst$$Register, $src$$Register);
 9532   %}
 9533 
 9534   ins_pipe(ialu_reg_mem);
 9535 %}
 9536 
 9537 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9538 %{
 9539   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9540   predicate(UseBMI1Instructions);
 9541   effect(KILL cr);
 9542 
 9543   ins_cost(125);
 9544   format %{ &quot;blsrl  $dst, $src&quot; %}
 9545 
 9546   ins_encode %{
 9547     __ blsrl($dst$$Register, $src$$Address);
 9548   %}
 9549 
 9550   ins_pipe(ialu_reg);
 9551 %}
 9552 
 9553 // Or Instructions
 9554 // Or Register with Register
 9555 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9556 %{
 9557   match(Set dst (OrI dst src));
 9558   effect(KILL cr);
 9559 
 9560   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9561   opcode(0x0B);
 9562   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9563   ins_pipe(ialu_reg_reg);
 9564 %}
 9565 
 9566 // Or Register with Immediate
 9567 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9568 %{
 9569   match(Set dst (OrI dst src));
 9570   effect(KILL cr);
 9571 
 9572   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9573   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9574   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9575   ins_pipe(ialu_reg);
 9576 %}
 9577 
 9578 // Or Register with Memory
 9579 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9580 %{
 9581   match(Set dst (OrI dst (LoadI src)));
 9582   effect(KILL cr);
 9583 
 9584   ins_cost(125);
 9585   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9586   opcode(0x0B);
 9587   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9588   ins_pipe(ialu_reg_mem);
 9589 %}
 9590 
 9591 // Or Memory with Register
 9592 instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9593 %{
 9594   match(Set dst (StoreB dst (OrI (LoadB dst) src)));
 9595   effect(KILL cr);
 9596 
 9597   ins_cost(150);
 9598   format %{ &quot;orb    $dst, $src\t# byte&quot; %}
 9599   opcode(0x08);
 9600   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9601   ins_pipe(ialu_mem_reg);
 9602 %}
 9603 
 9604 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9605 %{
 9606   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9607   effect(KILL cr);
 9608 
 9609   ins_cost(150);
 9610   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9611   opcode(0x09); /* Opcode 09 /r */
 9612   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9613   ins_pipe(ialu_mem_reg);
 9614 %}
 9615 
 9616 // Or Memory with Immediate
 9617 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9618 %{
 9619   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9620   effect(KILL cr);
 9621 
 9622   ins_cost(125);
 9623   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9624   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9625   ins_encode(REX_mem(dst), OpcSE(src),
 9626              RM_opc_mem(secondary, dst), Con8or32(src));
 9627   ins_pipe(ialu_mem_imm);
 9628 %}
 9629 
 9630 // Xor Instructions
 9631 // Xor Register with Register
 9632 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9633 %{
 9634   match(Set dst (XorI dst src));
 9635   effect(KILL cr);
 9636 
 9637   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9638   opcode(0x33);
 9639   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9640   ins_pipe(ialu_reg_reg);
 9641 %}
 9642 
 9643 // Xor Register with Immediate -1
 9644 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
 9645   match(Set dst (XorI dst imm));
 9646 
 9647   format %{ &quot;not    $dst&quot; %}
 9648   ins_encode %{
 9649      __ notl($dst$$Register);
 9650   %}
 9651   ins_pipe(ialu_reg);
 9652 %}
 9653 
 9654 // Xor Register with Immediate
 9655 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9656 %{
 9657   match(Set dst (XorI dst src));
 9658   effect(KILL cr);
 9659 
 9660   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9661   opcode(0x81, 0x06); /* Opcode 81 /6 id */
 9662   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9663   ins_pipe(ialu_reg);
 9664 %}
 9665 
 9666 // Xor Register with Memory
 9667 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9668 %{
 9669   match(Set dst (XorI dst (LoadI src)));
 9670   effect(KILL cr);
 9671 
 9672   ins_cost(125);
 9673   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9674   opcode(0x33);
 9675   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9676   ins_pipe(ialu_reg_mem);
 9677 %}
 9678 
 9679 // Xor Memory with Register
 9680 instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9681 %{
 9682   match(Set dst (StoreB dst (XorI (LoadB dst) src)));
 9683   effect(KILL cr);
 9684 
 9685   ins_cost(150);
 9686   format %{ &quot;xorb    $dst, $src\t# byte&quot; %}
 9687   opcode(0x30);
 9688   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9689   ins_pipe(ialu_mem_reg);
 9690 %}
 9691 
 9692 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9693 %{
 9694   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9695   effect(KILL cr);
 9696 
 9697   ins_cost(150);
 9698   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9699   opcode(0x31); /* Opcode 31 /r */
 9700   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9701   ins_pipe(ialu_mem_reg);
 9702 %}
 9703 
 9704 // Xor Memory with Immediate
 9705 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9706 %{
 9707   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9708   effect(KILL cr);
 9709 
 9710   ins_cost(125);
 9711   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9712   opcode(0x81, 0x6); /* Opcode 81 /6 id */
 9713   ins_encode(REX_mem(dst), OpcSE(src),
 9714              RM_opc_mem(secondary, dst), Con8or32(src));
 9715   ins_pipe(ialu_mem_imm);
 9716 %}
 9717 
 9718 
 9719 // Long Logical Instructions
 9720 
 9721 // And Instructions
 9722 // And Register with Register
 9723 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9724 %{
 9725   match(Set dst (AndL dst src));
 9726   effect(KILL cr);
 9727 
 9728   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9729   opcode(0x23);
 9730   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9731   ins_pipe(ialu_reg_reg);
 9732 %}
 9733 
 9734 // And Register with Immediate 255
 9735 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
 9736 %{
 9737   match(Set dst (AndL dst src));
 9738 
 9739   format %{ &quot;movzbq  $dst, $dst\t# long &amp; 0xFF&quot; %}
 9740   opcode(0x0F, 0xB6);
 9741   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9742   ins_pipe(ialu_reg);
 9743 %}
 9744 
 9745 // And Register with Immediate 65535
 9746 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
 9747 %{
 9748   match(Set dst (AndL dst src));
 9749 
 9750   format %{ &quot;movzwq  $dst, $dst\t# long &amp; 0xFFFF&quot; %}
 9751   opcode(0x0F, 0xB7);
 9752   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9753   ins_pipe(ialu_reg);
 9754 %}
 9755 
 9756 // And Register with Immediate
 9757 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9758 %{
 9759   match(Set dst (AndL dst src));
 9760   effect(KILL cr);
 9761 
 9762   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9763   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9764   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9765   ins_pipe(ialu_reg);
 9766 %}
 9767 
 9768 // And Register with Memory
 9769 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9770 %{
 9771   match(Set dst (AndL dst (LoadL src)));
 9772   effect(KILL cr);
 9773 
 9774   ins_cost(125);
 9775   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9776   opcode(0x23);
 9777   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9778   ins_pipe(ialu_reg_mem);
 9779 %}
 9780 
 9781 // And Memory with Register
 9782 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9783 %{
 9784   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9785   effect(KILL cr);
 9786 
 9787   ins_cost(150);
 9788   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9789   opcode(0x21); /* Opcode 21 /r */
 9790   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9791   ins_pipe(ialu_mem_reg);
 9792 %}
 9793 
 9794 // And Memory with Immediate
 9795 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9796 %{
 9797   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9798   effect(KILL cr);
 9799 
 9800   ins_cost(125);
 9801   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9802   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9803   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9804              RM_opc_mem(secondary, dst), Con8or32(src));
 9805   ins_pipe(ialu_mem_imm);
 9806 %}
 9807 
 9808 instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)
 9809 %{
 9810   // con should be a pure 64-bit immediate given that not(con) is a power of 2
 9811   // because AND/OR works well enough for 8/32-bit values.
 9812   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);
 9813 
 9814   match(Set dst (StoreL dst (AndL (LoadL dst) con)));
 9815   effect(KILL cr);
 9816 
 9817   ins_cost(125);
 9818   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}
 9819   ins_encode %{
 9820     __ btrq($dst$$Address, log2_long(~$con$$constant));
 9821   %}
 9822   ins_pipe(ialu_mem_imm);
 9823 %}
 9824 
 9825 // BMI1 instructions
 9826 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9827   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9828   predicate(UseBMI1Instructions);
 9829   effect(KILL cr);
 9830 
 9831   ins_cost(125);
 9832   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9833 
 9834   ins_encode %{
 9835     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9836   %}
 9837   ins_pipe(ialu_reg_mem);
 9838 %}
 9839 
 9840 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9841   match(Set dst (AndL (XorL src1 minus_1) src2));
 9842   predicate(UseBMI1Instructions);
 9843   effect(KILL cr);
 9844 
 9845   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9846 
 9847   ins_encode %{
 9848   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
 9849   %}
 9850   ins_pipe(ialu_reg_mem);
 9851 %}
 9852 
 9853 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
 9854   match(Set dst (AndL (SubL imm_zero src) src));
 9855   predicate(UseBMI1Instructions);
 9856   effect(KILL cr);
 9857 
 9858   format %{ &quot;blsiq  $dst, $src&quot; %}
 9859 
 9860   ins_encode %{
 9861     __ blsiq($dst$$Register, $src$$Register);
 9862   %}
 9863   ins_pipe(ialu_reg);
 9864 %}
 9865 
 9866 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
 9867   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9868   predicate(UseBMI1Instructions);
 9869   effect(KILL cr);
 9870 
 9871   ins_cost(125);
 9872   format %{ &quot;blsiq  $dst, $src&quot; %}
 9873 
 9874   ins_encode %{
 9875     __ blsiq($dst$$Register, $src$$Address);
 9876   %}
 9877   ins_pipe(ialu_reg_mem);
 9878 %}
 9879 
 9880 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9881 %{
 9882   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
 9883   predicate(UseBMI1Instructions);
 9884   effect(KILL cr);
 9885 
 9886   ins_cost(125);
 9887   format %{ &quot;blsmskq $dst, $src&quot; %}
 9888 
 9889   ins_encode %{
 9890     __ blsmskq($dst$$Register, $src$$Address);
 9891   %}
 9892   ins_pipe(ialu_reg_mem);
 9893 %}
 9894 
 9895 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9896 %{
 9897   match(Set dst (XorL (AddL src minus_1) src));
 9898   predicate(UseBMI1Instructions);
 9899   effect(KILL cr);
 9900 
 9901   format %{ &quot;blsmskq $dst, $src&quot; %}
 9902 
 9903   ins_encode %{
 9904     __ blsmskq($dst$$Register, $src$$Register);
 9905   %}
 9906 
 9907   ins_pipe(ialu_reg);
 9908 %}
 9909 
 9910 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9911 %{
 9912   match(Set dst (AndL (AddL src minus_1) src) );
 9913   predicate(UseBMI1Instructions);
 9914   effect(KILL cr);
 9915 
 9916   format %{ &quot;blsrq  $dst, $src&quot; %}
 9917 
 9918   ins_encode %{
 9919     __ blsrq($dst$$Register, $src$$Register);
 9920   %}
 9921 
 9922   ins_pipe(ialu_reg);
 9923 %}
 9924 
 9925 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9926 %{
 9927   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
 9928   predicate(UseBMI1Instructions);
 9929   effect(KILL cr);
 9930 
 9931   ins_cost(125);
 9932   format %{ &quot;blsrq  $dst, $src&quot; %}
 9933 
 9934   ins_encode %{
 9935     __ blsrq($dst$$Register, $src$$Address);
 9936   %}
 9937 
 9938   ins_pipe(ialu_reg);
 9939 %}
 9940 
 9941 // Or Instructions
 9942 // Or Register with Register
 9943 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9944 %{
 9945   match(Set dst (OrL dst src));
 9946   effect(KILL cr);
 9947 
 9948   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9949   opcode(0x0B);
 9950   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9951   ins_pipe(ialu_reg_reg);
 9952 %}
 9953 
 9954 // Use any_RegP to match R15 (TLS register) without spilling.
 9955 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
 9956   match(Set dst (OrL dst (CastP2X src)));
 9957   effect(KILL cr);
 9958 
 9959   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9960   opcode(0x0B);
 9961   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9962   ins_pipe(ialu_reg_reg);
 9963 %}
 9964 
 9965 
 9966 // Or Register with Immediate
 9967 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9968 %{
 9969   match(Set dst (OrL dst src));
 9970   effect(KILL cr);
 9971 
 9972   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9973   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9974   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9975   ins_pipe(ialu_reg);
 9976 %}
 9977 
 9978 // Or Register with Memory
 9979 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9980 %{
 9981   match(Set dst (OrL dst (LoadL src)));
 9982   effect(KILL cr);
 9983 
 9984   ins_cost(125);
 9985   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9986   opcode(0x0B);
 9987   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9988   ins_pipe(ialu_reg_mem);
 9989 %}
 9990 
 9991 // Or Memory with Register
 9992 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9993 %{
 9994   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
 9995   effect(KILL cr);
 9996 
 9997   ins_cost(150);
 9998   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9999   opcode(0x09); /* Opcode 09 /r */
10000   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10001   ins_pipe(ialu_mem_reg);
10002 %}
10003 
10004 // Or Memory with Immediate
10005 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10006 %{
10007   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10008   effect(KILL cr);
10009 
10010   ins_cost(125);
10011   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10012   opcode(0x81, 0x1); /* Opcode 81 /1 id */
10013   ins_encode(REX_mem_wide(dst), OpcSE(src),
10014              RM_opc_mem(secondary, dst), Con8or32(src));
10015   ins_pipe(ialu_mem_imm);
10016 %}
10017 
10018 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
10019 %{
10020   // con should be a pure 64-bit power of 2 immediate
10021   // because AND/OR works well enough for 8/32-bit values.
10022   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
10023 
10024   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
10025   effect(KILL cr);
10026 
10027   ins_cost(125);
10028   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
10029   ins_encode %{
10030     __ btsq($dst$$Address, log2_long((julong)$con$$constant));
10031   %}
10032   ins_pipe(ialu_mem_imm);
10033 %}
10034 
10035 // Xor Instructions
10036 // Xor Register with Register
10037 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10038 %{
10039   match(Set dst (XorL dst src));
10040   effect(KILL cr);
10041 
10042   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10043   opcode(0x33);
10044   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10045   ins_pipe(ialu_reg_reg);
10046 %}
10047 
10048 // Xor Register with Immediate -1
10049 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10050   match(Set dst (XorL dst imm));
10051 
10052   format %{ &quot;notq   $dst&quot; %}
10053   ins_encode %{
10054      __ notq($dst$$Register);
10055   %}
10056   ins_pipe(ialu_reg);
10057 %}
10058 
10059 // Xor Register with Immediate
10060 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10061 %{
10062   match(Set dst (XorL dst src));
10063   effect(KILL cr);
10064 
10065   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10066   opcode(0x81, 0x06); /* Opcode 81 /6 id */
10067   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10068   ins_pipe(ialu_reg);
10069 %}
10070 
10071 // Xor Register with Memory
10072 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10073 %{
10074   match(Set dst (XorL dst (LoadL src)));
10075   effect(KILL cr);
10076 
10077   ins_cost(125);
10078   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10079   opcode(0x33);
10080   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10081   ins_pipe(ialu_reg_mem);
10082 %}
10083 
10084 // Xor Memory with Register
10085 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10086 %{
10087   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10088   effect(KILL cr);
10089 
10090   ins_cost(150);
10091   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10092   opcode(0x31); /* Opcode 31 /r */
10093   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10094   ins_pipe(ialu_mem_reg);
10095 %}
10096 
10097 // Xor Memory with Immediate
10098 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10099 %{
10100   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10101   effect(KILL cr);
10102 
10103   ins_cost(125);
10104   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10105   opcode(0x81, 0x6); /* Opcode 81 /6 id */
10106   ins_encode(REX_mem_wide(dst), OpcSE(src),
10107              RM_opc_mem(secondary, dst), Con8or32(src));
10108   ins_pipe(ialu_mem_imm);
10109 %}
10110 
10111 // Convert Int to Boolean
10112 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
10113 %{
10114   match(Set dst (Conv2B src));
10115   effect(KILL cr);
10116 
10117   format %{ &quot;testl   $src, $src\t# ci2b\n\t&quot;
10118             &quot;setnz   $dst\n\t&quot;
10119             &quot;movzbl  $dst, $dst&quot; %}
10120   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
10121              setNZ_reg(dst),
10122              REX_reg_breg(dst, dst), // movzbl
10123              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10124   ins_pipe(pipe_slow); // XXX
10125 %}
10126 
10127 // Convert Pointer to Boolean
10128 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
10129 %{
10130   match(Set dst (Conv2B src));
10131   effect(KILL cr);
10132 
10133   format %{ &quot;testq   $src, $src\t# cp2b\n\t&quot;
10134             &quot;setnz   $dst\n\t&quot;
10135             &quot;movzbl  $dst, $dst&quot; %}
10136   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
10137              setNZ_reg(dst),
10138              REX_reg_breg(dst, dst), // movzbl
10139              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10140   ins_pipe(pipe_slow); // XXX
10141 %}
10142 
10143 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
10144 %{
10145   match(Set dst (CmpLTMask p q));
10146   effect(KILL cr);
10147 
10148   ins_cost(400);
10149   format %{ &quot;cmpl    $p, $q\t# cmpLTMask\n\t&quot;
10150             &quot;setlt   $dst\n\t&quot;
10151             &quot;movzbl  $dst, $dst\n\t&quot;
10152             &quot;negl    $dst&quot; %}
10153   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
10154              setLT_reg(dst),
10155              REX_reg_breg(dst, dst), // movzbl
10156              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
10157              neg_reg(dst));
10158   ins_pipe(pipe_slow);
10159 %}
10160 
10161 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10162 %{
10163   match(Set dst (CmpLTMask dst zero));
10164   effect(KILL cr);
10165 
10166   ins_cost(100);
10167   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10168   ins_encode %{
10169   __ sarl($dst$$Register, 31);
10170   %}
10171   ins_pipe(ialu_reg);
10172 %}
10173 
10174 /* Better to save a register than avoid a branch */
10175 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10176 %{
10177   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10178   effect(KILL cr);
10179   ins_cost(300);
10180   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;
10181             &quot;jge     done\n\t&quot;
10182             &quot;addl    $p,$y\n&quot;
10183             &quot;done:   &quot; %}
10184   ins_encode %{
10185     Register Rp = $p$$Register;
10186     Register Rq = $q$$Register;
10187     Register Ry = $y$$Register;
10188     Label done;
10189     __ subl(Rp, Rq);
10190     __ jccb(Assembler::greaterEqual, done);
10191     __ addl(Rp, Ry);
10192     __ bind(done);
10193   %}
10194   ins_pipe(pipe_cmplt);
10195 %}
10196 
10197 /* Better to save a register than avoid a branch */
10198 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10199 %{
10200   match(Set y (AndI (CmpLTMask p q) y));
10201   effect(KILL cr);
10202 
10203   ins_cost(300);
10204 
10205   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;
10206             &quot;jlt     done\n\t&quot;
10207             &quot;xorl    $y, $y\n&quot;
10208             &quot;done:   &quot; %}
10209   ins_encode %{
10210     Register Rp = $p$$Register;
10211     Register Rq = $q$$Register;
10212     Register Ry = $y$$Register;
10213     Label done;
10214     __ cmpl(Rp, Rq);
10215     __ jccb(Assembler::less, done);
10216     __ xorl(Ry, Ry);
10217     __ bind(done);
10218   %}
10219   ins_pipe(pipe_cmplt);
10220 %}
10221 
10222 
10223 //---------- FP Instructions------------------------------------------------
10224 
10225 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10226 %{
10227   match(Set cr (CmpF src1 src2));
10228 
10229   ins_cost(145);
10230   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10231             &quot;jnp,s   exit\n\t&quot;
10232             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10233             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10234             &quot;popfq\n&quot;
10235     &quot;exit:&quot; %}
10236   ins_encode %{
10237     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10238     emit_cmpfp_fixup(_masm);
10239   %}
10240   ins_pipe(pipe_slow);
10241 %}
10242 
10243 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
10244   match(Set cr (CmpF src1 src2));
10245 
10246   ins_cost(100);
10247   format %{ &quot;ucomiss $src1, $src2&quot; %}
10248   ins_encode %{
10249     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10250   %}
10251   ins_pipe(pipe_slow);
10252 %}
10253 
10254 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
10255 %{
10256   match(Set cr (CmpF src1 (LoadF src2)));
10257 
10258   ins_cost(145);
10259   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10260             &quot;jnp,s   exit\n\t&quot;
10261             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10262             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10263             &quot;popfq\n&quot;
10264     &quot;exit:&quot; %}
10265   ins_encode %{
10266     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10267     emit_cmpfp_fixup(_masm);
10268   %}
10269   ins_pipe(pipe_slow);
10270 %}
10271 
10272 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
10273   match(Set cr (CmpF src1 (LoadF src2)));
10274 
10275   ins_cost(100);
10276   format %{ &quot;ucomiss $src1, $src2&quot; %}
10277   ins_encode %{
10278     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10279   %}
10280   ins_pipe(pipe_slow);
10281 %}
10282 
10283 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
10284   match(Set cr (CmpF src con));
10285 
10286   ins_cost(145);
10287   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10288             &quot;jnp,s   exit\n\t&quot;
10289             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10290             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10291             &quot;popfq\n&quot;
10292     &quot;exit:&quot; %}
10293   ins_encode %{
10294     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10295     emit_cmpfp_fixup(_masm);
10296   %}
10297   ins_pipe(pipe_slow);
10298 %}
10299 
10300 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
10301   match(Set cr (CmpF src con));
10302   ins_cost(100);
10303   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con&quot; %}
10304   ins_encode %{
10305     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10306   %}
10307   ins_pipe(pipe_slow);
10308 %}
10309 
10310 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
10311 %{
10312   match(Set cr (CmpD src1 src2));
10313 
10314   ins_cost(145);
10315   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10316             &quot;jnp,s   exit\n\t&quot;
10317             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10318             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10319             &quot;popfq\n&quot;
10320     &quot;exit:&quot; %}
10321   ins_encode %{
10322     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10323     emit_cmpfp_fixup(_masm);
10324   %}
10325   ins_pipe(pipe_slow);
10326 %}
10327 
10328 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
10329   match(Set cr (CmpD src1 src2));
10330 
10331   ins_cost(100);
10332   format %{ &quot;ucomisd $src1, $src2 test&quot; %}
10333   ins_encode %{
10334     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10335   %}
10336   ins_pipe(pipe_slow);
10337 %}
10338 
10339 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
10340 %{
10341   match(Set cr (CmpD src1 (LoadD src2)));
10342 
10343   ins_cost(145);
10344   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10345             &quot;jnp,s   exit\n\t&quot;
10346             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10347             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10348             &quot;popfq\n&quot;
10349     &quot;exit:&quot; %}
10350   ins_encode %{
10351     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10352     emit_cmpfp_fixup(_masm);
10353   %}
10354   ins_pipe(pipe_slow);
10355 %}
10356 
10357 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
10358   match(Set cr (CmpD src1 (LoadD src2)));
10359 
10360   ins_cost(100);
10361   format %{ &quot;ucomisd $src1, $src2&quot; %}
10362   ins_encode %{
10363     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10364   %}
10365   ins_pipe(pipe_slow);
10366 %}
10367 
10368 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
10369   match(Set cr (CmpD src con));
10370 
10371   ins_cost(145);
10372   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10373             &quot;jnp,s   exit\n\t&quot;
10374             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10375             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10376             &quot;popfq\n&quot;
10377     &quot;exit:&quot; %}
10378   ins_encode %{
10379     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10380     emit_cmpfp_fixup(_masm);
10381   %}
10382   ins_pipe(pipe_slow);
10383 %}
10384 
10385 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
10386   match(Set cr (CmpD src con));
10387   ins_cost(100);
10388   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con&quot; %}
10389   ins_encode %{
10390     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10391   %}
10392   ins_pipe(pipe_slow);
10393 %}
10394 
10395 // Compare into -1,0,1
10396 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
10397 %{
10398   match(Set dst (CmpF3 src1 src2));
10399   effect(KILL cr);
10400 
10401   ins_cost(275);
10402   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10403             &quot;movl    $dst, #-1\n\t&quot;
10404             &quot;jp,s    done\n\t&quot;
10405             &quot;jb,s    done\n\t&quot;
10406             &quot;setne   $dst\n\t&quot;
10407             &quot;movzbl  $dst, $dst\n&quot;
10408     &quot;done:&quot; %}
10409   ins_encode %{
10410     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10411     emit_cmpfp3(_masm, $dst$$Register);
10412   %}
10413   ins_pipe(pipe_slow);
10414 %}
10415 
10416 // Compare into -1,0,1
10417 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
10418 %{
10419   match(Set dst (CmpF3 src1 (LoadF src2)));
10420   effect(KILL cr);
10421 
10422   ins_cost(275);
10423   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10424             &quot;movl    $dst, #-1\n\t&quot;
10425             &quot;jp,s    done\n\t&quot;
10426             &quot;jb,s    done\n\t&quot;
10427             &quot;setne   $dst\n\t&quot;
10428             &quot;movzbl  $dst, $dst\n&quot;
10429     &quot;done:&quot; %}
10430   ins_encode %{
10431     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10432     emit_cmpfp3(_masm, $dst$$Register);
10433   %}
10434   ins_pipe(pipe_slow);
10435 %}
10436 
10437 // Compare into -1,0,1
10438 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
10439   match(Set dst (CmpF3 src con));
10440   effect(KILL cr);
10441 
10442   ins_cost(275);
10443   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10444             &quot;movl    $dst, #-1\n\t&quot;
10445             &quot;jp,s    done\n\t&quot;
10446             &quot;jb,s    done\n\t&quot;
10447             &quot;setne   $dst\n\t&quot;
10448             &quot;movzbl  $dst, $dst\n&quot;
10449     &quot;done:&quot; %}
10450   ins_encode %{
10451     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10452     emit_cmpfp3(_masm, $dst$$Register);
10453   %}
10454   ins_pipe(pipe_slow);
10455 %}
10456 
10457 // Compare into -1,0,1
10458 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
10459 %{
10460   match(Set dst (CmpD3 src1 src2));
10461   effect(KILL cr);
10462 
10463   ins_cost(275);
10464   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10465             &quot;movl    $dst, #-1\n\t&quot;
10466             &quot;jp,s    done\n\t&quot;
10467             &quot;jb,s    done\n\t&quot;
10468             &quot;setne   $dst\n\t&quot;
10469             &quot;movzbl  $dst, $dst\n&quot;
10470     &quot;done:&quot; %}
10471   ins_encode %{
10472     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10473     emit_cmpfp3(_masm, $dst$$Register);
10474   %}
10475   ins_pipe(pipe_slow);
10476 %}
10477 
10478 // Compare into -1,0,1
10479 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
10480 %{
10481   match(Set dst (CmpD3 src1 (LoadD src2)));
10482   effect(KILL cr);
10483 
10484   ins_cost(275);
10485   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10486             &quot;movl    $dst, #-1\n\t&quot;
10487             &quot;jp,s    done\n\t&quot;
10488             &quot;jb,s    done\n\t&quot;
10489             &quot;setne   $dst\n\t&quot;
10490             &quot;movzbl  $dst, $dst\n&quot;
10491     &quot;done:&quot; %}
10492   ins_encode %{
10493     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10494     emit_cmpfp3(_masm, $dst$$Register);
10495   %}
10496   ins_pipe(pipe_slow);
10497 %}
10498 
10499 // Compare into -1,0,1
10500 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
10501   match(Set dst (CmpD3 src con));
10502   effect(KILL cr);
10503 
10504   ins_cost(275);
10505   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10506             &quot;movl    $dst, #-1\n\t&quot;
10507             &quot;jp,s    done\n\t&quot;
10508             &quot;jb,s    done\n\t&quot;
10509             &quot;setne   $dst\n\t&quot;
10510             &quot;movzbl  $dst, $dst\n&quot;
10511     &quot;done:&quot; %}
10512   ins_encode %{
10513     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10514     emit_cmpfp3(_masm, $dst$$Register);
10515   %}
10516   ins_pipe(pipe_slow);
10517 %}
10518 
10519 //----------Arithmetic Conversion Instructions---------------------------------
10520 
10521 instruct convF2D_reg_reg(regD dst, regF src)
10522 %{
10523   match(Set dst (ConvF2D src));
10524 
10525   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10526   ins_encode %{
10527     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10528   %}
10529   ins_pipe(pipe_slow); // XXX
10530 %}
10531 
10532 instruct convF2D_reg_mem(regD dst, memory src)
10533 %{
10534   match(Set dst (ConvF2D (LoadF src)));
10535 
10536   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10537   ins_encode %{
10538     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10539   %}
10540   ins_pipe(pipe_slow); // XXX
10541 %}
10542 
10543 instruct convD2F_reg_reg(regF dst, regD src)
10544 %{
10545   match(Set dst (ConvD2F src));
10546 
10547   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10548   ins_encode %{
10549     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10550   %}
10551   ins_pipe(pipe_slow); // XXX
10552 %}
10553 
10554 instruct convD2F_reg_mem(regF dst, memory src)
10555 %{
10556   match(Set dst (ConvD2F (LoadD src)));
10557 
10558   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10559   ins_encode %{
10560     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10561   %}
10562   ins_pipe(pipe_slow); // XXX
10563 %}
10564 
10565 // XXX do mem variants
10566 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10567 %{
10568   match(Set dst (ConvF2I src));
10569   effect(KILL cr);
10570   format %{ &quot;convert_f2i $dst,$src&quot; %}
10571   ins_encode %{
10572     __ convert_f2i($dst$$Register, $src$$XMMRegister);
10573   %}
10574   ins_pipe(pipe_slow);
10575 %}
10576 
10577 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10578 %{
10579   match(Set dst (ConvF2L src));
10580   effect(KILL cr);
10581   format %{ &quot;convert_f2l $dst,$src&quot;%}
10582   ins_encode %{
10583     __ convert_f2l($dst$$Register, $src$$XMMRegister);
10584   %}
10585   ins_pipe(pipe_slow);
10586 %}
10587 
10588 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10589 %{
10590   match(Set dst (ConvD2I src));
10591   effect(KILL cr);
10592   format %{ &quot;convert_d2i $dst,$src&quot;%}
10593   ins_encode %{
10594     __ convert_d2i($dst$$Register, $src$$XMMRegister);
10595   %}
10596   ins_pipe(pipe_slow);
10597 %}
10598 
10599 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10600 %{
10601   match(Set dst (ConvD2L src));
10602   effect(KILL cr);
10603   format %{ &quot;convert_d2l $dst,$src&quot;%}
10604   ins_encode %{
10605     __ convert_d2l($dst$$Register, $src$$XMMRegister);
10606   %}
10607   ins_pipe(pipe_slow);
10608 %}
10609 
10610 instruct convI2F_reg_reg(regF dst, rRegI src)
10611 %{
10612   predicate(!UseXmmI2F);
10613   match(Set dst (ConvI2F src));
10614 
10615   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10616   ins_encode %{
10617     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10618   %}
10619   ins_pipe(pipe_slow); // XXX
10620 %}
10621 
10622 instruct convI2F_reg_mem(regF dst, memory src)
10623 %{
10624   match(Set dst (ConvI2F (LoadI src)));
10625 
10626   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10627   ins_encode %{
10628     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10629   %}
10630   ins_pipe(pipe_slow); // XXX
10631 %}
10632 
10633 instruct convI2D_reg_reg(regD dst, rRegI src)
10634 %{
10635   predicate(!UseXmmI2D);
10636   match(Set dst (ConvI2D src));
10637 
10638   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10639   ins_encode %{
10640     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10641   %}
10642   ins_pipe(pipe_slow); // XXX
10643 %}
10644 
10645 instruct convI2D_reg_mem(regD dst, memory src)
10646 %{
10647   match(Set dst (ConvI2D (LoadI src)));
10648 
10649   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10650   ins_encode %{
10651     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10652   %}
10653   ins_pipe(pipe_slow); // XXX
10654 %}
10655 
10656 instruct convXI2F_reg(regF dst, rRegI src)
10657 %{
10658   predicate(UseXmmI2F);
10659   match(Set dst (ConvI2F src));
10660 
10661   format %{ &quot;movdl $dst, $src\n\t&quot;
10662             &quot;cvtdq2psl $dst, $dst\t# i2f&quot; %}
10663   ins_encode %{
10664     __ movdl($dst$$XMMRegister, $src$$Register);
10665     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10666   %}
10667   ins_pipe(pipe_slow); // XXX
10668 %}
10669 
10670 instruct convXI2D_reg(regD dst, rRegI src)
10671 %{
10672   predicate(UseXmmI2D);
10673   match(Set dst (ConvI2D src));
10674 
10675   format %{ &quot;movdl $dst, $src\n\t&quot;
10676             &quot;cvtdq2pdl $dst, $dst\t# i2d&quot; %}
10677   ins_encode %{
10678     __ movdl($dst$$XMMRegister, $src$$Register);
10679     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10680   %}
10681   ins_pipe(pipe_slow); // XXX
10682 %}
10683 
10684 instruct convL2F_reg_reg(regF dst, rRegL src)
10685 %{
10686   match(Set dst (ConvL2F src));
10687 
10688   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10689   ins_encode %{
10690     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10691   %}
10692   ins_pipe(pipe_slow); // XXX
10693 %}
10694 
10695 instruct convL2F_reg_mem(regF dst, memory src)
10696 %{
10697   match(Set dst (ConvL2F (LoadL src)));
10698 
10699   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10700   ins_encode %{
10701     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10702   %}
10703   ins_pipe(pipe_slow); // XXX
10704 %}
10705 
10706 instruct convL2D_reg_reg(regD dst, rRegL src)
10707 %{
10708   match(Set dst (ConvL2D src));
10709 
10710   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10711   ins_encode %{
10712     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10713   %}
10714   ins_pipe(pipe_slow); // XXX
10715 %}
10716 
10717 instruct convL2D_reg_mem(regD dst, memory src)
10718 %{
10719   match(Set dst (ConvL2D (LoadL src)));
10720 
10721   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10722   ins_encode %{
10723     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10724   %}
10725   ins_pipe(pipe_slow); // XXX
10726 %}
10727 
10728 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10729 %{
10730   match(Set dst (ConvI2L src));
10731 
10732   ins_cost(125);
10733   format %{ &quot;movslq  $dst, $src\t# i2l&quot; %}
10734   ins_encode %{
10735     __ movslq($dst$$Register, $src$$Register);
10736   %}
10737   ins_pipe(ialu_reg_reg);
10738 %}
10739 
10740 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10741 // %{
10742 //   match(Set dst (ConvI2L src));
10743 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10744 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10745 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10746 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10747 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10748 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10749 
10750 //   format %{ &quot;movl    $dst, $src\t# unsigned i2l&quot; %}
10751 //   ins_encode(enc_copy(dst, src));
10752 // //   opcode(0x63); // needs REX.W
10753 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10754 //   ins_pipe(ialu_reg_reg);
10755 // %}
10756 
10757 // Zero-extend convert int to long
10758 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10759 %{
10760   match(Set dst (AndL (ConvI2L src) mask));
10761 
10762   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10763   ins_encode %{
10764     if ($dst$$reg != $src$$reg) {
10765       __ movl($dst$$Register, $src$$Register);
10766     }
10767   %}
10768   ins_pipe(ialu_reg_reg);
10769 %}
10770 
10771 // Zero-extend convert int to long
10772 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10773 %{
10774   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10775 
10776   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10777   ins_encode %{
10778     __ movl($dst$$Register, $src$$Address);
10779   %}
10780   ins_pipe(ialu_reg_mem);
10781 %}
10782 
10783 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10784 %{
10785   match(Set dst (AndL src mask));
10786 
10787   format %{ &quot;movl    $dst, $src\t# zero-extend long&quot; %}
10788   ins_encode %{
10789     __ movl($dst$$Register, $src$$Register);
10790   %}
10791   ins_pipe(ialu_reg_reg);
10792 %}
10793 
10794 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10795 %{
10796   match(Set dst (ConvL2I src));
10797 
10798   format %{ &quot;movl    $dst, $src\t# l2i&quot; %}
10799   ins_encode %{
10800     __ movl($dst$$Register, $src$$Register);
10801   %}
10802   ins_pipe(ialu_reg_reg);
10803 %}
10804 
10805 
10806 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10807   match(Set dst (MoveF2I src));
10808   effect(DEF dst, USE src);
10809 
10810   ins_cost(125);
10811   format %{ &quot;movl    $dst, $src\t# MoveF2I_stack_reg&quot; %}
10812   ins_encode %{
10813     __ movl($dst$$Register, Address(rsp, $src$$disp));
10814   %}
10815   ins_pipe(ialu_reg_mem);
10816 %}
10817 
10818 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10819   match(Set dst (MoveI2F src));
10820   effect(DEF dst, USE src);
10821 
10822   ins_cost(125);
10823   format %{ &quot;movss   $dst, $src\t# MoveI2F_stack_reg&quot; %}
10824   ins_encode %{
10825     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10826   %}
10827   ins_pipe(pipe_slow);
10828 %}
10829 
10830 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10831   match(Set dst (MoveD2L src));
10832   effect(DEF dst, USE src);
10833 
10834   ins_cost(125);
10835   format %{ &quot;movq    $dst, $src\t# MoveD2L_stack_reg&quot; %}
10836   ins_encode %{
10837     __ movq($dst$$Register, Address(rsp, $src$$disp));
10838   %}
10839   ins_pipe(ialu_reg_mem);
10840 %}
10841 
10842 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10843   predicate(!UseXmmLoadAndClearUpper);
10844   match(Set dst (MoveL2D src));
10845   effect(DEF dst, USE src);
10846 
10847   ins_cost(125);
10848   format %{ &quot;movlpd  $dst, $src\t# MoveL2D_stack_reg&quot; %}
10849   ins_encode %{
10850     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10851   %}
10852   ins_pipe(pipe_slow);
10853 %}
10854 
10855 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10856   predicate(UseXmmLoadAndClearUpper);
10857   match(Set dst (MoveL2D src));
10858   effect(DEF dst, USE src);
10859 
10860   ins_cost(125);
10861   format %{ &quot;movsd   $dst, $src\t# MoveL2D_stack_reg&quot; %}
10862   ins_encode %{
10863     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10864   %}
10865   ins_pipe(pipe_slow);
10866 %}
10867 
10868 
10869 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10870   match(Set dst (MoveF2I src));
10871   effect(DEF dst, USE src);
10872 
10873   ins_cost(95); // XXX
10874   format %{ &quot;movss   $dst, $src\t# MoveF2I_reg_stack&quot; %}
10875   ins_encode %{
10876     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10877   %}
10878   ins_pipe(pipe_slow);
10879 %}
10880 
10881 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10882   match(Set dst (MoveI2F src));
10883   effect(DEF dst, USE src);
10884 
10885   ins_cost(100);
10886   format %{ &quot;movl    $dst, $src\t# MoveI2F_reg_stack&quot; %}
10887   ins_encode %{
10888     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10889   %}
10890   ins_pipe( ialu_mem_reg );
10891 %}
10892 
10893 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10894   match(Set dst (MoveD2L src));
10895   effect(DEF dst, USE src);
10896 
10897   ins_cost(95); // XXX
10898   format %{ &quot;movsd   $dst, $src\t# MoveL2D_reg_stack&quot; %}
10899   ins_encode %{
10900     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10901   %}
10902   ins_pipe(pipe_slow);
10903 %}
10904 
10905 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10906   match(Set dst (MoveL2D src));
10907   effect(DEF dst, USE src);
10908 
10909   ins_cost(100);
10910   format %{ &quot;movq    $dst, $src\t# MoveL2D_reg_stack&quot; %}
10911   ins_encode %{
10912     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10913   %}
10914   ins_pipe(ialu_mem_reg);
10915 %}
10916 
10917 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10918   match(Set dst (MoveF2I src));
10919   effect(DEF dst, USE src);
10920   ins_cost(85);
10921   format %{ &quot;movd    $dst,$src\t# MoveF2I&quot; %}
10922   ins_encode %{
10923     __ movdl($dst$$Register, $src$$XMMRegister);
10924   %}
10925   ins_pipe( pipe_slow );
10926 %}
10927 
10928 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10929   match(Set dst (MoveD2L src));
10930   effect(DEF dst, USE src);
10931   ins_cost(85);
10932   format %{ &quot;movd    $dst,$src\t# MoveD2L&quot; %}
10933   ins_encode %{
10934     __ movdq($dst$$Register, $src$$XMMRegister);
10935   %}
10936   ins_pipe( pipe_slow );
10937 %}
10938 
10939 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10940   match(Set dst (MoveI2F src));
10941   effect(DEF dst, USE src);
10942   ins_cost(100);
10943   format %{ &quot;movd    $dst,$src\t# MoveI2F&quot; %}
10944   ins_encode %{
10945     __ movdl($dst$$XMMRegister, $src$$Register);
10946   %}
10947   ins_pipe( pipe_slow );
10948 %}
10949 
10950 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10951   match(Set dst (MoveL2D src));
10952   effect(DEF dst, USE src);
10953   ins_cost(100);
10954   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10955   ins_encode %{
10956      __ movdq($dst$$XMMRegister, $src$$Register);
10957   %}
10958   ins_pipe( pipe_slow );
10959 %}
10960 
10961 
10962 // =======================================================================
10963 // fast clearing of an array
10964 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
10965                   Universe dummy, rFlagsReg cr)
10966 %{
10967   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());
10968   match(Set dummy (ClearArray (Binary cnt base) val));
10969   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
10970 
10971   format %{ $$template
10972     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10973     $$emit$$&quot;jg      LARGE\n\t&quot;
10974     $$emit$$&quot;dec     rcx\n\t&quot;
10975     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10976     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10977     $$emit$$&quot;dec     rcx\n\t&quot;
10978     $$emit$$&quot;jge     LOOP\n\t&quot;
10979     $$emit$$&quot;jmp     DONE\n\t&quot;
10980     $$emit$$&quot;# LARGE:\n\t&quot;
10981     if (UseFastStosb) {
10982        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10983        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10984     } else if (UseXMMForObjInit) {
10985        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
10986        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
10987        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
10988        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10989        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
10990        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
10991        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
10992        $$emit$$&quot;add     0x40,rax\n\t&quot;
10993        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10994        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10995        $$emit$$&quot;jge     L_loop\n\t&quot;
10996        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10997        $$emit$$&quot;jl      L_tail\n\t&quot;
10998        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
10999        $$emit$$&quot;add     0x20,rax\n\t&quot;
11000        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11001        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11002        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11003        $$emit$$&quot;jle     L_end\n\t&quot;
11004        $$emit$$&quot;dec     rcx\n\t&quot;
11005        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11006        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11007        $$emit$$&quot;add     0x8,rax\n\t&quot;
11008        $$emit$$&quot;dec     rcx\n\t&quot;
11009        $$emit$$&quot;jge     L_sloop\n\t&quot;
11010        $$emit$$&quot;# L_end:\n\t&quot;
11011     } else {
11012        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11013     }
11014     $$emit$$&quot;# DONE&quot;
11015   %}
11016   ins_encode %{
11017     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11018                  $tmp$$XMMRegister, false, false);
11019   %}
11020   ins_pipe(pipe_slow);
11021 %}
11022 
11023 instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
11024                   Universe dummy, rFlagsReg cr)
11025 %{
11026   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());
11027   match(Set dummy (ClearArray (Binary cnt base) val));
11028   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11029 
11030   format %{ $$template
11031     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
11032     $$emit$$&quot;jg      LARGE\n\t&quot;
11033     $$emit$$&quot;dec     rcx\n\t&quot;
11034     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
11035     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
11036     $$emit$$&quot;dec     rcx\n\t&quot;
11037     $$emit$$&quot;jge     LOOP\n\t&quot;
11038     $$emit$$&quot;jmp     DONE\n\t&quot;
11039     $$emit$$&quot;# LARGE:\n\t&quot;
11040     if (UseXMMForObjInit) {
11041        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11042        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11043        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11044        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11045        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11046        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11047        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11048        $$emit$$&quot;add     0x40,rax\n\t&quot;
11049        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11050        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11051        $$emit$$&quot;jge     L_loop\n\t&quot;
11052        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11053        $$emit$$&quot;jl      L_tail\n\t&quot;
11054        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11055        $$emit$$&quot;add     0x20,rax\n\t&quot;
11056        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11057        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11058        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11059        $$emit$$&quot;jle     L_end\n\t&quot;
11060        $$emit$$&quot;dec     rcx\n\t&quot;
11061        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11062        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11063        $$emit$$&quot;add     0x8,rax\n\t&quot;
11064        $$emit$$&quot;dec     rcx\n\t&quot;
11065        $$emit$$&quot;jge     L_sloop\n\t&quot;
11066        $$emit$$&quot;# L_end:\n\t&quot;
11067     } else {
11068        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11069     }
11070     $$emit$$&quot;# DONE&quot;
11071   %}
11072   ins_encode %{
11073     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11074                  $tmp$$XMMRegister, false, true);
11075   %}
11076   ins_pipe(pipe_slow);
11077 %}
11078 
11079 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
11080                         Universe dummy, rFlagsReg cr)
11081 %{
11082   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());
11083   match(Set dummy (ClearArray (Binary cnt base) val));
11084   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11085 
11086   format %{ $$template
11087     if (UseFastStosb) {
11088        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11089        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
11090     } else if (UseXMMForObjInit) {
11091        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11092        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11093        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11094        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11095        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11096        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11097        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11098        $$emit$$&quot;add     0x40,rax\n\t&quot;
11099        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11100        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11101        $$emit$$&quot;jge     L_loop\n\t&quot;
11102        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11103        $$emit$$&quot;jl      L_tail\n\t&quot;
11104        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11105        $$emit$$&quot;add     0x20,rax\n\t&quot;
11106        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11107        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11108        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11109        $$emit$$&quot;jle     L_end\n\t&quot;
11110        $$emit$$&quot;dec     rcx\n\t&quot;
11111        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11112        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11113        $$emit$$&quot;add     0x8,rax\n\t&quot;
11114        $$emit$$&quot;dec     rcx\n\t&quot;
11115        $$emit$$&quot;jge     L_sloop\n\t&quot;
11116        $$emit$$&quot;# L_end:\n\t&quot;
11117     } else {
11118        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11119     }
11120   %}
11121   ins_encode %{
11122     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11123                  $tmp$$XMMRegister, true, false);
11124   %}
11125   ins_pipe(pipe_slow);
11126 %}
11127 
11128 instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val, 
11129                         Universe dummy, rFlagsReg cr)
11130 %{
11131   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());
11132   match(Set dummy (ClearArray (Binary cnt base) val));
11133   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11134 
11135   format %{ $$template
11136     if (UseXMMForObjInit) {
11137        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11138        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11139        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11140        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11141        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11142        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11143        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11144        $$emit$$&quot;add     0x40,rax\n\t&quot;
11145        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11146        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11147        $$emit$$&quot;jge     L_loop\n\t&quot;
11148        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11149        $$emit$$&quot;jl      L_tail\n\t&quot;
11150        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11151        $$emit$$&quot;add     0x20,rax\n\t&quot;
11152        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11153        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11154        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11155        $$emit$$&quot;jle     L_end\n\t&quot;
11156        $$emit$$&quot;dec     rcx\n\t&quot;
11157        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11158        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11159        $$emit$$&quot;add     0x8,rax\n\t&quot;
11160        $$emit$$&quot;dec     rcx\n\t&quot;
11161        $$emit$$&quot;jge     L_sloop\n\t&quot;
11162        $$emit$$&quot;# L_end:\n\t&quot;
11163     } else {
11164        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11165     }
11166   %}
11167   ins_encode %{
11168     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register, 
11169                  $tmp$$XMMRegister, true, true);
11170   %}
11171   ins_pipe(pipe_slow);
11172 %}
11173 
11174 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11175                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11176 %{
11177   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11178   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11179   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11180 
11181   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11182   ins_encode %{
11183     __ string_compare($str1$$Register, $str2$$Register,
11184                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11185                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11186   %}
11187   ins_pipe( pipe_slow );
11188 %}
11189 
11190 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11191                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11192 %{
11193   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11194   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11195   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11196 
11197   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11198   ins_encode %{
11199     __ string_compare($str1$$Register, $str2$$Register,
11200                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11201                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11202   %}
11203   ins_pipe( pipe_slow );
11204 %}
11205 
11206 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11207                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11208 %{
11209   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11210   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11211   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11212 
11213   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11214   ins_encode %{
11215     __ string_compare($str1$$Register, $str2$$Register,
11216                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11217                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11218   %}
11219   ins_pipe( pipe_slow );
11220 %}
11221 
11222 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
11223                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11224 %{
11225   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11226   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11227   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11228 
11229   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11230   ins_encode %{
11231     __ string_compare($str2$$Register, $str1$$Register,
11232                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11233                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11234   %}
11235   ins_pipe( pipe_slow );
11236 %}
11237 
11238 // fast search of substring with known size.
11239 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11240                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11241 %{
11242   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11243   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11244   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11245 
11246   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11247   ins_encode %{
11248     int icnt2 = (int)$int_cnt2$$constant;
11249     if (icnt2 &gt;= 16) {
11250       // IndexOf for constant substrings with size &gt;= 16 elements
11251       // which don&#39;t need to be loaded through stack.
11252       __ string_indexofC8($str1$$Register, $str2$$Register,
11253                           $cnt1$$Register, $cnt2$$Register,
11254                           icnt2, $result$$Register,
11255                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11256     } else {
11257       // Small strings are loaded through stack if they cross page boundary.
11258       __ string_indexof($str1$$Register, $str2$$Register,
11259                         $cnt1$$Register, $cnt2$$Register,
11260                         icnt2, $result$$Register,
11261                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11262     }
11263   %}
11264   ins_pipe( pipe_slow );
11265 %}
11266 
11267 // fast search of substring with known size.
11268 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11269                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11270 %{
11271   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11272   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11273   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11274 
11275   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11276   ins_encode %{
11277     int icnt2 = (int)$int_cnt2$$constant;
11278     if (icnt2 &gt;= 8) {
11279       // IndexOf for constant substrings with size &gt;= 8 elements
11280       // which don&#39;t need to be loaded through stack.
11281       __ string_indexofC8($str1$$Register, $str2$$Register,
11282                           $cnt1$$Register, $cnt2$$Register,
11283                           icnt2, $result$$Register,
11284                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11285     } else {
11286       // Small strings are loaded through stack if they cross page boundary.
11287       __ string_indexof($str1$$Register, $str2$$Register,
11288                         $cnt1$$Register, $cnt2$$Register,
11289                         icnt2, $result$$Register,
11290                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11291     }
11292   %}
11293   ins_pipe( pipe_slow );
11294 %}
11295 
11296 // fast search of substring with known size.
11297 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11298                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11299 %{
11300   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11301   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11302   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11303 
11304   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11305   ins_encode %{
11306     int icnt2 = (int)$int_cnt2$$constant;
11307     if (icnt2 &gt;= 8) {
11308       // IndexOf for constant substrings with size &gt;= 8 elements
11309       // which don&#39;t need to be loaded through stack.
11310       __ string_indexofC8($str1$$Register, $str2$$Register,
11311                           $cnt1$$Register, $cnt2$$Register,
11312                           icnt2, $result$$Register,
11313                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11314     } else {
11315       // Small strings are loaded through stack if they cross page boundary.
11316       __ string_indexof($str1$$Register, $str2$$Register,
11317                         $cnt1$$Register, $cnt2$$Register,
11318                         icnt2, $result$$Register,
11319                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11320     }
11321   %}
11322   ins_pipe( pipe_slow );
11323 %}
11324 
11325 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11326                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11327 %{
11328   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11329   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11330   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11331 
11332   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11333   ins_encode %{
11334     __ string_indexof($str1$$Register, $str2$$Register,
11335                       $cnt1$$Register, $cnt2$$Register,
11336                       (-1), $result$$Register,
11337                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11338   %}
11339   ins_pipe( pipe_slow );
11340 %}
11341 
11342 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11343                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11344 %{
11345   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11346   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11347   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11348 
11349   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11350   ins_encode %{
11351     __ string_indexof($str1$$Register, $str2$$Register,
11352                       $cnt1$$Register, $cnt2$$Register,
11353                       (-1), $result$$Register,
11354                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11355   %}
11356   ins_pipe( pipe_slow );
11357 %}
11358 
11359 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11360                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11361 %{
11362   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11363   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11364   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11365 
11366   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11367   ins_encode %{
11368     __ string_indexof($str1$$Register, $str2$$Register,
11369                       $cnt1$$Register, $cnt2$$Register,
11370                       (-1), $result$$Register,
11371                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11372   %}
11373   ins_pipe( pipe_slow );
11374 %}
11375 
11376 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
11377                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)
11378 %{
11379   predicate(UseSSE42Intrinsics);
11380   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11381   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11382   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11383   ins_encode %{
11384     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11385                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);
11386   %}
11387   ins_pipe( pipe_slow );
11388 %}
11389 
11390 // fast string equals
11391 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
11392                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11393 %{
11394   match(Set result (StrEquals (Binary str1 str2) cnt));
11395   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11396 
11397   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11398   ins_encode %{
11399     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11400                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11401                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11402   %}
11403   ins_pipe( pipe_slow );
11404 %}
11405 
11406 // fast array equals
11407 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11408                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11409 %{
11410   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11411   match(Set result (AryEq ary1 ary2));
11412   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11413 
11414   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11415   ins_encode %{
11416     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11417                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11418                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11419   %}
11420   ins_pipe( pipe_slow );
11421 %}
11422 
11423 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11424                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11425 %{
11426   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11427   match(Set result (AryEq ary1 ary2));
11428   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11429 
11430   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11431   ins_encode %{
11432     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11433                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11434                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11435   %}
11436   ins_pipe( pipe_slow );
11437 %}
11438 
11439 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
11440                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11441 %{
11442   match(Set result (HasNegatives ary1 len));
11443   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11444 
11445   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11446   ins_encode %{
11447     __ has_negatives($ary1$$Register, $len$$Register,
11448                      $result$$Register, $tmp3$$Register,
11449                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11450   %}
11451   ins_pipe( pipe_slow );
11452 %}
11453 
11454 // fast char[] to byte[] compression
11455 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11456                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11457   match(Set result (StrCompressedCopy src (Binary dst len)));
11458   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11459 
11460   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11461   ins_encode %{
11462     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11463                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11464                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11465   %}
11466   ins_pipe( pipe_slow );
11467 %}
11468 
11469 // fast byte[] to char[] inflation
11470 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11471                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{
11472   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11473   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11474 
11475   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11476   ins_encode %{
11477     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11478                           $tmp1$$XMMRegister, $tmp2$$Register);
11479   %}
11480   ins_pipe( pipe_slow );
11481 %}
11482 
11483 // encode char[] to byte[] in ISO_8859_1
11484 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11485                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11486                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11487   match(Set result (EncodeISOArray src (Binary dst len)));
11488   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11489 
11490   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11491   ins_encode %{
11492     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11493                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11494                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11495   %}
11496   ins_pipe( pipe_slow );
11497 %}
11498 
11499 //----------Overflow Math Instructions-----------------------------------------
11500 
11501 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11502 %{
11503   match(Set cr (OverflowAddI op1 op2));
11504   effect(DEF cr, USE_KILL op1, USE op2);
11505 
11506   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11507 
11508   ins_encode %{
11509     __ addl($op1$$Register, $op2$$Register);
11510   %}
11511   ins_pipe(ialu_reg_reg);
11512 %}
11513 
11514 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
11515 %{
11516   match(Set cr (OverflowAddI op1 op2));
11517   effect(DEF cr, USE_KILL op1, USE op2);
11518 
11519   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11520 
11521   ins_encode %{
11522     __ addl($op1$$Register, $op2$$constant);
11523   %}
11524   ins_pipe(ialu_reg_reg);
11525 %}
11526 
11527 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11528 %{
11529   match(Set cr (OverflowAddL op1 op2));
11530   effect(DEF cr, USE_KILL op1, USE op2);
11531 
11532   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11533   ins_encode %{
11534     __ addq($op1$$Register, $op2$$Register);
11535   %}
11536   ins_pipe(ialu_reg_reg);
11537 %}
11538 
11539 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
11540 %{
11541   match(Set cr (OverflowAddL op1 op2));
11542   effect(DEF cr, USE_KILL op1, USE op2);
11543 
11544   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11545   ins_encode %{
11546     __ addq($op1$$Register, $op2$$constant);
11547   %}
11548   ins_pipe(ialu_reg_reg);
11549 %}
11550 
11551 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11552 %{
11553   match(Set cr (OverflowSubI op1 op2));
11554 
11555   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11556   ins_encode %{
11557     __ cmpl($op1$$Register, $op2$$Register);
11558   %}
11559   ins_pipe(ialu_reg_reg);
11560 %}
11561 
11562 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11563 %{
11564   match(Set cr (OverflowSubI op1 op2));
11565 
11566   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11567   ins_encode %{
11568     __ cmpl($op1$$Register, $op2$$constant);
11569   %}
11570   ins_pipe(ialu_reg_reg);
11571 %}
11572 
11573 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11574 %{
11575   match(Set cr (OverflowSubL op1 op2));
11576 
11577   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11578   ins_encode %{
11579     __ cmpq($op1$$Register, $op2$$Register);
11580   %}
11581   ins_pipe(ialu_reg_reg);
11582 %}
11583 
11584 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11585 %{
11586   match(Set cr (OverflowSubL op1 op2));
11587 
11588   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11589   ins_encode %{
11590     __ cmpq($op1$$Register, $op2$$constant);
11591   %}
11592   ins_pipe(ialu_reg_reg);
11593 %}
11594 
11595 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
11596 %{
11597   match(Set cr (OverflowSubI zero op2));
11598   effect(DEF cr, USE_KILL op2);
11599 
11600   format %{ &quot;negl    $op2\t# overflow check int&quot; %}
11601   ins_encode %{
11602     __ negl($op2$$Register);
11603   %}
11604   ins_pipe(ialu_reg_reg);
11605 %}
11606 
11607 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
11608 %{
11609   match(Set cr (OverflowSubL zero op2));
11610   effect(DEF cr, USE_KILL op2);
11611 
11612   format %{ &quot;negq    $op2\t# overflow check long&quot; %}
11613   ins_encode %{
11614     __ negq($op2$$Register);
11615   %}
11616   ins_pipe(ialu_reg_reg);
11617 %}
11618 
11619 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11620 %{
11621   match(Set cr (OverflowMulI op1 op2));
11622   effect(DEF cr, USE_KILL op1, USE op2);
11623 
11624   format %{ &quot;imull    $op1, $op2\t# overflow check int&quot; %}
11625   ins_encode %{
11626     __ imull($op1$$Register, $op2$$Register);
11627   %}
11628   ins_pipe(ialu_reg_reg_alu0);
11629 %}
11630 
11631 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
11632 %{
11633   match(Set cr (OverflowMulI op1 op2));
11634   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11635 
11636   format %{ &quot;imull    $tmp, $op1, $op2\t# overflow check int&quot; %}
11637   ins_encode %{
11638     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
11639   %}
11640   ins_pipe(ialu_reg_reg_alu0);
11641 %}
11642 
11643 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11644 %{
11645   match(Set cr (OverflowMulL op1 op2));
11646   effect(DEF cr, USE_KILL op1, USE op2);
11647 
11648   format %{ &quot;imulq    $op1, $op2\t# overflow check long&quot; %}
11649   ins_encode %{
11650     __ imulq($op1$$Register, $op2$$Register);
11651   %}
11652   ins_pipe(ialu_reg_reg_alu0);
11653 %}
11654 
11655 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
11656 %{
11657   match(Set cr (OverflowMulL op1 op2));
11658   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11659 
11660   format %{ &quot;imulq    $tmp, $op1, $op2\t# overflow check long&quot; %}
11661   ins_encode %{
11662     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
11663   %}
11664   ins_pipe(ialu_reg_reg_alu0);
11665 %}
11666 
11667 
11668 //----------Control Flow Instructions------------------------------------------
11669 // Signed compare Instructions
11670 
11671 // XXX more variants!!
11672 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11673 %{
11674   match(Set cr (CmpI op1 op2));
11675   effect(DEF cr, USE op1, USE op2);
11676 
11677   format %{ &quot;cmpl    $op1, $op2&quot; %}
11678   opcode(0x3B);  /* Opcode 3B /r */
11679   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11680   ins_pipe(ialu_cr_reg_reg);
11681 %}
11682 
11683 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11684 %{
11685   match(Set cr (CmpI op1 op2));
11686 
11687   format %{ &quot;cmpl    $op1, $op2&quot; %}
11688   opcode(0x81, 0x07); /* Opcode 81 /7 */
11689   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11690   ins_pipe(ialu_cr_reg_imm);
11691 %}
11692 
11693 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
11694 %{
11695   match(Set cr (CmpI op1 (LoadI op2)));
11696 
11697   ins_cost(500); // XXX
11698   format %{ &quot;cmpl    $op1, $op2&quot; %}
11699   opcode(0x3B); /* Opcode 3B /r */
11700   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11701   ins_pipe(ialu_cr_reg_mem);
11702 %}
11703 
11704 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11705 %{
11706   match(Set cr (CmpI src zero));
11707 
11708   format %{ &quot;testl   $src, $src&quot; %}
11709   opcode(0x85);
11710   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11711   ins_pipe(ialu_cr_reg_imm);
11712 %}
11713 
11714 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11715 %{
11716   match(Set cr (CmpI (AndI src con) zero));
11717 
11718   format %{ &quot;testl   $src, $con&quot; %}
11719   opcode(0xF7, 0x00);
11720   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11721   ins_pipe(ialu_cr_reg_imm);
11722 %}
11723 
11724 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11725 %{
11726   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11727 
11728   format %{ &quot;testl   $src, $mem&quot; %}
11729   opcode(0x85);
11730   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11731   ins_pipe(ialu_cr_reg_mem);
11732 %}
11733 
11734 // Fold array properties check
11735 instruct testI_mem_imm(rFlagsReg cr, memory mem, immI con, immI0 zero)
11736 %{
11737   match(Set cr (CmpI (AndI (CastN2I (LoadNKlass mem)) con) zero));
11738 
11739   format %{ &quot;testl   $mem, $con&quot; %}
11740   opcode(0xF7, 0x00);
11741   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(con));
11742   ins_pipe(ialu_mem_imm);
11743 %}
11744 
11745 // Unsigned compare Instructions; really, same as signed except they
11746 // produce an rFlagsRegU instead of rFlagsReg.
11747 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11748 %{
11749   match(Set cr (CmpU op1 op2));
11750 
11751   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11752   opcode(0x3B); /* Opcode 3B /r */
11753   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11754   ins_pipe(ialu_cr_reg_reg);
11755 %}
11756 
11757 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11758 %{
11759   match(Set cr (CmpU op1 op2));
11760 
11761   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11762   opcode(0x81,0x07); /* Opcode 81 /7 */
11763   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11764   ins_pipe(ialu_cr_reg_imm);
11765 %}
11766 
11767 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11768 %{
11769   match(Set cr (CmpU op1 (LoadI op2)));
11770 
11771   ins_cost(500); // XXX
11772   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11773   opcode(0x3B); /* Opcode 3B /r */
11774   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11775   ins_pipe(ialu_cr_reg_mem);
11776 %}
11777 
11778 // // // Cisc-spilled version of cmpU_rReg
11779 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11780 // //%{
11781 // //  match(Set cr (CmpU (LoadI op1) op2));
11782 // //
11783 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11784 // //  ins_cost(500);
11785 // //  opcode(0x39);  /* Opcode 39 /r */
11786 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11787 // //%}
11788 
11789 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11790 %{
11791   match(Set cr (CmpU src zero));
11792 
11793   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}
11794   opcode(0x85);
11795   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11796   ins_pipe(ialu_cr_reg_imm);
11797 %}
11798 
11799 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11800 %{
11801   match(Set cr (CmpP op1 op2));
11802 
11803   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11804   opcode(0x3B); /* Opcode 3B /r */
11805   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11806   ins_pipe(ialu_cr_reg_reg);
11807 %}
11808 
11809 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11810 %{
11811   match(Set cr (CmpP op1 (LoadP op2)));
11812   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11813 
11814   ins_cost(500); // XXX
11815   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11816   opcode(0x3B); /* Opcode 3B /r */
11817   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11818   ins_pipe(ialu_cr_reg_mem);
11819 %}
11820 
11821 // // // Cisc-spilled version of cmpP_rReg
11822 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11823 // //%{
11824 // //  match(Set cr (CmpP (LoadP op1) op2));
11825 // //
11826 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11827 // //  ins_cost(500);
11828 // //  opcode(0x39);  /* Opcode 39 /r */
11829 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11830 // //%}
11831 
11832 // XXX this is generalized by compP_rReg_mem???
11833 // Compare raw pointer (used in out-of-heap check).
11834 // Only works because non-oop pointers must be raw pointers
11835 // and raw pointers have no anti-dependencies.
11836 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11837 %{
11838   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;
11839             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11840   match(Set cr (CmpP op1 (LoadP op2)));
11841 
11842   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11843   opcode(0x3B); /* Opcode 3B /r */
11844   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11845   ins_pipe(ialu_cr_reg_mem);
11846 %}
11847 
11848 // This will generate a signed flags result. This should be OK since
11849 // any compare to a zero should be eq/neq.
11850 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11851 %{
11852   match(Set cr (CmpP src zero));
11853 
11854   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11855   opcode(0x85);
11856   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11857   ins_pipe(ialu_cr_reg_imm);
11858 %}
11859 
11860 // This will generate a signed flags result. This should be OK since
11861 // any compare to a zero should be eq/neq.
11862 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11863 %{
11864   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11865             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11866   match(Set cr (CmpP (LoadP op) zero));
11867 
11868   ins_cost(500); // XXX
11869   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11870   opcode(0xF7); /* Opcode F7 /0 */
11871   ins_encode(REX_mem_wide(op),
11872              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11873   ins_pipe(ialu_cr_reg_imm);
11874 %}
11875 
11876 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11877 %{
11878   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
11879             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11880   match(Set cr (CmpP (LoadP mem) zero));
11881 
11882   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11883   ins_encode %{
11884     __ cmpq(r12, $mem$$Address);
11885   %}
11886   ins_pipe(ialu_cr_reg_mem);
11887 %}
11888 
11889 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11890 %{
11891   match(Set cr (CmpN op1 op2));
11892 
11893   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11894   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11895   ins_pipe(ialu_cr_reg_reg);
11896 %}
11897 
11898 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11899 %{
11900   match(Set cr (CmpN src (LoadN mem)));
11901 
11902   format %{ &quot;cmpl    $src, $mem\t# compressed ptr&quot; %}
11903   ins_encode %{
11904     __ cmpl($src$$Register, $mem$$Address);
11905   %}
11906   ins_pipe(ialu_cr_reg_mem);
11907 %}
11908 
11909 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11910   match(Set cr (CmpN op1 op2));
11911 
11912   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11913   ins_encode %{
11914     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11915   %}
11916   ins_pipe(ialu_cr_reg_imm);
11917 %}
11918 
11919 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11920 %{
11921   match(Set cr (CmpN src (LoadN mem)));
11922 
11923   format %{ &quot;cmpl    $mem, $src\t# compressed ptr&quot; %}
11924   ins_encode %{
11925     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11926   %}
11927   ins_pipe(ialu_cr_reg_mem);
11928 %}
11929 
11930 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11931   match(Set cr (CmpN op1 op2));
11932 
11933   format %{ &quot;cmpl    $op1, $op2\t# compressed klass ptr&quot; %}
11934   ins_encode %{
11935     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
11936   %}
11937   ins_pipe(ialu_cr_reg_imm);
11938 %}
11939 
11940 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11941 %{
11942   match(Set cr (CmpN src (LoadNKlass mem)));
11943 
11944   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
11945   ins_encode %{
11946     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11947   %}
11948   ins_pipe(ialu_cr_reg_mem);
11949 %}
11950 
11951 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11952   match(Set cr (CmpN src zero));
11953 
11954   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11955   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11956   ins_pipe(ialu_cr_reg_imm);
11957 %}
11958 
11959 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11960 %{
11961   predicate(CompressedOops::base() != NULL);
11962   match(Set cr (CmpN (LoadN mem) zero));
11963 
11964   ins_cost(500); // XXX
11965   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11966   ins_encode %{
11967     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11968   %}
11969   ins_pipe(ialu_cr_reg_mem);
11970 %}
11971 
11972 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11973 %{
11974   predicate(CompressedOops::base() == NULL);
11975   match(Set cr (CmpN (LoadN mem) zero));
11976 
11977   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11978   ins_encode %{
11979     __ cmpl(r12, $mem$$Address);
11980   %}
11981   ins_pipe(ialu_cr_reg_mem);
11982 %}
11983 
11984 // Yanked all unsigned pointer compare operations.
11985 // Pointer compares are done with CmpP which is already unsigned.
11986 
11987 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11988 %{
11989   match(Set cr (CmpL op1 op2));
11990 
11991   format %{ &quot;cmpq    $op1, $op2&quot; %}
11992   opcode(0x3B);  /* Opcode 3B /r */
11993   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11994   ins_pipe(ialu_cr_reg_reg);
11995 %}
11996 
11997 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11998 %{
11999   match(Set cr (CmpL op1 op2));
12000 
12001   format %{ &quot;cmpq    $op1, $op2&quot; %}
12002   opcode(0x81, 0x07); /* Opcode 81 /7 */
12003   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
12004   ins_pipe(ialu_cr_reg_imm);
12005 %}
12006 
12007 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
12008 %{
12009   match(Set cr (CmpL op1 (LoadL op2)));
12010 
12011   format %{ &quot;cmpq    $op1, $op2&quot; %}
12012   opcode(0x3B); /* Opcode 3B /r */
12013   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
12014   ins_pipe(ialu_cr_reg_mem);
12015 %}
12016 
12017 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
12018 %{
12019   match(Set cr (CmpL src zero));
12020 
12021   format %{ &quot;testq   $src, $src&quot; %}
12022   opcode(0x85);
12023   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12024   ins_pipe(ialu_cr_reg_imm);
12025 %}
12026 
12027 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
12028 %{
12029   match(Set cr (CmpL (AndL src con) zero));
12030 
12031   format %{ &quot;testq   $src, $con\t# long&quot; %}
12032   opcode(0xF7, 0x00);
12033   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
12034   ins_pipe(ialu_cr_reg_imm);
12035 %}
12036 
12037 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
12038 %{
12039   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
12040 
12041   format %{ &quot;testq   $src, $mem&quot; %}
12042   opcode(0x85);
12043   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12044   ins_pipe(ialu_cr_reg_mem);
12045 %}
12046 
12047 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
12048 %{
12049   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
12050 
12051   format %{ &quot;testq   $src, $mem&quot; %}
12052   opcode(0x85);
12053   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12054   ins_pipe(ialu_cr_reg_mem);
12055 %}
12056 
12057 // Fold array properties check
12058 instruct testL_reg_mem3(rFlagsReg cr, memory mem, rRegL src, immL0 zero)
12059 %{
12060   match(Set cr (CmpL (AndL (CastP2X (LoadKlass mem)) src) zero));
12061 
12062   format %{ &quot;testq   $src, $mem\t# test array properties&quot; %}
12063   opcode(0x85);
12064   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12065   ins_pipe(ialu_cr_reg_mem);
12066 %}
12067 
12068 // Manifest a CmpL result in an integer register.  Very painful.
12069 // This is the test to avoid.
12070 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
12071 %{
12072   match(Set dst (CmpL3 src1 src2));
12073   effect(KILL flags);
12074 
12075   ins_cost(275); // XXX
12076   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
12077             &quot;movl    $dst, -1\n\t&quot;
12078             &quot;jl,s    done\n\t&quot;
12079             &quot;setne   $dst\n\t&quot;
12080             &quot;movzbl  $dst, $dst\n\t&quot;
12081     &quot;done:&quot; %}
12082   ins_encode(cmpl3_flag(src1, src2, dst));
12083   ins_pipe(pipe_slow);
12084 %}
12085 
12086 // Unsigned long compare Instructions; really, same as signed long except they
12087 // produce an rFlagsRegU instead of rFlagsReg.
12088 instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)
12089 %{
12090   match(Set cr (CmpUL op1 op2));
12091 
12092   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12093   opcode(0x3B);  /* Opcode 3B /r */
12094   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12095   ins_pipe(ialu_cr_reg_reg);
12096 %}
12097 
12098 instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)
12099 %{
12100   match(Set cr (CmpUL op1 op2));
12101 
12102   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12103   opcode(0x81, 0x07); /* Opcode 81 /7 */
12104   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
12105   ins_pipe(ialu_cr_reg_imm);
12106 %}
12107 
12108 instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)
12109 %{
12110   match(Set cr (CmpUL op1 (LoadL op2)));
12111 
12112   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12113   opcode(0x3B); /* Opcode 3B /r */
12114   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
12115   ins_pipe(ialu_cr_reg_mem);
12116 %}
12117 
12118 instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)
12119 %{
12120   match(Set cr (CmpUL src zero));
12121 
12122   format %{ &quot;testq   $src, $src\t# unsigned&quot; %}
12123   opcode(0x85);
12124   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12125   ins_pipe(ialu_cr_reg_imm);
12126 %}
12127 
12128 instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)
12129 %{
12130   match(Set cr (CmpI (LoadB mem) imm));
12131 
12132   ins_cost(125);
12133   format %{ &quot;cmpb    $mem, $imm&quot; %}
12134   ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}
12135   ins_pipe(ialu_cr_reg_mem);
12136 %}
12137 
12138 instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)
12139 %{
12140   match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));
12141 
12142   ins_cost(125);
12143   format %{ &quot;testb   $mem, $imm\t# ubyte&quot; %}
12144   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12145   ins_pipe(ialu_cr_reg_mem);
12146 %}
12147 
12148 instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI0 zero)
12149 %{
12150   match(Set cr (CmpI (AndI (LoadB mem) imm) zero));
12151 
12152   ins_cost(125);
12153   format %{ &quot;testb   $mem, $imm\t# byte&quot; %}
12154   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12155   ins_pipe(ialu_cr_reg_mem);
12156 %}
12157 
12158 //----------Max and Min--------------------------------------------------------
12159 // Min Instructions
12160 
12161 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
12162 %{
12163   effect(USE_DEF dst, USE src, USE cr);
12164 
12165   format %{ &quot;cmovlgt $dst, $src\t# min&quot; %}
12166   opcode(0x0F, 0x4F);
12167   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12168   ins_pipe(pipe_cmov_reg);
12169 %}
12170 
12171 
12172 instruct minI_rReg(rRegI dst, rRegI src)
12173 %{
12174   match(Set dst (MinI dst src));
12175 
12176   ins_cost(200);
12177   expand %{
12178     rFlagsReg cr;
12179     compI_rReg(cr, dst, src);
12180     cmovI_reg_g(dst, src, cr);
12181   %}
12182 %}
12183 
12184 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
12185 %{
12186   effect(USE_DEF dst, USE src, USE cr);
12187 
12188   format %{ &quot;cmovllt $dst, $src\t# max&quot; %}
12189   opcode(0x0F, 0x4C);
12190   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12191   ins_pipe(pipe_cmov_reg);
12192 %}
12193 
12194 
12195 instruct maxI_rReg(rRegI dst, rRegI src)
12196 %{
12197   match(Set dst (MaxI dst src));
12198 
12199   ins_cost(200);
12200   expand %{
12201     rFlagsReg cr;
12202     compI_rReg(cr, dst, src);
12203     cmovI_reg_l(dst, src, cr);
12204   %}
12205 %}
12206 
12207 // ============================================================================
12208 // Branch Instructions
12209 
12210 // Jump Direct - Label defines a relative address from JMP+1
12211 instruct jmpDir(label labl)
12212 %{
12213   match(Goto);
12214   effect(USE labl);
12215 
12216   ins_cost(300);
12217   format %{ &quot;jmp     $labl&quot; %}
12218   size(5);
12219   ins_encode %{
12220     Label* L = $labl$$label;
12221     __ jmp(*L, false); // Always long jump
12222   %}
12223   ins_pipe(pipe_jmp);
12224 %}
12225 
12226 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12227 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
12228 %{
12229   match(If cop cr);
12230   effect(USE labl);
12231 
12232   ins_cost(300);
12233   format %{ &quot;j$cop     $labl&quot; %}
12234   size(6);
12235   ins_encode %{
12236     Label* L = $labl$$label;
12237     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12238   %}
12239   ins_pipe(pipe_jcc);
12240 %}
12241 
12242 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12243 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
12244 %{
12245   predicate(!n-&gt;has_vector_mask_set());
12246   match(CountedLoopEnd cop cr);
12247   effect(USE labl);
12248 
12249   ins_cost(300);
12250   format %{ &quot;j$cop     $labl\t# loop end&quot; %}
12251   size(6);
12252   ins_encode %{
12253     Label* L = $labl$$label;
12254     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12255   %}
12256   ins_pipe(pipe_jcc);
12257 %}
12258 
12259 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12260 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12261   predicate(!n-&gt;has_vector_mask_set());
12262   match(CountedLoopEnd cop cmp);
12263   effect(USE labl);
12264 
12265   ins_cost(300);
12266   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12267   size(6);
12268   ins_encode %{
12269     Label* L = $labl$$label;
12270     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12271   %}
12272   ins_pipe(pipe_jcc);
12273 %}
12274 
12275 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12276   predicate(!n-&gt;has_vector_mask_set());
12277   match(CountedLoopEnd cop cmp);
12278   effect(USE labl);
12279 
12280   ins_cost(200);
12281   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12282   size(6);
12283   ins_encode %{
12284     Label* L = $labl$$label;
12285     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12286   %}
12287   ins_pipe(pipe_jcc);
12288 %}
12289 
12290 // mask version
12291 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12292 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)
12293 %{
12294   predicate(n-&gt;has_vector_mask_set());
12295   match(CountedLoopEnd cop cr);
12296   effect(USE labl);
12297 
12298   ins_cost(400);
12299   format %{ &quot;j$cop     $labl\t# loop end\n\t&quot;
12300             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12301   size(10);
12302   ins_encode %{
12303     Label* L = $labl$$label;
12304     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12305     __ restorevectmask();
12306   %}
12307   ins_pipe(pipe_jcc);
12308 %}
12309 
12310 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12311 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12312   predicate(n-&gt;has_vector_mask_set());
12313   match(CountedLoopEnd cop cmp);
12314   effect(USE labl);
12315 
12316   ins_cost(400);
12317   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12318             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12319   size(10);
12320   ins_encode %{
12321     Label* L = $labl$$label;
12322     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12323     __ restorevectmask();
12324   %}
12325   ins_pipe(pipe_jcc);
12326 %}
12327 
12328 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12329   predicate(n-&gt;has_vector_mask_set());
12330   match(CountedLoopEnd cop cmp);
12331   effect(USE labl);
12332 
12333   ins_cost(300);
12334   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12335             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12336   size(10);
12337   ins_encode %{
12338     Label* L = $labl$$label;
12339     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12340     __ restorevectmask();
12341   %}
12342   ins_pipe(pipe_jcc);
12343 %}
12344 
12345 // Jump Direct Conditional - using unsigned comparison
12346 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12347   match(If cop cmp);
12348   effect(USE labl);
12349 
12350   ins_cost(300);
12351   format %{ &quot;j$cop,u   $labl&quot; %}
12352   size(6);
12353   ins_encode %{
12354     Label* L = $labl$$label;
12355     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12356   %}
12357   ins_pipe(pipe_jcc);
12358 %}
12359 
12360 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12361   match(If cop cmp);
12362   effect(USE labl);
12363 
12364   ins_cost(200);
12365   format %{ &quot;j$cop,u   $labl&quot; %}
12366   size(6);
12367   ins_encode %{
12368     Label* L = $labl$$label;
12369     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12370   %}
12371   ins_pipe(pipe_jcc);
12372 %}
12373 
12374 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12375   match(If cop cmp);
12376   effect(USE labl);
12377 
12378   ins_cost(200);
12379   format %{ $$template
12380     if ($cop$$cmpcode == Assembler::notEqual) {
12381       $$emit$$&quot;jp,u    $labl\n\t&quot;
12382       $$emit$$&quot;j$cop,u   $labl&quot;
12383     } else {
12384       $$emit$$&quot;jp,u    done\n\t&quot;
12385       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12386       $$emit$$&quot;done:&quot;
12387     }
12388   %}
12389   ins_encode %{
12390     Label* l = $labl$$label;
12391     if ($cop$$cmpcode == Assembler::notEqual) {
12392       __ jcc(Assembler::parity, *l, false);
12393       __ jcc(Assembler::notEqual, *l, false);
12394     } else if ($cop$$cmpcode == Assembler::equal) {
12395       Label done;
12396       __ jccb(Assembler::parity, done);
12397       __ jcc(Assembler::equal, *l, false);
12398       __ bind(done);
12399     } else {
12400        ShouldNotReachHere();
12401     }
12402   %}
12403   ins_pipe(pipe_jcc);
12404 %}
12405 
12406 // ============================================================================
12407 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary
12408 // superklass array for an instance of the superklass.  Set a hidden
12409 // internal cache on a hit (cache is checked with exposed code in
12410 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
12411 // encoding ALSO sets flags.
12412 
12413 instruct partialSubtypeCheck(rdi_RegP result,
12414                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12415                              rFlagsReg cr)
12416 %{
12417   match(Set result (PartialSubtypeCheck sub super));
12418   effect(KILL rcx, KILL cr);
12419 
12420   ins_cost(1100);  // slightly larger than the next version
12421   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12422             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12423             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12424             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t&quot;
12425             &quot;jne,s   miss\t\t# Missed: rdi not-zero\n\t&quot;
12426             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12427             &quot;xorq    $result, $result\t\t Hit: rdi zero\n\t&quot;
12428     &quot;miss:\t&quot; %}
12429 
12430   opcode(0x1); // Force a XOR of RDI
12431   ins_encode(enc_PartialSubtypeCheck());
12432   ins_pipe(pipe_slow);
12433 %}
12434 
12435 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
12436                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12437                                      immP0 zero,
12438                                      rdi_RegP result)
12439 %{
12440   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12441   effect(KILL rcx, KILL result);
12442 
12443   ins_cost(1000);
12444   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12445             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12446             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12447             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t&quot;
12448             &quot;jne,s   miss\t\t# Missed: flags nz\n\t&quot;
12449             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12450     &quot;miss:\t&quot; %}
12451 
12452   opcode(0x0); // No need to XOR RDI
12453   ins_encode(enc_PartialSubtypeCheck());
12454   ins_pipe(pipe_slow);
12455 %}
12456 
12457 // ============================================================================
12458 // Branch Instructions -- short offset versions
12459 //
12460 // These instructions are used to replace jumps of a long offset (the default
12461 // match) with jumps of a shorter offset.  These instructions are all tagged
12462 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12463 // match rules in general matching.  Instead, the ADLC generates a conversion
12464 // method in the MachNode which can be used to do in-place replacement of the
12465 // long variant with the shorter variant.  The compiler will determine if a
12466 // branch can be taken by the is_short_branch_offset() predicate in the machine
12467 // specific code section of the file.
12468 
12469 // Jump Direct - Label defines a relative address from JMP+1
12470 instruct jmpDir_short(label labl) %{
12471   match(Goto);
12472   effect(USE labl);
12473 
12474   ins_cost(300);
12475   format %{ &quot;jmp,s   $labl&quot; %}
12476   size(2);
12477   ins_encode %{
12478     Label* L = $labl$$label;
12479     __ jmpb(*L);
12480   %}
12481   ins_pipe(pipe_jmp);
12482   ins_short_branch(1);
12483 %}
12484 
12485 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12486 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
12487   match(If cop cr);
12488   effect(USE labl);
12489 
12490   ins_cost(300);
12491   format %{ &quot;j$cop,s   $labl&quot; %}
12492   size(2);
12493   ins_encode %{
12494     Label* L = $labl$$label;
12495     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12496   %}
12497   ins_pipe(pipe_jcc);
12498   ins_short_branch(1);
12499 %}
12500 
12501 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12502 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
12503   match(CountedLoopEnd cop cr);
12504   effect(USE labl);
12505 
12506   ins_cost(300);
12507   format %{ &quot;j$cop,s   $labl\t# loop end&quot; %}
12508   size(2);
12509   ins_encode %{
12510     Label* L = $labl$$label;
12511     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12512   %}
12513   ins_pipe(pipe_jcc);
12514   ins_short_branch(1);
12515 %}
12516 
12517 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12518 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12519   match(CountedLoopEnd cop cmp);
12520   effect(USE labl);
12521 
12522   ins_cost(300);
12523   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12524   size(2);
12525   ins_encode %{
12526     Label* L = $labl$$label;
12527     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12528   %}
12529   ins_pipe(pipe_jcc);
12530   ins_short_branch(1);
12531 %}
12532 
12533 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12534   match(CountedLoopEnd cop cmp);
12535   effect(USE labl);
12536 
12537   ins_cost(300);
12538   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12539   size(2);
12540   ins_encode %{
12541     Label* L = $labl$$label;
12542     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12543   %}
12544   ins_pipe(pipe_jcc);
12545   ins_short_branch(1);
12546 %}
12547 
12548 // Jump Direct Conditional - using unsigned comparison
12549 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12550   match(If cop cmp);
12551   effect(USE labl);
12552 
12553   ins_cost(300);
12554   format %{ &quot;j$cop,us  $labl&quot; %}
12555   size(2);
12556   ins_encode %{
12557     Label* L = $labl$$label;
12558     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12559   %}
12560   ins_pipe(pipe_jcc);
12561   ins_short_branch(1);
12562 %}
12563 
12564 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12565   match(If cop cmp);
12566   effect(USE labl);
12567 
12568   ins_cost(300);
12569   format %{ &quot;j$cop,us  $labl&quot; %}
12570   size(2);
12571   ins_encode %{
12572     Label* L = $labl$$label;
12573     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12574   %}
12575   ins_pipe(pipe_jcc);
12576   ins_short_branch(1);
12577 %}
12578 
12579 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12580   match(If cop cmp);
12581   effect(USE labl);
12582 
12583   ins_cost(300);
12584   format %{ $$template
12585     if ($cop$$cmpcode == Assembler::notEqual) {
12586       $$emit$$&quot;jp,u,s  $labl\n\t&quot;
12587       $$emit$$&quot;j$cop,u,s  $labl&quot;
12588     } else {
12589       $$emit$$&quot;jp,u,s  done\n\t&quot;
12590       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12591       $$emit$$&quot;done:&quot;
12592     }
12593   %}
12594   size(4);
12595   ins_encode %{
12596     Label* l = $labl$$label;
12597     if ($cop$$cmpcode == Assembler::notEqual) {
12598       __ jccb(Assembler::parity, *l);
12599       __ jccb(Assembler::notEqual, *l);
12600     } else if ($cop$$cmpcode == Assembler::equal) {
12601       Label done;
12602       __ jccb(Assembler::parity, done);
12603       __ jccb(Assembler::equal, *l);
12604       __ bind(done);
12605     } else {
12606        ShouldNotReachHere();
12607     }
12608   %}
12609   ins_pipe(pipe_jcc);
12610   ins_short_branch(1);
12611 %}
12612 
12613 // ============================================================================
12614 // inlined locking and unlocking
12615 
12616 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12617   predicate(Compile::current()-&gt;use_rtm());
12618   match(Set cr (FastLock object box));
12619   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12620   ins_cost(300);
12621   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12622   ins_encode %{
12623     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12624                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12625                  _counters, _rtm_counters, _stack_rtm_counters,
12626                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12627                  true, ra_-&gt;C-&gt;profile_rtm());
12628   %}
12629   ins_pipe(pipe_slow);
12630 %}
12631 
12632 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr, rRegP cx1) %{
12633   predicate(!Compile::current()-&gt;use_rtm());
12634   match(Set cr (FastLock object box));
12635   effect(TEMP tmp, TEMP scr, TEMP cx1, USE_KILL box);
12636   ins_cost(300);
12637   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12638   ins_encode %{
12639     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12640                  $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);
12641   %}
12642   ins_pipe(pipe_slow);
12643 %}
12644 
12645 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12646   match(Set cr (FastUnlock object box));
12647   effect(TEMP tmp, USE_KILL box);
12648   ins_cost(300);
12649   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12650   ins_encode %{
12651     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12652   %}
12653   ins_pipe(pipe_slow);
12654 %}
12655 
12656 
12657 // ============================================================================
12658 // Safepoint Instructions
12659 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12660 %{
12661   match(SafePoint poll);
12662   effect(KILL cr, USE poll);
12663 
12664   format %{ &quot;testl   rax, [$poll]\t&quot;
12665             &quot;# Safepoint: poll for GC&quot; %}
12666   ins_cost(125);
12667   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12668   ins_encode %{
12669     __ relocate(relocInfo::poll_type);
12670     address pre_pc = __ pc();
12671     __ testl(rax, Address($poll$$Register, 0));
12672     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12673   %}
12674   ins_pipe(ialu_reg_mem);
12675 %}
12676 
12677 // ============================================================================
12678 // Procedure Call/Return Instructions
12679 // Call Java Static Instruction
12680 // Note: If this code changes, the corresponding ret_addr_offset() and
12681 //       compute_padding() functions will have to be adjusted.
12682 instruct CallStaticJavaDirect(method meth) %{
12683   match(CallStaticJava);
12684   effect(USE meth);
12685 
12686   ins_cost(300);
12687   format %{ &quot;call,static &quot; %}
12688   opcode(0xE8); /* E8 cd */
12689   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
12690   ins_pipe(pipe_slow);
12691   ins_alignment(4);
12692 %}
12693 
12694 // Call Java Dynamic Instruction
12695 // Note: If this code changes, the corresponding ret_addr_offset() and
12696 //       compute_padding() functions will have to be adjusted.
12697 instruct CallDynamicJavaDirect(method meth)
12698 %{
12699   match(CallDynamicJava);
12700   effect(USE meth);
12701 
12702   ins_cost(300);
12703   format %{ &quot;movq    rax, #Universe::non_oop_word()\n\t&quot;
12704             &quot;call,dynamic &quot; %}
12705   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
12706   ins_pipe(pipe_slow);
12707   ins_alignment(4);
12708 %}
12709 
12710 // Call Runtime Instruction
12711 instruct CallRuntimeDirect(method meth)
12712 %{
12713   match(CallRuntime);
12714   effect(USE meth);
12715 
12716   ins_cost(300);
12717   format %{ &quot;call,runtime &quot; %}
12718   ins_encode(clear_avx, Java_To_Runtime(meth));
12719   ins_pipe(pipe_slow);
12720 %}
12721 
12722 // Call runtime without safepoint
12723 instruct CallLeafDirect(method meth)
12724 %{
12725   match(CallLeaf);
12726   effect(USE meth);
12727 
12728   ins_cost(300);
12729   format %{ &quot;call_leaf,runtime &quot; %}
12730   ins_encode(clear_avx, Java_To_Runtime(meth));
12731   ins_pipe(pipe_slow);
12732 %}
12733 
12734 // Call runtime without safepoint
12735 // entry point is null, target holds the address to call
12736 instruct CallLeafNoFPInDirect(rRegP target)
12737 %{
12738   predicate(n-&gt;as_Call()-&gt;entry_point() == NULL);
12739   match(CallLeafNoFP target);
12740 
12741   ins_cost(300);
12742   format %{ &quot;call_leaf_nofp,runtime indirect &quot; %}
12743   ins_encode %{
12744      __ call($target$$Register);
12745   %}
12746 
12747   ins_pipe(pipe_slow);
12748 %}
12749 
12750 instruct CallLeafNoFPDirect(method meth)
12751 %{
12752   predicate(n-&gt;as_Call()-&gt;entry_point() != NULL);
12753   match(CallLeafNoFP);
12754   effect(USE meth);
12755 
12756   ins_cost(300);
12757   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12758   ins_encode(clear_avx, Java_To_Runtime(meth));
12759   ins_pipe(pipe_slow);
12760 %}
12761 
12762 // Return Instruction
12763 // Remove the return address &amp; jump to it.
12764 // Notice: We always emit a nop after a ret to make sure there is room
12765 // for safepoint patching
12766 instruct Ret()
12767 %{
12768   match(Return);
12769 
12770   format %{ &quot;ret&quot; %}
12771   opcode(0xC3);
12772   ins_encode(OpcP);
12773   ins_pipe(pipe_jmp);
12774 %}
12775 
12776 // Tail Call; Jump from runtime stub to Java code.
12777 // Also known as an &#39;interprocedural jump&#39;.
12778 // Target of jump will eventually return to caller.
12779 // TailJump below removes the return address.
12780 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
12781 %{
12782   match(TailCall jump_target method_oop);
12783 
12784   ins_cost(300);
12785   format %{ &quot;jmp     $jump_target\t# rbx holds method oop&quot; %}
12786   opcode(0xFF, 0x4); /* Opcode FF /4 */
12787   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
12788   ins_pipe(pipe_jmp);
12789 %}
12790 
12791 // Tail Jump; remove the return address; jump to target.
12792 // TailCall above leaves the return address around.
12793 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
12794 %{
12795   match(TailJump jump_target ex_oop);
12796 
12797   ins_cost(300);
12798   format %{ &quot;popq    rdx\t# pop return address\n\t&quot;
12799             &quot;jmp     $jump_target&quot; %}
12800   opcode(0xFF, 0x4); /* Opcode FF /4 */
12801   ins_encode(Opcode(0x5a), // popq rdx
12802              REX_reg(jump_target), OpcP, reg_opc(jump_target));
12803   ins_pipe(pipe_jmp);
12804 %}
12805 
12806 // Create exception oop: created by stack-crawling runtime code.
12807 // Created exception is now available to this handler, and is setup
12808 // just prior to jumping to this handler.  No code emitted.
12809 instruct CreateException(rax_RegP ex_oop)
12810 %{
12811   match(Set ex_oop (CreateEx));
12812 
12813   size(0);
12814   // use the following format syntax
12815   format %{ &quot;# exception oop is in rax; no code emitted&quot; %}
12816   ins_encode();
12817   ins_pipe(empty);
12818 %}
12819 
12820 // Rethrow exception:
12821 // The exception oop will come in the first argument position.
12822 // Then JUMP (not call) to the rethrow stub code.
12823 instruct RethrowException()
12824 %{
12825   match(Rethrow);
12826 
12827   // use the following format syntax
12828   format %{ &quot;jmp     rethrow_stub&quot; %}
12829   ins_encode(enc_rethrow);
12830   ins_pipe(pipe_jmp);
12831 %}
12832 
12833 // ============================================================================
12834 // This name is KNOWN by the ADLC and cannot be changed.
12835 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
12836 // for this guy.
12837 instruct tlsLoadP(r15_RegP dst) %{
12838   match(Set dst (ThreadLocal));
12839   effect(DEF dst);
12840 
12841   size(0);
12842   format %{ &quot;# TLS is in R15&quot; %}
12843   ins_encode( /*empty encoding*/ );
12844   ins_pipe(ialu_reg_reg);
12845 %}
12846 
12847 
12848 //----------PEEPHOLE RULES-----------------------------------------------------
12849 // These must follow all instruction definitions as they use the names
12850 // defined in the instructions definitions.
12851 //
12852 // peepmatch ( root_instr_name [preceding_instruction]* );
12853 //
12854 // peepconstraint %{
12855 // (instruction_number.operand_name relational_op instruction_number.operand_name
12856 //  [, ...] );
12857 // // instruction numbers are zero-based using left to right order in peepmatch
12858 //
12859 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
12860 // // provide an instruction_number.operand_name for each operand that appears
12861 // // in the replacement instruction&#39;s match rule
12862 //
12863 // ---------VM FLAGS---------------------------------------------------------
12864 //
12865 // All peephole optimizations can be turned off using -XX:-OptoPeephole
12866 //
12867 // Each peephole rule is given an identifying number starting with zero and
12868 // increasing by one in the order seen by the parser.  An individual peephole
12869 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
12870 // on the command-line.
12871 //
12872 // ---------CURRENT LIMITATIONS----------------------------------------------
12873 //
12874 // Only match adjacent instructions in same basic block
12875 // Only equality constraints
12876 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12877 // Only one replacement instruction
12878 //
12879 // ---------EXAMPLE----------------------------------------------------------
12880 //
12881 // // pertinent parts of existing instructions in architecture description
12882 // instruct movI(rRegI dst, rRegI src)
12883 // %{
12884 //   match(Set dst (CopyI src));
12885 // %}
12886 //
12887 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12888 // %{
12889 //   match(Set dst (AddI dst src));
12890 //   effect(KILL cr);
12891 // %}
12892 //
12893 // // Change (inc mov) to lea
12894 // peephole %{
12895 //   // increment preceeded by register-register move
12896 //   peepmatch ( incI_rReg movI );
12897 //   // require that the destination register of the increment
12898 //   // match the destination register of the move
12899 //   peepconstraint ( 0.dst == 1.dst );
12900 //   // construct a replacement instruction that sets
12901 //   // the destination to ( move&#39;s source register + one )
12902 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
12903 // %}
12904 //
12905 
12906 // Implementation no longer uses movX instructions since
12907 // machine-independent system no longer uses CopyX nodes.
12908 //
12909 // peephole
12910 // %{
12911 //   peepmatch (incI_rReg movI);
12912 //   peepconstraint (0.dst == 1.dst);
12913 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12914 // %}
12915 
12916 // peephole
12917 // %{
12918 //   peepmatch (decI_rReg movI);
12919 //   peepconstraint (0.dst == 1.dst);
12920 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12921 // %}
12922 
12923 // peephole
12924 // %{
12925 //   peepmatch (addI_rReg_imm movI);
12926 //   peepconstraint (0.dst == 1.dst);
12927 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12928 // %}
12929 
12930 // peephole
12931 // %{
12932 //   peepmatch (incL_rReg movL);
12933 //   peepconstraint (0.dst == 1.dst);
12934 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12935 // %}
12936 
12937 // peephole
12938 // %{
12939 //   peepmatch (decL_rReg movL);
12940 //   peepconstraint (0.dst == 1.dst);
12941 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12942 // %}
12943 
12944 // peephole
12945 // %{
12946 //   peepmatch (addL_rReg_imm movL);
12947 //   peepconstraint (0.dst == 1.dst);
12948 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12949 // %}
12950 
12951 // peephole
12952 // %{
12953 //   peepmatch (addP_rReg_imm movP);
12954 //   peepconstraint (0.dst == 1.dst);
12955 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
12956 // %}
12957 
12958 // // Change load of spilled value to only a spill
12959 // instruct storeI(memory mem, rRegI src)
12960 // %{
12961 //   match(Set mem (StoreI mem src));
12962 // %}
12963 //
12964 // instruct loadI(rRegI dst, memory mem)
12965 // %{
12966 //   match(Set dst (LoadI mem));
12967 // %}
12968 //
12969 
12970 peephole
12971 %{
12972   peepmatch (loadI storeI);
12973   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12974   peepreplace (storeI(1.mem 1.mem 1.src));
12975 %}
12976 
12977 peephole
12978 %{
12979   peepmatch (loadL storeL);
12980   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12981   peepreplace (storeL(1.mem 1.mem 1.src));
12982 %}
12983 
12984 //----------SMARTSPILL RULES---------------------------------------------------
12985 // These must follow all instruction definitions as they use the names
12986 // defined in the instructions definitions.
    </pre>
  </body>
</html>