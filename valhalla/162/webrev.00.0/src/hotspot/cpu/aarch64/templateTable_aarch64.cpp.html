<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/interp_masm.hpp&quot;
  32 #include &quot;interpreter/templateTable.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
  34 #include &quot;oops/methodData.hpp&quot;
  35 #include &quot;oops/method.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/oop.inline.hpp&quot;
  38 #include &quot;prims/methodHandles.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/synchronizer.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 // Platform-dependent initialization
  48 
  49 void TemplateTable::pd_initialize() {
  50   // No aarch64 specific initialization
  51 }
  52 
  53 // Address computation: local variables
  54 
  55 static inline Address iaddress(int n) {
  56   return Address(rlocals, Interpreter::local_offset_in_bytes(n));
  57 }
  58 
  59 static inline Address laddress(int n) {
  60   return iaddress(n + 1);
  61 }
  62 
  63 static inline Address faddress(int n) {
  64   return iaddress(n);
  65 }
  66 
  67 static inline Address daddress(int n) {
  68   return laddress(n);
  69 }
  70 
  71 static inline Address aaddress(int n) {
  72   return iaddress(n);
  73 }
  74 
  75 static inline Address iaddress(Register r) {
  76   return Address(rlocals, r, Address::lsl(3));
  77 }
  78 
  79 static inline Address laddress(Register r, Register scratch,
  80                                InterpreterMacroAssembler* _masm) {
  81   __ lea(scratch, Address(rlocals, r, Address::lsl(3)));
  82   return Address(scratch, Interpreter::local_offset_in_bytes(1));
  83 }
  84 
  85 static inline Address faddress(Register r) {
  86   return iaddress(r);
  87 }
  88 
  89 static inline Address daddress(Register r, Register scratch,
  90                                InterpreterMacroAssembler* _masm) {
  91   return laddress(r, scratch, _masm);
  92 }
  93 
  94 static inline Address aaddress(Register r) {
  95   return iaddress(r);
  96 }
  97 
  98 static inline Address at_rsp() {
  99   return Address(esp, 0);
 100 }
 101 
 102 // At top of Java expression stack which may be different than esp().  It
 103 // isn&#39;t for category 1 objects.
 104 static inline Address at_tos   () {
 105   return Address(esp,  Interpreter::expr_offset_in_bytes(0));
 106 }
 107 
 108 static inline Address at_tos_p1() {
 109   return Address(esp,  Interpreter::expr_offset_in_bytes(1));
 110 }
 111 
 112 static inline Address at_tos_p2() {
 113   return Address(esp,  Interpreter::expr_offset_in_bytes(2));
 114 }
 115 
 116 static inline Address at_tos_p3() {
 117   return Address(esp,  Interpreter::expr_offset_in_bytes(3));
 118 }
 119 
 120 static inline Address at_tos_p4() {
 121   return Address(esp,  Interpreter::expr_offset_in_bytes(4));
 122 }
 123 
 124 static inline Address at_tos_p5() {
 125   return Address(esp,  Interpreter::expr_offset_in_bytes(5));
 126 }
 127 
 128 // Condition conversion
 129 static Assembler::Condition j_not(TemplateTable::Condition cc) {
 130   switch (cc) {
 131   case TemplateTable::equal        : return Assembler::NE;
 132   case TemplateTable::not_equal    : return Assembler::EQ;
 133   case TemplateTable::less         : return Assembler::GE;
 134   case TemplateTable::less_equal   : return Assembler::GT;
 135   case TemplateTable::greater      : return Assembler::LE;
 136   case TemplateTable::greater_equal: return Assembler::LT;
 137   }
 138   ShouldNotReachHere();
 139   return Assembler::EQ;
 140 }
 141 
 142 
 143 // Miscelaneous helper routines
 144 // Store an oop (or NULL) at the Address described by obj.
 145 // If val == noreg this means store a NULL
 146 static void do_oop_store(InterpreterMacroAssembler* _masm,
 147                          Address dst,
 148                          Register val,
 149                          DecoratorSet decorators) {
 150   assert(val == noreg || val == r0, &quot;parameter is just for looks&quot;);
 151   __ store_heap_oop(dst, val, r10, r1, noreg, decorators);
 152 }
 153 
 154 static void do_oop_load(InterpreterMacroAssembler* _masm,
 155                         Address src,
 156                         Register dst,
 157                         DecoratorSet decorators) {
 158   __ load_heap_oop(dst, src, r10, r1, decorators);
 159 }
 160 
 161 Address TemplateTable::at_bcp(int offset) {
 162   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 163   return Address(rbcp, offset);
 164 }
 165 
 166 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 167                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 168                                    int byte_no)
 169 {
 170   if (!RewriteBytecodes)  return;
 171   Label L_patch_done;
 172 
 173   switch (bc) {
 174   case Bytecodes::_fast_qputfield:
 175   case Bytecodes::_fast_aputfield:
 176   case Bytecodes::_fast_bputfield:
 177   case Bytecodes::_fast_zputfield:
 178   case Bytecodes::_fast_cputfield:
 179   case Bytecodes::_fast_dputfield:
 180   case Bytecodes::_fast_fputfield:
 181   case Bytecodes::_fast_iputfield:
 182   case Bytecodes::_fast_lputfield:
 183   case Bytecodes::_fast_sputfield:
 184     {
 185       // We skip bytecode quickening for putfield instructions when
 186       // the put_code written to the constant pool cache is zero.
 187       // This is required so that every execution of this instruction
 188       // calls out to InterpreterRuntime::resolve_get_put to do
 189       // additional, required work.
 190       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 191       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 192       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 193       __ movw(bc_reg, bc);
 194       __ cbzw(temp_reg, L_patch_done);  // don&#39;t patch
 195     }
 196     break;
 197   default:
 198     assert(byte_no == -1, &quot;sanity&quot;);
 199     // the pair bytecodes have already done the load.
 200     if (load_bc_into_bc_reg) {
 201       __ movw(bc_reg, bc);
 202     }
 203   }
 204 
 205   if (JvmtiExport::can_post_breakpoint()) {
 206     Label L_fast_patch;
 207     // if a breakpoint is present we can&#39;t rewrite the stream directly
 208     __ load_unsigned_byte(temp_reg, at_bcp(0));
 209     __ cmpw(temp_reg, Bytecodes::_breakpoint);
 210     __ br(Assembler::NE, L_fast_patch);
 211     // Let breakpoint table handling rewrite to quicker bytecode
 212     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::set_original_bytecode_at), rmethod, rbcp, bc_reg);
 213     __ b(L_patch_done);
 214     __ bind(L_fast_patch);
 215   }
 216 
 217 #ifdef ASSERT
 218   Label L_okay;
 219   __ load_unsigned_byte(temp_reg, at_bcp(0));
 220   __ cmpw(temp_reg, (int) Bytecodes::java_code(bc));
 221   __ br(Assembler::EQ, L_okay);
 222   __ cmpw(temp_reg, bc_reg);
 223   __ br(Assembler::EQ, L_okay);
 224   __ stop(&quot;patching the wrong bytecode&quot;);
 225   __ bind(L_okay);
 226 #endif
 227 
 228   // patch bytecode
 229   __ strb(bc_reg, at_bcp(0));
 230   __ bind(L_patch_done);
 231 }
 232 
 233 
 234 // Individual instructions
 235 
 236 void TemplateTable::nop() {
 237   transition(vtos, vtos);
 238   // nothing to do
 239 }
 240 
 241 void TemplateTable::shouldnotreachhere() {
 242   transition(vtos, vtos);
 243   __ stop(&quot;shouldnotreachhere bytecode&quot;);
 244 }
 245 
 246 void TemplateTable::aconst_null()
 247 {
 248   transition(vtos, atos);
 249   __ mov(r0, 0);
 250 }
 251 
 252 void TemplateTable::iconst(int value)
 253 {
 254   transition(vtos, itos);
 255   __ mov(r0, value);
 256 }
 257 
 258 void TemplateTable::lconst(int value)
 259 {
 260   __ mov(r0, value);
 261 }
 262 
 263 void TemplateTable::fconst(int value)
 264 {
 265   transition(vtos, ftos);
 266   switch (value) {
 267   case 0:
 268     __ fmovs(v0, zr);
 269     break;
 270   case 1:
 271     __ fmovs(v0, 1.0);
 272     break;
 273   case 2:
 274     __ fmovs(v0, 2.0);
 275     break;
 276   default:
 277     ShouldNotReachHere();
 278     break;
 279   }
 280 }
 281 
 282 void TemplateTable::dconst(int value)
 283 {
 284   transition(vtos, dtos);
 285   switch (value) {
 286   case 0:
 287     __ fmovd(v0, zr);
 288     break;
 289   case 1:
 290     __ fmovd(v0, 1.0);
 291     break;
 292   case 2:
 293     __ fmovd(v0, 2.0);
 294     break;
 295   default:
 296     ShouldNotReachHere();
 297     break;
 298   }
 299 }
 300 
 301 void TemplateTable::bipush()
 302 {
 303   transition(vtos, itos);
 304   __ load_signed_byte32(r0, at_bcp(1));
 305 }
 306 
 307 void TemplateTable::sipush()
 308 {
 309   transition(vtos, itos);
 310   __ load_unsigned_short(r0, at_bcp(1));
 311   __ revw(r0, r0);
 312   __ asrw(r0, r0, 16);
 313 }
 314 
 315 void TemplateTable::ldc(bool wide)
 316 {
 317   transition(vtos, vtos);
 318   Label call_ldc, notFloat, notClass, notInt, Done;
 319 
 320   if (wide) {
 321     __ get_unsigned_2_byte_index_at_bcp(r1, 1);
 322   } else {
 323     __ load_unsigned_byte(r1, at_bcp(1));
 324   }
 325   __ get_cpool_and_tags(r2, r0);
 326 
 327   const int base_offset = ConstantPool::header_size() * wordSize;
 328   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 329 
 330   // get type
 331   __ add(r3, r1, tags_offset);
 332   __ lea(r3, Address(r0, r3));
 333   __ ldarb(r3, r3);
 334 
 335   // unresolved class - get the resolved class
 336   __ cmp(r3, (u1)JVM_CONSTANT_UnresolvedClass);
 337   __ br(Assembler::EQ, call_ldc);
 338 
 339   // unresolved class in error state - call into runtime to throw the error
 340   // from the first resolution attempt
 341   __ cmp(r3, (u1)JVM_CONSTANT_UnresolvedClassInError);
 342   __ br(Assembler::EQ, call_ldc);
 343 
 344   // resolved class - need to call vm to get java mirror of the class
 345   __ cmp(r3, (u1)JVM_CONSTANT_Class);
 346   __ br(Assembler::NE, notClass);
 347 
 348   __ bind(call_ldc);
 349   __ mov(c_rarg1, wide);
 350   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), c_rarg1);
 351   __ push_ptr(r0);
 352   __ verify_oop(r0);
 353   __ b(Done);
 354 
 355   __ bind(notClass);
 356   __ cmp(r3, (u1)JVM_CONSTANT_Float);
 357   __ br(Assembler::NE, notFloat);
 358   // ftos
 359   __ adds(r1, r2, r1, Assembler::LSL, 3);
 360   __ ldrs(v0, Address(r1, base_offset));
 361   __ push_f();
 362   __ b(Done);
 363 
 364   __ bind(notFloat);
 365 
 366   __ cmp(r3, (u1)JVM_CONSTANT_Integer);
 367   __ br(Assembler::NE, notInt);
 368 
 369   // itos
 370   __ adds(r1, r2, r1, Assembler::LSL, 3);
 371   __ ldrw(r0, Address(r1, base_offset));
 372   __ push_i(r0);
 373   __ b(Done);
 374 
 375   __ bind(notInt);
 376   condy_helper(Done);
 377 
 378   __ bind(Done);
 379 }
 380 
 381 // Fast path for caching oop constants.
 382 void TemplateTable::fast_aldc(bool wide)
 383 {
 384   transition(vtos, atos);
 385 
 386   Register result = r0;
 387   Register tmp = r1;
 388   Register rarg = r2;
 389 
 390   int index_size = wide ? sizeof(u2) : sizeof(u1);
 391 
 392   Label resolved;
 393 
 394   // We are resolved if the resolved reference cache entry contains a
 395   // non-null object (String, MethodType, etc.)
 396   assert_different_registers(result, tmp);
 397   __ get_cache_index_at_bcp(tmp, 1, index_size);
 398   __ load_resolved_reference_at_index(result, tmp);
 399   __ cbnz(result, resolved);
 400 
 401   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 402 
 403   // first time invocation - must resolve first
 404   __ mov(rarg, (int)bytecode());
 405   __ call_VM(result, entry, rarg);
 406 
 407   __ bind(resolved);
 408 
 409   { // Check for the null sentinel.
 410     // If we just called the VM, it already did the mapping for us,
 411     // but it&#39;s harmless to retry.
 412     Label notNull;
 413 
 414     // Stash null_sentinel address to get its value later
 415     __ movptr(rarg, (uintptr_t)Universe::the_null_sentinel_addr());
 416     __ ldr(tmp, Address(rarg));
 417     __ cmpoop(result, tmp);
 418     __ br(Assembler::NE, notNull);
 419     __ mov(result, 0);  // NULL object reference
 420     __ bind(notNull);
 421   }
 422 
 423   if (VerifyOops) {
 424     // Safe to call with 0 result
 425     __ verify_oop(result);
 426   }
 427 }
 428 
 429 void TemplateTable::ldc2_w()
 430 {
 431   transition(vtos, vtos);
 432   Label notDouble, notLong, Done;
 433   __ get_unsigned_2_byte_index_at_bcp(r0, 1);
 434 
 435   __ get_cpool_and_tags(r1, r2);
 436   const int base_offset = ConstantPool::header_size() * wordSize;
 437   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 438 
 439   // get type
 440   __ lea(r2, Address(r2, r0, Address::lsl(0)));
 441   __ load_unsigned_byte(r2, Address(r2, tags_offset));
 442   __ cmpw(r2, (int)JVM_CONSTANT_Double);
 443   __ br(Assembler::NE, notDouble);
 444 
 445   // dtos
 446   __ lea (r2, Address(r1, r0, Address::lsl(3)));
 447   __ ldrd(v0, Address(r2, base_offset));
 448   __ push_d();
 449   __ b(Done);
 450 
 451   __ bind(notDouble);
 452   __ cmpw(r2, (int)JVM_CONSTANT_Long);
 453   __ br(Assembler::NE, notLong);
 454 
 455   // ltos
 456   __ lea(r0, Address(r1, r0, Address::lsl(3)));
 457   __ ldr(r0, Address(r0, base_offset));
 458   __ push_l();
 459   __ b(Done);
 460 
 461   __ bind(notLong);
 462   condy_helper(Done);
 463 
 464   __ bind(Done);
 465 }
 466 
 467 void TemplateTable::condy_helper(Label&amp; Done)
 468 {
 469   Register obj = r0;
 470   Register rarg = r1;
 471   Register flags = r2;
 472   Register off = r3;
 473 
 474   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 475 
 476   __ mov(rarg, (int) bytecode());
 477   __ call_VM(obj, entry, rarg);
 478 
 479   __ get_vm_result_2(flags, rthread);
 480 
 481   // VMr = obj = base address to find primitive value to push
 482   // VMr2 = flags = (tos, off) using format of CPCE::_flags
 483   __ mov(off, flags);
 484   __ andw(off, off, ConstantPoolCacheEntry::field_index_mask);
 485 
 486   const Address field(obj, off);
 487 
 488   // What sort of thing are we loading?
 489   // x86 uses a shift and mask or wings it with a shift plus assert
 490   // the mask is not needed. aarch64 just uses bitfield extract
 491   __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,
 492            ConstantPoolCacheEntry::tos_state_bits);
 493 
 494   switch (bytecode()) {
 495     case Bytecodes::_ldc:
 496     case Bytecodes::_ldc_w:
 497       {
 498         // tos in (itos, ftos, stos, btos, ctos, ztos)
 499         Label notInt, notFloat, notShort, notByte, notChar, notBool;
 500         __ cmpw(flags, itos);
 501         __ br(Assembler::NE, notInt);
 502         // itos
 503         __ ldrw(r0, field);
 504         __ push(itos);
 505         __ b(Done);
 506 
 507         __ bind(notInt);
 508         __ cmpw(flags, ftos);
 509         __ br(Assembler::NE, notFloat);
 510         // ftos
 511         __ load_float(field);
 512         __ push(ftos);
 513         __ b(Done);
 514 
 515         __ bind(notFloat);
 516         __ cmpw(flags, stos);
 517         __ br(Assembler::NE, notShort);
 518         // stos
 519         __ load_signed_short(r0, field);
 520         __ push(stos);
 521         __ b(Done);
 522 
 523         __ bind(notShort);
 524         __ cmpw(flags, btos);
 525         __ br(Assembler::NE, notByte);
 526         // btos
 527         __ load_signed_byte(r0, field);
 528         __ push(btos);
 529         __ b(Done);
 530 
 531         __ bind(notByte);
 532         __ cmpw(flags, ctos);
 533         __ br(Assembler::NE, notChar);
 534         // ctos
 535         __ load_unsigned_short(r0, field);
 536         __ push(ctos);
 537         __ b(Done);
 538 
 539         __ bind(notChar);
 540         __ cmpw(flags, ztos);
 541         __ br(Assembler::NE, notBool);
 542         // ztos
 543         __ load_signed_byte(r0, field);
 544         __ push(ztos);
 545         __ b(Done);
 546 
 547         __ bind(notBool);
 548         break;
 549       }
 550 
 551     case Bytecodes::_ldc2_w:
 552       {
 553         Label notLong, notDouble;
 554         __ cmpw(flags, ltos);
 555         __ br(Assembler::NE, notLong);
 556         // ltos
 557         __ ldr(r0, field);
 558         __ push(ltos);
 559         __ b(Done);
 560 
 561         __ bind(notLong);
 562         __ cmpw(flags, dtos);
 563         __ br(Assembler::NE, notDouble);
 564         // dtos
 565         __ load_double(field);
 566         __ push(dtos);
 567         __ b(Done);
 568 
 569        __ bind(notDouble);
 570         break;
 571       }
 572 
 573     default:
 574       ShouldNotReachHere();
 575     }
 576 
 577     __ stop(&quot;bad ldc/condy&quot;);
 578 }
 579 
 580 void TemplateTable::locals_index(Register reg, int offset)
 581 {
 582   __ ldrb(reg, at_bcp(offset));
 583   __ neg(reg, reg);
 584 }
 585 
 586 void TemplateTable::iload() {
 587   iload_internal();
 588 }
 589 
 590 void TemplateTable::nofast_iload() {
 591   iload_internal(may_not_rewrite);
 592 }
 593 
 594 void TemplateTable::iload_internal(RewriteControl rc) {
 595   transition(vtos, itos);
 596   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 597     Label rewrite, done;
 598     Register bc = r4;
 599 
 600     // get next bytecode
 601     __ load_unsigned_byte(r1, at_bcp(Bytecodes::length_for(Bytecodes::_iload)));
 602 
 603     // if _iload, wait to rewrite to iload2.  We only want to rewrite the
 604     // last two iloads in a pair.  Comparing against fast_iload means that
 605     // the next bytecode is neither an iload or a caload, and therefore
 606     // an iload pair.
 607     __ cmpw(r1, Bytecodes::_iload);
 608     __ br(Assembler::EQ, done);
 609 
 610     // if _fast_iload rewrite to _fast_iload2
 611     __ cmpw(r1, Bytecodes::_fast_iload);
 612     __ movw(bc, Bytecodes::_fast_iload2);
 613     __ br(Assembler::EQ, rewrite);
 614 
 615     // if _caload rewrite to _fast_icaload
 616     __ cmpw(r1, Bytecodes::_caload);
 617     __ movw(bc, Bytecodes::_fast_icaload);
 618     __ br(Assembler::EQ, rewrite);
 619 
 620     // else rewrite to _fast_iload
 621     __ movw(bc, Bytecodes::_fast_iload);
 622 
 623     // rewrite
 624     // bc: new bytecode
 625     __ bind(rewrite);
 626     patch_bytecode(Bytecodes::_iload, bc, r1, false);
 627     __ bind(done);
 628 
 629   }
 630 
 631   // do iload, get the local value into tos
 632   locals_index(r1);
 633   __ ldr(r0, iaddress(r1));
 634 
 635 }
 636 
 637 void TemplateTable::fast_iload2()
 638 {
 639   transition(vtos, itos);
 640   locals_index(r1);
 641   __ ldr(r0, iaddress(r1));
 642   __ push(itos);
 643   locals_index(r1, 3);
 644   __ ldr(r0, iaddress(r1));
 645 }
 646 
 647 void TemplateTable::fast_iload()
 648 {
 649   transition(vtos, itos);
 650   locals_index(r1);
 651   __ ldr(r0, iaddress(r1));
 652 }
 653 
 654 void TemplateTable::lload()
 655 {
 656   transition(vtos, ltos);
 657   __ ldrb(r1, at_bcp(1));
 658   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 659   __ ldr(r0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 660 }
 661 
 662 void TemplateTable::fload()
 663 {
 664   transition(vtos, ftos);
 665   locals_index(r1);
 666   // n.b. we use ldrd here because this is a 64 bit slot
 667   // this is comparable to the iload case
 668   __ ldrd(v0, faddress(r1));
 669 }
 670 
 671 void TemplateTable::dload()
 672 {
 673   transition(vtos, dtos);
 674   __ ldrb(r1, at_bcp(1));
 675   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 676   __ ldrd(v0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 677 }
 678 
 679 void TemplateTable::aload()
 680 {
 681   transition(vtos, atos);
 682   locals_index(r1);
 683   __ ldr(r0, iaddress(r1));
 684 }
 685 
 686 void TemplateTable::locals_index_wide(Register reg) {
 687   __ ldrh(reg, at_bcp(2));
 688   __ rev16w(reg, reg);
 689   __ neg(reg, reg);
 690 }
 691 
 692 void TemplateTable::wide_iload() {
 693   transition(vtos, itos);
 694   locals_index_wide(r1);
 695   __ ldr(r0, iaddress(r1));
 696 }
 697 
 698 void TemplateTable::wide_lload()
 699 {
 700   transition(vtos, ltos);
 701   __ ldrh(r1, at_bcp(2));
 702   __ rev16w(r1, r1);
 703   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 704   __ ldr(r0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 705 }
 706 
 707 void TemplateTable::wide_fload()
 708 {
 709   transition(vtos, ftos);
 710   locals_index_wide(r1);
 711   // n.b. we use ldrd here because this is a 64 bit slot
 712   // this is comparable to the iload case
 713   __ ldrd(v0, faddress(r1));
 714 }
 715 
 716 void TemplateTable::wide_dload()
 717 {
 718   transition(vtos, dtos);
 719   __ ldrh(r1, at_bcp(2));
 720   __ rev16w(r1, r1);
 721   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 722   __ ldrd(v0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 723 }
 724 
 725 void TemplateTable::wide_aload()
 726 {
 727   transition(vtos, atos);
 728   locals_index_wide(r1);
 729   __ ldr(r0, aaddress(r1));
 730 }
 731 
 732 void TemplateTable::index_check(Register array, Register index)
 733 {
 734   // destroys r1, rscratch1
 735   // check array
 736   __ null_check(array, arrayOopDesc::length_offset_in_bytes());
 737   // sign extend index for use by indexed load
 738   // __ movl2ptr(index, index);
 739   // check index
 740   Register length = rscratch1;
 741   __ ldrw(length, Address(array, arrayOopDesc::length_offset_in_bytes()));
 742   __ cmpw(index, length);
 743   if (index != r1) {
 744     // ??? convention: move aberrant index into r1 for exception message
 745     assert(r1 != array, &quot;different registers&quot;);
 746     __ mov(r1, index);
 747   }
 748   Label ok;
 749   __ br(Assembler::LO, ok);
 750   // ??? convention: move array into r3 for exception message
 751    __ mov(r3, array);
 752    __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);
 753    __ br(rscratch1);
 754   __ bind(ok);
 755 }
 756 
 757 void TemplateTable::iaload()
 758 {
 759   transition(itos, itos);
 760   __ mov(r1, r0);
 761   __ pop_ptr(r0);
 762   // r0: array
 763   // r1: index
 764   index_check(r0, r1); // leaves index in r1, kills rscratch1
 765   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
 766   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);
 767 }
 768 
 769 void TemplateTable::laload()
 770 {
 771   transition(itos, ltos);
 772   __ mov(r1, r0);
 773   __ pop_ptr(r0);
 774   // r0: array
 775   // r1: index
 776   index_check(r0, r1); // leaves index in r1, kills rscratch1
 777   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
 778   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);
 779 }
 780 
 781 void TemplateTable::faload()
 782 {
 783   transition(itos, ftos);
 784   __ mov(r1, r0);
 785   __ pop_ptr(r0);
 786   // r0: array
 787   // r1: index
 788   index_check(r0, r1); // leaves index in r1, kills rscratch1
 789   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
 790   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);
 791 }
 792 
 793 void TemplateTable::daload()
 794 {
 795   transition(itos, dtos);
 796   __ mov(r1, r0);
 797   __ pop_ptr(r0);
 798   // r0: array
 799   // r1: index
 800   index_check(r0, r1); // leaves index in r1, kills rscratch1
 801   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
 802   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);
 803 }
 804 
 805 void TemplateTable::aaload()
 806 {
 807   transition(itos, atos);
 808   __ mov(r1, r0);
 809   __ pop_ptr(r0);
 810   // r0: array
 811   // r1: index
 812   index_check(r0, r1); // leaves index in r1, kills rscratch1
 813   if (UseFlatArray) {
 814     Label is_flat_array, done;
 815 
 816     __ test_flattened_array_oop(r0, r8 /*temp*/, is_flat_array);
 817     __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
 818     do_oop_load(_masm, Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)), r0, IS_ARRAY);
 819 
 820     __ b(done);
 821     __ bind(is_flat_array);
 822     __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::value_array_load), r0, r1);
 823     __ bind(done);
 824   } else {
 825     __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
 826     do_oop_load(_masm, Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)), r0, IS_ARRAY);
 827   }
 828 }
 829 
 830 void TemplateTable::baload()
 831 {
 832   transition(itos, itos);
 833   __ mov(r1, r0);
 834   __ pop_ptr(r0);
 835   // r0: array
 836   // r1: index
 837   index_check(r0, r1); // leaves index in r1, kills rscratch1
 838   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
 839   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(0)), noreg, noreg);
 840 }
 841 
 842 void TemplateTable::caload()
 843 {
 844   transition(itos, itos);
 845   __ mov(r1, r0);
 846   __ pop_ptr(r0);
 847   // r0: array
 848   // r1: index
 849   index_check(r0, r1); // leaves index in r1, kills rscratch1
 850   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
 851   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 852 }
 853 
 854 // iload followed by caload frequent pair
 855 void TemplateTable::fast_icaload()
 856 {
 857   transition(vtos, itos);
 858   // load index out of locals
 859   locals_index(r2);
 860   __ ldr(r1, iaddress(r2));
 861 
 862   __ pop_ptr(r0);
 863 
 864   // r0: array
 865   // r1: index
 866   index_check(r0, r1); // leaves index in r1, kills rscratch1
 867   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
 868   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 869 }
 870 
 871 void TemplateTable::saload()
 872 {
 873   transition(itos, itos);
 874   __ mov(r1, r0);
 875   __ pop_ptr(r0);
 876   // r0: array
 877   // r1: index
 878   index_check(r0, r1); // leaves index in r1, kills rscratch1
 879   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_SHORT) &gt;&gt; 1);
 880   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 881 }
 882 
 883 void TemplateTable::iload(int n)
 884 {
 885   transition(vtos, itos);
 886   __ ldr(r0, iaddress(n));
 887 }
 888 
 889 void TemplateTable::lload(int n)
 890 {
 891   transition(vtos, ltos);
 892   __ ldr(r0, laddress(n));
 893 }
 894 
 895 void TemplateTable::fload(int n)
 896 {
 897   transition(vtos, ftos);
 898   __ ldrs(v0, faddress(n));
 899 }
 900 
 901 void TemplateTable::dload(int n)
 902 {
 903   transition(vtos, dtos);
 904   __ ldrd(v0, daddress(n));
 905 }
 906 
 907 void TemplateTable::aload(int n)
 908 {
 909   transition(vtos, atos);
 910   __ ldr(r0, iaddress(n));
 911 }
 912 
 913 void TemplateTable::aload_0() {
 914   aload_0_internal();
 915 }
 916 
 917 void TemplateTable::nofast_aload_0() {
 918   aload_0_internal(may_not_rewrite);
 919 }
 920 
 921 void TemplateTable::aload_0_internal(RewriteControl rc) {
 922   // According to bytecode histograms, the pairs:
 923   //
 924   // _aload_0, _fast_igetfield
 925   // _aload_0, _fast_agetfield
 926   // _aload_0, _fast_fgetfield
 927   //
 928   // occur frequently. If RewriteFrequentPairs is set, the (slow)
 929   // _aload_0 bytecode checks if the next bytecode is either
 930   // _fast_igetfield, _fast_agetfield or _fast_fgetfield and then
 931   // rewrites the current bytecode into a pair bytecode; otherwise it
 932   // rewrites the current bytecode into _fast_aload_0 that doesn&#39;t do
 933   // the pair check anymore.
 934   //
 935   // Note: If the next bytecode is _getfield, the rewrite must be
 936   //       delayed, otherwise we may miss an opportunity for a pair.
 937   //
 938   // Also rewrite frequent pairs
 939   //   aload_0, aload_1
 940   //   aload_0, iload_1
 941   // These bytecodes with a small amount of code are most profitable
 942   // to rewrite
 943   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 944     Label rewrite, done;
 945     const Register bc = r4;
 946 
 947     // get next bytecode
 948     __ load_unsigned_byte(r1, at_bcp(Bytecodes::length_for(Bytecodes::_aload_0)));
 949 
 950     // if _getfield then wait with rewrite
 951     __ cmpw(r1, Bytecodes::Bytecodes::_getfield);
 952     __ br(Assembler::EQ, done);
 953 
 954     // if _igetfield then rewrite to _fast_iaccess_0
 955     assert(Bytecodes::java_code(Bytecodes::_fast_iaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 956     __ cmpw(r1, Bytecodes::_fast_igetfield);
 957     __ movw(bc, Bytecodes::_fast_iaccess_0);
 958     __ br(Assembler::EQ, rewrite);
 959 
 960     // if _agetfield then rewrite to _fast_aaccess_0
 961     assert(Bytecodes::java_code(Bytecodes::_fast_aaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 962     __ cmpw(r1, Bytecodes::_fast_agetfield);
 963     __ movw(bc, Bytecodes::_fast_aaccess_0);
 964     __ br(Assembler::EQ, rewrite);
 965 
 966     // if _fgetfield then rewrite to _fast_faccess_0
 967     assert(Bytecodes::java_code(Bytecodes::_fast_faccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 968     __ cmpw(r1, Bytecodes::_fast_fgetfield);
 969     __ movw(bc, Bytecodes::_fast_faccess_0);
 970     __ br(Assembler::EQ, rewrite);
 971 
 972     // else rewrite to _fast_aload0
 973     assert(Bytecodes::java_code(Bytecodes::_fast_aload_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 974     __ movw(bc, Bytecodes::Bytecodes::_fast_aload_0);
 975 
 976     // rewrite
 977     // bc: new bytecode
 978     __ bind(rewrite);
 979     patch_bytecode(Bytecodes::_aload_0, bc, r1, false);
 980 
 981     __ bind(done);
 982   }
 983 
 984   // Do actual aload_0 (must do this after patch_bytecode which might call VM and GC might change oop).
 985   aload(0);
 986 }
 987 
 988 void TemplateTable::istore()
 989 {
 990   transition(itos, vtos);
 991   locals_index(r1);
 992   // FIXME: We&#39;re being very pernickerty here storing a jint in a
 993   // local with strw, which costs an extra instruction over what we&#39;d
 994   // be able to do with a simple str.  We should just store the whole
 995   // word.
 996   __ lea(rscratch1, iaddress(r1));
 997   __ strw(r0, Address(rscratch1));
 998 }
 999 
1000 void TemplateTable::lstore()
1001 {
1002   transition(ltos, vtos);
1003   locals_index(r1);
1004   __ str(r0, laddress(r1, rscratch1, _masm));
1005 }
1006 
1007 void TemplateTable::fstore() {
1008   transition(ftos, vtos);
1009   locals_index(r1);
1010   __ lea(rscratch1, iaddress(r1));
1011   __ strs(v0, Address(rscratch1));
1012 }
1013 
1014 void TemplateTable::dstore() {
1015   transition(dtos, vtos);
1016   locals_index(r1);
1017   __ strd(v0, daddress(r1, rscratch1, _masm));
1018 }
1019 
1020 void TemplateTable::astore()
1021 {
1022   transition(vtos, vtos);
1023   __ pop_ptr(r0);
1024   locals_index(r1);
1025   __ str(r0, aaddress(r1));
1026 }
1027 
1028 void TemplateTable::wide_istore() {
1029   transition(vtos, vtos);
1030   __ pop_i();
1031   locals_index_wide(r1);
1032   __ lea(rscratch1, iaddress(r1));
1033   __ strw(r0, Address(rscratch1));
1034 }
1035 
1036 void TemplateTable::wide_lstore() {
1037   transition(vtos, vtos);
1038   __ pop_l();
1039   locals_index_wide(r1);
1040   __ str(r0, laddress(r1, rscratch1, _masm));
1041 }
1042 
1043 void TemplateTable::wide_fstore() {
1044   transition(vtos, vtos);
1045   __ pop_f();
1046   locals_index_wide(r1);
1047   __ lea(rscratch1, faddress(r1));
1048   __ strs(v0, rscratch1);
1049 }
1050 
1051 void TemplateTable::wide_dstore() {
1052   transition(vtos, vtos);
1053   __ pop_d();
1054   locals_index_wide(r1);
1055   __ strd(v0, daddress(r1, rscratch1, _masm));
1056 }
1057 
1058 void TemplateTable::wide_astore() {
1059   transition(vtos, vtos);
1060   __ pop_ptr(r0);
1061   locals_index_wide(r1);
1062   __ str(r0, aaddress(r1));
1063 }
1064 
1065 void TemplateTable::iastore() {
1066   transition(itos, vtos);
1067   __ pop_i(r1);
1068   __ pop_ptr(r3);
1069   // r0: value
1070   // r1: index
1071   // r3: array
1072   index_check(r3, r1); // prefer index in r1
1073   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
1074   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), r0, noreg, noreg);
1075 }
1076 
1077 void TemplateTable::lastore() {
1078   transition(ltos, vtos);
1079   __ pop_i(r1);
1080   __ pop_ptr(r3);
1081   // r0: value
1082   // r1: index
1083   // r3: array
1084   index_check(r3, r1); // prefer index in r1
1085   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
1086   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), r0, noreg, noreg);
1087 }
1088 
1089 void TemplateTable::fastore() {
1090   transition(ftos, vtos);
1091   __ pop_i(r1);
1092   __ pop_ptr(r3);
1093   // v0: value
1094   // r1:  index
1095   // r3:  array
1096   index_check(r3, r1); // prefer index in r1
1097   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
1098   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), noreg /* ftos */, noreg, noreg);
1099 }
1100 
1101 void TemplateTable::dastore() {
1102   transition(dtos, vtos);
1103   __ pop_i(r1);
1104   __ pop_ptr(r3);
1105   // v0: value
1106   // r1:  index
1107   // r3:  array
1108   index_check(r3, r1); // prefer index in r1
1109   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
1110   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), noreg /* dtos */, noreg, noreg);
1111 }
1112 
1113 void TemplateTable::aastore() {
1114   Label is_null, ok_is_subtype, done;
1115   transition(vtos, vtos);
1116   // stack: ..., array, index, value
1117   __ ldr(r0, at_tos());    // value
1118   __ ldr(r2, at_tos_p1()); // index
1119   __ ldr(r3, at_tos_p2()); // array
1120 
1121   Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));
1122 
1123   index_check(r3, r2);     // kills r1
1124 
1125   // FIXME: Could we remove the line below?
1126   __ add(r4, r2, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
1127 
1128   // do array store check - check for NULL value first
1129   __ cbz(r0, is_null);
1130 
1131   Label  is_flat_array;
1132   if (UseFlatArray) {
1133     __ test_flattened_array_oop(r3, r8 /*temp*/, is_flat_array);
1134   }
1135 
1136   // Move subklass into r1
1137   __ load_klass(r1, r0);
1138 
1139   // Move superklass into r0
1140   __ load_klass(r0, r3);
1141   __ ldr(r0, Address(r0, ObjArrayKlass::element_klass_offset()));
1142   // Compress array + index*oopSize + 12 into a single register.  Frees r2.
1143 
1144   // Generate subtype check.  Blows r2, r5
1145   // Superklass in r0.  Subklass in r1.
1146 
1147   __ gen_subtype_check(r1, ok_is_subtype);
1148 
1149   // Come here on failure
1150   // object is at TOS
1151   __ b(Interpreter::_throw_ArrayStoreException_entry);
1152 
1153 
1154   // Come here on success
1155   __ bind(ok_is_subtype);
1156 
1157 
1158   // Get the value we will store
1159   __ ldr(r0, at_tos());
1160   // Now store using the appropriate barrier
1161   do_oop_store(_masm, element_address, r0, IS_ARRAY);
1162   __ b(done);
1163 
1164   // Have a NULL in r0, r3=array, r2=index.  Store NULL at ary[idx]
1165   __ bind(is_null);
1166   __ profile_null_seen(r2);
1167 
1168   if (EnableValhalla) {
1169     Label is_null_into_value_array_npe, store_null;
1170 
1171     // No way to store null in flat array
1172     __ test_null_free_array_oop(r3, r8, is_null_into_value_array_npe);
1173     __ b(store_null);
1174 
1175     __ bind(is_null_into_value_array_npe);
1176     __ b(ExternalAddress(Interpreter::_throw_NullPointerException_entry));
1177 
1178     __ bind(store_null);
1179   }
1180 
1181   // Store a NULL
1182   do_oop_store(_masm, element_address, noreg, IS_ARRAY);
1183   __ b(done);
1184 
1185   if (EnableValhalla) {
1186      Label is_type_ok;
1187 
1188     // store non-null value
1189     __ bind(is_flat_array);
1190 
1191     // Simplistic type check...
1192     // r0 - value, r2 - index, r3 - array.
1193 
1194     // Profile the not-null value&#39;s klass.
1195     // Load value class
1196      __ load_klass(r1, r0);
1197      __ profile_typecheck(r2, r1, r0); // blows r2, and r0
1198 
1199     // flat value array needs exact type match
1200     // is &quot;r8 == r0&quot; (value subclass == array element superclass)
1201 
1202     // Move element klass into r0
1203 
1204      __ load_klass(r0, r3);
1205 
1206      __ ldr(r0, Address(r0, ArrayKlass::element_klass_offset()));
1207      __ cmp(r0, r1);
1208      __ br(Assembler::EQ, is_type_ok);
1209 
1210      __ profile_typecheck_failed(r2);
1211      __ b(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));
1212 
1213      __ bind(is_type_ok);
1214 
1215     // Reload from TOS to be safe, because of profile_typecheck that blows r2 and r0.
1216     // FIXME: Should we really do it?
1217      __ ldr(r1, at_tos());  // value
1218      __ mov(r2, r3); // array, ldr(r2, at_tos_p2());
1219      __ ldr(r3, at_tos_p1()); // index
1220      __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::value_array_store), r1, r2, r3);
1221   }
1222 
1223 
1224   // Pop stack arguments
1225   __ bind(done);
1226   __ add(esp, esp, 3 * Interpreter::stackElementSize);
1227 }
1228 
1229 void TemplateTable::bastore()
1230 {
1231   transition(itos, vtos);
1232   __ pop_i(r1);
1233   __ pop_ptr(r3);
1234   // r0: value
1235   // r1: index
1236   // r3: array
1237   index_check(r3, r1); // prefer index in r1
1238 
1239   // Need to check whether array is boolean or byte
1240   // since both types share the bastore bytecode.
1241   __ load_klass(r2, r3);
1242   __ ldrw(r2, Address(r2, Klass::layout_helper_offset()));
1243   int diffbit_index = exact_log2(Klass::layout_helper_boolean_diffbit());
1244   Label L_skip;
1245   __ tbz(r2, diffbit_index, L_skip);
1246   __ andw(r0, r0, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
1247   __ bind(L_skip);
1248 
1249   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
1250   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(0)), r0, noreg, noreg);
1251 }
1252 
1253 void TemplateTable::castore()
1254 {
1255   transition(itos, vtos);
1256   __ pop_i(r1);
1257   __ pop_ptr(r3);
1258   // r0: value
1259   // r1: index
1260   // r3: array
1261   index_check(r3, r1); // prefer index in r1
1262   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
1263   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(1)), r0, noreg, noreg);
1264 }
1265 
1266 void TemplateTable::sastore()
1267 {
1268   castore();
1269 }
1270 
1271 void TemplateTable::istore(int n)
1272 {
1273   transition(itos, vtos);
1274   __ str(r0, iaddress(n));
1275 }
1276 
1277 void TemplateTable::lstore(int n)
1278 {
1279   transition(ltos, vtos);
1280   __ str(r0, laddress(n));
1281 }
1282 
1283 void TemplateTable::fstore(int n)
1284 {
1285   transition(ftos, vtos);
1286   __ strs(v0, faddress(n));
1287 }
1288 
1289 void TemplateTable::dstore(int n)
1290 {
1291   transition(dtos, vtos);
1292   __ strd(v0, daddress(n));
1293 }
1294 
1295 void TemplateTable::astore(int n)
1296 {
1297   transition(vtos, vtos);
1298   __ pop_ptr(r0);
1299   __ str(r0, iaddress(n));
1300 }
1301 
1302 void TemplateTable::pop()
1303 {
1304   transition(vtos, vtos);
1305   __ add(esp, esp, Interpreter::stackElementSize);
1306 }
1307 
1308 void TemplateTable::pop2()
1309 {
1310   transition(vtos, vtos);
1311   __ add(esp, esp, 2 * Interpreter::stackElementSize);
1312 }
1313 
1314 void TemplateTable::dup()
1315 {
1316   transition(vtos, vtos);
1317   __ ldr(r0, Address(esp, 0));
1318   __ push(r0);
1319   // stack: ..., a, a
1320 }
1321 
1322 void TemplateTable::dup_x1()
1323 {
1324   transition(vtos, vtos);
1325   // stack: ..., a, b
1326   __ ldr(r0, at_tos());  // load b
1327   __ ldr(r2, at_tos_p1());  // load a
1328   __ str(r0, at_tos_p1());  // store b
1329   __ str(r2, at_tos());  // store a
1330   __ push(r0);                  // push b
1331   // stack: ..., b, a, b
1332 }
1333 
1334 void TemplateTable::dup_x2()
1335 {
1336   transition(vtos, vtos);
1337   // stack: ..., a, b, c
1338   __ ldr(r0, at_tos());  // load c
1339   __ ldr(r2, at_tos_p2());  // load a
1340   __ str(r0, at_tos_p2());  // store c in a
1341   __ push(r0);      // push c
1342   // stack: ..., c, b, c, c
1343   __ ldr(r0, at_tos_p2());  // load b
1344   __ str(r2, at_tos_p2());  // store a in b
1345   // stack: ..., c, a, c, c
1346   __ str(r0, at_tos_p1());  // store b in c
1347   // stack: ..., c, a, b, c
1348 }
1349 
1350 void TemplateTable::dup2()
1351 {
1352   transition(vtos, vtos);
1353   // stack: ..., a, b
1354   __ ldr(r0, at_tos_p1());  // load a
1355   __ push(r0);                  // push a
1356   __ ldr(r0, at_tos_p1());  // load b
1357   __ push(r0);                  // push b
1358   // stack: ..., a, b, a, b
1359 }
1360 
1361 void TemplateTable::dup2_x1()
1362 {
1363   transition(vtos, vtos);
1364   // stack: ..., a, b, c
1365   __ ldr(r2, at_tos());  // load c
1366   __ ldr(r0, at_tos_p1());  // load b
1367   __ push(r0);                  // push b
1368   __ push(r2);                  // push c
1369   // stack: ..., a, b, c, b, c
1370   __ str(r2, at_tos_p3());  // store c in b
1371   // stack: ..., a, c, c, b, c
1372   __ ldr(r2, at_tos_p4());  // load a
1373   __ str(r2, at_tos_p2());  // store a in 2nd c
1374   // stack: ..., a, c, a, b, c
1375   __ str(r0, at_tos_p4());  // store b in a
1376   // stack: ..., b, c, a, b, c
1377 }
1378 
1379 void TemplateTable::dup2_x2()
1380 {
1381   transition(vtos, vtos);
1382   // stack: ..., a, b, c, d
1383   __ ldr(r2, at_tos());  // load d
1384   __ ldr(r0, at_tos_p1());  // load c
1385   __ push(r0)            ;      // push c
1386   __ push(r2);                  // push d
1387   // stack: ..., a, b, c, d, c, d
1388   __ ldr(r0, at_tos_p4());  // load b
1389   __ str(r0, at_tos_p2());  // store b in d
1390   __ str(r2, at_tos_p4());  // store d in b
1391   // stack: ..., a, d, c, b, c, d
1392   __ ldr(r2, at_tos_p5());  // load a
1393   __ ldr(r0, at_tos_p3());  // load c
1394   __ str(r2, at_tos_p3());  // store a in c
1395   __ str(r0, at_tos_p5());  // store c in a
1396   // stack: ..., c, d, a, b, c, d
1397 }
1398 
1399 void TemplateTable::swap()
1400 {
1401   transition(vtos, vtos);
1402   // stack: ..., a, b
1403   __ ldr(r2, at_tos_p1());  // load a
1404   __ ldr(r0, at_tos());  // load b
1405   __ str(r2, at_tos());  // store a in b
1406   __ str(r0, at_tos_p1());  // store b in a
1407   // stack: ..., b, a
1408 }
1409 
1410 void TemplateTable::iop2(Operation op)
1411 {
1412   transition(itos, itos);
1413   // r0 &lt;== r1 op r0
1414   __ pop_i(r1);
1415   switch (op) {
1416   case add  : __ addw(r0, r1, r0); break;
1417   case sub  : __ subw(r0, r1, r0); break;
1418   case mul  : __ mulw(r0, r1, r0); break;
1419   case _and : __ andw(r0, r1, r0); break;
1420   case _or  : __ orrw(r0, r1, r0); break;
1421   case _xor : __ eorw(r0, r1, r0); break;
1422   case shl  : __ lslvw(r0, r1, r0); break;
1423   case shr  : __ asrvw(r0, r1, r0); break;
1424   case ushr : __ lsrvw(r0, r1, r0);break;
1425   default   : ShouldNotReachHere();
1426   }
1427 }
1428 
1429 void TemplateTable::lop2(Operation op)
1430 {
1431   transition(ltos, ltos);
1432   // r0 &lt;== r1 op r0
1433   __ pop_l(r1);
1434   switch (op) {
1435   case add  : __ add(r0, r1, r0); break;
1436   case sub  : __ sub(r0, r1, r0); break;
1437   case mul  : __ mul(r0, r1, r0); break;
1438   case _and : __ andr(r0, r1, r0); break;
1439   case _or  : __ orr(r0, r1, r0); break;
1440   case _xor : __ eor(r0, r1, r0); break;
1441   default   : ShouldNotReachHere();
1442   }
1443 }
1444 
1445 void TemplateTable::idiv()
1446 {
1447   transition(itos, itos);
1448   // explicitly check for div0
1449   Label no_div0;
1450   __ cbnzw(r0, no_div0);
1451   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1452   __ br(rscratch1);
1453   __ bind(no_div0);
1454   __ pop_i(r1);
1455   // r0 &lt;== r1 idiv r0
1456   __ corrected_idivl(r0, r1, r0, /* want_remainder */ false);
1457 }
1458 
1459 void TemplateTable::irem()
1460 {
1461   transition(itos, itos);
1462   // explicitly check for div0
1463   Label no_div0;
1464   __ cbnzw(r0, no_div0);
1465   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1466   __ br(rscratch1);
1467   __ bind(no_div0);
1468   __ pop_i(r1);
1469   // r0 &lt;== r1 irem r0
1470   __ corrected_idivl(r0, r1, r0, /* want_remainder */ true);
1471 }
1472 
1473 void TemplateTable::lmul()
1474 {
1475   transition(ltos, ltos);
1476   __ pop_l(r1);
1477   __ mul(r0, r0, r1);
1478 }
1479 
1480 void TemplateTable::ldiv()
1481 {
1482   transition(ltos, ltos);
1483   // explicitly check for div0
1484   Label no_div0;
1485   __ cbnz(r0, no_div0);
1486   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1487   __ br(rscratch1);
1488   __ bind(no_div0);
1489   __ pop_l(r1);
1490   // r0 &lt;== r1 ldiv r0
1491   __ corrected_idivq(r0, r1, r0, /* want_remainder */ false);
1492 }
1493 
1494 void TemplateTable::lrem()
1495 {
1496   transition(ltos, ltos);
1497   // explicitly check for div0
1498   Label no_div0;
1499   __ cbnz(r0, no_div0);
1500   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1501   __ br(rscratch1);
1502   __ bind(no_div0);
1503   __ pop_l(r1);
1504   // r0 &lt;== r1 lrem r0
1505   __ corrected_idivq(r0, r1, r0, /* want_remainder */ true);
1506 }
1507 
1508 void TemplateTable::lshl()
1509 {
1510   transition(itos, ltos);
1511   // shift count is in r0
1512   __ pop_l(r1);
1513   __ lslv(r0, r1, r0);
1514 }
1515 
1516 void TemplateTable::lshr()
1517 {
1518   transition(itos, ltos);
1519   // shift count is in r0
1520   __ pop_l(r1);
1521   __ asrv(r0, r1, r0);
1522 }
1523 
1524 void TemplateTable::lushr()
1525 {
1526   transition(itos, ltos);
1527   // shift count is in r0
1528   __ pop_l(r1);
1529   __ lsrv(r0, r1, r0);
1530 }
1531 
1532 void TemplateTable::fop2(Operation op)
1533 {
1534   transition(ftos, ftos);
1535   switch (op) {
1536   case add:
1537     // n.b. use ldrd because this is a 64 bit slot
1538     __ pop_f(v1);
1539     __ fadds(v0, v1, v0);
1540     break;
1541   case sub:
1542     __ pop_f(v1);
1543     __ fsubs(v0, v1, v0);
1544     break;
1545   case mul:
1546     __ pop_f(v1);
1547     __ fmuls(v0, v1, v0);
1548     break;
1549   case div:
1550     __ pop_f(v1);
1551     __ fdivs(v0, v1, v0);
1552     break;
1553   case rem:
1554     __ fmovs(v1, v0);
1555     __ pop_f(v0);
1556     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem));
1557     break;
1558   default:
1559     ShouldNotReachHere();
1560     break;
1561   }
1562 }
1563 
1564 void TemplateTable::dop2(Operation op)
1565 {
1566   transition(dtos, dtos);
1567   switch (op) {
1568   case add:
1569     // n.b. use ldrd because this is a 64 bit slot
1570     __ pop_d(v1);
1571     __ faddd(v0, v1, v0);
1572     break;
1573   case sub:
1574     __ pop_d(v1);
1575     __ fsubd(v0, v1, v0);
1576     break;
1577   case mul:
1578     __ pop_d(v1);
1579     __ fmuld(v0, v1, v0);
1580     break;
1581   case div:
1582     __ pop_d(v1);
1583     __ fdivd(v0, v1, v0);
1584     break;
1585   case rem:
1586     __ fmovd(v1, v0);
1587     __ pop_d(v0);
1588     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem));
1589     break;
1590   default:
1591     ShouldNotReachHere();
1592     break;
1593   }
1594 }
1595 
1596 void TemplateTable::ineg()
1597 {
1598   transition(itos, itos);
1599   __ negw(r0, r0);
1600 
1601 }
1602 
1603 void TemplateTable::lneg()
1604 {
1605   transition(ltos, ltos);
1606   __ neg(r0, r0);
1607 }
1608 
1609 void TemplateTable::fneg()
1610 {
1611   transition(ftos, ftos);
1612   __ fnegs(v0, v0);
1613 }
1614 
1615 void TemplateTable::dneg()
1616 {
1617   transition(dtos, dtos);
1618   __ fnegd(v0, v0);
1619 }
1620 
1621 void TemplateTable::iinc()
1622 {
1623   transition(vtos, vtos);
1624   __ load_signed_byte(r1, at_bcp(2)); // get constant
1625   locals_index(r2);
1626   __ ldr(r0, iaddress(r2));
1627   __ addw(r0, r0, r1);
1628   __ str(r0, iaddress(r2));
1629 }
1630 
1631 void TemplateTable::wide_iinc()
1632 {
1633   transition(vtos, vtos);
1634   // __ mov(r1, zr);
1635   __ ldrw(r1, at_bcp(2)); // get constant and index
1636   __ rev16(r1, r1);
1637   __ ubfx(r2, r1, 0, 16);
1638   __ neg(r2, r2);
1639   __ sbfx(r1, r1, 16, 16);
1640   __ ldr(r0, iaddress(r2));
1641   __ addw(r0, r0, r1);
1642   __ str(r0, iaddress(r2));
1643 }
1644 
1645 void TemplateTable::convert()
1646 {
1647   // Checking
1648 #ifdef ASSERT
1649   {
1650     TosState tos_in  = ilgl;
1651     TosState tos_out = ilgl;
1652     switch (bytecode()) {
1653     case Bytecodes::_i2l: // fall through
1654     case Bytecodes::_i2f: // fall through
1655     case Bytecodes::_i2d: // fall through
1656     case Bytecodes::_i2b: // fall through
1657     case Bytecodes::_i2c: // fall through
1658     case Bytecodes::_i2s: tos_in = itos; break;
1659     case Bytecodes::_l2i: // fall through
1660     case Bytecodes::_l2f: // fall through
1661     case Bytecodes::_l2d: tos_in = ltos; break;
1662     case Bytecodes::_f2i: // fall through
1663     case Bytecodes::_f2l: // fall through
1664     case Bytecodes::_f2d: tos_in = ftos; break;
1665     case Bytecodes::_d2i: // fall through
1666     case Bytecodes::_d2l: // fall through
1667     case Bytecodes::_d2f: tos_in = dtos; break;
1668     default             : ShouldNotReachHere();
1669     }
1670     switch (bytecode()) {
1671     case Bytecodes::_l2i: // fall through
1672     case Bytecodes::_f2i: // fall through
1673     case Bytecodes::_d2i: // fall through
1674     case Bytecodes::_i2b: // fall through
1675     case Bytecodes::_i2c: // fall through
1676     case Bytecodes::_i2s: tos_out = itos; break;
1677     case Bytecodes::_i2l: // fall through
1678     case Bytecodes::_f2l: // fall through
1679     case Bytecodes::_d2l: tos_out = ltos; break;
1680     case Bytecodes::_i2f: // fall through
1681     case Bytecodes::_l2f: // fall through
1682     case Bytecodes::_d2f: tos_out = ftos; break;
1683     case Bytecodes::_i2d: // fall through
1684     case Bytecodes::_l2d: // fall through
1685     case Bytecodes::_f2d: tos_out = dtos; break;
1686     default             : ShouldNotReachHere();
1687     }
1688     transition(tos_in, tos_out);
1689   }
1690 #endif // ASSERT
1691   // static const int64_t is_nan = 0x8000000000000000L;
1692 
1693   // Conversion
1694   switch (bytecode()) {
1695   case Bytecodes::_i2l:
1696     __ sxtw(r0, r0);
1697     break;
1698   case Bytecodes::_i2f:
1699     __ scvtfws(v0, r0);
1700     break;
1701   case Bytecodes::_i2d:
1702     __ scvtfwd(v0, r0);
1703     break;
1704   case Bytecodes::_i2b:
1705     __ sxtbw(r0, r0);
1706     break;
1707   case Bytecodes::_i2c:
1708     __ uxthw(r0, r0);
1709     break;
1710   case Bytecodes::_i2s:
1711     __ sxthw(r0, r0);
1712     break;
1713   case Bytecodes::_l2i:
1714     __ uxtw(r0, r0);
1715     break;
1716   case Bytecodes::_l2f:
1717     __ scvtfs(v0, r0);
1718     break;
1719   case Bytecodes::_l2d:
1720     __ scvtfd(v0, r0);
1721     break;
1722   case Bytecodes::_f2i:
1723   {
1724     Label L_Okay;
1725     __ clear_fpsr();
1726     __ fcvtzsw(r0, v0);
1727     __ get_fpsr(r1);
1728     __ cbzw(r1, L_Okay);
1729     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i));
1730     __ bind(L_Okay);
1731   }
1732     break;
1733   case Bytecodes::_f2l:
1734   {
1735     Label L_Okay;
1736     __ clear_fpsr();
1737     __ fcvtzs(r0, v0);
1738     __ get_fpsr(r1);
1739     __ cbzw(r1, L_Okay);
1740     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l));
1741     __ bind(L_Okay);
1742   }
1743     break;
1744   case Bytecodes::_f2d:
1745     __ fcvts(v0, v0);
1746     break;
1747   case Bytecodes::_d2i:
1748   {
1749     Label L_Okay;
1750     __ clear_fpsr();
1751     __ fcvtzdw(r0, v0);
1752     __ get_fpsr(r1);
1753     __ cbzw(r1, L_Okay);
1754     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i));
1755     __ bind(L_Okay);
1756   }
1757     break;
1758   case Bytecodes::_d2l:
1759   {
1760     Label L_Okay;
1761     __ clear_fpsr();
1762     __ fcvtzd(r0, v0);
1763     __ get_fpsr(r1);
1764     __ cbzw(r1, L_Okay);
1765     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l));
1766     __ bind(L_Okay);
1767   }
1768     break;
1769   case Bytecodes::_d2f:
1770     __ fcvtd(v0, v0);
1771     break;
1772   default:
1773     ShouldNotReachHere();
1774   }
1775 }
1776 
1777 void TemplateTable::lcmp()
1778 {
1779   transition(ltos, itos);
1780   Label done;
1781   __ pop_l(r1);
1782   __ cmp(r1, r0);
1783   __ mov(r0, (u_int64_t)-1L);
1784   __ br(Assembler::LT, done);
1785   // __ mov(r0, 1UL);
1786   // __ csel(r0, r0, zr, Assembler::NE);
1787   // and here is a faster way
1788   __ csinc(r0, zr, zr, Assembler::EQ);
1789   __ bind(done);
1790 }
1791 
1792 void TemplateTable::float_cmp(bool is_float, int unordered_result)
1793 {
1794   Label done;
1795   if (is_float) {
1796     // XXX get rid of pop here, use ... reg, mem32
1797     __ pop_f(v1);
1798     __ fcmps(v1, v0);
1799   } else {
1800     // XXX get rid of pop here, use ... reg, mem64
1801     __ pop_d(v1);
1802     __ fcmpd(v1, v0);
1803   }
1804   if (unordered_result &lt; 0) {
1805     // we want -1 for unordered or less than, 0 for equal and 1 for
1806     // greater than.
1807     __ mov(r0, (u_int64_t)-1L);
1808     // for FP LT tests less than or unordered
1809     __ br(Assembler::LT, done);
1810     // install 0 for EQ otherwise 1
1811     __ csinc(r0, zr, zr, Assembler::EQ);
1812   } else {
1813     // we want -1 for less than, 0 for equal and 1 for unordered or
1814     // greater than.
1815     __ mov(r0, 1L);
1816     // for FP HI tests greater than or unordered
1817     __ br(Assembler::HI, done);
1818     // install 0 for EQ otherwise ~0
1819     __ csinv(r0, zr, zr, Assembler::EQ);
1820 
1821   }
1822   __ bind(done);
1823 }
1824 
1825 void TemplateTable::branch(bool is_jsr, bool is_wide)
1826 {
1827   // We might be moving to a safepoint.  The thread which calls
1828   // Interpreter::notice_safepoints() will effectively flush its cache
1829   // when it makes a system call, but we need to do something to
1830   // ensure that we see the changed dispatch table.
1831   __ membar(MacroAssembler::LoadLoad);
1832 
1833   __ profile_taken_branch(r0, r1);
1834   const ByteSize be_offset = MethodCounters::backedge_counter_offset() +
1835                              InvocationCounter::counter_offset();
1836   const ByteSize inv_offset = MethodCounters::invocation_counter_offset() +
1837                               InvocationCounter::counter_offset();
1838 
1839   // load branch displacement
1840   if (!is_wide) {
1841     __ ldrh(r2, at_bcp(1));
1842     __ rev16(r2, r2);
1843     // sign extend the 16 bit value in r2
1844     __ sbfm(r2, r2, 0, 15);
1845   } else {
1846     __ ldrw(r2, at_bcp(1));
1847     __ revw(r2, r2);
1848     // sign extend the 32 bit value in r2
1849     __ sbfm(r2, r2, 0, 31);
1850   }
1851 
1852   // Handle all the JSR stuff here, then exit.
1853   // It&#39;s much shorter and cleaner than intermingling with the non-JSR
1854   // normal-branch stuff occurring below.
1855 
1856   if (is_jsr) {
1857     // Pre-load the next target bytecode into rscratch1
1858     __ load_unsigned_byte(rscratch1, Address(rbcp, r2));
1859     // compute return address as bci
1860     __ ldr(rscratch2, Address(rmethod, Method::const_offset()));
1861     __ add(rscratch2, rscratch2,
1862            in_bytes(ConstMethod::codes_offset()) - (is_wide ? 5 : 3));
1863     __ sub(r1, rbcp, rscratch2);
1864     __ push_i(r1);
1865     // Adjust the bcp by the 16-bit displacement in r2
1866     __ add(rbcp, rbcp, r2);
1867     __ dispatch_only(vtos, /*generate_poll*/true);
1868     return;
1869   }
1870 
1871   // Normal (non-jsr) branch handling
1872 
1873   // Adjust the bcp by the displacement in r2
1874   __ add(rbcp, rbcp, r2);
1875 
1876   assert(UseLoopCounter || !UseOnStackReplacement,
1877          &quot;on-stack-replacement requires loop counters&quot;);
1878   Label backedge_counter_overflow;
1879   Label profile_method;
1880   Label dispatch;
1881   if (UseLoopCounter) {
1882     // increment backedge counter for backward branches
1883     // r0: MDO
1884     // w1: MDO bumped taken-count
1885     // r2: target offset
1886     __ cmp(r2, zr);
1887     __ br(Assembler::GT, dispatch); // count only if backward branch
1888 
1889     // ECN: FIXME: This code smells
1890     // check if MethodCounters exists
1891     Label has_counters;
1892     __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1893     __ cbnz(rscratch1, has_counters);
1894     __ push(r0);
1895     __ push(r1);
1896     __ push(r2);
1897     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
1898             InterpreterRuntime::build_method_counters), rmethod);
1899     __ pop(r2);
1900     __ pop(r1);
1901     __ pop(r0);
1902     __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1903     __ cbz(rscratch1, dispatch); // No MethodCounters allocated, OutOfMemory
1904     __ bind(has_counters);
1905 
1906     if (TieredCompilation) {
1907       Label no_mdo;
1908       int increment = InvocationCounter::count_increment;
1909       if (ProfileInterpreter) {
1910         // Are we profiling?
1911         __ ldr(r1, Address(rmethod, in_bytes(Method::method_data_offset())));
1912         __ cbz(r1, no_mdo);
1913         // Increment the MDO backedge counter
1914         const Address mdo_backedge_counter(r1, in_bytes(MethodData::backedge_counter_offset()) +
1915                                            in_bytes(InvocationCounter::counter_offset()));
1916         const Address mask(r1, in_bytes(MethodData::backedge_mask_offset()));
1917         __ increment_mask_and_jump(mdo_backedge_counter, increment, mask,
1918                                    r0, rscratch1, false, Assembler::EQ,
1919                                    UseOnStackReplacement ? &amp;backedge_counter_overflow : &amp;dispatch);
1920         __ b(dispatch);
1921       }
1922       __ bind(no_mdo);
1923       // Increment backedge counter in MethodCounters*
1924       __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1925       const Address mask(rscratch1, in_bytes(MethodCounters::backedge_mask_offset()));
1926       __ increment_mask_and_jump(Address(rscratch1, be_offset), increment, mask,
1927                                  r0, rscratch2, false, Assembler::EQ,
1928                                  UseOnStackReplacement ? &amp;backedge_counter_overflow : &amp;dispatch);
1929     } else { // not TieredCompilation
1930       // increment counter
1931       __ ldr(rscratch2, Address(rmethod, Method::method_counters_offset()));
1932       __ ldrw(r0, Address(rscratch2, be_offset));        // load backedge counter
1933       __ addw(rscratch1, r0, InvocationCounter::count_increment); // increment counter
1934       __ strw(rscratch1, Address(rscratch2, be_offset));        // store counter
1935 
1936       __ ldrw(r0, Address(rscratch2, inv_offset));    // load invocation counter
1937       __ andw(r0, r0, (unsigned)InvocationCounter::count_mask_value); // and the status bits
1938       __ addw(r0, r0, rscratch1);        // add both counters
1939 
1940       if (ProfileInterpreter) {
1941         // Test to see if we should create a method data oop
1942         __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_profile_limit_offset())));
1943         __ cmpw(r0, rscratch1);
1944         __ br(Assembler::LT, dispatch);
1945 
1946         // if no method data exists, go to profile method
1947         __ test_method_data_pointer(r0, profile_method);
1948 
1949         if (UseOnStackReplacement) {
1950           // check for overflow against w1 which is the MDO taken count
1951           __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
1952           __ cmpw(r1, rscratch1);
1953           __ br(Assembler::LO, dispatch); // Intel == Assembler::below
1954 
1955           // When ProfileInterpreter is on, the backedge_count comes
1956           // from the MethodData*, which value does not get reset on
1957           // the call to frequency_counter_overflow().  To avoid
1958           // excessive calls to the overflow routine while the method is
1959           // being compiled, add a second test to make sure the overflow
1960           // function is called only once every overflow_frequency.
1961           const int overflow_frequency = 1024;
1962           __ andsw(r1, r1, overflow_frequency - 1);
1963           __ br(Assembler::EQ, backedge_counter_overflow);
1964 
1965         }
1966       } else {
1967         if (UseOnStackReplacement) {
1968           // check for overflow against w0, which is the sum of the
1969           // counters
1970           __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
1971           __ cmpw(r0, rscratch1);
1972           __ br(Assembler::HS, backedge_counter_overflow); // Intel == Assembler::aboveEqual
1973         }
1974       }
1975     }
1976     __ bind(dispatch);
1977   }
1978 
1979   // Pre-load the next target bytecode into rscratch1
1980   __ load_unsigned_byte(rscratch1, Address(rbcp, 0));
1981 
1982   // continue with the bytecode @ target
1983   // rscratch1: target bytecode
1984   // rbcp: target bcp
1985   __ dispatch_only(vtos, /*generate_poll*/true);
1986 
1987   if (UseLoopCounter) {
1988     if (ProfileInterpreter) {
1989       // Out-of-line code to allocate method data oop.
1990       __ bind(profile_method);
1991       __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
1992       __ load_unsigned_byte(r1, Address(rbcp, 0));  // restore target bytecode
1993       __ set_method_data_pointer_for_bcp();
1994       __ b(dispatch);
1995     }
1996 
1997     if (UseOnStackReplacement) {
1998       // invocation counter overflow
1999       __ bind(backedge_counter_overflow);
2000       __ neg(r2, r2);
2001       __ add(r2, r2, rbcp);     // branch bcp
2002       // IcoResult frequency_counter_overflow([JavaThread*], address branch_bcp)
2003       __ call_VM(noreg,
2004                  CAST_FROM_FN_PTR(address,
2005                                   InterpreterRuntime::frequency_counter_overflow),
2006                  r2);
2007       __ load_unsigned_byte(r1, Address(rbcp, 0));  // restore target bytecode
2008 
2009       // r0: osr nmethod (osr ok) or NULL (osr not possible)
2010       // w1: target bytecode
2011       // r2: scratch
2012       __ cbz(r0, dispatch);     // test result -- no osr if null
2013       // nmethod may have been invalidated (VM may block upon call_VM return)
2014       __ ldrb(r2, Address(r0, nmethod::state_offset()));
2015       if (nmethod::in_use != 0)
2016         __ sub(r2, r2, nmethod::in_use);
2017       __ cbnz(r2, dispatch);
2018 
2019       // We have the address of an on stack replacement routine in r0
2020       // We need to prepare to execute the OSR method. First we must
2021       // migrate the locals and monitors off of the stack.
2022 
2023       __ mov(r19, r0);                             // save the nmethod
2024 
2025       call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));
2026 
2027       // r0 is OSR buffer, move it to expected parameter location
2028       __ mov(j_rarg0, r0);
2029 
2030       // remove activation
2031       // get sender esp
2032       __ ldr(esp,
2033           Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));
2034       // remove frame anchor
2035       __ leave();
2036       // Ensure compiled code always sees stack at proper alignment
2037       __ andr(sp, esp, -16);
2038 
2039       // and begin the OSR nmethod
2040       __ ldr(rscratch1, Address(r19, nmethod::osr_entry_point_offset()));
2041       __ br(rscratch1);
2042     }
2043   }
2044 }
2045 
2046 
2047 void TemplateTable::if_0cmp(Condition cc)
2048 {
2049   transition(itos, vtos);
2050   // assume branch is more often taken than not (loops use backward branches)
2051   Label not_taken;
2052   if (cc == equal)
2053     __ cbnzw(r0, not_taken);
2054   else if (cc == not_equal)
2055     __ cbzw(r0, not_taken);
2056   else {
2057     __ andsw(zr, r0, r0);
2058     __ br(j_not(cc), not_taken);
2059   }
2060 
2061   branch(false, false);
2062   __ bind(not_taken);
2063   __ profile_not_taken_branch(r0);
2064 }
2065 
2066 void TemplateTable::if_icmp(Condition cc)
2067 {
2068   transition(itos, vtos);
2069   // assume branch is more often taken than not (loops use backward branches)
2070   Label not_taken;
2071   __ pop_i(r1);
2072   __ cmpw(r1, r0, Assembler::LSL);
2073   __ br(j_not(cc), not_taken);
2074   branch(false, false);
2075   __ bind(not_taken);
2076   __ profile_not_taken_branch(r0);
2077 }
2078 
2079 void TemplateTable::if_nullcmp(Condition cc)
2080 {
2081   transition(atos, vtos);
2082   // assume branch is more often taken than not (loops use backward branches)
2083   Label not_taken;
2084   if (cc == equal)
2085     __ cbnz(r0, not_taken);
2086   else
2087     __ cbz(r0, not_taken);
2088   branch(false, false);
2089   __ bind(not_taken);
2090   __ profile_not_taken_branch(r0);
2091 }
2092 
2093 void TemplateTable::if_acmp(Condition cc) {
2094   transition(atos, vtos);
2095   // assume branch is more often taken than not (loops use backward branches)
2096   Label taken, not_taken;
2097   __ pop_ptr(r1);
2098 
2099   Register is_value_mask = rscratch1;
2100   __ mov(is_value_mask, markWord::always_locked_pattern);
2101 
2102   if (EnableValhalla) {
2103     __ cmp(r1, r0);
2104     __ br(Assembler::EQ, (cc == equal) ? taken : not_taken);
2105 
2106     // might be substitutable, test if either r0 or r1 is null
2107     __ andr(r2, r0, r1);
2108     __ cbz(r2, (cc == equal) ? not_taken : taken);
2109 
2110     // and both are values ?
2111     __ ldr(r2, Address(r1, oopDesc::mark_offset_in_bytes()));
2112     __ andr(r2, r2, is_value_mask);
2113     __ ldr(r4, Address(r0, oopDesc::mark_offset_in_bytes()));
2114     __ andr(r4, r4, is_value_mask);
2115     __ andr(r2, r2, r4);
2116     __ cmp(r2,  is_value_mask);
2117     __ br(Assembler::NE, (cc == equal) ? not_taken : taken);
2118 
2119     // same value klass ?
2120     __ load_metadata(r2, r1);
2121     __ load_metadata(r4, r0);
2122     __ cmp(r2, r4);
2123     __ br(Assembler::NE, (cc == equal) ? not_taken : taken);
2124 
2125     // Know both are the same type, let&#39;s test for substitutability...
2126     if (cc == equal) {
2127       invoke_is_substitutable(r0, r1, taken, not_taken);
2128     } else {
2129       invoke_is_substitutable(r0, r1, not_taken, taken);
2130     }
2131     __ stop(&quot;Not reachable&quot;);
2132   }
2133 
2134   __ cmpoop(r1, r0);
2135   __ br(j_not(cc), not_taken);
2136   __ bind(taken);
2137   branch(false, false);
2138   __ bind(not_taken);
2139   __ profile_not_taken_branch(r0);
2140 }
2141 
2142 void TemplateTable::invoke_is_substitutable(Register aobj, Register bobj,
2143                                             Label&amp; is_subst, Label&amp; not_subst) {
2144 
2145   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::is_substitutable), aobj, bobj);
2146   // Restored... r0 answer, jmp to outcome...
2147   __ cbz(r0, not_subst);
2148   __ b(is_subst);
2149 }
2150 
2151 
2152 void TemplateTable::ret() {
2153   transition(vtos, vtos);
2154   // We might be moving to a safepoint.  The thread which calls
2155   // Interpreter::notice_safepoints() will effectively flush its cache
2156   // when it makes a system call, but we need to do something to
2157   // ensure that we see the changed dispatch table.
2158   __ membar(MacroAssembler::LoadLoad);
2159 
2160   locals_index(r1);
2161   __ ldr(r1, aaddress(r1)); // get return bci, compute return bcp
2162   __ profile_ret(r1, r2);
2163   __ ldr(rbcp, Address(rmethod, Method::const_offset()));
2164   __ lea(rbcp, Address(rbcp, r1));
2165   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));
2166   __ dispatch_next(vtos, 0, /*generate_poll*/true);
2167 }
2168 
2169 void TemplateTable::wide_ret() {
2170   transition(vtos, vtos);
2171   locals_index_wide(r1);
2172   __ ldr(r1, aaddress(r1)); // get return bci, compute return bcp
2173   __ profile_ret(r1, r2);
2174   __ ldr(rbcp, Address(rmethod, Method::const_offset()));
2175   __ lea(rbcp, Address(rbcp, r1));
2176   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));
2177   __ dispatch_next(vtos, 0, /*generate_poll*/true);
2178 }
2179 
2180 
2181 void TemplateTable::tableswitch() {
2182   Label default_case, continue_execution;
2183   transition(itos, vtos);
2184   // align rbcp
2185   __ lea(r1, at_bcp(BytesPerInt));
2186   __ andr(r1, r1, -BytesPerInt);
2187   // load lo &amp; hi
2188   __ ldrw(r2, Address(r1, BytesPerInt));
2189   __ ldrw(r3, Address(r1, 2 * BytesPerInt));
2190   __ rev32(r2, r2);
2191   __ rev32(r3, r3);
2192   // check against lo &amp; hi
2193   __ cmpw(r0, r2);
2194   __ br(Assembler::LT, default_case);
2195   __ cmpw(r0, r3);
2196   __ br(Assembler::GT, default_case);
2197   // lookup dispatch offset
2198   __ subw(r0, r0, r2);
2199   __ lea(r3, Address(r1, r0, Address::uxtw(2)));
2200   __ ldrw(r3, Address(r3, 3 * BytesPerInt));
2201   __ profile_switch_case(r0, r1, r2);
2202   // continue execution
2203   __ bind(continue_execution);
2204   __ rev32(r3, r3);
2205   __ load_unsigned_byte(rscratch1, Address(rbcp, r3, Address::sxtw(0)));
2206   __ add(rbcp, rbcp, r3, ext::sxtw);
2207   __ dispatch_only(vtos, /*generate_poll*/true);
2208   // handle default
2209   __ bind(default_case);
2210   __ profile_switch_default(r0);
2211   __ ldrw(r3, Address(r1, 0));
2212   __ b(continue_execution);
2213 }
2214 
2215 void TemplateTable::lookupswitch() {
2216   transition(itos, itos);
2217   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2218 }
2219 
2220 void TemplateTable::fast_linearswitch() {
2221   transition(itos, vtos);
2222   Label loop_entry, loop, found, continue_execution;
2223   // bswap r0 so we can avoid bswapping the table entries
2224   __ rev32(r0, r0);
2225   // align rbcp
2226   __ lea(r19, at_bcp(BytesPerInt)); // btw: should be able to get rid of
2227                                     // this instruction (change offsets
2228                                     // below)
2229   __ andr(r19, r19, -BytesPerInt);
2230   // set counter
2231   __ ldrw(r1, Address(r19, BytesPerInt));
2232   __ rev32(r1, r1);
2233   __ b(loop_entry);
2234   // table search
2235   __ bind(loop);
2236   __ lea(rscratch1, Address(r19, r1, Address::lsl(3)));
2237   __ ldrw(rscratch1, Address(rscratch1, 2 * BytesPerInt));
2238   __ cmpw(r0, rscratch1);
2239   __ br(Assembler::EQ, found);
2240   __ bind(loop_entry);
2241   __ subs(r1, r1, 1);
2242   __ br(Assembler::PL, loop);
2243   // default case
2244   __ profile_switch_default(r0);
2245   __ ldrw(r3, Address(r19, 0));
2246   __ b(continue_execution);
2247   // entry found -&gt; get offset
2248   __ bind(found);
2249   __ lea(rscratch1, Address(r19, r1, Address::lsl(3)));
2250   __ ldrw(r3, Address(rscratch1, 3 * BytesPerInt));
2251   __ profile_switch_case(r1, r0, r19);
2252   // continue execution
2253   __ bind(continue_execution);
2254   __ rev32(r3, r3);
2255   __ add(rbcp, rbcp, r3, ext::sxtw);
2256   __ ldrb(rscratch1, Address(rbcp, 0));
2257   __ dispatch_only(vtos, /*generate_poll*/true);
2258 }
2259 
2260 void TemplateTable::fast_binaryswitch() {
2261   transition(itos, vtos);
2262   // Implementation using the following core algorithm:
2263   //
2264   // int binary_search(int key, LookupswitchPair* array, int n) {
2265   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2266   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2267   //   int i = 0;
2268   //   int j = n;
2269   //   while (i+1 &lt; j) {
2270   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2271   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2272   //     // where a stands for the array and assuming that the (inexisting)
2273   //     // element a[n] is infinitely big.
2274   //     int h = (i + j) &gt;&gt; 1;
2275   //     // i &lt; h &lt; j
2276   //     if (key &lt; array[h].fast_match()) {
2277   //       j = h;
2278   //     } else {
2279   //       i = h;
2280   //     }
2281   //   }
2282   //   // R: a[i] &lt;= key &lt; a[i+1] or Q
2283   //   // (i.e., if key is within array, i is the correct index)
2284   //   return i;
2285   // }
2286 
2287   // Register allocation
2288   const Register key   = r0; // already set (tosca)
2289   const Register array = r1;
2290   const Register i     = r2;
2291   const Register j     = r3;
2292   const Register h     = rscratch1;
2293   const Register temp  = rscratch2;
2294 
2295   // Find array start
2296   __ lea(array, at_bcp(3 * BytesPerInt)); // btw: should be able to
2297                                           // get rid of this
2298                                           // instruction (change
2299                                           // offsets below)
2300   __ andr(array, array, -BytesPerInt);
2301 
2302   // Initialize i &amp; j
2303   __ mov(i, 0);                            // i = 0;
2304   __ ldrw(j, Address(array, -BytesPerInt)); // j = length(array);
2305 
2306   // Convert j into native byteordering
2307   __ rev32(j, j);
2308 
2309   // And start
2310   Label entry;
2311   __ b(entry);
2312 
2313   // binary search loop
2314   {
2315     Label loop;
2316     __ bind(loop);
2317     // int h = (i + j) &gt;&gt; 1;
2318     __ addw(h, i, j);                           // h = i + j;
2319     __ lsrw(h, h, 1);                                   // h = (i + j) &gt;&gt; 1;
2320     // if (key &lt; array[h].fast_match()) {
2321     //   j = h;
2322     // } else {
2323     //   i = h;
2324     // }
2325     // Convert array[h].match to native byte-ordering before compare
2326     __ ldr(temp, Address(array, h, Address::lsl(3)));
2327     __ rev32(temp, temp);
2328     __ cmpw(key, temp);
2329     // j = h if (key &lt;  array[h].fast_match())
2330     __ csel(j, h, j, Assembler::LT);
2331     // i = h if (key &gt;= array[h].fast_match())
2332     __ csel(i, h, i, Assembler::GE);
2333     // while (i+1 &lt; j)
2334     __ bind(entry);
2335     __ addw(h, i, 1);          // i+1
2336     __ cmpw(h, j);             // i+1 &lt; j
2337     __ br(Assembler::LT, loop);
2338   }
2339 
2340   // end of binary search, result index is i (must check again!)
2341   Label default_case;
2342   // Convert array[i].match to native byte-ordering before compare
2343   __ ldr(temp, Address(array, i, Address::lsl(3)));
2344   __ rev32(temp, temp);
2345   __ cmpw(key, temp);
2346   __ br(Assembler::NE, default_case);
2347 
2348   // entry found -&gt; j = offset
2349   __ add(j, array, i, ext::uxtx, 3);
2350   __ ldrw(j, Address(j, BytesPerInt));
2351   __ profile_switch_case(i, key, array);
2352   __ rev32(j, j);
2353   __ load_unsigned_byte(rscratch1, Address(rbcp, j, Address::sxtw(0)));
2354   __ lea(rbcp, Address(rbcp, j, Address::sxtw(0)));
2355   __ dispatch_only(vtos, /*generate_poll*/true);
2356 
2357   // default case -&gt; j = default offset
2358   __ bind(default_case);
2359   __ profile_switch_default(i);
2360   __ ldrw(j, Address(array, -2 * BytesPerInt));
2361   __ rev32(j, j);
2362   __ load_unsigned_byte(rscratch1, Address(rbcp, j, Address::sxtw(0)));
2363   __ lea(rbcp, Address(rbcp, j, Address::sxtw(0)));
2364   __ dispatch_only(vtos, /*generate_poll*/true);
2365 }
2366 
2367 
2368 void TemplateTable::_return(TosState state)
2369 {
2370   transition(state, state);
2371   assert(_desc-&gt;calls_vm(),
2372          &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2373 
2374   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2375     assert(state == vtos, &quot;only valid state&quot;);
2376 
2377     __ ldr(c_rarg1, aaddress(0));
2378     __ load_klass(r3, c_rarg1);
2379     __ ldrw(r3, Address(r3, Klass::access_flags_offset()));
2380     Label skip_register_finalizer;
2381     __ tbz(r3, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);
2382 
2383     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), c_rarg1);
2384 
2385     __ bind(skip_register_finalizer);
2386   }
2387 
2388   // Issue a StoreStore barrier after all stores but before return
2389   // from any constructor for any class with a final field.  We don&#39;t
2390   // know if this is a finalizer, so we always do so.
2391   if (_desc-&gt;bytecode() == Bytecodes::_return)
2392     __ membar(MacroAssembler::StoreStore);
2393 
2394   // Narrow result if state is itos but result type is smaller.
2395   // Need to narrow in the return bytecode rather than in generate_return_entry
2396   // since compiled code callers expect the result to already be narrowed.
2397   if (state == itos) {
2398     __ narrow(r0);
2399   }
2400 
2401   __ remove_activation(state);
2402   __ ret(lr);
2403 }
2404 
2405 // ----------------------------------------------------------------------------
2406 // Volatile variables demand their effects be made known to all CPU&#39;s
2407 // in order.  Store buffers on most chips allow reads &amp; writes to
2408 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2409 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2410 // the interpreter does not reorder volatile references, the hardware
2411 // also must not reorder them).
2412 //
2413 // According to the new Java Memory Model (JMM):
2414 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2415 //     writes act as aquire &amp; release, so:
2416 // (2) A read cannot let unrelated NON-volatile memory refs that
2417 //     happen after the read float up to before the read.  It&#39;s OK for
2418 //     non-volatile memory refs that happen before the volatile read to
2419 //     float down below it.
2420 // (3) Similar a volatile write cannot let unrelated NON-volatile
2421 //     memory refs that happen BEFORE the write float down to after the
2422 //     write.  It&#39;s OK for non-volatile memory refs that happen after the
2423 //     volatile write to float up before it.
2424 //
2425 // We only put in barriers around volatile refs (they are expensive),
2426 // not _between_ memory refs (that would require us to track the
2427 // flavor of the previous memory refs).  Requirements (2) and (3)
2428 // require some barriers before volatile stores and after volatile
2429 // loads.  These nearly cover requirement (1) but miss the
2430 // volatile-store-volatile-load case.  This final case is placed after
2431 // volatile-stores although it could just as well go before
2432 // volatile-loads.
2433 
2434 void TemplateTable::resolve_cache_and_index(int byte_no,
2435                                             Register Rcache,
2436                                             Register index,
2437                                             size_t index_size) {
2438   const Register temp = r19;
2439   assert_different_registers(Rcache, index, temp);
2440 
2441   Label resolved, clinit_barrier_slow;
2442 
2443   Bytecodes::Code code = bytecode();
2444   switch (code) {
2445   case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2446   case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2447   default: break;
2448   }
2449 
2450   assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
2451   __ get_cache_and_index_and_bytecode_at_bcp(Rcache, index, temp, byte_no, 1, index_size);
2452   __ subs(zr, temp, (int) code);  // have we resolved this bytecode?
2453   __ br(Assembler::EQ, resolved);
2454 
2455   // resolve first time through
2456   // Class initialization barrier slow path lands here as well.
2457   __ bind(clinit_barrier_slow);
2458   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2459   __ mov(temp, (int) code);
2460   __ call_VM(noreg, entry, temp);
2461 
2462   // Update registers with resolved info
2463   __ get_cache_and_index_at_bcp(Rcache, index, 1, index_size);
2464   // n.b. unlike x86 Rcache is now rcpool plus the indexed offset
2465   // so all clients ofthis method must be modified accordingly
2466   __ bind(resolved);
2467 
2468   // Class initialization barrier for static methods
2469   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {
2470     __ load_resolved_method_at_index(byte_no, temp, Rcache);
2471     __ load_method_holder(temp, temp);
2472     __ clinit_barrier(temp, rscratch1, NULL, &amp;clinit_barrier_slow);
2473   }
2474 }
2475 
2476 // The Rcache and index registers must be set before call
2477 // n.b unlike x86 cache already includes the index offset
2478 void TemplateTable::load_field_cp_cache_entry(Register obj,
2479                                               Register cache,
2480                                               Register index,
2481                                               Register off,
2482                                               Register flags,
2483                                               bool is_static = false) {
2484   assert_different_registers(cache, index, flags, off);
2485 
2486   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2487   // Field offset
2488   __ ldr(off, Address(cache, in_bytes(cp_base_offset +
2489                                           ConstantPoolCacheEntry::f2_offset())));
2490   // Flags
2491   __ ldrw(flags, Address(cache, in_bytes(cp_base_offset +
2492                                            ConstantPoolCacheEntry::flags_offset())));
2493 
2494   // klass overwrite register
2495   if (is_static) {
2496     __ ldr(obj, Address(cache, in_bytes(cp_base_offset +
2497                                         ConstantPoolCacheEntry::f1_offset())));
2498     const int mirror_offset = in_bytes(Klass::java_mirror_offset());
2499     __ ldr(obj, Address(obj, mirror_offset));
2500     __ resolve_oop_handle(obj);
2501   }
2502 }
2503 
2504 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
2505                                                Register method,
2506                                                Register itable_index,
2507                                                Register flags,
2508                                                bool is_invokevirtual,
2509                                                bool is_invokevfinal, /*unused*/
2510                                                bool is_invokedynamic) {
2511   // setup registers
2512   const Register cache = rscratch2;
2513   const Register index = r4;
2514   assert_different_registers(method, flags);
2515   assert_different_registers(method, cache, index);
2516   assert_different_registers(itable_index, flags);
2517   assert_different_registers(itable_index, cache, index);
2518   // determine constant pool cache field offsets
2519   assert(is_invokevirtual == (byte_no == f2_byte), &quot;is_invokevirtual flag redundant&quot;);
2520   const int method_offset = in_bytes(
2521     ConstantPoolCache::base_offset() +
2522       (is_invokevirtual
2523        ? ConstantPoolCacheEntry::f2_offset()
2524        : ConstantPoolCacheEntry::f1_offset()));
2525   const int flags_offset = in_bytes(ConstantPoolCache::base_offset() +
2526                                     ConstantPoolCacheEntry::flags_offset());
2527   // access constant pool cache fields
2528   const int index_offset = in_bytes(ConstantPoolCache::base_offset() +
2529                                     ConstantPoolCacheEntry::f2_offset());
2530 
2531   size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));
2532   resolve_cache_and_index(byte_no, cache, index, index_size);
2533   __ ldr(method, Address(cache, method_offset));
2534 
2535   if (itable_index != noreg) {
2536     __ ldr(itable_index, Address(cache, index_offset));
2537   }
2538   __ ldrw(flags, Address(cache, flags_offset));
2539 }
2540 
2541 
2542 // The registers cache and index expected to be set before call.
2543 // Correct values of the cache and index registers are preserved.
2544 void TemplateTable::jvmti_post_field_access(Register cache, Register index,
2545                                             bool is_static, bool has_tos) {
2546   // do the JVMTI work here to avoid disturbing the register state below
2547   // We use c_rarg registers here because we want to use the register used in
2548   // the call to the VM
2549   if (JvmtiExport::can_post_field_access()) {
2550     // Check to see if a field access watch has been set before we
2551     // take the time to call into the VM.
2552     Label L1;
2553     assert_different_registers(cache, index, r0);
2554     __ lea(rscratch1, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
2555     __ ldrw(r0, Address(rscratch1));
2556     __ cbzw(r0, L1);
2557 
2558     __ get_cache_and_index_at_bcp(c_rarg2, c_rarg3, 1);
2559     __ lea(c_rarg2, Address(c_rarg2, in_bytes(ConstantPoolCache::base_offset())));
2560 
2561     if (is_static) {
2562       __ mov(c_rarg1, zr); // NULL object reference
2563     } else {
2564       __ ldr(c_rarg1, at_tos()); // get object pointer without popping it
2565       __ verify_oop(c_rarg1);
2566     }
2567     // c_rarg1: object pointer or NULL
2568     // c_rarg2: cache entry pointer
2569     // c_rarg3: jvalue object on the stack
2570     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2571                                        InterpreterRuntime::post_field_access),
2572                c_rarg1, c_rarg2, c_rarg3);
2573     __ get_cache_and_index_at_bcp(cache, index, 1);
2574     __ bind(L1);
2575   }
2576 }
2577 
2578 void TemplateTable::pop_and_check_object(Register r)
2579 {
2580   __ pop_ptr(r);
2581   __ null_check(r);  // for field access must check obj.
2582   __ verify_oop(r);
2583 }
2584 
2585 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc)
2586 {
2587   const Register cache = r2;
2588   const Register index = r3;
2589   const Register obj   = r4;
2590   const Register off   = r19;
2591   const Register flags = r0;
2592   const Register raw_flags = r6;
2593   const Register bc    = r4; // uses same reg as obj, so don&#39;t mix them
2594 
2595   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2596   jvmti_post_field_access(cache, index, is_static, false);
2597   load_field_cp_cache_entry(obj, cache, index, off, raw_flags, is_static);
2598 
2599   if (!is_static) {
2600     // obj is on the stack
2601     pop_and_check_object(obj);
2602   }
2603 
2604   // 8179954: We need to make sure that the code generated for
2605   // volatile accesses forms a sequentially-consistent set of
2606   // operations when combined with STLR and LDAR.  Without a leading
2607   // membar it&#39;s possible for a simple Dekker test to fail if loads
2608   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
2609   // the stores in one method and we interpret the loads in another.
2610   if (!is_c1_or_interpreter_only()){
2611     Label notVolatile;
2612     __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2613     __ membar(MacroAssembler::AnyAny);
2614     __ bind(notVolatile);
2615   }
2616 
2617   const Address field(obj, off);
2618 
2619   Label Done, notByte, notBool, notInt, notShort, notChar,
2620               notLong, notFloat, notObj, notDouble;
2621 
2622   // x86 uses a shift and mask or wings it with a shift plus assert
2623   // the mask is not needed. aarch64 just uses bitfield extract
2624   __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift, ConstantPoolCacheEntry::tos_state_bits);
2625 
2626   assert(btos == 0, &quot;change code, btos != 0&quot;);
2627   __ cbnz(flags, notByte);
2628 
2629   // Don&#39;t rewrite getstatic, only getfield
2630   if (is_static) rc = may_not_rewrite;
2631 
2632   // btos
2633   __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
2634   __ push(btos);
2635   // Rewrite bytecode to be faster
2636   if (rc == may_rewrite) {
2637     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
2638   }
2639   __ b(Done);
2640 
2641   __ bind(notByte);
2642   __ cmp(flags, (u1)ztos);
2643   __ br(Assembler::NE, notBool);
2644 
2645   // ztos (same code as btos)
2646   __ access_load_at(T_BOOLEAN, IN_HEAP, r0, field, noreg, noreg);
2647   __ push(ztos);
2648   // Rewrite bytecode to be faster
2649   if (rc == may_rewrite) {
2650     // use btos rewriting, no truncating to t/f bit is needed for getfield.
2651     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
2652   }
2653   __ b(Done);
2654 
2655   __ bind(notBool);
2656   __ cmp(flags, (u1)atos);
2657   __ br(Assembler::NE, notObj);
2658   // atos
2659   if (!EnableValhalla) {
2660     do_oop_load(_masm, field, r0, IN_HEAP);
2661     __ push(atos);
2662     if (rc == may_rewrite) {
2663       patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);
2664     }
2665     __ b(Done);
2666   } else { // Valhalla
2667 
2668     if (is_static) {
2669       __ load_heap_oop(r0, field);
2670       Label is_inline, isUninitialized;
2671       // Issue below if the static field has not been initialized yet
2672       __ test_field_is_inline_type(raw_flags, r8 /*temp*/, is_inline);
2673         // Not inline case
2674         __ push(atos);
2675         __ b(Done);
2676       // Inline case, must not return null even if uninitialized
2677       __ bind(is_inline);
2678         __ cbz(r0, isUninitialized);
2679           __ push(atos);
2680           __ b(Done);
2681         __ bind(isUninitialized);
2682           __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);
2683           __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field), obj, raw_flags);
2684           __ verify_oop(r0);
2685           __ push(atos);
2686           __ b(Done);
2687     } else {
2688       Label isFlattened, isInitialized, is_inline, rewrite_inline;
2689         __ test_field_is_inline_type(raw_flags, r8 /*temp*/, is_inline);
2690         // Non-inline field case
2691         __ load_heap_oop(r0, field);
2692         __ push(atos);
2693         if (rc == may_rewrite) {
2694           patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);
2695         }
2696         __ b(Done);
2697       __ bind(is_inline);
2698         __ test_field_is_inlined(raw_flags, r8 /* temp */, isFlattened);
2699          // Non-inline field case
2700           __ load_heap_oop(r0, field);
2701           __ cbnz(r0, isInitialized);
2702             __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);
2703             __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_instance_inline_type_field), obj, raw_flags);
2704           __ bind(isInitialized);
2705           __ verify_oop(r0);
2706           __ push(atos);
2707           __ b(rewrite_inline);
2708         __ bind(isFlattened);
2709           __ ldr(r10, Address(cache, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset())));
2710           __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);
2711           call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flattened_field), obj, raw_flags, r10);
2712           __ verify_oop(r0);
2713           __ push(atos);
2714       __ bind(rewrite_inline);
2715       if (rc == may_rewrite) {
2716          patch_bytecode(Bytecodes::_fast_qgetfield, bc, r1);
2717       }
2718       __ b(Done);
2719     }
2720   }
2721 
2722   __ bind(notObj);
2723   __ cmp(flags, (u1)itos);
2724   __ br(Assembler::NE, notInt);
2725   // itos
2726   __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
2727   __ push(itos);
2728   // Rewrite bytecode to be faster
2729   if (rc == may_rewrite) {
2730     patch_bytecode(Bytecodes::_fast_igetfield, bc, r1);
2731   }
2732   __ b(Done);
2733 
2734   __ bind(notInt);
2735   __ cmp(flags, (u1)ctos);
2736   __ br(Assembler::NE, notChar);
2737   // ctos
2738   __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
2739   __ push(ctos);
2740   // Rewrite bytecode to be faster
2741   if (rc == may_rewrite) {
2742     patch_bytecode(Bytecodes::_fast_cgetfield, bc, r1);
2743   }
2744   __ b(Done);
2745 
2746   __ bind(notChar);
2747   __ cmp(flags, (u1)stos);
2748   __ br(Assembler::NE, notShort);
2749   // stos
2750   __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
2751   __ push(stos);
2752   // Rewrite bytecode to be faster
2753   if (rc == may_rewrite) {
2754     patch_bytecode(Bytecodes::_fast_sgetfield, bc, r1);
2755   }
2756   __ b(Done);
2757 
2758   __ bind(notShort);
2759   __ cmp(flags, (u1)ltos);
2760   __ br(Assembler::NE, notLong);
2761   // ltos
2762   __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
2763   __ push(ltos);
2764   // Rewrite bytecode to be faster
2765   if (rc == may_rewrite) {
2766     patch_bytecode(Bytecodes::_fast_lgetfield, bc, r1);
2767   }
2768   __ b(Done);
2769 
2770   __ bind(notLong);
2771   __ cmp(flags, (u1)ftos);
2772   __ br(Assembler::NE, notFloat);
2773   // ftos
2774   __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
2775   __ push(ftos);
2776   // Rewrite bytecode to be faster
2777   if (rc == may_rewrite) {
2778     patch_bytecode(Bytecodes::_fast_fgetfield, bc, r1);
2779   }
2780   __ b(Done);
2781 
2782   __ bind(notFloat);
2783 #ifdef ASSERT
2784   __ cmp(flags, (u1)dtos);
2785   __ br(Assembler::NE, notDouble);
2786 #endif
2787   // dtos
2788   __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
2789   __ push(dtos);
2790   // Rewrite bytecode to be faster
2791   if (rc == may_rewrite) {
2792     patch_bytecode(Bytecodes::_fast_dgetfield, bc, r1);
2793   }
2794 #ifdef ASSERT
2795   __ b(Done);
2796 
2797   __ bind(notDouble);
2798   __ stop(&quot;Bad state&quot;);
2799 #endif
2800 
2801   __ bind(Done);
2802 
2803   Label notVolatile;
2804   __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2805   __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
2806   __ bind(notVolatile);
2807 }
2808 
2809 
2810 void TemplateTable::getfield(int byte_no)
2811 {
2812   getfield_or_static(byte_no, false);
2813 }
2814 
2815 void TemplateTable::nofast_getfield(int byte_no) {
2816   getfield_or_static(byte_no, false, may_not_rewrite);
2817 }
2818 
2819 void TemplateTable::getstatic(int byte_no)
2820 {
2821   getfield_or_static(byte_no, true);
2822 }
2823 
2824 // The registers cache and index expected to be set before call.
2825 // The function may destroy various registers, just not the cache and index registers.
2826 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
2827   transition(vtos, vtos);
2828 
2829   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2830 
2831   if (JvmtiExport::can_post_field_modification()) {
2832     // Check to see if a field modification watch has been set before
2833     // we take the time to call into the VM.
2834     Label L1;
2835     assert_different_registers(cache, index, r0);
2836     __ lea(rscratch1, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
2837     __ ldrw(r0, Address(rscratch1));
2838     __ cbz(r0, L1);
2839 
2840     __ get_cache_and_index_at_bcp(c_rarg2, rscratch1, 1);
2841 
2842     if (is_static) {
2843       // Life is simple.  Null out the object pointer.
2844       __ mov(c_rarg1, zr);
2845     } else {
2846       // Life is harder. The stack holds the value on top, followed by
2847       // the object.  We don&#39;t know the size of the value, though; it
2848       // could be one or two words depending on its type. As a result,
2849       // we must find the type to determine where the object is.
2850       __ ldrw(c_rarg3, Address(c_rarg2,
2851                                in_bytes(cp_base_offset +
2852                                         ConstantPoolCacheEntry::flags_offset())));
2853       __ lsr(c_rarg3, c_rarg3,
2854              ConstantPoolCacheEntry::tos_state_shift);
2855       ConstantPoolCacheEntry::verify_tos_state_shift();
2856       Label nope2, done, ok;
2857       __ ldr(c_rarg1, at_tos_p1());  // initially assume a one word jvalue
2858       __ cmpw(c_rarg3, ltos);
2859       __ br(Assembler::EQ, ok);
2860       __ cmpw(c_rarg3, dtos);
2861       __ br(Assembler::NE, nope2);
2862       __ bind(ok);
2863       __ ldr(c_rarg1, at_tos_p2()); // ltos (two word jvalue)
2864       __ bind(nope2);
2865     }
2866     // cache entry pointer
2867     __ add(c_rarg2, c_rarg2, in_bytes(cp_base_offset));
2868     // object (tos)
2869     __ mov(c_rarg3, esp);
2870     // c_rarg1: object pointer set up above (NULL if static)
2871     // c_rarg2: cache entry pointer
2872     // c_rarg3: jvalue object on the stack
2873     __ call_VM(noreg,
2874                CAST_FROM_FN_PTR(address,
2875                                 InterpreterRuntime::post_field_modification),
2876                c_rarg1, c_rarg2, c_rarg3);
2877     __ get_cache_and_index_at_bcp(cache, index, 1);
2878     __ bind(L1);
2879   }
2880 }
2881 
2882 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2883   transition(vtos, vtos);
2884 
2885   const Register cache = r2;
2886   const Register index = r3;
2887   const Register obj   = r2;
2888   const Register off   = r19;
2889   const Register flags = r0;
2890   const Register flags2 = r6;
2891   const Register bc    = r4;
2892 
2893   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2894   jvmti_post_field_mod(cache, index, is_static);
2895   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2896 
2897   Label Done;
2898   __ mov(r5, flags);
2899 
2900   {
2901     Label notVolatile;
2902     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2903     __ membar(MacroAssembler::StoreStore | MacroAssembler::LoadStore);
2904     __ bind(notVolatile);
2905   }
2906 
2907   // field address
2908   const Address field(obj, off);
2909 
2910   Label notByte, notBool, notInt, notShort, notChar,
2911         notLong, notFloat, notObj, notDouble;
2912 
2913   __ mov(flags2, flags);
2914 
2915   // x86 uses a shift and mask or wings it with a shift plus assert
2916   // the mask is not needed. aarch64 just uses bitfield extract
2917   __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);
2918 
2919   assert(btos == 0, &quot;change code, btos != 0&quot;);
2920   __ cbnz(flags, notByte);
2921 
2922   // Don&#39;t rewrite putstatic, only putfield
2923   if (is_static) rc = may_not_rewrite;
2924 
2925   // btos
2926   {
2927     __ pop(btos);
2928     if (!is_static) pop_and_check_object(obj);
2929     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
2930     if (rc == may_rewrite) {
2931       patch_bytecode(Bytecodes::_fast_bputfield, bc, r1, true, byte_no);
2932     }
2933     __ b(Done);
2934   }
2935 
2936   __ bind(notByte);
2937   __ cmp(flags, (u1)ztos);
2938   __ br(Assembler::NE, notBool);
2939 
2940   // ztos
2941   {
2942     __ pop(ztos);
2943     if (!is_static) pop_and_check_object(obj);
2944     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
2945     if (rc == may_rewrite) {
2946       patch_bytecode(Bytecodes::_fast_zputfield, bc, r1, true, byte_no);
2947     }
2948     __ b(Done);
2949   }
2950 
2951   __ bind(notBool);
2952   __ cmp(flags, (u1)atos);
2953   __ br(Assembler::NE, notObj);
2954 
2955   // atos
2956   {
2957      if (!EnableValhalla) {
2958       __ pop(atos);
2959       if (!is_static) pop_and_check_object(obj);
2960       // Store into the field
2961       do_oop_store(_masm, field, r0, IN_HEAP);
2962       if (rc == may_rewrite) {
2963         patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);
2964       }
2965       __ b(Done);
2966      } else { // Valhalla
2967 
2968       __ pop(atos);
2969       if (is_static) {
2970         Label not_inline;
2971          __ test_field_is_not_inline_type(flags2, r8 /* temp */, not_inline);
2972          __ null_check(r0);
2973          __ bind(not_inline);
2974          do_oop_store(_masm, field, r0, IN_HEAP);
2975          __ b(Done);
2976       } else {
2977         Label is_inline, isFlattened, rewrite_not_inline, rewrite_inline;
2978         __ test_field_is_inline_type(flags2, r8 /*temp*/, is_inline);
2979         // Not inline case
2980         pop_and_check_object(obj);
2981         // Store into the field
2982         do_oop_store(_masm, field, r0, IN_HEAP);
2983         __ bind(rewrite_not_inline);
2984         if (rc == may_rewrite) {
2985           patch_bytecode(Bytecodes::_fast_aputfield, bc, r19, true, byte_no);
2986         }
2987         __ b(Done);
2988         // Implementation of the inline semantic
2989         __ bind(is_inline);
2990         __ null_check(r0);
2991         __ test_field_is_inlined(flags2, r8 /*temp*/, isFlattened);
2992         // Not inline case
2993         pop_and_check_object(obj);
2994         // Store into the field
2995         do_oop_store(_masm, field, r0, IN_HEAP);
2996         __ b(rewrite_inline);
2997         __ bind(isFlattened);
2998         pop_and_check_object(obj);
2999         call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::write_flattened_value), r0, off, obj);
3000         __ bind(rewrite_inline);
3001         if (rc == may_rewrite) {
3002           patch_bytecode(Bytecodes::_fast_qputfield, bc, r19, true, byte_no);
3003         }
3004         __ b(Done);
3005       }
3006      }  // Valhalla
3007   }
3008 
3009   __ bind(notObj);
3010   __ cmp(flags, (u1)itos);
3011   __ br(Assembler::NE, notInt);
3012 
3013   // itos
3014   {
3015     __ pop(itos);
3016     if (!is_static) pop_and_check_object(obj);
3017     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
3018     if (rc == may_rewrite) {
3019       patch_bytecode(Bytecodes::_fast_iputfield, bc, r1, true, byte_no);
3020     }
3021     __ b(Done);
3022   }
3023 
3024   __ bind(notInt);
3025   __ cmp(flags, (u1)ctos);
3026   __ br(Assembler::NE, notChar);
3027 
3028   // ctos
3029   {
3030     __ pop(ctos);
3031     if (!is_static) pop_and_check_object(obj);
3032     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
3033     if (rc == may_rewrite) {
3034       patch_bytecode(Bytecodes::_fast_cputfield, bc, r1, true, byte_no);
3035     }
3036     __ b(Done);
3037   }
3038 
3039   __ bind(notChar);
3040   __ cmp(flags, (u1)stos);
3041   __ br(Assembler::NE, notShort);
3042 
3043   // stos
3044   {
3045     __ pop(stos);
3046     if (!is_static) pop_and_check_object(obj);
3047     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
3048     if (rc == may_rewrite) {
3049       patch_bytecode(Bytecodes::_fast_sputfield, bc, r1, true, byte_no);
3050     }
3051     __ b(Done);
3052   }
3053 
3054   __ bind(notShort);
3055   __ cmp(flags, (u1)ltos);
3056   __ br(Assembler::NE, notLong);
3057 
3058   // ltos
3059   {
3060     __ pop(ltos);
3061     if (!is_static) pop_and_check_object(obj);
3062     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
3063     if (rc == may_rewrite) {
3064       patch_bytecode(Bytecodes::_fast_lputfield, bc, r1, true, byte_no);
3065     }
3066     __ b(Done);
3067   }
3068 
3069   __ bind(notLong);
3070   __ cmp(flags, (u1)ftos);
3071   __ br(Assembler::NE, notFloat);
3072 
3073   // ftos
3074   {
3075     __ pop(ftos);
3076     if (!is_static) pop_and_check_object(obj);
3077     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
3078     if (rc == may_rewrite) {
3079       patch_bytecode(Bytecodes::_fast_fputfield, bc, r1, true, byte_no);
3080     }
3081     __ b(Done);
3082   }
3083 
3084   __ bind(notFloat);
3085 #ifdef ASSERT
3086   __ cmp(flags, (u1)dtos);
3087   __ br(Assembler::NE, notDouble);
3088 #endif
3089 
3090   // dtos
3091   {
3092     __ pop(dtos);
3093     if (!is_static) pop_and_check_object(obj);
3094     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
3095     if (rc == may_rewrite) {
3096       patch_bytecode(Bytecodes::_fast_dputfield, bc, r1, true, byte_no);
3097     }
3098   }
3099 
3100 #ifdef ASSERT
3101   __ b(Done);
3102 
3103   __ bind(notDouble);
3104   __ stop(&quot;Bad state&quot;);
3105 #endif
3106 
3107   __ bind(Done);
3108 
3109   {
3110     Label notVolatile;
3111     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3112     __ membar(MacroAssembler::StoreLoad | MacroAssembler::StoreStore);
3113     __ bind(notVolatile);
3114   }
3115 }
3116 
3117 void TemplateTable::putfield(int byte_no)
3118 {
3119   putfield_or_static(byte_no, false);
3120 }
3121 
3122 void TemplateTable::nofast_putfield(int byte_no) {
3123   putfield_or_static(byte_no, false, may_not_rewrite);
3124 }
3125 
3126 void TemplateTable::putstatic(int byte_no) {
3127   putfield_or_static(byte_no, true);
3128 }
3129 
3130 void TemplateTable::jvmti_post_fast_field_mod()
3131 {
3132   if (JvmtiExport::can_post_field_modification()) {
3133     // Check to see if a field modification watch has been set before
3134     // we take the time to call into the VM.
3135     Label L2;
3136     __ lea(rscratch1, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3137     __ ldrw(c_rarg3, Address(rscratch1));
3138     __ cbzw(c_rarg3, L2);
3139     __ pop_ptr(r19);                  // copy the object pointer from tos
3140     __ verify_oop(r19);
3141     __ push_ptr(r19);                 // put the object pointer back on tos
3142     // Save tos values before call_VM() clobbers them. Since we have
3143     // to do it for every data type, we use the saved values as the
3144     // jvalue object.
3145     switch (bytecode()) {          // load values into the jvalue object
3146     case Bytecodes::_fast_qputfield: //fall through
3147     case Bytecodes::_fast_aputfield: __ push_ptr(r0); break;
3148     case Bytecodes::_fast_bputfield: // fall through
3149     case Bytecodes::_fast_zputfield: // fall through
3150     case Bytecodes::_fast_sputfield: // fall through
3151     case Bytecodes::_fast_cputfield: // fall through
3152     case Bytecodes::_fast_iputfield: __ push_i(r0); break;
3153     case Bytecodes::_fast_dputfield: __ push_d(); break;
3154     case Bytecodes::_fast_fputfield: __ push_f(); break;
3155     case Bytecodes::_fast_lputfield: __ push_l(r0); break;
3156 
3157     default:
3158       ShouldNotReachHere();
3159     }
3160     __ mov(c_rarg3, esp);             // points to jvalue on the stack
3161     // access constant pool cache entry
3162     __ get_cache_entry_pointer_at_bcp(c_rarg2, r0, 1);
3163     __ verify_oop(r19);
3164     // r19: object pointer copied above
3165     // c_rarg2: cache entry pointer
3166     // c_rarg3: jvalue object on the stack
3167     __ call_VM(noreg,
3168                CAST_FROM_FN_PTR(address,
3169                                 InterpreterRuntime::post_field_modification),
3170                r19, c_rarg2, c_rarg3);
3171 
3172     switch (bytecode()) {             // restore tos values
3173     case Bytecodes::_fast_qputfield: //fall through
3174     case Bytecodes::_fast_aputfield: __ pop_ptr(r0); break;
3175     case Bytecodes::_fast_bputfield: // fall through
3176     case Bytecodes::_fast_zputfield: // fall through
3177     case Bytecodes::_fast_sputfield: // fall through
3178     case Bytecodes::_fast_cputfield: // fall through
3179     case Bytecodes::_fast_iputfield: __ pop_i(r0); break;
3180     case Bytecodes::_fast_dputfield: __ pop_d(); break;
3181     case Bytecodes::_fast_fputfield: __ pop_f(); break;
3182     case Bytecodes::_fast_lputfield: __ pop_l(r0); break;
3183     default: break;
3184     }
3185     __ bind(L2);
3186   }
3187 }
3188 
3189 void TemplateTable::fast_storefield(TosState state)
3190 {
3191   transition(state, vtos);
3192 
3193   ByteSize base = ConstantPoolCache::base_offset();
3194 
3195   jvmti_post_fast_field_mod();
3196 
3197   // access constant pool cache
3198   __ get_cache_and_index_at_bcp(r2, r1, 1);
3199 
3200   // Must prevent reordering of the following cp cache loads with bytecode load
3201   __ membar(MacroAssembler::LoadLoad);
3202 
3203   // test for volatile with r3
3204   __ ldrw(r3, Address(r2, in_bytes(base +
3205                                    ConstantPoolCacheEntry::flags_offset())));
3206 
3207   // replace index with field offset from cache entry
3208   __ ldr(r1, Address(r2, in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
3209 
3210   {
3211     Label notVolatile;
3212     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3213     __ membar(MacroAssembler::StoreStore | MacroAssembler::LoadStore);
3214     __ bind(notVolatile);
3215   }
3216 
3217   Label notVolatile;
3218 
3219   // Get object from stack
3220   pop_and_check_object(r2);
3221 
3222   // field address
3223   const Address field(r2, r1);
3224 
3225   // access field
3226   switch (bytecode()) {
3227   case Bytecodes::_fast_qputfield: //fall through
3228    {
3229       Label isFlattened, done;
3230       __ null_check(r0);
3231       __ test_field_is_flattened(r3, r8 /* temp */, isFlattened);
3232       // No Flattened case
3233       do_oop_store(_masm, field, r0, IN_HEAP);
3234       __ b(done);
3235       __ bind(isFlattened);
3236       call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::write_flattened_value), r0, r1, r2);
3237       __ bind(done);
3238     }
3239     break;
3240   case Bytecodes::_fast_aputfield:
3241     do_oop_store(_masm, field, r0, IN_HEAP);
3242     break;
3243   case Bytecodes::_fast_lputfield:
3244     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
3245     break;
3246   case Bytecodes::_fast_iputfield:
3247     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
3248     break;
3249   case Bytecodes::_fast_zputfield:
3250     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
3251     break;
3252   case Bytecodes::_fast_bputfield:
3253     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
3254     break;
3255   case Bytecodes::_fast_sputfield:
3256     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
3257     break;
3258   case Bytecodes::_fast_cputfield:
3259     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
3260     break;
3261   case Bytecodes::_fast_fputfield:
3262     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
3263     break;
3264   case Bytecodes::_fast_dputfield:
3265     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
3266     break;
3267   default:
3268     ShouldNotReachHere();
3269   }
3270 
3271   {
3272     Label notVolatile;
3273     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3274     __ membar(MacroAssembler::StoreLoad | MacroAssembler::StoreStore);
3275     __ bind(notVolatile);
3276   }
3277 }
3278 
3279 
3280 void TemplateTable::fast_accessfield(TosState state)
3281 {
3282   transition(atos, state);
3283   // Do the JVMTI work here to avoid disturbing the register state below
3284   if (JvmtiExport::can_post_field_access()) {
3285     // Check to see if a field access watch has been set before we
3286     // take the time to call into the VM.
3287     Label L1;
3288     __ lea(rscratch1, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
3289     __ ldrw(r2, Address(rscratch1));
3290     __ cbzw(r2, L1);
3291     // access constant pool cache entry
3292     __ get_cache_entry_pointer_at_bcp(c_rarg2, rscratch2, 1);
3293     __ verify_oop(r0);
3294     __ push_ptr(r0);  // save object pointer before call_VM() clobbers it
3295     __ mov(c_rarg1, r0);
3296     // c_rarg1: object pointer copied above
3297     // c_rarg2: cache entry pointer
3298     __ call_VM(noreg,
3299                CAST_FROM_FN_PTR(address,
3300                                 InterpreterRuntime::post_field_access),
3301                c_rarg1, c_rarg2);
3302     __ pop_ptr(r0); // restore object pointer
3303     __ bind(L1);
3304   }
3305 
3306   // access constant pool cache
3307   __ get_cache_and_index_at_bcp(r2, r1, 1);
3308 
3309   // Must prevent reordering of the following cp cache loads with bytecode load
3310   __ membar(MacroAssembler::LoadLoad);
3311 
3312   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3313                                   ConstantPoolCacheEntry::f2_offset())));
3314   __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3315                                    ConstantPoolCacheEntry::flags_offset())));
3316 
3317   // r0: object
3318   __ verify_oop(r0);
3319   __ null_check(r0);
3320   const Address field(r0, r1);
3321 
3322   // 8179954: We need to make sure that the code generated for
3323   // volatile accesses forms a sequentially-consistent set of
3324   // operations when combined with STLR and LDAR.  Without a leading
3325   // membar it&#39;s possible for a simple Dekker test to fail if loads
3326   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3327   // the stores in one method and we interpret the loads in another.
3328   if (!is_c1_or_interpreter_only()) {
3329     Label notVolatile;
3330     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3331     __ membar(MacroAssembler::AnyAny);
3332     __ bind(notVolatile);
3333   }
3334 
3335   // access field
3336   switch (bytecode()) {
3337   case Bytecodes::_fast_qgetfield:
3338     {
3339        Label isFlattened, isInitialized, Done;
3340        // FIXME: We don&#39;t need to reload registers multiple times, but stay close to x86 code
3341        __ ldrw(r9, Address(r2, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset())));
3342        __ test_field_is_inlined(r9, r8 /* temp */, isFlattened);
3343         // Non-flattened field case
3344         __ mov(r9, r0);
3345         __ load_heap_oop(r0, field);
3346         __ cbnz(r0, isInitialized);
3347           __ mov(r0, r9);
3348           __ ldrw(r9, Address(r2, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset())));
3349           __ andw(r9, r9, ConstantPoolCacheEntry::field_index_mask);
3350           __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_instance_inline_type_field), r0, r9);
3351         __ bind(isInitialized);
3352         __ verify_oop(r0);
3353         __ b(Done);
3354       __ bind(isFlattened);
3355         __ ldrw(r9, Address(r2, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset())));
3356         __ andw(r9, r9, ConstantPoolCacheEntry::field_index_mask);
3357         __ ldr(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset())));
3358         call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flattened_field), r0, r9, r3);
3359         __ verify_oop(r0);
3360       __ bind(Done);
3361     }
3362     break;
3363   case Bytecodes::_fast_agetfield:
3364     do_oop_load(_masm, field, r0, IN_HEAP);
3365     __ verify_oop(r0);
3366     break;
3367   case Bytecodes::_fast_lgetfield:
3368     __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
3369     break;
3370   case Bytecodes::_fast_igetfield:
3371     __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
3372     break;
3373   case Bytecodes::_fast_bgetfield:
3374     __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
3375     break;
3376   case Bytecodes::_fast_sgetfield:
3377     __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
3378     break;
3379   case Bytecodes::_fast_cgetfield:
3380     __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
3381     break;
3382   case Bytecodes::_fast_fgetfield:
3383     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3384     break;
3385   case Bytecodes::_fast_dgetfield:
3386     __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* dtos */, field, noreg, noreg);
3387     break;
3388   default:
3389     ShouldNotReachHere();
3390   }
3391   {
3392     Label notVolatile;
3393     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3394     __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
3395     __ bind(notVolatile);
3396   }
3397 }
3398 
3399 void TemplateTable::fast_xaccess(TosState state)
3400 {
3401   transition(vtos, state);
3402 
3403   // get receiver
3404   __ ldr(r0, aaddress(0));
3405   // access constant pool cache
3406   __ get_cache_and_index_at_bcp(r2, r3, 2);
3407   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3408                                   ConstantPoolCacheEntry::f2_offset())));
3409 
3410   // 8179954: We need to make sure that the code generated for
3411   // volatile accesses forms a sequentially-consistent set of
3412   // operations when combined with STLR and LDAR.  Without a leading
3413   // membar it&#39;s possible for a simple Dekker test to fail if loads
3414   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3415   // the stores in one method and we interpret the loads in another.
3416   if (!is_c1_or_interpreter_only()) {
3417     Label notVolatile;
3418     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3419                                      ConstantPoolCacheEntry::flags_offset())));
3420     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3421     __ membar(MacroAssembler::AnyAny);
3422     __ bind(notVolatile);
3423   }
3424 
3425   // make sure exception is reported in correct bcp range (getfield is
3426   // next instruction)
3427   __ increment(rbcp);
3428   __ null_check(r0);
3429   switch (state) {
3430   case itos:
3431     __ access_load_at(T_INT, IN_HEAP, r0, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3432     break;
3433   case atos:
3434     do_oop_load(_masm, Address(r0, r1, Address::lsl(0)), r0, IN_HEAP);
3435     __ verify_oop(r0);
3436     break;
3437   case ftos:
3438     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3439     break;
3440   default:
3441     ShouldNotReachHere();
3442   }
3443 
3444   {
3445     Label notVolatile;
3446     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3447                                      ConstantPoolCacheEntry::flags_offset())));
3448     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3449     __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
3450     __ bind(notVolatile);
3451   }
3452 
3453   __ decrement(rbcp);
3454 }
3455 
3456 
3457 
3458 //-----------------------------------------------------------------------------
3459 // Calls
3460 
3461 void TemplateTable::count_calls(Register method, Register temp)
3462 {
3463   __ call_Unimplemented();
3464 }
3465 
3466 void TemplateTable::prepare_invoke(int byte_no,
3467                                    Register method, // linked method (or i-klass)
3468                                    Register index,  // itable index, MethodType, etc.
3469                                    Register recv,   // if caller wants to see it
3470                                    Register flags   // if caller wants to test it
3471                                    ) {
3472   // determine flags
3473   Bytecodes::Code code = bytecode();
3474   const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;
3475   const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;
3476   const bool is_invokehandle     = code == Bytecodes::_invokehandle;
3477   const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;
3478   const bool is_invokespecial    = code == Bytecodes::_invokespecial;
3479   const bool load_receiver       = (recv  != noreg);
3480   const bool save_flags          = (flags != noreg);
3481   assert(load_receiver == (code != Bytecodes::_invokestatic &amp;&amp; code != Bytecodes::_invokedynamic), &quot;&quot;);
3482   assert(save_flags    == (is_invokeinterface || is_invokevirtual), &quot;need flags for vfinal&quot;);
3483   assert(flags == noreg || flags == r3, &quot;&quot;);
3484   assert(recv  == noreg || recv  == r2, &quot;&quot;);
3485 
3486   // setup registers &amp; access constant pool cache
3487   if (recv  == noreg)  recv  = r2;
3488   if (flags == noreg)  flags = r3;
3489   assert_different_registers(method, index, recv, flags);
3490 
3491   // save &#39;interpreter return address&#39;
3492   __ save_bcp();
3493 
3494   load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, false, is_invokedynamic);
3495 
3496   // maybe push appendix to arguments (just before return address)
3497   if (is_invokedynamic || is_invokehandle) {
3498     Label L_no_push;
3499     __ tbz(flags, ConstantPoolCacheEntry::has_appendix_shift, L_no_push);
3500     // Push the appendix as a trailing parameter.
3501     // This must be done before we get the receiver,
3502     // since the parameter_size includes it.
3503     __ push(r19);
3504     __ mov(r19, index);
3505     __ load_resolved_reference_at_index(index, r19);
3506     __ pop(r19);
3507     __ push(index);  // push appendix (MethodType, CallSite, etc.)
3508     __ bind(L_no_push);
3509   }
3510 
3511   // load receiver if needed (note: no return address pushed yet)
3512   if (load_receiver) {
3513     __ andw(recv, flags, ConstantPoolCacheEntry::parameter_size_mask);
3514     // FIXME -- is this actually correct? looks like it should be 2
3515     // const int no_return_pc_pushed_yet = -1;  // argument slot correction before we push return address
3516     // const int receiver_is_at_end      = -1;  // back off one slot to get receiver
3517     // Address recv_addr = __ argument_address(recv, no_return_pc_pushed_yet + receiver_is_at_end);
3518     // __ movptr(recv, recv_addr);
3519     __ add(rscratch1, esp, recv, ext::uxtx, 3); // FIXME: uxtb here?
3520     __ ldr(recv, Address(rscratch1, -Interpreter::expr_offset_in_bytes(1)));
3521     __ verify_oop(recv);
3522   }
3523 
3524   // compute return type
3525   // x86 uses a shift and mask or wings it with a shift plus assert
3526   // the mask is not needed. aarch64 just uses bitfield extract
3527   __ ubfxw(rscratch2, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);
3528   // load return address
3529   {
3530     const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);
3531     __ mov(rscratch1, table_addr);
3532     __ ldr(lr, Address(rscratch1, rscratch2, Address::lsl(3)));
3533   }
3534 }
3535 
3536 
3537 void TemplateTable::invokevirtual_helper(Register index,
3538                                          Register recv,
3539                                          Register flags)
3540 {
3541   // Uses temporary registers r0, r3
3542   assert_different_registers(index, recv, r0, r3);
3543   // Test for an invoke of a final method
3544   Label notFinal;
3545   __ tbz(flags, ConstantPoolCacheEntry::is_vfinal_shift, notFinal);
3546 
3547   const Register method = index;  // method must be rmethod
3548   assert(method == rmethod,
3549          &quot;methodOop must be rmethod for interpreter calling convention&quot;);
3550 
3551   // do the call - the index is actually the method to call
3552   // that is, f2 is a vtable index if !is_vfinal, else f2 is a Method*
3553 
3554   // It&#39;s final, need a null check here!
3555   __ null_check(recv);
3556 
3557   // profile this call
3558   __ profile_final_call(r0);
3559   __ profile_arguments_type(r0, method, r4, true);
3560 
3561   __ jump_from_interpreted(method, r0);
3562 
3563   __ bind(notFinal);
3564 
3565   // get receiver klass
3566   __ null_check(recv, oopDesc::klass_offset_in_bytes());
3567   __ load_klass(r0, recv);
3568 
3569   // profile this call
3570   __ profile_virtual_call(r0, rlocals, r3);
3571 
3572   // get target methodOop &amp; entry point
3573   __ lookup_virtual_method(r0, index, method);
3574   __ profile_arguments_type(r3, method, r4, true);
3575   // FIXME -- this looks completely redundant. is it?
3576   // __ ldr(r3, Address(method, Method::interpreter_entry_offset()));
3577   __ jump_from_interpreted(method, r3);
3578 }
3579 
3580 void TemplateTable::invokevirtual(int byte_no)
3581 {
3582   transition(vtos, vtos);
3583   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3584 
3585   prepare_invoke(byte_no, rmethod, noreg, r2, r3);
3586 
3587   // rmethod: index (actually a Method*)
3588   // r2: receiver
3589   // r3: flags
3590 
3591   invokevirtual_helper(rmethod, r2, r3);
3592 }
3593 
3594 void TemplateTable::invokespecial(int byte_no)
3595 {
3596   transition(vtos, vtos);
3597   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3598 
3599   prepare_invoke(byte_no, rmethod, noreg,  // get f1 Method*
3600                  r2);  // get receiver also for null check
3601   __ verify_oop(r2);
3602   __ null_check(r2);
3603   // do the call
3604   __ profile_call(r0);
3605   __ profile_arguments_type(r0, rmethod, rbcp, false);
3606   __ jump_from_interpreted(rmethod, r0);
3607 }
3608 
3609 void TemplateTable::invokestatic(int byte_no)
3610 {
3611   transition(vtos, vtos);
3612   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3613 
3614   prepare_invoke(byte_no, rmethod);  // get f1 Method*
3615   // do the call
3616   __ profile_call(r0);
3617   __ profile_arguments_type(r0, rmethod, r4, false);
3618   __ jump_from_interpreted(rmethod, r0);
3619 }
3620 
3621 void TemplateTable::fast_invokevfinal(int byte_no)
3622 {
3623   __ call_Unimplemented();
3624 }
3625 
3626 void TemplateTable::invokeinterface(int byte_no) {
3627   transition(vtos, vtos);
3628   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3629 
3630   prepare_invoke(byte_no, r0, rmethod,  // get f1 Klass*, f2 Method*
3631                  r2, r3); // recv, flags
3632 
3633   // r0: interface klass (from f1)
3634   // rmethod: method (from f2)
3635   // r2: receiver
3636   // r3: flags
3637 
3638   // First check for Object case, then private interface method,
3639   // then regular interface method.
3640 
3641   // Special case of invokeinterface called for virtual method of
3642   // java.lang.Object.  See cpCache.cpp for details.
3643   Label notObjectMethod;
3644   __ tbz(r3, ConstantPoolCacheEntry::is_forced_virtual_shift, notObjectMethod);
3645 
3646   invokevirtual_helper(rmethod, r2, r3);
3647   __ bind(notObjectMethod);
3648 
3649   Label no_such_interface;
3650 
3651   // Check for private method invocation - indicated by vfinal
3652   Label notVFinal;
3653   __ tbz(r3, ConstantPoolCacheEntry::is_vfinal_shift, notVFinal);
3654 
3655   // Get receiver klass into r3 - also a null check
3656   __ null_check(r2, oopDesc::klass_offset_in_bytes());
3657   __ load_klass(r3, r2);
3658 
3659   Label subtype;
3660   __ check_klass_subtype(r3, r0, r4, subtype);
3661   // If we get here the typecheck failed
3662   __ b(no_such_interface);
3663   __ bind(subtype);
3664 
3665   __ profile_final_call(r0);
3666   __ profile_arguments_type(r0, rmethod, r4, true);
3667   __ jump_from_interpreted(rmethod, r0);
3668 
3669   __ bind(notVFinal);
3670 
3671   // Get receiver klass into r3 - also a null check
3672   __ restore_locals();
3673   __ null_check(r2, oopDesc::klass_offset_in_bytes());
3674   __ load_klass(r3, r2);
3675 
3676   Label no_such_method;
3677 
3678   // Preserve method for throw_AbstractMethodErrorVerbose.
3679   __ mov(r16, rmethod);
3680   // Receiver subtype check against REFC.
3681   // Superklass in r0. Subklass in r3. Blows rscratch2, r13
3682   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3683                              r3, r0, noreg,
3684                              // outputs: scan temp. reg, scan temp. reg
3685                              rscratch2, r13,
3686                              no_such_interface,
3687                              /*return_method=*/false);
3688 
3689   // profile this call
3690   __ profile_virtual_call(r3, r13, r19);
3691 
3692   // Get declaring interface class from method, and itable index
3693 
3694   __ load_method_holder(r0, rmethod);
3695   __ ldrw(rmethod, Address(rmethod, Method::itable_index_offset()));
3696   __ subw(rmethod, rmethod, Method::itable_index_max);
3697   __ negw(rmethod, rmethod);
3698 
3699   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
3700   __ mov(rlocals, r3);
3701   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3702                              rlocals, r0, rmethod,
3703                              // outputs: method, scan temp. reg
3704                              rmethod, r13,
3705                              no_such_interface);
3706 
3707   // rmethod,: methodOop to call
3708   // r2: receiver
3709   // Check for abstract method error
3710   // Note: This should be done more efficiently via a throw_abstract_method_error
3711   //       interpreter entry point and a conditional jump to it in case of a null
3712   //       method.
3713   __ cbz(rmethod, no_such_method);
3714 
3715   __ profile_arguments_type(r3, rmethod, r13, true);
3716 
3717   // do the call
3718   // r2: receiver
3719   // rmethod,: methodOop
3720   __ jump_from_interpreted(rmethod, r3);
3721   __ should_not_reach_here();
3722 
3723   // exception handling code follows...
3724   // note: must restore interpreter registers to canonical
3725   //       state for exception handling to work correctly!
3726 
3727   __ bind(no_such_method);
3728   // throw exception
3729   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
3730   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3731   // Pass arguments for generating a verbose error message.
3732   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_AbstractMethodErrorVerbose), r3, r16);
3733   // the call_VM checks for exception, so we should never return here.
3734   __ should_not_reach_here();
3735 
3736   __ bind(no_such_interface);
3737   // throw exception
3738   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
3739   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3740   // Pass arguments for generating a verbose error message.
3741   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
3742                    InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose), r3, r0);
3743   // the call_VM checks for exception, so we should never return here.
3744   __ should_not_reach_here();
3745   return;
3746 }
3747 
3748 void TemplateTable::invokehandle(int byte_no) {
3749   transition(vtos, vtos);
3750   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3751 
3752   prepare_invoke(byte_no, rmethod, r0, r2);
3753   __ verify_method_ptr(r2);
3754   __ verify_oop(r2);
3755   __ null_check(r2);
3756 
3757   // FIXME: profile the LambdaForm also
3758 
3759   // r13 is safe to use here as a scratch reg because it is about to
3760   // be clobbered by jump_from_interpreted().
3761   __ profile_final_call(r13);
3762   __ profile_arguments_type(r13, rmethod, r4, true);
3763 
3764   __ jump_from_interpreted(rmethod, r0);
3765 }
3766 
3767 void TemplateTable::invokedynamic(int byte_no) {
3768   transition(vtos, vtos);
3769   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3770 
3771   prepare_invoke(byte_no, rmethod, r0);
3772 
3773   // r0: CallSite object (from cpool-&gt;resolved_references[])
3774   // rmethod: MH.linkToCallSite method (from f2)
3775 
3776   // Note:  r0_callsite is already pushed by prepare_invoke
3777 
3778   // %%% should make a type profile for any invokedynamic that takes a ref argument
3779   // profile this call
3780   __ profile_call(rbcp);
3781   __ profile_arguments_type(r3, rmethod, r13, false);
3782 
3783   __ verify_oop(r0);
3784 
3785   __ jump_from_interpreted(rmethod, r0);
3786 }
3787 
3788 
3789 //-----------------------------------------------------------------------------
3790 // Allocation
3791 
3792 void TemplateTable::_new() {
3793   transition(vtos, atos);
3794 
3795   __ get_unsigned_2_byte_index_at_bcp(r3, 1);
3796   Label slow_case;
3797   Label done;
3798   Label initialize_header;
3799   Label initialize_object; // including clearing the fields
3800 
3801   __ get_cpool_and_tags(r4, r0);
3802   // Make sure the class we&#39;re about to instantiate has been resolved.
3803   // This is done before loading InstanceKlass to be consistent with the order
3804   // how Constant Pool is updated (see ConstantPool::klass_at_put)
3805   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
3806   __ lea(rscratch1, Address(r0, r3, Address::lsl(0)));
3807   __ lea(rscratch1, Address(rscratch1, tags_offset));
3808   __ ldarb(rscratch1, rscratch1);
3809   __ cmp(rscratch1, (u1)JVM_CONSTANT_Class);
3810   __ br(Assembler::NE, slow_case);
3811 
3812   // get InstanceKlass
3813   __ load_resolved_klass_at_offset(r4, r3, r4, rscratch1);
3814 
3815   // make sure klass is initialized &amp; doesn&#39;t have finalizer
3816   // make sure klass is fully initialized
3817   __ ldrb(rscratch1, Address(r4, InstanceKlass::init_state_offset()));
3818   __ cmp(rscratch1, (u1)InstanceKlass::fully_initialized);
3819   __ br(Assembler::NE, slow_case);
3820 
3821   // get instance_size in InstanceKlass (scaled to a count of bytes)
3822   __ ldrw(r3,
3823           Address(r4,
3824                   Klass::layout_helper_offset()));
3825   // test to see if it has a finalizer or is malformed in some way
3826   __ tbnz(r3, exact_log2(Klass::_lh_instance_slow_path_bit), slow_case);
3827 
3828   // Allocate the instance:
3829   //  If TLAB is enabled:
3830   //    Try to allocate in the TLAB.
3831   //    If fails, go to the slow path.
3832   //  Else If inline contiguous allocations are enabled:
3833   //    Try to allocate in eden.
3834   //    If fails due to heap end, go to slow path.
3835   //
3836   //  If TLAB is enabled OR inline contiguous is enabled:
3837   //    Initialize the allocation.
3838   //    Exit.
3839   //
3840   //  Go to slow path.
3841   const bool allow_shared_alloc =
3842     Universe::heap()-&gt;supports_inline_contig_alloc();
3843 
3844   if (UseTLAB) {
3845     __ tlab_allocate(r0, r3, 0, noreg, r1, slow_case);
3846 
3847     if (ZeroTLAB) {
3848       // the fields have been already cleared
3849       __ b(initialize_header);
3850     } else {
3851       // initialize both the header and fields
3852       __ b(initialize_object);
3853     }
3854   } else {
3855     // Allocation in the shared Eden, if allowed.
3856     //
3857     // r3: instance size in bytes
3858     if (allow_shared_alloc) {
3859       __ eden_allocate(r0, r3, 0, r10, slow_case);
3860     }
3861   }
3862 
3863   // If UseTLAB or allow_shared_alloc are true, the object is created above and
3864   // there is an initialize need. Otherwise, skip and go to the slow path.
3865   if (UseTLAB || allow_shared_alloc) {
3866     // The object is initialized before the header.  If the object size is
3867     // zero, go directly to the header initialization.
3868     __ bind(initialize_object);
3869     __ sub(r3, r3, sizeof(oopDesc));
3870     __ cbz(r3, initialize_header);
3871 
3872     // Initialize object fields
3873     {
3874       __ add(r2, r0, sizeof(oopDesc));
3875       Label loop;
3876       __ bind(loop);
3877       __ str(zr, Address(__ post(r2, BytesPerLong)));
3878       __ sub(r3, r3, BytesPerLong);
3879       __ cbnz(r3, loop);
3880     }
3881 
3882     // initialize object header only.
3883     __ bind(initialize_header);
3884     if (UseBiasedLocking) {
3885       __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));
3886     } else {
3887       __ mov(rscratch1, (intptr_t)markWord::prototype().value());
3888     }
3889     __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));
3890     __ store_klass_gap(r0, zr);  // zero klass gap for compressed oops
3891     __ store_klass(r0, r4);      // store klass last
3892 
3893     {
3894       SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false);
3895       // Trigger dtrace event for fastpath
3896       __ push(atos); // save the return value
3897       __ call_VM_leaf(
3898            CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), r0);
3899       __ pop(atos); // restore the return value
3900 
3901     }
3902     __ b(done);
3903   }
3904 
3905   // slow case
3906   __ bind(slow_case);
3907   __ get_constant_pool(c_rarg1);
3908   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3909   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);
3910   __ verify_oop(r0);
3911 
3912   // continue
3913   __ bind(done);
3914   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3915   __ membar(Assembler::StoreStore);
3916 }
3917 
3918 void TemplateTable::defaultvalue() {
3919   transition(vtos, atos);
3920   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3921   __ get_constant_pool(c_rarg1);
3922   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::defaultvalue),
3923           c_rarg1, c_rarg2);
3924   __ verify_oop(r0);
3925   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3926   __ membar(Assembler::StoreStore);
3927 }
3928 
3929 void TemplateTable::withfield() {
3930   transition(vtos, atos);
3931   resolve_cache_and_index(f2_byte, c_rarg1 /*cache*/, c_rarg2 /*index*/, sizeof(u2));
3932 
3933   // n.b. unlike x86 cache is now rcpool plus the indexed offset
3934   // so using rcpool to meet shared code expectations
3935 
3936   call_VM(r1, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), rcpool);
3937   __ verify_oop(r1);
3938   __ add(esp, esp, r0);
3939   __ mov(r0, r1);
3940 }
3941 
3942 void TemplateTable::newarray() {
3943   transition(itos, atos);
3944   __ load_unsigned_byte(c_rarg1, at_bcp(1));
3945   __ mov(c_rarg2, r0);
3946   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
3947           c_rarg1, c_rarg2);
3948   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3949   __ membar(Assembler::StoreStore);
3950 }
3951 
3952 void TemplateTable::anewarray() {
3953   transition(itos, atos);
3954   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3955   __ get_constant_pool(c_rarg1);
3956   __ mov(c_rarg3, r0);
3957   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
3958           c_rarg1, c_rarg2, c_rarg3);
3959   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3960   __ membar(Assembler::StoreStore);
3961 }
3962 
3963 void TemplateTable::arraylength() {
3964   transition(atos, itos);
3965   __ null_check(r0, arrayOopDesc::length_offset_in_bytes());
3966   __ ldrw(r0, Address(r0, arrayOopDesc::length_offset_in_bytes()));
3967 }
3968 
3969 void TemplateTable::checkcast()
3970 {
3971   transition(atos, atos);
3972   Label done, is_null, ok_is_subtype, quicked, resolved;
3973   __ cbz(r0, is_null);
3974 
3975   // Get cpool &amp; tags index
3976   __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
3977   __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
3978   // See if bytecode has already been quicked
3979   __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
3980   __ lea(r1, Address(rscratch1, r19));
3981   __ ldarb(r1, r1);
3982   __ cmp(r1, (u1)JVM_CONSTANT_Class);
3983   __ br(Assembler::EQ, quicked);
3984 
3985   __ push(atos); // save receiver for result, and for GC
3986   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3987   // vm_result_2 has metadata result
3988   __ get_vm_result_2(r0, rthread);
3989   __ pop(r3); // restore receiver
3990   __ b(resolved);
3991 
3992   // Get superklass in r0 and subklass in r3
3993   __ bind(quicked);
3994   __ mov(r3, r0); // Save object in r3; r0 needed for subtype check
3995   __ load_resolved_klass_at_offset(r2, r19, r0, rscratch1); // r0 = klass
3996 
3997   __ bind(resolved);
3998   __ load_klass(r19, r3);
3999 
4000   // Generate subtype check.  Blows r2, r5.  Object in r3.
4001   // Superklass in r0.  Subklass in r19.
4002   __ gen_subtype_check(r19, ok_is_subtype);
4003 
4004   // Come here on failure
4005   __ push(r3);
4006   // object is at TOS
4007   __ b(Interpreter::_throw_ClassCastException_entry);
4008 
4009   // Come here on success
4010   __ bind(ok_is_subtype);
4011   __ mov(r0, r3); // Restore object in r3
4012 
4013   __ b(done);
4014   __ bind(is_null);
4015 
4016   // Collect counts on whether this test sees NULLs a lot or not.
4017   if (ProfileInterpreter) {
4018     __ profile_null_seen(r2);
4019   }
4020 
4021   if (EnableValhalla) {
4022     // Get cpool &amp; tags index
4023     __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
4024     __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
4025      // See if bytecode has already been quicked
4026     __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
4027     __ lea(r1, Address(rscratch1, r19));
4028     __ ldarb(r1, r1);
4029     // See if CP entry is a Q-descriptor
4030     __ andr (r1, r1, JVM_CONSTANT_QDescBit);
4031     __ cmp(r1, (u1) JVM_CONSTANT_QDescBit);
4032     __ br(Assembler::NE, done);
4033     __ b(ExternalAddress(Interpreter::_throw_NullPointerException_entry));
4034   }
4035 
4036   __ bind(done);
4037 }
4038 
4039 void TemplateTable::instanceof() {
4040   transition(atos, itos);
4041   Label done, is_null, ok_is_subtype, quicked, resolved;
4042   __ cbz(r0, is_null);
4043 
4044   // Get cpool &amp; tags index
4045   __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
4046   __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
4047   // See if bytecode has already been quicked
4048   __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
4049   __ lea(r1, Address(rscratch1, r19));
4050   __ ldarb(r1, r1);
4051   __ cmp(r1, (u1)JVM_CONSTANT_Class);
4052   __ br(Assembler::EQ, quicked);
4053 
4054   __ push(atos); // save receiver for result, and for GC
4055   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4056   // vm_result_2 has metadata result
4057   __ get_vm_result_2(r0, rthread);
4058   __ pop(r3); // restore receiver
4059   __ verify_oop(r3);
4060   __ load_klass(r3, r3);
4061   __ b(resolved);
4062 
4063   // Get superklass in r0 and subklass in r3
4064   __ bind(quicked);
4065   __ load_klass(r3, r0);
4066   __ load_resolved_klass_at_offset(r2, r19, r0, rscratch1);
4067 
4068   __ bind(resolved);
4069 
4070   // Generate subtype check.  Blows r2, r5
4071   // Superklass in r0.  Subklass in r3.
4072   __ gen_subtype_check(r3, ok_is_subtype);
4073 
4074   // Come here on failure
4075   __ mov(r0, 0);
4076   __ b(done);
4077   // Come here on success
4078   __ bind(ok_is_subtype);
4079   __ mov(r0, 1);
4080 
4081   // Collect counts on whether this test sees NULLs a lot or not.
4082   if (ProfileInterpreter) {
4083     __ b(done);
4084     __ bind(is_null);
4085     __ profile_null_seen(r2);
4086   } else {
4087     __ bind(is_null);   // same as &#39;done&#39;
4088   }
4089   __ bind(done);
4090   // r0 = 0: obj == NULL or  obj is not an instanceof the specified klass
4091   // r0 = 1: obj != NULL and obj is     an instanceof the specified klass
4092 }
4093 
4094 //-----------------------------------------------------------------------------
4095 // Breakpoints
4096 void TemplateTable::_breakpoint() {
4097   // Note: We get here even if we are single stepping..
4098   // jbug inists on setting breakpoints at every bytecode
4099   // even if we are in single step mode.
4100 
4101   transition(vtos, vtos);
4102 
4103   // get the unpatched byte code
4104   __ get_method(c_rarg1);
4105   __ call_VM(noreg,
4106              CAST_FROM_FN_PTR(address,
4107                               InterpreterRuntime::get_original_bytecode_at),
4108              c_rarg1, rbcp);
4109   __ mov(r19, r0);
4110 
4111   // post the breakpoint event
4112   __ call_VM(noreg,
4113              CAST_FROM_FN_PTR(address, InterpreterRuntime::_breakpoint),
4114              rmethod, rbcp);
4115 
4116   // complete the execution of original bytecode
4117   __ mov(rscratch1, r19);
4118   __ dispatch_only_normal(vtos);
4119 }
4120 
4121 //-----------------------------------------------------------------------------
4122 // Exceptions
4123 
4124 void TemplateTable::athrow() {
4125   transition(atos, vtos);
4126   __ null_check(r0);
4127   __ b(Interpreter::throw_exception_entry());
4128 }
4129 
4130 //-----------------------------------------------------------------------------
4131 // Synchronization
4132 //
4133 // Note: monitorenter &amp; exit are symmetric routines; which is reflected
4134 //       in the assembly code structure as well
4135 //
4136 // Stack layout:
4137 //
4138 // [expressions  ] &lt;--- esp               = expression stack top
4139 // ..
4140 // [expressions  ]
4141 // [monitor entry] &lt;--- monitor block top = expression stack bot
4142 // ..
4143 // [monitor entry]
4144 // [frame data   ] &lt;--- monitor block bot
4145 // ...
4146 // [saved rbp    ] &lt;--- rbp
4147 void TemplateTable::monitorenter()
4148 {
4149   transition(atos, vtos);
4150 
4151   // check for NULL object
4152   __ null_check(r0);
4153 
4154   __ resolve(IS_NOT_NULL, r0);
4155 
4156   const Address monitor_block_top(
4157         rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4158   const Address monitor_block_bot(
4159         rfp, frame::interpreter_frame_initial_sp_offset * wordSize);
4160   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4161 
4162   Label allocated;
4163 
4164   // initialize entry pointer
4165   __ mov(c_rarg1, zr); // points to free slot or NULL
4166 
4167   // find a free slot in the monitor block (result in c_rarg1)
4168   {
4169     Label entry, loop, exit;
4170     __ ldr(c_rarg3, monitor_block_top); // points to current entry,
4171                                         // starting with top-most entry
4172     __ lea(c_rarg2, monitor_block_bot); // points to word before bottom
4173 
4174     __ b(entry);
4175 
4176     __ bind(loop);
4177     // check if current entry is used
4178     // if not used then remember entry in c_rarg1
4179     __ ldr(rscratch1, Address(c_rarg3, BasicObjectLock::obj_offset_in_bytes()));
4180     __ cmp(zr, rscratch1);
4181     __ csel(c_rarg1, c_rarg3, c_rarg1, Assembler::EQ);
4182     // check if current entry is for same object
4183     __ cmp(r0, rscratch1);
4184     // if same object then stop searching
4185     __ br(Assembler::EQ, exit);
4186     // otherwise advance to next entry
4187     __ add(c_rarg3, c_rarg3, entry_size);
4188     __ bind(entry);
4189     // check if bottom reached
4190     __ cmp(c_rarg3, c_rarg2);
4191     // if not at bottom then check this entry
4192     __ br(Assembler::NE, loop);
4193     __ bind(exit);
4194   }
4195 
4196   __ cbnz(c_rarg1, allocated); // check if a slot has been found and
4197                             // if found, continue with that on
4198 
4199   // allocate one if there&#39;s no free slot
4200   {
4201     Label entry, loop;
4202     // 1. compute new pointers            // rsp: old expression stack top
4203     __ ldr(c_rarg1, monitor_block_bot);   // c_rarg1: old expression stack bottom
4204     __ sub(esp, esp, entry_size);         // move expression stack top
4205     __ sub(c_rarg1, c_rarg1, entry_size); // move expression stack bottom
4206     __ mov(c_rarg3, esp);                 // set start value for copy loop
4207     __ str(c_rarg1, monitor_block_bot);   // set new monitor block bottom
4208 
4209     __ sub(sp, sp, entry_size);           // make room for the monitor
4210 
4211     __ b(entry);
4212     // 2. move expression stack contents
4213     __ bind(loop);
4214     __ ldr(c_rarg2, Address(c_rarg3, entry_size)); // load expression stack
4215                                                    // word from old location
4216     __ str(c_rarg2, Address(c_rarg3, 0));          // and store it at new location
4217     __ add(c_rarg3, c_rarg3, wordSize);            // advance to next word
4218     __ bind(entry);
4219     __ cmp(c_rarg3, c_rarg1);        // check if bottom reached
4220     __ br(Assembler::NE, loop);      // if not at bottom then
4221                                      // copy next word
4222   }
4223 
4224   // call run-time routine
4225   // c_rarg1: points to monitor entry
4226   __ bind(allocated);
4227 
4228   // Increment bcp to point to the next bytecode, so exception
4229   // handling for async. exceptions work correctly.
4230   // The object has already been poped from the stack, so the
4231   // expression stack looks correct.
4232   __ increment(rbcp);
4233 
4234   // store object
4235   __ str(r0, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));
4236   __ lock_object(c_rarg1);
4237 
4238   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
4239   __ save_bcp();  // in case of exception
4240   __ generate_stack_overflow_check(0);
4241 
4242   // The bcp has already been incremented. Just need to dispatch to
4243   // next instruction.
4244   __ dispatch_next(vtos);
4245 }
4246 
4247 
4248 void TemplateTable::monitorexit()
4249 {
4250   transition(atos, vtos);
4251 
4252   // check for NULL object
4253   __ null_check(r0);
4254 
4255   __ resolve(IS_NOT_NULL, r0);
4256 
4257   const Address monitor_block_top(
4258         rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4259   const Address monitor_block_bot(
4260         rfp, frame::interpreter_frame_initial_sp_offset * wordSize);
4261   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4262 
4263   Label found;
4264 
4265   // find matching slot
4266   {
4267     Label entry, loop;
4268     __ ldr(c_rarg1, monitor_block_top); // points to current entry,
4269                                         // starting with top-most entry
4270     __ lea(c_rarg2, monitor_block_bot); // points to word before bottom
4271                                         // of monitor block
4272     __ b(entry);
4273 
4274     __ bind(loop);
4275     // check if current entry is for same object
4276     __ ldr(rscratch1, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));
4277     __ cmp(r0, rscratch1);
4278     // if same object then stop searching
4279     __ br(Assembler::EQ, found);
4280     // otherwise advance to next entry
4281     __ add(c_rarg1, c_rarg1, entry_size);
4282     __ bind(entry);
4283     // check if bottom reached
4284     __ cmp(c_rarg1, c_rarg2);
4285     // if not at bottom then check this entry
4286     __ br(Assembler::NE, loop);
4287   }
4288 
4289   // error handling. Unlocking was not block-structured
4290   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
4291                    InterpreterRuntime::throw_illegal_monitor_state_exception));
4292   __ should_not_reach_here();
4293 
4294   // call run-time routine
4295   __ bind(found);
4296   __ push_ptr(r0); // make sure object is on stack (contract with oopMaps)
4297   __ unlock_object(c_rarg1);
4298   __ pop_ptr(r0); // discard object
4299 }
4300 
4301 
4302 // Wide instructions
4303 void TemplateTable::wide()
4304 {
4305   __ load_unsigned_byte(r19, at_bcp(1));
4306   __ mov(rscratch1, (address)Interpreter::_wentry_point);
4307   __ ldr(rscratch1, Address(rscratch1, r19, Address::uxtw(3)));
4308   __ br(rscratch1);
4309 }
4310 
4311 
4312 // Multi arrays
4313 void TemplateTable::multianewarray() {
4314   transition(vtos, atos);
4315   __ load_unsigned_byte(r0, at_bcp(3)); // get number of dimensions
4316   // last dim is on top of stack; we want address of first one:
4317   // first_addr = last_addr + (ndims - 1) * wordSize
4318   __ lea(c_rarg1, Address(esp, r0, Address::uxtw(3)));
4319   __ sub(c_rarg1, c_rarg1, wordSize);
4320   call_VM(r0,
4321           CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray),
4322           c_rarg1);
4323   __ load_unsigned_byte(r1, at_bcp(3));
4324   __ lea(esp, Address(esp, r1, Address::uxtw(3)));
4325 }
    </pre>
  </body>
</html>