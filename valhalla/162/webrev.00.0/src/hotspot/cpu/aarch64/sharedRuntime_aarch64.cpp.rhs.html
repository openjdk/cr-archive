<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;classfile/symbolTable.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  30 #include &quot;code/codeCache.hpp&quot;</span>
  31 #include &quot;code/debugInfoRec.hpp&quot;
  32 #include &quot;code/icBuffer.hpp&quot;
  33 #include &quot;code/vtableStubs.hpp&quot;
  34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  35 #include &quot;interpreter/interpreter.hpp&quot;
  36 #include &quot;interpreter/interp_masm.hpp&quot;
  37 #include &quot;logging/log.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;nativeInst_aarch64.hpp&quot;
  40 #include &quot;oops/compiledICHolder.hpp&quot;
  41 #include &quot;oops/klass.inline.hpp&quot;
  42 #include &quot;runtime/safepointMechanism.hpp&quot;
  43 #include &quot;runtime/sharedRuntime.hpp&quot;
  44 #include &quot;runtime/vframeArray.hpp&quot;
  45 #include &quot;utilities/align.hpp&quot;
  46 #include &quot;vmreg_aarch64.inline.hpp&quot;
  47 #ifdef COMPILER1
  48 #include &quot;c1/c1_Runtime1.hpp&quot;
  49 #endif
  50 #ifdef COMPILER2
  51 #include &quot;adfiles/ad_aarch64.hpp&quot;
  52 #include &quot;opto/runtime.hpp&quot;
  53 #endif
  54 #if INCLUDE_JVMCI
  55 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  56 #endif
  57 
  58 #define __ masm-&gt;
  59 
  60 const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  61 
  62 class SimpleRuntimeFrame {
  63 
  64   public:
  65 
  66   // Most of the runtime stubs have this simple frame layout.
  67   // This class exists to make the layout shared in one place.
  68   // Offsets are for compiler stack slots, which are jints.
  69   enum layout {
  70     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
  71     // will override any oopMap setting for it. We must therefore force the layout
  72     // so that it agrees with the frame sender code.
  73     // we don&#39;t expect any arg reg save area so aarch64 asserts that
  74     // frame::arg_reg_save_area_bytes == 0
  75     rbp_off = 0,
  76     rbp_off2,
  77     return_off, return_off2,
  78     framesize
  79   };
  80 };
  81 
  82 // FIXME -- this is used by C1
  83 class RegisterSaver {
  84  public:
  85   static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors = false);
  86   static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);
  87 
  88   // Offsets into the register save area
  89   // Used by deoptimization when it is managing result register
  90   // values on its own
  91 
  92   static int r0_offset_in_bytes(void)    { return (32 + r0-&gt;encoding()) * wordSize; }
  93   static int reg_offset_in_bytes(Register r)    { return r0_offset_in_bytes() + r-&gt;encoding() * wordSize; }
  94   static int rmethod_offset_in_bytes(void)    { return reg_offset_in_bytes(rmethod); }
  95   static int rscratch1_offset_in_bytes(void)    { return (32 + rscratch1-&gt;encoding()) * wordSize; }
  96   static int v0_offset_in_bytes(void)   { return 0; }
  97   static int return_offset_in_bytes(void) { return (32 /* floats*/ + 31 /* gregs*/) * wordSize; }
  98 
  99   // During deoptimization only the result registers need to be restored,
 100   // all the other values have already been extracted.
 101   static void restore_result_registers(MacroAssembler* masm);
 102 
 103     // Capture info about frame layout
 104   enum layout {
 105                 fpu_state_off = 0,
 106                 fpu_state_end = fpu_state_off + FPUStateSizeInWords - 1,
 107                 // The frame sender code expects that rfp will be in
 108                 // the &quot;natural&quot; place and will override any oopMap
 109                 // setting for it. We must therefore force the layout
 110                 // so that it agrees with the frame sender code.
 111                 r0_off = fpu_state_off + FPUStateSizeInWords,
 112                 rfp_off = r0_off + (RegisterImpl::number_of_registers - 2) * RegisterImpl::max_slots_per_register,
 113                 return_off = rfp_off + RegisterImpl::max_slots_per_register,      // slot for return address
 114                 reg_save_size = return_off + RegisterImpl::max_slots_per_register};
 115 
 116 };
 117 
 118 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {
 119 #if COMPILER2_OR_JVMCI
 120   if (save_vectors) {
 121     // Save upper half of vector registers
 122     int vect_words = FloatRegisterImpl::number_of_registers * FloatRegisterImpl::extra_save_slots_per_register /
 123                      VMRegImpl::slots_per_word;
 124     additional_frame_words += vect_words;
 125   }
 126 #else
 127   assert(!save_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 128 #endif
 129 
 130   int frame_size_in_bytes = align_up(additional_frame_words * wordSize +
 131                                      reg_save_size * BytesPerInt, 16);
 132   // OopMap frame size is in compiler stack slots (jint&#39;s) not bytes or words
 133   int frame_size_in_slots = frame_size_in_bytes / BytesPerInt;
 134   // The caller will allocate additional_frame_words
 135   int additional_frame_slots = additional_frame_words * wordSize / BytesPerInt;
 136   // CodeBlob frame size is in words.
 137   int frame_size_in_words = frame_size_in_bytes / wordSize;
 138   *total_frame_words = frame_size_in_words;
 139 
 140   // Save Integer and Float registers.
 141   __ enter();
 142   __ push_CPU_state(save_vectors);
 143 
 144   // Set an oopmap for the call site.  This oopmap will map all
 145   // oop-registers and debug-info registers as callee-saved.  This
 146   // will allow deoptimization at this safepoint to find all possible
 147   // debug-info recordings, as well as let GC find all oops.
 148 
 149   OopMapSet *oop_maps = new OopMapSet();
 150   OopMap* oop_map = new OopMap(frame_size_in_slots, 0);
 151 
 152   for (int i = 0; i &lt; RegisterImpl::number_of_registers; i++) {
 153     Register r = as_Register(i);
 154     if (r &lt;= rfp &amp;&amp; r != rscratch1 &amp;&amp; r != rscratch2) {
 155       // SP offsets are in 4-byte words.
 156       // Register slots are 8 bytes wide, 32 floating-point registers.
 157       int sp_offset = RegisterImpl::max_slots_per_register * i +
 158                       FloatRegisterImpl::save_slots_per_register * FloatRegisterImpl::number_of_registers;
 159       oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset + additional_frame_slots),
 160                                 r-&gt;as_VMReg());
 161     }
 162   }
 163 
 164   for (int i = 0; i &lt; FloatRegisterImpl::number_of_registers; i++) {
 165     FloatRegister r = as_FloatRegister(i);
 166     int sp_offset = save_vectors ? (FloatRegisterImpl::max_slots_per_register * i) :
 167                                    (FloatRegisterImpl::save_slots_per_register * i);
 168     oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
 169                               r-&gt;as_VMReg());
 170   }
 171 
 172   return oop_map;
 173 }
 174 
 175 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {
 176 #if !COMPILER2_OR_JVMCI
 177   assert(!restore_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 178 #endif
 179   __ pop_CPU_state(restore_vectors);
 180   __ leave();
 181 
 182 }
 183 
 184 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 185 
 186   // Just restore result register. Only used by deoptimization. By
 187   // now any callee save register that needs to be restored to a c2
 188   // caller of the deoptee has been extracted into the vframeArray
 189   // and will be stuffed into the c2i adapter we create for later
 190   // restoration so only result registers need to be restored here.
 191 
 192   // Restore fp result register
 193   __ ldrd(v0, Address(sp, v0_offset_in_bytes()));
 194   // Restore integer result register
 195   __ ldr(r0, Address(sp, r0_offset_in_bytes()));
 196 
 197   // Pop all of the register save are off the stack
 198   __ add(sp, sp, align_up(return_offset_in_bytes(), 16));
 199 }
 200 
 201 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
 202 // 8 bytes vector registers are saved by default on AArch64.
 203 bool SharedRuntime::is_wide_vector(int size) {
 204   return size &gt; 8;
 205 }
 206 
 207 size_t SharedRuntime::trampoline_size() {
 208   return 16;
 209 }
 210 
 211 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 212   __ mov(rscratch1, destination);
 213   __ br(rscratch1);
 214 }
 215 
 216 // The java_calling_convention describes stack locations as ideal slots on
 217 // a frame with no abi restrictions. Since we must observe abi restrictions
 218 // (like the placement of the register window) the slots must be biased by
 219 // the following value.
 220 static int reg2offset_in(VMReg r) {
 221   // Account for saved rfp and lr
 222   // This should really be in_preserve_stack_slots
 223   return (r-&gt;reg2stack() + 4) * VMRegImpl::stack_slot_size;
 224 }
 225 
 226 static int reg2offset_out(VMReg r) {
 227   return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 228 }
 229 
 230 // ---------------------------------------------------------------------------
 231 // Read the array of BasicTypes from a signature, and compute where the
 232 // arguments should go.  Values in the VMRegPair regs array refer to 4-byte
 233 // quantities.  Values less than VMRegImpl::stack0 are registers, those above
 234 // refer to 4-byte stack slots.  All stack slots are based off of the stack pointer
 235 // as framesizes are fixed.
 236 // VMRegImpl::stack0 refers to the first slot 0(sp).
 237 // and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register
 238 // up to RegisterImpl::number_of_registers) are the 64-bit
 239 // integer registers.
 240 
 241 // Note: the INPUTS in sig_bt are in units of Java argument words,
 242 // which are 64-bit.  The OUTPUTS are in 32-bit units.
 243 
 244 // The Java calling convention is a &quot;shifted&quot; version of the C ABI.
 245 // By skipping the first C ABI register we can call non-static jni
 246 // methods with small numbers of arguments without having to shuffle
 247 // the arguments at all. Since we control the java ABI we ought to at
 248 // least get some advantage out of it.
 249 
 250 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 251                                            VMRegPair *regs,
 252                                            int total_args_passed,
 253                                            int is_outgoing) {
 254 
 255   // Create the mapping between argument positions and
 256   // registers.
 257   static const Register INT_ArgReg[Argument::n_int_register_parameters_j] = {
 258     j_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4, j_rarg5, j_rarg6, j_rarg7
 259   };
 260   static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_j] = {
 261     j_farg0, j_farg1, j_farg2, j_farg3,
 262     j_farg4, j_farg5, j_farg6, j_farg7
 263   };
 264 
 265 
 266   uint int_args = 0;
 267   uint fp_args = 0;
 268   uint stk_args = 0; // inc by 2 each time
 269 
 270   for (int i = 0; i &lt; total_args_passed; i++) {
 271     switch (sig_bt[i]) {
 272     case T_BOOLEAN:
 273     case T_CHAR:
 274     case T_BYTE:
 275     case T_SHORT:
 276     case T_INT:
 277       if (int_args &lt; Argument::n_int_register_parameters_j) {
 278         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 279       } else {
 280         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 281         stk_args += 2;
 282       }
 283       break;
 284     case T_VOID:
 285       // halves of T_LONG or T_DOUBLE
 286       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 287       regs[i].set_bad();
 288       break;
 289     case T_LONG:
 290       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 291       // fall through
 292     case T_OBJECT:
 293     case T_ARRAY:
 294     case T_ADDRESS:
 295     case T_INLINE_TYPE:
 296       if (int_args &lt; Argument::n_int_register_parameters_j) {
 297         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 298       } else {
 299         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 300         stk_args += 2;
 301       }
 302       break;
 303     case T_FLOAT:
 304       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 305         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 306       } else {
 307         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 308         stk_args += 2;
 309       }
 310       break;
 311     case T_DOUBLE:
 312       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 313       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 314         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 315       } else {
 316         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 317         stk_args += 2;
 318       }
 319       break;
 320     default:
 321       ShouldNotReachHere();
 322       break;
 323     }
 324   }
 325 
 326   return align_up(stk_args, 2);
 327 }
 328 
 329 
 330 // const uint SharedRuntime::java_return_convention_max_int = Argument::n_int_register_parameters_j+1;
 331 const uint SharedRuntime::java_return_convention_max_int = 6;
 332 const uint SharedRuntime::java_return_convention_max_float = Argument::n_float_register_parameters_j;
 333 
 334 int SharedRuntime::java_return_convention(const BasicType *sig_bt, VMRegPair *regs, int total_args_passed) {
 335 
 336   // Create the mapping between argument positions and
 337   // registers.
 338   // r1, r2 used to address klasses and states, exclude it from return convention to avoid colision
 339 
 340   static const Register INT_ArgReg[java_return_convention_max_int] = {
 341      r0 /* j_rarg7 */, j_rarg6, j_rarg5, j_rarg4, j_rarg3, j_rarg2
 342   };
 343 
 344   static const FloatRegister FP_ArgReg[java_return_convention_max_float] = {
 345     j_farg0, j_farg1, j_farg2, j_farg3, j_farg4, j_farg5, j_farg6, j_farg7
 346   };
 347 
 348   uint int_args = 0;
 349   uint fp_args = 0;
 350 
 351   for (int i = 0; i &lt; total_args_passed; i++) {
 352     switch (sig_bt[i]) {
 353     case T_BOOLEAN:
 354     case T_CHAR:
 355     case T_BYTE:
 356     case T_SHORT:
 357     case T_INT:
 358       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {
 359         regs[i].set1(INT_ArgReg[int_args]-&gt;as_VMReg());
 360         int_args ++;
 361       } else {
 362         // Should we have gurantee here?
 363         return -1;
 364       }
 365       break;
 366     case T_VOID:
 367       // halves of T_LONG or T_DOUBLE
 368       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 369       regs[i].set_bad();
 370       break;
 371     case T_LONG:
 372       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 373       // fall through
 374     case T_OBJECT:
 375     case T_ARRAY:
 376     case T_ADDRESS:
 377       // Should T_METADATA be added to java_calling_convention as well ?
 378     case T_METADATA:
 379     case T_INLINE_TYPE:
 380       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {
 381         regs[i].set2(INT_ArgReg[int_args]-&gt;as_VMReg());
 382         int_args ++;
 383       } else {
 384         return -1;
 385       }
 386       break;
 387     case T_FLOAT:
 388       if (fp_args &lt; SharedRuntime::java_return_convention_max_float) {
 389         regs[i].set1(FP_ArgReg[fp_args]-&gt;as_VMReg());
 390         fp_args ++;
 391       } else {
 392         return -1;
 393       }
 394       break;
 395     case T_DOUBLE:
 396       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 397       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 398         regs[i].set2(FP_ArgReg[fp_args]-&gt;as_VMReg());
 399         fp_args ++;
 400       } else {
 401         return -1;
 402       }
 403       break;
 404     default:
 405       ShouldNotReachHere();
 406       break;
 407     }
 408   }
 409 
 410   return int_args + fp_args;
 411 }
 412 
 413 // Patch the callers callsite with entry to compiled code if it exists.
 414 static void patch_callers_callsite(MacroAssembler *masm) {
 415   Label L;
 416   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 417   __ cbz(rscratch1, L);
 418 
 419   __ enter();
 420   __ push_CPU_state();
 421 
 422   // VM needs caller&#39;s callsite
 423   // VM needs target method
 424   // This needs to be a long call since we will relocate this adapter to
 425   // the codeBuffer and it may not reach
 426 
 427 #ifndef PRODUCT
 428   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 429 #endif
 430 
 431   __ mov(c_rarg0, rmethod);
 432   __ mov(c_rarg1, lr);
 433   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 434   __ blr(rscratch1);
 435   __ maybe_isb();
 436 
 437   __ pop_CPU_state();
 438   // restore sp
 439   __ leave();
 440   __ bind(L);
 441 }
 442 
 443 // For each inline type argument, sig includes the list of fields of
 444 // the inline type. This utility function computes the number of
 445 // arguments for the call if inline types are passed by reference (the
 446 // calling convention the interpreter expects).
 447 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {
 448   int total_args_passed = 0;
 449   if (InlineTypePassFieldsAsArgs) {
 450      for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {
 451        BasicType bt = sig_extended-&gt;at(i)._bt;
 452        if (SigEntry::is_reserved_entry(sig_extended, i)) {
 453          // Ignore reserved entry
 454        } else if (bt == T_INLINE_TYPE) {
 455          // In sig_extended, an inline type argument starts with:
 456          // T_INLINE_TYPE, followed by the types of the fields of the
 457          // inline type and T_VOID to mark the end of the value
 458          // type. Inline types are flattened so, for instance, in the
 459          // case of an inline type with an int field and an inline type
 460          // field that itself has 2 fields, an int and a long:
 461          // T_INLINE_TYPE T_INT T_INLINE_TYPE T_INT T_LONG T_VOID (second
 462          // slot for the T_LONG) T_VOID (inner T_INLINE_TYPE) T_VOID
 463          // (outer T_INLINE_TYPE)
 464          total_args_passed++;
 465          int vt = 1;
 466          do {
 467            i++;
 468            BasicType bt = sig_extended-&gt;at(i)._bt;
 469            BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;
 470            if (bt == T_INLINE_TYPE) {
 471              vt++;
 472            } else if (bt == T_VOID &amp;&amp;
 473                       prev_bt != T_LONG &amp;&amp;
 474                       prev_bt != T_DOUBLE) {
 475              vt--;
 476            }
 477          } while (vt != 0);
 478        } else {
 479          total_args_passed++;
 480        }
 481      }
 482   } else {
 483     total_args_passed = sig_extended-&gt;length();
 484   }
 485 
 486   return total_args_passed;
 487 }
 488 
 489 
 490 static void gen_c2i_adapter_helper(MacroAssembler* masm, BasicType bt, const VMRegPair&amp; reg_pair, int extraspace, const Address&amp; to) {
 491 
 492     assert(bt != T_INLINE_TYPE || !InlineTypePassFieldsAsArgs, &quot;no inline type here&quot;);
 493 
 494     // Say 4 args:
 495     // i   st_off
 496     // 0   32 T_LONG
 497     // 1   24 T_VOID
 498     // 2   16 T_OBJECT
 499     // 3    8 T_BOOL
 500     // -    0 return address
 501     //
 502     // However to make thing extra confusing. Because we can fit a long/double in
 503     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 504     // leaves one slot empty and only stores to a single slot. In this case the
 505     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 506 
 507     // int next_off = st_off - Interpreter::stackElementSize;
 508 
 509     VMReg r_1 = reg_pair.first();
 510     VMReg r_2 = reg_pair.second();
 511 
 512     if (!r_1-&gt;is_valid()) {
 513       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 514       return;
 515     }
 516 
 517     if (r_1-&gt;is_stack()) {
 518       // memory to memory use rscratch1
 519       // words_pushed is always 0 so we don&#39;t use it.
 520       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extraspace /* + word_pushed * wordSize */);
 521       if (!r_2-&gt;is_valid()) {
 522         // sign extend??
 523         __ ldrw(rscratch1, Address(sp, ld_off));
 524         __ str(rscratch1, to);
 525 
 526       } else {
 527         __ ldr(rscratch1, Address(sp, ld_off));
 528         __ str(rscratch1, to);
 529       }
 530     } else if (r_1-&gt;is_Register()) {
 531       Register r = r_1-&gt;as_Register();
 532       __ str(r, to);
 533     } else {
 534       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 535       if (!r_2-&gt;is_valid()) {
 536         // only a float use just part of the slot
 537         __ strs(r_1-&gt;as_FloatRegister(), to);
 538       } else {
 539         __ strd(r_1-&gt;as_FloatRegister(), to);
 540       }
 541    }
 542 }
 543 
 544 static void gen_c2i_adapter(MacroAssembler *masm,
 545                             const GrowableArray&lt;SigEntry&gt;* sig_extended,
 546                             const VMRegPair *regs,
 547                             Label&amp; skip_fixup,
 548                             address start,
 549                             OopMapSet* oop_maps,
 550                             int&amp; frame_complete,
 551                             int&amp; frame_size_in_words,
 552                             bool alloc_inline_receiver) {
 553 
 554   // Before we get into the guts of the C2I adapter, see if we should be here
 555   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 556   // interpreter, which means the caller made a static call to get here
 557   // (vcalls always get a compiled target if there is one).  Check for a
 558   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 559   patch_callers_callsite(masm);
 560 
 561   __ bind(skip_fixup);
 562 
 563   bool has_inline_argument = false;
 564 
 565   if (InlineTypePassFieldsAsArgs) {
 566       // Is there an inline type argument?
 567      for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_inline_argument; i++) {
 568        has_inline_argument = (sig_extended-&gt;at(i)._bt == T_INLINE_TYPE);
 569      }
 570      if (has_inline_argument) {
 571       // There is at least an inline type argument: we&#39;re coming from
 572       // compiled code so we have no buffers to back the inline types
 573       // Allocate the buffers here with a runtime call.
 574       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
 575 
 576       frame_complete = __ offset();
 577       address the_pc = __ pc();
 578 
 579       __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);
 580 
 581       __ mov(c_rarg0, rthread);
 582       __ mov(c_rarg1, r1);
 583       __ mov(c_rarg2, (int64_t)alloc_inline_receiver);
 584 
 585       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_inline_types)));
 586       __ blr(rscratch1);
 587 
 588       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);
 589       __ reset_last_Java_frame(false);
 590 
 591       RegisterSaver::restore_live_registers(masm);
 592 
 593       Label no_exception;
 594       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
 595       __ cbz(r0, no_exception);
 596 
 597       __ str(zr, Address(rthread, JavaThread::vm_result_offset()));
 598       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
 599       __ b(RuntimeAddress(StubRoutines::forward_exception_entry()));
 600 
 601       __ bind(no_exception);
 602 
 603       // We get an array of objects from the runtime call
 604       __ get_vm_result(r10, rthread);
 605       __ get_vm_result_2(r1, rthread); // TODO: required to keep the callee Method live?
 606     }
 607   }
 608 
 609   int words_pushed = 0;
 610 
 611   // Since all args are passed on the stack, total_args_passed *
 612   // Interpreter::stackElementSize is the space we need.
 613 
 614   int total_args_passed = compute_total_args_passed_int(sig_extended);
 615   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;
 616 
 617   // stack is aligned, keep it that way
 618   extraspace = align_up(extraspace, 2 * wordSize);
 619 
 620   __ mov(r13, sp);
 621 
 622   if (extraspace)
 623     __ sub(sp, sp, extraspace);
 624 
 625   // Now write the args into the outgoing interpreter space
 626 
 627   int ignored = 0, next_vt_arg = 0, next_arg_int = 0;
 628   bool has_oop_field = false;
 629 
 630   for (int next_arg_comp = 0; next_arg_comp &lt; total_args_passed; next_arg_comp++) {
 631     BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 632     // offset to start parameters
 633     int st_off   = (total_args_passed - next_arg_int - 1) * Interpreter::stackElementSize;
 634 
 635     if (!InlineTypePassFieldsAsArgs || bt != T_INLINE_TYPE) {
 636 
 637             if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 638                continue; // Ignore reserved entry
 639             }
 640 
 641             if (bt == T_VOID) {
 642                assert(next_arg_comp &gt; 0 &amp;&amp; (sig_extended-&gt;at(next_arg_comp - 1)._bt == T_LONG || sig_extended-&gt;at(next_arg_comp - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
 643                next_arg_int ++;
 644                continue;
 645              }
 646 
 647              int next_off = st_off - Interpreter::stackElementSize;
 648              int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;
 649 
 650              gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp], extraspace, Address(sp, offset));
 651              next_arg_int ++;
 652    } else {
 653        ignored++;
 654       // get the buffer from the just allocated pool of buffers
 655       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_INLINE_TYPE);
 656       __ load_heap_oop(rscratch1, Address(r10, index));
 657       next_vt_arg++;
 658       next_arg_int++;
 659       int vt = 1;
 660       // write fields we get from compiled code in registers/stack
 661       // slots to the buffer: we know we are done with that inline type
 662       // argument when we hit the T_VOID that acts as an end of value
 663       // type delimiter for this inline type. Inline types are flattened
 664       // so we might encounter embedded inline types. Each entry in
 665       // sig_extended contains a field offset in the buffer.
 666       do {
 667         next_arg_comp++;
 668         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 669         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp - 1)._bt;
 670         if (bt == T_INLINE_TYPE) {
 671           vt++;
 672           ignored++;
 673         } else if (bt == T_VOID &amp;&amp; prev_bt != T_LONG &amp;&amp; prev_bt != T_DOUBLE) {
 674           vt--;
 675           ignored++;
 676         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 677           // Ignore reserved entry
 678         } else {
 679           int off = sig_extended-&gt;at(next_arg_comp)._offset;
 680           assert(off &gt; 0, &quot;offset in object should be positive&quot;);
 681 
 682           bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
 683           has_oop_field = has_oop_field || is_oop;
 684 
 685           gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp - ignored], extraspace, Address(r11, off));
 686         }
 687       } while (vt != 0);
 688       // pass the buffer to the interpreter
 689       __ str(rscratch1, Address(sp, st_off));
 690    }
 691 
 692   }
 693 
 694 // If an inline type was allocated and initialized, apply post barrier to all oop fields
 695   if (has_inline_argument &amp;&amp; has_oop_field) {
 696     __ push(r13); // save senderSP
 697     __ push(r1); // save callee
 698     // Allocate argument register save area
 699     if (frame::arg_reg_save_area_bytes != 0) {
 700       __ sub(sp, sp, frame::arg_reg_save_area_bytes);
 701     }
 702     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::apply_post_barriers), rthread, r10);
 703     // De-allocate argument register save area
 704     if (frame::arg_reg_save_area_bytes != 0) {
 705       __ add(sp, sp, frame::arg_reg_save_area_bytes);
 706     }
 707     __ pop(r1); // restore callee
 708     __ pop(r13); // restore sender SP
 709   }
 710 
 711   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 712 
 713   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 714   __ br(rscratch1);
 715 }
 716 
 717 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm, int comp_args_on_stack, const GrowableArray&lt;SigEntry&gt;* sig, const VMRegPair *regs) {
 718 
 719 
 720   // Note: r13 contains the senderSP on entry. We must preserve it since
 721   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 722   // code goes non-entrant while we get args ready.
 723 
 724   // In addition we use r13 to locate all the interpreter args because
 725   // we must align the stack to 16 bytes.
 726 
 727   // Adapters are frameless.
 728 
 729   // An i2c adapter is frameless because the *caller* frame, which is
 730   // interpreted, routinely repairs its own esp (from
 731   // interpreter_frame_last_sp), even if a callee has modified the
 732   // stack pointer.  It also recalculates and aligns sp.
 733 
 734   // A c2i adapter is frameless because the *callee* frame, which is
 735   // interpreted, routinely repairs its caller&#39;s sp (from sender_sp,
 736   // which is set up via the senderSP register).
 737 
 738   // In other words, if *either* the caller or callee is interpreted, we can
 739   // get the stack pointer repaired after a call.
 740 
 741   // This is why c2i and i2c adapters cannot be indefinitely composed.
 742   // In particular, if a c2i adapter were to somehow call an i2c adapter,
 743   // both caller and callee would be compiled methods, and neither would
 744   // clean up the stack pointer changes performed by the two adapters.
 745   // If this happens, control eventually transfers back to the compiled
 746   // caller, but with an uncorrected stack, causing delayed havoc.
 747 
 748   if (VerifyAdapterCalls &amp;&amp;
 749       (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {
 750 #if 0
 751     // So, let&#39;s test for cascading c2i/i2c adapters right now.
 752     //  assert(Interpreter::contains($return_addr) ||
 753     //         StubRoutines::contains($return_addr),
 754     //         &quot;i2c adapter must return to an interpreter frame&quot;);
 755     __ block_comment(&quot;verify_i2c { &quot;);
 756     Label L_ok;
 757     if (Interpreter::code() != NULL)
 758       range_check(masm, rax, r11,
 759                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 760                   L_ok);
 761     if (StubRoutines::code1() != NULL)
 762       range_check(masm, rax, r11,
 763                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 764                   L_ok);
 765     if (StubRoutines::code2() != NULL)
 766       range_check(masm, rax, r11,
 767                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 768                   L_ok);
 769     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 770     __ block_comment(msg);
 771     __ stop(msg);
 772     __ bind(L_ok);
 773     __ block_comment(&quot;} verify_i2ce &quot;);
 774 #endif
 775   }
 776 
 777   // Cut-out for having no stack args.
 778   int comp_words_on_stack = 0;
 779   if (comp_args_on_stack) {
 780      comp_words_on_stack = align_up(comp_args_on_stack * VMRegImpl::stack_slot_size, wordSize) &gt;&gt; LogBytesPerWord;
 781      __ sub(rscratch1, sp, comp_words_on_stack * wordSize);
 782      __ andr(sp, rscratch1, -16);
 783   }
 784 
 785   // Will jump to the compiled code just as if compiled code was doing it.
 786   // Pre-load the register-jump target early, to schedule it better.
 787   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 788 
 789 #if INCLUDE_JVMCI
 790   if (EnableJVMCI || UseAOT) {
 791     // check if this call should be routed towards a specific entry point
 792     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 793     Label no_alternative_target;
 794     __ cbz(rscratch2, no_alternative_target);
 795     __ mov(rscratch1, rscratch2);
 796     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 797     __ bind(no_alternative_target);
 798   }
 799 #endif // INCLUDE_JVMCI
 800 
 801   int total_args_passed = sig-&gt;length();
 802 
 803   // Now generate the shuffle code.
 804   for (int i = 0; i &lt; total_args_passed; i++) {
 805     BasicType bt = sig-&gt;at(i)._bt;
 806 
 807     assert(bt != T_INLINE_TYPE, &quot;i2c adapter doesn&#39;t unpack inline typ args&quot;);
 808     if (bt == T_VOID) {
 809       assert(i &gt; 0 &amp;&amp; (sig-&gt;at(i - 1)._bt == T_LONG || sig-&gt;at(i - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
 810       continue;
 811     }
 812 
 813     // Pick up 0, 1 or 2 words from SP+offset.
 814     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(), &quot;scrambled load targets?&quot;);
 815 
 816     // Load in argument order going down.
 817     int ld_off = (total_args_passed - i - 1) * Interpreter::stackElementSize;
 818     // Point to interpreter value (vs. tag)
 819     int next_off = ld_off - Interpreter::stackElementSize;
 820     //
 821     //
 822     //
 823     VMReg r_1 = regs[i].first();
 824     VMReg r_2 = regs[i].second();
 825     if (!r_1-&gt;is_valid()) {
 826       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 827       continue;
 828     }
 829     if (r_1-&gt;is_stack()) {
 830       // Convert stack slot to an SP offset (+ wordSize to account for return address )
 831       int st_off = regs[i].first()-&gt;reg2stack() * VMRegImpl::stack_slot_size;
 832       if (!r_2-&gt;is_valid()) {
 833         // sign extend???
 834         __ ldrsw(rscratch2, Address(esp, ld_off));
 835         __ str(rscratch2, Address(sp, st_off));
 836       } else {
 837         //
 838         // We are using two optoregs. This can be either T_OBJECT,
 839         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 840         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 841         // So we must adjust where to pick up the data to match the
 842         // interpreter.
 843         //
 844         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 845         // are accessed as negative so LSW is at LOW address
 846 
 847         // ld_off is MSW so get LSW
 848         const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;
 849         __ ldr(rscratch2, Address(esp, offset));
 850         // st_off is LSW (i.e. reg.first())
 851          __ str(rscratch2, Address(sp, st_off));
 852        }
 853      } else if (r_1-&gt;is_Register()) {  // Register argument
 854        Register r = r_1-&gt;as_Register();
 855        if (r_2-&gt;is_valid()) {
 856          //
 857          // We are using two VMRegs. This can be either T_OBJECT,
 858          // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 859          // two slots but only uses one for thr T_LONG or T_DOUBLE case
 860          // So we must adjust where to pick up the data to match the
 861          // interpreter.
 862 
 863         const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;
 864 
 865          // this can be a misaligned move
 866          __ ldr(r, Address(esp, offset));
 867        } else {
 868          // sign extend and use a full word?
 869          __ ldrw(r, Address(esp, ld_off));
 870        }
 871      } else {
 872        if (!r_2-&gt;is_valid()) {
 873          __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));
 874        } else {
 875          __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));
 876        }
 877      }
 878    }
 879 
 880 
 881   // 6243940 We might end up in handle_wrong_method if
 882   // the callee is deoptimized as we race thru here. If that
 883   // happens we don&#39;t want to take a safepoint because the
 884   // caller frame will look interpreted and arguments are now
 885   // &quot;compiled&quot; so it is much better to make this transition
 886   // invisible to the stack walking code. Unfortunately if
 887   // we try and find the callee by normal means a safepoint
 888   // is possible. So we stash the desired callee in the thread
 889   // and the vm will find there should this case occur.
 890 
 891   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));
 892   __ br(rscratch1);
 893 }
 894 
 895 static void gen_inline_cache_check(MacroAssembler *masm, Label&amp; skip_fixup) {
 896 
 897   Label ok;
 898 
 899   Register holder = rscratch2;
 900   Register receiver = j_rarg0;
 901   Register tmp = r10;  // A call-clobbered register not used for arg passing
 902 
 903   // -------------------------------------------------------------------------
 904   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 905   // to the interpreter.  The args start out packed in the compiled layout.  They
 906   // need to be unpacked into the interpreter layout.  This will almost always
 907   // require some stack space.  We grow the current (compiled) stack, then repack
 908   // the args.  We  finally end in a jump to the generic interpreter entry point.
 909   // On exit from the interpreter, the interpreter will restore our SP (lest the
 910   // compiled code, which relys solely on SP and not FP, get sick).
 911 
 912   {
 913     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 914     __ load_klass(rscratch1, receiver);
 915     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 916     __ cmp(rscratch1, tmp);
 917     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 918     __ br(Assembler::EQ, ok);
 919     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 920 
 921     __ bind(ok);
 922     // Method might have been compiled since the call site was patched to
 923     // interpreted; if that is the case treat it as a miss so we can get
 924     // the call site corrected.
 925     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 926     __ cbz(rscratch1, skip_fixup);
 927     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 928     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 929   }
 930 }
 931 
 932 
 933 // ---------------------------------------------------------------
 934 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
 935                                                             int comp_args_on_stack,
 936                                                             const GrowableArray&lt;SigEntry&gt;* sig,
 937                                                             const VMRegPair* regs,
 938                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc,
 939                                                             const VMRegPair* regs_cc,
 940                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc_ro,
 941                                                             const VMRegPair* regs_cc_ro,
 942                                                             AdapterFingerPrint* fingerprint,
 943                                                             AdapterBlob*&amp; new_adapter) {
 944 
 945   address i2c_entry = __ pc();
 946   gen_i2c_adapter(masm, comp_args_on_stack, sig, regs);
 947 
 948   address c2i_unverified_entry = __ pc();
 949   Label skip_fixup;
 950 
 951   gen_inline_cache_check(masm, skip_fixup);
 952 
 953   OopMapSet* oop_maps = new OopMapSet();
 954   int frame_complete = CodeOffsets::frame_never_safe;
 955   int frame_size_in_words = 0;
 956 
 957   // Scalarized c2i adapter with non-scalarized receiver (i.e., don&#39;t pack receiver)
 958   address c2i_inline_ro_entry = __ pc();
 959   if (regs_cc != regs_cc_ro) {
 960     Label unused;
 961     gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);
 962     skip_fixup = unused;
 963   }
 964 
 965   // Scalarized c2i adapter
 966   address c2i_entry = __ pc();
 967 
 968   // Class initialization barrier for static methods
 969   address c2i_no_clinit_check_entry = NULL;
 970 
 971   if (VM_Version::supports_fast_class_init_checks()) {
 972     Label L_skip_barrier;
 973     { // Bypass the barrier for non-static methods
 974         Register flags  = rscratch1;
 975       __ ldrw(flags, Address(rmethod, Method::access_flags_offset()));
 976       __ tst(flags, JVM_ACC_STATIC);
 977       __ br(Assembler::NE, L_skip_barrier); // non-static
 978     }
 979 
 980     Register klass = rscratch1;
 981     __ load_method_holder(klass, rmethod);
 982     // We pass rthread to this function on x86
 983     __ clinit_barrier(klass, rscratch2, &amp;L_skip_barrier /*L_fast_path*/);
 984 
 985     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
 986 
 987     __ bind(L_skip_barrier);
 988     c2i_no_clinit_check_entry = __ pc();
 989   }
 990 
 991   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 992   bs-&gt;c2i_entry_barrier(masm);
 993 
 994   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 995 
 996   address c2i_unverified_inline_entry = c2i_unverified_entry;
 997 
 998  // Non-scalarized c2i adapter
 999   address c2i_inline_entry = c2i_entry;
1000   if (regs != regs_cc) {
1001     Label inline_entry_skip_fixup;
1002     c2i_unverified_inline_entry = __ pc();
1003     gen_inline_cache_check(masm, inline_entry_skip_fixup);
1004 
1005     c2i_inline_entry = __ pc();
1006     Label unused;
1007     gen_c2i_adapter(masm, sig, regs, inline_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);
1008   }
1009 
1010   __ flush();
1011 
1012   // The c2i adapter might safepoint and trigger a GC. The caller must make sure that
1013   // the GC knows about the location of oop argument locations passed to the c2i adapter.
1014 
1015   bool caller_must_gc_arguments = (regs != regs_cc);
1016   new_adapter = AdapterBlob::create(masm-&gt;code(), frame_complete, frame_size_in_words + 10, oop_maps, caller_must_gc_arguments);
1017 
1018   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);
1019 }
1020 
1021 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
1022                                          VMRegPair *regs,
1023                                          VMRegPair *regs2,
1024                                          int total_args_passed) {
1025   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
1026 
1027 // We return the amount of VMRegImpl stack slots we need to reserve for all
1028 // the arguments NOT counting out_preserve_stack_slots.
1029 
1030     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
1031       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
1032     };
1033     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
1034       c_farg0, c_farg1, c_farg2, c_farg3,
1035       c_farg4, c_farg5, c_farg6, c_farg7
1036     };
1037 
1038     uint int_args = 0;
1039     uint fp_args = 0;
1040     uint stk_args = 0; // inc by 2 each time
1041 
1042     for (int i = 0; i &lt; total_args_passed; i++) {
1043       switch (sig_bt[i]) {
1044       case T_BOOLEAN:
1045       case T_CHAR:
1046       case T_BYTE:
1047       case T_SHORT:
1048       case T_INT:
1049         if (int_args &lt; Argument::n_int_register_parameters_c) {
1050           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
1051         } else {
1052           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1053           stk_args += 2;
1054         }
1055         break;
1056       case T_LONG:
1057         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1058         // fall through
1059       case T_OBJECT:
1060       case T_ARRAY:
1061       case T_INLINE_TYPE:
1062       case T_ADDRESS:
1063       case T_METADATA:
1064         if (int_args &lt; Argument::n_int_register_parameters_c) {
1065           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
1066         } else {
1067           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1068           stk_args += 2;
1069         }
1070         break;
1071       case T_FLOAT:
1072         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1073           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1074         } else {
1075           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1076           stk_args += 2;
1077         }
1078         break;
1079       case T_DOUBLE:
1080         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1081         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1082           regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1083         } else {
1084           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1085           stk_args += 2;
1086         }
1087         break;
1088       case T_VOID: // Halves of longs and doubles
1089         assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
1090         regs[i].set_bad();
1091         break;
1092       default:
1093         ShouldNotReachHere();
1094         break;
1095       }
1096     }
1097 
1098   return stk_args;
1099 }
1100 
1101 // On 64 bit we will store integer like items to the stack as
1102 // 64 bits items (sparc abi) even though java would only store
1103 // 32bits for a parameter. On 32bit it will simply be 32 bits
1104 // So this routine will do 32-&gt;32 on 32bit and 32-&gt;64 on 64bit
1105 static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1106   if (src.first()-&gt;is_stack()) {
1107     if (dst.first()-&gt;is_stack()) {
1108       // stack to stack
1109       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
1110       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
1111     } else {
1112       // stack to reg
1113       __ ldrsw(dst.first()-&gt;as_Register(), Address(rfp, reg2offset_in(src.first())));
1114     }
1115   } else if (dst.first()-&gt;is_stack()) {
1116     // reg to stack
1117     // Do we really have to sign extend???
1118     // __ movslq(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1119     __ str(src.first()-&gt;as_Register(), Address(sp, reg2offset_out(dst.first())));
1120   } else {
1121     if (dst.first() != src.first()) {
1122       __ sxtw(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1123     }
1124   }
1125 }
1126 
1127 // An oop arg. Must pass a handle not the oop itself
1128 static void object_move(MacroAssembler* masm,
1129                         OopMap* map,
1130                         int oop_handle_offset,
1131                         int framesize_in_slots,
1132                         VMRegPair src,
1133                         VMRegPair dst,
1134                         bool is_receiver,
1135                         int* receiver_offset) {
1136 
1137   // must pass a handle. First figure out the location we use as a handle
1138 
1139   Register rHandle = dst.first()-&gt;is_stack() ? rscratch2 : dst.first()-&gt;as_Register();
1140 
1141   // See if oop is NULL if it is we need no handle
1142 
1143   if (src.first()-&gt;is_stack()) {
1144 
1145     // Oop is already on the stack as an argument
1146     int offset_in_older_frame = src.first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1147     map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));
1148     if (is_receiver) {
1149       *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;
1150     }
1151 
1152     __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
1153     __ lea(rHandle, Address(rfp, reg2offset_in(src.first())));
1154     // conditionally move a NULL
1155     __ cmp(rscratch1, zr);
1156     __ csel(rHandle, zr, rHandle, Assembler::EQ);
1157   } else {
1158 
1159     // Oop is in an a register we must store it to the space we reserve
1160     // on the stack for oop_handles and pass a handle if oop is non-NULL
1161 
1162     const Register rOop = src.first()-&gt;as_Register();
1163     int oop_slot;
1164     if (rOop == j_rarg0)
1165       oop_slot = 0;
1166     else if (rOop == j_rarg1)
1167       oop_slot = 1;
1168     else if (rOop == j_rarg2)
1169       oop_slot = 2;
1170     else if (rOop == j_rarg3)
1171       oop_slot = 3;
1172     else if (rOop == j_rarg4)
1173       oop_slot = 4;
1174     else if (rOop == j_rarg5)
1175       oop_slot = 5;
1176     else if (rOop == j_rarg6)
1177       oop_slot = 6;
1178     else {
1179       assert(rOop == j_rarg7, &quot;wrong register&quot;);
1180       oop_slot = 7;
1181     }
1182 
1183     oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;
1184     int offset = oop_slot*VMRegImpl::stack_slot_size;
1185 
1186     map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot));
1187     // Store oop in handle area, may be NULL
1188     __ str(rOop, Address(sp, offset));
1189     if (is_receiver) {
1190       *receiver_offset = offset;
1191     }
1192 
1193     __ cmp(rOop, zr);
1194     __ lea(rHandle, Address(sp, offset));
1195     // conditionally move a NULL
1196     __ csel(rHandle, zr, rHandle, Assembler::EQ);
1197   }
1198 
1199   // If arg is on the stack then place it otherwise it is already in correct reg.
1200   if (dst.first()-&gt;is_stack()) {
1201     __ str(rHandle, Address(sp, reg2offset_out(dst.first())));
1202   }
1203 }
1204 
1205 // A float arg may have to do float reg int reg conversion
1206 static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1207   assert(src.first()-&gt;is_stack() &amp;&amp; dst.first()-&gt;is_stack() ||
1208          src.first()-&gt;is_reg() &amp;&amp; dst.first()-&gt;is_reg(), &quot;Unexpected error&quot;);
1209   if (src.first()-&gt;is_stack()) {
1210     if (dst.first()-&gt;is_stack()) {
1211       __ ldrw(rscratch1, Address(rfp, reg2offset_in(src.first())));
1212       __ strw(rscratch1, Address(sp, reg2offset_out(dst.first())));
1213     } else {
1214       ShouldNotReachHere();
1215     }
1216   } else if (src.first() != dst.first()) {
1217     if (src.is_single_phys_reg() &amp;&amp; dst.is_single_phys_reg())
1218       __ fmovs(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
1219     else
1220       ShouldNotReachHere();
1221   }
1222 }
1223 
1224 // A long move
1225 static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1226   if (src.first()-&gt;is_stack()) {
1227     if (dst.first()-&gt;is_stack()) {
1228       // stack to stack
1229       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
1230       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
1231     } else {
1232       // stack to reg
1233       __ ldr(dst.first()-&gt;as_Register(), Address(rfp, reg2offset_in(src.first())));
1234     }
1235   } else if (dst.first()-&gt;is_stack()) {
1236     // reg to stack
1237     // Do we really have to sign extend???
1238     // __ movslq(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1239     __ str(src.first()-&gt;as_Register(), Address(sp, reg2offset_out(dst.first())));
1240   } else {
1241     if (dst.first() != src.first()) {
1242       __ mov(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1243     }
1244   }
1245 }
1246 
1247 
1248 // A double move
1249 static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1250   assert(src.first()-&gt;is_stack() &amp;&amp; dst.first()-&gt;is_stack() ||
1251          src.first()-&gt;is_reg() &amp;&amp; dst.first()-&gt;is_reg(), &quot;Unexpected error&quot;);
1252   if (src.first()-&gt;is_stack()) {
1253     if (dst.first()-&gt;is_stack()) {
1254       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
1255       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
1256     } else {
1257       ShouldNotReachHere();
1258     }
1259   } else if (src.first() != dst.first()) {
1260     if (src.is_single_phys_reg() &amp;&amp; dst.is_single_phys_reg())
1261       __ fmovd(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
1262     else
1263       ShouldNotReachHere();
1264   }
1265 }
1266 
1267 
1268 void SharedRuntime::save_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1269   // We always ignore the frame_slots arg and just use the space just below frame pointer
1270   // which by this time is free to use
1271   switch (ret_type) {
1272   case T_FLOAT:
1273     __ strs(v0, Address(rfp, -wordSize));
1274     break;
1275   case T_DOUBLE:
1276     __ strd(v0, Address(rfp, -wordSize));
1277     break;
1278   case T_VOID:  break;
1279   default: {
1280     __ str(r0, Address(rfp, -wordSize));
1281     }
1282   }
1283 }
1284 
1285 void SharedRuntime::restore_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1286   // We always ignore the frame_slots arg and just use the space just below frame pointer
1287   // which by this time is free to use
1288   switch (ret_type) {
1289   case T_FLOAT:
1290     __ ldrs(v0, Address(rfp, -wordSize));
1291     break;
1292   case T_DOUBLE:
1293     __ ldrd(v0, Address(rfp, -wordSize));
1294     break;
1295   case T_VOID:  break;
1296   default: {
1297     __ ldr(r0, Address(rfp, -wordSize));
1298     }
1299   }
1300 }
1301 static void save_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1302   RegSet x;
1303   for ( int i = first_arg ; i &lt; arg_count ; i++ ) {
1304     if (args[i].first()-&gt;is_Register()) {
1305       x = x + args[i].first()-&gt;as_Register();
1306     } else if (args[i].first()-&gt;is_FloatRegister()) {
1307       __ strd(args[i].first()-&gt;as_FloatRegister(), Address(__ pre(sp, -2 * wordSize)));
1308     }
1309   }
1310   __ push(x, sp);
1311 }
1312 
1313 static void restore_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1314   RegSet x;
1315   for ( int i = first_arg ; i &lt; arg_count ; i++ ) {
1316     if (args[i].first()-&gt;is_Register()) {
1317       x = x + args[i].first()-&gt;as_Register();
1318     } else {
1319       ;
1320     }
1321   }
1322   __ pop(x, sp);
1323   for ( int i = arg_count - 1 ; i &gt;= first_arg ; i-- ) {
1324     if (args[i].first()-&gt;is_Register()) {
1325       ;
1326     } else if (args[i].first()-&gt;is_FloatRegister()) {
1327       __ ldrd(args[i].first()-&gt;as_FloatRegister(), Address(__ post(sp, 2 * wordSize)));
1328     }
1329   }
1330 }
1331 
1332 
1333 // Check GCLocker::needs_gc and enter the runtime if it&#39;s true.  This
1334 // keeps a new JNI critical region from starting until a GC has been
1335 // forced.  Save down any oops in registers and describe them in an
1336 // OopMap.
1337 static void check_needs_gc_for_critical_native(MacroAssembler* masm,
1338                                                int stack_slots,
1339                                                int total_c_args,
1340                                                int total_in_args,
1341                                                int arg_save_area,
1342                                                OopMapSet* oop_maps,
1343                                                VMRegPair* in_regs,
1344                                                BasicType* in_sig_bt) { Unimplemented(); }
1345 
1346 // Unpack an array argument into a pointer to the body and the length
1347 // if the array is non-null, otherwise pass 0 for both.
1348 static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type, VMRegPair body_arg, VMRegPair length_arg) { Unimplemented(); }
1349 
1350 
1351 class ComputeMoveOrder: public StackObj {
1352   class MoveOperation: public ResourceObj {
1353     friend class ComputeMoveOrder;
1354    private:
1355     VMRegPair        _src;
1356     VMRegPair        _dst;
1357     int              _src_index;
1358     int              _dst_index;
1359     bool             _processed;
1360     MoveOperation*  _next;
1361     MoveOperation*  _prev;
1362 
1363     static int get_id(VMRegPair r) { Unimplemented(); return 0; }
1364 
1365    public:
1366     MoveOperation(int src_index, VMRegPair src, int dst_index, VMRegPair dst):
1367       _src(src)
1368     , _dst(dst)
1369     , _src_index(src_index)
1370     , _dst_index(dst_index)
1371     , _processed(false)
1372     , _next(NULL)
1373     , _prev(NULL) { Unimplemented(); }
1374 
1375     VMRegPair src() const              { Unimplemented(); return _src; }
1376     int src_id() const                 { Unimplemented(); return 0; }
1377     int src_index() const              { Unimplemented(); return 0; }
1378     VMRegPair dst() const              { Unimplemented(); return _src; }
1379     void set_dst(int i, VMRegPair dst) { Unimplemented(); }
1380     int dst_index() const              { Unimplemented(); return 0; }
1381     int dst_id() const                 { Unimplemented(); return 0; }
1382     MoveOperation* next() const        { Unimplemented(); return 0; }
1383     MoveOperation* prev() const        { Unimplemented(); return 0; }
1384     void set_processed()               { Unimplemented(); }
1385     bool is_processed() const          { Unimplemented(); return 0; }
1386 
1387     // insert
1388     void break_cycle(VMRegPair temp_register) { Unimplemented(); }
1389 
1390     void link(GrowableArray&lt;MoveOperation*&gt;&amp; killer) { Unimplemented(); }
1391   };
1392 
1393  private:
1394   GrowableArray&lt;MoveOperation*&gt; edges;
1395 
1396  public:
1397   ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,
1398                     BasicType* in_sig_bt, GrowableArray&lt;int&gt;&amp; arg_order, VMRegPair tmp_vmreg) { Unimplemented(); }
1399 
1400   // Collected all the move operations
1401   void add_edge(int src_index, VMRegPair src, int dst_index, VMRegPair dst) { Unimplemented(); }
1402 
1403   // Walk the edges breaking cycles between moves.  The result list
1404   // can be walked in order to produce the proper set of loads
1405   GrowableArray&lt;MoveOperation*&gt;* get_store_order(VMRegPair temp_register) { Unimplemented(); return 0; }
1406 };
1407 
1408 
1409 static void rt_call(MacroAssembler* masm, address dest) {
1410   CodeBlob *cb = CodeCache::find_blob(dest);
1411   if (cb) {
1412     __ far_call(RuntimeAddress(dest));
1413   } else {
1414     __ lea(rscratch1, RuntimeAddress(dest));
1415     __ blr(rscratch1);
1416     __ maybe_isb();
1417   }
1418 }
1419 
1420 static void verify_oop_args(MacroAssembler* masm,
1421                             const methodHandle&amp; method,
1422                             const BasicType* sig_bt,
1423                             const VMRegPair* regs) {
1424   Register temp_reg = r19;  // not part of any compiled calling seq
1425   if (VerifyOops) {
1426     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
1427       if (sig_bt[i] == T_OBJECT ||
1428           sig_bt[i] == T_ARRAY) {
1429         VMReg r = regs[i].first();
1430         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
1431         if (r-&gt;is_stack()) {
1432           __ ldr(temp_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1433           __ verify_oop(temp_reg);
1434         } else {
1435           __ verify_oop(r-&gt;as_Register());
1436         }
1437       }
1438     }
1439   }
1440 }
1441 
1442 static void gen_special_dispatch(MacroAssembler* masm,
1443                                  const methodHandle&amp; method,
1444                                  const BasicType* sig_bt,
1445                                  const VMRegPair* regs) {
1446   verify_oop_args(masm, method, sig_bt, regs);
1447   vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1448 
1449   // Now write the args into the outgoing interpreter space
1450   bool     has_receiver   = false;
1451   Register receiver_reg   = noreg;
1452   int      member_arg_pos = -1;
1453   Register member_reg     = noreg;
1454   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
1455   if (ref_kind != 0) {
1456     member_arg_pos = method-&gt;size_of_parameters() - 1;  // trailing MemberName argument
1457     member_reg = r19;  // known to be free at this point
1458     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
1459   } else if (iid == vmIntrinsics::_invokeBasic) {
1460     has_receiver = true;
1461   } else {
1462     fatal(&quot;unexpected intrinsic id %d&quot;, iid);
1463   }
1464 
1465   if (member_reg != noreg) {
1466     // Load the member_arg into register, if necessary.
1467     SharedRuntime::check_member_name_argument_is_last_argument(method, sig_bt, regs);
1468     VMReg r = regs[member_arg_pos].first();
1469     if (r-&gt;is_stack()) {
1470       __ ldr(member_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1471     } else {
1472       // no data motion is needed
1473       member_reg = r-&gt;as_Register();
1474     }
1475   }
1476 
1477   if (has_receiver) {
1478     // Make sure the receiver is loaded into a register.
1479     assert(method-&gt;size_of_parameters() &gt; 0, &quot;oob&quot;);
1480     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
1481     VMReg r = regs[0].first();
1482     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
1483     if (r-&gt;is_stack()) {
1484       // Porting note:  This assumes that compiled calling conventions always
1485       // pass the receiver oop in a register.  If this is not true on some
1486       // platform, pick a temp and load the receiver from stack.
1487       fatal(&quot;receiver always in a register&quot;);
1488       receiver_reg = r2;  // known to be free at this point
1489       __ ldr(receiver_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1490     } else {
1491       // no data motion is needed
1492       receiver_reg = r-&gt;as_Register();
1493     }
1494   }
1495 
1496   // Figure out which address we are really jumping to:
1497   MethodHandles::generate_method_handle_dispatch(masm, iid,
1498                                                  receiver_reg, member_reg, /*for_compiler_entry:*/ true);
1499 }
1500 
1501 // ---------------------------------------------------------------------------
1502 // Generate a native wrapper for a given method.  The method takes arguments
1503 // in the Java compiled code convention, marshals them to the native
1504 // convention (handlizes oops, etc), transitions to native, makes the call,
1505 // returns to java state (possibly blocking), unhandlizes any result and
1506 // returns.
1507 //
1508 // Critical native functions are a shorthand for the use of
1509 // GetPrimtiveArrayCritical and disallow the use of any other JNI
1510 // functions.  The wrapper is expected to unpack the arguments before
1511 // passing them to the callee and perform checks before and after the
1512 // native call to ensure that they GCLocker
1513 // lock_critical/unlock_critical semantics are followed.  Some other
1514 // parts of JNI setup are skipped like the tear down of the JNI handle
1515 // block and the check for pending exceptions it&#39;s impossible for them
1516 // to be thrown.
1517 //
1518 // They are roughly structured like this:
1519 //    if (GCLocker::needs_gc())
1520 //      SharedRuntime::block_for_jni_critical();
1521 //    tranistion to thread_in_native
1522 //    unpack arrray arguments and call native entry point
1523 //    check for safepoint in progress
1524 //    check if any thread suspend flags are set
1525 //      call into JVM and possible unlock the JNI critical
1526 //      if a GC was suppressed while in the critical native.
1527 //    transition back to thread_in_Java
1528 //    return to caller
1529 //
1530 nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
1531                                                 const methodHandle&amp; method,
1532                                                 int compile_id,
1533                                                 BasicType* in_sig_bt,
1534                                                 VMRegPair* in_regs,
1535                                                 BasicType ret_type,
1536                                                 address critical_entry) {
1537   if (method-&gt;is_method_handle_intrinsic()) {
1538     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1539     intptr_t start = (intptr_t)__ pc();
1540     int vep_offset = ((intptr_t)__ pc()) - start;
1541 
1542     // First instruction must be a nop as it may need to be patched on deoptimisation
1543     __ nop();
1544     gen_special_dispatch(masm,
1545                          method,
1546                          in_sig_bt,
1547                          in_regs);
1548     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
1549     __ flush();
1550     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
1551     return nmethod::new_native_nmethod(method,
1552                                        compile_id,
1553                                        masm-&gt;code(),
1554                                        vep_offset,
1555                                        frame_complete,
1556                                        stack_slots / VMRegImpl::slots_per_word,
1557                                        in_ByteSize(-1),
1558                                        in_ByteSize(-1),
1559                                        (OopMapSet*)NULL);
1560   }
1561   bool is_critical_native = true;
1562   address native_func = critical_entry;
1563   if (native_func == NULL) {
1564     native_func = method-&gt;native_function();
1565     is_critical_native = false;
1566   }
1567   assert(native_func != NULL, &quot;must have function&quot;);
1568 
1569   // An OopMap for lock (and class if static)
1570   OopMapSet *oop_maps = new OopMapSet();
1571   intptr_t start = (intptr_t)__ pc();
1572 
1573   // We have received a description of where all the java arg are located
1574   // on entry to the wrapper. We need to convert these args to where
1575   // the jni function will expect them. To figure out where they go
1576   // we convert the java signature to a C signature by inserting
1577   // the hidden arguments as arg[0] and possibly arg[1] (static method)
1578 
1579   const int total_in_args = method-&gt;size_of_parameters();
1580   int total_c_args = total_in_args;
1581   if (!is_critical_native) {
1582     total_c_args += 1;
1583     if (method-&gt;is_static()) {
1584       total_c_args++;
1585     }
1586   } else {
1587     for (int i = 0; i &lt; total_in_args; i++) {
1588       if (in_sig_bt[i] == T_ARRAY) {
1589         total_c_args++;
1590       }
1591     }
1592   }
1593 
1594   BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1595   VMRegPair* out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1596   BasicType* in_elem_bt = NULL;
1597 
1598   int argc = 0;
1599   if (!is_critical_native) {
1600     out_sig_bt[argc++] = T_ADDRESS;
1601     if (method-&gt;is_static()) {
1602       out_sig_bt[argc++] = T_OBJECT;
1603     }
1604 
1605     for (int i = 0; i &lt; total_in_args ; i++ ) {
1606       out_sig_bt[argc++] = in_sig_bt[i];
1607     }
1608   } else {
1609     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
1610     SignatureStream ss(method-&gt;signature());
1611     for (int i = 0; i &lt; total_in_args ; i++ ) {
1612       if (in_sig_bt[i] == T_ARRAY) {
1613         // Arrays are passed as int, elem* pair
1614         out_sig_bt[argc++] = T_INT;
1615         out_sig_bt[argc++] = T_ADDRESS;
1616         ss.skip_array_prefix(1);  // skip one &#39;[&#39;
1617         assert(ss.is_primitive(), &quot;primitive type expected&quot;);
1618         in_elem_bt[i] = ss.type();
1619       } else {
1620         out_sig_bt[argc++] = in_sig_bt[i];
1621         in_elem_bt[i] = T_VOID;
1622       }
1623       if (in_sig_bt[i] != T_VOID) {
1624         assert(in_sig_bt[i] == ss.type() ||
1625                in_sig_bt[i] == T_ARRAY, &quot;must match&quot;);
1626         ss.next();
1627       }
1628     }
1629   }
1630 
1631   // Now figure out where the args must be stored and how much stack space
1632   // they require.
1633   int out_arg_slots;
1634   out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
1635 
1636   // Compute framesize for the wrapper.  We need to handlize all oops in
1637   // incoming registers
1638 
1639   // Calculate the total number of stack slots we will need.
1640 
1641   // First count the abi requirement plus all of the outgoing args
1642   int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;
1643 
1644   // Now the space for the inbound oop handle area
1645   int total_save_slots = 8 * VMRegImpl::slots_per_word;  // 8 arguments passed in registers
1646   if (is_critical_native) {
1647     // Critical natives may have to call out so they need a save area
1648     // for register arguments.
1649     int double_slots = 0;
1650     int single_slots = 0;
1651     for ( int i = 0; i &lt; total_in_args; i++) {
1652       if (in_regs[i].first()-&gt;is_Register()) {
1653         const Register reg = in_regs[i].first()-&gt;as_Register();
1654         switch (in_sig_bt[i]) {
1655           case T_BOOLEAN:
1656           case T_BYTE:
1657           case T_SHORT:
1658           case T_CHAR:
1659           case T_INT:  single_slots++; break;
1660           case T_ARRAY:  // specific to LP64 (7145024)
1661           case T_LONG: double_slots++; break;
1662           default:  ShouldNotReachHere();
1663         }
1664       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1665         ShouldNotReachHere();
1666       }
1667     }
1668     total_save_slots = double_slots * 2 + single_slots;
1669     // align the save area
1670     if (double_slots != 0) {
1671       stack_slots = align_up(stack_slots, 2);
1672     }
1673   }
1674 
1675   int oop_handle_offset = stack_slots;
1676   stack_slots += total_save_slots;
1677 
1678   // Now any space we need for handlizing a klass if static method
1679 
1680   int klass_slot_offset = 0;
1681   int klass_offset = -1;
1682   int lock_slot_offset = 0;
1683   bool is_static = false;
1684 
1685   if (method-&gt;is_static()) {
1686     klass_slot_offset = stack_slots;
1687     stack_slots += VMRegImpl::slots_per_word;
1688     klass_offset = klass_slot_offset * VMRegImpl::stack_slot_size;
1689     is_static = true;
1690   }
1691 
1692   // Plus a lock if needed
1693 
1694   if (method-&gt;is_synchronized()) {
1695     lock_slot_offset = stack_slots;
1696     stack_slots += VMRegImpl::slots_per_word;
1697   }
1698 
1699   // Now a place (+2) to save return values or temp during shuffling
1700   // + 4 for return address (which we own) and saved rfp
1701   stack_slots += 6;
1702 
1703   // Ok The space we have allocated will look like:
1704   //
1705   //
1706   // FP-&gt; |                     |
1707   //      |---------------------|
1708   //      | 2 slots for moves   |
1709   //      |---------------------|
1710   //      | lock box (if sync)  |
1711   //      |---------------------| &lt;- lock_slot_offset
1712   //      | klass (if static)   |
1713   //      |---------------------| &lt;- klass_slot_offset
1714   //      | oopHandle area      |
1715   //      |---------------------| &lt;- oop_handle_offset (8 java arg registers)
1716   //      | outbound memory     |
1717   //      | based arguments     |
1718   //      |                     |
1719   //      |---------------------|
1720   //      |                     |
1721   // SP-&gt; | out_preserved_slots |
1722   //
1723   //
1724 
1725 
1726   // Now compute actual number of stack words we need rounding to make
1727   // stack properly aligned.
1728   stack_slots = align_up(stack_slots, StackAlignmentInSlots);
1729 
1730   int stack_size = stack_slots * VMRegImpl::stack_slot_size;
1731 
1732   // First thing make an ic check to see if we should even be here
1733 
1734   // We are free to use all registers as temps without saving them and
1735   // restoring them except rfp. rfp is the only callee save register
1736   // as far as the interpreter and the compiler(s) are concerned.
1737 
1738 
1739   const Register ic_reg = rscratch2;
1740   const Register receiver = j_rarg0;
1741 
1742   Label hit;
1743   Label exception_pending;
1744 
1745   assert_different_registers(ic_reg, receiver, rscratch1);
1746   __ verify_oop(receiver);
1747   __ cmp_klass(receiver, ic_reg, rscratch1);
1748   __ br(Assembler::EQ, hit);
1749 
1750   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1751 
1752   // Verified entry point must be aligned
1753   __ align(8);
1754 
1755   __ bind(hit);
1756 
1757   int vep_offset = ((intptr_t)__ pc()) - start;
1758 
1759   // If we have to make this method not-entrant we&#39;ll overwrite its
1760   // first instruction with a jump.  For this action to be legal we
1761   // must ensure that this first instruction is a B, BL, NOP, BKPT,
1762   // SVC, HVC, or SMC.  Make it a NOP.
1763   __ nop();
1764 
1765   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {
1766     Label L_skip_barrier;
1767     __ mov_metadata(rscratch2, method-&gt;method_holder()); // InstanceKlass*
1768     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);
1769     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
1770 
1771     __ bind(L_skip_barrier);
1772   }
1773 
1774   // Generate stack overflow check
1775   if (UseStackBanging) {
1776     __ bang_stack_with_offset(JavaThread::stack_shadow_zone_size());
1777   } else {
1778     Unimplemented();
1779   }
1780 
1781   // Generate a new frame for the wrapper.
1782   __ enter();
1783   // -2 because return address is already present and so is saved rfp
1784   __ sub(sp, sp, stack_size - 2*wordSize);
1785 
1786   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1787   bs-&gt;nmethod_entry_barrier(masm);
1788 
1789   // Frame is now completed as far as size and linkage.
1790   int frame_complete = ((intptr_t)__ pc()) - start;
1791 
1792   // We use r20 as the oop handle for the receiver/klass
1793   // It is callee save so it survives the call to native
1794 
1795   const Register oop_handle_reg = r20;
1796 
1797   if (is_critical_native) {
1798     check_needs_gc_for_critical_native(masm, stack_slots, total_c_args, total_in_args,
1799                                        oop_handle_offset, oop_maps, in_regs, in_sig_bt);
1800   }
1801 
1802   //
1803   // We immediately shuffle the arguments so that any vm call we have to
1804   // make from here on out (sync slow path, jvmti, etc.) we will have
1805   // captured the oops from our caller and have a valid oopMap for
1806   // them.
1807 
1808   // -----------------
1809   // The Grand Shuffle
1810 
1811   // The Java calling convention is either equal (linux) or denser (win64) than the
1812   // c calling convention. However the because of the jni_env argument the c calling
1813   // convention always has at least one more (and two for static) arguments than Java.
1814   // Therefore if we move the args from java -&gt; c backwards then we will never have
1815   // a register-&gt;register conflict and we don&#39;t have to build a dependency graph
1816   // and figure out how to break any cycles.
1817   //
1818 
1819   // Record esp-based slot for receiver on stack for non-static methods
1820   int receiver_offset = -1;
1821 
1822   // This is a trick. We double the stack slots so we can claim
1823   // the oops in the caller&#39;s frame. Since we are sure to have
1824   // more args than the caller doubling is enough to make
1825   // sure we can capture all the incoming oop args from the
1826   // caller.
1827   //
1828   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1829 
1830   // Mark location of rfp (someday)
1831   // map-&gt;set_callee_saved(VMRegImpl::stack2reg( stack_slots - 2), stack_slots * 2, 0, vmreg(rfp));
1832 
1833 
1834   int float_args = 0;
1835   int int_args = 0;
1836 
1837 #ifdef ASSERT
1838   bool reg_destroyed[RegisterImpl::number_of_registers];
1839   bool freg_destroyed[FloatRegisterImpl::number_of_registers];
1840   for ( int r = 0 ; r &lt; RegisterImpl::number_of_registers ; r++ ) {
1841     reg_destroyed[r] = false;
1842   }
1843   for ( int f = 0 ; f &lt; FloatRegisterImpl::number_of_registers ; f++ ) {
1844     freg_destroyed[f] = false;
1845   }
1846 
1847 #endif /* ASSERT */
1848 
1849   // This may iterate in two different directions depending on the
1850   // kind of native it is.  The reason is that for regular JNI natives
1851   // the incoming and outgoing registers are offset upwards and for
1852   // critical natives they are offset down.
1853   GrowableArray&lt;int&gt; arg_order(2 * total_in_args);
1854   VMRegPair tmp_vmreg;
1855   tmp_vmreg.set2(r19-&gt;as_VMReg());
1856 
1857   if (!is_critical_native) {
1858     for (int i = total_in_args - 1, c_arg = total_c_args - 1; i &gt;= 0; i--, c_arg--) {
1859       arg_order.push(i);
1860       arg_order.push(c_arg);
1861     }
1862   } else {
1863     // Compute a valid move order, using tmp_vmreg to break any cycles
1864     ComputeMoveOrder cmo(total_in_args, in_regs, total_c_args, out_regs, in_sig_bt, arg_order, tmp_vmreg);
1865   }
1866 
1867   int temploc = -1;
1868   for (int ai = 0; ai &lt; arg_order.length(); ai += 2) {
1869     int i = arg_order.at(ai);
1870     int c_arg = arg_order.at(ai + 1);
1871     __ block_comment(err_msg(&quot;move %d -&gt; %d&quot;, i, c_arg));
1872     if (c_arg == -1) {
1873       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
1874       // This arg needs to be moved to a temporary
1875       __ mov(tmp_vmreg.first()-&gt;as_Register(), in_regs[i].first()-&gt;as_Register());
1876       in_regs[i] = tmp_vmreg;
1877       temploc = i;
1878       continue;
1879     } else if (i == -1) {
1880       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
1881       // Read from the temporary location
1882       assert(temploc != -1, &quot;must be valid&quot;);
1883       i = temploc;
1884       temploc = -1;
1885     }
1886 #ifdef ASSERT
1887     if (in_regs[i].first()-&gt;is_Register()) {
1888       assert(!reg_destroyed[in_regs[i].first()-&gt;as_Register()-&gt;encoding()], &quot;destroyed reg!&quot;);
1889     } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1890       assert(!freg_destroyed[in_regs[i].first()-&gt;as_FloatRegister()-&gt;encoding()], &quot;destroyed reg!&quot;);
1891     }
1892     if (out_regs[c_arg].first()-&gt;is_Register()) {
1893       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1894     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1895       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1896     }
1897 #endif /* ASSERT */
1898     switch (in_sig_bt[i]) {
1899       case T_ARRAY:
1900         if (is_critical_native) {
1901           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1902           c_arg++;
1903 #ifdef ASSERT
1904           if (out_regs[c_arg].first()-&gt;is_Register()) {
1905             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1906           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1907             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1908           }
1909 #endif
1910           int_args++;
1911           break;
1912         }
1913       case T_INLINE_TYPE:
1914       case T_OBJECT:
1915         assert(!is_critical_native, &quot;no oop arguments&quot;);
1916         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1917                     ((i == 0) &amp;&amp; (!is_static)),
1918                     &amp;receiver_offset);
1919         int_args++;
1920         break;
1921       case T_VOID:
1922         break;
1923 
1924       case T_FLOAT:
1925         float_move(masm, in_regs[i], out_regs[c_arg]);
1926         float_args++;
1927         break;
1928 
1929       case T_DOUBLE:
1930         assert( i + 1 &lt; total_in_args &amp;&amp;
1931                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1932                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1933         double_move(masm, in_regs[i], out_regs[c_arg]);
1934         float_args++;
1935         break;
1936 
1937       case T_LONG :
1938         long_move(masm, in_regs[i], out_regs[c_arg]);
1939         int_args++;
1940         break;
1941 
1942       case T_ADDRESS: assert(false, &quot;found T_ADDRESS in java args&quot;);
1943 
1944       default:
1945         move32_64(masm, in_regs[i], out_regs[c_arg]);
1946         int_args++;
1947     }
1948   }
1949 
1950   // point c_arg at the first arg that is already loaded in case we
1951   // need to spill before we call out
1952   int c_arg = total_c_args - total_in_args;
1953 
1954   // Pre-load a static method&#39;s oop into c_rarg1.
1955   if (method-&gt;is_static() &amp;&amp; !is_critical_native) {
1956 
1957     //  load oop into a register
1958     __ movoop(c_rarg1,
1959               JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()),
1960               /*immediate*/true);
1961 
1962     // Now handlize the static class mirror it&#39;s known not-null.
1963     __ str(c_rarg1, Address(sp, klass_offset));
1964     map-&gt;set_oop(VMRegImpl::stack2reg(klass_slot_offset));
1965 
1966     // Now get the handle
1967     __ lea(c_rarg1, Address(sp, klass_offset));
1968     // and protect the arg if we must spill
1969     c_arg--;
1970   }
1971 
1972   // Change state to native (we save the return address in the thread, since it might not
1973   // be pushed on the stack when we do a stack traversal).
1974   // We use the same pc/oopMap repeatedly when we call out
1975 
1976   Label native_return;
1977   __ set_last_Java_frame(sp, noreg, native_return, rscratch1);
1978 
1979   Label dtrace_method_entry, dtrace_method_entry_done;
1980   {
1981     unsigned long offset;
1982     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
1983     __ ldrb(rscratch1, Address(rscratch1, offset));
1984     __ cbnzw(rscratch1, dtrace_method_entry);
1985     __ bind(dtrace_method_entry_done);
1986   }
1987 
1988   // RedefineClasses() tracing support for obsolete method entry
1989   if (log_is_enabled(Trace, redefine, class, obsolete)) {
1990     // protect the args we&#39;ve loaded
1991     save_args(masm, total_c_args, c_arg, out_regs);
1992     __ mov_metadata(c_rarg1, method());
1993     __ call_VM_leaf(
1994       CAST_FROM_FN_PTR(address, SharedRuntime::rc_trace_method_entry),
1995       rthread, c_rarg1);
1996     restore_args(masm, total_c_args, c_arg, out_regs);
1997   }
1998 
1999   // Lock a synchronized method
2000 
2001   // Register definitions used by locking and unlocking
2002 
2003   const Register swap_reg = r0;
2004   const Register obj_reg  = r19;  // Will contain the oop
2005   const Register lock_reg = r13;  // Address of compiler lock object (BasicLock)
2006   const Register old_hdr  = r13;  // value of old header at unlock time
2007   const Register tmp = lr;
2008 
2009   Label slow_path_lock;
2010   Label lock_done;
2011 
2012   if (method-&gt;is_synchronized()) {
2013     assert(!is_critical_native, &quot;unhandled&quot;);
2014 
2015     const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();
2016 
2017     // Get the handle (the 2nd argument)
2018     __ mov(oop_handle_reg, c_rarg1);
2019 
2020     // Get address of the box
2021 
2022     __ lea(lock_reg, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2023 
2024     // Load the oop from the handle
2025     __ ldr(obj_reg, Address(oop_handle_reg, 0));
2026 
2027     __ resolve(IS_NOT_NULL, obj_reg);
2028 
2029     if (UseBiasedLocking) {
2030       __ biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, lock_done, &amp;slow_path_lock);
2031     }
2032 
2033     // Load (object-&gt;mark() | 1) into swap_reg %r0
2034     __ ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2035     __ orr(swap_reg, rscratch1, 1);
2036 
2037     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
2038     __ str(swap_reg, Address(lock_reg, mark_word_offset));
2039 
2040     // src -&gt; dest iff dest == r0 else r0 &lt;- dest
2041     { Label here;
2042       __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, lock_done, /*fallthrough*/NULL);
2043     }
2044 
2045     // Hmm should this move to the slow path code area???
2046 
2047     // Test if the oopMark is an obvious stack pointer, i.e.,
2048     //  1) (mark &amp; 3) == 0, and
2049     //  2) sp &lt;= mark &lt; mark + os::pagesize()
2050     // These 3 tests can be done by evaluating the following
2051     // expression: ((mark - sp) &amp; (3 - os::vm_page_size())),
2052     // assuming both stack pointer and pagesize have their
2053     // least significant 2 bits clear.
2054     // NOTE: the oopMark is in swap_reg %r0 as the result of cmpxchg
2055 
2056     __ sub(swap_reg, sp, swap_reg);
2057     __ neg(swap_reg, swap_reg);
2058     __ ands(swap_reg, swap_reg, 3 - os::vm_page_size());
2059 
2060     // Save the test result, for recursive case, the result is zero
2061     __ str(swap_reg, Address(lock_reg, mark_word_offset));
2062     __ br(Assembler::NE, slow_path_lock);
2063 
2064     // Slow path will re-enter here
2065 
2066     __ bind(lock_done);
2067   }
2068 
2069 
2070   // Finally just about ready to make the JNI call
2071 
2072   // get JNIEnv* which is first argument to native
2073   if (!is_critical_native) {
2074     __ lea(c_rarg0, Address(rthread, in_bytes(JavaThread::jni_environment_offset())));
2075   }
2076 
2077   // Now set thread in native
2078   __ mov(rscratch1, _thread_in_native);
2079   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
2080   __ stlrw(rscratch1, rscratch2);
2081 
2082   rt_call(masm, native_func);
2083 
2084   __ bind(native_return);
2085 
2086   intptr_t return_pc = (intptr_t) __ pc();
2087   oop_maps-&gt;add_gc_map(return_pc - start, map);
2088 
2089   // Unpack native results.
2090   switch (ret_type) {
2091   case T_BOOLEAN: __ c2bool(r0);                     break;
2092   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
2093   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
2094   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
2095   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
2096   case T_DOUBLE :
2097   case T_FLOAT  :
2098     // Result is in v0 we&#39;ll save as needed
2099     break;
2100   case T_ARRAY:                 // Really a handle
2101   case T_INLINE_TYPE:
2102   case T_OBJECT:                // Really a handle
2103       break; // can&#39;t de-handlize until after safepoint check
2104   case T_VOID: break;
2105   case T_LONG: break;
2106   default       : ShouldNotReachHere();
2107   }
2108 
2109   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
2110   // This additional state is necessary because reading and testing the synchronization
2111   // state is not atomic w.r.t. GC, as this scenario demonstrates:
2112   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
2113   //     VM thread changes sync state to synchronizing and suspends threads for GC.
2114   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
2115   //     didn&#39;t see any synchronization is progress, and escapes.
2116   __ mov(rscratch1, _thread_in_native_trans);
2117 
2118   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
2119 
2120   // Force this write out before the read below
2121   __ dmb(Assembler::ISH);
2122 
2123   // check for safepoint operation in progress and/or pending suspend requests
2124   Label safepoint_in_progress, safepoint_in_progress_done;
2125   {
2126     __ safepoint_poll_acquire(safepoint_in_progress);
2127     __ ldrw(rscratch1, Address(rthread, JavaThread::suspend_flags_offset()));
2128     __ cbnzw(rscratch1, safepoint_in_progress);
2129     __ bind(safepoint_in_progress_done);
2130   }
2131 
2132   // change thread state
2133   Label after_transition;
2134   __ mov(rscratch1, _thread_in_Java);
2135   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
2136   __ stlrw(rscratch1, rscratch2);
2137   __ bind(after_transition);
2138 
2139   Label reguard;
2140   Label reguard_done;
2141   __ ldrb(rscratch1, Address(rthread, JavaThread::stack_guard_state_offset()));
2142   __ cmpw(rscratch1, JavaThread::stack_guard_yellow_reserved_disabled);
2143   __ br(Assembler::EQ, reguard);
2144   __ bind(reguard_done);
2145 
2146   // native result if any is live
2147 
2148   // Unlock
2149   Label unlock_done;
2150   Label slow_path_unlock;
2151   if (method-&gt;is_synchronized()) {
2152 
2153     // Get locked oop from the handle we passed to jni
2154     __ ldr(obj_reg, Address(oop_handle_reg, 0));
2155 
2156     __ resolve(IS_NOT_NULL, obj_reg);
2157 
2158     Label done;
2159 
2160     if (UseBiasedLocking) {
2161       __ biased_locking_exit(obj_reg, old_hdr, done);
2162     }
2163 
2164     // Simple recursive lock?
2165 
2166     __ ldr(rscratch1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2167     __ cbz(rscratch1, done);
2168 
2169     // Must save r0 if if it is live now because cmpxchg must use it
2170     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2171       save_native_result(masm, ret_type, stack_slots);
2172     }
2173 
2174 
2175     // get address of the stack lock
2176     __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2177     //  get old displaced header
2178     __ ldr(old_hdr, Address(r0, 0));
2179 
2180     // Atomic swap old header if oop still contains the stack lock
2181     Label succeed;
2182     __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, succeed, &amp;slow_path_unlock);
2183     __ bind(succeed);
2184 
2185     // slow path re-enters here
2186     __ bind(unlock_done);
2187     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2188       restore_native_result(masm, ret_type, stack_slots);
2189     }
2190 
2191     __ bind(done);
2192   }
2193 
2194   Label dtrace_method_exit, dtrace_method_exit_done;
2195   {
2196     unsigned long offset;
2197     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
2198     __ ldrb(rscratch1, Address(rscratch1, offset));
2199     __ cbnzw(rscratch1, dtrace_method_exit);
2200     __ bind(dtrace_method_exit_done);
2201   }
2202 
2203   __ reset_last_Java_frame(false);
2204 
2205   // Unbox oop result, e.g. JNIHandles::resolve result.
2206   if (is_reference_type(ret_type)) {
2207     __ resolve_jobject(r0, rthread, rscratch2);
2208   }
2209 
2210   if (CheckJNICalls) {
2211     // clear_pending_jni_exception_check
2212     __ str(zr, Address(rthread, JavaThread::pending_jni_exception_check_fn_offset()));
2213   }
2214 
2215   if (!is_critical_native) {
2216     // reset handle block
2217     __ ldr(r2, Address(rthread, JavaThread::active_handles_offset()));
2218     __ str(zr, Address(r2, JNIHandleBlock::top_offset_in_bytes()));
2219   }
2220 
2221   __ leave();
2222 
2223   if (!is_critical_native) {
2224     // Any exception pending?
2225     __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2226     __ cbnz(rscratch1, exception_pending);
2227   }
2228 
2229   // We&#39;re done
2230   __ ret(lr);
2231 
2232   // Unexpected paths are out of line and go here
2233 
2234   if (!is_critical_native) {
2235     // forward the exception
2236     __ bind(exception_pending);
2237 
2238     // and forward the exception
2239     __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2240   }
2241 
2242   // Slow path locking &amp; unlocking
2243   if (method-&gt;is_synchronized()) {
2244 
2245     __ block_comment(&quot;Slow path lock {&quot;);
2246     __ bind(slow_path_lock);
2247 
2248     // has last_Java_frame setup. No exceptions so do vanilla call not call_VM
2249     // args are (oop obj, BasicLock* lock, JavaThread* thread)
2250 
2251     // protect the args we&#39;ve loaded
2252     save_args(masm, total_c_args, c_arg, out_regs);
2253 
2254     __ mov(c_rarg0, obj_reg);
2255     __ mov(c_rarg1, lock_reg);
2256     __ mov(c_rarg2, rthread);
2257 
2258     // Not a leaf but we have last_Java_frame setup as we want
2259     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C), 3);
2260     restore_args(masm, total_c_args, c_arg, out_regs);
2261 
2262 #ifdef ASSERT
2263     { Label L;
2264       __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2265       __ cbz(rscratch1, L);
2266       __ stop(&quot;no pending exception allowed on exit from monitorenter&quot;);
2267       __ bind(L);
2268     }
2269 #endif
2270     __ b(lock_done);
2271 
2272     __ block_comment(&quot;} Slow path lock&quot;);
2273 
2274     __ block_comment(&quot;Slow path unlock {&quot;);
2275     __ bind(slow_path_unlock);
2276 
2277     // If we haven&#39;t already saved the native result we must save it now as xmm registers
2278     // are still exposed.
2279 
2280     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2281       save_native_result(masm, ret_type, stack_slots);
2282     }
2283 
2284     __ mov(c_rarg2, rthread);
2285     __ lea(c_rarg1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2286     __ mov(c_rarg0, obj_reg);
2287 
2288     // Save pending exception around call to VM (which contains an EXCEPTION_MARK)
2289     // NOTE that obj_reg == r19 currently
2290     __ ldr(r19, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2291     __ str(zr, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2292 
2293     rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C));
2294 
2295 #ifdef ASSERT
2296     {
2297       Label L;
2298       __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2299       __ cbz(rscratch1, L);
2300       __ stop(&quot;no pending exception allowed on exit complete_monitor_unlocking_C&quot;);
2301       __ bind(L);
2302     }
2303 #endif /* ASSERT */
2304 
2305     __ str(r19, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2306 
2307     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2308       restore_native_result(masm, ret_type, stack_slots);
2309     }
2310     __ b(unlock_done);
2311 
2312     __ block_comment(&quot;} Slow path unlock&quot;);
2313 
2314   } // synchronized
2315 
2316   // SLOW PATH Reguard the stack if needed
2317 
2318   __ bind(reguard);
2319   save_native_result(masm, ret_type, stack_slots);
2320   rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));
2321   restore_native_result(masm, ret_type, stack_slots);
2322   // and continue
2323   __ b(reguard_done);
2324 
2325   // SLOW PATH safepoint
2326   {
2327     __ block_comment(&quot;safepoint {&quot;);
2328     __ bind(safepoint_in_progress);
2329 
2330     // Don&#39;t use call_VM as it will see a possible pending exception and forward it
2331     // and never return here preventing us from clearing _last_native_pc down below.
2332     //
2333     save_native_result(masm, ret_type, stack_slots);
2334     __ mov(c_rarg0, rthread);
2335 #ifndef PRODUCT
2336   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2337 #endif
2338     if (!is_critical_native) {
2339       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
2340     } else {
2341       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)));
2342     }
2343     __ blr(rscratch1);
2344     __ maybe_isb();
2345     // Restore any method result value
2346     restore_native_result(masm, ret_type, stack_slots);
2347 
2348     if (is_critical_native) {
2349       // The call above performed the transition to thread_in_Java so
2350       // skip the transition logic above.
2351       __ b(after_transition);
2352     }
2353 
2354     __ b(safepoint_in_progress_done);
2355     __ block_comment(&quot;} safepoint&quot;);
2356   }
2357 
2358   // SLOW PATH dtrace support
2359   {
2360     __ block_comment(&quot;dtrace entry {&quot;);
2361     __ bind(dtrace_method_entry);
2362 
2363     // We have all of the arguments setup at this point. We must not touch any register
2364     // argument registers at this point (what if we save/restore them there are no oop?
2365 
2366     save_args(masm, total_c_args, c_arg, out_regs);
2367     __ mov_metadata(c_rarg1, method());
2368     __ call_VM_leaf(
2369       CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),
2370       rthread, c_rarg1);
2371     restore_args(masm, total_c_args, c_arg, out_regs);
2372     __ b(dtrace_method_entry_done);
2373     __ block_comment(&quot;} dtrace entry&quot;);
2374   }
2375 
2376   {
2377     __ block_comment(&quot;dtrace exit {&quot;);
2378     __ bind(dtrace_method_exit);
2379     save_native_result(masm, ret_type, stack_slots);
2380     __ mov_metadata(c_rarg1, method());
2381     __ call_VM_leaf(
2382          CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),
2383          rthread, c_rarg1);
2384     restore_native_result(masm, ret_type, stack_slots);
2385     __ b(dtrace_method_exit_done);
2386     __ block_comment(&quot;} dtrace exit&quot;);
2387   }
2388 
2389 
2390   __ flush();
2391 
2392   nmethod *nm = nmethod::new_native_nmethod(method,
2393                                             compile_id,
2394                                             masm-&gt;code(),
2395                                             vep_offset,
2396                                             frame_complete,
2397                                             stack_slots / VMRegImpl::slots_per_word,
2398                                             (is_static ? in_ByteSize(klass_offset) : in_ByteSize(receiver_offset)),
2399                                             in_ByteSize(lock_slot_offset*VMRegImpl::stack_slot_size),
2400                                             oop_maps);
2401 
2402   if (is_critical_native) {
2403     nm-&gt;set_lazy_critical_native(true);
2404   }
2405 
2406   return nm;
2407 
2408 }
2409 
2410 // this function returns the adjust size (in number of words) to a c2i adapter
2411 // activation for use during deoptimization
2412 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals) {
2413   assert(callee_locals &gt;= callee_parameters,
2414           &quot;test and remove; got more parms than locals&quot;);
2415   if (callee_locals &lt; callee_parameters)
2416     return 0;                   // No adjustment for negative locals
2417   int diff = (callee_locals - callee_parameters) * Interpreter::stackElementWords;
2418   // diff is counted in stack words
2419   return align_up(diff, 2);
2420 }
2421 
2422 
2423 //------------------------------generate_deopt_blob----------------------------
2424 void SharedRuntime::generate_deopt_blob() {
2425   // Allocate space for the code
2426   ResourceMark rm;
2427   // Setup code generation tools
2428   int pad = 0;
2429 #if INCLUDE_JVMCI
2430   if (EnableJVMCI || UseAOT) {
2431     pad += 512; // Increase the buffer size when compiling for JVMCI
2432   }
2433 #endif
2434   CodeBuffer buffer(&quot;deopt_blob&quot;, 2048+pad, 1024);
2435   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2436   int frame_size_in_words;
2437   OopMap* map = NULL;
2438   OopMapSet *oop_maps = new OopMapSet();
2439 
2440   // -------------
2441   // This code enters when returning to a de-optimized nmethod.  A return
2442   // address has been pushed on the the stack, and return values are in
2443   // registers.
2444   // If we are doing a normal deopt then we were called from the patched
2445   // nmethod from the point we returned to the nmethod. So the return
2446   // address on the stack is wrong by NativeCall::instruction_size
2447   // We will adjust the value so it looks like we have the original return
2448   // address on the stack (like when we eagerly deoptimized).
2449   // In the case of an exception pending when deoptimizing, we enter
2450   // with a return address on the stack that points after the call we patched
2451   // into the exception handler. We have the following register state from,
2452   // e.g., the forward exception stub (see stubGenerator_x86_64.cpp).
2453   //    r0: exception oop
2454   //    r19: exception handler
2455   //    r3: throwing pc
2456   // So in this case we simply jam r3 into the useless return address and
2457   // the stack looks just like we want.
2458   //
2459   // At this point we need to de-opt.  We save the argument return
2460   // registers.  We call the first C routine, fetch_unroll_info().  This
2461   // routine captures the return values and returns a structure which
2462   // describes the current frame size and the sizes of all replacement frames.
2463   // The current frame is compiled code and may contain many inlined
2464   // functions, each with their own JVM state.  We pop the current frame, then
2465   // push all the new frames.  Then we call the C routine unpack_frames() to
2466   // populate these frames.  Finally unpack_frames() returns us the new target
2467   // address.  Notice that callee-save registers are BLOWN here; they have
2468   // already been captured in the vframeArray at the time the return PC was
2469   // patched.
2470   address start = __ pc();
2471   Label cont;
2472 
2473   // Prolog for non exception case!
2474 
2475   // Save everything in sight.
2476   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2477 
2478   // Normal deoptimization.  Save exec mode for unpack_frames.
2479   __ movw(rcpool, Deoptimization::Unpack_deopt); // callee-saved
2480   __ b(cont);
2481 
2482   int reexecute_offset = __ pc() - start;
2483 #if INCLUDE_JVMCI &amp;&amp; !defined(COMPILER1)
2484   if (EnableJVMCI &amp;&amp; UseJVMCICompiler) {
2485     // JVMCI does not use this kind of deoptimization
2486     __ should_not_reach_here();
2487   }
2488 #endif
2489 
2490   // Reexecute case
2491   // return address is the pc describes what bci to do re-execute at
2492 
2493   // No need to update map as each call to save_live_registers will produce identical oopmap
2494   (void) RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2495 
2496   __ movw(rcpool, Deoptimization::Unpack_reexecute); // callee-saved
2497   __ b(cont);
2498 
2499 #if INCLUDE_JVMCI
2500   Label after_fetch_unroll_info_call;
2501   int implicit_exception_uncommon_trap_offset = 0;
2502   int uncommon_trap_offset = 0;
2503 
2504   if (EnableJVMCI || UseAOT) {
2505     implicit_exception_uncommon_trap_offset = __ pc() - start;
2506 
2507     __ ldr(lr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2508     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2509 
2510     uncommon_trap_offset = __ pc() - start;
2511 
2512     // Save everything in sight.
2513     RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2514     // fetch_unroll_info needs to call last_java_frame()
2515     Label retaddr;
2516     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2517 
2518     __ ldrw(c_rarg1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2519     __ movw(rscratch1, -1);
2520     __ strw(rscratch1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2521 
2522     __ movw(rcpool, (int32_t)Deoptimization::Unpack_reexecute);
2523     __ mov(c_rarg0, rthread);
2524     __ movw(c_rarg2, rcpool); // exec mode
2525     __ lea(rscratch1,
2526            RuntimeAddress(CAST_FROM_FN_PTR(address,
2527                                            Deoptimization::uncommon_trap)));
2528     __ blr(rscratch1);
2529     __ bind(retaddr);
2530     oop_maps-&gt;add_gc_map( __ pc()-start, map-&gt;deep_copy());
2531 
2532     __ reset_last_Java_frame(false);
2533 
2534     __ b(after_fetch_unroll_info_call);
2535   } // EnableJVMCI
2536 #endif // INCLUDE_JVMCI
2537 
2538   int exception_offset = __ pc() - start;
2539 
2540   // Prolog for exception case
2541 
2542   // all registers are dead at this entry point, except for r0, and
2543   // r3 which contain the exception oop and exception pc
2544   // respectively.  Set them in TLS and fall thru to the
2545   // unpack_with_exception_in_tls entry point.
2546 
2547   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
2548   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
2549 
2550   int exception_in_tls_offset = __ pc() - start;
2551 
2552   // new implementation because exception oop is now passed in JavaThread
2553 
2554   // Prolog for exception case
2555   // All registers must be preserved because they might be used by LinearScan
2556   // Exceptiop oop and throwing PC are passed in JavaThread
2557   // tos: stack at point of call to method that threw the exception (i.e. only
2558   // args are on the stack, no return address)
2559 
2560   // The return address pushed by save_live_registers will be patched
2561   // later with the throwing pc. The correct value is not available
2562   // now because loading it from memory would destroy registers.
2563 
2564   // NB: The SP at this point must be the SP of the method that is
2565   // being deoptimized.  Deoptimization assumes that the frame created
2566   // here by save_live_registers is immediately below the method&#39;s SP.
2567   // This is a somewhat fragile mechanism.
2568 
2569   // Save everything in sight.
2570   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2571 
2572   // Now it is safe to overwrite any register
2573 
2574   // Deopt during an exception.  Save exec mode for unpack_frames.
2575   __ mov(rcpool, Deoptimization::Unpack_exception); // callee-saved
2576 
2577   // load throwing pc from JavaThread and patch it as the return address
2578   // of the current frame. Then clear the field in JavaThread
2579 
2580   __ ldr(r3, Address(rthread, JavaThread::exception_pc_offset()));
2581   __ str(r3, Address(rfp, wordSize));
2582   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
2583 
2584 #ifdef ASSERT
2585   // verify that there is really an exception oop in JavaThread
2586   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
2587   __ verify_oop(r0);
2588 
2589   // verify that there is no pending exception
2590   Label no_pending_exception;
2591   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2592   __ cbz(rscratch1, no_pending_exception);
2593   __ stop(&quot;must not have pending exception here&quot;);
2594   __ bind(no_pending_exception);
2595 #endif
2596 
2597   __ bind(cont);
2598 
2599   // Call C code.  Need thread and this frame, but NOT official VM entry
2600   // crud.  We cannot block on this call, no GC can happen.
2601   //
2602   // UnrollBlock* fetch_unroll_info(JavaThread* thread)
2603 
2604   // fetch_unroll_info needs to call last_java_frame().
2605 
2606   Label retaddr;
2607   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2608 #ifdef ASSERT0
2609   { Label L;
2610     __ ldr(rscratch1, Address(rthread,
2611                               JavaThread::last_Java_fp_offset()));
2612     __ cbz(rscratch1, L);
2613     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
2614     __ bind(L);
2615   }
2616 #endif // ASSERT
2617   __ mov(c_rarg0, rthread);
2618   __ mov(c_rarg1, rcpool);
2619   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)));
2620   __ blr(rscratch1);
2621   __ bind(retaddr);
2622 
2623   // Need to have an oopmap that tells fetch_unroll_info where to
2624   // find any register it might need.
2625   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2626 
2627   __ reset_last_Java_frame(false);
2628 
2629 #if INCLUDE_JVMCI
2630   if (EnableJVMCI || UseAOT) {
2631     __ bind(after_fetch_unroll_info_call);
2632   }
2633 #endif
2634 
2635   // Load UnrollBlock* into r5
2636   __ mov(r5, r0);
2637 
2638   __ ldrw(rcpool, Address(r5, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2639    Label noException;
2640   __ cmpw(rcpool, Deoptimization::Unpack_exception);   // Was exception pending?
2641   __ br(Assembler::NE, noException);
2642   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
2643   // QQQ this is useless it was NULL above
2644   __ ldr(r3, Address(rthread, JavaThread::exception_pc_offset()));
2645   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
2646   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
2647 
2648   __ verify_oop(r0);
2649 
2650   // Overwrite the result registers with the exception results.
2651   __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2652   // I think this is useless
2653   // __ str(r3, Address(sp, RegisterSaver::r3_offset_in_bytes()));
2654 
2655   __ bind(noException);
2656 
2657   // Only register save data is on the stack.
2658   // Now restore the result registers.  Everything else is either dead
2659   // or captured in the vframeArray.
2660   RegisterSaver::restore_result_registers(masm);
2661 
2662   // All of the register save area has been popped of the stack. Only the
2663   // return address remains.
2664 
2665   // Pop all the frames we must move/replace.
2666   //
2667   // Frame picture (youngest to oldest)
2668   // 1: self-frame (no frame link)
2669   // 2: deopting frame  (no frame link)
2670   // 3: caller of deopting frame (could be compiled/interpreted).
2671   //
2672   // Note: by leaving the return address of self-frame on the stack
2673   // and using the size of frame 2 to adjust the stack
2674   // when we are done the return to frame 3 will still be on the stack.
2675 
2676   // Pop deoptimized frame
2677   __ ldrw(r2, Address(r5, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
2678   __ sub(r2, r2, 2 * wordSize);
2679   __ add(sp, sp, r2);
2680   __ ldp(rfp, lr, __ post(sp, 2 * wordSize));
2681   // LR should now be the return address to the caller (3)
2682 
2683 #ifdef ASSERT
2684   // Compilers generate code that bang the stack by as much as the
2685   // interpreter would need. So this stack banging should never
2686   // trigger a fault. Verify that it does not on non product builds.
2687   if (UseStackBanging) {
2688     __ ldrw(r19, Address(r5, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
2689     __ bang_stack_size(r19, r2);
2690   }
2691 #endif
2692   // Load address of array of frame pcs into r2
2693   __ ldr(r2, Address(r5, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2694 
2695   // Trash the old pc
2696   // __ addptr(sp, wordSize);  FIXME ????
2697 
2698   // Load address of array of frame sizes into r4
2699   __ ldr(r4, Address(r5, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
2700 
2701   // Load counter into r3
2702   __ ldrw(r3, Address(r5, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
2703 
2704   // Now adjust the caller&#39;s stack to make up for the extra locals
2705   // but record the original sp so that we can save it in the skeletal interpreter
2706   // frame and the stack walking of interpreter_sender will get the unextended sp
2707   // value and not the &quot;real&quot; sp value.
2708 
2709   const Register sender_sp = r6;
2710 
2711   __ mov(sender_sp, sp);
2712   __ ldrw(r19, Address(r5,
2713                        Deoptimization::UnrollBlock::
2714                        caller_adjustment_offset_in_bytes()));
2715   __ sub(sp, sp, r19);
2716 
2717   // Push interpreter frames in a loop
2718   __ mov(rscratch1, (address)0xDEADDEAD);        // Make a recognizable pattern
2719   __ mov(rscratch2, rscratch1);
2720   Label loop;
2721   __ bind(loop);
2722   __ ldr(r19, Address(__ post(r4, wordSize)));          // Load frame size
2723   __ sub(r19, r19, 2*wordSize);           // We&#39;ll push pc and fp by hand
2724   __ ldr(lr, Address(__ post(r2, wordSize)));  // Load pc
2725   __ enter();                           // Save old &amp; set new fp
2726   __ sub(sp, sp, r19);                  // Prolog
2727   // This value is corrected by layout_activation_impl
2728   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
2729   __ str(sender_sp, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize)); // Make it walkable
2730   __ mov(sender_sp, sp);               // Pass sender_sp to next frame
2731   __ sub(r3, r3, 1);                   // Decrement counter
2732   __ cbnz(r3, loop);
2733 
2734     // Re-push self-frame
2735   __ ldr(lr, Address(r2));
2736   __ enter();
2737 
2738   // Allocate a full sized register save area.  We subtract 2 because
2739   // enter() just pushed 2 words
2740   __ sub(sp, sp, (frame_size_in_words - 2) * wordSize);
2741 
2742   // Restore frame locals after moving the frame
2743   __ strd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2744   __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2745 
2746   // Call C code.  Need thread but NOT official VM entry
2747   // crud.  We cannot block on this call, no GC can happen.  Call should
2748   // restore return values to their stack-slots with the new SP.
2749   //
2750   // void Deoptimization::unpack_frames(JavaThread* thread, int exec_mode)
2751 
2752   // Use rfp because the frames look interpreted now
2753   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2754   address the_pc = __ pc();
2755   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2756 
2757   __ mov(c_rarg0, rthread);
2758   __ movw(c_rarg1, rcpool); // second arg: exec_mode
2759   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
2760   __ blr(rscratch1);
2761 
2762   // Set an oopmap for the call site
2763   // Use the same PC we used for the last java frame
2764   oop_maps-&gt;add_gc_map(the_pc - start,
2765                        new OopMap( frame_size_in_words, 0 ));
2766 
2767   // Clear fp AND pc
2768   __ reset_last_Java_frame(true);
2769 
2770   // Collect return values
2771   __ ldrd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2772   __ ldr(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2773   // I think this is useless (throwing pc?)
2774   // __ ldr(r3, Address(sp, RegisterSaver::r3_offset_in_bytes()));
2775 
2776   // Pop self-frame.
2777   __ leave();                           // Epilog
2778 
2779   // Jump to interpreter
2780   __ ret(lr);
2781 
2782   // Make sure all code is generated
2783   masm-&gt;flush();
2784 
2785   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);
2786   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
2787 #if INCLUDE_JVMCI
2788   if (EnableJVMCI || UseAOT) {
2789     _deopt_blob-&gt;set_uncommon_trap_offset(uncommon_trap_offset);
2790     _deopt_blob-&gt;set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);
2791   }
2792 #endif
2793 }
2794 
2795 uint SharedRuntime::out_preserve_stack_slots() {
2796   return 0;
2797 }
2798 
2799 #ifdef COMPILER2
2800 //------------------------------generate_uncommon_trap_blob--------------------
2801 void SharedRuntime::generate_uncommon_trap_blob() {
2802   // Allocate space for the code
2803   ResourceMark rm;
2804   // Setup code generation tools
2805   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
2806   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2807 
2808   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
2809 
2810   address start = __ pc();
2811 
2812   // Push self-frame.  We get here with a return address in LR
2813   // and sp should be 16 byte aligned
2814   // push rfp and retaddr by hand
2815   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
2816   // we don&#39;t expect an arg reg save area
2817 #ifndef PRODUCT
2818   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2819 #endif
2820   // compiler left unloaded_class_index in j_rarg0 move to where the
2821   // runtime expects it.
2822   if (c_rarg1 != j_rarg0) {
2823     __ movw(c_rarg1, j_rarg0);
2824   }
2825 
2826   // we need to set the past SP to the stack pointer of the stub frame
2827   // and the pc to the address where this runtime call will return
2828   // although actually any pc in this code blob will do).
2829   Label retaddr;
2830   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2831 
2832   // Call C code.  Need thread but NOT official VM entry
2833   // crud.  We cannot block on this call, no GC can happen.  Call should
2834   // capture callee-saved registers as well as return values.
2835   // Thread is in rdi already.
2836   //
2837   // UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);
2838   //
2839   // n.b. 2 gp args, 0 fp args, integral return type
2840 
2841   __ mov(c_rarg0, rthread);
2842   __ movw(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);
2843   __ lea(rscratch1,
2844          RuntimeAddress(CAST_FROM_FN_PTR(address,
2845                                          Deoptimization::uncommon_trap)));
2846   __ blr(rscratch1);
2847   __ bind(retaddr);
2848 
2849   // Set an oopmap for the call site
2850   OopMapSet* oop_maps = new OopMapSet();
2851   OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);
2852 
2853   // location of rfp is known implicitly by the frame sender code
2854 
2855   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2856 
2857   __ reset_last_Java_frame(false);
2858 
2859   // move UnrollBlock* into r4
2860   __ mov(r4, r0);
2861 
2862 #ifdef ASSERT
2863   { Label L;
2864     __ ldrw(rscratch1, Address(r4, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2865     __ cmpw(rscratch1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2866     __ br(Assembler::EQ, L);
2867     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
2868     __ bind(L);
2869   }
2870 #endif
2871 
2872   // Pop all the frames we must move/replace.
2873   //
2874   // Frame picture (youngest to oldest)
2875   // 1: self-frame (no frame link)
2876   // 2: deopting frame  (no frame link)
2877   // 3: caller of deopting frame (could be compiled/interpreted).
2878 
2879   // Pop self-frame.  We have no frame, and must rely only on r0 and sp.
2880   __ add(sp, sp, (SimpleRuntimeFrame::framesize) &lt;&lt; LogBytesPerInt); // Epilog!
2881 
2882   // Pop deoptimized frame (int)
2883   __ ldrw(r2, Address(r4,
2884                       Deoptimization::UnrollBlock::
2885                       size_of_deoptimized_frame_offset_in_bytes()));
2886   __ sub(r2, r2, 2 * wordSize);
2887   __ add(sp, sp, r2);
2888   __ ldp(rfp, lr, __ post(sp, 2 * wordSize));
2889   // LR should now be the return address to the caller (3) frame
2890 
2891 #ifdef ASSERT
2892   // Compilers generate code that bang the stack by as much as the
2893   // interpreter would need. So this stack banging should never
2894   // trigger a fault. Verify that it does not on non product builds.
2895   if (UseStackBanging) {
2896     __ ldrw(r1, Address(r4,
2897                         Deoptimization::UnrollBlock::
2898                         total_frame_sizes_offset_in_bytes()));
2899     __ bang_stack_size(r1, r2);
2900   }
2901 #endif
2902 
2903   // Load address of array of frame pcs into r2 (address*)
2904   __ ldr(r2, Address(r4,
2905                      Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2906 
2907   // Load address of array of frame sizes into r5 (intptr_t*)
2908   __ ldr(r5, Address(r4,
2909                      Deoptimization::UnrollBlock::
2910                      frame_sizes_offset_in_bytes()));
2911 
2912   // Counter
2913   __ ldrw(r3, Address(r4,
2914                       Deoptimization::UnrollBlock::
2915                       number_of_frames_offset_in_bytes())); // (int)
2916 
2917   // Now adjust the caller&#39;s stack to make up for the extra locals but
2918   // record the original sp so that we can save it in the skeletal
2919   // interpreter frame and the stack walking of interpreter_sender
2920   // will get the unextended sp value and not the &quot;real&quot; sp value.
2921 
2922   const Register sender_sp = r8;
2923 
2924   __ mov(sender_sp, sp);
2925   __ ldrw(r1, Address(r4,
2926                       Deoptimization::UnrollBlock::
2927                       caller_adjustment_offset_in_bytes())); // (int)
2928   __ sub(sp, sp, r1);
2929 
2930   // Push interpreter frames in a loop
2931   Label loop;
2932   __ bind(loop);
2933   __ ldr(r1, Address(r5, 0));       // Load frame size
2934   __ sub(r1, r1, 2 * wordSize);     // We&#39;ll push pc and rfp by hand
2935   __ ldr(lr, Address(r2, 0));       // Save return address
2936   __ enter();                       // and old rfp &amp; set new rfp
2937   __ sub(sp, sp, r1);               // Prolog
2938   __ str(sender_sp, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize)); // Make it walkable
2939   // This value is corrected by layout_activation_impl
2940   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
2941   __ mov(sender_sp, sp);          // Pass sender_sp to next frame
2942   __ add(r5, r5, wordSize);       // Bump array pointer (sizes)
2943   __ add(r2, r2, wordSize);       // Bump array pointer (pcs)
2944   __ subsw(r3, r3, 1);            // Decrement counter
2945   __ br(Assembler::GT, loop);
2946   __ ldr(lr, Address(r2, 0));     // save final return address
2947   // Re-push self-frame
2948   __ enter();                     // &amp; old rfp &amp; set new rfp
2949 
2950   // Use rfp because the frames look interpreted now
2951   // Save &quot;the_pc&quot; since it cannot easily be retrieved using the last_java_SP after we aligned SP.
2952   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2953   address the_pc = __ pc();
2954   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2955 
2956   // Call C code.  Need thread but NOT official VM entry
2957   // crud.  We cannot block on this call, no GC can happen.  Call should
2958   // restore return values to their stack-slots with the new SP.
2959   // Thread is in rdi already.
2960   //
2961   // BasicType unpack_frames(JavaThread* thread, int exec_mode);
2962   //
2963   // n.b. 2 gp args, 0 fp args, integral return type
2964 
2965   // sp should already be aligned
2966   __ mov(c_rarg0, rthread);
2967   __ movw(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2968   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
2969   __ blr(rscratch1);
2970 
2971   // Set an oopmap for the call site
2972   // Use the same PC we used for the last java frame
2973   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
2974 
2975   // Clear fp AND pc
2976   __ reset_last_Java_frame(true);
2977 
2978   // Pop self-frame.
2979   __ leave();                 // Epilog
2980 
2981   // Jump to interpreter
2982   __ ret(lr);
2983 
2984   // Make sure all code is generated
2985   masm-&gt;flush();
2986 
2987   _uncommon_trap_blob =  UncommonTrapBlob::create(&amp;buffer, oop_maps,
2988                                                  SimpleRuntimeFrame::framesize &gt;&gt; 1);
2989 }
2990 #endif // COMPILER2
2991 
2992 
2993 //------------------------------generate_handler_blob------
2994 //
2995 // Generate a special Compile2Runtime blob that saves all registers,
2996 // and setup oopmap.
2997 //
2998 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
2999   ResourceMark rm;
3000   OopMapSet *oop_maps = new OopMapSet();
3001   OopMap* map;
3002 
3003   // Allocate space for the code.  Setup code generation tools.
3004   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
3005   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3006 
3007   address start   = __ pc();
3008   address call_pc = NULL;
3009   int frame_size_in_words;
3010   bool cause_return = (poll_type == POLL_AT_RETURN);
3011   bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
3012 
3013   // Save Integer and Float registers.
3014   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words, save_vectors);
3015 
3016   // The following is basically a call_VM.  However, we need the precise
3017   // address of the call in order to generate an oopmap. Hence, we do all the
3018   // work outselves.
3019 
3020   Label retaddr;
3021   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
3022 
3023   // The return address must always be correct so that frame constructor never
3024   // sees an invalid pc.
3025 
3026   if (!cause_return) {
3027     // overwrite the return address pushed by save_live_registers
3028     // Additionally, r20 is a callee-saved register so we can look at
3029     // it later to determine if someone changed the return address for
3030     // us!
3031     __ ldr(r20, Address(rthread, JavaThread::saved_exception_pc_offset()));
3032     __ str(r20, Address(rfp, wordSize));
3033   }
3034 
3035   // Do the call
3036   __ mov(c_rarg0, rthread);
3037   __ lea(rscratch1, RuntimeAddress(call_ptr));
3038   __ blr(rscratch1);
3039   __ bind(retaddr);
3040 
3041   // Set an oopmap for the call site.  This oopmap will map all
3042   // oop-registers and debug-info registers as callee-saved.  This
3043   // will allow deoptimization at this safepoint to find all possible
3044   // debug-info recordings, as well as let GC find all oops.
3045 
3046   oop_maps-&gt;add_gc_map( __ pc() - start, map);
3047 
3048   Label noException;
3049 
3050   __ reset_last_Java_frame(false);
3051 
3052   __ maybe_isb();
3053   __ membar(Assembler::LoadLoad | Assembler::LoadStore);
3054 
3055   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
3056   __ cbz(rscratch1, noException);
3057 
3058   // Exception pending
3059 
3060   RegisterSaver::restore_live_registers(masm, save_vectors);
3061 
3062   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3063 
3064   // No exception case
3065   __ bind(noException);
3066 
3067   Label no_adjust, bail;
3068   if (!cause_return) {
3069     // If our stashed return pc was modified by the runtime we avoid touching it
3070     __ ldr(rscratch1, Address(rfp, wordSize));
3071     __ cmp(r20, rscratch1);
3072     __ br(Assembler::NE, no_adjust);
3073 
3074 #ifdef ASSERT
3075     // Verify the correct encoding of the poll we&#39;re about to skip.
3076     // See NativeInstruction::is_ldrw_to_zr()
3077     __ ldrw(rscratch1, Address(r20));
3078     __ ubfx(rscratch2, rscratch1, 22, 10);
3079     __ cmpw(rscratch2, 0b1011100101);
3080     __ br(Assembler::NE, bail);
3081     __ ubfx(rscratch2, rscratch1, 0, 5);
3082     __ cmpw(rscratch2, 0b11111);
3083     __ br(Assembler::NE, bail);
3084 #endif
3085     // Adjust return pc forward to step over the safepoint poll instruction
3086     __ add(r20, r20, NativeInstruction::instruction_size);
3087     __ str(r20, Address(rfp, wordSize));
3088   }
3089 
3090   __ bind(no_adjust);
3091   // Normal exit, restore registers and exit.
3092   RegisterSaver::restore_live_registers(masm, save_vectors);
3093 
3094   __ ret(lr);
3095 
3096 #ifdef ASSERT
3097   __ bind(bail);
3098   __ stop(&quot;Attempting to adjust pc to skip safepoint poll but the return point is not what we expected&quot;);
3099 #endif
3100 
3101   // Make sure all code is generated
3102   masm-&gt;flush();
3103 
3104   // Fill-out other meta info
3105   return SafepointBlob::create(&amp;buffer, oop_maps, frame_size_in_words);
3106 }
3107 
3108 //
3109 // generate_resolve_blob - call resolution (static/virtual/opt-virtual/ic-miss
3110 //
3111 // Generate a stub that calls into vm to find out the proper destination
3112 // of a java call. All the argument registers are live at this point
3113 // but since this is generic code we don&#39;t know what they are and the caller
3114 // must do any gc of the args.
3115 //
3116 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
3117   assert (StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
3118 
3119   // allocate space for the code
3120   ResourceMark rm;
3121 
3122   CodeBuffer buffer(name, 1000, 512);
3123   MacroAssembler* masm                = new MacroAssembler(&amp;buffer);
3124 
3125   int frame_size_in_words;
3126 
3127   OopMapSet *oop_maps = new OopMapSet();
3128   OopMap* map = NULL;
3129 
3130   int start = __ offset();
3131 
3132   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
3133 
3134   int frame_complete = __ offset();
3135 
3136   {
3137     Label retaddr;
3138     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
3139 
3140     __ mov(c_rarg0, rthread);
3141     __ lea(rscratch1, RuntimeAddress(destination));
3142 
3143     __ blr(rscratch1);
3144     __ bind(retaddr);
3145   }
3146 
3147   // Set an oopmap for the call site.
3148   // We need this not only for callee-saved registers, but also for volatile
3149   // registers that the compiler might be keeping live across a safepoint.
3150 
3151   oop_maps-&gt;add_gc_map( __ offset() - start, map);
3152 
3153   __ maybe_isb();
3154 
3155   // r0 contains the address we are going to jump to assuming no exception got installed
3156 
3157   // clear last_Java_sp
3158   __ reset_last_Java_frame(false);
3159   // check for pending exceptions
3160   Label pending;
3161   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
3162   __ cbnz(rscratch1, pending);
3163 
3164   // get the returned Method*
3165   __ get_vm_result_2(rmethod, rthread);
3166   __ str(rmethod, Address(sp, RegisterSaver::reg_offset_in_bytes(rmethod)));
3167 
3168   // r0 is where we want to jump, overwrite rscratch1 which is saved and scratch
3169   __ str(r0, Address(sp, RegisterSaver::rscratch1_offset_in_bytes()));
3170   RegisterSaver::restore_live_registers(masm);
3171 
3172   // We are back the the original state on entry and ready to go.
3173 
3174   __ br(rscratch1);
3175 
3176   // Pending exception after the safepoint
3177 
3178   __ bind(pending);
3179 
3180   RegisterSaver::restore_live_registers(masm);
3181 
3182   // exception pending =&gt; remove activation and forward to exception handler
3183 
3184   __ str(zr, Address(rthread, JavaThread::vm_result_offset()));
3185 
3186   __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
3187   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3188 
3189   // -------------
3190   // make sure all code is generated
3191   masm-&gt;flush();
3192 
3193   // return the  blob
3194   // frame_size_words or bytes??
3195   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_in_words, oop_maps, true);
3196 }
3197 
3198 #ifdef COMPILER2
3199 // This is here instead of runtime_x86_64.cpp because it uses SimpleRuntimeFrame
3200 //
3201 //------------------------------generate_exception_blob---------------------------
3202 // creates exception blob at the end
3203 // Using exception blob, this code is jumped from a compiled method.
3204 // (see emit_exception_handler in x86_64.ad file)
3205 //
3206 // Given an exception pc at a call we call into the runtime for the
3207 // handler in this method. This handler might merely restore state
3208 // (i.e. callee save registers) unwind the frame and jump to the
3209 // exception handler for the nmethod if there is no Java level handler
3210 // for the nmethod.
3211 //
3212 // This code is entered with a jmp.
3213 //
3214 // Arguments:
3215 //   r0: exception oop
3216 //   r3: exception pc
3217 //
3218 // Results:
3219 //   r0: exception oop
3220 //   r3: exception pc in caller or ???
3221 //   destination: exception handler of caller
3222 //
3223 // Note: the exception pc MUST be at a call (precise debug information)
3224 //       Registers r0, r3, r2, r4, r5, r8-r11 are not callee saved.
3225 //
3226 
3227 void OptoRuntime::generate_exception_blob() {
3228   assert(!OptoRuntime::is_callee_saved_register(R3_num), &quot;&quot;);
3229   assert(!OptoRuntime::is_callee_saved_register(R0_num), &quot;&quot;);
3230   assert(!OptoRuntime::is_callee_saved_register(R2_num), &quot;&quot;);
3231 
3232   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
3233 
3234   // Allocate space for the code
3235   ResourceMark rm;
3236   // Setup code generation tools
3237   CodeBuffer buffer(&quot;exception_blob&quot;, 2048, 1024);
3238   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3239 
3240   // TODO check various assumptions made here
3241   //
3242   // make sure we do so before running this
3243 
3244   address start = __ pc();
3245 
3246   // push rfp and retaddr by hand
3247   // Exception pc is &#39;return address&#39; for stack walker
3248   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
3249   // there are no callee save registers and we don&#39;t expect an
3250   // arg reg save area
3251 #ifndef PRODUCT
3252   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
3253 #endif
3254   // Store exception in Thread object. We cannot pass any arguments to the
3255   // handle_exception call, since we do not want to make any assumption
3256   // about the size of the frame where the exception happened in.
3257   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
3258   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
3259 
3260   // This call does all the hard work.  It checks if an exception handler
3261   // exists in the method.
3262   // If so, it returns the handler address.
3263   // If not, it prepares for stack-unwinding, restoring the callee-save
3264   // registers of the frame being removed.
3265   //
3266   // address OptoRuntime::handle_exception_C(JavaThread* thread)
3267   //
3268   // n.b. 1 gp arg, 0 fp args, integral return type
3269 
3270   // the stack should always be aligned
3271   address the_pc = __ pc();
3272   __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);
3273   __ mov(c_rarg0, rthread);
3274   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));
3275   __ blr(rscratch1);
3276   __ maybe_isb();
3277 
3278   // Set an oopmap for the call site.  This oopmap will only be used if we
3279   // are unwinding the stack.  Hence, all locations will be dead.
3280   // Callee-saved registers will be the same as the frame above (i.e.,
3281   // handle_exception_stub), since they were restored when we got the
3282   // exception.
3283 
3284   OopMapSet* oop_maps = new OopMapSet();
3285 
3286   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
3287 
3288   __ reset_last_Java_frame(false);
3289 
3290   // Restore callee-saved registers
3291 
3292   // rfp is an implicitly saved callee saved register (i.e. the calling
3293   // convention will save restore it in prolog/epilog) Other than that
3294   // there are no callee save registers now that adapter frames are gone.
3295   // and we dont&#39; expect an arg reg save area
3296   __ ldp(rfp, r3, Address(__ post(sp, 2 * wordSize)));
3297 
3298   // r0: exception handler
3299 
3300   // We have a handler in r0 (could be deopt blob).
3301   __ mov(r8, r0);
3302 
3303   // Get the exception oop
3304   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
3305   // Get the exception pc in case we are deoptimized
3306   __ ldr(r4, Address(rthread, JavaThread::exception_pc_offset()));
3307 #ifdef ASSERT
3308   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3309   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3310 #endif
3311   // Clear the exception oop so GC no longer processes it as a root.
3312   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3313 
3314   // r0: exception oop
3315   // r8:  exception handler
3316   // r4: exception pc
3317   // Jump to handler
3318 
3319   __ br(r8);
3320 
3321   // Make sure all code is generated
3322   masm-&gt;flush();
3323 
3324   // Set exception blob
3325   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3326 }
3327 
3328 BufferedInlineTypeBlob* SharedRuntime::generate_buffered_inline_type_adapter(const InlineKlass* vk) {
3329   BufferBlob* buf = BufferBlob::create(&quot;inline types pack/unpack&quot;, 16 * K);
3330   CodeBuffer buffer(buf);
3331   short buffer_locs[20];
3332   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
3333                                          sizeof(buffer_locs)/sizeof(relocInfo));
3334 
3335   MacroAssembler _masm(&amp;buffer);
3336   MacroAssembler* masm = &amp;_masm;
3337 
3338   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
3339   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
3340 
3341   int pack_fields_off = __ offset();
3342 
3343   int j = 1;
3344   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3345     BasicType bt = sig_vk-&gt;at(i)._bt;
3346     if (bt == T_INLINE_TYPE) {
3347       continue;
3348     }
3349     if (bt == T_VOID) {
3350       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
3351           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
3352         j++;
3353       }
3354       continue;
3355     }
3356     int off = sig_vk-&gt;at(i)._offset;
3357     VMRegPair pair = regs-&gt;at(j);
3358     VMReg r_1 = pair.first();
3359     VMReg r_2 = pair.second();
3360     Address to(r0, off);
3361     if (bt == T_FLOAT) {
3362       __ strs(r_1-&gt;as_FloatRegister(), to);
3363     } else if (bt == T_DOUBLE) {
3364       __ strd(r_1-&gt;as_FloatRegister(), to);
3365     } else if (bt == T_OBJECT || bt == T_ARRAY) {
3366       Register val = r_1-&gt;as_Register();
3367       assert_different_registers(r0, val);
3368       // We don&#39;t need barriers because the destination is a newly allocated object.
3369       // Also, we cannot use store_heap_oop(to, val) because it uses r8 as tmp.
3370       if (UseCompressedOops) {
3371         __ encode_heap_oop(val);
3372         __ str(val, to);
3373       } else {
3374         __ str(val, to);
3375       }
3376     } else {
3377       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);
3378       assert_different_registers(r0, r_1-&gt;as_Register());
3379       size_t size_in_bytes = type2aelembytes(bt);
3380       __ store_sized_value(to, r_1-&gt;as_Register(), size_in_bytes);
3381     }
3382     j++;
3383   }
3384   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
3385 
3386   __ ret(lr);
3387 
3388   int unpack_fields_off = __ offset();
3389 
3390   j = 1;
3391   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3392     BasicType bt = sig_vk-&gt;at(i)._bt;
3393     if (bt == T_INLINE_TYPE) {
3394       continue;
3395     }
3396     if (bt == T_VOID) {
3397       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
3398           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
3399         j++;
3400       }
3401       continue;
3402     }
3403     int off = sig_vk-&gt;at(i)._offset;
3404     VMRegPair pair = regs-&gt;at(j);
3405     VMReg r_1 = pair.first();
3406     VMReg r_2 = pair.second();
3407     Address from(r0, off);
3408     if (bt == T_FLOAT) {
3409       __ ldrs(r_1-&gt;as_FloatRegister(), from);
3410     } else if (bt == T_DOUBLE) {
3411       __ ldrd(r_1-&gt;as_FloatRegister(), from);
3412     } else if (bt == T_OBJECT || bt == T_ARRAY) {
3413        assert_different_registers(r0, r_1-&gt;as_Register());
3414        __ load_heap_oop(r_1-&gt;as_Register(), from);
3415     } else {
3416       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);
3417       assert_different_registers(r0, r_1-&gt;as_Register());
3418 
3419       size_t size_in_bytes = type2aelembytes(bt);
3420       __ load_sized_value(r_1-&gt;as_Register(), from, size_in_bytes, bt != T_CHAR &amp;&amp; bt != T_BOOLEAN);
3421     }
3422     j++;
3423   }
3424   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
3425 
3426   __ ret(lr);
3427 
3428   __ flush();
3429 
3430   return BufferedInlineTypeBlob::create(&amp;buffer, pack_fields_off, unpack_fields_off);
3431 }
3432 #endif // COMPILER2
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>