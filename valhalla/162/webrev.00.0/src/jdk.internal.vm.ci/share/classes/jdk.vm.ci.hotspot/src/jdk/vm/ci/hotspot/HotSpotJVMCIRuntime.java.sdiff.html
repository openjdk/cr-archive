<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../../jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CheckGraalIntrinsics.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.InitTimer.timer;
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;
  27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  29 
  30 import java.io.IOException;
  31 import java.io.OutputStream;
  32 import java.io.PrintStream;
  33 import java.io.Serializable;
  34 import java.lang.invoke.CallSite;
  35 import java.lang.invoke.ConstantCallSite;
  36 import java.lang.invoke.MethodHandle;
  37 import java.lang.ref.WeakReference;
  38 import java.util.ArrayList;
  39 import java.util.Collections;

  40 import java.util.HashMap;
  41 import java.util.List;
  42 import java.util.Map;
  43 import java.util.Objects;
  44 import java.util.ServiceLoader;
  45 import java.util.function.Predicate;
  46 
  47 import jdk.vm.ci.code.Architecture;
  48 import jdk.vm.ci.code.CompilationRequestResult;
  49 import jdk.vm.ci.code.CompiledCode;
  50 import jdk.vm.ci.code.InstalledCode;
  51 import jdk.vm.ci.common.InitTimer;
  52 import jdk.vm.ci.common.JVMCIError;
  53 import jdk.vm.ci.common.NativeImageReinitialize;
  54 import jdk.vm.ci.meta.JavaKind;
  55 import jdk.vm.ci.meta.JavaType;
  56 import jdk.vm.ci.meta.ResolvedJavaType;
  57 import jdk.vm.ci.meta.UnresolvedJavaType;
  58 import jdk.vm.ci.runtime.JVMCI;
  59 import jdk.vm.ci.runtime.JVMCIBackend;
</pre>
<hr />
<pre>
 201             }
 202         }
 203         return result;
 204     }
 205 
 206     @VMEntryPoint
 207     static Throwable decodeThrowable(String encodedThrowable) throws Throwable {
 208         return TranslatedException.decodeThrowable(encodedThrowable);
 209     }
 210 
 211     @VMEntryPoint
 212     static String encodeThrowable(Throwable throwable) throws Throwable {
 213         return TranslatedException.encodeThrowable(throwable);
 214     }
 215 
 216     @VMEntryPoint
 217     static String callToString(Object o) {
 218         return o.toString();
 219     }
 220 









 221     /**
 222      * A list of all supported JVMCI options.
 223      */
 224     public enum Option {
 225         // @formatter:off
 226         Compiler(String.class, null, &quot;Selects the system compiler. This must match the getCompilerName() value returned &quot; +
 227                 &quot;by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. &quot; +
 228                 &quot;An empty string or the value \&quot;null\&quot; selects a compiler &quot; +
 229                 &quot;that will raise an exception upon receiving a compilation request.&quot;),
 230         // Note: The following one is not used (see InitTimer.ENABLED). It is added here
 231         // so that -XX:+JVMCIPrintProperties shows the option.
 232         InitTimer(Boolean.class, false, &quot;Specifies if initialization timing is enabled.&quot;),
 233         PrintConfig(Boolean.class, false, &quot;Prints VM configuration available via JVMCI.&quot;),
 234         AuditHandles(Boolean.class, false, &quot;Record stack trace along with scoped foreign object reference wrappers &quot; +
 235                 &quot;to debug issue with a wrapper being used after its scope has closed.&quot;),
 236         TraceMethodDataFilter(String.class, null,
 237                 &quot;Enables tracing of profiling info when read by JVMCI.&quot;,
 238                 &quot;Empty value: trace all methods&quot;,
<span class="line-modified"> 239                 &quot;Non-empty value: trace methods whose fully qualified name contains the value.&quot;),</span>
 240         UseProfilingInformation(Boolean.class, true, &quot;&quot;);
 241         // @formatter:on
 242 
 243         /**
 244          * The prefix for system properties that are JVMCI options.
 245          */
 246         private static final String JVMCI_OPTION_PROPERTY_PREFIX = &quot;jvmci.&quot;;
 247 
 248         /**
 249          * Sentinel for value initialized to {@code null} since {@code null} means uninitialized.
 250          */
 251         private static final String NULL_VALUE = &quot;NULL&quot;;
 252 
 253         private final Class&lt;?&gt; type;
 254         @NativeImageReinitialize private Object value;
 255         private final Object defaultValue;
<span class="line-modified"> 256         private boolean isDefault;</span>
 257         private final String[] helpLines;
 258 
 259         Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
 260             assert Character.isUpperCase(name().charAt(0)) : &quot;Option name must start with upper-case letter: &quot; + name();
 261             this.type = type;
 262             this.defaultValue = defaultValue;
 263             this.helpLines = helpLines;


 264         }
 265 
 266         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
<span class="line-modified"> 267         private Object getValue() {</span>
<span class="line-modified"> 268             if (value == null) {</span>
<span class="line-modified"> 269                 String propertyValue = Services.getSavedProperty(getPropertyName());</span>
<span class="line-modified"> 270                 if (propertyValue == null) {</span>
<span class="line-modified"> 271                     this.value = defaultValue == null ? NULL_VALUE : defaultValue;</span>
<span class="line-modified"> 272                     this.isDefault = true;</span>




 273                 } else {
<span class="line-modified"> 274                     if (type == Boolean.class) {</span>
<span class="line-removed"> 275                         this.value = Boolean.parseBoolean(propertyValue);</span>
<span class="line-removed"> 276                     } else if (type == String.class) {</span>
<span class="line-removed"> 277                         this.value = propertyValue;</span>
<span class="line-removed"> 278                     } else {</span>
<span class="line-removed"> 279                         throw new JVMCIError(&quot;Unexpected option type &quot; + type);</span>
<span class="line-removed"> 280                     }</span>
<span class="line-removed"> 281                     this.isDefault = false;</span>
 282                 }











 283             }
<span class="line-modified"> 284             return value == NULL_VALUE ? null : value;</span>
 285         }
 286 
 287         /**
 288          * Gets the name of system property from which this option gets its value.
 289          */
 290         public String getPropertyName() {
 291             return JVMCI_OPTION_PROPERTY_PREFIX + name();
 292         }
 293 
 294         /**
 295          * Returns the option&#39;s value as boolean.
 296          *
 297          * @return option&#39;s value
 298          */
 299         public boolean getBoolean() {
 300             return (boolean) getValue();
 301         }
 302 
 303         /**
 304          * Returns the option&#39;s value as String.
</pre>
<hr />
<pre>
 325                 if (value instanceof String) {
 326                     value = &#39;&quot;&#39; + String.valueOf(value) + &#39;&quot;&#39;;
 327                 }
 328 
 329                 String name = option.getPropertyName();
 330                 String assign = option.isDefault ? &quot;=&quot; : &quot;:=&quot;;
 331                 String typeName = option.type.getSimpleName();
 332                 String linePrefix = String.format(&quot;%s %s %s &quot;, name, assign, value);
 333                 int typeStartPos = PROPERTY_LINE_WIDTH - typeName.length();
 334                 int linePad = typeStartPos - linePrefix.length();
 335                 if (linePad &gt; 0) {
 336                     out.printf(&quot;%s%-&quot; + linePad + &quot;s[%s]%n&quot;, linePrefix, &quot;&quot;, typeName);
 337                 } else {
 338                     out.printf(&quot;%s[%s]%n&quot;, linePrefix, typeName);
 339                 }
 340                 for (String line : option.helpLines) {
 341                     out.printf(&quot;%&quot; + PROPERTY_HELP_INDENT + &quot;s%s%n&quot;, &quot;&quot;, line);
 342                 }
 343             }
 344         }























































 345     }
 346 
 347     private static HotSpotJVMCIBackendFactory findFactory(String architecture) {
 348         Iterable&lt;HotSpotJVMCIBackendFactory&gt; factories = getHotSpotJVMCIBackendFactories();
 349         assert factories != null : &quot;sanity&quot;;
 350         for (HotSpotJVMCIBackendFactory factory : factories) {
 351             if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
 352                 return factory;
 353             }
 354         }
 355 
 356         throw new JVMCIError(&quot;No JVMCI runtime available for the %s architecture&quot;, architecture);
 357     }
 358 
 359     private static volatile List&lt;HotSpotJVMCIBackendFactory&gt; cachedHotSpotJVMCIBackendFactories;
 360 
 361     @SuppressFBWarnings(value = &quot;LI_LAZY_INIT_UPDATE_STATIC&quot;, justification = &quot;not sure about this&quot;)
 362     private static Iterable&lt;HotSpotJVMCIBackendFactory&gt; getHotSpotJVMCIBackendFactories() {
 363         if (IS_IN_NATIVE_IMAGE || cachedHotSpotJVMCIBackendFactories != null) {
 364             return cachedHotSpotJVMCIBackendFactories;
</pre>
<hr />
<pre>
 445 
 446     @SuppressWarnings(&quot;try&quot;)
 447     private HotSpotJVMCIRuntime() {
 448         compilerToVm = new CompilerToVM();
 449 
 450         try (InitTimer t = timer(&quot;HotSpotVMConfig&lt;init&gt;&quot;)) {
 451             configStore = new HotSpotVMConfigStore(compilerToVm);
 452             config = new HotSpotVMConfig(configStore);
 453         }
 454 
 455         reflection = IS_IN_NATIVE_IMAGE ? new SharedLibraryJVMCIReflection() : new HotSpotJDKReflection();
 456 
 457         PrintStream vmLogStream = null;
 458         if (IS_IN_NATIVE_IMAGE) {
 459             // Redirect System.out and System.err to HotSpot&#39;s TTY stream
 460             vmLogStream = new PrintStream(getLogStream());
 461             System.setOut(vmLogStream);
 462             System.setErr(vmLogStream);
 463         }
 464 



 465         String hostArchitecture = config.getHostArchitectureName();
 466 
 467         HotSpotJVMCIBackendFactory factory;
 468         try (InitTimer t = timer(&quot;find factory:&quot;, hostArchitecture)) {
 469             factory = findFactory(hostArchitecture);
 470         }
 471 
 472         try (InitTimer t = timer(&quot;create JVMCI backend:&quot;, hostArchitecture)) {
 473             hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
 474         }
 475 
 476         compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
 477         if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
 478             hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
 479             if (hsCompilerFactory.getCompilationLevelAdjustment() != None) {
 480                 String name = HotSpotJVMCICompilerFactory.class.getName();
 481                 String msg = String.format(&quot;%s.getCompilationLevelAdjustment() is no longer supported. &quot; +
 482                                 &quot;Use %s.excludeFromJVMCICompilation() instead.&quot;, name, name);
 483                 throw new UnsupportedOperationException(msg);
 484             }
</pre>
<hr />
<pre>
 703     private HotSpotCompilationRequestResult compileMethod(HotSpotResolvedJavaMethod method, int entryBCI, long compileState, int id) {
 704         HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, compileState, id);
 705         CompilationRequestResult result = getCompiler().compileMethod(request);
 706         assert result != null : &quot;compileMethod must always return something&quot;;
 707         HotSpotCompilationRequestResult hsResult;
 708         if (result instanceof HotSpotCompilationRequestResult) {
 709             hsResult = (HotSpotCompilationRequestResult) result;
 710         } else {
 711             Object failure = result.getFailure();
 712             if (failure != null) {
 713                 boolean retry = false; // Be conservative with unknown compiler
 714                 hsResult = HotSpotCompilationRequestResult.failure(failure.toString(), retry);
 715             } else {
 716                 int inlinedBytecodes = -1;
 717                 hsResult = HotSpotCompilationRequestResult.success(inlinedBytecodes);
 718             }
 719         }
 720         return hsResult;
 721     }
 722 





 723     /**
 724      * Shuts down the runtime.
 725      */
 726     @VMEntryPoint
<span class="line-modified"> 727     private void shutdown() throws Exception {</span>
<span class="line-modified"> 728         // Cleaners are normally only processed when a new Cleaner is</span>
<span class="line-modified"> 729         // instantiated so process all remaining cleaners now.</span>
<span class="line-modified"> 730         Cleaner.clean();</span>
<span class="line-modified"> 731 </span>
<span class="line-modified"> 732         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {</span>
<span class="line-modified"> 733             vmEventListener.notifyShutdown();</span>



 734         }
 735     }
 736 
 737     /**
 738      * Notify on completion of a bootstrap.
 739      */
 740     @VMEntryPoint
 741     private void bootstrapFinished() throws Exception {
 742         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 743             vmEventListener.notifyBootstrapFinished();
 744         }
 745     }
 746 
 747     /**
 748      * Notify on successful install into the CodeCache.
 749      *
 750      * @param hotSpotCodeCacheProvider
 751      * @param installedCode
 752      * @param compiledCode
 753      */
</pre>
<hr />
<pre>
 905      * import java.lang.reflect.Method;
 906      *
 907      * public static class JCompile {
 908      *     static {
 909      *         HotSpotJVMCIRuntime.runtime().registerNativeMethods(JCompile.class);
 910      *     }
 911      *     public static boolean compile(Method method, String[] options) {
 912      *         // Convert to simpler data types for passing/serializing across native interface
 913      *         long metaspaceMethodHandle = getHandle(method);
 914      *         char[] opts = convertToCharArray(options);
 915      *         return compile(metaspaceMethodHandle, opts);
 916      *     }
 917      *     private static native boolean compile0(long metaspaceMethodHandle, char[] options);
 918      *
 919      *     private static long getHandle(Method method) { ... }
 920      *     private static char[] convertToCharArray(String[] a) { ... }
 921      * }
 922      * &lt;/pre&gt;
 923      *
 924      * The implementation of the native {@code JCompile.compile0} method would be in the JVMCI
<span class="line-modified"> 925      * shared library that contains the bulk of the JVMCI compiler. The {@code JCompile.compile0}</span>
<span class="line-modified"> 926      * implementation will be exported as the following JNI-compatible symbol:</span>
 927      *
 928      * &lt;pre&gt;
 929      * Java_com_jcompile_JCompile_compile0
 930      * &lt;/pre&gt;
 931      *
 932      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#resolving_native_method_names&quot;
 933      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#creating_the_vm&quot;
 934      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#invocation_api_functions&quot;
 935      *
 936      *
<span class="line-modified"> 937      * @return an array of 4 longs where the first value is the {@code JavaVM*} value representing</span>
<span class="line-modified"> 938      *         the Java VM in the JVMCI shared library, and the remaining values are the first 3</span>
<span class="line-modified"> 939      *         pointers in the Invocation API function table (i.e., {@code JNIInvokeInterface})</span>









 940      * @throws NullPointerException if {@code clazz == null}
 941      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
 942      *             {@code -XX:-UseJVMCINativeLibrary})
 943      * @throws IllegalStateException if the current execution context is the JVMCI shared library
 944      * @throws IllegalArgumentException if {@code clazz} is {@link Class#isPrimitive()}
 945      * @throws UnsatisfiedLinkError if there&#39;s a problem linking a native method in {@code clazz}
 946      *             (no matching JNI symbol or the native method is already linked to a different
 947      *             address)
 948      */
 949     public long[] registerNativeMethods(Class&lt;?&gt; clazz) {
 950         return compilerToVm.registerNativeMethods(clazz);
 951     }
 952 
 953     /**
 954      * Creates or retrieves an object in the peer runtime that mirrors {@code obj}. The types whose
 955      * objects can be translated are:
 956      * &lt;ul&gt;
 957      * &lt;li&gt;{@link HotSpotResolvedJavaMethodImpl},&lt;/li&gt;
 958      * &lt;li&gt;{@link HotSpotResolvedObjectTypeImpl},&lt;/li&gt;
 959      * &lt;li&gt;{@link HotSpotResolvedPrimitiveType},&lt;/li&gt;
</pre>
<hr />
<pre>
1008     }
1009 
1010     /**
1011      * Gets the address of the HotSpot {@code JavaThread} C++ object for the current thread. This
1012      * will return {@code 0} if called from an unattached JVMCI shared library thread.
1013      */
1014     public long getCurrentJavaThread() {
1015         return compilerToVm.getCurrentJavaThread();
1016     }
1017 
1018     /**
1019      * Ensures the current thread is attached to the peer runtime.
1020      *
1021      * @param asDaemon if the thread is not yet attached, should it be attached as a daemon
1022      * @return {@code true} if this call attached the current thread, {@code false} if the current
1023      *         thread was already attached
1024      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1025      *             {@code -XX:-UseJVMCINativeLibrary})
1026      * @throws IllegalStateException if the peer runtime has not been initialized or there is an
1027      *             error while trying to attach the thread


1028      */
1029     public boolean attachCurrentThread(boolean asDaemon) {
1030         return compilerToVm.attachCurrentThread(asDaemon);
1031     }
1032 
1033     /**
1034      * Detaches the current thread from the peer runtime.
1035      *
1036      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1037      *             {@code -XX:-UseJVMCINativeLibrary})
1038      * @throws IllegalStateException if the peer runtime has not been initialized or if the current
1039      *             thread is not attached or if there is an error while trying to detach the thread
1040      */
1041     public void detachCurrentThread() {
1042         compilerToVm.detachCurrentThread();
1043     }
1044 
1045     /**
1046      * Informs HotSpot that no method whose module is in {@code modules} is to be compiled
1047      * with {@link #compileMethod}.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.InitTimer.timer;
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;
  27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  29 
  30 import java.io.IOException;
  31 import java.io.OutputStream;
  32 import java.io.PrintStream;
  33 import java.io.Serializable;
  34 import java.lang.invoke.CallSite;
  35 import java.lang.invoke.ConstantCallSite;
  36 import java.lang.invoke.MethodHandle;
  37 import java.lang.ref.WeakReference;
  38 import java.util.ArrayList;
  39 import java.util.Collections;
<span class="line-added">  40 import java.util.Formatter;</span>
  41 import java.util.HashMap;
  42 import java.util.List;
  43 import java.util.Map;
  44 import java.util.Objects;
  45 import java.util.ServiceLoader;
  46 import java.util.function.Predicate;
  47 
  48 import jdk.vm.ci.code.Architecture;
  49 import jdk.vm.ci.code.CompilationRequestResult;
  50 import jdk.vm.ci.code.CompiledCode;
  51 import jdk.vm.ci.code.InstalledCode;
  52 import jdk.vm.ci.common.InitTimer;
  53 import jdk.vm.ci.common.JVMCIError;
  54 import jdk.vm.ci.common.NativeImageReinitialize;
  55 import jdk.vm.ci.meta.JavaKind;
  56 import jdk.vm.ci.meta.JavaType;
  57 import jdk.vm.ci.meta.ResolvedJavaType;
  58 import jdk.vm.ci.meta.UnresolvedJavaType;
  59 import jdk.vm.ci.runtime.JVMCI;
  60 import jdk.vm.ci.runtime.JVMCIBackend;
</pre>
<hr />
<pre>
 202             }
 203         }
 204         return result;
 205     }
 206 
 207     @VMEntryPoint
 208     static Throwable decodeThrowable(String encodedThrowable) throws Throwable {
 209         return TranslatedException.decodeThrowable(encodedThrowable);
 210     }
 211 
 212     @VMEntryPoint
 213     static String encodeThrowable(Throwable throwable) throws Throwable {
 214         return TranslatedException.encodeThrowable(throwable);
 215     }
 216 
 217     @VMEntryPoint
 218     static String callToString(Object o) {
 219         return o.toString();
 220     }
 221 
<span class="line-added"> 222     /**</span>
<span class="line-added"> 223      * Set of recognized {@code &quot;jvmci.*&quot;} system properties. Entries not associated with an</span>
<span class="line-added"> 224      * {@link Option} have this object as their value.</span>
<span class="line-added"> 225      */</span>
<span class="line-added"> 226     static final Map&lt;String, Object&gt; options = new HashMap&lt;&gt;();</span>
<span class="line-added"> 227     static {</span>
<span class="line-added"> 228         options.put(&quot;jvmci.class.path.append&quot;, options);</span>
<span class="line-added"> 229     }</span>
<span class="line-added"> 230 </span>
 231     /**
 232      * A list of all supported JVMCI options.
 233      */
 234     public enum Option {
 235         // @formatter:off
 236         Compiler(String.class, null, &quot;Selects the system compiler. This must match the getCompilerName() value returned &quot; +
 237                 &quot;by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. &quot; +
 238                 &quot;An empty string or the value \&quot;null\&quot; selects a compiler &quot; +
 239                 &quot;that will raise an exception upon receiving a compilation request.&quot;),
 240         // Note: The following one is not used (see InitTimer.ENABLED). It is added here
 241         // so that -XX:+JVMCIPrintProperties shows the option.
 242         InitTimer(Boolean.class, false, &quot;Specifies if initialization timing is enabled.&quot;),
 243         PrintConfig(Boolean.class, false, &quot;Prints VM configuration available via JVMCI.&quot;),
 244         AuditHandles(Boolean.class, false, &quot;Record stack trace along with scoped foreign object reference wrappers &quot; +
 245                 &quot;to debug issue with a wrapper being used after its scope has closed.&quot;),
 246         TraceMethodDataFilter(String.class, null,
 247                 &quot;Enables tracing of profiling info when read by JVMCI.&quot;,
 248                 &quot;Empty value: trace all methods&quot;,
<span class="line-modified"> 249                         &quot;Non-empty value: trace methods whose fully qualified name contains the value.&quot;),</span>
 250         UseProfilingInformation(Boolean.class, true, &quot;&quot;);
 251         // @formatter:on
 252 
 253         /**
 254          * The prefix for system properties that are JVMCI options.
 255          */
 256         private static final String JVMCI_OPTION_PROPERTY_PREFIX = &quot;jvmci.&quot;;
 257 
 258         /**
 259          * Sentinel for value initialized to {@code null} since {@code null} means uninitialized.
 260          */
 261         private static final String NULL_VALUE = &quot;NULL&quot;;
 262 
 263         private final Class&lt;?&gt; type;
 264         @NativeImageReinitialize private Object value;
 265         private final Object defaultValue;
<span class="line-modified"> 266         private boolean isDefault = true;</span>
 267         private final String[] helpLines;
 268 
 269         Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
 270             assert Character.isUpperCase(name().charAt(0)) : &quot;Option name must start with upper-case letter: &quot; + name();
 271             this.type = type;
 272             this.defaultValue = defaultValue;
 273             this.helpLines = helpLines;
<span class="line-added"> 274             Object existing = options.put(getPropertyName(), this);</span>
<span class="line-added"> 275             assert existing == null : getPropertyName();</span>
 276         }
 277 
 278         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
<span class="line-modified"> 279         private void init(String propertyValue) {</span>
<span class="line-modified"> 280             assert value == null : &quot;cannot re-initialize &quot; + name();</span>
<span class="line-modified"> 281             if (propertyValue == null) {</span>
<span class="line-modified"> 282                 this.value = defaultValue == null ? NULL_VALUE : defaultValue;</span>
<span class="line-modified"> 283                 this.isDefault = true;</span>
<span class="line-modified"> 284             } else {</span>
<span class="line-added"> 285                 if (type == Boolean.class) {</span>
<span class="line-added"> 286                     this.value = Boolean.parseBoolean(propertyValue);</span>
<span class="line-added"> 287                 } else if (type == String.class) {</span>
<span class="line-added"> 288                     this.value = propertyValue;</span>
 289                 } else {
<span class="line-modified"> 290                     throw new JVMCIError(&quot;Unexpected option type &quot; + type);</span>







 291                 }
<span class="line-added"> 292                 this.isDefault = false;</span>
<span class="line-added"> 293             }</span>
<span class="line-added"> 294         }</span>
<span class="line-added"> 295 </span>
<span class="line-added"> 296         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)</span>
<span class="line-added"> 297         private Object getValue() {</span>
<span class="line-added"> 298             if (value == NULL_VALUE) {</span>
<span class="line-added"> 299                 return null;</span>
<span class="line-added"> 300             }</span>
<span class="line-added"> 301             if (value == null) {</span>
<span class="line-added"> 302                 return defaultValue;</span>
 303             }
<span class="line-modified"> 304             return value;</span>
 305         }
 306 
 307         /**
 308          * Gets the name of system property from which this option gets its value.
 309          */
 310         public String getPropertyName() {
 311             return JVMCI_OPTION_PROPERTY_PREFIX + name();
 312         }
 313 
 314         /**
 315          * Returns the option&#39;s value as boolean.
 316          *
 317          * @return option&#39;s value
 318          */
 319         public boolean getBoolean() {
 320             return (boolean) getValue();
 321         }
 322 
 323         /**
 324          * Returns the option&#39;s value as String.
</pre>
<hr />
<pre>
 345                 if (value instanceof String) {
 346                     value = &#39;&quot;&#39; + String.valueOf(value) + &#39;&quot;&#39;;
 347                 }
 348 
 349                 String name = option.getPropertyName();
 350                 String assign = option.isDefault ? &quot;=&quot; : &quot;:=&quot;;
 351                 String typeName = option.type.getSimpleName();
 352                 String linePrefix = String.format(&quot;%s %s %s &quot;, name, assign, value);
 353                 int typeStartPos = PROPERTY_LINE_WIDTH - typeName.length();
 354                 int linePad = typeStartPos - linePrefix.length();
 355                 if (linePad &gt; 0) {
 356                     out.printf(&quot;%s%-&quot; + linePad + &quot;s[%s]%n&quot;, linePrefix, &quot;&quot;, typeName);
 357                 } else {
 358                     out.printf(&quot;%s[%s]%n&quot;, linePrefix, typeName);
 359                 }
 360                 for (String line : option.helpLines) {
 361                     out.printf(&quot;%&quot; + PROPERTY_HELP_INDENT + &quot;s%s%n&quot;, &quot;&quot;, line);
 362                 }
 363             }
 364         }
<span class="line-added"> 365 </span>
<span class="line-added"> 366         /**</span>
<span class="line-added"> 367          * Compute string similarity based on Dice&#39;s coefficient.</span>
<span class="line-added"> 368          *</span>
<span class="line-added"> 369          * Ported from str_similar() in globals.cpp.</span>
<span class="line-added"> 370          */</span>
<span class="line-added"> 371         static float stringSimiliarity(String str1, String str2) {</span>
<span class="line-added"> 372             int hit = 0;</span>
<span class="line-added"> 373             for (int i = 0; i &lt; str1.length() - 1; ++i) {</span>
<span class="line-added"> 374                 for (int j = 0; j &lt; str2.length() - 1; ++j) {</span>
<span class="line-added"> 375                     if ((str1.charAt(i) == str2.charAt(j)) &amp;&amp; (str1.charAt(i + 1) == str2.charAt(j + 1))) {</span>
<span class="line-added"> 376                         ++hit;</span>
<span class="line-added"> 377                         break;</span>
<span class="line-added"> 378                     }</span>
<span class="line-added"> 379                 }</span>
<span class="line-added"> 380             }</span>
<span class="line-added"> 381             return 2.0f * hit / (str1.length() + str2.length());</span>
<span class="line-added"> 382         }</span>
<span class="line-added"> 383 </span>
<span class="line-added"> 384         private static final float FUZZY_MATCH_THRESHOLD = 0.7F;</span>
<span class="line-added"> 385 </span>
<span class="line-added"> 386         /**</span>
<span class="line-added"> 387          * Parses all system properties starting with {@value #JVMCI_OPTION_PROPERTY_PREFIX} and</span>
<span class="line-added"> 388          * initializes the options based on their values.</span>
<span class="line-added"> 389          */</span>
<span class="line-added"> 390         static void parse() {</span>
<span class="line-added"> 391             Map&lt;String, String&gt; savedProps = jdk.vm.ci.services.Services.getSavedProperties();</span>
<span class="line-added"> 392             for (Map.Entry&lt;String, String&gt; e : savedProps.entrySet()) {</span>
<span class="line-added"> 393                 String name = e.getKey();</span>
<span class="line-added"> 394                 if (name.startsWith(Option.JVMCI_OPTION_PROPERTY_PREFIX)) {</span>
<span class="line-added"> 395                     Object value = options.get(name);</span>
<span class="line-added"> 396                     if (value == null) {</span>
<span class="line-added"> 397                         List&lt;String&gt; matches = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 398                         for (String pn : options.keySet()) {</span>
<span class="line-added"> 399                             float score = stringSimiliarity(pn, name);</span>
<span class="line-added"> 400                             if (score &gt;= FUZZY_MATCH_THRESHOLD) {</span>
<span class="line-added"> 401                                 matches.add(pn);</span>
<span class="line-added"> 402                             }</span>
<span class="line-added"> 403                         }</span>
<span class="line-added"> 404                         Formatter msg = new Formatter();</span>
<span class="line-added"> 405                         msg.format(&quot;Could not find option %s&quot;, name);</span>
<span class="line-added"> 406                         if (!matches.isEmpty()) {</span>
<span class="line-added"> 407                             msg.format(&quot;%nDid you mean one of the following?&quot;);</span>
<span class="line-added"> 408                             for (String match : matches) {</span>
<span class="line-added"> 409                                 msg.format(&quot;%n    %s=&lt;value&gt;&quot;, match);</span>
<span class="line-added"> 410                             }</span>
<span class="line-added"> 411                         }</span>
<span class="line-added"> 412                         throw new IllegalArgumentException(msg.toString());</span>
<span class="line-added"> 413                     } else if (value instanceof Option) {</span>
<span class="line-added"> 414                         Option option = (Option) value;</span>
<span class="line-added"> 415                         option.init(e.getValue());</span>
<span class="line-added"> 416                     }</span>
<span class="line-added"> 417                 }</span>
<span class="line-added"> 418             }</span>
<span class="line-added"> 419         }</span>
 420     }
 421 
 422     private static HotSpotJVMCIBackendFactory findFactory(String architecture) {
 423         Iterable&lt;HotSpotJVMCIBackendFactory&gt; factories = getHotSpotJVMCIBackendFactories();
 424         assert factories != null : &quot;sanity&quot;;
 425         for (HotSpotJVMCIBackendFactory factory : factories) {
 426             if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
 427                 return factory;
 428             }
 429         }
 430 
 431         throw new JVMCIError(&quot;No JVMCI runtime available for the %s architecture&quot;, architecture);
 432     }
 433 
 434     private static volatile List&lt;HotSpotJVMCIBackendFactory&gt; cachedHotSpotJVMCIBackendFactories;
 435 
 436     @SuppressFBWarnings(value = &quot;LI_LAZY_INIT_UPDATE_STATIC&quot;, justification = &quot;not sure about this&quot;)
 437     private static Iterable&lt;HotSpotJVMCIBackendFactory&gt; getHotSpotJVMCIBackendFactories() {
 438         if (IS_IN_NATIVE_IMAGE || cachedHotSpotJVMCIBackendFactories != null) {
 439             return cachedHotSpotJVMCIBackendFactories;
</pre>
<hr />
<pre>
 520 
 521     @SuppressWarnings(&quot;try&quot;)
 522     private HotSpotJVMCIRuntime() {
 523         compilerToVm = new CompilerToVM();
 524 
 525         try (InitTimer t = timer(&quot;HotSpotVMConfig&lt;init&gt;&quot;)) {
 526             configStore = new HotSpotVMConfigStore(compilerToVm);
 527             config = new HotSpotVMConfig(configStore);
 528         }
 529 
 530         reflection = IS_IN_NATIVE_IMAGE ? new SharedLibraryJVMCIReflection() : new HotSpotJDKReflection();
 531 
 532         PrintStream vmLogStream = null;
 533         if (IS_IN_NATIVE_IMAGE) {
 534             // Redirect System.out and System.err to HotSpot&#39;s TTY stream
 535             vmLogStream = new PrintStream(getLogStream());
 536             System.setOut(vmLogStream);
 537             System.setErr(vmLogStream);
 538         }
 539 
<span class="line-added"> 540         // Initialize the Option values.</span>
<span class="line-added"> 541         Option.parse();</span>
<span class="line-added"> 542 </span>
 543         String hostArchitecture = config.getHostArchitectureName();
 544 
 545         HotSpotJVMCIBackendFactory factory;
 546         try (InitTimer t = timer(&quot;find factory:&quot;, hostArchitecture)) {
 547             factory = findFactory(hostArchitecture);
 548         }
 549 
 550         try (InitTimer t = timer(&quot;create JVMCI backend:&quot;, hostArchitecture)) {
 551             hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
 552         }
 553 
 554         compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
 555         if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
 556             hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
 557             if (hsCompilerFactory.getCompilationLevelAdjustment() != None) {
 558                 String name = HotSpotJVMCICompilerFactory.class.getName();
 559                 String msg = String.format(&quot;%s.getCompilationLevelAdjustment() is no longer supported. &quot; +
 560                                 &quot;Use %s.excludeFromJVMCICompilation() instead.&quot;, name, name);
 561                 throw new UnsupportedOperationException(msg);
 562             }
</pre>
<hr />
<pre>
 781     private HotSpotCompilationRequestResult compileMethod(HotSpotResolvedJavaMethod method, int entryBCI, long compileState, int id) {
 782         HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, compileState, id);
 783         CompilationRequestResult result = getCompiler().compileMethod(request);
 784         assert result != null : &quot;compileMethod must always return something&quot;;
 785         HotSpotCompilationRequestResult hsResult;
 786         if (result instanceof HotSpotCompilationRequestResult) {
 787             hsResult = (HotSpotCompilationRequestResult) result;
 788         } else {
 789             Object failure = result.getFailure();
 790             if (failure != null) {
 791                 boolean retry = false; // Be conservative with unknown compiler
 792                 hsResult = HotSpotCompilationRequestResult.failure(failure.toString(), retry);
 793             } else {
 794                 int inlinedBytecodes = -1;
 795                 hsResult = HotSpotCompilationRequestResult.success(inlinedBytecodes);
 796             }
 797         }
 798         return hsResult;
 799     }
 800 
<span class="line-added"> 801     /**</span>
<span class="line-added"> 802      * Guard to ensure shut down actions are performed at most once.</span>
<span class="line-added"> 803      */</span>
<span class="line-added"> 804     private boolean isShutdown;</span>
<span class="line-added"> 805 </span>
 806     /**
 807      * Shuts down the runtime.
 808      */
 809     @VMEntryPoint
<span class="line-modified"> 810     private synchronized void shutdown() throws Exception {</span>
<span class="line-modified"> 811         if (!isShutdown) {</span>
<span class="line-modified"> 812             isShutdown = true;</span>
<span class="line-modified"> 813             // Cleaners are normally only processed when a new Cleaner is</span>
<span class="line-modified"> 814             // instantiated so process all remaining cleaners now.</span>
<span class="line-modified"> 815             Cleaner.clean();</span>
<span class="line-modified"> 816 </span>
<span class="line-added"> 817             for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {</span>
<span class="line-added"> 818                 vmEventListener.notifyShutdown();</span>
<span class="line-added"> 819             }</span>
 820         }
 821     }
 822 
 823     /**
 824      * Notify on completion of a bootstrap.
 825      */
 826     @VMEntryPoint
 827     private void bootstrapFinished() throws Exception {
 828         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 829             vmEventListener.notifyBootstrapFinished();
 830         }
 831     }
 832 
 833     /**
 834      * Notify on successful install into the CodeCache.
 835      *
 836      * @param hotSpotCodeCacheProvider
 837      * @param installedCode
 838      * @param compiledCode
 839      */
</pre>
<hr />
<pre>
 991      * import java.lang.reflect.Method;
 992      *
 993      * public static class JCompile {
 994      *     static {
 995      *         HotSpotJVMCIRuntime.runtime().registerNativeMethods(JCompile.class);
 996      *     }
 997      *     public static boolean compile(Method method, String[] options) {
 998      *         // Convert to simpler data types for passing/serializing across native interface
 999      *         long metaspaceMethodHandle = getHandle(method);
1000      *         char[] opts = convertToCharArray(options);
1001      *         return compile(metaspaceMethodHandle, opts);
1002      *     }
1003      *     private static native boolean compile0(long metaspaceMethodHandle, char[] options);
1004      *
1005      *     private static long getHandle(Method method) { ... }
1006      *     private static char[] convertToCharArray(String[] a) { ... }
1007      * }
1008      * &lt;/pre&gt;
1009      *
1010      * The implementation of the native {@code JCompile.compile0} method would be in the JVMCI
<span class="line-modified">1011      * shared library that contains the JVMCI compiler. The {@code JCompile.compile0} implementation</span>
<span class="line-modified">1012      * must be exported as the following JNI-compatible symbol:</span>
1013      *
1014      * &lt;pre&gt;
1015      * Java_com_jcompile_JCompile_compile0
1016      * &lt;/pre&gt;
1017      *
1018      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#resolving_native_method_names&quot;
1019      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#creating_the_vm&quot;
1020      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#invocation_api_functions&quot;
1021      *
1022      *
<span class="line-modified">1023      * @return info about the Java VM in the JVMCI shared library {@code JavaVM*}. The info is</span>
<span class="line-modified">1024      *         encoded in a long array as follows:</span>
<span class="line-modified">1025      *</span>
<span class="line-added">1026      *         &lt;pre&gt;</span>
<span class="line-added">1027      *     long[] info = {</span>
<span class="line-added">1028      *         javaVM, // the {@code JavaVM*} value</span>
<span class="line-added">1029      *         javaVM-&gt;functions-&gt;reserved0,</span>
<span class="line-added">1030      *         javaVM-&gt;functions-&gt;reserved1,</span>
<span class="line-added">1031      *         javaVM-&gt;functions-&gt;reserved2</span>
<span class="line-added">1032      *     }</span>
<span class="line-added">1033      *         &lt;/pre&gt;</span>
<span class="line-added">1034      *</span>
1035      * @throws NullPointerException if {@code clazz == null}
1036      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1037      *             {@code -XX:-UseJVMCINativeLibrary})
1038      * @throws IllegalStateException if the current execution context is the JVMCI shared library
1039      * @throws IllegalArgumentException if {@code clazz} is {@link Class#isPrimitive()}
1040      * @throws UnsatisfiedLinkError if there&#39;s a problem linking a native method in {@code clazz}
1041      *             (no matching JNI symbol or the native method is already linked to a different
1042      *             address)
1043      */
1044     public long[] registerNativeMethods(Class&lt;?&gt; clazz) {
1045         return compilerToVm.registerNativeMethods(clazz);
1046     }
1047 
1048     /**
1049      * Creates or retrieves an object in the peer runtime that mirrors {@code obj}. The types whose
1050      * objects can be translated are:
1051      * &lt;ul&gt;
1052      * &lt;li&gt;{@link HotSpotResolvedJavaMethodImpl},&lt;/li&gt;
1053      * &lt;li&gt;{@link HotSpotResolvedObjectTypeImpl},&lt;/li&gt;
1054      * &lt;li&gt;{@link HotSpotResolvedPrimitiveType},&lt;/li&gt;
</pre>
<hr />
<pre>
1103     }
1104 
1105     /**
1106      * Gets the address of the HotSpot {@code JavaThread} C++ object for the current thread. This
1107      * will return {@code 0} if called from an unattached JVMCI shared library thread.
1108      */
1109     public long getCurrentJavaThread() {
1110         return compilerToVm.getCurrentJavaThread();
1111     }
1112 
1113     /**
1114      * Ensures the current thread is attached to the peer runtime.
1115      *
1116      * @param asDaemon if the thread is not yet attached, should it be attached as a daemon
1117      * @return {@code true} if this call attached the current thread, {@code false} if the current
1118      *         thread was already attached
1119      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1120      *             {@code -XX:-UseJVMCINativeLibrary})
1121      * @throws IllegalStateException if the peer runtime has not been initialized or there is an
1122      *             error while trying to attach the thread
<span class="line-added">1123      * @throws ArrayIndexOutOfBoundsException if {@code javaVMInfo} is non-null and is shorter than</span>
<span class="line-added">1124      *             the length of the array returned by {@link #registerNativeMethods}</span>
1125      */
1126     public boolean attachCurrentThread(boolean asDaemon) {
1127         return compilerToVm.attachCurrentThread(asDaemon);
1128     }
1129 
1130     /**
1131      * Detaches the current thread from the peer runtime.
1132      *
1133      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1134      *             {@code -XX:-UseJVMCINativeLibrary})
1135      * @throws IllegalStateException if the peer runtime has not been initialized or if the current
1136      *             thread is not attached or if there is an error while trying to detach the thread
1137      */
1138     public void detachCurrentThread() {
1139         compilerToVm.detachCurrentThread();
1140     }
1141 
1142     /**
1143      * Informs HotSpot that no method whose module is in {@code modules} is to be compiled
1144      * with {@link #compileMethod}.
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../../jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CheckGraalIntrinsics.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>