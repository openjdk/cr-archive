<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CheckGraalIntrinsics.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.test;
 26 
 27 import java.lang.reflect.Method;
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.Collection;
 31 import java.util.Collections;
 32 import java.util.Formatter;
 33 import java.util.List;
 34 import java.util.ServiceLoader;
 35 import java.util.Set;
 36 import java.util.TreeSet;
 37 import java.util.stream.Collectors;
 38 
 39 import jdk.internal.vm.compiler.collections.EconomicMap;
 40 import jdk.internal.vm.compiler.collections.MapCursor;
 41 import org.graalvm.compiler.api.test.Graal;
 42 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 43 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 44 import org.graalvm.compiler.hotspot.meta.HotSpotGraphBuilderPlugins;
 45 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 46 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 47 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 48 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 49 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Binding;
 50 import org.graalvm.compiler.runtime.RuntimeProvider;
 51 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 52 import org.graalvm.compiler.test.GraalTest;
 53 import org.junit.Test;
 54 
 55 import jdk.vm.ci.aarch64.AArch64;
 56 import jdk.vm.ci.amd64.AMD64;
 57 import jdk.vm.ci.code.Architecture;
 58 import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
 59 import jdk.vm.ci.hotspot.VMIntrinsicMethod;
 60 import jdk.vm.ci.meta.MetaAccessProvider;
 61 import jdk.vm.ci.meta.MetaUtil;
 62 import jdk.vm.ci.meta.MethodHandleAccessProvider.IntrinsicMethod;
 63 import jdk.vm.ci.meta.ResolvedJavaMethod;
 64 
 65 /**
 66  * Checks the intrinsics implemented by Graal against the set of intrinsics declared by HotSpot. The
 67  * purpose of this test is to detect when new intrinsics are added to HotSpot and process them
 68  * appropriately in Graal. This will be achieved by working through {@link #toBeInvestigated} and
 69  * either implementing the intrinsic or moving it to {@link #ignore} .
 70  */
 71 public class CheckGraalIntrinsics extends GraalTest {
 72 
 73     public static boolean match(String type, Binding binding, VMIntrinsicMethod intrinsic) {
 74         if (intrinsic.name.equals(binding.name)) {
 75             if (intrinsic.descriptor.startsWith(binding.argumentsDescriptor)) {
 76                 if (type.equals(intrinsic.declaringClass)) {
 77                     return true;
 78                 }
 79             }
 80         }
 81         return false;
 82     }
 83 
 84     public static InvocationPlugin findPlugin(EconomicMap&lt;String, List&lt;Binding&gt;&gt; bindings, VMIntrinsicMethod intrinsic) {
 85         MapCursor&lt;String, List&lt;Binding&gt;&gt; cursor = bindings.getEntries();
 86         while (cursor.advance()) {
 87             // Match format of VMIntrinsicMethod.declaringClass
 88             String type = MetaUtil.internalNameToJava(cursor.getKey(), true, false).replace(&#39;.&#39;, &#39;/&#39;);
 89             for (Binding binding : cursor.getValue()) {
 90                 if (match(type, binding, intrinsic)) {
 91                     return binding.plugin;
 92                 }
 93             }
 94         }
 95         return null;
 96     }
 97 
 98     public static ResolvedJavaMethod resolveIntrinsic(MetaAccessProvider metaAccess, VMIntrinsicMethod intrinsic) throws ClassNotFoundException {
 99         Class&lt;?&gt; c;
100         try {
101             c = Class.forName(intrinsic.declaringClass.replace(&#39;/&#39;, &#39;.&#39;), false, CheckGraalIntrinsics.class.getClassLoader());
102         } catch (ClassNotFoundException ex) {
103             try {
104                 Class.forName(&quot;javax.naming.Reference&quot;);
105             } catch (ClassNotFoundException coreNamingMissing) {
106                 // if core JDK classes aren&#39;t found, we are probably running in a
107                 // JDK9 java.base environment and then missing class is OK
108                 return null;
109             }
110             throw ex;
111         }
112         for (Method javaMethod : c.getDeclaredMethods()) {
113             if (javaMethod.getName().equals(intrinsic.name)) {
114                 ResolvedJavaMethod method = metaAccess.lookupJavaMethod(javaMethod);
115                 if (intrinsic.descriptor.equals(&quot;*&quot;)) {
116                     // Signature polymorphic method - name match is enough
117                     return method;
118                 } else {
119                     if (method.getSignature().toMethodDescriptor().equals(intrinsic.descriptor)) {
120                         return method;
121                     }
122                 }
123             }
124         }
125         return null;
126     }
127 
128     /**
129      * The HotSpot intrinsics that:
130      * &lt;ul&gt;
131      * &lt;li&gt;will never implemented by Graal (comments must explain why)&lt;/li&gt;
132      * &lt;li&gt;are implemented without {@link InvocationPlugin}s, or&lt;/li&gt;
133      * &lt;li&gt;whose {@link InvocationPlugin} registration is guarded by a condition that is false in
134      * the current VM context.&lt;/li&gt;
135      * &lt;/ul&gt;
136      */
137     public final Set&lt;String&gt; ignore = new TreeSet&lt;&gt;();
138 
139     /**
140      * The HotSpot intrinsics whose {@link InvocationPlugin} registration is guarded by a condition
141      * too complex to duplicate here.
142      * &lt;/ul&gt;
143      */
144     public final Set&lt;String&gt; complexGuard = new TreeSet&lt;&gt;();
145 
146     /**
147      * The HotSpot intrinsics implemented downstream.
148      * &lt;/ul&gt;
149      */
150     public final Set&lt;String&gt; downstream = new TreeSet&lt;&gt;();
151 
152     /**
153      * The HotSpot intrinsics yet to be implemented or moved to {@link #ignore}.
154      */
155     public final Set&lt;String&gt; toBeInvestigated = new TreeSet&lt;&gt;();
156 
157     private static Collection&lt;String&gt; add(Collection&lt;String&gt; c, String... elements) {
158         String[] sorted = elements.clone();
159         Arrays.sort(sorted);
160         if (!Arrays.equals(elements, sorted)) {
161             int width = 2 + Arrays.asList(elements).stream().map(String::length).reduce(0, Integer::max);
162             Formatter fmt = new Formatter();
163             fmt.format(&quot;%-&quot; + width + &quot;s | sorted%n&quot;, &quot;original&quot;);
164             fmt.format(&quot;%s%n&quot;, new String(new char[width * 2 + 2]).replace(&#39;\0&#39;, &#39;=&#39;));
165             for (int i = 0; i &lt; elements.length; i++) {
166                 fmt.format(&quot;%-&quot; + width + &quot;s | %s%n&quot;, elements[i], sorted[i]);
167             }
168             fail(&quot;Elements not sorted alphabetically:%n%s&quot;, fmt);
169         }
170         c.addAll(Arrays.asList(elements));
171         return c;
172     }
173 
174     public final HotSpotGraalRuntimeProvider rt = (HotSpotGraalRuntimeProvider) Graal.getRequiredCapability(RuntimeProvider.class);
175     public final Architecture arch = rt.getHostBackend().getTarget().arch;
176     public final GraalHotSpotVMConfig config = rt.getVMConfig();
177 
178     public CheckGraalIntrinsics() {
179         // These are dead
180         add(ignore,
181                         &quot;java/lang/Math.atan2(DD)D&quot;,
182                         &quot;jdk/internal/misc/Unsafe.park(ZJ)V&quot;,
183                         &quot;jdk/internal/misc/Unsafe.unpark(Ljava/lang/Object;)V&quot;,
184                         &quot;sun/misc/Unsafe.park(ZJ)V&quot;,
185                         &quot;sun/misc/Unsafe.prefetchRead(Ljava/lang/Object;J)V&quot;,
186                         &quot;sun/misc/Unsafe.prefetchReadStatic(Ljava/lang/Object;J)V&quot;,
187                         &quot;sun/misc/Unsafe.prefetchWrite(Ljava/lang/Object;J)V&quot;,
188                         &quot;sun/misc/Unsafe.prefetchWriteStatic(Ljava/lang/Object;J)V&quot;,
189                         &quot;sun/misc/Unsafe.unpark(Ljava/lang/Object;)V&quot;);
190 
191         // These only exist to assist escape analysis in C2
192         add(ignore,
193                         &quot;java/lang/Throwable.fillInStackTrace()Ljava/lang/Throwable;&quot;);
194 
195         // These are only used for the security handling during stack walking
196         add(ignore,
197                         &quot;java/lang/reflect/Method.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;);
198 
199         // These are marker intrinsic ids only
200         add(ignore,
201                         &quot;java/lang/invoke/MethodHandle.&lt;compiledLambdaForm&gt;*&quot;,
202                         &quot;java/lang/invoke/MethodHandle.invoke*&quot;);
203 
204         // These are implemented through lowering
205         add(ignore,
206                         &quot;java/lang/ref/Reference.get()Ljava/lang/Object;&quot;);
207 
208         // These are only used by C1
209         add(ignore,
210                         &quot;java/nio/Buffer.checkIndex(I)I&quot;);
211 
212         // These do general compiler optimizations and convert min/max to cmov instructions. We are
213         // ignoring them as cmovs are not necessarily beneficial.
214         add(ignore,
215                         &quot;java/lang/Math.max(II)I&quot;,
216                         &quot;java/lang/Math.min(II)I&quot;);
217 
218         // These are known to be implemented down stream
219         add(downstream,
220                         &quot;java/lang/Integer.toString(I)Ljava/lang/String;&quot;,
221                         &quot;java/lang/String.&lt;init&gt;(Ljava/lang/String;)V&quot;,
222                         &quot;java/lang/StringBuffer.&lt;init&gt;()V&quot;,
223                         &quot;java/lang/StringBuffer.&lt;init&gt;(I)V&quot;,
224                         &quot;java/lang/StringBuffer.&lt;init&gt;(Ljava/lang/String;)V&quot;,
225                         &quot;java/lang/StringBuffer.append(C)Ljava/lang/StringBuffer;&quot;,
226                         &quot;java/lang/StringBuffer.append(I)Ljava/lang/StringBuffer;&quot;,
227                         &quot;java/lang/StringBuffer.append(Ljava/lang/String;)Ljava/lang/StringBuffer;&quot;,
228                         &quot;java/lang/StringBuffer.toString()Ljava/lang/String;&quot;,
229                         &quot;java/lang/StringBuilder.&lt;init&gt;()V&quot;,
230                         &quot;java/lang/StringBuilder.&lt;init&gt;(I)V&quot;,
231                         &quot;java/lang/StringBuilder.&lt;init&gt;(Ljava/lang/String;)V&quot;,
232                         &quot;java/lang/StringBuilder.append(C)Ljava/lang/StringBuilder;&quot;,
233                         &quot;java/lang/StringBuilder.append(I)Ljava/lang/StringBuilder;&quot;,
234                         &quot;java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;,
235                         &quot;java/lang/StringBuilder.toString()Ljava/lang/String;&quot;,
236                         &quot;java/util/Arrays.copyOf([Ljava/lang/Object;ILjava/lang/Class;)[Ljava/lang/Object;&quot;,
237                         &quot;java/util/Arrays.copyOfRange([Ljava/lang/Object;IILjava/lang/Class;)[Ljava/lang/Object;&quot;);
238 
239         add(complexGuard,
240                         &quot;java/lang/Integer.bitCount(I)I&quot;,
241                         &quot;java/lang/Integer.numberOfLeadingZeros(I)I&quot;,
242                         &quot;java/lang/Integer.numberOfTrailingZeros(I)I&quot;,
243                         &quot;java/lang/Long.bitCount(J)I&quot;,
244                         &quot;java/lang/Long.numberOfLeadingZeros(J)I&quot;,
245                         &quot;java/lang/Long.numberOfTrailingZeros(J)I&quot;);
246 
247         // Relevant for Java flight recorder
248         add(toBeInvestigated,
249                         &quot;oracle/jrockit/jfr/Timing.counterTime()J&quot;,
250                         &quot;oracle/jrockit/jfr/VMJFR.classID0(Ljava/lang/Class;)J&quot;,
251                         &quot;oracle/jrockit/jfr/VMJFR.threadID()I&quot;);
252 
253         add(toBeInvestigated,
254                         // Similar to addExact
255                         &quot;java/lang/Math.negateExact(I)I&quot;,
256                         // Similar to addExact
257                         &quot;java/lang/Math.negateExact(J)J&quot;,
258                         // HotSpot MacroAssembler-based intrinsic
259                         &quot;java/lang/String.indexOf(Ljava/lang/String;)I&quot;,
260                         // Can share most implementation parts with with
261                         // Unsafe.allocateUninitializedArray0
262                         &quot;java/lang/reflect/Array.newArray(Ljava/lang/Class;I)Ljava/lang/Object;&quot;,
263                         // HotSpot MacroAssembler-based intrinsic
264                         &quot;sun/nio/cs/ISO_8859_1$Encoder.encodeISOArray([CI[BII)I&quot;,
265                         // We have implemented implCompressMultiBlock0 on JDK9+. Does it worth
266                         // backporting as corresponding HotSpot stubs are only generated on SPARC?
267                         &quot;sun/security/provider/DigestBase.implCompressMultiBlock([BII)I&quot;);
268 
269         // See JDK-8207146.
270         String oopName = isJDK12OrHigher() ? &quot;Reference&quot; : &quot;Object&quot;;
271 
272         if (isJDK9OrHigher()) {
273             // Relevant for Java flight recorder
274             add(toBeInvestigated,
275                             &quot;jdk/jfr/internal/JVM.counterTime()J&quot;,
276                             &quot;jdk/jfr/internal/JVM.getBufferWriter()Ljava/lang/Object;&quot;,
277                             &quot;jdk/jfr/internal/JVM.getClassId(Ljava/lang/Class;)J&quot;);
278 
279             add(toBeInvestigated,
280                             // Only used as a marker for vectorization?
281                             &quot;java/util/stream/Streams$RangeIntSpliterator.forEachRemaining(Ljava/util/function/IntConsumer;)V&quot;,
282                             // Only implemented on non-AMD64 platforms (some logic and runtime call)
283                             &quot;java/util/zip/Adler32.updateByteBuffer(IJII)I&quot;,
284                             // Only implemented on non-AMD64 platforms (some logic and runtime call)
285                             &quot;java/util/zip/Adler32.updateBytes(I[BII)I&quot;,
286                             // Emits a slow and a fast path and some dispatching logic
287                             &quot;jdk/internal/misc/Unsafe.allocateUninitializedArray0(Ljava/lang/Class;I)Ljava/lang/Object;&quot;,
288 
289                             // Control flow, deopts, and a cast
290                             &quot;jdk/internal/util/Preconditions.checkIndex(IILjava/util/function/BiFunction;)I&quot;,
291                             // HotSpot MacroAssembler-based intrinsic
292                             &quot;sun/nio/cs/ISO_8859_1$Encoder.implEncodeISOArray([CI[BII)I&quot;);
293 
294             /*
295              * Per default, all these operations are mapped to some generic method for which we
296              * already have compiler intrinsics. Performance-wise it would be better to support them
297              * explicitly as the more generic method might be more restrictive and therefore slower
298              * than necessary.
299              */
300 
301             add(toBeInvestigated,
302                             // Mapped to compareAndExchange*
303                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeByteAcquire(Ljava/lang/Object;JBB)B&quot;,
304                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeByteRelease(Ljava/lang/Object;JBB)B&quot;,
305                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeIntAcquire(Ljava/lang/Object;JII)I&quot;,
306                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeIntRelease(Ljava/lang/Object;JII)I&quot;,
307                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeLongAcquire(Ljava/lang/Object;JJJ)J&quot;,
308                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeLongRelease(Ljava/lang/Object;JJJ)J&quot;,
309                             &quot;jdk/internal/misc/Unsafe.compareAndExchange&quot; + oopName + &quot;Acquire(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&quot;,
310                             &quot;jdk/internal/misc/Unsafe.compareAndExchange&quot; + oopName + &quot;Release(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&quot;,
311                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeShortAcquire(Ljava/lang/Object;JSS)S&quot;,
312                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeShortRelease(Ljava/lang/Object;JSS)S&quot;,
313 
314                             // Mapped to compareAndSet*
315                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetByte(Ljava/lang/Object;JBB)Z&quot;,
316                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetByteAcquire(Ljava/lang/Object;JBB)Z&quot;,
317                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetBytePlain(Ljava/lang/Object;JBB)Z&quot;,
318                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetByteRelease(Ljava/lang/Object;JBB)Z&quot;,
319                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetInt(Ljava/lang/Object;JII)Z&quot;,
320                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetIntAcquire(Ljava/lang/Object;JII)Z&quot;,
321                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetIntPlain(Ljava/lang/Object;JII)Z&quot;,
322                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetIntRelease(Ljava/lang/Object;JII)Z&quot;,
323                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetLong(Ljava/lang/Object;JJJ)Z&quot;,
324                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetLongAcquire(Ljava/lang/Object;JJJ)Z&quot;,
325                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetLongPlain(Ljava/lang/Object;JJJ)Z&quot;,
326                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetLongRelease(Ljava/lang/Object;JJJ)Z&quot;,
327                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSet&quot; + oopName + &quot;(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z&quot;,
328                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSet&quot; + oopName + &quot;Acquire(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z&quot;,
329                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSet&quot; + oopName + &quot;Plain(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z&quot;,
330                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSet&quot; + oopName + &quot;Release(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z&quot;,
331                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetShort(Ljava/lang/Object;JSS)Z&quot;,
332                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetShortAcquire(Ljava/lang/Object;JSS)Z&quot;,
333                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetShortPlain(Ljava/lang/Object;JSS)Z&quot;,
334                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetShortRelease(Ljava/lang/Object;JSS)Z&quot;);
335 
336             // Compact string support - HotSpot MacroAssembler-based intrinsic or complex C2 logic.
337             add(toBeInvestigated,
338                             &quot;java/lang/StringCoding.hasNegatives([BII)Z&quot;,
339                             &quot;java/lang/StringCoding.implEncodeISOArray([BI[BII)I&quot;);
340             add(ignore,
341                             // handled through an intrinsic for String.equals itself
342                             &quot;java/lang/StringLatin1.equals([B[B)Z&quot;,
343 
344                             // handled by an intrinsic for StringLatin1.indexOf([BI[BII)I
345                             &quot;java/lang/StringLatin1.indexOf([B[B)I&quot;,
346 
347                             // handled through an intrinsic for String.equals itself
348                             &quot;java/lang/StringUTF16.equals([B[B)Z&quot;,
349 
350                             // handled by an intrinsic for StringUTF16.indexOfUnsafe
351                             &quot;java/lang/StringUTF16.indexOf([BI[BII)I&quot;,
352                             &quot;java/lang/StringUTF16.indexOf([B[B)I&quot;,
353 
354                             // handled by an intrinsic for StringUTF16.indexOfCharUnsafe
355                             &quot;java/lang/StringUTF16.indexOfChar([BIII)I&quot;,
356 
357                             // handled by an intrinsic for StringUTF16.indexOfLatin1Unsafe
358                             &quot;java/lang/StringUTF16.indexOfLatin1([BI[BII)I&quot;,
359                             &quot;java/lang/StringUTF16.indexOfLatin1([B[B)I&quot;);
360 
361             if (!config.useAESCTRIntrinsics) {
362                 add(ignore,
363                                 &quot;com/sun/crypto/provider/CounterMode.implCrypt([BII[BI)I&quot;);
364             }
365             if (!config.useGHASHIntrinsics()) {
366                 add(ignore,
367                                 &quot;com/sun/crypto/provider/GHASH.processBlocks([BII[J[J)V&quot;);
368             }
369             if (!config.useFMAIntrinsics) {
370                 add(ignore,
371                                 &quot;java/lang/Math.fma(DDD)D&quot;,
372                                 &quot;java/lang/Math.fma(FFF)F&quot;);
373             } else if (isSPARC(arch)) {
374                 add(toBeInvestigated,
375                                 &quot;java/lang/Math.fma(DDD)D&quot;,
376                                 &quot;java/lang/Math.fma(FFF)F&quot;);
377             }
378         }
379 
380         if (isJDK10OrHigher()) {
381             if (!(arch instanceof AArch64)) {
382                 add(toBeInvestigated,
383                                 &quot;java/lang/Math.multiplyHigh(JJ)J&quot;);
384             }
385         }
386 
387         if (isJDK11OrHigher()) {
388             // Relevant for Java flight recorder
389             add(toBeInvestigated,
390                             &quot;java/lang/CharacterDataLatin1.isDigit(I)Z&quot;,
391                             &quot;java/lang/CharacterDataLatin1.isLowerCase(I)Z&quot;,
392                             &quot;java/lang/CharacterDataLatin1.isUpperCase(I)Z&quot;,
393                             &quot;java/lang/CharacterDataLatin1.isWhitespace(I)Z&quot;,
394                             &quot;jdk/jfr/internal/JVM.getEventWriter()Ljava/lang/Object;&quot;);
395             if (!config.useBase64Intrinsics()) {
396                 add(ignore,
397                                 &quot;java/util/Base64$Encoder.encodeBlock([BII[BIZ)V&quot;);
398             }
399         }
400 
401         if (isJDK13OrHigher()) {
402             if (!(arch instanceof AArch64)) {
403                 add(toBeInvestigated,
404                                 &quot;java/lang/Math.abs(I)I&quot;,
405                                 &quot;java/lang/Math.abs(J)J&quot;);
406             }
407             add(toBeInvestigated,
408                             &quot;java/lang/Math.max(DD)D&quot;,
409                             &quot;java/lang/Math.max(FF)F&quot;,
410                             &quot;java/lang/Math.min(DD)D&quot;,
411                             &quot;java/lang/Math.min(FF)F&quot;);
412             add(toBeInvestigated,
413                             &quot;jdk/internal/misc/Unsafe.writeback0(J)V&quot;,
414                             &quot;jdk/internal/misc/Unsafe.writebackPostSync0()V&quot;,
415                             &quot;jdk/internal/misc/Unsafe.writebackPreSync0()V&quot;);
416         }
417 
418         if (isJDK14OrHigher()) {
419             add(toBeInvestigated,
420                             &quot;com/sun/crypto/provider/ElectronicCodeBook.implECBDecrypt([BII[BI)I&quot;,
421                             &quot;com/sun/crypto/provider/ElectronicCodeBook.implECBEncrypt([BII[BI)I&quot;,
422                             &quot;java/lang/Class.asIndirectType()Ljava/lang/Class;&quot;,
423                             &quot;java/lang/Class.asPrimaryType()Ljava/lang/Class;&quot;,
424                             &quot;java/math/BigInteger.shiftLeftImplWorker([I[IIII)V&quot;,
425                             &quot;java/math/BigInteger.shiftRightImplWorker([I[IIII)V&quot;,
426                             &quot;jdk/internal/misc/Unsafe.finishPrivateBuffer(Ljava/lang/Object;)Ljava/lang/Object;&quot;,
427                             &quot;jdk/internal/misc/Unsafe.getValue(Ljava/lang/Object;JLjava/lang/Class;)Ljava/lang/Object;&quot;,
428                             &quot;jdk/internal/misc/Unsafe.makePrivateBuffer(Ljava/lang/Object;)Ljava/lang/Object;&quot;,
429                             &quot;jdk/internal/misc/Unsafe.putValue(Ljava/lang/Object;JLjava/lang/Class;Ljava/lang/Object;)V&quot;);
430         }
431 
432         if (!config.inlineNotify()) {
433             add(ignore, &quot;java/lang/Object.notify()V&quot;);
434         }
435         if (!config.inlineNotifyAll()) {
436             add(ignore, &quot;java/lang/Object.notifyAll()V&quot;);
437         }
438 
439         if (!(arch instanceof AMD64)) {
440             // Can we implement these on non-AMD64 platforms? C2 seems to.
441             add(toBeInvestigated,
442                             &quot;com/sun/crypto/provider/CounterMode.implCrypt([BII[BI)I&quot;,
443                             &quot;java/lang/String.compareTo(Ljava/lang/String;)I&quot;,
444                             &quot;java/lang/StringLatin1.indexOf([B[B)I&quot;,
445                             &quot;java/lang/StringLatin1.inflate([BI[BII)V&quot;,
446                             &quot;java/lang/StringLatin1.inflate([BI[CII)V&quot;,
447                             &quot;java/lang/StringUTF16.compress([BI[BII)I&quot;,
448                             &quot;java/lang/StringUTF16.compress([CI[BII)I&quot;,
449                             &quot;java/lang/StringUTF16.indexOf([BI[BII)I&quot;,
450                             &quot;java/lang/StringUTF16.indexOf([B[B)I&quot;,
451                             &quot;java/lang/StringUTF16.indexOfChar([BIII)I&quot;,
452                             &quot;java/lang/StringUTF16.indexOfLatin1([BI[BII)I&quot;,
453                             &quot;java/lang/StringUTF16.indexOfLatin1([B[B)I&quot;,
454                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeByte(Ljava/lang/Object;JBB)B&quot;,
455                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeShort(Ljava/lang/Object;JSS)S&quot;,
456                             &quot;jdk/internal/misc/Unsafe.compareAndSetByte(Ljava/lang/Object;JBB)Z&quot;,
457                             &quot;jdk/internal/misc/Unsafe.compareAndSetShort(Ljava/lang/Object;JSS)Z&quot;,
458                             &quot;jdk/internal/misc/Unsafe.getAndAddByte(Ljava/lang/Object;JB)B&quot;,
459                             &quot;jdk/internal/misc/Unsafe.getAndAddShort(Ljava/lang/Object;JS)S&quot;,
460                             &quot;jdk/internal/misc/Unsafe.getAndSetByte(Ljava/lang/Object;JB)B&quot;,
461                             &quot;jdk/internal/misc/Unsafe.getAndSetShort(Ljava/lang/Object;JS)S&quot;,
462                             &quot;sun/misc/Unsafe.getAndAddInt(Ljava/lang/Object;JI)I&quot;,
463                             &quot;sun/misc/Unsafe.getAndAddLong(Ljava/lang/Object;JJ)J&quot;,
464                             &quot;sun/misc/Unsafe.getAndSetInt(Ljava/lang/Object;JI)I&quot;,
465                             &quot;sun/misc/Unsafe.getAndSetLong(Ljava/lang/Object;JJ)J&quot;,
466                             &quot;sun/misc/Unsafe.getAndSet&quot; + oopName + &quot;(Ljava/lang/Object;JLjava/lang/Object;)Ljava/lang/Object;&quot;);
467 
468             if (isJDK9OrHigher()) {
469                 if (!(arch instanceof AArch64)) {
470                     add(toBeInvestigated,
471                                     &quot;java/lang/StringLatin1.compareTo([B[B)I&quot;,
472                                     &quot;java/lang/StringLatin1.compareToUTF16([B[B)I&quot;,
473                                     &quot;java/lang/StringUTF16.compareTo([B[B)I&quot;,
474                                     &quot;java/lang/StringUTF16.compareToLatin1([B[B)I&quot;,
475                                     &quot;jdk/internal/misc/Unsafe.getAndAddInt(Ljava/lang/Object;JI)I&quot;,
476                                     &quot;jdk/internal/misc/Unsafe.getAndAddLong(Ljava/lang/Object;JJ)J&quot;,
477                                     &quot;jdk/internal/misc/Unsafe.getAndSetInt(Ljava/lang/Object;JI)I&quot;,
478                                     &quot;jdk/internal/misc/Unsafe.getAndSetLong(Ljava/lang/Object;JJ)J&quot;,
479                                     &quot;jdk/internal/misc/Unsafe.getAndSet&quot; + oopName + &quot;(Ljava/lang/Object;JLjava/lang/Object;)Ljava/lang/Object;&quot;);
480                 }
481                 add(toBeInvestigated,
482                                 &quot;java/lang/Thread.onSpinWait()V&quot;,
483                                 &quot;java/util/ArraysSupport.vectorizedMismatch(Ljava/lang/Object;JLjava/lang/Object;JII)I&quot;,
484                                 &quot;jdk/internal/misc/Unsafe.getCharUnaligned(Ljava/lang/Object;J)C&quot;,
485                                 &quot;jdk/internal/misc/Unsafe.getIntUnaligned(Ljava/lang/Object;J)I&quot;,
486                                 &quot;jdk/internal/misc/Unsafe.getLongUnaligned(Ljava/lang/Object;J)J&quot;,
487                                 &quot;jdk/internal/misc/Unsafe.getShortUnaligned(Ljava/lang/Object;J)S&quot;,
488                                 &quot;jdk/internal/misc/Unsafe.putCharUnaligned(Ljava/lang/Object;JC)V&quot;,
489                                 &quot;jdk/internal/misc/Unsafe.putIntUnaligned(Ljava/lang/Object;JI)V&quot;,
490                                 &quot;jdk/internal/misc/Unsafe.putLongUnaligned(Ljava/lang/Object;JJ)V&quot;,
491                                 &quot;jdk/internal/misc/Unsafe.putShortUnaligned(Ljava/lang/Object;JS)V&quot;);
492             }
493             if (isJDK10OrHigher()) {
494                 add(toBeInvestigated,
495                                 &quot;jdk/internal/util/ArraysSupport.vectorizedMismatch(Ljava/lang/Object;JLjava/lang/Object;JII)I&quot;);
496             }
497         }
498 
499         /*
500          * The intrinsics down here are known to be implemented but they are not always enabled on
501          * the HotSpot side (e.g., because they require certain CPU features). So, we are ignoring
502          * them if the HotSpot config tells us that they can&#39;t be used.
503          */
504 
505         // CRC32 intrinsics
506         if (!config.useCRC32Intrinsics) {
507             add(ignore, &quot;java/util/zip/CRC32.update(II)I&quot;);
508             if (isJDK9OrHigher()) {
509                 add(ignore,
510                                 &quot;java/util/zip/CRC32.updateByteBuffer0(IJII)I&quot;,
511                                 &quot;java/util/zip/CRC32.updateBytes0(I[BII)I&quot;);
512             } else {
513                 add(ignore,
514                                 &quot;java/util/zip/CRC32.updateByteBuffer(IJII)I&quot;,
515                                 &quot;java/util/zip/CRC32.updateBytes(I[BII)I&quot;);
516             }
517         }
518 
519         // CRC32C intrinsics
520         if (!config.useCRC32CIntrinsics) {
521             add(ignore,
522                             &quot;java/util/zip/CRC32C.updateBytes(I[BII)I&quot;,
523                             &quot;java/util/zip/CRC32C.updateDirectByteBuffer(IJII)I&quot;);
524         }
525 
526         String cbcEncryptName = HotSpotGraphBuilderPlugins.lookupIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implEncrypt&quot;, &quot;encrypt&quot;);
527         String cbcDecryptName = HotSpotGraphBuilderPlugins.lookupIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implDecrypt&quot;, &quot;decrypt&quot;);
528         String aesEncryptName = HotSpotGraphBuilderPlugins.lookupIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implEncryptBlock&quot;, &quot;encryptBlock&quot;);
529         String aesDecryptName = HotSpotGraphBuilderPlugins.lookupIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implDecryptBlock&quot;, &quot;decryptBlock&quot;);
530 
531         // AES intrinsics
532         if (!config.useAESIntrinsics) {
533             add(ignore,
534                             &quot;com/sun/crypto/provider/AESCrypt.&quot; + aesDecryptName + &quot;([BI[BI)V&quot;,
535                             &quot;com/sun/crypto/provider/AESCrypt.&quot; + aesEncryptName + &quot;([BI[BI)V&quot;,
536                             &quot;com/sun/crypto/provider/CipherBlockChaining.&quot; + cbcDecryptName + &quot;([BII[BI)I&quot;,
537                             &quot;com/sun/crypto/provider/CipherBlockChaining.&quot; + cbcEncryptName + &quot;([BII[BI)I&quot;);
538         }
539 
540         // BigInteger intrinsics
541         if (!config.useMultiplyToLenIntrinsic()) {
542             if (isJDK9OrHigher()) {
543                 add(ignore, &quot;java/math/BigInteger.implMultiplyToLen([II[II[I)[I&quot;);
544             } else {
545                 add(ignore, &quot;java/math/BigInteger.multiplyToLen([II[II[I)[I&quot;);
546             }
547         }
548         if (!config.useMulAddIntrinsic()) {
549             add(ignore, &quot;java/math/BigInteger.implMulAdd([I[IIII)I&quot;);
550         }
551         if (!config.useMontgomeryMultiplyIntrinsic()) {
552             add(ignore, &quot;java/math/BigInteger.implMontgomeryMultiply([I[I[IIJ[I)[I&quot;);
553         }
554         if (!config.useMontgomerySquareIntrinsic()) {
555             add(ignore, &quot;java/math/BigInteger.implMontgomerySquare([I[IIJ[I)[I&quot;);
556         }
557         if (!config.useSquareToLenIntrinsic()) {
558             add(ignore, &quot;java/math/BigInteger.implSquareToLen([II[II)[I&quot;);
559         }
560         // DigestBase intrinsics
561         if (HotSpotGraphBuilderPlugins.isIntrinsicName(config, &quot;sun/security/provider/DigestBase&quot;, &quot;implCompressMultiBlock0&quot;) &amp;&amp;
562                         !(config.useSHA1Intrinsics() || config.useSHA256Intrinsics() || config.useSHA512Intrinsics())) {
563             add(ignore, &quot;sun/security/provider/DigestBase.implCompressMultiBlock0([BII)I&quot;);
564         }
565         // SHA intrinsics
566         String shaCompressName = HotSpotGraphBuilderPlugins.lookupIntrinsicName(config, &quot;sun/security/provider/SHA&quot;, &quot;implCompress0&quot;, &quot;implCompress&quot;);
567         if (!config.useSHA1Intrinsics()) {
568             add(ignore, &quot;sun/security/provider/SHA.&quot; + shaCompressName + &quot;([BI)V&quot;);
569         }
570         if (!config.useSHA256Intrinsics()) {
571             add(ignore, &quot;sun/security/provider/SHA2.&quot; + shaCompressName + &quot;([BI)V&quot;);
572         }
573         if (!config.useSHA512Intrinsics()) {
574             add(ignore, &quot;sun/security/provider/SHA5.&quot; + shaCompressName + &quot;([BI)V&quot;);
575         }
576     }
577 
578     private static boolean isJDK9OrHigher() {
579         return JavaVersionUtil.JAVA_SPEC &gt;= 9;
580     }
581 
582     private static boolean isJDK10OrHigher() {
583         return JavaVersionUtil.JAVA_SPEC &gt;= 10;
584     }
585 
586     private static boolean isJDK11OrHigher() {
587         return JavaVersionUtil.JAVA_SPEC &gt;= 11;
588     }
589 
590     private static boolean isJDK12OrHigher() {
591         return JavaVersionUtil.JAVA_SPEC &gt;= 12;
592     }
593 
594     private static boolean isJDK13OrHigher() {
595         return JavaVersionUtil.JAVA_SPEC &gt;= 13;
596     }
597 
598     private static boolean isJDK14OrHigher() {
599         return JavaVersionUtil.JAVA_SPEC &gt;= 14;
600     }
601 
602     public interface Refiner {
603         void refine(CheckGraalIntrinsics checker);
604     }
605 
606     @Test
607     @SuppressWarnings(&quot;try&quot;)
608     public void test() throws ClassNotFoundException {
609         HotSpotProviders providers = rt.getHostBackend().getProviders();
610         Plugins graphBuilderPlugins = providers.getGraphBuilderPlugins();
611         InvocationPlugins invocationPlugins = graphBuilderPlugins.getInvocationPlugins();
612 
613         HotSpotVMConfigStore store = config.getStore();
614         List&lt;VMIntrinsicMethod&gt; intrinsics = store.getIntrinsics();
615 
616         for (Refiner refiner : ServiceLoader.load(Refiner.class)) {
617             refiner.refine(this);
618         }
619 
620         List&lt;String&gt; missing = new ArrayList&lt;&gt;();
621         List&lt;String&gt; mischaracterizedAsToBeInvestigated = new ArrayList&lt;&gt;();
622         List&lt;String&gt; mischaracterizedAsIgnored = new ArrayList&lt;&gt;();
623         EconomicMap&lt;String, List&lt;Binding&gt;&gt; bindings = invocationPlugins.getBindings(true);
624         for (VMIntrinsicMethod intrinsic : intrinsics) {
625             InvocationPlugin plugin = findPlugin(bindings, intrinsic);
626             String m = String.format(&quot;%s.%s%s&quot;, intrinsic.declaringClass, intrinsic.name, intrinsic.descriptor);
627             if (plugin == null) {
628                 ResolvedJavaMethod method = resolveIntrinsic(providers.getMetaAccess(), intrinsic);
629                 if (method != null) {
630                     IntrinsicMethod intrinsicMethod = providers.getConstantReflection().getMethodHandleAccess().lookupMethodHandleIntrinsic(method);
631                     if (intrinsicMethod != null) {
632                         continue;
633                     }
634                 }
635                 if (!toBeInvestigated.contains(m) &amp;&amp; !ignore.contains(m) &amp;&amp; !complexGuard.contains(m) &amp;&amp; !downstream.contains(m)) {
636                     missing.add(m);
637                 }
638             } else {
639                 if (toBeInvestigated.contains(m)) {
640                     mischaracterizedAsToBeInvestigated.add(m);
641                 } else if (ignore.contains(m)) {
642                     mischaracterizedAsIgnored.add(m);
643                 }
644             }
645         }
646 
647         Formatter errorMsgBuf = new Formatter();
648         if (!missing.isEmpty()) {
649             Collections.sort(missing);
650             String missingString = missing.stream().collect(Collectors.joining(String.format(&quot;%n    &quot;)));
651             errorMsgBuf.format(&quot;missing Graal intrinsics for:%n    %s%n&quot;, missingString);
652         }
653         if (!mischaracterizedAsToBeInvestigated.isEmpty()) {
654             Collections.sort(mischaracterizedAsToBeInvestigated);
655             String missingString = mischaracterizedAsToBeInvestigated.stream().collect(Collectors.joining(String.format(&quot;%n    &quot;)));
656             errorMsgBuf.format(&quot;found plugins for intrinsics characterized as toBeInvestigated:%n    %s%n&quot;, missingString);
657         }
658         if (!mischaracterizedAsIgnored.isEmpty()) {
659             Collections.sort(mischaracterizedAsIgnored);
660             String missingString = mischaracterizedAsIgnored.stream().collect(Collectors.joining(String.format(&quot;%n    &quot;)));
661             errorMsgBuf.format(&quot;found plugins for intrinsics characterized as IGNORED:%n    %s%n&quot;, missingString);
662         }
663         String errorMsg = errorMsgBuf.toString();
664         if (!errorMsg.isEmpty()) {
665             fail(errorMsg);
666         }
667     }
668 }
    </pre>
  </body>
</html>