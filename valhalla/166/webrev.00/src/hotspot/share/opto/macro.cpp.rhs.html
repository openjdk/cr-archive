<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/macro.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciFlatArrayKlass.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  29 #include &quot;libadt/vectset.hpp&quot;
  30 #include &quot;memory/universe.hpp&quot;
  31 #include &quot;opto/addnode.hpp&quot;
  32 #include &quot;opto/arraycopynode.hpp&quot;
  33 #include &quot;opto/callnode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/cfgnode.hpp&quot;
  36 #include &quot;opto/compile.hpp&quot;
  37 #include &quot;opto/convertnode.hpp&quot;
  38 #include &quot;opto/graphKit.hpp&quot;
  39 #include &quot;opto/inlinetypenode.hpp&quot;
  40 #include &quot;opto/intrinsicnode.hpp&quot;
  41 #include &quot;opto/locknode.hpp&quot;
  42 #include &quot;opto/loopnode.hpp&quot;
  43 #include &quot;opto/macro.hpp&quot;
  44 #include &quot;opto/memnode.hpp&quot;
  45 #include &quot;opto/narrowptrnode.hpp&quot;
  46 #include &quot;opto/node.hpp&quot;
  47 #include &quot;opto/opaquenode.hpp&quot;
  48 #include &quot;opto/phaseX.hpp&quot;
  49 #include &quot;opto/rootnode.hpp&quot;
  50 #include &quot;opto/runtime.hpp&quot;
  51 #include &quot;opto/subnode.hpp&quot;
  52 #include &quot;opto/subtypenode.hpp&quot;
  53 #include &quot;opto/type.hpp&quot;
  54 #include &quot;runtime/sharedRuntime.hpp&quot;
  55 #include &quot;utilities/macros.hpp&quot;
  56 #include &quot;utilities/powerOfTwo.hpp&quot;
  57 #if INCLUDE_G1GC
  58 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  59 #endif // INCLUDE_G1GC
  60 #if INCLUDE_SHENANDOAHGC
  61 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  62 #endif
  63 
  64 
  65 //
  66 // Replace any references to &quot;oldref&quot; in inputs to &quot;use&quot; with &quot;newref&quot;.
  67 // Returns the number of replacements made.
  68 //
  69 int PhaseMacroExpand::replace_input(Node *use, Node *oldref, Node *newref) {
  70   int nreplacements = 0;
  71   uint req = use-&gt;req();
  72   for (uint j = 0; j &lt; use-&gt;len(); j++) {
  73     Node *uin = use-&gt;in(j);
  74     if (uin == oldref) {
  75       if (j &lt; req)
  76         use-&gt;set_req(j, newref);
  77       else
  78         use-&gt;set_prec(j, newref);
  79       nreplacements++;
  80     } else if (j &gt;= req &amp;&amp; uin == NULL) {
  81       break;
  82     }
  83   }
  84   return nreplacements;
  85 }
  86 
  87 Node* PhaseMacroExpand::opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path) {
  88   Node* cmp;
  89   if (mask != 0) {
  90     Node* and_node = transform_later(new AndXNode(word, MakeConX(mask)));
  91     cmp = transform_later(new CmpXNode(and_node, MakeConX(bits)));
  92   } else {
  93     cmp = word;
  94   }
  95   Node* bol = transform_later(new BoolNode(cmp, BoolTest::ne));
  96   IfNode* iff = new IfNode( ctrl, bol, PROB_MIN, COUNT_UNKNOWN );
  97   transform_later(iff);
  98 
  99   // Fast path taken.
 100   Node *fast_taken = transform_later(new IfFalseNode(iff));
 101 
 102   // Fast path not-taken, i.e. slow path
 103   Node *slow_taken = transform_later(new IfTrueNode(iff));
 104 
 105   if (return_fast_path) {
 106     region-&gt;init_req(edge, slow_taken); // Capture slow-control
 107     return fast_taken;
 108   } else {
 109     region-&gt;init_req(edge, fast_taken); // Capture fast-control
 110     return slow_taken;
 111   }
 112 }
 113 
 114 //--------------------copy_predefined_input_for_runtime_call--------------------
 115 void PhaseMacroExpand::copy_predefined_input_for_runtime_call(Node * ctrl, CallNode* oldcall, CallNode* call) {
 116   // Set fixed predefined input arguments
 117   call-&gt;init_req( TypeFunc::Control, ctrl );
 118   call-&gt;init_req( TypeFunc::I_O    , oldcall-&gt;in( TypeFunc::I_O) );
 119   call-&gt;init_req( TypeFunc::Memory , oldcall-&gt;in( TypeFunc::Memory ) ); // ?????
 120   call-&gt;init_req( TypeFunc::ReturnAdr, oldcall-&gt;in( TypeFunc::ReturnAdr ) );
 121   call-&gt;init_req( TypeFunc::FramePtr, oldcall-&gt;in( TypeFunc::FramePtr ) );
 122 }
 123 
 124 //------------------------------make_slow_call---------------------------------
 125 CallNode* PhaseMacroExpand::make_slow_call(CallNode *oldcall, const TypeFunc* slow_call_type,
 126                                            address slow_call, const char* leaf_name, Node* slow_path,
 127                                            Node* parm0, Node* parm1, Node* parm2) {
 128 
 129   // Slow-path call
 130  CallNode *call = leaf_name
 131    ? (CallNode*)new CallLeafNode      ( slow_call_type, slow_call, leaf_name, TypeRawPtr::BOTTOM )
 132    : (CallNode*)new CallStaticJavaNode( slow_call_type, slow_call, OptoRuntime::stub_name(slow_call), oldcall-&gt;jvms()-&gt;bci(), TypeRawPtr::BOTTOM );
 133 
 134   // Slow path call has no side-effects, uses few values
 135   copy_predefined_input_for_runtime_call(slow_path, oldcall, call );
 136   if (parm0 != NULL)  call-&gt;init_req(TypeFunc::Parms+0, parm0);
 137   if (parm1 != NULL)  call-&gt;init_req(TypeFunc::Parms+1, parm1);
 138   if (parm2 != NULL)  call-&gt;init_req(TypeFunc::Parms+2, parm2);
 139   call-&gt;copy_call_debug_info(&amp;_igvn, oldcall);
 140   call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
 141   _igvn.replace_node(oldcall, call);
 142   transform_later(call);
 143 
 144   return call;
 145 }
 146 
 147 void PhaseMacroExpand::extract_call_projections(CallNode *call) {
 148   _fallthroughproj = NULL;
 149   _fallthroughcatchproj = NULL;
 150   _ioproj_fallthrough = NULL;
 151   _ioproj_catchall = NULL;
 152   _catchallcatchproj = NULL;
 153   _memproj_fallthrough = NULL;
 154   _memproj_catchall = NULL;
 155   _resproj = NULL;
 156   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
 157     ProjNode *pn = call-&gt;fast_out(i)-&gt;as_Proj();
 158     switch (pn-&gt;_con) {
 159       case TypeFunc::Control:
 160       {
 161         // For Control (fallthrough) and I_O (catch_all_index) we have CatchProj -&gt; Catch -&gt; Proj
 162         _fallthroughproj = pn;
 163         DUIterator_Fast jmax, j = pn-&gt;fast_outs(jmax);
 164         const Node *cn = pn-&gt;fast_out(j);
 165         if (cn-&gt;is_Catch()) {
 166           ProjNode *cpn = NULL;
 167           for (DUIterator_Fast kmax, k = cn-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 168             cpn = cn-&gt;fast_out(k)-&gt;as_Proj();
 169             assert(cpn-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
 170             if (cpn-&gt;_con == CatchProjNode::fall_through_index)
 171               _fallthroughcatchproj = cpn;
 172             else {
 173               assert(cpn-&gt;_con == CatchProjNode::catch_all_index, &quot;must be correct index.&quot;);
 174               _catchallcatchproj = cpn;
 175             }
 176           }
 177         }
 178         break;
 179       }
 180       case TypeFunc::I_O:
 181         if (pn-&gt;_is_io_use)
 182           _ioproj_catchall = pn;
 183         else
 184           _ioproj_fallthrough = pn;
 185         break;
 186       case TypeFunc::Memory:
 187         if (pn-&gt;_is_io_use)
 188           _memproj_catchall = pn;
 189         else
 190           _memproj_fallthrough = pn;
 191         break;
 192       case TypeFunc::Parms:
 193         _resproj = pn;
 194         break;
 195       default:
 196         assert(false, &quot;unexpected projection from allocation node.&quot;);
 197     }
 198   }
 199 
 200 }
 201 
 202 void PhaseMacroExpand::eliminate_gc_barrier(Node* p2x) {
 203   BarrierSetC2 *bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<a name="1" id="anc1"></a><span class="line-modified"> 204   bs-&gt;eliminate_gc_barrier(&amp;_igvn, p2x);</span>
 205 }
 206 
 207 // Search for a memory operation for the specified memory slice.
 208 static Node *scan_mem_chain(Node *mem, int alias_idx, int offset, Node *start_mem, Node *alloc, PhaseGVN *phase) {
 209   Node *orig_mem = mem;
 210   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 211   const TypeOopPtr *tinst = phase-&gt;C-&gt;get_adr_type(alias_idx)-&gt;isa_oopptr();
 212   while (true) {
 213     if (mem == alloc_mem || mem == start_mem ) {
 214       return mem;  // hit one of our sentinels
 215     } else if (mem-&gt;is_MergeMem()) {
 216       mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias_idx);
 217     } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;as_Proj()-&gt;_con == TypeFunc::Memory) {
 218       Node *in = mem-&gt;in(0);
 219       // we can safely skip over safepoints, calls, locks and membars because we
 220       // already know that the object is safe to eliminate.
 221       if (in-&gt;is_Initialize() &amp;&amp; in-&gt;as_Initialize()-&gt;allocation() == alloc) {
 222         return in;
 223       } else if (in-&gt;is_Call()) {
 224         CallNode *call = in-&gt;as_Call();
 225         if (call-&gt;may_modify(tinst, phase)) {
 226           assert(call-&gt;is_ArrayCopy(), &quot;ArrayCopy is the only call node that doesn&#39;t make allocation escape&quot;);
 227           if (call-&gt;as_ArrayCopy()-&gt;modifies(offset, offset, phase, false)) {
 228             return in;
 229           }
 230         }
 231         mem = in-&gt;in(TypeFunc::Memory);
 232       } else if (in-&gt;is_MemBar()) {
 233         ArrayCopyNode* ac = NULL;
 234         if (ArrayCopyNode::may_modify(tinst, in-&gt;as_MemBar(), phase, ac)) {
 235           assert(ac != NULL &amp;&amp; ac-&gt;is_clonebasic(), &quot;Only basic clone is a non escaping clone&quot;);
 236           return ac;
 237         }
 238         mem = in-&gt;in(TypeFunc::Memory);
 239       } else {
 240         assert(false, &quot;unexpected projection&quot;);
 241       }
 242     } else if (mem-&gt;is_Store()) {
 243       const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 244       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 245       if (adr_idx == alias_idx) {
 246         assert(atype-&gt;isa_oopptr(), &quot;address type must be oopptr&quot;);
 247         int adr_offset = atype-&gt;flattened_offset();
 248         uint adr_iid = atype-&gt;is_oopptr()-&gt;instance_id();
 249         // Array elements references have the same alias_idx
 250         // but different offset and different instance_id.
 251         if (adr_offset == offset &amp;&amp; adr_iid == alloc-&gt;_idx)
 252           return mem;
 253       } else {
 254         assert(adr_idx == Compile::AliasIdxRaw, &quot;address must match or be raw&quot;);
 255       }
 256       mem = mem-&gt;in(MemNode::Memory);
 257     } else if (mem-&gt;is_ClearArray()) {
 258       if (!ClearArrayNode::step_through(&amp;mem, alloc-&gt;_idx, phase)) {
 259         // Can not bypass initialization of the instance
 260         // we are looking.
 261         debug_only(intptr_t offset;)
 262         assert(alloc == AllocateNode::Ideal_allocation(mem-&gt;in(3), phase, offset), &quot;sanity&quot;);
 263         InitializeNode* init = alloc-&gt;as_Allocate()-&gt;initialization();
 264         // We are looking for stored value, return Initialize node
 265         // or memory edge from Allocate node.
 266         if (init != NULL)
 267           return init;
 268         else
 269           return alloc-&gt;in(TypeFunc::Memory); // It will produce zero value (see callers).
 270       }
 271       // Otherwise skip it (the call updated &#39;mem&#39; value).
 272     } else if (mem-&gt;Opcode() == Op_SCMemProj) {
 273       mem = mem-&gt;in(0);
 274       Node* adr = NULL;
 275       if (mem-&gt;is_LoadStore()) {
 276         adr = mem-&gt;in(MemNode::Address);
 277       } else {
 278         assert(mem-&gt;Opcode() == Op_EncodeISOArray ||
 279                mem-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 280         adr = mem-&gt;in(3); // Destination array
 281       }
 282       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 283       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 284       if (adr_idx == alias_idx) {
 285         DEBUG_ONLY(mem-&gt;dump();)
 286         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 287         return NULL;
 288       }
 289       mem = mem-&gt;in(MemNode::Memory);
 290     } else if (mem-&gt;Opcode() == Op_StrInflatedCopy) {
 291       Node* adr = mem-&gt;in(3); // Destination array
 292       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 293       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 294       if (adr_idx == alias_idx) {
 295         DEBUG_ONLY(mem-&gt;dump();)
 296         assert(false, &quot;Object is not scalar replaceable if a StrInflatedCopy node accesses its field&quot;);
 297         return NULL;
 298       }
 299       mem = mem-&gt;in(MemNode::Memory);
 300     } else {
 301       return mem;
 302     }
 303     assert(mem != orig_mem, &quot;dead memory loop&quot;);
 304   }
 305 }
 306 
 307 // Generate loads from source of the arraycopy for fields of
 308 // destination needed at a deoptimization point
 309 Node* PhaseMacroExpand::make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc) {
 310   BasicType bt = ft;
 311   const Type *type = ftype;
 312   if (ft == T_NARROWOOP) {
 313     bt = T_OBJECT;
 314     type = ftype-&gt;make_oopptr();
 315   }
 316   Node* res = NULL;
 317   if (ac-&gt;is_clonebasic()) {
 318     assert(ac-&gt;in(ArrayCopyNode::Src) != ac-&gt;in(ArrayCopyNode::Dest), &quot;clone source equals destination&quot;);
 319     Node* base = ac-&gt;in(ArrayCopyNode::Src);
 320     Node* adr = _igvn.transform(new AddPNode(base, base, MakeConX(offset)));
 321     const TypePtr* adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(offset);
 322     MergeMemNode* mergemen = MergeMemNode::make(mem);
 323     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 324     res = ArrayCopyNode::load(bs, &amp;_igvn, ctl, mergemen, adr, adr_type, type, bt);
 325   } else {
 326     if (ac-&gt;modifies(offset, offset, &amp;_igvn, true)) {
 327       assert(ac-&gt;in(ArrayCopyNode::Dest) == alloc-&gt;result_cast(), &quot;arraycopy destination should be allocation&#39;s result&quot;);
 328       uint shift = exact_log2(type2aelembytes(bt));
 329       Node* src_pos = ac-&gt;in(ArrayCopyNode::SrcPos);
 330       Node* dest_pos = ac-&gt;in(ArrayCopyNode::DestPos);
 331       const TypeInt* src_pos_t = _igvn.type(src_pos)-&gt;is_int();
 332       const TypeInt* dest_pos_t = _igvn.type(dest_pos)-&gt;is_int();
 333 
 334       Node* adr = NULL;
 335       Node* base = ac-&gt;in(ArrayCopyNode::Src);
 336       const TypePtr* adr_type = _igvn.type(base)-&gt;is_ptr();
 337       assert(adr_type-&gt;isa_aryptr(), &quot;only arrays here&quot;);
 338       if (src_pos_t-&gt;is_con() &amp;&amp; dest_pos_t-&gt;is_con()) {
 339         intptr_t off = ((src_pos_t-&gt;get_con() - dest_pos_t-&gt;get_con()) &lt;&lt; shift) + offset;
 340         adr = _igvn.transform(new AddPNode(base, base, MakeConX(off)));
 341         adr_type = _igvn.type(adr)-&gt;is_ptr();
 342         assert(adr_type == _igvn.type(base)-&gt;is_aryptr()-&gt;add_field_offset_and_offset(off), &quot;incorrect address type&quot;);
 343         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {
 344           // Don&#39;t emit a new load from src if src == dst but try to get the value from memory instead
 345           return value_from_mem(ac-&gt;in(TypeFunc::Memory), ctl, ft, ftype, adr_type-&gt;isa_oopptr(), alloc);
 346         }
 347       } else {
 348         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {
 349           // Non constant offset in the array: we can&#39;t statically
 350           // determine the value
 351           return NULL;
 352         }
 353         Node* diff = _igvn.transform(new SubINode(ac-&gt;in(ArrayCopyNode::SrcPos), ac-&gt;in(ArrayCopyNode::DestPos)));
 354 #ifdef _LP64
 355         diff = _igvn.transform(new ConvI2LNode(diff));
 356 #endif
 357         diff = _igvn.transform(new LShiftXNode(diff, intcon(shift)));
 358 
 359         Node* off = _igvn.transform(new AddXNode(MakeConX(offset), diff));
 360         adr = _igvn.transform(new AddPNode(base, base, off));
 361         // In the case of a flattened inline type array, each field has its
 362         // own slice so we need to extract the field being accessed from
 363         // the address computation
 364         adr_type = adr_type-&gt;is_aryptr()-&gt;add_field_offset_and_offset(offset)-&gt;add_offset(Type::OffsetBot);
 365         adr = _igvn.transform(new CastPPNode(adr, adr_type));
 366       }
 367       MergeMemNode* mergemen = MergeMemNode::make(mem);
 368       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 369       res = ArrayCopyNode::load(bs, &amp;_igvn, ctl, mergemen, adr, adr_type, type, bt);
 370     }
 371   }
 372   if (res != NULL) {
 373     if (ftype-&gt;isa_narrowoop()) {
 374       // PhaseMacroExpand::scalar_replacement adds DecodeN nodes
 375       assert(res-&gt;isa_DecodeN(), &quot;should be narrow oop&quot;);
 376       res = _igvn.transform(new EncodePNode(res, ftype));
 377     }
 378     return res;
 379   }
 380   return NULL;
 381 }
 382 
 383 //
 384 // Given a Memory Phi, compute a value Phi containing the values from stores
 385 // on the input paths.
 386 // Note: this function is recursive, its depth is limited by the &quot;level&quot; argument
 387 // Returns the computed Phi, or NULL if it cannot compute it.
 388 Node *PhaseMacroExpand::value_from_mem_phi(Node *mem, BasicType ft, const Type *phi_type, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level) {
 389   assert(mem-&gt;is_Phi(), &quot;sanity&quot;);
 390   int alias_idx = C-&gt;get_alias_index(adr_t);
 391   int offset = adr_t-&gt;flattened_offset();
 392   int instance_id = adr_t-&gt;instance_id();
 393 
 394   // Check if an appropriate value phi already exists.
 395   Node* region = mem-&gt;in(0);
 396   for (DUIterator_Fast kmax, k = region-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 397     Node* phi = region-&gt;fast_out(k);
 398     if (phi-&gt;is_Phi() &amp;&amp; phi != mem &amp;&amp;
 399         phi-&gt;as_Phi()-&gt;is_same_inst_field(phi_type, (int)mem-&gt;_idx, instance_id, alias_idx, offset)) {
 400       return phi;
 401     }
 402   }
 403   // Check if an appropriate new value phi already exists.
 404   Node* new_phi = value_phis-&gt;find(mem-&gt;_idx);
 405   if (new_phi != NULL)
 406     return new_phi;
 407 
 408   if (level &lt;= 0) {
 409     return NULL; // Give up: phi tree too deep
 410   }
 411   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 412   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 413 
 414   uint length = mem-&gt;req();
 415   GrowableArray &lt;Node *&gt; values(length, length, NULL);
 416 
 417   // create a new Phi for the value
 418   PhiNode *phi = new PhiNode(mem-&gt;in(0), phi_type, NULL, mem-&gt;_idx, instance_id, alias_idx, offset);
 419   transform_later(phi);
 420   value_phis-&gt;push(phi, mem-&gt;_idx);
 421 
 422   for (uint j = 1; j &lt; length; j++) {
 423     Node *in = mem-&gt;in(j);
 424     if (in == NULL || in-&gt;is_top()) {
 425       values.at_put(j, in);
 426     } else  {
 427       Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 428       if (val == start_mem || val == alloc_mem) {
 429         // hit a sentinel, return appropriate 0 value
 430         Node* default_value = alloc-&gt;in(AllocateNode::DefaultValue);
 431         if (default_value != NULL) {
 432           values.at_put(j, default_value);
 433         } else {
 434           assert(alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);
 435           values.at_put(j, _igvn.zerocon(ft));
 436         }
 437         continue;
 438       }
 439       if (val-&gt;is_Initialize()) {
 440         val = val-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 441       }
 442       if (val == NULL) {
 443         return NULL;  // can&#39;t find a value on this path
 444       }
 445       if (val == mem) {
 446         values.at_put(j, mem);
 447       } else if (val-&gt;is_Store()) {
 448         Node* n = val-&gt;in(MemNode::ValueIn);
 449         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 450         n = bs-&gt;step_over_gc_barrier(n);
 451         values.at_put(j, n);
 452       } else if(val-&gt;is_Proj() &amp;&amp; val-&gt;in(0) == alloc) {
 453         Node* default_value = alloc-&gt;in(AllocateNode::DefaultValue);
 454         if (default_value != NULL) {
 455           values.at_put(j, default_value);
 456         } else {
 457           assert(alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);
 458           values.at_put(j, _igvn.zerocon(ft));
 459         }
 460       } else if (val-&gt;is_Phi()) {
 461         val = value_from_mem_phi(val, ft, phi_type, adr_t, alloc, value_phis, level-1);
 462         if (val == NULL) {
 463           return NULL;
 464         }
 465         values.at_put(j, val);
 466       } else if (val-&gt;Opcode() == Op_SCMemProj) {
 467         assert(val-&gt;in(0)-&gt;is_LoadStore() ||
 468                val-&gt;in(0)-&gt;Opcode() == Op_EncodeISOArray ||
 469                val-&gt;in(0)-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 470         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 471         return NULL;
 472       } else if (val-&gt;is_ArrayCopy()) {
 473         Node* res = make_arraycopy_load(val-&gt;as_ArrayCopy(), offset, val-&gt;in(0), val-&gt;in(TypeFunc::Memory), ft, phi_type, alloc);
 474         if (res == NULL) {
 475           return NULL;
 476         }
 477         values.at_put(j, res);
 478       } else {
 479 #ifdef ASSERT
 480         val-&gt;dump();
 481         assert(false, &quot;unknown node on this path&quot;);
 482 #endif
 483         return NULL;  // unknown node on this path
 484       }
 485     }
 486   }
 487   // Set Phi&#39;s inputs
 488   for (uint j = 1; j &lt; length; j++) {
 489     if (values.at(j) == mem) {
 490       phi-&gt;init_req(j, phi);
 491     } else {
 492       phi-&gt;init_req(j, values.at(j));
 493     }
 494   }
 495   return phi;
 496 }
 497 
 498 // Search the last value stored into the object&#39;s field.
 499 Node *PhaseMacroExpand::value_from_mem(Node *sfpt_mem, Node *sfpt_ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc) {
 500   assert(adr_t-&gt;is_known_instance_field(), &quot;instance required&quot;);
 501   int instance_id = adr_t-&gt;instance_id();
 502   assert((uint)instance_id == alloc-&gt;_idx, &quot;wrong allocation&quot;);
 503 
 504   int alias_idx = C-&gt;get_alias_index(adr_t);
 505   int offset = adr_t-&gt;flattened_offset();
 506   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 507   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 508   VectorSet visited;
 509 
 510   bool done = sfpt_mem == alloc_mem;
 511   Node *mem = sfpt_mem;
 512   while (!done) {
 513     if (visited.test_set(mem-&gt;_idx)) {
 514       return NULL;  // found a loop, give up
 515     }
 516     mem = scan_mem_chain(mem, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 517     if (mem == start_mem || mem == alloc_mem) {
 518       done = true;  // hit a sentinel, return appropriate 0 value
 519     } else if (mem-&gt;is_Initialize()) {
 520       mem = mem-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 521       if (mem == NULL) {
 522         done = true; // Something went wrong.
 523       } else if (mem-&gt;is_Store()) {
 524         const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 525         assert(C-&gt;get_alias_index(atype) == Compile::AliasIdxRaw, &quot;store is correct memory slice&quot;);
 526         done = true;
 527       }
 528     } else if (mem-&gt;is_Store()) {
 529       const TypeOopPtr* atype = mem-&gt;as_Store()-&gt;adr_type()-&gt;isa_oopptr();
 530       assert(atype != NULL, &quot;address type must be oopptr&quot;);
 531       assert(C-&gt;get_alias_index(atype) == alias_idx &amp;&amp;
 532              atype-&gt;is_known_instance_field() &amp;&amp; atype-&gt;flattened_offset() == offset &amp;&amp;
 533              atype-&gt;instance_id() == instance_id, &quot;store is correct memory slice&quot;);
 534       done = true;
 535     } else if (mem-&gt;is_Phi()) {
 536       // try to find a phi&#39;s unique input
 537       Node *unique_input = NULL;
 538       Node *top = C-&gt;top();
 539       for (uint i = 1; i &lt; mem-&gt;req(); i++) {
 540         Node *n = scan_mem_chain(mem-&gt;in(i), alias_idx, offset, start_mem, alloc, &amp;_igvn);
 541         if (n == NULL || n == top || n == mem) {
 542           continue;
 543         } else if (unique_input == NULL) {
 544           unique_input = n;
 545         } else if (unique_input != n) {
 546           unique_input = top;
 547           break;
 548         }
 549       }
 550       if (unique_input != NULL &amp;&amp; unique_input != top) {
 551         mem = unique_input;
 552       } else {
 553         done = true;
 554       }
 555     } else if (mem-&gt;is_ArrayCopy()) {
 556       done = true;
 557     } else {
 558       assert(false, &quot;unexpected node&quot;);
 559     }
 560   }
 561   if (mem != NULL) {
 562     if (mem == start_mem || mem == alloc_mem) {
 563       // hit a sentinel, return appropriate 0 value
 564       Node* default_value = alloc-&gt;in(AllocateNode::DefaultValue);
 565       if (default_value != NULL) {
 566         return default_value;
 567       }
 568       assert(alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);
 569       return _igvn.zerocon(ft);
 570     } else if (mem-&gt;is_Store()) {
 571       Node* n = mem-&gt;in(MemNode::ValueIn);
 572       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 573       n = bs-&gt;step_over_gc_barrier(n);
 574       return n;
 575     } else if (mem-&gt;is_Phi()) {
 576       // attempt to produce a Phi reflecting the values on the input paths of the Phi
 577       Node_Stack value_phis(8);
 578       Node* phi = value_from_mem_phi(mem, ft, ftype, adr_t, alloc, &amp;value_phis, ValueSearchLimit);
 579       if (phi != NULL) {
 580         return phi;
 581       } else {
 582         // Kill all new Phis
 583         while(value_phis.is_nonempty()) {
 584           Node* n = value_phis.node();
 585           _igvn.replace_node(n, C-&gt;top());
 586           value_phis.pop();
 587         }
 588       }
 589     } else if (mem-&gt;is_ArrayCopy()) {
 590       Node* ctl = mem-&gt;in(0);
 591       Node* m = mem-&gt;in(TypeFunc::Memory);
 592       if (sfpt_ctl-&gt;is_Proj() &amp;&amp; sfpt_ctl-&gt;as_Proj()-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none)) {
 593         // pin the loads in the uncommon trap path
 594         ctl = sfpt_ctl;
 595         m = sfpt_mem;
 596       }
 597       return make_arraycopy_load(mem-&gt;as_ArrayCopy(), offset, ctl, m, ft, ftype, alloc);
 598     }
 599   }
 600   // Something went wrong.
 601   return NULL;
 602 }
 603 
 604 // Search the last value stored into the inline type&#39;s fields.
 605 Node* PhaseMacroExpand::inline_type_from_mem(Node* mem, Node* ctl, ciInlineKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc) {
 606   // Subtract the offset of the first field to account for the missing oop header
 607   offset -= vk-&gt;first_field_offset();
 608   // Create a new InlineTypeNode and retrieve the field values from memory
 609   InlineTypeNode* vt = InlineTypeNode::make_uninitialized(_igvn, vk)-&gt;as_InlineType();
 610   for (int i = 0; i &lt; vk-&gt;nof_declared_nonstatic_fields(); ++i) {
 611     ciType* field_type = vt-&gt;field_type(i);
 612     int field_offset = offset + vt-&gt;field_offset(i);
 613     // Each inline type field has its own memory slice
 614     adr_type = adr_type-&gt;with_field_offset(field_offset);
 615     Node* value = NULL;
 616     if (vt-&gt;field_is_flattened(i)) {
 617       value = inline_type_from_mem(mem, ctl, field_type-&gt;as_inline_klass(), adr_type, field_offset, alloc);
 618     } else {
 619       const Type* ft = Type::get_const_type(field_type);
 620       BasicType bt = field_type-&gt;basic_type();
 621       if (UseCompressedOops &amp;&amp; !is_java_primitive(bt)) {
 622         ft = ft-&gt;make_narrowoop();
 623         bt = T_NARROWOOP;
 624       }
 625       value = value_from_mem(mem, ctl, bt, ft, adr_type, alloc);
 626       if (value != NULL &amp;&amp; ft-&gt;isa_narrowoop()) {
 627         assert(UseCompressedOops, &quot;unexpected narrow oop&quot;);
 628         value = transform_later(new DecodeNNode(value, value-&gt;get_ptr_type()));
 629       }
 630     }
 631     if (value != NULL) {
 632       vt-&gt;set_field_value(i, value);
 633     } else {
 634       // We might have reached the TrackedInitializationLimit
 635       return NULL;
 636     }
 637   }
 638   return transform_later(vt);
 639 }
 640 
 641 // Check the possibility of scalar replacement.
 642 bool PhaseMacroExpand::can_eliminate_allocation(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints) {
 643   //  Scan the uses of the allocation to check for anything that would
 644   //  prevent us from eliminating it.
 645   NOT_PRODUCT( const char* fail_eliminate = NULL; )
 646   DEBUG_ONLY( Node* disq_node = NULL; )
 647   bool  can_eliminate = true;
 648 
 649   Node* res = alloc-&gt;result_cast();
 650   const TypeOopPtr* res_type = NULL;
 651   if (res == NULL) {
 652     // All users were eliminated.
 653   } else if (!res-&gt;is_CheckCastPP()) {
 654     NOT_PRODUCT(fail_eliminate = &quot;Allocation does not have unique CheckCastPP&quot;;)
 655     can_eliminate = false;
 656   } else {
 657     res_type = _igvn.type(res)-&gt;isa_oopptr();
 658     if (res_type == NULL) {
 659       NOT_PRODUCT(fail_eliminate = &quot;Neither instance or array allocation&quot;;)
 660       can_eliminate = false;
 661     } else if (res_type-&gt;isa_aryptr()) {
 662       int length = alloc-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 663       if (length &lt; 0) {
 664         NOT_PRODUCT(fail_eliminate = &quot;Array&#39;s size is not constant&quot;;)
 665         can_eliminate = false;
 666       }
 667     }
 668   }
 669 
 670   if (can_eliminate &amp;&amp; res != NULL) {
 671     for (DUIterator_Fast jmax, j = res-&gt;fast_outs(jmax);
 672                                j &lt; jmax &amp;&amp; can_eliminate; j++) {
 673       Node* use = res-&gt;fast_out(j);
 674 
 675       if (use-&gt;is_AddP()) {
 676         const TypePtr* addp_type = _igvn.type(use)-&gt;is_ptr();
 677         int offset = addp_type-&gt;offset();
 678 
 679         if (offset == Type::OffsetTop || offset == Type::OffsetBot) {
 680           NOT_PRODUCT(fail_eliminate = &quot;Undefined field referrence&quot;;)
 681           can_eliminate = false;
 682           break;
 683         }
 684         for (DUIterator_Fast kmax, k = use-&gt;fast_outs(kmax);
 685                                    k &lt; kmax &amp;&amp; can_eliminate; k++) {
 686           Node* n = use-&gt;fast_out(k);
 687           if (!n-&gt;is_Store() &amp;&amp; n-&gt;Opcode() != Op_CastP2X
 688               SHENANDOAHGC_ONLY(&amp;&amp; (!UseShenandoahGC || !ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(n))) ) {
 689             DEBUG_ONLY(disq_node = n;)
 690             if (n-&gt;is_Load() || n-&gt;is_LoadStore()) {
 691               NOT_PRODUCT(fail_eliminate = &quot;Field load&quot;;)
 692             } else {
 693               NOT_PRODUCT(fail_eliminate = &quot;Not store field reference&quot;;)
 694             }
 695             can_eliminate = false;
 696           }
 697         }
 698       } else if (use-&gt;is_ArrayCopy() &amp;&amp;
 699                  (use-&gt;as_ArrayCopy()-&gt;is_clonebasic() ||
 700                   use-&gt;as_ArrayCopy()-&gt;is_arraycopy_validated() ||
 701                   use-&gt;as_ArrayCopy()-&gt;is_copyof_validated() ||
 702                   use-&gt;as_ArrayCopy()-&gt;is_copyofrange_validated()) &amp;&amp;
 703                  use-&gt;in(ArrayCopyNode::Dest) == res) {
 704         // ok to eliminate
 705       } else if (use-&gt;is_SafePoint()) {
 706         SafePointNode* sfpt = use-&gt;as_SafePoint();
 707         if (sfpt-&gt;is_Call() &amp;&amp; sfpt-&gt;as_Call()-&gt;has_non_debug_use(res)) {
 708           // Object is passed as argument.
 709           DEBUG_ONLY(disq_node = use;)
 710           NOT_PRODUCT(fail_eliminate = &quot;Object is passed as argument&quot;;)
 711           can_eliminate = false;
 712         }
 713         Node* sfptMem = sfpt-&gt;memory();
 714         if (sfptMem == NULL || sfptMem-&gt;is_top()) {
 715           DEBUG_ONLY(disq_node = use;)
 716           NOT_PRODUCT(fail_eliminate = &quot;NULL or TOP memory&quot;;)
 717           can_eliminate = false;
 718         } else {
 719           safepoints.append_if_missing(sfpt);
 720         }
 721       } else if (use-&gt;is_InlineType() &amp;&amp; use-&gt;isa_InlineType()-&gt;get_oop() == res) {
 722         // ok to eliminate
 723       } else if (use-&gt;Opcode() == Op_StoreX &amp;&amp; use-&gt;in(MemNode::Address) == res) {
<a name="2" id="anc2"></a><span class="line-modified"> 724         // Store to mark word of inline type larval buffer</span>
<span class="line-added"> 725         assert(res_type-&gt;is_inlinetypeptr(), &quot;Unexpected store to mark word&quot;);</span>
 726       } else if (use-&gt;Opcode() != Op_CastP2X) { // CastP2X is used by card mark
 727         if (use-&gt;is_Phi()) {
 728           if (use-&gt;outcnt() == 1 &amp;&amp; use-&gt;unique_out()-&gt;Opcode() == Op_Return) {
 729             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
 730           } else {
 731             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by Phi&quot;;)
 732           }
 733           DEBUG_ONLY(disq_node = use;)
 734         } else {
 735           if (use-&gt;Opcode() == Op_Return) {
 736             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
 737           } else {
 738             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by node&quot;;)
 739           }
 740           DEBUG_ONLY(disq_node = use;)
 741         }
 742         can_eliminate = false;
 743       } else {
 744         assert(use-&gt;Opcode() == Op_CastP2X, &quot;should be&quot;);
 745         assert(!use-&gt;has_out_with(Op_OrL), &quot;should have been removed because oop is never null&quot;);
 746       }
 747     }
 748   }
 749 
 750 #ifndef PRODUCT
 751   if (PrintEliminateAllocations) {
 752     if (can_eliminate) {
 753       tty-&gt;print(&quot;Scalar &quot;);
 754       if (res == NULL)
 755         alloc-&gt;dump();
 756       else
 757         res-&gt;dump();
 758     } else if (alloc-&gt;_is_scalar_replaceable) {
 759       tty-&gt;print(&quot;NotScalar (%s)&quot;, fail_eliminate);
 760       if (res == NULL)
 761         alloc-&gt;dump();
 762       else
 763         res-&gt;dump();
 764 #ifdef ASSERT
 765       if (disq_node != NULL) {
 766           tty-&gt;print(&quot;  &gt;&gt;&gt;&gt; &quot;);
 767           disq_node-&gt;dump();
 768       }
 769 #endif /*ASSERT*/
 770     }
 771   }
 772 #endif
 773   return can_eliminate;
 774 }
 775 
 776 // Do scalar replacement.
 777 bool PhaseMacroExpand::scalar_replacement(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints) {
 778   GrowableArray &lt;SafePointNode *&gt; safepoints_done;
 779 
 780   ciKlass* klass = NULL;
 781   ciInstanceKlass* iklass = NULL;
 782   int nfields = 0;
 783   int array_base = 0;
 784   int element_size = 0;
 785   BasicType basic_elem_type = T_ILLEGAL;
 786   ciType* elem_type = NULL;
 787 
 788   Node* res = alloc-&gt;result_cast();
 789   assert(res == NULL || res-&gt;is_CheckCastPP(), &quot;unexpected AllocateNode result&quot;);
 790   const TypeOopPtr* res_type = NULL;
 791   if (res != NULL) { // Could be NULL when there are no users
 792     res_type = _igvn.type(res)-&gt;isa_oopptr();
 793   }
 794 
 795   if (res != NULL) {
 796     klass = res_type-&gt;klass();
 797     if (res_type-&gt;isa_instptr()) {
 798       // find the fields of the class which will be needed for safepoint debug information
 799       assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass.&quot;);
 800       iklass = klass-&gt;as_instance_klass();
 801       nfields = iklass-&gt;nof_nonstatic_fields();
 802     } else {
 803       // find the array&#39;s elements which will be needed for safepoint debug information
 804       nfields = alloc-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 805       assert(klass-&gt;is_array_klass() &amp;&amp; nfields &gt;= 0, &quot;must be an array klass.&quot;);
 806       elem_type = klass-&gt;as_array_klass()-&gt;element_type();
 807       basic_elem_type = elem_type-&gt;basic_type();
 808       if (elem_type-&gt;is_inlinetype() &amp;&amp; !klass-&gt;is_flat_array_klass()) {
 809         assert(basic_elem_type == T_INLINE_TYPE, &quot;unexpected element basic type&quot;);
 810         basic_elem_type = T_OBJECT;
 811       }
 812       array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
 813       element_size = type2aelembytes(basic_elem_type);
 814       if (klass-&gt;is_flat_array_klass()) {
 815         // Flattened inline type array
 816         element_size = klass-&gt;as_flat_array_klass()-&gt;element_byte_size();
 817       }
 818     }
 819   }
 820   //
 821   // Process the safepoint uses
 822   //
 823   Unique_Node_List value_worklist;
 824   while (safepoints.length() &gt; 0) {
 825     SafePointNode* sfpt = safepoints.pop();
 826     Node* mem = sfpt-&gt;memory();
 827     Node* ctl = sfpt-&gt;control();
 828     assert(sfpt-&gt;jvms() != NULL, &quot;missed JVMS&quot;);
 829     // Fields of scalar objs are referenced only at the end
 830     // of regular debuginfo at the last (youngest) JVMS.
 831     // Record relative start index.
 832     uint first_ind = (sfpt-&gt;req() - sfpt-&gt;jvms()-&gt;scloff());
 833     SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type,
 834 #ifdef ASSERT
 835                                                  alloc,
 836 #endif
 837                                                  first_ind, nfields);
 838     sobj-&gt;init_req(0, C-&gt;root());
 839     transform_later(sobj);
 840 
 841     // Scan object&#39;s fields adding an input to the safepoint for each field.
 842     for (int j = 0; j &lt; nfields; j++) {
 843       intptr_t offset;
 844       ciField* field = NULL;
 845       if (iklass != NULL) {
 846         field = iklass-&gt;nonstatic_field_at(j);
 847         offset = field-&gt;offset();
 848         elem_type = field-&gt;type();
 849         basic_elem_type = field-&gt;layout_type();
 850         assert(!field-&gt;is_flattened(), &quot;flattened inline type fields should not have safepoint uses&quot;);
 851       } else {
 852         offset = array_base + j * (intptr_t)element_size;
 853       }
 854 
 855       const Type *field_type;
 856       // The next code is taken from Parse::do_get_xxx().
 857       if (is_reference_type(basic_elem_type)) {
 858         if (!elem_type-&gt;is_loaded()) {
 859           field_type = TypeInstPtr::BOTTOM;
 860         } else if (field != NULL &amp;&amp; field-&gt;is_static_constant()) {
 861           // This can happen if the constant oop is non-perm.
 862           ciObject* con = field-&gt;constant_value().as_object();
 863           // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
 864           // and may yield a vacuous result if the field is of interface type.
 865           field_type = TypeOopPtr::make_from_constant(con)-&gt;isa_oopptr();
 866           assert(field_type != NULL, &quot;field singleton type must be consistent&quot;);
 867         } else {
 868           field_type = TypeOopPtr::make_from_klass(elem_type-&gt;as_klass());
 869         }
 870         if (UseCompressedOops) {
 871           field_type = field_type-&gt;make_narrowoop();
 872           basic_elem_type = T_NARROWOOP;
 873         }
 874       } else {
 875         field_type = Type::get_const_basic_type(basic_elem_type);
 876       }
 877 
 878       Node* field_val = NULL;
 879       const TypeOopPtr* field_addr_type = res_type-&gt;add_offset(offset)-&gt;isa_oopptr();
 880       if (klass-&gt;is_flat_array_klass()) {
 881         ciInlineKlass* vk = elem_type-&gt;as_inline_klass();
 882         assert(vk-&gt;flatten_array(), &quot;must be flattened&quot;);
 883         field_val = inline_type_from_mem(mem, ctl, vk, field_addr_type-&gt;isa_aryptr(), 0, alloc);
 884       } else {
 885         field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);
 886       }
 887       if (field_val == NULL) {
 888         // We weren&#39;t able to find a value for this field,
 889         // give up on eliminating this allocation.
 890 
 891         // Remove any extra entries we added to the safepoint.
 892         uint last = sfpt-&gt;req() - 1;
 893         for (int k = 0;  k &lt; j; k++) {
 894           sfpt-&gt;del_req(last--);
 895         }
 896         _igvn._worklist.push(sfpt);
 897         // rollback processed safepoints
 898         while (safepoints_done.length() &gt; 0) {
 899           SafePointNode* sfpt_done = safepoints_done.pop();
 900           // remove any extra entries we added to the safepoint
 901           last = sfpt_done-&gt;req() - 1;
 902           for (int k = 0;  k &lt; nfields; k++) {
 903             sfpt_done-&gt;del_req(last--);
 904           }
 905           JVMState *jvms = sfpt_done-&gt;jvms();
 906           jvms-&gt;set_endoff(sfpt_done-&gt;req());
 907           // Now make a pass over the debug information replacing any references
 908           // to SafePointScalarObjectNode with the allocated object.
 909           int start = jvms-&gt;debug_start();
 910           int end   = jvms-&gt;debug_end();
 911           for (int i = start; i &lt; end; i++) {
 912             if (sfpt_done-&gt;in(i)-&gt;is_SafePointScalarObject()) {
 913               SafePointScalarObjectNode* scobj = sfpt_done-&gt;in(i)-&gt;as_SafePointScalarObject();
 914               if (scobj-&gt;first_index(jvms) == sfpt_done-&gt;req() &amp;&amp;
 915                   scobj-&gt;n_fields() == (uint)nfields) {
 916                 assert(scobj-&gt;alloc() == alloc, &quot;sanity&quot;);
 917                 sfpt_done-&gt;set_req(i, res);
 918               }
 919             }
 920           }
 921           _igvn._worklist.push(sfpt_done);
 922         }
 923 #ifndef PRODUCT
 924         if (PrintEliminateAllocations) {
 925           if (field != NULL) {
 926             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of Field: &quot;,
 927                        sfpt-&gt;_idx);
 928             field-&gt;print();
 929             int field_idx = C-&gt;get_alias_index(field_addr_type);
 930             tty-&gt;print(&quot; (alias_idx=%d)&quot;, field_idx);
 931           } else { // Array&#39;s element
 932             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of array element [%d]&quot;,
 933                        sfpt-&gt;_idx, j);
 934           }
 935           tty-&gt;print(&quot;, which prevents elimination of: &quot;);
 936           if (res == NULL)
 937             alloc-&gt;dump();
 938           else
 939             res-&gt;dump();
 940         }
 941 #endif
 942         return false;
 943       }
 944       if (field_val-&gt;is_InlineType()) {
 945         // Keep track of inline types to scalarize them later
 946         value_worklist.push(field_val);
 947       } else if (UseCompressedOops &amp;&amp; field_type-&gt;isa_narrowoop()) {
 948         // Enable &quot;DecodeN(EncodeP(Allocate)) --&gt; Allocate&quot; transformation
 949         // to be able scalar replace the allocation.
 950         if (field_val-&gt;is_EncodeP()) {
 951           field_val = field_val-&gt;in(1);
 952         } else {
 953           field_val = transform_later(new DecodeNNode(field_val, field_val-&gt;get_ptr_type()));
 954         }
 955       }
 956       sfpt-&gt;add_req(field_val);
 957     }
 958     JVMState *jvms = sfpt-&gt;jvms();
 959     jvms-&gt;set_endoff(sfpt-&gt;req());
 960     // Now make a pass over the debug information replacing any references
 961     // to the allocated object with &quot;sobj&quot;
 962     int start = jvms-&gt;debug_start();
 963     int end   = jvms-&gt;debug_end();
 964     sfpt-&gt;replace_edges_in_range(res, sobj, start, end);
 965     _igvn._worklist.push(sfpt);
 966     safepoints_done.append_if_missing(sfpt); // keep it for rollback
 967   }
 968   // Scalarize inline types that were added to the safepoint
 969   for (uint i = 0; i &lt; value_worklist.size(); ++i) {
 970     Node* vt = value_worklist.at(i);
 971     vt-&gt;as_InlineType()-&gt;make_scalar_in_safepoints(&amp;_igvn);
 972   }
 973   return true;
 974 }
 975 
 976 static void disconnect_projections(MultiNode* n, PhaseIterGVN&amp; igvn) {
 977   Node* ctl_proj = n-&gt;proj_out_or_null(TypeFunc::Control);
 978   Node* mem_proj = n-&gt;proj_out_or_null(TypeFunc::Memory);
 979   if (ctl_proj != NULL) {
 980     igvn.replace_node(ctl_proj, n-&gt;in(0));
 981   }
 982   if (mem_proj != NULL) {
 983     igvn.replace_node(mem_proj, n-&gt;in(TypeFunc::Memory));
 984   }
 985 }
 986 
 987 // Process users of eliminated allocation.
 988 void PhaseMacroExpand::process_users_of_allocation(CallNode *alloc, bool inline_alloc) {
 989   Node* res = alloc-&gt;result_cast();
 990   if (res != NULL) {
 991     for (DUIterator_Last jmin, j = res-&gt;last_outs(jmin); j &gt;= jmin; ) {
 992       Node *use = res-&gt;last_out(j);
 993       uint oc1 = res-&gt;outcnt();
 994 
 995       if (use-&gt;is_AddP()) {
 996         for (DUIterator_Last kmin, k = use-&gt;last_outs(kmin); k &gt;= kmin; ) {
 997           Node *n = use-&gt;last_out(k);
 998           uint oc2 = use-&gt;outcnt();
 999           if (n-&gt;is_Store()) {
1000             for (DUIterator_Fast pmax, p = n-&gt;fast_outs(pmax); p &lt; pmax; p++) {
1001               MemBarNode* mb = n-&gt;fast_out(p)-&gt;isa_MemBar();
1002               if (mb != NULL &amp;&amp; mb-&gt;req() &lt;= MemBarNode::Precedent &amp;&amp; mb-&gt;in(MemBarNode::Precedent) == n) {
1003                 // MemBarVolatiles should have been removed by MemBarNode::Ideal() for non-inline allocations
1004                 assert(inline_alloc, &quot;MemBarVolatile should be eliminated for non-escaping object&quot;);
1005                 mb-&gt;remove(&amp;_igvn);
1006               }
1007             }
1008             _igvn.replace_node(n, n-&gt;in(MemNode::Memory));
1009           } else {
1010             eliminate_gc_barrier(n);
1011           }
1012           k -= (oc2 - use-&gt;outcnt());
1013         }
1014         _igvn.remove_dead_node(use);
1015       } else if (use-&gt;is_ArrayCopy()) {
1016         // Disconnect ArrayCopy node
1017         ArrayCopyNode* ac = use-&gt;as_ArrayCopy();
1018         if (ac-&gt;is_clonebasic()) {
1019           Node* membar_after = ac-&gt;proj_out(TypeFunc::Control)-&gt;unique_ctrl_out();
1020           disconnect_projections(ac, _igvn);
1021           assert(alloc-&gt;in(TypeFunc::Memory)-&gt;is_Proj() &amp;&amp; alloc-&gt;in(TypeFunc::Memory)-&gt;in(0)-&gt;Opcode() == Op_MemBarCPUOrder, &quot;mem barrier expected before allocation&quot;);
1022           Node* membar_before = alloc-&gt;in(TypeFunc::Memory)-&gt;in(0);
1023           disconnect_projections(membar_before-&gt;as_MemBar(), _igvn);
1024           if (membar_after-&gt;is_MemBar()) {
1025             disconnect_projections(membar_after-&gt;as_MemBar(), _igvn);
1026           }
1027         } else {
1028           assert(ac-&gt;is_arraycopy_validated() ||
1029                  ac-&gt;is_copyof_validated() ||
1030                  ac-&gt;is_copyofrange_validated(), &quot;unsupported&quot;);
1031           CallProjections* callprojs = ac-&gt;extract_projections(true);
1032 
1033           _igvn.replace_node(callprojs-&gt;fallthrough_ioproj, ac-&gt;in(TypeFunc::I_O));
1034           _igvn.replace_node(callprojs-&gt;fallthrough_memproj, ac-&gt;in(TypeFunc::Memory));
1035           _igvn.replace_node(callprojs-&gt;fallthrough_catchproj, ac-&gt;in(TypeFunc::Control));
1036 
1037           // Set control to top. IGVN will remove the remaining projections
1038           ac-&gt;set_req(0, top());
1039           ac-&gt;replace_edge(res, top());
1040 
1041           // Disconnect src right away: it can help find new
1042           // opportunities for allocation elimination
1043           Node* src = ac-&gt;in(ArrayCopyNode::Src);
1044           ac-&gt;replace_edge(src, top());
1045           // src can be top at this point if src and dest of the
1046           // arraycopy were the same
1047           if (src-&gt;outcnt() == 0 &amp;&amp; !src-&gt;is_top()) {
1048             _igvn.remove_dead_node(src);
1049           }
1050         }
1051         _igvn._worklist.push(ac);
1052       } else if (use-&gt;is_InlineType()) {
1053         assert(use-&gt;isa_InlineType()-&gt;get_oop() == res, &quot;unexpected inline type use&quot;);
1054         _igvn.rehash_node_delayed(use);
1055         use-&gt;isa_InlineType()-&gt;set_oop(_igvn.zerocon(T_INLINE_TYPE));
<a name="3" id="anc3"></a><span class="line-modified">1056       } else if (use-&gt;Opcode() == Op_StoreX &amp;&amp; use-&gt;in(MemNode::Address) == res) {</span>
<span class="line-added">1057         // Store to mark word of inline type larval buffer</span>
<span class="line-added">1058         assert(inline_alloc, &quot;Unexpected store to mark word&quot;);</span>
1059         _igvn.replace_node(use, use-&gt;in(MemNode::Memory));
1060       } else {
1061         eliminate_gc_barrier(use);
1062       }
1063       j -= (oc1 - res-&gt;outcnt());
1064     }
1065     assert(res-&gt;outcnt() == 0, &quot;all uses of allocated objects must be deleted&quot;);
1066     _igvn.remove_dead_node(res);
1067   }
1068 
1069   //
1070   // Process other users of allocation&#39;s projections
1071   //
1072   if (_resproj != NULL &amp;&amp; _resproj-&gt;outcnt() != 0) {
1073     // First disconnect stores captured by Initialize node.
1074     // If Initialize node is eliminated first in the following code,
1075     // it will kill such stores and DUIterator_Last will assert.
1076     for (DUIterator_Fast jmax, j = _resproj-&gt;fast_outs(jmax);  j &lt; jmax; j++) {
1077       Node *use = _resproj-&gt;fast_out(j);
1078       if (use-&gt;is_AddP()) {
1079         // raw memory addresses used only by the initialization
1080         _igvn.replace_node(use, C-&gt;top());
1081         --j; --jmax;
1082       }
1083     }
1084     for (DUIterator_Last jmin, j = _resproj-&gt;last_outs(jmin); j &gt;= jmin; ) {
1085       Node *use = _resproj-&gt;last_out(j);
1086       uint oc1 = _resproj-&gt;outcnt();
1087       if (use-&gt;is_Initialize()) {
1088         // Eliminate Initialize node.
1089         InitializeNode *init = use-&gt;as_Initialize();
1090         assert(init-&gt;outcnt() &lt;= 2, &quot;only a control and memory projection expected&quot;);
1091         Node *ctrl_proj = init-&gt;proj_out_or_null(TypeFunc::Control);
1092         if (ctrl_proj != NULL) {
1093           // Inline type buffer allocations are followed by a membar
1094           Node* membar_after = ctrl_proj-&gt;unique_ctrl_out();
1095           if (inline_alloc &amp;&amp; membar_after-&gt;Opcode() == Op_MemBarCPUOrder) {
1096             membar_after-&gt;as_MemBar()-&gt;remove(&amp;_igvn);
1097           }
1098           _igvn.replace_node(ctrl_proj, init-&gt;in(TypeFunc::Control));
1099 #ifdef ASSERT
1100           Node* tmp = init-&gt;in(TypeFunc::Control);
1101           assert(tmp == _fallthroughcatchproj, &quot;allocation control projection&quot;);
1102 #endif
1103         }
1104         Node *mem_proj = init-&gt;proj_out_or_null(TypeFunc::Memory);
1105         if (mem_proj != NULL) {
1106           Node *mem = init-&gt;in(TypeFunc::Memory);
1107 #ifdef ASSERT
1108           if (mem-&gt;is_MergeMem()) {
1109             assert(mem-&gt;in(TypeFunc::Memory) == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1110           } else {
1111             assert(mem == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1112           }
1113 #endif
1114           _igvn.replace_node(mem_proj, mem);
1115         }
1116       } else if (use-&gt;Opcode() == Op_MemBarStoreStore) {
1117         // Inline type buffer allocations are followed by a membar
1118         assert(inline_alloc, &quot;Unexpected MemBarStoreStore&quot;);
1119         use-&gt;as_MemBar()-&gt;remove(&amp;_igvn);
1120       } else  {
1121         assert(false, &quot;only Initialize or AddP expected&quot;);
1122       }
1123       j -= (oc1 - _resproj-&gt;outcnt());
1124     }
1125   }
1126   if (_fallthroughcatchproj != NULL) {
1127     _igvn.replace_node(_fallthroughcatchproj, alloc-&gt;in(TypeFunc::Control));
1128   }
1129   if (_memproj_fallthrough != NULL) {
1130     _igvn.replace_node(_memproj_fallthrough, alloc-&gt;in(TypeFunc::Memory));
1131   }
1132   if (_memproj_catchall != NULL) {
1133     _igvn.replace_node(_memproj_catchall, C-&gt;top());
1134   }
1135   if (_ioproj_fallthrough != NULL) {
1136     _igvn.replace_node(_ioproj_fallthrough, alloc-&gt;in(TypeFunc::I_O));
1137   }
1138   if (_ioproj_catchall != NULL) {
1139     _igvn.replace_node(_ioproj_catchall, C-&gt;top());
1140   }
1141   if (_catchallcatchproj != NULL) {
1142     _igvn.replace_node(_catchallcatchproj, C-&gt;top());
1143   }
1144 }
1145 
1146 bool PhaseMacroExpand::eliminate_allocate_node(AllocateNode *alloc) {
1147   // Don&#39;t do scalar replacement if the frame can be popped by JVMTI:
1148   // if reallocation fails during deoptimization we&#39;ll pop all
1149   // interpreter frames for this compiled frame and that won&#39;t play
1150   // nice with JVMTI popframe.
1151   if (!EliminateAllocations || JvmtiExport::can_pop_frame()) {
1152     return false;
1153   }
1154   Node* klass = alloc-&gt;in(AllocateNode::KlassNode);
1155   const TypeKlassPtr* tklass = _igvn.type(klass)-&gt;is_klassptr();
1156 
1157   // Attempt to eliminate inline type buffer allocations
1158   // regardless of usage and escape/replaceable status.
1159   bool inline_alloc = tklass-&gt;klass()-&gt;is_inlinetype();
1160   if (!alloc-&gt;_is_non_escaping &amp;&amp; !inline_alloc) {
1161     return false;
1162   }
1163   // Eliminate boxing allocations which are not used
1164   // regardless of scalar replaceable status.
1165   Node* res = alloc-&gt;result_cast();
1166   bool boxing_alloc = (res == NULL) &amp;&amp; C-&gt;eliminate_boxing() &amp;&amp;
1167                       tklass-&gt;klass()-&gt;is_instance_klass() &amp;&amp;
1168                       tklass-&gt;klass()-&gt;as_instance_klass()-&gt;is_box_klass();
1169   if (!alloc-&gt;_is_scalar_replaceable &amp;&amp; !boxing_alloc &amp;&amp; !inline_alloc) {
1170     return false;
1171   }
1172 
1173   extract_call_projections(alloc);
1174 
1175   GrowableArray &lt;SafePointNode *&gt; safepoints;
1176   if (!can_eliminate_allocation(alloc, safepoints)) {
1177     return false;
1178   }
1179 
1180   if (!alloc-&gt;_is_scalar_replaceable) {
1181     assert(res == NULL || inline_alloc, &quot;sanity&quot;);
1182     // We can only eliminate allocation if all debug info references
1183     // are already replaced with SafePointScalarObject because
1184     // we can&#39;t search for a fields value without instance_id.
1185     if (safepoints.length() &gt; 0) {
1186       assert(!inline_alloc, &quot;Inline type allocations should not have safepoint uses&quot;);
1187       return false;
1188     }
1189   }
1190 
1191   if (!scalar_replacement(alloc, safepoints)) {
1192     return false;
1193   }
1194 
1195   CompileLog* log = C-&gt;log();
1196   if (log != NULL) {
1197     log-&gt;head(&quot;eliminate_allocation type=&#39;%d&#39;&quot;,
1198               log-&gt;identify(tklass-&gt;klass()));
1199     JVMState* p = alloc-&gt;jvms();
1200     while (p != NULL) {
1201       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1202       p = p-&gt;caller();
1203     }
1204     log-&gt;tail(&quot;eliminate_allocation&quot;);
1205   }
1206 
1207   process_users_of_allocation(alloc, inline_alloc);
1208 
1209 #ifndef PRODUCT
1210   if (PrintEliminateAllocations) {
1211     if (alloc-&gt;is_AllocateArray())
1212       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1213     else
1214       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1215   }
1216 #endif
1217 
1218   return true;
1219 }
1220 
1221 bool PhaseMacroExpand::eliminate_boxing_node(CallStaticJavaNode *boxing) {
1222   // EA should remove all uses of non-escaping boxing node.
1223   if (!C-&gt;eliminate_boxing() || boxing-&gt;proj_out_or_null(TypeFunc::Parms) != NULL) {
1224     return false;
1225   }
1226 
1227   assert(boxing-&gt;result_cast() == NULL, &quot;unexpected boxing node result&quot;);
1228 
1229   extract_call_projections(boxing);
1230 
1231   const TypeTuple* r = boxing-&gt;tf()-&gt;range_sig();
1232   assert(r-&gt;cnt() &gt; TypeFunc::Parms, &quot;sanity&quot;);
1233   const TypeInstPtr* t = r-&gt;field_at(TypeFunc::Parms)-&gt;isa_instptr();
1234   assert(t != NULL, &quot;sanity&quot;);
1235 
1236   CompileLog* log = C-&gt;log();
1237   if (log != NULL) {
1238     log-&gt;head(&quot;eliminate_boxing type=&#39;%d&#39;&quot;,
1239               log-&gt;identify(t-&gt;klass()));
1240     JVMState* p = boxing-&gt;jvms();
1241     while (p != NULL) {
1242       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1243       p = p-&gt;caller();
1244     }
1245     log-&gt;tail(&quot;eliminate_boxing&quot;);
1246   }
1247 
1248   process_users_of_allocation(boxing);
1249 
1250 #ifndef PRODUCT
1251   if (PrintEliminateAllocations) {
1252     tty-&gt;print(&quot;++++ Eliminated: %d &quot;, boxing-&gt;_idx);
1253     boxing-&gt;method()-&gt;print_short_name(tty);
1254     tty-&gt;cr();
1255   }
1256 #endif
1257 
1258   return true;
1259 }
1260 
1261 //---------------------------set_eden_pointers-------------------------
1262 void PhaseMacroExpand::set_eden_pointers(Node* &amp;eden_top_adr, Node* &amp;eden_end_adr) {
1263   if (UseTLAB) {                // Private allocation: load from TLS
1264     Node* thread = transform_later(new ThreadLocalNode());
1265     int tlab_top_offset = in_bytes(JavaThread::tlab_top_offset());
1266     int tlab_end_offset = in_bytes(JavaThread::tlab_end_offset());
1267     eden_top_adr = basic_plus_adr(top()/*not oop*/, thread, tlab_top_offset);
1268     eden_end_adr = basic_plus_adr(top()/*not oop*/, thread, tlab_end_offset);
1269   } else {                      // Shared allocation: load from globals
1270     CollectedHeap* ch = Universe::heap();
1271     address top_adr = (address)ch-&gt;top_addr();
1272     address end_adr = (address)ch-&gt;end_addr();
1273     eden_top_adr = makecon(TypeRawPtr::make(top_adr));
1274     eden_end_adr = basic_plus_adr(eden_top_adr, end_adr - top_adr);
1275   }
1276 }
1277 
1278 
1279 Node* PhaseMacroExpand::make_load(Node* ctl, Node* mem, Node* base, int offset, const Type* value_type, BasicType bt) {
1280   Node* adr = basic_plus_adr(base, offset);
1281   const TypePtr* adr_type = adr-&gt;bottom_type()-&gt;is_ptr();
1282   Node* value = LoadNode::make(_igvn, ctl, mem, adr, adr_type, value_type, bt, MemNode::unordered);
1283   transform_later(value);
1284   return value;
1285 }
1286 
1287 
1288 Node* PhaseMacroExpand::make_store(Node* ctl, Node* mem, Node* base, int offset, Node* value, BasicType bt) {
1289   Node* adr = basic_plus_adr(base, offset);
1290   mem = StoreNode::make(_igvn, ctl, mem, adr, NULL, value, bt, MemNode::unordered);
1291   transform_later(mem);
1292   return mem;
1293 }
1294 
1295 //=============================================================================
1296 //
1297 //                              A L L O C A T I O N
1298 //
1299 // Allocation attempts to be fast in the case of frequent small objects.
1300 // It breaks down like this:
1301 //
1302 // 1) Size in doublewords is computed.  This is a constant for objects and
1303 // variable for most arrays.  Doubleword units are used to avoid size
1304 // overflow of huge doubleword arrays.  We need doublewords in the end for
1305 // rounding.
1306 //
1307 // 2) Size is checked for being &#39;too large&#39;.  Too-large allocations will go
1308 // the slow path into the VM.  The slow path can throw any required
1309 // exceptions, and does all the special checks for very large arrays.  The
1310 // size test can constant-fold away for objects.  For objects with
1311 // finalizers it constant-folds the otherway: you always go slow with
1312 // finalizers.
1313 //
1314 // 3) If NOT using TLABs, this is the contended loop-back point.
1315 // Load-Locked the heap top.  If using TLABs normal-load the heap top.
1316 //
1317 // 4) Check that heap top + size*8 &lt; max.  If we fail go the slow ` route.
1318 // NOTE: &quot;top+size*8&quot; cannot wrap the 4Gig line!  Here&#39;s why: for largish
1319 // &quot;size*8&quot; we always enter the VM, where &quot;largish&quot; is a constant picked small
1320 // enough that there&#39;s always space between the eden max and 4Gig (old space is
1321 // there so it&#39;s quite large) and large enough that the cost of entering the VM
1322 // is dwarfed by the cost to initialize the space.
1323 //
1324 // 5) If NOT using TLABs, Store-Conditional the adjusted heap top back
1325 // down.  If contended, repeat at step 3.  If using TLABs normal-store
1326 // adjusted heap top back down; there is no contention.
1327 //
1328 // 6) If !ZeroTLAB then Bulk-clear the object/array.  Fill in klass &amp; mark
1329 // fields.
1330 //
1331 // 7) Merge with the slow-path; cast the raw memory pointer to the correct
1332 // oop flavor.
1333 //
1334 //=============================================================================
1335 // FastAllocateSizeLimit value is in DOUBLEWORDS.
1336 // Allocations bigger than this always go the slow route.
1337 // This value must be small enough that allocation attempts that need to
1338 // trigger exceptions go the slow route.  Also, it must be small enough so
1339 // that heap_top + size_in_bytes does not wrap around the 4Gig limit.
1340 //=============================================================================j//
1341 // %%% Here is an old comment from parseHelper.cpp; is it outdated?
1342 // The allocator will coalesce int-&gt;oop copies away.  See comment in
1343 // coalesce.cpp about how this works.  It depends critically on the exact
1344 // code shape produced here, so if you are changing this code shape
1345 // make sure the GC info for the heap-top is correct in and around the
1346 // slow-path call.
1347 //
1348 
1349 void PhaseMacroExpand::expand_allocate_common(
1350             AllocateNode* alloc, // allocation node to be expanded
1351             Node* length,  // array length for an array allocation
1352             const TypeFunc* slow_call_type, // Type of slow call
1353             address slow_call_address  // Address of slow call
1354     )
1355 {
1356   Node* ctrl = alloc-&gt;in(TypeFunc::Control);
1357   Node* mem  = alloc-&gt;in(TypeFunc::Memory);
1358   Node* i_o  = alloc-&gt;in(TypeFunc::I_O);
1359   Node* size_in_bytes     = alloc-&gt;in(AllocateNode::AllocSize);
1360   Node* klass_node        = alloc-&gt;in(AllocateNode::KlassNode);
1361   Node* initial_slow_test = alloc-&gt;in(AllocateNode::InitialTest);
1362   assert(ctrl != NULL, &quot;must have control&quot;);
1363 
1364   // We need a Region and corresponding Phi&#39;s to merge the slow-path and fast-path results.
1365   // they will not be used if &quot;always_slow&quot; is set
1366   enum { slow_result_path = 1, fast_result_path = 2 };
1367   Node *result_region = NULL;
1368   Node *result_phi_rawmem = NULL;
1369   Node *result_phi_rawoop = NULL;
1370   Node *result_phi_i_o = NULL;
1371 
1372   // The initial slow comparison is a size check, the comparison
1373   // we want to do is a BoolTest::gt
1374   bool expand_fast_path = true;
1375   int tv = _igvn.find_int_con(initial_slow_test, -1);
1376   if (tv &gt;= 0) {
1377     // InitialTest has constant result
1378     //   0 - can fit in TLAB
1379     //   1 - always too big or negative
1380     assert(tv &lt;= 1, &quot;0 or 1 if a constant&quot;);
1381     expand_fast_path = (tv == 0);
1382     initial_slow_test = NULL;
1383   } else {
1384     initial_slow_test = BoolNode::make_predicate(initial_slow_test, &amp;_igvn);
1385   }
1386 
1387   if (C-&gt;env()-&gt;dtrace_alloc_probes() ||
1388       (!UseTLAB &amp;&amp; !Universe::heap()-&gt;supports_inline_contig_alloc())) {
1389     // Force slow-path allocation
1390     expand_fast_path = false;
1391     initial_slow_test = NULL;
1392   }
1393 
1394   bool allocation_has_use = (alloc-&gt;result_cast() != NULL);
1395   if (!allocation_has_use) {
1396     InitializeNode* init = alloc-&gt;initialization();
1397     if (init != NULL) {
1398       init-&gt;remove(&amp;_igvn);
1399     }
1400     if (expand_fast_path &amp;&amp; (initial_slow_test == NULL)) {
1401       // Remove allocation node and return.
1402       // Size is a non-negative constant -&gt; no initial check needed -&gt; directly to fast path.
1403       // Also, no usages -&gt; empty fast path -&gt; no fall out to slow path -&gt; nothing left.
1404 #ifndef PRODUCT
1405       if (PrintEliminateAllocations) {
1406         tty-&gt;print(&quot;NotUsed &quot;);
1407         Node* res = alloc-&gt;proj_out_or_null(TypeFunc::Parms);
1408         if (res != NULL) {
1409           res-&gt;dump();
1410         } else {
1411           alloc-&gt;dump();
1412         }
1413       }
1414 #endif
1415       yank_alloc_node(alloc);
1416       return;
1417     }
1418   }
1419 
1420   enum { too_big_or_final_path = 1, need_gc_path = 2 };
1421   Node *slow_region = NULL;
1422   Node *toobig_false = ctrl;
1423 
1424   // generate the initial test if necessary
1425   if (initial_slow_test != NULL ) {
1426     assert (expand_fast_path, &quot;Only need test if there is a fast path&quot;);
1427     slow_region = new RegionNode(3);
1428 
1429     // Now make the initial failure test.  Usually a too-big test but
1430     // might be a TRUE for finalizers or a fancy class check for
1431     // newInstance0.
1432     IfNode* toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);
1433     transform_later(toobig_iff);
1434     // Plug the failing-too-big test into the slow-path region
1435     Node* toobig_true = new IfTrueNode(toobig_iff);
1436     transform_later(toobig_true);
1437     slow_region    -&gt;init_req( too_big_or_final_path, toobig_true );
1438     toobig_false = new IfFalseNode(toobig_iff);
1439     transform_later(toobig_false);
1440   } else {
1441     // No initial test, just fall into next case
1442     assert(allocation_has_use || !expand_fast_path, &quot;Should already have been handled&quot;);
1443     toobig_false = ctrl;
1444     debug_only(slow_region = NodeSentinel);
1445   }
1446 
1447   // If we are here there are several possibilities
1448   // - expand_fast_path is false - then only a slow path is expanded. That&#39;s it.
1449   // no_initial_check means a constant allocation.
1450   // - If check always evaluates to false -&gt; expand_fast_path is false (see above)
1451   // - If check always evaluates to true -&gt; directly into fast path (but may bailout to slowpath)
1452   // if !allocation_has_use the fast path is empty
1453   // if !allocation_has_use &amp;&amp; no_initial_check
1454   // - Then there are no fastpath that can fall out to slowpath -&gt; no allocation code at all.
1455   //   removed by yank_alloc_node above.
1456 
1457   Node *slow_mem = mem;  // save the current memory state for slow path
1458   // generate the fast allocation code unless we know that the initial test will always go slow
1459   if (expand_fast_path) {
1460     // Fast path modifies only raw memory.
1461     if (mem-&gt;is_MergeMem()) {
1462       mem = mem-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);
1463     }
1464 
1465     // allocate the Region and Phi nodes for the result
1466     result_region = new RegionNode(3);
1467     result_phi_rawmem = new PhiNode(result_region, Type::MEMORY, TypeRawPtr::BOTTOM);
1468     result_phi_i_o    = new PhiNode(result_region, Type::ABIO); // I/O is used for Prefetch
1469 
1470     // Grab regular I/O before optional prefetch may change it.
1471     // Slow-path does no I/O so just set it to the original I/O.
1472     result_phi_i_o-&gt;init_req(slow_result_path, i_o);
1473 
1474     // Name successful fast-path variables
1475     Node* fast_oop_ctrl;
1476     Node* fast_oop_rawmem;
1477 
1478     if (allocation_has_use) {
1479       Node* needgc_ctrl = NULL;
1480       result_phi_rawoop = new PhiNode(result_region, TypeRawPtr::BOTTOM);
1481 
1482       intx prefetch_lines = length != NULL ? AllocatePrefetchLines : AllocateInstancePrefetchLines;
1483       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1484       Node* fast_oop = bs-&gt;obj_allocate(this, ctrl, mem, toobig_false, size_in_bytes, i_o, needgc_ctrl,
1485                                         fast_oop_ctrl, fast_oop_rawmem,
1486                                         prefetch_lines);
1487 
1488       if (initial_slow_test != NULL) {
1489         // This completes all paths into the slow merge point
1490         slow_region-&gt;init_req(need_gc_path, needgc_ctrl);
1491         transform_later(slow_region);
1492       } else {
1493         // No initial slow path needed!
1494         // Just fall from the need-GC path straight into the VM call.
1495         slow_region = needgc_ctrl;
1496       }
1497 
1498       InitializeNode* init = alloc-&gt;initialization();
1499       fast_oop_rawmem = initialize_object(alloc,
1500                                           fast_oop_ctrl, fast_oop_rawmem, fast_oop,
1501                                           klass_node, length, size_in_bytes);
1502       expand_initialize_membar(alloc, init, fast_oop_ctrl, fast_oop_rawmem);
1503       expand_dtrace_alloc_probe(alloc, fast_oop, fast_oop_ctrl, fast_oop_rawmem);
1504 
1505       result_phi_rawoop-&gt;init_req(fast_result_path, fast_oop);
1506     } else {
1507       assert (initial_slow_test != NULL, &quot;sanity&quot;);
1508       fast_oop_ctrl   = toobig_false;
1509       fast_oop_rawmem = mem;
1510       transform_later(slow_region);
1511     }
1512 
1513     // Plug in the successful fast-path into the result merge point
1514     result_region    -&gt;init_req(fast_result_path, fast_oop_ctrl);
1515     result_phi_i_o   -&gt;init_req(fast_result_path, i_o);
1516     result_phi_rawmem-&gt;init_req(fast_result_path, fast_oop_rawmem);
1517   } else {
1518     slow_region = ctrl;
1519     result_phi_i_o = i_o; // Rename it to use in the following code.
1520   }
1521 
1522   // Generate slow-path call
1523   CallNode *call = new CallStaticJavaNode(slow_call_type, slow_call_address,
1524                                OptoRuntime::stub_name(slow_call_address),
1525                                alloc-&gt;jvms()-&gt;bci(),
1526                                TypePtr::BOTTOM);
1527   call-&gt;init_req(TypeFunc::Control,   slow_region);
1528   call-&gt;init_req(TypeFunc::I_O,       top());    // does no i/o
1529   call-&gt;init_req(TypeFunc::Memory,    slow_mem); // may gc ptrs
1530   call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));
1531   call-&gt;init_req(TypeFunc::FramePtr,  alloc-&gt;in(TypeFunc::FramePtr));
1532 
1533   call-&gt;init_req(TypeFunc::Parms+0, klass_node);
1534   if (length != NULL) {
1535     call-&gt;init_req(TypeFunc::Parms+1, length);
1536   } else {
1537     // Let the runtime know if this is a larval allocation
1538     call-&gt;init_req(TypeFunc::Parms+1, _igvn.intcon(alloc-&gt;_larval));
1539   }
1540 
1541   // Copy debug information and adjust JVMState information, then replace
1542   // allocate node with the call
1543   call-&gt;copy_call_debug_info(&amp;_igvn, alloc);
1544   if (expand_fast_path) {
1545     call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
1546   } else {
1547     // Hook i_o projection to avoid its elimination during allocation
1548     // replacement (when only a slow call is generated).
1549     call-&gt;set_req(TypeFunc::I_O, result_phi_i_o);
1550   }
1551   _igvn.replace_node(alloc, call);
1552   transform_later(call);
1553 
1554   // Identify the output projections from the allocate node and
1555   // adjust any references to them.
1556   // The control and io projections look like:
1557   //
1558   //        v---Proj(ctrl) &lt;-----+   v---CatchProj(ctrl)
1559   //  Allocate                   Catch
1560   //        ^---Proj(io) &lt;-------+   ^---CatchProj(io)
1561   //
1562   //  We are interested in the CatchProj nodes.
1563   //
1564   extract_call_projections(call);
1565 
1566   // An allocate node has separate memory projections for the uses on
1567   // the control and i_o paths. Replace the control memory projection with
1568   // result_phi_rawmem (unless we are only generating a slow call when
1569   // both memory projections are combined)
1570   if (expand_fast_path &amp;&amp; _memproj_fallthrough != NULL) {
1571     _igvn.replace_in_uses(_memproj_fallthrough, result_phi_rawmem);
1572   }
1573   // Now change uses of _memproj_catchall to use _memproj_fallthrough and delete
1574   // _memproj_catchall so we end up with a call that has only 1 memory projection.
1575   if (_memproj_catchall != NULL) {
1576     if (_memproj_fallthrough == NULL) {
1577       _memproj_fallthrough = new ProjNode(call, TypeFunc::Memory);
1578       transform_later(_memproj_fallthrough);
1579     }
1580     _igvn.replace_in_uses(_memproj_catchall, _memproj_fallthrough);
1581     _igvn.remove_dead_node(_memproj_catchall);
1582   }
1583 
1584   // An allocate node has separate i_o projections for the uses on the control
1585   // and i_o paths. Always replace the control i_o projection with result i_o
1586   // otherwise incoming i_o become dead when only a slow call is generated
1587   // (it is different from memory projections where both projections are
1588   // combined in such case).
1589   if (_ioproj_fallthrough != NULL) {
1590     _igvn.replace_in_uses(_ioproj_fallthrough, result_phi_i_o);
1591   }
1592   // Now change uses of _ioproj_catchall to use _ioproj_fallthrough and delete
1593   // _ioproj_catchall so we end up with a call that has only 1 i_o projection.
1594   if (_ioproj_catchall != NULL) {
1595     if (_ioproj_fallthrough == NULL) {
1596       _ioproj_fallthrough = new ProjNode(call, TypeFunc::I_O);
1597       transform_later(_ioproj_fallthrough);
1598     }
1599     _igvn.replace_in_uses(_ioproj_catchall, _ioproj_fallthrough);
1600     _igvn.remove_dead_node(_ioproj_catchall);
1601   }
1602 
1603   // if we generated only a slow call, we are done
1604   if (!expand_fast_path) {
1605     // Now we can unhook i_o.
1606     if (result_phi_i_o-&gt;outcnt() &gt; 1) {
1607       call-&gt;set_req(TypeFunc::I_O, top());
1608     } else {
1609       assert(result_phi_i_o-&gt;unique_ctrl_out() == call, &quot;sanity&quot;);
1610       // Case of new array with negative size known during compilation.
1611       // AllocateArrayNode::Ideal() optimization disconnect unreachable
1612       // following code since call to runtime will throw exception.
1613       // As result there will be no users of i_o after the call.
1614       // Leave i_o attached to this call to avoid problems in preceding graph.
1615     }
1616     return;
1617   }
1618 
1619   if (_fallthroughcatchproj != NULL) {
1620     ctrl = _fallthroughcatchproj-&gt;clone();
1621     transform_later(ctrl);
1622     _igvn.replace_node(_fallthroughcatchproj, result_region);
1623   } else {
1624     ctrl = top();
1625   }
1626   Node *slow_result;
1627   if (_resproj == NULL) {
1628     // no uses of the allocation result
1629     slow_result = top();
1630   } else {
1631     slow_result = _resproj-&gt;clone();
1632     transform_later(slow_result);
1633     _igvn.replace_node(_resproj, result_phi_rawoop);
1634   }
1635 
1636   // Plug slow-path into result merge point
1637   result_region-&gt;init_req( slow_result_path, ctrl);
1638   transform_later(result_region);
1639   if (allocation_has_use) {
1640     result_phi_rawoop-&gt;init_req(slow_result_path, slow_result);
1641     transform_later(result_phi_rawoop);
1642   }
1643   result_phi_rawmem-&gt;init_req(slow_result_path, _memproj_fallthrough);
1644   transform_later(result_phi_rawmem);
1645   transform_later(result_phi_i_o);
1646   // This completes all paths into the result merge point
1647 }
1648 
1649 // Remove alloc node that has no uses.
1650 void PhaseMacroExpand::yank_alloc_node(AllocateNode* alloc) {
1651   Node* ctrl = alloc-&gt;in(TypeFunc::Control);
1652   Node* mem  = alloc-&gt;in(TypeFunc::Memory);
1653   Node* i_o  = alloc-&gt;in(TypeFunc::I_O);
1654 
1655   extract_call_projections(alloc);
1656   if (_resproj != NULL) {
1657     for (DUIterator_Fast imax, i = _resproj-&gt;fast_outs(imax); i &lt; imax; i++) {
1658       Node* use = _resproj-&gt;fast_out(i);
1659       use-&gt;isa_MemBar()-&gt;remove(&amp;_igvn);
1660       --imax;
1661       --i; // back up iterator
1662     }
1663     assert(_resproj-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);
1664     _igvn.remove_dead_node(_resproj);
1665   }
1666   if (_fallthroughcatchproj != NULL) {
1667     _igvn.replace_in_uses(_fallthroughcatchproj, ctrl);
1668     _igvn.remove_dead_node(_fallthroughcatchproj);
1669   }
1670   if (_catchallcatchproj != NULL) {
1671     _igvn.rehash_node_delayed(_catchallcatchproj);
1672     _catchallcatchproj-&gt;set_req(0, top());
1673   }
1674   if (_fallthroughproj != NULL) {
1675     Node* catchnode = _fallthroughproj-&gt;unique_ctrl_out();
1676     _igvn.remove_dead_node(catchnode);
1677     _igvn.remove_dead_node(_fallthroughproj);
1678   }
1679   if (_memproj_fallthrough != NULL) {
1680     _igvn.replace_in_uses(_memproj_fallthrough, mem);
1681     _igvn.remove_dead_node(_memproj_fallthrough);
1682   }
1683   if (_ioproj_fallthrough != NULL) {
1684     _igvn.replace_in_uses(_ioproj_fallthrough, i_o);
1685     _igvn.remove_dead_node(_ioproj_fallthrough);
1686   }
1687   if (_memproj_catchall != NULL) {
1688     _igvn.rehash_node_delayed(_memproj_catchall);
1689     _memproj_catchall-&gt;set_req(0, top());
1690   }
1691   if (_ioproj_catchall != NULL) {
1692     _igvn.rehash_node_delayed(_ioproj_catchall);
1693     _ioproj_catchall-&gt;set_req(0, top());
1694   }
1695 #ifndef PRODUCT
1696   if (PrintEliminateAllocations) {
1697     if (alloc-&gt;is_AllocateArray()) {
1698       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1699     } else {
1700       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1701     }
1702   }
1703 #endif
1704   _igvn.remove_dead_node(alloc);
1705 }
1706 
1707 void PhaseMacroExpand::expand_initialize_membar(AllocateNode* alloc, InitializeNode* init,
1708                                                 Node*&amp; fast_oop_ctrl, Node*&amp; fast_oop_rawmem) {
1709   // If initialization is performed by an array copy, any required
1710   // MemBarStoreStore was already added. If the object does not
1711   // escape no need for a MemBarStoreStore. If the object does not
1712   // escape in its initializer and memory barrier (MemBarStoreStore or
1713   // stronger) is already added at exit of initializer, also no need
1714   // for a MemBarStoreStore. Otherwise we need a MemBarStoreStore
1715   // so that stores that initialize this object can&#39;t be reordered
1716   // with a subsequent store that makes this object accessible by
1717   // other threads.
1718   // Other threads include java threads and JVM internal threads
1719   // (for example concurrent GC threads). Current concurrent GC
1720   // implementation: G1 will not scan newly created object,
1721   // so it&#39;s safe to skip storestore barrier when allocation does
1722   // not escape.
1723   if (!alloc-&gt;does_not_escape_thread() &amp;&amp;
1724     !alloc-&gt;is_allocation_MemBar_redundant() &amp;&amp;
1725     (init == NULL || !init-&gt;is_complete_with_arraycopy())) {
1726     if (init == NULL || init-&gt;req() &lt; InitializeNode::RawStores) {
1727       // No InitializeNode or no stores captured by zeroing
1728       // elimination. Simply add the MemBarStoreStore after object
1729       // initialization.
1730       MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);
1731       transform_later(mb);
1732 
1733       mb-&gt;init_req(TypeFunc::Memory, fast_oop_rawmem);
1734       mb-&gt;init_req(TypeFunc::Control, fast_oop_ctrl);
1735       fast_oop_ctrl = new ProjNode(mb, TypeFunc::Control);
1736       transform_later(fast_oop_ctrl);
1737       fast_oop_rawmem = new ProjNode(mb, TypeFunc::Memory);
1738       transform_later(fast_oop_rawmem);
1739     } else {
1740       // Add the MemBarStoreStore after the InitializeNode so that
1741       // all stores performing the initialization that were moved
1742       // before the InitializeNode happen before the storestore
1743       // barrier.
1744 
1745       Node* init_ctrl = init-&gt;proj_out_or_null(TypeFunc::Control);
1746       Node* init_mem = init-&gt;proj_out_or_null(TypeFunc::Memory);
1747 
1748       MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);
1749       transform_later(mb);
1750 
1751       Node* ctrl = new ProjNode(init, TypeFunc::Control);
1752       transform_later(ctrl);
1753       Node* mem = new ProjNode(init, TypeFunc::Memory);
1754       transform_later(mem);
1755 
1756       // The MemBarStoreStore depends on control and memory coming
1757       // from the InitializeNode
1758       mb-&gt;init_req(TypeFunc::Memory, mem);
1759       mb-&gt;init_req(TypeFunc::Control, ctrl);
1760 
1761       ctrl = new ProjNode(mb, TypeFunc::Control);
1762       transform_later(ctrl);
1763       mem = new ProjNode(mb, TypeFunc::Memory);
1764       transform_later(mem);
1765 
1766       // All nodes that depended on the InitializeNode for control
1767       // and memory must now depend on the MemBarNode that itself
1768       // depends on the InitializeNode
1769       if (init_ctrl != NULL) {
1770         _igvn.replace_node(init_ctrl, ctrl);
1771       }
1772       if (init_mem != NULL) {
1773         _igvn.replace_node(init_mem, mem);
1774       }
1775     }
1776   }
1777 }
1778 
1779 void PhaseMacroExpand::expand_dtrace_alloc_probe(AllocateNode* alloc, Node* oop,
1780                                                 Node*&amp; ctrl, Node*&amp; rawmem) {
1781   if (C-&gt;env()-&gt;dtrace_extended_probes()) {
1782     // Slow-path call
1783     int size = TypeFunc::Parms + 2;
1784     CallLeafNode *call = new CallLeafNode(OptoRuntime::dtrace_object_alloc_Type(),
1785                                           CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc_base),
1786                                           &quot;dtrace_object_alloc&quot;,
1787                                           TypeRawPtr::BOTTOM);
1788 
1789     // Get base of thread-local storage area
1790     Node* thread = new ThreadLocalNode();
1791     transform_later(thread);
1792 
1793     call-&gt;init_req(TypeFunc::Parms + 0, thread);
1794     call-&gt;init_req(TypeFunc::Parms + 1, oop);
1795     call-&gt;init_req(TypeFunc::Control, ctrl);
1796     call-&gt;init_req(TypeFunc::I_O    , top()); // does no i/o
1797     call-&gt;init_req(TypeFunc::Memory , ctrl);
1798     call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));
1799     call-&gt;init_req(TypeFunc::FramePtr, alloc-&gt;in(TypeFunc::FramePtr));
1800     transform_later(call);
1801     ctrl = new ProjNode(call, TypeFunc::Control);
1802     transform_later(ctrl);
1803     rawmem = new ProjNode(call, TypeFunc::Memory);
1804     transform_later(rawmem);
1805   }
1806 }
1807 
1808 // Helper for PhaseMacroExpand::expand_allocate_common.
1809 // Initializes the newly-allocated storage.
1810 Node* PhaseMacroExpand::initialize_object(AllocateNode* alloc,
1811                                           Node* control, Node* rawmem, Node* object,
1812                                           Node* klass_node, Node* length,
1813                                           Node* size_in_bytes) {
1814   InitializeNode* init = alloc-&gt;initialization();
1815   // Store the klass &amp; mark bits
1816   Node* mark_node = alloc-&gt;make_ideal_mark(&amp;_igvn, control, rawmem);
1817   if (!mark_node-&gt;is_Con()) {
1818     transform_later(mark_node);
1819   }
1820   rawmem = make_store(control, rawmem, object, oopDesc::mark_offset_in_bytes(), mark_node, TypeX_X-&gt;basic_type());
1821 
1822   rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);
1823   int header_size = alloc-&gt;minimum_header_size();  // conservatively small
1824 
1825   // Array length
1826   if (length != NULL) {         // Arrays need length field
1827     rawmem = make_store(control, rawmem, object, arrayOopDesc::length_offset_in_bytes(), length, T_INT);
1828     // conservatively small header size:
1829     header_size = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1830     ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
1831     if (k-&gt;is_array_klass())    // we know the exact header size in most cases:
1832       header_size = Klass::layout_helper_header_size(k-&gt;layout_helper());
1833   }
1834 
1835   // Clear the object body, if necessary.
1836   if (init == NULL) {
1837     // The init has somehow disappeared; be cautious and clear everything.
1838     //
1839     // This can happen if a node is allocated but an uncommon trap occurs
1840     // immediately.  In this case, the Initialize gets associated with the
1841     // trap, and may be placed in a different (outer) loop, if the Allocate
1842     // is in a loop.  If (this is rare) the inner loop gets unrolled, then
1843     // there can be two Allocates to one Initialize.  The answer in all these
1844     // edge cases is safety first.  It is always safe to clear immediately
1845     // within an Allocate, and then (maybe or maybe not) clear some more later.
1846     if (!(UseTLAB &amp;&amp; ZeroTLAB)) {
1847       rawmem = ClearArrayNode::clear_memory(control, rawmem, object,
1848                                             alloc-&gt;in(AllocateNode::DefaultValue),
1849                                             alloc-&gt;in(AllocateNode::RawDefaultValue),
1850                                             header_size, size_in_bytes,
1851                                             &amp;_igvn);
1852     }
1853   } else {
1854     if (!init-&gt;is_complete()) {
1855       // Try to win by zeroing only what the init does not store.
1856       // We can also try to do some peephole optimizations,
1857       // such as combining some adjacent subword stores.
1858       rawmem = init-&gt;complete_stores(control, rawmem, object,
1859                                      header_size, size_in_bytes, &amp;_igvn);
1860     }
1861     // We have no more use for this link, since the AllocateNode goes away:
1862     init-&gt;set_req(InitializeNode::RawAddress, top());
1863     // (If we keep the link, it just confuses the register allocator,
1864     // who thinks he sees a real use of the address by the membar.)
1865   }
1866 
1867   return rawmem;
1868 }
1869 
1870 // Generate prefetch instructions for next allocations.
1871 Node* PhaseMacroExpand::prefetch_allocation(Node* i_o, Node*&amp; needgc_false,
1872                                         Node*&amp; contended_phi_rawmem,
1873                                         Node* old_eden_top, Node* new_eden_top,
1874                                         intx lines) {
1875    enum { fall_in_path = 1, pf_path = 2 };
1876    if( UseTLAB &amp;&amp; AllocatePrefetchStyle == 2 ) {
1877       // Generate prefetch allocation with watermark check.
1878       // As an allocation hits the watermark, we will prefetch starting
1879       // at a &quot;distance&quot; away from watermark.
1880 
1881       Node *pf_region = new RegionNode(3);
1882       Node *pf_phi_rawmem = new PhiNode( pf_region, Type::MEMORY,
1883                                                 TypeRawPtr::BOTTOM );
1884       // I/O is used for Prefetch
1885       Node *pf_phi_abio = new PhiNode( pf_region, Type::ABIO );
1886 
1887       Node *thread = new ThreadLocalNode();
1888       transform_later(thread);
1889 
1890       Node *eden_pf_adr = new AddPNode( top()/*not oop*/, thread,
1891                    _igvn.MakeConX(in_bytes(JavaThread::tlab_pf_top_offset())) );
1892       transform_later(eden_pf_adr);
1893 
1894       Node *old_pf_wm = new LoadPNode(needgc_false,
1895                                    contended_phi_rawmem, eden_pf_adr,
1896                                    TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM,
1897                                    MemNode::unordered);
1898       transform_later(old_pf_wm);
1899 
1900       // check against new_eden_top
1901       Node *need_pf_cmp = new CmpPNode( new_eden_top, old_pf_wm );
1902       transform_later(need_pf_cmp);
1903       Node *need_pf_bol = new BoolNode( need_pf_cmp, BoolTest::ge );
1904       transform_later(need_pf_bol);
1905       IfNode *need_pf_iff = new IfNode( needgc_false, need_pf_bol,
1906                                        PROB_UNLIKELY_MAG(4), COUNT_UNKNOWN );
1907       transform_later(need_pf_iff);
1908 
1909       // true node, add prefetchdistance
1910       Node *need_pf_true = new IfTrueNode( need_pf_iff );
1911       transform_later(need_pf_true);
1912 
1913       Node *need_pf_false = new IfFalseNode( need_pf_iff );
1914       transform_later(need_pf_false);
1915 
1916       Node *new_pf_wmt = new AddPNode( top(), old_pf_wm,
1917                                     _igvn.MakeConX(AllocatePrefetchDistance) );
1918       transform_later(new_pf_wmt );
1919       new_pf_wmt-&gt;set_req(0, need_pf_true);
1920 
1921       Node *store_new_wmt = new StorePNode(need_pf_true,
1922                                        contended_phi_rawmem, eden_pf_adr,
1923                                        TypeRawPtr::BOTTOM, new_pf_wmt,
1924                                        MemNode::unordered);
1925       transform_later(store_new_wmt);
1926 
1927       // adding prefetches
1928       pf_phi_abio-&gt;init_req( fall_in_path, i_o );
1929 
1930       Node *prefetch_adr;
1931       Node *prefetch;
1932       uint step_size = AllocatePrefetchStepSize;
1933       uint distance = 0;
1934 
1935       for ( intx i = 0; i &lt; lines; i++ ) {
1936         prefetch_adr = new AddPNode( old_pf_wm, new_pf_wmt,
1937                                             _igvn.MakeConX(distance) );
1938         transform_later(prefetch_adr);
1939         prefetch = new PrefetchAllocationNode( i_o, prefetch_adr );
1940         transform_later(prefetch);
1941         distance += step_size;
1942         i_o = prefetch;
1943       }
1944       pf_phi_abio-&gt;set_req( pf_path, i_o );
1945 
1946       pf_region-&gt;init_req( fall_in_path, need_pf_false );
1947       pf_region-&gt;init_req( pf_path, need_pf_true );
1948 
1949       pf_phi_rawmem-&gt;init_req( fall_in_path, contended_phi_rawmem );
1950       pf_phi_rawmem-&gt;init_req( pf_path, store_new_wmt );
1951 
1952       transform_later(pf_region);
1953       transform_later(pf_phi_rawmem);
1954       transform_later(pf_phi_abio);
1955 
1956       needgc_false = pf_region;
1957       contended_phi_rawmem = pf_phi_rawmem;
1958       i_o = pf_phi_abio;
1959    } else if( UseTLAB &amp;&amp; AllocatePrefetchStyle == 3 ) {
1960       // Insert a prefetch instruction for each allocation.
1961       // This code is used to generate 1 prefetch instruction per cache line.
1962 
1963       // Generate several prefetch instructions.
1964       uint step_size = AllocatePrefetchStepSize;
1965       uint distance = AllocatePrefetchDistance;
1966 
1967       // Next cache address.
1968       Node *cache_adr = new AddPNode(old_eden_top, old_eden_top,
1969                                      _igvn.MakeConX(step_size + distance));
1970       transform_later(cache_adr);
1971       cache_adr = new CastP2XNode(needgc_false, cache_adr);
1972       transform_later(cache_adr);
1973       // Address is aligned to execute prefetch to the beginning of cache line size
1974       // (it is important when BIS instruction is used on SPARC as prefetch).
1975       Node* mask = _igvn.MakeConX(~(intptr_t)(step_size-1));
1976       cache_adr = new AndXNode(cache_adr, mask);
1977       transform_later(cache_adr);
1978       cache_adr = new CastX2PNode(cache_adr);
1979       transform_later(cache_adr);
1980 
1981       // Prefetch
1982       Node *prefetch = new PrefetchAllocationNode( contended_phi_rawmem, cache_adr );
1983       prefetch-&gt;set_req(0, needgc_false);
1984       transform_later(prefetch);
1985       contended_phi_rawmem = prefetch;
1986       Node *prefetch_adr;
1987       distance = step_size;
1988       for ( intx i = 1; i &lt; lines; i++ ) {
1989         prefetch_adr = new AddPNode( cache_adr, cache_adr,
1990                                             _igvn.MakeConX(distance) );
1991         transform_later(prefetch_adr);
1992         prefetch = new PrefetchAllocationNode( contended_phi_rawmem, prefetch_adr );
1993         transform_later(prefetch);
1994         distance += step_size;
1995         contended_phi_rawmem = prefetch;
1996       }
1997    } else if( AllocatePrefetchStyle &gt; 0 ) {
1998       // Insert a prefetch for each allocation only on the fast-path
1999       Node *prefetch_adr;
2000       Node *prefetch;
2001       // Generate several prefetch instructions.
2002       uint step_size = AllocatePrefetchStepSize;
2003       uint distance = AllocatePrefetchDistance;
2004       for ( intx i = 0; i &lt; lines; i++ ) {
2005         prefetch_adr = new AddPNode( old_eden_top, new_eden_top,
2006                                             _igvn.MakeConX(distance) );
2007         transform_later(prefetch_adr);
2008         prefetch = new PrefetchAllocationNode( i_o, prefetch_adr );
2009         // Do not let it float too high, since if eden_top == eden_end,
2010         // both might be null.
2011         if( i == 0 ) { // Set control for first prefetch, next follows it
2012           prefetch-&gt;init_req(0, needgc_false);
2013         }
2014         transform_later(prefetch);
2015         distance += step_size;
2016         i_o = prefetch;
2017       }
2018    }
2019    return i_o;
2020 }
2021 
2022 
2023 void PhaseMacroExpand::expand_allocate(AllocateNode *alloc) {
2024   expand_allocate_common(alloc, NULL,
2025                          OptoRuntime::new_instance_Type(),
2026                          OptoRuntime::new_instance_Java());
2027 }
2028 
2029 void PhaseMacroExpand::expand_allocate_array(AllocateArrayNode *alloc) {
2030   Node* length = alloc-&gt;in(AllocateNode::ALength);
2031   InitializeNode* init = alloc-&gt;initialization();
2032   Node* klass_node = alloc-&gt;in(AllocateNode::KlassNode);
2033   ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
2034   address slow_call_address;  // Address of slow call
2035   if (init != NULL &amp;&amp; init-&gt;is_complete_with_arraycopy() &amp;&amp;
2036       k-&gt;is_type_array_klass()) {
2037     // Don&#39;t zero type array during slow allocation in VM since
2038     // it will be initialized later by arraycopy in compiled code.
2039     slow_call_address = OptoRuntime::new_array_nozero_Java();
2040   } else {
2041     slow_call_address = OptoRuntime::new_array_Java();
2042   }
2043   expand_allocate_common(alloc, length,
2044                          OptoRuntime::new_array_Type(),
2045                          slow_call_address);
2046 }
2047 
2048 //-------------------mark_eliminated_box----------------------------------
2049 //
2050 // During EA obj may point to several objects but after few ideal graph
2051 // transformations (CCP) it may point to only one non escaping object
2052 // (but still using phi), corresponding locks and unlocks will be marked
2053 // for elimination. Later obj could be replaced with a new node (new phi)
2054 // and which does not have escape information. And later after some graph
2055 // reshape other locks and unlocks (which were not marked for elimination
2056 // before) are connected to this new obj (phi) but they still will not be
2057 // marked for elimination since new obj has no escape information.
2058 // Mark all associated (same box and obj) lock and unlock nodes for
2059 // elimination if some of them marked already.
2060 void PhaseMacroExpand::mark_eliminated_box(Node* oldbox, Node* obj) {
2061   if (oldbox-&gt;as_BoxLock()-&gt;is_eliminated())
2062     return; // This BoxLock node was processed already.
2063 
2064   // New implementation (EliminateNestedLocks) has separate BoxLock
2065   // node for each locked region so mark all associated locks/unlocks as
2066   // eliminated even if different objects are referenced in one locked region
2067   // (for example, OSR compilation of nested loop inside locked scope).
2068   if (EliminateNestedLocks ||
2069       oldbox-&gt;as_BoxLock()-&gt;is_simple_lock_region(NULL, obj)) {
2070     // Box is used only in one lock region. Mark this box as eliminated.
2071     _igvn.hash_delete(oldbox);
2072     oldbox-&gt;as_BoxLock()-&gt;set_eliminated(); // This changes box&#39;s hash value
2073      _igvn.hash_insert(oldbox);
2074 
2075     for (uint i = 0; i &lt; oldbox-&gt;outcnt(); i++) {
2076       Node* u = oldbox-&gt;raw_out(i);
2077       if (u-&gt;is_AbstractLock() &amp;&amp; !u-&gt;as_AbstractLock()-&gt;is_non_esc_obj()) {
2078         AbstractLockNode* alock = u-&gt;as_AbstractLock();
2079         // Check lock&#39;s box since box could be referenced by Lock&#39;s debug info.
2080         if (alock-&gt;box_node() == oldbox) {
2081           // Mark eliminated all related locks and unlocks.
2082 #ifdef ASSERT
2083           alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_non_esc4&quot;);
2084 #endif
2085           alock-&gt;set_non_esc_obj();
2086         }
2087       }
2088     }
2089     return;
2090   }
2091 
2092   // Create new &quot;eliminated&quot; BoxLock node and use it in monitor debug info
2093   // instead of oldbox for the same object.
2094   BoxLockNode* newbox = oldbox-&gt;clone()-&gt;as_BoxLock();
2095 
2096   // Note: BoxLock node is marked eliminated only here and it is used
2097   // to indicate that all associated lock and unlock nodes are marked
2098   // for elimination.
2099   newbox-&gt;set_eliminated();
2100   transform_later(newbox);
2101 
2102   // Replace old box node with new box for all users of the same object.
2103   for (uint i = 0; i &lt; oldbox-&gt;outcnt();) {
2104     bool next_edge = true;
2105 
2106     Node* u = oldbox-&gt;raw_out(i);
2107     if (u-&gt;is_AbstractLock()) {
2108       AbstractLockNode* alock = u-&gt;as_AbstractLock();
2109       if (alock-&gt;box_node() == oldbox &amp;&amp; alock-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2110         // Replace Box and mark eliminated all related locks and unlocks.
2111 #ifdef ASSERT
2112         alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_non_esc5&quot;);
2113 #endif
2114         alock-&gt;set_non_esc_obj();
2115         _igvn.rehash_node_delayed(alock);
2116         alock-&gt;set_box_node(newbox);
2117         next_edge = false;
2118       }
2119     }
2120     if (u-&gt;is_FastLock() &amp;&amp; u-&gt;as_FastLock()-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2121       FastLockNode* flock = u-&gt;as_FastLock();
2122       assert(flock-&gt;box_node() == oldbox, &quot;sanity&quot;);
2123       _igvn.rehash_node_delayed(flock);
2124       flock-&gt;set_box_node(newbox);
2125       next_edge = false;
2126     }
2127 
2128     // Replace old box in monitor debug info.
2129     if (u-&gt;is_SafePoint() &amp;&amp; u-&gt;as_SafePoint()-&gt;jvms()) {
2130       SafePointNode* sfn = u-&gt;as_SafePoint();
2131       JVMState* youngest_jvms = sfn-&gt;jvms();
2132       int max_depth = youngest_jvms-&gt;depth();
2133       for (int depth = 1; depth &lt;= max_depth; depth++) {
2134         JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
2135         int num_mon  = jvms-&gt;nof_monitors();
2136         // Loop over monitors
2137         for (int idx = 0; idx &lt; num_mon; idx++) {
2138           Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
2139           Node* box_node = sfn-&gt;monitor_box(jvms, idx);
2140           if (box_node == oldbox &amp;&amp; obj_node-&gt;eqv_uncast(obj)) {
2141             int j = jvms-&gt;monitor_box_offset(idx);
2142             _igvn.replace_input_of(u, j, newbox);
2143             next_edge = false;
2144           }
2145         }
2146       }
2147     }
2148     if (next_edge) i++;
2149   }
2150 }
2151 
2152 //-----------------------mark_eliminated_locking_nodes-----------------------
2153 void PhaseMacroExpand::mark_eliminated_locking_nodes(AbstractLockNode *alock) {
2154   if (EliminateNestedLocks) {
2155     if (alock-&gt;is_nested()) {
2156        assert(alock-&gt;box_node()-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2157        return;
2158     } else if (!alock-&gt;is_non_esc_obj()) { // Not eliminated or coarsened
2159       // Only Lock node has JVMState needed here.
2160       // Not that preceding claim is documented anywhere else.
2161       if (alock-&gt;jvms() != NULL) {
2162         if (alock-&gt;as_Lock()-&gt;is_nested_lock_region()) {
2163           // Mark eliminated related nested locks and unlocks.
2164           Node* obj = alock-&gt;obj_node();
2165           BoxLockNode* box_node = alock-&gt;box_node()-&gt;as_BoxLock();
2166           assert(!box_node-&gt;is_eliminated(), &quot;should not be marked yet&quot;);
2167           // Note: BoxLock node is marked eliminated only here
2168           // and it is used to indicate that all associated lock
2169           // and unlock nodes are marked for elimination.
2170           box_node-&gt;set_eliminated(); // Box&#39;s hash is always NO_HASH here
2171           for (uint i = 0; i &lt; box_node-&gt;outcnt(); i++) {
2172             Node* u = box_node-&gt;raw_out(i);
2173             if (u-&gt;is_AbstractLock()) {
2174               alock = u-&gt;as_AbstractLock();
2175               if (alock-&gt;box_node() == box_node) {
2176                 // Verify that this Box is referenced only by related locks.
2177                 assert(alock-&gt;obj_node()-&gt;eqv_uncast(obj), &quot;&quot;);
2178                 // Mark all related locks and unlocks.
2179 #ifdef ASSERT
2180                 alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_nested&quot;);
2181 #endif
2182                 alock-&gt;set_nested();
2183               }
2184             }
2185           }
2186         } else {
2187 #ifdef ASSERT
2188           alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_NOT_nested_lock_region&quot;);
2189           if (C-&gt;log() != NULL)
2190             alock-&gt;as_Lock()-&gt;is_nested_lock_region(C); // rerun for debugging output
2191 #endif
2192         }
2193       }
2194       return;
2195     }
2196     // Process locks for non escaping object
2197     assert(alock-&gt;is_non_esc_obj(), &quot;&quot;);
2198   } // EliminateNestedLocks
2199 
2200   if (alock-&gt;is_non_esc_obj()) { // Lock is used for non escaping object
2201     // Look for all locks of this object and mark them and
2202     // corresponding BoxLock nodes as eliminated.
2203     Node* obj = alock-&gt;obj_node();
2204     for (uint j = 0; j &lt; obj-&gt;outcnt(); j++) {
2205       Node* o = obj-&gt;raw_out(j);
2206       if (o-&gt;is_AbstractLock() &amp;&amp;
2207           o-&gt;as_AbstractLock()-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2208         alock = o-&gt;as_AbstractLock();
2209         Node* box = alock-&gt;box_node();
2210         // Replace old box node with new eliminated box for all users
2211         // of the same object and mark related locks as eliminated.
2212         mark_eliminated_box(box, obj);
2213       }
2214     }
2215   }
2216 }
2217 
2218 // we have determined that this lock/unlock can be eliminated, we simply
2219 // eliminate the node without expanding it.
2220 //
2221 // Note:  The membar&#39;s associated with the lock/unlock are currently not
2222 //        eliminated.  This should be investigated as a future enhancement.
2223 //
2224 bool PhaseMacroExpand::eliminate_locking_node(AbstractLockNode *alock) {
2225 
2226   if (!alock-&gt;is_eliminated()) {
2227     return false;
2228   }
2229 #ifdef ASSERT
2230   const Type* obj_type = _igvn.type(alock-&gt;obj_node());
2231   assert(!obj_type-&gt;isa_inlinetype() &amp;&amp; !obj_type-&gt;is_inlinetypeptr(), &quot;Eliminating lock on inline type&quot;);
2232   if (!alock-&gt;is_coarsened()) {
2233     // Check that new &quot;eliminated&quot; BoxLock node is created.
2234     BoxLockNode* oldbox = alock-&gt;box_node()-&gt;as_BoxLock();
2235     assert(oldbox-&gt;is_eliminated(), &quot;should be done already&quot;);
2236   }
2237 #endif
2238 
2239   alock-&gt;log_lock_optimization(C, &quot;eliminate_lock&quot;);
2240 
2241 #ifndef PRODUCT
2242   if (PrintEliminateLocks) {
2243     if (alock-&gt;is_Lock()) {
2244       tty-&gt;print_cr(&quot;++++ Eliminated: %d Lock&quot;, alock-&gt;_idx);
2245     } else {
2246       tty-&gt;print_cr(&quot;++++ Eliminated: %d Unlock&quot;, alock-&gt;_idx);
2247     }
2248   }
2249 #endif
2250 
2251   Node* mem  = alock-&gt;in(TypeFunc::Memory);
2252   Node* ctrl = alock-&gt;in(TypeFunc::Control);
2253   guarantee(ctrl != NULL, &quot;missing control projection, cannot replace_node() with NULL&quot;);
2254 
2255   extract_call_projections(alock);
2256   // There are 2 projections from the lock.  The lock node will
2257   // be deleted when its last use is subsumed below.
2258   assert(alock-&gt;outcnt() == 2 &amp;&amp;
2259          _fallthroughproj != NULL &amp;&amp;
2260          _memproj_fallthrough != NULL,
2261          &quot;Unexpected projections from Lock/Unlock&quot;);
2262 
2263   Node* fallthroughproj = _fallthroughproj;
2264   Node* memproj_fallthrough = _memproj_fallthrough;
2265 
2266   // The memory projection from a lock/unlock is RawMem
2267   // The input to a Lock is merged memory, so extract its RawMem input
2268   // (unless the MergeMem has been optimized away.)
2269   if (alock-&gt;is_Lock()) {
2270     // Seach for MemBarAcquireLock node and delete it also.
2271     MemBarNode* membar = fallthroughproj-&gt;unique_ctrl_out()-&gt;as_MemBar();
2272     assert(membar != NULL &amp;&amp; membar-&gt;Opcode() == Op_MemBarAcquireLock, &quot;&quot;);
2273     Node* ctrlproj = membar-&gt;proj_out(TypeFunc::Control);
2274     Node* memproj = membar-&gt;proj_out(TypeFunc::Memory);
2275     _igvn.replace_node(ctrlproj, fallthroughproj);
2276     _igvn.replace_node(memproj, memproj_fallthrough);
2277 
2278     // Delete FastLock node also if this Lock node is unique user
2279     // (a loop peeling may clone a Lock node).
2280     Node* flock = alock-&gt;as_Lock()-&gt;fastlock_node();
2281     if (flock-&gt;outcnt() == 1) {
2282       assert(flock-&gt;unique_out() == alock, &quot;sanity&quot;);
2283       _igvn.replace_node(flock, top());
2284     }
2285   }
2286 
2287   // Seach for MemBarReleaseLock node and delete it also.
2288   if (alock-&gt;is_Unlock() &amp;&amp; ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_MemBar()) {
2289     MemBarNode* membar = ctrl-&gt;in(0)-&gt;as_MemBar();
2290     assert(membar-&gt;Opcode() == Op_MemBarReleaseLock &amp;&amp;
2291            mem-&gt;is_Proj() &amp;&amp; membar == mem-&gt;in(0), &quot;&quot;);
2292     _igvn.replace_node(fallthroughproj, ctrl);
2293     _igvn.replace_node(memproj_fallthrough, mem);
2294     fallthroughproj = ctrl;
2295     memproj_fallthrough = mem;
2296     ctrl = membar-&gt;in(TypeFunc::Control);
2297     mem  = membar-&gt;in(TypeFunc::Memory);
2298   }
2299 
2300   _igvn.replace_node(fallthroughproj, ctrl);
2301   _igvn.replace_node(memproj_fallthrough, mem);
2302   return true;
2303 }
2304 
2305 
2306 //------------------------------expand_lock_node----------------------
2307 void PhaseMacroExpand::expand_lock_node(LockNode *lock) {
2308 
2309   Node* ctrl = lock-&gt;in(TypeFunc::Control);
2310   Node* mem = lock-&gt;in(TypeFunc::Memory);
2311   Node* obj = lock-&gt;obj_node();
2312   Node* box = lock-&gt;box_node();
2313   Node* flock = lock-&gt;fastlock_node();
2314 
2315   assert(!box-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2316 
2317   // Make the merge point
2318   Node *region;
2319   Node *mem_phi;
2320   Node *slow_path;
2321 
2322   if (UseOptoBiasInlining) {
2323     /*
2324      *  See the full description in MacroAssembler::biased_locking_enter().
2325      *
2326      *  if( (mark_word &amp; biased_lock_mask) == biased_lock_pattern ) {
2327      *    // The object is biased.
2328      *    proto_node = klass-&gt;prototype_header;
2329      *    o_node = thread | proto_node;
2330      *    x_node = o_node ^ mark_word;
2331      *    if( (x_node &amp; ~age_mask) == 0 ) { // Biased to the current thread ?
2332      *      // Done.
2333      *    } else {
2334      *      if( (x_node &amp; biased_lock_mask) != 0 ) {
2335      *        // The klass&#39;s prototype header is no longer biased.
2336      *        cas(&amp;mark_word, mark_word, proto_node)
2337      *        goto cas_lock;
2338      *      } else {
2339      *        // The klass&#39;s prototype header is still biased.
2340      *        if( (x_node &amp; epoch_mask) != 0 ) { // Expired epoch?
2341      *          old = mark_word;
2342      *          new = o_node;
2343      *        } else {
2344      *          // Different thread or anonymous biased.
2345      *          old = mark_word &amp; (epoch_mask | age_mask | biased_lock_mask);
2346      *          new = thread | old;
2347      *        }
2348      *        // Try to rebias.
2349      *        if( cas(&amp;mark_word, old, new) == 0 ) {
2350      *          // Done.
2351      *        } else {
2352      *          goto slow_path; // Failed.
2353      *        }
2354      *      }
2355      *    }
2356      *  } else {
2357      *    // The object is not biased.
2358      *    cas_lock:
2359      *    if( FastLock(obj) == 0 ) {
2360      *      // Done.
2361      *    } else {
2362      *      slow_path:
2363      *      OptoRuntime::complete_monitor_locking_Java(obj);
2364      *    }
2365      *  }
2366      */
2367 
2368     region  = new RegionNode(5);
2369     // create a Phi for the memory state
2370     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2371 
2372     Node* fast_lock_region  = new RegionNode(3);
2373     Node* fast_lock_mem_phi = new PhiNode( fast_lock_region, Type::MEMORY, TypeRawPtr::BOTTOM);
2374 
2375     // First, check mark word for the biased lock pattern.
2376     Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());
2377 
2378     // Get fast path - mark word has the biased lock pattern.
2379     ctrl = opt_bits_test(ctrl, fast_lock_region, 1, mark_node,
2380                          markWord::biased_lock_mask_in_place,
2381                          markWord::biased_lock_pattern, true);
2382     // fast_lock_region-&gt;in(1) is set to slow path.
2383     fast_lock_mem_phi-&gt;init_req(1, mem);
2384 
2385     // Now check that the lock is biased to the current thread and has
2386     // the same epoch and bias as Klass::_prototype_header.
2387 
2388     // Special-case a fresh allocation to avoid building nodes:
2389     Node* klass_node = AllocateNode::Ideal_klass(obj, &amp;_igvn);
2390     if (klass_node == NULL) {
2391       Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());
2392       klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, mem, k_adr, _igvn.type(k_adr)-&gt;is_ptr()));
2393 #ifdef _LP64
2394       if (UseCompressedClassPointers &amp;&amp; klass_node-&gt;is_DecodeNKlass()) {
2395         assert(klass_node-&gt;in(1)-&gt;Opcode() == Op_LoadNKlass, &quot;sanity&quot;);
2396         klass_node-&gt;in(1)-&gt;init_req(0, ctrl);
2397       } else
2398 #endif
2399       klass_node-&gt;init_req(0, ctrl);
2400     }
2401     Node *proto_node = make_load(ctrl, mem, klass_node, in_bytes(Klass::prototype_header_offset()), TypeX_X, TypeX_X-&gt;basic_type());
2402 
2403     Node* thread = transform_later(new ThreadLocalNode());
2404     Node* cast_thread = transform_later(new CastP2XNode(ctrl, thread));
2405     Node* o_node = transform_later(new OrXNode(cast_thread, proto_node));
2406     Node* x_node = transform_later(new XorXNode(o_node, mark_node));
2407 
2408     // Get slow path - mark word does NOT match the value.
2409     STATIC_ASSERT(markWord::age_mask_in_place &lt;= INT_MAX);
2410     Node* not_biased_ctrl =  opt_bits_test(ctrl, region, 3, x_node,
2411                                       (~(int)markWord::age_mask_in_place), 0);
2412     // region-&gt;in(3) is set to fast path - the object is biased to the current thread.
2413     mem_phi-&gt;init_req(3, mem);
2414 
2415 
2416     // Mark word does NOT match the value (thread | Klass::_prototype_header).
2417 
2418 
2419     // First, check biased pattern.
2420     // Get fast path - _prototype_header has the same biased lock pattern.
2421     ctrl =  opt_bits_test(not_biased_ctrl, fast_lock_region, 2, x_node,
2422                           markWord::biased_lock_mask_in_place, 0, true);
2423 
2424     not_biased_ctrl = fast_lock_region-&gt;in(2); // Slow path
2425     // fast_lock_region-&gt;in(2) - the prototype header is no longer biased
2426     // and we have to revoke the bias on this object.
2427     // We are going to try to reset the mark of this object to the prototype
2428     // value and fall through to the CAS-based locking scheme.
2429     Node* adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
2430     Node* cas = new StoreXConditionalNode(not_biased_ctrl, mem, adr,
2431                                           proto_node, mark_node);
2432     transform_later(cas);
2433     Node* proj = transform_later(new SCMemProjNode(cas));
2434     fast_lock_mem_phi-&gt;init_req(2, proj);
2435 
2436 
2437     // Second, check epoch bits.
2438     Node* rebiased_region  = new RegionNode(3);
2439     Node* old_phi = new PhiNode( rebiased_region, TypeX_X);
2440     Node* new_phi = new PhiNode( rebiased_region, TypeX_X);
2441 
2442     // Get slow path - mark word does NOT match epoch bits.
2443     Node* epoch_ctrl =  opt_bits_test(ctrl, rebiased_region, 1, x_node,
2444                                       markWord::epoch_mask_in_place, 0);
2445     // The epoch of the current bias is not valid, attempt to rebias the object
2446     // toward the current thread.
2447     rebiased_region-&gt;init_req(2, epoch_ctrl);
2448     old_phi-&gt;init_req(2, mark_node);
2449     new_phi-&gt;init_req(2, o_node);
2450 
2451     // rebiased_region-&gt;in(1) is set to fast path.
2452     // The epoch of the current bias is still valid but we know
2453     // nothing about the owner; it might be set or it might be clear.
2454     Node* cmask   = MakeConX(markWord::biased_lock_mask_in_place |
2455                              markWord::age_mask_in_place |
2456                              markWord::epoch_mask_in_place);
2457     Node* old = transform_later(new AndXNode(mark_node, cmask));
2458     cast_thread = transform_later(new CastP2XNode(ctrl, thread));
2459     Node* new_mark = transform_later(new OrXNode(cast_thread, old));
2460     old_phi-&gt;init_req(1, old);
2461     new_phi-&gt;init_req(1, new_mark);
2462 
2463     transform_later(rebiased_region);
2464     transform_later(old_phi);
2465     transform_later(new_phi);
2466 
2467     // Try to acquire the bias of the object using an atomic operation.
2468     // If this fails we will go in to the runtime to revoke the object&#39;s bias.
2469     cas = new StoreXConditionalNode(rebiased_region, mem, adr, new_phi, old_phi);
2470     transform_later(cas);
2471     proj = transform_later(new SCMemProjNode(cas));
2472 
2473     // Get slow path - Failed to CAS.
2474     not_biased_ctrl = opt_bits_test(rebiased_region, region, 4, cas, 0, 0);
2475     mem_phi-&gt;init_req(4, proj);
2476     // region-&gt;in(4) is set to fast path - the object is rebiased to the current thread.
2477 
2478     // Failed to CAS.
2479     slow_path  = new RegionNode(3);
2480     Node *slow_mem = new PhiNode( slow_path, Type::MEMORY, TypeRawPtr::BOTTOM);
2481 
2482     slow_path-&gt;init_req(1, not_biased_ctrl); // Capture slow-control
2483     slow_mem-&gt;init_req(1, proj);
2484 
2485     // Call CAS-based locking scheme (FastLock node).
2486 
2487     transform_later(fast_lock_region);
2488     transform_later(fast_lock_mem_phi);
2489 
2490     // Get slow path - FastLock failed to lock the object.
2491     ctrl = opt_bits_test(fast_lock_region, region, 2, flock, 0, 0);
2492     mem_phi-&gt;init_req(2, fast_lock_mem_phi);
2493     // region-&gt;in(2) is set to fast path - the object is locked to the current thread.
2494 
2495     slow_path-&gt;init_req(2, ctrl); // Capture slow-control
2496     slow_mem-&gt;init_req(2, fast_lock_mem_phi);
2497 
2498     transform_later(slow_path);
2499     transform_later(slow_mem);
2500     // Reset lock&#39;s memory edge.
2501     lock-&gt;set_req(TypeFunc::Memory, slow_mem);
2502 
2503   } else {
2504     region  = new RegionNode(3);
2505     // create a Phi for the memory state
2506     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2507 
2508     // Optimize test; set region slot 2
2509     slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);
2510     mem_phi-&gt;init_req(2, mem);
2511   }
2512 
2513   const TypeOopPtr* objptr = _igvn.type(obj)-&gt;make_oopptr();
2514   if (objptr-&gt;can_be_inline_type()) {
2515     // Deoptimize and re-execute if a value
2516     assert(EnableValhalla, &quot;should only be used if inline types are enabled&quot;);
2517     Node* mark = make_load(slow_path, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());
2518     Node* value_mask = _igvn.MakeConX(markWord::always_locked_pattern);
2519     Node* is_value = _igvn.transform(new AndXNode(mark, value_mask));
2520     Node* cmp = _igvn.transform(new CmpXNode(is_value, value_mask));
2521     Node* bol = _igvn.transform(new BoolNode(cmp, BoolTest::eq));
2522     Node* unc_ctrl = generate_slow_guard(&amp;slow_path, bol, NULL);
2523 
2524     int trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_class_check, Deoptimization::Action_none);
2525     address call_addr = SharedRuntime::uncommon_trap_blob()-&gt;entry_point();
2526     const TypePtr* no_memory_effects = NULL;
2527     JVMState* jvms = lock-&gt;jvms();
2528     CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, &quot;uncommon_trap&quot;,
2529                                            jvms-&gt;bci(), no_memory_effects);
2530 
2531     unc-&gt;init_req(TypeFunc::Control, unc_ctrl);
2532     unc-&gt;init_req(TypeFunc::I_O, lock-&gt;i_o());
2533     unc-&gt;init_req(TypeFunc::Memory, mem); // may gc ptrs
2534     unc-&gt;init_req(TypeFunc::FramePtr,  lock-&gt;in(TypeFunc::FramePtr));
2535     unc-&gt;init_req(TypeFunc::ReturnAdr, lock-&gt;in(TypeFunc::ReturnAdr));
2536     unc-&gt;init_req(TypeFunc::Parms+0, _igvn.intcon(trap_request));
2537     unc-&gt;set_cnt(PROB_UNLIKELY_MAG(4));
2538     unc-&gt;copy_call_debug_info(&amp;_igvn, lock);
2539 
2540     assert(unc-&gt;peek_monitor_box() == box, &quot;wrong monitor&quot;);
2541     assert(unc-&gt;peek_monitor_obj() == obj, &quot;wrong monitor&quot;);
2542 
2543     // pop monitor and push obj back on stack: we trap before the monitorenter
2544     unc-&gt;pop_monitor();
2545     unc-&gt;grow_stack(unc-&gt;jvms(), 1);
2546     unc-&gt;set_stack(unc-&gt;jvms(), unc-&gt;jvms()-&gt;stk_size()-1, obj);
2547 
2548     _igvn.register_new_node_with_optimizer(unc);
2549 
2550     Node* ctrl = _igvn.transform(new ProjNode(unc, TypeFunc::Control));
2551     Node* halt = _igvn.transform(new HaltNode(ctrl, lock-&gt;in(TypeFunc::FramePtr), &quot;monitor enter on value-type&quot;));
2552     C-&gt;root()-&gt;add_req(halt);
2553   }
2554 
2555   // Make slow path call
2556   CallNode *call = make_slow_call((CallNode *) lock, OptoRuntime::complete_monitor_enter_Type(),
2557                                   OptoRuntime::complete_monitor_locking_Java(), NULL, slow_path,
2558                                   obj, box, NULL);
2559 
2560   extract_call_projections(call);
2561 
2562   // Slow path can only throw asynchronous exceptions, which are always
2563   // de-opted.  So the compiler thinks the slow-call can never throw an
2564   // exception.  If it DOES throw an exception we would need the debug
2565   // info removed first (since if it throws there is no monitor).
2566   assert ( _ioproj_fallthrough == NULL &amp;&amp; _ioproj_catchall == NULL &amp;&amp;
2567            _memproj_catchall == NULL &amp;&amp; _catchallcatchproj == NULL, &quot;Unexpected projection from Lock&quot;);
2568 
2569   // Capture slow path
2570   // disconnect fall-through projection from call and create a new one
2571   // hook up users of fall-through projection to region
2572   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2573   transform_later(slow_ctrl);
2574   _igvn.hash_delete(_fallthroughproj);
2575   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2576   region-&gt;init_req(1, slow_ctrl);
2577   // region inputs are now complete
2578   transform_later(region);
2579   _igvn.replace_node(_fallthroughproj, region);
2580 
2581   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory));
2582   mem_phi-&gt;init_req(1, memproj );
2583   transform_later(mem_phi);
2584   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2585 }
2586 
2587 //------------------------------expand_unlock_node----------------------
2588 void PhaseMacroExpand::expand_unlock_node(UnlockNode *unlock) {
2589 
2590   Node* ctrl = unlock-&gt;in(TypeFunc::Control);
2591   Node* mem = unlock-&gt;in(TypeFunc::Memory);
2592   Node* obj = unlock-&gt;obj_node();
2593   Node* box = unlock-&gt;box_node();
2594 
2595   assert(!box-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2596 
2597   // No need for a null check on unlock
2598 
2599   // Make the merge point
2600   Node *region;
2601   Node *mem_phi;
2602 
2603   if (UseOptoBiasInlining) {
2604     // Check for biased locking unlock case, which is a no-op.
2605     // See the full description in MacroAssembler::biased_locking_exit().
2606     region  = new RegionNode(4);
2607     // create a Phi for the memory state
2608     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2609     mem_phi-&gt;init_req(3, mem);
2610 
2611     Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());
2612     ctrl = opt_bits_test(ctrl, region, 3, mark_node,
2613                          markWord::biased_lock_mask_in_place,
2614                          markWord::biased_lock_pattern);
2615   } else {
2616     region  = new RegionNode(3);
2617     // create a Phi for the memory state
2618     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2619   }
2620 
2621   FastUnlockNode *funlock = new FastUnlockNode( ctrl, obj, box );
2622   funlock = transform_later( funlock )-&gt;as_FastUnlock();
2623   // Optimize test; set region slot 2
2624   Node *slow_path = opt_bits_test(ctrl, region, 2, funlock, 0, 0);
2625   Node *thread = transform_later(new ThreadLocalNode());
2626 
2627   CallNode *call = make_slow_call((CallNode *) unlock, OptoRuntime::complete_monitor_exit_Type(),
2628                                   CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C),
2629                                   &quot;complete_monitor_unlocking_C&quot;, slow_path, obj, box, thread);
2630 
2631   extract_call_projections(call);
2632 
2633   assert ( _ioproj_fallthrough == NULL &amp;&amp; _ioproj_catchall == NULL &amp;&amp;
2634            _memproj_catchall == NULL &amp;&amp; _catchallcatchproj == NULL, &quot;Unexpected projection from Lock&quot;);
2635 
2636   // No exceptions for unlocking
2637   // Capture slow path
2638   // disconnect fall-through projection from call and create a new one
2639   // hook up users of fall-through projection to region
2640   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2641   transform_later(slow_ctrl);
2642   _igvn.hash_delete(_fallthroughproj);
2643   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2644   region-&gt;init_req(1, slow_ctrl);
2645   // region inputs are now complete
2646   transform_later(region);
2647   _igvn.replace_node(_fallthroughproj, region);
2648 
2649   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory) );
2650   mem_phi-&gt;init_req(1, memproj );
2651   mem_phi-&gt;init_req(2, mem);
2652   transform_later(mem_phi);
2653   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2654 }
2655 
2656 // An inline type might be returned from the call but we don&#39;t know its
2657 // type. Either we get a buffered inline type (and nothing needs to be done)
2658 // or one of the inlines being returned is the klass of the inline type
2659 // and we need to allocate an inline type instance of that type and
2660 // initialize it with other values being returned. In that case, we
2661 // first try a fast path allocation and initialize the value with the
2662 // inline klass&#39;s pack handler or we fall back to a runtime call.
2663 void PhaseMacroExpand::expand_mh_intrinsic_return(CallStaticJavaNode* call) {
2664   assert(call-&gt;method()-&gt;is_method_handle_intrinsic(), &quot;must be a method handle intrinsic call&quot;);
2665   Node* ret = call-&gt;proj_out_or_null(TypeFunc::Parms);
2666   if (ret == NULL) {
2667     return;
2668   }
2669   const TypeFunc* tf = call-&gt;_tf;
2670   const TypeTuple* domain = OptoRuntime::store_inline_type_fields_Type()-&gt;domain_cc();
2671   const TypeFunc* new_tf = TypeFunc::make(tf-&gt;domain_sig(), tf-&gt;domain_cc(), tf-&gt;range_sig(), domain);
2672   call-&gt;_tf = new_tf;
2673   // Make sure the change of type is applied before projections are processed by igvn
2674   _igvn.set_type(call, call-&gt;Value(&amp;_igvn));
2675   _igvn.set_type(ret, ret-&gt;Value(&amp;_igvn));
2676 
2677   // Before any new projection is added:
2678   CallProjections* projs = call-&gt;extract_projections(true, true);
2679 
2680   Node* ctl = new Node(1);
2681   Node* mem = new Node(1);
2682   Node* io = new Node(1);
2683   Node* ex_ctl = new Node(1);
2684   Node* ex_mem = new Node(1);
2685   Node* ex_io = new Node(1);
2686   Node* res = new Node(1);
2687 
2688   Node* cast = transform_later(new CastP2XNode(ctl, res));
2689   Node* mask = MakeConX(0x1);
2690   Node* masked = transform_later(new AndXNode(cast, mask));
2691   Node* cmp = transform_later(new CmpXNode(masked, mask));
2692   Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));
2693   IfNode* allocation_iff = new IfNode(ctl, bol, PROB_MAX, COUNT_UNKNOWN);
2694   transform_later(allocation_iff);
2695   Node* allocation_ctl = transform_later(new IfTrueNode(allocation_iff));
2696   Node* no_allocation_ctl = transform_later(new IfFalseNode(allocation_iff));
2697 
2698   Node* no_allocation_res = transform_later(new CheckCastPPNode(no_allocation_ctl, res, TypeInstPtr::BOTTOM));
2699 
2700   Node* mask2 = MakeConX(-2);
2701   Node* masked2 = transform_later(new AndXNode(cast, mask2));
2702   Node* rawklassptr = transform_later(new CastX2PNode(masked2));
2703   Node* klass_node = transform_later(new CheckCastPPNode(allocation_ctl, rawklassptr, TypeKlassPtr::OBJECT_OR_NULL));
2704 
2705   Node* slowpath_bol = NULL;
2706   Node* top_adr = NULL;
2707   Node* old_top = NULL;
2708   Node* new_top = NULL;
2709   if (UseTLAB) {
2710     Node* end_adr = NULL;
2711     set_eden_pointers(top_adr, end_adr);
2712     Node* end = make_load(ctl, mem, end_adr, 0, TypeRawPtr::BOTTOM, T_ADDRESS);
2713     old_top = new LoadPNode(ctl, mem, top_adr, TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM, MemNode::unordered);
2714     transform_later(old_top);
2715     Node* layout_val = make_load(NULL, mem, klass_node, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);
2716     Node* size_in_bytes = ConvI2X(layout_val);
2717     new_top = new AddPNode(top(), old_top, size_in_bytes);
2718     transform_later(new_top);
2719     Node* slowpath_cmp = new CmpPNode(new_top, end);
2720     transform_later(slowpath_cmp);
2721     slowpath_bol = new BoolNode(slowpath_cmp, BoolTest::ge);
2722     transform_later(slowpath_bol);
2723   } else {
2724     slowpath_bol = intcon(1);
2725     top_adr = top();
2726     old_top = top();
2727     new_top = top();
2728   }
2729   IfNode* slowpath_iff = new IfNode(allocation_ctl, slowpath_bol, PROB_UNLIKELY_MAG(4), COUNT_UNKNOWN);
2730   transform_later(slowpath_iff);
2731 
2732   Node* slowpath_true = new IfTrueNode(slowpath_iff);
2733   transform_later(slowpath_true);
2734 
2735   CallStaticJavaNode* slow_call = new CallStaticJavaNode(OptoRuntime::store_inline_type_fields_Type(),
2736                                                          StubRoutines::store_inline_type_fields_to_buf(),
2737                                                          &quot;store_inline_type_fields&quot;,
2738                                                          call-&gt;jvms()-&gt;bci(),
2739                                                          TypePtr::BOTTOM);
2740   slow_call-&gt;init_req(TypeFunc::Control, slowpath_true);
2741   slow_call-&gt;init_req(TypeFunc::Memory, mem);
2742   slow_call-&gt;init_req(TypeFunc::I_O, io);
2743   slow_call-&gt;init_req(TypeFunc::FramePtr, call-&gt;in(TypeFunc::FramePtr));
2744   slow_call-&gt;init_req(TypeFunc::ReturnAdr, call-&gt;in(TypeFunc::ReturnAdr));
2745   slow_call-&gt;init_req(TypeFunc::Parms, res);
2746 
2747   Node* slow_ctl = transform_later(new ProjNode(slow_call, TypeFunc::Control));
2748   Node* slow_mem = transform_later(new ProjNode(slow_call, TypeFunc::Memory));
2749   Node* slow_io = transform_later(new ProjNode(slow_call, TypeFunc::I_O));
2750   Node* slow_res = transform_later(new ProjNode(slow_call, TypeFunc::Parms));
2751   Node* slow_catc = transform_later(new CatchNode(slow_ctl, slow_io, 2));
2752   Node* slow_norm = transform_later(new CatchProjNode(slow_catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci));
2753   Node* slow_excp = transform_later(new CatchProjNode(slow_catc, CatchProjNode::catch_all_index,    CatchProjNode::no_handler_bci));
2754 
2755   Node* ex_r = new RegionNode(3);
2756   Node* ex_mem_phi = new PhiNode(ex_r, Type::MEMORY, TypePtr::BOTTOM);
2757   Node* ex_io_phi = new PhiNode(ex_r, Type::ABIO);
2758   ex_r-&gt;init_req(1, slow_excp);
2759   ex_mem_phi-&gt;init_req(1, slow_mem);
2760   ex_io_phi-&gt;init_req(1, slow_io);
2761   ex_r-&gt;init_req(2, ex_ctl);
2762   ex_mem_phi-&gt;init_req(2, ex_mem);
2763   ex_io_phi-&gt;init_req(2, ex_io);
2764 
2765   transform_later(ex_r);
2766   transform_later(ex_mem_phi);
2767   transform_later(ex_io_phi);
2768 
2769   Node* slowpath_false = new IfFalseNode(slowpath_iff);
2770   transform_later(slowpath_false);
2771   Node* rawmem = new StorePNode(slowpath_false, mem, top_adr, TypeRawPtr::BOTTOM, new_top, MemNode::unordered);
2772   transform_later(rawmem);
2773   Node* mark_node = makecon(TypeRawPtr::make((address)markWord::always_locked_prototype().value()));
2774   rawmem = make_store(slowpath_false, rawmem, old_top, oopDesc::mark_offset_in_bytes(), mark_node, T_ADDRESS);
2775   rawmem = make_store(slowpath_false, rawmem, old_top, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);
2776   if (UseCompressedClassPointers) {
2777     rawmem = make_store(slowpath_false, rawmem, old_top, oopDesc::klass_gap_offset_in_bytes(), intcon(0), T_INT);
2778   }
2779   Node* fixed_block  = make_load(slowpath_false, rawmem, klass_node, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset()), TypeRawPtr::BOTTOM, T_ADDRESS);
2780   Node* pack_handler = make_load(slowpath_false, rawmem, fixed_block, in_bytes(InlineKlass::pack_handler_offset()), TypeRawPtr::BOTTOM, T_ADDRESS);
2781 
2782   CallLeafNoFPNode* handler_call = new CallLeafNoFPNode(OptoRuntime::pack_inline_type_Type(),
2783                                                         NULL,
2784                                                         &quot;pack handler&quot;,
2785                                                         TypeRawPtr::BOTTOM);
2786   handler_call-&gt;init_req(TypeFunc::Control, slowpath_false);
2787   handler_call-&gt;init_req(TypeFunc::Memory, rawmem);
2788   handler_call-&gt;init_req(TypeFunc::I_O, top());
2789   handler_call-&gt;init_req(TypeFunc::FramePtr, call-&gt;in(TypeFunc::FramePtr));
2790   handler_call-&gt;init_req(TypeFunc::ReturnAdr, top());
2791   handler_call-&gt;init_req(TypeFunc::Parms, pack_handler);
2792   handler_call-&gt;init_req(TypeFunc::Parms+1, old_top);
2793 
2794   // We don&#39;t know how many values are returned. This assumes the
2795   // worst case, that all available registers are used.
2796   for (uint i = TypeFunc::Parms+1; i &lt; domain-&gt;cnt(); i++) {
2797     if (domain-&gt;field_at(i) == Type::HALF) {
2798       slow_call-&gt;init_req(i, top());
2799       handler_call-&gt;init_req(i+1, top());
2800       continue;
2801     }
2802     Node* proj = transform_later(new ProjNode(call, i));
2803     slow_call-&gt;init_req(i, proj);
2804     handler_call-&gt;init_req(i+1, proj);
2805   }
2806 
2807   // We can safepoint at that new call
2808   slow_call-&gt;copy_call_debug_info(&amp;_igvn, call);
2809   transform_later(slow_call);
2810   transform_later(handler_call);
2811 
2812   Node* handler_ctl = transform_later(new ProjNode(handler_call, TypeFunc::Control));
2813   rawmem = transform_later(new ProjNode(handler_call, TypeFunc::Memory));
2814   Node* slowpath_false_res = transform_later(new ProjNode(handler_call, TypeFunc::Parms));
2815 
2816   MergeMemNode* slowpath_false_mem = MergeMemNode::make(mem);
2817   slowpath_false_mem-&gt;set_memory_at(Compile::AliasIdxRaw, rawmem);
2818   transform_later(slowpath_false_mem);
2819 
2820   Node* r = new RegionNode(4);
2821   Node* mem_phi = new PhiNode(r, Type::MEMORY, TypePtr::BOTTOM);
2822   Node* io_phi = new PhiNode(r, Type::ABIO);
2823   Node* res_phi = new PhiNode(r, TypeInstPtr::BOTTOM);
2824 
2825   r-&gt;init_req(1, no_allocation_ctl);
2826   mem_phi-&gt;init_req(1, mem);
2827   io_phi-&gt;init_req(1, io);
2828   res_phi-&gt;init_req(1, no_allocation_res);
2829   r-&gt;init_req(2, slow_norm);
2830   mem_phi-&gt;init_req(2, slow_mem);
2831   io_phi-&gt;init_req(2, slow_io);
2832   res_phi-&gt;init_req(2, slow_res);
2833   r-&gt;init_req(3, handler_ctl);
2834   mem_phi-&gt;init_req(3, slowpath_false_mem);
2835   io_phi-&gt;init_req(3, io);
2836   res_phi-&gt;init_req(3, slowpath_false_res);
2837 
2838   transform_later(r);
2839   transform_later(mem_phi);
2840   transform_later(io_phi);
2841   transform_later(res_phi);
2842 
2843   assert(projs-&gt;nb_resproj == 1, &quot;unexpected number of results&quot;);
2844   _igvn.replace_in_uses(projs-&gt;fallthrough_catchproj, r);
2845   _igvn.replace_in_uses(projs-&gt;fallthrough_memproj, mem_phi);
2846   _igvn.replace_in_uses(projs-&gt;fallthrough_ioproj, io_phi);
2847   _igvn.replace_in_uses(projs-&gt;resproj[0], res_phi);
2848   _igvn.replace_in_uses(projs-&gt;catchall_catchproj, ex_r);
2849   _igvn.replace_in_uses(projs-&gt;catchall_memproj, ex_mem_phi);
2850   _igvn.replace_in_uses(projs-&gt;catchall_ioproj, ex_io_phi);
2851 
2852   _igvn.replace_node(ctl, projs-&gt;fallthrough_catchproj);
2853   _igvn.replace_node(mem, projs-&gt;fallthrough_memproj);
2854   _igvn.replace_node(io, projs-&gt;fallthrough_ioproj);
2855   _igvn.replace_node(res, projs-&gt;resproj[0]);
2856   _igvn.replace_node(ex_ctl, projs-&gt;catchall_catchproj);
2857   _igvn.replace_node(ex_mem, projs-&gt;catchall_memproj);
2858   _igvn.replace_node(ex_io, projs-&gt;catchall_ioproj);
2859  }
2860 
2861 void PhaseMacroExpand::expand_subtypecheck_node(SubTypeCheckNode *check) {
2862   assert(check-&gt;in(SubTypeCheckNode::Control) == NULL, &quot;should be pinned&quot;);
2863   Node* bol = check-&gt;unique_out();
2864   Node* obj_or_subklass = check-&gt;in(SubTypeCheckNode::ObjOrSubKlass);
2865   Node* superklass = check-&gt;in(SubTypeCheckNode::SuperKlass);
2866   assert(bol-&gt;is_Bool() &amp;&amp; bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne, &quot;unexpected bool node&quot;);
2867 
2868   for (DUIterator_Last imin, i = bol-&gt;last_outs(imin); i &gt;= imin; --i) {
2869     Node* iff = bol-&gt;last_out(i);
2870     assert(iff-&gt;is_If(), &quot;where&#39;s the if?&quot;);
2871 
2872     if (iff-&gt;in(0)-&gt;is_top()) {
2873       _igvn.replace_input_of(iff, 1, C-&gt;top());
2874       continue;
2875     }
2876 
2877     Node* iftrue = iff-&gt;as_If()-&gt;proj_out(1);
2878     Node* iffalse = iff-&gt;as_If()-&gt;proj_out(0);
2879     Node* ctrl = iff-&gt;in(0);
2880 
2881     Node* subklass = NULL;
2882     if (_igvn.type(obj_or_subklass)-&gt;isa_klassptr()) {
2883       subklass = obj_or_subklass;
2884     } else {
2885       Node* k_adr = basic_plus_adr(obj_or_subklass, oopDesc::klass_offset_in_bytes());
2886       subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C-&gt;immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));
2887     }
2888 
2889     Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &amp;ctrl, NULL, _igvn);
2890 
2891     _igvn.replace_input_of(iff, 0, C-&gt;top());
2892     _igvn.replace_node(iftrue, not_subtype_ctrl);
2893     _igvn.replace_node(iffalse, ctrl);
2894   }
2895   _igvn.replace_node(check, C-&gt;top());
2896 }
2897 
2898 //---------------------------eliminate_macro_nodes----------------------
2899 // Eliminate scalar replaced allocations and associated locks.
2900 void PhaseMacroExpand::eliminate_macro_nodes() {
2901   if (C-&gt;macro_count() == 0)
2902     return;
2903 
2904   // First, attempt to eliminate locks
2905   int cnt = C-&gt;macro_count();
2906   for (int i=0; i &lt; cnt; i++) {
2907     Node *n = C-&gt;macro_node(i);
2908     if (n-&gt;is_AbstractLock()) { // Lock and Unlock nodes
2909       // Before elimination mark all associated (same box and obj)
2910       // lock and unlock nodes.
2911       mark_eliminated_locking_nodes(n-&gt;as_AbstractLock());
2912     }
2913   }
2914   bool progress = true;
2915   while (progress) {
2916     progress = false;
2917     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2918       Node * n = C-&gt;macro_node(i-1);
2919       bool success = false;
2920       debug_only(int old_macro_count = C-&gt;macro_count(););
2921       if (n-&gt;is_AbstractLock()) {
2922         success = eliminate_locking_node(n-&gt;as_AbstractLock());
2923       }
2924       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2925       progress = progress || success;
2926     }
2927   }
2928   // Next, attempt to eliminate allocations
2929   _has_locks = false;
2930   progress = true;
2931   while (progress) {
2932     progress = false;
2933     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2934       Node * n = C-&gt;macro_node(i-1);
2935       bool success = false;
2936       debug_only(int old_macro_count = C-&gt;macro_count(););
2937       switch (n-&gt;class_id()) {
2938       case Node::Class_Allocate:
2939       case Node::Class_AllocateArray:
2940         success = eliminate_allocate_node(n-&gt;as_Allocate());
2941         break;
2942       case Node::Class_CallStaticJava: {
2943         CallStaticJavaNode* call = n-&gt;as_CallStaticJava();
2944         if (!call-&gt;method()-&gt;is_method_handle_intrinsic()) {
2945           success = eliminate_boxing_node(n-&gt;as_CallStaticJava());
2946         }
2947         break;
2948       }
2949       case Node::Class_Lock:
2950       case Node::Class_Unlock:
2951         assert(!n-&gt;as_AbstractLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2952         _has_locks = true;
2953         break;
2954       case Node::Class_ArrayCopy:
2955         break;
2956       case Node::Class_OuterStripMinedLoop:
2957         break;
2958       case Node::Class_SubTypeCheck:
2959         break;
2960       default:
2961         assert(n-&gt;Opcode() == Op_LoopLimit ||
2962                n-&gt;Opcode() == Op_Opaque1   ||
2963                n-&gt;Opcode() == Op_Opaque2   ||
2964                n-&gt;Opcode() == Op_Opaque3   ||
2965                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(n),
2966                &quot;unknown node type in macro list&quot;);
2967       }
2968       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2969       progress = progress || success;
2970     }
2971   }
2972 }
2973 
2974 //------------------------------expand_macro_nodes----------------------
2975 //  Returns true if a failure occurred.
2976 bool PhaseMacroExpand::expand_macro_nodes() {
2977   // Last attempt to eliminate macro nodes.
2978   eliminate_macro_nodes();
2979 
2980   // Eliminate Opaque and LoopLimit nodes. Do it after all loop optimizations.
2981   bool progress = true;
2982   while (progress) {
2983     progress = false;
2984     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2985       Node* n = C-&gt;macro_node(i-1);
2986       bool success = false;
2987       debug_only(int old_macro_count = C-&gt;macro_count(););
2988       if (n-&gt;Opcode() == Op_LoopLimit) {
2989         // Remove it from macro list and put on IGVN worklist to optimize.
2990         C-&gt;remove_macro_node(n);
2991         _igvn._worklist.push(n);
2992         success = true;
2993       } else if (n-&gt;Opcode() == Op_CallStaticJava) {
2994         CallStaticJavaNode* call = n-&gt;as_CallStaticJava();
2995         if (!call-&gt;method()-&gt;is_method_handle_intrinsic()) {
2996           // Remove it from macro list and put on IGVN worklist to optimize.
2997           C-&gt;remove_macro_node(n);
2998           _igvn._worklist.push(n);
2999           success = true;
3000         }
3001       } else if (n-&gt;Opcode() == Op_Opaque1 || n-&gt;Opcode() == Op_Opaque2) {
3002         _igvn.replace_node(n, n-&gt;in(1));
3003         success = true;
3004 #if INCLUDE_RTM_OPT
3005       } else if ((n-&gt;Opcode() == Op_Opaque3) &amp;&amp; ((Opaque3Node*)n)-&gt;rtm_opt()) {
3006         assert(C-&gt;profile_rtm(), &quot;should be used only in rtm deoptimization code&quot;);
3007         assert((n-&gt;outcnt() == 1) &amp;&amp; n-&gt;unique_out()-&gt;is_Cmp(), &quot;&quot;);
3008         Node* cmp = n-&gt;unique_out();
3009 #ifdef ASSERT
3010         // Validate graph.
3011         assert((cmp-&gt;outcnt() == 1) &amp;&amp; cmp-&gt;unique_out()-&gt;is_Bool(), &quot;&quot;);
3012         BoolNode* bol = cmp-&gt;unique_out()-&gt;as_Bool();
3013         assert((bol-&gt;outcnt() == 1) &amp;&amp; bol-&gt;unique_out()-&gt;is_If() &amp;&amp;
3014                (bol-&gt;_test._test == BoolTest::ne), &quot;&quot;);
3015         IfNode* ifn = bol-&gt;unique_out()-&gt;as_If();
3016         assert((ifn-&gt;outcnt() == 2) &amp;&amp;
3017                ifn-&gt;proj_out(1)-&gt;is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != NULL, &quot;&quot;);
3018 #endif
3019         Node* repl = n-&gt;in(1);
3020         if (!_has_locks) {
3021           // Remove RTM state check if there are no locks in the code.
3022           // Replace input to compare the same value.
3023           repl = (cmp-&gt;in(1) == n) ? cmp-&gt;in(2) : cmp-&gt;in(1);
3024         }
3025         _igvn.replace_node(n, repl);
3026         success = true;
3027 #endif
3028       } else if (n-&gt;Opcode() == Op_OuterStripMinedLoop) {
3029         n-&gt;as_OuterStripMinedLoop()-&gt;adjust_strip_mined_loop(&amp;_igvn);
3030         C-&gt;remove_macro_node(n);
3031         success = true;
3032       }
3033       assert(!success || (C-&gt;macro_count() == (old_macro_count - 1)), &quot;elimination must have deleted one node from macro list&quot;);
3034       progress = progress || success;
3035     }
3036   }
3037 
3038   // Clean up the graph so we&#39;re less likely to hit the maximum node
3039   // limit
3040   _igvn.set_delay_transform(false);
3041   _igvn.optimize();
3042   if (C-&gt;failing())  return true;
3043   _igvn.set_delay_transform(true);
3044 
3045 
3046   // Because we run IGVN after each expansion, some macro nodes may go
3047   // dead and be removed from the list as we iterate over it. Move
3048   // Allocate nodes (processed in a second pass) at the beginning of
3049   // the list and then iterate from the last element of the list until
3050   // an Allocate node is seen. This is robust to random deletion in
3051   // the list due to nodes going dead.
3052   C-&gt;sort_macro_nodes();
3053 
3054   // expand arraycopy &quot;macro&quot; nodes first
3055   // For ReduceBulkZeroing, we must first process all arraycopy nodes
3056   // before the allocate nodes are expanded.
3057   while (C-&gt;macro_count() &gt; 0) {
3058     int macro_count = C-&gt;macro_count();
3059     Node * n = C-&gt;macro_node(macro_count-1);
3060     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
3061     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
3062       // node is unreachable, so don&#39;t try to expand it
3063       C-&gt;remove_macro_node(n);
3064       continue;
3065     }
3066     if (n-&gt;is_Allocate()) {
3067       break;
3068     }
3069     // Make sure expansion will not cause node limit to be exceeded.
3070     // Worst case is a macro node gets expanded into about 200 nodes.
3071     // Allow 50% more for optimization.
3072     if (C-&gt;check_node_count(300, &quot;out of nodes before macro expansion&quot;)) {
3073       return true;
3074     }
3075 
3076     debug_only(int old_macro_count = C-&gt;macro_count(););
3077     switch (n-&gt;class_id()) {
3078     case Node::Class_Lock:
3079       expand_lock_node(n-&gt;as_Lock());
3080       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3081       break;
3082     case Node::Class_Unlock:
3083       expand_unlock_node(n-&gt;as_Unlock());
3084       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3085       break;
3086     case Node::Class_ArrayCopy:
3087       expand_arraycopy_node(n-&gt;as_ArrayCopy());
3088       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3089       break;
3090     case Node::Class_SubTypeCheck:
3091       expand_subtypecheck_node(n-&gt;as_SubTypeCheck());
3092       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3093       break;
3094     case Node::Class_CallStaticJava:
3095       expand_mh_intrinsic_return(n-&gt;as_CallStaticJava());
3096       C-&gt;remove_macro_node(n);
3097       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
3098       break;
3099     default:
3100       assert(false, &quot;unknown node type in macro list&quot;);
3101     }
3102     assert(C-&gt;macro_count() &lt; macro_count, &quot;must have deleted a node from macro list&quot;);
3103     if (C-&gt;failing())  return true;
3104 
3105     // Clean up the graph so we&#39;re less likely to hit the maximum node
3106     // limit
3107     _igvn.set_delay_transform(false);
3108     _igvn.optimize();
3109     if (C-&gt;failing())  return true;
3110     _igvn.set_delay_transform(true);
3111   }
3112 
3113   // All nodes except Allocate nodes are expanded now. There could be
3114   // new optimization opportunities (such as folding newly created
3115   // load from a just allocated object). Run IGVN.
3116 
3117   // expand &quot;macro&quot; nodes
3118   // nodes are removed from the macro list as they are processed
3119   while (C-&gt;macro_count() &gt; 0) {
3120     int macro_count = C-&gt;macro_count();
3121     Node * n = C-&gt;macro_node(macro_count-1);
3122     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
3123     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
3124       // node is unreachable, so don&#39;t try to expand it
3125       C-&gt;remove_macro_node(n);
3126       continue;
3127     }
3128     // Make sure expansion will not cause node limit to be exceeded.
3129     // Worst case is a macro node gets expanded into about 200 nodes.
3130     // Allow 50% more for optimization.
3131     if (C-&gt;check_node_count(300, &quot;out of nodes before macro expansion&quot;)) {
3132       return true;
3133     }
3134     switch (n-&gt;class_id()) {
3135     case Node::Class_Allocate:
3136       expand_allocate(n-&gt;as_Allocate());
3137       break;
3138     case Node::Class_AllocateArray:
3139       expand_allocate_array(n-&gt;as_AllocateArray());
3140       break;
3141     default:
3142       assert(false, &quot;unknown node type in macro list&quot;);
3143     }
3144     assert(C-&gt;macro_count() &lt; macro_count, &quot;must have deleted a node from macro list&quot;);
3145     if (C-&gt;failing())  return true;
3146 
3147     // Clean up the graph so we&#39;re less likely to hit the maximum node
3148     // limit
3149     _igvn.set_delay_transform(false);
3150     _igvn.optimize();
3151     if (C-&gt;failing())  return true;
3152     _igvn.set_delay_transform(true);
3153   }
3154 
3155   _igvn.set_delay_transform(false);
3156   return false;
3157 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>