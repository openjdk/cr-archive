<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.unsupported/share/classes/sun/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.misc;
  27 
  28 import jdk.internal.vm.annotation.ForceInline;
  29 import jdk.internal.misc.VM;
  30 import jdk.internal.reflect.CallerSensitive;
  31 import jdk.internal.reflect.Reflection;
  32 
  33 import java.lang.invoke.MethodHandles;
  34 import java.lang.reflect.Field;
  35 import java.util.Set;
  36 
  37 
  38 /**
  39  * A collection of methods for performing low-level, unsafe operations.
  40  * Although the class and all methods are public, use of this class is
  41  * limited because only trusted code can obtain instances of it.
  42  *
  43  * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make sure
  44  * arguments are checked before methods of this class are
  45  * called. While some rudimentary checks are performed on the input,
  46  * the checks are best effort and when performance is an overriding
  47  * priority, as when methods of this class are optimized by the
  48  * runtime compiler, some or all checks (if any) may be elided. Hence,
  49  * the caller must not rely on the checks and corresponding
  50  * exceptions!
  51  *
  52  * @author John R. Rose
  53  * @see #getUnsafe
  54  */
  55 
  56 public final class Unsafe {
  57 
  58     static {
  59         Reflection.registerMethodsToFilter(Unsafe.class, Set.of(&quot;getUnsafe&quot;));
  60     }
  61 
  62     private Unsafe() {}
  63 
  64     private static final Unsafe theUnsafe = new Unsafe();
  65     private static final jdk.internal.misc.Unsafe theInternalUnsafe = jdk.internal.misc.Unsafe.getUnsafe();
  66 
  67     /**
  68      * Provides the caller with the capability of performing unsafe
  69      * operations.
  70      *
  71      * &lt;p&gt;The returned {@code Unsafe} object should be carefully guarded
  72      * by the caller, since it can be used to read and write data at arbitrary
  73      * memory addresses.  It must never be passed to untrusted code.
  74      *
  75      * &lt;p&gt;Most methods in this class are very low-level, and correspond to a
  76      * small number of hardware instructions (on typical machines).  Compilers
  77      * are encouraged to optimize these methods accordingly.
  78      *
  79      * &lt;p&gt;Here is a suggested idiom for using unsafe operations:
  80      *
  81      * &lt;pre&gt; {@code
  82      * class MyTrustedClass {
  83      *   private static final Unsafe unsafe = Unsafe.getUnsafe();
  84      *   ...
  85      *   private long myCountAddress = ...;
  86      *   public int getCount() { return unsafe.getByte(myCountAddress); }
  87      * }}&lt;/pre&gt;
  88      *
  89      * (It may assist compilers to make the local variable {@code final}.)
  90      *
  91      * @throws  SecurityException if the class loader of the caller
  92      *          class is not in the system domain in which all permissions
  93      *          are granted.
  94      */
  95     @CallerSensitive
  96     public static Unsafe getUnsafe() {
  97         Class&lt;?&gt; caller = Reflection.getCallerClass();
  98         if (!VM.isSystemDomainLoader(caller.getClassLoader()))
  99             throw new SecurityException(&quot;Unsafe&quot;);
 100         return theUnsafe;
 101     }
 102 
 103     /// peek and poke operations
 104     /// (compilers should optimize these to memory ops)
 105 
 106     // These work on object fields in the Java heap.
 107     // They will not work on elements of packed arrays.
 108 
 109     /**
 110      * Fetches a value from a given Java variable.
 111      * More specifically, fetches a field or array element within the given
 112      * object {@code o} at the given offset, or (if {@code o} is null)
 113      * from the memory address whose numerical value is the given offset.
 114      * &lt;p&gt;
 115      * The results are undefined unless one of the following cases is true:
 116      * &lt;ul&gt;
 117      * &lt;li&gt;The offset was obtained from {@link #objectFieldOffset} on
 118      * the {@link java.lang.reflect.Field} of some Java field and the object
 119      * referred to by {@code o} is of a class compatible with that
 120      * field&#39;s class.
 121      *
 122      * &lt;li&gt;The offset and object reference {@code o} (either null or
 123      * non-null) were both obtained via {@link #staticFieldOffset}
 124      * and {@link #staticFieldBase} (respectively) from the
 125      * reflective {@link Field} representation of some Java field.
 126      *
 127      * &lt;li&gt;The object referred to by {@code o} is an array, and the offset
 128      * is an integer of the form {@code B+N*S}, where {@code N} is
 129      * a valid index into the array, and {@code B} and {@code S} are
 130      * the values obtained by {@link #arrayBaseOffset} and {@link
 131      * #arrayIndexScale} (respectively) from the array&#39;s class.  The value
 132      * referred to is the {@code N}&lt;em&gt;th&lt;/em&gt; element of the array.
 133      *
 134      * &lt;/ul&gt;
 135      * &lt;p&gt;
 136      * If one of the above cases is true, the call references a specific Java
 137      * variable (field or array element).  However, the results are undefined
 138      * if that variable is not in fact of the type returned by this method.
 139      * &lt;p&gt;
 140      * This method refers to a variable by means of two parameters, and so
 141      * it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode
 142      * for Java variables.  When the object reference is null, this method
 143      * uses its offset as an absolute address.  This is similar in operation
 144      * to methods such as {@link #getInt(long)}, which provide (in effect) a
 145      * &lt;em&gt;single-register&lt;/em&gt; addressing mode for non-Java variables.
 146      * However, because Java variables may have a different layout in memory
 147      * from non-Java variables, programmers should not assume that these
 148      * two addressing modes are ever equivalent.  Also, programmers should
 149      * remember that offsets from the double-register addressing mode cannot
 150      * be portably confused with longs used in the single-register addressing
 151      * mode.
 152      *
 153      * @param o Java heap object in which the variable resides, if any, else
 154      *        null
 155      * @param offset indication of where the variable resides in a Java heap
 156      *        object, if any, else a memory address locating the variable
 157      *        statically
 158      * @return the value fetched from the indicated Java variable
 159      * @throws RuntimeException No defined exceptions are thrown, not even
 160      *         {@link NullPointerException}
 161      */
 162     @ForceInline
 163     public int getInt(Object o, long offset) {
 164         return theInternalUnsafe.getInt(o, offset);
 165     }
 166 
 167     /**
 168      * Stores a value into a given Java variable.
 169      * &lt;p&gt;
 170      * The first two parameters are interpreted exactly as with
 171      * {@link #getInt(Object, long)} to refer to a specific
 172      * Java variable (field or array element).  The given value
 173      * is stored into that variable.
 174      * &lt;p&gt;
 175      * The variable must be of the same type as the method
 176      * parameter {@code x}.
 177      *
 178      * @param o Java heap object in which the variable resides, if any, else
 179      *        null
 180      * @param offset indication of where the variable resides in a Java heap
 181      *        object, if any, else a memory address locating the variable
 182      *        statically
 183      * @param x the value to store into the indicated Java variable
 184      * @throws RuntimeException No defined exceptions are thrown, not even
 185      *         {@link NullPointerException}
 186      */
 187     @ForceInline
 188     public void putInt(Object o, long offset, int x) {
 189         theInternalUnsafe.putInt(o, offset, x);
 190     }
 191 
 192     /**
 193      * Fetches a reference value from a given Java variable.
 194      * @see #getInt(Object, long)
 195      */
 196     @ForceInline
 197     public Object getObject(Object o, long offset) {
 198         return theInternalUnsafe.getReference(o, offset);
 199     }
 200 
 201     /**
 202      * Stores a reference value into a given Java variable.
 203      * &lt;p&gt;
 204      * Unless the reference {@code x} being stored is either null
 205      * or matches the field type, the results are undefined.
 206      * If the reference {@code o} is non-null, card marks or
 207      * other store barriers for that object (if the VM requires them)
 208      * are updated.
 209      * @see #putInt(Object, long, int)
 210      */
 211     @ForceInline
 212     public void putObject(Object o, long offset, Object x) {
 213         theInternalUnsafe.putReference(o, offset, x);
 214     }
 215 
 216     /** @see #getInt(Object, long) */
 217     @ForceInline
 218     public boolean getBoolean(Object o, long offset) {
 219         return theInternalUnsafe.getBoolean(o, offset);
 220     }
 221 
 222     /** @see #putInt(Object, long, int) */
 223     @ForceInline
 224     public void putBoolean(Object o, long offset, boolean x) {
 225         theInternalUnsafe.putBoolean(o, offset, x);
 226     }
 227 
 228     /** @see #getInt(Object, long) */
 229     @ForceInline
 230     public byte getByte(Object o, long offset) {
 231         return theInternalUnsafe.getByte(o, offset);
 232     }
 233 
 234     /** @see #putInt(Object, long, int) */
 235     @ForceInline
 236     public void putByte(Object o, long offset, byte x) {
 237         theInternalUnsafe.putByte(o, offset, x);
 238     }
 239 
 240     /** @see #getInt(Object, long) */
 241     @ForceInline
 242     public short getShort(Object o, long offset) {
 243         return theInternalUnsafe.getShort(o, offset);
 244     }
 245 
 246     /** @see #putInt(Object, long, int) */
 247     @ForceInline
 248     public void putShort(Object o, long offset, short x) {
 249         theInternalUnsafe.putShort(o, offset, x);
 250     }
 251 
 252     /** @see #getInt(Object, long) */
 253     @ForceInline
 254     public char getChar(Object o, long offset) {
 255         return theInternalUnsafe.getChar(o, offset);
 256     }
 257 
 258     /** @see #putInt(Object, long, int) */
 259     @ForceInline
 260     public void putChar(Object o, long offset, char x) {
 261         theInternalUnsafe.putChar(o, offset, x);
 262     }
 263 
 264     /** @see #getInt(Object, long) */
 265     @ForceInline
 266     public long getLong(Object o, long offset) {
 267         return theInternalUnsafe.getLong(o, offset);
 268     }
 269 
 270     /** @see #putInt(Object, long, int) */
 271     @ForceInline
 272     public void putLong(Object o, long offset, long x) {
 273         theInternalUnsafe.putLong(o, offset, x);
 274     }
 275 
 276     /** @see #getInt(Object, long) */
 277     @ForceInline
 278     public float getFloat(Object o, long offset) {
 279         return theInternalUnsafe.getFloat(o, offset);
 280     }
 281 
 282     /** @see #putInt(Object, long, int) */
 283     @ForceInline
 284     public void putFloat(Object o, long offset, float x) {
 285         theInternalUnsafe.putFloat(o, offset, x);
 286     }
 287 
 288     /** @see #getInt(Object, long) */
 289     @ForceInline
 290     public double getDouble(Object o, long offset) {
 291         return theInternalUnsafe.getDouble(o, offset);
 292     }
 293 
 294     /** @see #putInt(Object, long, int) */
 295     @ForceInline
 296     public void putDouble(Object o, long offset, double x) {
 297         theInternalUnsafe.putDouble(o, offset, x);
 298     }
 299 
 300     // These work on values in the C heap.
 301 
 302     /**
 303      * Fetches a value from a given memory address.  If the address is zero, or
 304      * does not point into a block obtained from {@link #allocateMemory}, the
 305      * results are undefined.
 306      *
 307      * @see #allocateMemory
 308      */
 309     @ForceInline
 310     public byte getByte(long address) {
 311         return theInternalUnsafe.getByte(address);
 312     }
 313 
 314     /**
 315      * Stores a value into a given memory address.  If the address is zero, or
 316      * does not point into a block obtained from {@link #allocateMemory}, the
 317      * results are undefined.
 318      *
 319      * @see #getByte(long)
 320      */
 321     @ForceInline
 322     public void putByte(long address, byte x) {
 323         theInternalUnsafe.putByte(address, x);
 324     }
 325 
 326     /** @see #getByte(long) */
 327     @ForceInline
 328     public short getShort(long address) {
 329         return theInternalUnsafe.getShort(address);
 330     }
 331 
 332     /** @see #putByte(long, byte) */
 333     @ForceInline
 334     public void putShort(long address, short x) {
 335         theInternalUnsafe.putShort(address, x);
 336     }
 337 
 338     /** @see #getByte(long) */
 339     @ForceInline
 340     public char getChar(long address) {
 341         return theInternalUnsafe.getChar(address);
 342     }
 343 
 344     /** @see #putByte(long, byte) */
 345     @ForceInline
 346     public void putChar(long address, char x) {
 347         theInternalUnsafe.putChar(address, x);
 348     }
 349 
 350     /** @see #getByte(long) */
 351     @ForceInline
 352     public int getInt(long address) {
 353         return theInternalUnsafe.getInt(address);
 354     }
 355 
 356     /** @see #putByte(long, byte) */
 357     @ForceInline
 358     public void putInt(long address, int x) {
 359         theInternalUnsafe.putInt(address, x);
 360     }
 361 
 362     /** @see #getByte(long) */
 363     @ForceInline
 364     public long getLong(long address) {
 365         return theInternalUnsafe.getLong(address);
 366     }
 367 
 368     /** @see #putByte(long, byte) */
 369     @ForceInline
 370     public void putLong(long address, long x) {
 371         theInternalUnsafe.putLong(address, x);
 372     }
 373 
 374     /** @see #getByte(long) */
 375     @ForceInline
 376     public float getFloat(long address) {
 377         return theInternalUnsafe.getFloat(address);
 378     }
 379 
 380     /** @see #putByte(long, byte) */
 381     @ForceInline
 382     public void putFloat(long address, float x) {
 383         theInternalUnsafe.putFloat(address, x);
 384     }
 385 
 386     /** @see #getByte(long) */
 387     @ForceInline
 388     public double getDouble(long address) {
 389         return theInternalUnsafe.getDouble(address);
 390     }
 391 
 392     /** @see #putByte(long, byte) */
 393     @ForceInline
 394     public void putDouble(long address, double x) {
 395         theInternalUnsafe.putDouble(address, x);
 396     }
 397 
 398 
 399     /**
 400      * Fetches a native pointer from a given memory address.  If the address is
 401      * zero, or does not point into a block obtained from {@link
 402      * #allocateMemory}, the results are undefined.
 403      *
 404      * &lt;p&gt;If the native pointer is less than 64 bits wide, it is extended as
 405      * an unsigned number to a Java long.  The pointer may be indexed by any
 406      * given byte offset, simply by adding that offset (as a simple integer) to
 407      * the long representing the pointer.  The number of bytes actually read
 408      * from the target address may be determined by consulting {@link
 409      * #addressSize}.
 410      *
 411      * @see #allocateMemory
 412      */
 413     @ForceInline
 414     public long getAddress(long address) {
 415         return theInternalUnsafe.getAddress(address);
 416     }
 417 
 418     /**
 419      * Stores a native pointer into a given memory address.  If the address is
 420      * zero, or does not point into a block obtained from {@link
 421      * #allocateMemory}, the results are undefined.
 422      *
 423      * &lt;p&gt;The number of bytes actually written at the target address may be
 424      * determined by consulting {@link #addressSize}.
 425      *
 426      * @see #getAddress(long)
 427      */
 428     @ForceInline
 429     public void putAddress(long address, long x) {
 430         theInternalUnsafe.putAddress(address, x);
 431     }
 432 
 433 
 434     /// wrappers for malloc, realloc, free:
 435 
 436     /**
 437      * Allocates a new block of native memory, of the given size in bytes.  The
 438      * contents of the memory are uninitialized; they will generally be
 439      * garbage.  The resulting native pointer will never be zero, and will be
 440      * aligned for all value types.  Dispose of this memory by calling {@link
 441      * #freeMemory}, or resize it with {@link #reallocateMemory}.
 442      *
 443      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 444      * sure arguments are checked before the methods are called. While
 445      * some rudimentary checks are performed on the input, the checks
 446      * are best effort and when performance is an overriding priority,
 447      * as when methods of this class are optimized by the runtime
 448      * compiler, some or all checks (if any) may be elided. Hence, the
 449      * caller must not rely on the checks and corresponding
 450      * exceptions!
 451      *
 452      * @throws RuntimeException if the size is negative or too large
 453      *         for the native size_t type
 454      *
 455      * @throws OutOfMemoryError if the allocation is refused by the system
 456      *
 457      * @see #getByte(long)
 458      * @see #putByte(long, byte)
 459      */
 460     @ForceInline
 461     public long allocateMemory(long bytes) {
 462         return theInternalUnsafe.allocateMemory(bytes);
 463     }
 464 
 465     /**
 466      * Resizes a new block of native memory, to the given size in bytes.  The
 467      * contents of the new block past the size of the old block are
 468      * uninitialized; they will generally be garbage.  The resulting native
 469      * pointer will be zero if and only if the requested size is zero.  The
 470      * resulting native pointer will be aligned for all value types.  Dispose
 471      * of this memory by calling {@link #freeMemory}, or resize it with {@link
 472      * #reallocateMemory}.  The address passed to this method may be null, in
 473      * which case an allocation will be performed.
 474      *
 475      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 476      * sure arguments are checked before the methods are called. While
 477      * some rudimentary checks are performed on the input, the checks
 478      * are best effort and when performance is an overriding priority,
 479      * as when methods of this class are optimized by the runtime
 480      * compiler, some or all checks (if any) may be elided. Hence, the
 481      * caller must not rely on the checks and corresponding
 482      * exceptions!
 483      *
 484      * @throws RuntimeException if the size is negative or too large
 485      *         for the native size_t type
 486      *
 487      * @throws OutOfMemoryError if the allocation is refused by the system
 488      *
 489      * @see #allocateMemory
 490      */
 491     @ForceInline
 492     public long reallocateMemory(long address, long bytes) {
 493         return theInternalUnsafe.reallocateMemory(address, bytes);
 494     }
 495 
 496     /**
 497      * Sets all bytes in a given block of memory to a fixed value
 498      * (usually zero).
 499      *
 500      * &lt;p&gt;This method determines a block&#39;s base address by means of two parameters,
 501      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 502      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 503      * the offset supplies an absolute base address.
 504      *
 505      * &lt;p&gt;The stores are in coherent (atomic) units of a size determined
 506      * by the address and length parameters.  If the effective address and
 507      * length are all even modulo 8, the stores take place in &#39;long&#39; units.
 508      * If the effective address and length are (resp.) even modulo 4 or 2,
 509      * the stores take place in units of &#39;int&#39; or &#39;short&#39;.
 510      *
 511      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 512      * sure arguments are checked before the methods are called. While
 513      * some rudimentary checks are performed on the input, the checks
 514      * are best effort and when performance is an overriding priority,
 515      * as when methods of this class are optimized by the runtime
 516      * compiler, some or all checks (if any) may be elided. Hence, the
 517      * caller must not rely on the checks and corresponding
 518      * exceptions!
 519      *
 520      * @throws RuntimeException if any of the arguments is invalid
 521      *
 522      * @since 1.7
 523      */
 524     @ForceInline
 525     public void setMemory(Object o, long offset, long bytes, byte value) {
 526         theInternalUnsafe.setMemory(o, offset, bytes, value);
 527     }
 528 
 529     /**
 530      * Sets all bytes in a given block of memory to a fixed value
 531      * (usually zero).  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 532      * as discussed in {@link #getInt(Object,long)}.
 533      *
 534      * &lt;p&gt;Equivalent to {@code setMemory(null, address, bytes, value)}.
 535      */
 536     @ForceInline
 537     public void setMemory(long address, long bytes, byte value) {
 538         theInternalUnsafe.setMemory(address, bytes, value);
 539     }
 540 
 541     /**
 542      * Sets all bytes in a given block of memory to a copy of another
 543      * block.
 544      *
 545      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 546      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 547      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 548      * the offset supplies an absolute base address.
 549      *
 550      * &lt;p&gt;The transfers are in coherent (atomic) units of a size determined
 551      * by the address and length parameters.  If the effective addresses and
 552      * length are all even modulo 8, the transfer takes place in &#39;long&#39; units.
 553      * If the effective addresses and length are (resp.) even modulo 4 or 2,
 554      * the transfer takes place in units of &#39;int&#39; or &#39;short&#39;.
 555      *
 556      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 557      * sure arguments are checked before the methods are called. While
 558      * some rudimentary checks are performed on the input, the checks
 559      * are best effort and when performance is an overriding priority,
 560      * as when methods of this class are optimized by the runtime
 561      * compiler, some or all checks (if any) may be elided. Hence, the
 562      * caller must not rely on the checks and corresponding
 563      * exceptions!
 564      *
 565      * @throws RuntimeException if any of the arguments is invalid
 566      *
 567      * @since 1.7
 568      */
 569     @ForceInline
 570     public void copyMemory(Object srcBase, long srcOffset,
 571                            Object destBase, long destOffset,
 572                            long bytes) {
 573         theInternalUnsafe.copyMemory(srcBase, srcOffset, destBase, destOffset, bytes);
 574     }
 575 
 576     /**
 577      * Sets all bytes in a given block of memory to a copy of another
 578      * block.  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 579      * as discussed in {@link #getInt(Object,long)}.
 580      *
 581      * Equivalent to {@code copyMemory(null, srcAddress, null, destAddress, bytes)}.
 582      */
 583     @ForceInline
 584     public void copyMemory(long srcAddress, long destAddress, long bytes) {
 585         theInternalUnsafe.copyMemory(srcAddress, destAddress, bytes);
 586     }
 587 
 588     /**
 589      * Disposes of a block of native memory, as obtained from {@link
 590      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
 591      * this method may be null, in which case no action is taken.
 592      *
 593      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 594      * sure arguments are checked before the methods are called. While
 595      * some rudimentary checks are performed on the input, the checks
 596      * are best effort and when performance is an overriding priority,
 597      * as when methods of this class are optimized by the runtime
 598      * compiler, some or all checks (if any) may be elided. Hence, the
 599      * caller must not rely on the checks and corresponding
 600      * exceptions!
 601      *
 602      * @throws RuntimeException if any of the arguments is invalid
 603      *
 604      * @see #allocateMemory
 605      */
 606     @ForceInline
 607     public void freeMemory(long address) {
 608         theInternalUnsafe.freeMemory(address);
 609     }
 610 
 611     /// random queries
 612 
 613     /**
 614      * This constant differs from all results that will ever be returned from
 615      * {@link #staticFieldOffset}, {@link #objectFieldOffset},
 616      * or {@link #arrayBaseOffset}.
 617      */
 618     public static final int INVALID_FIELD_OFFSET = jdk.internal.misc.Unsafe.INVALID_FIELD_OFFSET;
 619 
 620     /**
 621      * Reports the location of a given field in the storage allocation of its
 622      * class.  Do not expect to perform any sort of arithmetic on this offset;
 623      * it is just a cookie which is passed to the unsafe heap memory accessors.
 624      *
 625      * &lt;p&gt;Any given field will always have the same offset and base, and no
 626      * two distinct fields of the same class will ever have the same offset
 627      * and base.
 628      *
 629      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 630      * although the Sun JVM does not use the most significant 32 bits.
 631      * However, JVM implementations which store static fields at absolute
 632      * addresses can use long offsets and null base pointers to express
 633      * the field locations in a form usable by {@link #getInt(Object,long)}.
 634      * Therefore, code which will be ported to such JVMs on 64-bit platforms
 635      * must preserve all bits of static field offsets.
 636      * @see #getInt(Object, long)
 637      */
 638     @ForceInline
<a name="2" id="anc2"></a><span class="line-added"> 639     @SuppressWarnings(&quot;preview&quot;)</span>
 640     public long objectFieldOffset(Field f) {
 641         if (f == null) {
 642             throw new NullPointerException();
 643         }
<a name="3" id="anc3"></a><span class="line-modified"> 644         Class&lt;?&gt; declaringClass = f.getDeclaringClass();</span>
<span class="line-added"> 645         if (declaringClass.isHidden()) {</span>
 646             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on a hidden class: &quot; + f);
 647         }
 648         if (f.getDeclaringClass().isInlineClass()) {
 649             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on an inline class: &quot; + f);
 650         }
<a name="4" id="anc4"></a><span class="line-added"> 651         if (declaringClass.isRecord()) {</span>
<span class="line-added"> 652             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on a record (preview): &quot; + f);</span>
<span class="line-added"> 653         }</span>
 654         return theInternalUnsafe.objectFieldOffset(f);
 655     }
 656 
 657     /**
 658      * Reports the location of a given static field, in conjunction with {@link
 659      * #staticFieldBase}.
 660      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
 661      * it is just a cookie which is passed to the unsafe heap memory accessors.
 662      *
 663      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
 664      * fields of the same class will ever have the same offset.
 665      *
 666      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 667      * although the Sun JVM does not use the most significant 32 bits.
 668      * It is hard to imagine a JVM technology which needs more than
 669      * a few bits to encode an offset within a non-array object,
 670      * However, for consistency with other methods in this class,
 671      * this method reports its result as a long value.
 672      * @see #getInt(Object, long)
 673      */
 674     @ForceInline
<a name="5" id="anc5"></a><span class="line-added"> 675     @SuppressWarnings(&quot;preview&quot;)</span>
 676     public long staticFieldOffset(Field f) {
 677         if (f == null) {
 678             throw new NullPointerException();
 679         }
<a name="6" id="anc6"></a><span class="line-modified"> 680         Class&lt;?&gt; declaringClass = f.getDeclaringClass();</span>
<span class="line-added"> 681         if (declaringClass.isHidden()) {</span>
 682             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on a hidden class: &quot; + f);
 683         }
 684         if (f.getDeclaringClass().isInlineClass()) {
 685             throw new UnsupportedOperationException(&quot;can&#39;t get static field offset on an inline class: &quot; + f);
 686         }
<a name="7" id="anc7"></a><span class="line-added"> 687         if (declaringClass.isRecord()) {</span>
<span class="line-added"> 688             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on a record (preview): &quot; + f);</span>
<span class="line-added"> 689         }</span>
 690         return theInternalUnsafe.staticFieldOffset(f);
 691     }
 692 
 693     /**
 694      * Reports the location of a given static field, in conjunction with {@link
 695      * #staticFieldOffset}.
 696      * &lt;p&gt;Fetch the base &quot;Object&quot;, if any, with which static fields of the
 697      * given class can be accessed via methods like {@link #getInt(Object,
 698      * long)}.  This value may be null.  This value may refer to an object
 699      * which is a &quot;cookie&quot;, not guaranteed to be a real Object, and it should
 700      * not be used in any way except as argument to the get and put routines in
 701      * this class.
 702      */
 703     @ForceInline
<a name="8" id="anc8"></a><span class="line-added"> 704     @SuppressWarnings(&quot;preview&quot;)</span>
 705     public Object staticFieldBase(Field f) {
 706         if (f == null) {
 707             throw new NullPointerException();
 708         }
<a name="9" id="anc9"></a><span class="line-modified"> 709         Class&lt;?&gt; declaringClass = f.getDeclaringClass();</span>
<span class="line-added"> 710         if (declaringClass.isHidden()) {</span>
 711             throw new UnsupportedOperationException(&quot;can&#39;t get base address on a hidden class: &quot; + f);
 712         }
 713         if (f.getDeclaringClass().isInlineClass()) {
 714             throw new UnsupportedOperationException(&quot;can&#39;t get base address on an inline class: &quot; + f);
 715         }
<a name="10" id="anc10"></a><span class="line-added"> 716         if (declaringClass.isRecord()) {</span>
<span class="line-added"> 717             throw new UnsupportedOperationException(&quot;can&#39;t get base address on a record (preview): &quot; + f);</span>
<span class="line-added"> 718         }</span>
 719         return theInternalUnsafe.staticFieldBase(f);
 720     }
 721 
 722     /**
 723      * Detects if the given class may need to be initialized. This is often
 724      * needed in conjunction with obtaining the static field base of a
 725      * class.
 726      *
 727      * @deprecated No replacement API for this method.  As multiple threads
 728      * may be trying to initialize the same class or interface at the same time.
 729      * The only reliable result returned by this method is {@code false}
 730      * indicating that the given class has been initialized.  Instead, simply
 731      * call {@link java.lang.invoke.MethodHandles.Lookup#ensureInitialized(Class)}
 732      * that does nothing if the given class has already been initialized.
 733      * This method is subject to removal in a future version of JDK.
 734      *
 735      * @return false only if a call to {@code ensureClassInitialized} would have no effect
 736      *
 737      */
 738     @Deprecated(since = &quot;15&quot;, forRemoval = true)
 739     @ForceInline
 740     public boolean shouldBeInitialized(Class&lt;?&gt; c) {
 741         return theInternalUnsafe.shouldBeInitialized(c);
 742     }
 743 
 744     /**
 745      * Ensures the given class has been initialized. This is often
 746      * needed in conjunction with obtaining the static field base of a
 747      * class.
 748      *
 749      * @deprecated Use the {@link java.lang.invoke.MethodHandles.Lookup#ensureInitialized(Class)}
 750      * method instead.  This method is subject to removal in a future version of JDK.
 751      */
 752     @Deprecated(since = &quot;15&quot;, forRemoval = true)
 753     @ForceInline
 754     public void ensureClassInitialized(Class&lt;?&gt; c) {
 755         theInternalUnsafe.ensureClassInitialized(c);
 756     }
 757 
 758     /**
 759      * Reports the offset of the first element in the storage allocation of a
 760      * given array class.  If {@link #arrayIndexScale} returns a non-zero value
 761      * for the same class, you may use that scale factor, together with this
 762      * base offset, to form new offsets to access elements of arrays of the
 763      * given class.
 764      *
 765      * @see #getInt(Object, long)
 766      * @see #putInt(Object, long, int)
 767      */
 768     @ForceInline
 769     public int arrayBaseOffset(Class&lt;?&gt; arrayClass) {
 770         return theInternalUnsafe.arrayBaseOffset(arrayClass);
 771     }
 772 
 773     /** The value of {@code arrayBaseOffset(boolean[].class)} */
 774     public static final int ARRAY_BOOLEAN_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;
 775 
 776     /** The value of {@code arrayBaseOffset(byte[].class)} */
 777     public static final int ARRAY_BYTE_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;
 778 
 779     /** The value of {@code arrayBaseOffset(short[].class)} */
 780     public static final int ARRAY_SHORT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_SHORT_BASE_OFFSET;
 781 
 782     /** The value of {@code arrayBaseOffset(char[].class)} */
 783     public static final int ARRAY_CHAR_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_CHAR_BASE_OFFSET;
 784 
 785     /** The value of {@code arrayBaseOffset(int[].class)} */
 786     public static final int ARRAY_INT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_INT_BASE_OFFSET;
 787 
 788     /** The value of {@code arrayBaseOffset(long[].class)} */
 789     public static final int ARRAY_LONG_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_LONG_BASE_OFFSET;
 790 
 791     /** The value of {@code arrayBaseOffset(float[].class)} */
 792     public static final int ARRAY_FLOAT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_FLOAT_BASE_OFFSET;
 793 
 794     /** The value of {@code arrayBaseOffset(double[].class)} */
 795     public static final int ARRAY_DOUBLE_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_DOUBLE_BASE_OFFSET;
 796 
 797     /** The value of {@code arrayBaseOffset(Object[].class)} */
 798     public static final int ARRAY_OBJECT_BASE_OFFSET = jdk.internal.misc.Unsafe.ARRAY_OBJECT_BASE_OFFSET;
 799 
 800     /**
 801      * Reports the scale factor for addressing elements in the storage
 802      * allocation of a given array class.  However, arrays of &quot;narrow&quot; types
 803      * will generally not work properly with accessors like {@link
 804      * #getByte(Object, long)}, so the scale factor for such classes is reported
 805      * as zero.
 806      *
 807      * @see #arrayBaseOffset
 808      * @see #getInt(Object, long)
 809      * @see #putInt(Object, long, int)
 810      */
 811     @ForceInline
 812     public int arrayIndexScale(Class&lt;?&gt; arrayClass) {
 813         return theInternalUnsafe.arrayIndexScale(arrayClass);
 814     }
 815 
 816     /** The value of {@code arrayIndexScale(boolean[].class)} */
 817     public static final int ARRAY_BOOLEAN_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_BOOLEAN_INDEX_SCALE;
 818 
 819     /** The value of {@code arrayIndexScale(byte[].class)} */
 820     public static final int ARRAY_BYTE_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_BYTE_INDEX_SCALE;
 821 
 822     /** The value of {@code arrayIndexScale(short[].class)} */
 823     public static final int ARRAY_SHORT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_SHORT_INDEX_SCALE;
 824 
 825     /** The value of {@code arrayIndexScale(char[].class)} */
 826     public static final int ARRAY_CHAR_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_CHAR_INDEX_SCALE;
 827 
 828     /** The value of {@code arrayIndexScale(int[].class)} */
 829     public static final int ARRAY_INT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_INT_INDEX_SCALE;
 830 
 831     /** The value of {@code arrayIndexScale(long[].class)} */
 832     public static final int ARRAY_LONG_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_LONG_INDEX_SCALE;
 833 
 834     /** The value of {@code arrayIndexScale(float[].class)} */
 835     public static final int ARRAY_FLOAT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_FLOAT_INDEX_SCALE;
 836 
 837     /** The value of {@code arrayIndexScale(double[].class)} */
 838     public static final int ARRAY_DOUBLE_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_DOUBLE_INDEX_SCALE;
 839 
 840     /** The value of {@code arrayIndexScale(Object[].class)} */
 841     public static final int ARRAY_OBJECT_INDEX_SCALE = jdk.internal.misc.Unsafe.ARRAY_OBJECT_INDEX_SCALE;
 842 
 843     /**
 844      * Reports the size in bytes of a native pointer, as stored via {@link
 845      * #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
 846      * other primitive types (as stored in native memory blocks) is determined
 847      * fully by their information content.
 848      */
 849     @ForceInline
 850     public int addressSize() {
 851         return theInternalUnsafe.addressSize();
 852     }
 853 
 854     /** The value of {@code addressSize()} */
 855     public static final int ADDRESS_SIZE = theInternalUnsafe.addressSize();
 856 
 857     /**
 858      * Reports the size in bytes of a native memory page (whatever that is).
 859      * This value will always be a power of two.
 860      */
 861     @ForceInline
 862     public int pageSize() {
 863         return theInternalUnsafe.pageSize();
 864     }
 865 
 866 
 867     /// random trusted operations from JNI:
 868 
 869     /**
 870      * Defines a class but does not make it known to the class loader or system dictionary.
 871      * &lt;p&gt;
 872      * For each CP entry, the corresponding CP patch must either be null or have
 873      * the a format that matches its tag:
 874      * &lt;ul&gt;
 875      * &lt;li&gt;Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
 876      * &lt;li&gt;Utf8: a string (must have suitable syntax if used as signature or name)
 877      * &lt;li&gt;Class: any java.lang.Class object
 878      * &lt;li&gt;String: any object (not just a java.lang.String)
 879      * &lt;li&gt;InterfaceMethodRef: (NYI) a method handle to invoke on that call site&#39;s arguments
 880      * &lt;/ul&gt;
 881      *
 882      * @deprecated Use the {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)}
 883      * method.
 884      *
 885      * @param hostClass context for linkage, access control, protection domain, and class loader
 886      * @param data      bytes of a class file
 887      * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data
 888      */
 889     @ForceInline
 890     @Deprecated(since = &quot;15&quot;, forRemoval = false)
 891     public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches) {
 892         return theInternalUnsafe.defineAnonymousClass(hostClass, data, cpPatches);
 893     }
 894 
 895     /**
 896      * Allocates an instance but does not run any constructor.
 897      * Initializes the class if it has not yet been.
 898      */
 899     @ForceInline
 900     public Object allocateInstance(Class&lt;?&gt; cls)
 901         throws InstantiationException {
 902         return theInternalUnsafe.allocateInstance(cls);
 903     }
 904 
 905     /** Throws the exception without telling the verifier. */
 906     @ForceInline
 907     public void throwException(Throwable ee) {
 908         theInternalUnsafe.throwException(ee);
 909     }
 910 
 911     /**
 912      * Atomically updates Java variable to {@code x} if it is currently
 913      * holding {@code expected}.
 914      *
 915      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
 916      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
 917      *
 918      * @return {@code true} if successful
 919      */
 920     @ForceInline
 921     public final boolean compareAndSwapObject(Object o, long offset,
 922                                               Object expected,
 923                                               Object x) {
 924         return theInternalUnsafe.compareAndSetReference(o, offset, expected, x);
 925     }
 926 
 927     /**
 928      * Atomically updates Java variable to {@code x} if it is currently
 929      * holding {@code expected}.
 930      *
 931      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
 932      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
 933      *
 934      * @return {@code true} if successful
 935      */
 936     @ForceInline
 937     public final boolean compareAndSwapInt(Object o, long offset,
 938                                            int expected,
 939                                            int x) {
 940         return theInternalUnsafe.compareAndSetInt(o, offset, expected, x);
 941     }
 942 
 943     /**
 944      * Atomically updates Java variable to {@code x} if it is currently
 945      * holding {@code expected}.
 946      *
 947      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
 948      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
 949      *
 950      * @return {@code true} if successful
 951      */
 952     @ForceInline
 953     public final boolean compareAndSwapLong(Object o, long offset,
 954                                             long expected,
 955                                             long x) {
 956         return theInternalUnsafe.compareAndSetLong(o, offset, expected, x);
 957     }
 958 
 959     /**
 960      * Fetches a reference value from a given Java variable, with volatile
 961      * load semantics. Otherwise identical to {@link #getObject(Object, long)}
 962      */
 963     @ForceInline
 964     public Object getObjectVolatile(Object o, long offset) {
 965         return theInternalUnsafe.getReferenceVolatile(o, offset);
 966     }
 967 
 968     /**
 969      * Stores a reference value into a given Java variable, with
 970      * volatile store semantics. Otherwise identical to {@link #putObject(Object, long, Object)}
 971      */
 972     @ForceInline
 973     public void putObjectVolatile(Object o, long offset, Object x) {
 974         theInternalUnsafe.putReferenceVolatile(o, offset, x);
 975     }
 976 
 977     /** Volatile version of {@link #getInt(Object, long)}  */
 978     @ForceInline
 979     public int getIntVolatile(Object o, long offset) {
 980         return theInternalUnsafe.getIntVolatile(o, offset);
 981     }
 982 
 983     /** Volatile version of {@link #putInt(Object, long, int)}  */
 984     @ForceInline
 985     public void putIntVolatile(Object o, long offset, int x) {
 986         theInternalUnsafe.putIntVolatile(o, offset, x);
 987     }
 988 
 989     /** Volatile version of {@link #getBoolean(Object, long)}  */
 990     @ForceInline
 991     public boolean getBooleanVolatile(Object o, long offset) {
 992         return theInternalUnsafe.getBooleanVolatile(o, offset);
 993     }
 994 
 995     /** Volatile version of {@link #putBoolean(Object, long, boolean)}  */
 996     @ForceInline
 997     public void putBooleanVolatile(Object o, long offset, boolean x) {
 998         theInternalUnsafe.putBooleanVolatile(o, offset, x);
 999     }
1000 
1001     /** Volatile version of {@link #getByte(Object, long)}  */
1002     @ForceInline
1003     public byte getByteVolatile(Object o, long offset) {
1004         return theInternalUnsafe.getByteVolatile(o, offset);
1005     }
1006 
1007     /** Volatile version of {@link #putByte(Object, long, byte)}  */
1008     @ForceInline
1009     public void putByteVolatile(Object o, long offset, byte x) {
1010         theInternalUnsafe.putByteVolatile(o, offset, x);
1011     }
1012 
1013     /** Volatile version of {@link #getShort(Object, long)}  */
1014     @ForceInline
1015     public short getShortVolatile(Object o, long offset) {
1016         return theInternalUnsafe.getShortVolatile(o, offset);
1017     }
1018 
1019     /** Volatile version of {@link #putShort(Object, long, short)}  */
1020     @ForceInline
1021     public void putShortVolatile(Object o, long offset, short x) {
1022         theInternalUnsafe.putShortVolatile(o, offset, x);
1023     }
1024 
1025     /** Volatile version of {@link #getChar(Object, long)}  */
1026     @ForceInline
1027     public char getCharVolatile(Object o, long offset) {
1028         return theInternalUnsafe.getCharVolatile(o, offset);
1029     }
1030 
1031     /** Volatile version of {@link #putChar(Object, long, char)}  */
1032     @ForceInline
1033     public void putCharVolatile(Object o, long offset, char x) {
1034         theInternalUnsafe.putCharVolatile(o, offset, x);
1035     }
1036 
1037     /** Volatile version of {@link #getLong(Object, long)}  */
1038     @ForceInline
1039     public long getLongVolatile(Object o, long offset) {
1040         return theInternalUnsafe.getLongVolatile(o, offset);
1041     }
1042 
1043     /** Volatile version of {@link #putLong(Object, long, long)}  */
1044     @ForceInline
1045     public void putLongVolatile(Object o, long offset, long x) {
1046         theInternalUnsafe.putLongVolatile(o, offset, x);
1047     }
1048 
1049     /** Volatile version of {@link #getFloat(Object, long)}  */
1050     @ForceInline
1051     public float getFloatVolatile(Object o, long offset) {
1052         return theInternalUnsafe.getFloatVolatile(o, offset);
1053     }
1054 
1055     /** Volatile version of {@link #putFloat(Object, long, float)}  */
1056     @ForceInline
1057     public void putFloatVolatile(Object o, long offset, float x) {
1058         theInternalUnsafe.putFloatVolatile(o, offset, x);
1059     }
1060 
1061     /** Volatile version of {@link #getDouble(Object, long)}  */
1062     @ForceInline
1063     public double getDoubleVolatile(Object o, long offset) {
1064         return theInternalUnsafe.getDoubleVolatile(o, offset);
1065     }
1066 
1067     /** Volatile version of {@link #putDouble(Object, long, double)}  */
1068     @ForceInline
1069     public void putDoubleVolatile(Object o, long offset, double x) {
1070         theInternalUnsafe.putDoubleVolatile(o, offset, x);
1071     }
1072 
1073     /**
1074      * Version of {@link #putObjectVolatile(Object, long, Object)}
1075      * that does not guarantee immediate visibility of the store to
1076      * other threads. This method is generally only useful if the
1077      * underlying field is a Java volatile (or if an array cell, one
1078      * that is otherwise only accessed using volatile accesses).
1079      *
1080      * Corresponds to C11 atomic_store_explicit(..., memory_order_release).
1081      */
1082     @ForceInline
1083     public void putOrderedObject(Object o, long offset, Object x) {
1084         theInternalUnsafe.putReferenceRelease(o, offset, x);
1085     }
1086 
1087     /** Ordered/Lazy version of {@link #putIntVolatile(Object, long, int)}  */
1088     @ForceInline
1089     public void putOrderedInt(Object o, long offset, int x) {
1090         theInternalUnsafe.putIntRelease(o, offset, x);
1091     }
1092 
1093     /** Ordered/Lazy version of {@link #putLongVolatile(Object, long, long)} */
1094     @ForceInline
1095     public void putOrderedLong(Object o, long offset, long x) {
1096         theInternalUnsafe.putLongRelease(o, offset, x);
1097     }
1098 
1099     /**
1100      * Unblocks the given thread blocked on {@code park}, or, if it is
1101      * not blocked, causes the subsequent call to {@code park} not to
1102      * block.  Note: this operation is &quot;unsafe&quot; solely because the
1103      * caller must somehow ensure that the thread has not been
1104      * destroyed. Nothing special is usually required to ensure this
1105      * when called from Java (in which there will ordinarily be a live
1106      * reference to the thread) but this is not nearly-automatically
1107      * so when calling from native code.
1108      *
1109      * @param thread the thread to unpark.
1110      */
1111     @ForceInline
1112     public void unpark(Object thread) {
1113         theInternalUnsafe.unpark(thread);
1114     }
1115 
1116     /**
1117      * Blocks current thread, returning when a balancing
1118      * {@code unpark} occurs, or a balancing {@code unpark} has
1119      * already occurred, or the thread is interrupted, or, if not
1120      * absolute and time is not zero, the given time nanoseconds have
1121      * elapsed, or if absolute, the given deadline in milliseconds
1122      * since Epoch has passed, or spuriously (i.e., returning for no
1123      * &quot;reason&quot;). Note: This operation is in the Unsafe class only
1124      * because {@code unpark} is, so it would be strange to place it
1125      * elsewhere.
1126      */
1127     @ForceInline
1128     public void park(boolean isAbsolute, long time) {
1129         theInternalUnsafe.park(isAbsolute, time);
1130     }
1131 
1132     /**
1133      * Gets the load average in the system run queue assigned
1134      * to the available processors averaged over various periods of time.
1135      * This method retrieves the given {@code nelem} samples and
1136      * assigns to the elements of the given {@code loadavg} array.
1137      * The system imposes a maximum of 3 samples, representing
1138      * averages over the last 1,  5,  and  15 minutes, respectively.
1139      *
1140      * @param loadavg an array of double of size nelems
1141      * @param nelems the number of samples to be retrieved and
1142      *        must be 1 to 3.
1143      *
1144      * @return the number of samples actually retrieved; or -1
1145      *         if the load average is unobtainable.
1146      */
1147     @ForceInline
1148     public int getLoadAverage(double[] loadavg, int nelems) {
1149         return theInternalUnsafe.getLoadAverage(loadavg, nelems);
1150     }
1151 
1152     // The following contain CAS-based Java implementations used on
1153     // platforms not supporting native instructions
1154 
1155     /**
1156      * Atomically adds the given value to the current value of a field
1157      * or array element within the given object {@code o}
1158      * at the given {@code offset}.
1159      *
1160      * @param o object/array to update the field/element in
1161      * @param offset field/element offset
1162      * @param delta the value to add
1163      * @return the previous value
1164      * @since 1.8
1165      */
1166     @ForceInline
1167     public final int getAndAddInt(Object o, long offset, int delta) {
1168         return theInternalUnsafe.getAndAddInt(o, offset, delta);
1169     }
1170 
1171     /**
1172      * Atomically adds the given value to the current value of a field
1173      * or array element within the given object {@code o}
1174      * at the given {@code offset}.
1175      *
1176      * @param o object/array to update the field/element in
1177      * @param offset field/element offset
1178      * @param delta the value to add
1179      * @return the previous value
1180      * @since 1.8
1181      */
1182     @ForceInline
1183     public final long getAndAddLong(Object o, long offset, long delta) {
1184         return theInternalUnsafe.getAndAddLong(o, offset, delta);
1185     }
1186 
1187     /**
1188      * Atomically exchanges the given value with the current value of
1189      * a field or array element within the given object {@code o}
1190      * at the given {@code offset}.
1191      *
1192      * @param o object/array to update the field/element in
1193      * @param offset field/element offset
1194      * @param newValue new value
1195      * @return the previous value
1196      * @since 1.8
1197      */
1198     @ForceInline
1199     public final int getAndSetInt(Object o, long offset, int newValue) {
1200         return theInternalUnsafe.getAndSetInt(o, offset, newValue);
1201     }
1202 
1203     /**
1204      * Atomically exchanges the given value with the current value of
1205      * a field or array element within the given object {@code o}
1206      * at the given {@code offset}.
1207      *
1208      * @param o object/array to update the field/element in
1209      * @param offset field/element offset
1210      * @param newValue new value
1211      * @return the previous value
1212      * @since 1.8
1213      */
1214     @ForceInline
1215     public final long getAndSetLong(Object o, long offset, long newValue) {
1216         return theInternalUnsafe.getAndSetLong(o, offset, newValue);
1217     }
1218 
1219     /**
1220      * Atomically exchanges the given reference value with the current
1221      * reference value of a field or array element within the given
1222      * object {@code o} at the given {@code offset}.
1223      *
1224      * @param o object/array to update the field/element in
1225      * @param offset field/element offset
1226      * @param newValue new value
1227      * @return the previous value
1228      * @since 1.8
1229      */
1230     @ForceInline
1231     public final Object getAndSetObject(Object o, long offset, Object newValue) {
1232         return theInternalUnsafe.getAndSetReference(o, offset, newValue);
1233     }
1234 
1235 
1236     /**
1237      * Ensures that loads before the fence will not be reordered with loads and
1238      * stores after the fence; a &quot;LoadLoad plus LoadStore barrier&quot;.
1239      *
1240      * Corresponds to C11 atomic_thread_fence(memory_order_acquire)
1241      * (an &quot;acquire fence&quot;).
1242      *
1243      * A pure LoadLoad fence is not provided, since the addition of LoadStore
1244      * is almost always desired, and most current hardware instructions that
1245      * provide a LoadLoad barrier also provide a LoadStore barrier for free.
1246      * @since 1.8
1247      */
1248     @ForceInline
1249     public void loadFence() {
1250         theInternalUnsafe.loadFence();
1251     }
1252 
1253     /**
1254      * Ensures that loads and stores before the fence will not be reordered with
1255      * stores after the fence; a &quot;StoreStore plus LoadStore barrier&quot;.
1256      *
1257      * Corresponds to C11 atomic_thread_fence(memory_order_release)
1258      * (a &quot;release fence&quot;).
1259      *
1260      * A pure StoreStore fence is not provided, since the addition of LoadStore
1261      * is almost always desired, and most current hardware instructions that
1262      * provide a StoreStore barrier also provide a LoadStore barrier for free.
1263      * @since 1.8
1264      */
1265     @ForceInline
1266     public void storeFence() {
1267         theInternalUnsafe.storeFence();
1268     }
1269 
1270     /**
1271      * Ensures that loads and stores before the fence will not be reordered
1272      * with loads and stores after the fence.  Implies the effects of both
1273      * loadFence() and storeFence(), and in addition, the effect of a StoreLoad
1274      * barrier.
1275      *
1276      * Corresponds to C11 atomic_thread_fence(memory_order_seq_cst).
1277      * @since 1.8
1278      */
1279     @ForceInline
1280     public void fullFence() {
1281         theInternalUnsafe.fullFence();
1282     }
1283 
1284     /**
1285      * Invokes the given direct byte buffer&#39;s cleaner, if any.
1286      *
1287      * @param directBuffer a direct byte buffer
1288      * @throws NullPointerException if {@code directBuffer} is null
1289      * @throws IllegalArgumentException if {@code directBuffer} is non-direct,
1290      * or is a {@link java.nio.Buffer#slice slice}, or is a
1291      * {@link java.nio.Buffer#duplicate duplicate}
1292      * @since 9
1293      */
1294     public void invokeCleaner(java.nio.ByteBuffer directBuffer) {
1295         if (!directBuffer.isDirect())
1296             throw new IllegalArgumentException(&quot;buffer is non-direct&quot;);
1297 
1298         theInternalUnsafe.invokeCleaner(directBuffer);
1299     }
1300 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>