<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/reflection.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/verifier.hpp&quot;
  33 #include &quot;classfile/vmSymbols.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/oopFactory.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/inlineKlass.inline.hpp&quot;
  40 #include &quot;oops/instanceKlass.hpp&quot;
  41 #include &quot;oops/objArrayKlass.hpp&quot;
  42 #include &quot;oops/objArrayOop.inline.hpp&quot;
  43 #include &quot;oops/oop.inline.hpp&quot;
  44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  45 #include &quot;prims/jvmtiExport.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
  49 #include &quot;runtime/javaCalls.hpp&quot;
  50 #include &quot;runtime/reflection.hpp&quot;
  51 #include &quot;runtime/reflectionUtils.hpp&quot;
  52 #include &quot;runtime/signature.hpp&quot;
  53 #include &quot;runtime/thread.inline.hpp&quot;
  54 #include &quot;runtime/vframe.inline.hpp&quot;
  55 #include &quot;utilities/globalDefinitions.hpp&quot;
  56 
  57 static void trace_class_resolution(oop mirror) {
  58   if (mirror == NULL || java_lang_Class::is_primitive(mirror)) {
  59     return;
  60   }
  61   Klass* to_class = java_lang_Class::as_Klass(mirror);
  62   ResourceMark rm;
  63   int line_number = -1;
  64   const char * source_file = NULL;
  65   Klass* caller = NULL;
  66   JavaThread* jthread = JavaThread::current();
  67   if (jthread-&gt;has_last_Java_frame()) {
  68     vframeStream vfst(jthread);
  69     // skip over any frames belonging to java.lang.Class
  70     while (!vfst.at_end() &amp;&amp;
  71            vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class()) {
  72       vfst.next();
  73     }
  74     if (!vfst.at_end()) {
  75       // this frame is a likely suspect
  76       caller = vfst.method()-&gt;method_holder();
  77       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
  78       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
  79       if (s != NULL) {
  80         source_file = s-&gt;as_C_string();
  81       }
  82     }
  83   }
  84   if (caller != NULL) {
  85     const char * from = caller-&gt;external_name();
  86     const char * to = to_class-&gt;external_name();
  87     // print in a single call to reduce interleaving between threads
  88     if (source_file != NULL) {
  89       log_debug(class, resolve)(&quot;%s %s %s:%d (reflection)&quot;, from, to, source_file, line_number);
  90     } else {
  91       log_debug(class, resolve)(&quot;%s %s (reflection)&quot;, from, to);
  92     }
  93   }
  94 }
  95 
  96 
  97 oop Reflection::box(jvalue* value, BasicType type, TRAPS) {
  98   if (type == T_VOID) {
  99     return NULL;
 100   }
 101   if (is_reference_type(type)) {
 102     // regular objects are not boxed
 103     return (oop) value-&gt;l;
 104   }
 105   oop result = java_lang_boxing_object::create(type, value, CHECK_NULL);
 106   if (result == NULL) {
 107     THROW_(vmSymbols::java_lang_IllegalArgumentException(), result);
 108   }
 109   return result;
 110 }
 111 
 112 
 113 BasicType Reflection::unbox_for_primitive(oop box, jvalue* value, TRAPS) {
 114   if (box == NULL) {
 115     THROW_(vmSymbols::java_lang_IllegalArgumentException(), T_ILLEGAL);
 116   }
 117   return java_lang_boxing_object::get_value(box, value);
 118 }
 119 
 120 BasicType Reflection::unbox_for_regular_object(oop box, jvalue* value) {
 121   // Note:  box is really the unboxed oop.  It might even be a Short, etc.!
 122   value-&gt;l = cast_from_oop&lt;jobject&gt;(box);
 123   return T_OBJECT;
 124 }
 125 
 126 
 127 void Reflection::widen(jvalue* value, BasicType current_type, BasicType wide_type, TRAPS) {
 128   assert(wide_type != current_type, &quot;widen should not be called with identical types&quot;);
 129   switch (wide_type) {
 130     case T_BOOLEAN:
 131     case T_BYTE:
 132     case T_CHAR:
 133       break;  // fail
 134     case T_SHORT:
 135       switch (current_type) {
 136         case T_BYTE:
 137           value-&gt;s = (jshort) value-&gt;b;
 138           return;
 139         default:
 140           break;
 141       }
 142       break;  // fail
 143     case T_INT:
 144       switch (current_type) {
 145         case T_BYTE:
 146           value-&gt;i = (jint) value-&gt;b;
 147           return;
 148         case T_CHAR:
 149           value-&gt;i = (jint) value-&gt;c;
 150           return;
 151         case T_SHORT:
 152           value-&gt;i = (jint) value-&gt;s;
 153           return;
 154         default:
 155           break;
 156       }
 157       break;  // fail
 158     case T_LONG:
 159       switch (current_type) {
 160         case T_BYTE:
 161           value-&gt;j = (jlong) value-&gt;b;
 162           return;
 163         case T_CHAR:
 164           value-&gt;j = (jlong) value-&gt;c;
 165           return;
 166         case T_SHORT:
 167           value-&gt;j = (jlong) value-&gt;s;
 168           return;
 169         case T_INT:
 170           value-&gt;j = (jlong) value-&gt;i;
 171           return;
 172         default:
 173           break;
 174       }
 175       break;  // fail
 176     case T_FLOAT:
 177       switch (current_type) {
 178         case T_BYTE:
 179           value-&gt;f = (jfloat) value-&gt;b;
 180           return;
 181         case T_CHAR:
 182           value-&gt;f = (jfloat) value-&gt;c;
 183           return;
 184         case T_SHORT:
 185           value-&gt;f = (jfloat) value-&gt;s;
 186           return;
 187         case T_INT:
 188           value-&gt;f = (jfloat) value-&gt;i;
 189           return;
 190         case T_LONG:
 191           value-&gt;f = (jfloat) value-&gt;j;
 192           return;
 193         default:
 194           break;
 195       }
 196       break;  // fail
 197     case T_DOUBLE:
 198       switch (current_type) {
 199         case T_BYTE:
 200           value-&gt;d = (jdouble) value-&gt;b;
 201           return;
 202         case T_CHAR:
 203           value-&gt;d = (jdouble) value-&gt;c;
 204           return;
 205         case T_SHORT:
 206           value-&gt;d = (jdouble) value-&gt;s;
 207           return;
 208         case T_INT:
 209           value-&gt;d = (jdouble) value-&gt;i;
 210           return;
 211         case T_FLOAT:
 212           value-&gt;d = (jdouble) value-&gt;f;
 213           return;
 214         case T_LONG:
 215           value-&gt;d = (jdouble) value-&gt;j;
 216           return;
 217         default:
 218           break;
 219       }
 220       break;  // fail
 221     default:
 222       break;  // fail
 223   }
 224   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
 225 }
 226 
 227 
 228 BasicType Reflection::array_get(jvalue* value, arrayOop a, int index, TRAPS) {
 229   if (!a-&gt;is_within_bounds(index)) {
 230     THROW_(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), T_ILLEGAL);
 231   }
 232   if (a-&gt;is_objArray()) {
 233     value-&gt;l = cast_from_oop&lt;jobject&gt;(objArrayOop(a)-&gt;obj_at(index));
 234     return T_OBJECT;
 235   } else {
 236     assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
 237     BasicType type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 238     switch (type) {
 239       case T_BOOLEAN:
 240         value-&gt;z = typeArrayOop(a)-&gt;bool_at(index);
 241         break;
 242       case T_CHAR:
 243         value-&gt;c = typeArrayOop(a)-&gt;char_at(index);
 244         break;
 245       case T_FLOAT:
 246         value-&gt;f = typeArrayOop(a)-&gt;float_at(index);
 247         break;
 248       case T_DOUBLE:
 249         value-&gt;d = typeArrayOop(a)-&gt;double_at(index);
 250         break;
 251       case T_BYTE:
 252         value-&gt;b = typeArrayOop(a)-&gt;byte_at(index);
 253         break;
 254       case T_SHORT:
 255         value-&gt;s = typeArrayOop(a)-&gt;short_at(index);
 256         break;
 257       case T_INT:
 258         value-&gt;i = typeArrayOop(a)-&gt;int_at(index);
 259         break;
 260       case T_LONG:
 261         value-&gt;j = typeArrayOop(a)-&gt;long_at(index);
 262         break;
 263       default:
 264         return T_ILLEGAL;
 265     }
 266     return type;
 267   }
 268 }
 269 
 270 
 271 void Reflection::array_set(jvalue* value, arrayOop a, int index, BasicType value_type, TRAPS) {
 272   if (!a-&gt;is_within_bounds(index)) {
 273     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
 274   }
 275   if (a-&gt;is_objArray()) {
 276     if (value_type == T_OBJECT) {
 277       oop obj = (oop) value-&gt;l;
 278       if (obj != NULL) {
 279         Klass* element_klass = ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass();
 280         if (!obj-&gt;is_a(element_klass)) {
 281           THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;array element type mismatch&quot;);
 282         }
 283       }
 284       objArrayOop(a)-&gt;obj_at_put(index, obj);
 285     }
 286   } else {
 287     assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
 288     BasicType array_type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 289     if (array_type != value_type) {
 290       // The widen operation can potentially throw an exception, but cannot block,
 291       // so typeArrayOop a is safe if the call succeeds.
 292       widen(value, value_type, array_type, CHECK);
 293     }
 294     switch (array_type) {
 295       case T_BOOLEAN:
 296         typeArrayOop(a)-&gt;bool_at_put(index, value-&gt;z);
 297         break;
 298       case T_CHAR:
 299         typeArrayOop(a)-&gt;char_at_put(index, value-&gt;c);
 300         break;
 301       case T_FLOAT:
 302         typeArrayOop(a)-&gt;float_at_put(index, value-&gt;f);
 303         break;
 304       case T_DOUBLE:
 305         typeArrayOop(a)-&gt;double_at_put(index, value-&gt;d);
 306         break;
 307       case T_BYTE:
 308         typeArrayOop(a)-&gt;byte_at_put(index, value-&gt;b);
 309         break;
 310       case T_SHORT:
 311         typeArrayOop(a)-&gt;short_at_put(index, value-&gt;s);
 312         break;
 313       case T_INT:
 314         typeArrayOop(a)-&gt;int_at_put(index, value-&gt;i);
 315         break;
 316       case T_LONG:
 317         typeArrayOop(a)-&gt;long_at_put(index, value-&gt;j);
 318         break;
 319       default:
 320         THROW(vmSymbols::java_lang_IllegalArgumentException());
 321     }
 322   }
 323 }
 324 
 325 static Klass* basic_type_mirror_to_arrayklass(oop basic_type_mirror, TRAPS) {
 326   assert(java_lang_Class::is_primitive(basic_type_mirror), &quot;just checking&quot;);
 327   BasicType type = java_lang_Class::primitive_type(basic_type_mirror);
 328   if (type == T_VOID) {
 329     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 330   }
 331   else {
 332     return Universe::typeArrayKlassObj(type);
 333   }
 334 }
 335 
 336 arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
 337   if (element_mirror == NULL) {
 338     THROW_0(vmSymbols::java_lang_NullPointerException());
 339   }
 340   if (length &lt; 0) {
 341     THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
 342   }
 343   if (java_lang_Class::is_primitive(element_mirror)) {
 344     Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 345     return TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);
 346   } else {
 347     Klass* k = java_lang_Class::as_Klass(element_mirror);
 348     if (k-&gt;is_array_klass() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) {
 349       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 350     }
 351     if (k-&gt;is_inline_klass()) {
 352       return oopFactory::new_flatArray(k, length, THREAD);
 353     } else {
 354       return oopFactory::new_objArray(k, length, THREAD);
 355     }
 356   }
 357 }
 358 
 359 
 360 arrayOop Reflection::reflect_new_multi_array(oop element_mirror, typeArrayOop dim_array, TRAPS) {
 361   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
 362   assert(TypeArrayKlass::cast(dim_array-&gt;klass())-&gt;element_type() == T_INT, &quot;just checking&quot;);
 363 
 364   if (element_mirror == NULL) {
 365     THROW_0(vmSymbols::java_lang_NullPointerException());
 366   }
 367 
 368   int len = dim_array-&gt;length();
 369   if (len &lt;= 0 || len &gt; MAX_DIM) {
 370     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 371   }
 372 
 373   jint dimensions[MAX_DIM];   // C array copy of intArrayOop
 374   for (int i = 0; i &lt; len; i++) {
 375     int d = dim_array-&gt;int_at(i);
 376     if (d &lt; 0) {
 377       THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, d));
 378     }
 379     dimensions[i] = d;
 380   }
 381 
 382   Klass* klass;
 383   int dim = len;
 384   if (java_lang_Class::is_primitive(element_mirror)) {
 385     klass = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 386   } else {
 387     klass = java_lang_Class::as_Klass(element_mirror);
 388     if (klass-&gt;is_array_klass()) {
 389       int k_dim = ArrayKlass::cast(klass)-&gt;dimension();
 390       if (k_dim + len &gt; MAX_DIM) {
 391         THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 392       }
 393       dim += k_dim;
 394     }
 395   }
 396   klass = klass-&gt;array_klass(dim, CHECK_NULL);
 397   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(len, dimensions, CHECK_NULL);
 398   assert(obj-&gt;is_array(), &quot;just checking&quot;);
 399   return arrayOop(obj);
 400 }
 401 
 402 
 403 static bool under_unsafe_anonymous_host(const InstanceKlass* ik, const InstanceKlass* unsafe_anonymous_host) {
 404   DEBUG_ONLY(int inf_loop_check = 1000 * 1000 * 1000);
 405   for (;;) {
 406     const InstanceKlass* hc = ik-&gt;unsafe_anonymous_host();
 407     if (hc == NULL)        return false;
 408     if (hc == unsafe_anonymous_host)  return true;
 409     ik = hc;
 410 
 411     // There&#39;s no way to make a host class loop short of patching memory.
 412     // Therefore there cannot be a loop here unless there&#39;s another bug.
 413     // Still, let&#39;s check for it.
 414     assert(--inf_loop_check &gt; 0, &quot;no unsafe_anonymous_host loop&quot;);
 415   }
 416 }
 417 
 418 static bool can_relax_access_check_for(const Klass* accessor,
 419                                        const Klass* accessee,
 420                                        bool classloader_only) {
 421 
 422   const InstanceKlass* accessor_ik = InstanceKlass::cast(accessor);
 423   const InstanceKlass* accessee_ik = InstanceKlass::cast(accessee);
 424 
 425   // If either is on the other&#39;s unsafe_anonymous_host chain, access is OK,
 426   // because one is inside the other.
 427   if (under_unsafe_anonymous_host(accessor_ik, accessee_ik) ||
 428     under_unsafe_anonymous_host(accessee_ik, accessor_ik))
 429     return true;
 430 
 431   if (RelaxAccessControlCheck &amp;&amp;
 432     accessor_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION &amp;&amp;
 433     accessee_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION) {
 434     return classloader_only &amp;&amp;
 435       Verifier::relax_access_for(accessor_ik-&gt;class_loader()) &amp;&amp;
 436       accessor_ik-&gt;protection_domain() == accessee_ik-&gt;protection_domain() &amp;&amp;
 437       accessor_ik-&gt;class_loader() == accessee_ik-&gt;class_loader();
 438   }
 439 
 440   return false;
 441 }
 442 
 443 /*
 444     Type Accessibility check for public types: Callee Type T is accessible to Caller Type S if:
 445 
 446                         Callee T in             Callee T in package PT,
 447                         unnamed module          runtime module MT
 448  ------------------------------------------------------------------------------------------------
 449 
 450  Caller S in package     If MS is loose: YES      If same classloader/package (PS == PT): YES
 451  PS, runtime module MS   If MS can read T&#39;s       If same runtime module: (MS == MT): YES
 452                          unnamed module: YES
 453                                                   Else if (MS can read MT (establish readability) &amp;&amp;
 454                                                     ((MT exports PT to MS or to all modules) ||
 455                                                      (MT is open))): YES
 456 
 457  ------------------------------------------------------------------------------------------------
 458  Caller S in unnamed         YES                  Readability exists because unnamed module
 459  module UM                                            &quot;reads&quot; all modules
 460                                                   if (MT exports PT to UM or to all modules): YES
 461 
 462  ------------------------------------------------------------------------------------------------
 463 
 464  Note: a loose module is a module that can read all current and future unnamed modules.
 465 */
 466 Reflection::VerifyClassAccessResults Reflection::verify_class_access(
 467   const Klass* current_class, const InstanceKlass* new_class, bool classloader_only) {
 468 
 469   // Verify that current_class can access new_class.  If the classloader_only
 470   // flag is set, we automatically allow any accesses in which current_class
 471   // doesn&#39;t have a classloader.
 472   if ((current_class == NULL) ||
 473       (current_class == new_class) ||
 474       is_same_class_package(current_class, new_class)) {
 475     return ACCESS_OK;
 476   }
 477   // Allow all accesses from jdk/internal/reflect/MagicAccessorImpl subclasses to
 478   // succeed trivially.
 479   if (SystemDictionary::reflect_MagicAccessorImpl_klass_is_loaded() &amp;&amp;
 480       current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 481     return ACCESS_OK;
 482   }
 483 
 484   // module boundaries
 485   if (new_class-&gt;is_public()) {
 486     // Ignore modules for DumpSharedSpaces because we do not have any package
 487     // or module information for modules other than java.base.
 488     if (DumpSharedSpaces) {
 489       return ACCESS_OK;
 490     }
 491 
 492     // Find the module entry for current_class, the accessor
 493     ModuleEntry* module_from = current_class-&gt;module();
 494     // Find the module entry for new_class, the accessee
 495     ModuleEntry* module_to = new_class-&gt;module();
 496 
 497     // both in same (possibly unnamed) module
 498     if (module_from == module_to) {
 499       return ACCESS_OK;
 500     }
 501 
 502     // Acceptable access to a type in an unnamed module. Note that since
 503     // unnamed modules can read all unnamed modules, this also handles the
 504     // case where module_from is also unnamed but in a different class loader.
 505     if (!module_to-&gt;is_named() &amp;&amp;
 506         (module_from-&gt;can_read_all_unnamed() || module_from-&gt;can_read(module_to))) {
 507       return ACCESS_OK;
 508     }
 509 
 510     // Establish readability, check if module_from is allowed to read module_to.
 511     if (!module_from-&gt;can_read(module_to)) {
 512       return MODULE_NOT_READABLE;
 513     }
 514 
 515     // Access is allowed if module_to is open, i.e. all its packages are unqualifiedly exported
 516     if (module_to-&gt;is_open()) {
 517       return ACCESS_OK;
 518     }
 519 
 520     PackageEntry* package_to = new_class-&gt;package();
 521     assert(package_to != NULL, &quot;can not obtain new_class&#39; package&quot;);
 522 
 523     {
 524       MutexLocker m1(Module_lock);
 525 
 526       // Once readability is established, if module_to exports T unqualifiedly,
 527       // (to all modules), than whether module_from is in the unnamed module
 528       // or not does not matter, access is allowed.
 529       if (package_to-&gt;is_unqual_exported()) {
 530         return ACCESS_OK;
 531       }
 532 
 533       // Access is allowed if both 1 &amp; 2 hold:
 534       //   1. Readability, module_from can read module_to (established above).
 535       //   2. Either module_to exports T to module_from qualifiedly.
 536       //      or
 537       //      module_to exports T to all unnamed modules and module_from is unnamed.
 538       //      or
 539       //      module_to exports T unqualifiedly to all modules (checked above).
 540       if (!package_to-&gt;is_qexported_to(module_from)) {
 541         return TYPE_NOT_EXPORTED;
 542       }
 543     }
 544     return ACCESS_OK;
 545   }
 546 
 547   if (can_relax_access_check_for(current_class, new_class, classloader_only)) {
 548     return ACCESS_OK;
 549   }
 550   return OTHER_PROBLEM;
 551 }
 552 
 553 // Return an error message specific to the specified Klass*&#39;s and result.
 554 // This function must be called from within a block containing a ResourceMark.
 555 char* Reflection::verify_class_access_msg(const Klass* current_class,
 556                                           const InstanceKlass* new_class,
 557                                           const VerifyClassAccessResults result) {
 558   assert(result != ACCESS_OK, &quot;must be failure result&quot;);
 559   char * msg = NULL;
 560   if (result != OTHER_PROBLEM &amp;&amp; new_class != NULL &amp;&amp; current_class != NULL) {
 561     // Find the module entry for current_class, the accessor
 562     ModuleEntry* module_from = current_class-&gt;module();
 563     const char * module_from_name = module_from-&gt;is_named() ? module_from-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
 564     const char * current_class_name = current_class-&gt;external_name();
 565 
 566     // Find the module entry for new_class, the accessee
 567     ModuleEntry* module_to = NULL;
 568     module_to = new_class-&gt;module();
 569     const char * module_to_name = module_to-&gt;is_named() ? module_to-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
 570     const char * new_class_name = new_class-&gt;external_name();
 571 
 572     if (result == MODULE_NOT_READABLE) {
 573       assert(module_from-&gt;is_named(), &quot;Unnamed modules can read all modules&quot;);
 574       if (module_to-&gt;is_named()) {
 575         size_t len = 100 + strlen(current_class_name) + 2*strlen(module_from_name) +
 576           strlen(new_class_name) + 2*strlen(module_to_name);
 577         msg = NEW_RESOURCE_ARRAY(char, len);
 578         jio_snprintf(msg, len - 1,
 579           &quot;class %s (in module %s) cannot access class %s (in module %s) because module %s does not read module %s&quot;,
 580           current_class_name, module_from_name, new_class_name,
 581           module_to_name, module_from_name, module_to_name);
 582       } else {
 583         oop jlm = module_to-&gt;module();
 584         assert(jlm != NULL, &quot;Null jlm in module_to ModuleEntry&quot;);
 585         intptr_t identity_hash = jlm-&gt;identity_hash();
 586         size_t len = 160 + strlen(current_class_name) + 2*strlen(module_from_name) +
 587           strlen(new_class_name) + 2*sizeof(uintx);
 588         msg = NEW_RESOURCE_ARRAY(char, len);
 589         jio_snprintf(msg, len - 1,
 590           &quot;class %s (in module %s) cannot access class %s (in unnamed module @&quot; SIZE_FORMAT_HEX &quot;) because module %s does not read unnamed module @&quot; SIZE_FORMAT_HEX,
 591           current_class_name, module_from_name, new_class_name, uintx(identity_hash),
 592           module_from_name, uintx(identity_hash));
 593       }
 594 
 595     } else if (result == TYPE_NOT_EXPORTED) {
 596       assert(new_class-&gt;package() != NULL,
 597              &quot;Unnamed packages are always exported&quot;);
 598       const char * package_name =
 599         new_class-&gt;package()-&gt;name()-&gt;as_klass_external_name();
 600       assert(module_to-&gt;is_named(), &quot;Unnamed modules export all packages&quot;);
 601       if (module_from-&gt;is_named()) {
 602         size_t len = 118 + strlen(current_class_name) + 2*strlen(module_from_name) +
 603           strlen(new_class_name) + 2*strlen(module_to_name) + strlen(package_name);
 604         msg = NEW_RESOURCE_ARRAY(char, len);
 605         jio_snprintf(msg, len - 1,
 606           &quot;class %s (in module %s) cannot access class %s (in module %s) because module %s does not export %s to module %s&quot;,
 607           current_class_name, module_from_name, new_class_name,
 608           module_to_name, module_to_name, package_name, module_from_name);
 609       } else {
 610         oop jlm = module_from-&gt;module();
 611         assert(jlm != NULL, &quot;Null jlm in module_from ModuleEntry&quot;);
 612         intptr_t identity_hash = jlm-&gt;identity_hash();
 613         size_t len = 170 + strlen(current_class_name) + strlen(new_class_name) +
 614           2*strlen(module_to_name) + strlen(package_name) + 2*sizeof(uintx);
 615         msg = NEW_RESOURCE_ARRAY(char, len);
 616         jio_snprintf(msg, len - 1,
 617           &quot;class %s (in unnamed module @&quot; SIZE_FORMAT_HEX &quot;) cannot access class %s (in module %s) because module %s does not export %s to unnamed module @&quot; SIZE_FORMAT_HEX,
 618           current_class_name, uintx(identity_hash), new_class_name, module_to_name,
 619           module_to_name, package_name, uintx(identity_hash));
 620       }
 621     } else {
 622         ShouldNotReachHere();
 623     }
 624   }  // result != OTHER_PROBLEM...
 625   return msg;
 626 }
 627 
 628 bool Reflection::verify_member_access(const Klass* current_class,
 629                                       const Klass* resolved_class,
 630                                       const Klass* member_class,
 631                                       AccessFlags access,
 632                                       bool classloader_only,
 633                                       bool protected_restriction,
 634                                       TRAPS) {
 635   // Verify that current_class can access a member of member_class, where that
 636   // field&#39;s access bits are &quot;access&quot;.  We assume that we&#39;ve already verified
 637   // that current_class can access member_class.
 638   //
 639   // If the classloader_only flag is set, we automatically allow any accesses
 640   // in which current_class doesn&#39;t have a classloader.
 641   //
 642   // &quot;resolved_class&quot; is the runtime type of &quot;member_class&quot;. Sometimes we don&#39;t
 643   // need this distinction (e.g. if all we have is the runtime type, or during
 644   // class file parsing when we only care about the static type); in that case
 645   // callers should ensure that resolved_class == member_class.
 646   //
 647   if ((current_class == NULL) ||
 648       (current_class == member_class) ||
 649       access.is_public()) {
 650     return true;
 651   }
 652 
 653   const Klass* host_class = current_class;
 654   if (current_class-&gt;is_instance_klass() &amp;&amp;
 655       InstanceKlass::cast(current_class)-&gt;is_unsafe_anonymous()) {
 656     host_class = InstanceKlass::cast(current_class)-&gt;unsafe_anonymous_host();
 657     assert(host_class != NULL, &quot;Unsafe anonymous class has null host class&quot;);
 658     assert(!(host_class-&gt;is_instance_klass() &amp;&amp;
 659            InstanceKlass::cast(host_class)-&gt;is_unsafe_anonymous()),
 660            &quot;unsafe_anonymous_host should not be unsafe anonymous itself&quot;);
 661   }
 662   if (host_class == member_class) {
 663     return true;
 664   }
 665 
 666   if (access.is_protected()) {
 667     if (!protected_restriction) {
 668       // See if current_class (or outermost host class) is a subclass of member_class
 669       // An interface may not access protected members of j.l.Object
 670       if (!host_class-&gt;is_interface() &amp;&amp; host_class-&gt;is_subclass_of(member_class)) {
 671         if (access.is_static() || // static fields are ok, see 6622385
 672             current_class == resolved_class ||
 673             member_class == resolved_class ||
 674             host_class-&gt;is_subclass_of(resolved_class) ||
 675             resolved_class-&gt;is_subclass_of(host_class)) {
 676           return true;
 677         }
 678       }
 679     }
 680   }
 681 
 682   // package access
 683   if (!access.is_private() &amp;&amp; is_same_class_package(current_class, member_class)) {
 684     return true;
 685   }
 686 
 687   // private access between different classes needs a nestmate check, but
 688   // not for unsafe anonymous classes - so check host_class
 689   if (access.is_private() &amp;&amp; host_class == current_class) {
 690     if (current_class-&gt;is_instance_klass() &amp;&amp; member_class-&gt;is_instance_klass() ) {
 691       InstanceKlass* cur_ik = const_cast&lt;InstanceKlass*&gt;(InstanceKlass::cast(current_class));
 692       InstanceKlass* field_ik = const_cast&lt;InstanceKlass*&gt;(InstanceKlass::cast(member_class));
 693       // Nestmate access checks may require resolution and validation of the nest-host.
 694       // It is up to the caller to check for pending exceptions and handle appropriately.
 695       bool access = cur_ik-&gt;has_nestmate_access_to(field_ik, CHECK_false);
 696       if (access) {
 697         guarantee(resolved_class-&gt;is_subclass_of(member_class), &quot;must be!&quot;);
 698         return true;
 699       }
 700     }
 701   }
 702 
 703   // Allow all accesses from jdk/internal/reflect/MagicAccessorImpl subclasses to
 704   // succeed trivially.
 705   if (current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 706     return true;
 707   }
 708 
 709   // Check for special relaxations
 710   return can_relax_access_check_for(current_class, member_class, classloader_only);
 711 }
 712 
 713 bool Reflection::is_same_class_package(const Klass* class1, const Klass* class2) {
 714   return InstanceKlass::cast(class1)-&gt;is_same_class_package(class2);
 715 }
 716 
 717 // Checks that the &#39;outer&#39; klass has declared &#39;inner&#39; as being an inner klass. If not,
 718 // throw an incompatible class change exception
 719 // If inner_is_member, require the inner to be a member of the outer.
 720 // If !inner_is_member, require the inner to be hidden or unsafe anonymous (non-members).
 721 // Caller is responsible for figuring out in advance which case must be true.
 722 void Reflection::check_for_inner_class(const InstanceKlass* outer, const InstanceKlass* inner,
 723                                        bool inner_is_member, TRAPS) {
 724   InnerClassesIterator iter(outer);
 725   constantPoolHandle cp   (THREAD, outer-&gt;constants());
 726   for (; !iter.done(); iter.next()) {
 727     int ioff = iter.inner_class_info_index();
 728     int ooff = iter.outer_class_info_index();
 729 
 730     if (inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff != 0) {
 731       if (cp-&gt;klass_name_at_matches(outer, ooff) &amp;&amp;
 732           cp-&gt;klass_name_at_matches(inner, ioff)) {
 733         Klass* o = cp-&gt;klass_at(ooff, CHECK);
 734         if (o == outer) {
 735           Klass* i = cp-&gt;klass_at(ioff, CHECK);
 736           if (i == inner) {
 737             return;
 738           }
 739         }
 740       }
 741     }
 742 
 743     if (!inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff == 0 &amp;&amp;
 744         cp-&gt;klass_name_at_matches(inner, ioff)) {
 745       Klass* i = cp-&gt;klass_at(ioff, CHECK);
 746       if (i == inner) {
 747         return;
 748       }
 749     }
 750   }
 751 
 752   // &#39;inner&#39; not declared as an inner klass in outer
 753   ResourceMark rm(THREAD);
 754   Exceptions::fthrow(
 755     THREAD_AND_LOCATION,
 756     vmSymbols::java_lang_IncompatibleClassChangeError(),
 757     &quot;%s and %s disagree on InnerClasses attribute&quot;,
 758     outer-&gt;external_name(),
 759     inner-&gt;external_name()
 760   );
 761 }
 762 
 763 static objArrayHandle get_parameter_types(const methodHandle&amp; method,
 764                                           int parameter_count,
 765                                           oop* return_type,
 766                                           TRAPS) {
 767   // Allocate array holding parameter types (java.lang.Class instances)
 768   objArrayOop m = oopFactory::new_objArray(SystemDictionary::Class_klass(), parameter_count, CHECK_(objArrayHandle()));
 769   objArrayHandle mirrors(THREAD, m);
 770   int index = 0;
 771   // Collect parameter types
 772   ResourceMark rm(THREAD);
 773   for (ResolvingSignatureStream ss(method()); !ss.is_done(); ss.next()) {
 774     oop mirror = ss.as_java_mirror(SignatureStream::NCDFError, CHECK_(objArrayHandle()));
 775     if (log_is_enabled(Debug, class, resolve)) {
 776       trace_class_resolution(mirror);
 777     }
 778     if (!ss.at_return_type()) {
 779       mirrors-&gt;obj_at_put(index++, mirror);
 780     } else if (return_type != NULL) {
 781       // Collect return type as well
 782       assert(ss.at_return_type(), &quot;return type should be present&quot;);
 783       *return_type = mirror;
 784     }
 785   }
 786   assert(index == parameter_count, &quot;invalid parameter count&quot;);
 787   return mirrors;
 788 }
 789 
 790 static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
 791   return method-&gt;resolved_checked_exceptions(THREAD);
 792 }
 793 
 794 static Handle new_type(Symbol* signature, Klass* k, TRAPS) {
 795   ResolvingSignatureStream ss(signature, k, false);
 796   oop nt = ss.as_java_mirror(SignatureStream::NCDFError, CHECK_NH);
 797   return Handle(THREAD, nt);
 798 }
 799 
 800 
 801 oop Reflection::new_method(const methodHandle&amp; method, bool for_constant_pool_access, TRAPS) {
 802   // Allow sun.reflect.ConstantPool to refer to &lt;clinit&gt; methods as java.lang.reflect.Methods.
 803   assert(!method()-&gt;name()-&gt;starts_with(&#39;&lt;&#39;) || for_constant_pool_access,
 804          &quot;should call new_constructor instead&quot;);
 805   InstanceKlass* holder = method-&gt;method_holder();
 806   int slot = method-&gt;method_idnum();
 807 
 808   Symbol*  signature  = method-&gt;signature();
 809   int parameter_count = ArgumentCount(signature).size();
 810   oop return_type_oop = NULL;
 811   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, &amp;return_type_oop, CHECK_NULL);
 812   if (parameter_types.is_null() || return_type_oop == NULL) return NULL;
 813 
 814   Handle return_type(THREAD, return_type_oop);
 815 
 816   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 817 
 818   if (exception_types.is_null()) return NULL;
 819 
 820   Symbol*  method_name = method-&gt;name();
 821   oop name_oop = StringTable::intern(method_name, CHECK_NULL);
 822   Handle name = Handle(THREAD, name_oop);
 823   if (name == NULL) return NULL;
 824 
 825   const int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 826 
 827   Handle mh = java_lang_reflect_Method::create(CHECK_NULL);
 828 
 829   java_lang_reflect_Method::set_clazz(mh(), holder-&gt;java_mirror());
 830   java_lang_reflect_Method::set_slot(mh(), slot);
 831   java_lang_reflect_Method::set_name(mh(), name());
 832   java_lang_reflect_Method::set_return_type(mh(), return_type());
 833   java_lang_reflect_Method::set_parameter_types(mh(), parameter_types());
 834   java_lang_reflect_Method::set_exception_types(mh(), exception_types());
 835   java_lang_reflect_Method::set_modifiers(mh(), modifiers);
 836   java_lang_reflect_Method::set_override(mh(), false);
 837   if (method-&gt;generic_signature() != NULL) {
 838     Symbol*  gs = method-&gt;generic_signature();
 839     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 840     java_lang_reflect_Method::set_signature(mh(), sig());
 841   }
 842   typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 843   java_lang_reflect_Method::set_annotations(mh(), an_oop);
 844   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 845   java_lang_reflect_Method::set_parameter_annotations(mh(), an_oop);
 846   an_oop = Annotations::make_java_array(method-&gt;annotation_default(), CHECK_NULL);
 847   java_lang_reflect_Method::set_annotation_default(mh(), an_oop);
 848   return mh();
 849 }
 850 
 851 
 852 oop Reflection::new_constructor(const methodHandle&amp; method, TRAPS) {
 853   assert(method()-&gt;is_object_constructor() ||
 854          method()-&gt;is_static_init_factory(),
 855          &quot;should call new_method instead&quot;);
 856 
 857   InstanceKlass* holder = method-&gt;method_holder();
 858   int slot = method-&gt;method_idnum();
 859 
 860   Symbol*  signature  = method-&gt;signature();
 861   int parameter_count = ArgumentCount(signature).size();
 862   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, NULL, CHECK_NULL);
 863   if (parameter_types.is_null()) return NULL;
 864 
 865   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 866   if (exception_types.is_null()) return NULL;
 867 
 868   const int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 869 
 870   Handle ch = java_lang_reflect_Constructor::create(CHECK_NULL);
 871 
 872   java_lang_reflect_Constructor::set_clazz(ch(), holder-&gt;java_mirror());
 873   java_lang_reflect_Constructor::set_slot(ch(), slot);
 874   java_lang_reflect_Constructor::set_parameter_types(ch(), parameter_types());
 875   java_lang_reflect_Constructor::set_exception_types(ch(), exception_types());
 876   java_lang_reflect_Constructor::set_modifiers(ch(), modifiers);
 877   java_lang_reflect_Constructor::set_override(ch(), false);
 878   if (method-&gt;generic_signature() != NULL) {
 879     Symbol*  gs = method-&gt;generic_signature();
 880     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 881     java_lang_reflect_Constructor::set_signature(ch(), sig());
 882   }
 883   typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 884   java_lang_reflect_Constructor::set_annotations(ch(), an_oop);
 885   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 886   java_lang_reflect_Constructor::set_parameter_annotations(ch(), an_oop);
 887   return ch();
 888 }
 889 
 890 
 891 oop Reflection::new_field(fieldDescriptor* fd, TRAPS) {
 892   Symbol*  field_name = fd-&gt;name();
 893   oop name_oop = StringTable::intern(field_name, CHECK_NULL);
 894   Handle name = Handle(THREAD, name_oop);
 895   Symbol*  signature  = fd-&gt;signature();
 896   InstanceKlass* holder = fd-&gt;field_holder();
 897   Handle type = new_type(signature, holder, CHECK_NULL);
 898   Handle rh  = java_lang_reflect_Field::create(CHECK_NULL);
 899 
 900   java_lang_reflect_Field::set_clazz(rh(), fd-&gt;field_holder()-&gt;java_mirror());
 901   java_lang_reflect_Field::set_slot(rh(), fd-&gt;index());
 902   java_lang_reflect_Field::set_name(rh(), name());
 903   java_lang_reflect_Field::set_type(rh(), type());
<a name="1" id="anc1"></a><span class="line-added"> 904   if (fd-&gt;is_trusted_final()) {</span>
<span class="line-added"> 905     java_lang_reflect_Field::set_trusted_final(rh());</span>
<span class="line-added"> 906   }</span>
 907   // Note the ACC_ANNOTATION bit, which is a per-class access flag, is never set here.
 908   int modifiers = fd-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
 909   if (fd-&gt;is_inlined()) {
 910     modifiers |= JVM_ACC_FIELD_INLINED;
 911   }
 912   java_lang_reflect_Field::set_modifiers(rh(), modifiers);
 913   java_lang_reflect_Field::set_override(rh(), false);
 914   if (fd-&gt;has_generic_signature()) {
 915     Symbol*  gs = fd-&gt;generic_signature();
 916     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 917     java_lang_reflect_Field::set_signature(rh(), sig());
 918   }
 919   typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;annotations(), CHECK_NULL);
 920   java_lang_reflect_Field::set_annotations(rh(), an_oop);
 921   return rh();
 922 }
 923 
 924 oop Reflection::new_parameter(Handle method, int index, Symbol* sym,
 925                               int flags, TRAPS) {
 926 
 927   Handle rh = java_lang_reflect_Parameter::create(CHECK_NULL);
 928 
 929   if(NULL != sym) {
 930     Handle name = java_lang_String::create_from_symbol(sym, CHECK_NULL);
 931     java_lang_reflect_Parameter::set_name(rh(), name());
 932   } else {
 933     java_lang_reflect_Parameter::set_name(rh(), NULL);
 934   }
 935 
 936   java_lang_reflect_Parameter::set_modifiers(rh(), flags);
 937   java_lang_reflect_Parameter::set_executable(rh(), method());
 938   java_lang_reflect_Parameter::set_index(rh(), index);
 939   return rh();
 940 }
 941 
 942 
 943 static methodHandle resolve_interface_call(InstanceKlass* klass,
 944                                            const methodHandle&amp; method,
 945                                            Klass* recv_klass,
 946                                            Handle receiver,
 947                                            TRAPS) {
 948 
 949   assert(!method.is_null() , &quot;method should not be null&quot;);
 950 
 951   CallInfo info;
 952   Symbol*  signature  = method-&gt;signature();
 953   Symbol*  name       = method-&gt;name();
 954   LinkResolver::resolve_interface_call(info, receiver, recv_klass,
 955                                        LinkInfo(klass, name, signature),
 956                                        true,
 957                                        CHECK_(methodHandle()));
 958   return methodHandle(THREAD, info.selected_method());
 959 }
 960 
 961 // Conversion
 962 static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {
 963   assert(java_lang_Class::is_primitive(basic_type_mirror),
 964     &quot;just checking&quot;);
 965   return java_lang_Class::primitive_type(basic_type_mirror);
 966 }
 967 
 968 // Narrowing of basic types. Used to create correct jvalues for
 969 // boolean, byte, char and short return return values from interpreter
 970 // which are returned as ints. Throws IllegalArgumentException.
 971 static void narrow(jvalue* value, BasicType narrow_type, TRAPS) {
 972   switch (narrow_type) {
 973   case T_BOOLEAN:
 974     value-&gt;z = (jboolean) (value-&gt;i &amp; 1);
 975     return;
 976   case T_BYTE:
 977     value-&gt;b = (jbyte)value-&gt;i;
 978     return;
 979   case T_CHAR:
 980     value-&gt;c = (jchar)value-&gt;i;
 981     return;
 982   case T_SHORT:
 983     value-&gt;s = (jshort)value-&gt;i;
 984     return;
 985   default:
 986     break; // fail
 987   }
 988   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
 989 }
 990 
 991 
 992 // Method call (shared by invoke_method and invoke_constructor)
 993 static oop invoke(InstanceKlass* klass,
 994                   const methodHandle&amp; reflected_method,
 995                   Handle receiver,
 996                   bool override,
 997                   objArrayHandle ptypes,
 998                   BasicType rtype,
 999                   objArrayHandle args,
1000                   bool is_method_invoke,
1001                   TRAPS) {
1002 
1003   ResourceMark rm(THREAD);
1004 
1005   methodHandle method;      // actual method to invoke
1006   Klass* target_klass;      // target klass, receiver&#39;s klass for non-static
1007 
1008   // Ensure klass is initialized
1009   klass-&gt;initialize(CHECK_NULL);
1010 
1011   bool is_static = reflected_method-&gt;is_static();
1012   if (is_static) {
1013     // ignore receiver argument
1014     method = reflected_method;
1015     target_klass = klass;
1016   } else {
1017     // check for null receiver
1018     if (receiver.is_null()) {
1019       THROW_0(vmSymbols::java_lang_NullPointerException());
1020     }
1021     // Check class of receiver against class declaring method
1022     if (!receiver-&gt;is_a(klass)) {
1023       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;object is not an instance of declaring class&quot;);
1024     }
1025     // target klass is receiver&#39;s klass
1026     target_klass = receiver-&gt;klass();
1027     // no need to resolve if method is private or &lt;init&gt;
1028     if (reflected_method-&gt;is_private() || reflected_method-&gt;name() == vmSymbols::object_initializer_name()) {
1029       method = reflected_method;
1030     } else {
1031       // resolve based on the receiver
1032       if (reflected_method-&gt;method_holder()-&gt;is_interface()) {
1033         // resolve interface call
1034         //
1035         // Match resolution errors with those thrown due to reflection inlining
1036         // Linktime resolution &amp; IllegalAccessCheck already done by Class.getMethod()
1037         method = resolve_interface_call(klass, reflected_method, target_klass, receiver, THREAD);
1038         if (HAS_PENDING_EXCEPTION) {
1039           // Method resolution threw an exception; wrap it in an InvocationTargetException
1040           oop resolution_exception = PENDING_EXCEPTION;
1041           CLEAR_PENDING_EXCEPTION;
1042           // JVMTI has already reported the pending exception
1043           // JVMTI internal flag reset is needed in order to report InvocationTargetException
1044           if (THREAD-&gt;is_Java_thread()) {
1045             JvmtiExport::clear_detected_exception((JavaThread*)THREAD);
1046           }
1047           JavaCallArguments args(Handle(THREAD, resolution_exception));
1048           THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1049                       vmSymbols::throwable_void_signature(),
1050                       &amp;args);
1051         }
1052       }  else {
1053         // if the method can be overridden, we resolve using the vtable index.
1054         assert(!reflected_method-&gt;has_itable_index(), &quot;&quot;);
1055         int index = reflected_method-&gt;vtable_index();
1056         method = reflected_method;
1057         if (index != Method::nonvirtual_vtable_index) {
1058           method = methodHandle(THREAD, target_klass-&gt;method_at_vtable(index));
1059         }
1060         if (!method.is_null()) {
1061           // Check for abstract methods as well
1062           if (method-&gt;is_abstract()) {
1063             // new default: 6531596
1064             ResourceMark rm(THREAD);
1065             stringStream ss;
1066             ss.print(&quot;&#39;&quot;);
1067             Method::print_external_name(&amp;ss, target_klass, method-&gt;name(), method-&gt;signature());
1068             ss.print(&quot;&#39;&quot;);
1069             Handle h_origexception = Exceptions::new_exception(THREAD,
1070               vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1071             JavaCallArguments args(h_origexception);
1072             THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1073               vmSymbols::throwable_void_signature(),
1074               &amp;args);
1075           }
1076         }
1077       }
1078     }
1079   }
1080 
1081   // I believe this is a ShouldNotGetHere case which requires
1082   // an internal vtable bug. If you ever get this please let Karen know.
1083   if (method.is_null()) {
1084     ResourceMark rm(THREAD);
1085     stringStream ss;
1086     ss.print(&quot;&#39;&quot;);
1087     Method::print_external_name(&amp;ss, klass,
1088                                      reflected_method-&gt;name(),
1089                                      reflected_method-&gt;signature());
1090     ss.print(&quot;&#39;&quot;);
1091     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), ss.as_string());
1092   }
1093 
1094   assert(ptypes-&gt;is_objArray(), &quot;just checking&quot;);
1095   int args_len = args.is_null() ? 0 : args-&gt;length();
1096   // Check number of arguments
1097   if (ptypes-&gt;length() != args_len) {
1098     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1099                 &quot;wrong number of arguments&quot;);
1100   }
1101 
1102   // Create object to contain parameters for the JavaCall
1103   JavaCallArguments java_args(method-&gt;size_of_parameters());
1104 
1105   if (!is_static) {
1106     java_args.push_oop(receiver);
1107   }
1108 
1109   for (int i = 0; i &lt; args_len; i++) {
1110     oop type_mirror = ptypes-&gt;obj_at(i);
1111     oop arg = args-&gt;obj_at(i);
1112     if (java_lang_Class::is_primitive(type_mirror)) {
1113       jvalue value;
1114       BasicType ptype = basic_type_mirror_to_basic_type(type_mirror, CHECK_NULL);
1115       BasicType atype = Reflection::unbox_for_primitive(arg, &amp;value, CHECK_NULL);
1116       if (ptype != atype) {
1117         Reflection::widen(&amp;value, atype, ptype, CHECK_NULL);
1118       }
1119       switch (ptype) {
1120         case T_BOOLEAN:     java_args.push_int(value.z);    break;
1121         case T_CHAR:        java_args.push_int(value.c);    break;
1122         case T_BYTE:        java_args.push_int(value.b);    break;
1123         case T_SHORT:       java_args.push_int(value.s);    break;
1124         case T_INT:         java_args.push_int(value.i);    break;
1125         case T_LONG:        java_args.push_long(value.j);   break;
1126         case T_FLOAT:       java_args.push_float(value.f);  break;
1127         case T_DOUBLE:      java_args.push_double(value.d); break;
1128         default:
1129           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
1130       }
1131     } else {
1132       if (arg != NULL) {
1133         Klass* k = java_lang_Class::as_Klass(type_mirror);
1134         if (!arg-&gt;is_a(k)) {
1135           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1136                       &quot;argument type mismatch&quot;);
1137         }
1138       }
1139       Handle arg_handle(THREAD, arg);         // Create handle for argument
1140       java_args.push_oop(arg_handle); // Push handle
1141     }
1142   }
1143 
1144   assert(java_args.size_of_parameters() == method-&gt;size_of_parameters(),
1145     &quot;just checking&quot;);
1146 
1147   // All oops (including receiver) is passed in as Handles. An potential oop is returned as an
1148   // oop (i.e., NOT as an handle)
1149   JavaValue result(rtype);
1150   JavaCalls::call(&amp;result, method, &amp;java_args, THREAD);
1151 
1152   if (HAS_PENDING_EXCEPTION) {
1153     // Method threw an exception; wrap it in an InvocationTargetException
1154     oop target_exception = PENDING_EXCEPTION;
1155     CLEAR_PENDING_EXCEPTION;
1156     // JVMTI has already reported the pending exception
1157     // JVMTI internal flag reset is needed in order to report InvocationTargetException
1158     if (THREAD-&gt;is_Java_thread()) {
1159       JvmtiExport::clear_detected_exception((JavaThread*)THREAD);
1160     }
1161 
1162     JavaCallArguments args(Handle(THREAD, target_exception));
1163     THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1164                 vmSymbols::throwable_void_signature(),
1165                 &amp;args);
1166   } else {
1167     if (rtype == T_BOOLEAN || rtype == T_BYTE || rtype == T_CHAR || rtype == T_SHORT) {
1168       narrow((jvalue*)result.get_value_addr(), rtype, CHECK_NULL);
1169     }
1170     return Reflection::box((jvalue*)result.get_value_addr(), rtype, THREAD);
1171   }
1172 }
1173 
1174 // This would be nicer if, say, java.lang.reflect.Method was a subclass
1175 // of java.lang.reflect.Constructor
1176 
1177 oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
1178   oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
1179   int slot               = java_lang_reflect_Method::slot(method_mirror);
1180   bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
1181   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));
1182 
1183   oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
1184   BasicType rtype;
1185   if (java_lang_Class::is_primitive(return_type_mirror)) {
1186     rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
1187   } else if (java_lang_Class::as_Klass(return_type_mirror)-&gt;is_inline_klass()) {
1188     rtype = T_INLINE_TYPE;
1189   } else {
1190     rtype = T_OBJECT;
1191   }
1192 
1193   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1194   Method* m = klass-&gt;method_with_idnum(slot);
1195   if (m == NULL) {
1196     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1197   }
1198   methodHandle method(THREAD, m);
1199 
1200   return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
1201 }
1202 
1203 
1204 oop Reflection::invoke_constructor(oop constructor_mirror, objArrayHandle args, TRAPS) {
1205   oop mirror             = java_lang_reflect_Constructor::clazz(constructor_mirror);
1206   int slot               = java_lang_reflect_Constructor::slot(constructor_mirror);
1207   bool override          = java_lang_reflect_Constructor::override(constructor_mirror) != 0;
1208   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Constructor::parameter_types(constructor_mirror)));
1209 
1210   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1211   Method* m = klass-&gt;method_with_idnum(slot);
1212   if (m == NULL) {
1213     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1214   }
1215   methodHandle method(THREAD, m);
1216   assert(method-&gt;name() == vmSymbols::object_initializer_name(), &quot;invalid constructor&quot;);
1217 
1218   // Make sure klass gets initialize
1219   klass-&gt;initialize(CHECK_NULL);
1220 
1221   // Create new instance (the receiver)
1222   klass-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1223 
1224   // Special case for factory methods
1225   if (!method-&gt;signature()-&gt;is_void_method_signature()) {
1226     assert(klass-&gt;is_inline_klass(), &quot;inline classes must use factory methods&quot;);
1227     Handle no_receiver; // null instead of receiver
1228     BasicType rtype;
1229     if (klass-&gt;is_hidden()) {
1230       rtype = T_OBJECT;
1231     } else {
1232       rtype = T_INLINE_TYPE;
1233     }
1234     return invoke(klass, method, no_receiver, override, ptypes, rtype, args, false, CHECK_NULL);
1235   }
1236 
1237   // main branch of code creates a non-inline object:
1238   assert(!klass-&gt;is_inline_klass(), &quot;classic constructors are only for non-inline classes&quot;);
1239   Handle receiver = klass-&gt;allocate_instance_handle(CHECK_NULL);
1240 
1241   // Ignore result from call and return receiver
1242   invoke(klass, method, receiver, override, ptypes, T_VOID, args, false, CHECK_NULL);
1243   return receiver();
1244 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>