<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  33 #include &quot;classfile/classLoaderExt.hpp&quot;
  34 #include &quot;classfile/dictionary.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/loaderConstraints.hpp&quot;
  38 #include &quot;classfile/packageEntry.hpp&quot;
  39 #include &quot;classfile/placeholders.hpp&quot;
  40 #include &quot;classfile/protectionDomainCache.hpp&quot;
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<a name="1" id="anc1"></a>
  49 #include &quot;interpreter/bytecodeStream.hpp&quot;
  50 #include &quot;interpreter/interpreter.hpp&quot;
  51 #include &quot;jfr/jfrEvents.hpp&quot;
  52 #include &quot;logging/log.hpp&quot;
  53 #include &quot;logging/logStream.hpp&quot;
  54 #include &quot;memory/filemap.hpp&quot;
  55 #include &quot;memory/heapShared.hpp&quot;
  56 #include &quot;memory/metaspaceClosure.hpp&quot;
  57 #include &quot;memory/oopFactory.hpp&quot;
  58 #include &quot;memory/resourceArea.hpp&quot;
  59 #include &quot;memory/universe.hpp&quot;
  60 #include &quot;oops/access.inline.hpp&quot;
  61 #include &quot;oops/fieldStreams.inline.hpp&quot;
  62 #include &quot;oops/instanceKlass.hpp&quot;
  63 #include &quot;oops/instanceRefKlass.hpp&quot;
  64 #include &quot;oops/klass.inline.hpp&quot;
  65 #include &quot;oops/method.inline.hpp&quot;
  66 #include &quot;oops/methodData.hpp&quot;
  67 #include &quot;oops/objArrayKlass.hpp&quot;
  68 #include &quot;oops/objArrayOop.inline.hpp&quot;
  69 #include &quot;oops/oop.inline.hpp&quot;
  70 #include &quot;oops/oopHandle.inline.hpp&quot;
  71 #include &quot;oops/symbol.hpp&quot;
  72 #include &quot;oops/typeArrayKlass.hpp&quot;
  73 #include &quot;oops/inlineKlass.inline.hpp&quot;
  74 #include &quot;prims/jvmtiExport.hpp&quot;
  75 #include &quot;prims/methodHandles.hpp&quot;
  76 #include &quot;runtime/arguments.hpp&quot;
  77 #include &quot;runtime/biasedLocking.hpp&quot;
  78 #include &quot;runtime/handles.inline.hpp&quot;
  79 #include &quot;runtime/java.hpp&quot;
  80 #include &quot;runtime/javaCalls.hpp&quot;
  81 #include &quot;runtime/mutexLocker.hpp&quot;
  82 #include &quot;runtime/os.hpp&quot;
  83 #include &quot;runtime/sharedRuntime.hpp&quot;
  84 #include &quot;runtime/signature.hpp&quot;
  85 #include &quot;services/classLoadingService.hpp&quot;
  86 #include &quot;services/diagnosticCommand.hpp&quot;
  87 #include &quot;services/threadService.hpp&quot;
  88 #include &quot;utilities/macros.hpp&quot;
  89 #include &quot;utilities/utf8.hpp&quot;
  90 #if INCLUDE_CDS
  91 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  92 #endif
  93 #if INCLUDE_JFR
  94 #include &quot;jfr/jfr.hpp&quot;
  95 #endif
  96 
  97 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  98 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  99 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 100 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 101 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 102 
 103 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 104                                                           =  { NULL /*, NULL...*/ };
 105 
 106 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 107 
 108 
 109 OopHandle   SystemDictionary::_system_loader_lock_obj;
 110 OopHandle   SystemDictionary::_java_system_loader;
 111 OopHandle   SystemDictionary::_java_platform_loader;
 112 
 113 // Default ProtectionDomainCacheSize value
 114 
 115 const int defaultProtectionDomainCacheSize = 1009;
 116 
 117 ClassLoadInfo::ClassLoadInfo() {
 118   _protection_domain = Handle();
 119   _unsafe_anonymous_host = NULL;
 120   _cp_patches = NULL;
 121   _class_hidden_info._dynamic_nest_host = NULL;
 122   _class_hidden_info._class_data = Handle();
 123   _is_hidden = false;
 124   _is_strong_hidden = false;
 125   _can_access_vm_annotations = false;
 126 }
 127 
 128 ClassLoadInfo::ClassLoadInfo(Handle protection_domain) {
 129   _protection_domain = protection_domain;
 130   _unsafe_anonymous_host = NULL;
 131   _cp_patches = NULL;
 132   _class_hidden_info._dynamic_nest_host = NULL;
 133   _class_hidden_info._class_data = Handle();
 134   _is_hidden = false;
 135   _is_strong_hidden = false;
 136   _can_access_vm_annotations = false;
 137 }
 138 
 139 ClassLoadInfo::ClassLoadInfo(Handle protection_domain,
 140                              const InstanceKlass* unsafe_anonymous_host,
 141                              GrowableArray&lt;Handle&gt;* cp_patches,
 142                              InstanceKlass* dynamic_nest_host,
 143                              Handle class_data,
 144                              bool is_hidden,
 145                              bool is_strong_hidden,
 146                              bool can_access_vm_annotations) {
 147   _protection_domain = protection_domain;
 148   _unsafe_anonymous_host = unsafe_anonymous_host;
 149   _cp_patches = cp_patches;
 150   _class_hidden_info._dynamic_nest_host = dynamic_nest_host;
 151   _class_hidden_info._class_data = class_data;
 152   _is_hidden = is_hidden;
 153   _is_strong_hidden = is_strong_hidden;
 154   _can_access_vm_annotations = can_access_vm_annotations;
 155 }
 156 
 157 // ----------------------------------------------------------------------------
 158 // Java-level SystemLoader and PlatformLoader
 159 
 160 oop SystemDictionary::system_loader_lock() {
 161   return _system_loader_lock_obj.resolve();
 162 }
 163 
 164 oop SystemDictionary::java_system_loader() {
 165   return _java_system_loader.resolve();
 166 }
 167 
 168 oop SystemDictionary::java_platform_loader() {
 169   return _java_platform_loader.resolve();
 170 }
 171 
 172 void SystemDictionary::compute_java_loaders(TRAPS) {
 173   JavaValue result(T_OBJECT);
 174   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 175   JavaCalls::call_static(&amp;result,
 176                          class_loader_klass,
 177                          vmSymbols::getSystemClassLoader_name(),
 178                          vmSymbols::void_classloader_signature(),
 179                          CHECK);
 180 
<a name="2" id="anc2"></a><span class="line-modified"> 181   _java_system_loader = OopHandle::create((oop)result.get_jobject());</span>
 182 
 183   JavaCalls::call_static(&amp;result,
 184                          class_loader_klass,
 185                          vmSymbols::getPlatformClassLoader_name(),
 186                          vmSymbols::void_classloader_signature(),
 187                          CHECK);
 188 
<a name="3" id="anc3"></a><span class="line-modified"> 189   _java_platform_loader = OopHandle::create((oop)result.get_jobject());</span>
 190 }
 191 
 192 ClassLoaderData* SystemDictionary::register_loader(Handle class_loader, bool create_mirror_cld) {
 193   if (create_mirror_cld) {
 194     // Add a new class loader data to the graph.
 195     return ClassLoaderDataGraph::add(class_loader, true);
 196   } else {
 197     return (class_loader() == NULL) ? ClassLoaderData::the_null_class_loader_data() :
 198                                       ClassLoaderDataGraph::find_or_create(class_loader);
 199   }
 200 }
 201 
 202 // ----------------------------------------------------------------------------
 203 // Parallel class loading check
 204 
 205 bool SystemDictionary::is_parallelCapable(Handle class_loader) {
 206   if (class_loader.is_null()) return true;
 207   if (AlwaysLockClassLoader) return false;
 208   return java_lang_ClassLoader::parallelCapable(class_loader());
 209 }
 210 // ----------------------------------------------------------------------------
 211 // ParallelDefineClass flag does not apply to bootclass loader
 212 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 213    if (class_loader.is_null()) return false;
 214    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 215      return true;
 216    }
 217    return false;
 218 }
 219 
 220 // Returns true if the passed class loader is the builtin application class loader
 221 // or a custom system class loader. A customer system class loader can be
 222 // specified via -Djava.system.class.loader.
 223 bool SystemDictionary::is_system_class_loader(oop class_loader) {
 224   if (class_loader == NULL) {
 225     return false;
 226   }
 227   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
 228          class_loader == _java_system_loader.peek());
 229 }
 230 
 231 // Returns true if the passed class loader is the platform class loader.
 232 bool SystemDictionary::is_platform_class_loader(oop class_loader) {
 233   if (class_loader == NULL) {
 234     return false;
 235   }
 236   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());
 237 }
 238 
 239 // ----------------------------------------------------------------------------
 240 // Resolving of classes
 241 
 242 Symbol* SystemDictionary::class_name_symbol(const char* name, Symbol* exception, TRAPS) {
 243   if (name == NULL) {
 244     THROW_MSG_0(exception, &quot;No class name given&quot;);
 245   }
 246   if ((int)strlen(name) &gt; Symbol::max_length()) {
 247     // It&#39;s impossible to create this class;  the name cannot fit
 248     // into the constant pool.
 249     Exceptions::fthrow(THREAD_AND_LOCATION, exception,
 250                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 251                        Symbol::max_length(),
 252                        name);
 253     return NULL;
 254   }
 255   // Callers should ensure that the name is never an illegal UTF8 string.
 256   assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false),
 257          &quot;Class name is not a valid utf8 string.&quot;);
 258 
 259   // Make a new symbol for the class name.
 260   return SymbolTable::new_symbol(name);
 261 }
 262 
 263 // Forwards to resolve_or_null
 264 
 265 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {
 266   Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);
 267   if (HAS_PENDING_EXCEPTION || klass == NULL) {
 268     // can return a null klass
 269     klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);
 270   }
 271   return klass;
 272 }
 273 
 274 Klass* SystemDictionary::handle_resolution_exception(Symbol* class_name,
 275                                                      bool throw_error,
 276                                                      Klass* klass, TRAPS) {
 277   if (HAS_PENDING_EXCEPTION) {
 278     // If we have a pending exception we forward it to the caller, unless throw_error is true,
 279     // in which case we have to check whether the pending exception is a ClassNotFoundException,
 280     // and if so convert it to a NoClassDefFoundError
 281     // And chain the original ClassNotFoundException
 282     if (throw_error &amp;&amp; PENDING_EXCEPTION-&gt;is_a(SystemDictionary::ClassNotFoundException_klass())) {
 283       ResourceMark rm(THREAD);
 284       assert(klass == NULL, &quot;Should not have result with exception pending&quot;);
 285       Handle e(THREAD, PENDING_EXCEPTION);
 286       CLEAR_PENDING_EXCEPTION;
 287       THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string(), e);
 288     } else {
 289       return NULL;
 290     }
 291   }
 292   // Class not found, throw appropriate error or exception depending on value of throw_error
 293   if (klass == NULL) {
 294     ResourceMark rm(THREAD);
 295     if (throw_error) {
 296       THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string());
 297     } else {
 298       THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name-&gt;as_C_string());
 299     }
 300   }
 301   return klass;
 302 }
 303 
 304 
 305 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
 306                                            bool throw_error, TRAPS)
 307 {
 308   return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);
 309 }
 310 
 311 
 312 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 313 
 314 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 315   if (Signature::is_array(class_name)) {
 316     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 317   } else {
 318     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 319   }
 320 }
 321 
 322 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 323 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 324                                                                        Handle class_loader,
 325                                                                        Handle protection_domain,
 326                                                                        TRAPS) {
 327   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 328   if (Signature::has_envelope(class_name)) {
 329     ResourceMark rm(THREAD);
 330     // Ignore wrapping L and ;. (and Q and ; for value types);
 331     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 332                                                  class_name-&gt;utf8_length() - 2);
 333     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 334   } else {
 335     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 336   }
 337 }
 338 
 339 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 340   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 341 }
 342 
 343 // Forwards to resolve_instance_class_or_null
 344 
 345 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 346                                                      Handle class_loader,
 347                                                      Handle protection_domain,
 348                                                      TRAPS) {
 349   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 350   ResourceMark rm(THREAD);
 351   SignatureStream ss(class_name, false);
 352   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 353   Klass* k = NULL;
 354   BasicType t = ss.type();
 355   if (ss.has_envelope()) {
 356     Symbol* obj_class = ss.as_symbol();
 357     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 358                                                          class_loader,
 359                                                          protection_domain,
 360                                                          CHECK_NULL);
 361     if (k != NULL) {
 362       if ((class_name-&gt;is_Q_array_signature() &amp;&amp; !k-&gt;is_inline_klass()) ||
 363           (!class_name-&gt;is_Q_array_signature() &amp;&amp; k-&gt;is_inline_klass())) {
 364             THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), &quot;L/Q mismatch on bottom type&quot;);
 365           }
 366       k = k-&gt;array_klass(ndims, CHECK_NULL);
 367     }
 368   } else {
 369     k = Universe::typeArrayKlassObj(t);
 370     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);
 371   }
 372   return k;
 373 }
 374 
 375 // Must be called for any super-class or super-interface resolution
 376 // during class definition to allow class circularity checking
 377 // super-interface callers:
 378 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 379 // super-class callers:
 380 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 381 //   load_shared_class - while loading a class from shared archive
 382 //   resolve_instance_class_or_null:
 383 //     via: handle_parallel_super_load
 384 //      when resolving a class that has an existing placeholder with
 385 //      a saved superclass [i.e. a defineClass is currently in progress]
 386 //      if another thread is trying to resolve the class, it must do
 387 //      super-class checks on its own thread to catch class circularity
 388 // This last call is critical in class circularity checking for cases
 389 // where classloading is delegated to different threads and the
 390 // classloader lock is released.
 391 // Take the case: Base-&gt;Super-&gt;Base
 392 //   1. If thread T1 tries to do a defineClass of class Base
 393 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 394 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
 395 //    so it tries to load Super
 396 //   3. If we load the class internally, or user classloader uses same thread
 397 //      loadClassFromxxx or defineClass via parseClassFile Super ...
 398 //      3.1 resolve_super_or_fail creates placeholder: T1, Super (super Base)
 399 //      3.3 resolve_instance_class_or_null Base, finds placeholder for Base
 400 //      3.4 calls resolve_super_or_fail Base
 401 //      3.5 finds T1,Base -&gt; throws class circularity
 402 //OR 4. If T2 tries to resolve Super via defineClass Super ...
 403 //      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)
 404 //      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)
 405 //      4.3 calls resolve_super_or_fail Super in parallel on own thread T2
 406 //      4.4 finds T2, Super -&gt; throws class circularity
 407 // Must be called, even if superclass is null, since this is
 408 // where the placeholder entry is created which claims this
 409 // thread is loading this class/classloader.
 410 // Be careful when modifying this code: once you have run
 411 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_SUPER),
 412 // you need to find_and_remove it before returning.
 413 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 414 InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,
 415                                                        Symbol* super_name,
 416                                                        Handle class_loader,
 417                                                        Handle protection_domain,
 418                                                        bool is_superclass,
 419                                                        TRAPS) {
 420   assert(!Signature::is_array(super_name), &quot;invalid super class name&quot;);
 421 #if INCLUDE_CDS
 422   if (DumpSharedSpaces) {
 423     // Special processing for handling UNREGISTERED shared classes.
 424     InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
 425         super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
 426     if (k) {
 427       return k;
 428     }
 429   }
 430 #endif // INCLUDE_CDS
 431 
 432   // Double-check, if child class is already loaded, just return super-class,interface
 433   // Don&#39;t add a placedholder if already loaded, i.e. already in appropriate class loader
 434   // dictionary.
 435   // Make sure there&#39;s a placeholder for the *child* before resolving.
 436   // Used as a claim that this thread is currently loading superclass/classloader
 437   // Used here for ClassCircularity checks and also for heap verification
 438   // (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).
 439   // Must check ClassCircularity before checking if super class is already loaded.
 440   //
 441   // We might not already have a placeholder if this child_name was
 442   // first seen via resolve_from_stream (jni_DefineClass or JVM_DefineClass);
 443   // the name of the class might not be known until the stream is actually
 444   // parsed.
 445   // Bugs 4643874, 4715493
 446 
 447   ClassLoaderData* loader_data = class_loader_data(class_loader);
 448   Dictionary* dictionary = loader_data-&gt;dictionary();
 449   unsigned int d_hash = dictionary-&gt;compute_hash(child_name);
 450   unsigned int p_hash = placeholders()-&gt;compute_hash(child_name);
 451   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 452   // can&#39;t throw error holding a lock
 453   bool child_already_loaded = false;
 454   bool throw_circularity_error = false;
 455   {
 456     MutexLocker mu(THREAD, SystemDictionary_lock);
 457     InstanceKlass* childk = find_class(d_hash, child_name, dictionary);
 458     InstanceKlass* quicksuperk;
 459     // to support // loading: if child done loading, just return superclass
 460     // if super_name, &amp; class_loader don&#39;t match:
 461     // if initial define, SD update will give LinkageError
 462     // if redefine: compare_class_versions will give HIERARCHY_CHANGED
 463     // so we don&#39;t throw an exception here.
 464     // see: nsk redefclass014 &amp; java.lang.instrument Instrument032
 465     if ((childk != NULL ) &amp;&amp; (is_superclass) &amp;&amp;
 466         ((quicksuperk = childk-&gt;java_super()) != NULL) &amp;&amp;
 467          ((quicksuperk-&gt;name() == super_name) &amp;&amp;
 468             (quicksuperk-&gt;class_loader() == class_loader()))) {
 469            return quicksuperk;
 470     } else {
 471       PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, child_name, loader_data);
 472       if (probe &amp;&amp; probe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_SUPER)) {
 473           throw_circularity_error = true;
 474       }
 475     }
 476     if (!throw_circularity_error) {
 477       // Be careful not to exit resolve_super
 478       PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);
 479     }
 480   }
 481   if (throw_circularity_error) {
 482       ResourceMark rm(THREAD);
 483       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name-&gt;as_C_string());
 484   }
 485 
 486 // java.lang.Object should have been found above
 487   assert(super_name != NULL, &quot;null super class for resolving&quot;);
 488   // Resolve the super class or interface, check results on return
 489   InstanceKlass* superk =
 490     SystemDictionary::resolve_instance_class_or_null_helper(super_name,
 491                                                             class_loader,
 492                                                             protection_domain,
 493                                                             THREAD);
 494 
 495   // Clean up of placeholders moved so that each classloadAction registrar self-cleans up
 496   // It is no longer necessary to keep the placeholder table alive until update_dictionary
 497   // or error. GC used to walk the placeholder table as strong roots.
 498   // The instanceKlass is kept alive because the class loader is on the stack,
 499   // which keeps the loader_data alive, as well as all instanceKlasses in
 500   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 501   {
 502     MutexLocker mu(THREAD, SystemDictionary_lock);
 503     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 504     SystemDictionary_lock-&gt;notify_all();
 505   }
 506   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 507     // can null superk
 508     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 509     assert(k == NULL || k == superk, &quot;must be&quot;);
 510     if (k == NULL) {
 511       superk = NULL;
 512     }
 513   }
 514 
 515   return superk;
 516 }
 517 
 518 Klass* SystemDictionary::resolve_inline_type_field_or_fail(AllFieldStream* fs,
 519                                                            Handle class_loader,
 520                                                            Handle protection_domain,
 521                                                            bool throw_error,
 522                                                            TRAPS) {
 523   Symbol* class_name = fs-&gt;signature()-&gt;fundamental_name(THREAD);
 524   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 525   ClassLoaderData* loader_data = class_loader_data(class_loader);
 526   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);
 527   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 528   bool throw_circularity_error = false;
 529   PlaceholderEntry* oldprobe;
 530 
 531   {
 532     MutexLocker mu(THREAD, SystemDictionary_lock);
 533     oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, class_name, loader_data);
 534     if (oldprobe != NULL &amp;&amp;
 535       oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::INLINE_TYPE_FIELD)) {
 536       throw_circularity_error = true;
 537 
 538     } else {
 539       placeholders()-&gt;find_and_add(p_index, p_hash, class_name, loader_data,
 540                                    PlaceholderTable::INLINE_TYPE_FIELD, NULL, THREAD);
 541     }
 542   }
 543 
 544   Klass* klass = NULL;
 545   if (!throw_circularity_error) {
 546     klass = SystemDictionary::resolve_or_fail(class_name, class_loader,
 547                                                protection_domain, true, THREAD);
 548   } else {
 549     ResourceMark rm(THREAD);
 550     THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name-&gt;as_C_string());
 551   }
 552 
 553   {
 554     MutexLocker mu(THREAD, SystemDictionary_lock);
 555     placeholders()-&gt;find_and_remove(p_index, p_hash, class_name, loader_data,
 556                                     PlaceholderTable::INLINE_TYPE_FIELD, THREAD);
 557   }
 558 
 559   class_name-&gt;decrement_refcount();
 560   return klass;
 561 }
 562 
 563 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 564                                                   Handle class_loader,
 565                                                   Handle protection_domain,
 566                                                   TRAPS) {
 567   // Now we have to call back to java to check if the initating class has access
 568   JavaValue result(T_VOID);
 569   LogTarget(Debug, protectiondomain) lt;
 570   if (lt.is_enabled()) {
 571     ResourceMark rm(THREAD);
 572     // Print out trace information
 573     LogStream ls(lt);
 574     ls.print_cr(&quot;Checking package access&quot;);
 575     if (class_loader() != NULL) {
 576       ls.print(&quot;class loader: &quot;);
 577       class_loader()-&gt;print_value_on(&amp;ls);
 578     } else {
 579       ls.print_cr(&quot;class loader: NULL&quot;);
 580     }
 581     if (protection_domain() != NULL) {
 582       ls.print(&quot; protection domain: &quot;);
 583       protection_domain()-&gt;print_value_on(&amp;ls);
 584     } else {
 585       ls.print_cr(&quot; protection domain: NULL&quot;);
 586     }
 587     ls.print(&quot; loading: &quot;); klass-&gt;print_value_on(&amp;ls);
 588     ls.cr();
 589   }
 590 
 591   // This handle and the class_loader handle passed in keeps this class from
 592   // being unloaded through several GC points.
 593   // The class_loader handle passed in is the initiating loader.
 594   Handle mirror(THREAD, klass-&gt;java_mirror());
 595 
 596   InstanceKlass* system_loader = SystemDictionary::ClassLoader_klass();
 597   JavaCalls::call_special(&amp;result,
 598                          class_loader,
 599                          system_loader,
 600                          vmSymbols::checkPackageAccess_name(),
 601                          vmSymbols::class_protectiondomain_signature(),
 602                          mirror,
 603                          protection_domain,
 604                          THREAD);
 605 
 606   if (HAS_PENDING_EXCEPTION) {
 607     log_debug(protectiondomain)(&quot;DENIED !!!!!!!!!!!!!!!!!!!!!&quot;);
 608   } else {
 609    log_debug(protectiondomain)(&quot;granted&quot;);
 610   }
 611 
 612   if (HAS_PENDING_EXCEPTION) return;
 613 
 614   // If no exception has been thrown, we have validated the protection domain
 615   // Insert the protection domain of the initiating class into the set.
 616   {
 617     ClassLoaderData* loader_data = class_loader_data(class_loader);
 618     Dictionary* dictionary = loader_data-&gt;dictionary();
 619 
 620     Symbol*  kn = klass-&gt;name();
 621     unsigned int d_hash = dictionary-&gt;compute_hash(kn);
 622 
 623     MutexLocker mu(THREAD, SystemDictionary_lock);
 624     int d_index = dictionary-&gt;hash_to_index(d_hash);
 625     dictionary-&gt;add_protection_domain(d_index, d_hash, klass,
 626                                       protection_domain, THREAD);
 627   }
 628 }
 629 
 630 // We only get here if this thread finds that another thread
 631 // has already claimed the placeholder token for the current operation,
 632 // but that other thread either never owned or gave up the
 633 // object lock
 634 // Waits on SystemDictionary_lock to indicate placeholder table updated
 635 // On return, caller must recheck placeholder table state
 636 //
 637 // We only get here if
 638 //  1) custom classLoader, i.e. not bootstrap classloader
 639 //  2) custom classLoader has broken the class loader objectLock
 640 //     so another thread got here in parallel
 641 //
 642 // lockObject must be held.
 643 // Complicated dance due to lock ordering:
 644 // Must first release the classloader object lock to
 645 // allow initial definer to complete the class definition
 646 // and to avoid deadlock
 647 // Reclaim classloader lock object with same original recursion count
 648 // Must release SystemDictionary_lock after notify, since
 649 // class loader lock must be claimed before SystemDictionary_lock
 650 // to prevent deadlocks
 651 //
 652 // The notify allows applications that did an untimed wait() on
 653 // the classloader object lock to not hang.
 654 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 655   assert_lock_strong(SystemDictionary_lock);
 656 
 657   bool calledholdinglock
 658       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 659   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
 660   assert((lockObject() != _system_loader_lock_obj.resolve() &amp;&amp;
 661          !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);
 662   ObjectSynchronizer::notifyall(lockObject, THREAD);
 663   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);
 664   SystemDictionary_lock-&gt;wait();
 665   SystemDictionary_lock-&gt;unlock();
 666   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
 667   SystemDictionary_lock-&gt;lock();
 668 }
 669 
 670 // If the class in is in the placeholder table, class loading is in progress
 671 // For cases where the application changes threads to load classes, it
 672 // is critical to ClassCircularity detection that we try loading
 673 // the superclass on the same thread internally, so we do parallel
 674 // super class loading here.
 675 // This also is critical in cases where the original thread gets stalled
 676 // even in non-circularity situations.
 677 // Note: must call resolve_super_or_fail even if null super -
 678 // to force placeholder entry creation for this class for circularity detection
 679 // Caller must check for pending exception
 680 // Returns non-null Klass* if other thread has completed load
 681 // and we are done,
 682 // If return null Klass* and no pending exception, the caller must load the class
 683 InstanceKlass* SystemDictionary::handle_parallel_super_load(
 684     Symbol* name, Symbol* superclassname, Handle class_loader,
 685     Handle protection_domain, Handle lockObject, TRAPS) {
 686 
 687   ClassLoaderData* loader_data = class_loader_data(class_loader);
 688   Dictionary* dictionary = loader_data-&gt;dictionary();
 689   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 690   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 691   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 692 
 693   // superk is not used, resolve_super called for circularity check only
 694   // This code is reached in two situations. One if this thread
 695   // is loading the same class twice (e.g. ClassCircularity, or
 696   // java.lang.instrument).
 697   // The second is if another thread started the resolve_super first
 698   // and has not yet finished.
 699   // In both cases the original caller will clean up the placeholder
 700   // entry on error.
 701   Klass* superk = SystemDictionary::resolve_super_or_fail(name,
 702                                                           superclassname,
 703                                                           class_loader,
 704                                                           protection_domain,
 705                                                           true,
 706                                                           CHECK_NULL);
 707 
 708   // parallelCapable class loaders do NOT wait for parallel superclass loads to complete
 709   // Serial class loaders and bootstrap classloader do wait for superclass loads
 710  if (!class_loader.is_null() &amp;&amp; is_parallelCapable(class_loader)) {
 711     MutexLocker mu(THREAD, SystemDictionary_lock);
 712     // Check if classloading completed while we were loading superclass or waiting
 713     return find_class(d_hash, name, dictionary);
 714   }
 715 
 716   // must loop to both handle other placeholder updates
 717   // and spurious notifications
 718   bool super_load_in_progress = true;
 719   PlaceholderEntry* placeholder;
 720   while (super_load_in_progress) {
 721     MutexLocker mu(THREAD, SystemDictionary_lock);
 722     // Check if classloading completed while we were loading superclass or waiting
 723     InstanceKlass* check = find_class(d_hash, name, dictionary);
 724     if (check != NULL) {
 725       // Klass is already loaded, so just return it
 726       return check;
 727     } else {
 728       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 729       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress() ){
 730         // We only get here if the application has released the
 731         // classloader lock when another thread was in the middle of loading a
 732         // superclass/superinterface for this class, and now
 733         // this thread is also trying to load this class.
 734         // To minimize surprises, the first thread that started to
 735         // load a class should be the one to complete the loading
 736         // with the classfile it initially expected.
 737         // This logic has the current thread wait once it has done
 738         // all the superclass/superinterface loading it can, until
 739         // the original thread completes the class loading or fails
 740         // If it completes we will use the resulting InstanceKlass
 741         // which we will find below in the systemDictionary.
 742         // We also get here for parallel bootstrap classloader
 743         if (class_loader.is_null()) {
 744           SystemDictionary_lock-&gt;wait();
 745         } else {
 746           double_lock_wait(lockObject, THREAD);
 747         }
 748       } else {
 749         // If not in SD and not in PH, other thread&#39;s load must have failed
 750         super_load_in_progress = false;
 751       }
 752     }
 753   }
 754   return NULL;
 755 }
 756 
 757 void SystemDictionary::post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {
 758   assert(event != NULL, &quot;invariant&quot;);
 759   assert(k != NULL, &quot;invariant&quot;);
 760   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 761   event-&gt;set_loadedClass(k);
 762   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 763   event-&gt;set_initiatingClassLoader(init_cld);
 764   event-&gt;commit();
 765 }
 766 
 767 
 768 // Be careful when modifying this code: once you have run
 769 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 770 // you need to find_and_remove it before returning.
 771 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 772 //
 773 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 774 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 775                                                                 Handle class_loader,
 776                                                                 Handle protection_domain,
 777                                                                 TRAPS) {
 778   assert(name != NULL &amp;&amp; !Signature::is_array(name) &amp;&amp;
 779          !Signature::has_envelope(name), &quot;invalid class name&quot;);
 780 
 781   EventClassLoad class_load_start_event;
 782 
 783   HandleMark hm(THREAD);
 784 
 785   // Fix for 4474172; see evaluation for more details
 786   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 787   ClassLoaderData* loader_data = register_loader(class_loader);
 788   Dictionary* dictionary = loader_data-&gt;dictionary();
 789   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 790 
 791   // Do lookup to see if class already exist and the protection domain
 792   // has the right access
 793   // This call uses find which checks protection domain already matches
 794   // All subsequent calls use find_class, and set has_loaded_class so that
 795   // before we return a result we call out to java to check for valid protection domain
 796   // to allow returning the Klass* and add it to the pd_set if it is valid
 797   {
 798     InstanceKlass* probe = dictionary-&gt;find(d_hash, name, protection_domain);
 799     if (probe != NULL) return probe;
 800   }
 801 
 802   // Non-bootstrap class loaders will call out to class loader and
 803   // define via jvm/jni_DefineClass which will acquire the
 804   // class loader object lock to protect against multiple threads
 805   // defining the class in parallel by accident.
 806   // This lock must be acquired here so the waiter will find
 807   // any successful result in the SystemDictionary and not attempt
 808   // the define.
 809   // ParallelCapable Classloaders and the bootstrap classloader
 810   // do not acquire lock here.
 811   bool DoObjectLock = true;
 812   if (is_parallelCapable(class_loader)) {
 813     DoObjectLock = false;
 814   }
 815 
 816   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 817   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 818 
 819   // Class is not in SystemDictionary so we have to do loading.
 820   // Make sure we are synchronized on the class loader before we proceed
 821   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
 822   check_loader_lock_contention(lockObject, THREAD);
 823   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
 824 
 825   // Check again (after locking) if class already exist in SystemDictionary
 826   bool class_has_been_loaded   = false;
 827   bool super_load_in_progress  = false;
 828   bool havesupername = false;
 829   InstanceKlass* k = NULL;
 830   PlaceholderEntry* placeholder;
 831   Symbol* superclassname = NULL;
 832 
 833   assert(THREAD-&gt;can_call_java(),
 834          &quot;can not load classes with compiler thread: class=%s, classloader=%s&quot;,
 835          name-&gt;as_C_string(),
 836          class_loader.is_null() ? &quot;null&quot; : class_loader-&gt;klass()-&gt;name()-&gt;as_C_string());
 837   {
 838     MutexLocker mu(THREAD, SystemDictionary_lock);
 839     InstanceKlass* check = find_class(d_hash, name, dictionary);
 840     if (check != NULL) {
 841       // InstanceKlass is already loaded, so just return it
 842       class_has_been_loaded = true;
 843       k = check;
 844     } else {
 845       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 846       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress()) {
 847          super_load_in_progress = true;
 848          if (placeholder-&gt;havesupername() == true) {
 849            superclassname = placeholder-&gt;supername();
 850            havesupername = true;
 851          }
 852       }
 853     }
 854   }
 855 
 856   // If the class is in the placeholder table, class loading is in progress
 857   if (super_load_in_progress &amp;&amp; havesupername==true) {
 858     k = handle_parallel_super_load(name,
 859                                    superclassname,
 860                                    class_loader,
 861                                    protection_domain,
 862                                    lockObject, THREAD);
 863     if (HAS_PENDING_EXCEPTION) {
 864       return NULL;
 865     }
 866     if (k != NULL) {
 867       class_has_been_loaded = true;
 868     }
 869   }
 870 
 871   bool throw_circularity_error = false;
 872   if (!class_has_been_loaded) {
 873     bool load_instance_added = false;
 874 
 875     // add placeholder entry to record loading instance class
 876     // Five cases:
 877     // All cases need to prevent modifying bootclasssearchpath
 878     // in parallel with a classload of same classname
 879     // Redefineclasses uses existence of the placeholder for the duration
 880     // of the class load to prevent concurrent redefinition of not completely
 881     // defined classes.
 882     // case 1. traditional classloaders that rely on the classloader object lock
 883     //   - no other need for LOAD_INSTANCE
 884     // case 2. traditional classloaders that break the classloader object lock
 885     //    as a deadlock workaround. Detection of this case requires that
 886     //    this check is done while holding the classloader object lock,
 887     //    and that lock is still held when calling classloader&#39;s loadClass.
 888     //    For these classloaders, we ensure that the first requestor
 889     //    completes the load and other requestors wait for completion.
 890     // case 3. Bootstrap classloader - don&#39;t own objectLocker
 891     //    This classloader supports parallelism at the classloader level,
 892     //    but only allows a single load of a class/classloader pair.
 893     //    No performance benefit and no deadlock issues.
 894     // case 4. parallelCapable user level classloaders - without objectLocker
 895     //    Allow parallel classloading of a class/classloader pair
 896 
 897     {
 898       MutexLocker mu(THREAD, SystemDictionary_lock);
 899       if (class_loader.is_null() || !is_parallelCapable(class_loader)) {
 900         PlaceholderEntry* oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 901         if (oldprobe) {
 902           // only need check_seen_thread once, not on each loop
 903           // 6341374 java/lang/Instrument with -Xcomp
 904           if (oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {
 905             throw_circularity_error = true;
 906           } else {
 907             // case 1: traditional: should never see load_in_progress.
 908             while (!class_has_been_loaded &amp;&amp; oldprobe &amp;&amp; oldprobe-&gt;instance_load_in_progress()) {
 909 
 910               // case 3: bootstrap classloader: prevent futile classloading,
 911               // wait on first requestor
 912               if (class_loader.is_null()) {
 913                 SystemDictionary_lock-&gt;wait();
 914               } else {
 915               // case 2: traditional with broken classloader lock. wait on first
 916               // requestor.
 917                 double_lock_wait(lockObject, THREAD);
 918               }
 919               // Check if classloading completed while we were waiting
 920               InstanceKlass* check = find_class(d_hash, name, dictionary);
 921               if (check != NULL) {
 922                 // Klass is already loaded, so just return it
 923                 k = check;
 924                 class_has_been_loaded = true;
 925               }
 926               // check if other thread failed to load and cleaned up
 927               oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 928             }
 929           }
 930         }
 931       }
 932       // All cases: add LOAD_INSTANCE holding SystemDictionary_lock
 933       // case 4: parallelCapable: allow competing threads to try
 934       // LOAD_INSTANCE in parallel
 935 
 936       if (!throw_circularity_error &amp;&amp; !class_has_been_loaded) {
 937         PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, NULL, THREAD);
 938         load_instance_added = true;
 939         // For class loaders that do not acquire the classloader object lock,
 940         // if they did not catch another thread holding LOAD_INSTANCE,
 941         // need a check analogous to the acquire ObjectLocker/find_class
 942         // i.e. now that we hold the LOAD_INSTANCE token on loading this class/CL
 943         // one final check if the load has already completed
 944         // class loaders holding the ObjectLock shouldn&#39;t find the class here
 945         InstanceKlass* check = find_class(d_hash, name, dictionary);
 946         if (check != NULL) {
 947           // Klass is already loaded, so return it after checking/adding protection domain
 948           k = check;
 949           class_has_been_loaded = true;
 950         }
 951       }
 952     }
 953 
 954     // must throw error outside of owning lock
 955     if (throw_circularity_error) {
 956       assert(!HAS_PENDING_EXCEPTION &amp;&amp; load_instance_added == false,&quot;circularity error cleanup&quot;);
 957       ResourceMark rm(THREAD);
 958       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), name-&gt;as_C_string());
 959     }
 960 
 961     if (!class_has_been_loaded) {
 962 
 963       // Do actual loading
 964       k = load_instance_class(name, class_loader, THREAD);
 965 
 966       // If everything was OK (no exceptions, no null return value), and
 967       // class_loader is NOT the defining loader, do a little more bookkeeping.
 968       if (!HAS_PENDING_EXCEPTION &amp;&amp; k != NULL &amp;&amp;
 969         k-&gt;class_loader() != class_loader()) {
 970 
 971         check_constraints(d_hash, k, class_loader, false, THREAD);
 972 
 973         // Need to check for a PENDING_EXCEPTION again; check_constraints
 974         // can throw but we may have to remove entry from the placeholder table below.
 975         if (!HAS_PENDING_EXCEPTION) {
 976           // Record dependency for non-parent delegation.
 977           // This recording keeps the defining class loader of the klass (k) found
 978           // from being unloaded while the initiating class loader is loaded
 979           // even if the reference to the defining class loader is dropped
 980           // before references to the initiating class loader.
 981           loader_data-&gt;record_dependency(k);
 982 
 983           { // Grabbing the Compile_lock prevents systemDictionary updates
 984             // during compilations.
 985             MutexLocker mu(THREAD, Compile_lock);
 986             update_dictionary(d_hash, p_index, p_hash,
 987               k, class_loader, THREAD);
 988           }
 989 
 990           if (JvmtiExport::should_post_class_load()) {
 991             Thread *thread = THREAD;
 992             assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 993             JvmtiExport::post_class_load((JavaThread *) thread, k);
 994           }
 995         }
 996       }
 997     } // load_instance_class
 998 
 999     if (load_instance_added == true) {
1000       // clean up placeholder entries for LOAD_INSTANCE success or error
1001       // This brackets the SystemDictionary updates for both defining
1002       // and initiating loaders
1003       MutexLocker mu(THREAD, SystemDictionary_lock);
1004       placeholders()-&gt;find_and_remove(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);
1005       SystemDictionary_lock-&gt;notify_all();
1006     }
1007   }
1008 
1009   if (HAS_PENDING_EXCEPTION || k == NULL) {
1010     return NULL;
1011   }
1012   if (class_load_start_event.should_commit()) {
1013     post_class_load_event(&amp;class_load_start_event, k, loader_data);
1014   }
1015 #ifdef ASSERT
1016   {
1017     ClassLoaderData* loader_data = k-&gt;class_loader_data();
1018     MutexLocker mu(THREAD, SystemDictionary_lock);
1019     InstanceKlass* kk = find_class(name, loader_data);
1020     assert(kk == k, &quot;should be present in dictionary&quot;);
1021   }
1022 #endif
1023 
1024   // return if the protection domain in NULL
1025   if (protection_domain() == NULL) return k;
1026 
1027   // Check the protection domain has the right access
1028   if (dictionary-&gt;is_valid_protection_domain(d_hash, name,
1029                                              protection_domain)) {
1030     return k;
1031   }
1032 
1033   // Verify protection domain. If it fails an exception is thrown
1034   validate_protection_domain(k, class_loader, protection_domain, CHECK_NULL);
1035 
1036   return k;
1037 }
1038 
1039 
1040 // This routine does not lock the system dictionary.
1041 //
1042 // Since readers don&#39;t hold a lock, we must make sure that system
1043 // dictionary entries are only removed at a safepoint (when only one
1044 // thread is running), and are added to in a safe way (all links must
1045 // be updated in an MT-safe manner).
1046 //
1047 // Callers should be aware that an entry could be added just after
1048 // _dictionary-&gt;bucket(index) is read here, so the caller will not see
1049 // the new entry.
1050 
1051 Klass* SystemDictionary::find(Symbol* class_name,
1052                               Handle class_loader,
1053                               Handle protection_domain,
1054                               TRAPS) {
1055 
1056   // The result of this call should be consistent with the result
1057   // of the call to resolve_instance_class_or_null().
1058   // See evaluation 6790209 and 4474172 for more details.
1059   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
1060   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader());
1061 
1062   if (loader_data == NULL) {
1063     // If the ClassLoaderData has not been setup,
1064     // then the class loader has no entries in the dictionary.
1065     return NULL;
1066   }
1067 
1068   Dictionary* dictionary = loader_data-&gt;dictionary();
1069   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
1070   return dictionary-&gt;find(d_hash, class_name,
1071                           protection_domain);
1072 }
1073 
1074 
1075 // Look for a loaded instance or array klass by name.  Do not do any loading.
1076 // return NULL in case of error.
1077 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
1078                                                       Handle class_loader,
1079                                                       Handle protection_domain,
1080                                                       TRAPS) {
1081   Klass* k = NULL;
1082   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1083 
1084   if (Signature::is_array(class_name)) {
1085     // The name refers to an array.  Parse the name.
1086     // dimension and object_key in FieldArrayInfo are assigned as a
1087     // side-effect of this call
1088     SignatureStream ss(class_name, false);
1089     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1090     BasicType t = ss.type();
1091     if (t != T_OBJECT &amp;&amp; t != T_INLINE_TYPE) {
1092       k = Universe::typeArrayKlassObj(t);
1093     } else {
1094       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1095     }
1096     if (k != NULL) {
1097       k = k-&gt;array_klass_or_null(ndims);
1098     }
1099   } else {
1100     k = find(class_name, class_loader, protection_domain, THREAD);
1101   }
1102   return k;
1103 }
1104 
1105 // Note: this method is much like resolve_from_stream, but
1106 // does not publish the classes via the SystemDictionary.
1107 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
1108 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.
1109 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1110                                               Handle class_loader,
1111                                               ClassFileStream* st,
1112                                               const ClassLoadInfo&amp; cl_info,
1113                                               TRAPS) {
1114 
1115   EventClassLoad class_load_start_event;
1116   ClassLoaderData* loader_data;
1117   bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;
1118 
1119   // - for unsafe anonymous class: create a new CLD whith a class holder that uses
1120   //                               the same class loader as the unsafe_anonymous_host.
1121   // - for hidden classes that are not strong: create a new CLD that has a class holder and
1122   //                                           whose loader is the Lookup class&#39;s loader.
1123   // - for hidden class: add the class to the Lookup class&#39;s loader&#39;s CLD.
1124   if (is_unsafe_anon_class || cl_info.is_hidden()) {
1125     guarantee(!is_unsafe_anon_class || cl_info.unsafe_anonymous_host()-&gt;class_loader() == class_loader(),
1126               &quot;should be NULL or the same&quot;);
1127     bool create_mirror_cld = is_unsafe_anon_class || !cl_info.is_strong_hidden();
1128     loader_data = register_loader(class_loader, create_mirror_cld);
1129   } else {
1130     loader_data = ClassLoaderData::class_loader_data(class_loader());
1131   }
1132 
1133   assert(st != NULL, &quot;invariant&quot;);
1134   assert(st-&gt;need_verify(), &quot;invariant&quot;);
1135 
1136   // Parse stream and create a klass.
1137   // Note that we do this even though this klass might
1138   // already be present in the SystemDictionary, otherwise we would not
1139   // throw potential ClassFormatErrors.
1140 
1141   InstanceKlass* k = KlassFactory::create_from_stream(st,
1142                                                       class_name,
1143                                                       loader_data,
1144                                                       cl_info,
1145                                                       CHECK_NULL);
1146 
1147   if ((cl_info.is_hidden() || is_unsafe_anon_class) &amp;&amp; k != NULL) {
1148     // Hidden classes that are not strong and unsafe anonymous classes must update
1149     // ClassLoaderData holder so that they can be unloaded when the mirror is no
1150     // longer referenced.
1151     if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {
1152       k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));
1153     }
1154 
1155     {
1156       MutexLocker mu_r(THREAD, Compile_lock);
1157 
1158       // Add to class hierarchy, initialize vtables, and do possible
1159       // deoptimizations.
1160       add_to_hierarchy(k, CHECK_NULL); // No exception, but can block
1161       // But, do not add to dictionary.
1162     }
1163 
1164     // Rewrite and patch constant pool here.
1165     k-&gt;link_class(CHECK_NULL);
1166     if (cl_info.cp_patches() != NULL) {
1167       k-&gt;constants()-&gt;patch_resolved_references(cl_info.cp_patches());
1168     }
1169 
1170     // If it&#39;s anonymous, initialize it now, since nobody else will.
1171     if (is_unsafe_anon_class) {
1172       k-&gt;eager_initialize(CHECK_NULL);
1173     }
1174 
1175     // notify jvmti
1176     if (JvmtiExport::should_post_class_load()) {
1177         assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1178         JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1179     }
1180     if (class_load_start_event.should_commit()) {
1181       post_class_load_event(&amp;class_load_start_event, k, loader_data);
1182     }
1183   }
1184   assert(is_unsafe_anon_class || NULL == cl_info.cp_patches(),
1185          &quot;cp_patches only found with unsafe_anonymous_host&quot;);
1186 
1187   return k;
1188 }
1189 
1190 // Add a klass to the system from a stream (called by jni_DefineClass and
1191 // JVM_DefineClass).
1192 // Note: class_name can be NULL. In that case we do not know the name of
1193 // the class until we have parsed the stream.
1194 
1195 InstanceKlass* SystemDictionary::resolve_from_stream(Symbol* class_name,
1196                                                      Handle class_loader,
1197                                                      Handle protection_domain,
1198                                                      ClassFileStream* st,
1199                                                      TRAPS) {
1200 
1201   HandleMark hm(THREAD);
1202 
1203   // Classloaders that support parallelism, e.g. bootstrap classloader,
1204   // do not acquire lock here
1205   bool DoObjectLock = true;
1206   if (is_parallelCapable(class_loader)) {
1207     DoObjectLock = false;
1208   }
1209 
1210   ClassLoaderData* loader_data = register_loader(class_loader);
1211 
1212   // Make sure we are synchronized on the class loader before we proceed
1213   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1214   check_loader_lock_contention(lockObject, THREAD);
1215   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
1216 
1217   assert(st != NULL, &quot;invariant&quot;);
1218 
1219   // Parse the stream and create a klass.
1220   // Note that we do this even though this klass might
1221   // already be present in the SystemDictionary, otherwise we would not
1222   // throw potential ClassFormatErrors.
1223  InstanceKlass* k = NULL;
1224 
1225 #if INCLUDE_CDS
1226   if (!DumpSharedSpaces) {
1227     k = SystemDictionaryShared::lookup_from_stream(class_name,
1228                                                    class_loader,
1229                                                    protection_domain,
1230                                                    st,
1231                                                    CHECK_NULL);
1232   }
1233 #endif
1234 
1235   if (k == NULL) {
1236     if (st-&gt;buffer() == NULL) {
1237       return NULL;
1238     }
1239     ClassLoadInfo cl_info(protection_domain);
1240     k = KlassFactory::create_from_stream(st, class_name, loader_data, cl_info, CHECK_NULL);
1241   }
1242 
1243   assert(k != NULL, &quot;no klass created&quot;);
1244   Symbol* h_name = k-&gt;name();
1245   assert(class_name == NULL || class_name == h_name, &quot;name mismatch&quot;);
1246 
1247   // Add class just loaded
1248   // If a class loader supports parallel classloading handle parallel define requests
1249   // find_or_define_instance_class may return a different InstanceKlass
1250   if (is_parallelCapable(class_loader)) {
1251     InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
1252     if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1253       // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1254       assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1255       loader_data-&gt;add_to_deallocate_list(k);
1256       k = defined_k;
1257     }
1258   } else {
1259     define_instance_class(k, THREAD);
1260   }
1261 
1262   // If defining the class throws an exception register &#39;k&#39; for cleanup.
1263   if (HAS_PENDING_EXCEPTION) {
1264     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1265     loader_data-&gt;add_to_deallocate_list(k);
1266     return NULL;
1267   }
1268 
1269   // Make sure we have an entry in the SystemDictionary on success
1270   debug_only( {
1271     MutexLocker mu(THREAD, SystemDictionary_lock);
1272 
1273     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1274     assert(check == k, &quot;should be present in the dictionary&quot;);
1275   } );
1276 
1277   return k;
1278 }
1279 
1280 #if INCLUDE_CDS
1281 // Load a class for boot loader from the shared spaces. This also
1282 // forces the super class and all interfaces to be loaded.
1283 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
1284                                                         PackageEntry* pkg_entry,
1285                                                         TRAPS) {
1286   assert(UseSharedSpaces, &quot;Sanity check&quot;);
1287   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1288   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
1289     return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);
1290   }
1291   return NULL;
1292 }
1293 
<a name="4" id="anc4"></a><span class="line-modified">1294 // Check if a shared class can be loaded by the specific classloader:</span>
<span class="line-removed">1295 //</span>
<span class="line-removed">1296 // NULL classloader:</span>
<span class="line-removed">1297 //   - Module class from &quot;modules&quot; jimage. ModuleEntry must be defined in the classloader.</span>
<span class="line-removed">1298 //   - Class from -Xbootclasspath/a. The class has no defined PackageEntry, or must</span>
<span class="line-removed">1299 //     be defined in an unnamed module.</span>
1300 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1301                                                InstanceKlass* ik,
1302                                                PackageEntry* pkg_entry,
1303                                                Handle class_loader, TRAPS) {
1304   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1305          &quot;Cannot use sharing if java.base is patched&quot;);
<a name="5" id="anc5"></a><span class="line-modified">1306   if (ik-&gt;shared_classpath_index() &lt; 0) {</span>
<span class="line-modified">1307     // path_index &lt; 0 indicates that the class is intended for a custom loader</span>
<span class="line-modified">1308     // and should not be loaded by boot/platform/app loaders</span>
<span class="line-modified">1309     if (is_builtin_class_loader(class_loader())) {</span>














1310       return false;
1311     } else {
1312       return true;
1313     }
1314   }
1315 
<a name="6" id="anc6"></a><span class="line-modified">1316   // skip class visibility check</span>

1317   if (MetaspaceShared::use_optimized_module_handling()) {
<a name="7" id="anc7"></a><span class="line-modified">1318     assert(SystemDictionary::is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD), &quot;Optimizing module handling failed.&quot;);</span>



1319     return true;
1320   }
1321   return is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD);
1322 }
1323 
1324 bool SystemDictionary::is_shared_class_visible_impl(Symbol* class_name,
<a name="8" id="anc8"></a><span class="line-modified">1325                                                InstanceKlass* ik,</span>
<span class="line-modified">1326                                                PackageEntry* pkg_entry,</span>
<span class="line-modified">1327                                                Handle class_loader, TRAPS) {</span>
<span class="line-modified">1328   int path_index = ik-&gt;shared_classpath_index();</span>
<span class="line-modified">1329   ClassLoaderData* loader_data = class_loader_data(class_loader);</span>
<span class="line-modified">1330   SharedClassPathEntry* ent =</span>
<span class="line-modified">1331             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);</span>
1332   if (!Universe::is_module_initialized()) {
<a name="9" id="anc9"></a><span class="line-modified">1333     assert(ent != NULL &amp;&amp; ent-&gt;is_modules_image(),</span>
1334            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1335     assert(class_loader.is_null(), &quot;sanity&quot;);
1336     return true;
1337   }
<a name="10" id="anc10"></a><span class="line-modified">1338   // Get the pkg_entry from the classloader</span>
<span class="line-modified">1339   ModuleEntry* mod_entry = NULL;</span>
<span class="line-modified">1340   TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry-&gt;name() :</span>
<span class="line-modified">1341                                                ClassLoader::package_from_class_name(class_name);</span>
<span class="line-removed">1342   if (pkg_name != NULL) {</span>
<span class="line-removed">1343     if (loader_data != NULL) {</span>
<span class="line-removed">1344       if (pkg_entry != NULL) {</span>
<span class="line-removed">1345         mod_entry = pkg_entry-&gt;module();</span>
<span class="line-removed">1346         // If the archived class is from a module that has been patched at runtime,</span>
<span class="line-removed">1347         // the class cannot be loaded from the archive.</span>
<span class="line-removed">1348         if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {</span>
<span class="line-removed">1349           return false;</span>
<span class="line-removed">1350         }</span>
<span class="line-removed">1351       }</span>
<span class="line-removed">1352     }</span>
<span class="line-removed">1353   }</span>
<span class="line-removed">1354 </span>
<span class="line-removed">1355   if (class_loader.is_null()) {</span>
<span class="line-removed">1356     assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);</span>
<span class="line-removed">1357     // The NULL classloader can load archived class originated from the</span>
<span class="line-removed">1358     // &quot;modules&quot; jimage and the -Xbootclasspath/a. For class from the</span>
<span class="line-removed">1359     // &quot;modules&quot; jimage, the PackageEntry/ModuleEntry must be defined</span>
<span class="line-removed">1360     // by the NULL classloader.</span>
<span class="line-removed">1361     if (mod_entry != NULL) {</span>
<span class="line-removed">1362       // PackageEntry/ModuleEntry is found in the classloader. Check if the</span>
<span class="line-removed">1363       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.</span>
<span class="line-removed">1364       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {</span>
<span class="line-removed">1365         return true; // Module class from the &quot;module&quot; jimage</span>
<span class="line-removed">1366       }</span>
1367     }
1368 
<a name="11" id="anc11"></a><span class="line-modified">1369     // If the archived class is not from the &quot;module&quot; jimage, the class can be</span>
<span class="line-modified">1370     // loaded by the NULL classloader if</span>
<span class="line-modified">1371     //</span>
<span class="line-modified">1372     // 1. the class is from the unamed package</span>
<span class="line-modified">1373     // 2. or, the class is not from a module defined in the NULL classloader</span>
<span class="line-modified">1374     // 3. or, the class is from an unamed module</span>
<span class="line-removed">1375     if (!ent-&gt;is_modules_image() &amp;&amp; ik-&gt;is_shared_boot_class()) {</span>
<span class="line-removed">1376       // the class is from the -Xbootclasspath/a</span>
<span class="line-removed">1377       if (pkg_name == NULL ||</span>
<span class="line-removed">1378           pkg_entry == NULL ||</span>
<span class="line-removed">1379           pkg_entry-&gt;in_unnamed_module()) {</span>
<span class="line-removed">1380         assert(mod_entry == NULL ||</span>
<span class="line-removed">1381                mod_entry == loader_data-&gt;unnamed_module(),</span>
<span class="line-removed">1382                &quot;the unnamed module is not defined in the classloader&quot;);</span>
<span class="line-removed">1383         return true;</span>
1384       }
<a name="12" id="anc12"></a>



1385     }
<a name="13" id="anc13"></a><span class="line-modified">1386     return false;</span>
<span class="line-modified">1387   } else {</span>
<span class="line-modified">1388     bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(</span>
<span class="line-modified">1389               ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));</span>



1390     return res;
1391   }
<a name="14" id="anc14"></a>

1392 }
1393 
1394 bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,
1395                                                      Handle class_loader,  Handle protection_domain,
1396                                                      bool is_superclass, TRAPS) {
1397   assert(super_type-&gt;is_shared(), &quot;must be&quot;);
1398 
1399   Klass *found = resolve_super_or_fail(child-&gt;name(), super_type-&gt;name(),
1400                                        class_loader, protection_domain, is_superclass, CHECK_0);
1401   if (found == super_type) {
1402     return true;
1403   } else {
1404     // The dynamically resolved super type is not the same as the one we used during dump time,
1405     // so we cannot use the child class.
1406     return false;
1407   }
1408 }
1409 
1410 bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
1411                                                       Handle protection_domain, TRAPS) {
1412   // Check the superclass and interfaces. They must be the same
1413   // as in dump time, because the layout of &lt;ik&gt; depends on
1414   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().
1415   //
1416   // If unexpected superclass or interfaces are found, we cannot
1417   // load &lt;ik&gt; from the shared archive.
1418 
1419   if (ik-&gt;super() != NULL &amp;&amp;
1420       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),
1421                                      class_loader, protection_domain, true, THREAD)) {
1422     return false;
1423   }
1424 
1425   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1426   int num_interfaces = interfaces-&gt;length();
1427   for (int index = 0; index &lt; num_interfaces; index++) {
1428     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {
1429       return false;
1430     }
1431   }
1432 
1433   return true;
1434 }
1435 
1436 InstanceKlass* SystemDictionary::load_shared_lambda_proxy_class(InstanceKlass* ik,
1437                                                                 Handle class_loader,
1438                                                                 Handle protection_domain,
1439                                                                 PackageEntry* pkg_entry,
1440                                                                 TRAPS) {
1441   InstanceKlass* shared_nest_host = SystemDictionaryShared::get_shared_nest_host(ik);
1442   assert(shared_nest_host-&gt;is_shared(), &quot;nest host must be in CDS archive&quot;);
1443   Symbol* cn = shared_nest_host-&gt;name();
1444   Klass *s = resolve_or_fail(cn, class_loader, protection_domain, true, CHECK_NULL);
1445   if (s != shared_nest_host) {
1446     // The dynamically resolved nest_host is not the same as the one we used during dump time,
1447     // so we cannot use ik.
1448     return NULL;
1449   } else {
1450     assert(s-&gt;is_shared(), &quot;must be&quot;);
1451   }
1452 
1453   // The lambda proxy class and its nest host have the same class loader and class loader data,
1454   // as verified in SystemDictionaryShared::add_lambda_proxy_class()
1455   assert(shared_nest_host-&gt;class_loader() == class_loader(), &quot;mismatched class loader&quot;);
1456   assert(shared_nest_host-&gt;class_loader_data() == ClassLoaderData::class_loader_data(class_loader()), &quot;mismatched class loader data&quot;);
1457   ik-&gt;set_nest_host(shared_nest_host, THREAD);
1458 
1459   InstanceKlass* loaded_ik = load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, CHECK_NULL);
1460 
1461   assert(shared_nest_host-&gt;is_same_class_package(ik),
1462          &quot;lambda proxy class and its nest host must be in the same package&quot;);
1463 
1464   return loaded_ik;
1465 }
1466 
1467 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1468                                                    Handle class_loader,
1469                                                    Handle protection_domain,
1470                                                    const ClassFileStream *cfs,
1471                                                    PackageEntry* pkg_entry,
1472                                                    TRAPS) {
1473   assert(ik != NULL, &quot;sanity&quot;);
1474   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1475   Symbol* class_name = ik-&gt;name();
1476 
1477   bool visible = is_shared_class_visible(
1478                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1479   if (!visible) {
1480     return NULL;
1481   }
1482 
1483   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1484     return NULL;
1485   }
1486 
1487 
1488   if (ik-&gt;has_inline_type_fields()) {
1489     for (AllFieldStream fs(ik-&gt;fields(), ik-&gt;constants()); !fs.done(); fs.next()) {
1490       if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE) {
1491         if (!fs.access_flags().is_static()) {
1492           // Pre-load inline class
1493           Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,
1494             class_loader, protection_domain, true, CHECK_NULL);
1495           Klass* k = ik-&gt;get_inline_type_field_klass_or_null(fs.index());
1496           if (real_k != k) {
1497             // oops, the app has substituted a different version of k!
1498             return NULL;
1499           }
1500         }
1501       }
1502     }
1503   }
1504 
1505   InstanceKlass* new_ik = NULL;
1506   // CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).
1507   // It will be skipped for shared VM hidden lambda proxy classes.
1508   if (!SystemDictionaryShared::is_hidden_lambda_proxy(ik)) {
1509     new_ik = KlassFactory::check_shared_class_file_load_hook(
1510       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1511   }
1512   if (new_ik != NULL) {
1513     // The class is changed by CFLH. Return the new class. The shared class is
1514     // not used.
1515     return new_ik;
1516   }
1517 
1518   // Adjust methods to recover missing data.  They need addresses for
1519   // interpreter entry points and their default native method address
1520   // must be reset.
1521 
1522   // Updating methods must be done under a lock so multiple
1523   // threads don&#39;t update these in parallel
1524   //
1525   // Shared classes are all currently loaded by either the bootstrap or
1526   // internal parallel class loaders, so this will never cause a deadlock
1527   // on a custom class loader lock.
1528 
1529   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1530   {
1531     HandleMark hm(THREAD);
1532     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1533     check_loader_lock_contention(lockObject, THREAD);
1534     ObjectLocker ol(lockObject, THREAD, true);
1535     // prohibited package check assumes all classes loaded from archive call
1536     // restore_unshareable_info which calls ik-&gt;set_package()
1537     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1538   }
1539 
1540   load_shared_class_misc(ik, loader_data, CHECK_NULL);
1541 
1542   if (ik-&gt;is_inline_klass()) {
1543     InlineKlass* vk = InlineKlass::cast(ik);
1544     oop val = ik-&gt;allocate_instance(CHECK_NULL);
1545     vk-&gt;set_default_value(val);
1546   }
1547 
1548   return ik;
1549 }
1550 
1551 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1552   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1553 
1554   // For boot loader, ensure that GetSystemPackage knows that a class in this
1555   // package was loaded.
1556   if (loader_data-&gt;is_the_null_class_loader_data()) {
1557     int path_index = ik-&gt;shared_classpath_index();
1558     ik-&gt;set_classpath_index(path_index, THREAD);
1559   }
1560 
1561   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1562     // Only dump the classes that can be stored into CDS archive
1563     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1564       ResourceMark rm(THREAD);
1565       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1566       classlist_file-&gt;flush();
1567     }
1568   }
1569 
1570   // notify a class loaded from shared object
1571   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1572 
1573   ik-&gt;set_has_passed_fingerprint_check(false);
1574   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1575     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1576     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1577     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1578       // This class matches with a class saved in an AOT library
1579       ik-&gt;set_has_passed_fingerprint_check(true);
1580     } else {
1581       if (log_is_enabled(Info, class, fingerprint)) {
1582         ResourceMark rm(THREAD);
1583         log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
1584       }
1585     }
1586   }
1587 }
1588 
1589 void SystemDictionary::quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) {
1590   assert(!Universe::is_fully_initialized(), &quot;We can make short cuts only during VM initialization&quot;);
1591   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1592   if (klass-&gt;class_loader_data() != NULL) {
1593     return;
1594   }
1595 
1596   // add super and interfaces first
1597   Klass* super = klass-&gt;super();
1598   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1599     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1600     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1601   }
1602 
1603   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1604   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1605     InstanceKlass* ik = ifs-&gt;at(i);
1606     if (ik-&gt;class_loader_data()  == NULL) {
1607       quick_resolve(ik, loader_data, domain, CHECK);
1608     }
1609   }
1610 
1611   if (klass-&gt;has_inline_type_fields()) {
1612     for (AllFieldStream fs(klass-&gt;fields(), klass-&gt;constants()); !fs.done(); fs.next()) {
1613       if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE) {
1614         if (!fs.access_flags().is_static()) {
1615           Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,
1616             Handle(THREAD, loader_data-&gt;class_loader()), domain, true, CHECK);
1617           Klass* k = klass-&gt;get_inline_type_field_klass_or_null(fs.index());
1618           assert(real_k == k, &quot;oops, the app has substituted a different version of k!&quot;);
1619         } else {
1620           klass-&gt;reset_inline_type_field_klass(fs.index());
1621         }
1622       }
1623     }
1624   }
1625 
1626   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);
1627   load_shared_class_misc(klass, loader_data, CHECK);
1628   Dictionary* dictionary = loader_data-&gt;dictionary();
1629   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1630   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1631   add_to_hierarchy(klass, CHECK);
1632   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1633 }
1634 #endif // INCLUDE_CDS
1635 
1636 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1637 
1638   if (class_loader.is_null()) {
1639     ResourceMark rm(THREAD);
1640     PackageEntry* pkg_entry = NULL;
1641     bool search_only_bootloader_append = false;
1642     ClassLoaderData *loader_data = class_loader_data(class_loader);
1643 
1644     // Find the package in the boot loader&#39;s package entry table.
1645     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
1646     if (pkg_name != NULL) {
1647       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1648     }
1649 
1650     // Prior to attempting to load the class, enforce the boot loader&#39;s
1651     // visibility boundaries.
1652     if (!Universe::is_module_initialized()) {
1653       // During bootstrapping, prior to module initialization, any
1654       // class attempting to be loaded must be checked against the
1655       // java.base packages in the boot loader&#39;s PackageEntryTable.
1656       // No class outside of java.base is allowed to be loaded during
1657       // this bootstrapping window.
1658       if (pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1659         // Class is either in the unnamed package or in
1660         // a named package within the unnamed module.  Either
1661         // case is outside of java.base, do not attempt to
1662         // load the class post java.base definition.  If
1663         // java.base has not been defined, let the class load
1664         // and its package will be checked later by
1665         // ModuleEntryTable::verify_javabase_packages.
1666         if (ModuleEntryTable::javabase_defined()) {
1667           return NULL;
1668         }
1669       } else {
1670         // Check that the class&#39; package is defined within java.base.
1671         ModuleEntry* mod_entry = pkg_entry-&gt;module();
1672         Symbol* mod_entry_name = mod_entry-&gt;name();
1673         if (mod_entry_name-&gt;fast_compare(vmSymbols::java_base()) != 0) {
1674           return NULL;
1675         }
1676       }
1677     } else {
1678       // After the module system has been initialized, check if the class&#39;
1679       // package is in a module defined to the boot loader.
1680       if (pkg_name == NULL || pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1681         // Class is either in the unnamed package, in a named package
1682         // within a module not defined to the boot loader or in a
1683         // a named package within the unnamed module.  In all cases,
1684         // limit visibility to search for the class only in the boot
1685         // loader&#39;s append path.
1686         if (!ClassLoader::has_bootclasspath_append()) {
1687            // If there is no bootclasspath append entry, no need to continue
1688            // searching.
1689            return NULL;
1690         }
1691         search_only_bootloader_append = true;
1692       }
1693     }
1694 
1695     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1696     // of the boot loader&#39;s module path
1697     assert(Universe::is_module_initialized() ||
1698            !search_only_bootloader_append,
1699            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1700 
1701     // Search for classes in the CDS archive.
1702     InstanceKlass* k = NULL;
1703 
1704 #if INCLUDE_CDS
1705     if (UseSharedSpaces)
1706     {
1707       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
1708       k = load_shared_boot_class(class_name, pkg_entry, THREAD);
1709     }
1710 #endif
1711 
1712     if (k == NULL) {
1713       // Use VM class loader
1714       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
1715       k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);
1716     }
1717 
1718     // find_or_define_instance_class may return a different InstanceKlass
1719     if (k != NULL) {
1720       InstanceKlass* defined_k =
1721         find_or_define_instance_class(class_name, class_loader, k, THREAD);
1722       if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1723         // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1724         assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1725         loader_data-&gt;add_to_deallocate_list(k);
1726         k = defined_k;
1727       } else if (HAS_PENDING_EXCEPTION) {
1728         loader_data-&gt;add_to_deallocate_list(k);
1729         return NULL;
1730       }
1731     }
1732     return k;
1733   } else {
1734     // Use user specified class loader to load class. Call loadClass operation on class_loader.
1735     ResourceMark rm(THREAD);
1736 
1737     assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1738     JavaThread* jt = (JavaThread*) THREAD;
1739 
1740     PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(),
1741                                ClassLoader::perf_app_classload_selftime(),
1742                                ClassLoader::perf_app_classload_count(),
1743                                jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1744                                jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1745                                PerfClassTraceTime::CLASS_LOAD);
1746 
1747     Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);
1748     // Translate to external class name format, i.e., convert &#39;/&#39; chars to &#39;.&#39;
1749     Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);
1750 
1751     JavaValue result(T_OBJECT);
1752 
1753     InstanceKlass* spec_klass = SystemDictionary::ClassLoader_klass();
1754 
1755     // Call public unsynchronized loadClass(String) directly for all class loaders.
1756     // For parallelCapable class loaders, JDK &gt;=7, loadClass(String, boolean) will
1757     // acquire a class-name based lock rather than the class loader object lock.
1758     // JDK &lt; 7 already acquire the class loader lock in loadClass(String, boolean).
1759     JavaCalls::call_virtual(&amp;result,
1760                             class_loader,
1761                             spec_klass,
1762                             vmSymbols::loadClass_name(),
1763                             vmSymbols::string_class_signature(),
1764                             string,
1765                             CHECK_NULL);
1766 
1767     assert(result.get_type() == T_OBJECT, &quot;just checking&quot;);
1768     oop obj = (oop) result.get_jobject();
1769 
1770     // Primitive classes return null since forName() can not be
1771     // used to obtain any of the Class objects representing primitives or void
1772     if ((obj != NULL) &amp;&amp; !(java_lang_Class::is_primitive(obj))) {
1773       InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(obj));
1774       // For user defined Java class loaders, check that the name returned is
1775       // the same as that requested.  This check is done for the bootstrap
1776       // loader when parsing the class file.
1777       if (class_name == k-&gt;name()) {
1778         return k;
1779       }
1780     }
1781     // Class is not found or has the wrong name, return NULL
1782     return NULL;
1783   }
1784 }
1785 
1786 static void post_class_define_event(InstanceKlass* k, const ClassLoaderData* def_cld) {
1787   EventClassDefine event;
1788   if (event.should_commit()) {
1789     event.set_definedClass(k);
1790     event.set_definingClassLoader(def_cld);
1791     event.commit();
1792   }
1793 }
1794 
1795 void SystemDictionary::define_instance_class(InstanceKlass* k, TRAPS) {
1796 
1797   HandleMark hm(THREAD);
1798   ClassLoaderData* loader_data = k-&gt;class_loader_data();
1799   Handle class_loader_h(THREAD, loader_data-&gt;class_loader());
1800 
1801  // for bootstrap and other parallel classloaders don&#39;t acquire lock,
1802  // use placeholder token
1803  // If a parallelCapable class loader calls define_instance_class instead of
1804  // find_or_define_instance_class to get here, we have a timing
1805  // hole with systemDictionary updates and check_constraints
1806  if (!class_loader_h.is_null() &amp;&amp; !is_parallelCapable(class_loader_h)) {
1807     assert(ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD,
1808          compute_loader_lock_object(class_loader_h, THREAD)),
1809          &quot;define called without lock&quot;);
1810   }
1811 
1812   // Check class-loading constraints. Throw exception if violation is detected.
1813   // Grabs and releases SystemDictionary_lock
1814   // The check_constraints/find_class call and update_dictionary sequence
1815   // must be &quot;atomic&quot; for a specific class/classloader pair so we never
1816   // define two different instanceKlasses for that class/classloader pair.
1817   // Existing classloaders will call define_instance_class with the
1818   // classloader lock held
1819   // Parallel classloaders will call find_or_define_instance_class
1820   // which will require a token to perform the define class
1821   Symbol*  name_h = k-&gt;name();
1822   Dictionary* dictionary = loader_data-&gt;dictionary();
1823   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1824   check_constraints(d_hash, k, class_loader_h, true, CHECK);
1825 
1826   // Register class just loaded with class loader (placed in ArrayList)
1827   // Note we do this before updating the dictionary, as this can
1828   // fail with an OutOfMemoryError (if it does, we will *not* put this
1829   // class in the dictionary and will not update the class hierarchy).
1830   // JVMTI FollowReferences needs to find the classes this way.
1831   if (k-&gt;class_loader() != NULL) {
1832     methodHandle m(THREAD, Universe::loader_addClass_method());
1833     JavaValue result(T_VOID);
1834     JavaCallArguments args(class_loader_h);
1835     args.push_oop(Handle(THREAD, k-&gt;java_mirror()));
1836     JavaCalls::call(&amp;result, m, &amp;args, CHECK);
1837   }
1838 
1839   // Add the new class. We need recompile lock during update of CHA.
1840   {
1841     unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1842     int p_index = placeholders()-&gt;hash_to_index(p_hash);
1843 
1844     MutexLocker mu_r(THREAD, Compile_lock);
1845 
1846     // Add to class hierarchy, initialize vtables, and do possible
1847     // deoptimizations.
1848     add_to_hierarchy(k, CHECK); // No exception, but can block
1849 
1850     // Add to systemDictionary - so other classes can see it.
1851     // Grabs and releases SystemDictionary_lock
1852     update_dictionary(d_hash, p_index, p_hash,
1853                       k, class_loader_h, THREAD);
1854   }
1855   k-&gt;eager_initialize(THREAD);
1856 
1857   // notify jvmti
1858   if (JvmtiExport::should_post_class_load()) {
1859       assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1860       JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1861 
1862   }
1863   post_class_define_event(k, loader_data);
1864 }
1865 
1866 // Support parallel classloading
1867 // All parallel class loaders, including bootstrap classloader
1868 // lock a placeholder entry for this class/class_loader pair
1869 // to allow parallel defines of different classes for this class loader
1870 // With AllowParallelDefine flag==true, in case they do not synchronize around
1871 // FindLoadedClass/DefineClass, calls, we check for parallel
1872 // loading for them, wait if a defineClass is in progress
1873 // and return the initial requestor&#39;s results
1874 // This flag does not apply to the bootstrap classloader.
1875 // With AllowParallelDefine flag==false, call through to define_instance_class
1876 // which will throw LinkageError: duplicate class definition.
1877 // False is the requested default.
1878 // For better performance, the class loaders should synchronize
1879 // findClass(), i.e. FindLoadedClass/DefineClassIfAbsent or they
1880 // potentially waste time reading and parsing the bytestream.
1881 // Note: VM callers should ensure consistency of k/class_name,class_loader
1882 // Be careful when modifying this code: once you have run
1883 // placeholders()-&gt;find_and_add(PlaceholderTable::DEFINE_CLASS),
1884 // you need to find_and_remove it before returning.
1885 // So be careful to not exit with a CHECK_ macro betweeen these calls.
1886 InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,
1887                                                                InstanceKlass* k, TRAPS) {
1888 
1889   Symbol*  name_h = k-&gt;name(); // passed in class_name may be null
1890   ClassLoaderData* loader_data = class_loader_data(class_loader);
1891   Dictionary* dictionary = loader_data-&gt;dictionary();
1892 
1893   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1894 
1895   // Hold SD lock around find_class and placeholder creation for DEFINE_CLASS
1896   unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1897   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1898   PlaceholderEntry* probe;
1899 
1900   {
1901     MutexLocker mu(THREAD, SystemDictionary_lock);
1902     // First check if class already defined
1903     if (is_parallelDefine(class_loader)) {
1904       InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1905       if (check != NULL) {
1906         return check;
1907       }
1908     }
1909 
1910     // Acquire define token for this class/classloader
1911     probe = placeholders()-&gt;find_and_add(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, NULL, THREAD);
1912     // Wait if another thread defining in parallel
1913     // All threads wait - even those that will throw duplicate class: otherwise
1914     // caller is surprised by LinkageError: duplicate, but findLoadedClass fails
1915     // if other thread has not finished updating dictionary
1916     while (probe-&gt;definer() != NULL) {
1917       SystemDictionary_lock-&gt;wait();
1918     }
1919     // Only special cases allow parallel defines and can use other thread&#39;s results
1920     // Other cases fall through, and may run into duplicate defines
1921     // caught by finding an entry in the SystemDictionary
1922     if (is_parallelDefine(class_loader) &amp;&amp; (probe-&gt;instance_klass() != NULL)) {
1923         placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1924         SystemDictionary_lock-&gt;notify_all();
1925 #ifdef ASSERT
1926         InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1927         assert(check != NULL, &quot;definer missed recording success&quot;);
1928 #endif
1929         return probe-&gt;instance_klass();
1930     } else {
1931       // This thread will define the class (even if earlier thread tried and had an error)
1932       probe-&gt;set_definer(THREAD);
1933     }
1934   }
1935 
1936   define_instance_class(k, THREAD);
1937 
1938   Handle linkage_exception = Handle(); // null handle
1939 
1940   // definer must notify any waiting threads
1941   {
1942     MutexLocker mu(THREAD, SystemDictionary_lock);
1943     PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, name_h, loader_data);
1944     assert(probe != NULL, &quot;DEFINE_CLASS placeholder lost?&quot;);
1945     if (probe != NULL) {
1946       if (HAS_PENDING_EXCEPTION) {
1947         linkage_exception = Handle(THREAD,PENDING_EXCEPTION);
1948         CLEAR_PENDING_EXCEPTION;
1949       } else {
1950         probe-&gt;set_instance_klass(k);
1951       }
1952       probe-&gt;set_definer(NULL);
1953       placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1954       SystemDictionary_lock-&gt;notify_all();
1955     }
1956   }
1957 
1958   // Can&#39;t throw exception while holding lock due to rank ordering
1959   if (linkage_exception() != NULL) {
1960     THROW_OOP_(linkage_exception(), NULL); // throws exception and returns
1961   }
1962 
1963   return k;
1964 }
1965 
1966 Handle SystemDictionary::compute_loader_lock_object(Handle class_loader, TRAPS) {
1967   // If class_loader is NULL we synchronize on _system_loader_lock_obj
1968   if (class_loader.is_null()) {
1969     return Handle(THREAD, _system_loader_lock_obj.resolve());
1970   } else {
1971     return class_loader;
1972   }
1973 }
1974 
1975 // This method is added to check how often we have to wait to grab loader
1976 // lock. The results are being recorded in the performance counters defined in
1977 // ClassLoader::_sync_systemLoaderLockContentionRate and
1978 // ClassLoader::_sync_nonSystemLoaderLockConteionRate.
1979 void SystemDictionary::check_loader_lock_contention(Handle loader_lock, TRAPS) {
1980   if (!UsePerfData) {
1981     return;
1982   }
1983 
1984   assert(!loader_lock.is_null(), &quot;NULL lock object&quot;);
1985 
1986   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
1987       == ObjectSynchronizer::owner_other) {
1988     // contention will likely happen, so increment the corresponding
1989     // contention counter.
1990     if (loader_lock() == _system_loader_lock_obj.resolve()) {
1991       ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
1992     } else {
1993       ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
1994     }
1995   }
1996 }
1997 
1998 // ----------------------------------------------------------------------------
1999 // Lookup
2000 
2001 InstanceKlass* SystemDictionary::find_class(unsigned int hash,
2002                                             Symbol* class_name,
2003                                             Dictionary* dictionary) {
2004   assert_locked_or_safepoint(SystemDictionary_lock);
2005   int index = dictionary-&gt;hash_to_index(hash);
2006   return dictionary-&gt;find_class(index, hash, class_name);
2007 }
2008 
2009 
2010 // Basic find on classes in the midst of being loaded
2011 Symbol* SystemDictionary::find_placeholder(Symbol* class_name,
2012                                            ClassLoaderData* loader_data) {
2013   assert_locked_or_safepoint(SystemDictionary_lock);
2014   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);
2015   int p_index = placeholders()-&gt;hash_to_index(p_hash);
2016   return placeholders()-&gt;find_entry(p_index, p_hash, class_name, loader_data);
2017 }
2018 
2019 
2020 // Used for assertions and verification only
2021 // Precalculating the hash and index is an optimization because there are many lookups
2022 // before adding the class.
2023 InstanceKlass* SystemDictionary::find_class(Symbol* class_name, ClassLoaderData* loader_data) {
2024   assert_locked_or_safepoint(SystemDictionary_lock);
2025   #ifndef ASSERT
2026   guarantee(VerifyBeforeGC      ||
2027             VerifyDuringGC      ||
2028             VerifyBeforeExit    ||
2029             VerifyDuringStartup ||
2030             VerifyAfterGC, &quot;too expensive&quot;);
2031   #endif
2032 
2033   Dictionary* dictionary = loader_data-&gt;dictionary();
2034   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
2035   return find_class(d_hash, class_name, dictionary);
2036 }
2037 
2038 
2039 // ----------------------------------------------------------------------------
2040 // Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Recompile_lock
2041 // is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in
2042 // before a new class is used.
2043 
2044 void SystemDictionary::add_to_hierarchy(InstanceKlass* k, TRAPS) {
2045   assert(k != NULL, &quot;just checking&quot;);
2046   if (Universe::is_fully_initialized()) {
2047     assert_locked_or_safepoint(Compile_lock);
2048   }
2049 
2050   k-&gt;set_init_state(InstanceKlass::loaded);
2051   // make sure init_state store is already done.
2052   // The compiler reads the hierarchy outside of the Compile_lock.
2053   // Access ordering is used to add to hierarchy.
2054 
2055   // Link into hierachy.
2056   k-&gt;append_to_sibling_list();                    // add to superklass/sibling list
2057   k-&gt;process_interfaces(THREAD);                  // handle all &quot;implements&quot; declarations
2058 
2059   // Now flush all code that depended on old class hierarchy.
2060   // Note: must be done *after* linking k into the hierarchy (was bug 12/9/97)
2061   if (Universe::is_fully_initialized()) {
2062     CodeCache::flush_dependents_on(k);
2063   }
2064 }
2065 
2066 // ----------------------------------------------------------------------------
2067 // GC support
2068 
2069 // Assumes classes in the SystemDictionary are only unloaded at a safepoint
2070 // Note: anonymous classes are not in the SD.
2071 bool SystemDictionary::do_unloading(GCTimer* gc_timer) {
2072 
2073   bool unloading_occurred;
2074   bool is_concurrent = !SafepointSynchronize::is_at_safepoint();
2075   {
2076     GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
2077     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
2078     // First, mark for unload all ClassLoaderData referencing a dead class loader.
2079     unloading_occurred = ClassLoaderDataGraph::do_unloading();
2080     if (unloading_occurred) {
2081       MutexLocker ml2(is_concurrent ? Module_lock : NULL);
2082       JFR_ONLY(Jfr::on_unloading_classes();)
2083 
2084       MutexLocker ml1(is_concurrent ? SystemDictionary_lock : NULL);
2085       ClassLoaderDataGraph::clean_module_and_package_info();
2086       constraints()-&gt;purge_loader_constraints();
2087       resolution_errors()-&gt;purge_resolution_errors();
2088     }
2089   }
2090 
2091   GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);
2092 
2093   if (unloading_occurred) {
2094     SymbolTable::trigger_cleanup();
2095 
2096     // Oops referenced by the protection domain cache table may get unreachable independently
2097     // of the class loader (eg. cached protection domain oops). So we need to
2098     // explicitly unlink them here.
2099     // All protection domain oops are linked to the caller class, so if nothing
2100     // unloads, this is not needed.
2101     _pd_cache_table-&gt;trigger_cleanup();
2102   }
2103 
2104   return unloading_occurred;
2105 }
2106 
2107 // CDS: scan and relocate all classes referenced by _well_known_klasses[].
2108 void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
2109   for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
2110     it-&gt;push(well_known_klass_addr((WKID)id));
2111   }
2112 }
2113 
2114 void SystemDictionary::methods_do(void f(Method*)) {
2115   // Walk methods in loaded classes
2116   MutexLocker ml(ClassLoaderDataGraph_lock);
2117   ClassLoaderDataGraph::methods_do(f);
2118   // Walk method handle intrinsics
2119   invoke_method_table()-&gt;methods_do(f);
2120 }
2121 
2122 // ----------------------------------------------------------------------------
2123 // Initialization
2124 
2125 void SystemDictionary::initialize(TRAPS) {
2126   // Allocate arrays
2127   _placeholders        = new PlaceholderTable(_placeholder_table_size);
2128   _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);
2129   _resolution_errors   = new ResolutionErrorTable(_resolution_error_size);
2130   _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);
2131   _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);
2132 
2133   // Allocate private object used as system class loader lock
2134   oop lock_obj = oopFactory::new_intArray(0, CHECK);
<a name="15" id="anc15"></a><span class="line-modified">2135   _system_loader_lock_obj = OopHandle::create(lock_obj);</span>
2136 
2137   // Initialize basic classes
2138   resolve_well_known_classes(CHECK);
2139 }
2140 
2141 // Compact table of directions on the initialization of klasses:
2142 static const short wk_init_info[] = {
2143   #define WK_KLASS_INIT_INFO(name, symbol) \
2144     ((short)vmSymbols::VM_SYMBOL_ENUM_NAME(symbol)),
2145 
2146   WK_KLASSES_DO(WK_KLASS_INIT_INFO)
2147   #undef WK_KLASS_INIT_INFO
2148   0
2149 };
2150 
2151 #ifdef ASSERT
2152 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
2153   int sid;
2154   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
2155     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2156     if (class_name == symbol) {
2157       return true;
2158     }
2159   }
2160   return false;
2161 }
2162 #endif
2163 
2164 bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {
2165   assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
2166   int sid = wk_init_info[id - FIRST_WKID];
2167   Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2168   InstanceKlass** klassp = &amp;_well_known_klasses[id];
2169 
2170 #if INCLUDE_CDS
2171   if (UseSharedSpaces &amp;&amp; !JvmtiExport::should_post_class_prepare()) {
2172     InstanceKlass* k = *klassp;
2173     assert(k-&gt;is_shared_boot_class(), &quot;must be&quot;);
2174 
2175     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
2176     quick_resolve(k, loader_data, Handle(), CHECK_false);
2177     return true;
2178   }
2179 #endif // INCLUDE_CDS
2180 
2181   if (!is_wk_klass_loaded(*klassp)) {
2182     Klass* k = resolve_or_fail(symbol, true, CHECK_false);
2183     (*klassp) = InstanceKlass::cast(k);
2184   }
2185   return ((*klassp) != NULL);
2186 }
2187 
2188 void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS) {
2189   assert((int)start_id &lt;= (int)limit_id, &quot;IDs are out of order!&quot;);
2190   for (int id = (int)start_id; id &lt; (int)limit_id; id++) {
2191     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
2192     resolve_wk_klass((WKID)id, CHECK);
2193   }
2194 
2195   // move the starting value forward to the limit:
2196   start_id = limit_id;
2197 }
2198 
2199 void SystemDictionary::resolve_well_known_classes(TRAPS) {
2200   assert(!Object_klass_loaded(), &quot;well-known classes should only be initialized once&quot;);
2201 
2202   // Create the ModuleEntry for java.base.  This call needs to be done here,
2203   // after vmSymbols::initialize() is called but before any classes are pre-loaded.
2204   ClassLoader::classLoader_init2(CHECK);
2205 
2206   // Preload commonly used klasses
2207   WKID scan = FIRST_WKID;
2208   // first do Object, then String, Class
2209 #if INCLUDE_CDS
2210   if (UseSharedSpaces) {
2211     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Object_klass), scan, CHECK);
2212 
2213     // It&#39;s unsafe to access the archived heap regions before they
2214     // are fixed up, so we must do the fixup as early as possible
2215     // before the archived java objects are accessed by functions
2216     // such as java_lang_Class::restore_archived_mirror and
2217     // ConstantPool::restore_unshareable_info (restores the archived
2218     // resolved_references array object).
2219     //
2220     // HeapShared::fixup_mapped_heap_regions() fills the empty
2221     // spaces in the archived heap regions and may use
2222     // SystemDictionary::Object_klass(), so we can do this only after
2223     // Object_klass is resolved. See the above resolve_wk_klasses_through()
2224     // call. No mirror objects are accessed/restored in the above call.
2225     // Mirrors are restored after java.lang.Class is loaded.
2226     HeapShared::fixup_mapped_heap_regions();
2227 
2228     // Initialize the constant pool for the Object_class
2229     assert(Object_klass()-&gt;is_shared(), &quot;must be&quot;);
2230     Object_klass()-&gt;constants()-&gt;restore_unshareable_info(CHECK);
2231     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2232   } else
2233 #endif
2234   {
2235     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2236   }
2237 
2238   assert(WK_KLASS(Object_klass) != NULL, &quot;well-known classes should now be initialized&quot;);
2239 
2240   java_lang_Object::register_natives(CHECK);
2241 
2242   // Calculate offsets for String and Class classes since they are loaded and
2243   // can be used after this point.
2244   java_lang_String::compute_offsets();
2245   java_lang_Class::compute_offsets();
2246 
2247   // Fixup mirrors for classes loaded before java.lang.Class.
2248   Universe::initialize_basic_type_mirrors(CHECK);
2249   Universe::fixup_mirrors(CHECK);
2250 
2251   // do a bunch more:
2252   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
2253 
2254   // The offsets for jlr.Reference must be computed before
2255   // InstanceRefKlass::update_nonstatic_oop_maps is called. That function uses
2256   // the offsets to remove the referent and discovered fields from the oop maps,
2257   // as they are treated in a special way by the GC. Removing these oops from the
2258   // oop maps must be done before the usual subclasses of jlr.Reference are loaded.
2259   java_lang_ref_Reference::compute_offsets();
2260 
2261   // Preload ref klasses and set reference types
2262   WK_KLASS(Reference_klass)-&gt;set_reference_type(REF_OTHER);
2263   InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
2264 
2265   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
2266   WK_KLASS(SoftReference_klass)-&gt;set_reference_type(REF_SOFT);
2267   WK_KLASS(WeakReference_klass)-&gt;set_reference_type(REF_WEAK);
2268   WK_KLASS(FinalReference_klass)-&gt;set_reference_type(REF_FINAL);
2269   WK_KLASS(PhantomReference_klass)-&gt;set_reference_type(REF_PHANTOM);
2270 
2271   // JSR 292 classes
2272   WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
2273   WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
2274   resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
2275   resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
2276   WKID last = WKID_LIMIT;
2277   resolve_wk_klasses_until(last, scan, CHECK);
2278 
2279   _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
2280   _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
2281   _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
2282   _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);
2283   _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);
2284   _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);
2285   _box_klasses[T_INT]     = WK_KLASS(Integer_klass);
2286   _box_klasses[T_LONG]    = WK_KLASS(Long_klass);
2287   //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
2288   //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
2289 
2290 #ifdef ASSERT
2291   if (UseSharedSpaces) {
2292     JVMTI_ONLY(assert(JvmtiExport::is_early_phase(),
2293                       &quot;All well known classes must be resolved in JVMTI early phase&quot;));
2294     for (int i = FIRST_WKID; i &lt; last; i++) {
2295       InstanceKlass* k = _well_known_klasses[i];
2296       assert(k-&gt;is_shared(), &quot;must not be replaced by JVMTI class file load hook&quot;);
2297     }
2298   }
2299 #endif
2300 }
2301 
2302 // Tells if a given klass is a box (wrapper class, such as java.lang.Integer).
2303 // If so, returns the basic type it holds.  If not, returns T_OBJECT.
2304 BasicType SystemDictionary::box_klass_type(Klass* k) {
2305   assert(k != NULL, &quot;&quot;);
2306   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
2307     if (_box_klasses[i] == k)
2308       return (BasicType)i;
2309   }
2310   return T_OBJECT;
2311 }
2312 
2313 // Constraints on class loaders. The details of the algorithm can be
2314 // found in the OOPSLA&#39;98 paper &quot;Dynamic Class Loading in the Java
2315 // Virtual Machine&quot; by Sheng Liang and Gilad Bracha.  The basic idea is
2316 // that the dictionary needs to maintain a set of contraints that
2317 // must be satisfied by all classes in the dictionary.
2318 // if defining is true, then LinkageError if already in dictionary
2319 // if initiating loader, then ok if InstanceKlass matches existing entry
2320 
2321 void SystemDictionary::check_constraints(unsigned int d_hash,
2322                                          InstanceKlass* k,
2323                                          Handle class_loader,
2324                                          bool defining,
2325                                          TRAPS) {
2326   ResourceMark rm(THREAD);
2327   stringStream ss;
2328   bool throwException = false;
2329 
2330   {
2331     Symbol *name = k-&gt;name();
2332     ClassLoaderData *loader_data = class_loader_data(class_loader);
2333 
2334     MutexLocker mu(THREAD, SystemDictionary_lock);
2335 
2336     InstanceKlass* check = find_class(d_hash, name, loader_data-&gt;dictionary());
2337     if (check != NULL) {
2338       // If different InstanceKlass - duplicate class definition,
2339       // else - ok, class loaded by a different thread in parallel.
2340       // We should only have found it if it was done loading and ok to use.
2341       // The dictionary only holds instance classes, placeholders
2342       // also hold array classes.
2343 
2344       assert(check-&gt;is_instance_klass(), &quot;noninstance in systemdictionary&quot;);
2345       if ((defining == true) || (k != check)) {
2346         throwException = true;
2347         ss.print(&quot;loader %s&quot;, loader_data-&gt;loader_name_and_id());
2348         ss.print(&quot; attempted duplicate %s definition for %s. (%s)&quot;,
2349                  k-&gt;external_kind(), k-&gt;external_name(), k-&gt;class_in_module_of_loader(false, true));
2350       } else {
2351         return;
2352       }
2353     }
2354 
2355 #ifdef ASSERT
2356     Symbol* ph_check = find_placeholder(name, loader_data);
2357     assert(ph_check == NULL || ph_check == name, &quot;invalid symbol&quot;);
2358 #endif
2359 
2360     if (throwException == false) {
2361       if (constraints()-&gt;check_or_update(k, class_loader, name) == false) {
2362         throwException = true;
2363         ss.print(&quot;loader constraint violation: loader %s&quot;, loader_data-&gt;loader_name_and_id());
2364         ss.print(&quot; wants to load %s %s.&quot;,
2365                  k-&gt;external_kind(), k-&gt;external_name());
2366         Klass *existing_klass = constraints()-&gt;find_constrained_klass(name, class_loader);
2367         if (existing_klass != NULL &amp;&amp; existing_klass-&gt;class_loader() != class_loader()) {
2368           ss.print(&quot; A different %s with the same name was previously loaded by %s. (%s)&quot;,
2369                    existing_klass-&gt;external_kind(),
2370                    existing_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
2371                    existing_klass-&gt;class_in_module_of_loader(false, true));
2372         } else {
2373           ss.print(&quot; (%s)&quot;, k-&gt;class_in_module_of_loader(false, true));
2374         }
2375       }
2376     }
2377   }
2378 
2379   // Throw error now if needed (cannot throw while holding
2380   // SystemDictionary_lock because of rank ordering)
2381   if (throwException == true) {
2382     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
2383   }
2384 }
2385 
2386 // Update class loader data dictionary - done after check_constraint and add_to_hierachy
2387 // have been called.
2388 void SystemDictionary::update_dictionary(unsigned int d_hash,
2389                                          int p_index, unsigned int p_hash,
2390                                          InstanceKlass* k,
2391                                          Handle class_loader,
2392                                          TRAPS) {
2393   // Compile_lock prevents systemDictionary updates during compilations
2394   assert_locked_or_safepoint(Compile_lock);
2395   Symbol*  name  = k-&gt;name();
2396   ClassLoaderData *loader_data = class_loader_data(class_loader);
2397 
2398   {
2399     MutexLocker mu1(THREAD, SystemDictionary_lock);
2400 
2401     // Make a new dictionary entry.
2402     Dictionary* dictionary = loader_data-&gt;dictionary();
2403     InstanceKlass* sd_check = find_class(d_hash, name, dictionary);
2404     if (sd_check == NULL) {
2405       dictionary-&gt;add_klass(d_hash, name, k);
2406     }
2407   #ifdef ASSERT
2408     sd_check = find_class(d_hash, name, dictionary);
2409     assert (sd_check != NULL, &quot;should have entry in dictionary&quot;);
2410     // Note: there may be a placeholder entry: for circularity testing
2411     // or for parallel defines
2412   #endif
2413     SystemDictionary_lock-&gt;notify_all();
2414   }
2415 }
2416 
2417 
2418 // Try to find a class name using the loader constraints.  The
2419 // loader constraints might know about a class that isn&#39;t fully loaded
2420 // yet and these will be ignored.
2421 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2422                     Symbol* class_name, Handle class_loader, TRAPS) {
2423 
2424   // First see if it has been loaded directly.
2425   // Force the protection domain to be null.  (This removes protection checks.)
2426   Handle no_protection_domain;
2427   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2428                                               no_protection_domain, CHECK_NULL);
2429   if (klass != NULL)
2430     return klass;
2431 
2432   // Now look to see if it has been loaded elsewhere, and is subject to
2433   // a loader constraint that would require this loader to return the
2434   // klass that is already loaded.
2435   if (Signature::is_array(class_name)) {
2436     // For array classes, their Klass*s are not kept in the
2437     // constraint table. The element Klass*s are.
2438     SignatureStream ss(class_name, false);
2439     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2440     BasicType t = ss.type();
2441     if (t != T_OBJECT &amp;&amp; t != T_INLINE_TYPE) {
2442       klass = Universe::typeArrayKlassObj(t);
2443     } else {
2444       MutexLocker mu(THREAD, SystemDictionary_lock);
2445       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2446     }
2447     // If element class already loaded, allocate array klass
2448     if (klass != NULL) {
2449       klass = klass-&gt;array_klass_or_null(ndims);
2450     }
2451   } else {
2452     MutexLocker mu(THREAD, SystemDictionary_lock);
2453     // Non-array classes are easy: simply check the constraint table.
2454     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2455   }
2456 
2457   return klass;
2458 }
2459 
2460 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2461                                              Klass* klass_being_linked,
2462                                              Handle class_loader1,
2463                                              Handle class_loader2,
2464                                              Thread* THREAD) {
2465   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2466   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2467 
2468   Symbol* constraint_name = NULL;
2469 
2470   if (!Signature::is_array(class_name)) {
2471     constraint_name = class_name;
2472   } else {
2473     // For array classes, their Klass*s are not kept in the
2474     // constraint table. The element classes are.
2475     SignatureStream ss(class_name, false);
2476     ss.skip_array_prefix();  // skip all &#39;[&#39;s
2477     if (!ss.has_envelope()) {
2478       return true;     // primitive types always pass
2479     }
2480     constraint_name = ss.as_symbol();
2481     // Increment refcount to keep constraint_name alive after
2482     // SignatureStream is destructed. It will be decremented below
2483     // before returning.
2484     constraint_name-&gt;increment_refcount();
2485   }
2486 
2487   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2488   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2489 
2490   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2491   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2492 
2493   {
2494     MutexLocker mu_s(THREAD, SystemDictionary_lock);
2495     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2496     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
2497     bool result = constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,
2498                                            klass2, class_loader2);
2499 #if INCLUDE_CDS
2500     if (Arguments::is_dumping_archive() &amp;&amp; klass_being_linked != NULL &amp;&amp;
2501         !klass_being_linked-&gt;is_shared()) {
2502          SystemDictionaryShared::record_linking_constraint(constraint_name,
2503                                      InstanceKlass::cast(klass_being_linked),
2504                                      class_loader1, class_loader2, THREAD);
2505     }
2506 #endif // INCLUDE_CDS
2507     if (Signature::is_array(class_name)) {
2508       constraint_name-&gt;decrement_refcount();
2509     }
2510     return result;
2511   }
2512 }
2513 
2514 // Add entry to resolution error table to record the error when the first
2515 // attempt to resolve a reference to a class has failed.
2516 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2517                                             Symbol* error, Symbol* message) {
2518   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2519   int index = resolution_errors()-&gt;hash_to_index(hash);
2520   {
2521     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2522     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2523   }
2524 }
2525 
2526 // Delete a resolution error for RedefineClasses for a constant pool is going away
2527 void SystemDictionary::delete_resolution_error(ConstantPool* pool) {
2528   resolution_errors()-&gt;delete_entry(pool);
2529 }
2530 
2531 // Lookup resolution error table. Returns error if found, otherwise NULL.
2532 Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
2533                                                 Symbol** message) {
2534   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2535   int index = resolution_errors()-&gt;hash_to_index(hash);
2536   {
2537     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2538     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2539     if (entry != NULL) {
2540       *message = entry-&gt;message();
2541       return entry-&gt;error();
2542     } else {
2543       return NULL;
2544     }
2545   }
2546 }
2547 
2548 // Add an entry to resolution error table to record an error in resolving or
2549 // validating a nest host. This is used to construct informative error
2550 // messages when IllegalAccessError&#39;s occur. If an entry already exists it will
2551 // be updated with the nest host error message.
2552 void SystemDictionary::add_nest_host_error(const constantPoolHandle&amp; pool,
2553                                            int which,
2554                                            const char* message) {
2555   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2556   int index = resolution_errors()-&gt;hash_to_index(hash);
2557   {
2558     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2559     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2560     if (entry != NULL) {
2561       assert(entry-&gt;nest_host_error() == NULL, &quot;Nest host error message already set!&quot;);
2562       entry-&gt;set_nest_host_error(message);
2563     } else {
2564       resolution_errors()-&gt;add_entry(index, hash, pool, which, message);
2565     }
2566   }
2567 }
2568 
2569 // Lookup any nest host error
2570 const char* SystemDictionary::find_nest_host_error(const constantPoolHandle&amp; pool, int which) {
2571   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2572   int index = resolution_errors()-&gt;hash_to_index(hash);
2573   {
2574     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2575     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2576     if (entry != NULL) {
2577       return entry-&gt;nest_host_error();
2578     } else {
2579       return NULL;
2580     }
2581   }
2582 }
2583 
2584 
2585 // Signature constraints ensure that callers and callees agree about
2586 // the meaning of type names in their signatures.  This routine is the
2587 // intake for constraints.  It collects them from several places:
2588 //
2589 //  * LinkResolver::resolve_method (if check_access is true) requires
2590 //    that the resolving class (the caller) and the defining class of
2591 //    the resolved method (the callee) agree on each type in the
2592 //    method&#39;s signature.
2593 //
2594 //  * LinkResolver::resolve_interface_method performs exactly the same
2595 //    checks.
2596 //
2597 //  * LinkResolver::resolve_field requires that the constant pool
2598 //    attempting to link to a field agree with the field&#39;s defining
2599 //    class about the type of the field signature.
2600 //
2601 //  * klassVtable::initialize_vtable requires that, when a class
2602 //    overrides a vtable entry allocated by a superclass, that the
2603 //    overriding method (i.e., the callee) agree with the superclass
2604 //    on each type in the method&#39;s signature.
2605 //
2606 //  * klassItable::initialize_itable requires that, when a class fills
2607 //    in its itables, for each non-abstract method installed in an
2608 //    itable, the method (i.e., the callee) agree with the interface
2609 //    on each type in the method&#39;s signature.
2610 //
2611 // All those methods have a boolean (check_access, checkconstraints)
2612 // which turns off the checks.  This is used from specialized contexts
2613 // such as bootstrapping, dumping, and debugging.
2614 //
2615 // No direct constraint is placed between the class and its
2616 // supertypes.  Constraints are only placed along linked relations
2617 // between callers and callees.  When a method overrides or implements
2618 // an abstract method in a supertype (superclass or interface), the
2619 // constraints are placed as if the supertype were the caller to the
2620 // overriding method.  (This works well, since callers to the
2621 // supertype have already established agreement between themselves and
2622 // the supertype.)  As a result of all this, a class can disagree with
2623 // its supertype about the meaning of a type name, as long as that
2624 // class neither calls a relevant method of the supertype, nor is
2625 // called (perhaps via an override) from the supertype.
2626 //
2627 //
2628 // SystemDictionary::check_signature_loaders(sig, klass_being_linked, l1, l2)
2629 //
2630 // Make sure all class components (including arrays) in the given
2631 // signature will be resolved to the same class in both loaders.
2632 // Returns the name of the type that failed a loader constraint check, or
2633 // NULL if no constraint failed.  No exception except OOME is thrown.
2634 // Arrays are not added to the loader constraint table, their elements are.
2635 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
2636                                                Klass* klass_being_linked,
2637                                                Handle loader1, Handle loader2,
2638                                                bool is_method, TRAPS)  {
2639   // Nothing to do if loaders are the same.
2640   if (loader1() == loader2()) {
2641     return NULL;
2642   }
2643 
2644   for (SignatureStream ss(signature, is_method); !ss.is_done(); ss.next()) {
2645     if (ss.is_reference()) {
2646       Symbol* sig = ss.as_symbol();
2647       // Note: In the future, if template-like types can take
2648       // arguments, we will want to recognize them and dig out class
2649       // names hiding inside the argument lists.
2650       if (!add_loader_constraint(sig, klass_being_linked, loader1, loader2, THREAD)) {
2651         return sig;
2652       }
2653     }
2654   }
2655   return NULL;
2656 }
2657 
2658 Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,
2659                                                        Symbol* signature,
2660                                                        TRAPS) {
2661   methodHandle empty;
2662   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2663          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2664          iid != vmIntrinsics::_invokeGeneric,
2665          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2666 
2667   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2668   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2669   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2670   methodHandle m;
2671   if (spe == NULL || spe-&gt;method() == NULL) {
2672     spe = NULL;
2673     // Must create lots of stuff here, but outside of the SystemDictionary lock.
2674     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);
2675     if (!Arguments::is_interpreter_only()) {
2676       // Generate a compiled form of the MH intrinsic.
2677       AdapterHandlerLibrary::create_native_wrapper(m);
2678       // Check if have the compiled code.
2679       if (!m-&gt;has_compiled_code()) {
2680         THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),
2681                        &quot;Out of space in CodeCache for method handle intrinsic&quot;);
2682       }
2683     }
2684     // Now grab the lock.  We might have to throw away the new method,
2685     // if a racing thread has managed to install one at the same time.
2686     {
2687       MutexLocker ml(THREAD, SystemDictionary_lock);
2688       spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2689       if (spe == NULL)
2690         spe = invoke_method_table()-&gt;add_entry(index, hash, signature, iid);
2691       if (spe-&gt;method() == NULL)
2692         spe-&gt;set_method(m());
2693     }
2694   }
2695 
2696   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2697   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2698          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2699          &quot;MH intrinsic invariant&quot;);
2700   return spe-&gt;method();
2701 }
2702 
2703 // Helper for unpacking the return value from linkMethod and linkCallSite.
2704 static Method* unpack_method_and_appendix(Handle mname,
2705                                           Klass* accessing_klass,
2706                                           objArrayHandle appendix_box,
2707                                           Handle* appendix_result,
2708                                           TRAPS) {
2709   if (mname.not_null()) {
2710     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2711     if (m != NULL) {
2712       oop appendix = appendix_box-&gt;obj_at(0);
2713       LogTarget(Info, methodhandles) lt;
2714       if (lt.develop_is_enabled()) {
2715         ResourceMark rm(THREAD);
2716         LogStream ls(lt);
2717         ls.print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));
2718         m-&gt;print_on(&amp;ls);
2719         if (appendix != NULL) { ls.print(&quot;appendix = &quot;); appendix-&gt;print_on(&amp;ls); }
2720         ls.cr();
2721       }
2722 
2723       (*appendix_result) = Handle(THREAD, appendix);
2724       // the target is stored in the cpCache and if a reference to this
2725       // MemberName is dropped we need a way to make sure the
2726       // class_loader containing this method is kept alive.
2727       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2728       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2729       this_key-&gt;record_dependency(m-&gt;method_holder());
2730       return mh();
2731     }
2732   }
2733   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2734 }
2735 
2736 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2737                                                      Symbol* name,
2738                                                      Symbol* signature,
2739                                                           Klass* accessing_klass,
2740                                                           Handle *appendix_result,
2741                                                           TRAPS) {
2742   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
2743   Handle method_type =
2744     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_NULL);
2745 
2746   int ref_kind = JVM_REF_invokeVirtual;
2747   oop name_oop = StringTable::intern(name, CHECK_NULL);
2748   Handle name_str (THREAD, name_oop);
2749   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_NULL);
2750   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2751 
2752   // This should not happen.  JDK code should take care of that.
2753   if (accessing_klass == NULL || method_type.is_null()) {
2754     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;);
2755   }
2756 
2757   // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
2758   JavaCallArguments args;
2759   args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
2760   args.push_int(ref_kind);
2761   args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
2762   args.push_oop(name_str);
2763   args.push_oop(method_type);
2764   args.push_oop(appendix_box);
2765   JavaValue result(T_OBJECT);
2766   JavaCalls::call_static(&amp;result,
2767                          SystemDictionary::MethodHandleNatives_klass(),
2768                          vmSymbols::linkMethod_name(),
2769                          vmSymbols::linkMethod_signature(),
2770                          &amp;args, CHECK_NULL);
2771   Handle mname(THREAD, (oop) result.get_jobject());
2772   return unpack_method_and_appendix(mname, accessing_klass, appendix_box, appendix_result, THREAD);
2773 }
2774 
2775 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2776 // We must ensure that all class loaders everywhere will reach this class, for any client.
2777 // This is a safe bet for public classes in java.lang, such as Object and String.
2778 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2779 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2780 static bool is_always_visible_class(oop mirror) {
2781   Klass* klass = java_lang_Class::as_Klass(mirror);
2782   if (klass-&gt;is_objArray_klass()) {
2783     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2784   }
2785   if (klass-&gt;is_typeArray_klass()) {
2786     return true; // primitive array
2787   }
2788   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2789   return klass-&gt;is_public() &amp;&amp;
2790          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2791           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2792 }
2793 
2794 // Find or construct the Java mirror (java.lang.Class instance) for
2795 // the given field type signature, as interpreted relative to the
2796 // given class loader.  Handles primitives, void, references, arrays,
2797 // and all other reflectable types, except method types.
2798 // N.B.  Code in reflection should use this entry point.
2799 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2800                                                    Klass* accessing_klass,
2801                                                    Handle class_loader,
2802                                                    Handle protection_domain,
2803                                                    SignatureStream::FailureMode failure_mode,
2804                                                    TRAPS) {
2805   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2806          &quot;one or the other, or perhaps neither&quot;);
2807 
2808   // What we have here must be a valid field descriptor,
2809   // and all valid field descriptors are supported.
2810   // Produce the same java.lang.Class that reflection reports.
2811   if (accessing_klass != NULL) {
2812     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2813     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2814   }
2815   ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);
2816   oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);
2817   if (mirror_oop == NULL) {
2818     return Handle();  // report failure this way
2819   }
2820   Handle mirror(THREAD, mirror_oop);
2821 
2822   if (accessing_klass != NULL) {
2823     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2824     Klass* sel_klass = java_lang_Class::as_Klass(mirror());
2825     if (sel_klass != NULL) {
2826       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_NH);
2827     }
2828   }
2829   return mirror;
2830 }
2831 
2832 
2833 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2834 // signature, as interpreted relative to the given class loader.
2835 // Because of class loader constraints, all method handle usage must be
2836 // consistent with this loader.
2837 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2838                                                  Klass* accessing_klass,
2839                                                  TRAPS) {
2840   Handle empty;
2841   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2842   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2843   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2844   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2845   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2846     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
2847     return Handle(THREAD, spe-&gt;method_type());
2848   } else if (!THREAD-&gt;can_call_java()) {
2849     warning(&quot;SystemDictionary::find_method_handle_type called from compiler thread&quot;);  // FIXME
2850     return Handle();  // do not attempt from within compiler, unless it was cached
2851   }
2852 
2853   Handle class_loader, protection_domain;
2854   if (accessing_klass != NULL) {
2855     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2856     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2857   }
2858   bool can_be_cached = true;
2859   int npts = ArgumentCount(signature).size();
2860   objArrayHandle pts = oopFactory::new_objArray_handle(SystemDictionary::Class_klass(), npts, CHECK_(empty));
2861   int arg = 0;
2862   Handle rt; // the return type from the signature
2863   ResourceMark rm(THREAD);
2864   for (SignatureStream ss(signature); !ss.is_done(); ss.next()) {
2865     oop mirror = NULL;
2866     if (can_be_cached) {
2867       // Use neutral class loader to lookup candidate classes to be placed in the cache.
2868       mirror = ss.as_java_mirror(Handle(), Handle(),
2869                                  SignatureStream::ReturnNull, CHECK_(empty));
2870       if (mirror == NULL || (ss.is_reference() &amp;&amp; !is_always_visible_class(mirror))) {
2871         // Fall back to accessing_klass context.
2872         can_be_cached = false;
2873       }
2874     }
2875     if (!can_be_cached) {
2876       // Resolve, throwing a real error if it doesn&#39;t work.
2877       mirror = ss.as_java_mirror(class_loader, protection_domain,
2878                                  SignatureStream::NCDFError, CHECK_(empty));
2879     }
2880     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2881     if (ss.at_return_type())
2882       rt = Handle(THREAD, mirror);
2883     else
2884       pts-&gt;obj_at_put(arg++, mirror);
2885 
2886     // Check accessibility.
2887     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2888       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2889       mirror = NULL;  // safety
2890       // Emulate ConstantPool::verify_constant_pool_resolve.
2891       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_(empty));
2892     }
2893   }
2894   assert(arg == npts, &quot;&quot;);
2895 
2896   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2897   JavaCallArguments args(Handle(THREAD, rt()));
2898   args.push_oop(pts);
2899   JavaValue result(T_OBJECT);
2900   JavaCalls::call_static(&amp;result,
2901                          SystemDictionary::MethodHandleNatives_klass(),
2902                          vmSymbols::findMethodHandleType_name(),
2903                          vmSymbols::findMethodHandleType_signature(),
2904                          &amp;args, CHECK_(empty));
2905   Handle method_type(THREAD, (oop) result.get_jobject());
2906 
2907   if (can_be_cached) {
2908     // We can cache this MethodType inside the JVM.
2909     MutexLocker ml(THREAD, SystemDictionary_lock);
2910     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2911     if (spe == NULL)
2912       spe = invoke_method_table()-&gt;add_entry(index, hash, signature, null_iid);
2913     if (spe-&gt;method_type() == NULL) {
2914       spe-&gt;set_method_type(method_type());
2915     }
2916   }
2917 
2918   // report back to the caller with the MethodType
2919   return method_type;
2920 }
2921 
2922 Handle SystemDictionary::find_field_handle_type(Symbol* signature,
2923                                                 Klass* accessing_klass,
2924                                                 TRAPS) {
2925   Handle empty;
2926   ResourceMark rm(THREAD);
2927   SignatureStream ss(signature, /*is_method=*/ false);
2928   if (!ss.is_done()) {
2929     Handle class_loader, protection_domain;
2930     if (accessing_klass != NULL) {
2931       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2932       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2933     }
2934     oop mirror = ss.as_java_mirror(class_loader, protection_domain, SignatureStream::NCDFError, CHECK_(empty));
2935     ss.next();
2936     if (ss.is_done()) {
2937       return Handle(THREAD, mirror);
2938     }
2939   }
2940   return empty;
2941 }
2942 
2943 // Ask Java code to find or construct a method handle constant.
2944 Handle SystemDictionary::link_method_handle_constant(Klass* caller,
2945                                                      int ref_kind, //e.g., JVM_REF_invokeVirtual
2946                                                      Klass* callee,
2947                                                      Symbol* name,
2948                                                      Symbol* signature,
2949                                                      TRAPS) {
2950   Handle empty;
2951   if (caller == NULL) {
2952     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad MH constant&quot;, empty);
2953   }
2954   Handle name_str      = java_lang_String::create_from_symbol(name,      CHECK_(empty));
2955   Handle signature_str = java_lang_String::create_from_symbol(signature, CHECK_(empty));
2956 
2957   // Put symbolic info from the MH constant into freshly created MemberName and resolve it.
2958   Handle mname = MemberName_klass()-&gt;allocate_instance_handle(CHECK_(empty));
2959   java_lang_invoke_MemberName::set_clazz(mname(), callee-&gt;java_mirror());
2960   java_lang_invoke_MemberName::set_name (mname(), name_str());
2961   java_lang_invoke_MemberName::set_type (mname(), signature_str());
2962   java_lang_invoke_MemberName::set_flags(mname(), MethodHandles::ref_kind_to_flags(ref_kind));
2963 
2964   if (ref_kind == JVM_REF_invokeVirtual &amp;&amp;
2965       MethodHandles::is_signature_polymorphic_public_name(callee, name)) {
2966     // Skip resolution for public signature polymorphic methods such as
2967     // j.l.i.MethodHandle.invoke()/invokeExact() and those on VarHandle
2968     // They require appendix argument which MemberName resolution doesn&#39;t handle.
2969     // There&#39;s special logic on JDK side to handle them
2970     // (see MethodHandles.linkMethodHandleConstant() and MethodHandles.findVirtualForMH()).
2971   } else {
2972     MethodHandles::resolve_MemberName(mname, caller, /*speculative_resolve*/false, CHECK_(empty));
2973   }
2974 
2975   // After method/field resolution succeeded, it&#39;s safe to resolve MH signature as well.
2976   Handle type = MethodHandles::resolve_MemberName_type(mname, caller, CHECK_(empty));
2977 
2978   // call java.lang.invoke.MethodHandleNatives::linkMethodHandleConstant(Class caller, int refKind, Class callee, String name, Object type) -&gt; MethodHandle
2979   JavaCallArguments args;
2980   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));  // the referring class
2981   args.push_int(ref_kind);
2982   args.push_oop(Handle(THREAD, callee-&gt;java_mirror()));  // the target class
2983   args.push_oop(name_str);
2984   args.push_oop(type);
2985   JavaValue result(T_OBJECT);
2986   JavaCalls::call_static(&amp;result,
2987                          SystemDictionary::MethodHandleNatives_klass(),
2988                          vmSymbols::linkMethodHandleConstant_name(),
2989                          vmSymbols::linkMethodHandleConstant_signature(),
2990                          &amp;args, CHECK_(empty));
2991   return Handle(THREAD, (oop) result.get_jobject());
2992 }
2993 
2994 // Ask Java to run a bootstrap method, in order to create a dynamic call site
2995 // while linking an invokedynamic op, or compute a constant for Dynamic_info CP entry
2996 // with linkage results being stored back into the bootstrap specifier.
2997 void SystemDictionary::invoke_bootstrap_method(BootstrapInfo&amp; bootstrap_specifier, TRAPS) {
2998   // Resolve the bootstrap specifier, its name, type, and static arguments
2999   bootstrap_specifier.resolve_bsm(CHECK);
3000 
3001   // This should not happen.  JDK code should take care of that.
3002   if (bootstrap_specifier.caller() == NULL || bootstrap_specifier.type_arg().is_null()) {
3003     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;Invalid bootstrap method invocation with no caller or type argument&quot;);
3004   }
3005 
3006   bool is_indy = bootstrap_specifier.is_method_call();
3007   objArrayHandle appendix_box;
3008   if (is_indy) {
3009     // Some method calls may require an appendix argument.  Arrange to receive it.
3010     appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK);
3011     assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
3012   }
3013 
3014   // call condy: java.lang.invoke.MethodHandleNatives::linkDynamicConstant(caller, condy_index, bsm, type, info)
3015   //       indy: java.lang.invoke.MethodHandleNatives::linkCallSite(caller, indy_index, bsm, name, mtype, info, &amp;appendix)
3016   JavaCallArguments args;
3017   args.push_oop(Handle(THREAD, bootstrap_specifier.caller_mirror()));
3018   args.push_int(bootstrap_specifier.bss_index());
3019   args.push_oop(bootstrap_specifier.bsm());
3020   args.push_oop(bootstrap_specifier.name_arg());
3021   args.push_oop(bootstrap_specifier.type_arg());
3022   args.push_oop(bootstrap_specifier.arg_values());
3023   if (is_indy) {
3024     args.push_oop(appendix_box);
3025   }
3026   JavaValue result(T_OBJECT);
3027   JavaCalls::call_static(&amp;result,
3028                          SystemDictionary::MethodHandleNatives_klass(),
3029                          is_indy ? vmSymbols::linkCallSite_name() : vmSymbols::linkDynamicConstant_name(),
3030                          is_indy ? vmSymbols::linkCallSite_signature() : vmSymbols::linkDynamicConstant_signature(),
3031                          &amp;args, CHECK);
3032 
3033   Handle value(THREAD, (oop) result.get_jobject());
3034   if (is_indy) {
3035     Handle appendix;
3036     Method* method = unpack_method_and_appendix(value,
3037                                                 bootstrap_specifier.caller(),
3038                                                 appendix_box,
3039                                                 &amp;appendix, CHECK);
3040     methodHandle mh(THREAD, method);
3041     bootstrap_specifier.set_resolved_method(mh, appendix);
3042   } else {
3043     bootstrap_specifier.set_resolved_value(value);
3044   }
3045 
3046   // sanity check
3047   assert(bootstrap_specifier.is_resolved() ||
3048          (bootstrap_specifier.is_method_call() &amp;&amp;
3049           bootstrap_specifier.resolved_method().not_null()), &quot;bootstrap method call failed&quot;);
3050 }
3051 
3052 // Protection domain cache table handling
3053 
3054 ProtectionDomainCacheEntry* SystemDictionary::cache_get(Handle protection_domain) {
3055   return _pd_cache_table-&gt;get(protection_domain);
3056 }
3057 
3058 // ----------------------------------------------------------------------------
3059 
3060 void SystemDictionary::print_on(outputStream *st) {
3061   CDS_ONLY(SystemDictionaryShared::print_on(st));
3062   GCMutexLocker mu(SystemDictionary_lock);
3063 
3064   ClassLoaderDataGraph::print_dictionary(st);
3065 
3066   // Placeholders
3067   placeholders()-&gt;print_on(st);
3068   st-&gt;cr();
3069 
3070   // loader constraints - print under SD_lock
3071   constraints()-&gt;print_on(st);
3072   st-&gt;cr();
3073 
3074   _pd_cache_table-&gt;print_on(st);
3075   st-&gt;cr();
3076 }
3077 
3078 void SystemDictionary::print() { print_on(tty); }
3079 
3080 void SystemDictionary::verify() {
3081   guarantee(constraints() != NULL,
3082             &quot;Verify of loader constraints failed&quot;);
3083   guarantee(placeholders()-&gt;number_of_entries() &gt;= 0,
3084             &quot;Verify of placeholders failed&quot;);
3085 
3086   GCMutexLocker mu(SystemDictionary_lock);
3087 
3088   // Verify dictionary
3089   ClassLoaderDataGraph::verify_dictionary();
3090 
3091   placeholders()-&gt;verify();
3092 
3093   // Verify constraint table
3094   guarantee(constraints() != NULL, &quot;Verify of loader constraints failed&quot;);
3095   constraints()-&gt;verify(placeholders());
3096 
3097   _pd_cache_table-&gt;verify();
3098 }
3099 
3100 void SystemDictionary::dump(outputStream *st, bool verbose) {
3101   assert_locked_or_safepoint(SystemDictionary_lock);
3102   if (verbose) {
3103     print_on(st);
3104   } else {
3105     CDS_ONLY(SystemDictionaryShared::print_table_statistics(st));
3106     ClassLoaderDataGraph::print_table_statistics(st);
3107     placeholders()-&gt;print_table_statistics(st, &quot;Placeholder Table&quot;);
3108     constraints()-&gt;print_table_statistics(st, &quot;LoaderConstraints Table&quot;);
3109     pd_cache_table()-&gt;print_table_statistics(st, &quot;ProtectionDomainCache Table&quot;);
3110   }
3111 }
3112 
3113 TableStatistics SystemDictionary::placeholders_statistics() {
3114   MutexLocker ml(SystemDictionary_lock);
3115   return placeholders()-&gt;statistics_calculate();
3116 }
3117 
3118 TableStatistics SystemDictionary::loader_constraints_statistics() {
3119   MutexLocker ml(SystemDictionary_lock);
3120   return constraints()-&gt;statistics_calculate();
3121 }
3122 
3123 TableStatistics SystemDictionary::protection_domain_cache_statistics() {
3124   MutexLocker ml(SystemDictionary_lock);
3125   return pd_cache_table()-&gt;statistics_calculate();
3126 }
3127 
3128 // Utility for dumping dictionaries.
3129 SystemDictionaryDCmd::SystemDictionaryDCmd(outputStream* output, bool heap) :
3130                                  DCmdWithParser(output, heap),
3131   _verbose(&quot;-verbose&quot;, &quot;Dump the content of each dictionary entry for all class loaders&quot;,
3132            &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
3133   _dcmdparser.add_dcmd_option(&amp;_verbose);
3134 }
3135 
3136 void SystemDictionaryDCmd::execute(DCmdSource source, TRAPS) {
3137   VM_DumpHashtable dumper(output(), VM_DumpHashtable::DumpSysDict,
3138                          _verbose.value());
3139   VMThread::execute(&amp;dumper);
3140 }
3141 
3142 int SystemDictionaryDCmd::num_arguments() {
3143   ResourceMark rm;
3144   SystemDictionaryDCmd* dcmd = new SystemDictionaryDCmd(NULL, false);
3145   if (dcmd != NULL) {
3146     DCmdMark mark(dcmd);
3147     return dcmd-&gt;_dcmdparser.num_arguments();
3148   } else {
3149     return 0;
3150   }
3151 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>