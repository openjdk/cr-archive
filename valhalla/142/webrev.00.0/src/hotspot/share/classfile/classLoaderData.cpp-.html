<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/classLoaderData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1  /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // A ClassLoaderData identifies the full set of class types that a class
 26 // loader&#39;s name resolution strategy produces for a given configuration of the
 27 // class loader.
 28 // Class types in the ClassLoaderData may be defined by from class file binaries
 29 // provided by the class loader, or from other class loader it interacts with
 30 // according to its name resolution strategy.
 31 //
 32 // Class loaders that implement a deterministic name resolution strategy
 33 // (including with respect to their delegation behavior), such as the boot, the
 34 // platform, and the system loaders of the JDK&#39;s built-in class loader
 35 // hierarchy, always produce the same linkset for a given configuration.
 36 //
 37 // ClassLoaderData carries information related to a linkset (e.g.,
 38 // metaspace holding its klass definitions).
 39 // The System Dictionary and related data structures (e.g., placeholder table,
 40 // loader constraints table) as well as the runtime representation of classes
 41 // only reference ClassLoaderData.
 42 //
 43 // Instances of java.lang.ClassLoader holds a pointer to a ClassLoaderData that
 44 // that represent the loader&#39;s &quot;linking domain&quot; in the JVM.
 45 //
 46 // The bootstrap loader (represented by NULL) also has a ClassLoaderData,
 47 // the singleton class the_null_class_loader_data().
 48 
 49 #include &quot;precompiled.hpp&quot;
 50 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 51 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
 52 #include &quot;classfile/dictionary.hpp&quot;
 53 #include &quot;classfile/javaClasses.hpp&quot;
 54 #include &quot;classfile/moduleEntry.hpp&quot;
 55 #include &quot;classfile/packageEntry.hpp&quot;
 56 #include &quot;classfile/symbolTable.hpp&quot;
 57 #include &quot;classfile/systemDictionary.hpp&quot;
 58 #include &quot;logging/log.hpp&quot;
 59 #include &quot;logging/logStream.hpp&quot;
 60 #include &quot;memory/allocation.inline.hpp&quot;
 61 #include &quot;memory/metadataFactory.hpp&quot;
 62 #include &quot;memory/resourceArea.hpp&quot;
 63 #include &quot;oops/access.inline.hpp&quot;
 64 #include &quot;oops/oop.inline.hpp&quot;
 65 #include &quot;oops/oopHandle.inline.hpp&quot;
 66 #include &quot;oops/inlineKlass.inline.hpp&quot;
 67 #include &quot;oops/weakHandle.inline.hpp&quot;
 68 #include &quot;runtime/atomic.hpp&quot;
 69 #include &quot;runtime/handles.inline.hpp&quot;
 70 #include &quot;runtime/mutex.hpp&quot;
 71 #include &quot;runtime/safepoint.hpp&quot;
 72 #include &quot;utilities/growableArray.hpp&quot;
 73 #include &quot;utilities/macros.hpp&quot;
 74 #include &quot;utilities/ostream.hpp&quot;
 75 
 76 ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = NULL;
 77 
 78 void ClassLoaderData::init_null_class_loader_data() {
 79   assert(_the_null_class_loader_data == NULL, &quot;cannot initialize twice&quot;);
 80   assert(ClassLoaderDataGraph::_head == NULL, &quot;cannot initialize twice&quot;);
 81 
 82   _the_null_class_loader_data = new ClassLoaderData(Handle(), false);
 83   ClassLoaderDataGraph::_head = _the_null_class_loader_data;
 84   assert(_the_null_class_loader_data-&gt;is_the_null_class_loader_data(), &quot;Must be&quot;);
 85 
 86   LogTarget(Trace, class, loader, data) lt;
 87   if (lt.is_enabled()) {
 88     ResourceMark rm;
 89     LogStream ls(lt);
 90     ls.print(&quot;create &quot;);
 91     _the_null_class_loader_data-&gt;print_value_on(&amp;ls);
 92     ls.cr();
 93   }
 94 }
 95 
 96 // Obtain and set the class loader&#39;s name within the ClassLoaderData so
 97 // it will be available for error messages, logging, JFR, etc.  The name
 98 // and klass are available after the class_loader oop is no longer alive,
 99 // during unloading.
100 void ClassLoaderData::initialize_name(Handle class_loader) {
101   Thread* THREAD = Thread::current();
102   ResourceMark rm(THREAD);
103 
104   // Obtain the class loader&#39;s name.  If the class loader&#39;s name was not
105   // explicitly set during construction, the CLD&#39;s _name field will be null.
106   oop cl_name = java_lang_ClassLoader::name(class_loader());
107   if (cl_name != NULL) {
108     const char* cl_instance_name = java_lang_String::as_utf8_string(cl_name);
109 
110     if (cl_instance_name != NULL &amp;&amp; cl_instance_name[0] != &#39;\0&#39;) {
111       _name = SymbolTable::new_symbol(cl_instance_name);
112     }
113   }
114 
115   // Obtain the class loader&#39;s name and identity hash.  If the class loader&#39;s
116   // name was not explicitly set during construction, the class loader&#39;s name and id
117   // will be set to the qualified class name of the class loader along with its
118   // identity hash.
119   // If for some reason the ClassLoader&#39;s constructor has not been run, instead of
120   // leaving the _name_and_id field null, fall back to the external qualified class
121   // name.  Thus CLD&#39;s _name_and_id field should never have a null value.
122   oop cl_name_and_id = java_lang_ClassLoader::nameAndId(class_loader());
123   const char* cl_instance_name_and_id =
124                   (cl_name_and_id == NULL) ? _class_loader_klass-&gt;external_name() :
125                                              java_lang_String::as_utf8_string(cl_name_and_id);
126   assert(cl_instance_name_and_id != NULL &amp;&amp; cl_instance_name_and_id[0] != &#39;\0&#39;, &quot;class loader has no name and id&quot;);
127   _name_and_id = SymbolTable::new_symbol(cl_instance_name_and_id);
128 }
129 
130 ClassLoaderData::ClassLoaderData(Handle h_class_loader, bool has_class_mirror_holder) :
131   _metaspace(NULL),
132   _metaspace_lock(new Mutex(Mutex::leaf+1, &quot;Metaspace allocation lock&quot;, true,
133                             Mutex::_safepoint_check_never)),
134   _unloading(false), _has_class_mirror_holder(has_class_mirror_holder),
135   _modified_oops(true), _accumulated_modified_oops(false),
136   // An unsafe anonymous class loader data doesn&#39;t have anything to keep
137   // it from being unloaded during parsing of the unsafe anonymous class.
138   // The null-class-loader should always be kept alive.
139   _keep_alive((has_class_mirror_holder || h_class_loader.is_null()) ? 1 : 0),
140   _claim(0),
141   _handles(),
142   _klasses(NULL), _packages(NULL), _modules(NULL), _unnamed_module(NULL), _dictionary(NULL),
143   _jmethod_ids(NULL),
144   _deallocate_list(NULL),
145   _next(NULL),
146   _class_loader_klass(NULL), _name(NULL), _name_and_id(NULL) {
147 
148   if (!h_class_loader.is_null()) {
149     _class_loader = _handles.add(h_class_loader());
150     _class_loader_klass = h_class_loader-&gt;klass();
151     initialize_name(h_class_loader);
152   }
153 
154   if (!has_class_mirror_holder) {
155     // The holder is initialized later for non-strong hidden classes and unsafe anonymous classes,
156     // and before calling anything that call class_loader().
157     initialize_holder(h_class_loader);
158 
159     // A ClassLoaderData created solely for a non-strong hidden class or unsafe anonymous class should
160     // never have a ModuleEntryTable or PackageEntryTable created for it. The defining package
161     // and module for an unsafe anonymous class will be found in its host class.
162     _packages = new PackageEntryTable(PackageEntryTable::_packagetable_entry_size);
163     if (h_class_loader.is_null()) {
164       // Create unnamed module for boot loader
165       _unnamed_module = ModuleEntry::create_boot_unnamed_module(this);
166     } else {
167       // Create unnamed module for all other loaders
168       _unnamed_module = ModuleEntry::create_unnamed_module(this);
169     }
170     _dictionary = create_dictionary();
171   }
172 
173   NOT_PRODUCT(_dependency_count = 0); // number of class loader dependencies
174 
175   JFR_ONLY(INIT_ID(this);)
176 }
177 
178 ClassLoaderData::ChunkedHandleList::~ChunkedHandleList() {
179   Chunk* c = _head;
180   while (c != NULL) {
181     Chunk* next = c-&gt;_next;
182     delete c;
183     c = next;
184   }
185 }
186 
187 OopHandle ClassLoaderData::ChunkedHandleList::add(oop o) {
188   if (_head == NULL || _head-&gt;_size == Chunk::CAPACITY) {
189     Chunk* next = new Chunk(_head);
190     Atomic::release_store(&amp;_head, next);
191   }
192   oop* handle = &amp;_head-&gt;_data[_head-&gt;_size];
193   NativeAccess&lt;IS_DEST_UNINITIALIZED&gt;::oop_store(handle, o);
194   Atomic::release_store(&amp;_head-&gt;_size, _head-&gt;_size + 1);
195   return OopHandle(handle);
196 }
197 
198 int ClassLoaderData::ChunkedHandleList::count() const {
199   int count = 0;
200   Chunk* chunk = _head;
201   while (chunk != NULL) {
202     count += chunk-&gt;_size;
203     chunk = chunk-&gt;_next;
204   }
205   return count;
206 }
207 
208 inline void ClassLoaderData::ChunkedHandleList::oops_do_chunk(OopClosure* f, Chunk* c, const juint size) {
209   for (juint i = 0; i &lt; size; i++) {
210     if (c-&gt;_data[i] != NULL) {
211       f-&gt;do_oop(&amp;c-&gt;_data[i]);
212     }
213   }
214 }
215 
216 void ClassLoaderData::ChunkedHandleList::oops_do(OopClosure* f) {
217   Chunk* head = Atomic::load_acquire(&amp;_head);
218   if (head != NULL) {
219     // Must be careful when reading size of head
220     oops_do_chunk(f, head, Atomic::load_acquire(&amp;head-&gt;_size));
221     for (Chunk* c = head-&gt;_next; c != NULL; c = c-&gt;_next) {
222       oops_do_chunk(f, c, c-&gt;_size);
223     }
224   }
225 }
226 
227 class VerifyContainsOopClosure : public OopClosure {
228   oop  _target;
229   bool _found;
230 
231  public:
232   VerifyContainsOopClosure(oop target) : _target(target), _found(false) {}
233 
234   void do_oop(oop* p) {
235     if (p != NULL &amp;&amp; NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(p) == _target) {
236       _found = true;
237     }
238   }
239 
240   void do_oop(narrowOop* p) {
241     // The ChunkedHandleList should not contain any narrowOop
242     ShouldNotReachHere();
243   }
244 
245   bool found() const {
246     return _found;
247   }
248 };
249 
250 bool ClassLoaderData::ChunkedHandleList::contains(oop p) {
251   VerifyContainsOopClosure cl(p);
252   oops_do(&amp;cl);
253   return cl.found();
254 }
255 
256 #ifndef PRODUCT
257 bool ClassLoaderData::ChunkedHandleList::owner_of(oop* oop_handle) {
258   Chunk* chunk = _head;
259   while (chunk != NULL) {
260     if (&amp;(chunk-&gt;_data[0]) &lt;= oop_handle &amp;&amp; oop_handle &lt; &amp;(chunk-&gt;_data[chunk-&gt;_size])) {
261       return true;
262     }
263     chunk = chunk-&gt;_next;
264   }
265   return false;
266 }
267 #endif // PRODUCT
268 
269 void ClassLoaderData::clear_claim(int claim) {
270   for (;;) {
271     int old_claim = Atomic::load(&amp;_claim);
272     if ((old_claim &amp; claim) == 0) {
273       return;
274     }
275     int new_claim = old_claim &amp; ~claim;
276     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {
277       return;
278     }
279   }
280 }
281 
282 bool ClassLoaderData::try_claim(int claim) {
283   for (;;) {
284     int old_claim = Atomic::load(&amp;_claim);
285     if ((old_claim &amp; claim) == claim) {
286       return false;
287     }
288     int new_claim = old_claim | claim;
289     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {
290       return true;
291     }
292   }
293 }
294 
295 // Weak hidden and unsafe anonymous classes have their own ClassLoaderData that is marked to keep alive
296 // while the class is being parsed, and if the class appears on the module fixup list.
297 // Due to the uniqueness that no other class shares the hidden or unsafe anonymous class&#39; name or
298 // ClassLoaderData, no other non-GC thread has knowledge of the hidden or unsafe anonymous class while
299 // it is being defined, therefore _keep_alive is not volatile or atomic.
300 void ClassLoaderData::inc_keep_alive() {
301   if (has_class_mirror_holder()) {
302     assert(_keep_alive &gt; 0, &quot;Invalid keep alive increment count&quot;);
303     _keep_alive++;
304   }
305 }
306 
307 void ClassLoaderData::dec_keep_alive() {
308   if (has_class_mirror_holder()) {
309     assert(_keep_alive &gt; 0, &quot;Invalid keep alive decrement count&quot;);
310     _keep_alive--;
311   }
312 }
313 
314 void ClassLoaderData::oops_do(OopClosure* f, int claim_value, bool clear_mod_oops) {
315   if (claim_value != ClassLoaderData::_claim_none &amp;&amp; !try_claim(claim_value)) {
316     return;
317   }
318 
319   // Only clear modified_oops after the ClassLoaderData is claimed.
320   if (clear_mod_oops) {
321     clear_modified_oops();
322   }
323 
324   _handles.oops_do(f);
325 }
326 
327 void ClassLoaderData::classes_do(KlassClosure* klass_closure) {
328   // Lock-free access requires load_acquire
329   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
330     klass_closure-&gt;do_klass(k);
331     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
332   }
333 }
334 
335 void ClassLoaderData::classes_do(void f(Klass * const)) {
336   // Lock-free access requires load_acquire
337   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
338     f(k);
339     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
340   }
341 }
342 
343 void ClassLoaderData::methods_do(void f(Method*)) {
344   // Lock-free access requires load_acquire
345   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
346     if (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;is_loaded()) {
347       InstanceKlass::cast(k)-&gt;methods_do(f);
348     }
349   }
350 }
351 
352 void ClassLoaderData::loaded_classes_do(KlassClosure* klass_closure) {
353   // Lock-free access requires load_acquire
354   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
355     // Do not filter ArrayKlass oops here...
356     if (k-&gt;is_array_klass() || (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;is_loaded())) {
357 #ifdef ASSERT
358       oop m = k-&gt;java_mirror();
359       assert(m != NULL, &quot;NULL mirror&quot;);
360       assert(m-&gt;is_a(SystemDictionary::Class_klass()), &quot;invalid mirror&quot;);
361 #endif
362       klass_closure-&gt;do_klass(k);
363     }
364   }
365 }
366 
367 void ClassLoaderData::classes_do(void f(InstanceKlass*)) {
368   // Lock-free access requires load_acquire
369   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
370     if (k-&gt;is_instance_klass()) {
371       f(InstanceKlass::cast(k));
372     }
373     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
374   }
375 }
376 
377 void ClassLoaderData::inline_classes_do(void f(InlineKlass*)) {
378   // Lock-free access requires load_acquire
379   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
380     if (k-&gt;is_inline_klass()) {
381       f(InlineKlass::cast(k));
382     }
383     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
384   }
385 }
386 
387 void ClassLoaderData::modules_do(void f(ModuleEntry*)) {
388   assert_locked_or_safepoint(Module_lock);
389   if (_unnamed_module != NULL) {
390     f(_unnamed_module);
391   }
392   if (_modules != NULL) {
393     for (int i = 0; i &lt; _modules-&gt;table_size(); i++) {
394       for (ModuleEntry* entry = _modules-&gt;bucket(i);
395            entry != NULL;
396            entry = entry-&gt;next()) {
397         f(entry);
398       }
399     }
400   }
401 }
402 
403 void ClassLoaderData::packages_do(void f(PackageEntry*)) {
404   assert_locked_or_safepoint(Module_lock);
405   if (_packages != NULL) {
406     for (int i = 0; i &lt; _packages-&gt;table_size(); i++) {
407       for (PackageEntry* entry = _packages-&gt;bucket(i);
408            entry != NULL;
409            entry = entry-&gt;next()) {
410         f(entry);
411       }
412     }
413   }
414 }
415 
416 void ClassLoaderData::record_dependency(const Klass* k) {
417   assert(k != NULL, &quot;invariant&quot;);
418 
419   ClassLoaderData * const from_cld = this;
420   ClassLoaderData * const to_cld = k-&gt;class_loader_data();
421 
422   // Do not need to record dependency if the dependency is to a class whose
423   // class loader data is never freed.  (i.e. the dependency&#39;s class loader
424   // is one of the three builtin class loaders and the dependency&#39;s class
425   // loader data has a ClassLoader holder, not a Class holder.)
426   if (to_cld-&gt;is_permanent_class_loader_data()) {
427     return;
428   }
429 
430   oop to;
431   if (to_cld-&gt;has_class_mirror_holder()) {
432     // Just return if a non-strong hidden class or unsafe anonymous class is attempting to record a dependency
433     // to itself.  (Note that every non-strong hidden class or unsafe anonymous class has its own unique class
434     // loader data.)
435     if (to_cld == from_cld) {
436       return;
437     }
438     // Hidden and unsafe anonymous class dependencies are through the mirror.
439     to = k-&gt;java_mirror();
440   } else {
441     to = to_cld-&gt;class_loader();
442     oop from = from_cld-&gt;class_loader();
443 
444     // Just return if this dependency is to a class with the same or a parent
445     // class_loader.
446     if (from == to || java_lang_ClassLoader::isAncestor(from, to)) {
447       return; // this class loader is in the parent list, no need to add it.
448     }
449   }
450 
451   // It&#39;s a dependency we won&#39;t find through GC, add it.
452   if (!_handles.contains(to)) {
453     NOT_PRODUCT(Atomic::inc(&amp;_dependency_count));
454     LogTarget(Trace, class, loader, data) lt;
455     if (lt.is_enabled()) {
456       ResourceMark rm;
457       LogStream ls(lt);
458       ls.print(&quot;adding dependency from &quot;);
459       print_value_on(&amp;ls);
460       ls.print(&quot; to &quot;);
461       to_cld-&gt;print_value_on(&amp;ls);
462       ls.cr();
463     }
464     Handle dependency(Thread::current(), to);
465     add_handle(dependency);
466     // Added a potentially young gen oop to the ClassLoaderData
467     record_modified_oops();
468   }
469 }
470 
471 void ClassLoaderData::add_class(Klass* k, bool publicize /* true */) {
472   {
473     MutexLocker ml(metaspace_lock(), Mutex::_no_safepoint_check_flag);
474     Klass* old_value = _klasses;
475     k-&gt;set_next_link(old_value);
476     // Link the new item into the list, making sure the linked class is stable
477     // since the list can be walked without a lock
478     Atomic::release_store(&amp;_klasses, k);
479     if (k-&gt;is_array_klass()) {
480       ClassLoaderDataGraph::inc_array_classes(1);
481     } else {
482       ClassLoaderDataGraph::inc_instance_classes(1);
483     }
484   }
485 
486   if (publicize) {
487     LogTarget(Trace, class, loader, data) lt;
488     if (lt.is_enabled()) {
489       ResourceMark rm;
490       LogStream ls(lt);
491       ls.print(&quot;Adding k: &quot; PTR_FORMAT &quot; %s to &quot;, p2i(k), k-&gt;external_name());
492       print_value_on(&amp;ls);
493       ls.cr();
494     }
495   }
496 }
497 
498 void ClassLoaderData::initialize_holder(Handle loader_or_mirror) {
499   if (loader_or_mirror() != NULL) {
500     assert(_holder.is_null(), &quot;never replace holders&quot;);
501     _holder = WeakHandle&lt;vm_weak_data&gt;::create(loader_or_mirror);
502   }
503 }
504 
505 // Remove a klass from the _klasses list for scratch_class during redefinition
506 // or parsed class in the case of an error.
507 void ClassLoaderData::remove_class(Klass* scratch_class) {
508   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
509 
510   // Adjust global class iterator.
511   ClassLoaderDataGraph::adjust_saved_class(scratch_class);
512 
513   Klass* prev = NULL;
514   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
515     if (k == scratch_class) {
516       if (prev == NULL) {
517         _klasses = k-&gt;next_link();
518       } else {
519         Klass* next = k-&gt;next_link();
520         prev-&gt;set_next_link(next);
521       }
522 
523       if (k-&gt;is_array_klass()) {
524         ClassLoaderDataGraph::dec_array_classes(1);
525       } else {
526         ClassLoaderDataGraph::dec_instance_classes(1);
527       }
528 
529       return;
530     }
531     prev = k;
532     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
533   }
534   ShouldNotReachHere();   // should have found this class!!
535 }
536 
537 void ClassLoaderData::unload() {
538   _unloading = true;
539 
540   LogTarget(Trace, class, loader, data) lt;
541   if (lt.is_enabled()) {
542     ResourceMark rm;
543     LogStream ls(lt);
544     ls.print(&quot;unload&quot;);
545     print_value_on(&amp;ls);
546     ls.cr();
547   }
548 
549   // Some items on the _deallocate_list need to free their C heap structures
550   // if they are not already on the _klasses list.
551   free_deallocate_list_C_heap_structures();
552 
553   inline_classes_do(InlineKlass::cleanup);
554 
555   // Clean up class dependencies and tell serviceability tools
556   // these classes are unloading.  Must be called
557   // after erroneous classes are released.
558   classes_do(InstanceKlass::unload_class);
559 
560   // Clean up global class iterator for compiler
561   ClassLoaderDataGraph::adjust_saved_class(this);
562 }
563 
564 ModuleEntryTable* ClassLoaderData::modules() {
565   // Lazily create the module entry table at first request.
566   // Lock-free access requires load_acquire.
567   ModuleEntryTable* modules = Atomic::load_acquire(&amp;_modules);
568   if (modules == NULL) {
569     MutexLocker m1(Module_lock);
570     // Check if _modules got allocated while we were waiting for this lock.
571     if ((modules = _modules) == NULL) {
572       modules = new ModuleEntryTable(ModuleEntryTable::_moduletable_entry_size);
573 
574       {
575         MutexLocker m1(metaspace_lock(), Mutex::_no_safepoint_check_flag);
576         // Ensure _modules is stable, since it is examined without a lock
577         Atomic::release_store(&amp;_modules, modules);
578       }
579     }
580   }
581   return modules;
582 }
583 
584 const int _boot_loader_dictionary_size    = 1009;
585 const int _default_loader_dictionary_size = 107;
586 
587 Dictionary* ClassLoaderData::create_dictionary() {
588   assert(!has_class_mirror_holder(), &quot;class mirror holder cld does not have a dictionary&quot;);
589   int size;
590   bool resizable = false;
591   if (_the_null_class_loader_data == NULL) {
592     size = _boot_loader_dictionary_size;
593     resizable = true;
594   } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
595     size = 1;  // there&#39;s only one class in relection class loader and no initiated classes
596   } else if (is_system_class_loader_data()) {
597     size = _boot_loader_dictionary_size;
598     resizable = true;
599   } else {
600     size = _default_loader_dictionary_size;
601     resizable = true;
602   }
603   if (!DynamicallyResizeSystemDictionaries || DumpSharedSpaces) {
604     resizable = false;
605   }
606   return new Dictionary(this, size, resizable);
607 }
608 
609 // Tell the GC to keep this klass alive while iterating ClassLoaderDataGraph
610 oop ClassLoaderData::holder_phantom() const {
611   // A klass that was previously considered dead can be looked up in the
612   // CLD/SD, and its _java_mirror or _class_loader can be stored in a root
613   // or a reachable object making it alive again. The SATB part of G1 needs
614   // to get notified about this potential resurrection, otherwise the marking
615   // might not find the object.
616   if (!_holder.is_null()) {  // NULL class_loader
617     return _holder.resolve();
618   } else {
619     return NULL;
620   }
621 }
622 
623 // Let the GC read the holder without keeping it alive.
624 oop ClassLoaderData::holder_no_keepalive() const {
625   if (!_holder.is_null()) {  // NULL class_loader
626     return _holder.peek();
627   } else {
628     return NULL;
629   }
630 }
631 
632 // Unloading support
633 bool ClassLoaderData::is_alive() const {
634   bool alive = keep_alive()         // null class loader and incomplete non-strong hidden class or unsafe anonymous class.
635       || (_holder.peek() != NULL);  // and not cleaned by the GC weak handle processing.
636 
637   return alive;
638 }
639 
640 class ReleaseKlassClosure: public KlassClosure {
641 private:
642   size_t  _instance_class_released;
643   size_t  _array_class_released;
644 public:
645   ReleaseKlassClosure() : _instance_class_released(0), _array_class_released(0) { }
646 
647   size_t instance_class_released() const { return _instance_class_released; }
648   size_t array_class_released()    const { return _array_class_released;    }
649 
650   void do_klass(Klass* k) {
651     if (k-&gt;is_array_klass()) {
652       _array_class_released ++;
653     } else {
654       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
655       _instance_class_released ++;
656     }
657     k-&gt;release_C_heap_structures();
658   }
659 };
660 
661 ClassLoaderData::~ClassLoaderData() {
662   // Release C heap structures for all the classes.
663   ReleaseKlassClosure cl;
664   classes_do(&amp;cl);
665 
666   ClassLoaderDataGraph::dec_array_classes(cl.array_class_released());
667   ClassLoaderDataGraph::dec_instance_classes(cl.instance_class_released());
668 
669   // Release the WeakHandle
670   _holder.release();
671 
672   // Release C heap allocated hashtable for all the packages.
673   if (_packages != NULL) {
674     // Destroy the table itself
675     delete _packages;
676     _packages = NULL;
677   }
678 
679   // Release C heap allocated hashtable for all the modules.
680   if (_modules != NULL) {
681     // Destroy the table itself
682     delete _modules;
683     _modules = NULL;
684   }
685 
686   // Release C heap allocated hashtable for the dictionary
687   if (_dictionary != NULL) {
688     // Destroy the table itself
689     delete _dictionary;
690     _dictionary = NULL;
691   }
692 
693   if (_unnamed_module != NULL) {
694     _unnamed_module-&gt;delete_unnamed_module();
695     _unnamed_module = NULL;
696   }
697 
698   // release the metaspace
699   ClassLoaderMetaspace *m = _metaspace;
700   if (m != NULL) {
701     _metaspace = NULL;
702     delete m;
703   }
704   // Clear all the JNI handles for methods
705   // These aren&#39;t deallocated and are going to look like a leak, but that&#39;s
706   // needed because we can&#39;t really get rid of jmethodIDs because we don&#39;t
707   // know when native code is going to stop using them.  The spec says that
708   // they&#39;re &quot;invalid&quot; but existing programs likely rely on their being
709   // NULL after class unloading.
710   if (_jmethod_ids != NULL) {
711     Method::clear_jmethod_ids(this);
712   }
713   // Delete lock
714   delete _metaspace_lock;
715 
716   // Delete free list
717   if (_deallocate_list != NULL) {
718     delete _deallocate_list;
719   }
720 
721   // Decrement refcounts of Symbols if created.
722   if (_name != NULL) {
723     _name-&gt;decrement_refcount();
724   }
725   if (_name_and_id != NULL) {
726     _name_and_id-&gt;decrement_refcount();
727   }
728 }
729 
730 // Returns true if this class loader data is for the app class loader
731 // or a user defined system class loader.  (Note that the class loader
732 // data may have a Class holder.)
733 bool ClassLoaderData::is_system_class_loader_data() const {
734   return SystemDictionary::is_system_class_loader(class_loader());
735 }
736 
737 // Returns true if this class loader data is for the platform class loader.
738 // (Note that the class loader data may have a Class holder.)
739 bool ClassLoaderData::is_platform_class_loader_data() const {
740   return SystemDictionary::is_platform_class_loader(class_loader());
741 }
742 
743 // Returns true if the class loader for this class loader data is one of
744 // the 3 builtin (boot application/system or platform) class loaders,
745 // including a user-defined system class loader.  Note that if the class
746 // loader data is for a non-strong hidden class or unsafe anonymous class then it may
747 // get freed by a GC even if its class loader is one of these loaders.
748 bool ClassLoaderData::is_builtin_class_loader_data() const {
749   return (is_boot_class_loader_data() ||
750           SystemDictionary::is_system_class_loader(class_loader()) ||
751           SystemDictionary::is_platform_class_loader(class_loader()));
752 }
753 
754 // Returns true if this class loader data is a class loader data
755 // that is not ever freed by a GC.  It must be the CLD for one of the builtin
756 // class loaders and not the CLD for a non-strong hidden class or unsafe anonymous class.
757 bool ClassLoaderData::is_permanent_class_loader_data() const {
758   return is_builtin_class_loader_data() &amp;&amp; !has_class_mirror_holder();
759 }
760 
761 ClassLoaderMetaspace* ClassLoaderData::metaspace_non_null() {
762   // If the metaspace has not been allocated, create a new one.  Might want
763   // to create smaller arena for Reflection class loaders also.
764   // The reason for the delayed allocation is because some class loaders are
765   // simply for delegating with no metadata of their own.
766   // Lock-free access requires load_acquire.
767   ClassLoaderMetaspace* metaspace = Atomic::load_acquire(&amp;_metaspace);
768   if (metaspace == NULL) {
769     MutexLocker ml(_metaspace_lock,  Mutex::_no_safepoint_check_flag);
770     // Check if _metaspace got allocated while we were waiting for this lock.
771     if ((metaspace = _metaspace) == NULL) {
772       if (this == the_null_class_loader_data()) {
773         assert (class_loader() == NULL, &quot;Must be&quot;);
774         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::BootMetaspaceType);
775       } else if (has_class_mirror_holder()) {
776         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ClassMirrorHolderMetaspaceType);
777       } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
778         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);
779       } else {
780         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::StandardMetaspaceType);
781       }
782       // Ensure _metaspace is stable, since it is examined without a lock
783       Atomic::release_store(&amp;_metaspace, metaspace);
784     }
785   }
786   return metaspace;
787 }
788 
789 OopHandle ClassLoaderData::add_handle(Handle h) {
790   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
791   record_modified_oops();
792   return _handles.add(h());
793 }
794 
795 void ClassLoaderData::remove_handle(OopHandle h) {
796   assert(!is_unloading(), &quot;Do not remove a handle for a CLD that is unloading&quot;);
797   oop* ptr = h.ptr_raw();
798   if (ptr != NULL) {
799     assert(_handles.owner_of(ptr), &quot;Got unexpected handle &quot; PTR_FORMAT, p2i(ptr));
800     NativeAccess&lt;&gt;::oop_store(ptr, oop(NULL));
801   }
802 }
803 
804 void ClassLoaderData::init_handle_locked(OopHandle&amp; dest, Handle h) {
805   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
806   if (dest.resolve() != NULL) {
807     return;
808   } else {
809     dest = _handles.add(h());
810   }
811 }
812 
813 // Add this metadata pointer to be freed when it&#39;s safe.  This is only during
814 // a safepoint which checks if handles point to this metadata field.
815 void ClassLoaderData::add_to_deallocate_list(Metadata* m) {
816   // Metadata in shared region isn&#39;t deleted.
817   if (!m-&gt;is_shared()) {
818     MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
819     if (_deallocate_list == NULL) {
820       _deallocate_list = new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Metadata*&gt;(100, mtClass);
821     }
822     _deallocate_list-&gt;append_if_missing(m);
823     log_debug(class, loader, data)(&quot;deallocate added for %s&quot;, m-&gt;print_value_string());
824     ClassLoaderDataGraph::set_should_clean_deallocate_lists();
825   }
826 }
827 
828 // Deallocate free metadata on the free list.  How useful the PermGen was!
829 void ClassLoaderData::free_deallocate_list() {
830   // This must be called at a safepoint because it depends on metadata walking at
831   // safepoint cleanup time.
832   assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
833   assert(!is_unloading(), &quot;only called for ClassLoaderData that are not unloading&quot;);
834   if (_deallocate_list == NULL) {
835     return;
836   }
837   // Go backwards because this removes entries that are freed.
838   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
839     Metadata* m = _deallocate_list-&gt;at(i);
840     if (!m-&gt;on_stack()) {
841       _deallocate_list-&gt;remove_at(i);
842       // There are only three types of metadata that we deallocate directly.
843       // Cast them so they can be used by the template function.
844       if (m-&gt;is_method()) {
845         MetadataFactory::free_metadata(this, (Method*)m);
846       } else if (m-&gt;is_constantPool()) {
847         MetadataFactory::free_metadata(this, (ConstantPool*)m);
848       } else if (m-&gt;is_klass()) {
849         if (!((Klass*)m)-&gt;is_inline_klass()) {
850           MetadataFactory::free_metadata(this, (InstanceKlass*)m);
851         } else {
852           MetadataFactory::free_metadata(this, (InlineKlass*)m);
853         }
854       } else {
855         ShouldNotReachHere();
856       }
857     } else {
858       // Metadata is alive.
859       // If scratch_class is on stack then it shouldn&#39;t be on this list!
860       assert(!m-&gt;is_klass() || !((InstanceKlass*)m)-&gt;is_scratch_class(),
861              &quot;scratch classes on this list should be dead&quot;);
862       // Also should assert that other metadata on the list was found in handles.
863       // Some cleaning remains.
864       ClassLoaderDataGraph::set_should_clean_deallocate_lists();
865     }
866   }
867 }
868 
869 // This is distinct from free_deallocate_list.  For class loader data that are
870 // unloading, this frees the C heap memory for items on the list, and unlinks
871 // scratch or error classes so that unloading events aren&#39;t triggered for these
872 // classes. The metadata is removed with the unloading metaspace.
873 // There isn&#39;t C heap memory allocated for methods, so nothing is done for them.
874 void ClassLoaderData::free_deallocate_list_C_heap_structures() {
875   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
876   assert(is_unloading(), &quot;only called for ClassLoaderData that are unloading&quot;);
877   if (_deallocate_list == NULL) {
878     return;
879   }
880   // Go backwards because this removes entries that are freed.
881   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
882     Metadata* m = _deallocate_list-&gt;at(i);
883     _deallocate_list-&gt;remove_at(i);
884     if (m-&gt;is_constantPool()) {
885       ((ConstantPool*)m)-&gt;release_C_heap_structures();
886     } else if (m-&gt;is_klass()) {
887       InstanceKlass* ik = (InstanceKlass*)m;
888       // also releases ik-&gt;constants() C heap memory
889       ik-&gt;release_C_heap_structures();
890       // Remove the class so unloading events aren&#39;t triggered for
891       // this class (scratch or error class) in do_unloading().
892       remove_class(ik);
893     }
894   }
895 }
896 
897 // Caller needs ResourceMark
898 // If the class loader&#39;s _name has not been explicitly set, the class loader&#39;s
899 // qualified class name is returned.
900 const char* ClassLoaderData::loader_name() const {
901    if (_class_loader_klass == NULL) {
902      return BOOTSTRAP_LOADER_NAME;
903    } else if (_name != NULL) {
904      return _name-&gt;as_C_string();
905    } else {
906      return _class_loader_klass-&gt;external_name();
907    }
908 }
909 
910 // Caller needs ResourceMark
911 // Format of the _name_and_id is as follows:
912 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
913 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
914 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
915 const char* ClassLoaderData::loader_name_and_id() const {
916   if (_class_loader_klass == NULL) {
917     return &quot;&#39;&quot; BOOTSTRAP_LOADER_NAME &quot;&#39;&quot;;
918   } else if (_name_and_id != NULL) {
919     return _name_and_id-&gt;as_C_string();
920   } else {
921     // May be called in a race before _name_and_id is initialized.
922     return _class_loader_klass-&gt;external_name();
923   }
924 }
925 
926 void ClassLoaderData::print_value_on(outputStream* out) const {
927   if (!is_unloading() &amp;&amp; class_loader() != NULL) {
928     out-&gt;print(&quot;loader data: &quot; INTPTR_FORMAT &quot; for instance &quot;, p2i(this));
929     class_loader()-&gt;print_value_on(out);  // includes loader_name_and_id() and address of class loader instance
930   } else {
931     // loader data: 0xsomeaddr of &#39;bootstrap&#39;
932     out-&gt;print(&quot;loader data: &quot; INTPTR_FORMAT &quot; of %s&quot;, p2i(this), loader_name_and_id());
933   }
934   if (_has_class_mirror_holder) {
935     out-&gt;print(&quot; has a class holder&quot;);
936   }
937 }
938 
939 void ClassLoaderData::print_value() const { print_value_on(tty); }
940 
941 #ifndef PRODUCT
942 void ClassLoaderData::print_on(outputStream* out) const {
943   out-&gt;print(&quot;ClassLoaderData CLD: &quot; PTR_FORMAT &quot;, loader: &quot; PTR_FORMAT &quot;, loader_klass: %s {&quot;,
944               p2i(this), p2i(_class_loader.ptr_raw()), loader_name_and_id());
945   if (has_class_mirror_holder()) out-&gt;print(&quot; has a class holder&quot;);
946   if (claimed()) out-&gt;print(&quot; claimed&quot;);
947   if (is_unloading()) out-&gt;print(&quot; unloading&quot;);
948   out-&gt;print(&quot; metaspace: &quot; INTPTR_FORMAT, p2i(metaspace_or_null()));
949 
950   if (_jmethod_ids != NULL) {
951     Method::print_jmethod_ids(this, out);
952   }
953   out-&gt;print(&quot; handles count %d&quot;, _handles.count());
954   out-&gt;print(&quot; dependencies %d&quot;, _dependency_count);
955   out-&gt;print_cr(&quot;}&quot;);
956 }
957 #endif // PRODUCT
958 
959 void ClassLoaderData::print() const { print_on(tty); }
960 
961 void ClassLoaderData::verify() {
962   assert_locked_or_safepoint(_metaspace_lock);
963   oop cl = class_loader();
964 
965   guarantee(this == class_loader_data(cl) || has_class_mirror_holder(), &quot;Must be the same&quot;);
966   guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), &quot;must be&quot;);
967 
968   // Verify the integrity of the allocated space.
969   if (metaspace_or_null() != NULL) {
970     metaspace_or_null()-&gt;verify();
971   }
972 
973   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
974     guarantee(k-&gt;class_loader_data() == this, &quot;Must be the same&quot;);
975     k-&gt;verify();
976     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
977   }
978 }
979 
980 bool ClassLoaderData::contains_klass(Klass* klass) {
981   // Lock-free access requires load_acquire
982   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
983     if (k == klass) return true;
984   }
985   return false;
986 }
    </pre>
  </body>
</html>