<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/globalDefinitions.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../runtime/vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="growableArray.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/globalDefinitions.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 415 inline size_t pointer_delta(const MetaWord* left, const MetaWord* right) {
 416   return pointer_delta(left, right, sizeof(MetaWord));
 417 }
 418 
 419 //
 420 // ANSI C++ does not allow casting from one pointer type to a function pointer
 421 // directly without at best a warning. This macro accomplishes it silently
 422 // In every case that is present at this point the value be cast is a pointer
 423 // to a C linkage function. In some case the type used for the cast reflects
 424 // that linkage and a picky compiler would not complain. In other cases because
 425 // there is no convenient place to place a typedef with extern C linkage (i.e
 426 // a platform dependent header file) it doesn&#39;t. At this point no compiler seems
 427 // picky enough to catch these instances (which are few). It is possible that
 428 // using templates could fix these for all cases. This use of templates is likely
 429 // so far from the middle of the road that it is likely to be problematic in
 430 // many C++ compilers.
 431 //
 432 #define CAST_TO_FN_PTR(func_type, value) (reinterpret_cast&lt;func_type&gt;(value))
 433 #define CAST_FROM_FN_PTR(new_type, func_ptr) ((new_type)((address_word)(func_ptr)))
 434 





 435 // Unsigned byte types for os and stream.hpp
 436 
 437 // Unsigned one, two, four and eigth byte quantities used for describing
 438 // the .class file format. See JVM book chapter 4.
 439 
 440 typedef jubyte  u1;
 441 typedef jushort u2;
 442 typedef juint   u4;
 443 typedef julong  u8;
 444 
 445 const jubyte  max_jubyte  = (jubyte)-1;  // 0xFF       largest jubyte
 446 const jushort max_jushort = (jushort)-1; // 0xFFFF     largest jushort
 447 const juint   max_juint   = (juint)-1;   // 0xFFFFFFFF largest juint
 448 const julong  max_julong  = (julong)-1;  // 0xFF....FF largest julong
 449 
 450 typedef jbyte  s1;
 451 typedef jshort s2;
 452 typedef jint   s4;
 453 typedef jlong  s8;
 454 
</pre>
</td>
<td>
<hr />
<pre>
 415 inline size_t pointer_delta(const MetaWord* left, const MetaWord* right) {
 416   return pointer_delta(left, right, sizeof(MetaWord));
 417 }
 418 
 419 //
 420 // ANSI C++ does not allow casting from one pointer type to a function pointer
 421 // directly without at best a warning. This macro accomplishes it silently
 422 // In every case that is present at this point the value be cast is a pointer
 423 // to a C linkage function. In some case the type used for the cast reflects
 424 // that linkage and a picky compiler would not complain. In other cases because
 425 // there is no convenient place to place a typedef with extern C linkage (i.e
 426 // a platform dependent header file) it doesn&#39;t. At this point no compiler seems
 427 // picky enough to catch these instances (which are few). It is possible that
 428 // using templates could fix these for all cases. This use of templates is likely
 429 // so far from the middle of the road that it is likely to be problematic in
 430 // many C++ compilers.
 431 //
 432 #define CAST_TO_FN_PTR(func_type, value) (reinterpret_cast&lt;func_type&gt;(value))
 433 #define CAST_FROM_FN_PTR(new_type, func_ptr) ((new_type)((address_word)(func_ptr)))
 434 
<span class="line-added"> 435 // Need the correct linkage to call qsort without warnings</span>
<span class="line-added"> 436 extern &quot;C&quot; {</span>
<span class="line-added"> 437   typedef int (*_sort_Fn)(const void *, const void *);</span>
<span class="line-added"> 438 }</span>
<span class="line-added"> 439 </span>
 440 // Unsigned byte types for os and stream.hpp
 441 
 442 // Unsigned one, two, four and eigth byte quantities used for describing
 443 // the .class file format. See JVM book chapter 4.
 444 
 445 typedef jubyte  u1;
 446 typedef jushort u2;
 447 typedef juint   u4;
 448 typedef julong  u8;
 449 
 450 const jubyte  max_jubyte  = (jubyte)-1;  // 0xFF       largest jubyte
 451 const jushort max_jushort = (jushort)-1; // 0xFFFF     largest jushort
 452 const juint   max_juint   = (juint)-1;   // 0xFFFFFFFF largest juint
 453 const julong  max_julong  = (julong)-1;  // 0xFF....FF largest julong
 454 
 455 typedef jbyte  s1;
 456 typedef jshort s2;
 457 typedef jint   s4;
 458 typedef jlong  s8;
 459 
</pre>
</td>
</tr>
</table>
<center><a href="../runtime/vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="growableArray.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>