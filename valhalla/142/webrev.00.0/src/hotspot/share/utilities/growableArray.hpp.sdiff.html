<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/growableArray.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globalDefinitions.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/invoke/MemberName.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/growableArray.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_GROWABLEARRAY_HPP
 26 #define SHARE_UTILITIES_GROWABLEARRAY_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/array.hpp&quot;
 30 #include &quot;oops/oop.hpp&quot;

 31 #include &quot;utilities/debug.hpp&quot;
 32 #include &quot;utilities/globalDefinitions.hpp&quot;
 33 #include &quot;utilities/ostream.hpp&quot;
 34 #include &quot;utilities/powerOfTwo.hpp&quot;
 35 
 36 // A growable array.
 37 
 38 /*************************************************************************/
 39 /*                                                                       */
 40 /*     WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING   */
 41 /*                                                                       */
 42 /* Should you use GrowableArrays to contain handles you must be certain  */
<span class="line-modified"> 43 /* the the GrowableArray does not outlive the HandleMark that contains   */</span>
 44 /* the handles. Since GrowableArrays are typically resource allocated    */
 45 /* the following is an example of INCORRECT CODE,                        */
 46 /*                                                                       */
 47 /* ResourceMark rm;                                                      */
 48 /* GrowableArray&lt;Handle&gt;* arr = new GrowableArray&lt;Handle&gt;(size);         */
 49 /* if (blah) {                                                           */
 50 /*    while (...) {                                                      */
 51 /*      HandleMark hm;                                                   */
 52 /*      ...                                                              */
 53 /*      Handle h(THREAD, some_oop);                                      */
 54 /*      arr-&gt;append(h);                                                  */
 55 /*    }                                                                  */
 56 /* }                                                                     */
 57 /* if (arr-&gt;length() != 0 ) {                                            */
 58 /*    oop bad_oop = arr-&gt;at(0)(); // Handle is BAD HERE.                 */
 59 /*    ...                                                                */
 60 /* }                                                                     */
 61 /*                                                                       */
 62 /* If the GrowableArrays you are creating is C_Heap allocated then it    */
<span class="line-modified"> 63 /* hould not old handles since the handles could trivially try and       */</span>
 64 /* outlive their HandleMark. In some situations you might need to do     */
 65 /* this and it would be legal but be very careful and see if you can do  */
 66 /* the code in some other manner.                                        */
 67 /*                                                                       */
 68 /*************************************************************************/
 69 
<span class="line-modified"> 70 // To call default constructor the placement operator new() is used.</span>
<span class="line-removed"> 71 // It should be empty (it only returns the passed void* pointer).</span>
<span class="line-removed"> 72 // The definition of placement operator new(size_t, void*) in the &lt;new&gt;.</span>
 73 
<span class="line-modified"> 74 #include &lt;new&gt;</span>
<span class="line-removed"> 75 </span>
<span class="line-removed"> 76 // Need the correct linkage to call qsort without warnings</span>
<span class="line-removed"> 77 extern &quot;C&quot; {</span>
<span class="line-removed"> 78   typedef int (*_sort_Fn)(const void *, const void *);</span>
<span class="line-removed"> 79 }</span>
<span class="line-removed"> 80 </span>
 81 class GenericGrowableArray : public ResourceObj {
 82   friend class VMStructs;
 83 
<span class="line-modified"> 84  protected:</span>
<span class="line-modified"> 85   int    _len;          // current length</span>
<span class="line-modified"> 86   int    _max;          // maximum length</span>
<span class="line-modified"> 87   Arena* _arena;        // Indicates where allocation occurs:</span>
<span class="line-modified"> 88                         //   0 means default ResourceArea</span>
<span class="line-removed"> 89                         //   1 means on C heap</span>
<span class="line-removed"> 90                         //   otherwise, allocate in _arena</span>
<span class="line-removed"> 91 </span>
<span class="line-removed"> 92   MEMFLAGS   _memflags;   // memory type if allocation in C heap</span>
<span class="line-removed"> 93 </span>
<span class="line-removed"> 94 #ifdef ASSERT</span>
<span class="line-removed"> 95   int    _nesting;      // resource area nesting at creation</span>
<span class="line-removed"> 96   void   set_nesting();</span>
<span class="line-removed"> 97   void   check_nesting();</span>
<span class="line-removed"> 98 #else</span>
<span class="line-removed"> 99 #define  set_nesting();</span>
<span class="line-removed">100 #define  check_nesting();</span>
<span class="line-removed">101 #endif</span>
<span class="line-removed">102 </span>
<span class="line-removed">103   // Where are we going to allocate memory?</span>
<span class="line-removed">104   bool on_C_heap() { return _arena == (Arena*)1; }</span>
<span class="line-removed">105   bool on_stack () { return _arena == NULL;      }</span>
<span class="line-removed">106   bool on_arena () { return _arena &gt;  (Arena*)1;  }</span>
<span class="line-removed">107 </span>
<span class="line-removed">108   // This GA will use the resource stack for storage if c_heap==false,</span>
<span class="line-removed">109   // Else it will use the C heap.  Use clear_and_deallocate to avoid leaks.</span>
<span class="line-removed">110   GenericGrowableArray(int initial_size, int initial_len, MEMFLAGS flags) {</span>
<span class="line-removed">111     _len = initial_len;</span>
<span class="line-removed">112     _max = initial_size;</span>
<span class="line-removed">113     _memflags = flags;</span>
<span class="line-removed">114 </span>
<span class="line-removed">115     assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);</span>
<span class="line-removed">116 </span>
<span class="line-removed">117     const bool c_heap = flags != mtNone;</span>
<span class="line-removed">118     _arena = (c_heap ? (Arena*)1 : NULL);</span>
<span class="line-removed">119     set_nesting();</span>
<span class="line-removed">120     assert(!on_C_heap() || allocated_on_C_heap(), &quot;growable array must be on C heap if elements are&quot;);</span>
<span class="line-removed">121     assert(!on_stack() ||</span>
<span class="line-removed">122            (allocated_on_res_area() || allocated_on_stack()),</span>
<span class="line-removed">123            &quot;growable array must be on stack if elements are not on arena and not on C heap&quot;);</span>
<span class="line-removed">124   }</span>
125 
<span class="line-modified">126   // This GA will use the given arena for storage.</span>
<span class="line-modified">127   // Consider using new(arena) GrowableArray&lt;T&gt; to allocate the header.</span>
<span class="line-modified">128   GenericGrowableArray(Arena* arena, int initial_size, int initial_len) {</span>
<span class="line-removed">129     _len = initial_len;</span>
<span class="line-removed">130     _max = initial_size;</span>
131     assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);
<span class="line-removed">132     _arena = arena;</span>
<span class="line-removed">133     _memflags = mtNone;</span>
<span class="line-removed">134 </span>
<span class="line-removed">135     assert(on_arena(), &quot;arena has taken on reserved value 0 or 1&quot;);</span>
<span class="line-removed">136     // Relax next assert to allow object allocation on resource area,</span>
<span class="line-removed">137     // on stack or embedded into an other object.</span>
<span class="line-removed">138     assert(allocated_on_arena() || allocated_on_stack(),</span>
<span class="line-removed">139            &quot;growable array must be on arena or on stack if elements are on arena&quot;);</span>
140   }
141 
<span class="line-modified">142   void* raw_allocate(int elementSize);</span>
143 
<span class="line-removed">144   void free_C_heap(void* elements);</span>
<span class="line-removed">145 };</span>
<span class="line-removed">146 </span>
<span class="line-removed">147 template&lt;class E&gt; class GrowableArrayIterator;</span>
<span class="line-removed">148 template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator;</span>
<span class="line-removed">149 </span>
<span class="line-removed">150 template&lt;class E&gt;</span>
<span class="line-removed">151 class CompareClosure : public Closure {</span>
<span class="line-removed">152 public:</span>
<span class="line-removed">153     virtual int do_compare(const E&amp;, const E&amp;) = 0;</span>
<span class="line-removed">154 };</span>
<span class="line-removed">155 </span>
<span class="line-removed">156 template&lt;class E&gt; class GrowableArray : public GenericGrowableArray {</span>
<span class="line-removed">157   friend class VMStructs;</span>
<span class="line-removed">158 </span>
<span class="line-removed">159  private:</span>
<span class="line-removed">160   E*     _data;         // data array</span>
<span class="line-removed">161 </span>
<span class="line-removed">162   void grow(int j);</span>
<span class="line-removed">163   void raw_at_put_grow(int i, const E&amp; p, const E&amp; fill);</span>
<span class="line-removed">164   void  clear_and_deallocate();</span>
<span class="line-removed">165 </span>
<span class="line-removed">166 public:</span>
<span class="line-removed">167   GrowableArray(int initial_size, MEMFLAGS F = mtNone)</span>
<span class="line-removed">168     : GenericGrowableArray(initial_size, 0, F) {</span>
<span class="line-removed">169     _data = (E*)raw_allocate(sizeof(E));</span>
<span class="line-removed">170 // Needed for Visual Studio 2012 and older</span>
<span class="line-removed">171 #ifdef _MSC_VER</span>
<span class="line-removed">172 #pragma warning(suppress: 4345)</span>
<span class="line-removed">173 #endif</span>
<span class="line-removed">174     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();</span>
<span class="line-removed">175   }</span>
<span class="line-removed">176 </span>
<span class="line-removed">177   GrowableArray(int initial_size, int initial_len, const E&amp; filler, MEMFLAGS memflags = mtNone)</span>
<span class="line-removed">178     : GenericGrowableArray(initial_size, initial_len, memflags) {</span>
<span class="line-removed">179     _data = (E*)raw_allocate(sizeof(E));</span>
<span class="line-removed">180     int i = 0;</span>
<span class="line-removed">181     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);</span>
<span class="line-removed">182     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();</span>
<span class="line-removed">183   }</span>
<span class="line-removed">184 </span>
<span class="line-removed">185   // Watch out, if filler was generated by a constructor, the destuctor might</span>
<span class="line-removed">186   // be called on the original object invalidating all the copies made here.</span>
<span class="line-removed">187   // Carefully design the copy constructor.</span>
<span class="line-removed">188   GrowableArray(Arena* arena, int initial_size, int initial_len, const E&amp; filler) :</span>
<span class="line-removed">189       GenericGrowableArray(arena, initial_size, initial_len) {</span>
<span class="line-removed">190     _data = (E*)raw_allocate(sizeof(E));</span>
<span class="line-removed">191     int i = 0;</span>
<span class="line-removed">192     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);</span>
<span class="line-removed">193     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();</span>
<span class="line-removed">194   }</span>
<span class="line-removed">195 </span>
<span class="line-removed">196   GrowableArray() : GenericGrowableArray(2, 0, mtNone) {</span>
<span class="line-removed">197     _data = (E*)raw_allocate(sizeof(E));</span>
<span class="line-removed">198     ::new ((void*)&amp;_data[0]) E();</span>
<span class="line-removed">199     ::new ((void*)&amp;_data[1]) E();</span>
<span class="line-removed">200   }</span>
<span class="line-removed">201 </span>
<span class="line-removed">202                                 // Does nothing for resource and arena objects</span>
<span class="line-removed">203   ~GrowableArray()              { if (on_C_heap()) clear_and_deallocate(); }</span>
<span class="line-removed">204 </span>
205   void  clear()                 { _len = 0; }
206   int   length() const          { return _len; }
207   int   max_length() const      { return _max; }
<span class="line-modified">208   void  trunc_to(int l)         { assert(l &lt;= _len,&quot;cannot increase length&quot;); _len = l; }</span>
209   bool  is_empty() const        { return _len == 0; }
210   bool  is_nonempty() const     { return _len != 0; }
211   bool  is_full() const         { return _len == _max; }
<span class="line-modified">212   DEBUG_ONLY(E* data_addr() const      { return _data; })</span>
<span class="line-modified">213 </span>
<span class="line-modified">214   void print();</span>
<span class="line-modified">215 </span>
<span class="line-removed">216   int append(const E&amp; elem) {</span>
<span class="line-removed">217     check_nesting();</span>
<span class="line-removed">218     if (_len == _max) grow(_len);</span>
<span class="line-removed">219     int idx = _len++;</span>
<span class="line-removed">220     _data[idx] = elem;</span>
221     return idx;
222   }

223 
<span class="line-modified">224   bool append_if_missing(const E&amp; elem) {</span>
<span class="line-modified">225     // Returns TRUE if elem is added.</span>
<span class="line-modified">226     bool missed = !contains(elem);</span>
<span class="line-modified">227     if (missed) append(elem);</span>
<span class="line-modified">228     return missed;</span>
<span class="line-modified">229   }</span>















230 

231   E&amp; at(int i) {
232     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
233     return _data[i];
234   }
235 
236   E const&amp; at(int i) const {
237     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
238     return _data[i];
239   }
240 
241   E* adr_at(int i) const {
242     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
243     return &amp;_data[i];
244   }
245 
246   E first() const {
247     assert(_len &gt; 0, &quot;empty list&quot;);
248     return _data[0];
249   }
250 
251   E top() const {
252     assert(_len &gt; 0, &quot;empty list&quot;);
253     return _data[_len-1];
254   }
255 
256   E last() const {
257     return top();
258   }
259 
260   GrowableArrayIterator&lt;E&gt; begin() const {
261     return GrowableArrayIterator&lt;E&gt;(this, 0);
262   }
263 
264   GrowableArrayIterator&lt;E&gt; end() const {
265     return GrowableArrayIterator&lt;E&gt;(this, length());
266   }
267 
<span class="line-removed">268   void push(const E&amp; elem) { append(elem); }</span>
<span class="line-removed">269 </span>
270   E pop() {
271     assert(_len &gt; 0, &quot;empty list&quot;);
272     return _data[--_len];
273   }
274 
275   void at_put(int i, const E&amp; elem) {
276     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
277     _data[i] = elem;
278   }
279 
<span class="line-removed">280   E at_grow(int i, const E&amp; fill = E()) {</span>
<span class="line-removed">281     assert(0 &lt;= i, &quot;negative index&quot;);</span>
<span class="line-removed">282     check_nesting();</span>
<span class="line-removed">283     if (i &gt;= _len) {</span>
<span class="line-removed">284       if (i &gt;= _max) grow(i);</span>
<span class="line-removed">285       for (int j = _len; j &lt;= i; j++)</span>
<span class="line-removed">286         _data[j] = fill;</span>
<span class="line-removed">287       _len = i+1;</span>
<span class="line-removed">288     }</span>
<span class="line-removed">289     return _data[i];</span>
<span class="line-removed">290   }</span>
<span class="line-removed">291 </span>
<span class="line-removed">292   void at_put_grow(int i, const E&amp; elem, const E&amp; fill = E()) {</span>
<span class="line-removed">293     assert(0 &lt;= i, &quot;negative index&quot;);</span>
<span class="line-removed">294     check_nesting();</span>
<span class="line-removed">295     raw_at_put_grow(i, elem, fill);</span>
<span class="line-removed">296   }</span>
<span class="line-removed">297 </span>
298   bool contains(const E&amp; elem) const {
299     for (int i = 0; i &lt; _len; i++) {
300       if (_data[i] == elem) return true;
301     }
302     return false;
303   }
304 
305   int  find(const E&amp; elem) const {
306     for (int i = 0; i &lt; _len; i++) {
307       if (_data[i] == elem) return i;
308     }
309     return -1;
310   }
311 
312   int  find_from_end(const E&amp; elem) const {
313     for (int i = _len-1; i &gt;= 0; i--) {
314       if (_data[i] == elem) return i;
315     }
316     return -1;
317   }
</pre>
<hr />
<pre>
341     }
342     ShouldNotReachHere();
343   }
344 
345   // The order is preserved.
346   void remove_at(int index) {
347     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
348     for (int j = index + 1; j &lt; _len; j++) _data[j-1] = _data[j];
349     _len--;
350   }
351 
352   // The order is changed.
353   void delete_at(int index) {
354     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
355     if (index &lt; --_len) {
356       // Replace removed element with last one.
357       _data[index] = _data[_len];
358     }
359   }
360 
<span class="line-modified">361   // inserts the given element before the element at index i</span>
<span class="line-removed">362   void insert_before(const int idx, const E&amp; elem) {</span>
<span class="line-removed">363     assert(0 &lt;= idx &amp;&amp; idx &lt;= _len, &quot;illegal index&quot;);</span>
<span class="line-removed">364     check_nesting();</span>
<span class="line-removed">365     if (_len == _max) grow(_len);</span>
<span class="line-removed">366     for (int j = _len - 1; j &gt;= idx; j--) {</span>
<span class="line-removed">367       _data[j + 1] = _data[j];</span>
<span class="line-removed">368     }</span>
<span class="line-removed">369     _len++;</span>
<span class="line-removed">370     _data[idx] = elem;</span>
<span class="line-removed">371   }</span>
<span class="line-removed">372 </span>
<span class="line-removed">373   void insert_before(const int idx, const GrowableArray&lt;E&gt;* array) {</span>
<span class="line-removed">374     assert(0 &lt;= idx &amp;&amp; idx &lt;= _len, &quot;illegal index&quot;);</span>
<span class="line-removed">375     check_nesting();</span>
<span class="line-removed">376     int array_len = array-&gt;length();</span>
<span class="line-removed">377     int new_len = _len + array_len;</span>
<span class="line-removed">378     if (new_len &gt;= _max) grow(new_len);</span>
<span class="line-removed">379 </span>
<span class="line-removed">380     for (int j = _len - 1; j &gt;= idx; j--) {</span>
<span class="line-removed">381       _data[j + array_len] = _data[j];</span>
<span class="line-removed">382     }</span>
<span class="line-removed">383 </span>
<span class="line-removed">384     for (int j = 0; j &lt; array_len; j++) {</span>
<span class="line-removed">385       _data[idx + j] = array-&gt;_data[j];</span>
<span class="line-removed">386     }</span>
<span class="line-removed">387 </span>
<span class="line-removed">388     _len += array_len;</span>
<span class="line-removed">389   }</span>
<span class="line-removed">390 </span>
<span class="line-removed">391   void appendAll(const GrowableArray&lt;E&gt;* l) {</span>
<span class="line-removed">392     for (int i = 0; i &lt; l-&gt;_len; i++) {</span>
<span class="line-removed">393       raw_at_put_grow(_len, l-&gt;_data[i], E());</span>
<span class="line-removed">394     }</span>
<span class="line-removed">395   }</span>
<span class="line-removed">396 </span>
<span class="line-removed">397   void appendAll(const Array&lt;E&gt;* l) {</span>
<span class="line-removed">398     for (int i = 0; i &lt; l-&gt;length(); i++) {</span>
<span class="line-removed">399       raw_at_put_grow(_len, l-&gt;at(i), E());</span>
<span class="line-removed">400     }</span>
<span class="line-removed">401   }</span>
<span class="line-removed">402 </span>
<span class="line-removed">403   void sort(int f(E*,E*)) {</span>
404     qsort(_data, length(), sizeof(E), (_sort_Fn)f);
405   }
406   // sort by fixed-stride sub arrays:
<span class="line-modified">407   void sort(int f(E*,E*), int stride) {</span>
408     qsort(_data, length() / stride, sizeof(E) * stride, (_sort_Fn)f);
409   }
410 
<span class="line-removed">411   // Binary search and insertion utility.  Search array for element</span>
<span class="line-removed">412   // matching key according to the static compare function.  Insert</span>
<span class="line-removed">413   // that element is not already in the list.  Assumes the list is</span>
<span class="line-removed">414   // already sorted according to compare function.</span>
<span class="line-removed">415   template &lt;int compare(const E&amp;, const E&amp;)&gt; E insert_sorted(const E&amp; key) {</span>
<span class="line-removed">416     bool found;</span>
<span class="line-removed">417     int location = find_sorted&lt;E, compare&gt;(key, found);</span>
<span class="line-removed">418     if (!found) {</span>
<span class="line-removed">419       insert_before(location, key);</span>
<span class="line-removed">420     }</span>
<span class="line-removed">421     return at(location);</span>
<span class="line-removed">422   }</span>
<span class="line-removed">423 </span>
424   template &lt;typename K, int compare(const K&amp;, const E&amp;)&gt; int find_sorted(const K&amp; key, bool&amp; found) {
425     found = false;
426     int min = 0;
427     int max = length() - 1;
428 
429     while (max &gt;= min) {
430       int mid = (int)(((uint)max + min) / 2);
431       E value = at(mid);
432       int diff = compare(key, value);
433       if (diff &gt; 0) {
434         min = mid + 1;
435       } else if (diff &lt; 0) {
436         max = mid - 1;
437       } else {
438         found = true;
439         return mid;
440       }
441     }
442     return min;
443   }
444 
<span class="line-modified">445   E insert_sorted(CompareClosure&lt;E&gt;* cc, const E&amp; key) {</span>
<span class="line-removed">446     bool found;</span>
<span class="line-removed">447     int location = find_sorted(cc, key, found);</span>
<span class="line-removed">448     if (!found) {</span>
<span class="line-removed">449       insert_before(location, key);</span>
<span class="line-removed">450     }</span>
<span class="line-removed">451     return at(location);</span>
<span class="line-removed">452   }</span>
<span class="line-removed">453 </span>
<span class="line-removed">454   template&lt;typename K&gt;</span>
455   int find_sorted(CompareClosure&lt;E&gt;* cc, const K&amp; key, bool&amp; found) {
456     found = false;
457     int min = 0;
458     int max = length() - 1;
459 
460     while (max &gt;= min) {
461       int mid = (int)(((uint)max + min) / 2);
462       E value = at(mid);
463       int diff = cc-&gt;do_compare(key, value);
464       if (diff &gt; 0) {
465         min = mid + 1;
466       } else if (diff &lt; 0) {
467         max = mid - 1;
468       } else {
469         found = true;
470         return mid;
471       }
472     }
473     return min;
474   }









475 };
476 
<span class="line-modified">477 // Global GrowableArray methods (one instance in the library per each &#39;E&#39; type).</span>












478 
<span class="line-modified">479 template&lt;class E&gt; void GrowableArray&lt;E&gt;::grow(int j) {</span>
<span class="line-modified">480     int old_max = _max;</span>
<span class="line-modified">481     // grow the array by increasing _max to the first power of two larger than the size we need</span>
<span class="line-modified">482     _max = next_power_of_2((uint32_t)j);</span>
<span class="line-modified">483     // j &lt; _max</span>
<span class="line-modified">484     E* newData = (E*)raw_allocate(sizeof(E));</span>




485     int i = 0;
<span class="line-modified">486     for (     ; i &lt; _len; i++) ::new ((void*)&amp;newData[i]) E(_data[i]);</span>
<span class="line-modified">487 // Needed for Visual Studio 2012 and older</span>
<span class="line-removed">488 #ifdef _MSC_VER</span>
<span class="line-removed">489 #pragma warning(suppress: 4345)</span>
<span class="line-removed">490 #endif</span>
<span class="line-removed">491     for (     ; i &lt; _max; i++) ::new ((void*)&amp;newData[i]) E();</span>
<span class="line-removed">492     for (i = 0; i &lt; old_max; i++) _data[i].~E();</span>
<span class="line-removed">493     if (on_C_heap() &amp;&amp; _data != NULL) {</span>
<span class="line-removed">494       free_C_heap(_data);</span>
495     }
<span class="line-modified">496     _data = newData;</span>
<span class="line-modified">497 }</span>



















498 
<span class="line-modified">499 template&lt;class E&gt; void GrowableArray&lt;E&gt;::raw_at_put_grow(int i, const E&amp; p, const E&amp; fill) {</span>
<span class="line-modified">500     if (i &gt;= _len) {</span>
<span class="line-modified">501       if (i &gt;= _max) grow(i);</span>
<span class="line-modified">502       for (int j = _len; j &lt; i; j++)</span>
<span class="line-modified">503         _data[j] = fill;</span>
<span class="line-modified">504       _len = i+1;</span>



505     }
<span class="line-modified">506     _data[i] = p;</span>
<span class="line-modified">507 }</span>
































































508 
<span class="line-modified">509 // This function clears and deallocate the data in the growable array that</span>
<span class="line-modified">510 // has been allocated on the C heap.  It&#39;s not public - called by the</span>
<span class="line-modified">511 // destructor.</span>
<span class="line-modified">512 template&lt;class E&gt; void GrowableArray&lt;E&gt;::clear_and_deallocate() {</span>
<span class="line-modified">513     assert(on_C_heap(),</span>
<span class="line-removed">514            &quot;clear_and_deallocate should only be called when on C heap&quot;);</span>
<span class="line-removed">515     clear();</span>
<span class="line-removed">516     if (_data != NULL) {</span>
<span class="line-removed">517       for (int i = 0; i &lt; _max; i++) _data[i].~E();</span>
<span class="line-removed">518       free_C_heap(_data);</span>
<span class="line-removed">519       _data = NULL;</span>
520     }





















521 }
522 
<span class="line-modified">523 template&lt;class E&gt; void GrowableArray&lt;E&gt;::print() {</span>
<span class="line-modified">524     tty-&gt;print(&quot;Growable Array &quot; INTPTR_FORMAT, this);</span>
<span class="line-modified">525     tty-&gt;print(&quot;: length %ld (_max %ld) { &quot;, _len, _max);</span>
<span class="line-modified">526     for (int i = 0; i &lt; _len; i++) tty-&gt;print(INTPTR_FORMAT &quot; &quot;, *(intptr_t*)&amp;(_data[i]));</span>
<span class="line-modified">527     tty-&gt;print(&quot;}\n&quot;);</span>






528 }
529 


















































































































































































































































530 // Custom STL-style iterator to iterate over GrowableArrays
531 // It is constructed by invoking GrowableArray::begin() and GrowableArray::end()
<span class="line-modified">532 template&lt;class E&gt; class GrowableArrayIterator : public StackObj {</span>
<span class="line-modified">533   friend class GrowableArray&lt;E&gt;;</span>
<span class="line-modified">534   template&lt;class F, class UnaryPredicate&gt; friend class GrowableArrayFilterIterator;</span>

535 
536  private:
<span class="line-modified">537   const GrowableArray&lt;E&gt;* _array; // GrowableArray we iterate over</span>
<span class="line-modified">538   int _position;                  // The current position in the GrowableArray</span>
539 
540   // Private constructor used in GrowableArray::begin() and GrowableArray::end()
<span class="line-modified">541   GrowableArrayIterator(const GrowableArray&lt;E&gt;* array, int position) : _array(array), _position(position) {</span>
542     assert(0 &lt;= position &amp;&amp; position &lt;= _array-&gt;length(), &quot;illegal position&quot;);
543   }
544 
545  public:
546   GrowableArrayIterator() : _array(NULL), _position(0) { }
<span class="line-modified">547   GrowableArrayIterator&lt;E&gt;&amp; operator++()  { ++_position; return *this; }</span>
<span class="line-modified">548   E operator*()                           { return _array-&gt;at(_position); }</span>
549 
550   bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
551     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
552     return _position == rhs._position;
553   }
554 
555   bool operator!=(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
556     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
557     return _position != rhs._position;
558   }
559 };
560 
561 // Custom STL-style iterator to iterate over elements of a GrowableArray that satisfy a given predicate
<span class="line-modified">562 template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator : public StackObj {</span>
<span class="line-modified">563   friend class GrowableArray&lt;E&gt;;</span>

564 
565  private:
<span class="line-modified">566   const GrowableArray&lt;E&gt;* _array;   // GrowableArray we iterate over</span>
<span class="line-modified">567   int _position;                    // Current position in the GrowableArray</span>
<span class="line-modified">568   UnaryPredicate _predicate;        // Unary predicate the elements of the GrowableArray should satisfy</span>
569 
570  public:
<span class="line-modified">571   GrowableArrayFilterIterator(const GrowableArray&lt;E&gt;* array, UnaryPredicate filter_predicate)</span>
<span class="line-modified">572    : _array(array), _position(0), _predicate(filter_predicate) {</span>
573     // Advance to first element satisfying the predicate
574     while(!at_end() &amp;&amp; !_predicate(_array-&gt;at(_position))) {
575       ++_position;
576     }
577   }
578 
579   GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; operator++() {
580     do {
581       // Advance to next element satisfying the predicate
582       ++_position;
583     } while(!at_end() &amp;&amp; !_predicate(_array-&gt;at(_position)));
584     return *this;
585   }
586 
<span class="line-modified">587   E operator*()   { return _array-&gt;at(_position); }</span>
588 
589   bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
590     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
591     return _position == rhs._position;
592   }
593 
594   bool operator!=(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
595     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
596     return _position != rhs._position;
597   }
598 
599   bool operator==(const GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; rhs)  {
600     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
601     return _position == rhs._position;
602   }
603 
604   bool operator!=(const GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; rhs)  {
605     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
606     return _position != rhs._position;
607   }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_GROWABLEARRAY_HPP
 26 #define SHARE_UTILITIES_GROWABLEARRAY_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/array.hpp&quot;
 30 #include &quot;oops/oop.hpp&quot;
<span class="line-added"> 31 #include &quot;memory/iterator.hpp&quot;</span>
 32 #include &quot;utilities/debug.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 #include &quot;utilities/ostream.hpp&quot;
 35 #include &quot;utilities/powerOfTwo.hpp&quot;
 36 
 37 // A growable array.
 38 
 39 /*************************************************************************/
 40 /*                                                                       */
 41 /*     WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING   */
 42 /*                                                                       */
 43 /* Should you use GrowableArrays to contain handles you must be certain  */
<span class="line-modified"> 44 /* that the GrowableArray does not outlive the HandleMark that contains  */</span>
 45 /* the handles. Since GrowableArrays are typically resource allocated    */
 46 /* the following is an example of INCORRECT CODE,                        */
 47 /*                                                                       */
 48 /* ResourceMark rm;                                                      */
 49 /* GrowableArray&lt;Handle&gt;* arr = new GrowableArray&lt;Handle&gt;(size);         */
 50 /* if (blah) {                                                           */
 51 /*    while (...) {                                                      */
 52 /*      HandleMark hm;                                                   */
 53 /*      ...                                                              */
 54 /*      Handle h(THREAD, some_oop);                                      */
 55 /*      arr-&gt;append(h);                                                  */
 56 /*    }                                                                  */
 57 /* }                                                                     */
 58 /* if (arr-&gt;length() != 0 ) {                                            */
 59 /*    oop bad_oop = arr-&gt;at(0)(); // Handle is BAD HERE.                 */
 60 /*    ...                                                                */
 61 /* }                                                                     */
 62 /*                                                                       */
 63 /* If the GrowableArrays you are creating is C_Heap allocated then it    */
<span class="line-modified"> 64 /* should not hold handles since the handles could trivially try and     */</span>
 65 /* outlive their HandleMark. In some situations you might need to do     */
 66 /* this and it would be legal but be very careful and see if you can do  */
 67 /* the code in some other manner.                                        */
 68 /*                                                                       */
 69 /*************************************************************************/
 70 
<span class="line-modified"> 71 // Non-template base class responsible for handling the length and max.</span>


 72 
<span class="line-modified"> 73 </span>






 74 class GrowableArrayBase : public ResourceObj {
 75   friend class VMStructs;
 76 
<span class="line-modified"> 77 protected:</span>
<span class="line-modified"> 78   // Current number of accessible elements</span>
<span class="line-modified"> 79   int _len;</span>
<span class="line-modified"> 80   // Current number of allocated elements</span>
<span class="line-modified"> 81   int _max;</span>




































 82 
<span class="line-modified"> 83   GrowableArrayBase(int initial_max, int initial_len) :</span>
<span class="line-modified"> 84       _len(initial_len),</span>
<span class="line-modified"> 85       _max(initial_max) {</span>


 86     assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);








 87   }
 88 
<span class="line-modified"> 89   ~GrowableArrayBase() {}</span>
 90 





























































 91 public:
 92   int   length() const          { return _len; }
 93   int   max_length() const      { return _max; }
<span class="line-modified"> 94 </span>
 95   bool  is_empty() const        { return _len == 0; }
 96   bool  is_nonempty() const     { return _len != 0; }
 97   bool  is_full() const         { return _len == _max; }
<span class="line-modified"> 98 </span>
<span class="line-modified"> 99   void  clear()                 { _len = 0; }</span>
<span class="line-modified">100   void  trunc_to(int length)    {</span>
<span class="line-modified">101     assert(length &lt;= _len,&quot;cannot increase length&quot;);</span>





102     _len = length;
103   }
<span class="line-added">104 };</span>
105 
<span class="line-modified">106 template &lt;typename E&gt; class GrowableArrayIterator;</span>
<span class="line-modified">107 template &lt;typename E, typename UnaryPredicate&gt; class GrowableArrayFilterIterator;</span>
<span class="line-modified">108 </span>
<span class="line-modified">109 // Extends GrowableArrayBase with a typed data array.</span>
<span class="line-modified">110 //</span>
<span class="line-modified">111 // E: Element type</span>
<span class="line-added">112 //</span>
<span class="line-added">113 // The &quot;view&quot; adds function that don&#39;t grow or deallocate</span>
<span class="line-added">114 // the _data array, so there&#39;s no need for an allocator.</span>
<span class="line-added">115 //</span>
<span class="line-added">116 // The &quot;view&quot; can be used to type erase the allocator classes</span>
<span class="line-added">117 // of GrowableArrayWithAllocator.</span>
<span class="line-added">118 template &lt;typename E&gt;</span>
<span class="line-added">119 class GrowableArrayView : public GrowableArrayBase {</span>
<span class="line-added">120 protected:</span>
<span class="line-added">121   E* _data; // data array</span>
<span class="line-added">122 </span>
<span class="line-added">123   GrowableArrayView&lt;E&gt;(E* data, int initial_max, int initial_len) :</span>
<span class="line-added">124       GrowableArrayBase(initial_max, initial_len), _data(data) {}</span>
<span class="line-added">125 </span>
<span class="line-added">126   ~GrowableArrayView() {}</span>
127 
<span class="line-added">128 public:</span>
129   E&amp; at(int i) {
130     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
131     return _data[i];
132   }
133 
134   E const&amp; at(int i) const {
135     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
136     return _data[i];
137   }
138 
139   E* adr_at(int i) const {
140     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
141     return &amp;_data[i];
142   }
143 
144   E first() const {
145     assert(_len &gt; 0, &quot;empty list&quot;);
146     return _data[0];
147   }
148 
149   E top() const {
150     assert(_len &gt; 0, &quot;empty list&quot;);
151     return _data[_len-1];
152   }
153 
154   E last() const {
155     return top();
156   }
157 
158   GrowableArrayIterator&lt;E&gt; begin() const {
159     return GrowableArrayIterator&lt;E&gt;(this, 0);
160   }
161 
162   GrowableArrayIterator&lt;E&gt; end() const {
163     return GrowableArrayIterator&lt;E&gt;(this, length());
164   }
165 


166   E pop() {
167     assert(_len &gt; 0, &quot;empty list&quot;);
168     return _data[--_len];
169   }
170 
171   void at_put(int i, const E&amp; elem) {
172     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
173     _data[i] = elem;
174   }
175 


















176   bool contains(const E&amp; elem) const {
177     for (int i = 0; i &lt; _len; i++) {
178       if (_data[i] == elem) return true;
179     }
180     return false;
181   }
182 
183   int  find(const E&amp; elem) const {
184     for (int i = 0; i &lt; _len; i++) {
185       if (_data[i] == elem) return i;
186     }
187     return -1;
188   }
189 
190   int  find_from_end(const E&amp; elem) const {
191     for (int i = _len-1; i &gt;= 0; i--) {
192       if (_data[i] == elem) return i;
193     }
194     return -1;
195   }
</pre>
<hr />
<pre>
219     }
220     ShouldNotReachHere();
221   }
222 
223   // The order is preserved.
224   void remove_at(int index) {
225     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
226     for (int j = index + 1; j &lt; _len; j++) _data[j-1] = _data[j];
227     _len--;
228   }
229 
230   // The order is changed.
231   void delete_at(int index) {
232     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
233     if (index &lt; --_len) {
234       // Replace removed element with last one.
235       _data[index] = _data[_len];
236     }
237   }
238 
<span class="line-modified">239   void sort(int f(E*, E*)) {</span>










































240     qsort(_data, length(), sizeof(E), (_sort_Fn)f);
241   }
242   // sort by fixed-stride sub arrays:
<span class="line-modified">243   void sort(int f(E*, E*), int stride) {</span>
244     qsort(_data, length() / stride, sizeof(E) * stride, (_sort_Fn)f);
245   }
246 













247   template &lt;typename K, int compare(const K&amp;, const E&amp;)&gt; int find_sorted(const K&amp; key, bool&amp; found) {
248     found = false;
249     int min = 0;
250     int max = length() - 1;
251 
252     while (max &gt;= min) {
253       int mid = (int)(((uint)max + min) / 2);
254       E value = at(mid);
255       int diff = compare(key, value);
256       if (diff &gt; 0) {
257         min = mid + 1;
258       } else if (diff &lt; 0) {
259         max = mid - 1;
260       } else {
261         found = true;
262         return mid;
263       }
264     }
265     return min;
266   }
267 
<span class="line-modified">268   template &lt;typename K&gt;</span>









269   int find_sorted(CompareClosure&lt;E&gt;* cc, const K&amp; key, bool&amp; found) {
270     found = false;
271     int min = 0;
272     int max = length() - 1;
273 
274     while (max &gt;= min) {
275       int mid = (int)(((uint)max + min) / 2);
276       E value = at(mid);
277       int diff = cc-&gt;do_compare(key, value);
278       if (diff &gt; 0) {
279         min = mid + 1;
280       } else if (diff &lt; 0) {
281         max = mid - 1;
282       } else {
283         found = true;
284         return mid;
285       }
286     }
287     return min;
288   }
<span class="line-added">289 </span>
<span class="line-added">290   void print() {</span>
<span class="line-added">291     tty-&gt;print(&quot;Growable Array &quot; INTPTR_FORMAT, this);</span>
<span class="line-added">292     tty-&gt;print(&quot;: length %ld (_max %ld) { &quot;, _len, _max);</span>
<span class="line-added">293     for (int i = 0; i &lt; _len; i++) {</span>
<span class="line-added">294       tty-&gt;print(INTPTR_FORMAT &quot; &quot;, *(intptr_t*)&amp;(_data[i]));</span>
<span class="line-added">295     }</span>
<span class="line-added">296     tty-&gt;print(&quot;}\n&quot;);</span>
<span class="line-added">297   }</span>
298 };
299 
<span class="line-modified">300 // GrowableArrayWithAllocator extends the &quot;view&quot; with</span>
<span class="line-added">301 // the capability to grow and deallocate the data array.</span>
<span class="line-added">302 //</span>
<span class="line-added">303 // The allocator responsibility is delegated to the sub-class.</span>
<span class="line-added">304 //</span>
<span class="line-added">305 // Derived: The sub-class responsible for allocation / deallocation</span>
<span class="line-added">306 //  - E* Derived::allocate()       - member function responsible for allocation</span>
<span class="line-added">307 //  - void Derived::deallocate(E*) - member function responsible for deallocation</span>
<span class="line-added">308 template &lt;typename E, typename Derived&gt;</span>
<span class="line-added">309 class GrowableArrayWithAllocator : public GrowableArrayView&lt;E&gt; {</span>
<span class="line-added">310   friend class VMStructs;</span>
<span class="line-added">311 </span>
<span class="line-added">312   void grow(int j);</span>
313 
<span class="line-modified">314 protected:</span>
<span class="line-modified">315   GrowableArrayWithAllocator(E* data, int initial_max) :</span>
<span class="line-modified">316       GrowableArrayView&lt;E&gt;(data, initial_max, 0) {</span>
<span class="line-modified">317     for (int i = 0; i &lt; initial_max; i++) {</span>
<span class="line-modified">318       ::new ((void*)&amp;data[i]) E();</span>
<span class="line-modified">319     }</span>
<span class="line-added">320   }</span>
<span class="line-added">321 </span>
<span class="line-added">322   GrowableArrayWithAllocator(E* data, int initial_max, int initial_len, const E&amp; filler) :</span>
<span class="line-added">323       GrowableArrayView&lt;E&gt;(data, initial_max, initial_len) {</span>
324     int i = 0;
<span class="line-modified">325     for (; i &lt; initial_len; i++) {</span>
<span class="line-modified">326       ::new ((void*)&amp;data[i]) E(filler);</span>







327     }
<span class="line-modified">328     for (; i &lt; initial_max; i++) {</span>
<span class="line-modified">329       ::new ((void*)&amp;data[i]) E();</span>
<span class="line-added">330     }</span>
<span class="line-added">331   }</span>
<span class="line-added">332 </span>
<span class="line-added">333   ~GrowableArrayWithAllocator() {}</span>
<span class="line-added">334 </span>
<span class="line-added">335 public:</span>
<span class="line-added">336   int append(const E&amp; elem) {</span>
<span class="line-added">337     if (this-&gt;_len == this-&gt;_max) grow(this-&gt;_len);</span>
<span class="line-added">338     int idx = this-&gt;_len++;</span>
<span class="line-added">339     this-&gt;_data[idx] = elem;</span>
<span class="line-added">340     return idx;</span>
<span class="line-added">341   }</span>
<span class="line-added">342 </span>
<span class="line-added">343   bool append_if_missing(const E&amp; elem) {</span>
<span class="line-added">344     // Returns TRUE if elem is added.</span>
<span class="line-added">345     bool missed = !this-&gt;contains(elem);</span>
<span class="line-added">346     if (missed) append(elem);</span>
<span class="line-added">347     return missed;</span>
<span class="line-added">348   }</span>
349 
<span class="line-modified">350   void push(const E&amp; elem) { append(elem); }</span>
<span class="line-modified">351 </span>
<span class="line-modified">352   E at_grow(int i, const E&amp; fill = E()) {</span>
<span class="line-modified">353     assert(0 &lt;= i, &quot;negative index&quot;);</span>
<span class="line-modified">354     if (i &gt;= this-&gt;_len) {</span>
<span class="line-modified">355       if (i &gt;= this-&gt;_max) grow(i);</span>
<span class="line-added">356       for (int j = this-&gt;_len; j &lt;= i; j++)</span>
<span class="line-added">357         this-&gt;_data[j] = fill;</span>
<span class="line-added">358       this-&gt;_len = i+1;</span>
359     }
<span class="line-modified">360     return this-&gt;_data[i];</span>
<span class="line-modified">361   }</span>
<span class="line-added">362 </span>
<span class="line-added">363   void at_put_grow(int i, const E&amp; elem, const E&amp; fill = E()) {</span>
<span class="line-added">364     assert(0 &lt;= i, &quot;negative index&quot;);</span>
<span class="line-added">365     if (i &gt;= this-&gt;_len) {</span>
<span class="line-added">366       if (i &gt;= this-&gt;_max) grow(i);</span>
<span class="line-added">367       for (int j = this-&gt;_len; j &lt; i; j++)</span>
<span class="line-added">368         this-&gt;_data[j] = fill;</span>
<span class="line-added">369       this-&gt;_len = i+1;</span>
<span class="line-added">370     }</span>
<span class="line-added">371     this-&gt;_data[i] = elem;</span>
<span class="line-added">372   }</span>
<span class="line-added">373 </span>
<span class="line-added">374   // inserts the given element before the element at index i</span>
<span class="line-added">375   void insert_before(const int idx, const E&amp; elem) {</span>
<span class="line-added">376     assert(0 &lt;= idx &amp;&amp; idx &lt;= this-&gt;_len, &quot;illegal index&quot;);</span>
<span class="line-added">377     if (this-&gt;_len == this-&gt;_max) grow(this-&gt;_len);</span>
<span class="line-added">378     for (int j = this-&gt;_len - 1; j &gt;= idx; j--) {</span>
<span class="line-added">379       this-&gt;_data[j + 1] = this-&gt;_data[j];</span>
<span class="line-added">380     }</span>
<span class="line-added">381     this-&gt;_len++;</span>
<span class="line-added">382     this-&gt;_data[idx] = elem;</span>
<span class="line-added">383   }</span>
<span class="line-added">384 </span>
<span class="line-added">385   void insert_before(const int idx, const GrowableArrayView&lt;E&gt;* array) {</span>
<span class="line-added">386     assert(0 &lt;= idx &amp;&amp; idx &lt;= this-&gt;_len, &quot;illegal index&quot;);</span>
<span class="line-added">387     int array_len = array-&gt;length();</span>
<span class="line-added">388     int new_len = this-&gt;_len + array_len;</span>
<span class="line-added">389     if (new_len &gt;= this-&gt;_max) grow(new_len);</span>
<span class="line-added">390 </span>
<span class="line-added">391     for (int j = this-&gt;_len - 1; j &gt;= idx; j--) {</span>
<span class="line-added">392       this-&gt;_data[j + array_len] = this-&gt;_data[j];</span>
<span class="line-added">393     }</span>
<span class="line-added">394 </span>
<span class="line-added">395     for (int j = 0; j &lt; array_len; j++) {</span>
<span class="line-added">396       this-&gt;_data[idx + j] = array-&gt;at(j);</span>
<span class="line-added">397     }</span>
<span class="line-added">398 </span>
<span class="line-added">399     this-&gt;_len += array_len;</span>
<span class="line-added">400   }</span>
<span class="line-added">401 </span>
<span class="line-added">402   void appendAll(const GrowableArrayView&lt;E&gt;* l) {</span>
<span class="line-added">403     for (int i = 0; i &lt; l-&gt;length(); i++) {</span>
<span class="line-added">404       this-&gt;at_put_grow(this-&gt;_len, l-&gt;at(i), E());</span>
<span class="line-added">405     }</span>
<span class="line-added">406   }</span>
<span class="line-added">407 </span>
<span class="line-added">408   void appendAll(const Array&lt;E&gt;* l) {</span>
<span class="line-added">409     for (int i = 0; i &lt; l-&gt;length(); i++) {</span>
<span class="line-added">410       this-&gt;at_put_grow(this-&gt;_len, l-&gt;at(i), E());</span>
<span class="line-added">411     }</span>
<span class="line-added">412   }</span>
<span class="line-added">413 </span>
<span class="line-added">414   // Binary search and insertion utility.  Search array for element</span>
<span class="line-added">415   // matching key according to the static compare function.  Insert</span>
<span class="line-added">416   // that element is not already in the list.  Assumes the list is</span>
<span class="line-added">417   // already sorted according to compare function.</span>
<span class="line-added">418   template &lt;int compare(const E&amp;, const E&amp;)&gt; E insert_sorted(const E&amp; key) {</span>
<span class="line-added">419     bool found;</span>
<span class="line-added">420     int location = GrowableArrayView&lt;E&gt;::template find_sorted&lt;E, compare&gt;(key, found);</span>
<span class="line-added">421     if (!found) {</span>
<span class="line-added">422       insert_before(location, key);</span>
<span class="line-added">423     }</span>
<span class="line-added">424     return this-&gt;at(location);</span>
<span class="line-added">425   }</span>
426 
<span class="line-modified">427   E insert_sorted(CompareClosure&lt;E&gt;* cc, const E&amp; key) {</span>
<span class="line-modified">428     bool found;</span>
<span class="line-modified">429     int location = find_sorted(cc, key, found);</span>
<span class="line-modified">430     if (!found) {</span>
<span class="line-modified">431       insert_before(location, key);</span>






432     }
<span class="line-added">433     return this-&gt;at(location);</span>
<span class="line-added">434   }</span>
<span class="line-added">435 </span>
<span class="line-added">436   void clear_and_deallocate();</span>
<span class="line-added">437 };</span>
<span class="line-added">438 </span>
<span class="line-added">439 template &lt;typename E, typename Derived&gt;</span>
<span class="line-added">440 void GrowableArrayWithAllocator&lt;E, Derived&gt;::grow(int j) {</span>
<span class="line-added">441   int old_max = this-&gt;_max;</span>
<span class="line-added">442   // grow the array by increasing _max to the first power of two larger than the size we need</span>
<span class="line-added">443   this-&gt;_max = next_power_of_2((uint32_t)j);</span>
<span class="line-added">444   // j &lt; _max</span>
<span class="line-added">445   E* newData = static_cast&lt;Derived*&gt;(this)-&gt;allocate();</span>
<span class="line-added">446   int i = 0;</span>
<span class="line-added">447   for (     ; i &lt; this-&gt;_len; i++) ::new ((void*)&amp;newData[i]) E(this-&gt;_data[i]);</span>
<span class="line-added">448   for (     ; i &lt; this-&gt;_max; i++) ::new ((void*)&amp;newData[i]) E();</span>
<span class="line-added">449   for (i = 0; i &lt; old_max; i++) this-&gt;_data[i].~E();</span>
<span class="line-added">450   if (this-&gt;_data != NULL) {</span>
<span class="line-added">451     static_cast&lt;Derived*&gt;(this)-&gt;deallocate(this-&gt;_data);</span>
<span class="line-added">452   }</span>
<span class="line-added">453   this-&gt;_data = newData;</span>
454 }
455 
<span class="line-modified">456 template &lt;typename E, typename Derived&gt;</span>
<span class="line-modified">457 void GrowableArrayWithAllocator&lt;E, Derived&gt;::clear_and_deallocate() {</span>
<span class="line-modified">458   if (this-&gt;_data != NULL) {</span>
<span class="line-modified">459     for (int i = 0; i &lt; this-&gt;_max; i++) {</span>
<span class="line-modified">460       this-&gt;_data[i].~E();</span>
<span class="line-added">461     }</span>
<span class="line-added">462     static_cast&lt;Derived*&gt;(this)-&gt;deallocate(this-&gt;_data);</span>
<span class="line-added">463     this-&gt;_data = NULL;</span>
<span class="line-added">464   }</span>
<span class="line-added">465   this-&gt;_len = 0;</span>
<span class="line-added">466   this-&gt;_max = 0;</span>
467 }
468 
<span class="line-added">469 class GrowableArrayResourceAllocator {</span>
<span class="line-added">470 public:</span>
<span class="line-added">471   static void* allocate(int max, int element_size);</span>
<span class="line-added">472 };</span>
<span class="line-added">473 </span>
<span class="line-added">474 // Arena allocator</span>
<span class="line-added">475 class GrowableArrayArenaAllocator {</span>
<span class="line-added">476 public:</span>
<span class="line-added">477   static void* allocate(int max, int element_size, Arena* arena);</span>
<span class="line-added">478 };</span>
<span class="line-added">479 </span>
<span class="line-added">480 // CHeap allocator</span>
<span class="line-added">481 class GrowableArrayCHeapAllocator {</span>
<span class="line-added">482 public:</span>
<span class="line-added">483   static void* allocate(int max, int element_size, MEMFLAGS memflags);</span>
<span class="line-added">484   static void deallocate(void* mem);</span>
<span class="line-added">485 };</span>
<span class="line-added">486 </span>
<span class="line-added">487 #ifdef ASSERT</span>
<span class="line-added">488 </span>
<span class="line-added">489 // Checks resource allocation nesting</span>
<span class="line-added">490 class GrowableArrayNestingCheck {</span>
<span class="line-added">491   // resource area nesting at creation</span>
<span class="line-added">492   int _nesting;</span>
<span class="line-added">493 </span>
<span class="line-added">494 public:</span>
<span class="line-added">495   GrowableArrayNestingCheck(bool on_stack);</span>
<span class="line-added">496 </span>
<span class="line-added">497   void on_stack_alloc() const;</span>
<span class="line-added">498 };</span>
<span class="line-added">499 </span>
<span class="line-added">500 #endif // ASSERT</span>
<span class="line-added">501 </span>
<span class="line-added">502 // Encodes where the backing array is allocated</span>
<span class="line-added">503 // and performs necessary checks.</span>
<span class="line-added">504 class GrowableArrayMetadata {</span>
<span class="line-added">505   uintptr_t _bits;</span>
<span class="line-added">506 </span>
<span class="line-added">507   // resource area nesting at creation</span>
<span class="line-added">508   debug_only(GrowableArrayNestingCheck _nesting_check;)</span>
<span class="line-added">509 </span>
<span class="line-added">510   uintptr_t bits(MEMFLAGS memflags) const {</span>
<span class="line-added">511     if (memflags == mtNone) {</span>
<span class="line-added">512       // Stack allocation</span>
<span class="line-added">513       return 0;</span>
<span class="line-added">514     }</span>
<span class="line-added">515 </span>
<span class="line-added">516     // CHeap allocation</span>
<span class="line-added">517     return (uintptr_t(memflags) &lt;&lt; 1) | 1;</span>
<span class="line-added">518   }</span>
<span class="line-added">519 </span>
<span class="line-added">520   uintptr_t bits(Arena* arena) const {</span>
<span class="line-added">521     return uintptr_t(arena);</span>
<span class="line-added">522   }</span>
<span class="line-added">523 </span>
<span class="line-added">524 public:</span>
<span class="line-added">525   GrowableArrayMetadata(Arena* arena) :</span>
<span class="line-added">526       _bits(bits(arena))</span>
<span class="line-added">527       debug_only(COMMA _nesting_check(on_stack())) {</span>
<span class="line-added">528   }</span>
<span class="line-added">529 </span>
<span class="line-added">530   GrowableArrayMetadata(MEMFLAGS memflags) :</span>
<span class="line-added">531       _bits(bits(memflags))</span>
<span class="line-added">532       debug_only(COMMA _nesting_check(on_stack())) {</span>
<span class="line-added">533   }</span>
<span class="line-added">534 </span>
<span class="line-added">535 #ifdef ASSERT</span>
<span class="line-added">536   GrowableArrayMetadata(const GrowableArrayMetadata&amp; other) :</span>
<span class="line-added">537       _bits(other._bits),</span>
<span class="line-added">538       _nesting_check(other._nesting_check) {</span>
<span class="line-added">539     assert(!on_C_heap(), &quot;Copying of CHeap arrays not supported&quot;);</span>
<span class="line-added">540     assert(!other.on_C_heap(), &quot;Copying of CHeap arrays not supported&quot;);</span>
<span class="line-added">541   }</span>
<span class="line-added">542 </span>
<span class="line-added">543   GrowableArrayMetadata&amp; operator=(const GrowableArrayMetadata&amp; other) {</span>
<span class="line-added">544     _bits = other._bits;</span>
<span class="line-added">545     _nesting_check = other._nesting_check;</span>
<span class="line-added">546     assert(!on_C_heap(), &quot;Assignment of CHeap arrays not supported&quot;);</span>
<span class="line-added">547     assert(!other.on_C_heap(), &quot;Assignment of CHeap arrays not supported&quot;);</span>
<span class="line-added">548     return *this;</span>
<span class="line-added">549   }</span>
<span class="line-added">550 </span>
<span class="line-added">551   void init_checks(const GrowableArrayBase* array) const;</span>
<span class="line-added">552   void on_stack_alloc_check() const;</span>
<span class="line-added">553 #endif // ASSERT</span>
<span class="line-added">554 </span>
<span class="line-added">555   bool on_C_heap() const { return (_bits &amp; 1) == 1; }</span>
<span class="line-added">556   bool on_stack () const { return _bits == 0;      }</span>
<span class="line-added">557   bool on_arena () const { return (_bits &amp; 1) == 0 &amp;&amp; _bits != 0; }</span>
<span class="line-added">558 </span>
<span class="line-added">559   Arena* arena() const      { return (Arena*)_bits; }</span>
<span class="line-added">560   MEMFLAGS memflags() const { return MEMFLAGS(_bits &gt;&gt; 1); }</span>
<span class="line-added">561 };</span>
<span class="line-added">562 </span>
<span class="line-added">563 // THE GrowableArray.</span>
<span class="line-added">564 //</span>
<span class="line-added">565 // Supports multiple allocation strategies:</span>
<span class="line-added">566 //  - Resource stack allocation: if memflags == mtNone</span>
<span class="line-added">567 //  - CHeap allocation: if memflags != mtNone</span>
<span class="line-added">568 //  - Arena allocation: if an arena is provided</span>
<span class="line-added">569 //</span>
<span class="line-added">570 // There are some drawbacks of using GrowableArray, that are removed in some</span>
<span class="line-added">571 // of the other implementations of GrowableArrayWithAllocator sub-classes:</span>
<span class="line-added">572 //</span>
<span class="line-added">573 // Memory overhead: The multiple allocation strategies uses extra metadata</span>
<span class="line-added">574 //  embedded in the instance.</span>
<span class="line-added">575 //</span>
<span class="line-added">576 // Strict allocation locations: There are rules about where the GrowableArray</span>
<span class="line-added">577 //  instance is allocated, that depends on where the data array is allocated.</span>
<span class="line-added">578 //  See: init_checks.</span>
<span class="line-added">579 </span>
<span class="line-added">580 template &lt;typename E&gt;</span>
<span class="line-added">581 class GrowableArray : public GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt; {</span>
<span class="line-added">582   friend class GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt;;</span>
<span class="line-added">583   friend class GrowableArrayTest;</span>
<span class="line-added">584 </span>
<span class="line-added">585   static E* allocate(int max) {</span>
<span class="line-added">586     return (E*)GrowableArrayResourceAllocator::allocate(max, sizeof(E));</span>
<span class="line-added">587   }</span>
<span class="line-added">588 </span>
<span class="line-added">589   static E* allocate(int max, MEMFLAGS memflags) {</span>
<span class="line-added">590     if (memflags != mtNone) {</span>
<span class="line-added">591       return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), memflags);</span>
<span class="line-added">592     }</span>
<span class="line-added">593 </span>
<span class="line-added">594     return (E*)GrowableArrayResourceAllocator::allocate(max, sizeof(E));</span>
<span class="line-added">595   }</span>
<span class="line-added">596 </span>
<span class="line-added">597   static E* allocate(int max, Arena* arena) {</span>
<span class="line-added">598     return (E*)GrowableArrayArenaAllocator::allocate(max, sizeof(E), arena);</span>
<span class="line-added">599   }</span>
<span class="line-added">600 </span>
<span class="line-added">601   GrowableArrayMetadata _metadata;</span>
<span class="line-added">602 </span>
<span class="line-added">603   void init_checks() const { debug_only(_metadata.init_checks(this);) }</span>
<span class="line-added">604 </span>
<span class="line-added">605   // Where are we going to allocate memory?</span>
<span class="line-added">606   bool on_C_heap() const { return _metadata.on_C_heap(); }</span>
<span class="line-added">607   bool on_stack () const { return _metadata.on_stack(); }</span>
<span class="line-added">608   bool on_arena () const { return _metadata.on_arena(); }</span>
<span class="line-added">609 </span>
<span class="line-added">610   E* allocate() {</span>
<span class="line-added">611     if (on_stack()) {</span>
<span class="line-added">612       debug_only(_metadata.on_stack_alloc_check());</span>
<span class="line-added">613       return allocate(this-&gt;_max);</span>
<span class="line-added">614     }</span>
<span class="line-added">615 </span>
<span class="line-added">616     if (on_C_heap()) {</span>
<span class="line-added">617       return allocate(this-&gt;_max, _metadata.memflags());</span>
<span class="line-added">618     }</span>
<span class="line-added">619 </span>
<span class="line-added">620     assert(on_arena(), &quot;Sanity&quot;);</span>
<span class="line-added">621     return allocate(this-&gt;_max, _metadata.arena());</span>
<span class="line-added">622   }</span>
<span class="line-added">623 </span>
<span class="line-added">624   void deallocate(E* mem) {</span>
<span class="line-added">625     if (on_C_heap()) {</span>
<span class="line-added">626       GrowableArrayCHeapAllocator::deallocate(mem);</span>
<span class="line-added">627     }</span>
<span class="line-added">628   }</span>
<span class="line-added">629 </span>
<span class="line-added">630 public:</span>
<span class="line-added">631   GrowableArray(int initial_max = 2, MEMFLAGS memflags = mtNone) :</span>
<span class="line-added">632       GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt;(</span>
<span class="line-added">633           allocate(initial_max, memflags),</span>
<span class="line-added">634           initial_max),</span>
<span class="line-added">635       _metadata(memflags) {</span>
<span class="line-added">636     init_checks();</span>
<span class="line-added">637   }</span>
<span class="line-added">638 </span>
<span class="line-added">639   GrowableArray(int initial_max, int initial_len, const E&amp; filler, MEMFLAGS memflags = mtNone) :</span>
<span class="line-added">640       GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt;(</span>
<span class="line-added">641           allocate(initial_max, memflags),</span>
<span class="line-added">642           initial_max, initial_len, filler),</span>
<span class="line-added">643       _metadata(memflags) {</span>
<span class="line-added">644     init_checks();</span>
<span class="line-added">645   }</span>
<span class="line-added">646 </span>
<span class="line-added">647   GrowableArray(Arena* arena, int initial_max, int initial_len, const E&amp; filler) :</span>
<span class="line-added">648       GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt;(</span>
<span class="line-added">649           allocate(initial_max, arena),</span>
<span class="line-added">650           initial_max, initial_len, filler),</span>
<span class="line-added">651       _metadata(arena) {</span>
<span class="line-added">652     init_checks();</span>
<span class="line-added">653   }</span>
<span class="line-added">654 </span>
<span class="line-added">655   ~GrowableArray() {</span>
<span class="line-added">656     if (on_C_heap()) {</span>
<span class="line-added">657       this-&gt;clear_and_deallocate();</span>
<span class="line-added">658     }</span>
<span class="line-added">659   }</span>
<span class="line-added">660 };</span>
<span class="line-added">661 </span>
<span class="line-added">662 // Leaner GrowableArray for CHeap backed data arrays, with compile-time decided MEMFLAGS.</span>
<span class="line-added">663 template &lt;typename E, MEMFLAGS F&gt;</span>
<span class="line-added">664 class GrowableArrayCHeap : public GrowableArrayWithAllocator&lt;E, GrowableArrayCHeap&lt;E, F&gt; &gt; {</span>
<span class="line-added">665   friend class GrowableArrayWithAllocator&lt;E, GrowableArrayCHeap&lt;E, F&gt; &gt;;</span>
<span class="line-added">666 </span>
<span class="line-added">667   STATIC_ASSERT(F != mtNone);</span>
<span class="line-added">668 </span>
<span class="line-added">669   static E* allocate(int max, MEMFLAGS flags) {</span>
<span class="line-added">670     if (max == 0) {</span>
<span class="line-added">671       return NULL;</span>
<span class="line-added">672     }</span>
<span class="line-added">673 </span>
<span class="line-added">674     return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), flags);</span>
<span class="line-added">675   }</span>
<span class="line-added">676 </span>
<span class="line-added">677   NONCOPYABLE(GrowableArrayCHeap);</span>
<span class="line-added">678 </span>
<span class="line-added">679   E* allocate() {</span>
<span class="line-added">680     return allocate(this-&gt;_max, F);</span>
<span class="line-added">681   }</span>
<span class="line-added">682 </span>
<span class="line-added">683   void deallocate(E* mem) {</span>
<span class="line-added">684     GrowableArrayCHeapAllocator::deallocate(mem);</span>
<span class="line-added">685   }</span>
<span class="line-added">686 </span>
<span class="line-added">687 public:</span>
<span class="line-added">688   GrowableArrayCHeap(int initial_max) :</span>
<span class="line-added">689       GrowableArrayWithAllocator&lt;E, GrowableArrayCHeap&lt;E, F&gt; &gt;(</span>
<span class="line-added">690           allocate(initial_max, F),</span>
<span class="line-added">691           initial_max) {}</span>
<span class="line-added">692 </span>
<span class="line-added">693   GrowableArrayCHeap(int initial_max, int initial_len, const E&amp; filler) :</span>
<span class="line-added">694       GrowableArrayWithAllocator&lt;E, GrowableArrayCHeap&lt;E, F&gt; &gt;(</span>
<span class="line-added">695           allocate(initial_max, F),</span>
<span class="line-added">696           initial_max, initial_len, filler) {}</span>
<span class="line-added">697 </span>
<span class="line-added">698   ~GrowableArrayCHeap() {</span>
<span class="line-added">699     this-&gt;clear_and_deallocate();</span>
<span class="line-added">700   }</span>
<span class="line-added">701 </span>
<span class="line-added">702   void* operator new(size_t size) throw() {</span>
<span class="line-added">703     return ResourceObj::operator new(size, ResourceObj::C_HEAP, F);</span>
<span class="line-added">704   }</span>
<span class="line-added">705 </span>
<span class="line-added">706   void* operator new(size_t size, const std::nothrow_t&amp;  nothrow_constant) throw() {</span>
<span class="line-added">707     return ResourceObj::operator new(size, nothrow_constant, ResourceObj::C_HEAP, F);</span>
<span class="line-added">708   }</span>
<span class="line-added">709 };</span>
<span class="line-added">710 </span>
711 // Custom STL-style iterator to iterate over GrowableArrays
712 // It is constructed by invoking GrowableArray::begin() and GrowableArray::end()
<span class="line-modified">713 template &lt;typename E&gt;</span>
<span class="line-modified">714 class GrowableArrayIterator : public StackObj {</span>
<span class="line-modified">715   friend class GrowableArrayView&lt;E&gt;;</span>
<span class="line-added">716   template &lt;typename F, typename UnaryPredicate&gt; friend class GrowableArrayFilterIterator;</span>
717 
718  private:
<span class="line-modified">719   const GrowableArrayView&lt;E&gt;* _array; // GrowableArray we iterate over</span>
<span class="line-modified">720   int _position;                      // The current position in the GrowableArray</span>
721 
722   // Private constructor used in GrowableArray::begin() and GrowableArray::end()
<span class="line-modified">723   GrowableArrayIterator(const GrowableArrayView&lt;E&gt;* array, int position) : _array(array), _position(position) {</span>
724     assert(0 &lt;= position &amp;&amp; position &lt;= _array-&gt;length(), &quot;illegal position&quot;);
725   }
726 
727  public:
728   GrowableArrayIterator() : _array(NULL), _position(0) { }
<span class="line-modified">729   GrowableArrayIterator&lt;E&gt;&amp; operator++() { ++_position; return *this; }</span>
<span class="line-modified">730   E operator*()                          { return _array-&gt;at(_position); }</span>
731 
732   bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
733     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
734     return _position == rhs._position;
735   }
736 
737   bool operator!=(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
738     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
739     return _position != rhs._position;
740   }
741 };
742 
743 // Custom STL-style iterator to iterate over elements of a GrowableArray that satisfy a given predicate
<span class="line-modified">744 template &lt;typename E, class UnaryPredicate&gt;</span>
<span class="line-modified">745 class GrowableArrayFilterIterator : public StackObj {</span>
<span class="line-added">746   friend class GrowableArrayView&lt;E&gt;;</span>
747 
748  private:
<span class="line-modified">749   const GrowableArrayView&lt;E&gt;* _array; // GrowableArray we iterate over</span>
<span class="line-modified">750   int _position;                      // Current position in the GrowableArray</span>
<span class="line-modified">751   UnaryPredicate _predicate;          // Unary predicate the elements of the GrowableArray should satisfy</span>
752 
753  public:
<span class="line-modified">754   GrowableArrayFilterIterator(const GrowableArray&lt;E&gt;* array, UnaryPredicate filter_predicate) :</span>
<span class="line-modified">755       _array(array), _position(0), _predicate(filter_predicate) {</span>
756     // Advance to first element satisfying the predicate
757     while(!at_end() &amp;&amp; !_predicate(_array-&gt;at(_position))) {
758       ++_position;
759     }
760   }
761 
762   GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; operator++() {
763     do {
764       // Advance to next element satisfying the predicate
765       ++_position;
766     } while(!at_end() &amp;&amp; !_predicate(_array-&gt;at(_position)));
767     return *this;
768   }
769 
<span class="line-modified">770   E operator*() { return _array-&gt;at(_position); }</span>
771 
772   bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
773     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
774     return _position == rhs._position;
775   }
776 
777   bool operator!=(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
778     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
779     return _position != rhs._position;
780   }
781 
782   bool operator==(const GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; rhs)  {
783     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
784     return _position == rhs._position;
785   }
786 
787   bool operator!=(const GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; rhs)  {
788     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
789     return _position != rhs._position;
790   }
</pre>
</td>
</tr>
</table>
<center><a href="globalDefinitions.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/invoke/MemberName.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>