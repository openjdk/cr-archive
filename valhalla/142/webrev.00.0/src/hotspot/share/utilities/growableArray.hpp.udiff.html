<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/utilities/growableArray.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globalDefinitions.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/invoke/MemberName.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/growableArray.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,10 +26,11 @@</span>
  #define SHARE_UTILITIES_GROWABLEARRAY_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;oops/array.hpp&quot;
  #include &quot;oops/oop.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/iterator.hpp&quot;</span>
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/ostream.hpp&quot;
  #include &quot;utilities/powerOfTwo.hpp&quot;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -38,11 +39,11 @@</span>
  /*************************************************************************/
  /*                                                                       */
  /*     WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING   */
  /*                                                                       */
  /* Should you use GrowableArrays to contain handles you must be certain  */
<span class="udiff-line-modified-removed">- /* the the GrowableArray does not outlive the HandleMark that contains   */</span>
<span class="udiff-line-modified-added">+ /* that the GrowableArray does not outlive the HandleMark that contains  */</span>
  /* the handles. Since GrowableArrays are typically resource allocated    */
  /* the following is an example of INCORRECT CODE,                        */
  /*                                                                       */
  /* ResourceMark rm;                                                      */
  /* GrowableArray&lt;Handle&gt;* arr = new GrowableArray&lt;Handle&gt;(size);         */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -58,178 +59,75 @@</span>
  /*    oop bad_oop = arr-&gt;at(0)(); // Handle is BAD HERE.                 */
  /*    ...                                                                */
  /* }                                                                     */
  /*                                                                       */
  /* If the GrowableArrays you are creating is C_Heap allocated then it    */
<span class="udiff-line-modified-removed">- /* hould not old handles since the handles could trivially try and       */</span>
<span class="udiff-line-modified-added">+ /* should not hold handles since the handles could trivially try and     */</span>
  /* outlive their HandleMark. In some situations you might need to do     */
  /* this and it would be legal but be very careful and see if you can do  */
  /* the code in some other manner.                                        */
  /*                                                                       */
  /*************************************************************************/
  
<span class="udiff-line-modified-removed">- // To call default constructor the placement operator new() is used.</span>
<span class="udiff-line-removed">- // It should be empty (it only returns the passed void* pointer).</span>
<span class="udiff-line-removed">- // The definition of placement operator new(size_t, void*) in the &lt;new&gt;.</span>
<span class="udiff-line-modified-added">+ // Non-template base class responsible for handling the length and max.</span>
  
<span class="udiff-line-modified-removed">- #include &lt;new&gt;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Need the correct linkage to call qsort without warnings</span>
<span class="udiff-line-removed">- extern &quot;C&quot; {</span>
<span class="udiff-line-removed">-   typedef int (*_sort_Fn)(const void *, const void *);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+ </span>
  class GrowableArrayBase : public ResourceObj {
    friend class VMStructs;
  
<span class="udiff-line-modified-removed">-  protected:</span>
<span class="udiff-line-modified-removed">-   int    _len;          // current length</span>
<span class="udiff-line-modified-removed">-   int    _max;          // maximum length</span>
<span class="udiff-line-modified-removed">-   Arena* _arena;        // Indicates where allocation occurs:</span>
<span class="udiff-line-modified-removed">-                         //   0 means default ResourceArea</span>
<span class="udiff-line-removed">-                         //   1 means on C heap</span>
<span class="udiff-line-removed">-                         //   otherwise, allocate in _arena</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   MEMFLAGS   _memflags;   // memory type if allocation in C heap</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-   int    _nesting;      // resource area nesting at creation</span>
<span class="udiff-line-removed">-   void   set_nesting();</span>
<span class="udiff-line-removed">-   void   check_nesting();</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">- #define  set_nesting();</span>
<span class="udiff-line-removed">- #define  check_nesting();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Where are we going to allocate memory?</span>
<span class="udiff-line-removed">-   bool on_C_heap() { return _arena == (Arena*)1; }</span>
<span class="udiff-line-removed">-   bool on_stack () { return _arena == NULL;      }</span>
<span class="udiff-line-removed">-   bool on_arena () { return _arena &gt;  (Arena*)1;  }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // This GA will use the resource stack for storage if c_heap==false,</span>
<span class="udiff-line-removed">-   // Else it will use the C heap.  Use clear_and_deallocate to avoid leaks.</span>
<span class="udiff-line-removed">-   GenericGrowableArray(int initial_size, int initial_len, MEMFLAGS flags) {</span>
<span class="udiff-line-removed">-     _len = initial_len;</span>
<span class="udiff-line-removed">-     _max = initial_size;</span>
<span class="udiff-line-removed">-     _memflags = flags;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     const bool c_heap = flags != mtNone;</span>
<span class="udiff-line-removed">-     _arena = (c_heap ? (Arena*)1 : NULL);</span>
<span class="udiff-line-removed">-     set_nesting();</span>
<span class="udiff-line-removed">-     assert(!on_C_heap() || allocated_on_C_heap(), &quot;growable array must be on C heap if elements are&quot;);</span>
<span class="udiff-line-removed">-     assert(!on_stack() ||</span>
<span class="udiff-line-removed">-            (allocated_on_res_area() || allocated_on_stack()),</span>
<span class="udiff-line-removed">-            &quot;growable array must be on stack if elements are not on arena and not on C heap&quot;);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+ protected:</span>
<span class="udiff-line-modified-added">+   // Current number of accessible elements</span>
<span class="udiff-line-modified-added">+   int _len;</span>
<span class="udiff-line-modified-added">+   // Current number of allocated elements</span>
<span class="udiff-line-modified-added">+   int _max;</span>
  
<span class="udiff-line-modified-removed">-   // This GA will use the given arena for storage.</span>
<span class="udiff-line-modified-removed">-   // Consider using new(arena) GrowableArray&lt;T&gt; to allocate the header.</span>
<span class="udiff-line-modified-removed">-   GenericGrowableArray(Arena* arena, int initial_size, int initial_len) {</span>
<span class="udiff-line-removed">-     _len = initial_len;</span>
<span class="udiff-line-removed">-     _max = initial_size;</span>
<span class="udiff-line-modified-added">+   GrowableArrayBase(int initial_max, int initial_len) :</span>
<span class="udiff-line-modified-added">+       _len(initial_len),</span>
<span class="udiff-line-modified-added">+       _max(initial_max) {</span>
      assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);
<span class="udiff-line-removed">-     _arena = arena;</span>
<span class="udiff-line-removed">-     _memflags = mtNone;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     assert(on_arena(), &quot;arena has taken on reserved value 0 or 1&quot;);</span>
<span class="udiff-line-removed">-     // Relax next assert to allow object allocation on resource area,</span>
<span class="udiff-line-removed">-     // on stack or embedded into an other object.</span>
<span class="udiff-line-removed">-     assert(allocated_on_arena() || allocated_on_stack(),</span>
<span class="udiff-line-removed">-            &quot;growable array must be on arena or on stack if elements are on arena&quot;);</span>
    }
  
<span class="udiff-line-modified-removed">-   void* raw_allocate(int elementSize);</span>
<span class="udiff-line-modified-added">+   ~GrowableArrayBase() {}</span>
  
<span class="udiff-line-removed">-   void free_C_heap(void* elements);</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- template&lt;class E&gt; class GrowableArrayIterator;</span>
<span class="udiff-line-removed">- template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- template&lt;class E&gt;</span>
<span class="udiff-line-removed">- class CompareClosure : public Closure {</span>
<span class="udiff-line-removed">- public:</span>
<span class="udiff-line-removed">-     virtual int do_compare(const E&amp;, const E&amp;) = 0;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- template&lt;class E&gt; class GrowableArray : public GenericGrowableArray {</span>
<span class="udiff-line-removed">-   friend class VMStructs;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-  private:</span>
<span class="udiff-line-removed">-   E*     _data;         // data array</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void grow(int j);</span>
<span class="udiff-line-removed">-   void raw_at_put_grow(int i, const E&amp; p, const E&amp; fill);</span>
<span class="udiff-line-removed">-   void  clear_and_deallocate();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- public:</span>
<span class="udiff-line-removed">-   GrowableArray(int initial_size, MEMFLAGS F = mtNone)</span>
<span class="udiff-line-removed">-     : GenericGrowableArray(initial_size, 0, F) {</span>
<span class="udiff-line-removed">-     _data = (E*)raw_allocate(sizeof(E));</span>
<span class="udiff-line-removed">- // Needed for Visual Studio 2012 and older</span>
<span class="udiff-line-removed">- #ifdef _MSC_VER</span>
<span class="udiff-line-removed">- #pragma warning(suppress: 4345)</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   GrowableArray(int initial_size, int initial_len, const E&amp; filler, MEMFLAGS memflags = mtNone)</span>
<span class="udiff-line-removed">-     : GenericGrowableArray(initial_size, initial_len, memflags) {</span>
<span class="udiff-line-removed">-     _data = (E*)raw_allocate(sizeof(E));</span>
<span class="udiff-line-removed">-     int i = 0;</span>
<span class="udiff-line-removed">-     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);</span>
<span class="udiff-line-removed">-     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Watch out, if filler was generated by a constructor, the destuctor might</span>
<span class="udiff-line-removed">-   // be called on the original object invalidating all the copies made here.</span>
<span class="udiff-line-removed">-   // Carefully design the copy constructor.</span>
<span class="udiff-line-removed">-   GrowableArray(Arena* arena, int initial_size, int initial_len, const E&amp; filler) :</span>
<span class="udiff-line-removed">-       GenericGrowableArray(arena, initial_size, initial_len) {</span>
<span class="udiff-line-removed">-     _data = (E*)raw_allocate(sizeof(E));</span>
<span class="udiff-line-removed">-     int i = 0;</span>
<span class="udiff-line-removed">-     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);</span>
<span class="udiff-line-removed">-     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   GrowableArray() : GenericGrowableArray(2, 0, mtNone) {</span>
<span class="udiff-line-removed">-     _data = (E*)raw_allocate(sizeof(E));</span>
<span class="udiff-line-removed">-     ::new ((void*)&amp;_data[0]) E();</span>
<span class="udiff-line-removed">-     ::new ((void*)&amp;_data[1]) E();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                                 // Does nothing for resource and arena objects</span>
<span class="udiff-line-removed">-   ~GrowableArray()              { if (on_C_heap()) clear_and_deallocate(); }</span>
<span class="udiff-line-removed">- </span>
  public:
    int   length() const          { return _len; }
    int   max_length() const      { return _max; }
<span class="udiff-line-modified-removed">-   void  trunc_to(int l)         { assert(l &lt;= _len,&quot;cannot increase length&quot;); _len = l; }</span>
<span class="udiff-line-modified-added">+ </span>
    bool  is_empty() const        { return _len == 0; }
    bool  is_nonempty() const     { return _len != 0; }
    bool  is_full() const         { return _len == _max; }
<span class="udiff-line-modified-removed">-   DEBUG_ONLY(E* data_addr() const      { return _data; })</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   void print();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   int append(const E&amp; elem) {</span>
<span class="udiff-line-removed">-     check_nesting();</span>
<span class="udiff-line-removed">-     if (_len == _max) grow(_len);</span>
<span class="udiff-line-removed">-     int idx = _len++;</span>
<span class="udiff-line-removed">-     _data[idx] = elem;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   void  clear()                 { _len = 0; }</span>
<span class="udiff-line-modified-added">+   void  trunc_to(int length)    {</span>
<span class="udiff-line-modified-added">+     assert(length &lt;= _len,&quot;cannot increase length&quot;);</span>
      _len = length;
    }
<span class="udiff-line-added">+ };</span>
  
<span class="udiff-line-modified-removed">-   bool append_if_missing(const E&amp; elem) {</span>
<span class="udiff-line-modified-removed">-     // Returns TRUE if elem is added.</span>
<span class="udiff-line-modified-removed">-     bool missed = !contains(elem);</span>
<span class="udiff-line-modified-removed">-     if (missed) append(elem);</span>
<span class="udiff-line-modified-removed">-     return missed;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+ template &lt;typename E&gt; class GrowableArrayIterator;</span>
<span class="udiff-line-modified-added">+ template &lt;typename E, typename UnaryPredicate&gt; class GrowableArrayFilterIterator;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ // Extends GrowableArrayBase with a typed data array.</span>
<span class="udiff-line-modified-added">+ //</span>
<span class="udiff-line-modified-added">+ // E: Element type</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // The &quot;view&quot; adds function that don&#39;t grow or deallocate</span>
<span class="udiff-line-added">+ // the _data array, so there&#39;s no need for an allocator.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // The &quot;view&quot; can be used to type erase the allocator classes</span>
<span class="udiff-line-added">+ // of GrowableArrayWithAllocator.</span>
<span class="udiff-line-added">+ template &lt;typename E&gt;</span>
<span class="udiff-line-added">+ class GrowableArrayView : public GrowableArrayBase {</span>
<span class="udiff-line-added">+ protected:</span>
<span class="udiff-line-added">+   E* _data; // data array</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GrowableArrayView&lt;E&gt;(E* data, int initial_max, int initial_len) :</span>
<span class="udiff-line-added">+       GrowableArrayBase(initial_max, initial_len), _data(data) {}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ~GrowableArrayView() {}</span>
  
<span class="udiff-line-added">+ public:</span>
    E&amp; at(int i) {
      assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
      return _data[i];
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -263,40 +161,20 @@</span>
  
    GrowableArrayIterator&lt;E&gt; end() const {
      return GrowableArrayIterator&lt;E&gt;(this, length());
    }
  
<span class="udiff-line-removed">-   void push(const E&amp; elem) { append(elem); }</span>
<span class="udiff-line-removed">- </span>
    E pop() {
      assert(_len &gt; 0, &quot;empty list&quot;);
      return _data[--_len];
    }
  
    void at_put(int i, const E&amp; elem) {
      assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
      _data[i] = elem;
    }
  
<span class="udiff-line-removed">-   E at_grow(int i, const E&amp; fill = E()) {</span>
<span class="udiff-line-removed">-     assert(0 &lt;= i, &quot;negative index&quot;);</span>
<span class="udiff-line-removed">-     check_nesting();</span>
<span class="udiff-line-removed">-     if (i &gt;= _len) {</span>
<span class="udiff-line-removed">-       if (i &gt;= _max) grow(i);</span>
<span class="udiff-line-removed">-       for (int j = _len; j &lt;= i; j++)</span>
<span class="udiff-line-removed">-         _data[j] = fill;</span>
<span class="udiff-line-removed">-       _len = i+1;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return _data[i];</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void at_put_grow(int i, const E&amp; elem, const E&amp; fill = E()) {</span>
<span class="udiff-line-removed">-     assert(0 &lt;= i, &quot;negative index&quot;);</span>
<span class="udiff-line-removed">-     check_nesting();</span>
<span class="udiff-line-removed">-     raw_at_put_grow(i, elem, fill);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    bool contains(const E&amp; elem) const {
      for (int i = 0; i &lt; _len; i++) {
        if (_data[i] == elem) return true;
      }
      return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -356,73 +234,18 @@</span>
        // Replace removed element with last one.
        _data[index] = _data[_len];
      }
    }
  
<span class="udiff-line-modified-removed">-   // inserts the given element before the element at index i</span>
<span class="udiff-line-removed">-   void insert_before(const int idx, const E&amp; elem) {</span>
<span class="udiff-line-removed">-     assert(0 &lt;= idx &amp;&amp; idx &lt;= _len, &quot;illegal index&quot;);</span>
<span class="udiff-line-removed">-     check_nesting();</span>
<span class="udiff-line-removed">-     if (_len == _max) grow(_len);</span>
<span class="udiff-line-removed">-     for (int j = _len - 1; j &gt;= idx; j--) {</span>
<span class="udiff-line-removed">-       _data[j + 1] = _data[j];</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     _len++;</span>
<span class="udiff-line-removed">-     _data[idx] = elem;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void insert_before(const int idx, const GrowableArray&lt;E&gt;* array) {</span>
<span class="udiff-line-removed">-     assert(0 &lt;= idx &amp;&amp; idx &lt;= _len, &quot;illegal index&quot;);</span>
<span class="udiff-line-removed">-     check_nesting();</span>
<span class="udiff-line-removed">-     int array_len = array-&gt;length();</span>
<span class="udiff-line-removed">-     int new_len = _len + array_len;</span>
<span class="udiff-line-removed">-     if (new_len &gt;= _max) grow(new_len);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (int j = _len - 1; j &gt;= idx; j--) {</span>
<span class="udiff-line-removed">-       _data[j + array_len] = _data[j];</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (int j = 0; j &lt; array_len; j++) {</span>
<span class="udiff-line-removed">-       _data[idx + j] = array-&gt;_data[j];</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     _len += array_len;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void appendAll(const GrowableArray&lt;E&gt;* l) {</span>
<span class="udiff-line-removed">-     for (int i = 0; i &lt; l-&gt;_len; i++) {</span>
<span class="udiff-line-removed">-       raw_at_put_grow(_len, l-&gt;_data[i], E());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void appendAll(const Array&lt;E&gt;* l) {</span>
<span class="udiff-line-removed">-     for (int i = 0; i &lt; l-&gt;length(); i++) {</span>
<span class="udiff-line-removed">-       raw_at_put_grow(_len, l-&gt;at(i), E());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void sort(int f(E*,E*)) {</span>
<span class="udiff-line-modified-added">+   void sort(int f(E*, E*)) {</span>
      qsort(_data, length(), sizeof(E), (_sort_Fn)f);
    }
    // sort by fixed-stride sub arrays:
<span class="udiff-line-modified-removed">-   void sort(int f(E*,E*), int stride) {</span>
<span class="udiff-line-modified-added">+   void sort(int f(E*, E*), int stride) {</span>
      qsort(_data, length() / stride, sizeof(E) * stride, (_sort_Fn)f);
    }
  
<span class="udiff-line-removed">-   // Binary search and insertion utility.  Search array for element</span>
<span class="udiff-line-removed">-   // matching key according to the static compare function.  Insert</span>
<span class="udiff-line-removed">-   // that element is not already in the list.  Assumes the list is</span>
<span class="udiff-line-removed">-   // already sorted according to compare function.</span>
<span class="udiff-line-removed">-   template &lt;int compare(const E&amp;, const E&amp;)&gt; E insert_sorted(const E&amp; key) {</span>
<span class="udiff-line-removed">-     bool found;</span>
<span class="udiff-line-removed">-     int location = find_sorted&lt;E, compare&gt;(key, found);</span>
<span class="udiff-line-removed">-     if (!found) {</span>
<span class="udiff-line-removed">-       insert_before(location, key);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return at(location);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    template &lt;typename K, int compare(const K&amp;, const E&amp;)&gt; int find_sorted(const K&amp; key, bool&amp; found) {
      found = false;
      int min = 0;
      int max = length() - 1;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -440,20 +263,11 @@</span>
        }
      }
      return min;
    }
  
<span class="udiff-line-modified-removed">-   E insert_sorted(CompareClosure&lt;E&gt;* cc, const E&amp; key) {</span>
<span class="udiff-line-removed">-     bool found;</span>
<span class="udiff-line-removed">-     int location = find_sorted(cc, key, found);</span>
<span class="udiff-line-removed">-     if (!found) {</span>
<span class="udiff-line-removed">-       insert_before(location, key);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return at(location);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   template&lt;typename K&gt;</span>
<span class="udiff-line-modified-added">+   template &lt;typename K&gt;</span>
    int find_sorted(CompareClosure&lt;E&gt;* cc, const K&amp; key, bool&amp; found) {
      found = false;
      int min = 0;
      int max = length() - 1;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -470,84 +284,452 @@</span>
          return mid;
        }
      }
      return min;
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void print() {</span>
<span class="udiff-line-added">+     tty-&gt;print(&quot;Growable Array &quot; INTPTR_FORMAT, this);</span>
<span class="udiff-line-added">+     tty-&gt;print(&quot;: length %ld (_max %ld) { &quot;, _len, _max);</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; _len; i++) {</span>
<span class="udiff-line-added">+       tty-&gt;print(INTPTR_FORMAT &quot; &quot;, *(intptr_t*)&amp;(_data[i]));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     tty-&gt;print(&quot;}\n&quot;);</span>
<span class="udiff-line-added">+   }</span>
  };
  
<span class="udiff-line-modified-removed">- // Global GrowableArray methods (one instance in the library per each &#39;E&#39; type).</span>
<span class="udiff-line-modified-added">+ // GrowableArrayWithAllocator extends the &quot;view&quot; with</span>
<span class="udiff-line-added">+ // the capability to grow and deallocate the data array.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // The allocator responsibility is delegated to the sub-class.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Derived: The sub-class responsible for allocation / deallocation</span>
<span class="udiff-line-added">+ //  - E* Derived::allocate()       - member function responsible for allocation</span>
<span class="udiff-line-added">+ //  - void Derived::deallocate(E*) - member function responsible for deallocation</span>
<span class="udiff-line-added">+ template &lt;typename E, typename Derived&gt;</span>
<span class="udiff-line-added">+ class GrowableArrayWithAllocator : public GrowableArrayView&lt;E&gt; {</span>
<span class="udiff-line-added">+   friend class VMStructs;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void grow(int j);</span>
  
<span class="udiff-line-modified-removed">- template&lt;class E&gt; void GrowableArray&lt;E&gt;::grow(int j) {</span>
<span class="udiff-line-modified-removed">-     int old_max = _max;</span>
<span class="udiff-line-modified-removed">-     // grow the array by increasing _max to the first power of two larger than the size we need</span>
<span class="udiff-line-modified-removed">-     _max = next_power_of_2((uint32_t)j);</span>
<span class="udiff-line-modified-removed">-     // j &lt; _max</span>
<span class="udiff-line-modified-removed">-     E* newData = (E*)raw_allocate(sizeof(E));</span>
<span class="udiff-line-modified-added">+ protected:</span>
<span class="udiff-line-modified-added">+   GrowableArrayWithAllocator(E* data, int initial_max) :</span>
<span class="udiff-line-modified-added">+       GrowableArrayView&lt;E&gt;(data, initial_max, 0) {</span>
<span class="udiff-line-modified-added">+     for (int i = 0; i &lt; initial_max; i++) {</span>
<span class="udiff-line-modified-added">+       ::new ((void*)&amp;data[i]) E();</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GrowableArrayWithAllocator(E* data, int initial_max, int initial_len, const E&amp; filler) :</span>
<span class="udiff-line-added">+       GrowableArrayView&lt;E&gt;(data, initial_max, initial_len) {</span>
      int i = 0;
<span class="udiff-line-modified-removed">-     for (     ; i &lt; _len; i++) ::new ((void*)&amp;newData[i]) E(_data[i]);</span>
<span class="udiff-line-modified-removed">- // Needed for Visual Studio 2012 and older</span>
<span class="udiff-line-removed">- #ifdef _MSC_VER</span>
<span class="udiff-line-removed">- #pragma warning(suppress: 4345)</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     for (     ; i &lt; _max; i++) ::new ((void*)&amp;newData[i]) E();</span>
<span class="udiff-line-removed">-     for (i = 0; i &lt; old_max; i++) _data[i].~E();</span>
<span class="udiff-line-removed">-     if (on_C_heap() &amp;&amp; _data != NULL) {</span>
<span class="udiff-line-removed">-       free_C_heap(_data);</span>
<span class="udiff-line-modified-added">+     for (; i &lt; initial_len; i++) {</span>
<span class="udiff-line-modified-added">+       ::new ((void*)&amp;data[i]) E(filler);</span>
      }
<span class="udiff-line-modified-removed">-     _data = newData;</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-added">+     for (; i &lt; initial_max; i++) {</span>
<span class="udiff-line-modified-added">+       ::new ((void*)&amp;data[i]) E();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ~GrowableArrayWithAllocator() {}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   int append(const E&amp; elem) {</span>
<span class="udiff-line-added">+     if (this-&gt;_len == this-&gt;_max) grow(this-&gt;_len);</span>
<span class="udiff-line-added">+     int idx = this-&gt;_len++;</span>
<span class="udiff-line-added">+     this-&gt;_data[idx] = elem;</span>
<span class="udiff-line-added">+     return idx;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool append_if_missing(const E&amp; elem) {</span>
<span class="udiff-line-added">+     // Returns TRUE if elem is added.</span>
<span class="udiff-line-added">+     bool missed = !this-&gt;contains(elem);</span>
<span class="udiff-line-added">+     if (missed) append(elem);</span>
<span class="udiff-line-added">+     return missed;</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">- template&lt;class E&gt; void GrowableArray&lt;E&gt;::raw_at_put_grow(int i, const E&amp; p, const E&amp; fill) {</span>
<span class="udiff-line-modified-removed">-     if (i &gt;= _len) {</span>
<span class="udiff-line-modified-removed">-       if (i &gt;= _max) grow(i);</span>
<span class="udiff-line-modified-removed">-       for (int j = _len; j &lt; i; j++)</span>
<span class="udiff-line-modified-removed">-         _data[j] = fill;</span>
<span class="udiff-line-modified-removed">-       _len = i+1;</span>
<span class="udiff-line-modified-added">+   void push(const E&amp; elem) { append(elem); }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   E at_grow(int i, const E&amp; fill = E()) {</span>
<span class="udiff-line-modified-added">+     assert(0 &lt;= i, &quot;negative index&quot;);</span>
<span class="udiff-line-modified-added">+     if (i &gt;= this-&gt;_len) {</span>
<span class="udiff-line-modified-added">+       if (i &gt;= this-&gt;_max) grow(i);</span>
<span class="udiff-line-added">+       for (int j = this-&gt;_len; j &lt;= i; j++)</span>
<span class="udiff-line-added">+         this-&gt;_data[j] = fill;</span>
<span class="udiff-line-added">+       this-&gt;_len = i+1;</span>
      }
<span class="udiff-line-modified-removed">-     _data[i] = p;</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-added">+     return this-&gt;_data[i];</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void at_put_grow(int i, const E&amp; elem, const E&amp; fill = E()) {</span>
<span class="udiff-line-added">+     assert(0 &lt;= i, &quot;negative index&quot;);</span>
<span class="udiff-line-added">+     if (i &gt;= this-&gt;_len) {</span>
<span class="udiff-line-added">+       if (i &gt;= this-&gt;_max) grow(i);</span>
<span class="udiff-line-added">+       for (int j = this-&gt;_len; j &lt; i; j++)</span>
<span class="udiff-line-added">+         this-&gt;_data[j] = fill;</span>
<span class="udiff-line-added">+       this-&gt;_len = i+1;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     this-&gt;_data[i] = elem;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // inserts the given element before the element at index i</span>
<span class="udiff-line-added">+   void insert_before(const int idx, const E&amp; elem) {</span>
<span class="udiff-line-added">+     assert(0 &lt;= idx &amp;&amp; idx &lt;= this-&gt;_len, &quot;illegal index&quot;);</span>
<span class="udiff-line-added">+     if (this-&gt;_len == this-&gt;_max) grow(this-&gt;_len);</span>
<span class="udiff-line-added">+     for (int j = this-&gt;_len - 1; j &gt;= idx; j--) {</span>
<span class="udiff-line-added">+       this-&gt;_data[j + 1] = this-&gt;_data[j];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     this-&gt;_len++;</span>
<span class="udiff-line-added">+     this-&gt;_data[idx] = elem;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void insert_before(const int idx, const GrowableArrayView&lt;E&gt;* array) {</span>
<span class="udiff-line-added">+     assert(0 &lt;= idx &amp;&amp; idx &lt;= this-&gt;_len, &quot;illegal index&quot;);</span>
<span class="udiff-line-added">+     int array_len = array-&gt;length();</span>
<span class="udiff-line-added">+     int new_len = this-&gt;_len + array_len;</span>
<span class="udiff-line-added">+     if (new_len &gt;= this-&gt;_max) grow(new_len);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (int j = this-&gt;_len - 1; j &gt;= idx; j--) {</span>
<span class="udiff-line-added">+       this-&gt;_data[j + array_len] = this-&gt;_data[j];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (int j = 0; j &lt; array_len; j++) {</span>
<span class="udiff-line-added">+       this-&gt;_data[idx + j] = array-&gt;at(j);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     this-&gt;_len += array_len;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void appendAll(const GrowableArrayView&lt;E&gt;* l) {</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; l-&gt;length(); i++) {</span>
<span class="udiff-line-added">+       this-&gt;at_put_grow(this-&gt;_len, l-&gt;at(i), E());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void appendAll(const Array&lt;E&gt;* l) {</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; l-&gt;length(); i++) {</span>
<span class="udiff-line-added">+       this-&gt;at_put_grow(this-&gt;_len, l-&gt;at(i), E());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Binary search and insertion utility.  Search array for element</span>
<span class="udiff-line-added">+   // matching key according to the static compare function.  Insert</span>
<span class="udiff-line-added">+   // that element is not already in the list.  Assumes the list is</span>
<span class="udiff-line-added">+   // already sorted according to compare function.</span>
<span class="udiff-line-added">+   template &lt;int compare(const E&amp;, const E&amp;)&gt; E insert_sorted(const E&amp; key) {</span>
<span class="udiff-line-added">+     bool found;</span>
<span class="udiff-line-added">+     int location = GrowableArrayView&lt;E&gt;::template find_sorted&lt;E, compare&gt;(key, found);</span>
<span class="udiff-line-added">+     if (!found) {</span>
<span class="udiff-line-added">+       insert_before(location, key);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return this-&gt;at(location);</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">- // This function clears and deallocate the data in the growable array that</span>
<span class="udiff-line-modified-removed">- // has been allocated on the C heap.  It&#39;s not public - called by the</span>
<span class="udiff-line-modified-removed">- // destructor.</span>
<span class="udiff-line-modified-removed">- template&lt;class E&gt; void GrowableArray&lt;E&gt;::clear_and_deallocate() {</span>
<span class="udiff-line-modified-removed">-     assert(on_C_heap(),</span>
<span class="udiff-line-removed">-            &quot;clear_and_deallocate should only be called when on C heap&quot;);</span>
<span class="udiff-line-removed">-     clear();</span>
<span class="udiff-line-removed">-     if (_data != NULL) {</span>
<span class="udiff-line-removed">-       for (int i = 0; i &lt; _max; i++) _data[i].~E();</span>
<span class="udiff-line-removed">-       free_C_heap(_data);</span>
<span class="udiff-line-removed">-       _data = NULL;</span>
<span class="udiff-line-modified-added">+   E insert_sorted(CompareClosure&lt;E&gt;* cc, const E&amp; key) {</span>
<span class="udiff-line-modified-added">+     bool found;</span>
<span class="udiff-line-modified-added">+     int location = find_sorted(cc, key, found);</span>
<span class="udiff-line-modified-added">+     if (!found) {</span>
<span class="udiff-line-modified-added">+       insert_before(location, key);</span>
      }
<span class="udiff-line-added">+     return this-&gt;at(location);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void clear_and_deallocate();</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename E, typename Derived&gt;</span>
<span class="udiff-line-added">+ void GrowableArrayWithAllocator&lt;E, Derived&gt;::grow(int j) {</span>
<span class="udiff-line-added">+   int old_max = this-&gt;_max;</span>
<span class="udiff-line-added">+   // grow the array by increasing _max to the first power of two larger than the size we need</span>
<span class="udiff-line-added">+   this-&gt;_max = next_power_of_2((uint32_t)j);</span>
<span class="udiff-line-added">+   // j &lt; _max</span>
<span class="udiff-line-added">+   E* newData = static_cast&lt;Derived*&gt;(this)-&gt;allocate();</span>
<span class="udiff-line-added">+   int i = 0;</span>
<span class="udiff-line-added">+   for (     ; i &lt; this-&gt;_len; i++) ::new ((void*)&amp;newData[i]) E(this-&gt;_data[i]);</span>
<span class="udiff-line-added">+   for (     ; i &lt; this-&gt;_max; i++) ::new ((void*)&amp;newData[i]) E();</span>
<span class="udiff-line-added">+   for (i = 0; i &lt; old_max; i++) this-&gt;_data[i].~E();</span>
<span class="udiff-line-added">+   if (this-&gt;_data != NULL) {</span>
<span class="udiff-line-added">+     static_cast&lt;Derived*&gt;(this)-&gt;deallocate(this-&gt;_data);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   this-&gt;_data = newData;</span>
  }
  
<span class="udiff-line-modified-removed">- template&lt;class E&gt; void GrowableArray&lt;E&gt;::print() {</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot;Growable Array &quot; INTPTR_FORMAT, this);</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot;: length %ld (_max %ld) { &quot;, _len, _max);</span>
<span class="udiff-line-modified-removed">-     for (int i = 0; i &lt; _len; i++) tty-&gt;print(INTPTR_FORMAT &quot; &quot;, *(intptr_t*)&amp;(_data[i]));</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot;}\n&quot;);</span>
<span class="udiff-line-modified-added">+ template &lt;typename E, typename Derived&gt;</span>
<span class="udiff-line-modified-added">+ void GrowableArrayWithAllocator&lt;E, Derived&gt;::clear_and_deallocate() {</span>
<span class="udiff-line-modified-added">+   if (this-&gt;_data != NULL) {</span>
<span class="udiff-line-modified-added">+     for (int i = 0; i &lt; this-&gt;_max; i++) {</span>
<span class="udiff-line-modified-added">+       this-&gt;_data[i].~E();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     static_cast&lt;Derived*&gt;(this)-&gt;deallocate(this-&gt;_data);</span>
<span class="udiff-line-added">+     this-&gt;_data = NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   this-&gt;_len = 0;</span>
<span class="udiff-line-added">+   this-&gt;_max = 0;</span>
  }
  
<span class="udiff-line-added">+ class GrowableArrayResourceAllocator {</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   static void* allocate(int max, int element_size);</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Arena allocator</span>
<span class="udiff-line-added">+ class GrowableArrayArenaAllocator {</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   static void* allocate(int max, int element_size, Arena* arena);</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // CHeap allocator</span>
<span class="udiff-line-added">+ class GrowableArrayCHeapAllocator {</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   static void* allocate(int max, int element_size, MEMFLAGS memflags);</span>
<span class="udiff-line-added">+   static void deallocate(void* mem);</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Checks resource allocation nesting</span>
<span class="udiff-line-added">+ class GrowableArrayNestingCheck {</span>
<span class="udiff-line-added">+   // resource area nesting at creation</span>
<span class="udiff-line-added">+   int _nesting;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   GrowableArrayNestingCheck(bool on_stack);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void on_stack_alloc() const;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #endif // ASSERT</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Encodes where the backing array is allocated</span>
<span class="udiff-line-added">+ // and performs necessary checks.</span>
<span class="udiff-line-added">+ class GrowableArrayMetadata {</span>
<span class="udiff-line-added">+   uintptr_t _bits;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // resource area nesting at creation</span>
<span class="udiff-line-added">+   debug_only(GrowableArrayNestingCheck _nesting_check;)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uintptr_t bits(MEMFLAGS memflags) const {</span>
<span class="udiff-line-added">+     if (memflags == mtNone) {</span>
<span class="udiff-line-added">+       // Stack allocation</span>
<span class="udiff-line-added">+       return 0;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // CHeap allocation</span>
<span class="udiff-line-added">+     return (uintptr_t(memflags) &lt;&lt; 1) | 1;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uintptr_t bits(Arena* arena) const {</span>
<span class="udiff-line-added">+     return uintptr_t(arena);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   GrowableArrayMetadata(Arena* arena) :</span>
<span class="udiff-line-added">+       _bits(bits(arena))</span>
<span class="udiff-line-added">+       debug_only(COMMA _nesting_check(on_stack())) {</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GrowableArrayMetadata(MEMFLAGS memflags) :</span>
<span class="udiff-line-added">+       _bits(bits(memflags))</span>
<span class="udiff-line-added">+       debug_only(COMMA _nesting_check(on_stack())) {</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+   GrowableArrayMetadata(const GrowableArrayMetadata&amp; other) :</span>
<span class="udiff-line-added">+       _bits(other._bits),</span>
<span class="udiff-line-added">+       _nesting_check(other._nesting_check) {</span>
<span class="udiff-line-added">+     assert(!on_C_heap(), &quot;Copying of CHeap arrays not supported&quot;);</span>
<span class="udiff-line-added">+     assert(!other.on_C_heap(), &quot;Copying of CHeap arrays not supported&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GrowableArrayMetadata&amp; operator=(const GrowableArrayMetadata&amp; other) {</span>
<span class="udiff-line-added">+     _bits = other._bits;</span>
<span class="udiff-line-added">+     _nesting_check = other._nesting_check;</span>
<span class="udiff-line-added">+     assert(!on_C_heap(), &quot;Assignment of CHeap arrays not supported&quot;);</span>
<span class="udiff-line-added">+     assert(!other.on_C_heap(), &quot;Assignment of CHeap arrays not supported&quot;);</span>
<span class="udiff-line-added">+     return *this;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void init_checks(const GrowableArrayBase* array) const;</span>
<span class="udiff-line-added">+   void on_stack_alloc_check() const;</span>
<span class="udiff-line-added">+ #endif // ASSERT</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool on_C_heap() const { return (_bits &amp; 1) == 1; }</span>
<span class="udiff-line-added">+   bool on_stack () const { return _bits == 0;      }</span>
<span class="udiff-line-added">+   bool on_arena () const { return (_bits &amp; 1) == 0 &amp;&amp; _bits != 0; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Arena* arena() const      { return (Arena*)_bits; }</span>
<span class="udiff-line-added">+   MEMFLAGS memflags() const { return MEMFLAGS(_bits &gt;&gt; 1); }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // THE GrowableArray.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Supports multiple allocation strategies:</span>
<span class="udiff-line-added">+ //  - Resource stack allocation: if memflags == mtNone</span>
<span class="udiff-line-added">+ //  - CHeap allocation: if memflags != mtNone</span>
<span class="udiff-line-added">+ //  - Arena allocation: if an arena is provided</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // There are some drawbacks of using GrowableArray, that are removed in some</span>
<span class="udiff-line-added">+ // of the other implementations of GrowableArrayWithAllocator sub-classes:</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Memory overhead: The multiple allocation strategies uses extra metadata</span>
<span class="udiff-line-added">+ //  embedded in the instance.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Strict allocation locations: There are rules about where the GrowableArray</span>
<span class="udiff-line-added">+ //  instance is allocated, that depends on where the data array is allocated.</span>
<span class="udiff-line-added">+ //  See: init_checks.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename E&gt;</span>
<span class="udiff-line-added">+ class GrowableArray : public GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt; {</span>
<span class="udiff-line-added">+   friend class GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt;;</span>
<span class="udiff-line-added">+   friend class GrowableArrayTest;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static E* allocate(int max) {</span>
<span class="udiff-line-added">+     return (E*)GrowableArrayResourceAllocator::allocate(max, sizeof(E));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static E* allocate(int max, MEMFLAGS memflags) {</span>
<span class="udiff-line-added">+     if (memflags != mtNone) {</span>
<span class="udiff-line-added">+       return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), memflags);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return (E*)GrowableArrayResourceAllocator::allocate(max, sizeof(E));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static E* allocate(int max, Arena* arena) {</span>
<span class="udiff-line-added">+     return (E*)GrowableArrayArenaAllocator::allocate(max, sizeof(E), arena);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GrowableArrayMetadata _metadata;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void init_checks() const { debug_only(_metadata.init_checks(this);) }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Where are we going to allocate memory?</span>
<span class="udiff-line-added">+   bool on_C_heap() const { return _metadata.on_C_heap(); }</span>
<span class="udiff-line-added">+   bool on_stack () const { return _metadata.on_stack(); }</span>
<span class="udiff-line-added">+   bool on_arena () const { return _metadata.on_arena(); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   E* allocate() {</span>
<span class="udiff-line-added">+     if (on_stack()) {</span>
<span class="udiff-line-added">+       debug_only(_metadata.on_stack_alloc_check());</span>
<span class="udiff-line-added">+       return allocate(this-&gt;_max);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (on_C_heap()) {</span>
<span class="udiff-line-added">+       return allocate(this-&gt;_max, _metadata.memflags());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     assert(on_arena(), &quot;Sanity&quot;);</span>
<span class="udiff-line-added">+     return allocate(this-&gt;_max, _metadata.arena());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void deallocate(E* mem) {</span>
<span class="udiff-line-added">+     if (on_C_heap()) {</span>
<span class="udiff-line-added">+       GrowableArrayCHeapAllocator::deallocate(mem);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   GrowableArray(int initial_max = 2, MEMFLAGS memflags = mtNone) :</span>
<span class="udiff-line-added">+       GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt;(</span>
<span class="udiff-line-added">+           allocate(initial_max, memflags),</span>
<span class="udiff-line-added">+           initial_max),</span>
<span class="udiff-line-added">+       _metadata(memflags) {</span>
<span class="udiff-line-added">+     init_checks();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GrowableArray(int initial_max, int initial_len, const E&amp; filler, MEMFLAGS memflags = mtNone) :</span>
<span class="udiff-line-added">+       GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt;(</span>
<span class="udiff-line-added">+           allocate(initial_max, memflags),</span>
<span class="udiff-line-added">+           initial_max, initial_len, filler),</span>
<span class="udiff-line-added">+       _metadata(memflags) {</span>
<span class="udiff-line-added">+     init_checks();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GrowableArray(Arena* arena, int initial_max, int initial_len, const E&amp; filler) :</span>
<span class="udiff-line-added">+       GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt;(</span>
<span class="udiff-line-added">+           allocate(initial_max, arena),</span>
<span class="udiff-line-added">+           initial_max, initial_len, filler),</span>
<span class="udiff-line-added">+       _metadata(arena) {</span>
<span class="udiff-line-added">+     init_checks();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ~GrowableArray() {</span>
<span class="udiff-line-added">+     if (on_C_heap()) {</span>
<span class="udiff-line-added">+       this-&gt;clear_and_deallocate();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Leaner GrowableArray for CHeap backed data arrays, with compile-time decided MEMFLAGS.</span>
<span class="udiff-line-added">+ template &lt;typename E, MEMFLAGS F&gt;</span>
<span class="udiff-line-added">+ class GrowableArrayCHeap : public GrowableArrayWithAllocator&lt;E, GrowableArrayCHeap&lt;E, F&gt; &gt; {</span>
<span class="udiff-line-added">+   friend class GrowableArrayWithAllocator&lt;E, GrowableArrayCHeap&lt;E, F&gt; &gt;;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   STATIC_ASSERT(F != mtNone);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static E* allocate(int max, MEMFLAGS flags) {</span>
<span class="udiff-line-added">+     if (max == 0) {</span>
<span class="udiff-line-added">+       return NULL;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), flags);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   NONCOPYABLE(GrowableArrayCHeap);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   E* allocate() {</span>
<span class="udiff-line-added">+     return allocate(this-&gt;_max, F);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void deallocate(E* mem) {</span>
<span class="udiff-line-added">+     GrowableArrayCHeapAllocator::deallocate(mem);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   GrowableArrayCHeap(int initial_max) :</span>
<span class="udiff-line-added">+       GrowableArrayWithAllocator&lt;E, GrowableArrayCHeap&lt;E, F&gt; &gt;(</span>
<span class="udiff-line-added">+           allocate(initial_max, F),</span>
<span class="udiff-line-added">+           initial_max) {}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GrowableArrayCHeap(int initial_max, int initial_len, const E&amp; filler) :</span>
<span class="udiff-line-added">+       GrowableArrayWithAllocator&lt;E, GrowableArrayCHeap&lt;E, F&gt; &gt;(</span>
<span class="udiff-line-added">+           allocate(initial_max, F),</span>
<span class="udiff-line-added">+           initial_max, initial_len, filler) {}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ~GrowableArrayCHeap() {</span>
<span class="udiff-line-added">+     this-&gt;clear_and_deallocate();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void* operator new(size_t size) throw() {</span>
<span class="udiff-line-added">+     return ResourceObj::operator new(size, ResourceObj::C_HEAP, F);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void* operator new(size_t size, const std::nothrow_t&amp;  nothrow_constant) throw() {</span>
<span class="udiff-line-added">+     return ResourceObj::operator new(size, nothrow_constant, ResourceObj::C_HEAP, F);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  // Custom STL-style iterator to iterate over GrowableArrays
  // It is constructed by invoking GrowableArray::begin() and GrowableArray::end()
<span class="udiff-line-modified-removed">- template&lt;class E&gt; class GrowableArrayIterator : public StackObj {</span>
<span class="udiff-line-modified-removed">-   friend class GrowableArray&lt;E&gt;;</span>
<span class="udiff-line-modified-removed">-   template&lt;class F, class UnaryPredicate&gt; friend class GrowableArrayFilterIterator;</span>
<span class="udiff-line-modified-added">+ template &lt;typename E&gt;</span>
<span class="udiff-line-modified-added">+ class GrowableArrayIterator : public StackObj {</span>
<span class="udiff-line-modified-added">+   friend class GrowableArrayView&lt;E&gt;;</span>
<span class="udiff-line-added">+   template &lt;typename F, typename UnaryPredicate&gt; friend class GrowableArrayFilterIterator;</span>
  
   private:
<span class="udiff-line-modified-removed">-   const GrowableArray&lt;E&gt;* _array; // GrowableArray we iterate over</span>
<span class="udiff-line-modified-removed">-   int _position;                  // The current position in the GrowableArray</span>
<span class="udiff-line-modified-added">+   const GrowableArrayView&lt;E&gt;* _array; // GrowableArray we iterate over</span>
<span class="udiff-line-modified-added">+   int _position;                      // The current position in the GrowableArray</span>
  
    // Private constructor used in GrowableArray::begin() and GrowableArray::end()
<span class="udiff-line-modified-removed">-   GrowableArrayIterator(const GrowableArray&lt;E&gt;* array, int position) : _array(array), _position(position) {</span>
<span class="udiff-line-modified-added">+   GrowableArrayIterator(const GrowableArrayView&lt;E&gt;* array, int position) : _array(array), _position(position) {</span>
      assert(0 &lt;= position &amp;&amp; position &lt;= _array-&gt;length(), &quot;illegal position&quot;);
    }
  
   public:
    GrowableArrayIterator() : _array(NULL), _position(0) { }
<span class="udiff-line-modified-removed">-   GrowableArrayIterator&lt;E&gt;&amp; operator++()  { ++_position; return *this; }</span>
<span class="udiff-line-modified-removed">-   E operator*()                           { return _array-&gt;at(_position); }</span>
<span class="udiff-line-modified-added">+   GrowableArrayIterator&lt;E&gt;&amp; operator++() { ++_position; return *this; }</span>
<span class="udiff-line-modified-added">+   E operator*()                          { return _array-&gt;at(_position); }</span>
  
    bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
      assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
      return _position == rhs._position;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -557,21 +739,22 @@</span>
      return _position != rhs._position;
    }
  };
  
  // Custom STL-style iterator to iterate over elements of a GrowableArray that satisfy a given predicate
<span class="udiff-line-modified-removed">- template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator : public StackObj {</span>
<span class="udiff-line-modified-removed">-   friend class GrowableArray&lt;E&gt;;</span>
<span class="udiff-line-modified-added">+ template &lt;typename E, class UnaryPredicate&gt;</span>
<span class="udiff-line-modified-added">+ class GrowableArrayFilterIterator : public StackObj {</span>
<span class="udiff-line-added">+   friend class GrowableArrayView&lt;E&gt;;</span>
  
   private:
<span class="udiff-line-modified-removed">-   const GrowableArray&lt;E&gt;* _array;   // GrowableArray we iterate over</span>
<span class="udiff-line-modified-removed">-   int _position;                    // Current position in the GrowableArray</span>
<span class="udiff-line-modified-removed">-   UnaryPredicate _predicate;        // Unary predicate the elements of the GrowableArray should satisfy</span>
<span class="udiff-line-modified-added">+   const GrowableArrayView&lt;E&gt;* _array; // GrowableArray we iterate over</span>
<span class="udiff-line-modified-added">+   int _position;                      // Current position in the GrowableArray</span>
<span class="udiff-line-modified-added">+   UnaryPredicate _predicate;          // Unary predicate the elements of the GrowableArray should satisfy</span>
  
   public:
<span class="udiff-line-modified-removed">-   GrowableArrayFilterIterator(const GrowableArray&lt;E&gt;* array, UnaryPredicate filter_predicate)</span>
<span class="udiff-line-modified-removed">-    : _array(array), _position(0), _predicate(filter_predicate) {</span>
<span class="udiff-line-modified-added">+   GrowableArrayFilterIterator(const GrowableArray&lt;E&gt;* array, UnaryPredicate filter_predicate) :</span>
<span class="udiff-line-modified-added">+       _array(array), _position(0), _predicate(filter_predicate) {</span>
      // Advance to first element satisfying the predicate
      while(!at_end() &amp;&amp; !_predicate(_array-&gt;at(_position))) {
        ++_position;
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -582,11 +765,11 @@</span>
        ++_position;
      } while(!at_end() &amp;&amp; !_predicate(_array-&gt;at(_position)));
      return *this;
    }
  
<span class="udiff-line-modified-removed">-   E operator*()   { return _array-&gt;at(_position); }</span>
<span class="udiff-line-modified-added">+   E operator*() { return _array-&gt;at(_position); }</span>
  
    bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
      assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
      return _position == rhs._position;
    }
</pre>
<center><a href="globalDefinitions.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/invoke/MemberName.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>