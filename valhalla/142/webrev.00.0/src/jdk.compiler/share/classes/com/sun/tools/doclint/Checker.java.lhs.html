<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.doclint;
  27 
  28 import java.io.IOException;
  29 import java.io.StringWriter;
  30 import java.net.URI;
  31 import java.net.URISyntaxException;
  32 import java.util.Deque;
  33 import java.util.EnumSet;
  34 import java.util.HashMap;
  35 import java.util.HashSet;
  36 import java.util.LinkedList;
  37 import java.util.List;
  38 import java.util.Map;
  39 import java.util.Set;
  40 import java.util.regex.Matcher;
  41 import java.util.regex.Pattern;
  42 
  43 import javax.lang.model.element.Element;
  44 import javax.lang.model.element.ElementKind;
  45 import javax.lang.model.element.ExecutableElement;
  46 import javax.lang.model.element.Name;
  47 import javax.lang.model.element.VariableElement;
  48 import javax.lang.model.type.TypeKind;
  49 import javax.lang.model.type.TypeMirror;
  50 import javax.tools.Diagnostic.Kind;
  51 import javax.tools.JavaFileObject;
  52 
  53 import com.sun.source.doctree.AttributeTree;
  54 import com.sun.source.doctree.AuthorTree;
  55 import com.sun.source.doctree.DocCommentTree;
  56 import com.sun.source.doctree.DocRootTree;
  57 import com.sun.source.doctree.DocTree;
  58 import com.sun.source.doctree.EndElementTree;
  59 import com.sun.source.doctree.EntityTree;
  60 import com.sun.source.doctree.ErroneousTree;
  61 import com.sun.source.doctree.IdentifierTree;
  62 import com.sun.source.doctree.IndexTree;
  63 import com.sun.source.doctree.InheritDocTree;
  64 import com.sun.source.doctree.LinkTree;
  65 import com.sun.source.doctree.LiteralTree;
  66 import com.sun.source.doctree.ParamTree;
  67 import com.sun.source.doctree.ProvidesTree;
  68 import com.sun.source.doctree.ReferenceTree;
  69 import com.sun.source.doctree.ReturnTree;
  70 import com.sun.source.doctree.SerialDataTree;
  71 import com.sun.source.doctree.SerialFieldTree;
  72 import com.sun.source.doctree.SinceTree;
  73 import com.sun.source.doctree.StartElementTree;
  74 import com.sun.source.doctree.SummaryTree;
  75 import com.sun.source.doctree.SystemPropertyTree;
  76 import com.sun.source.doctree.TextTree;
  77 import com.sun.source.doctree.ThrowsTree;
  78 import com.sun.source.doctree.UnknownBlockTagTree;
  79 import com.sun.source.doctree.UnknownInlineTagTree;
  80 import com.sun.source.doctree.UsesTree;
  81 import com.sun.source.doctree.ValueTree;
  82 import com.sun.source.doctree.VersionTree;
  83 import com.sun.source.tree.Tree;
  84 import com.sun.source.util.DocTreePath;
  85 import com.sun.source.util.DocTreePathScanner;
  86 import com.sun.source.util.TreePath;
  87 import com.sun.tools.doclint.HtmlTag.AttrKind;
  88 import com.sun.tools.javac.tree.DocPretty;
  89 import com.sun.tools.javac.util.Assert;
  90 import com.sun.tools.javac.util.DefinedBy;
  91 import com.sun.tools.javac.util.DefinedBy.Api;
  92 import com.sun.tools.javac.util.StringUtils;
  93 
  94 import static com.sun.tools.doclint.Messages.Group.*;
  95 
  96 
  97 /**
  98  * Validate a doc comment.
  99  *
 100  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 101  * If you write code that depends on this, you do so at your own
 102  * risk.  This code and its internal interfaces are subject to change
 103  * or deletion without notice.&lt;/b&gt;&lt;/p&gt;
 104  */
 105 public class Checker extends DocTreePathScanner&lt;Void, Void&gt; {
 106     final Env env;
 107 
 108     Set&lt;Element&gt; foundParams = new HashSet&lt;&gt;();
 109     Set&lt;TypeMirror&gt; foundThrows = new HashSet&lt;&gt;();
 110     Map&lt;Element, Set&lt;String&gt;&gt; foundAnchors = new HashMap&lt;&gt;();
 111     boolean foundInheritDoc = false;
 112     boolean foundReturn = false;
 113     boolean hasNonWhitespaceText = false;
 114 
 115     public enum Flag {
 116         TABLE_HAS_CAPTION,
 117         HAS_ELEMENT,
 118         HAS_HEADING,
 119         HAS_INLINE_TAG,
 120         HAS_TEXT,
 121         REPORTED_BAD_INLINE
 122     }
 123 
 124     static class TagStackItem {
 125         final DocTree tree; // typically, but not always, StartElementTree
 126         final HtmlTag tag;
 127         final Set&lt;HtmlTag.Attr&gt; attrs;
 128         final Set&lt;Flag&gt; flags;
 129         TagStackItem(DocTree tree, HtmlTag tag) {
 130             this.tree = tree;
 131             this.tag = tag;
 132             attrs = EnumSet.noneOf(HtmlTag.Attr.class);
 133             flags = EnumSet.noneOf(Flag.class);
 134         }
 135         @Override
 136         public String toString() {
 137             return String.valueOf(tag);
 138         }
 139     }
 140 
 141     private final Deque&lt;TagStackItem&gt; tagStack; // TODO: maybe want to record starting tree as well
 142     private HtmlTag currHeadingTag;
 143 
 144     private int implicitHeadingRank;
 145 
 146     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Top level&quot;&gt;
 147 
 148     Checker(Env env) {
 149         this.env = Assert.checkNonNull(env);
 150         tagStack = new LinkedList&lt;&gt;();
 151     }
 152 
 153     public Void scan(DocCommentTree tree, TreePath p) {
 154         env.initTypes();
 155         env.setCurrent(p, tree);
 156 
 157         boolean isOverridingMethod = !env.currOverriddenMethods.isEmpty();
 158         JavaFileObject fo = p.getCompilationUnit().getSourceFile();
 159 
 160         if (p.getLeaf().getKind() == Tree.Kind.PACKAGE) {
 161             // If p points to a package, the implied declaration is the
 162             // package declaration (if any) for the compilation unit.
 163             // Handle this case specially, because doc comments are only
 164             // expected in package-info files.
 165             boolean isPkgInfo = fo.isNameCompatible(&quot;package-info&quot;, JavaFileObject.Kind.SOURCE);
 166             if (tree == null) {
 167                 if (isPkgInfo)
 168                     reportMissing(&quot;dc.missing.comment&quot;);
 169                 return null;
 170             } else {
 171                 if (!isPkgInfo)
 172                     reportReference(&quot;dc.unexpected.comment&quot;);
 173             }
 174         } else if (tree != null &amp;&amp; fo.isNameCompatible(&quot;package&quot;, JavaFileObject.Kind.HTML)) {
 175             // a package.html file with a DocCommentTree
 176             if (tree.getFullBody().isEmpty()) {
 177                 reportMissing(&quot;dc.missing.comment&quot;);
 178                 return null;
 179             }
 180         } else {
 181             if (tree == null) {
 182                 if (!isSynthetic() &amp;&amp; !isOverridingMethod)
 183                     reportMissing(&quot;dc.missing.comment&quot;);
 184                 return null;
 185             }
 186         }
 187 
 188         tagStack.clear();
 189         currHeadingTag = null;
 190 
 191         foundParams.clear();
 192         foundThrows.clear();
 193         foundInheritDoc = false;
 194         foundReturn = false;
 195         hasNonWhitespaceText = false;
 196 
 197         switch (p.getLeaf().getKind()) {
 198             // the following are for declarations that have their own top-level page,
 199             // and so the doc comment comes after the &lt;h1&gt; page title.
 200             case MODULE:
 201             case PACKAGE:
 202             case CLASS:
 203             case INTERFACE:
 204             case ENUM:
 205             case ANNOTATION_TYPE:
 206             case RECORD:
 207                 implicitHeadingRank = 1;
 208                 break;
 209 
 210             // this is for html files
 211             // ... if it is a legacy package.html, the doc comment comes after the &lt;h1&gt; page title
 212             // ... otherwise, (e.g. overview file and doc-files/*.html files) no additional headings are inserted
 213             case COMPILATION_UNIT:
 214                 implicitHeadingRank = fo.isNameCompatible(&quot;package&quot;, JavaFileObject.Kind.HTML) ? 1 : 0;
 215                 break;
 216 
 217             // the following are for member declarations, which appear in the page
 218             // for the enclosing type, and so appear after the &lt;h2&gt; &quot;Members&quot;
 219             // aggregate heading and the specific &lt;h3&gt; &quot;Member signature&quot; heading.
 220             case METHOD:
 221             case VARIABLE:
 222                 implicitHeadingRank = 3;
 223                 break;
 224 
 225             default:
 226                 Assert.error(&quot;unexpected tree kind: &quot; + p.getLeaf().getKind() + &quot; &quot; + fo);
 227         }
 228 
 229         scan(new DocTreePath(p, tree), null);
 230 
 231         if (!isOverridingMethod) {
 232             switch (env.currElement.getKind()) {
 233                 case METHOD:
 234                 case CONSTRUCTOR: {
 235                     ExecutableElement ee = (ExecutableElement) env.currElement;
 236                     checkParamsDocumented(ee.getTypeParameters());
 237                     checkParamsDocumented(ee.getParameters());
 238                     switch (ee.getReturnType().getKind()) {
 239                         case VOID:
 240                         case NONE:
 241                             break;
 242                         default:
 243                             if (!foundReturn
 244                                     &amp;&amp; !foundInheritDoc
 245                                     &amp;&amp; !env.types.isSameType(ee.getReturnType(), env.java_lang_Void)) {
 246                                 reportMissing(&quot;dc.missing.return&quot;);
 247                             }
 248                     }
 249                     checkThrowsDocumented(ee.getThrownTypes());
 250                 }
 251             }
 252         }
 253 
 254         return null;
 255     }
 256 
 257     private void reportMissing(String code, Object... args) {
 258         env.messages.report(MISSING, Kind.WARNING, env.currPath.getLeaf(), code, args);
 259     }
 260 
 261     private void reportReference(String code, Object... args) {
 262         env.messages.report(REFERENCE, Kind.WARNING, env.currPath.getLeaf(), code, args);
 263     }
 264 
 265     @Override @DefinedBy(Api.COMPILER_TREE)
 266     public Void visitDocComment(DocCommentTree tree, Void ignore) {
 267         super.visitDocComment(tree, ignore);
 268         for (TagStackItem tsi: tagStack) {
 269             warnIfEmpty(tsi, null);
 270             if (tsi.tree.getKind() == DocTree.Kind.START_ELEMENT
 271                     &amp;&amp; tsi.tag.endKind == HtmlTag.EndKind.REQUIRED) {
 272                 StartElementTree t = (StartElementTree) tsi.tree;
 273                 env.messages.error(HTML, t, &quot;dc.tag.not.closed&quot;, t.getName());
 274             }
 275         }
 276         return null;
 277     }
 278     // &lt;/editor-fold&gt;
 279 
 280     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Text and entities.&quot;&gt;
 281 
 282     @Override @DefinedBy(Api.COMPILER_TREE)
 283     public Void visitText(TextTree tree, Void ignore) {
 284         hasNonWhitespaceText = hasNonWhitespace(tree);
 285         if (hasNonWhitespaceText) {
 286             checkAllowsText(tree);
 287             markEnclosingTag(Flag.HAS_TEXT);
 288         }
 289         return null;
 290     }
 291 
 292     @Override @DefinedBy(Api.COMPILER_TREE)
 293     public Void visitEntity(EntityTree tree, Void ignore) {
 294         checkAllowsText(tree);
 295         markEnclosingTag(Flag.HAS_TEXT);
 296         String name = tree.getName().toString();
 297         if (name.startsWith(&quot;#&quot;)) {
 298             int v = StringUtils.toLowerCase(name).startsWith(&quot;#x&quot;)
 299                     ? Integer.parseInt(name.substring(2), 16)
 300                     : Integer.parseInt(name.substring(1), 10);
 301             if (!Entity.isValid(v)) {
 302                 env.messages.error(HTML, tree, &quot;dc.entity.invalid&quot;, name);
 303             }
 304         } else if (!Entity.isValid(name)) {
 305             env.messages.error(HTML, tree, &quot;dc.entity.invalid&quot;, name);
 306         }
 307         return null;
 308     }
 309 
 310     void checkAllowsText(DocTree tree) {
 311         TagStackItem top = tagStack.peek();
 312         if (top != null
 313                 &amp;&amp; top.tree.getKind() == DocTree.Kind.START_ELEMENT
 314                 &amp;&amp; !top.tag.acceptsText()) {
 315             if (top.flags.add(Flag.REPORTED_BAD_INLINE)) {
 316                 env.messages.error(HTML, tree, &quot;dc.text.not.allowed&quot;,
 317                         ((StartElementTree) top.tree).getName());
 318             }
 319         }
 320     }
 321 
 322     // &lt;/editor-fold&gt;
 323 
 324     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;HTML elements&quot;&gt;
 325 
 326     @Override @DefinedBy(Api.COMPILER_TREE)
 327     public Void visitStartElement(StartElementTree tree, Void ignore) {
 328         final Name treeName = tree.getName();
 329         final HtmlTag t = HtmlTag.get(treeName);
 330         if (t == null) {
 331             env.messages.error(HTML, tree, &quot;dc.tag.unknown&quot;, treeName);
 332         } else if (t.allowedVersion != HtmlVersion.ALL &amp;&amp; t.allowedVersion != env.htmlVersion) {
 333             env.messages.error(HTML, tree, &quot;dc.tag.not.supported&quot;, treeName);
 334         } else {
 335             boolean done = false;
 336             for (TagStackItem tsi: tagStack) {
 337                 if (tsi.tag.accepts(t)) {
 338                     while (tagStack.peek() != tsi) {
 339                         warnIfEmpty(tagStack.peek(), null);
 340                         tagStack.pop();
 341                     }
 342                     done = true;
 343                     break;
 344                 } else if (tsi.tag.endKind != HtmlTag.EndKind.OPTIONAL) {
 345                     done = true;
 346                     break;
 347                 }
 348             }
 349             if (!done &amp;&amp; HtmlTag.BODY.accepts(t)) {
 350                 while (!tagStack.isEmpty()) {
 351                     warnIfEmpty(tagStack.peek(), null);
 352                     tagStack.pop();
 353                 }
 354             }
 355 
 356             markEnclosingTag(Flag.HAS_ELEMENT);
 357             checkStructure(tree, t);
 358 
 359             // tag specific checks
 360             switch (t) {
 361                 // check for out of sequence headings, such as &lt;h1&gt;...&lt;/h1&gt;  &lt;h3&gt;...&lt;/h3&gt;
 362                 case H1: case H2: case H3: case H4: case H5: case H6:
 363                     checkHeading(tree, t);
 364                     break;
 365             }
 366 
 367             if (t.flags.contains(HtmlTag.Flag.NO_NEST)) {
 368                 for (TagStackItem i: tagStack) {
 369                     if (t == i.tag) {
 370                         env.messages.warning(HTML, tree, &quot;dc.tag.nested.not.allowed&quot;, treeName);
 371                         break;
 372                     }
 373                 }
 374             }
 375         }
 376 
 377         // check for self closing tags, such as &lt;a id=&quot;name&quot;/&gt;
 378         if (tree.isSelfClosing() &amp;&amp; !isSelfClosingAllowed(t)) {
 379             env.messages.error(HTML, tree, &quot;dc.tag.self.closing&quot;, treeName);
 380         }
 381 
 382         try {
 383             TagStackItem parent = tagStack.peek();
 384             TagStackItem top = new TagStackItem(tree, t);
 385             tagStack.push(top);
 386 
 387             super.visitStartElement(tree, ignore);
 388 
 389             // handle attributes that may or may not have been found in start element
 390             if (t != null) {
 391                 switch (t) {
 392                     case CAPTION:
 393                         if (parent != null &amp;&amp; parent.tag == HtmlTag.TABLE)
 394                             parent.flags.add(Flag.TABLE_HAS_CAPTION);
 395                         break;
 396 
 397                     case H1: case H2: case H3: case H4: case H5: case H6:
 398                         if (parent != null &amp;&amp; (parent.tag == HtmlTag.SECTION || parent.tag == HtmlTag.ARTICLE)) {
 399                             parent.flags.add(Flag.HAS_HEADING);
 400                         }
 401                         break;
 402 
 403                     case IMG:
 404                         if (!top.attrs.contains(HtmlTag.Attr.ALT))
 405                             env.messages.error(ACCESSIBILITY, tree, &quot;dc.no.alt.attr.for.image&quot;);
 406                         break;
 407                 }
 408             }
 409 
 410             return null;
 411         } finally {
 412 
 413             if (t == null || t.endKind == HtmlTag.EndKind.NONE)
 414                 tagStack.pop();
 415         }
 416     }
 417 
 418     // so-called &quot;self-closing&quot; tags are only permitted in HTML 5, for void elements
 419     // https://html.spec.whatwg.org/multipage/syntax.html#start-tags
 420     private boolean isSelfClosingAllowed(HtmlTag tag) {
 421         return env.htmlVersion == HtmlVersion.HTML5
 422                 &amp;&amp; tag.endKind == HtmlTag.EndKind.NONE;
 423     }
 424 
 425     private void checkStructure(StartElementTree tree, HtmlTag t) {
 426         Name treeName = tree.getName();
 427         TagStackItem top = tagStack.peek();
 428         switch (t.blockType) {
 429             case BLOCK:
 430                 if (top == null || top.tag.accepts(t))
 431                     return;
 432 
 433                 switch (top.tree.getKind()) {
 434                     case START_ELEMENT: {
 435                         if (top.tag.blockType == HtmlTag.BlockType.INLINE) {
 436                             Name name = ((StartElementTree) top.tree).getName();
 437                             env.messages.error(HTML, tree, &quot;dc.tag.not.allowed.inline.element&quot;,
 438                                     treeName, name);
 439                             return;
 440                         }
 441                     }
 442                     break;
 443 
 444                     case LINK:
 445                     case LINK_PLAIN: {
 446                         String name = top.tree.getKind().tagName;
 447                         env.messages.error(HTML, tree, &quot;dc.tag.not.allowed.inline.tag&quot;,
 448                                 treeName, name);
 449                         return;
 450                     }
 451                 }
 452                 break;
 453 
 454             case INLINE:
 455                 if (top == null || top.tag.accepts(t))
 456                     return;
 457                 break;
 458 
 459             case LIST_ITEM:
 460             case TABLE_ITEM:
 461                 if (top != null) {
 462                     // reset this flag so subsequent bad inline content gets reported
 463                     top.flags.remove(Flag.REPORTED_BAD_INLINE);
 464                     if (top.tag.accepts(t))
 465                         return;
 466                 }
 467                 break;
 468 
 469             case OTHER:
 470                 switch (t) {
 471                     case SCRIPT:
 472                         // &lt;script&gt; may or may not be allowed, depending on --allow-script-in-comments
 473                         // but we allow it here, and rely on a separate scanner to detect all uses
 474                         // of JavaScript, including &lt;script&gt; tags, and use in attributes, etc.
 475                         break;
 476 
 477                     default:
 478                         env.messages.error(HTML, tree, &quot;dc.tag.not.allowed&quot;, treeName);
 479                 }
 480                 return;
 481         }
 482 
 483         env.messages.error(HTML, tree, &quot;dc.tag.not.allowed.here&quot;, treeName);
 484     }
 485 
 486     private void checkHeading(StartElementTree tree, HtmlTag tag) {
 487         // verify the new tag
 488         if (getHeadingRank(tag) &gt; getHeadingRank(currHeadingTag) + 1) {
 489             if (currHeadingTag == null) {
 490                 env.messages.error(ACCESSIBILITY, tree, &quot;dc.tag.heading.sequence.1&quot;,
 491                         tag, implicitHeadingRank);
 492             } else {
 493                 env.messages.error(ACCESSIBILITY, tree, &quot;dc.tag.heading.sequence.2&quot;,
 494                     tag, currHeadingTag);
 495             }
 496         } else if (getHeadingRank(tag) &lt;= implicitHeadingRank) {
 497             env.messages.error(ACCESSIBILITY, tree, &quot;dc.tag.heading.sequence.3&quot;,
 498                     tag, implicitHeadingRank);
 499         }
 500 
 501         currHeadingTag = tag;
 502     }
 503 
 504     private int getHeadingRank(HtmlTag tag) {
 505         if (tag == null)
 506             return implicitHeadingRank;
 507         switch (tag) {
 508             case H1: return 1;
 509             case H2: return 2;
 510             case H3: return 3;
 511             case H4: return 4;
 512             case H5: return 5;
 513             case H6: return 6;
 514             default: throw new IllegalArgumentException();
 515         }
 516     }
 517 
 518     @Override @DefinedBy(Api.COMPILER_TREE)
 519     public Void visitEndElement(EndElementTree tree, Void ignore) {
 520         final Name treeName = tree.getName();
 521         final HtmlTag t = HtmlTag.get(treeName);
 522         if (t == null) {
 523             env.messages.error(HTML, tree, &quot;dc.tag.unknown&quot;, treeName);
 524         } else if (t.endKind == HtmlTag.EndKind.NONE) {
 525             env.messages.error(HTML, tree, &quot;dc.tag.end.not.permitted&quot;, treeName);
 526         } else {
 527             boolean done = false;
 528             while (!tagStack.isEmpty()) {
 529                 TagStackItem top = tagStack.peek();
 530                 if (t == top.tag) {
 531                     switch (t) {
 532                         case TABLE:
 533                             if (!top.attrs.contains(HtmlTag.Attr.SUMMARY)
 534                                     &amp;&amp; !top.flags.contains(Flag.TABLE_HAS_CAPTION)) {
 535                                 env.messages.error(ACCESSIBILITY, tree,
 536                                         &quot;dc.no.summary.or.caption.for.table&quot;);
 537                             }
 538                             break;
 539 
 540                         case SECTION:
 541                         case ARTICLE:
 542                             if (env.htmlVersion == HtmlVersion.HTML5 &amp;&amp; !top.flags.contains(Flag.HAS_HEADING)) {
 543                                 env.messages.error(HTML, tree, &quot;dc.tag.requires.heading&quot;, treeName);
 544                             }
 545                             break;
 546                     }
 547                     warnIfEmpty(top, tree);
 548                     tagStack.pop();
 549                     done = true;
 550                     break;
 551                 } else if (top.tag == null || top.tag.endKind != HtmlTag.EndKind.REQUIRED) {
 552                     tagStack.pop();
 553                 } else {
 554                     boolean found = false;
 555                     for (TagStackItem si: tagStack) {
 556                         if (si.tag == t) {
 557                             found = true;
 558                             break;
 559                         }
 560                     }
 561                     if (found &amp;&amp; top.tree.getKind() == DocTree.Kind.START_ELEMENT) {
 562                         env.messages.error(HTML, top.tree, &quot;dc.tag.start.unmatched&quot;,
 563                                 ((StartElementTree) top.tree).getName());
 564                         tagStack.pop();
 565                     } else {
 566                         env.messages.error(HTML, tree, &quot;dc.tag.end.unexpected&quot;, treeName);
 567                         done = true;
 568                         break;
 569                     }
 570                 }
 571             }
 572 
 573             if (!done &amp;&amp; tagStack.isEmpty()) {
 574                 env.messages.error(HTML, tree, &quot;dc.tag.end.unexpected&quot;, treeName);
 575             }
 576         }
 577 
 578         return super.visitEndElement(tree, ignore);
 579     }
 580 
 581     void warnIfEmpty(TagStackItem tsi, DocTree endTree) {
 582         if (tsi.tag != null &amp;&amp; tsi.tree instanceof StartElementTree) {
 583             if (tsi.tag.flags.contains(HtmlTag.Flag.EXPECT_CONTENT)
 584                     &amp;&amp; !tsi.flags.contains(Flag.HAS_TEXT)
 585                     &amp;&amp; !tsi.flags.contains(Flag.HAS_ELEMENT)
 586                     &amp;&amp; !tsi.flags.contains(Flag.HAS_INLINE_TAG)) {
 587                 DocTree tree = (endTree != null) ? endTree : tsi.tree;
 588                 Name treeName = ((StartElementTree) tsi.tree).getName();
 589                 env.messages.warning(HTML, tree, &quot;dc.tag.empty&quot;, treeName);
 590             }
 591         }
 592     }
 593 
 594     // &lt;/editor-fold&gt;
 595 
 596     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;HTML attributes&quot;&gt;
 597 
 598     @Override @DefinedBy(Api.COMPILER_TREE) @SuppressWarnings(&quot;fallthrough&quot;)
 599     public Void visitAttribute(AttributeTree tree, Void ignore) {
 600         HtmlTag currTag = tagStack.peek().tag;
 601         if (currTag != null) {
 602             Name name = tree.getName();
 603             HtmlTag.Attr attr = currTag.getAttr(name);
 604             if (attr != null) {
 605                 if (env.htmlVersion == HtmlVersion.HTML4 &amp;&amp; attr.name().contains(&quot;-&quot;)) {
 606                     env.messages.error(HTML, tree, &quot;dc.attr.not.supported.html4&quot;, name);
 607                 }
 608                 boolean first = tagStack.peek().attrs.add(attr);
 609                 if (!first)
 610                     env.messages.error(HTML, tree, &quot;dc.attr.repeated&quot;, name);
 611             }
 612             // for now, doclint allows all attribute names beginning with &quot;on&quot; as event handler names,
 613             // without checking the validity or applicability of the name
 614             if (!name.toString().startsWith(&quot;on&quot;)) {
 615                 AttrKind k = currTag.getAttrKind(name);
 616                 switch (env.htmlVersion) {
 617                     case HTML4:
 618                         validateHtml4Attrs(tree, name, k);
 619                         break;
 620 
 621                     case HTML5:
 622                         validateHtml5Attrs(tree, name, k);
 623                         break;
 624                 }
 625             }
 626 
 627             if (attr != null) {
 628                 switch (attr) {
 629                     case NAME:
 630                         if (currTag != HtmlTag.A) {
 631                             break;
 632                         }
 633                         // fallthrough
 634                     case ID:
 635                         String value = getAttrValue(tree);
 636                         if (value == null) {
 637                             env.messages.error(HTML, tree, &quot;dc.anchor.value.missing&quot;);
 638                         } else {
 639                             if (!validName.matcher(value).matches()) {
 640                                 env.messages.error(HTML, tree, &quot;dc.invalid.anchor&quot;, value);
 641                             }
 642                             if (!checkAnchor(value)) {
 643                                 env.messages.error(HTML, tree, &quot;dc.anchor.already.defined&quot;, value);
 644                             }
 645                         }
 646                         break;
 647 
 648                     case HREF:
 649                         if (currTag == HtmlTag.A) {
 650                             String v = getAttrValue(tree);
 651                             if (v == null || v.isEmpty()) {
 652                                 env.messages.error(HTML, tree, &quot;dc.attr.lacks.value&quot;);
 653                             } else {
 654                                 Matcher m = docRoot.matcher(v);
 655                                 if (m.matches()) {
 656                                     String rest = m.group(2);
 657                                     if (!rest.isEmpty())
 658                                         checkURI(tree, rest);
 659                                 } else {
 660                                     checkURI(tree, v);
 661                                 }
 662                             }
 663                         }
 664                         break;
 665 
 666                     case VALUE:
 667                         if (currTag == HtmlTag.LI) {
 668                             String v = getAttrValue(tree);
 669                             if (v == null || v.isEmpty()) {
 670                                 env.messages.error(HTML, tree, &quot;dc.attr.lacks.value&quot;);
 671                             } else if (!validNumber.matcher(v).matches()) {
 672                                 env.messages.error(HTML, tree, &quot;dc.attr.not.number&quot;);
 673                             }
 674                         }
 675                         break;
 676 
 677                     case BORDER:
 678                         if (currTag == HtmlTag.TABLE) {
 679                             String v = getAttrValue(tree);
 680                             try {
 681                                 if (env.htmlVersion == HtmlVersion.HTML5
 682                                         &amp;&amp; (v == null || (!v.isEmpty() &amp;&amp; Integer.parseInt(v) != 1))) {
 683                                     env.messages.error(HTML, tree, &quot;dc.attr.table.border.html5&quot;, attr);
 684                                 }
 685                             } catch (NumberFormatException ex) {
 686                                 env.messages.error(HTML, tree, &quot;dc.attr.table.border.html5&quot;, attr);
 687                             }
 688                         }
 689                         break;
 690                 }
 691             }
 692         }
 693 
 694         // TODO: basic check on value
 695 
 696         return null;
 697     }
 698 
 699     private void validateHtml4Attrs(AttributeTree tree, Name name, AttrKind k) {
 700         switch (k) {
 701             case ALL:
 702             case HTML4:
 703                 break;
 704 
 705             case INVALID:
 706                 env.messages.error(HTML, tree, &quot;dc.attr.unknown&quot;, name);
 707                 break;
 708 
 709             case OBSOLETE:
 710                 env.messages.warning(HTML, tree, &quot;dc.attr.obsolete&quot;, name);
 711                 break;
 712 
 713             case USE_CSS:
 714                 env.messages.warning(HTML, tree, &quot;dc.attr.obsolete.use.css&quot;, name);
 715                 break;
 716 
 717             case HTML5:
 718                 env.messages.error(HTML, tree, &quot;dc.attr.not.supported.html4&quot;, name);
 719                 break;
 720         }
 721     }
 722 
 723     private void validateHtml5Attrs(AttributeTree tree, Name name, AttrKind k) {
 724         switch (k) {
 725             case ALL:
 726             case HTML5:
 727                 break;
 728 
 729             case INVALID:
 730             case OBSOLETE:
 731             case USE_CSS:
 732             case HTML4:
 733                 env.messages.error(HTML, tree, &quot;dc.attr.not.supported.html5&quot;, name);
 734                 break;
 735         }
 736     }
 737 
 738     private boolean checkAnchor(String name) {
 739         Element e = getEnclosingPackageOrClass(env.currElement);
 740         if (e == null)
 741             return true;
 742         Set&lt;String&gt; set = foundAnchors.get(e);
 743         if (set == null)
 744             foundAnchors.put(e, set = new HashSet&lt;&gt;());
 745         return set.add(name);
 746     }
 747 
 748     private Element getEnclosingPackageOrClass(Element e) {
 749         while (e != null) {
 750             switch (e.getKind()) {
 751                 case CLASS:
 752                 case ENUM:
 753                 case INTERFACE:
 754                 case PACKAGE:
 755                     return e;
 756                 default:
 757                     e = e.getEnclosingElement();
 758             }
 759         }
 760         return e;
 761     }
 762 
 763     // http://www.w3.org/TR/html401/types.html#type-name
 764     private static final Pattern validName = Pattern.compile(&quot;[A-Za-z][A-Za-z0-9-_:.]*&quot;);
 765 
 766     private static final Pattern validNumber = Pattern.compile(&quot;-?[0-9]+&quot;);
 767 
 768     // pattern to remove leading {@docRoot}/?
 769     private static final Pattern docRoot = Pattern.compile(&quot;(?i)(\\{@docRoot *\\}/?)?(.*)&quot;);
 770 
 771     private String getAttrValue(AttributeTree tree) {
 772         if (tree.getValue() == null)
 773             return null;
 774 
 775         StringWriter sw = new StringWriter();
 776         try {
 777             new DocPretty(sw).print(tree.getValue());
 778         } catch (IOException e) {
 779             // cannot happen
 780         }
 781         // ignore potential use of entities for now
 782         return sw.toString();
 783     }
 784 
 785     private void checkURI(AttributeTree tree, String uri) {
 786         // allow URIs beginning with javascript:, which would otherwise be rejected by the URI API.
 787         if (uri.startsWith(&quot;javascript:&quot;))
 788             return;
 789         try {
 790             URI u = new URI(uri);
 791         } catch (URISyntaxException e) {
 792             env.messages.error(HTML, tree, &quot;dc.invalid.uri&quot;, uri);
 793         }
 794     }
 795     // &lt;/editor-fold&gt;
 796 
 797     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;javadoc tags&quot;&gt;
 798 
 799     @Override @DefinedBy(Api.COMPILER_TREE)
 800     public Void visitAuthor(AuthorTree tree, Void ignore) {
 801         warnIfEmpty(tree, tree.getName());
 802         return super.visitAuthor(tree, ignore);
 803     }
 804 
 805     @Override @DefinedBy(Api.COMPILER_TREE)
 806     public Void visitDocRoot(DocRootTree tree, Void ignore) {
 807         markEnclosingTag(Flag.HAS_INLINE_TAG);
 808         return super.visitDocRoot(tree, ignore);
 809     }
 810 
 811     @Override @DefinedBy(Api.COMPILER_TREE)
 812     public Void visitIndex(IndexTree tree, Void ignore) {
 813         markEnclosingTag(Flag.HAS_INLINE_TAG);
 814         for (TagStackItem tsi : tagStack) {
 815             if (tsi.tag == HtmlTag.A) {
 816                 env.messages.warning(HTML, tree, &quot;dc.tag.a.within.a&quot;,
 817                         &quot;{@&quot; + tree.getTagName() + &quot;}&quot;);
 818                 break;
 819             }
 820         }
 821         return super.visitIndex(tree, ignore);
 822     }
 823 
 824     @Override @DefinedBy(Api.COMPILER_TREE)
 825     public Void visitInheritDoc(InheritDocTree tree, Void ignore) {
 826         markEnclosingTag(Flag.HAS_INLINE_TAG);
 827         // TODO: verify on overridden method
 828         foundInheritDoc = true;
 829         return super.visitInheritDoc(tree, ignore);
 830     }
 831 
 832     @Override @DefinedBy(Api.COMPILER_TREE)
 833     public Void visitLink(LinkTree tree, Void ignore) {
 834         markEnclosingTag(Flag.HAS_INLINE_TAG);
 835         // simulate inline context on tag stack
 836         HtmlTag t = (tree.getKind() == DocTree.Kind.LINK)
 837                 ? HtmlTag.CODE : HtmlTag.SPAN;
 838         tagStack.push(new TagStackItem(tree, t));
 839         try {
 840             return super.visitLink(tree, ignore);
 841         } finally {
 842             tagStack.pop();
 843         }
 844     }
 845 
 846     @Override @DefinedBy(Api.COMPILER_TREE)
 847     public Void visitLiteral(LiteralTree tree, Void ignore) {
 848         markEnclosingTag(Flag.HAS_INLINE_TAG);
 849         if (tree.getKind() == DocTree.Kind.CODE) {
 850             for (TagStackItem tsi: tagStack) {
 851                 if (tsi.tag == HtmlTag.CODE) {
 852                     env.messages.warning(HTML, tree, &quot;dc.tag.code.within.code&quot;);
 853                     break;
 854                 }
 855             }
 856         }
 857         return super.visitLiteral(tree, ignore);
 858     }
 859 
 860     @Override @DefinedBy(Api.COMPILER_TREE)
 861     @SuppressWarnings(&quot;fallthrough&quot;)
 862     public Void visitParam(ParamTree tree, Void ignore) {
 863         boolean typaram = tree.isTypeParameter();
 864         IdentifierTree nameTree = tree.getName();
 865         Element paramElement = nameTree != null ? env.trees.getElement(new DocTreePath(getCurrentPath(), nameTree)) : null;
 866 
 867         if (paramElement == null) {
 868             switch (env.currElement.getKind()) {
 869                 case CLASS: case INTERFACE: {
 870                     if (!typaram) {
 871                         env.messages.error(REFERENCE, tree, &quot;dc.invalid.param&quot;);
 872                         break;
 873                     }
 874                 }
 875                 case METHOD: case CONSTRUCTOR: {
 876                     env.messages.error(REFERENCE, nameTree, &quot;dc.param.name.not.found&quot;);
 877                     break;
 878                 }
 879 
 880                 default:
 881                     env.messages.error(REFERENCE, tree, &quot;dc.invalid.param&quot;);
 882                     break;
 883             }
 884         } else {
 885             boolean unique = foundParams.add(paramElement);
 886 
 887             if (!unique) {
 888                 env.messages.warning(REFERENCE, tree, &quot;dc.exists.param&quot;, nameTree);
 889             }
 890         }
 891 
 892         warnIfEmpty(tree, tree.getDescription());
 893         return super.visitParam(tree, ignore);
 894     }
 895 
 896     private void checkParamsDocumented(List&lt;? extends Element&gt; list) {
 897         if (foundInheritDoc)
 898             return;
 899 
 900         for (Element e: list) {
 901             if (!foundParams.contains(e)) {
 902                 CharSequence paramName = (e.getKind() == ElementKind.TYPE_PARAMETER)
 903                         ? &quot;&lt;&quot; + e.getSimpleName() + &quot;&gt;&quot;
 904                         : e.getSimpleName();
 905                 reportMissing(&quot;dc.missing.param&quot;, paramName);
 906             }
 907         }
 908     }
 909 
 910     @Override @DefinedBy(Api.COMPILER_TREE)
 911     public Void visitProvides(ProvidesTree tree, Void ignore) {
 912         Element e = env.trees.getElement(env.currPath);
 913         if (e.getKind() != ElementKind.MODULE) {
 914             env.messages.error(REFERENCE, tree, &quot;dc.invalid.provides&quot;);
 915         }
 916         ReferenceTree serviceType = tree.getServiceType();
 917         Element se = env.trees.getElement(new DocTreePath(getCurrentPath(), serviceType));
 918         if (se == null) {
 919             env.messages.error(REFERENCE, tree, &quot;dc.service.not.found&quot;);
 920         }
 921         return super.visitProvides(tree, ignore);
 922     }
 923 
 924     @Override @DefinedBy(Api.COMPILER_TREE)
 925     public Void visitReference(ReferenceTree tree, Void ignore) {
 926         Element e = env.trees.getElement(getCurrentPath());
 927         if (e == null)
 928             env.messages.error(REFERENCE, tree, &quot;dc.ref.not.found&quot;);
 929         return super.visitReference(tree, ignore);
 930     }
 931 
 932     @Override @DefinedBy(Api.COMPILER_TREE)
 933     public Void visitReturn(ReturnTree tree, Void ignore) {
 934         if (foundReturn) {
 935             env.messages.warning(REFERENCE, tree, &quot;dc.exists.return&quot;);
 936         }
 937 
 938         Element e = env.trees.getElement(env.currPath);
 939         if (e.getKind() != ElementKind.METHOD
 940                 || ((ExecutableElement) e).getReturnType().getKind() == TypeKind.VOID)
 941             env.messages.error(REFERENCE, tree, &quot;dc.invalid.return&quot;);
 942         foundReturn = true;
 943         warnIfEmpty(tree, tree.getDescription());
 944         return super.visitReturn(tree, ignore);
 945     }
 946 
 947     @Override @DefinedBy(Api.COMPILER_TREE)
 948     public Void visitSerialData(SerialDataTree tree, Void ignore) {
 949         warnIfEmpty(tree, tree.getDescription());
 950         return super.visitSerialData(tree, ignore);
 951     }
 952 
 953     @Override @DefinedBy(Api.COMPILER_TREE)
 954     public Void visitSerialField(SerialFieldTree tree, Void ignore) {
 955         warnIfEmpty(tree, tree.getDescription());
 956         return super.visitSerialField(tree, ignore);
 957     }
 958 
 959     @Override @DefinedBy(Api.COMPILER_TREE)
 960     public Void visitSince(SinceTree tree, Void ignore) {
 961         warnIfEmpty(tree, tree.getBody());
 962         return super.visitSince(tree, ignore);
 963     }
 964 
 965     @Override @DefinedBy(Api.COMPILER_TREE)
 966     public Void visitSummary(SummaryTree node, Void aVoid) {
 967         markEnclosingTag(Flag.HAS_INLINE_TAG);
 968         int idx = env.currDocComment.getFullBody().indexOf(node);
 969         // Warn if the node is preceded by non-whitespace characters,
 970         // or other non-text nodes.
 971         if ((idx == 1 &amp;&amp; hasNonWhitespaceText) || idx &gt; 1) {
 972             env.messages.warning(SYNTAX, node, &quot;dc.invalid.summary&quot;, node.getTagName());
 973         }
 974         return super.visitSummary(node, aVoid);
 975     }
 976 
 977     @Override @DefinedBy(Api.COMPILER_TREE)
 978     public Void visitSystemProperty(SystemPropertyTree tree, Void ignore) {
 979         markEnclosingTag(Flag.HAS_INLINE_TAG);
 980         for (TagStackItem tsi : tagStack) {
 981             if (tsi.tag == HtmlTag.A) {
 982                 env.messages.warning(HTML, tree, &quot;dc.tag.a.within.a&quot;,
 983                         &quot;{@&quot; + tree.getTagName() + &quot;}&quot;);
 984                 break;
 985             }
 986         }
 987         return super.visitSystemProperty(tree, ignore);
 988     }
 989 
 990     @Override @DefinedBy(Api.COMPILER_TREE)
 991     public Void visitThrows(ThrowsTree tree, Void ignore) {
 992         ReferenceTree exName = tree.getExceptionName();
 993         Element ex = env.trees.getElement(new DocTreePath(getCurrentPath(), exName));
 994         if (ex == null) {
 995             env.messages.error(REFERENCE, tree, &quot;dc.ref.not.found&quot;);
 996         } else if (isThrowable(ex.asType())) {
 997             switch (env.currElement.getKind()) {
 998                 case CONSTRUCTOR:
 999                 case METHOD:
1000                     if (isCheckedException(ex.asType())) {
1001                         ExecutableElement ee = (ExecutableElement) env.currElement;
1002                         checkThrowsDeclared(exName, ex.asType(), ee.getThrownTypes());
1003                     }
1004                     break;
1005                 default:
1006                     env.messages.error(REFERENCE, tree, &quot;dc.invalid.throws&quot;);
1007             }
1008         } else {
1009             env.messages.error(REFERENCE, tree, &quot;dc.invalid.throws&quot;);
1010         }
1011         warnIfEmpty(tree, tree.getDescription());
1012         return scan(tree.getDescription(), ignore);
1013     }
1014 
1015     private boolean isThrowable(TypeMirror tm) {
1016         switch (tm.getKind()) {
1017             case DECLARED:
1018             case TYPEVAR:
1019                 return env.types.isAssignable(tm, env.java_lang_Throwable);
1020         }
1021         return false;
1022     }
1023 
1024     private void checkThrowsDeclared(ReferenceTree tree, TypeMirror t, List&lt;? extends TypeMirror&gt; list) {
1025         boolean found = false;
1026         for (TypeMirror tl : list) {
1027             if (env.types.isAssignable(t, tl)) {
1028                 foundThrows.add(tl);
1029                 found = true;
1030             }
1031         }
1032         if (!found)
1033             env.messages.error(REFERENCE, tree, &quot;dc.exception.not.thrown&quot;, t);
1034     }
1035 
1036     private void checkThrowsDocumented(List&lt;? extends TypeMirror&gt; list) {
1037         if (foundInheritDoc)
1038             return;
1039 
1040         for (TypeMirror tl: list) {
1041             if (isCheckedException(tl) &amp;&amp; !foundThrows.contains(tl))
1042                 reportMissing(&quot;dc.missing.throws&quot;, tl);
1043         }
1044     }
1045 
1046     @Override @DefinedBy(Api.COMPILER_TREE)
1047     public Void visitUnknownBlockTag(UnknownBlockTagTree tree, Void ignore) {
1048         checkUnknownTag(tree, tree.getTagName());
1049         return super.visitUnknownBlockTag(tree, ignore);
1050     }
1051 
1052     @Override @DefinedBy(Api.COMPILER_TREE)
1053     public Void visitUnknownInlineTag(UnknownInlineTagTree tree, Void ignore) {
1054         markEnclosingTag(Flag.HAS_INLINE_TAG);
1055         checkUnknownTag(tree, tree.getTagName());
1056         return super.visitUnknownInlineTag(tree, ignore);
1057     }
1058 
1059     private void checkUnknownTag(DocTree tree, String tagName) {
1060         if (env.customTags != null &amp;&amp; !env.customTags.contains(tagName))
1061             env.messages.error(SYNTAX, tree, &quot;dc.tag.unknown&quot;, tagName);
1062     }
1063 
1064     @Override @DefinedBy(Api.COMPILER_TREE)
1065     public Void visitUses(UsesTree tree, Void ignore) {
1066         Element e = env.trees.getElement(env.currPath);
1067         if (e.getKind() != ElementKind.MODULE) {
1068             env.messages.error(REFERENCE, tree, &quot;dc.invalid.uses&quot;);
1069         }
1070         ReferenceTree serviceType = tree.getServiceType();
1071         Element se = env.trees.getElement(new DocTreePath(getCurrentPath(), serviceType));
1072         if (se == null) {
1073             env.messages.error(REFERENCE, tree, &quot;dc.service.not.found&quot;);
1074         }
1075         return super.visitUses(tree, ignore);
1076     }
1077 
1078     @Override @DefinedBy(Api.COMPILER_TREE)
1079     public Void visitValue(ValueTree tree, Void ignore) {
1080         ReferenceTree ref = tree.getReference();
1081         if (ref == null || ref.getSignature().isEmpty()) {
1082             if (!isConstant(env.currElement))
1083                 env.messages.error(REFERENCE, tree, &quot;dc.value.not.allowed.here&quot;);
1084         } else {
1085             Element e = env.trees.getElement(new DocTreePath(getCurrentPath(), ref));
1086             if (!isConstant(e))
1087                 env.messages.error(REFERENCE, tree, &quot;dc.value.not.a.constant&quot;);
1088         }
1089 
1090         markEnclosingTag(Flag.HAS_INLINE_TAG);
1091         return super.visitValue(tree, ignore);
1092     }
1093 
1094     private boolean isConstant(Element e) {
1095         if (e == null)
1096             return false;
1097 
1098         switch (e.getKind()) {
1099             case FIELD:
1100                 Object value = ((VariableElement) e).getConstantValue();
1101                 return (value != null); // can&#39;t distinguish &quot;not a constant&quot; from &quot;constant is null&quot;
1102             default:
1103                 return false;
1104         }
1105     }
1106 
1107     @Override @DefinedBy(Api.COMPILER_TREE)
1108     public Void visitVersion(VersionTree tree, Void ignore) {
1109         warnIfEmpty(tree, tree.getBody());
1110         return super.visitVersion(tree, ignore);
1111     }
1112 
1113     @Override @DefinedBy(Api.COMPILER_TREE)
1114     public Void visitErroneous(ErroneousTree tree, Void ignore) {
1115         env.messages.error(SYNTAX, tree, null, tree.getDiagnostic().getMessage(null));
1116         return null;
1117     }
1118     // &lt;/editor-fold&gt;
1119 
1120     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Utility methods&quot;&gt;
1121 
1122     private boolean isCheckedException(TypeMirror t) {
1123         return !(env.types.isAssignable(t, env.java_lang_Error)
1124                 || env.types.isAssignable(t, env.java_lang_RuntimeException));
1125     }
1126 
1127     private boolean isSynthetic() {
1128         switch (env.currElement.getKind()) {
1129             case CONSTRUCTOR:
1130                 // A synthetic default constructor has the same pos as the
1131                 // enclosing class
1132             case METHOD:
1133                 // Ditto for a synthetic method injected by the compiler (for value types)
1134                 TreePath p = env.currPath;
1135                 return env.getPos(p) == env.getPos(p.getParentPath());
1136         }
1137         return false;
1138     }
1139 
1140     void markEnclosingTag(Flag flag) {
1141         TagStackItem top = tagStack.peek();
1142         if (top != null)
1143             top.flags.add(flag);
1144     }
1145 
1146     String toString(TreePath p) {
1147         StringBuilder sb = new StringBuilder(&quot;TreePath[&quot;);
1148         toString(p, sb);
1149         sb.append(&quot;]&quot;);
1150         return sb.toString();
1151     }
1152 
1153     void toString(TreePath p, StringBuilder sb) {
1154         TreePath parent = p.getParentPath();
1155         if (parent != null) {
1156             toString(parent, sb);
1157             sb.append(&quot;,&quot;);
1158         }
1159        sb.append(p.getLeaf().getKind()).append(&quot;:&quot;).append(env.getPos(p)).append(&quot;:S&quot;).append(env.getStartPos(p));
1160     }
1161 
1162     void warnIfEmpty(DocTree tree, List&lt;? extends DocTree&gt; list) {
1163         for (DocTree d: list) {
1164             switch (d.getKind()) {
1165                 case TEXT:
1166                     if (hasNonWhitespace((TextTree) d))
1167                         return;
1168                     break;
1169                 default:
1170                     return;
1171             }
1172         }
<a name="1" id="anc1"></a><span class="line-modified">1173         env.messages.warning(SYNTAX, tree, &quot;dc.empty&quot;, tree.getKind().tagName);</span>
1174     }
1175 
1176     boolean hasNonWhitespace(TextTree tree) {
1177         String s = tree.getBody();
1178         for (int i = 0; i &lt; s.length(); i++) {
1179             Character c = s.charAt(i);
1180             if (!Character.isWhitespace(s.charAt(i)))
1181                 return true;
1182         }
1183         return false;
1184     }
1185 
1186     // &lt;/editor-fold&gt;
1187 
1188 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>