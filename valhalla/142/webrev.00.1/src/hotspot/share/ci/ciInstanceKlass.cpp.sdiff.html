<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciInstanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciField.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciInstanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciField.hpp&quot;

 27 #include &quot;ci/ciInstance.hpp&quot;
 28 #include &quot;ci/ciInstanceKlass.hpp&quot;
 29 #include &quot;ci/ciUtilities.inline.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;oops/fieldStreams.inline.hpp&quot;

 36 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/jniHandles.inline.hpp&quot;
 39 
 40 // ciInstanceKlass
 41 //
 42 // This class represents a Klass* in the HotSpot virtual machine
 43 // whose Klass part in an InstanceKlass.
 44 
 45 
 46 // ------------------------------------------------------------------
 47 // ciInstanceKlass::ciInstanceKlass
 48 //
 49 // Loaded instance klass.
 50 ciInstanceKlass::ciInstanceKlass(Klass* k) :
 51   ciKlass(k)
 52 {
 53   assert(get_Klass()-&gt;is_instance_klass(), &quot;wrong type&quot;);
 54   assert(get_instanceKlass()-&gt;is_loaded(), &quot;must be at least loaded&quot;);
 55   InstanceKlass* ik = get_instanceKlass();
</pre>
<hr />
<pre>
 98     _protection_domain = JNIHandles::make_global(h_protection_domain);
 99     _is_shared = true;
100   }
101 
102   // Lazy fields get filled in only upon request.
103   _super  = NULL;
104   _java_mirror = NULL;
105 
106   if (is_shared()) {
107     if (k != SystemDictionary::Object_klass()) {
108       super();
109     }
110     //compute_nonstatic_fields();  // done outside of constructor
111   }
112 
113   _field_cache = NULL;
114 }
115 
116 // Version for unloaded classes:
117 ciInstanceKlass::ciInstanceKlass(ciSymbol* name,
<span class="line-modified">118                                  jobject loader, jobject protection_domain)</span>
<span class="line-modified">119   : ciKlass(name, T_OBJECT)</span>

120 {
121   assert(name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY, &quot;not an instance klass&quot;);
122   _init_state = (InstanceKlass::ClassState)0;
123   _nonstatic_field_size = -1;
124   _has_nonstatic_fields = false;
<span class="line-modified">125   _nonstatic_fields = NULL;</span>
126   _has_injected_fields = -1;
127   _is_unsafe_anonymous = false;
128   _is_hidden = false;
129   _is_record = false;
130   _loader = loader;
131   _protection_domain = protection_domain;
132   _is_shared = false;
133   _super = NULL;
134   _java_mirror = NULL;
135   _field_cache = NULL;
136 }
137 
138 
139 
140 // ------------------------------------------------------------------
141 // ciInstanceKlass::compute_shared_is_initialized
142 void ciInstanceKlass::compute_shared_init_state() {
143   GUARDED_VM_ENTRY(
144     InstanceKlass* ik = get_instanceKlass();
145     _init_state = ik-&gt;init_state();
</pre>
<hr />
<pre>
315   if (name()-&gt;index_of_at(len+1, &quot;/&quot;, 1) &gt;= 0)
316     return false;
317 
318   return true;
319 }
320 
321 // ------------------------------------------------------------------
322 // ciInstanceKlass::print_impl
323 //
324 // Implementation of the print method.
325 void ciInstanceKlass::print_impl(outputStream* st) {
326   ciKlass::print_impl(st);
327   GUARDED_VM_ENTRY(st-&gt;print(&quot; loader=&quot; INTPTR_FORMAT, p2i(loader()));)
328   if (is_loaded()) {
329     st-&gt;print(&quot; loaded=true initialized=%s finalized=%s subklass=%s size=%d flags=&quot;,
330               bool_to_str(is_initialized()),
331               bool_to_str(has_finalizer()),
332               bool_to_str(has_subklass()),
333               layout_helper());
334 
<span class="line-modified">335     _flags.print_klass_flags();</span>
336 
337     if (_super) {
338       st-&gt;print(&quot; super=&quot;);
<span class="line-modified">339       _super-&gt;print_name();</span>
340     }
341     if (_java_mirror) {
342       st-&gt;print(&quot; mirror=PRESENT&quot;);
343     }
344   } else {
345     st-&gt;print(&quot; loaded=false&quot;);
346   }
347 }
348 
349 // ------------------------------------------------------------------
350 // ciInstanceKlass::super
351 //
352 // Get the superklass of this klass.
353 ciInstanceKlass* ciInstanceKlass::super() {
354   assert(is_loaded(), &quot;must be loaded&quot;);
355   if (_super == NULL &amp;&amp; !is_java_lang_Object()) {
356     GUARDED_VM_ENTRY(
357       Klass* super_klass = get_instanceKlass()-&gt;super();
358       _super = CURRENT_ENV-&gt;get_instance_klass(super_klass);
359     )
</pre>
<hr />
<pre>
415       ciField* field = _nonstatic_fields-&gt;at(i);
416       int  field_off = field-&gt;offset_in_bytes();
417       if (field_off == field_offset)
418         return field;
419       if (field_off &gt; field_offset)
420         break;
421       // could do binary search or check bins, but probably not worth it
422     }
423     return NULL;
424   }
425   VM_ENTRY_MARK;
426   InstanceKlass* k = get_instanceKlass();
427   fieldDescriptor fd;
428   if (!k-&gt;find_field_from_offset(field_offset, is_static, &amp;fd)) {
429     return NULL;
430   }
431   ciField* field = new (CURRENT_THREAD_ENV-&gt;arena()) ciField(&amp;fd);
432   return field;
433 }
434 























435 // ------------------------------------------------------------------
436 // ciInstanceKlass::get_field_by_name
437 ciField* ciInstanceKlass::get_field_by_name(ciSymbol* name, ciSymbol* signature, bool is_static) {
438   VM_ENTRY_MARK;
439   InstanceKlass* k = get_instanceKlass();
440   fieldDescriptor fd;
441   Klass* def = k-&gt;find_field(name-&gt;get_symbol(), signature-&gt;get_symbol(), is_static, &amp;fd);
442   if (def == NULL) {
443     return NULL;
444   }
445   ciField* field = new (CURRENT_THREAD_ENV-&gt;arena()) ciField(&amp;fd);
446   return field;
447 }
448 
449 
450 static int sort_field_by_offset(ciField** a, ciField** b) {
451   return (*a)-&gt;offset_in_bytes() - (*b)-&gt;offset_in_bytes();
452   // (no worries about 32-bit overflow...)
453 }
454 
</pre>
<hr />
<pre>
476     int super_flen   = super-&gt;nof_nonstatic_fields();
477     super_fields = super-&gt;_nonstatic_fields;
478     assert(super_flen == 0 || super_fields != NULL, &quot;first get nof_fields&quot;);
479   }
480 
481   GrowableArray&lt;ciField*&gt;* fields = NULL;
482   GUARDED_VM_ENTRY({
483       fields = compute_nonstatic_fields_impl(super_fields);
484     });
485 
486   if (fields == NULL) {
487     // This can happen if this class (java.lang.Class) has invisible fields.
488     if (super_fields != NULL) {
489       _nonstatic_fields = super_fields;
490       return super_fields-&gt;length();
491     } else {
492       return 0;
493     }
494   }
495 
<span class="line-modified">496   int flen = fields-&gt;length();</span>
<span class="line-removed">497 </span>
<span class="line-removed">498   // Now sort them by offset, ascending.</span>
<span class="line-removed">499   // (In principle, they could mix with superclass fields.)</span>
<span class="line-removed">500   fields-&gt;sort(sort_field_by_offset);</span>
<span class="line-removed">501   _nonstatic_fields = fields;</span>
502   return flen;
503 }
504 
<span class="line-modified">505 GrowableArray&lt;ciField*&gt;*</span>
<span class="line-removed">506 ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray&lt;ciField*&gt;*</span>
<span class="line-removed">507                                                super_fields) {</span>
508   ASSERT_IN_VM;
509   Arena* arena = CURRENT_ENV-&gt;arena();
510   int flen = 0;
511   GrowableArray&lt;ciField*&gt;* fields = NULL;
512   InstanceKlass* k = get_instanceKlass();
513   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
514     if (fs.access_flags().is_static())  continue;
515     flen += 1;
516   }
517 
518   // allocate the array:
519   if (flen == 0) {
520     return NULL;  // return nothing if none are locally declared
521   }
522   if (super_fields != NULL) {
523     flen += super_fields-&gt;length();
524   }

525   fields = new (arena) GrowableArray&lt;ciField*&gt;(arena, flen, 0, NULL);
526   if (super_fields != NULL) {
527     fields-&gt;appendAll(super_fields);
528   }
529 
530   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
531     if (fs.access_flags().is_static())  continue;
532     fieldDescriptor&amp; fd = fs.field_descriptor();
<span class="line-modified">533     ciField* field = new (arena) ciField(&amp;fd);</span>
<span class="line-modified">534     fields-&gt;append(field);</span>




















535   }
536   assert(fields-&gt;length() == flen, &quot;sanity&quot;);



537   return fields;
538 }
539 
540 bool ciInstanceKlass::compute_injected_fields_helper() {
541   ASSERT_IN_VM;
542   InstanceKlass* k = get_instanceKlass();
543 
544   for (InternalFieldStream fs(k); !fs.done(); fs.next()) {
545     if (fs.access_flags().is_static())  continue;
546     return true;
547   }
548   return false;
549 }
550 
551 void ciInstanceKlass::compute_injected_fields() {
552   assert(is_loaded(), &quot;must be loaded&quot;);
553 
554   int has_injected_fields = 0;
555   if (super() != NULL &amp;&amp; super()-&gt;has_injected_fields()) {
556     has_injected_fields = 1;
</pre>
<hr />
<pre>
614       VM_ENTRY_MARK;
615       MutexLocker ml(Compile_lock);
616       Klass* k = get_instanceKlass()-&gt;implementor();
617       if (k != NULL) {
618         if (k == get_instanceKlass()) {
619           // More than one implementors. Use &#39;this&#39; in this case.
620           impl = this;
621         } else {
622           impl = CURRENT_THREAD_ENV-&gt;get_instance_klass(k);
623         }
624       }
625     }
626     // Memoize this result.
627     if (!is_shared()) {
628       _implementor = impl;
629     }
630   }
631   return impl;
632 }
633 
















634 ciInstanceKlass* ciInstanceKlass::unsafe_anonymous_host() {
635   assert(is_loaded(), &quot;must be loaded&quot;);
636   if (is_unsafe_anonymous()) {
637     VM_ENTRY_MARK
638     Klass* unsafe_anonymous_host = get_instanceKlass()-&gt;unsafe_anonymous_host();
639     return CURRENT_ENV-&gt;get_instance_klass(unsafe_anonymous_host);
640   }
641   return NULL;
642 }
643 
644 // Utility class for printing of the contents of the static fields for
645 // use by compilation replay.  It only prints out the information that
646 // could be consumed by the compiler, so for primitive types it prints
647 // out the actual value.  For Strings it&#39;s the actual string value.
648 // For array types it it&#39;s first level array size since that&#39;s the
649 // only value which statically unchangeable.  For all other reference
650 // types it simply prints out the dynamic type.
651 
<span class="line-modified">652 class StaticFinalFieldPrinter : public FieldClosure {</span>

653   outputStream* _out;








654   const char*   _holder;
655  public:
656   StaticFinalFieldPrinter(outputStream* out, const char* holder) :
<span class="line-modified">657     _out(out),</span>
<span class="line-removed">658     _holder(holder) {</span>
659   }
660   void do_field(fieldDescriptor* fd) {
661     if (fd-&gt;is_final() &amp;&amp; !fd-&gt;has_initial_value()) {
662       ResourceMark rm;
<span class="line-modified">663       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();</span>
<span class="line-modified">664       _out-&gt;print(&quot;staticfield %s %s %s &quot;, _holder, fd-&gt;name()-&gt;as_quoted_ascii(), fd-&gt;signature()-&gt;as_quoted_ascii());</span>
<span class="line-modified">665       switch (fd-&gt;field_type()) {</span>
<span class="line-modified">666         case T_BYTE:    _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;byte_field(fd-&gt;offset()));   break;</span>
<span class="line-modified">667         case T_BOOLEAN: _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;bool_field(fd-&gt;offset()));   break;</span>
<span class="line-modified">668         case T_SHORT:   _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;short_field(fd-&gt;offset()));  break;</span>
<span class="line-modified">669         case T_CHAR:    _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;char_field(fd-&gt;offset()));   break;</span>
<span class="line-modified">670         case T_INT:     _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;int_field(fd-&gt;offset()));    break;</span>
<span class="line-modified">671         case T_LONG:    _out-&gt;print_cr(INT64_FORMAT, (int64_t)(mirror-&gt;long_field(fd-&gt;offset())));   break;</span>
<span class="line-modified">672         case T_FLOAT: {</span>
<span class="line-modified">673           float f = mirror-&gt;float_field(fd-&gt;offset());</span>
<span class="line-modified">674           _out-&gt;print_cr(&quot;%d&quot;, *(int*)&amp;f);</span>
<span class="line-modified">675           break;</span>
<span class="line-modified">676         }</span>
<span class="line-modified">677         case T_DOUBLE: {</span>
<span class="line-modified">678           double d = mirror-&gt;double_field(fd-&gt;offset());</span>
<span class="line-modified">679           _out-&gt;print_cr(INT64_FORMAT, *(int64_t*)&amp;d);</span>
<span class="line-modified">680           break;</span>
<span class="line-modified">681         }</span>
<span class="line-modified">682         case T_ARRAY:  // fall-through</span>
<span class="line-modified">683         case T_OBJECT: {</span>
<span class="line-modified">684           oop value =  mirror-&gt;obj_field_acquire(fd-&gt;offset());</span>
<span class="line-modified">685           if (value == NULL) {</span>
<span class="line-modified">686             _out-&gt;print_cr(&quot;null&quot;);</span>
<span class="line-modified">687           } else if (value-&gt;is_instance()) {</span>
<span class="line-modified">688             assert(fd-&gt;field_type() == T_OBJECT, &quot;&quot;);</span>
<span class="line-modified">689             if (value-&gt;is_a(SystemDictionary::String_klass())) {</span>
<span class="line-modified">690               const char* ascii_value = java_lang_String::as_quoted_ascii(value);</span>
<span class="line-modified">691               _out-&gt;print(&quot;\&quot;%s\&quot;&quot;, (ascii_value != NULL) ? ascii_value : &quot;&quot;);</span>
<span class="line-modified">692             } else {</span>
<span class="line-modified">693               const char* klass_name  = value-&gt;klass()-&gt;name()-&gt;as_quoted_ascii();</span>
<span class="line-modified">694               _out-&gt;print_cr(&quot;%s&quot;, klass_name);</span>
<span class="line-modified">695             }</span>
<span class="line-modified">696           } else if (value-&gt;is_array()) {</span>
<span class="line-modified">697             typeArrayOop ta = (typeArrayOop)value;</span>
<span class="line-modified">698             _out-&gt;print(&quot;%d&quot;, ta-&gt;length());</span>
<span class="line-modified">699             if (value-&gt;is_objArray()) {</span>
<span class="line-modified">700               objArrayOop oa = (objArrayOop)value;</span>
<span class="line-modified">701               const char* klass_name  = value-&gt;klass()-&gt;name()-&gt;as_quoted_ascii();</span>
<span class="line-modified">702               _out-&gt;print(&quot; %s&quot;, klass_name);</span>
<span class="line-modified">703             }</span>
<span class="line-modified">704             _out-&gt;cr();</span>
<span class="line-modified">705           } else {</span>
<span class="line-modified">706             ShouldNotReachHere();</span>
<span class="line-modified">707           }</span>
<span class="line-modified">708           break;</span>












709         }
<span class="line-modified">710         default:</span>
<span class="line-modified">711           ShouldNotReachHere();</span>





712         }




713     }
























714   }
<span class="line-modified">715 };</span>
716 
717 
718 void ciInstanceKlass::dump_replay_data(outputStream* out) {
719   ResourceMark rm;
720 
721   InstanceKlass* ik = get_instanceKlass();
722   ConstantPool*  cp = ik-&gt;constants();
723 
724   // Try to record related loaded classes
725   Klass* sub = ik-&gt;subklass();
726   while (sub != NULL) {
727     if (sub-&gt;is_instance_klass()) {
728       out-&gt;print_cr(&quot;instanceKlass %s&quot;, sub-&gt;name()-&gt;as_quoted_ascii());
729     }
730     sub = sub-&gt;next_sibling();
731   }
732 
733   // Dump out the state of the constant pool tags.  During replay the
734   // tags will be validated for things which shouldn&#39;t change and
735   // classes will be resolved if the tags indicate that they were
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciField.hpp&quot;
<span class="line-added"> 27 #include &quot;ci/ciInlineKlass.hpp&quot;</span>
 28 #include &quot;ci/ciInstance.hpp&quot;
 29 #include &quot;ci/ciInstanceKlass.hpp&quot;
 30 #include &quot;ci/ciUtilities.inline.hpp&quot;
 31 #include &quot;classfile/systemDictionary.hpp&quot;
 32 #include &quot;memory/allocation.hpp&quot;
 33 #include &quot;memory/allocation.inline.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;oops/fieldStreams.inline.hpp&quot;
<span class="line-added"> 37 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
 38 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 39 #include &quot;runtime/handles.inline.hpp&quot;
 40 #include &quot;runtime/jniHandles.inline.hpp&quot;
 41 
 42 // ciInstanceKlass
 43 //
 44 // This class represents a Klass* in the HotSpot virtual machine
 45 // whose Klass part in an InstanceKlass.
 46 
 47 
 48 // ------------------------------------------------------------------
 49 // ciInstanceKlass::ciInstanceKlass
 50 //
 51 // Loaded instance klass.
 52 ciInstanceKlass::ciInstanceKlass(Klass* k) :
 53   ciKlass(k)
 54 {
 55   assert(get_Klass()-&gt;is_instance_klass(), &quot;wrong type&quot;);
 56   assert(get_instanceKlass()-&gt;is_loaded(), &quot;must be at least loaded&quot;);
 57   InstanceKlass* ik = get_instanceKlass();
</pre>
<hr />
<pre>
100     _protection_domain = JNIHandles::make_global(h_protection_domain);
101     _is_shared = true;
102   }
103 
104   // Lazy fields get filled in only upon request.
105   _super  = NULL;
106   _java_mirror = NULL;
107 
108   if (is_shared()) {
109     if (k != SystemDictionary::Object_klass()) {
110       super();
111     }
112     //compute_nonstatic_fields();  // done outside of constructor
113   }
114 
115   _field_cache = NULL;
116 }
117 
118 // Version for unloaded classes:
119 ciInstanceKlass::ciInstanceKlass(ciSymbol* name,
<span class="line-modified">120                                  jobject loader, jobject protection_domain,</span>
<span class="line-modified">121                                  BasicType bt)</span>
<span class="line-added">122   : ciKlass(name, bt)</span>
123 {
124   assert(name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY, &quot;not an instance klass&quot;);
125   _init_state = (InstanceKlass::ClassState)0;
126   _nonstatic_field_size = -1;
127   _has_nonstatic_fields = false;
<span class="line-modified">128   _nonstatic_fields = NULL;            // initialized lazily by compute_nonstatic_fields</span>
129   _has_injected_fields = -1;
130   _is_unsafe_anonymous = false;
131   _is_hidden = false;
132   _is_record = false;
133   _loader = loader;
134   _protection_domain = protection_domain;
135   _is_shared = false;
136   _super = NULL;
137   _java_mirror = NULL;
138   _field_cache = NULL;
139 }
140 
141 
142 
143 // ------------------------------------------------------------------
144 // ciInstanceKlass::compute_shared_is_initialized
145 void ciInstanceKlass::compute_shared_init_state() {
146   GUARDED_VM_ENTRY(
147     InstanceKlass* ik = get_instanceKlass();
148     _init_state = ik-&gt;init_state();
</pre>
<hr />
<pre>
318   if (name()-&gt;index_of_at(len+1, &quot;/&quot;, 1) &gt;= 0)
319     return false;
320 
321   return true;
322 }
323 
324 // ------------------------------------------------------------------
325 // ciInstanceKlass::print_impl
326 //
327 // Implementation of the print method.
328 void ciInstanceKlass::print_impl(outputStream* st) {
329   ciKlass::print_impl(st);
330   GUARDED_VM_ENTRY(st-&gt;print(&quot; loader=&quot; INTPTR_FORMAT, p2i(loader()));)
331   if (is_loaded()) {
332     st-&gt;print(&quot; loaded=true initialized=%s finalized=%s subklass=%s size=%d flags=&quot;,
333               bool_to_str(is_initialized()),
334               bool_to_str(has_finalizer()),
335               bool_to_str(has_subklass()),
336               layout_helper());
337 
<span class="line-modified">338     _flags.print_klass_flags(st);</span>
339 
340     if (_super) {
341       st-&gt;print(&quot; super=&quot;);
<span class="line-modified">342       _super-&gt;print_name_on(st);</span>
343     }
344     if (_java_mirror) {
345       st-&gt;print(&quot; mirror=PRESENT&quot;);
346     }
347   } else {
348     st-&gt;print(&quot; loaded=false&quot;);
349   }
350 }
351 
352 // ------------------------------------------------------------------
353 // ciInstanceKlass::super
354 //
355 // Get the superklass of this klass.
356 ciInstanceKlass* ciInstanceKlass::super() {
357   assert(is_loaded(), &quot;must be loaded&quot;);
358   if (_super == NULL &amp;&amp; !is_java_lang_Object()) {
359     GUARDED_VM_ENTRY(
360       Klass* super_klass = get_instanceKlass()-&gt;super();
361       _super = CURRENT_ENV-&gt;get_instance_klass(super_klass);
362     )
</pre>
<hr />
<pre>
418       ciField* field = _nonstatic_fields-&gt;at(i);
419       int  field_off = field-&gt;offset_in_bytes();
420       if (field_off == field_offset)
421         return field;
422       if (field_off &gt; field_offset)
423         break;
424       // could do binary search or check bins, but probably not worth it
425     }
426     return NULL;
427   }
428   VM_ENTRY_MARK;
429   InstanceKlass* k = get_instanceKlass();
430   fieldDescriptor fd;
431   if (!k-&gt;find_field_from_offset(field_offset, is_static, &amp;fd)) {
432     return NULL;
433   }
434   ciField* field = new (CURRENT_THREAD_ENV-&gt;arena()) ciField(&amp;fd);
435   return field;
436 }
437 
<span class="line-added">438 ciField* ciInstanceKlass::get_non_flattened_field_by_offset(int field_offset) {</span>
<span class="line-added">439   if (super() != NULL &amp;&amp; super()-&gt;has_nonstatic_fields()) {</span>
<span class="line-added">440     ciField* f = super()-&gt;get_non_flattened_field_by_offset(field_offset);</span>
<span class="line-added">441     if (f != NULL) {</span>
<span class="line-added">442       return f;</span>
<span class="line-added">443     }</span>
<span class="line-added">444   }</span>
<span class="line-added">445 </span>
<span class="line-added">446   VM_ENTRY_MARK;</span>
<span class="line-added">447   InstanceKlass* k = get_instanceKlass();</span>
<span class="line-added">448   Arena* arena = CURRENT_ENV-&gt;arena();</span>
<span class="line-added">449   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {</span>
<span class="line-added">450     if (fs.access_flags().is_static())  continue;</span>
<span class="line-added">451     fieldDescriptor&amp; fd = fs.field_descriptor();</span>
<span class="line-added">452     if (fd.offset() == field_offset) {</span>
<span class="line-added">453       ciField* f = new (arena) ciField(&amp;fd);</span>
<span class="line-added">454       return f;</span>
<span class="line-added">455     }</span>
<span class="line-added">456   }</span>
<span class="line-added">457 </span>
<span class="line-added">458   return NULL;</span>
<span class="line-added">459 }</span>
<span class="line-added">460 </span>
461 // ------------------------------------------------------------------
462 // ciInstanceKlass::get_field_by_name
463 ciField* ciInstanceKlass::get_field_by_name(ciSymbol* name, ciSymbol* signature, bool is_static) {
464   VM_ENTRY_MARK;
465   InstanceKlass* k = get_instanceKlass();
466   fieldDescriptor fd;
467   Klass* def = k-&gt;find_field(name-&gt;get_symbol(), signature-&gt;get_symbol(), is_static, &amp;fd);
468   if (def == NULL) {
469     return NULL;
470   }
471   ciField* field = new (CURRENT_THREAD_ENV-&gt;arena()) ciField(&amp;fd);
472   return field;
473 }
474 
475 
476 static int sort_field_by_offset(ciField** a, ciField** b) {
477   return (*a)-&gt;offset_in_bytes() - (*b)-&gt;offset_in_bytes();
478   // (no worries about 32-bit overflow...)
479 }
480 
</pre>
<hr />
<pre>
502     int super_flen   = super-&gt;nof_nonstatic_fields();
503     super_fields = super-&gt;_nonstatic_fields;
504     assert(super_flen == 0 || super_fields != NULL, &quot;first get nof_fields&quot;);
505   }
506 
507   GrowableArray&lt;ciField*&gt;* fields = NULL;
508   GUARDED_VM_ENTRY({
509       fields = compute_nonstatic_fields_impl(super_fields);
510     });
511 
512   if (fields == NULL) {
513     // This can happen if this class (java.lang.Class) has invisible fields.
514     if (super_fields != NULL) {
515       _nonstatic_fields = super_fields;
516       return super_fields-&gt;length();
517     } else {
518       return 0;
519     }
520   }
521 
<span class="line-modified">522   _nonstatic_fields = fields;</span>





523   return fields-&gt;length();
524 }
525 
<span class="line-modified">526 GrowableArray&lt;ciField*&gt;* ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray&lt;ciField*&gt;* super_fields, bool flatten) {</span>


527   ASSERT_IN_VM;
528   Arena* arena = CURRENT_ENV-&gt;arena();
529   int flen = 0;
530   GrowableArray&lt;ciField*&gt;* fields = NULL;
531   InstanceKlass* k = get_instanceKlass();
532   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
533     if (fs.access_flags().is_static())  continue;
534     flen += 1;
535   }
536 
537   // allocate the array:
538   if (flen == 0) {
539     return NULL;  // return nothing if none are locally declared
540   }
541   if (super_fields != NULL) {
542     flen += super_fields-&gt;length();
543   }
<span class="line-added">544 </span>
545   fields = new (arena) GrowableArray&lt;ciField*&gt;(arena, flen, 0, NULL);
546   if (super_fields != NULL) {
547     fields-&gt;appendAll(super_fields);
548   }
549 
550   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
551     if (fs.access_flags().is_static())  continue;
552     fieldDescriptor&amp; fd = fs.field_descriptor();
<span class="line-modified">553     if (fd.is_inlined() &amp;&amp; flatten) {</span>
<span class="line-modified">554       // Inline type fields are embedded</span>
<span class="line-added">555       int field_offset = fd.offset();</span>
<span class="line-added">556       // Get InlineKlass and adjust number of fields</span>
<span class="line-added">557       Klass* k = get_instanceKlass()-&gt;get_inline_type_field_klass(fd.index());</span>
<span class="line-added">558       ciInlineKlass* vk = CURRENT_ENV-&gt;get_klass(k)-&gt;as_inline_klass();</span>
<span class="line-added">559       flen += vk-&gt;nof_nonstatic_fields() - 1;</span>
<span class="line-added">560       // Iterate over fields of the flattened inline type and copy them to &#39;this&#39;</span>
<span class="line-added">561       for (int i = 0; i &lt; vk-&gt;nof_nonstatic_fields(); ++i) {</span>
<span class="line-added">562         ciField* flattened_field = vk-&gt;nonstatic_field_at(i);</span>
<span class="line-added">563         // Adjust offset to account for missing oop header</span>
<span class="line-added">564         int offset = field_offset + (flattened_field-&gt;offset() - vk-&gt;first_field_offset());</span>
<span class="line-added">565         // A flattened field can be treated as final if the non-flattened</span>
<span class="line-added">566         // field is declared final or the holder klass is an inline type itself.</span>
<span class="line-added">567         bool is_final = fd.is_final() || is_inlinetype();</span>
<span class="line-added">568         ciField* field = new (arena) ciField(flattened_field, this, offset, is_final);</span>
<span class="line-added">569         fields-&gt;append(field);</span>
<span class="line-added">570       }</span>
<span class="line-added">571     } else {</span>
<span class="line-added">572       ciField* field = new (arena) ciField(&amp;fd);</span>
<span class="line-added">573       fields-&gt;append(field);</span>
<span class="line-added">574     }</span>
575   }
576   assert(fields-&gt;length() == flen, &quot;sanity&quot;);
<span class="line-added">577   // Now sort them by offset, ascending.</span>
<span class="line-added">578   // (In principle, they could mix with superclass fields.)</span>
<span class="line-added">579   fields-&gt;sort(sort_field_by_offset);</span>
580   return fields;
581 }
582 
583 bool ciInstanceKlass::compute_injected_fields_helper() {
584   ASSERT_IN_VM;
585   InstanceKlass* k = get_instanceKlass();
586 
587   for (InternalFieldStream fs(k); !fs.done(); fs.next()) {
588     if (fs.access_flags().is_static())  continue;
589     return true;
590   }
591   return false;
592 }
593 
594 void ciInstanceKlass::compute_injected_fields() {
595   assert(is_loaded(), &quot;must be loaded&quot;);
596 
597   int has_injected_fields = 0;
598   if (super() != NULL &amp;&amp; super()-&gt;has_injected_fields()) {
599     has_injected_fields = 1;
</pre>
<hr />
<pre>
657       VM_ENTRY_MARK;
658       MutexLocker ml(Compile_lock);
659       Klass* k = get_instanceKlass()-&gt;implementor();
660       if (k != NULL) {
661         if (k == get_instanceKlass()) {
662           // More than one implementors. Use &#39;this&#39; in this case.
663           impl = this;
664         } else {
665           impl = CURRENT_THREAD_ENV-&gt;get_instance_klass(k);
666         }
667       }
668     }
669     // Memoize this result.
670     if (!is_shared()) {
671       _implementor = impl;
672     }
673   }
674   return impl;
675 }
676 
<span class="line-added">677 bool ciInstanceKlass::can_be_inline_klass(bool is_exact) {</span>
<span class="line-added">678   if (!EnableValhalla) {</span>
<span class="line-added">679     return false;</span>
<span class="line-added">680   }</span>
<span class="line-added">681   if (!is_loaded() || is_inlinetype()) {</span>
<span class="line-added">682     // Not loaded or known to be an inline klass</span>
<span class="line-added">683     return true;</span>
<span class="line-added">684   }</span>
<span class="line-added">685   if (!is_exact) {</span>
<span class="line-added">686     // Not exact, check if this is a valid super for an inline klass</span>
<span class="line-added">687     VM_ENTRY_MARK;</span>
<span class="line-added">688     return !get_instanceKlass()-&gt;invalid_inline_super();</span>
<span class="line-added">689   }</span>
<span class="line-added">690   return false;</span>
<span class="line-added">691 }</span>
<span class="line-added">692 </span>
693 ciInstanceKlass* ciInstanceKlass::unsafe_anonymous_host() {
694   assert(is_loaded(), &quot;must be loaded&quot;);
695   if (is_unsafe_anonymous()) {
696     VM_ENTRY_MARK
697     Klass* unsafe_anonymous_host = get_instanceKlass()-&gt;unsafe_anonymous_host();
698     return CURRENT_ENV-&gt;get_instance_klass(unsafe_anonymous_host);
699   }
700   return NULL;
701 }
702 
703 // Utility class for printing of the contents of the static fields for
704 // use by compilation replay.  It only prints out the information that
705 // could be consumed by the compiler, so for primitive types it prints
706 // out the actual value.  For Strings it&#39;s the actual string value.
707 // For array types it it&#39;s first level array size since that&#39;s the
708 // only value which statically unchangeable.  For all other reference
709 // types it simply prints out the dynamic type.
710 
<span class="line-modified">711 class StaticFieldPrinter : public FieldClosure {</span>
<span class="line-added">712 protected:</span>
713   outputStream* _out;
<span class="line-added">714 public:</span>
<span class="line-added">715   StaticFieldPrinter(outputStream* out) :</span>
<span class="line-added">716     _out(out) {</span>
<span class="line-added">717   }</span>
<span class="line-added">718   void do_field_helper(fieldDescriptor* fd, oop obj, bool flattened);</span>
<span class="line-added">719 };</span>
<span class="line-added">720 </span>
<span class="line-added">721 class StaticFinalFieldPrinter : public StaticFieldPrinter {</span>
722   const char*   _holder;
723  public:
724   StaticFinalFieldPrinter(outputStream* out, const char* holder) :
<span class="line-modified">725     StaticFieldPrinter(out), _holder(holder) {</span>

726   }
727   void do_field(fieldDescriptor* fd) {
728     if (fd-&gt;is_final() &amp;&amp; !fd-&gt;has_initial_value()) {
729       ResourceMark rm;
<span class="line-modified">730       InstanceKlass* holder = fd-&gt;field_holder();</span>
<span class="line-modified">731       oop mirror = holder-&gt;java_mirror();</span>
<span class="line-modified">732       _out-&gt;print(&quot;staticfield %s %s &quot;, _holder, fd-&gt;name()-&gt;as_quoted_ascii());</span>
<span class="line-modified">733       BasicType bt = fd-&gt;field_type();</span>
<span class="line-modified">734       if (bt != T_OBJECT &amp;&amp; bt != T_ARRAY) {</span>
<span class="line-modified">735         _out-&gt;print(&quot;%s &quot;, fd-&gt;signature()-&gt;as_quoted_ascii());</span>
<span class="line-modified">736       }</span>
<span class="line-modified">737       do_field_helper(fd, mirror, false);</span>
<span class="line-modified">738       _out-&gt;cr();</span>
<span class="line-modified">739     }</span>
<span class="line-modified">740   }</span>
<span class="line-modified">741 };</span>
<span class="line-modified">742 </span>
<span class="line-modified">743 class InlineTypeFieldPrinter : public StaticFieldPrinter {</span>
<span class="line-modified">744   oop _obj;</span>
<span class="line-modified">745 public:</span>
<span class="line-modified">746   InlineTypeFieldPrinter(outputStream* out, oop obj) :</span>
<span class="line-modified">747     StaticFieldPrinter(out), _obj(obj) {</span>
<span class="line-modified">748   }</span>
<span class="line-modified">749   void do_field(fieldDescriptor* fd) {</span>
<span class="line-modified">750     do_field_helper(fd, _obj, true);</span>
<span class="line-modified">751     _out-&gt;print(&quot; &quot;);</span>
<span class="line-modified">752   }</span>
<span class="line-modified">753 };</span>
<span class="line-modified">754 </span>
<span class="line-modified">755 void StaticFieldPrinter::do_field_helper(fieldDescriptor* fd, oop mirror, bool flattened) {</span>
<span class="line-modified">756   BasicType bt = fd-&gt;field_type();</span>
<span class="line-modified">757   switch (bt) {</span>
<span class="line-modified">758     case T_BYTE:    _out-&gt;print(&quot;%d&quot;, mirror-&gt;byte_field(fd-&gt;offset()));   break;</span>
<span class="line-modified">759     case T_BOOLEAN: _out-&gt;print(&quot;%d&quot;, mirror-&gt;bool_field(fd-&gt;offset()));   break;</span>
<span class="line-modified">760     case T_SHORT:   _out-&gt;print(&quot;%d&quot;, mirror-&gt;short_field(fd-&gt;offset()));  break;</span>
<span class="line-modified">761     case T_CHAR:    _out-&gt;print(&quot;%d&quot;, mirror-&gt;char_field(fd-&gt;offset()));   break;</span>
<span class="line-modified">762     case T_INT:     _out-&gt;print(&quot;%d&quot;, mirror-&gt;int_field(fd-&gt;offset()));    break;</span>
<span class="line-modified">763     case T_LONG:    _out-&gt;print(INT64_FORMAT, (int64_t)(mirror-&gt;long_field(fd-&gt;offset())));   break;</span>
<span class="line-modified">764     case T_FLOAT: {</span>
<span class="line-modified">765       float f = mirror-&gt;float_field(fd-&gt;offset());</span>
<span class="line-modified">766       _out-&gt;print(&quot;%d&quot;, *(int*)&amp;f);</span>
<span class="line-modified">767       break;</span>
<span class="line-modified">768     }</span>
<span class="line-modified">769     case T_DOUBLE: {</span>
<span class="line-modified">770       double d = mirror-&gt;double_field(fd-&gt;offset());</span>
<span class="line-modified">771       _out-&gt;print(INT64_FORMAT, *(int64_t*)&amp;d);</span>
<span class="line-modified">772       break;</span>
<span class="line-modified">773     }</span>
<span class="line-modified">774     case T_ARRAY:  // fall-through</span>
<span class="line-modified">775     case T_OBJECT: {</span>
<span class="line-added">776       _out-&gt;print(&quot;%s &quot;, fd-&gt;signature()-&gt;as_quoted_ascii());</span>
<span class="line-added">777       oop value =  mirror-&gt;obj_field_acquire(fd-&gt;offset());</span>
<span class="line-added">778       if (value == NULL) {</span>
<span class="line-added">779         _out-&gt;print_cr(&quot;null&quot;);</span>
<span class="line-added">780       } else if (value-&gt;is_instance()) {</span>
<span class="line-added">781         assert(fd-&gt;field_type() == T_OBJECT, &quot;&quot;);</span>
<span class="line-added">782         if (value-&gt;is_a(SystemDictionary::String_klass())) {</span>
<span class="line-added">783           const char* ascii_value = java_lang_String::as_quoted_ascii(value);</span>
<span class="line-added">784           _out-&gt;print(&quot;\&quot;%s\&quot;&quot;, (ascii_value != NULL) ? ascii_value : &quot;&quot;);</span>
<span class="line-added">785          } else {</span>
<span class="line-added">786           const char* klass_name  = value-&gt;klass()-&gt;name()-&gt;as_quoted_ascii();</span>
<span class="line-added">787           _out-&gt;print(&quot;%s&quot;, klass_name);</span>
788         }
<span class="line-modified">789       } else if (value-&gt;is_array()) {</span>
<span class="line-modified">790         typeArrayOop ta = (typeArrayOop)value;</span>
<span class="line-added">791         _out-&gt;print(&quot;%d&quot;, ta-&gt;length());</span>
<span class="line-added">792         if (value-&gt;is_objArray() || value-&gt;is_flatArray()) {</span>
<span class="line-added">793           objArrayOop oa = (objArrayOop)value;</span>
<span class="line-added">794           const char* klass_name  = value-&gt;klass()-&gt;name()-&gt;as_quoted_ascii();</span>
<span class="line-added">795           _out-&gt;print(&quot; %s&quot;, klass_name);</span>
796         }
<span class="line-added">797       } else {</span>
<span class="line-added">798         ShouldNotReachHere();</span>
<span class="line-added">799       }</span>
<span class="line-added">800       break;</span>
801     }
<span class="line-added">802     case T_INLINE_TYPE: {</span>
<span class="line-added">803       ResetNoHandleMark rnhm;</span>
<span class="line-added">804       Thread* THREAD = Thread::current();</span>
<span class="line-added">805       SignatureStream ss(fd-&gt;signature(), false);</span>
<span class="line-added">806       Symbol* name = ss.as_symbol();</span>
<span class="line-added">807       assert(!HAS_PENDING_EXCEPTION, &quot;can resolve klass?&quot;);</span>
<span class="line-added">808       InstanceKlass* holder = fd-&gt;field_holder();</span>
<span class="line-added">809       Klass* k = SystemDictionary::find(name, Handle(THREAD, holder-&gt;class_loader()),</span>
<span class="line-added">810                                         Handle(THREAD, holder-&gt;protection_domain()), THREAD);</span>
<span class="line-added">811       assert(k != NULL &amp;&amp; !HAS_PENDING_EXCEPTION, &quot;can resolve klass?&quot;);</span>
<span class="line-added">812       InlineKlass* vk = InlineKlass::cast(k);</span>
<span class="line-added">813       oop obj;</span>
<span class="line-added">814       if (flattened) {</span>
<span class="line-added">815         int field_offset = fd-&gt;offset() - vk-&gt;first_field_offset();</span>
<span class="line-added">816         obj = (oop) (cast_from_oop&lt;address&gt;(mirror) + field_offset);</span>
<span class="line-added">817       } else {</span>
<span class="line-added">818         obj =  mirror-&gt;obj_field_acquire(fd-&gt;offset());</span>
<span class="line-added">819       }</span>
<span class="line-added">820       InlineTypeFieldPrinter print_field(_out, obj);</span>
<span class="line-added">821       vk-&gt;do_nonstatic_fields(&amp;print_field);</span>
<span class="line-added">822       break;</span>
<span class="line-added">823     }</span>
<span class="line-added">824     default:</span>
<span class="line-added">825       ShouldNotReachHere();</span>
826   }
<span class="line-modified">827 }</span>
828 
829 
830 void ciInstanceKlass::dump_replay_data(outputStream* out) {
831   ResourceMark rm;
832 
833   InstanceKlass* ik = get_instanceKlass();
834   ConstantPool*  cp = ik-&gt;constants();
835 
836   // Try to record related loaded classes
837   Klass* sub = ik-&gt;subklass();
838   while (sub != NULL) {
839     if (sub-&gt;is_instance_klass()) {
840       out-&gt;print_cr(&quot;instanceKlass %s&quot;, sub-&gt;name()-&gt;as_quoted_ascii());
841     }
842     sub = sub-&gt;next_sibling();
843   }
844 
845   // Dump out the state of the constant pool tags.  During replay the
846   // tags will be validated for things which shouldn&#39;t change and
847   // classes will be resolved if the tags indicate that they were
</pre>
</td>
</tr>
</table>
<center><a href="ciField.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>