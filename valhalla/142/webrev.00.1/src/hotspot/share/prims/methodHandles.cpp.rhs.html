<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/methodHandles.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;code/codeCache.hpp&quot;
  30 #include &quot;code/dependencyContext.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/oopMapCache.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/oopFactory.hpp&quot;
  39 #include &quot;memory/resourceArea.hpp&quot;
  40 #include &quot;memory/universe.hpp&quot;
  41 #include &quot;oops/objArrayKlass.hpp&quot;
  42 #include &quot;oops/objArrayOop.inline.hpp&quot;
  43 #include &quot;oops/oop.inline.hpp&quot;
  44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  45 #include &quot;prims/methodHandles.hpp&quot;
  46 #include &quot;runtime/deoptimization.hpp&quot;
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
  49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  50 #include &quot;runtime/javaCalls.hpp&quot;
  51 #include &quot;runtime/jniHandles.inline.hpp&quot;
  52 #include &quot;runtime/timerTrace.hpp&quot;
  53 #include &quot;runtime/reflection.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/signature.hpp&quot;
  56 #include &quot;runtime/stubRoutines.hpp&quot;
  57 #include &quot;utilities/exceptions.hpp&quot;
  58 
  59 
  60 /*
  61  * JSR 292 reference implementation: method handles
  62  * The JDK 7 reference implementation represented method handle
  63  * combinations as chains.  Each link in the chain had a &quot;vmentry&quot;
  64  * field which pointed at a bit of assembly code which performed
  65  * one transformation before dispatching to the next link in the chain.
  66  *
  67  * The current reference implementation pushes almost all code generation
  68  * responsibility to (trusted) Java code.  A method handle contains a
  69  * pointer to its &quot;LambdaForm&quot;, which embodies all details of the method
  70  * handle&#39;s behavior.  The LambdaForm is a normal Java object, managed
  71  * by a runtime coded in Java.
  72  */
  73 
  74 bool MethodHandles::_enabled = false; // set true after successful native linkage
  75 MethodHandlesAdapterBlob* MethodHandles::_adapter_code = NULL;
  76 
  77 /**
  78  * Generates method handle adapters. Returns &#39;false&#39; if memory allocation
  79  * failed and true otherwise.
  80  */
  81 void MethodHandles::generate_adapters() {
  82   assert(SystemDictionary::MethodHandle_klass() != NULL, &quot;should be present&quot;);
  83   assert(_adapter_code == NULL, &quot;generate only once&quot;);
  84 
  85   ResourceMark rm;
  86   TraceTime timer(&quot;MethodHandles adapters generation&quot;, TRACETIME_LOG(Info, startuptime));
  87   _adapter_code = MethodHandlesAdapterBlob::create(adapter_code_size);
  88   CodeBuffer code(_adapter_code);
  89   MethodHandlesAdapterGenerator g(&amp;code);
  90   g.generate();
  91   code.log_section_sizes(&quot;MethodHandlesAdapterBlob&quot;);
  92 }
  93 
  94 //------------------------------------------------------------------------------
  95 // MethodHandlesAdapterGenerator::generate
  96 //
  97 void MethodHandlesAdapterGenerator::generate() {
  98   // Generate generic method handle adapters.
  99   // Generate interpreter entries
 100   for (Interpreter::MethodKind mk = Interpreter::method_handle_invoke_FIRST;
 101        mk &lt;= Interpreter::method_handle_invoke_LAST;
 102        mk = Interpreter::MethodKind(1 + (int)mk)) {
 103     vmIntrinsics::ID iid = Interpreter::method_handle_intrinsic(mk);
 104     StubCodeMark mark(this, &quot;MethodHandle::interpreter_entry&quot;, vmIntrinsics::name_at(iid));
 105     address entry = MethodHandles::generate_method_handle_interpreter_entry(_masm, iid);
 106     if (entry != NULL) {
 107       Interpreter::set_entry_for_kind(mk, entry);
 108     }
 109     // If the entry is not set, it will throw AbstractMethodError.
 110   }
 111 }
 112 
 113 void MethodHandles::set_enabled(bool z) {
 114   if (_enabled != z) {
 115     guarantee(z, &quot;can only enable once&quot;);
 116     _enabled = z;
 117   }
 118 }
 119 
 120 // MemberName support
 121 
 122 // import java_lang_invoke_MemberName.*
 123 enum {
<a name="1" id="anc1"></a><span class="line-modified"> 124   IS_METHOD             = java_lang_invoke_MemberName::MN_IS_METHOD,</span>
<span class="line-modified"> 125   IS_OBJECT_CONSTRUCTOR = java_lang_invoke_MemberName::MN_IS_OBJECT_CONSTRUCTOR,</span>
<span class="line-modified"> 126   IS_FIELD              = java_lang_invoke_MemberName::MN_IS_FIELD,</span>
<span class="line-modified"> 127   IS_TYPE               = java_lang_invoke_MemberName::MN_IS_TYPE,</span>
<span class="line-modified"> 128   CALLER_SENSITIVE      = java_lang_invoke_MemberName::MN_CALLER_SENSITIVE,</span>
 129   TRUSTED_FINAL        = java_lang_invoke_MemberName::MN_TRUSTED_FINAL,
<a name="2" id="anc2"></a><span class="line-modified"> 130   REFERENCE_KIND_SHIFT  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,</span>
<span class="line-modified"> 131   REFERENCE_KIND_MASK   = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,</span>
<span class="line-modified"> 132   SEARCH_SUPERCLASSES   = java_lang_invoke_MemberName::MN_SEARCH_SUPERCLASSES,</span>
<span class="line-modified"> 133   SEARCH_INTERFACES     = java_lang_invoke_MemberName::MN_SEARCH_INTERFACES,</span>
<span class="line-modified"> 134   ALL_KINDS      = IS_METHOD | IS_OBJECT_CONSTRUCTOR | IS_FIELD | IS_TYPE</span>
 135 };
 136 
 137 int MethodHandles::ref_kind_to_flags(int ref_kind) {
 138   assert(ref_kind_is_valid(ref_kind), &quot;%d&quot;, ref_kind);
 139   int flags = (ref_kind &lt;&lt; REFERENCE_KIND_SHIFT);
 140   if (ref_kind_is_field(ref_kind)) {
 141     flags |= IS_FIELD;
 142   } else if (ref_kind_is_method(ref_kind)) {
 143     flags |= IS_METHOD;
 144   } else if (ref_kind == JVM_REF_newInvokeSpecial) {
<a name="3" id="anc3"></a><span class="line-modified"> 145     flags |= IS_OBJECT_CONSTRUCTOR;</span>
 146   }
 147   return flags;
 148 }
 149 
 150 Handle MethodHandles::resolve_MemberName_type(Handle mname, Klass* caller, TRAPS) {
 151   Handle empty;
 152   Handle type(THREAD, java_lang_invoke_MemberName::type(mname()));
 153   if (!java_lang_String::is_instance_inlined(type())) {
 154     return type; // already resolved
 155   }
 156   Symbol* signature = java_lang_String::as_symbol_or_null(type());
 157   if (signature == NULL) {
 158     return empty;  // no such signature exists in the VM
 159   }
 160   Handle resolved;
 161   int flags = java_lang_invoke_MemberName::flags(mname());
 162   switch (flags &amp; ALL_KINDS) {
 163     case IS_METHOD:
<a name="4" id="anc4"></a><span class="line-modified"> 164     case IS_OBJECT_CONSTRUCTOR:</span>
 165       resolved = SystemDictionary::find_method_handle_type(signature, caller, CHECK_(empty));
 166       break;
 167     case IS_FIELD:
 168       resolved = SystemDictionary::find_field_handle_type(signature, caller, CHECK_(empty));
 169       break;
 170     default:
 171       THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unrecognized MemberName format&quot;, empty);
 172   }
 173   if (resolved.is_null()) {
 174     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad MemberName type&quot;, empty);
 175   }
 176   return resolved;
 177 }
 178 
 179 oop MethodHandles::init_MemberName(Handle mname, Handle target, TRAPS) {
 180   // This method is used from java.lang.invoke.MemberName constructors.
 181   // It fills in the new MemberName from a java.lang.reflect.Member.
 182   Thread* thread = Thread::current();
 183   oop target_oop = target();
 184   Klass* target_klass = target_oop-&gt;klass();
 185   if (target_klass == SystemDictionary::reflect_Field_klass()) {
 186     oop clazz = java_lang_reflect_Field::clazz(target_oop); // fd.field_holder()
 187     int slot  = java_lang_reflect_Field::slot(target_oop);  // fd.index()
 188     Klass* k = java_lang_Class::as_Klass(clazz);
 189     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 190       fieldDescriptor fd(InstanceKlass::cast(k), slot);
 191       oop mname2 = init_field_MemberName(mname, fd);
 192       if (mname2 != NULL) {
 193         // Since we have the reified name and type handy, add them to the result.
 194         if (java_lang_invoke_MemberName::name(mname2) == NULL)
 195           java_lang_invoke_MemberName::set_name(mname2, java_lang_reflect_Field::name(target_oop));
 196         if (java_lang_invoke_MemberName::type(mname2) == NULL)
 197           java_lang_invoke_MemberName::set_type(mname2, java_lang_reflect_Field::type(target_oop));
 198       }
 199       return mname2;
 200     }
 201   } else if (target_klass == SystemDictionary::reflect_Method_klass()) {
 202     oop clazz  = java_lang_reflect_Method::clazz(target_oop);
 203     int slot   = java_lang_reflect_Method::slot(target_oop);
 204     Klass* k = java_lang_Class::as_Klass(clazz);
 205     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 206       Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
 207       if (m == NULL || is_signature_polymorphic(m-&gt;intrinsic_id()))
 208         return NULL;            // do not resolve unless there is a concrete signature
 209       CallInfo info(m, k, CHECK_NULL);
 210       return init_method_MemberName(mname, info);
 211     }
 212   } else if (target_klass == SystemDictionary::reflect_Constructor_klass()) {
 213     oop clazz  = java_lang_reflect_Constructor::clazz(target_oop);
 214     int slot   = java_lang_reflect_Constructor::slot(target_oop);
 215     Klass* k = java_lang_Class::as_Klass(clazz);
 216     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 217       Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
 218       if (m == NULL)  return NULL;
 219       CallInfo info(m, k, CHECK_NULL);
 220       return init_method_MemberName(mname, info);
 221     }
 222   }
 223   return NULL;
 224 }
 225 
 226 oop MethodHandles::init_method_MemberName(Handle mname, CallInfo&amp; info) {
 227   assert(info.resolved_appendix().is_null(), &quot;only normal methods here&quot;);
 228   methodHandle m(Thread::current(), info.resolved_method());
 229   assert(m.not_null(), &quot;null method handle&quot;);
 230   InstanceKlass* m_klass = m-&gt;method_holder();
 231   assert(m_klass != NULL, &quot;null holder for method handle&quot;);
 232   int flags = (jushort)( m-&gt;access_flags().as_short() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS );
 233   int vmindex = Method::invalid_vtable_index;
 234   LogTarget(Debug, methodhandles, indy) lt_indy;
 235 
 236   switch (info.call_kind()) {
 237   case CallInfo::itable_call:
 238     vmindex = info.itable_index();
 239     // More importantly, the itable index only works with the method holder.
 240     assert(m_klass-&gt;verify_itable_index(vmindex), &quot;&quot;);
 241     flags |= IS_METHOD | (JVM_REF_invokeInterface &lt;&lt; REFERENCE_KIND_SHIFT);
 242     if (lt_indy.is_enabled()) {
 243       ResourceMark rm;
 244       LogStream ls(lt_indy);
 245       ls.print_cr(&quot;memberName: invokeinterface method_holder::method: %s, itableindex: %d, access_flags:&quot;,
 246                   Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),
 247                   vmindex);
 248        m-&gt;access_flags().print_on(&amp;ls);
 249        if (!m-&gt;is_abstract()) {
 250          if (!m-&gt;is_private()) {
 251            ls.print(&quot;default&quot;);
 252          }
 253          else {
 254            ls.print(&quot;private-intf&quot;);
 255          }
 256        }
 257        ls.cr();
 258     }
 259     break;
 260 
 261   case CallInfo::vtable_call:
 262     vmindex = info.vtable_index();
 263     flags |= IS_METHOD | (JVM_REF_invokeVirtual &lt;&lt; REFERENCE_KIND_SHIFT);
 264     assert(info.resolved_klass()-&gt;is_subtype_of(m_klass), &quot;virtual call must be type-safe&quot;);
 265     if (m_klass-&gt;is_interface()) {
 266       // This is a vtable call to an interface method (abstract &quot;miranda method&quot; or default method).
 267       // The vtable index is meaningless without a class (not interface) receiver type, so get one.
 268       // (LinkResolver should help us figure this out.)
 269       assert(info.resolved_klass()-&gt;is_instance_klass(), &quot;subtype of interface must be an instance klass&quot;);
 270       InstanceKlass* m_klass_non_interface = InstanceKlass::cast(info.resolved_klass());
 271       if (m_klass_non_interface-&gt;is_interface()) {
 272         m_klass_non_interface = SystemDictionary::Object_klass();
 273 #ifdef ASSERT
 274         { ResourceMark rm;
 275           Method* m2 = m_klass_non_interface-&gt;vtable().method_at(vmindex);
 276           assert(m-&gt;name() == m2-&gt;name() &amp;&amp; m-&gt;signature() == m2-&gt;signature(),
 277                  &quot;at %d, %s != %s&quot;, vmindex,
 278                  m-&gt;name_and_sig_as_C_string(), m2-&gt;name_and_sig_as_C_string());
 279         }
 280 #endif //ASSERT
 281       }
 282       if (!m-&gt;is_public()) {
 283         assert(m-&gt;is_public(), &quot;virtual call must be to public interface method&quot;);
 284         return NULL;  // elicit an error later in product build
 285       }
 286       assert(info.resolved_klass()-&gt;is_subtype_of(m_klass_non_interface), &quot;virtual call must be type-safe&quot;);
 287       m_klass = m_klass_non_interface;
 288     }
 289     if (lt_indy.is_enabled()) {
 290       ResourceMark rm;
 291       LogStream ls(lt_indy);
 292       ls.print_cr(&quot;memberName: invokevirtual method_holder::method: %s, receiver: %s, vtableindex: %d, access_flags:&quot;,
 293                   Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),
 294                   m_klass-&gt;internal_name(), vmindex);
 295        m-&gt;access_flags().print_on(&amp;ls);
 296        if (m-&gt;is_default_method()) {
 297          ls.print(&quot;default&quot;);
 298        }
 299        ls.cr();
 300     }
 301     break;
 302 
 303   case CallInfo::direct_call:
 304     vmindex = Method::nonvirtual_vtable_index;
 305     if (m-&gt;is_static()) {
 306       flags |= IS_METHOD      | (JVM_REF_invokeStatic  &lt;&lt; REFERENCE_KIND_SHIFT);
<a name="5" id="anc5"></a><span class="line-modified"> 307     } else if (m-&gt;is_object_constructor()) {</span>
<span class="line-modified"> 308       flags |= IS_OBJECT_CONSTRUCTOR | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);</span>
 309     } else {
 310       // &quot;special&quot; reflects that this is a direct call, not that it
 311       // necessarily originates from an invokespecial. We can also do
 312       // direct calls for private and/or final non-static methods.
 313       flags |= IS_METHOD      | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 314     }
 315     break;
 316 
 317   default:  assert(false, &quot;bad CallInfo&quot;);  return NULL;
 318   }
 319 
 320   // @CallerSensitive annotation detected
 321   if (m-&gt;caller_sensitive()) {
 322     flags |= CALLER_SENSITIVE;
 323   }
 324 
 325   Handle resolved_method = info.resolved_method_name();
 326   assert(java_lang_invoke_ResolvedMethodName::vmtarget(resolved_method()) == m() || m-&gt;is_old(),
 327          &quot;Should not change after link resolution&quot;);
 328 
 329   oop mname_oop = mname();
 330   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 331   java_lang_invoke_MemberName::set_method (mname_oop, resolved_method());
 332   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);   // vtable/itable index
 333   java_lang_invoke_MemberName::set_clazz  (mname_oop, m_klass-&gt;java_mirror());
 334   // Note:  name and type can be lazily computed by resolve_MemberName,
 335   // if Java code needs them as resolved String and MethodType objects.
 336   // If relevant, the vtable or itable value is stored as vmindex.
 337   // This is done eagerly, since it is readily available without
 338   // constructing any new objects.
 339   return mname();
 340 }
 341 
 342 oop MethodHandles::init_field_MemberName(Handle mname, fieldDescriptor&amp; fd, bool is_setter) {
 343   InstanceKlass* ik = fd.field_holder();
 344   int flags = (jushort)( fd.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS );
 345   flags |= IS_FIELD | ((fd.is_static() ? JVM_REF_getStatic : JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
<a name="6" id="anc6"></a><span class="line-added"> 346   if (fd.is_inlined()) {</span>
<span class="line-added"> 347     flags |= JVM_ACC_FIELD_INLINED;</span>
<span class="line-added"> 348   }</span>
 349   if (fd.is_trusted_final()) flags |= TRUSTED_FINAL;
 350   if (is_setter)  flags += ((JVM_REF_putField - JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
 351   int vmindex        = fd.offset();  // determines the field uniquely when combined with static bit
 352 
 353   oop mname_oop = mname();
 354   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 355   java_lang_invoke_MemberName::set_method (mname_oop, NULL);
 356   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);
 357   java_lang_invoke_MemberName::set_clazz  (mname_oop, ik-&gt;java_mirror());
 358 
 359   oop type = field_signature_type_or_null(fd.signature());
 360   oop name = field_name_or_null(fd.name());
 361   if (name != NULL)
 362     java_lang_invoke_MemberName::set_name(mname_oop,   name);
 363   if (type != NULL)
 364     java_lang_invoke_MemberName::set_type(mname_oop,   type);
 365   // Note:  name and type can be lazily computed by resolve_MemberName,
 366   // if Java code needs them as resolved String and Class objects.
 367   // Note that the incoming type oop might be pre-resolved (non-null).
 368   // The base clazz and field offset (vmindex) must be eagerly stored,
 369   // because they unambiguously identify the field.
 370   // Although the fieldDescriptor::_index would also identify the field,
 371   // we do not use it, because it is harder to decode.
 372   // TO DO: maybe intern mname_oop
 373   return mname();
 374 }
 375 
 376 // JVM 2.9 Special Methods:
 377 // A method is signature polymorphic if and only if all of the following conditions hold :
 378 // * It is declared in the java.lang.invoke.MethodHandle/VarHandle classes.
 379 // * It has a single formal parameter of type Object[].
 380 // * It has a return type of Object for a polymorphic return type, otherwise a fixed return type.
 381 // * It has the ACC_VARARGS and ACC_NATIVE flags set.
 382 bool MethodHandles::is_method_handle_invoke_name(Klass* klass, Symbol* name) {
 383   if (klass == NULL)
 384     return false;
 385   // The following test will fail spuriously during bootstrap of MethodHandle itself:
 386   //    if (klass != SystemDictionary::MethodHandle_klass())
 387   // Test the name instead:
 388   if (klass-&gt;name() != vmSymbols::java_lang_invoke_MethodHandle() &amp;&amp;
 389       klass-&gt;name() != vmSymbols::java_lang_invoke_VarHandle()) {
 390     return false;
 391   }
 392 
 393   // Look up signature polymorphic method with polymorphic return type
 394   Symbol* poly_sig = vmSymbols::object_array_object_signature();
 395   InstanceKlass* iklass = InstanceKlass::cast(klass);
 396   Method* m = iklass-&gt;find_method(name, poly_sig);
 397   if (m != NULL) {
 398     int required = JVM_ACC_NATIVE | JVM_ACC_VARARGS;
 399     int flags = m-&gt;access_flags().as_int();
 400     if ((flags &amp; required) == required) {
 401       return true;
 402     }
 403   }
 404 
 405   // Look up signature polymorphic method with non-polymorphic (non Object) return type
 406   int me;
 407   int ms = iklass-&gt;find_method_by_name(name, &amp;me);
 408   if (ms == -1) return false;
 409   for (; ms &lt; me; ms++) {
 410     Method* m = iklass-&gt;methods()-&gt;at(ms);
 411     int required = JVM_ACC_NATIVE | JVM_ACC_VARARGS;
 412     int flags = m-&gt;access_flags().as_int();
 413     if ((flags &amp; required) == required &amp;&amp; ArgumentCount(m-&gt;signature()).size() == 1) {
 414       return true;
 415     }
 416   }
 417   return false;
 418 }
 419 
 420 
 421 Symbol* MethodHandles::signature_polymorphic_intrinsic_name(vmIntrinsics::ID iid) {
 422   assert(is_signature_polymorphic_intrinsic(iid), &quot;%d %s&quot;, iid, vmIntrinsics::name_at(iid));
 423   switch (iid) {
 424   case vmIntrinsics::_invokeBasic:      return vmSymbols::invokeBasic_name();
 425   case vmIntrinsics::_linkToVirtual:    return vmSymbols::linkToVirtual_name();
 426   case vmIntrinsics::_linkToStatic:     return vmSymbols::linkToStatic_name();
 427   case vmIntrinsics::_linkToSpecial:    return vmSymbols::linkToSpecial_name();
 428   case vmIntrinsics::_linkToInterface:  return vmSymbols::linkToInterface_name();
 429   default:
 430     fatal(&quot;unexpected intrinsic id: %d %s&quot;, iid, vmIntrinsics::name_at(iid));
 431     return 0;
 432   }
 433 }
 434 
 435 Bytecodes::Code MethodHandles::signature_polymorphic_intrinsic_bytecode(vmIntrinsics::ID id) {
 436   switch(id) {
 437     case vmIntrinsics::_linkToVirtual:   return Bytecodes::_invokevirtual;
 438     case vmIntrinsics::_linkToInterface: return Bytecodes::_invokeinterface;
 439     case vmIntrinsics::_linkToStatic:    return Bytecodes::_invokestatic;
 440     case vmIntrinsics::_linkToSpecial:   return Bytecodes::_invokespecial;
 441     case vmIntrinsics::_invokeBasic:     return Bytecodes::_invokehandle;
 442     default:
 443       fatal(&quot;unexpected id: (%d) %s&quot;, (uint)id, vmIntrinsics::name_at(id));
 444       return Bytecodes::_illegal;
 445   }
 446 }
 447 
 448 int MethodHandles::signature_polymorphic_intrinsic_ref_kind(vmIntrinsics::ID iid) {
 449   switch (iid) {
 450   case vmIntrinsics::_invokeBasic:      return 0;
 451   case vmIntrinsics::_linkToVirtual:    return JVM_REF_invokeVirtual;
 452   case vmIntrinsics::_linkToStatic:     return JVM_REF_invokeStatic;
 453   case vmIntrinsics::_linkToSpecial:    return JVM_REF_invokeSpecial;
 454   case vmIntrinsics::_linkToInterface:  return JVM_REF_invokeInterface;
 455   default:
 456     fatal(&quot;unexpected intrinsic id: %d %s&quot;, iid, vmIntrinsics::name_at(iid));
 457     return 0;
 458   }
 459 }
 460 
 461 vmIntrinsics::ID MethodHandles::signature_polymorphic_name_id(Symbol* name) {
 462   vmSymbols::SID name_id = vmSymbols::find_sid(name);
 463   switch (name_id) {
 464   // The ID _invokeGeneric stands for all non-static signature-polymorphic methods, except built-ins.
 465   case vmSymbols::VM_SYMBOL_ENUM_NAME(invoke_name):           return vmIntrinsics::_invokeGeneric;
 466   // The only built-in non-static signature-polymorphic method is MethodHandle.invokeBasic:
 467   case vmSymbols::VM_SYMBOL_ENUM_NAME(invokeBasic_name):      return vmIntrinsics::_invokeBasic;
 468 
 469   // There is one static signature-polymorphic method for each JVM invocation mode.
 470   case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToVirtual_name):    return vmIntrinsics::_linkToVirtual;
 471   case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToStatic_name):     return vmIntrinsics::_linkToStatic;
 472   case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToSpecial_name):    return vmIntrinsics::_linkToSpecial;
 473   case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToInterface_name):  return vmIntrinsics::_linkToInterface;
 474   default:                                                    break;
 475   }
 476 
 477   // Cover the case of invokeExact and any future variants of invokeFoo.
 478   Klass* mh_klass = SystemDictionary::well_known_klass(
 479                               SystemDictionary::WK_KLASS_ENUM_NAME(MethodHandle_klass) );
 480   if (mh_klass != NULL &amp;&amp; is_method_handle_invoke_name(mh_klass, name)) {
 481     return vmIntrinsics::_invokeGeneric;
 482   }
 483 
 484   // Cover the case of methods on VarHandle.
 485   Klass* vh_klass = SystemDictionary::well_known_klass(
 486                               SystemDictionary::WK_KLASS_ENUM_NAME(VarHandle_klass) );
 487   if (vh_klass != NULL &amp;&amp; is_method_handle_invoke_name(vh_klass, name)) {
 488     return vmIntrinsics::_invokeGeneric;
 489   }
 490 
 491   // Note: The pseudo-intrinsic _compiledLambdaForm is never linked against.
 492   // Instead it is used to mark lambda forms bound to invokehandle or invokedynamic.
 493   return vmIntrinsics::_none;
 494 }
 495 
 496 vmIntrinsics::ID MethodHandles::signature_polymorphic_name_id(Klass* klass, Symbol* name) {
 497   if (klass != NULL &amp;&amp;
 498       (klass-&gt;name() == vmSymbols::java_lang_invoke_MethodHandle() ||
 499        klass-&gt;name() == vmSymbols::java_lang_invoke_VarHandle())) {
 500     vmIntrinsics::ID iid = signature_polymorphic_name_id(name);
 501     if (iid != vmIntrinsics::_none)
 502       return iid;
 503     if (is_method_handle_invoke_name(klass, name))
 504       return vmIntrinsics::_invokeGeneric;
 505   }
 506   return vmIntrinsics::_none;
 507 }
 508 
 509 // Returns true if method is signature polymorphic and public
 510 bool MethodHandles::is_signature_polymorphic_public_name(Klass* klass, Symbol* name) {
 511   if (is_signature_polymorphic_name(klass, name)) {
 512     InstanceKlass* iklass = InstanceKlass::cast(klass);
 513     int me;
 514     int ms = iklass-&gt;find_method_by_name(name, &amp;me);
 515     assert(ms != -1, &quot;&quot;);
 516     for (; ms &lt; me; ms++) {
 517       Method* m = iklass-&gt;methods()-&gt;at(ms);
 518       int required = JVM_ACC_NATIVE | JVM_ACC_VARARGS | JVM_ACC_PUBLIC;
 519       int flags = m-&gt;access_flags().as_int();
 520       if ((flags &amp; required) == required &amp;&amp; ArgumentCount(m-&gt;signature()).size() == 1) {
 521         return true;
 522       }
 523     }
 524   }
 525   return false;
 526 }
 527 
 528 // convert the external string or reflective type to an internal signature
 529 Symbol* MethodHandles::lookup_signature(oop type_str, bool intern_if_not_found, TRAPS) {
 530   if (java_lang_invoke_MethodType::is_instance(type_str)) {
 531     return java_lang_invoke_MethodType::as_signature(type_str, intern_if_not_found);
 532   } else if (java_lang_Class::is_instance(type_str)) {
 533     return java_lang_Class::as_signature(type_str, false);
 534   } else if (java_lang_String::is_instance_inlined(type_str)) {
 535     if (intern_if_not_found) {
 536       return java_lang_String::as_symbol(type_str);
 537     } else {
 538       return java_lang_String::as_symbol_or_null(type_str);
 539     }
 540   } else {
 541     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unrecognized type&quot;, NULL);
 542   }
 543 }
 544 
 545 static const char OBJ_SIG[] = &quot;Ljava/lang/Object;&quot;;
 546 enum { OBJ_SIG_LEN = 18 };
 547 
 548 bool MethodHandles::is_basic_type_signature(Symbol* sig) {
 549   assert(vmSymbols::object_signature()-&gt;utf8_length() == (int)OBJ_SIG_LEN, &quot;&quot;);
 550   assert(vmSymbols::object_signature()-&gt;equals(OBJ_SIG), &quot;&quot;);
 551   for (SignatureStream ss(sig, sig-&gt;starts_with(JVM_SIGNATURE_FUNC)); !ss.is_done(); ss.next()) {
 552     switch (ss.type()) {
 553     case T_OBJECT:
 554       // only java/lang/Object is valid here
 555       if (strncmp((char*) ss.raw_bytes(), OBJ_SIG, OBJ_SIG_LEN) != 0)
 556         return false;
 557       break;
 558     case T_VOID:
 559     case T_INT:
 560     case T_LONG:
 561     case T_FLOAT:
 562     case T_DOUBLE:
 563       break;
 564     default:
 565       // subword types (T_BYTE etc.), Q-descriptors, arrays
 566       return false;
 567     }
 568   }
 569   return true;
 570 }
 571 
 572 Symbol* MethodHandles::lookup_basic_type_signature(Symbol* sig, bool keep_last_arg, TRAPS) {
 573   Symbol* bsig = NULL;
 574   if (sig == NULL) {
 575     return sig;
 576   } else if (is_basic_type_signature(sig)) {
 577     sig-&gt;increment_refcount();
 578     return sig;  // that was easy
 579   } else if (!sig-&gt;starts_with(JVM_SIGNATURE_FUNC)) {
 580     BasicType bt = Signature::basic_type(sig);
 581     if (is_subword_type(bt)) {
 582       bsig = vmSymbols::int_signature();
 583     } else {
 584       assert(is_reference_type(bt), &quot;is_basic_type_signature was false&quot;);
 585       bsig = vmSymbols::object_signature();
 586     }
 587   } else {
 588     ResourceMark rm;
 589     stringStream buffer(128);
 590     buffer.put(JVM_SIGNATURE_FUNC);
 591     int arg_pos = 0, keep_arg_pos = -1;
 592     if (keep_last_arg)
 593       keep_arg_pos = ArgumentCount(sig).size() - 1;
 594     for (SignatureStream ss(sig); !ss.is_done(); ss.next()) {
 595       BasicType bt = ss.type();
 596       size_t this_arg_pos = buffer.size();
 597       if (ss.at_return_type()) {
 598         buffer.put(JVM_SIGNATURE_ENDFUNC);
 599       }
 600       if (arg_pos == keep_arg_pos) {
 601         buffer.write((char*) ss.raw_bytes(),
 602                      (int)   ss.raw_length());
 603       } else if (is_reference_type(bt)) {
 604         buffer.write(OBJ_SIG, OBJ_SIG_LEN);
 605       } else {
 606         if (is_subword_type(bt))
 607           bt = T_INT;
 608         buffer.put(type2char(bt));
 609       }
 610       arg_pos++;
 611     }
 612     const char* sigstr =       buffer.base();
 613     int         siglen = (int) buffer.size();
 614     bsig = SymbolTable::new_symbol(sigstr, siglen);
 615   }
 616   assert(is_basic_type_signature(bsig) ||
 617          // detune assert in case the injected argument is not a basic type:
 618          keep_last_arg, &quot;&quot;);
 619   return bsig;
 620 }
 621 
 622 void MethodHandles::print_as_basic_type_signature_on(outputStream* st,
 623                                                      Symbol* sig) {
 624   st = st ? st : tty;
 625   bool prev_type = false;
 626   bool is_method = (sig-&gt;char_at(0) == JVM_SIGNATURE_FUNC);
 627   if (is_method)  st-&gt;put(JVM_SIGNATURE_FUNC);
 628   for (SignatureStream ss(sig, is_method); !ss.is_done(); ss.next()) {
 629     if (ss.at_return_type())
 630       st-&gt;put(JVM_SIGNATURE_ENDFUNC);
 631     else if (prev_type)
 632       st-&gt;put(&#39;,&#39;);
 633     const char* cp = (const char*) ss.raw_bytes();
 634     if (ss.is_array()) {
 635       st-&gt;put(JVM_SIGNATURE_ARRAY);
 636       if (ss.array_prefix_length() == 1)
 637         st-&gt;put(cp[1]);
 638       else
 639         st-&gt;put(JVM_SIGNATURE_CLASS);
 640     } else {
 641       st-&gt;put(cp[0]);
 642     }
 643   }
 644 }
 645 
 646 
 647 
 648 static oop object_java_mirror() {
 649   return SystemDictionary::Object_klass()-&gt;java_mirror();
 650 }
 651 
 652 oop MethodHandles::field_name_or_null(Symbol* s) {
 653   if (s == NULL)  return NULL;
 654   return StringTable::lookup(s);
 655 }
 656 
 657 oop MethodHandles::field_signature_type_or_null(Symbol* s) {
 658   if (s == NULL)  return NULL;
 659   BasicType bt = Signature::basic_type(s);
 660   if (is_java_primitive(bt)) {
 661     assert(s-&gt;utf8_length() == 1, &quot;&quot;);
 662     return java_lang_Class::primitive_mirror(bt);
 663   }
 664   // Here are some more short cuts for common types.
 665   // They are optional, since reference types can be resolved lazily.
 666   if (bt == T_OBJECT) {
 667     if (s == vmSymbols::object_signature()) {
 668       return object_java_mirror();
 669     } else if (s == vmSymbols::class_signature()) {
 670       return SystemDictionary::Class_klass()-&gt;java_mirror();
 671     } else if (s == vmSymbols::string_signature()) {
 672       return SystemDictionary::String_klass()-&gt;java_mirror();
 673     }
 674   }
 675   return NULL;
 676 }
 677 
 678 
 679 // An unresolved member name is a mere symbolic reference.
 680 // Resolving it plants a vmtarget/vmindex in it,
 681 // which refers directly to JVM internals.
 682 Handle MethodHandles::resolve_MemberName(Handle mname, Klass* caller,
 683                                          bool speculative_resolve, TRAPS) {
 684   Handle empty;
 685   assert(java_lang_invoke_MemberName::is_instance(mname()), &quot;&quot;);
 686 
 687   if (java_lang_invoke_MemberName::vmtarget(mname()) != NULL) {
 688     // Already resolved.
 689     DEBUG_ONLY(int vmindex = java_lang_invoke_MemberName::vmindex(mname()));
 690     assert(vmindex &gt;= Method::nonvirtual_vtable_index, &quot;&quot;);
 691     return mname;
 692   }
 693 
 694   Handle defc_oop(THREAD, java_lang_invoke_MemberName::clazz(mname()));
 695   Handle name_str(THREAD, java_lang_invoke_MemberName::name( mname()));
 696   Handle type_str(THREAD, java_lang_invoke_MemberName::type( mname()));
 697   int    flags    =       java_lang_invoke_MemberName::flags(mname());
 698   int    ref_kind =       (flags &gt;&gt; REFERENCE_KIND_SHIFT) &amp; REFERENCE_KIND_MASK;
 699   if (!ref_kind_is_valid(ref_kind)) {
 700     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;obsolete MemberName format&quot;, empty);
 701   }
 702 
 703   DEBUG_ONLY(int old_vmindex);
 704   assert((old_vmindex = java_lang_invoke_MemberName::vmindex(mname())) == 0, &quot;clean input&quot;);
 705 
 706   if (defc_oop.is_null() || name_str.is_null() || type_str.is_null()) {
 707     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), &quot;nothing to resolve&quot;, empty);
 708   }
 709 
 710   InstanceKlass* defc = NULL;
 711   {
 712     Klass* defc_klass = java_lang_Class::as_Klass(defc_oop());
 713     if (defc_klass == NULL)  return empty;  // a primitive; no resolution possible
 714     if (!defc_klass-&gt;is_instance_klass()) {
 715       if (!defc_klass-&gt;is_array_klass())  return empty;
 716       defc_klass = SystemDictionary::Object_klass();
 717     }
 718     defc = InstanceKlass::cast(defc_klass);
 719   }
 720   if (defc == NULL) {
 721     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;primitive class&quot;, empty);
 722   }
 723   defc-&gt;link_class(CHECK_(empty));  // possible safepoint
 724 
 725   // convert the external string name to an internal symbol
 726   TempNewSymbol name = java_lang_String::as_symbol_or_null(name_str());
 727   if (name == NULL)  return empty;  // no such name
 728   if (name == vmSymbols::class_initializer_name())
 729     return empty; // illegal name
 730 
 731   vmIntrinsics::ID mh_invoke_id = vmIntrinsics::_none;
 732   if ((flags &amp; ALL_KINDS) == IS_METHOD &amp;&amp;
 733       (defc == SystemDictionary::MethodHandle_klass() || defc == SystemDictionary::VarHandle_klass()) &amp;&amp;
 734       (ref_kind == JVM_REF_invokeVirtual ||
 735        ref_kind == JVM_REF_invokeSpecial ||
 736        // static invocation mode is required for _linkToVirtual, etc.:
 737        ref_kind == JVM_REF_invokeStatic)) {
 738     vmIntrinsics::ID iid = signature_polymorphic_name_id(name);
 739     if (iid != vmIntrinsics::_none &amp;&amp;
 740         ((ref_kind == JVM_REF_invokeStatic) == is_signature_polymorphic_static(iid))) {
 741       // Virtual methods invoke and invokeExact, plus internal invokers like _invokeBasic.
 742       // For a static reference it could an internal linkage routine like _linkToVirtual, etc.
 743       mh_invoke_id = iid;
 744     }
 745   }
 746 
 747   // convert the external string or reflective type to an internal signature
 748   TempNewSymbol type = lookup_signature(type_str(), (mh_invoke_id != vmIntrinsics::_none), CHECK_(empty));
 749   if (type == NULL)  return empty;  // no such signature exists in the VM
 750 
 751   LinkInfo::AccessCheck access_check = caller != NULL ?
 752                                               LinkInfo::needs_access_check :
 753                                               LinkInfo::skip_access_check;
 754 
 755   // Time to do the lookup.
 756   switch (flags &amp; ALL_KINDS) {
 757   case IS_METHOD:
 758     {
 759       CallInfo result;
 760       LinkInfo link_info(defc, name, type, caller, access_check);
 761       {
 762         assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
 763         if (ref_kind == JVM_REF_invokeStatic) {
 764           LinkResolver::resolve_static_call(result,
 765                         link_info, false, THREAD);
 766         } else if (ref_kind == JVM_REF_invokeInterface) {
 767           LinkResolver::resolve_interface_call(result, Handle(), defc,
 768                         link_info, false, THREAD);
 769         } else if (mh_invoke_id != vmIntrinsics::_none) {
 770           assert(!is_signature_polymorphic_static(mh_invoke_id), &quot;&quot;);
 771           LinkResolver::resolve_handle_call(result, link_info, THREAD);
 772         } else if (ref_kind == JVM_REF_invokeSpecial) {
 773           LinkResolver::resolve_special_call(result, Handle(),
 774                         link_info, THREAD);
 775         } else if (ref_kind == JVM_REF_invokeVirtual) {
 776           LinkResolver::resolve_virtual_call(result, Handle(), defc,
 777                         link_info, false, THREAD);
 778         } else {
 779           assert(false, &quot;ref_kind=%d&quot;, ref_kind);
 780         }
 781         if (HAS_PENDING_EXCEPTION) {
 782           if (speculative_resolve) {
 783             CLEAR_PENDING_EXCEPTION;
 784           }
 785           return empty;
 786         }
 787       }
 788       if (result.resolved_appendix().not_null()) {
 789         // The resolved MemberName must not be accompanied by an appendix argument,
 790         // since there is no way to bind this value into the MemberName.
 791         // Caller is responsible to prevent this from happening.
 792         THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;appendix&quot;, empty);
 793       }
 794       result.set_resolved_method_name(CHECK_(empty));
 795       oop mname2 = init_method_MemberName(mname, result);
 796       return Handle(THREAD, mname2);
 797     }
<a name="7" id="anc7"></a><span class="line-modified"> 798   case IS_OBJECT_CONSTRUCTOR:</span>
 799     {
 800       CallInfo result;
 801       LinkInfo link_info(defc, name, type, caller, access_check);
 802       {
 803         assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
<a name="8" id="anc8"></a><span class="line-modified"> 804         if (name != vmSymbols::object_initializer_name()) {</span>
<span class="line-added"> 805           break;                // will throw after end of switch</span>
<span class="line-added"> 806         } else if (type-&gt;is_void_method_signature()) {</span>
 807           LinkResolver::resolve_special_call(result, Handle(), link_info, THREAD);
 808         } else {
<a name="9" id="anc9"></a><span class="line-modified"> 809           // LinkageError unless it returns something reasonable</span>
<span class="line-added"> 810           LinkResolver::resolve_static_call(result, link_info, false, THREAD);</span>
 811         }
 812         if (HAS_PENDING_EXCEPTION) {
 813           if (speculative_resolve) {
 814             CLEAR_PENDING_EXCEPTION;
 815           }
 816           return empty;
 817         }
 818       }
 819       assert(result.is_statically_bound(), &quot;&quot;);
 820       result.set_resolved_method_name(CHECK_(empty));
 821       oop mname2 = init_method_MemberName(mname, result);
 822       return Handle(THREAD, mname2);
 823     }
 824   case IS_FIELD:
 825     {
 826       fieldDescriptor result; // find_field initializes fd if found
 827       {
 828         assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
 829         LinkInfo link_info(defc, name, type, caller, LinkInfo::skip_access_check);
 830         LinkResolver::resolve_field(result, link_info, Bytecodes::_nop, false, THREAD);
 831         if (HAS_PENDING_EXCEPTION) {
 832           if (speculative_resolve) {
 833             CLEAR_PENDING_EXCEPTION;
 834           }
 835           return empty;
 836         }
 837       }
 838       oop mname2 = init_field_MemberName(mname, result, ref_kind_is_setter(ref_kind));
 839       return Handle(THREAD, mname2);
 840     }
 841   default:
 842     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unrecognized MemberName format&quot;, empty);
 843   }
 844 
 845   return empty;
 846 }
 847 
 848 // Conversely, a member name which is only initialized from JVM internals
 849 // may have null defc, name, and type fields.
 850 // Resolving it plants a vmtarget/vmindex in it,
 851 // which refers directly to JVM internals.
 852 void MethodHandles::expand_MemberName(Handle mname, int suppress, TRAPS) {
 853   assert(java_lang_invoke_MemberName::is_instance(mname()), &quot;&quot;);
 854 
 855   bool have_defc = (java_lang_invoke_MemberName::clazz(mname()) != NULL);
 856   bool have_name = (java_lang_invoke_MemberName::name(mname()) != NULL);
 857   bool have_type = (java_lang_invoke_MemberName::type(mname()) != NULL);
 858   int flags      = java_lang_invoke_MemberName::flags(mname());
 859 
 860   if (suppress != 0) {
 861     if (suppress &amp; _suppress_defc)  have_defc = true;
 862     if (suppress &amp; _suppress_name)  have_name = true;
 863     if (suppress &amp; _suppress_type)  have_type = true;
 864   }
 865 
 866   if (have_defc &amp;&amp; have_name &amp;&amp; have_type)  return;  // nothing needed
 867 
 868   switch (flags &amp; ALL_KINDS) {
 869   case IS_METHOD:
<a name="10" id="anc10"></a><span class="line-modified"> 870   case IS_OBJECT_CONSTRUCTOR:</span>
 871     {
 872       Method* vmtarget = java_lang_invoke_MemberName::vmtarget(mname());
 873       if (vmtarget == NULL) {
 874         THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;nothing to expand&quot;);
 875       }
 876       methodHandle m(THREAD, vmtarget);
 877       DEBUG_ONLY(vmtarget = NULL);  // safety
 878       if (!have_defc) {
 879         InstanceKlass* defc = m-&gt;method_holder();
 880         java_lang_invoke_MemberName::set_clazz(mname(), defc-&gt;java_mirror());
 881       }
 882       if (!have_name) {
 883         //not java_lang_String::create_from_symbol; let&#39;s intern member names
 884         oop name = StringTable::intern(m-&gt;name(), CHECK);
 885         java_lang_invoke_MemberName::set_name(mname(), name);
 886       }
 887       if (!have_type) {
 888         Handle type = java_lang_String::create_from_symbol(m-&gt;signature(), CHECK);
 889         java_lang_invoke_MemberName::set_type(mname(), type());
 890       }
 891       return;
 892     }
 893   case IS_FIELD:
 894     {
 895       oop clazz = java_lang_invoke_MemberName::clazz(mname());
 896       if (clazz == NULL) {
 897         THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;nothing to expand (as field)&quot;);
 898       }
 899       InstanceKlass* defc = InstanceKlass::cast(java_lang_Class::as_Klass(clazz));
 900       DEBUG_ONLY(clazz = NULL);  // safety
 901       int vmindex  = java_lang_invoke_MemberName::vmindex(mname());
 902       bool is_static = ((flags &amp; JVM_ACC_STATIC) != 0);
 903       fieldDescriptor fd; // find_field initializes fd if found
 904       if (!defc-&gt;find_field_from_offset(vmindex, is_static, &amp;fd))
 905         break;                  // cannot expand
 906       if (!have_name) {
 907         //not java_lang_String::create_from_symbol; let&#39;s intern member names
 908         oop name = StringTable::intern(fd.name(), CHECK);
 909         java_lang_invoke_MemberName::set_name(mname(), name);
 910       }
 911       if (!have_type) {
 912         // If it is a primitive field type, don&#39;t mess with short strings like &quot;I&quot;.
 913         Handle type (THREAD, field_signature_type_or_null(fd.signature()));
 914         if (type.is_null()) {
 915           type = java_lang_String::create_from_symbol(fd.signature(), CHECK);
 916         }
 917         java_lang_invoke_MemberName::set_type(mname(), type());
 918       }
 919       return;
 920     }
 921   }
 922   THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;unrecognized MemberName format&quot;);
 923 }
 924 
 925 int MethodHandles::find_MemberNames(Klass* k,
 926                                     Symbol* name, Symbol* sig,
 927                                     int mflags, Klass* caller,
 928                                     int skip, objArrayHandle results, TRAPS) {
 929   // %%% take caller into account!
 930 
 931   Thread* thread = Thread::current();
 932 
 933   if (k == NULL || !k-&gt;is_instance_klass())  return -1;
 934 
 935   int rfill = 0, rlimit = results-&gt;length(), rskip = skip;
 936   // overflow measurement:
 937   int overflow = 0, overflow_limit = MAX2(1000, rlimit);
 938 
 939   int match_flags = mflags;
 940   bool search_superc = ((match_flags &amp; SEARCH_SUPERCLASSES) != 0);
 941   bool search_intfc  = ((match_flags &amp; SEARCH_INTERFACES)   != 0);
 942   bool local_only = !(search_superc | search_intfc);
 943 
 944   if (name != NULL) {
 945     if (name-&gt;utf8_length() == 0)  return 0; // a match is not possible
 946   }
 947   if (sig != NULL) {
 948     if (sig-&gt;starts_with(JVM_SIGNATURE_FUNC))
 949       match_flags &amp;= ~(IS_FIELD | IS_TYPE);
 950     else
<a name="11" id="anc11"></a><span class="line-modified"> 951       match_flags &amp;= ~(IS_OBJECT_CONSTRUCTOR | IS_METHOD);</span>
 952   }
 953 
 954   if ((match_flags &amp; IS_TYPE) != 0) {
 955     // NYI, and Core Reflection works quite well for this query
 956   }
 957 
 958   if ((match_flags &amp; IS_FIELD) != 0) {
 959     InstanceKlass* ik = InstanceKlass::cast(k);
 960     for (FieldStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {
 961       if (name != NULL &amp;&amp; st.name() != name)
 962           continue;
 963       if (sig != NULL &amp;&amp; st.signature() != sig)
 964         continue;
 965       // passed the filters
 966       if (rskip &gt; 0) {
 967         --rskip;
 968       } else if (rfill &lt; rlimit) {
 969         Handle result(thread, results-&gt;obj_at(rfill++));
 970         if (!java_lang_invoke_MemberName::is_instance(result()))
 971           return -99;  // caller bug!
 972         oop saved = MethodHandles::init_field_MemberName(result, st.field_descriptor());
 973         if (saved != result())
 974           results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
 975       } else if (++overflow &gt;= overflow_limit) {
 976         match_flags = 0; break; // got tired of looking at overflow
 977       }
 978     }
 979   }
 980 
<a name="12" id="anc12"></a><span class="line-modified"> 981   if ((match_flags &amp; (IS_METHOD | IS_OBJECT_CONSTRUCTOR)) != 0) {</span>
 982     // watch out for these guys:
 983     Symbol* init_name   = vmSymbols::object_initializer_name();
 984     Symbol* clinit_name = vmSymbols::class_initializer_name();
 985     if (name == clinit_name)  clinit_name = NULL; // hack for exposing &lt;clinit&gt;
<a name="13" id="anc13"></a><span class="line-modified"> 986     bool ctor_ok = true, sfac_ok = true;</span>
<span class="line-modified"> 987     // fix name so that it captures the intention of IS_OBJECT_CONSTRUCTOR</span>
 988     if (!(match_flags &amp; IS_METHOD)) {
 989       // constructors only
 990       if (name == NULL) {
 991         name = init_name;
 992       } else if (name != init_name) {
 993         return 0;               // no constructors of this method name
 994       }
<a name="14" id="anc14"></a><span class="line-modified"> 995       sfac_ok = false;</span>
<span class="line-added"> 996     } else if (!(match_flags &amp; IS_OBJECT_CONSTRUCTOR)) {</span>
 997       // methods only
<a name="15" id="anc15"></a><span class="line-modified"> 998       ctor_ok = false;  // but sfac_ok is true, so we might find &lt;init&gt;</span>





 999     } else {
1000       // caller will accept either sort; no need to adjust name
1001     }
1002     InstanceKlass* ik = InstanceKlass::cast(k);
1003     for (MethodStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {
1004       Method* m = st.method();
1005       Symbol* m_name = m-&gt;name();
1006       if (m_name == clinit_name)
1007         continue;
<a name="16" id="anc16"></a><span class="line-modified">1008       if (name != NULL &amp;&amp; m_name != name)</span>
1009           continue;
1010       if (sig != NULL &amp;&amp; m-&gt;signature() != sig)
1011         continue;
<a name="17" id="anc17"></a><span class="line-added">1012       if (m_name == init_name) {  // might be either ctor or sfac</span>
<span class="line-added">1013         if (m-&gt;is_object_constructor()  &amp;&amp; !ctor_ok)  continue;</span>
<span class="line-added">1014         if (m-&gt;is_static_init_factory() &amp;&amp; !sfac_ok)  continue;</span>
<span class="line-added">1015       }</span>
1016       // passed the filters
1017       if (rskip &gt; 0) {
1018         --rskip;
1019       } else if (rfill &lt; rlimit) {
1020         Handle result(thread, results-&gt;obj_at(rfill++));
1021         if (!java_lang_invoke_MemberName::is_instance(result()))
1022           return -99;  // caller bug!
1023         CallInfo info(m, NULL, CHECK_0);
1024         oop saved = MethodHandles::init_method_MemberName(result, info);
1025         if (saved != result())
1026           results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
1027       } else if (++overflow &gt;= overflow_limit) {
1028         match_flags = 0; break; // got tired of looking at overflow
1029       }
1030     }
1031   }
1032 
1033   // return number of elements we at leasted wanted to initialize
1034   return rfill + overflow;
1035 }
1036 
1037 void MethodHandles::add_dependent_nmethod(oop call_site, nmethod* nm) {
1038   assert_locked_or_safepoint(CodeCache_lock);
1039 
1040   oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);
1041   DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1042   // Try to purge stale entries on updates.
1043   // Since GC doesn&#39;t clean dependency contexts rooted at CallSiteContext objects,
1044   // in order to avoid memory leak, stale entries are purged whenever a dependency list
1045   // is changed (both on addition and removal). Though memory reclamation is delayed,
1046   // it avoids indefinite memory usage growth.
1047   deps.add_dependent_nmethod(nm);
1048 }
1049 
1050 void MethodHandles::remove_dependent_nmethod(oop call_site, nmethod* nm) {
1051   assert_locked_or_safepoint(CodeCache_lock);
1052 
1053   oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);
1054   DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1055   deps.remove_dependent_nmethod(nm);
1056 }
1057 
1058 void MethodHandles::clean_dependency_context(oop call_site) {
1059   oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);
1060   DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1061   deps.clean_unloading_dependents();
1062 }
1063 
1064 void MethodHandles::flush_dependent_nmethods(Handle call_site, Handle target) {
1065   assert_lock_strong(Compile_lock);
1066 
1067   int marked = 0;
1068   CallSiteDepChange changes(call_site, target);
1069   {
1070     NoSafepointVerifier nsv;
1071     MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1072 
1073     oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());
1074     DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1075     marked = deps.mark_dependent_nmethods(changes);
1076   }
1077   if (marked &gt; 0) {
1078     // At least one nmethod has been marked for deoptimization.
1079     Deoptimization::deoptimize_all_marked();
1080   }
1081 }
1082 
1083 void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
1084   if (log_is_enabled(Info, methodhandles)) {
1085     const char* name = vmIntrinsics::name_at(iid);
1086     if (*name == &#39;_&#39;)  name += 1;
1087     const size_t len = strlen(name) + 50;
1088     char* qname = NEW_C_HEAP_ARRAY(char, len, mtInternal);
1089     const char* suffix = &quot;&quot;;
1090     if (is_signature_polymorphic(iid)) {
1091       if (is_signature_polymorphic_static(iid))
1092         suffix = &quot;/static&quot;;
1093       else
1094         suffix = &quot;/private&quot;;
1095     }
1096     jio_snprintf(qname, len, &quot;MethodHandle::interpreter_entry::%s%s&quot;, name, suffix);
1097     trace_method_handle(_masm, qname);
1098     // Note:  Don&#39;t free the allocated char array because it&#39;s used
1099     // during runtime.
1100   }
1101 }
1102 
1103 //
1104 // Here are the native methods in java.lang.invoke.MethodHandleNatives
1105 // They are the private interface between this JVM and the HotSpot-specific
1106 // Java code that implements JSR 292 method handles.
1107 //
1108 // Note:  We use a JVM_ENTRY macro to define each of these, for this is the way
1109 // that intrinsic (non-JNI) native methods are defined in HotSpot.
1110 //
1111 
1112 #ifndef PRODUCT
1113 #define EACH_NAMED_CON(template, requirement) \
1114     template(java_lang_invoke_MemberName,MN_IS_METHOD) \
<a name="18" id="anc18"></a><span class="line-modified">1115     template(java_lang_invoke_MemberName,MN_IS_OBJECT_CONSTRUCTOR) \</span>
1116     template(java_lang_invoke_MemberName,MN_IS_FIELD) \
1117     template(java_lang_invoke_MemberName,MN_IS_TYPE) \
1118     template(java_lang_invoke_MemberName,MN_CALLER_SENSITIVE) \
1119     template(java_lang_invoke_MemberName,MN_TRUSTED_FINAL) \
1120     template(java_lang_invoke_MemberName,MN_SEARCH_SUPERCLASSES) \
1121     template(java_lang_invoke_MemberName,MN_SEARCH_INTERFACES) \
1122     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_SHIFT) \
1123     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_MASK) \
1124     template(java_lang_invoke_MemberName,MN_NESTMATE_CLASS) \
1125     template(java_lang_invoke_MemberName,MN_HIDDEN_CLASS) \
1126     template(java_lang_invoke_MemberName,MN_STRONG_LOADER_LINK) \
1127     template(java_lang_invoke_MemberName,MN_ACCESS_VM_ANNOTATIONS) \
1128     /*end*/
1129 
1130 #define IGNORE_REQ(req_expr) /* req_expr */
1131 #define ONE_PLUS(scope,value) 1+
1132 static const int con_value_count = EACH_NAMED_CON(ONE_PLUS, IGNORE_REQ) 0;
1133 #define VALUE_COMMA(scope,value) scope::value,
1134 static const int con_values[con_value_count+1] = { EACH_NAMED_CON(VALUE_COMMA, IGNORE_REQ) 0 };
1135 #define STRING_NULL(scope,value) #value &quot;\0&quot;
1136 static const char con_names[] = { EACH_NAMED_CON(STRING_NULL, IGNORE_REQ) };
1137 
1138 static bool advertise_con_value(int which) {
1139   if (which &lt; 0)  return false;
1140   bool ok = true;
1141   int count = 0;
1142 #define INC_COUNT(scope,value) \
1143   ++count;
1144 #define CHECK_REQ(req_expr) \
1145   if (which &lt; count)  return ok; \
1146   ok = (req_expr);
1147   EACH_NAMED_CON(INC_COUNT, CHECK_REQ);
1148 #undef INC_COUNT
1149 #undef CHECK_REQ
1150   assert(count == con_value_count, &quot;&quot;);
1151   if (which &lt; count)  return ok;
1152   return false;
1153 }
1154 
1155 #undef ONE_PLUS
1156 #undef VALUE_COMMA
1157 #undef STRING_NULL
1158 #undef EACH_NAMED_CON
1159 #endif // PRODUCT
1160 
1161 JVM_ENTRY(jint, MHN_getNamedCon(JNIEnv *env, jobject igcls, jint which, jobjectArray box_jh)) {
1162 #ifndef PRODUCT
1163   if (advertise_con_value(which)) {
1164     assert(which &gt;= 0 &amp;&amp; which &lt; con_value_count, &quot;&quot;);
1165     int con = con_values[which];
1166     objArrayHandle box(THREAD, (objArrayOop) JNIHandles::resolve(box_jh));
1167     if (box.not_null() &amp;&amp; box-&gt;klass() == Universe::objectArrayKlassObj() &amp;&amp; box-&gt;length() &gt; 0) {
1168       const char* str = &amp;con_names[0];
1169       for (int i = 0; i &lt; which; i++)
1170         str += strlen(str) + 1;   // skip name and null
1171       oop name = java_lang_String::create_oop_from_str(str, CHECK_0);  // possible safepoint
1172       box-&gt;obj_at_put(0, name);
1173     }
1174     return con;
1175   }
1176 #endif
1177   return 0;
1178 }
1179 JVM_END
1180 
1181 // void init(MemberName self, AccessibleObject ref)
1182 JVM_ENTRY(void, MHN_init_Mem(JNIEnv *env, jobject igcls, jobject mname_jh, jobject target_jh)) {
1183   if (mname_jh == NULL) { THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;mname is null&quot;); }
1184   if (target_jh == NULL) { THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;target is null&quot;); }
1185   Handle mname(THREAD, JNIHandles::resolve_non_null(mname_jh));
1186   Handle target(THREAD, JNIHandles::resolve_non_null(target_jh));
1187   MethodHandles::init_MemberName(mname, target, CHECK);
1188 }
1189 JVM_END
1190 
1191 // void expand(MemberName self)
1192 JVM_ENTRY(void, MHN_expand_Mem(JNIEnv *env, jobject igcls, jobject mname_jh)) {
1193   if (mname_jh == NULL) { THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;mname is null&quot;); }
1194   Handle mname(THREAD, JNIHandles::resolve_non_null(mname_jh));
1195   MethodHandles::expand_MemberName(mname, 0, CHECK);
1196 }
1197 JVM_END
1198 
1199 // void resolve(MemberName self, Class&lt;?&gt; caller)
1200 JVM_ENTRY(jobject, MHN_resolve_Mem(JNIEnv *env, jobject igcls, jobject mname_jh, jclass caller_jh,
1201     jboolean speculative_resolve)) {
1202   if (mname_jh == NULL) { THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;mname is null&quot;); }
1203   Handle mname(THREAD, JNIHandles::resolve_non_null(mname_jh));
1204 
1205   // The trusted Java code that calls this method should already have performed
1206   // access checks on behalf of the given caller.  But, we can verify this.
1207   if (VerifyMethodHandles &amp;&amp; caller_jh != NULL &amp;&amp;
1208       java_lang_invoke_MemberName::clazz(mname()) != NULL) {
1209     Klass* reference_klass = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
1210     if (reference_klass != NULL &amp;&amp; reference_klass-&gt;is_objArray_klass()) {
1211       reference_klass = ObjArrayKlass::cast(reference_klass)-&gt;bottom_klass();
1212     }
1213 
1214     // Reflection::verify_class_access can only handle instance classes.
1215     if (reference_klass != NULL &amp;&amp; reference_klass-&gt;is_instance_klass()) {
1216       // Emulate LinkResolver::check_klass_accessability.
1217       Klass* caller = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(caller_jh));
1218       if (caller != SystemDictionary::Object_klass()
1219           &amp;&amp; Reflection::verify_class_access(caller,
1220                                              InstanceKlass::cast(reference_klass),
1221                                              true) != Reflection::ACCESS_OK) {
1222         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), reference_klass-&gt;external_name());
1223       }
1224     }
1225   }
1226 
1227   Klass* caller = caller_jh == NULL ? NULL :
1228                      java_lang_Class::as_Klass(JNIHandles::resolve_non_null(caller_jh));
1229   Handle resolved = MethodHandles::resolve_MemberName(mname, caller, speculative_resolve == JNI_TRUE,
1230                                                       CHECK_NULL);
1231 
1232   if (resolved.is_null()) {
1233     int flags = java_lang_invoke_MemberName::flags(mname());
1234     int ref_kind = (flags &gt;&gt; REFERENCE_KIND_SHIFT) &amp; REFERENCE_KIND_MASK;
1235     if (!MethodHandles::ref_kind_is_valid(ref_kind)) {
1236       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;obsolete MemberName format&quot;);
1237     }
1238     if (speculative_resolve) {
1239       assert(!HAS_PENDING_EXCEPTION, &quot;No exceptions expected when resolving speculatively&quot;);
1240       return NULL;
1241     }
1242     if ((flags &amp; ALL_KINDS) == IS_FIELD) {
1243       THROW_MSG_NULL(vmSymbols::java_lang_NoSuchFieldError(), &quot;field resolution failed&quot;);
1244     } else if ((flags &amp; ALL_KINDS) == IS_METHOD ||
<a name="19" id="anc19"></a><span class="line-modified">1245                (flags &amp; ALL_KINDS) == IS_OBJECT_CONSTRUCTOR) {</span>
1246       THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(), &quot;method resolution failed&quot;);
1247     } else {
1248       THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;resolution failed&quot;);
1249     }
1250   }
1251 
1252   return JNIHandles::make_local(THREAD, resolved());
1253 }
1254 JVM_END
1255 
1256 static jlong find_member_field_offset(oop mname, bool must_be_static, TRAPS) {
1257   if (mname == NULL ||
1258       java_lang_invoke_MemberName::clazz(mname) == NULL) {
1259     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;mname not resolved&quot;);
1260   } else {
1261     int flags = java_lang_invoke_MemberName::flags(mname);
1262     if ((flags &amp; IS_FIELD) != 0 &amp;&amp;
1263         (must_be_static
1264          ? (flags &amp; JVM_ACC_STATIC) != 0
1265          : (flags &amp; JVM_ACC_STATIC) == 0)) {
1266       int vmindex = java_lang_invoke_MemberName::vmindex(mname);
1267       return (jlong) vmindex;
1268     }
1269   }
1270   const char* msg = (must_be_static ? &quot;static field required&quot; : &quot;non-static field required&quot;);
1271   THROW_MSG_0(vmSymbols::java_lang_InternalError(), msg);
1272   return 0;
1273 }
1274 
1275 JVM_ENTRY(jlong, MHN_objectFieldOffset(JNIEnv *env, jobject igcls, jobject mname_jh)) {
1276   return find_member_field_offset(JNIHandles::resolve(mname_jh), false, THREAD);
1277 }
1278 JVM_END
1279 
1280 JVM_ENTRY(jlong, MHN_staticFieldOffset(JNIEnv *env, jobject igcls, jobject mname_jh)) {
1281   return find_member_field_offset(JNIHandles::resolve(mname_jh), true, THREAD);
1282 }
1283 JVM_END
1284 
1285 JVM_ENTRY(jobject, MHN_staticFieldBase(JNIEnv *env, jobject igcls, jobject mname_jh)) {
1286   // use the other function to perform sanity checks:
1287   jlong ignore = find_member_field_offset(JNIHandles::resolve(mname_jh), true, CHECK_NULL);
1288   oop clazz = java_lang_invoke_MemberName::clazz(JNIHandles::resolve_non_null(mname_jh));
1289   return JNIHandles::make_local(THREAD, clazz);
1290 }
1291 JVM_END
1292 
1293 JVM_ENTRY(jobject, MHN_getMemberVMInfo(JNIEnv *env, jobject igcls, jobject mname_jh)) {
1294   if (mname_jh == NULL)  return NULL;
1295   Handle mname(THREAD, JNIHandles::resolve_non_null(mname_jh));
1296   intptr_t vmindex  = java_lang_invoke_MemberName::vmindex(mname());
1297   objArrayHandle result = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 2, CHECK_NULL);
1298   jvalue vmindex_value; vmindex_value.j = (long)vmindex;
1299   oop x = java_lang_boxing_object::create(T_LONG, &amp;vmindex_value, CHECK_NULL);
1300   result-&gt;obj_at_put(0, x);
1301 
1302   int flags = java_lang_invoke_MemberName::flags(mname());
1303   if ((flags &amp; IS_FIELD) != 0) {
1304     x = java_lang_invoke_MemberName::clazz(mname());
1305   } else {
1306     Method* vmtarget = java_lang_invoke_MemberName::vmtarget(mname());
1307     assert(vmtarget != NULL &amp;&amp; vmtarget-&gt;is_method(), &quot;vmtarget is only method&quot;);
1308     x = mname();
1309   }
1310   result-&gt;obj_at_put(1, x);
1311   return JNIHandles::make_local(env, result());
1312 }
1313 JVM_END
1314 
1315 
1316 
1317 //  static native int getMembers(Class&lt;?&gt; defc, String matchName, String matchSig,
1318 //          int matchFlags, Class&lt;?&gt; caller, int skip, MemberName[] results);
1319 JVM_ENTRY(jint, MHN_getMembers(JNIEnv *env, jobject igcls,
1320                                jclass clazz_jh, jstring name_jh, jstring sig_jh,
1321                                int mflags, jclass caller_jh, jint skip, jobjectArray results_jh)) {
1322   if (clazz_jh == NULL || results_jh == NULL)  return -1;
1323   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz_jh));
1324 
1325   objArrayHandle results(THREAD, (objArrayOop) JNIHandles::resolve(results_jh));
1326   if (results.is_null() || !results-&gt;is_objArray())  return -1;
1327 
1328   TempNewSymbol name = NULL;
1329   TempNewSymbol sig = NULL;
1330   if (name_jh != NULL) {
1331     name = java_lang_String::as_symbol_or_null(JNIHandles::resolve_non_null(name_jh));
1332     if (name == NULL)  return 0; // a match is not possible
1333   }
1334   if (sig_jh != NULL) {
1335     sig = java_lang_String::as_symbol_or_null(JNIHandles::resolve_non_null(sig_jh));
1336     if (sig == NULL)  return 0; // a match is not possible
1337   }
1338 
1339   Klass* caller = NULL;
1340   if (caller_jh != NULL) {
1341     oop caller_oop = JNIHandles::resolve_non_null(caller_jh);
1342     if (!java_lang_Class::is_instance(caller_oop))  return -1;
1343     caller = java_lang_Class::as_Klass(caller_oop);
1344   }
1345 
1346   if (name != NULL &amp;&amp; sig != NULL &amp;&amp; results.not_null()) {
1347     // try a direct resolve
1348     // %%% TO DO
1349   }
1350 
1351   int res = MethodHandles::find_MemberNames(k, name, sig, mflags,
1352                                             caller, skip, results, CHECK_0);
1353   // TO DO: expand at least some of the MemberNames, to avoid massive callbacks
1354   return res;
1355 }
1356 JVM_END
1357 
1358 JVM_ENTRY(void, MHN_setCallSiteTargetNormal(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
1359   Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
1360   Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
1361   {
1362     // Walk all nmethods depending on this call site.
1363     MutexLocker mu(thread, Compile_lock);
1364     MethodHandles::flush_dependent_nmethods(call_site, target);
1365     java_lang_invoke_CallSite::set_target(call_site(), target());
1366   }
1367 }
1368 JVM_END
1369 
1370 JVM_ENTRY(void, MHN_setCallSiteTargetVolatile(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
1371   Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
1372   Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
1373   {
1374     // Walk all nmethods depending on this call site.
1375     MutexLocker mu(thread, Compile_lock);
1376     MethodHandles::flush_dependent_nmethods(call_site, target);
1377     java_lang_invoke_CallSite::set_target_volatile(call_site(), target());
1378   }
1379 }
1380 JVM_END
1381 
1382 JVM_ENTRY(void, MHN_copyOutBootstrapArguments(JNIEnv* env, jobject igcls,
1383                                               jobject caller_jh, jintArray index_info_jh,
1384                                               jint start, jint end,
1385                                               jobjectArray buf_jh, jint pos,
1386                                               jboolean resolve, jobject ifna_jh)) {
1387   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller_jh));
1388   if (caller_k == NULL || !caller_k-&gt;is_instance_klass()) {
1389       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;bad caller&quot;);
1390   }
1391   InstanceKlass* caller = InstanceKlass::cast(caller_k);
1392   typeArrayOop index_info_oop = (typeArrayOop) JNIHandles::resolve(index_info_jh);
1393   if (index_info_oop == NULL ||
1394       index_info_oop-&gt;klass() != Universe::intArrayKlassObj() ||
1395       typeArrayOop(index_info_oop)-&gt;length() &lt; 2) {
1396       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;bad index info (0)&quot;);
1397   }
1398   typeArrayHandle index_info(THREAD, index_info_oop);
1399   int bss_index_in_pool = index_info-&gt;int_at(1);
1400   // While we are here, take a quick look at the index info:
1401   if (bss_index_in_pool &lt;= 0 ||
1402       bss_index_in_pool &gt;= caller-&gt;constants()-&gt;length() ||
1403       index_info-&gt;int_at(0)
1404       != caller-&gt;constants()-&gt;bootstrap_argument_count_at(bss_index_in_pool)) {
1405       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;bad index info (1)&quot;);
1406   }
1407   objArrayHandle buf(THREAD, (objArrayOop) JNIHandles::resolve(buf_jh));
1408   if (start &lt; 0) {
1409     for (int pseudo_index = -4; pseudo_index &lt; 0; pseudo_index++) {
1410       if (start == pseudo_index) {
1411         if (start &gt;= end || 0 &gt; pos || pos &gt;= buf-&gt;length())  break;
1412         oop pseudo_arg = NULL;
1413         switch (pseudo_index) {
1414         case -4:  // bootstrap method
1415           {
1416             int bsm_index = caller-&gt;constants()-&gt;bootstrap_method_ref_index_at(bss_index_in_pool);
1417             pseudo_arg = caller-&gt;constants()-&gt;resolve_possibly_cached_constant_at(bsm_index, CHECK);
1418             break;
1419           }
1420         case -3:  // name
1421           {
1422             Symbol* name = caller-&gt;constants()-&gt;name_ref_at(bss_index_in_pool);
1423             Handle str = java_lang_String::create_from_symbol(name, CHECK);
1424             pseudo_arg = str();
1425             break;
1426           }
1427         case -2:  // type
1428           {
1429             Symbol* type = caller-&gt;constants()-&gt;signature_ref_at(bss_index_in_pool);
1430             Handle th;
1431             if (type-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {
1432               th = SystemDictionary::find_method_handle_type(type, caller, CHECK);
1433             } else {
1434               th = SystemDictionary::find_java_mirror_for_type(type, caller, SignatureStream::NCDFError, CHECK);
1435             }
1436             pseudo_arg = th();
1437             break;
1438           }
1439         case -1:  // argument count
1440           {
1441             int argc = caller-&gt;constants()-&gt;bootstrap_argument_count_at(bss_index_in_pool);
1442             jvalue argc_value; argc_value.i = (jint)argc;
1443             pseudo_arg = java_lang_boxing_object::create(T_INT, &amp;argc_value, CHECK);
1444             break;
1445           }
1446         }
1447 
1448         // Store the pseudo-argument, and advance the pointers.
1449         buf-&gt;obj_at_put(pos++, pseudo_arg);
1450         ++start;
1451       }
1452     }
1453     // When we are done with this there may be regular arguments to process too.
1454   }
1455   Handle ifna(THREAD, JNIHandles::resolve(ifna_jh));
1456   caller-&gt;constants()-&gt;
1457     copy_bootstrap_arguments_at(bss_index_in_pool,
1458                                 start, end, buf, pos,
1459                                 (resolve == JNI_TRUE), ifna, CHECK);
1460 }
1461 JVM_END
1462 
1463 // It is called by a Cleaner object which ensures that dropped CallSites properly
1464 // deallocate their dependency information.
1465 JVM_ENTRY(void, MHN_clearCallSiteContext(JNIEnv* env, jobject igcls, jobject context_jh)) {
1466   Handle context(THREAD, JNIHandles::resolve_non_null(context_jh));
1467   {
1468     // Walk all nmethods depending on this call site.
1469     MutexLocker mu1(thread, Compile_lock);
1470 
1471     int marked = 0;
1472     {
1473       NoSafepointVerifier nsv;
1474       MutexLocker mu2(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);
1475       DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());
1476       marked = deps.remove_all_dependents();
1477     }
1478     if (marked &gt; 0) {
1479       // At least one nmethod has been marked for deoptimization
1480       Deoptimization::deoptimize_all_marked();
1481     }
1482   }
1483 }
1484 JVM_END
1485 
1486 /**
1487  * Throws a java/lang/UnsupportedOperationException unconditionally.
1488  * This is required by the specification of MethodHandle.invoke if
1489  * invoked directly.
1490  */
1491 JVM_ENTRY(jobject, MH_invoke_UOE(JNIEnv* env, jobject mh, jobjectArray args)) {
1492   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;MethodHandle.invoke cannot be invoked reflectively&quot;);
1493   return NULL;
1494 }
1495 JVM_END
1496 
1497 /**
1498  * Throws a java/lang/UnsupportedOperationException unconditionally.
1499  * This is required by the specification of MethodHandle.invokeExact if
1500  * invoked directly.
1501  */
1502 JVM_ENTRY(jobject, MH_invokeExact_UOE(JNIEnv* env, jobject mh, jobjectArray args)) {
1503   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;MethodHandle.invokeExact cannot be invoked reflectively&quot;);
1504   return NULL;
1505 }
1506 JVM_END
1507 
1508 /// JVM_RegisterMethodHandleMethods
1509 
1510 #define LANG &quot;Ljava/lang/&quot;
1511 #define JLINV &quot;Ljava/lang/invoke/&quot;
1512 
1513 #define OBJ   LANG &quot;Object;&quot;
1514 #define CLS   LANG &quot;Class;&quot;
1515 #define STRG  LANG &quot;String;&quot;
1516 #define CS    JLINV &quot;CallSite;&quot;
1517 #define MT    JLINV &quot;MethodType;&quot;
1518 #define MH    JLINV &quot;MethodHandle;&quot;
1519 #define MEM   JLINV &quot;MemberName;&quot;
1520 #define CTX   JLINV &quot;MethodHandleNatives$CallSiteContext;&quot;
1521 
1522 #define CC (char*)  /*cast a literal from (const char*)*/
1523 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
1524 
1525 // These are the native methods on java.lang.invoke.MethodHandleNatives.
1526 static JNINativeMethod MHN_methods[] = {
1527   {CC &quot;init&quot;,                      CC &quot;(&quot; MEM &quot;&quot; OBJ &quot;)V&quot;,                   FN_PTR(MHN_init_Mem)},
1528   {CC &quot;expand&quot;,                    CC &quot;(&quot; MEM &quot;)V&quot;,                          FN_PTR(MHN_expand_Mem)},
1529   {CC &quot;resolve&quot;,                   CC &quot;(&quot; MEM &quot;&quot; CLS &quot;Z)&quot; MEM,               FN_PTR(MHN_resolve_Mem)},
1530   //  static native int getNamedCon(int which, Object[] name)
1531   {CC &quot;getNamedCon&quot;,               CC &quot;(I[&quot; OBJ &quot;)I&quot;,                        FN_PTR(MHN_getNamedCon)},
1532   //  static native int getMembers(Class&lt;?&gt; defc, String matchName, String matchSig,
1533   //          int matchFlags, Class&lt;?&gt; caller, int skip, MemberName[] results);
1534   {CC &quot;getMembers&quot;,                CC &quot;(&quot; CLS &quot;&quot; STRG &quot;&quot; STRG &quot;I&quot; CLS &quot;I[&quot; MEM &quot;)I&quot;, FN_PTR(MHN_getMembers)},
1535   {CC &quot;objectFieldOffset&quot;,         CC &quot;(&quot; MEM &quot;)J&quot;,                          FN_PTR(MHN_objectFieldOffset)},
1536   {CC &quot;setCallSiteTargetNormal&quot;,   CC &quot;(&quot; CS &quot;&quot; MH &quot;)V&quot;,                     FN_PTR(MHN_setCallSiteTargetNormal)},
1537   {CC &quot;setCallSiteTargetVolatile&quot;, CC &quot;(&quot; CS &quot;&quot; MH &quot;)V&quot;,                     FN_PTR(MHN_setCallSiteTargetVolatile)},
1538   {CC &quot;copyOutBootstrapArguments&quot;, CC &quot;(&quot; CLS &quot;[III[&quot; OBJ &quot;IZ&quot; OBJ &quot;)V&quot;,     FN_PTR(MHN_copyOutBootstrapArguments)},
1539   {CC &quot;clearCallSiteContext&quot;,      CC &quot;(&quot; CTX &quot;)V&quot;,                          FN_PTR(MHN_clearCallSiteContext)},
1540   {CC &quot;staticFieldOffset&quot;,         CC &quot;(&quot; MEM &quot;)J&quot;,                          FN_PTR(MHN_staticFieldOffset)},
1541   {CC &quot;staticFieldBase&quot;,           CC &quot;(&quot; MEM &quot;)&quot; OBJ,                        FN_PTR(MHN_staticFieldBase)},
1542   {CC &quot;getMemberVMInfo&quot;,           CC &quot;(&quot; MEM &quot;)&quot; OBJ,                       FN_PTR(MHN_getMemberVMInfo)}
1543 };
1544 
1545 static JNINativeMethod MH_methods[] = {
1546   // UnsupportedOperationException throwers
1547   {CC &quot;invoke&quot;,                    CC &quot;([&quot; OBJ &quot;)&quot; OBJ,                       FN_PTR(MH_invoke_UOE)},
1548   {CC &quot;invokeExact&quot;,               CC &quot;([&quot; OBJ &quot;)&quot; OBJ,                       FN_PTR(MH_invokeExact_UOE)}
1549 };
1550 
1551 /**
1552  * This one function is exported, used by NativeLookup.
1553  */
1554 JVM_ENTRY(void, JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass MHN_class)) {
1555   assert(!MethodHandles::enabled(), &quot;must not be enabled&quot;);
1556   assert(SystemDictionary::MethodHandle_klass() != NULL, &quot;should be present&quot;);
1557 
1558   oop mirror = SystemDictionary::MethodHandle_klass()-&gt;java_mirror();
1559   jclass MH_class = (jclass) JNIHandles::make_local(env, mirror);
1560 
1561   {
1562     ThreadToNativeFromVM ttnfv(thread);
1563 
1564     int status = env-&gt;RegisterNatives(MHN_class, MHN_methods, sizeof(MHN_methods)/sizeof(JNINativeMethod));
1565     guarantee(status == JNI_OK &amp;&amp; !env-&gt;ExceptionOccurred(),
1566               &quot;register java.lang.invoke.MethodHandleNative natives&quot;);
1567 
1568     status = env-&gt;RegisterNatives(MH_class, MH_methods, sizeof(MH_methods)/sizeof(JNINativeMethod));
1569     guarantee(status == JNI_OK &amp;&amp; !env-&gt;ExceptionOccurred(),
1570               &quot;register java.lang.invoke.MethodHandle natives&quot;);
1571   }
1572 
1573   log_debug(methodhandles, indy)(&quot;MethodHandle support loaded (using LambdaForms)&quot;);
1574 
1575   MethodHandles::set_enabled(true);
1576 }
1577 JVM_END
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>