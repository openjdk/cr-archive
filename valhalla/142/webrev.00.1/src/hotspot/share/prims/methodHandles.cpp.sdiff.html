<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/methodHandles.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnvBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="whitebox.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/methodHandles.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 104     StubCodeMark mark(this, &quot;MethodHandle::interpreter_entry&quot;, vmIntrinsics::name_at(iid));
 105     address entry = MethodHandles::generate_method_handle_interpreter_entry(_masm, iid);
 106     if (entry != NULL) {
 107       Interpreter::set_entry_for_kind(mk, entry);
 108     }
 109     // If the entry is not set, it will throw AbstractMethodError.
 110   }
 111 }
 112 
 113 void MethodHandles::set_enabled(bool z) {
 114   if (_enabled != z) {
 115     guarantee(z, &quot;can only enable once&quot;);
 116     _enabled = z;
 117   }
 118 }
 119 
 120 // MemberName support
 121 
 122 // import java_lang_invoke_MemberName.*
 123 enum {
<span class="line-modified"> 124   IS_METHOD            = java_lang_invoke_MemberName::MN_IS_METHOD,</span>
<span class="line-modified"> 125   IS_CONSTRUCTOR       = java_lang_invoke_MemberName::MN_IS_CONSTRUCTOR,</span>
<span class="line-modified"> 126   IS_FIELD             = java_lang_invoke_MemberName::MN_IS_FIELD,</span>
<span class="line-modified"> 127   IS_TYPE              = java_lang_invoke_MemberName::MN_IS_TYPE,</span>
<span class="line-modified"> 128   CALLER_SENSITIVE     = java_lang_invoke_MemberName::MN_CALLER_SENSITIVE,</span>
 129   TRUSTED_FINAL        = java_lang_invoke_MemberName::MN_TRUSTED_FINAL,
<span class="line-modified"> 130   REFERENCE_KIND_SHIFT = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,</span>
<span class="line-modified"> 131   REFERENCE_KIND_MASK  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,</span>
<span class="line-modified"> 132   SEARCH_SUPERCLASSES  = java_lang_invoke_MemberName::MN_SEARCH_SUPERCLASSES,</span>
<span class="line-modified"> 133   SEARCH_INTERFACES    = java_lang_invoke_MemberName::MN_SEARCH_INTERFACES,</span>
<span class="line-modified"> 134   ALL_KINDS      = IS_METHOD | IS_CONSTRUCTOR | IS_FIELD | IS_TYPE</span>
 135 };
 136 
 137 int MethodHandles::ref_kind_to_flags(int ref_kind) {
 138   assert(ref_kind_is_valid(ref_kind), &quot;%d&quot;, ref_kind);
 139   int flags = (ref_kind &lt;&lt; REFERENCE_KIND_SHIFT);
 140   if (ref_kind_is_field(ref_kind)) {
 141     flags |= IS_FIELD;
 142   } else if (ref_kind_is_method(ref_kind)) {
 143     flags |= IS_METHOD;
 144   } else if (ref_kind == JVM_REF_newInvokeSpecial) {
<span class="line-modified"> 145     flags |= IS_CONSTRUCTOR;</span>
 146   }
 147   return flags;
 148 }
 149 
 150 Handle MethodHandles::resolve_MemberName_type(Handle mname, Klass* caller, TRAPS) {
 151   Handle empty;
 152   Handle type(THREAD, java_lang_invoke_MemberName::type(mname()));
 153   if (!java_lang_String::is_instance_inlined(type())) {
 154     return type; // already resolved
 155   }
 156   Symbol* signature = java_lang_String::as_symbol_or_null(type());
 157   if (signature == NULL) {
 158     return empty;  // no such signature exists in the VM
 159   }
 160   Handle resolved;
 161   int flags = java_lang_invoke_MemberName::flags(mname());
 162   switch (flags &amp; ALL_KINDS) {
 163     case IS_METHOD:
<span class="line-modified"> 164     case IS_CONSTRUCTOR:</span>
 165       resolved = SystemDictionary::find_method_handle_type(signature, caller, CHECK_(empty));
 166       break;
 167     case IS_FIELD:
 168       resolved = SystemDictionary::find_field_handle_type(signature, caller, CHECK_(empty));
 169       break;
 170     default:
 171       THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unrecognized MemberName format&quot;, empty);
 172   }
 173   if (resolved.is_null()) {
 174     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad MemberName type&quot;, empty);
 175   }
 176   return resolved;
 177 }
 178 
 179 oop MethodHandles::init_MemberName(Handle mname, Handle target, TRAPS) {
 180   // This method is used from java.lang.invoke.MemberName constructors.
 181   // It fills in the new MemberName from a java.lang.reflect.Member.
 182   Thread* thread = Thread::current();
 183   oop target_oop = target();
 184   Klass* target_klass = target_oop-&gt;klass();
</pre>
<hr />
<pre>
 287       m_klass = m_klass_non_interface;
 288     }
 289     if (lt_indy.is_enabled()) {
 290       ResourceMark rm;
 291       LogStream ls(lt_indy);
 292       ls.print_cr(&quot;memberName: invokevirtual method_holder::method: %s, receiver: %s, vtableindex: %d, access_flags:&quot;,
 293                   Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),
 294                   m_klass-&gt;internal_name(), vmindex);
 295        m-&gt;access_flags().print_on(&amp;ls);
 296        if (m-&gt;is_default_method()) {
 297          ls.print(&quot;default&quot;);
 298        }
 299        ls.cr();
 300     }
 301     break;
 302 
 303   case CallInfo::direct_call:
 304     vmindex = Method::nonvirtual_vtable_index;
 305     if (m-&gt;is_static()) {
 306       flags |= IS_METHOD      | (JVM_REF_invokeStatic  &lt;&lt; REFERENCE_KIND_SHIFT);
<span class="line-modified"> 307     } else if (m-&gt;is_initializer()) {</span>
<span class="line-modified"> 308       flags |= IS_CONSTRUCTOR | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);</span>
 309     } else {
 310       // &quot;special&quot; reflects that this is a direct call, not that it
 311       // necessarily originates from an invokespecial. We can also do
 312       // direct calls for private and/or final non-static methods.
 313       flags |= IS_METHOD      | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 314     }
 315     break;
 316 
 317   default:  assert(false, &quot;bad CallInfo&quot;);  return NULL;
 318   }
 319 
 320   // @CallerSensitive annotation detected
 321   if (m-&gt;caller_sensitive()) {
 322     flags |= CALLER_SENSITIVE;
 323   }
 324 
 325   Handle resolved_method = info.resolved_method_name();
 326   assert(java_lang_invoke_ResolvedMethodName::vmtarget(resolved_method()) == m() || m-&gt;is_old(),
 327          &quot;Should not change after link resolution&quot;);
 328 
 329   oop mname_oop = mname();
 330   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 331   java_lang_invoke_MemberName::set_method (mname_oop, resolved_method());
 332   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);   // vtable/itable index
 333   java_lang_invoke_MemberName::set_clazz  (mname_oop, m_klass-&gt;java_mirror());
 334   // Note:  name and type can be lazily computed by resolve_MemberName,
 335   // if Java code needs them as resolved String and MethodType objects.
 336   // If relevant, the vtable or itable value is stored as vmindex.
 337   // This is done eagerly, since it is readily available without
 338   // constructing any new objects.
 339   return mname();
 340 }
 341 
 342 oop MethodHandles::init_field_MemberName(Handle mname, fieldDescriptor&amp; fd, bool is_setter) {
 343   InstanceKlass* ik = fd.field_holder();
 344   int flags = (jushort)( fd.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS );
 345   flags |= IS_FIELD | ((fd.is_static() ? JVM_REF_getStatic : JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);



 346   if (fd.is_trusted_final()) flags |= TRUSTED_FINAL;
 347   if (is_setter)  flags += ((JVM_REF_putField - JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
 348   int vmindex        = fd.offset();  // determines the field uniquely when combined with static bit
 349 
 350   oop mname_oop = mname();
 351   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 352   java_lang_invoke_MemberName::set_method (mname_oop, NULL);
 353   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);
 354   java_lang_invoke_MemberName::set_clazz  (mname_oop, ik-&gt;java_mirror());
 355 
 356   oop type = field_signature_type_or_null(fd.signature());
 357   oop name = field_name_or_null(fd.name());
 358   if (name != NULL)
 359     java_lang_invoke_MemberName::set_name(mname_oop,   name);
 360   if (type != NULL)
 361     java_lang_invoke_MemberName::set_type(mname_oop,   type);
 362   // Note:  name and type can be lazily computed by resolve_MemberName,
 363   // if Java code needs them as resolved String and Class objects.
 364   // Note that the incoming type oop might be pre-resolved (non-null).
 365   // The base clazz and field offset (vmindex) must be eagerly stored,
</pre>
<hr />
<pre>
 775         } else {
 776           assert(false, &quot;ref_kind=%d&quot;, ref_kind);
 777         }
 778         if (HAS_PENDING_EXCEPTION) {
 779           if (speculative_resolve) {
 780             CLEAR_PENDING_EXCEPTION;
 781           }
 782           return empty;
 783         }
 784       }
 785       if (result.resolved_appendix().not_null()) {
 786         // The resolved MemberName must not be accompanied by an appendix argument,
 787         // since there is no way to bind this value into the MemberName.
 788         // Caller is responsible to prevent this from happening.
 789         THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;appendix&quot;, empty);
 790       }
 791       result.set_resolved_method_name(CHECK_(empty));
 792       oop mname2 = init_method_MemberName(mname, result);
 793       return Handle(THREAD, mname2);
 794     }
<span class="line-modified"> 795   case IS_CONSTRUCTOR:</span>
 796     {
 797       CallInfo result;
 798       LinkInfo link_info(defc, name, type, caller, access_check);
 799       {
 800         assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
<span class="line-modified"> 801         if (name == vmSymbols::object_initializer_name()) {</span>


 802           LinkResolver::resolve_special_call(result, Handle(), link_info, THREAD);
 803         } else {
<span class="line-modified"> 804           break;                // will throw after end of switch</span>

 805         }
 806         if (HAS_PENDING_EXCEPTION) {
 807           if (speculative_resolve) {
 808             CLEAR_PENDING_EXCEPTION;
 809           }
 810           return empty;
 811         }
 812       }
 813       assert(result.is_statically_bound(), &quot;&quot;);
 814       result.set_resolved_method_name(CHECK_(empty));
 815       oop mname2 = init_method_MemberName(mname, result);
 816       return Handle(THREAD, mname2);
 817     }
 818   case IS_FIELD:
 819     {
 820       fieldDescriptor result; // find_field initializes fd if found
 821       {
 822         assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
 823         LinkInfo link_info(defc, name, type, caller, LinkInfo::skip_access_check);
 824         LinkResolver::resolve_field(result, link_info, Bytecodes::_nop, false, THREAD);
</pre>
<hr />
<pre>
 844 // Resolving it plants a vmtarget/vmindex in it,
 845 // which refers directly to JVM internals.
 846 void MethodHandles::expand_MemberName(Handle mname, int suppress, TRAPS) {
 847   assert(java_lang_invoke_MemberName::is_instance(mname()), &quot;&quot;);
 848 
 849   bool have_defc = (java_lang_invoke_MemberName::clazz(mname()) != NULL);
 850   bool have_name = (java_lang_invoke_MemberName::name(mname()) != NULL);
 851   bool have_type = (java_lang_invoke_MemberName::type(mname()) != NULL);
 852   int flags      = java_lang_invoke_MemberName::flags(mname());
 853 
 854   if (suppress != 0) {
 855     if (suppress &amp; _suppress_defc)  have_defc = true;
 856     if (suppress &amp; _suppress_name)  have_name = true;
 857     if (suppress &amp; _suppress_type)  have_type = true;
 858   }
 859 
 860   if (have_defc &amp;&amp; have_name &amp;&amp; have_type)  return;  // nothing needed
 861 
 862   switch (flags &amp; ALL_KINDS) {
 863   case IS_METHOD:
<span class="line-modified"> 864   case IS_CONSTRUCTOR:</span>
 865     {
 866       Method* vmtarget = java_lang_invoke_MemberName::vmtarget(mname());
 867       if (vmtarget == NULL) {
 868         THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;nothing to expand&quot;);
 869       }
 870       methodHandle m(THREAD, vmtarget);
 871       DEBUG_ONLY(vmtarget = NULL);  // safety
 872       if (!have_defc) {
 873         InstanceKlass* defc = m-&gt;method_holder();
 874         java_lang_invoke_MemberName::set_clazz(mname(), defc-&gt;java_mirror());
 875       }
 876       if (!have_name) {
 877         //not java_lang_String::create_from_symbol; let&#39;s intern member names
 878         oop name = StringTable::intern(m-&gt;name(), CHECK);
 879         java_lang_invoke_MemberName::set_name(mname(), name);
 880       }
 881       if (!have_type) {
 882         Handle type = java_lang_String::create_from_symbol(m-&gt;signature(), CHECK);
 883         java_lang_invoke_MemberName::set_type(mname(), type());
 884       }
</pre>
<hr />
<pre>
 925   Thread* thread = Thread::current();
 926 
 927   if (k == NULL || !k-&gt;is_instance_klass())  return -1;
 928 
 929   int rfill = 0, rlimit = results-&gt;length(), rskip = skip;
 930   // overflow measurement:
 931   int overflow = 0, overflow_limit = MAX2(1000, rlimit);
 932 
 933   int match_flags = mflags;
 934   bool search_superc = ((match_flags &amp; SEARCH_SUPERCLASSES) != 0);
 935   bool search_intfc  = ((match_flags &amp; SEARCH_INTERFACES)   != 0);
 936   bool local_only = !(search_superc | search_intfc);
 937 
 938   if (name != NULL) {
 939     if (name-&gt;utf8_length() == 0)  return 0; // a match is not possible
 940   }
 941   if (sig != NULL) {
 942     if (sig-&gt;starts_with(JVM_SIGNATURE_FUNC))
 943       match_flags &amp;= ~(IS_FIELD | IS_TYPE);
 944     else
<span class="line-modified"> 945       match_flags &amp;= ~(IS_CONSTRUCTOR | IS_METHOD);</span>
 946   }
 947 
 948   if ((match_flags &amp; IS_TYPE) != 0) {
 949     // NYI, and Core Reflection works quite well for this query
 950   }
 951 
 952   if ((match_flags &amp; IS_FIELD) != 0) {
 953     InstanceKlass* ik = InstanceKlass::cast(k);
 954     for (FieldStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {
 955       if (name != NULL &amp;&amp; st.name() != name)
 956           continue;
 957       if (sig != NULL &amp;&amp; st.signature() != sig)
 958         continue;
 959       // passed the filters
 960       if (rskip &gt; 0) {
 961         --rskip;
 962       } else if (rfill &lt; rlimit) {
 963         Handle result(thread, results-&gt;obj_at(rfill++));
 964         if (!java_lang_invoke_MemberName::is_instance(result()))
 965           return -99;  // caller bug!
 966         oop saved = MethodHandles::init_field_MemberName(result, st.field_descriptor());
 967         if (saved != result())
 968           results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
 969       } else if (++overflow &gt;= overflow_limit) {
 970         match_flags = 0; break; // got tired of looking at overflow
 971       }
 972     }
 973   }
 974 
<span class="line-modified"> 975   if ((match_flags &amp; (IS_METHOD | IS_CONSTRUCTOR)) != 0) {</span>
 976     // watch out for these guys:
 977     Symbol* init_name   = vmSymbols::object_initializer_name();
 978     Symbol* clinit_name = vmSymbols::class_initializer_name();
 979     if (name == clinit_name)  clinit_name = NULL; // hack for exposing &lt;clinit&gt;
<span class="line-modified"> 980     bool negate_name_test = false;</span>
<span class="line-modified"> 981     // fix name so that it captures the intention of IS_CONSTRUCTOR</span>
 982     if (!(match_flags &amp; IS_METHOD)) {
 983       // constructors only
 984       if (name == NULL) {
 985         name = init_name;
 986       } else if (name != init_name) {
 987         return 0;               // no constructors of this method name
 988       }
<span class="line-modified"> 989     } else if (!(match_flags &amp; IS_CONSTRUCTOR)) {</span>

 990       // methods only
<span class="line-modified"> 991       if (name == NULL) {</span>
<span class="line-removed"> 992         name = init_name;</span>
<span class="line-removed"> 993         negate_name_test = true; // if we see the name, we *omit* the entry</span>
<span class="line-removed"> 994       } else if (name == init_name) {</span>
<span class="line-removed"> 995         return 0;               // no methods of this constructor name</span>
<span class="line-removed"> 996       }</span>
 997     } else {
 998       // caller will accept either sort; no need to adjust name
 999     }
1000     InstanceKlass* ik = InstanceKlass::cast(k);
1001     for (MethodStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {
1002       Method* m = st.method();
1003       Symbol* m_name = m-&gt;name();
1004       if (m_name == clinit_name)
1005         continue;
<span class="line-modified">1006       if (name != NULL &amp;&amp; ((m_name != name) ^ negate_name_test))</span>
1007           continue;
1008       if (sig != NULL &amp;&amp; m-&gt;signature() != sig)
1009         continue;




1010       // passed the filters
1011       if (rskip &gt; 0) {
1012         --rskip;
1013       } else if (rfill &lt; rlimit) {
1014         Handle result(thread, results-&gt;obj_at(rfill++));
1015         if (!java_lang_invoke_MemberName::is_instance(result()))
1016           return -99;  // caller bug!
1017         CallInfo info(m, NULL, CHECK_0);
1018         oop saved = MethodHandles::init_method_MemberName(result, info);
1019         if (saved != result())
1020           results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
1021       } else if (++overflow &gt;= overflow_limit) {
1022         match_flags = 0; break; // got tired of looking at overflow
1023       }
1024     }
1025   }
1026 
1027   // return number of elements we at leasted wanted to initialize
1028   return rfill + overflow;
1029 }
</pre>
<hr />
<pre>
1089     }
1090     jio_snprintf(qname, len, &quot;MethodHandle::interpreter_entry::%s%s&quot;, name, suffix);
1091     trace_method_handle(_masm, qname);
1092     // Note:  Don&#39;t free the allocated char array because it&#39;s used
1093     // during runtime.
1094   }
1095 }
1096 
1097 //
1098 // Here are the native methods in java.lang.invoke.MethodHandleNatives
1099 // They are the private interface between this JVM and the HotSpot-specific
1100 // Java code that implements JSR 292 method handles.
1101 //
1102 // Note:  We use a JVM_ENTRY macro to define each of these, for this is the way
1103 // that intrinsic (non-JNI) native methods are defined in HotSpot.
1104 //
1105 
1106 #ifndef PRODUCT
1107 #define EACH_NAMED_CON(template, requirement) \
1108     template(java_lang_invoke_MemberName,MN_IS_METHOD) \
<span class="line-modified">1109     template(java_lang_invoke_MemberName,MN_IS_CONSTRUCTOR) \</span>
1110     template(java_lang_invoke_MemberName,MN_IS_FIELD) \
1111     template(java_lang_invoke_MemberName,MN_IS_TYPE) \
1112     template(java_lang_invoke_MemberName,MN_CALLER_SENSITIVE) \
1113     template(java_lang_invoke_MemberName,MN_TRUSTED_FINAL) \
1114     template(java_lang_invoke_MemberName,MN_SEARCH_SUPERCLASSES) \
1115     template(java_lang_invoke_MemberName,MN_SEARCH_INTERFACES) \
1116     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_SHIFT) \
1117     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_MASK) \
1118     template(java_lang_invoke_MemberName,MN_NESTMATE_CLASS) \
1119     template(java_lang_invoke_MemberName,MN_HIDDEN_CLASS) \
1120     template(java_lang_invoke_MemberName,MN_STRONG_LOADER_LINK) \
1121     template(java_lang_invoke_MemberName,MN_ACCESS_VM_ANNOTATIONS) \
1122     /*end*/
1123 
1124 #define IGNORE_REQ(req_expr) /* req_expr */
1125 #define ONE_PLUS(scope,value) 1+
1126 static const int con_value_count = EACH_NAMED_CON(ONE_PLUS, IGNORE_REQ) 0;
1127 #define VALUE_COMMA(scope,value) scope::value,
1128 static const int con_values[con_value_count+1] = { EACH_NAMED_CON(VALUE_COMMA, IGNORE_REQ) 0 };
1129 #define STRING_NULL(scope,value) #value &quot;\0&quot;
</pre>
<hr />
<pre>
1219   }
1220 
1221   Klass* caller = caller_jh == NULL ? NULL :
1222                      java_lang_Class::as_Klass(JNIHandles::resolve_non_null(caller_jh));
1223   Handle resolved = MethodHandles::resolve_MemberName(mname, caller, speculative_resolve == JNI_TRUE,
1224                                                       CHECK_NULL);
1225 
1226   if (resolved.is_null()) {
1227     int flags = java_lang_invoke_MemberName::flags(mname());
1228     int ref_kind = (flags &gt;&gt; REFERENCE_KIND_SHIFT) &amp; REFERENCE_KIND_MASK;
1229     if (!MethodHandles::ref_kind_is_valid(ref_kind)) {
1230       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;obsolete MemberName format&quot;);
1231     }
1232     if (speculative_resolve) {
1233       assert(!HAS_PENDING_EXCEPTION, &quot;No exceptions expected when resolving speculatively&quot;);
1234       return NULL;
1235     }
1236     if ((flags &amp; ALL_KINDS) == IS_FIELD) {
1237       THROW_MSG_NULL(vmSymbols::java_lang_NoSuchFieldError(), &quot;field resolution failed&quot;);
1238     } else if ((flags &amp; ALL_KINDS) == IS_METHOD ||
<span class="line-modified">1239                (flags &amp; ALL_KINDS) == IS_CONSTRUCTOR) {</span>
1240       THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(), &quot;method resolution failed&quot;);
1241     } else {
1242       THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;resolution failed&quot;);
1243     }
1244   }
1245 
1246   return JNIHandles::make_local(THREAD, resolved());
1247 }
1248 JVM_END
1249 
1250 static jlong find_member_field_offset(oop mname, bool must_be_static, TRAPS) {
1251   if (mname == NULL ||
1252       java_lang_invoke_MemberName::clazz(mname) == NULL) {
1253     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;mname not resolved&quot;);
1254   } else {
1255     int flags = java_lang_invoke_MemberName::flags(mname);
1256     if ((flags &amp; IS_FIELD) != 0 &amp;&amp;
1257         (must_be_static
1258          ? (flags &amp; JVM_ACC_STATIC) != 0
1259          : (flags &amp; JVM_ACC_STATIC) == 0)) {
</pre>
</td>
<td>
<hr />
<pre>
 104     StubCodeMark mark(this, &quot;MethodHandle::interpreter_entry&quot;, vmIntrinsics::name_at(iid));
 105     address entry = MethodHandles::generate_method_handle_interpreter_entry(_masm, iid);
 106     if (entry != NULL) {
 107       Interpreter::set_entry_for_kind(mk, entry);
 108     }
 109     // If the entry is not set, it will throw AbstractMethodError.
 110   }
 111 }
 112 
 113 void MethodHandles::set_enabled(bool z) {
 114   if (_enabled != z) {
 115     guarantee(z, &quot;can only enable once&quot;);
 116     _enabled = z;
 117   }
 118 }
 119 
 120 // MemberName support
 121 
 122 // import java_lang_invoke_MemberName.*
 123 enum {
<span class="line-modified"> 124   IS_METHOD             = java_lang_invoke_MemberName::MN_IS_METHOD,</span>
<span class="line-modified"> 125   IS_OBJECT_CONSTRUCTOR = java_lang_invoke_MemberName::MN_IS_OBJECT_CONSTRUCTOR,</span>
<span class="line-modified"> 126   IS_FIELD              = java_lang_invoke_MemberName::MN_IS_FIELD,</span>
<span class="line-modified"> 127   IS_TYPE               = java_lang_invoke_MemberName::MN_IS_TYPE,</span>
<span class="line-modified"> 128   CALLER_SENSITIVE      = java_lang_invoke_MemberName::MN_CALLER_SENSITIVE,</span>
 129   TRUSTED_FINAL        = java_lang_invoke_MemberName::MN_TRUSTED_FINAL,
<span class="line-modified"> 130   REFERENCE_KIND_SHIFT  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,</span>
<span class="line-modified"> 131   REFERENCE_KIND_MASK   = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,</span>
<span class="line-modified"> 132   SEARCH_SUPERCLASSES   = java_lang_invoke_MemberName::MN_SEARCH_SUPERCLASSES,</span>
<span class="line-modified"> 133   SEARCH_INTERFACES     = java_lang_invoke_MemberName::MN_SEARCH_INTERFACES,</span>
<span class="line-modified"> 134   ALL_KINDS      = IS_METHOD | IS_OBJECT_CONSTRUCTOR | IS_FIELD | IS_TYPE</span>
 135 };
 136 
 137 int MethodHandles::ref_kind_to_flags(int ref_kind) {
 138   assert(ref_kind_is_valid(ref_kind), &quot;%d&quot;, ref_kind);
 139   int flags = (ref_kind &lt;&lt; REFERENCE_KIND_SHIFT);
 140   if (ref_kind_is_field(ref_kind)) {
 141     flags |= IS_FIELD;
 142   } else if (ref_kind_is_method(ref_kind)) {
 143     flags |= IS_METHOD;
 144   } else if (ref_kind == JVM_REF_newInvokeSpecial) {
<span class="line-modified"> 145     flags |= IS_OBJECT_CONSTRUCTOR;</span>
 146   }
 147   return flags;
 148 }
 149 
 150 Handle MethodHandles::resolve_MemberName_type(Handle mname, Klass* caller, TRAPS) {
 151   Handle empty;
 152   Handle type(THREAD, java_lang_invoke_MemberName::type(mname()));
 153   if (!java_lang_String::is_instance_inlined(type())) {
 154     return type; // already resolved
 155   }
 156   Symbol* signature = java_lang_String::as_symbol_or_null(type());
 157   if (signature == NULL) {
 158     return empty;  // no such signature exists in the VM
 159   }
 160   Handle resolved;
 161   int flags = java_lang_invoke_MemberName::flags(mname());
 162   switch (flags &amp; ALL_KINDS) {
 163     case IS_METHOD:
<span class="line-modified"> 164     case IS_OBJECT_CONSTRUCTOR:</span>
 165       resolved = SystemDictionary::find_method_handle_type(signature, caller, CHECK_(empty));
 166       break;
 167     case IS_FIELD:
 168       resolved = SystemDictionary::find_field_handle_type(signature, caller, CHECK_(empty));
 169       break;
 170     default:
 171       THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unrecognized MemberName format&quot;, empty);
 172   }
 173   if (resolved.is_null()) {
 174     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad MemberName type&quot;, empty);
 175   }
 176   return resolved;
 177 }
 178 
 179 oop MethodHandles::init_MemberName(Handle mname, Handle target, TRAPS) {
 180   // This method is used from java.lang.invoke.MemberName constructors.
 181   // It fills in the new MemberName from a java.lang.reflect.Member.
 182   Thread* thread = Thread::current();
 183   oop target_oop = target();
 184   Klass* target_klass = target_oop-&gt;klass();
</pre>
<hr />
<pre>
 287       m_klass = m_klass_non_interface;
 288     }
 289     if (lt_indy.is_enabled()) {
 290       ResourceMark rm;
 291       LogStream ls(lt_indy);
 292       ls.print_cr(&quot;memberName: invokevirtual method_holder::method: %s, receiver: %s, vtableindex: %d, access_flags:&quot;,
 293                   Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),
 294                   m_klass-&gt;internal_name(), vmindex);
 295        m-&gt;access_flags().print_on(&amp;ls);
 296        if (m-&gt;is_default_method()) {
 297          ls.print(&quot;default&quot;);
 298        }
 299        ls.cr();
 300     }
 301     break;
 302 
 303   case CallInfo::direct_call:
 304     vmindex = Method::nonvirtual_vtable_index;
 305     if (m-&gt;is_static()) {
 306       flags |= IS_METHOD      | (JVM_REF_invokeStatic  &lt;&lt; REFERENCE_KIND_SHIFT);
<span class="line-modified"> 307     } else if (m-&gt;is_object_constructor()) {</span>
<span class="line-modified"> 308       flags |= IS_OBJECT_CONSTRUCTOR | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);</span>
 309     } else {
 310       // &quot;special&quot; reflects that this is a direct call, not that it
 311       // necessarily originates from an invokespecial. We can also do
 312       // direct calls for private and/or final non-static methods.
 313       flags |= IS_METHOD      | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 314     }
 315     break;
 316 
 317   default:  assert(false, &quot;bad CallInfo&quot;);  return NULL;
 318   }
 319 
 320   // @CallerSensitive annotation detected
 321   if (m-&gt;caller_sensitive()) {
 322     flags |= CALLER_SENSITIVE;
 323   }
 324 
 325   Handle resolved_method = info.resolved_method_name();
 326   assert(java_lang_invoke_ResolvedMethodName::vmtarget(resolved_method()) == m() || m-&gt;is_old(),
 327          &quot;Should not change after link resolution&quot;);
 328 
 329   oop mname_oop = mname();
 330   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 331   java_lang_invoke_MemberName::set_method (mname_oop, resolved_method());
 332   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);   // vtable/itable index
 333   java_lang_invoke_MemberName::set_clazz  (mname_oop, m_klass-&gt;java_mirror());
 334   // Note:  name and type can be lazily computed by resolve_MemberName,
 335   // if Java code needs them as resolved String and MethodType objects.
 336   // If relevant, the vtable or itable value is stored as vmindex.
 337   // This is done eagerly, since it is readily available without
 338   // constructing any new objects.
 339   return mname();
 340 }
 341 
 342 oop MethodHandles::init_field_MemberName(Handle mname, fieldDescriptor&amp; fd, bool is_setter) {
 343   InstanceKlass* ik = fd.field_holder();
 344   int flags = (jushort)( fd.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS );
 345   flags |= IS_FIELD | ((fd.is_static() ? JVM_REF_getStatic : JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
<span class="line-added"> 346   if (fd.is_inlined()) {</span>
<span class="line-added"> 347     flags |= JVM_ACC_FIELD_INLINED;</span>
<span class="line-added"> 348   }</span>
 349   if (fd.is_trusted_final()) flags |= TRUSTED_FINAL;
 350   if (is_setter)  flags += ((JVM_REF_putField - JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
 351   int vmindex        = fd.offset();  // determines the field uniquely when combined with static bit
 352 
 353   oop mname_oop = mname();
 354   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 355   java_lang_invoke_MemberName::set_method (mname_oop, NULL);
 356   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);
 357   java_lang_invoke_MemberName::set_clazz  (mname_oop, ik-&gt;java_mirror());
 358 
 359   oop type = field_signature_type_or_null(fd.signature());
 360   oop name = field_name_or_null(fd.name());
 361   if (name != NULL)
 362     java_lang_invoke_MemberName::set_name(mname_oop,   name);
 363   if (type != NULL)
 364     java_lang_invoke_MemberName::set_type(mname_oop,   type);
 365   // Note:  name and type can be lazily computed by resolve_MemberName,
 366   // if Java code needs them as resolved String and Class objects.
 367   // Note that the incoming type oop might be pre-resolved (non-null).
 368   // The base clazz and field offset (vmindex) must be eagerly stored,
</pre>
<hr />
<pre>
 778         } else {
 779           assert(false, &quot;ref_kind=%d&quot;, ref_kind);
 780         }
 781         if (HAS_PENDING_EXCEPTION) {
 782           if (speculative_resolve) {
 783             CLEAR_PENDING_EXCEPTION;
 784           }
 785           return empty;
 786         }
 787       }
 788       if (result.resolved_appendix().not_null()) {
 789         // The resolved MemberName must not be accompanied by an appendix argument,
 790         // since there is no way to bind this value into the MemberName.
 791         // Caller is responsible to prevent this from happening.
 792         THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;appendix&quot;, empty);
 793       }
 794       result.set_resolved_method_name(CHECK_(empty));
 795       oop mname2 = init_method_MemberName(mname, result);
 796       return Handle(THREAD, mname2);
 797     }
<span class="line-modified"> 798   case IS_OBJECT_CONSTRUCTOR:</span>
 799     {
 800       CallInfo result;
 801       LinkInfo link_info(defc, name, type, caller, access_check);
 802       {
 803         assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
<span class="line-modified"> 804         if (name != vmSymbols::object_initializer_name()) {</span>
<span class="line-added"> 805           break;                // will throw after end of switch</span>
<span class="line-added"> 806         } else if (type-&gt;is_void_method_signature()) {</span>
 807           LinkResolver::resolve_special_call(result, Handle(), link_info, THREAD);
 808         } else {
<span class="line-modified"> 809           // LinkageError unless it returns something reasonable</span>
<span class="line-added"> 810           LinkResolver::resolve_static_call(result, link_info, false, THREAD);</span>
 811         }
 812         if (HAS_PENDING_EXCEPTION) {
 813           if (speculative_resolve) {
 814             CLEAR_PENDING_EXCEPTION;
 815           }
 816           return empty;
 817         }
 818       }
 819       assert(result.is_statically_bound(), &quot;&quot;);
 820       result.set_resolved_method_name(CHECK_(empty));
 821       oop mname2 = init_method_MemberName(mname, result);
 822       return Handle(THREAD, mname2);
 823     }
 824   case IS_FIELD:
 825     {
 826       fieldDescriptor result; // find_field initializes fd if found
 827       {
 828         assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
 829         LinkInfo link_info(defc, name, type, caller, LinkInfo::skip_access_check);
 830         LinkResolver::resolve_field(result, link_info, Bytecodes::_nop, false, THREAD);
</pre>
<hr />
<pre>
 850 // Resolving it plants a vmtarget/vmindex in it,
 851 // which refers directly to JVM internals.
 852 void MethodHandles::expand_MemberName(Handle mname, int suppress, TRAPS) {
 853   assert(java_lang_invoke_MemberName::is_instance(mname()), &quot;&quot;);
 854 
 855   bool have_defc = (java_lang_invoke_MemberName::clazz(mname()) != NULL);
 856   bool have_name = (java_lang_invoke_MemberName::name(mname()) != NULL);
 857   bool have_type = (java_lang_invoke_MemberName::type(mname()) != NULL);
 858   int flags      = java_lang_invoke_MemberName::flags(mname());
 859 
 860   if (suppress != 0) {
 861     if (suppress &amp; _suppress_defc)  have_defc = true;
 862     if (suppress &amp; _suppress_name)  have_name = true;
 863     if (suppress &amp; _suppress_type)  have_type = true;
 864   }
 865 
 866   if (have_defc &amp;&amp; have_name &amp;&amp; have_type)  return;  // nothing needed
 867 
 868   switch (flags &amp; ALL_KINDS) {
 869   case IS_METHOD:
<span class="line-modified"> 870   case IS_OBJECT_CONSTRUCTOR:</span>
 871     {
 872       Method* vmtarget = java_lang_invoke_MemberName::vmtarget(mname());
 873       if (vmtarget == NULL) {
 874         THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;nothing to expand&quot;);
 875       }
 876       methodHandle m(THREAD, vmtarget);
 877       DEBUG_ONLY(vmtarget = NULL);  // safety
 878       if (!have_defc) {
 879         InstanceKlass* defc = m-&gt;method_holder();
 880         java_lang_invoke_MemberName::set_clazz(mname(), defc-&gt;java_mirror());
 881       }
 882       if (!have_name) {
 883         //not java_lang_String::create_from_symbol; let&#39;s intern member names
 884         oop name = StringTable::intern(m-&gt;name(), CHECK);
 885         java_lang_invoke_MemberName::set_name(mname(), name);
 886       }
 887       if (!have_type) {
 888         Handle type = java_lang_String::create_from_symbol(m-&gt;signature(), CHECK);
 889         java_lang_invoke_MemberName::set_type(mname(), type());
 890       }
</pre>
<hr />
<pre>
 931   Thread* thread = Thread::current();
 932 
 933   if (k == NULL || !k-&gt;is_instance_klass())  return -1;
 934 
 935   int rfill = 0, rlimit = results-&gt;length(), rskip = skip;
 936   // overflow measurement:
 937   int overflow = 0, overflow_limit = MAX2(1000, rlimit);
 938 
 939   int match_flags = mflags;
 940   bool search_superc = ((match_flags &amp; SEARCH_SUPERCLASSES) != 0);
 941   bool search_intfc  = ((match_flags &amp; SEARCH_INTERFACES)   != 0);
 942   bool local_only = !(search_superc | search_intfc);
 943 
 944   if (name != NULL) {
 945     if (name-&gt;utf8_length() == 0)  return 0; // a match is not possible
 946   }
 947   if (sig != NULL) {
 948     if (sig-&gt;starts_with(JVM_SIGNATURE_FUNC))
 949       match_flags &amp;= ~(IS_FIELD | IS_TYPE);
 950     else
<span class="line-modified"> 951       match_flags &amp;= ~(IS_OBJECT_CONSTRUCTOR | IS_METHOD);</span>
 952   }
 953 
 954   if ((match_flags &amp; IS_TYPE) != 0) {
 955     // NYI, and Core Reflection works quite well for this query
 956   }
 957 
 958   if ((match_flags &amp; IS_FIELD) != 0) {
 959     InstanceKlass* ik = InstanceKlass::cast(k);
 960     for (FieldStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {
 961       if (name != NULL &amp;&amp; st.name() != name)
 962           continue;
 963       if (sig != NULL &amp;&amp; st.signature() != sig)
 964         continue;
 965       // passed the filters
 966       if (rskip &gt; 0) {
 967         --rskip;
 968       } else if (rfill &lt; rlimit) {
 969         Handle result(thread, results-&gt;obj_at(rfill++));
 970         if (!java_lang_invoke_MemberName::is_instance(result()))
 971           return -99;  // caller bug!
 972         oop saved = MethodHandles::init_field_MemberName(result, st.field_descriptor());
 973         if (saved != result())
 974           results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
 975       } else if (++overflow &gt;= overflow_limit) {
 976         match_flags = 0; break; // got tired of looking at overflow
 977       }
 978     }
 979   }
 980 
<span class="line-modified"> 981   if ((match_flags &amp; (IS_METHOD | IS_OBJECT_CONSTRUCTOR)) != 0) {</span>
 982     // watch out for these guys:
 983     Symbol* init_name   = vmSymbols::object_initializer_name();
 984     Symbol* clinit_name = vmSymbols::class_initializer_name();
 985     if (name == clinit_name)  clinit_name = NULL; // hack for exposing &lt;clinit&gt;
<span class="line-modified"> 986     bool ctor_ok = true, sfac_ok = true;</span>
<span class="line-modified"> 987     // fix name so that it captures the intention of IS_OBJECT_CONSTRUCTOR</span>
 988     if (!(match_flags &amp; IS_METHOD)) {
 989       // constructors only
 990       if (name == NULL) {
 991         name = init_name;
 992       } else if (name != init_name) {
 993         return 0;               // no constructors of this method name
 994       }
<span class="line-modified"> 995       sfac_ok = false;</span>
<span class="line-added"> 996     } else if (!(match_flags &amp; IS_OBJECT_CONSTRUCTOR)) {</span>
 997       // methods only
<span class="line-modified"> 998       ctor_ok = false;  // but sfac_ok is true, so we might find &lt;init&gt;</span>





 999     } else {
1000       // caller will accept either sort; no need to adjust name
1001     }
1002     InstanceKlass* ik = InstanceKlass::cast(k);
1003     for (MethodStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {
1004       Method* m = st.method();
1005       Symbol* m_name = m-&gt;name();
1006       if (m_name == clinit_name)
1007         continue;
<span class="line-modified">1008       if (name != NULL &amp;&amp; m_name != name)</span>
1009           continue;
1010       if (sig != NULL &amp;&amp; m-&gt;signature() != sig)
1011         continue;
<span class="line-added">1012       if (m_name == init_name) {  // might be either ctor or sfac</span>
<span class="line-added">1013         if (m-&gt;is_object_constructor()  &amp;&amp; !ctor_ok)  continue;</span>
<span class="line-added">1014         if (m-&gt;is_static_init_factory() &amp;&amp; !sfac_ok)  continue;</span>
<span class="line-added">1015       }</span>
1016       // passed the filters
1017       if (rskip &gt; 0) {
1018         --rskip;
1019       } else if (rfill &lt; rlimit) {
1020         Handle result(thread, results-&gt;obj_at(rfill++));
1021         if (!java_lang_invoke_MemberName::is_instance(result()))
1022           return -99;  // caller bug!
1023         CallInfo info(m, NULL, CHECK_0);
1024         oop saved = MethodHandles::init_method_MemberName(result, info);
1025         if (saved != result())
1026           results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
1027       } else if (++overflow &gt;= overflow_limit) {
1028         match_flags = 0; break; // got tired of looking at overflow
1029       }
1030     }
1031   }
1032 
1033   // return number of elements we at leasted wanted to initialize
1034   return rfill + overflow;
1035 }
</pre>
<hr />
<pre>
1095     }
1096     jio_snprintf(qname, len, &quot;MethodHandle::interpreter_entry::%s%s&quot;, name, suffix);
1097     trace_method_handle(_masm, qname);
1098     // Note:  Don&#39;t free the allocated char array because it&#39;s used
1099     // during runtime.
1100   }
1101 }
1102 
1103 //
1104 // Here are the native methods in java.lang.invoke.MethodHandleNatives
1105 // They are the private interface between this JVM and the HotSpot-specific
1106 // Java code that implements JSR 292 method handles.
1107 //
1108 // Note:  We use a JVM_ENTRY macro to define each of these, for this is the way
1109 // that intrinsic (non-JNI) native methods are defined in HotSpot.
1110 //
1111 
1112 #ifndef PRODUCT
1113 #define EACH_NAMED_CON(template, requirement) \
1114     template(java_lang_invoke_MemberName,MN_IS_METHOD) \
<span class="line-modified">1115     template(java_lang_invoke_MemberName,MN_IS_OBJECT_CONSTRUCTOR) \</span>
1116     template(java_lang_invoke_MemberName,MN_IS_FIELD) \
1117     template(java_lang_invoke_MemberName,MN_IS_TYPE) \
1118     template(java_lang_invoke_MemberName,MN_CALLER_SENSITIVE) \
1119     template(java_lang_invoke_MemberName,MN_TRUSTED_FINAL) \
1120     template(java_lang_invoke_MemberName,MN_SEARCH_SUPERCLASSES) \
1121     template(java_lang_invoke_MemberName,MN_SEARCH_INTERFACES) \
1122     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_SHIFT) \
1123     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_MASK) \
1124     template(java_lang_invoke_MemberName,MN_NESTMATE_CLASS) \
1125     template(java_lang_invoke_MemberName,MN_HIDDEN_CLASS) \
1126     template(java_lang_invoke_MemberName,MN_STRONG_LOADER_LINK) \
1127     template(java_lang_invoke_MemberName,MN_ACCESS_VM_ANNOTATIONS) \
1128     /*end*/
1129 
1130 #define IGNORE_REQ(req_expr) /* req_expr */
1131 #define ONE_PLUS(scope,value) 1+
1132 static const int con_value_count = EACH_NAMED_CON(ONE_PLUS, IGNORE_REQ) 0;
1133 #define VALUE_COMMA(scope,value) scope::value,
1134 static const int con_values[con_value_count+1] = { EACH_NAMED_CON(VALUE_COMMA, IGNORE_REQ) 0 };
1135 #define STRING_NULL(scope,value) #value &quot;\0&quot;
</pre>
<hr />
<pre>
1225   }
1226 
1227   Klass* caller = caller_jh == NULL ? NULL :
1228                      java_lang_Class::as_Klass(JNIHandles::resolve_non_null(caller_jh));
1229   Handle resolved = MethodHandles::resolve_MemberName(mname, caller, speculative_resolve == JNI_TRUE,
1230                                                       CHECK_NULL);
1231 
1232   if (resolved.is_null()) {
1233     int flags = java_lang_invoke_MemberName::flags(mname());
1234     int ref_kind = (flags &gt;&gt; REFERENCE_KIND_SHIFT) &amp; REFERENCE_KIND_MASK;
1235     if (!MethodHandles::ref_kind_is_valid(ref_kind)) {
1236       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;obsolete MemberName format&quot;);
1237     }
1238     if (speculative_resolve) {
1239       assert(!HAS_PENDING_EXCEPTION, &quot;No exceptions expected when resolving speculatively&quot;);
1240       return NULL;
1241     }
1242     if ((flags &amp; ALL_KINDS) == IS_FIELD) {
1243       THROW_MSG_NULL(vmSymbols::java_lang_NoSuchFieldError(), &quot;field resolution failed&quot;);
1244     } else if ((flags &amp; ALL_KINDS) == IS_METHOD ||
<span class="line-modified">1245                (flags &amp; ALL_KINDS) == IS_OBJECT_CONSTRUCTOR) {</span>
1246       THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(), &quot;method resolution failed&quot;);
1247     } else {
1248       THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;resolution failed&quot;);
1249     }
1250   }
1251 
1252   return JNIHandles::make_local(THREAD, resolved());
1253 }
1254 JVM_END
1255 
1256 static jlong find_member_field_offset(oop mname, bool must_be_static, TRAPS) {
1257   if (mname == NULL ||
1258       java_lang_invoke_MemberName::clazz(mname) == NULL) {
1259     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;mname not resolved&quot;);
1260   } else {
1261     int flags = java_lang_invoke_MemberName::flags(mname);
1262     if ((flags &amp; IS_FIELD) != 0 &amp;&amp;
1263         (must_be_static
1264          ? (flags &amp; JVM_ACC_STATIC) != 0
1265          : (flags &amp; JVM_ACC_STATIC) == 0)) {
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiEnvBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="whitebox.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>