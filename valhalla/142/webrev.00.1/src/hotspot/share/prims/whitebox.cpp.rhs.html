<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  30 #include &quot;classfile/javaClasses.inline.hpp&quot;
  31 #include &quot;classfile/modules.hpp&quot;
  32 #include &quot;classfile/protectionDomainCache.hpp&quot;
  33 #include &quot;classfile/stringTable.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;code/codeCache.hpp&quot;
  36 #include &quot;compiler/compilationPolicy.hpp&quot;
  37 #include &quot;compiler/methodMatcher.hpp&quot;
  38 #include &quot;compiler/directivesParser.hpp&quot;
  39 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;
  40 #include &quot;gc/shared/gcConfig.hpp&quot;
  41 #include &quot;gc/shared/genArguments.hpp&quot;
  42 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  43 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  44 #include &quot;memory/filemap.hpp&quot;
  45 #include &quot;memory/heapShared.inline.hpp&quot;
  46 #include &quot;memory/metaspaceShared.hpp&quot;
  47 #include &quot;memory/metadataFactory.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified">  48 #include &quot;memory/iterator.inline.hpp&quot;</span>
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;memory/oopFactory.hpp&quot;
  52 #include &quot;oops/array.hpp&quot;
  53 #include &quot;oops/compressedOops.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  54 #include &quot;oops/compressedOops.inline.hpp&quot;</span>
  55 #include &quot;oops/constantPool.inline.hpp&quot;
  56 #include &quot;oops/method.inline.hpp&quot;
  57 #include &quot;oops/objArrayKlass.hpp&quot;
  58 #include &quot;oops/objArrayOop.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added">  60 #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
  61 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  62 #include &quot;prims/resolvedMethodTable.hpp&quot;
  63 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  64 #include &quot;prims/whitebox.inline.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/atomic.hpp&quot;
  67 #include &quot;runtime/deoptimization.hpp&quot;
  68 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  69 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  70 #include &quot;runtime/frame.inline.hpp&quot;
  71 #include &quot;runtime/handles.inline.hpp&quot;
  72 #include &quot;runtime/handshake.hpp&quot;
  73 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  74 #include &quot;runtime/javaCalls.hpp&quot;
  75 #include &quot;runtime/jniHandles.inline.hpp&quot;
  76 #include &quot;runtime/os.hpp&quot;
  77 #include &quot;runtime/sweeper.hpp&quot;
  78 #include &quot;runtime/synchronizer.hpp&quot;
  79 #include &quot;runtime/thread.hpp&quot;
  80 #include &quot;runtime/threadSMR.hpp&quot;
  81 #include &quot;runtime/vm_version.hpp&quot;
  82 #include &quot;services/memoryService.hpp&quot;
  83 #include &quot;utilities/align.hpp&quot;
  84 #include &quot;utilities/debug.hpp&quot;
  85 #include &quot;utilities/elfFile.hpp&quot;
  86 #include &quot;utilities/exceptions.hpp&quot;
  87 #include &quot;utilities/macros.hpp&quot;
  88 #if INCLUDE_CDS
  89 #include &quot;prims/cdsoffsets.hpp&quot;
  90 #endif // INCLUDE_CDS
  91 #if INCLUDE_G1GC
  92 #include &quot;gc/g1/g1Arguments.hpp&quot;
  93 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  94 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  95 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  96 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  97 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  98 #endif // INCLUDE_G1GC
  99 #if INCLUDE_PARALLELGC
 100 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
 101 #endif // INCLUDE_PARALLELGC
 102 #if INCLUDE_NMT
 103 #include &quot;services/mallocSiteTable.hpp&quot;
 104 #include &quot;services/memTracker.hpp&quot;
 105 #include &quot;utilities/nativeCallStack.hpp&quot;
 106 #endif // INCLUDE_NMT
 107 #if INCLUDE_AOT
 108 #include &quot;aot/aotLoader.hpp&quot;
 109 #endif // INCLUDE_AOT
 110 
 111 #ifdef LINUX
 112 #include &quot;osContainer_linux.hpp&quot;
 113 #include &quot;cgroupSubsystem_linux.hpp&quot;
 114 #endif
 115 
 116 #define SIZE_T_MAX_VALUE ((size_t) -1)
 117 
 118 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 119   do {                                                                 \
 120     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 121     THREAD-&gt;clear_pending_jni_exception_check();                       \
 122     if (HAS_PENDING_EXCEPTION) {                                       \
 123       return(value);                                                   \
 124     }                                                                  \
 125   } while (0)
 126 
 127 #define CHECK_JNI_EXCEPTION(env)                                       \
 128   do {                                                                 \
 129     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 130     THREAD-&gt;clear_pending_jni_exception_check();                       \
 131     if (HAS_PENDING_EXCEPTION) {                                       \
 132       return;                                                          \
 133     }                                                                  \
 134   } while (0)
 135 
 136 bool WhiteBox::_used = false;
 137 volatile bool WhiteBox::compilation_locked = false;
 138 
 139 class VM_WhiteBoxOperation : public VM_Operation {
 140  public:
 141   VM_WhiteBoxOperation()                         { }
 142   VMOp_Type type()                  const        { return VMOp_WhiteBoxOperation; }
 143   bool allow_nested_vm_operations() const        { return true; }
 144 };
 145 
 146 
 147 WB_ENTRY(jlong, WB_GetObjectAddress(JNIEnv* env, jobject o, jobject obj))
 148   return (jlong)(void*)JNIHandles::resolve(obj);
 149 WB_END
 150 
 151 WB_ENTRY(jint, WB_GetHeapOopSize(JNIEnv* env, jobject o))
 152   return heapOopSize;
 153 WB_END
 154 
 155 WB_ENTRY(jint, WB_GetVMPageSize(JNIEnv* env, jobject o))
 156   return os::vm_page_size();
 157 WB_END
 158 
 159 WB_ENTRY(jlong, WB_GetVMAllocationGranularity(JNIEnv* env, jobject o))
 160   return os::vm_allocation_granularity();
 161 WB_END
 162 
 163 WB_ENTRY(jlong, WB_GetVMLargePageSize(JNIEnv* env, jobject o))
 164   return os::large_page_size();
 165 WB_END
 166 
 167 class WBIsKlassAliveClosure : public LockedClassesDo {
 168     Symbol* _name;
 169     int _count;
 170 public:
 171     WBIsKlassAliveClosure(Symbol* name) : _name(name), _count(0) {}
 172 
 173     void do_klass(Klass* k) {
 174       Symbol* ksym = k-&gt;name();
 175       if (ksym-&gt;fast_compare(_name) == 0) {
 176         _count++;
 177       }
 178     }
 179 
 180     int count() const {
 181         return _count;
 182     }
 183 };
 184 
 185 WB_ENTRY(jint, WB_CountAliveClasses(JNIEnv* env, jobject target, jstring name))
 186   oop h_name = JNIHandles::resolve(name);
 187   if (h_name == NULL) return false;
 188   Symbol* sym = java_lang_String::as_symbol(h_name);
 189   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 190 
 191   WBIsKlassAliveClosure closure(sym);
 192   ClassLoaderDataGraph::classes_do(&amp;closure);
 193 
 194   // Return the count of alive classes with this name.
 195   return closure.count();
 196 WB_END
 197 
 198 WB_ENTRY(jint, WB_GetSymbolRefcount(JNIEnv* env, jobject unused, jstring name))
 199   oop h_name = JNIHandles::resolve(name);
 200   if (h_name == NULL) return false;
 201   Symbol* sym = java_lang_String::as_symbol(h_name);
 202   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 203   return (jint)sym-&gt;refcount();
 204 WB_END
 205 
 206 
 207 WB_ENTRY(void, WB_AddToBootstrapClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 208 #if INCLUDE_JVMTI
 209   ResourceMark rm;
 210   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 211   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 212   jvmtiError err = jvmti_env-&gt;AddToBootstrapClassLoaderSearch(seg);
 213   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 214 #endif
 215 }
 216 WB_END
 217 
 218 WB_ENTRY(void, WB_AddToSystemClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 219 #if INCLUDE_JVMTI
 220   ResourceMark rm;
 221   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 222   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 223   jvmtiError err = jvmti_env-&gt;AddToSystemClassLoaderSearch(seg);
 224   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 225 #endif
 226 }
 227 WB_END
 228 
 229 
 230 WB_ENTRY(jlong, WB_GetCompressedOopsMaxHeapSize(JNIEnv* env, jobject o)) {
 231   return (jlong)Arguments::max_heap_for_compressed_oops();
 232 }
 233 WB_END
 234 
 235 WB_ENTRY(void, WB_PrintHeapSizes(JNIEnv* env, jobject o)) {
 236   tty-&gt;print_cr(&quot;Minimum heap &quot; SIZE_FORMAT &quot; Initial heap &quot; SIZE_FORMAT &quot; &quot;
 237                 &quot;Maximum heap &quot; SIZE_FORMAT &quot; Space alignment &quot; SIZE_FORMAT &quot; Heap alignment &quot; SIZE_FORMAT,
 238                 MinHeapSize,
 239                 InitialHeapSize,
 240                 MaxHeapSize,
 241                 SpaceAlignment,
 242                 HeapAlignment);
 243 }
 244 WB_END
 245 
 246 #ifndef PRODUCT
 247 // Forward declaration
 248 void TestReservedSpace_test();
 249 void TestReserveMemorySpecial_test();
 250 void TestVirtualSpace_test();
 251 #endif
 252 
 253 WB_ENTRY(void, WB_RunMemoryUnitTests(JNIEnv* env, jobject o))
 254 #ifndef PRODUCT
 255   TestReservedSpace_test();
 256   TestReserveMemorySpecial_test();
 257   TestVirtualSpace_test();
 258 #endif
 259 WB_END
 260 
 261 WB_ENTRY(void, WB_ReadFromNoaccessArea(JNIEnv* env, jobject o))
 262   size_t granularity = os::vm_allocation_granularity();
 263   ReservedHeapSpace rhs(100 * granularity, granularity, false);
 264   VirtualSpace vs;
 265   vs.initialize(rhs, 50 * granularity);
 266 
 267   // Check if constraints are complied
 268   if (!( UseCompressedOops &amp;&amp; rhs.base() != NULL &amp;&amp;
 269          CompressedOops::base() != NULL &amp;&amp;
 270          CompressedOops::use_implicit_null_checks() )) {
 271     tty-&gt;print_cr(&quot;WB_ReadFromNoaccessArea method is useless:\n &quot;
 272                   &quot;\tUseCompressedOops is %d\n&quot;
 273                   &quot;\trhs.base() is &quot; PTR_FORMAT &quot;\n&quot;
 274                   &quot;\tCompressedOops::base() is &quot; PTR_FORMAT &quot;\n&quot;
 275                   &quot;\tCompressedOops::use_implicit_null_checks() is %d&quot;,
 276                   UseCompressedOops,
 277                   p2i(rhs.base()),
 278                   p2i(CompressedOops::base()),
 279                   CompressedOops::use_implicit_null_checks());
 280     return;
 281   }
 282   tty-&gt;print_cr(&quot;Reading from no access area... &quot;);
 283   tty-&gt;print_cr(&quot;*(vs.low_boundary() - rhs.noaccess_prefix() / 2 ) = %c&quot;,
 284                 *(vs.low_boundary() - rhs.noaccess_prefix() / 2 ));
 285 WB_END
 286 
 287 static jint wb_stress_virtual_space_resize(size_t reserved_space_size,
 288                                            size_t magnitude, size_t iterations) {
 289   size_t granularity = os::vm_allocation_granularity();
 290   ReservedHeapSpace rhs(reserved_space_size * granularity, granularity, false);
 291   VirtualSpace vs;
 292   if (!vs.initialize(rhs, 0)) {
 293     tty-&gt;print_cr(&quot;Failed to initialize VirtualSpace. Can&#39;t proceed.&quot;);
 294     return 3;
 295   }
 296 
 297   int seed = os::random();
 298   tty-&gt;print_cr(&quot;Random seed is %d&quot;, seed);
 299   os::init_random(seed);
 300 
 301   for (size_t i = 0; i &lt; iterations; i++) {
 302 
 303     // Whether we will shrink or grow
 304     bool shrink = os::random() % 2L == 0;
 305 
 306     // Get random delta to resize virtual space
 307     size_t delta = (size_t)os::random() % magnitude;
 308 
 309     // If we are about to shrink virtual space below zero, then expand instead
 310     if (shrink &amp;&amp; vs.committed_size() &lt; delta) {
 311       shrink = false;
 312     }
 313 
 314     // Resizing by delta
 315     if (shrink) {
 316       vs.shrink_by(delta);
 317     } else {
 318       // If expanding fails expand_by will silently return false
 319       vs.expand_by(delta, true);
 320     }
 321   }
 322   return 0;
 323 }
 324 
 325 WB_ENTRY(jint, WB_StressVirtualSpaceResize(JNIEnv* env, jobject o,
 326         jlong reserved_space_size, jlong magnitude, jlong iterations))
 327   tty-&gt;print_cr(&quot;reservedSpaceSize=&quot; JLONG_FORMAT &quot;, magnitude=&quot; JLONG_FORMAT &quot;, &quot;
 328                 &quot;iterations=&quot; JLONG_FORMAT &quot;\n&quot;, reserved_space_size, magnitude,
 329                 iterations);
 330   if (reserved_space_size &lt; 0 || magnitude &lt; 0 || iterations &lt; 0) {
 331     tty-&gt;print_cr(&quot;One of variables printed above is negative. Can&#39;t proceed.\n&quot;);
 332     return 1;
 333   }
 334 
 335   // sizeof(size_t) depends on whether OS is 32bit or 64bit. sizeof(jlong) is
 336   // always 8 byte. That&#39;s why we should avoid overflow in case of 32bit platform.
 337   if (sizeof(size_t) &lt; sizeof(jlong)) {
 338     jlong size_t_max_value = (jlong) SIZE_T_MAX_VALUE;
 339     if (reserved_space_size &gt; size_t_max_value || magnitude &gt; size_t_max_value
 340         || iterations &gt; size_t_max_value) {
 341       tty-&gt;print_cr(&quot;One of variables printed above overflows size_t. Can&#39;t proceed.\n&quot;);
 342       return 2;
 343     }
 344   }
 345 
 346   return wb_stress_virtual_space_resize((size_t) reserved_space_size,
 347                                         (size_t) magnitude, (size_t) iterations);
 348 WB_END
 349 
 350 WB_ENTRY(jboolean, WB_IsGCSupported(JNIEnv* env, jobject o, jint name))
 351   return GCConfig::is_gc_supported((CollectedHeap::Name)name);
 352 WB_END
 353 
 354 WB_ENTRY(jboolean, WB_IsGCSelected(JNIEnv* env, jobject o, jint name))
 355   return GCConfig::is_gc_selected((CollectedHeap::Name)name);
 356 WB_END
 357 
 358 WB_ENTRY(jboolean, WB_IsGCSelectedErgonomically(JNIEnv* env, jobject o))
 359   return GCConfig::is_gc_selected_ergonomically();
 360 WB_END
 361 
 362 WB_ENTRY(jboolean, WB_isObjectInOldGen(JNIEnv* env, jobject o, jobject obj))
 363   oop p = JNIHandles::resolve(obj);
 364 #if INCLUDE_G1GC
 365   if (UseG1GC) {
 366     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 367     const HeapRegion* hr = g1h-&gt;heap_region_containing(p);
 368     if (hr == NULL) {
 369       return false;
 370     }
 371     return !(hr-&gt;is_young());
 372   }
 373 #endif
 374 #if INCLUDE_PARALLELGC
 375   if (UseParallelGC) {
 376     ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();
 377     return !psh-&gt;is_in_young(p);
 378   }
 379 #endif
 380 #if INCLUDE_ZGC
 381   if (UseZGC) {
 382     return Universe::heap()-&gt;is_in(p);
 383   }
 384 #endif
 385   GenCollectedHeap* gch = GenCollectedHeap::heap();
 386   return !gch-&gt;is_in_young(p);
 387 WB_END
 388 
 389 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 390   oop p = JNIHandles::resolve(obj);
 391   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
 392 WB_END
 393 
 394 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 395   return (jlong)SpaceAlignment;
 396 WB_END
 397 
 398 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 399   return (jlong)HeapAlignment;
 400 WB_END
 401 
 402 WB_ENTRY(jboolean, WB_SupportsConcurrentGCBreakpoints(JNIEnv* env, jobject o))
 403   return Universe::heap()-&gt;supports_concurrent_gc_breakpoints();
 404 WB_END
 405 
 406 WB_ENTRY(void, WB_ConcurrentGCAcquireControl(JNIEnv* env, jobject o))
 407   ConcurrentGCBreakpoints::acquire_control();
 408 WB_END
 409 
 410 WB_ENTRY(void, WB_ConcurrentGCReleaseControl(JNIEnv* env, jobject o))
 411   ConcurrentGCBreakpoints::release_control();
 412 WB_END
 413 
 414 WB_ENTRY(void, WB_ConcurrentGCRunToIdle(JNIEnv* env, jobject o))
 415   ConcurrentGCBreakpoints::run_to_idle();
 416 WB_END
 417 
 418 WB_ENTRY(jboolean, WB_ConcurrentGCRunTo(JNIEnv* env, jobject o, jobject at))
 419   Handle h_name(THREAD, JNIHandles::resolve(at));
 420   ResourceMark rm;
 421   const char* c_name = java_lang_String::as_utf8_string(h_name());
 422   return ConcurrentGCBreakpoints::run_to(c_name);
 423 WB_END
 424 
 425 #if INCLUDE_G1GC
 426 
 427 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 428   if (UseG1GC) {
 429     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 430     oop result = JNIHandles::resolve(obj);
 431     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 432     return hr-&gt;is_humongous();
 433   }
 434   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1IsHumongous: G1 GC is not enabled&quot;);
 435 WB_END
 436 
 437 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 438   if (UseG1GC) {
 439     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 440     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 441     return hr-&gt;is_humongous();
 442   }
 443   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToHumongousRegion: G1 GC is not enabled&quot;);
 444 WB_END
 445 
 446 WB_ENTRY(jboolean, WB_G1BelongsToFreeRegion(JNIEnv* env, jobject o, jlong addr))
 447   if (UseG1GC) {
 448     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 449     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 450     return hr-&gt;is_free();
 451   }
 452   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToFreeRegion: G1 GC is not enabled&quot;);
 453 WB_END
 454 
 455 WB_ENTRY(jlong, WB_G1NumMaxRegions(JNIEnv* env, jobject o))
 456   if (UseG1GC) {
 457     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 458     size_t nr = g1h-&gt;max_regions();
 459     return (jlong)nr;
 460   }
 461   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumMaxRegions: G1 GC is not enabled&quot;);
 462 WB_END
 463 
 464 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 465   if (UseG1GC) {
 466     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 467     size_t nr = g1h-&gt;num_free_regions();
 468     return (jlong)nr;
 469   }
 470   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumFreeRegions: G1 GC is not enabled&quot;);
 471 WB_END
 472 
 473 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 474   if (UseG1GC) {
 475     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 476     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 477   }
 478   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1InConcurrentMark: G1 GC is not enabled&quot;);
 479 WB_END
 480 
 481 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 482   if (UseG1GC) {
 483     if (AsyncDeflateIdleMonitors) {
 484       // AsyncDeflateIdleMonitors needs to know when System.gc() or
 485       // the equivalent is called so any special clean up can be done
 486       // at a safepoint, e.g., TestHumongousClassLoader.java.
 487       ObjectSynchronizer::set_is_special_deflation_requested(true);
 488     }
 489     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 490     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 491       g1h-&gt;collect(GCCause::_wb_conc_mark);
 492       return true;
 493     }
 494     return false;
 495   }
 496   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1StartMarkCycle: G1 GC is not enabled&quot;);
 497 WB_END
 498 
 499 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 500   if (UseG1GC) {
 501     return (jint)HeapRegion::GrainBytes;
 502   }
 503   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1RegionSize: G1 GC is not enabled&quot;);
 504 WB_END
 505 
 506 #endif // INCLUDE_G1GC
 507 
 508 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
 509 WB_ENTRY(jlong, WB_DramReservedStart(JNIEnv* env, jobject o))
 510 #if INCLUDE_G1GC
 511   if (UseG1GC) {
 512     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 513     if (g1h-&gt;is_heterogeneous_heap()) {
 514       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_dram();
 515       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 516     } else {
 517       return (jlong)g1h-&gt;base();
 518     }
 519   }
 520 #endif // INCLUDE_G1GC
 521 #if INCLUDE_PARALLELGC
 522   if (UseParallelGC) {
 523     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 524     if (AllocateOldGenAt != NULL) {
 525       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 526       return (jlong)reserved.start();
 527     } else {
 528       return (jlong)ps_heap-&gt;base();
 529     }
 530   }
 531 #endif // INCLUDE_PARALLELGC
 532   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedStart: enabled only for G1 and Parallel GC&quot;);
 533 WB_END
 534 
 535 WB_ENTRY(jlong, WB_DramReservedEnd(JNIEnv* env, jobject o))
 536 #if INCLUDE_G1GC
 537   if (UseG1GC) {
 538     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 539     if (g1h-&gt;is_heterogeneous_heap()) {
 540       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;end_index_of_dram();
 541       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 542     } else {
 543       return (jlong)g1h-&gt;base() + G1Arguments::heap_max_size_bytes();
 544     }
 545   }
 546 #endif // INCLUDE_G1GC
 547 #if INCLUDE_PARALLELGC
 548   if (UseParallelGC) {
 549     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 550     if (AllocateOldGenAt != NULL) {
 551       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 552       return (jlong)reserved.end();
 553     } else {
 554       return (jlong)ps_heap-&gt;reserved_region().end();
 555     }
 556   }
 557 #endif // INCLUDE_PARALLELGC
 558   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedEnd: enabled only for G1 and Parallel GC&quot;);
 559 WB_END
 560 
 561 WB_ENTRY(jlong, WB_NvdimmReservedStart(JNIEnv* env, jobject o))
 562 #if INCLUDE_G1GC
 563   if (UseG1GC) {
 564     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 565     if (g1h-&gt;is_heterogeneous_heap()) {
 566       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 567       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 568     } else {
 569       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 570     }
 571   }
 572 #endif // INCLUDE_G1GC
 573 #if INCLUDE_PARALLELGC
 574   if (UseParallelGC) {
 575     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 576     if (AllocateOldGenAt != NULL) {
 577       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 578       return (jlong)reserved.start();
 579     } else {
 580       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 581     }
 582   }
 583 #endif // INCLUDE_PARALLELGC
 584   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: enabled only for G1 and Parallel GC&quot;);
 585 WB_END
 586 
 587 WB_ENTRY(jlong, WB_NvdimmReservedEnd(JNIEnv* env, jobject o))
 588 #if INCLUDE_G1GC
 589   if (UseG1GC) {
 590     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 591     if (g1h-&gt;is_heterogeneous_heap()) {
 592       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 593       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 594     } else {
 595       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 596     }
 597   }
 598 #endif // INCLUDE_G1GC
 599 #if INCLUDE_PARALLELGC
 600   if (UseParallelGC) {
 601     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 602     if (AllocateOldGenAt != NULL) {
 603       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 604       return (jlong)reserved.end();
 605       } else {
 606       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 607     }
 608   }
 609 #endif // INCLUDE_PARALLELGC
 610   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: enabled only for G1 and Parallel GC&quot;);
 611 WB_END
 612 
 613 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
 614 
 615 #if INCLUDE_PARALLELGC
 616 
 617 WB_ENTRY(jlong, WB_PSVirtualSpaceAlignment(JNIEnv* env, jobject o))
 618   if (UseParallelGC) {
 619     return GenAlignment;
 620   }
 621   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSVirtualSpaceAlignment: Parallel GC is not enabled&quot;);
 622 WB_END
 623 
 624 WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))
 625   if (UseParallelGC) {
 626     return GenAlignment;
 627   }
 628   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSHeapGenerationAlignment: Parallel GC is not enabled&quot;);
 629 WB_END
 630 
 631 #endif // INCLUDE_PARALLELGC
 632 
 633 #if INCLUDE_G1GC
 634 
 635 WB_ENTRY(jobject, WB_G1AuxiliaryMemoryUsage(JNIEnv* env))
 636   if (UseG1GC) {
 637     ResourceMark rm(THREAD);
 638     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 639     MemoryUsage usage = g1h-&gt;get_auxiliary_data_memory_usage();
 640     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 641     return JNIHandles::make_local(env, h());
 642   }
 643   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1AuxiliaryMemoryUsage: G1 GC is not enabled&quot;);
 644 WB_END
 645 
 646 WB_ENTRY(jint, WB_G1ActiveMemoryNodeCount(JNIEnv* env, jobject o))
 647   if (UseG1GC) {
 648     G1NUMA* numa = G1NUMA::numa();
 649     return (jint)numa-&gt;num_active_nodes();
 650   }
 651   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1ActiveMemoryNodeCount: G1 GC is not enabled&quot;);
 652 WB_END
 653 
 654 WB_ENTRY(jintArray, WB_G1MemoryNodeIds(JNIEnv* env, jobject o))
 655   if (UseG1GC) {
 656     G1NUMA* numa = G1NUMA::numa();
 657     int num_node_ids = (int)numa-&gt;num_active_nodes();
 658     const int* node_ids = numa-&gt;node_ids();
 659 
 660     typeArrayOop result = oopFactory::new_intArray(num_node_ids, CHECK_NULL);
 661     for (int i = 0; i &lt; num_node_ids; i++) {
 662       result-&gt;int_at_put(i, (jint)node_ids[i]);
 663     }
 664     return (jintArray) JNIHandles::make_local(env, result);
 665   }
 666   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1MemoryNodeIds: G1 GC is not enabled&quot;);
 667 WB_END
 668 
 669 class OldRegionsLivenessClosure: public HeapRegionClosure {
 670 
 671  private:
 672   const int _liveness;
 673   size_t _total_count;
 674   size_t _total_memory;
 675   size_t _total_memory_to_free;
 676 
 677  public:
 678   OldRegionsLivenessClosure(int liveness) :
 679     _liveness(liveness),
 680     _total_count(0),
 681     _total_memory(0),
 682     _total_memory_to_free(0) { }
 683 
 684     size_t total_count() { return _total_count; }
 685     size_t total_memory() { return _total_memory; }
 686     size_t total_memory_to_free() { return _total_memory_to_free; }
 687 
 688   bool do_heap_region(HeapRegion* r) {
 689     if (r-&gt;is_old()) {
 690       size_t prev_live = r-&gt;marked_bytes();
 691       size_t live = r-&gt;live_bytes();
 692       size_t size = r-&gt;used();
 693       size_t reg_size = HeapRegion::GrainBytes;
 694       if (size &gt; 0 &amp;&amp; ((int)(live * 100 / size) &lt; _liveness)) {
 695         _total_memory += size;
 696         ++_total_count;
 697         if (size == reg_size) {
 698         // we don&#39;t include non-full regions since they are unlikely included in mixed gc
 699         // for testing purposes it&#39;s enough to have lowest estimation of total memory that is expected to be freed
 700           _total_memory_to_free += size - prev_live;
 701         }
 702       }
 703     }
 704     return false;
 705   }
 706 };
 707 
 708 
 709 WB_ENTRY(jlongArray, WB_G1GetMixedGCInfo(JNIEnv* env, jobject o, jint liveness))
 710   if (!UseG1GC) {
 711     THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1GetMixedGCInfo: G1 GC is not enabled&quot;);
 712   }
 713   if (liveness &lt; 0) {
 714     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;liveness value should be non-negative&quot;);
 715   }
 716 
 717   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 718   OldRegionsLivenessClosure rli(liveness);
 719   g1h-&gt;heap_region_iterate(&amp;rli);
 720 
 721   typeArrayOop result = oopFactory::new_longArray(3, CHECK_NULL);
 722   result-&gt;long_at_put(0, rli.total_count());
 723   result-&gt;long_at_put(1, rli.total_memory());
 724   result-&gt;long_at_put(2, rli.total_memory_to_free());
 725   return (jlongArray) JNIHandles::make_local(env, result);
 726 WB_END
 727 
 728 #endif // INCLUDE_G1GC
 729 
 730 #if INCLUDE_NMT
 731 // Alloc memory using the test memory type so that we can use that to see if
 732 // NMT picks it up correctly
 733 WB_ENTRY(jlong, WB_NMTMalloc(JNIEnv* env, jobject o, jlong size))
 734   jlong addr = 0;
 735   addr = (jlong)(uintptr_t)os::malloc(size, mtTest);
 736   return addr;
 737 WB_END
 738 
 739 // Alloc memory with pseudo call stack. The test can create psudo malloc
 740 // allocation site to stress the malloc tracking.
 741 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStack(JNIEnv* env, jobject o, jlong size, jint pseudo_stack))
 742   address pc = (address)(size_t)pseudo_stack;
 743   NativeCallStack stack(&amp;pc, 1);
 744   return (jlong)(uintptr_t)os::malloc(size, mtTest, stack);
 745 WB_END
 746 
 747 // Alloc memory with pseudo call stack and specific memory type.
 748 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint type))
 749   address pc = (address)(size_t)pseudo_stack;
 750   NativeCallStack stack(&amp;pc, 1);
 751   return (jlong)(uintptr_t)os::malloc(size, (MEMFLAGS)type, stack);
 752 WB_END
 753 
 754 // Free the memory allocated by NMTAllocTest
 755 WB_ENTRY(void, WB_NMTFree(JNIEnv* env, jobject o, jlong mem))
 756   os::free((void*)(uintptr_t)mem);
 757 WB_END
 758 
 759 WB_ENTRY(jlong, WB_NMTReserveMemory(JNIEnv* env, jobject o, jlong size))
 760   jlong addr = 0;
 761 
 762   addr = (jlong)(uintptr_t)os::reserve_memory(size);
 763   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 764 
 765   return addr;
 766 WB_END
 767 
 768 WB_ENTRY(jlong, WB_NMTAttemptReserveMemoryAt(JNIEnv* env, jobject o, jlong addr, jlong size))
 769   addr = (jlong)(uintptr_t)os::attempt_reserve_memory_at((size_t)size, (char*)(uintptr_t)addr);
 770   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 771 
 772   return addr;
 773 WB_END
 774 
 775 WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 776   os::commit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 777   MemTracker::record_virtual_memory_type((address)(uintptr_t)addr, mtTest);
 778 WB_END
 779 
 780 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 781   os::uncommit_memory((char *)(uintptr_t)addr, size);
 782 WB_END
 783 
 784 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 785   os::release_memory((char *)(uintptr_t)addr, size);
 786 WB_END
 787 
 788 WB_ENTRY(jboolean, WB_NMTChangeTrackingLevel(JNIEnv* env))
 789   // Test that we can downgrade NMT levels but not upgrade them.
 790   if (MemTracker::tracking_level() == NMT_off) {
 791     MemTracker::transition_to(NMT_off);
 792     return MemTracker::tracking_level() == NMT_off;
 793   } else {
 794     assert(MemTracker::tracking_level() == NMT_detail, &quot;Should start out as detail tracking&quot;);
 795     MemTracker::transition_to(NMT_summary);
 796     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should be summary now&quot;);
 797 
 798     // Can&#39;t go to detail once NMT is set to summary.
 799     MemTracker::transition_to(NMT_detail);
 800     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should still be summary now&quot;);
 801 
 802     // Shutdown sets tracking level to minimal.
 803     MemTracker::shutdown();
 804     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should be minimal now&quot;);
 805 
 806     // Once the tracking level is minimal, we cannot increase to summary.
 807     // The code ignores this request instead of asserting because if the malloc site
 808     // table overflows in another thread, it tries to change the code to summary.
 809     MemTracker::transition_to(NMT_summary);
 810     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 811 
 812     // Really can never go up to detail, verify that the code would never do this.
 813     MemTracker::transition_to(NMT_detail);
 814     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 815     return MemTracker::tracking_level() == NMT_minimal;
 816   }
 817 WB_END
 818 
 819 WB_ENTRY(jint, WB_NMTGetHashSize(JNIEnv* env, jobject o))
 820   int hash_size = MallocSiteTable::hash_buckets();
 821   assert(hash_size &gt; 0, &quot;NMT hash_size should be &gt; 0&quot;);
 822   return (jint)hash_size;
 823 WB_END
 824 
 825 WB_ENTRY(jlong, WB_NMTNewArena(JNIEnv* env, jobject o, jlong init_size))
 826   Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));
 827   return (jlong)arena;
 828 WB_END
 829 
 830 WB_ENTRY(void, WB_NMTFreeArena(JNIEnv* env, jobject o, jlong arena))
 831   Arena* a = (Arena*)arena;
 832   delete a;
 833 WB_END
 834 
 835 WB_ENTRY(void, WB_NMTArenaMalloc(JNIEnv* env, jobject o, jlong arena, jlong size))
 836   Arena* a = (Arena*)arena;
 837   a-&gt;Amalloc(size_t(size));
 838 WB_END
 839 #endif // INCLUDE_NMT
 840 
 841 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
 842   assert(method != NULL, &quot;method should not be null&quot;);
 843   ThreadToNativeFromVM ttn(thread);
 844   return env-&gt;FromReflectedMethod(method);
 845 }
 846 
 847 static CompLevel highestCompLevel() {
 848   return TieredCompilation ? MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier) : CompLevel_highest_tier;
 849 }
 850 
 851 // Deoptimizes all compiled frames and makes nmethods not entrant if it&#39;s requested
 852 class VM_WhiteBoxDeoptimizeFrames : public VM_WhiteBoxOperation {
 853  private:
 854   int _result;
 855   const bool _make_not_entrant;
 856  public:
 857   VM_WhiteBoxDeoptimizeFrames(bool make_not_entrant) :
 858         _result(0), _make_not_entrant(make_not_entrant) { }
 859   int  result() const { return _result; }
 860 
 861   void doit() {
 862     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
 863       if (t-&gt;has_last_Java_frame()) {
 864         for (StackFrameStream fst(t, false); !fst.is_done(); fst.next()) {
 865           frame* f = fst.current();
 866           if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
 867             Deoptimization::deoptimize(t, *f);
 868             if (_make_not_entrant) {
 869                 CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
 870                 assert(cm != NULL, &quot;sanity check&quot;);
 871                 cm-&gt;make_not_entrant();
 872             }
 873             ++_result;
 874           }
 875         }
 876       }
 877     }
 878   }
 879 };
 880 
 881 WB_ENTRY(jint, WB_DeoptimizeFrames(JNIEnv* env, jobject o, jboolean make_not_entrant))
 882   VM_WhiteBoxDeoptimizeFrames op(make_not_entrant == JNI_TRUE);
 883   VMThread::execute(&amp;op);
 884   return op.result();
 885 WB_END
 886 
 887 WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
 888   CodeCache::mark_all_nmethods_for_deoptimization();
 889   Deoptimization::deoptimize_all_marked();
 890 WB_END
 891 
 892 WB_ENTRY(jint, WB_DeoptimizeMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 893   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 894   int result = 0;
 895   CHECK_JNI_EXCEPTION_(env, result);
 896   MutexLocker mu(Compile_lock);
 897   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 898   if (is_osr) {
 899     result += mh-&gt;mark_osr_nmethods();
 900   } else if (mh-&gt;code() != NULL) {
 901     mh-&gt;code()-&gt;mark_for_deoptimization();
 902     ++result;
 903   }
 904   result += CodeCache::mark_for_deoptimization(mh());
 905   if (result &gt; 0) {
 906     Deoptimization::deoptimize_all_marked();
 907   }
 908   return result;
 909 WB_END
 910 
 911 WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 912   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 913   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 914   MutexLocker mu(Compile_lock);
 915   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 916   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 917   if (code == NULL) {
 918     return JNI_FALSE;
 919   }
 920   return (code-&gt;is_alive() &amp;&amp; !code-&gt;is_marked_for_deoptimization());
 921 WB_END
 922 
 923 WB_ENTRY(jboolean, WB_IsMethodCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 924   if (method == NULL || comp_level &gt; highestCompLevel()) {
 925     return false;
 926   }
 927   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 928   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 929   MutexLocker mu(Compile_lock);
 930   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 931   if (is_osr) {
 932     return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
 933   } else {
 934     return CompilationPolicy::can_be_compiled(mh, comp_level);
 935   }
 936 WB_END
 937 
 938 WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
 939   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 940   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 941   MutexLocker mu(Compile_lock);
 942   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 943   return mh-&gt;queued_for_compilation();
 944 WB_END
 945 
 946 WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
 947   if (compLevel &lt; CompLevel_none || compLevel &gt; highestCompLevel()) {
 948     return false; // Intrinsic is not available on a non-existent compilation level.
 949   }
 950   jmethodID method_id, compilation_context_id;
 951   method_id = reflected_method_to_jmid(thread, env, method);
 952   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 953   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(method_id));
 954 
 955   DirectiveSet* directive;
 956   AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);
 957   assert(comp != NULL, &quot;compiler not available&quot;);
 958   if (compilation_context != NULL) {
 959     compilation_context_id = reflected_method_to_jmid(thread, env, compilation_context);
 960     CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 961     methodHandle cch(THREAD, Method::checked_resolve_jmethod_id(compilation_context_id));
 962     directive = DirectivesStack::getMatchingDirective(cch, comp);
 963   } else {
 964     // Calling with NULL matches default directive
 965     directive = DirectivesStack::getDefaultDirective(comp);
 966   }
 967   bool result = comp-&gt;is_intrinsic_available(mh, directive);
 968   DirectivesStack::release(directive);
 969   return result;
 970 WB_END
 971 
 972 WB_ENTRY(jint, WB_GetMethodCompilationLevel(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 973   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 974   CHECK_JNI_EXCEPTION_(env, CompLevel_none);
 975   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 976   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 977   return (code != NULL ? code-&gt;comp_level() : CompLevel_none);
 978 WB_END
 979 
 980 WB_ENTRY(void, WB_MakeMethodNotCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 981   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 982   CHECK_JNI_EXCEPTION(env);
 983   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 984   if (is_osr) {
 985     mh-&gt;set_not_osr_compilable(&quot;WhiteBox&quot;, comp_level);
 986   } else {
 987     mh-&gt;set_not_compilable(&quot;WhiteBox&quot;, comp_level);
 988   }
 989 WB_END
 990 
 991 WB_ENTRY(jint, WB_GetMethodEntryBci(JNIEnv* env, jobject o, jobject method))
 992   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 993   CHECK_JNI_EXCEPTION_(env, InvocationEntryBci);
 994   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 995   CompiledMethod* code = mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false);
 996   return (code != NULL &amp;&amp; code-&gt;is_osr_method() ? code-&gt;osr_entry_bci() : InvocationEntryBci);
 997 WB_END
 998 
 999 WB_ENTRY(jboolean, WB_TestSetDontInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
1000   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1001   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1002   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1003   bool result = mh-&gt;dont_inline();
1004   mh-&gt;set_dont_inline(value == JNI_TRUE);
1005   return result;
1006 WB_END
1007 
1008 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
1009   if (comp_level == CompLevel_any) {
1010     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
1011         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
1012   } else {
1013     return CompileBroker::queue_size(comp_level);
1014   }
1015 WB_END
1016 
1017 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
1018   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1019   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1020   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1021   bool result = mh-&gt;force_inline();
1022   mh-&gt;set_force_inline(value == JNI_TRUE);
1023   return result;
1024 WB_END
1025 
1026 #ifdef LINUX
1027 bool WhiteBox::validate_cgroup(const char* proc_cgroups,
1028                                const char* proc_self_cgroup,
1029                                const char* proc_self_mountinfo,
1030                                u1* cg_flags) {
1031   CgroupInfo cg_infos[4];
1032   return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,
1033                                                     proc_self_cgroup,
1034                                                     proc_self_mountinfo, cg_flags);
1035 }
1036 #endif
1037 
1038 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1039   // Screen for unavailable/bad comp level or null method
1040   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1041   if (method == NULL) {
1042     tty-&gt;print_cr(&quot;WB error: request to compile NULL method&quot;);
1043     return false;
1044   }
1045   if (comp_level &gt; highestCompLevel()) {
1046     tty-&gt;print_cr(&quot;WB error: invalid compilation level %d&quot;, comp_level);
1047     return false;
1048   }
1049   if (comp == NULL) {
1050     tty-&gt;print_cr(&quot;WB error: no compiler for requested compilation level %d&quot;, comp_level);
1051     return false;
1052   }
1053 
1054   // Check if compilation is blocking
1055   methodHandle mh(THREAD, method);
1056   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1057   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
1058   DirectivesStack::release(directive);
1059 
1060   // Compile method and check result
1061   nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
1062   MutexLocker mu(THREAD, Compile_lock);
1063   bool is_queued = mh-&gt;queued_for_compilation();
1064   if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
1065     return true;
1066   }
1067   tty-&gt;print(&quot;WB error: failed to %s compile at level %d method &quot;, is_blocking ? &quot;blocking&quot; : &quot;&quot;, comp_level);
1068   mh-&gt;print_short_name(tty);
1069   tty-&gt;cr();
1070   if (is_blocking &amp;&amp; is_queued) {
1071     tty-&gt;print_cr(&quot;WB error: blocking compilation is still in queue!&quot;);
1072   }
1073   return false;
1074 }
1075 
1076 WB_ENTRY(jboolean, WB_EnqueueMethodForCompilation(JNIEnv* env, jobject o, jobject method, jint comp_level, jint bci))
1077   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1078   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1079   return WhiteBox::compile_method(Method::checked_resolve_jmethod_id(jmid), comp_level, bci, THREAD);
1080 WB_END
1081 
1082 WB_ENTRY(jboolean, WB_EnqueueInitializerForCompilation(JNIEnv* env, jobject o, jclass klass, jint comp_level))
1083   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1084   Method* clinit = ik-&gt;class_initializer();
1085   if (clinit == NULL) {
1086     return false;
1087   }
1088   return WhiteBox::compile_method(clinit, comp_level, InvocationEntryBci, THREAD);
1089 WB_END
1090 
1091 WB_ENTRY(jboolean, WB_ShouldPrintAssembly(JNIEnv* env, jobject o, jobject method, jint comp_level))
1092   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1093   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1094 
1095   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1096   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, CompileBroker::compiler(comp_level));
1097   bool result = directive-&gt;PrintAssemblyOption;
1098   DirectivesStack::release(directive);
1099 
1100   return result;
1101 WB_END
1102 
1103 WB_ENTRY(jint, WB_MatchesInline(JNIEnv* env, jobject o, jobject method, jstring pattern))
1104   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1105   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1106 
1107   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1108 
1109   ResourceMark rm(THREAD);
1110   const char* error_msg = NULL;
1111   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1112   InlineMatcher* m = InlineMatcher::parse_inline_pattern(method_str, error_msg);
1113 
1114   if (m == NULL) {
1115     assert(error_msg != NULL, &quot;Always have an error message&quot;);
1116     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1117     return -1; // Pattern failed
1118   }
1119 
1120   // Pattern works - now check if it matches
1121   int result;
1122   if (m-&gt;match(mh, InlineMatcher::force_inline)) {
1123     result = 2; // Force inline match
1124   } else if (m-&gt;match(mh, InlineMatcher::dont_inline)) {
1125     result = 1; // Dont inline match
1126   } else {
1127     result = 0; // No match
1128   }
1129   delete m;
1130   return result;
1131 WB_END
1132 
1133 WB_ENTRY(jint, WB_MatchesMethod(JNIEnv* env, jobject o, jobject method, jstring pattern))
1134   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1135   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1136 
1137   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1138 
1139   ResourceMark rm;
1140   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1141 
1142   const char* error_msg = NULL;
1143 
1144   BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);
1145   if (m == NULL) {
1146     assert(error_msg != NULL, &quot;Must have error_msg&quot;);
1147     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1148     return -1;
1149   }
1150 
1151   // Pattern works - now check if it matches
1152   int result = m-&gt;matches(mh);
1153   delete m;
1154   assert(result == 0 || result == 1, &quot;Result out of range&quot;);
1155   return result;
1156 WB_END
1157 
1158 WB_ENTRY(void, WB_MarkMethodProfiled(JNIEnv* env, jobject o, jobject method))
1159   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1160   CHECK_JNI_EXCEPTION(env);
1161   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1162 
1163   MethodData* mdo = mh-&gt;method_data();
1164   if (mdo == NULL) {
1165     Method::build_interpreter_method_data(mh, CHECK_AND_CLEAR);
1166     mdo = mh-&gt;method_data();
1167   }
1168   mdo-&gt;init();
1169   InvocationCounter* icnt = mdo-&gt;invocation_counter();
1170   InvocationCounter* bcnt = mdo-&gt;backedge_counter();
1171   // set i-counter according to TieredThresholdPolicy::is_method_profiled
1172   icnt-&gt;set(Tier4MinInvocationThreshold);
1173   bcnt-&gt;set(Tier4CompileThreshold);
1174 WB_END
1175 
1176 WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
1177   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1178   CHECK_JNI_EXCEPTION(env);
1179   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1180   MutexLocker mu(THREAD, Compile_lock);
1181   MethodData* mdo = mh-&gt;method_data();
1182   MethodCounters* mcs = mh-&gt;method_counters();
1183 
1184   if (mdo != NULL) {
1185     mdo-&gt;init();
1186     ResourceMark rm(THREAD);
1187     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
1188     for (int i = 0; i &lt; arg_count; i++) {
1189       mdo-&gt;set_arg_modified(i, 0);
1190     }
1191     MutexLocker mu(THREAD, mdo-&gt;extra_data_lock());
1192     mdo-&gt;clean_method_data(/*always_clean*/true);
1193   }
1194 
1195   mh-&gt;clear_not_c1_compilable();
1196   mh-&gt;clear_not_c2_compilable();
1197   mh-&gt;clear_not_c2_osr_compilable();
1198   NOT_PRODUCT(mh-&gt;set_compiled_invocation_count(0));
1199   if (mcs != NULL) {
1200     mcs-&gt;backedge_counter()-&gt;init();
1201     mcs-&gt;invocation_counter()-&gt;init();
1202     mcs-&gt;set_interpreter_invocation_count(0);
1203     mcs-&gt;set_interpreter_throwout_count(0);
1204 
1205 #ifdef TIERED
1206     mcs-&gt;set_rate(0.0F);
1207     mh-&gt;set_prev_event_count(0);
1208     mh-&gt;set_prev_time(0);
1209 #endif
1210   }
1211 WB_END
1212 
1213 template &lt;typename T&gt;
1214 static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const JVMFlag*, T*)) {
1215   if (name == NULL) {
1216     return false;
1217   }
1218   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1219   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1220   CHECK_JNI_EXCEPTION_(env, false);
1221   const JVMFlag* flag = JVMFlag::find_declared_flag(flag_name);
1222   JVMFlag::Error result = (*TAt)(flag, value);
1223   env-&gt;ReleaseStringUTFChars(name, flag_name);
1224   return (result == JVMFlag::SUCCESS);
1225 }
1226 
1227 template &lt;typename T&gt;
1228 static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(JVMFlag* flag, T*, JVMFlag::Flags)) {
1229   if (name == NULL) {
1230     return false;
1231   }
1232   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1233   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1234   CHECK_JNI_EXCEPTION_(env, false);
1235   JVMFlag* flag = JVMFlag::find_flag(flag_name);
1236   JVMFlag::Error result = (*TAtPut)(flag, value, JVMFlag::INTERNAL);
1237   env-&gt;ReleaseStringUTFChars(name, flag_name);
1238   return (result == JVMFlag::SUCCESS);
1239 }
1240 
1241 template &lt;typename T&gt;
1242 static jobject box(JavaThread* thread, JNIEnv* env, Symbol* name, Symbol* sig, T value) {
1243   ResourceMark rm(thread);
1244   jclass clazz = env-&gt;FindClass(name-&gt;as_C_string());
1245   CHECK_JNI_EXCEPTION_(env, NULL);
1246   jmethodID methodID = env-&gt;GetStaticMethodID(clazz,
1247         vmSymbols::valueOf_name()-&gt;as_C_string(),
1248         sig-&gt;as_C_string());
1249   CHECK_JNI_EXCEPTION_(env, NULL);
1250   jobject result = env-&gt;CallStaticObjectMethod(clazz, methodID, value);
1251   CHECK_JNI_EXCEPTION_(env, NULL);
1252   return result;
1253 }
1254 
1255 static jobject booleanBox(JavaThread* thread, JNIEnv* env, jboolean value) {
1256   return box(thread, env, vmSymbols::java_lang_Boolean(), vmSymbols::Boolean_valueOf_signature(), value);
1257 }
1258 static jobject integerBox(JavaThread* thread, JNIEnv* env, jint value) {
1259   return box(thread, env, vmSymbols::java_lang_Integer(), vmSymbols::Integer_valueOf_signature(), value);
1260 }
1261 static jobject longBox(JavaThread* thread, JNIEnv* env, jlong value) {
1262   return box(thread, env, vmSymbols::java_lang_Long(), vmSymbols::Long_valueOf_signature(), value);
1263 }
1264 /* static jobject floatBox(JavaThread* thread, JNIEnv* env, jfloat value) {
1265   return box(thread, env, vmSymbols::java_lang_Float(), vmSymbols::Float_valueOf_signature(), value);
1266 }*/
1267 static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
1268   return box(thread, env, vmSymbols::java_lang_Double(), vmSymbols::Double_valueOf_signature(), value);
1269 }
1270 
1271 static const JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {
1272   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1273   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1274   CHECK_JNI_EXCEPTION_(env, NULL);
1275   const JVMFlag* result = JVMFlag::find_declared_flag(flag_name);
1276   env-&gt;ReleaseStringUTFChars(name, flag_name);
1277   return result;
1278 }
1279 
1280 WB_ENTRY(jboolean, WB_IsConstantVMFlag(JNIEnv* env, jobject o, jstring name))
1281   const JVMFlag* flag = getVMFlag(thread, env, name);
1282   return (flag != NULL) &amp;&amp; flag-&gt;is_constant_in_binary();
1283 WB_END
1284 
1285 WB_ENTRY(jboolean, WB_IsLockedVMFlag(JNIEnv* env, jobject o, jstring name))
1286   const JVMFlag* flag = getVMFlag(thread, env, name);
1287   return (flag != NULL) &amp;&amp; !(flag-&gt;is_unlocked() || flag-&gt;is_unlocker());
1288 WB_END
1289 
1290 WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
1291   bool result;
1292   if (GetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAt)) {
1293     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1294     return booleanBox(thread, env, result);
1295   }
1296   return NULL;
1297 WB_END
1298 
1299 WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))
1300   int result;
1301   if (GetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAt)) {
1302     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1303     return longBox(thread, env, result);
1304   }
1305   return NULL;
1306 WB_END
1307 
1308 WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEnv* env, jobject o, jstring name))
1309   uint result;
1310   if (GetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAt)) {
1311     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1312     return longBox(thread, env, result);
1313   }
1314   return NULL;
1315 WB_END
1316 
1317 WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEnv* env, jobject o, jstring name))
1318   intx result;
1319   if (GetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAt)) {
1320     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1321     return longBox(thread, env, result);
1322   }
1323   return NULL;
1324 WB_END
1325 
1326 WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIEnv* env, jobject o, jstring name))
1327   uintx result;
1328   if (GetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAt)) {
1329     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1330     return longBox(thread, env, result);
1331   }
1332   return NULL;
1333 WB_END
1334 
1335 WB_ENTRY(jobject, WB_GetUint64VMFlag(JNIEnv* env, jobject o, jstring name))
1336   uint64_t result;
1337   if (GetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAt)) {
1338     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1339     return longBox(thread, env, result);
1340   }
1341   return NULL;
1342 WB_END
1343 
1344 WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIEnv* env, jobject o, jstring name))
1345   size_t result;
1346   if (GetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAt)) {
1347     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1348     return longBox(thread, env, result);
1349   }
1350   return NULL;
1351 WB_END
1352 
1353 WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNIEnv* env, jobject o, jstring name))
1354   double result;
1355   if (GetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAt)) {
1356     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1357     return doubleBox(thread, env, result);
1358   }
1359   return NULL;
1360 WB_END
1361 
1362 WB_ENTRY(jstring, WB_GetStringVMFlag(JNIEnv* env, jobject o, jstring name))
1363   ccstr ccstrResult;
1364   if (GetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAt)) {
1365     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1366     jstring result = env-&gt;NewStringUTF(ccstrResult);
1367     CHECK_JNI_EXCEPTION_(env, NULL);
1368     return result;
1369   }
1370   return NULL;
1371 WB_END
1372 
1373 WB_ENTRY(void, WB_SetBooleanVMFlag(JNIEnv* env, jobject o, jstring name, jboolean value))
1374   bool result = value == JNI_TRUE ? true : false;
1375   SetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAtPut);
1376 WB_END
1377 
1378 WB_ENTRY(void, WB_SetIntVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1379   int result = value;
1380   SetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAtPut);
1381 WB_END
1382 
1383 WB_ENTRY(void, WB_SetUintVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1384   uint result = value;
1385   SetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAtPut);
1386 WB_END
1387 
1388 WB_ENTRY(void, WB_SetIntxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1389   intx result = value;
1390   SetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAtPut);
1391 WB_END
1392 
1393 WB_ENTRY(void, WB_SetUintxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1394   uintx result = value;
1395   SetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAtPut);
1396 WB_END
1397 
1398 WB_ENTRY(void, WB_SetUint64VMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1399   uint64_t result = value;
1400   SetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAtPut);
1401 WB_END
1402 
1403 WB_ENTRY(void, WB_SetSizeTVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1404   size_t result = value;
1405   SetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAtPut);
1406 WB_END
1407 
1408 WB_ENTRY(void, WB_SetDoubleVMFlag(JNIEnv* env, jobject o, jstring name, jdouble value))
1409   double result = value;
1410   SetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAtPut);
1411 WB_END
1412 
1413 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
1414   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1415   const char* ccstrValue;
1416   if (value == NULL) {
1417     ccstrValue = NULL;
1418   }
1419   else {
1420     ccstrValue = env-&gt;GetStringUTFChars(value, NULL);
1421     CHECK_JNI_EXCEPTION(env);
1422   }
1423   ccstr ccstrResult = ccstrValue;
1424   bool needFree;
1425   {
1426     ThreadInVMfromNative ttvfn(thread); // back to VM
1427     needFree = SetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAtPut);
1428   }
1429   if (value != NULL) {
1430     env-&gt;ReleaseStringUTFChars(value, ccstrValue);
1431   }
1432   if (needFree) {
1433     FREE_C_HEAP_ARRAY(char, ccstrResult);
1434   }
1435 WB_END
1436 
1437 WB_ENTRY(void, WB_LockCompilation(JNIEnv* env, jobject o, jlong timeout))
1438   WhiteBox::compilation_locked = true;
1439 WB_END
1440 
1441 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1442   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1443   WhiteBox::compilation_locked = false;
1444   mo.notify_all();
1445 WB_END
1446 
1447 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1448   // Force a code cache sweep and block until it finished
1449   NMethodSweeper::force_sweep();
1450 WB_END
1451 
1452 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1453   ResourceMark rm(THREAD);
1454   int len;
1455   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1456   return (StringTable::lookup(name, len) != NULL);
1457 WB_END
1458 
1459 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))
1460   if (AsyncDeflateIdleMonitors) {
1461     // AsyncDeflateIdleMonitors needs to know when System.gc() or
1462     // the equivalent is called so any special clean up can be done
1463     // at a safepoint, e.g., TestHumongousClassLoader.java.
1464     ObjectSynchronizer::set_is_special_deflation_requested(true);
1465   }
1466   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1467   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1468 #if INCLUDE_G1GC
1469   if (UseG1GC) {
1470     // Needs to be cleared explicitly for G1
1471     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1472   }
1473 #endif // INCLUDE_G1GC
1474 WB_END
1475 
1476 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1477   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1478 WB_END
1479 
1480 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1481   // static+volatile in order to force the read to happen
1482   // (not be eliminated by the compiler)
1483   static char c;
1484   static volatile char* p;
1485 
1486   p = os::reserve_memory(os::vm_allocation_granularity(), NULL, 0);
1487   if (p == NULL) {
1488     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), &quot;Failed to reserve memory&quot;);
1489   }
1490 
1491   c = *p;
1492 WB_END
1493 
1494 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
1495   const char* features = VM_Version::features_string();
1496   ThreadToNativeFromVM ttn(thread);
1497   jstring features_string = env-&gt;NewStringUTF(features);
1498 
1499   CHECK_JNI_EXCEPTION_(env, NULL);
1500 
1501   return features_string;
1502 WB_END
1503 
1504 int WhiteBox::get_blob_type(const CodeBlob* code) {
1505   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1506   if (code-&gt;is_aot()) {
1507     return -1;
1508   }
1509   return CodeCache::get_code_heap(code)-&gt;code_blob_type();
1510 }
1511 
1512 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1513   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1514   return CodeCache::get_code_heap(blob_type);
1515 }
1516 
1517 struct CodeBlobStub {
1518   CodeBlobStub(const CodeBlob* blob) :
1519       name(os::strdup(blob-&gt;name())),
1520       size(blob-&gt;size()),
1521       blob_type(WhiteBox::get_blob_type(blob)),
1522       address((jlong) blob) { }
1523   ~CodeBlobStub() { os::free((void*) name); }
1524   const char* const name;
1525   const jint        size;
1526   const jint        blob_type;
1527   const jlong       address;
1528 };
1529 
1530 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {
1531   ResourceMark rm;
1532   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1533   CHECK_JNI_EXCEPTION_(env, NULL);
1534   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1535 
1536   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1537   CHECK_JNI_EXCEPTION_(env, NULL);
1538   env-&gt;SetObjectArrayElement(result, 0, name);
1539 
1540   jobject obj = integerBox(thread, env, cb-&gt;size);
1541   CHECK_JNI_EXCEPTION_(env, NULL);
1542   env-&gt;SetObjectArrayElement(result, 1, obj);
1543 
1544   obj = integerBox(thread, env, cb-&gt;blob_type);
1545   CHECK_JNI_EXCEPTION_(env, NULL);
1546   env-&gt;SetObjectArrayElement(result, 2, obj);
1547 
1548   obj = longBox(thread, env, cb-&gt;address);
1549   CHECK_JNI_EXCEPTION_(env, NULL);
1550   env-&gt;SetObjectArrayElement(result, 3, obj);
1551 
1552   return result;
1553 }
1554 
1555 WB_ENTRY(jobjectArray, WB_GetNMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
1556   ResourceMark rm(THREAD);
1557   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1558   CHECK_JNI_EXCEPTION_(env, NULL);
1559   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1560   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
1561   jobjectArray result = NULL;
1562   if (code == NULL) {
1563     return result;
1564   }
1565   int comp_level = code-&gt;comp_level();
1566   int insts_size = comp_level == CompLevel_aot ? code-&gt;code_end() - code-&gt;code_begin() : code-&gt;insts_size();
1567 
1568   ThreadToNativeFromVM ttn(thread);
1569   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1570   CHECK_JNI_EXCEPTION_(env, NULL);
1571   result = env-&gt;NewObjectArray(5, clazz, NULL);
1572   if (result == NULL) {
1573     return result;
1574   }
1575 
1576   CodeBlobStub stub(code);
1577   jobjectArray codeBlob = codeBlob2objectArray(thread, env, &amp;stub);
1578   CHECK_JNI_EXCEPTION_(env, NULL);
1579   env-&gt;SetObjectArrayElement(result, 0, codeBlob);
1580 
1581   jobject level = integerBox(thread, env, comp_level);
1582   CHECK_JNI_EXCEPTION_(env, NULL);
1583   env-&gt;SetObjectArrayElement(result, 1, level);
1584 
1585   jbyteArray insts = env-&gt;NewByteArray(insts_size);
1586   CHECK_JNI_EXCEPTION_(env, NULL);
1587   env-&gt;SetByteArrayRegion(insts, 0, insts_size, (jbyte*) code-&gt;insts_begin());
1588   env-&gt;SetObjectArrayElement(result, 2, insts);
1589 
1590   jobject id = integerBox(thread, env, code-&gt;compile_id());
1591   CHECK_JNI_EXCEPTION_(env, NULL);
1592   env-&gt;SetObjectArrayElement(result, 3, id);
1593 
1594   jobject entry_point = longBox(thread, env, (jlong) code-&gt;entry_point());
1595   CHECK_JNI_EXCEPTION_(env, NULL);
1596   env-&gt;SetObjectArrayElement(result, 4, entry_point);
1597 
1598   return result;
1599 WB_END
1600 
1601 CodeBlob* WhiteBox::allocate_code_blob(int size, int blob_type) {
1602   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1603   BufferBlob* blob;
1604   int full_size = CodeBlob::align_code_offset(sizeof(BufferBlob));
1605   if (full_size &lt; size) {
1606     full_size += align_up(size - full_size, oopSize);
1607   }
1608   {
1609     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1610     blob = (BufferBlob*) CodeCache::allocate(full_size, blob_type);
1611     if (blob != NULL) {
1612       ::new (blob) BufferBlob(&quot;WB::DummyBlob&quot;, full_size);
1613     }
1614   }
1615   // Track memory usage statistic after releasing CodeCache_lock
1616   MemoryService::track_code_cache_memory_usage();
1617   return blob;
1618 }
1619 
1620 WB_ENTRY(jlong, WB_AllocateCodeBlob(JNIEnv* env, jobject o, jint size, jint blob_type))
1621   if (size &lt; 0) {
1622     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1623       err_msg(&quot;WB_AllocateCodeBlob: size is negative: &quot; INT32_FORMAT, size));
1624   }
1625   return (jlong) WhiteBox::allocate_code_blob(size, blob_type);
1626 WB_END
1627 
1628 WB_ENTRY(void, WB_FreeCodeBlob(JNIEnv* env, jobject o, jlong addr))
1629   if (addr == 0) {
1630     return;
1631   }
1632   BufferBlob::free((BufferBlob*) addr);
1633 WB_END
1634 
1635 WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_type))
1636   ResourceMark rm;
1637   GrowableArray&lt;CodeBlobStub*&gt; blobs;
1638   {
1639     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1640     CodeHeap* heap = WhiteBox::get_code_heap(blob_type);
1641     if (heap == NULL) {
1642       return NULL;
1643     }
1644     for (CodeBlob* cb = (CodeBlob*) heap-&gt;first();
1645          cb != NULL; cb = (CodeBlob*) heap-&gt;next(cb)) {
1646       CodeBlobStub* stub = NEW_RESOURCE_OBJ(CodeBlobStub);
1647       new (stub) CodeBlobStub(cb);
1648       blobs.append(stub);
1649     }
1650   }
1651   ThreadToNativeFromVM ttn(thread);
1652   jobjectArray result = NULL;
1653   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1654   CHECK_JNI_EXCEPTION_(env, NULL);
1655   result = env-&gt;NewObjectArray(blobs.length(), clazz, NULL);
1656   CHECK_JNI_EXCEPTION_(env, NULL);
1657   if (result == NULL) {
1658     return result;
1659   }
1660   int i = 0;
1661   for (GrowableArrayIterator&lt;CodeBlobStub*&gt; it = blobs.begin();
1662        it != blobs.end(); ++it) {
1663     jobjectArray obj = codeBlob2objectArray(thread, env, *it);
1664     CHECK_JNI_EXCEPTION_(env, NULL);
1665     env-&gt;SetObjectArrayElement(result, i, obj);
1666     CHECK_JNI_EXCEPTION_(env, NULL);
1667     ++i;
1668   }
1669   return result;
1670 WB_END
1671 
1672 WB_ENTRY(jint, WB_GetCompilationActivityMode(JNIEnv* env, jobject o))
1673   return CompileBroker::get_compilation_activity_mode();
1674 WB_END
1675 
1676 WB_ENTRY(jobjectArray, WB_GetCodeBlob(JNIEnv* env, jobject o, jlong addr))
1677   if (addr == 0) {
1678     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
1679       &quot;WB_GetCodeBlob: addr is null&quot;);
1680   }
1681   ThreadToNativeFromVM ttn(thread);
1682   CodeBlobStub stub((CodeBlob*) addr);
1683   return codeBlob2objectArray(thread, env, &amp;stub);
1684 WB_END
1685 
1686 WB_ENTRY(jlong, WB_GetMethodData(JNIEnv* env, jobject wv, jobject method))
1687   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1688   CHECK_JNI_EXCEPTION_(env, 0);
1689   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1690   return (jlong) mh-&gt;method_data();
1691 WB_END
1692 
1693 WB_ENTRY(jlong, WB_GetThreadStackSize(JNIEnv* env, jobject o))
1694   return (jlong) Thread::current()-&gt;stack_size();
1695 WB_END
1696 
1697 WB_ENTRY(jlong, WB_GetThreadRemainingStackSize(JNIEnv* env, jobject o))
1698   JavaThread* t = JavaThread::current();
1699   return (jlong) t-&gt;stack_available(os::current_stack_pointer()) - (jlong)JavaThread::stack_shadow_zone_size();
1700 WB_END
1701 
1702 
1703 int WhiteBox::array_bytes_to_length(size_t bytes) {
1704   return Array&lt;u1&gt;::bytes_to_length(bytes);
1705 }
1706 
1707 WB_ENTRY(jlong, WB_AllocateMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong size))
1708   if (size &lt; 0) {
1709     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1710         err_msg(&quot;WB_AllocateMetaspace: size is negative: &quot; JLONG_FORMAT, size));
1711   }
1712 
1713   oop class_loader_oop = JNIHandles::resolve(class_loader);
1714   ClassLoaderData* cld = class_loader_oop != NULL
1715       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1716       : ClassLoaderData::the_null_class_loader_data();
1717 
1718   void* metadata = MetadataFactory::new_array&lt;u1&gt;(cld, WhiteBox::array_bytes_to_length((size_t)size), thread);
1719 
1720   return (jlong)(uintptr_t)metadata;
1721 WB_END
1722 
1723 WB_ENTRY(void, WB_FreeMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong addr, jlong size))
1724   oop class_loader_oop = JNIHandles::resolve(class_loader);
1725   ClassLoaderData* cld = class_loader_oop != NULL
1726       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1727       : ClassLoaderData::the_null_class_loader_data();
1728 
1729   MetadataFactory::free_array(cld, (Array&lt;u1&gt;*)(uintptr_t)addr);
1730 WB_END
1731 
1732 WB_ENTRY(void, WB_DefineModule(JNIEnv* env, jobject o, jobject module, jboolean is_open,
1733                                 jstring version, jstring location, jobjectArray packages))
1734   Modules::define_module(module, is_open, version, location, packages, CHECK);
1735 WB_END
1736 
1737 WB_ENTRY(void, WB_AddModuleExports(JNIEnv* env, jobject o, jobject from_module, jstring package, jobject to_module))
1738   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1739 WB_END
1740 
1741 WB_ENTRY(void, WB_AddModuleExportsToAllUnnamed(JNIEnv* env, jobject o, jclass module, jstring package))
1742   Modules::add_module_exports_to_all_unnamed(module, package, CHECK);
1743 WB_END
1744 
1745 WB_ENTRY(void, WB_AddModuleExportsToAll(JNIEnv* env, jobject o, jclass module, jstring package))
1746   Modules::add_module_exports(module, package, NULL, CHECK);
1747 WB_END
1748 
1749 WB_ENTRY(void, WB_AddReadsModule(JNIEnv* env, jobject o, jobject from_module, jobject source_module))
1750   Modules::add_reads_module(from_module, source_module, CHECK);
1751 WB_END
1752 
1753 WB_ENTRY(jlong, WB_IncMetaspaceCapacityUntilGC(JNIEnv* env, jobject wb, jlong inc))
1754   if (inc &lt; 0) {
1755     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1756         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc is negative: &quot; JLONG_FORMAT, inc));
1757   }
1758 
1759   jlong max_size_t = (jlong) ((size_t) -1);
1760   if (inc &gt; max_size_t) {
1761     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1762         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc does not fit in size_t: &quot; JLONG_FORMAT, inc));
1763   }
1764 
1765   size_t new_cap_until_GC = 0;
1766   size_t aligned_inc = align_down((size_t) inc, Metaspace::commit_alignment());
1767   bool success = MetaspaceGC::inc_capacity_until_GC(aligned_inc, &amp;new_cap_until_GC);
1768   if (!success) {
1769     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(),
1770                 &quot;WB_IncMetaspaceCapacityUntilGC: could not increase capacity until GC &quot;
1771                 &quot;due to contention with another thread&quot;);
1772   }
1773   return (jlong) new_cap_until_GC;
1774 WB_END
1775 
1776 WB_ENTRY(jlong, WB_MetaspaceCapacityUntilGC(JNIEnv* env, jobject wb))
1777   return (jlong) MetaspaceGC::capacity_until_GC();
1778 WB_END
1779 
1780 WB_ENTRY(jlong, WB_MetaspaceReserveAlignment(JNIEnv* env, jobject wb))
1781   return (jlong)Metaspace::reserve_alignment();
1782 WB_END
1783 
1784 WB_ENTRY(void, WB_AssertMatchingSafepointCalls(JNIEnv* env, jobject o, jboolean mutexSafepointValue, jboolean attemptedNoSafepointValue))
1785   Mutex::SafepointCheckRequired sfpt_check_required = mutexSafepointValue ?
1786                                            Mutex::_safepoint_check_always :
1787                                            Mutex::_safepoint_check_never;
1788   Mutex::SafepointCheckFlag sfpt_check_attempted = attemptedNoSafepointValue ?
1789                                            Mutex::_no_safepoint_check_flag :
1790                                            Mutex::_safepoint_check_flag;
1791   MutexLocker ml(new Mutex(Mutex::leaf, &quot;SFPT_Test_lock&quot;, true, sfpt_check_required),
1792                  sfpt_check_attempted);
1793 WB_END
1794 
1795 WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))
1796   // Create a special lock violating condition in value
1797   Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?
1798                                            Mutex::_safepoint_check_always :
1799                                            Mutex::_safepoint_check_never;
1800   Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?
1801                                            Monitor::_safepoint_check_flag :
1802                                            Monitor::_no_safepoint_check_flag;
1803 
1804   MutexLocker ml(new Mutex(Mutex::special, &quot;SpecialTest_lock&quot;, allowVMBlock, sfpt_check_required), safepoint_check);
1805   // If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.
1806   ThreadBlockInVM tbivm(JavaThread::current());
1807 WB_END
1808 
1809 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1810   oop obj_oop = JNIHandles::resolve(obj);
1811   return (jboolean) obj_oop-&gt;mark().has_monitor();
1812 WB_END
1813 
1814 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
1815   if (AsyncDeflateIdleMonitors) {
1816     // AsyncDeflateIdleMonitors needs to know when System.gc() or
1817     // the equivalent is called so any special clean up can be done
1818     // at a safepoint, e.g., TestRTMTotalCountIncrRate.java or
1819     // TestUseRTMForStackLocks.java.
1820     ObjectSynchronizer::set_is_special_deflation_requested(true);
1821   }
1822   VM_ForceSafepoint force_safepoint_op;
1823   VMThread::execute(&amp;force_safepoint_op);
1824 WB_END
1825 
1826 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1827   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1828   return (jlong) ik-&gt;constants();
1829 WB_END
1830 
1831 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1832   return ConstantPool::CPCACHE_INDEX_TAG;
1833 WB_END
1834 
1835 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1836   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1837   ConstantPool* cp = ik-&gt;constants();
1838   if (cp-&gt;cache() == NULL) {
1839       return -1;
1840   }
1841   return cp-&gt;cache()-&gt;length();
1842 WB_END
1843 
1844 WB_ENTRY(jint, WB_ConstantPoolRemapInstructionOperandFromCache(JNIEnv* env, jobject wb, jclass klass, jint index))
1845   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1846   ConstantPool* cp = ik-&gt;constants();
1847   if (cp-&gt;cache() == NULL) {
1848     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(), &quot;Constant pool does not have a cache&quot;);
1849   }
1850   jint cpci = index;
1851   jint cpciTag = ConstantPool::CPCACHE_INDEX_TAG;
1852   if (cpciTag &gt; cpci || cpci &gt;= cp-&gt;cache()-&gt;length() + cpciTag) {
1853     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool cache index is out of range&quot;);
1854   }
1855   jint cpi = cp-&gt;remap_instruction_operand_from_cache(cpci);
1856   return cpi;
1857 WB_END
1858 
1859 WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))
1860   return ConstantPool::encode_invokedynamic_index(index);
1861 WB_END
1862 
<a name="4" id="anc4"></a><span class="line-added">1863 WB_ENTRY(jobjectArray, WB_getObjectsViaKlassOopMaps(JNIEnv* env, jobject wb, jobject thing))</span>
<span class="line-added">1864   oop aoop = JNIHandles::resolve(thing);</span>
<span class="line-added">1865   if (!aoop-&gt;is_instance()) {</span>
<span class="line-added">1866     return NULL;</span>
<span class="line-added">1867   }</span>
<span class="line-added">1868   instanceHandle ih(THREAD, (instanceOop) aoop);</span>
<span class="line-added">1869   InstanceKlass* klass = InstanceKlass::cast(aoop-&gt;klass());</span>
<span class="line-added">1870   if (klass-&gt;nonstatic_oop_map_count() == 0) {</span>
<span class="line-added">1871     return NULL;</span>
<span class="line-added">1872   }</span>
<span class="line-added">1873   const OopMapBlock* map = klass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">1874   const OopMapBlock* const end = map + klass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">1875   int oop_count = 0;</span>
<span class="line-added">1876   while (map &lt; end) {</span>
<span class="line-added">1877     oop_count += map-&gt;count();</span>
<span class="line-added">1878     map++;</span>
<span class="line-added">1879   }</span>
<span class="line-added">1880 </span>
<span class="line-added">1881   objArrayOop result_array =</span>
<span class="line-added">1882       oopFactory::new_objArray(SystemDictionary::Object_klass(), oop_count, CHECK_NULL);</span>
<span class="line-added">1883   map = klass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">1884   instanceOop ioop = ih();</span>
<span class="line-added">1885   int index = 0;</span>
<span class="line-added">1886   while (map &lt; end) {</span>
<span class="line-added">1887     int offset = map-&gt;offset();</span>
<span class="line-added">1888     for (unsigned int j = 0; j &lt; map-&gt;count(); j++) {</span>
<span class="line-added">1889       result_array-&gt;obj_at_put(index++, ioop-&gt;obj_field(offset));</span>
<span class="line-added">1890       offset += heapOopSize;</span>
<span class="line-added">1891     }</span>
<span class="line-added">1892     map++;</span>
<span class="line-added">1893   }</span>
<span class="line-added">1894   return (jobjectArray)JNIHandles::make_local(env, result_array);</span>
<span class="line-added">1895 WB_END</span>
<span class="line-added">1896 </span>
<span class="line-added">1897 class CollectOops : public BasicOopIterateClosure {</span>
<span class="line-added">1898  public:</span>
<span class="line-added">1899   GrowableArray&lt;Handle&gt;* array;</span>
<span class="line-added">1900 </span>
<span class="line-added">1901   objArrayOop create_results(TRAPS) {</span>
<span class="line-added">1902     objArrayOop result_array =</span>
<span class="line-added">1903         oopFactory::new_objArray(SystemDictionary::Object_klass(), array-&gt;length(), CHECK_NULL);</span>
<span class="line-added">1904     for (int i = 0 ; i &lt; array-&gt;length(); i++) {</span>
<span class="line-added">1905       result_array-&gt;obj_at_put(i, array-&gt;at(i)());</span>
<span class="line-added">1906     }</span>
<span class="line-added">1907     return result_array;</span>
<span class="line-added">1908   }</span>
<span class="line-added">1909 </span>
<span class="line-added">1910   jobjectArray create_jni_result(JNIEnv* env, TRAPS) {</span>
<span class="line-added">1911     return (jobjectArray)JNIHandles::make_local(env, create_results(THREAD));</span>
<span class="line-added">1912   }</span>
<span class="line-added">1913 </span>
<span class="line-added">1914   void add_oop(oop o) {</span>
<span class="line-added">1915     // Value might be oop, but JLS can&#39;t see as Object, just iterate through it...</span>
<span class="line-added">1916     if (o != NULL &amp;&amp; o-&gt;is_inline_type()) {</span>
<span class="line-added">1917       o-&gt;oop_iterate(this);</span>
<span class="line-added">1918     } else {</span>
<span class="line-added">1919       array-&gt;append(Handle(Thread::current(), o));</span>
<span class="line-added">1920     }</span>
<span class="line-added">1921   }</span>
<span class="line-added">1922 </span>
<span class="line-added">1923   void do_oop(oop* o) { add_oop(*o); }</span>
<span class="line-added">1924   void do_oop(narrowOop* v) { add_oop(CompressedOops::decode(*v)); }</span>
<span class="line-added">1925 };</span>
<span class="line-added">1926 </span>
<span class="line-added">1927 </span>
<span class="line-added">1928 WB_ENTRY(jobjectArray, WB_getObjectsViaOopIterator(JNIEnv* env, jobject wb, jobject thing))</span>
<span class="line-added">1929   ResourceMark rm(THREAD);</span>
<span class="line-added">1930   GrowableArray&lt;Handle&gt;* array = new GrowableArray&lt;Handle&gt;(128);</span>
<span class="line-added">1931   CollectOops collectOops;</span>
<span class="line-added">1932   collectOops.array = array;</span>
<span class="line-added">1933 </span>
<span class="line-added">1934   JNIHandles::resolve(thing)-&gt;oop_iterate(&amp;collectOops);</span>
<span class="line-added">1935 </span>
<span class="line-added">1936   return collectOops.create_jni_result(env, THREAD);</span>
<span class="line-added">1937 WB_END</span>
<span class="line-added">1938 </span>
<span class="line-added">1939 WB_ENTRY(jobjectArray, WB_getObjectsViaFrameOopIterator(JNIEnv* env, jobject wb, jint depth))</span>
<span class="line-added">1940   ResourceMark rm(THREAD);</span>
<span class="line-added">1941   GrowableArray&lt;Handle&gt;* array = new GrowableArray&lt;Handle&gt;(128);</span>
<span class="line-added">1942   CollectOops collectOops;</span>
<span class="line-added">1943   collectOops.array = array;</span>
<span class="line-added">1944   StackFrameStream sfs(thread);</span>
<span class="line-added">1945   while (depth &gt; 0) { // Skip the native WB API frame</span>
<span class="line-added">1946     sfs.next();</span>
<span class="line-added">1947     frame* f = sfs.current();</span>
<span class="line-added">1948     f-&gt;oops_do(&amp;collectOops, NULL, sfs.register_map());</span>
<span class="line-added">1949     depth--;</span>
<span class="line-added">1950   }</span>
<span class="line-added">1951   return collectOops.create_jni_result(env, THREAD);</span>
<span class="line-added">1952 WB_END</span>
<span class="line-added">1953 </span>
<span class="line-added">1954 </span>
1955 WB_ENTRY(void, WB_ClearInlineCaches(JNIEnv* env, jobject wb, jboolean preserve_static_stubs))
1956   VM_ClearICs clear_ics(preserve_static_stubs == JNI_TRUE);
1957   VMThread::execute(&amp;clear_ics);
1958 WB_END
1959 
1960 template &lt;typename T&gt;
1961 static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jstring name, T* value) {
1962   assert(value != NULL, &quot;sanity&quot;);
1963   if (method == NULL || name == NULL) {
1964     return false;
1965   }
1966   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1967   CHECK_JNI_EXCEPTION_(env, false);
1968   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1969   // can&#39;t be in VM when we call JNI
1970   ThreadToNativeFromVM ttnfv(thread);
1971   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1972   CHECK_JNI_EXCEPTION_(env, false);
1973   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
1974   env-&gt;ReleaseStringUTFChars(name, flag_name);
1975   return result;
1976 }
1977 
1978 WB_ENTRY(jobject, WB_GetMethodBooleaneOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1979   bool result;
1980   if (GetMethodOption&lt;bool&gt; (thread, env, method, name, &amp;result)) {
1981     // can&#39;t be in VM when we call JNI
1982     ThreadToNativeFromVM ttnfv(thread);
1983     return booleanBox(thread, env, result);
1984   }
1985   return NULL;
1986 WB_END
1987 
1988 WB_ENTRY(jobject, WB_GetMethodIntxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1989   intx result;
1990   if (GetMethodOption &lt;intx&gt; (thread, env, method, name, &amp;result)) {
1991     // can&#39;t be in VM when we call JNI
1992     ThreadToNativeFromVM ttnfv(thread);
1993     return longBox(thread, env, result);
1994   }
1995   return NULL;
1996 WB_END
1997 
1998 WB_ENTRY(jobject, WB_GetMethodUintxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1999   uintx result;
2000   if (GetMethodOption &lt;uintx&gt; (thread, env, method, name, &amp;result)) {
2001     // can&#39;t be in VM when we call JNI
2002     ThreadToNativeFromVM ttnfv(thread);
2003     return longBox(thread, env, result);
2004   }
2005   return NULL;
2006 WB_END
2007 
2008 WB_ENTRY(jobject, WB_GetMethodDoubleOption(JNIEnv* env, jobject wb, jobject method, jstring name))
2009   double result;
2010   if (GetMethodOption &lt;double&gt; (thread, env, method, name, &amp;result)) {
2011     // can&#39;t be in VM when we call JNI
2012     ThreadToNativeFromVM ttnfv(thread);
2013     return doubleBox(thread, env, result);
2014   }
2015   return NULL;
2016 WB_END
2017 
2018 WB_ENTRY(jobject, WB_GetMethodStringOption(JNIEnv* env, jobject wb, jobject method, jstring name))
2019   ccstr ccstrResult;
2020   if (GetMethodOption &lt;ccstr&gt; (thread, env, method, name, &amp;ccstrResult)) {
2021     // can&#39;t be in VM when we call JNI
2022     ThreadToNativeFromVM ttnfv(thread);
2023     jstring result = env-&gt;NewStringUTF(ccstrResult);
2024     CHECK_JNI_EXCEPTION_(env, NULL);
2025     return result;
2026   }
2027   return NULL;
2028 WB_END
2029 
2030 WB_ENTRY(jobject, WB_GetDefaultArchivePath(JNIEnv* env, jobject wb))
2031   const char* p = Arguments::get_default_shared_archive_path();
2032   ThreadToNativeFromVM ttn(thread);
2033   jstring path_string = env-&gt;NewStringUTF(p);
2034 
2035   CHECK_JNI_EXCEPTION_(env, NULL);
2036 
2037   return path_string;
2038 WB_END
2039 
2040 WB_ENTRY(jboolean, WB_IsSharingEnabled(JNIEnv* env, jobject wb))
2041   return UseSharedSpaces;
2042 WB_END
2043 
2044 WB_ENTRY(jboolean, WB_CDSMemoryMappingFailed(JNIEnv* env, jobject wb))
2045   return FileMapInfo::memory_mapping_failed();
2046 WB_END
2047 
2048 WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))
2049   oop obj_oop = JNIHandles::resolve(obj);
2050   return HeapShared::is_archived_object(obj_oop);
2051 WB_END
2052 
2053 WB_ENTRY(jboolean, WB_IsSharedClass(JNIEnv* env, jobject wb, jclass clazz))
2054   return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
2055 WB_END
2056 
2057 WB_ENTRY(jboolean, WB_AreSharedStringsIgnored(JNIEnv* env))
2058   return !HeapShared::closed_archive_heap_region_mapped();
2059 WB_END
2060 
2061 WB_ENTRY(jobject, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass clazz))
2062   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2063   if (k-&gt;is_instance_klass()) {
2064     InstanceKlass *ik = InstanceKlass::cast(k);
2065     ConstantPool *cp = ik-&gt;constants();
2066     objArrayOop refs =  cp-&gt;resolved_references();
2067     return (jobject)JNIHandles::make_local(env, refs);
2068   } else {
2069     return NULL;
2070   }
2071 WB_END
2072 
2073 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
2074   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2075   if (!k-&gt;is_instance_klass()) {
2076     return;
2077   }
2078   InstanceKlass *ik = InstanceKlass::cast(k);
2079   ik-&gt;link_class(THREAD); // may throw verification error
2080 WB_END
2081 
2082 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
2083   return HeapShared::open_archive_heap_region_mapped();
2084 WB_END
2085 
2086 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
2087 #if INCLUDE_CDS
2088   return true;
2089 #else
2090   return false;
2091 #endif // INCLUDE_CDS
2092 WB_END
2093 
2094 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
2095 #if COMPILER2_OR_JVMCI
2096   return true;
2097 #else
2098   return false;
2099 #endif
2100 WB_END
2101 
2102 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
2103   return HeapShared::is_heap_object_archiving_allowed();
2104 WB_END
2105 
2106 
2107 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
2108 #if INCLUDE_JFR
2109   return true;
2110 #else
2111   return false;
2112 #endif // INCLUDE_JFR
2113 WB_END
2114 
2115 #if INCLUDE_CDS
2116 
2117 WB_ENTRY(jint, WB_GetOffsetForName(JNIEnv* env, jobject o, jstring name))
2118   ResourceMark rm;
2119   char* c_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
2120   int result = CDSOffsets::find_offset(c_name);
2121   return (jint)result;
2122 WB_END
2123 
2124 #endif // INCLUDE_CDS
2125 
2126 WB_ENTRY(jint, WB_HandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle, jboolean all_threads))
2127   class TraceSelfClosure : public HandshakeClosure {
2128     jint _num_threads_completed;
2129 
2130     void do_thread(Thread* th) {
2131       assert(th-&gt;is_Java_thread(), &quot;sanity&quot;);
2132       JavaThread* jt = (JavaThread*)th;
2133       ResourceMark rm;
2134 
2135       jt-&gt;print_on(tty);
2136       jt-&gt;print_stack_on(tty);
2137       tty-&gt;cr();
2138       Atomic::inc(&amp;_num_threads_completed);
2139     }
2140 
2141   public:
2142     TraceSelfClosure() : HandshakeClosure(&quot;WB_TraceSelf&quot;), _num_threads_completed(0) {}
2143 
2144     jint num_threads_completed() const { return _num_threads_completed; }
2145   };
2146   TraceSelfClosure tsc;
2147 
2148   if (all_threads) {
2149     Handshake::execute(&amp;tsc);
2150   } else {
2151     oop thread_oop = JNIHandles::resolve(thread_handle);
2152     if (thread_oop != NULL) {
2153       JavaThread* target = java_lang_Thread::thread(thread_oop);
2154       Handshake::execute(&amp;tsc, target);
2155     }
2156   }
2157   return tsc.num_threads_completed();
2158 WB_END
2159 
2160 //Some convenience methods to deal with objects from java
2161 int WhiteBox::offset_for_field(const char* field_name, oop object,
2162     Symbol* signature_symbol) {
2163   assert(field_name != NULL &amp;&amp; strlen(field_name) &gt; 0, &quot;Field name not valid&quot;);
2164   Thread* THREAD = Thread::current();
2165 
2166   //Get the class of our object
2167   Klass* arg_klass = object-&gt;klass();
2168   //Turn it into an instance-klass
2169   InstanceKlass* ik = InstanceKlass::cast(arg_klass);
2170 
2171   //Create symbols to look for in the class
2172   TempNewSymbol name_symbol = SymbolTable::new_symbol(field_name);
2173 
2174   //To be filled in with an offset of the field we&#39;re looking for
2175   fieldDescriptor fd;
2176 
2177   Klass* res = ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd);
2178   if (res == NULL) {
2179     tty-&gt;print_cr(&quot;Invalid layout of %s at %s&quot;, ik-&gt;external_name(),
2180         name_symbol-&gt;as_C_string());
2181     vm_exit_during_initialization(&quot;Invalid layout of preloaded class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
2182   }
2183 
2184   //fetch the field at the offset we&#39;ve found
2185   int dest_offset = fd.offset();
2186 
2187   return dest_offset;
2188 }
2189 
2190 
2191 const char* WhiteBox::lookup_jstring(const char* field_name, oop object) {
2192   int offset = offset_for_field(field_name, object,
2193       vmSymbols::string_signature());
2194   oop string = object-&gt;obj_field(offset);
2195   if (string == NULL) {
2196     return NULL;
2197   }
2198   const char* ret = java_lang_String::as_utf8_string(string);
2199   return ret;
2200 }
2201 
2202 bool WhiteBox::lookup_bool(const char* field_name, oop object) {
2203   int offset =
2204       offset_for_field(field_name, object, vmSymbols::bool_signature());
2205   bool ret = (object-&gt;bool_field(offset) == JNI_TRUE);
2206   return ret;
2207 }
2208 
2209 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
2210   ResourceMark rm;
2211   ThreadToNativeFromVM ttnfv(thread); // can&#39;t be in VM when we call JNI
2212 
2213   //  one by one registration natives for exception catching
2214   jclass no_such_method_error_klass = env-&gt;FindClass(vmSymbols::java_lang_NoSuchMethodError()-&gt;as_C_string());
2215   CHECK_JNI_EXCEPTION(env);
2216   for (int i = 0, n = method_count; i &lt; n; ++i) {
2217     // Skip dummy entries
2218     if (method_array[i].fnPtr == NULL) continue;
2219     if (env-&gt;RegisterNatives(wbclass, &amp;method_array[i], 1) != 0) {
2220       jthrowable throwable_obj = env-&gt;ExceptionOccurred();
2221       if (throwable_obj != NULL) {
2222         env-&gt;ExceptionClear();
2223         if (env-&gt;IsInstanceOf(throwable_obj, no_such_method_error_klass)) {
2224           // NoSuchMethodError is thrown when a method can&#39;t be found or a method is not native.
2225           // Ignoring the exception since it is not preventing use of other WhiteBox methods.
2226           tty-&gt;print_cr(&quot;Warning: &#39;NoSuchMethodError&#39; on register of sun.hotspot.WhiteBox::%s%s&quot;,
2227               method_array[i].name, method_array[i].signature);
2228         }
2229       } else {
2230         // Registration failed unexpectedly.
2231         tty-&gt;print_cr(&quot;Warning: unexpected error on register of sun.hotspot.WhiteBox::%s%s. All methods will be unregistered&quot;,
2232             method_array[i].name, method_array[i].signature);
2233         env-&gt;UnregisterNatives(wbclass);
2234         break;
2235       }
2236     }
2237   }
2238 }
2239 
2240 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
2241   // can&#39;t be in VM when we call JNI
2242   ThreadToNativeFromVM ttnfv(thread);
2243   const char* dir = env-&gt;GetStringUTFChars(compDirect, NULL);
2244   CHECK_JNI_EXCEPTION_(env, 0);
2245   int ret;
2246   {
2247     ThreadInVMfromNative ttvfn(thread); // back to VM
2248     ret = DirectivesParser::parse_string(dir, tty);
2249   }
2250   env-&gt;ReleaseStringUTFChars(compDirect, dir);
2251   // -1 for error parsing directive. Return 0 as number of directives added.
2252   if (ret == -1) {
2253     ret = 0;
2254   }
2255   return (jint) ret;
2256 WB_END
2257 
2258 WB_ENTRY(void, WB_RemoveCompilerDirective(JNIEnv* env, jobject o, jint count))
2259   DirectivesStack::pop(count);
2260 WB_END
2261 
2262 // Checks that the library libfile has the noexecstack bit set.
2263 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2264   jboolean ret = false;
2265 #ifdef LINUX
2266   // Can&#39;t be in VM when we call JNI.
2267   ThreadToNativeFromVM ttnfv(thread);
2268   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2269   CHECK_JNI_EXCEPTION_(env, 0);
2270   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2271   env-&gt;ReleaseStringUTFChars(libfile, lf);
2272 #endif
2273   return ret;
2274 WB_END
2275 
2276 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2277   LINUX_ONLY(return OSContainer::is_containerized();)
2278   return false;
2279 WB_END
2280 
2281 WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,
2282                                     jobject o,
2283                                     jstring proc_cgroups,
2284                                     jstring proc_self_cgroup,
2285                                     jstring proc_self_mountinfo))
2286   jint ret = 0;
2287 #ifdef LINUX
2288   ThreadToNativeFromVM ttnfv(thread);
2289   const char* p_cgroups = env-&gt;GetStringUTFChars(proc_cgroups, NULL);
2290   CHECK_JNI_EXCEPTION_(env, 0);
2291   const char* p_s_cgroup = env-&gt;GetStringUTFChars(proc_self_cgroup, NULL);
2292   CHECK_JNI_EXCEPTION_(env, 0);
2293   const char* p_s_mountinfo = env-&gt;GetStringUTFChars(proc_self_mountinfo, NULL);
2294   CHECK_JNI_EXCEPTION_(env, 0);
2295   u1 cg_type_flags = 0;
2296   // This sets cg_type_flags
2297   WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &amp;cg_type_flags);
2298   ret = (jint)cg_type_flags;
2299   env-&gt;ReleaseStringUTFChars(proc_cgroups, p_cgroups);
2300   env-&gt;ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);
2301   env-&gt;ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);
2302 #endif
2303   return ret;
2304 WB_END
2305 
2306 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2307   os::print_os_info(tty);
2308 WB_END
2309 
2310 // Elf decoder
2311 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2312 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2313   ElfFile::_do_not_cache_elf_section = true;
2314 #endif
2315 WB_END
2316 
2317 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2318   return (jlong) ResolvedMethodTable::items_count();
2319 WB_END
2320 
2321 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2322   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2323 WB_END
2324 
2325 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
2326   jint result = 0;
2327 #if INCLUDE_AOT
2328   result = (jint) AOTLoader::heaps_count();
2329 #endif
2330   return result;
2331 WB_END
2332 
2333 WB_ENTRY(jint, WB_GetKlassMetadataSize(JNIEnv* env, jobject wb, jclass mirror))
2334   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2335   // Return size in bytes.
2336   return k-&gt;size() * wordSize;
2337 WB_END
2338 
2339 // See test/hotspot/jtreg/runtime/Thread/ThreadObjAccessAtExit.java.
2340 // It explains how the thread&#39;s priority field is used for test state coordination.
2341 //
2342 WB_ENTRY(void, WB_CheckThreadObjOfTerminatingThread(JNIEnv* env, jobject wb, jobject target_handle))
2343   oop target_oop = JNIHandles::resolve_non_null(target_handle);
2344   jlong tid = java_lang_Thread::thread_id(target_oop);
2345   JavaThread* target = java_lang_Thread::thread(target_oop);
2346 
2347   // Grab a ThreadsListHandle to protect the target thread whilst terminating
2348   ThreadsListHandle tlh;
2349 
2350   // Look up the target thread by tid to ensure it is present
2351   JavaThread* t = tlh.list()-&gt;find_JavaThread_from_java_tid(tid);
2352   if (t == NULL) {
2353     THROW_MSG(vmSymbols::java_lang_RuntimeException(), &quot;Target thread not found in ThreadsList!&quot;);
2354   }
2355 
2356   tty-&gt;print_cr(&quot;WB_CheckThreadObjOfTerminatingThread: target thread is protected&quot;);
2357   // Allow target to terminate by boosting priority
2358   java_lang_Thread::set_priority(t-&gt;threadObj(), ThreadPriority(NormPriority + 1));
2359 
2360   // Now wait for the target to terminate
2361   while (!target-&gt;is_terminated()) {
2362     ThreadBlockInVM tbivm(thread);  // just in case target is involved in a safepoint
2363     os::naked_short_sleep(0);
2364   }
2365 
2366   tty-&gt;print_cr(&quot;WB_CheckThreadObjOfTerminatingThread: target thread is terminated&quot;);
2367 
2368   // Now release the GC inducing thread - we have to re-resolve the external oop that
2369   // was passed in as GC may have occurred and we don&#39;t know if we can trust t-&gt;threadObj() now.
2370   oop original = JNIHandles::resolve_non_null(target_handle);
2371   java_lang_Thread::set_priority(original, ThreadPriority(NormPriority + 2));
2372 
2373   tty-&gt;print_cr(&quot;WB_CheckThreadObjOfTerminatingThread: GC has been initiated - checking threadObj:&quot;);
2374 
2375   // The Java code should be creating garbage and triggering GC, which would potentially move
2376   // the threadObj oop. If the exiting thread is properly protected then its threadObj should
2377   // remain valid and equal to our initial target_handle. Loop a few times to give GC a chance to
2378   // kick in.
2379   for (int i = 0; i &lt; 5; i++) {
2380     oop original = JNIHandles::resolve_non_null(target_handle);
2381     oop current = t-&gt;threadObj();
2382     if (original != current) {
2383       tty-&gt;print_cr(&quot;WB_CheckThreadObjOfTerminatingThread: failed comparison on iteration %d&quot;, i);
2384       THROW_MSG(vmSymbols::java_lang_RuntimeException(), &quot;Target thread oop has changed!&quot;);
2385     } else {
2386       tty-&gt;print_cr(&quot;WB_CheckThreadObjOfTerminatingThread: successful comparison on iteration %d&quot;, i);
2387       ThreadBlockInVM tbivm(thread);
2388       os::naked_short_sleep(50);
2389     }
2390   }
2391 WB_END
2392 
2393 #define CC (char*)
2394 
2395 static JNINativeMethod methods[] = {
2396   {CC&quot;getObjectAddress0&quot;,                CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectAddress  },
2397   {CC&quot;getObjectSize0&quot;,                   CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectSize     },
2398   {CC&quot;isObjectInOldGen0&quot;,                CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_isObjectInOldGen  },
2399   {CC&quot;getHeapOopSize&quot;,                   CC&quot;()I&quot;,                   (void*)&amp;WB_GetHeapOopSize    },
2400   {CC&quot;getVMPageSize&quot;,                    CC&quot;()I&quot;,                   (void*)&amp;WB_GetVMPageSize     },
2401   {CC&quot;getVMAllocationGranularity&quot;,       CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMAllocationGranularity },
2402   {CC&quot;getVMLargePageSize&quot;,               CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMLargePageSize},
2403   {CC&quot;getHeapSpaceAlignment&quot;,            CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapSpaceAlignment},
2404   {CC&quot;getHeapAlignment&quot;,                 CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapAlignment},
2405   {CC&quot;countAliveClasses0&quot;,               CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_CountAliveClasses },
2406   {CC&quot;getSymbolRefcount&quot;,                CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_GetSymbolRefcount },
2407   {CC&quot;parseCommandLine0&quot;,
2408       CC&quot;(Ljava/lang/String;C[Lsun/hotspot/parser/DiagnosticCommand;)[Ljava/lang/Object;&quot;,
2409       (void*) &amp;WB_ParseCommandLine
2410   },
2411   {CC&quot;addToBootstrapClassLoaderSearch0&quot;, CC&quot;(Ljava/lang/String;)V&quot;,
2412                                                       (void*)&amp;WB_AddToBootstrapClassLoaderSearch},
2413   {CC&quot;addToSystemClassLoaderSearch0&quot;,    CC&quot;(Ljava/lang/String;)V&quot;,
2414                                                       (void*)&amp;WB_AddToSystemClassLoaderSearch},
2415   {CC&quot;getCompressedOopsMaxHeapSize&quot;, CC&quot;()J&quot;,
2416       (void*)&amp;WB_GetCompressedOopsMaxHeapSize},
2417   {CC&quot;printHeapSizes&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_PrintHeapSizes    },
2418   {CC&quot;runMemoryUnitTests&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_RunMemoryUnitTests},
2419   {CC&quot;readFromNoaccessArea&quot;,CC&quot;()V&quot;,                  (void*)&amp;WB_ReadFromNoaccessArea},
2420   {CC&quot;stressVirtualSpaceResize&quot;,CC&quot;(JJJ)I&quot;,           (void*)&amp;WB_StressVirtualSpaceResize},
2421 #if INCLUDE_CDS
2422   {CC&quot;getOffsetForName0&quot;, CC&quot;(Ljava/lang/String;)I&quot;,  (void*)&amp;WB_GetOffsetForName},
2423 #endif
2424 #if INCLUDE_G1GC
2425   {CC&quot;g1InConcurrentMark&quot;, CC&quot;()Z&quot;,                   (void*)&amp;WB_G1InConcurrentMark},
2426   {CC&quot;g1IsHumongous0&quot;,      CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_G1IsHumongous     },
2427   {CC&quot;g1BelongsToHumongousRegion0&quot;, CC&quot;(J)Z&quot;,         (void*)&amp;WB_G1BelongsToHumongousRegion},
2428   {CC&quot;g1BelongsToFreeRegion0&quot;, CC&quot;(J)Z&quot;,              (void*)&amp;WB_G1BelongsToFreeRegion},
2429   {CC&quot;g1NumMaxRegions&quot;,    CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumMaxRegions  },
2430   {CC&quot;g1NumFreeRegions&quot;,   CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumFreeRegions  },
2431   {CC&quot;g1RegionSize&quot;,       CC&quot;()I&quot;,                   (void*)&amp;WB_G1RegionSize      },
2432   {CC&quot;g1StartConcMarkCycle&quot;,       CC&quot;()Z&quot;,           (void*)&amp;WB_G1StartMarkCycle  },
2433   {CC&quot;g1AuxiliaryMemoryUsage&quot;, CC&quot;()Ljava/lang/management/MemoryUsage;&quot;,
2434                                                       (void*)&amp;WB_G1AuxiliaryMemoryUsage  },
2435   {CC&quot;g1ActiveMemoryNodeCount&quot;, CC&quot;()I&quot;,              (void*)&amp;WB_G1ActiveMemoryNodeCount },
2436   {CC&quot;g1MemoryNodeIds&quot;,    CC&quot;()[I&quot;,                  (void*)&amp;WB_G1MemoryNodeIds },
2437   {CC&quot;g1GetMixedGCInfo&quot;,   CC&quot;(I)[J&quot;,                 (void*)&amp;WB_G1GetMixedGCInfo },
2438 #endif // INCLUDE_G1GC
2439 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
2440   {CC&quot;dramReservedStart&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedStart },
2441   {CC&quot;dramReservedEnd&quot;,     CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedEnd },
2442   {CC&quot;nvdimmReservedStart&quot;, CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedStart },
2443   {CC&quot;nvdimmReservedEnd&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedEnd },
2444 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
2445 #if INCLUDE_PARALLELGC
2446   {CC&quot;psVirtualSpaceAlignment&quot;,CC&quot;()J&quot;,               (void*)&amp;WB_PSVirtualSpaceAlignment},
2447   {CC&quot;psHeapGenerationAlignment&quot;,CC&quot;()J&quot;,             (void*)&amp;WB_PSHeapGenerationAlignment},
2448 #endif
2449 #if INCLUDE_NMT
2450   {CC&quot;NMTMalloc&quot;,           CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTMalloc          },
2451   {CC&quot;NMTMallocWithPseudoStack&quot;, CC&quot;(JI)J&quot;,           (void*)&amp;WB_NMTMallocWithPseudoStack},
2452   {CC&quot;NMTMallocWithPseudoStackAndType&quot;, CC&quot;(JII)J&quot;,   (void*)&amp;WB_NMTMallocWithPseudoStackAndType},
2453   {CC&quot;NMTFree&quot;,             CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFree            },
2454   {CC&quot;NMTReserveMemory&quot;,    CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTReserveMemory   },
2455   {CC&quot;NMTAttemptReserveMemoryAt&quot;,    CC&quot;(JJ)J&quot;,       (void*)&amp;WB_NMTAttemptReserveMemoryAt },
2456   {CC&quot;NMTCommitMemory&quot;,     CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTCommitMemory    },
2457   {CC&quot;NMTUncommitMemory&quot;,   CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTUncommitMemory  },
2458   {CC&quot;NMTReleaseMemory&quot;,    CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTReleaseMemory   },
2459   {CC&quot;NMTChangeTrackingLevel&quot;, CC&quot;()Z&quot;,               (void*)&amp;WB_NMTChangeTrackingLevel},
2460   {CC&quot;NMTGetHashSize&quot;,      CC&quot;()I&quot;,                  (void*)&amp;WB_NMTGetHashSize     },
2461   {CC&quot;NMTNewArena&quot;,         CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTNewArena        },
2462   {CC&quot;NMTFreeArena&quot;,        CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFreeArena       },
2463   {CC&quot;NMTArenaMalloc&quot;,      CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTArenaMalloc     },
2464 #endif // INCLUDE_NMT
2465   {CC&quot;deoptimizeFrames&quot;,   CC&quot;(Z)I&quot;,                  (void*)&amp;WB_DeoptimizeFrames  },
2466   {CC&quot;deoptimizeAll&quot;,      CC&quot;()V&quot;,                   (void*)&amp;WB_DeoptimizeAll     },
2467   {CC&quot;deoptimizeMethod0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,
2468                                                       (void*)&amp;WB_DeoptimizeMethod  },
2469   {CC&quot;isMethodCompiled0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,
2470                                                       (void*)&amp;WB_IsMethodCompiled  },
2471   {CC&quot;isMethodCompilable0&quot;, CC&quot;(Ljava/lang/reflect/Executable;IZ)Z&quot;,
2472                                                       (void*)&amp;WB_IsMethodCompilable},
2473   {CC&quot;isMethodQueuedForCompilation0&quot;,
2474       CC&quot;(Ljava/lang/reflect/Executable;)Z&quot;,          (void*)&amp;WB_IsMethodQueuedForCompilation},
2475   {CC&quot;isIntrinsicAvailable0&quot;,
2476       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/reflect/Executable;I)Z&quot;,
2477                                                       (void*)&amp;WB_IsIntrinsicAvailable},
2478   {CC&quot;makeMethodNotCompilable0&quot;,
2479       CC&quot;(Ljava/lang/reflect/Executable;IZ)V&quot;,        (void*)&amp;WB_MakeMethodNotCompilable},
2480   {CC&quot;testSetDontInlineMethod0&quot;,
2481       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetDontInlineMethod},
2482   {CC&quot;getMethodCompilationLevel0&quot;,
2483       CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,         (void*)&amp;WB_GetMethodCompilationLevel},
2484   {CC&quot;getMethodEntryBci0&quot;,
2485       CC&quot;(Ljava/lang/reflect/Executable;)I&quot;,          (void*)&amp;WB_GetMethodEntryBci},
2486   {CC&quot;getCompileQueueSize&quot;,
2487       CC&quot;(I)I&quot;,                                       (void*)&amp;WB_GetCompileQueueSize},
2488   {CC&quot;testSetForceInlineMethod0&quot;,
2489       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetForceInlineMethod},
2490   {CC&quot;enqueueMethodForCompilation0&quot;,
2491       CC&quot;(Ljava/lang/reflect/Executable;II)Z&quot;,        (void*)&amp;WB_EnqueueMethodForCompilation},
2492   {CC&quot;enqueueInitializerForCompilation0&quot;,
2493       CC&quot;(Ljava/lang/Class;I)Z&quot;,                      (void*)&amp;WB_EnqueueInitializerForCompilation},
2494   {CC&quot;markMethodProfiled&quot;,
2495       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_MarkMethodProfiled},
2496   {CC&quot;clearMethodState0&quot;,
2497       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_ClearMethodState},
2498   {CC&quot;lockCompilation&quot;,    CC&quot;()V&quot;,                   (void*)&amp;WB_LockCompilation},
2499   {CC&quot;unlockCompilation&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_UnlockCompilation},
2500   {CC&quot;matchesMethod&quot;,
2501       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2502                                                       (void*)&amp;WB_MatchesMethod},
2503   {CC&quot;matchesInline&quot;,
2504       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2505                                                       (void*)&amp;WB_MatchesInline},
2506   {CC&quot;shouldPrintAssembly&quot;,
2507         CC&quot;(Ljava/lang/reflect/Executable;I)Z&quot;,
2508                                                         (void*)&amp;WB_ShouldPrintAssembly},
2509 
2510   {CC&quot;isConstantVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsConstantVMFlag},
2511   {CC&quot;isLockedVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsLockedVMFlag},
2512   {CC&quot;setBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;Z)V&quot;,(void*)&amp;WB_SetBooleanVMFlag},
2513   {CC&quot;setIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntVMFlag},
2514   {CC&quot;setUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintVMFlag},
2515   {CC&quot;setIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntxVMFlag},
2516   {CC&quot;setUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintxVMFlag},
2517   {CC&quot;setUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUint64VMFlag},
2518   {CC&quot;setSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetSizeTVMFlag},
2519   {CC&quot;setDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;D)V&quot;,(void*)&amp;WB_SetDoubleVMFlag},
2520   {CC&quot;setStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;,
2521                                                       (void*)&amp;WB_SetStringVMFlag},
2522   {CC&quot;getBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2523                                                       (void*)&amp;WB_GetBooleanVMFlag},
2524   {CC&quot;getIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2525                                                       (void*)&amp;WB_GetIntVMFlag},
2526   {CC&quot;getUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2527                                                       (void*)&amp;WB_GetUintVMFlag},
2528   {CC&quot;getIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2529                                                       (void*)&amp;WB_GetIntxVMFlag},
2530   {CC&quot;getUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2531                                                       (void*)&amp;WB_GetUintxVMFlag},
2532   {CC&quot;getUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2533                                                       (void*)&amp;WB_GetUint64VMFlag},
2534   {CC&quot;getSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2535                                                       (void*)&amp;WB_GetSizeTVMFlag},
2536   {CC&quot;getDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Double;&quot;,
2537                                                       (void*)&amp;WB_GetDoubleVMFlag},
2538   {CC&quot;getStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;,
2539                                                       (void*)&amp;WB_GetStringVMFlag},
2540   {CC&quot;isInStringTable&quot;,    CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsInStringTable  },
2541   {CC&quot;fullGC&quot;,   CC&quot;()V&quot;,                             (void*)&amp;WB_FullGC },
2542   {CC&quot;youngGC&quot;,  CC&quot;()V&quot;,                             (void*)&amp;WB_YoungGC },
2543   {CC&quot;readReservedMemory&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_ReadReservedMemory },
2544   {CC&quot;allocateMetaspace&quot;,
2545      CC&quot;(Ljava/lang/ClassLoader;J)J&quot;,                 (void*)&amp;WB_AllocateMetaspace },
2546   {CC&quot;freeMetaspace&quot;,
2547      CC&quot;(Ljava/lang/ClassLoader;JJ)V&quot;,                (void*)&amp;WB_FreeMetaspace },
2548   {CC&quot;incMetaspaceCapacityUntilGC&quot;, CC&quot;(J)J&quot;,         (void*)&amp;WB_IncMetaspaceCapacityUntilGC },
2549   {CC&quot;metaspaceCapacityUntilGC&quot;, CC&quot;()J&quot;,             (void*)&amp;WB_MetaspaceCapacityUntilGC },
2550   {CC&quot;metaspaceReserveAlignment&quot;, CC&quot;()J&quot;,            (void*)&amp;WB_MetaspaceReserveAlignment },
2551   {CC&quot;getCPUFeatures&quot;,     CC&quot;()Ljava/lang/String;&quot;,  (void*)&amp;WB_GetCPUFeatures     },
2552   {CC&quot;getNMethod0&quot;,         CC&quot;(Ljava/lang/reflect/Executable;Z)[Ljava/lang/Object;&quot;,
2553                                                       (void*)&amp;WB_GetNMethod         },
2554   {CC&quot;forceNMethodSweep&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_ForceNMethodSweep  },
2555   {CC&quot;allocateCodeBlob&quot;,   CC&quot;(II)J&quot;,                 (void*)&amp;WB_AllocateCodeBlob   },
2556   {CC&quot;freeCodeBlob&quot;,       CC&quot;(J)V&quot;,                  (void*)&amp;WB_FreeCodeBlob       },
2557   {CC&quot;getCodeHeapEntries&quot;, CC&quot;(I)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeHeapEntries },
2558   {CC&quot;getCompilationActivityMode&quot;,
2559                            CC&quot;()I&quot;,                   (void*)&amp;WB_GetCompilationActivityMode},
2560   {CC&quot;getMethodData0&quot;,     CC&quot;(Ljava/lang/reflect/Executable;)J&quot;,
2561                                                       (void*)&amp;WB_GetMethodData      },
2562   {CC&quot;getCodeBlob&quot;,        CC&quot;(J)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeBlob        },
2563   {CC&quot;getThreadStackSize&quot;, CC&quot;()J&quot;,                   (void*)&amp;WB_GetThreadStackSize },
2564   {CC&quot;getThreadRemainingStackSize&quot;, CC&quot;()J&quot;,          (void*)&amp;WB_GetThreadRemainingStackSize },
2565   {CC&quot;DefineModule&quot;,       CC&quot;(Ljava/lang/Object;ZLjava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V&quot;,
2566                                                       (void*)&amp;WB_DefineModule },
2567   {CC&quot;AddModuleExports&quot;,   CC&quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,
2568                                                       (void*)&amp;WB_AddModuleExports },
2569   {CC&quot;AddReadsModule&quot;,     CC&quot;(Ljava/lang/Object;Ljava/lang/Object;)V&quot;,
2570                                                       (void*)&amp;WB_AddReadsModule },
2571   {CC&quot;AddModuleExportsToAllUnnamed&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2572                                                       (void*)&amp;WB_AddModuleExportsToAllUnnamed },
2573   {CC&quot;AddModuleExportsToAll&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2574                                                       (void*)&amp;WB_AddModuleExportsToAll },
2575   {CC&quot;assertMatchingSafepointCalls&quot;, CC&quot;(ZZ)V&quot;,       (void*)&amp;WB_AssertMatchingSafepointCalls },
2576   {CC&quot;assertSpecialLock&quot;,  CC&quot;(ZZ)V&quot;,                 (void*)&amp;WB_AssertSpecialLock },
2577   {CC&quot;isMonitorInflated0&quot;, CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsMonitorInflated  },
2578   {CC&quot;forceSafepoint&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_ForceSafepoint     },
2579   {CC&quot;getConstantPool0&quot;,   CC&quot;(Ljava/lang/Class;)J&quot;,  (void*)&amp;WB_GetConstantPool    },
2580   {CC&quot;getConstantPoolCacheIndexTag0&quot;, CC&quot;()I&quot;,  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
2581   {CC&quot;getConstantPoolCacheLength0&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,  (void*)&amp;WB_GetConstantPoolCacheLength},
2582   {CC&quot;remapInstructionOperandFromCPCache0&quot;,
2583       CC&quot;(Ljava/lang/Class;I)I&quot;,                      (void*)&amp;WB_ConstantPoolRemapInstructionOperandFromCache},
2584   {CC&quot;encodeConstantPoolIndyIndex0&quot;,
2585       CC&quot;(I)I&quot;,                      (void*)&amp;WB_ConstantPoolEncodeIndyIndex},
<a name="5" id="anc5"></a><span class="line-added">2586   {CC&quot;getObjectsViaKlassOopMaps0&quot;,</span>
<span class="line-added">2587       CC&quot;(Ljava/lang/Object;)[Ljava/lang/Object;&quot;,    (void*)&amp;WB_getObjectsViaKlassOopMaps},</span>
<span class="line-added">2588   {CC&quot;getObjectsViaOopIterator0&quot;,</span>
<span class="line-added">2589           CC&quot;(Ljava/lang/Object;)[Ljava/lang/Object;&quot;,(void*)&amp;WB_getObjectsViaOopIterator},</span>
<span class="line-added">2590   {CC&quot;getObjectsViaFrameOopIterator&quot;,</span>
<span class="line-added">2591       CC&quot;(I)[Ljava/lang/Object;&quot;,                     (void*)&amp;WB_getObjectsViaFrameOopIterator},</span>
2592   {CC&quot;getMethodBooleanOption&quot;,
2593       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2594                                                       (void*)&amp;WB_GetMethodBooleaneOption},
2595   {CC&quot;getMethodIntxOption&quot;,
2596       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2597                                                       (void*)&amp;WB_GetMethodIntxOption},
2598   {CC&quot;getMethodUintxOption&quot;,
2599       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2600                                                       (void*)&amp;WB_GetMethodUintxOption},
2601   {CC&quot;getMethodDoubleOption&quot;,
2602       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Double;&quot;,
2603                                                       (void*)&amp;WB_GetMethodDoubleOption},
2604   {CC&quot;getMethodStringOption&quot;,
2605       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/String;&quot;,
2606                                                       (void*)&amp;WB_GetMethodStringOption},
2607   {CC&quot;getDefaultArchivePath&quot;,             CC&quot;()Ljava/lang/String;&quot;,
2608                                                       (void*)&amp;WB_GetDefaultArchivePath},
2609   {CC&quot;isSharingEnabled&quot;,   CC&quot;()Z&quot;,                   (void*)&amp;WB_IsSharingEnabled},
2610   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2611   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
2612   {CC&quot;areSharedStringsIgnored&quot;,           CC&quot;()Z&quot;,    (void*)&amp;WB_AreSharedStringsIgnored },
2613   {CC&quot;getResolvedReferences&quot;, CC&quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, (void*)&amp;WB_GetResolvedReferences},
2614   {CC&quot;linkClass&quot;,          CC&quot;(Ljava/lang/Class;)V&quot;,  (void*)&amp;WB_LinkClass},
2615   {CC&quot;areOpenArchiveHeapObjectsMapped&quot;,   CC&quot;()Z&quot;,    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2616   {CC&quot;isCDSIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2617   {CC&quot;isJFRIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2618   {CC&quot;isC2OrJVMCIIncludedInVmBuild&quot;,      CC&quot;()Z&quot;,    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2619   {CC&quot;isJavaHeapArchiveSupported&quot;,        CC&quot;()Z&quot;,    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2620   {CC&quot;cdsMemoryMappingFailed&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_CDSMemoryMappingFailed },
2621 
2622   {CC&quot;clearInlineCaches0&quot;,  CC&quot;(Z)V&quot;,                 (void*)&amp;WB_ClearInlineCaches },
2623   {CC&quot;handshakeWalkStack&quot;, CC&quot;(Ljava/lang/Thread;Z)I&quot;, (void*)&amp;WB_HandshakeWalkStack },
2624   {CC&quot;checkThreadObjOfTerminatingThread&quot;, CC&quot;(Ljava/lang/Thread;)V&quot;, (void*)&amp;WB_CheckThreadObjOfTerminatingThread },
2625   {CC&quot;addCompilerDirective&quot;,    CC&quot;(Ljava/lang/String;)I&quot;,
2626                                                       (void*)&amp;WB_AddCompilerDirective },
2627   {CC&quot;removeCompilerDirective&quot;,   CC&quot;(I)V&quot;,           (void*)&amp;WB_RemoveCompilerDirective },
2628   {CC&quot;isGCSupported&quot;,             CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSupported},
2629   {CC&quot;isGCSelected&quot;,              CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSelected},
2630   {CC&quot;isGCSelectedErgonomically&quot;, CC&quot;()Z&quot;,            (void*)&amp;WB_IsGCSelectedErgonomically},
2631   {CC&quot;supportsConcurrentGCBreakpoints&quot;, CC&quot;()Z&quot;,      (void*)&amp;WB_SupportsConcurrentGCBreakpoints},
2632   {CC&quot;concurrentGCAcquireControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCAcquireControl},
2633   {CC&quot;concurrentGCReleaseControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCReleaseControl},
2634   {CC&quot;concurrentGCRunToIdle0&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_ConcurrentGCRunToIdle},
2635   {CC&quot;concurrentGCRunTo0&quot;,        CC&quot;(Ljava/lang/String;)Z&quot;,
2636                                                       (void*)&amp;WB_ConcurrentGCRunTo},
2637   {CC&quot;checkLibSpecifiesNoexecstack&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
2638                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2639   {CC&quot;isContainerized&quot;,           CC&quot;()Z&quot;,            (void*)&amp;WB_IsContainerized },
2640   {CC&quot;validateCgroup&quot;,
2641       CC&quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I&quot;,
2642                                                       (void*)&amp;WB_ValidateCgroup },
2643   {CC&quot;printOsInfo&quot;,               CC&quot;()V&quot;,            (void*)&amp;WB_PrintOsInfo },
2644   {CC&quot;disableElfSectionCache&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_DisableElfSectionCache },
2645   {CC&quot;resolvedMethodItemsCount&quot;,  CC&quot;()J&quot;,            (void*)&amp;WB_ResolvedMethodItemsCount },
2646   {CC&quot;protectionDomainRemovedCount&quot;,   CC&quot;()I&quot;,       (void*)&amp;WB_ProtectionDomainRemovedCount },
2647   {CC&quot;aotLibrariesCount&quot;, CC&quot;()I&quot;,                    (void*)&amp;WB_AotLibrariesCount },
2648   {CC&quot;getKlassMetadataSize&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,(void*)&amp;WB_GetKlassMetadataSize},
2649 };
2650 
2651 
2652 #undef CC
2653 
2654 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2655   {
2656     if (WhiteBoxAPI) {
2657       // Make sure that wbclass is loaded by the null classloader
2658       InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(wbclass)));
2659       Handle loader(THREAD, ik-&gt;class_loader());
2660       if (loader.is_null()) {
2661         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2662         WhiteBox::set_used();
2663       }
2664     }
2665   }
2666 JVM_END
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>