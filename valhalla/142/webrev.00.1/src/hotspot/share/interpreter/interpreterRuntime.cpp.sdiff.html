<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/interpreterRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="abstractInterpreter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRuntime.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/interpreterRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/symbolTable.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;code/codeCache.hpp&quot;
  31 #include &quot;compiler/compilationPolicy.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;gc/shared/barrierSetNMethod.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  38 #include &quot;interpreter/linkResolver.hpp&quot;
  39 #include &quot;interpreter/templateTable.hpp&quot;
  40 #include &quot;logging/log.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.hpp&quot;
  45 #include &quot;oops/cpCache.inline.hpp&quot;



  46 #include &quot;oops/instanceKlass.hpp&quot;
  47 #include &quot;oops/methodData.hpp&quot;
  48 #include &quot;oops/objArrayKlass.hpp&quot;
  49 #include &quot;oops/objArrayOop.inline.hpp&quot;
  50 #include &quot;oops/oop.inline.hpp&quot;
  51 #include &quot;oops/symbol.hpp&quot;
  52 #include &quot;prims/jvmtiExport.hpp&quot;
  53 #include &quot;prims/nativeLookup.hpp&quot;
  54 #include &quot;runtime/atomic.hpp&quot;
  55 #include &quot;runtime/biasedLocking.hpp&quot;
  56 #include &quot;runtime/deoptimization.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/icache.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  65 #include &quot;runtime/osThread.hpp&quot;
  66 #include &quot;runtime/sharedRuntime.hpp&quot;
  67 #include &quot;runtime/stubRoutines.hpp&quot;
  68 #include &quot;runtime/synchronizer.hpp&quot;
  69 #include &quot;runtime/threadCritical.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/copy.hpp&quot;
  72 #include &quot;utilities/events.hpp&quot;

  73 #ifdef COMPILER2
  74 #include &quot;opto/runtime.hpp&quot;
  75 #endif
  76 
  77 class UnlockFlagSaver {
  78   private:
  79     JavaThread* _thread;
  80     bool _do_not_unlock;
  81   public:
  82     UnlockFlagSaver(JavaThread* t) {
  83       _thread = t;
  84       _do_not_unlock = t-&gt;do_not_unlock_if_synchronized();
  85       t-&gt;set_do_not_unlock_if_synchronized(false);
  86     }
  87     ~UnlockFlagSaver() {
  88       _thread-&gt;set_do_not_unlock_if_synchronized(_do_not_unlock);
  89     }
  90 };
  91 
  92 // Helper class to access current interpreter state
</pre>
<hr />
<pre>
 213   thread-&gt;set_vm_result(result);
 214   if (!is_fast_aldc) {
 215     // Tell the interpreter how to unbox the primitive.
 216     guarantee(java_lang_boxing_object::is_instance(result, type), &quot;&quot;);
 217     int offset = java_lang_boxing_object::value_offset(type);
 218     intptr_t flags = ((as_TosState(type) &lt;&lt; ConstantPoolCacheEntry::tos_state_shift)
 219                       | (offset &amp; ConstantPoolCacheEntry::field_index_mask));
 220     thread-&gt;set_vm_result_2((Metadata*)flags);
 221   }
 222 }
 223 JRT_END
 224 
 225 
 226 //------------------------------------------------------------------------------------------------------------------------
 227 // Allocation
 228 
 229 JRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))
 230   Klass* k = pool-&gt;klass_at(index, CHECK);
 231   InstanceKlass* klass = InstanceKlass::cast(k);
 232 




 233   // Make sure we are not instantiating an abstract klass
 234   klass-&gt;check_valid_for_instantiation(true, CHECK);
 235 
 236   // Make sure klass is initialized
 237   klass-&gt;initialize(CHECK);
 238 
 239   // At this point the class may not be fully initialized
 240   // because of recursive initialization. If it is fully
 241   // initialized &amp; has_finalized is not set, we rewrite
 242   // it into its fast version (Note: no locking is needed
 243   // here since this is an atomic byte write and can be
 244   // done more than once).
 245   //
 246   // Note: In case of classes with has_finalized we don&#39;t
 247   //       rewrite since that saves us an extra check in
 248   //       the fast version which then would call the
 249   //       slow version anyway (and do a call back into
 250   //       Java).
 251   //       If we have a breakpoint, then we don&#39;t rewrite
 252   //       because the _breakpoint bytecode would be lost.
 253   oop obj = klass-&gt;allocate_instance(CHECK);
 254   thread-&gt;set_vm_result(obj);
 255 JRT_END
 256 



















































































































































































 257 
 258 JRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread* thread, BasicType type, jint size))
 259   oop obj = oopFactory::new_typeArray(type, size, CHECK);
 260   thread-&gt;set_vm_result(obj);
 261 JRT_END
 262 
 263 
 264 JRT_ENTRY(void, InterpreterRuntime::anewarray(JavaThread* thread, ConstantPool* pool, int index, jint size))
 265   Klass*    klass = pool-&gt;klass_at(index, CHECK);
<span class="line-modified"> 266   objArrayOop obj = oopFactory::new_objArray(klass, size, CHECK);</span>







 267   thread-&gt;set_vm_result(obj);
 268 JRT_END
 269 










 270 
 271 JRT_ENTRY(void, InterpreterRuntime::multianewarray(JavaThread* thread, jint* first_size_address))
 272   // We may want to pass in more arguments - could make this slightly faster
 273   LastFrameAccessor last_frame(thread);
 274   ConstantPool* constants = last_frame.method()-&gt;constants();
<span class="line-modified"> 275   int          i = last_frame.get_index_u2(Bytecodes::_multianewarray);</span>
<span class="line-modified"> 276   Klass* klass   = constants-&gt;klass_at(i, CHECK);</span>

 277   int   nof_dims = last_frame.number_of_dimensions();
 278   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 279   assert(nof_dims &gt;= 1, &quot;multianewarray rank must be nonzero&quot;);
 280 




 281   // We must create an array of jints to pass to multi_allocate.
 282   ResourceMark rm(thread);
 283   const int small_dims = 10;
 284   jint dim_array[small_dims];
 285   jint *dims = &amp;dim_array[0];
 286   if (nof_dims &gt; small_dims) {
 287     dims = (jint*) NEW_RESOURCE_ARRAY(jint, nof_dims);
 288   }
 289   for (int index = 0; index &lt; nof_dims; index++) {
 290     // offset from first_size_address is addressed as local[index]
 291     int n = Interpreter::local_offset_in_bytes(index)/jintSize;
 292     dims[index] = first_size_address[n];
 293   }
 294   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(nof_dims, dims, CHECK);
 295   thread-&gt;set_vm_result(obj);
 296 JRT_END
 297 
 298 
 299 JRT_ENTRY(void, InterpreterRuntime::register_finalizer(JavaThread* thread, oopDesc* obj))
 300   assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
 301   assert(obj-&gt;klass()-&gt;has_finalizer(), &quot;shouldn&#39;t be here otherwise&quot;);
 302   InstanceKlass::register_finalizer(instanceOop(obj), CHECK);
 303 JRT_END
 304 























 305 
 306 // Quicken instance-of and check-cast bytecodes
 307 JRT_ENTRY(void, InterpreterRuntime::quicken_io_cc(JavaThread* thread))
 308   // Force resolving; quicken the bytecode
 309   LastFrameAccessor last_frame(thread);
 310   int which = last_frame.get_index_u2(Bytecodes::_checkcast);
 311   ConstantPool* cpool = last_frame.method()-&gt;constants();
 312   // We&#39;d expect to assert that we&#39;re only here to quicken bytecodes, but in a multithreaded
 313   // program we might have seen an unquick&#39;d bytecode in the interpreter but have another
 314   // thread quicken the bytecode before we get here.
 315   // assert( cpool-&gt;tag_at(which).is_unresolved_klass(), &quot;should only come here to quicken bytecodes&quot; );
 316   Klass* klass = cpool-&gt;klass_at(which, CHECK);
 317   thread-&gt;set_vm_result_2(klass);
 318 JRT_END
 319 
 320 
 321 //------------------------------------------------------------------------------------------------------------------------
 322 // Exceptions
 323 
 324 void InterpreterRuntime::note_trap_inner(JavaThread* thread, int reason,
</pre>
<hr />
<pre>
 608 // and therefore we don&#39;t have the receiver object at our fingertips. (Though,
 609 // on some platforms the receiver still resides in a register...). Thus,
 610 // we have no choice but print an error message not containing the receiver
 611 // type.
 612 JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorWithMethod(JavaThread* thread,
 613                                                                         Method* missingMethod))
 614   ResourceMark rm(thread);
 615   assert(missingMethod != NULL, &quot;sanity&quot;);
 616   methodHandle m(thread, missingMethod);
 617   LinkResolver::throw_abstract_method_error(m, THREAD);
 618 JRT_END
 619 
 620 JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorVerbose(JavaThread* thread,
 621                                                                      Klass* recvKlass,
 622                                                                      Method* missingMethod))
 623   ResourceMark rm(thread);
 624   methodHandle mh = methodHandle(thread, missingMethod);
 625   LinkResolver::throw_abstract_method_error(mh, recvKlass, THREAD);
 626 JRT_END
 627 




 628 
 629 JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeError(JavaThread* thread))
 630   THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
 631 JRT_END
 632 
 633 JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose(JavaThread* thread,
 634                                                                               Klass* recvKlass,
 635                                                                               Klass* interfaceKlass))
 636   ResourceMark rm(thread);
 637   char buf[1000];
 638   buf[0] = &#39;\0&#39;;
 639   jio_snprintf(buf, sizeof(buf),
 640                &quot;Class %s does not implement the requested interface %s&quot;,
 641                recvKlass ? recvKlass-&gt;external_name() : &quot;NULL&quot;,
 642                interfaceKlass ? interfaceKlass-&gt;external_name() : &quot;NULL&quot;);
 643   THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 644 JRT_END
 645 
 646 //------------------------------------------------------------------------------------------------------------------------
 647 // Fields
 648 //
 649 
 650 void InterpreterRuntime::resolve_get_put(JavaThread* thread, Bytecodes::Code bytecode) {
 651   Thread* THREAD = thread;
 652   // resolve field
 653   fieldDescriptor info;
 654   LastFrameAccessor last_frame(thread);
 655   constantPoolHandle pool(thread, last_frame.method()-&gt;constants());
 656   methodHandle m(thread, last_frame.method());
 657   bool is_put    = (bytecode == Bytecodes::_putfield  || bytecode == Bytecodes::_nofast_putfield ||
<span class="line-modified"> 658                     bytecode == Bytecodes::_putstatic);</span>
 659   bool is_static = (bytecode == Bytecodes::_getstatic || bytecode == Bytecodes::_putstatic);

 660 
 661   {
 662     JvmtiHideSingleStepping jhss(thread);
 663     LinkResolver::resolve_field_access(info, pool, last_frame.get_index_u2_cpcache(bytecode),
 664                                        m, bytecode, CHECK);
 665   } // end JvmtiHideSingleStepping
 666 
 667   // check if link resolution caused cpCache to be updated
 668   ConstantPoolCacheEntry* cp_cache_entry = last_frame.cache_entry();
 669   if (cp_cache_entry-&gt;is_resolved(bytecode)) return;
 670 
 671   // compute auxiliary field attributes
 672   TosState state  = as_TosState(info.field_type());
 673 
 674   // Resolution of put instructions on final fields is delayed. That is required so that
 675   // exceptions are thrown at the correct place (when the instruction is actually invoked).
 676   // If we do not resolve an instruction in the current pass, leaving the put_code
 677   // set to zero will cause the next put instruction to the same field to reresolve.
 678 
 679   // Resolution of put instructions to final instance fields with invalid updates (i.e.,
</pre>
<hr />
<pre>
 683   // initializer method &lt;init&gt;. If resolution were not inhibited, a putfield
 684   // in an initializer method could be resolved in the initializer. Subsequent
 685   // putfield instructions to the same field would then use cached information.
 686   // As a result, those instructions would not pass through the VM. That is,
 687   // checks in resolve_field_access() would not be executed for those instructions
 688   // and the required IllegalAccessError would not be thrown.
 689   //
 690   // Also, we need to delay resolving getstatic and putstatic instructions until the
 691   // class is initialized.  This is required so that access to the static
 692   // field will call the initialization function every time until the class
 693   // is completely initialized ala. in 2.17.5 in JVM Specification.
 694   InstanceKlass* klass = info.field_holder();
 695   bool uninitialized_static = is_static &amp;&amp; !klass-&gt;is_initialized();
 696   bool has_initialized_final_update = info.field_holder()-&gt;major_version() &gt;= 53 &amp;&amp;
 697                                       info.has_initialized_final_update();
 698   assert(!(has_initialized_final_update &amp;&amp; !info.access_flags().is_final()), &quot;Fields with initialized final updates must be final&quot;);
 699 
 700   Bytecodes::Code get_code = (Bytecodes::Code)0;
 701   Bytecodes::Code put_code = (Bytecodes::Code)0;
 702   if (!uninitialized_static) {
<span class="line-modified"> 703     get_code = ((is_static) ? Bytecodes::_getstatic : Bytecodes::_getfield);</span>
<span class="line-modified"> 704     if ((is_put &amp;&amp; !has_initialized_final_update) || !info.access_flags().is_final()) {</span>
<span class="line-modified"> 705       put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);</span>






 706     }
 707   }
 708 
 709   cp_cache_entry-&gt;set_field(
 710     get_code,
 711     put_code,
 712     info.field_holder(),
 713     info.index(),
 714     info.offset(),
 715     state,
 716     info.access_flags().is_final(),
 717     info.access_flags().is_volatile(),


 718     pool-&gt;pool_holder()
 719   );
 720 }
 721 
 722 
 723 //------------------------------------------------------------------------------------------------------------------------
 724 // Synchronization
 725 //
 726 // The interpreter&#39;s synchronization code is factored out so that it can
 727 // be shared by method invocation and synchronized blocks.
 728 //%note synchronization_3
 729 
 730 //%note monitor_1
 731 JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))
 732 #ifdef ASSERT
 733   thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
 734 #endif
 735   if (PrintBiasedLockingStatistics) {
 736     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
 737   }
</pre>
<hr />
<pre>
 947   int index = last_frame.get_index_u4(bytecode);
 948   {
 949     JvmtiHideSingleStepping jhss(thread);
 950     LinkResolver::resolve_invoke(info, Handle(), pool,
 951                                  index, bytecode, CHECK);
 952   } // end JvmtiHideSingleStepping
 953 
 954   ConstantPoolCacheEntry* cp_cache_entry = pool-&gt;invokedynamic_cp_cache_entry_at(index);
 955   cp_cache_entry-&gt;set_dynamic_call(pool, info);
 956 }
 957 
 958 // This function is the interface to the assembly code. It returns the resolved
 959 // cpCache entry.  This doesn&#39;t safepoint, but the helper routines safepoint.
 960 // This function will check for redefinition!
 961 JRT_ENTRY(void, InterpreterRuntime::resolve_from_cache(JavaThread* thread, Bytecodes::Code bytecode)) {
 962   switch (bytecode) {
 963   case Bytecodes::_getstatic:
 964   case Bytecodes::_putstatic:
 965   case Bytecodes::_getfield:
 966   case Bytecodes::_putfield:

 967     resolve_get_put(thread, bytecode);
 968     break;
 969   case Bytecodes::_invokevirtual:
 970   case Bytecodes::_invokespecial:
 971   case Bytecodes::_invokestatic:
 972   case Bytecodes::_invokeinterface:
 973     resolve_invoke(thread, bytecode);
 974     break;
 975   case Bytecodes::_invokehandle:
 976     resolve_invokehandle(thread);
 977     break;
 978   case Bytecodes::_invokedynamic:
 979     resolve_invokedynamic(thread);
 980     break;
 981   default:
 982     fatal(&quot;unexpected bytecode: %s&quot;, Bytecodes::name(bytecode));
 983     break;
 984   }
 985 }
 986 JRT_END
</pre>
<hr />
<pre>
1173 
1174   if (JvmtiExport::should_post_single_step()) {
1175     // We are called during regular safepoints and when the VM is
1176     // single stepping. If any thread is marked for single stepping,
1177     // then we may have JVMTI work to do.
1178     LastFrameAccessor last_frame(thread);
1179     JvmtiExport::at_single_stepping_point(thread, last_frame.method(), last_frame.bcp());
1180   }
1181 JRT_END
1182 
1183 JRT_ENTRY(void, InterpreterRuntime::post_field_access(JavaThread *thread, oopDesc* obj,
1184 ConstantPoolCacheEntry *cp_entry))
1185 
1186   // check the access_flags for the field in the klass
1187 
1188   InstanceKlass* ik = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
1189   int index = cp_entry-&gt;field_index();
1190   if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_ACCESS_WATCHED) == 0) return;
1191 
1192   bool is_static = (obj == NULL);

1193   HandleMark hm(thread);
1194 
1195   Handle h_obj;
1196   if (!is_static) {
1197     // non-static field accessors have an object, but we need a handle
1198     h_obj = Handle(thread, obj);
1199   }
1200   InstanceKlass* cp_entry_f1 = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
<span class="line-modified">1201   jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry-&gt;f2_as_index(), is_static);</span>
1202   LastFrameAccessor last_frame(thread);
1203   JvmtiExport::post_field_access(thread, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);
1204 JRT_END
1205 
1206 JRT_ENTRY(void, InterpreterRuntime::post_field_modification(JavaThread *thread,
1207   oopDesc* obj, ConstantPoolCacheEntry *cp_entry, jvalue *value))
1208 
1209   Klass* k = cp_entry-&gt;f1_as_klass();
1210 
1211   // check the access_flags for the field in the klass
1212   InstanceKlass* ik = InstanceKlass::cast(k);
1213   int index = cp_entry-&gt;field_index();
1214   // bail out if field modifications are not watched
1215   if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_MODIFICATION_WATCHED) == 0) return;
1216 
1217   char sig_type = &#39;\0&#39;;
1218 
1219   switch(cp_entry-&gt;flag_state()) {
1220     case btos: sig_type = JVM_SIGNATURE_BYTE;    break;
1221     case ztos: sig_type = JVM_SIGNATURE_BOOLEAN; break;
1222     case ctos: sig_type = JVM_SIGNATURE_CHAR;    break;
1223     case stos: sig_type = JVM_SIGNATURE_SHORT;   break;
1224     case itos: sig_type = JVM_SIGNATURE_INT;     break;
1225     case ftos: sig_type = JVM_SIGNATURE_FLOAT;   break;
1226     case atos: sig_type = JVM_SIGNATURE_CLASS;   break;
1227     case ltos: sig_type = JVM_SIGNATURE_LONG;    break;
1228     case dtos: sig_type = JVM_SIGNATURE_DOUBLE;  break;
1229     default:  ShouldNotReachHere(); return;
1230   }






1231   bool is_static = (obj == NULL);

1232 
1233   HandleMark hm(thread);
<span class="line-modified">1234   jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry-&gt;f2_as_index(), is_static);</span>
1235   jvalue fvalue;
1236 #ifdef _LP64
1237   fvalue = *value;
1238 #else
1239   // Long/double values are stored unaligned and also noncontiguously with
1240   // tagged stacks.  We can&#39;t just do a simple assignment even in the non-
1241   // J/D cases because a C++ compiler is allowed to assume that a jvalue is
1242   // 8-byte aligned, and interpreter stack slots are only 4-byte aligned.
1243   // We assume that the two halves of longs/doubles are stored in interpreter
1244   // stack slots in platform-endian order.
1245   jlong_accessor u;
1246   jint* newval = (jint*)value;
1247   u.words[0] = newval[0];
1248   u.words[1] = newval[Interpreter::stackElementWords]; // skip if tag
1249   fvalue.j = u.long_value;
1250 #endif // _LP64
1251 
1252   Handle h_obj;
1253   if (!is_static) {
1254     // non-static field accessors have an object, but we need a handle
</pre>
</td>
<td>
<hr />
<pre>
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/symbolTable.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;code/codeCache.hpp&quot;
  31 #include &quot;compiler/compilationPolicy.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;gc/shared/barrierSetNMethod.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  38 #include &quot;interpreter/linkResolver.hpp&quot;
  39 #include &quot;interpreter/templateTable.hpp&quot;
  40 #include &quot;logging/log.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.hpp&quot;
  45 #include &quot;oops/cpCache.inline.hpp&quot;
<span class="line-added">  46 #include &quot;oops/flatArrayKlass.hpp&quot;</span>
<span class="line-added">  47 #include &quot;oops/flatArrayOop.inline.hpp&quot;</span>
<span class="line-added">  48 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
  49 #include &quot;oops/instanceKlass.hpp&quot;
  50 #include &quot;oops/methodData.hpp&quot;
  51 #include &quot;oops/objArrayKlass.hpp&quot;
  52 #include &quot;oops/objArrayOop.inline.hpp&quot;
  53 #include &quot;oops/oop.inline.hpp&quot;
  54 #include &quot;oops/symbol.hpp&quot;
  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/nativeLookup.hpp&quot;
  57 #include &quot;runtime/atomic.hpp&quot;
  58 #include &quot;runtime/biasedLocking.hpp&quot;
  59 #include &quot;runtime/deoptimization.hpp&quot;
  60 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  61 #include &quot;runtime/frame.inline.hpp&quot;
  62 #include &quot;runtime/handles.inline.hpp&quot;
  63 #include &quot;runtime/icache.hpp&quot;
  64 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  65 #include &quot;runtime/java.hpp&quot;
  66 #include &quot;runtime/javaCalls.hpp&quot;
  67 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  68 #include &quot;runtime/osThread.hpp&quot;
  69 #include &quot;runtime/sharedRuntime.hpp&quot;
  70 #include &quot;runtime/stubRoutines.hpp&quot;
  71 #include &quot;runtime/synchronizer.hpp&quot;
  72 #include &quot;runtime/threadCritical.hpp&quot;
  73 #include &quot;utilities/align.hpp&quot;
  74 #include &quot;utilities/copy.hpp&quot;
  75 #include &quot;utilities/events.hpp&quot;
<span class="line-added">  76 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  77 #ifdef COMPILER2
  78 #include &quot;opto/runtime.hpp&quot;
  79 #endif
  80 
  81 class UnlockFlagSaver {
  82   private:
  83     JavaThread* _thread;
  84     bool _do_not_unlock;
  85   public:
  86     UnlockFlagSaver(JavaThread* t) {
  87       _thread = t;
  88       _do_not_unlock = t-&gt;do_not_unlock_if_synchronized();
  89       t-&gt;set_do_not_unlock_if_synchronized(false);
  90     }
  91     ~UnlockFlagSaver() {
  92       _thread-&gt;set_do_not_unlock_if_synchronized(_do_not_unlock);
  93     }
  94 };
  95 
  96 // Helper class to access current interpreter state
</pre>
<hr />
<pre>
 217   thread-&gt;set_vm_result(result);
 218   if (!is_fast_aldc) {
 219     // Tell the interpreter how to unbox the primitive.
 220     guarantee(java_lang_boxing_object::is_instance(result, type), &quot;&quot;);
 221     int offset = java_lang_boxing_object::value_offset(type);
 222     intptr_t flags = ((as_TosState(type) &lt;&lt; ConstantPoolCacheEntry::tos_state_shift)
 223                       | (offset &amp; ConstantPoolCacheEntry::field_index_mask));
 224     thread-&gt;set_vm_result_2((Metadata*)flags);
 225   }
 226 }
 227 JRT_END
 228 
 229 
 230 //------------------------------------------------------------------------------------------------------------------------
 231 // Allocation
 232 
 233 JRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))
 234   Klass* k = pool-&gt;klass_at(index, CHECK);
 235   InstanceKlass* klass = InstanceKlass::cast(k);
 236 
<span class="line-added"> 237   if (klass-&gt;is_inline_klass()) {</span>
<span class="line-added"> 238     THROW(vmSymbols::java_lang_InstantiationError());</span>
<span class="line-added"> 239   }</span>
<span class="line-added"> 240 </span>
 241   // Make sure we are not instantiating an abstract klass
 242   klass-&gt;check_valid_for_instantiation(true, CHECK);
 243 
 244   // Make sure klass is initialized
 245   klass-&gt;initialize(CHECK);
 246 
 247   // At this point the class may not be fully initialized
 248   // because of recursive initialization. If it is fully
 249   // initialized &amp; has_finalized is not set, we rewrite
 250   // it into its fast version (Note: no locking is needed
 251   // here since this is an atomic byte write and can be
 252   // done more than once).
 253   //
 254   // Note: In case of classes with has_finalized we don&#39;t
 255   //       rewrite since that saves us an extra check in
 256   //       the fast version which then would call the
 257   //       slow version anyway (and do a call back into
 258   //       Java).
 259   //       If we have a breakpoint, then we don&#39;t rewrite
 260   //       because the _breakpoint bytecode would be lost.
 261   oop obj = klass-&gt;allocate_instance(CHECK);
 262   thread-&gt;set_vm_result(obj);
 263 JRT_END
 264 
<span class="line-added"> 265 void copy_primitive_argument(intptr_t* addr, Handle instance, int offset, BasicType type) {</span>
<span class="line-added"> 266   switch (type) {</span>
<span class="line-added"> 267   case T_BOOLEAN:</span>
<span class="line-added"> 268     instance()-&gt;bool_field_put(offset, (jboolean)*((int*)addr));</span>
<span class="line-added"> 269     break;</span>
<span class="line-added"> 270   case T_CHAR:</span>
<span class="line-added"> 271     instance()-&gt;char_field_put(offset, (jchar) *((int*)addr));</span>
<span class="line-added"> 272     break;</span>
<span class="line-added"> 273   case T_FLOAT:</span>
<span class="line-added"> 274     instance()-&gt;float_field_put(offset, (jfloat)*((float*)addr));</span>
<span class="line-added"> 275     break;</span>
<span class="line-added"> 276   case T_DOUBLE:</span>
<span class="line-added"> 277     instance()-&gt;double_field_put(offset, (jdouble)*((double*)addr));</span>
<span class="line-added"> 278     break;</span>
<span class="line-added"> 279   case T_BYTE:</span>
<span class="line-added"> 280     instance()-&gt;byte_field_put(offset, (jbyte)*((int*)addr));</span>
<span class="line-added"> 281     break;</span>
<span class="line-added"> 282   case T_SHORT:</span>
<span class="line-added"> 283     instance()-&gt;short_field_put(offset, (jshort)*((int*)addr));</span>
<span class="line-added"> 284     break;</span>
<span class="line-added"> 285   case T_INT:</span>
<span class="line-added"> 286     instance()-&gt;int_field_put(offset, (jint)*((int*)addr));</span>
<span class="line-added"> 287     break;</span>
<span class="line-added"> 288   case T_LONG:</span>
<span class="line-added"> 289     instance()-&gt;long_field_put(offset, (jlong)*((long long*)addr));</span>
<span class="line-added"> 290     break;</span>
<span class="line-added"> 291   case T_OBJECT:</span>
<span class="line-added"> 292   case T_ARRAY:</span>
<span class="line-added"> 293   case T_INLINE_TYPE:</span>
<span class="line-added"> 294     fatal(&quot;Should not be handled with this method&quot;);</span>
<span class="line-added"> 295     break;</span>
<span class="line-added"> 296   default:</span>
<span class="line-added"> 297     fatal(&quot;Unsupported BasicType&quot;);</span>
<span class="line-added"> 298   }</span>
<span class="line-added"> 299 }</span>
<span class="line-added"> 300 </span>
<span class="line-added"> 301 JRT_ENTRY(void, InterpreterRuntime::defaultvalue(JavaThread* thread, ConstantPool* pool, int index))</span>
<span class="line-added"> 302   // Getting the InlineKlass</span>
<span class="line-added"> 303   Klass* k = pool-&gt;klass_at(index, CHECK);</span>
<span class="line-added"> 304   if (!k-&gt;is_inline_klass()) {</span>
<span class="line-added"> 305     // inconsistency with &#39;new&#39; which throws an InstantiationError</span>
<span class="line-added"> 306     // in the future, defaultvalue will just return null instead of throwing an exception</span>
<span class="line-added"> 307     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added"> 308   }</span>
<span class="line-added"> 309   assert(k-&gt;is_inline_klass(), &quot;defaultvalue argument must be the inline type class&quot;);</span>
<span class="line-added"> 310   InlineKlass* vklass = InlineKlass::cast(k);</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312   vklass-&gt;initialize(THREAD);</span>
<span class="line-added"> 313   oop res = vklass-&gt;default_value();</span>
<span class="line-added"> 314   thread-&gt;set_vm_result(res);</span>
<span class="line-added"> 315 JRT_END</span>
<span class="line-added"> 316 </span>
<span class="line-added"> 317 JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* thread, ConstantPoolCache* cp_cache))</span>
<span class="line-added"> 318   LastFrameAccessor last_frame(thread);</span>
<span class="line-added"> 319   // Getting the InlineKlass</span>
<span class="line-added"> 320   int index = ConstantPool::decode_cpcache_index(last_frame.get_index_u2_cpcache(Bytecodes::_withfield));</span>
<span class="line-added"> 321   ConstantPoolCacheEntry* cp_entry = cp_cache-&gt;entry_at(index);</span>
<span class="line-added"> 322   assert(cp_entry-&gt;is_resolved(Bytecodes::_withfield), &quot;Should have been resolved&quot;);</span>
<span class="line-added"> 323   Klass* klass = cp_entry-&gt;f1_as_klass();</span>
<span class="line-added"> 324   assert(klass-&gt;is_inline_klass(), &quot;withfield only applies to inline types&quot;);</span>
<span class="line-added"> 325   InlineKlass* vklass = InlineKlass::cast(klass);</span>
<span class="line-added"> 326 </span>
<span class="line-added"> 327   // Getting Field information</span>
<span class="line-added"> 328   int offset = cp_entry-&gt;f2_as_index();</span>
<span class="line-added"> 329   int field_index = cp_entry-&gt;field_index();</span>
<span class="line-added"> 330   int field_offset = cp_entry-&gt;f2_as_offset();</span>
<span class="line-added"> 331   Symbol* field_signature = vklass-&gt;field_signature(field_index);</span>
<span class="line-added"> 332   BasicType field_type = Signature::basic_type(field_signature);</span>
<span class="line-added"> 333   int return_offset = (type2size[field_type] + type2size[T_OBJECT]) * AbstractInterpreter::stackElementSize;</span>
<span class="line-added"> 334 </span>
<span class="line-added"> 335   // Getting old value</span>
<span class="line-added"> 336   frame&amp; f = last_frame.get_frame();</span>
<span class="line-added"> 337   jint tos_idx = f.interpreter_frame_expression_stack_size() - 1;</span>
<span class="line-added"> 338   int vt_offset = type2size[field_type];</span>
<span class="line-added"> 339   oop old_value = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx - vt_offset);</span>
<span class="line-added"> 340   assert(old_value != NULL &amp;&amp; oopDesc::is_oop(old_value) &amp;&amp; old_value-&gt;is_inline_type(),&quot;Verifying receiver&quot;);</span>
<span class="line-added"> 341   Handle old_value_h(THREAD, old_value);</span>
<span class="line-added"> 342 </span>
<span class="line-added"> 343   // Creating new value by copying the one passed in argument</span>
<span class="line-added"> 344   instanceOop new_value = vklass-&gt;allocate_instance_buffer(</span>
<span class="line-added"> 345       CHECK_((type2size[field_type]) * AbstractInterpreter::stackElementSize));</span>
<span class="line-added"> 346   Handle new_value_h = Handle(THREAD, new_value);</span>
<span class="line-added"> 347   vklass-&gt;inline_copy_oop_to_new_oop(old_value_h(), new_value_h());</span>
<span class="line-added"> 348 </span>
<span class="line-added"> 349   // Updating the field specified in arguments</span>
<span class="line-added"> 350   if (field_type == T_ARRAY || field_type == T_OBJECT) {</span>
<span class="line-added"> 351     oop aoop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);</span>
<span class="line-added"> 352     assert(aoop == NULL || oopDesc::is_oop(aoop),&quot;argument must be a reference type&quot;);</span>
<span class="line-added"> 353     new_value_h()-&gt;obj_field_put(field_offset, aoop);</span>
<span class="line-added"> 354   } else if (field_type == T_INLINE_TYPE) {</span>
<span class="line-added"> 355     if (cp_entry-&gt;is_inlined()) {</span>
<span class="line-added"> 356       oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);</span>
<span class="line-added"> 357       assert(vt_oop != NULL &amp;&amp; oopDesc::is_oop(vt_oop) &amp;&amp; vt_oop-&gt;is_inline_type(),&quot;argument must be an inline type&quot;);</span>
<span class="line-added"> 358       InlineKlass* field_vk = InlineKlass::cast(vklass-&gt;get_inline_type_field_klass(field_index));</span>
<span class="line-added"> 359       assert(vt_oop != NULL &amp;&amp; field_vk == vt_oop-&gt;klass(), &quot;Must match&quot;);</span>
<span class="line-added"> 360       field_vk-&gt;write_inlined_field(new_value_h(), offset, vt_oop, CHECK_(return_offset));</span>
<span class="line-added"> 361     } else { // not inlined</span>
<span class="line-added"> 362       oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);</span>
<span class="line-added"> 363       if (voop == NULL &amp;&amp; cp_entry-&gt;is_inline_type()) {</span>
<span class="line-added"> 364         THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);</span>
<span class="line-added"> 365       }</span>
<span class="line-added"> 366       assert(voop == NULL || oopDesc::is_oop(voop),&quot;checking argument&quot;);</span>
<span class="line-added"> 367       new_value_h()-&gt;obj_field_put(field_offset, voop);</span>
<span class="line-added"> 368     }</span>
<span class="line-added"> 369   } else { // not T_OBJECT nor T_ARRAY nor T_INLINE_TYPE</span>
<span class="line-added"> 370     intptr_t* addr = f.interpreter_frame_expression_stack_at(tos_idx);</span>
<span class="line-added"> 371     copy_primitive_argument(addr, new_value_h, field_offset, field_type);</span>
<span class="line-added"> 372   }</span>
<span class="line-added"> 373 </span>
<span class="line-added"> 374   // returning result</span>
<span class="line-added"> 375   thread-&gt;set_vm_result(new_value_h());</span>
<span class="line-added"> 376   return return_offset;</span>
<span class="line-added"> 377 JRT_END</span>
<span class="line-added"> 378 </span>
<span class="line-added"> 379 JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_inline_type_field(JavaThread* thread, oopDesc* mirror, int index))</span>
<span class="line-added"> 380   // The interpreter tries to access an inline static field that has not been initialized.</span>
<span class="line-added"> 381   // This situation can happen in different scenarios:</span>
<span class="line-added"> 382   //   1 - if the load or initialization of the field failed during step 8 of</span>
<span class="line-added"> 383   //       the initialization of the holder of the field, in this case the access to the field</span>
<span class="line-added"> 384   //       must fail</span>
<span class="line-added"> 385   //   2 - it can also happen when the initialization of the holder class triggered the initialization of</span>
<span class="line-added"> 386   //       another class which accesses this field in its static initializer, in this case the</span>
<span class="line-added"> 387   //       access must succeed to allow circularity</span>
<span class="line-added"> 388   // The code below tries to load and initialize the field&#39;s class again before returning the default value.</span>
<span class="line-added"> 389   // If the field was not initialized because of an error, a exception should be thrown.</span>
<span class="line-added"> 390   // If the class is being initialized, the default value is returned.</span>
<span class="line-added"> 391   instanceHandle mirror_h(THREAD, (instanceOop)mirror);</span>
<span class="line-added"> 392   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));</span>
<span class="line-added"> 393   if (klass-&gt;is_being_initialized() &amp;&amp; klass-&gt;is_reentrant_initialization(THREAD)) {</span>
<span class="line-added"> 394     int offset = klass-&gt;field_offset(index);</span>
<span class="line-added"> 395     Klass* field_k = klass-&gt;get_inline_type_field_klass_or_null(index);</span>
<span class="line-added"> 396     if (field_k == NULL) {</span>
<span class="line-added"> 397       field_k = SystemDictionary::resolve_or_fail(klass-&gt;field_signature(index)-&gt;fundamental_name(THREAD),</span>
<span class="line-added"> 398           Handle(THREAD, klass-&gt;class_loader()),</span>
<span class="line-added"> 399           Handle(THREAD, klass-&gt;protection_domain()),</span>
<span class="line-added"> 400           true, CHECK);</span>
<span class="line-added"> 401       assert(field_k != NULL, &quot;Should have been loaded or an exception thrown above&quot;);</span>
<span class="line-added"> 402       klass-&gt;set_inline_type_field_klass(index, field_k);</span>
<span class="line-added"> 403     }</span>
<span class="line-added"> 404     field_k-&gt;initialize(CHECK);</span>
<span class="line-added"> 405     oop defaultvalue = InlineKlass::cast(field_k)-&gt;default_value();</span>
<span class="line-added"> 406     // It is safe to initialized the static field because 1) the current thread is the initializing thread</span>
<span class="line-added"> 407     // and is the only one that can access it, and 2) the field is actually not initialized (i.e. null)</span>
<span class="line-added"> 408     // otherwise the JVM should not be executing this code.</span>
<span class="line-added"> 409     mirror-&gt;obj_field_put(offset, defaultvalue);</span>
<span class="line-added"> 410     thread-&gt;set_vm_result(defaultvalue);</span>
<span class="line-added"> 411   } else {</span>
<span class="line-added"> 412     assert(klass-&gt;is_in_error_state(), &quot;If not initializing, initialization must have failed to get there&quot;);</span>
<span class="line-added"> 413     ResourceMark rm(THREAD);</span>
<span class="line-added"> 414     const char* desc = &quot;Could not initialize class &quot;;</span>
<span class="line-added"> 415     const char* className = klass-&gt;external_name();</span>
<span class="line-added"> 416     size_t msglen = strlen(desc) + strlen(className) + 1;</span>
<span class="line-added"> 417     char* message = NEW_RESOURCE_ARRAY(char, msglen);</span>
<span class="line-added"> 418     if (NULL == message) {</span>
<span class="line-added"> 419       // Out of memory: can&#39;t create detailed error message</span>
<span class="line-added"> 420       THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), className);</span>
<span class="line-added"> 421     } else {</span>
<span class="line-added"> 422       jio_snprintf(message, msglen, &quot;%s%s&quot;, desc, className);</span>
<span class="line-added"> 423       THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), message);</span>
<span class="line-added"> 424     }</span>
<span class="line-added"> 425   }</span>
<span class="line-added"> 426 JRT_END</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428 JRT_ENTRY(void, InterpreterRuntime::read_inlined_field(JavaThread* thread, oopDesc* obj, int index, Klass* field_holder))</span>
<span class="line-added"> 429   Handle obj_h(THREAD, obj);</span>
<span class="line-added"> 430 </span>
<span class="line-added"> 431   assert(oopDesc::is_oop(obj), &quot;Sanity check&quot;);</span>
<span class="line-added"> 432 </span>
<span class="line-added"> 433   assert(field_holder-&gt;is_instance_klass(), &quot;Sanity check&quot;);</span>
<span class="line-added"> 434   InstanceKlass* klass = InstanceKlass::cast(field_holder);</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436   assert(klass-&gt;field_is_inlined(index), &quot;Sanity check&quot;);</span>
<span class="line-added"> 437 </span>
<span class="line-added"> 438   InlineKlass* field_vklass = InlineKlass::cast(klass-&gt;get_inline_type_field_klass(index));</span>
<span class="line-added"> 439   assert(field_vklass-&gt;is_initialized(), &quot;Must be initialized at this point&quot;);</span>
<span class="line-added"> 440 </span>
<span class="line-added"> 441   oop res = field_vklass-&gt;read_inlined_field(obj_h(), klass-&gt;field_offset(index), CHECK);</span>
<span class="line-added"> 442   thread-&gt;set_vm_result(res);</span>
<span class="line-added"> 443 JRT_END</span>
 444 
 445 JRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread* thread, BasicType type, jint size))
 446   oop obj = oopFactory::new_typeArray(type, size, CHECK);
 447   thread-&gt;set_vm_result(obj);
 448 JRT_END
 449 
 450 
 451 JRT_ENTRY(void, InterpreterRuntime::anewarray(JavaThread* thread, ConstantPool* pool, int index, jint size))
 452   Klass*    klass = pool-&gt;klass_at(index, CHECK);
<span class="line-modified"> 453   bool      is_qtype_desc = pool-&gt;tag_at(index).is_Qdescriptor_klass();</span>
<span class="line-added"> 454   arrayOop obj;</span>
<span class="line-added"> 455   if ((!klass-&gt;is_array_klass()) &amp;&amp; is_qtype_desc) { // Logically creates elements, ensure klass init</span>
<span class="line-added"> 456     klass-&gt;initialize(CHECK);</span>
<span class="line-added"> 457     obj = oopFactory::new_flatArray(klass, size, CHECK);</span>
<span class="line-added"> 458   } else {</span>
<span class="line-added"> 459     obj = oopFactory::new_objArray(klass, size, CHECK);</span>
<span class="line-added"> 460   }</span>
 461   thread-&gt;set_vm_result(obj);
 462 JRT_END
 463 
<span class="line-added"> 464 JRT_ENTRY(void, InterpreterRuntime::value_array_load(JavaThread* thread, arrayOopDesc* array, int index))</span>
<span class="line-added"> 465   flatArrayHandle vah(thread, (flatArrayOop)array);</span>
<span class="line-added"> 466   oop value_holder = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);</span>
<span class="line-added"> 467   thread-&gt;set_vm_result(value_holder);</span>
<span class="line-added"> 468 JRT_END</span>
<span class="line-added"> 469 </span>
<span class="line-added"> 470 JRT_ENTRY(void, InterpreterRuntime::value_array_store(JavaThread* thread, void* val, arrayOopDesc* array, int index))</span>
<span class="line-added"> 471   assert(val != NULL, &quot;can&#39;t store null into flat array&quot;);</span>
<span class="line-added"> 472   ((flatArrayOop)array)-&gt;value_copy_to_index((oop)val, index);</span>
<span class="line-added"> 473 JRT_END</span>
 474 
 475 JRT_ENTRY(void, InterpreterRuntime::multianewarray(JavaThread* thread, jint* first_size_address))
 476   // We may want to pass in more arguments - could make this slightly faster
 477   LastFrameAccessor last_frame(thread);
 478   ConstantPool* constants = last_frame.method()-&gt;constants();
<span class="line-modified"> 479   int i = last_frame.get_index_u2(Bytecodes::_multianewarray);</span>
<span class="line-modified"> 480   Klass* klass = constants-&gt;klass_at(i, CHECK);</span>
<span class="line-added"> 481   bool is_qtype = klass-&gt;name()-&gt;is_Q_array_signature();</span>
 482   int   nof_dims = last_frame.number_of_dimensions();
 483   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 484   assert(nof_dims &gt;= 1, &quot;multianewarray rank must be nonzero&quot;);
 485 
<span class="line-added"> 486   if (is_qtype) { // Logically creates elements, ensure klass init</span>
<span class="line-added"> 487     klass-&gt;initialize(CHECK);</span>
<span class="line-added"> 488   }</span>
<span class="line-added"> 489 </span>
 490   // We must create an array of jints to pass to multi_allocate.
 491   ResourceMark rm(thread);
 492   const int small_dims = 10;
 493   jint dim_array[small_dims];
 494   jint *dims = &amp;dim_array[0];
 495   if (nof_dims &gt; small_dims) {
 496     dims = (jint*) NEW_RESOURCE_ARRAY(jint, nof_dims);
 497   }
 498   for (int index = 0; index &lt; nof_dims; index++) {
 499     // offset from first_size_address is addressed as local[index]
 500     int n = Interpreter::local_offset_in_bytes(index)/jintSize;
 501     dims[index] = first_size_address[n];
 502   }
 503   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(nof_dims, dims, CHECK);
 504   thread-&gt;set_vm_result(obj);
 505 JRT_END
 506 
 507 
 508 JRT_ENTRY(void, InterpreterRuntime::register_finalizer(JavaThread* thread, oopDesc* obj))
 509   assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
 510   assert(obj-&gt;klass()-&gt;has_finalizer(), &quot;shouldn&#39;t be here otherwise&quot;);
 511   InstanceKlass::register_finalizer(instanceOop(obj), CHECK);
 512 JRT_END
 513 
<span class="line-added"> 514 JRT_ENTRY(jboolean, InterpreterRuntime::is_substitutable(JavaThread* thread, oopDesc* aobj, oopDesc* bobj))</span>
<span class="line-added"> 515   assert(oopDesc::is_oop(aobj) &amp;&amp; oopDesc::is_oop(bobj), &quot;must be valid oops&quot;);</span>
<span class="line-added"> 516 </span>
<span class="line-added"> 517   Handle ha(THREAD, aobj);</span>
<span class="line-added"> 518   Handle hb(THREAD, bobj);</span>
<span class="line-added"> 519   JavaValue result(T_BOOLEAN);</span>
<span class="line-added"> 520   JavaCallArguments args;</span>
<span class="line-added"> 521   args.push_oop(ha);</span>
<span class="line-added"> 522   args.push_oop(hb);</span>
<span class="line-added"> 523   methodHandle method(thread, Universe::is_substitutable_method());</span>
<span class="line-added"> 524   JavaCalls::call(&amp;result, method, &amp;args, THREAD);</span>
<span class="line-added"> 525   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added"> 526     // Something really bad happened because isSubstitutable() should not throw exceptions</span>
<span class="line-added"> 527     // If it is an error, just let it propagate</span>
<span class="line-added"> 528     // If it is an exception, wrap it into an InternalError</span>
<span class="line-added"> 529     if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::Error_klass())) {</span>
<span class="line-added"> 530       Handle e(THREAD, PENDING_EXCEPTION);</span>
<span class="line-added"> 531       CLEAR_PENDING_EXCEPTION;</span>
<span class="line-added"> 532       THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), &quot;Internal error in substitutability test&quot;, e, false);</span>
<span class="line-added"> 533     }</span>
<span class="line-added"> 534   }</span>
<span class="line-added"> 535   return result.get_jboolean();</span>
<span class="line-added"> 536 JRT_END</span>
 537 
 538 // Quicken instance-of and check-cast bytecodes
 539 JRT_ENTRY(void, InterpreterRuntime::quicken_io_cc(JavaThread* thread))
 540   // Force resolving; quicken the bytecode
 541   LastFrameAccessor last_frame(thread);
 542   int which = last_frame.get_index_u2(Bytecodes::_checkcast);
 543   ConstantPool* cpool = last_frame.method()-&gt;constants();
 544   // We&#39;d expect to assert that we&#39;re only here to quicken bytecodes, but in a multithreaded
 545   // program we might have seen an unquick&#39;d bytecode in the interpreter but have another
 546   // thread quicken the bytecode before we get here.
 547   // assert( cpool-&gt;tag_at(which).is_unresolved_klass(), &quot;should only come here to quicken bytecodes&quot; );
 548   Klass* klass = cpool-&gt;klass_at(which, CHECK);
 549   thread-&gt;set_vm_result_2(klass);
 550 JRT_END
 551 
 552 
 553 //------------------------------------------------------------------------------------------------------------------------
 554 // Exceptions
 555 
 556 void InterpreterRuntime::note_trap_inner(JavaThread* thread, int reason,
</pre>
<hr />
<pre>
 840 // and therefore we don&#39;t have the receiver object at our fingertips. (Though,
 841 // on some platforms the receiver still resides in a register...). Thus,
 842 // we have no choice but print an error message not containing the receiver
 843 // type.
 844 JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorWithMethod(JavaThread* thread,
 845                                                                         Method* missingMethod))
 846   ResourceMark rm(thread);
 847   assert(missingMethod != NULL, &quot;sanity&quot;);
 848   methodHandle m(thread, missingMethod);
 849   LinkResolver::throw_abstract_method_error(m, THREAD);
 850 JRT_END
 851 
 852 JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorVerbose(JavaThread* thread,
 853                                                                      Klass* recvKlass,
 854                                                                      Method* missingMethod))
 855   ResourceMark rm(thread);
 856   methodHandle mh = methodHandle(thread, missingMethod);
 857   LinkResolver::throw_abstract_method_error(mh, recvKlass, THREAD);
 858 JRT_END
 859 
<span class="line-added"> 860 JRT_ENTRY(void, InterpreterRuntime::throw_InstantiationError(JavaThread* thread))</span>
<span class="line-added"> 861   THROW(vmSymbols::java_lang_InstantiationError());</span>
<span class="line-added"> 862 JRT_END</span>
<span class="line-added"> 863 </span>
 864 
 865 JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeError(JavaThread* thread))
 866   THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
 867 JRT_END
 868 
 869 JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose(JavaThread* thread,
 870                                                                               Klass* recvKlass,
 871                                                                               Klass* interfaceKlass))
 872   ResourceMark rm(thread);
 873   char buf[1000];
 874   buf[0] = &#39;\0&#39;;
 875   jio_snprintf(buf, sizeof(buf),
 876                &quot;Class %s does not implement the requested interface %s&quot;,
 877                recvKlass ? recvKlass-&gt;external_name() : &quot;NULL&quot;,
 878                interfaceKlass ? interfaceKlass-&gt;external_name() : &quot;NULL&quot;);
 879   THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 880 JRT_END
 881 
 882 //------------------------------------------------------------------------------------------------------------------------
 883 // Fields
 884 //
 885 
 886 void InterpreterRuntime::resolve_get_put(JavaThread* thread, Bytecodes::Code bytecode) {
 887   Thread* THREAD = thread;
 888   // resolve field
 889   fieldDescriptor info;
 890   LastFrameAccessor last_frame(thread);
 891   constantPoolHandle pool(thread, last_frame.method()-&gt;constants());
 892   methodHandle m(thread, last_frame.method());
 893   bool is_put    = (bytecode == Bytecodes::_putfield  || bytecode == Bytecodes::_nofast_putfield ||
<span class="line-modified"> 894                     bytecode == Bytecodes::_putstatic || bytecode == Bytecodes::_withfield);</span>
 895   bool is_static = (bytecode == Bytecodes::_getstatic || bytecode == Bytecodes::_putstatic);
<span class="line-added"> 896   bool is_inline_type  = bytecode == Bytecodes::_withfield;</span>
 897 
 898   {
 899     JvmtiHideSingleStepping jhss(thread);
 900     LinkResolver::resolve_field_access(info, pool, last_frame.get_index_u2_cpcache(bytecode),
 901                                        m, bytecode, CHECK);
 902   } // end JvmtiHideSingleStepping
 903 
 904   // check if link resolution caused cpCache to be updated
 905   ConstantPoolCacheEntry* cp_cache_entry = last_frame.cache_entry();
 906   if (cp_cache_entry-&gt;is_resolved(bytecode)) return;
 907 
 908   // compute auxiliary field attributes
 909   TosState state  = as_TosState(info.field_type());
 910 
 911   // Resolution of put instructions on final fields is delayed. That is required so that
 912   // exceptions are thrown at the correct place (when the instruction is actually invoked).
 913   // If we do not resolve an instruction in the current pass, leaving the put_code
 914   // set to zero will cause the next put instruction to the same field to reresolve.
 915 
 916   // Resolution of put instructions to final instance fields with invalid updates (i.e.,
</pre>
<hr />
<pre>
 920   // initializer method &lt;init&gt;. If resolution were not inhibited, a putfield
 921   // in an initializer method could be resolved in the initializer. Subsequent
 922   // putfield instructions to the same field would then use cached information.
 923   // As a result, those instructions would not pass through the VM. That is,
 924   // checks in resolve_field_access() would not be executed for those instructions
 925   // and the required IllegalAccessError would not be thrown.
 926   //
 927   // Also, we need to delay resolving getstatic and putstatic instructions until the
 928   // class is initialized.  This is required so that access to the static
 929   // field will call the initialization function every time until the class
 930   // is completely initialized ala. in 2.17.5 in JVM Specification.
 931   InstanceKlass* klass = info.field_holder();
 932   bool uninitialized_static = is_static &amp;&amp; !klass-&gt;is_initialized();
 933   bool has_initialized_final_update = info.field_holder()-&gt;major_version() &gt;= 53 &amp;&amp;
 934                                       info.has_initialized_final_update();
 935   assert(!(has_initialized_final_update &amp;&amp; !info.access_flags().is_final()), &quot;Fields with initialized final updates must be final&quot;);
 936 
 937   Bytecodes::Code get_code = (Bytecodes::Code)0;
 938   Bytecodes::Code put_code = (Bytecodes::Code)0;
 939   if (!uninitialized_static) {
<span class="line-modified"> 940     if (is_static) {</span>
<span class="line-modified"> 941       get_code = Bytecodes::_getstatic;</span>
<span class="line-modified"> 942     } else {</span>
<span class="line-added"> 943       get_code = Bytecodes::_getfield;</span>
<span class="line-added"> 944     }</span>
<span class="line-added"> 945     if (is_put &amp;&amp; is_inline_type) {</span>
<span class="line-added"> 946         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_withfield);</span>
<span class="line-added"> 947     } else if ((is_put &amp;&amp; !has_initialized_final_update) || !info.access_flags().is_final()) {</span>
<span class="line-added"> 948         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);</span>
 949     }
 950   }
 951 
 952   cp_cache_entry-&gt;set_field(
 953     get_code,
 954     put_code,
 955     info.field_holder(),
 956     info.index(),
 957     info.offset(),
 958     state,
 959     info.access_flags().is_final(),
 960     info.access_flags().is_volatile(),
<span class="line-added"> 961     info.is_inlined(),</span>
<span class="line-added"> 962     info.is_inline_type(),</span>
 963     pool-&gt;pool_holder()
 964   );
 965 }
 966 
 967 
 968 //------------------------------------------------------------------------------------------------------------------------
 969 // Synchronization
 970 //
 971 // The interpreter&#39;s synchronization code is factored out so that it can
 972 // be shared by method invocation and synchronized blocks.
 973 //%note synchronization_3
 974 
 975 //%note monitor_1
 976 JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))
 977 #ifdef ASSERT
 978   thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
 979 #endif
 980   if (PrintBiasedLockingStatistics) {
 981     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
 982   }
</pre>
<hr />
<pre>
1192   int index = last_frame.get_index_u4(bytecode);
1193   {
1194     JvmtiHideSingleStepping jhss(thread);
1195     LinkResolver::resolve_invoke(info, Handle(), pool,
1196                                  index, bytecode, CHECK);
1197   } // end JvmtiHideSingleStepping
1198 
1199   ConstantPoolCacheEntry* cp_cache_entry = pool-&gt;invokedynamic_cp_cache_entry_at(index);
1200   cp_cache_entry-&gt;set_dynamic_call(pool, info);
1201 }
1202 
1203 // This function is the interface to the assembly code. It returns the resolved
1204 // cpCache entry.  This doesn&#39;t safepoint, but the helper routines safepoint.
1205 // This function will check for redefinition!
1206 JRT_ENTRY(void, InterpreterRuntime::resolve_from_cache(JavaThread* thread, Bytecodes::Code bytecode)) {
1207   switch (bytecode) {
1208   case Bytecodes::_getstatic:
1209   case Bytecodes::_putstatic:
1210   case Bytecodes::_getfield:
1211   case Bytecodes::_putfield:
<span class="line-added">1212   case Bytecodes::_withfield:</span>
1213     resolve_get_put(thread, bytecode);
1214     break;
1215   case Bytecodes::_invokevirtual:
1216   case Bytecodes::_invokespecial:
1217   case Bytecodes::_invokestatic:
1218   case Bytecodes::_invokeinterface:
1219     resolve_invoke(thread, bytecode);
1220     break;
1221   case Bytecodes::_invokehandle:
1222     resolve_invokehandle(thread);
1223     break;
1224   case Bytecodes::_invokedynamic:
1225     resolve_invokedynamic(thread);
1226     break;
1227   default:
1228     fatal(&quot;unexpected bytecode: %s&quot;, Bytecodes::name(bytecode));
1229     break;
1230   }
1231 }
1232 JRT_END
</pre>
<hr />
<pre>
1419 
1420   if (JvmtiExport::should_post_single_step()) {
1421     // We are called during regular safepoints and when the VM is
1422     // single stepping. If any thread is marked for single stepping,
1423     // then we may have JVMTI work to do.
1424     LastFrameAccessor last_frame(thread);
1425     JvmtiExport::at_single_stepping_point(thread, last_frame.method(), last_frame.bcp());
1426   }
1427 JRT_END
1428 
1429 JRT_ENTRY(void, InterpreterRuntime::post_field_access(JavaThread *thread, oopDesc* obj,
1430 ConstantPoolCacheEntry *cp_entry))
1431 
1432   // check the access_flags for the field in the klass
1433 
1434   InstanceKlass* ik = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
1435   int index = cp_entry-&gt;field_index();
1436   if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_ACCESS_WATCHED) == 0) return;
1437 
1438   bool is_static = (obj == NULL);
<span class="line-added">1439   bool is_inlined = cp_entry-&gt;is_inlined();</span>
1440   HandleMark hm(thread);
1441 
1442   Handle h_obj;
1443   if (!is_static) {
1444     // non-static field accessors have an object, but we need a handle
1445     h_obj = Handle(thread, obj);
1446   }
1447   InstanceKlass* cp_entry_f1 = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
<span class="line-modified">1448   jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry-&gt;f2_as_index(), is_static, is_inlined);</span>
1449   LastFrameAccessor last_frame(thread);
1450   JvmtiExport::post_field_access(thread, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);
1451 JRT_END
1452 
1453 JRT_ENTRY(void, InterpreterRuntime::post_field_modification(JavaThread *thread,
1454   oopDesc* obj, ConstantPoolCacheEntry *cp_entry, jvalue *value))
1455 
1456   Klass* k = cp_entry-&gt;f1_as_klass();
1457 
1458   // check the access_flags for the field in the klass
1459   InstanceKlass* ik = InstanceKlass::cast(k);
1460   int index = cp_entry-&gt;field_index();
1461   // bail out if field modifications are not watched
1462   if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_MODIFICATION_WATCHED) == 0) return;
1463 
1464   char sig_type = &#39;\0&#39;;
1465 
1466   switch(cp_entry-&gt;flag_state()) {
1467     case btos: sig_type = JVM_SIGNATURE_BYTE;    break;
1468     case ztos: sig_type = JVM_SIGNATURE_BOOLEAN; break;
1469     case ctos: sig_type = JVM_SIGNATURE_CHAR;    break;
1470     case stos: sig_type = JVM_SIGNATURE_SHORT;   break;
1471     case itos: sig_type = JVM_SIGNATURE_INT;     break;
1472     case ftos: sig_type = JVM_SIGNATURE_FLOAT;   break;
1473     case atos: sig_type = JVM_SIGNATURE_CLASS;   break;
1474     case ltos: sig_type = JVM_SIGNATURE_LONG;    break;
1475     case dtos: sig_type = JVM_SIGNATURE_DOUBLE;  break;
1476     default:  ShouldNotReachHere(); return;
1477   }
<span class="line-added">1478 </span>
<span class="line-added">1479   // Both Q-signatures and L-signatures are mapped to atos</span>
<span class="line-added">1480   if (cp_entry-&gt;flag_state() == atos &amp;&amp; ik-&gt;field_signature(index)-&gt;is_Q_signature()) {</span>
<span class="line-added">1481     sig_type = JVM_SIGNATURE_INLINE_TYPE;</span>
<span class="line-added">1482   }</span>
<span class="line-added">1483 </span>
1484   bool is_static = (obj == NULL);
<span class="line-added">1485   bool is_inlined = cp_entry-&gt;is_inlined();</span>
1486 
1487   HandleMark hm(thread);
<span class="line-modified">1488   jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry-&gt;f2_as_index(), is_static, is_inlined);</span>
1489   jvalue fvalue;
1490 #ifdef _LP64
1491   fvalue = *value;
1492 #else
1493   // Long/double values are stored unaligned and also noncontiguously with
1494   // tagged stacks.  We can&#39;t just do a simple assignment even in the non-
1495   // J/D cases because a C++ compiler is allowed to assume that a jvalue is
1496   // 8-byte aligned, and interpreter stack slots are only 4-byte aligned.
1497   // We assume that the two halves of longs/doubles are stored in interpreter
1498   // stack slots in platform-endian order.
1499   jlong_accessor u;
1500   jint* newval = (jint*)value;
1501   u.words[0] = newval[0];
1502   u.words[1] = newval[Interpreter::stackElementWords]; // skip if tag
1503   fvalue.j = u.long_value;
1504 #endif // _LP64
1505 
1506   Handle h_obj;
1507   if (!is_static) {
1508     // non-static field accessors have an object, but we need a handle
</pre>
</td>
</tr>
</table>
<center><a href="abstractInterpreter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRuntime.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>