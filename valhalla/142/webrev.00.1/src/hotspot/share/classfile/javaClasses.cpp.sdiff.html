<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  26 #include &quot;classfile/altHashing.hpp&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;


  46 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/resolvedMethodTable.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/init.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepoint.hpp&quot;
  66 #include &quot;runtime/safepointVerifiers.hpp&quot;
  67 #include &quot;runtime/thread.inline.hpp&quot;
</pre>
<hr />
<pre>
 791   bool is_latin1 = java_lang_String::is_latin1(java_string);
 792 
 793   st-&gt;print(&quot;\&quot;&quot;);
 794   for (int index = 0; index &lt; length; index++) {
 795     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 796                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 797   }
 798   st-&gt;print(&quot;\&quot;&quot;);
 799 }
 800 
 801 // java_lang_Class
 802 
 803 int java_lang_Class::_klass_offset;
 804 int java_lang_Class::_array_klass_offset;
 805 int java_lang_Class::_oop_size_offset;
 806 int java_lang_Class::_static_oop_field_count_offset;
 807 int java_lang_Class::_class_loader_offset;
 808 int java_lang_Class::_module_offset;
 809 int java_lang_Class::_protection_domain_offset;
 810 int java_lang_Class::_component_mirror_offset;


 811 int java_lang_Class::_init_lock_offset;
 812 int java_lang_Class::_signers_offset;
 813 int java_lang_Class::_name_offset;
 814 int java_lang_Class::_source_file_offset;
 815 int java_lang_Class::_classData_offset;
 816 int java_lang_Class::_classRedefinedCount_offset;
 817 
 818 bool java_lang_Class::_offsets_computed = false;
 819 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
 820 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
 821 
 822 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 823   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 824   if (fd-&gt;has_initial_value()) {
 825     BasicType t = fd-&gt;field_type();
 826     switch (t) {
 827       case T_BYTE:
 828         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 829               break;
 830       case T_BOOLEAN:
</pre>
<hr />
<pre>
 986   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 987   k-&gt;set_modifier_flags(computed_modifiers);
 988   // Class_klass has to be loaded because it is used to allocate
 989   // the mirror.
 990   if (SystemDictionary::Class_klass_loaded()) {
 991     // Allocate mirror (java.lang.Class instance)
 992     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 993     Handle mirror(THREAD, mirror_oop);
 994     Handle comp_mirror;
 995 
 996     // Setup indirection from mirror-&gt;klass
 997     java_lang_Class::set_klass(mirror(), k);
 998 
 999     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
1000     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
1001 
1002     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
1003 
1004     // It might also have a component mirror.  This mirror must already exist.
1005     if (k-&gt;is_array_klass()) {
<span class="line-modified">1006       if (k-&gt;is_typeArray_klass()) {</span>





1007         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
1008         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
1009       } else {
1010         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1011         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1012         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1013         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
1014       }
1015       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
1016 
1017       // Two-way link between the array klass and its component mirror:
1018       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1019       set_component_mirror(mirror(), comp_mirror());
1020       // See below for ordering dependencies between field array_klass in component mirror
1021       // and java_mirror in this klass.
1022     } else {
1023       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1024 
1025       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1026       if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
1033       }
1034     }
1035 
1036     // set the classLoader field in the java_lang_Class instance
1037     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1038     set_class_loader(mirror(), class_loader());
1039 
1040     // Setup indirection from klass-&gt;mirror
1041     // after any exceptions can happen during allocations.
1042     k-&gt;set_java_mirror(mirror);
1043 
1044     // Set the module field in the java_lang_Class instance.  This must be done
1045     // after the mirror is set.
1046     set_mirror_module_field(k, mirror, module, THREAD);
1047 
1048     if (comp_mirror() != NULL) {
1049       // Set after k-&gt;java_mirror() is published, because compiled code running
1050       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1051       release_set_array_klass(comp_mirror(), k);
1052     }



















1053   } else {
1054     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1055     fixup_mirror_list()-&gt;push(k);
1056   }
1057 }
1058 
1059 #if INCLUDE_CDS_JAVA_HEAP
1060 // Clears mirror fields. Static final fields with initial values are reloaded
1061 // from constant pool. The object identity hash is in the object header and is
1062 // not affected.
1063 class ResetMirrorField: public FieldClosure {
1064  private:
1065   Handle _m;
1066 
1067  public:
1068   ResetMirrorField(Handle mirror) : _m(mirror) {}
1069 
1070   void do_field(fieldDescriptor* fd) {
1071     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1072     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
</pre>
<hr />
<pre>
1085         _m()-&gt;char_field_put(fd-&gt;offset(), 0);
1086         break;
1087       case T_DOUBLE:
1088         _m()-&gt;double_field_put(fd-&gt;offset(), 0);
1089         break;
1090       case T_FLOAT:
1091         _m()-&gt;float_field_put(fd-&gt;offset(), 0);
1092         break;
1093       case T_INT:
1094         _m()-&gt;int_field_put(fd-&gt;offset(), 0);
1095         break;
1096       case T_LONG:
1097         _m()-&gt;long_field_put(fd-&gt;offset(), 0);
1098         break;
1099       case T_SHORT:
1100         _m()-&gt;short_field_put(fd-&gt;offset(), 0);
1101         break;
1102       case T_BOOLEAN:
1103         _m()-&gt;bool_field_put(fd-&gt;offset(), false);
1104         break;

1105       case T_ARRAY:
1106       case T_OBJECT: {
1107         // It might be useful to cache the String field, but
1108         // for now just clear out any reference field
1109         oop o = _m()-&gt;obj_field(fd-&gt;offset());
1110         _m()-&gt;obj_field_put(fd-&gt;offset(), NULL);
1111         break;
1112       }
1113       default:
1114         ShouldNotReachHere();
1115         break;
1116      }
1117   }
1118 };
1119 
1120 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
1121   assert(HeapShared::is_heap_object_archiving_allowed(),
1122          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1123 
1124   for (int t = 0; t &lt;= T_VOID; t++) {
</pre>
<hr />
<pre>
1189 
1190   // No mirror
1191   oop mirror = k-&gt;java_mirror();
1192   if (mirror == NULL) {
1193     return NULL;
1194   }
1195 
1196   if (k-&gt;is_instance_klass()) {
1197     InstanceKlass *ik = InstanceKlass::cast(k);
1198     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1199 
1200     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1201           ik-&gt;is_shared_app_class())) {
1202       // Archiving mirror for classes from non-builtin loaders is not
1203       // supported. Clear the _java_mirror within the archived class.
1204       k-&gt;set_java_mirror_handle(OopHandle());
1205       return NULL;
1206     }
1207   }
1208 






1209   // Now start archiving the mirror object
1210   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1211   if (archived_mirror == NULL) {
1212     return NULL;
1213   }
1214 
1215   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1216   if (archived_mirror == NULL) {
1217     return NULL;
1218   }
1219 
1220   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1221 
1222   k-&gt;set_has_raw_archived_mirror();
1223 
1224   ResourceMark rm;
1225   log_trace(cds, heap, mirror)(
1226     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1227     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1228 
</pre>
<hr />
<pre>
1480 oop java_lang_Class::name(Handle java_class, TRAPS) {
1481   assert(_name_offset != 0, &quot;must be set&quot;);
1482   oop o = java_class-&gt;obj_field(_name_offset);
1483   if (o == NULL) {
1484     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1485     java_class-&gt;obj_field_put(_name_offset, o);
1486   }
1487   return o;
1488 }
1489 
1490 oop java_lang_Class::source_file(oop java_class) {
1491   assert(_source_file_offset != 0, &quot;must be set&quot;);
1492   return java_class-&gt;obj_field(_source_file_offset);
1493 }
1494 
1495 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1496   assert(_source_file_offset != 0, &quot;must be set&quot;);
1497   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1498 }
1499 




















1500 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1501   // This should be improved by adding a field at the Java level or by
1502   // introducing a new VM klass (see comment in ClassFileParser)
1503   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1504   if (type != T_VOID) {
1505     Klass* aklass = Universe::typeArrayKlassObj(type);
1506     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1507     release_set_array_klass(java_class, aklass);
1508   }
1509 #ifdef ASSERT
1510   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1511   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1512 #endif
1513   return java_class;
1514 }
1515 
1516 
1517 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1518   //%note memory_2
1519   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1520   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1521   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1522   return k;
1523 }
1524 
1525 
1526 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1527   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1528   java_class-&gt;metadata_field_put(_klass_offset, klass);
1529 }
1530 
1531 
1532 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1533   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1534   Symbol* name = NULL;
1535   bool is_instance = false;

1536   if (is_primitive(java_class)) {
1537     name = vmSymbols::type_signature(primitive_type(java_class));
1538   } else {
1539     Klass* k = as_Klass(java_class);
1540     is_instance = k-&gt;is_instance_klass();

1541     name = k-&gt;name();
1542   }
1543   if (name == NULL) {
1544     st-&gt;print(&quot;&lt;null&gt;&quot;);
1545     return;
1546   }
<span class="line-modified">1547   if (is_instance)  st-&gt;print(&quot;L&quot;);</span>






1548   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1549   if (is_instance)  st-&gt;print(&quot;;&quot;);
1550 }
1551 
1552 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1553   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1554   Symbol* name;
1555   if (is_primitive(java_class)) {
1556     name = vmSymbols::type_signature(primitive_type(java_class));
1557     // Because this can create a new symbol, the caller has to decrement
1558     // the refcount, so make adjustment here and below for symbols returned
1559     // that are not created or incremented due to a successful lookup.
1560     name-&gt;increment_refcount();
1561   } else {
1562     Klass* k = as_Klass(java_class);
1563     if (!k-&gt;is_instance_klass()) {
1564       name = k-&gt;name();
1565       name-&gt;increment_refcount();
1566     } else {
1567       ResourceMark rm;
1568       const char* sigstr = k-&gt;signature_name();
<span class="line-modified">1569       int         siglen = (int) strlen(sigstr);</span>
1570       if (!intern_if_not_found) {
1571         name = SymbolTable::probe(sigstr, siglen);
1572       } else {
1573         name = SymbolTable::new_symbol(sigstr, siglen);
1574       }
1575     }
1576   }
1577   return name;
1578 }
1579 
1580 // Returns the Java name for this Java mirror (Resource allocated)
1581 // See Klass::external_name().
1582 // For primitive type Java mirrors, its type name is returned.
1583 const char* java_lang_Class::as_external_name(oop java_class) {
1584   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1585   const char* name = NULL;
1586   if (is_primitive(java_class)) {
1587     name = type2name(primitive_type(java_class));
1588   } else {
1589     name = as_Klass(java_class)-&gt;external_name();
</pre>
<hr />
<pre>
1631     if (reference_klass != NULL)
1632       (*reference_klass) = as_Klass(java_class);
1633     return T_OBJECT;
1634   }
1635 }
1636 
1637 
1638 oop java_lang_Class::primitive_mirror(BasicType t) {
1639   oop mirror = Universe::java_mirror(t);
1640   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1641   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1642   return mirror;
1643 }
1644 
1645 #define CLASS_FIELDS_DO(macro) \
1646   macro(_classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1647   macro(_class_loader_offset,        k, &quot;classLoader&quot;,         classloader_signature, false); \
1648   macro(_component_mirror_offset,    k, &quot;componentType&quot;,       class_signature,       false); \
1649   macro(_module_offset,              k, &quot;module&quot;,              module_signature,      false); \
1650   macro(_name_offset,                k, &quot;name&quot;,                string_signature,      false); \


1651   macro(_classData_offset,           k, &quot;classData&quot;,           object_signature,      false);
1652 
1653 void java_lang_Class::compute_offsets() {
1654   if (_offsets_computed) {
1655     return;
1656   }
1657 
1658   _offsets_computed = true;
1659 
1660   InstanceKlass* k = SystemDictionary::Class_klass();
1661   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1662 
1663   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1664   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1665   // GC treats them the same.
1666   _init_lock_offset = _component_mirror_offset;
1667 
1668   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1669 }
1670 
</pre>
<hr />
<pre>
2514 #endif
2515 
2516     // the format of the stacktrace will be:
2517     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2518     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2519     // - rest of the stack
2520 
2521     if (!skip_fillInStackTrace_check) {
2522       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2523           throwable-&gt;is_a(method-&gt;method_holder())) {
2524         continue;
2525       }
2526       else {
2527         skip_fillInStackTrace_check = true; // gone past them all
2528       }
2529     }
2530     if (!skip_throwableInit_check) {
2531       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2532 
2533       // skip &lt;init&gt; methods of the exception class and superclasses
<span class="line-modified">2534       // This is simlar to classic VM.</span>
<span class="line-modified">2535       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
2536           throwable-&gt;is_a(method-&gt;method_holder())) {
2537         continue;
2538       } else {
2539         // there are none or we&#39;ve seen them all - either way stop checking
2540         skip_throwableInit_check = true;
2541       }
2542     }
2543     if (method-&gt;is_hidden()) {
2544       if (skip_hidden) {
2545         if (total_count == 0) {
2546           // The top frame will be hidden from the stack trace.
2547           bt.set_has_hidden_top_frame(CHECK);
2548         }
2549         continue;
2550       }
2551     }
2552     bt.push(method, bci, CHECK);
2553     total_count++;
2554   }
2555 
</pre>
<hr />
<pre>
3884 int java_lang_invoke_MemberName::flags(oop mname) {
3885   assert(is_instance(mname), &quot;wrong type&quot;);
3886   return mname-&gt;int_field(_flags_offset);
3887 }
3888 
3889 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3890   assert(is_instance(mname), &quot;wrong type&quot;);
3891   mname-&gt;int_field_put(_flags_offset, flags);
3892 }
3893 
3894 
3895 // Return vmtarget from ResolvedMethodName method field through indirection
3896 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3897   assert(is_instance(mname), &quot;wrong type&quot;);
3898   oop method = mname-&gt;obj_field(_method_offset);
3899   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3900 }
3901 
3902 bool java_lang_invoke_MemberName::is_method(oop mname) {
3903   assert(is_instance(mname), &quot;must be MemberName&quot;);
<span class="line-modified">3904   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) &gt; 0;</span>
3905 }
3906 
3907 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3908   assert(is_instance(mname), &quot;wrong type&quot;);
3909   mname-&gt;obj_field_put(_method_offset, resolved_method);
3910 }
3911 
3912 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3913   assert(is_instance(mname), &quot;wrong type&quot;);
3914   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3915 }
3916 
3917 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3918   assert(is_instance(mname), &quot;wrong type&quot;);
3919   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3920 }
3921 
3922 
3923 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3924   assert(is_instance(resolved_method), &quot;wrong type&quot;);
</pre>
<hr />
<pre>
4686   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4687   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4688 }
4689 
4690 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4691   oop base = ik-&gt;static_field_base_raw();
4692   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4693 }
4694 
4695 Symbol* java_lang_Byte_ByteCache::symbol() {
4696   return vmSymbols::java_lang_Byte_ByteCache();
4697 }
4698 
4699 #if INCLUDE_CDS
4700 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4701   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4702 }
4703 #endif
4704 #undef BYTE_CACHE_FIELDS_DO
4705 







































































4706 jbyte java_lang_Byte::value(oop obj) {
4707    jvalue v;
4708    java_lang_boxing_object::get_value(obj, &amp;v);
4709    return v.b;
4710 }
4711 
4712 int java_lang_Boolean::_static_TRUE_offset;
4713 int java_lang_Boolean::_static_FALSE_offset;
4714 
4715 #define BOOLEAN_FIELDS_DO(macro) \
4716   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4717   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4718 
4719 
4720 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4721   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4722   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4723 }
4724 
4725 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
</pre>
</td>
<td>
<hr />
<pre>
  26 #include &quot;classfile/altHashing.hpp&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
<span class="line-added">  46 #include &quot;oops/flatArrayKlass.hpp&quot;</span>
<span class="line-added">  47 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
  48 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-modified">  49 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;</span>
  50 #include &quot;oops/klass.hpp&quot;
  51 #include &quot;oops/method.inline.hpp&quot;
  52 #include &quot;oops/objArrayOop.inline.hpp&quot;
  53 #include &quot;oops/oop.inline.hpp&quot;
  54 #include &quot;oops/symbol.hpp&quot;
  55 #include &quot;oops/recordComponent.hpp&quot;
  56 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  57 #include &quot;prims/jvmtiExport.hpp&quot;
  58 #include &quot;prims/resolvedMethodTable.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/init.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/java.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/jniHandles.inline.hpp&quot;
  67 #include &quot;runtime/safepoint.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
</pre>
<hr />
<pre>
 793   bool is_latin1 = java_lang_String::is_latin1(java_string);
 794 
 795   st-&gt;print(&quot;\&quot;&quot;);
 796   for (int index = 0; index &lt; length; index++) {
 797     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 798                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 799   }
 800   st-&gt;print(&quot;\&quot;&quot;);
 801 }
 802 
 803 // java_lang_Class
 804 
 805 int java_lang_Class::_klass_offset;
 806 int java_lang_Class::_array_klass_offset;
 807 int java_lang_Class::_oop_size_offset;
 808 int java_lang_Class::_static_oop_field_count_offset;
 809 int java_lang_Class::_class_loader_offset;
 810 int java_lang_Class::_module_offset;
 811 int java_lang_Class::_protection_domain_offset;
 812 int java_lang_Class::_component_mirror_offset;
<span class="line-added"> 813 int java_lang_Class::_val_type_mirror_offset;</span>
<span class="line-added"> 814 int java_lang_Class::_ref_type_mirror_offset;</span>
 815 int java_lang_Class::_init_lock_offset;
 816 int java_lang_Class::_signers_offset;
 817 int java_lang_Class::_name_offset;
 818 int java_lang_Class::_source_file_offset;
 819 int java_lang_Class::_classData_offset;
 820 int java_lang_Class::_classRedefinedCount_offset;
 821 
 822 bool java_lang_Class::_offsets_computed = false;
 823 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
 824 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
 825 
 826 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 827   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 828   if (fd-&gt;has_initial_value()) {
 829     BasicType t = fd-&gt;field_type();
 830     switch (t) {
 831       case T_BYTE:
 832         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 833               break;
 834       case T_BOOLEAN:
</pre>
<hr />
<pre>
 990   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 991   k-&gt;set_modifier_flags(computed_modifiers);
 992   // Class_klass has to be loaded because it is used to allocate
 993   // the mirror.
 994   if (SystemDictionary::Class_klass_loaded()) {
 995     // Allocate mirror (java.lang.Class instance)
 996     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 997     Handle mirror(THREAD, mirror_oop);
 998     Handle comp_mirror;
 999 
1000     // Setup indirection from mirror-&gt;klass
1001     java_lang_Class::set_klass(mirror(), k);
1002 
1003     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
1004     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
1005 
1006     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
1007 
1008     // It might also have a component mirror.  This mirror must already exist.
1009     if (k-&gt;is_array_klass()) {
<span class="line-modified">1010       if (k-&gt;is_flatArray_klass()) {</span>
<span class="line-added">1011         Klass* element_klass = (Klass*) FlatArrayKlass::cast(k)-&gt;element_klass();</span>
<span class="line-added">1012         assert(element_klass-&gt;is_inline_klass(), &quot;Must be inline type component&quot;);</span>
<span class="line-added">1013         InlineKlass* vk = InlineKlass::cast(InstanceKlass::cast(element_klass));</span>
<span class="line-added">1014         comp_mirror = Handle(THREAD, vk-&gt;java_mirror());</span>
<span class="line-added">1015       } else if (k-&gt;is_typeArray_klass()) {</span>
1016         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
1017         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
1018       } else {
1019         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1020         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1021         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1022         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
1023       }
1024       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
1025 
1026       // Two-way link between the array klass and its component mirror:
1027       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1028       set_component_mirror(mirror(), comp_mirror());
1029       // See below for ordering dependencies between field array_klass in component mirror
1030       // and java_mirror in this klass.
1031     } else {
1032       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1033 
1034       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1035       if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
1042       }
1043     }
1044 
1045     // set the classLoader field in the java_lang_Class instance
1046     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1047     set_class_loader(mirror(), class_loader());
1048 
1049     // Setup indirection from klass-&gt;mirror
1050     // after any exceptions can happen during allocations.
1051     k-&gt;set_java_mirror(mirror);
1052 
1053     // Set the module field in the java_lang_Class instance.  This must be done
1054     // after the mirror is set.
1055     set_mirror_module_field(k, mirror, module, THREAD);
1056 
1057     if (comp_mirror() != NULL) {
1058       // Set after k-&gt;java_mirror() is published, because compiled code running
1059       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1060       release_set_array_klass(comp_mirror(), k);
1061     }
<span class="line-added">1062 </span>
<span class="line-added">1063     if (k-&gt;is_inline_klass()) {</span>
<span class="line-added">1064       InstanceKlass* super = k-&gt;java_super();</span>
<span class="line-added">1065       set_val_type_mirror(mirror(), mirror());</span>
<span class="line-added">1066 </span>
<span class="line-added">1067       // if the supertype is a restricted abstract class</span>
<span class="line-added">1068       if (super != SystemDictionary::Object_klass()) {</span>
<span class="line-added">1069         assert(super-&gt;access_flags().is_abstract(), &quot;must be an abstract class&quot;);</span>
<span class="line-added">1070         oop ref_type_oop = super-&gt;java_mirror();</span>
<span class="line-added">1071         // set the reference projection type</span>
<span class="line-added">1072         set_ref_type_mirror(mirror(), ref_type_oop);</span>
<span class="line-added">1073 </span>
<span class="line-added">1074         assert(oopDesc::is_oop(ref_type_oop), &quot;Sanity check&quot;);</span>
<span class="line-added">1075 </span>
<span class="line-added">1076         // set the value and reference projection types</span>
<span class="line-added">1077         set_val_type_mirror(ref_type_oop, mirror());</span>
<span class="line-added">1078         set_ref_type_mirror(ref_type_oop, ref_type_oop);</span>
<span class="line-added">1079       }</span>
<span class="line-added">1080     }</span>
1081   } else {
1082     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1083     fixup_mirror_list()-&gt;push(k);
1084   }
1085 }
1086 
1087 #if INCLUDE_CDS_JAVA_HEAP
1088 // Clears mirror fields. Static final fields with initial values are reloaded
1089 // from constant pool. The object identity hash is in the object header and is
1090 // not affected.
1091 class ResetMirrorField: public FieldClosure {
1092  private:
1093   Handle _m;
1094 
1095  public:
1096   ResetMirrorField(Handle mirror) : _m(mirror) {}
1097 
1098   void do_field(fieldDescriptor* fd) {
1099     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1100     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
</pre>
<hr />
<pre>
1113         _m()-&gt;char_field_put(fd-&gt;offset(), 0);
1114         break;
1115       case T_DOUBLE:
1116         _m()-&gt;double_field_put(fd-&gt;offset(), 0);
1117         break;
1118       case T_FLOAT:
1119         _m()-&gt;float_field_put(fd-&gt;offset(), 0);
1120         break;
1121       case T_INT:
1122         _m()-&gt;int_field_put(fd-&gt;offset(), 0);
1123         break;
1124       case T_LONG:
1125         _m()-&gt;long_field_put(fd-&gt;offset(), 0);
1126         break;
1127       case T_SHORT:
1128         _m()-&gt;short_field_put(fd-&gt;offset(), 0);
1129         break;
1130       case T_BOOLEAN:
1131         _m()-&gt;bool_field_put(fd-&gt;offset(), false);
1132         break;
<span class="line-added">1133       case T_INLINE_TYPE:</span>
1134       case T_ARRAY:
1135       case T_OBJECT: {
1136         // It might be useful to cache the String field, but
1137         // for now just clear out any reference field
1138         oop o = _m()-&gt;obj_field(fd-&gt;offset());
1139         _m()-&gt;obj_field_put(fd-&gt;offset(), NULL);
1140         break;
1141       }
1142       default:
1143         ShouldNotReachHere();
1144         break;
1145      }
1146   }
1147 };
1148 
1149 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
1150   assert(HeapShared::is_heap_object_archiving_allowed(),
1151          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1152 
1153   for (int t = 0; t &lt;= T_VOID; t++) {
</pre>
<hr />
<pre>
1218 
1219   // No mirror
1220   oop mirror = k-&gt;java_mirror();
1221   if (mirror == NULL) {
1222     return NULL;
1223   }
1224 
1225   if (k-&gt;is_instance_klass()) {
1226     InstanceKlass *ik = InstanceKlass::cast(k);
1227     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1228 
1229     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1230           ik-&gt;is_shared_app_class())) {
1231       // Archiving mirror for classes from non-builtin loaders is not
1232       // supported. Clear the _java_mirror within the archived class.
1233       k-&gt;set_java_mirror_handle(OopHandle());
1234       return NULL;
1235     }
1236   }
1237 
<span class="line-added">1238   if (k-&gt;is_inline_klass()) {</span>
<span class="line-added">1239     // Inline types have a val type mirror and a ref type mirror. Don&#39;t handle this for now. TODO:CDS</span>
<span class="line-added">1240     k-&gt;set_java_mirror_handle(OopHandle());</span>
<span class="line-added">1241     return NULL;</span>
<span class="line-added">1242   }</span>
<span class="line-added">1243 </span>
1244   // Now start archiving the mirror object
1245   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1246   if (archived_mirror == NULL) {
1247     return NULL;
1248   }
1249 
1250   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1251   if (archived_mirror == NULL) {
1252     return NULL;
1253   }
1254 
1255   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1256 
1257   k-&gt;set_has_raw_archived_mirror();
1258 
1259   ResourceMark rm;
1260   log_trace(cds, heap, mirror)(
1261     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1262     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1263 
</pre>
<hr />
<pre>
1515 oop java_lang_Class::name(Handle java_class, TRAPS) {
1516   assert(_name_offset != 0, &quot;must be set&quot;);
1517   oop o = java_class-&gt;obj_field(_name_offset);
1518   if (o == NULL) {
1519     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1520     java_class-&gt;obj_field_put(_name_offset, o);
1521   }
1522   return o;
1523 }
1524 
1525 oop java_lang_Class::source_file(oop java_class) {
1526   assert(_source_file_offset != 0, &quot;must be set&quot;);
1527   return java_class-&gt;obj_field(_source_file_offset);
1528 }
1529 
1530 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1531   assert(_source_file_offset != 0, &quot;must be set&quot;);
1532   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1533 }
1534 
<span class="line-added">1535 oop java_lang_Class::val_type_mirror(oop java_class) {</span>
<span class="line-added">1536   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1537   return java_class-&gt;obj_field(_val_type_mirror_offset);</span>
<span class="line-added">1538 }</span>
<span class="line-added">1539 </span>
<span class="line-added">1540 void java_lang_Class::set_val_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1541   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1542   java_class-&gt;obj_field_put(_val_type_mirror_offset, mirror);</span>
<span class="line-added">1543 }</span>
<span class="line-added">1544 </span>
<span class="line-added">1545 oop java_lang_Class::ref_type_mirror(oop java_class) {</span>
<span class="line-added">1546   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1547   return java_class-&gt;obj_field(_ref_type_mirror_offset);</span>
<span class="line-added">1548 }</span>
<span class="line-added">1549 </span>
<span class="line-added">1550 void java_lang_Class::set_ref_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1551   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1552   java_class-&gt;obj_field_put(_ref_type_mirror_offset, mirror);</span>
<span class="line-added">1553 }</span>
<span class="line-added">1554 </span>
1555 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1556   // This should be improved by adding a field at the Java level or by
1557   // introducing a new VM klass (see comment in ClassFileParser)
1558   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1559   if (type != T_VOID) {
1560     Klass* aklass = Universe::typeArrayKlassObj(type);
1561     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1562     release_set_array_klass(java_class, aklass);
1563   }
1564 #ifdef ASSERT
1565   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1566   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1567 #endif
1568   return java_class;
1569 }
1570 
1571 
1572 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1573   //%note memory_2
1574   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1575   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1576   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1577   return k;
1578 }
1579 
1580 
1581 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1582   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1583   java_class-&gt;metadata_field_put(_klass_offset, klass);
1584 }
1585 
1586 
1587 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1588   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1589   Symbol* name = NULL;
1590   bool is_instance = false;
<span class="line-added">1591   bool is_value = false;</span>
1592   if (is_primitive(java_class)) {
1593     name = vmSymbols::type_signature(primitive_type(java_class));
1594   } else {
1595     Klass* k = as_Klass(java_class);
1596     is_instance = k-&gt;is_instance_klass();
<span class="line-added">1597     is_value = k-&gt;is_inline_klass();</span>
1598     name = k-&gt;name();
1599   }
1600   if (name == NULL) {
1601     st-&gt;print(&quot;&lt;null&gt;&quot;);
1602     return;
1603   }
<span class="line-modified">1604   if (is_instance)  {</span>
<span class="line-added">1605     if (is_value) {</span>
<span class="line-added">1606       st-&gt;print(&quot;Q&quot;);</span>
<span class="line-added">1607     } else {</span>
<span class="line-added">1608       st-&gt;print(&quot;L&quot;);</span>
<span class="line-added">1609     }</span>
<span class="line-added">1610   }</span>
1611   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1612   if (is_instance)  st-&gt;print(&quot;;&quot;);
1613 }
1614 
1615 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1616   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1617   Symbol* name;
1618   if (is_primitive(java_class)) {
1619     name = vmSymbols::type_signature(primitive_type(java_class));
1620     // Because this can create a new symbol, the caller has to decrement
1621     // the refcount, so make adjustment here and below for symbols returned
1622     // that are not created or incremented due to a successful lookup.
1623     name-&gt;increment_refcount();
1624   } else {
1625     Klass* k = as_Klass(java_class);
1626     if (!k-&gt;is_instance_klass()) {
1627       name = k-&gt;name();
1628       name-&gt;increment_refcount();
1629     } else {
1630       ResourceMark rm;
1631       const char* sigstr = k-&gt;signature_name();
<span class="line-modified">1632       int siglen = (int) strlen(sigstr);</span>
1633       if (!intern_if_not_found) {
1634         name = SymbolTable::probe(sigstr, siglen);
1635       } else {
1636         name = SymbolTable::new_symbol(sigstr, siglen);
1637       }
1638     }
1639   }
1640   return name;
1641 }
1642 
1643 // Returns the Java name for this Java mirror (Resource allocated)
1644 // See Klass::external_name().
1645 // For primitive type Java mirrors, its type name is returned.
1646 const char* java_lang_Class::as_external_name(oop java_class) {
1647   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1648   const char* name = NULL;
1649   if (is_primitive(java_class)) {
1650     name = type2name(primitive_type(java_class));
1651   } else {
1652     name = as_Klass(java_class)-&gt;external_name();
</pre>
<hr />
<pre>
1694     if (reference_klass != NULL)
1695       (*reference_klass) = as_Klass(java_class);
1696     return T_OBJECT;
1697   }
1698 }
1699 
1700 
1701 oop java_lang_Class::primitive_mirror(BasicType t) {
1702   oop mirror = Universe::java_mirror(t);
1703   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1704   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1705   return mirror;
1706 }
1707 
1708 #define CLASS_FIELDS_DO(macro) \
1709   macro(_classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1710   macro(_class_loader_offset,        k, &quot;classLoader&quot;,         classloader_signature, false); \
1711   macro(_component_mirror_offset,    k, &quot;componentType&quot;,       class_signature,       false); \
1712   macro(_module_offset,              k, &quot;module&quot;,              module_signature,      false); \
1713   macro(_name_offset,                k, &quot;name&quot;,                string_signature,      false); \
<span class="line-added">1714   macro(_val_type_mirror_offset,     k, &quot;valType&quot;,             class_signature,       false); \</span>
<span class="line-added">1715   macro(_ref_type_mirror_offset,     k, &quot;refType&quot;,             class_signature,       false); \</span>
1716   macro(_classData_offset,           k, &quot;classData&quot;,           object_signature,      false);
1717 
1718 void java_lang_Class::compute_offsets() {
1719   if (_offsets_computed) {
1720     return;
1721   }
1722 
1723   _offsets_computed = true;
1724 
1725   InstanceKlass* k = SystemDictionary::Class_klass();
1726   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1727 
1728   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1729   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1730   // GC treats them the same.
1731   _init_lock_offset = _component_mirror_offset;
1732 
1733   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1734 }
1735 
</pre>
<hr />
<pre>
2579 #endif
2580 
2581     // the format of the stacktrace will be:
2582     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2583     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2584     // - rest of the stack
2585 
2586     if (!skip_fillInStackTrace_check) {
2587       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2588           throwable-&gt;is_a(method-&gt;method_holder())) {
2589         continue;
2590       }
2591       else {
2592         skip_fillInStackTrace_check = true; // gone past them all
2593       }
2594     }
2595     if (!skip_throwableInit_check) {
2596       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2597 
2598       // skip &lt;init&gt; methods of the exception class and superclasses
<span class="line-modified">2599       // This is similar to classic VM (before HotSpot).</span>
<span class="line-modified">2600       if (method-&gt;is_object_constructor() &amp;&amp;</span>
2601           throwable-&gt;is_a(method-&gt;method_holder())) {
2602         continue;
2603       } else {
2604         // there are none or we&#39;ve seen them all - either way stop checking
2605         skip_throwableInit_check = true;
2606       }
2607     }
2608     if (method-&gt;is_hidden()) {
2609       if (skip_hidden) {
2610         if (total_count == 0) {
2611           // The top frame will be hidden from the stack trace.
2612           bt.set_has_hidden_top_frame(CHECK);
2613         }
2614         continue;
2615       }
2616     }
2617     bt.push(method, bci, CHECK);
2618     total_count++;
2619   }
2620 
</pre>
<hr />
<pre>
3949 int java_lang_invoke_MemberName::flags(oop mname) {
3950   assert(is_instance(mname), &quot;wrong type&quot;);
3951   return mname-&gt;int_field(_flags_offset);
3952 }
3953 
3954 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3955   assert(is_instance(mname), &quot;wrong type&quot;);
3956   mname-&gt;int_field_put(_flags_offset, flags);
3957 }
3958 
3959 
3960 // Return vmtarget from ResolvedMethodName method field through indirection
3961 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3962   assert(is_instance(mname), &quot;wrong type&quot;);
3963   oop method = mname-&gt;obj_field(_method_offset);
3964   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3965 }
3966 
3967 bool java_lang_invoke_MemberName::is_method(oop mname) {
3968   assert(is_instance(mname), &quot;must be MemberName&quot;);
<span class="line-modified">3969   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) &gt; 0;</span>
3970 }
3971 
3972 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3973   assert(is_instance(mname), &quot;wrong type&quot;);
3974   mname-&gt;obj_field_put(_method_offset, resolved_method);
3975 }
3976 
3977 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3978   assert(is_instance(mname), &quot;wrong type&quot;);
3979   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3980 }
3981 
3982 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3983   assert(is_instance(mname), &quot;wrong type&quot;);
3984   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3985 }
3986 
3987 
3988 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3989   assert(is_instance(resolved_method), &quot;wrong type&quot;);
</pre>
<hr />
<pre>
4751   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4752   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4753 }
4754 
4755 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4756   oop base = ik-&gt;static_field_base_raw();
4757   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4758 }
4759 
4760 Symbol* java_lang_Byte_ByteCache::symbol() {
4761   return vmSymbols::java_lang_Byte_ByteCache();
4762 }
4763 
4764 #if INCLUDE_CDS
4765 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4766   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4767 }
4768 #endif
4769 #undef BYTE_CACHE_FIELDS_DO
4770 
<span class="line-added">4771 // jdk_internal_vm_jni_SubElementSelector</span>
<span class="line-added">4772 </span>
<span class="line-added">4773 int jdk_internal_vm_jni_SubElementSelector::_arrayElementType_offset;</span>
<span class="line-added">4774 int jdk_internal_vm_jni_SubElementSelector::_subElementType_offset;</span>
<span class="line-added">4775 int jdk_internal_vm_jni_SubElementSelector::_offset_offset;</span>
<span class="line-added">4776 int jdk_internal_vm_jni_SubElementSelector::_isInlined_offset;</span>
<span class="line-added">4777 int jdk_internal_vm_jni_SubElementSelector::_isInlineType_offset;</span>
<span class="line-added">4778 </span>
<span class="line-added">4779 #define SUBELEMENT_SELECTOR_FIELDS_DO(macro) \</span>
<span class="line-added">4780   macro(_arrayElementType_offset,  k, &quot;arrayElementType&quot;, class_signature, false); \</span>
<span class="line-added">4781   macro(_subElementType_offset,    k, &quot;subElementType&quot;,   class_signature, false); \</span>
<span class="line-added">4782   macro(_offset_offset,            k, &quot;offset&quot;,           int_signature,   false); \</span>
<span class="line-added">4783   macro(_isInlined_offset,         k, &quot;isInlined&quot;,        bool_signature,  false); \</span>
<span class="line-added">4784   macro(_isInlineType_offset,      k, &quot;isInlineType&quot;,     bool_signature,  false);</span>
<span class="line-added">4785 </span>
<span class="line-added">4786 void jdk_internal_vm_jni_SubElementSelector::compute_offsets() {</span>
<span class="line-added">4787   InstanceKlass* k = SystemDictionary::jdk_internal_vm_jni_SubElementSelector_klass();</span>
<span class="line-added">4788   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4789 }</span>
<span class="line-added">4790 </span>
<span class="line-added">4791 #if INCLUDE_CDS</span>
<span class="line-added">4792 void jdk_internal_vm_jni_SubElementSelector::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4793   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4794 }</span>
<span class="line-added">4795 #endif</span>
<span class="line-added">4796 #undef SUBELEMENT_SELECTOR_FIELDS_DO</span>
<span class="line-added">4797 </span>
<span class="line-added">4798 Symbol* jdk_internal_vm_jni_SubElementSelector::symbol() {</span>
<span class="line-added">4799   return vmSymbols::jdk_internal_vm_jni_SubElementSelector();</span>
<span class="line-added">4800 }</span>
<span class="line-added">4801 </span>
<span class="line-added">4802 oop jdk_internal_vm_jni_SubElementSelector::getArrayElementType(oop obj) {</span>
<span class="line-added">4803   return obj-&gt;obj_field(_arrayElementType_offset);</span>
<span class="line-added">4804 }</span>
<span class="line-added">4805 </span>
<span class="line-added">4806 void jdk_internal_vm_jni_SubElementSelector::setArrayElementType(oop obj, oop type) {</span>
<span class="line-added">4807   obj-&gt;obj_field_put(_arrayElementType_offset, type);</span>
<span class="line-added">4808 }</span>
<span class="line-added">4809 </span>
<span class="line-added">4810 oop jdk_internal_vm_jni_SubElementSelector::getSubElementType(oop obj) {</span>
<span class="line-added">4811   return obj-&gt;obj_field(_subElementType_offset);</span>
<span class="line-added">4812 }</span>
<span class="line-added">4813 </span>
<span class="line-added">4814 void jdk_internal_vm_jni_SubElementSelector::setSubElementType(oop obj, oop type) {</span>
<span class="line-added">4815   obj-&gt;obj_field_put(_subElementType_offset, type);</span>
<span class="line-added">4816 }</span>
<span class="line-added">4817 </span>
<span class="line-added">4818 int jdk_internal_vm_jni_SubElementSelector::getOffset(oop obj) {</span>
<span class="line-added">4819   return obj-&gt;int_field(_offset_offset);</span>
<span class="line-added">4820 }</span>
<span class="line-added">4821 </span>
<span class="line-added">4822 void jdk_internal_vm_jni_SubElementSelector::setOffset(oop obj, int offset) {</span>
<span class="line-added">4823   obj-&gt;int_field_put(_offset_offset, offset);</span>
<span class="line-added">4824 }</span>
<span class="line-added">4825 </span>
<span class="line-added">4826 bool jdk_internal_vm_jni_SubElementSelector::getIsInlined(oop obj) {</span>
<span class="line-added">4827   return obj-&gt;bool_field(_isInlined_offset);</span>
<span class="line-added">4828 }</span>
<span class="line-added">4829 </span>
<span class="line-added">4830 void jdk_internal_vm_jni_SubElementSelector::setIsInlined(oop obj, bool b) {</span>
<span class="line-added">4831   obj-&gt;bool_field_put(_isInlined_offset, b);</span>
<span class="line-added">4832 }</span>
<span class="line-added">4833 </span>
<span class="line-added">4834 bool jdk_internal_vm_jni_SubElementSelector::getIsInlineType(oop obj) {</span>
<span class="line-added">4835   return obj-&gt;bool_field(_isInlineType_offset);</span>
<span class="line-added">4836 }</span>
<span class="line-added">4837 </span>
<span class="line-added">4838 void jdk_internal_vm_jni_SubElementSelector::setIsInlineType(oop obj, bool b) {</span>
<span class="line-added">4839   obj-&gt;bool_field_put(_isInlineType_offset, b);</span>
<span class="line-added">4840 }</span>
<span class="line-added">4841 </span>
4842 jbyte java_lang_Byte::value(oop obj) {
4843    jvalue v;
4844    java_lang_boxing_object::get_value(obj, &amp;v);
4845    return v.b;
4846 }
4847 
4848 int java_lang_Boolean::_static_TRUE_offset;
4849 int java_lang_Boolean::_static_FALSE_offset;
4850 
4851 #define BOOLEAN_FIELDS_DO(macro) \
4852   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4853   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4854 
4855 
4856 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4857   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4858   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4859 }
4860 
4861 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>