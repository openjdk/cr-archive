<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/vmSymbols.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/symbolTable.hpp&quot;
  28 #include &quot;classfile/vmSymbols.hpp&quot;
  29 #include &quot;compiler/compilerDirectives.hpp&quot;
  30 #include &quot;memory/allocation.inline.hpp&quot;
  31 #include &quot;memory/oopFactory.hpp&quot;
  32 #include &quot;memory/metaspaceClosure.hpp&quot;
  33 #include &quot;oops/oop.inline.hpp&quot;
  34 #include &quot;runtime/handles.inline.hpp&quot;
  35 #include &quot;utilities/tribool.hpp&quot;
  36 #include &quot;utilities/xmlstream.hpp&quot;
  37 
  38 
  39 Symbol* vmSymbols::_symbols[vmSymbols::SID_LIMIT];
  40 
  41 Symbol* vmSymbols::_type_signatures[T_VOID+1] = { NULL /*, NULL...*/ };
  42 
  43 inline int compare_symbol(const Symbol* a, const Symbol* b) {
  44   if (a == b)  return 0;
  45   // follow the natural address order:
  46   return (address)a &gt; (address)b ? +1 : -1;
  47 }
  48 
  49 static vmSymbols::SID vm_symbol_index[vmSymbols::SID_LIMIT];
  50 extern &quot;C&quot; {
  51   static int compare_vmsymbol_sid(const void* void_a, const void* void_b) {
  52     const Symbol* a = vmSymbols::symbol_at(*((vmSymbols::SID*) void_a));
  53     const Symbol* b = vmSymbols::symbol_at(*((vmSymbols::SID*) void_b));
  54     return compare_symbol(a, b);
  55   }
  56 }
  57 
  58 #ifdef ASSERT
  59 #define VM_SYMBOL_ENUM_NAME_BODY(name, string) #name &quot;\0&quot;
  60 static const char* vm_symbol_enum_names =
  61   VM_SYMBOLS_DO(VM_SYMBOL_ENUM_NAME_BODY, VM_ALIAS_IGNORE)
  62   &quot;\0&quot;;
  63 static const char* vm_symbol_enum_name(vmSymbols::SID sid) {
  64   const char* string = &amp;vm_symbol_enum_names[0];
  65   int skip = (int)sid - (int)vmSymbols::FIRST_SID;
  66   for (; skip != 0; skip--) {
  67     size_t skiplen = strlen(string);
  68     if (skiplen == 0)  return &quot;&lt;unknown&gt;&quot;;  // overflow
  69     string += skiplen+1;
  70   }
  71   return string;
  72 }
  73 #endif //ASSERT
  74 
  75 // Put all the VM symbol strings in one place.
  76 // Makes for a more compact libjvm.
  77 #define VM_SYMBOL_BODY(name, string) string &quot;\0&quot;
  78 static const char* vm_symbol_bodies = VM_SYMBOLS_DO(VM_SYMBOL_BODY, VM_ALIAS_IGNORE);
  79 
  80 void vmSymbols::initialize(TRAPS) {
  81   assert((int)SID_LIMIT &lt;= (1&lt;&lt;log2_SID_LIMIT), &quot;must fit in this bitfield&quot;);
  82   assert((int)SID_LIMIT*5 &gt; (1&lt;&lt;log2_SID_LIMIT), &quot;make the bitfield smaller, please&quot;);
  83   assert(vmIntrinsics::FLAG_LIMIT &lt;= (1 &lt;&lt; vmIntrinsics::log2_FLAG_LIMIT), &quot;must fit in this bitfield&quot;);
  84 
  85   if (!UseSharedSpaces) {
  86     const char* string = &amp;vm_symbol_bodies[0];
  87     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
  88       Symbol* sym = SymbolTable::new_permanent_symbol(string);
  89       _symbols[index] = sym;
  90       string += strlen(string); // skip string body
  91       string += 1;              // skip trailing null
  92     }
  93 
  94     _type_signatures[T_BYTE]    = byte_signature();
  95     _type_signatures[T_CHAR]    = char_signature();
  96     _type_signatures[T_DOUBLE]  = double_signature();
  97     _type_signatures[T_FLOAT]   = float_signature();
  98     _type_signatures[T_INT]     = int_signature();
  99     _type_signatures[T_LONG]    = long_signature();
 100     _type_signatures[T_SHORT]   = short_signature();
 101     _type_signatures[T_BOOLEAN] = bool_signature();
 102     _type_signatures[T_VOID]    = void_signature();
 103 #ifdef ASSERT
 104     for (int i = (int)T_BOOLEAN; i &lt; (int)T_VOID+1; i++) {
 105       Symbol* s = _type_signatures[i];
 106       if (s == NULL)  continue;
 107       SignatureStream ss(s, false);
 108       assert(ss.type() == i, &quot;matching signature&quot;);
 109       assert(!ss.is_reference(), &quot;no single-char signature for T_OBJECT, etc.&quot;);
 110     }
 111 #endif
 112   }
 113 
 114 #ifdef ASSERT
 115   // Check for duplicates:
 116   for (int i1 = (int)FIRST_SID; i1 &lt; (int)SID_LIMIT; i1++) {
 117     Symbol* sym = symbol_at((SID)i1);
 118     for (int i2 = (int)FIRST_SID; i2 &lt; i1; i2++) {
 119       if (symbol_at((SID)i2) == sym) {
 120         tty-&gt;print(&quot;*** Duplicate VM symbol SIDs %s(%d) and %s(%d): \&quot;&quot;,
 121                    vm_symbol_enum_name((SID)i2), i2,
 122                    vm_symbol_enum_name((SID)i1), i1);
 123         sym-&gt;print_symbol_on(tty);
 124         tty-&gt;print_cr(&quot;\&quot;&quot;);
 125       }
 126     }
 127   }
 128 #endif //ASSERT
 129 
 130   // Create an index for find_id:
 131   {
 132     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 133       vm_symbol_index[index] = (SID)index;
 134     }
 135     int num_sids = SID_LIMIT-FIRST_SID;
 136     qsort(&amp;vm_symbol_index[FIRST_SID], num_sids, sizeof(vm_symbol_index[0]),
 137           compare_vmsymbol_sid);
 138   }
 139 
 140 #ifdef ASSERT
 141   {
 142     // Spot-check correspondence between strings, symbols, and enums:
 143     assert(_symbols[NO_SID] == NULL, &quot;must be&quot;);
 144     const char* str = &quot;java/lang/Object&quot;;
 145     TempNewSymbol jlo = SymbolTable::new_permanent_symbol(str);
 146     assert(strncmp(str, (char*)jlo-&gt;base(), jlo-&gt;utf8_length()) == 0, &quot;&quot;);
 147     assert(jlo == java_lang_Object(), &quot;&quot;);
 148     SID sid = VM_SYMBOL_ENUM_NAME(java_lang_Object);
 149     assert(find_sid(jlo) == sid, &quot;&quot;);
 150     assert(symbol_at(sid) == jlo, &quot;&quot;);
 151 
 152     // Make sure find_sid produces the right answer in each case.
 153     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 154       Symbol* sym = symbol_at((SID)index);
 155       sid = find_sid(sym);
 156       assert(sid == (SID)index, &quot;symbol index works&quot;);
 157       // Note:  If there are duplicates, this assert will fail.
 158       // A &quot;Duplicate VM symbol&quot; message will have already been printed.
 159     }
 160 
 161     // The string &quot;format&quot; happens (at the moment) not to be a vmSymbol,
 162     // though it is a method name in java.lang.String.
 163     str = &quot;format&quot;;
 164     TempNewSymbol fmt = SymbolTable::new_permanent_symbol(str);
 165     sid = find_sid(fmt);
 166     assert(sid == NO_SID, &quot;symbol index works (negative test)&quot;);
 167   }
 168 #endif
 169 }
 170 
 171 
 172 #ifndef PRODUCT
 173 const char* vmSymbols::name_for(vmSymbols::SID sid) {
 174   if (sid == NO_SID)
 175     return &quot;NO_SID&quot;;
 176   const char* string = &amp;vm_symbol_bodies[0];
 177   for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 178     if (index == (int)sid)
 179       return string;
 180     string += strlen(string); // skip string body
 181     string += 1;              // skip trailing null
 182   }
 183   return &quot;BAD_SID&quot;;
 184 }
 185 #endif
 186 
 187 
 188 
 189 void vmSymbols::symbols_do(SymbolClosure* f) {
 190   for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 191     f-&gt;do_symbol(&amp;_symbols[index]);
 192   }
 193   for (int i = 0; i &lt; T_VOID+1; i++) {
 194     f-&gt;do_symbol(&amp;_type_signatures[i]);
 195   }
 196 }
 197 
 198 void vmSymbols::metaspace_pointers_do(MetaspaceClosure *it) {
 199   for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 200     it-&gt;push(&amp;_symbols[index]);
 201   }
 202   for (int i = 0; i &lt; T_VOID+1; i++) {
 203     it-&gt;push(&amp;_type_signatures[i]);
 204   }
 205 }
 206 
 207 void vmSymbols::serialize(SerializeClosure* soc) {
 208   soc-&gt;do_region((u_char*)&amp;_symbols[FIRST_SID],
 209                  (SID_LIMIT - FIRST_SID) * sizeof(_symbols[0]));
 210   soc-&gt;do_region((u_char*)_type_signatures, sizeof(_type_signatures));
 211 }
 212 
 213 static int mid_hint = (int)vmSymbols::FIRST_SID+1;
 214 
 215 #ifndef PRODUCT
 216 static int find_sid_calls, find_sid_probes;
 217 // (Typical counts are calls=7000 and probes=17000.)
 218 #endif
 219 
 220 vmSymbols::SID vmSymbols::find_sid(const Symbol* symbol) {
 221   // Handle the majority of misses by a bounds check.
 222   // Then, use a binary search over the index.
 223   // Expected trip count is less than log2_SID_LIMIT, about eight.
 224   // This is slow but acceptable, given that calls are not
 225   // dynamically common.  (Method*::intrinsic_id has a cache.)
 226   NOT_PRODUCT(find_sid_calls++);
 227   int min = (int)FIRST_SID, max = (int)SID_LIMIT - 1;
 228   SID sid = NO_SID, sid1;
 229   int cmp1;
 230   sid1 = vm_symbol_index[min];
 231   cmp1 = compare_symbol(symbol, symbol_at(sid1));
 232   if (cmp1 &lt;= 0) {              // before the first
 233     if (cmp1 == 0)  sid = sid1;
 234   } else {
 235     sid1 = vm_symbol_index[max];
 236     cmp1 = compare_symbol(symbol, symbol_at(sid1));
 237     if (cmp1 &gt;= 0) {            // after the last
 238       if (cmp1 == 0)  sid = sid1;
 239     } else {
 240       // After checking the extremes, do a binary search.
 241       ++min; --max;             // endpoints are done
 242       int mid = mid_hint;       // start at previous success
 243       while (max &gt;= min) {
 244         assert(mid &gt;= min &amp;&amp; mid &lt;= max, &quot;&quot;);
 245         NOT_PRODUCT(find_sid_probes++);
 246         sid1 = vm_symbol_index[mid];
 247         cmp1 = compare_symbol(symbol, symbol_at(sid1));
 248         if (cmp1 == 0) {
 249           mid_hint = mid;
 250           sid = sid1;
 251           break;
 252         }
 253         if (cmp1 &lt; 0)
 254           max = mid - 1;        // symbol &lt; symbol_at(sid)
 255         else
 256           min = mid + 1;
 257 
 258         // Pick a new probe point:
 259         mid = (max + min) / 2;
 260       }
 261     }
 262   }
 263 
 264 #ifdef ASSERT
 265   // Perform the exhaustive self-check the first 1000 calls,
 266   // and every 100 calls thereafter.
 267   static int find_sid_check_count = -2000;
 268   if ((uint)++find_sid_check_count &gt; (uint)100) {
 269     if (find_sid_check_count &gt; 0)  find_sid_check_count = 0;
 270 
 271     // Make sure this is the right answer, using linear search.
 272     // (We have already proven that there are no duplicates in the list.)
 273     SID sid2 = NO_SID;
 274     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 275       Symbol* sym2 = symbol_at((SID)index);
 276       if (sym2 == symbol) {
 277         sid2 = (SID)index;
 278         break;
 279       }
 280     }
 281     // Unless it&#39;s a duplicate, assert that the sids are the same.
 282     if (_symbols[sid] != _symbols[sid2]) {
 283       assert(sid == sid2, &quot;binary same as linear search&quot;);
 284     }
 285   }
 286 #endif //ASSERT
 287 
 288   return sid;
 289 }
 290 
 291 vmSymbols::SID vmSymbols::find_sid(const char* symbol_name) {
 292   Symbol* symbol = SymbolTable::probe(symbol_name, (int) strlen(symbol_name));
 293   if (symbol == NULL)  return NO_SID;
 294   return find_sid(symbol);
 295 }
 296 
 297 static vmIntrinsics::ID wrapper_intrinsic(BasicType type, bool unboxing) {
 298 #define TYPE2(type, unboxing) ((int)(type)*2 + ((unboxing) ? 1 : 0))
 299   switch (TYPE2(type, unboxing)) {
 300 #define BASIC_TYPE_CASE(type, box, unbox) \
 301     case TYPE2(type, false):  return vmIntrinsics::box; \
 302     case TYPE2(type, true):   return vmIntrinsics::unbox
 303     BASIC_TYPE_CASE(T_BOOLEAN, _Boolean_valueOf,   _booleanValue);
 304     BASIC_TYPE_CASE(T_BYTE,    _Byte_valueOf,      _byteValue);
 305     BASIC_TYPE_CASE(T_CHAR,    _Character_valueOf, _charValue);
 306     BASIC_TYPE_CASE(T_SHORT,   _Short_valueOf,     _shortValue);
 307     BASIC_TYPE_CASE(T_INT,     _Integer_valueOf,   _intValue);
 308     BASIC_TYPE_CASE(T_LONG,    _Long_valueOf,      _longValue);
 309     BASIC_TYPE_CASE(T_FLOAT,   _Float_valueOf,     _floatValue);
 310     BASIC_TYPE_CASE(T_DOUBLE,  _Double_valueOf,    _doubleValue);
 311 #undef BASIC_TYPE_CASE
 312   }
 313 #undef TYPE2
 314   return vmIntrinsics::_none;
 315 }
 316 
 317 vmIntrinsics::ID vmIntrinsics::for_boxing(BasicType type) {
 318   return wrapper_intrinsic(type, false);
 319 }
 320 vmIntrinsics::ID vmIntrinsics::for_unboxing(BasicType type) {
 321   return wrapper_intrinsic(type, true);
 322 }
 323 
 324 vmIntrinsics::ID vmIntrinsics::for_raw_conversion(BasicType src, BasicType dest) {
 325 #define SRC_DEST(s,d) (((int)(s) &lt;&lt; 4) + (int)(d))
 326   switch (SRC_DEST(src, dest)) {
 327   case SRC_DEST(T_INT, T_FLOAT):   return vmIntrinsics::_intBitsToFloat;
 328   case SRC_DEST(T_FLOAT, T_INT):   return vmIntrinsics::_floatToRawIntBits;
 329 
 330   case SRC_DEST(T_LONG, T_DOUBLE): return vmIntrinsics::_longBitsToDouble;
 331   case SRC_DEST(T_DOUBLE, T_LONG): return vmIntrinsics::_doubleToRawLongBits;
 332   }
 333 #undef SRC_DEST
 334 
 335   return vmIntrinsics::_none;
 336 }
 337 
 338 bool vmIntrinsics::preserves_state(vmIntrinsics::ID id) {
 339   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 340   switch(id) {
 341 #ifdef JFR_HAVE_INTRINSICS
 342   case vmIntrinsics::_counterTime:
 343 #endif
 344   case vmIntrinsics::_currentTimeMillis:
 345   case vmIntrinsics::_nanoTime:
 346   case vmIntrinsics::_floatToRawIntBits:
 347   case vmIntrinsics::_intBitsToFloat:
 348   case vmIntrinsics::_doubleToRawLongBits:
 349   case vmIntrinsics::_longBitsToDouble:
 350   case vmIntrinsics::_getClass:
 351   case vmIntrinsics::_isInstance:
 352   case vmIntrinsics::_currentThread:
 353   case vmIntrinsics::_dabs:
 354   case vmIntrinsics::_fabs:
 355   case vmIntrinsics::_iabs:
 356   case vmIntrinsics::_labs:
 357   case vmIntrinsics::_dsqrt:
 358   case vmIntrinsics::_dsin:
 359   case vmIntrinsics::_dcos:
 360   case vmIntrinsics::_dtan:
 361   case vmIntrinsics::_dlog:
 362   case vmIntrinsics::_dlog10:
 363   case vmIntrinsics::_dexp:
 364   case vmIntrinsics::_dpow:
 365   case vmIntrinsics::_checkIndex:
 366   case vmIntrinsics::_Reference_get:
 367   case vmIntrinsics::_updateCRC32:
 368   case vmIntrinsics::_updateBytesCRC32:
 369   case vmIntrinsics::_updateByteBufferCRC32:
 370   case vmIntrinsics::_vectorizedMismatch:
 371   case vmIntrinsics::_fmaD:
 372   case vmIntrinsics::_fmaF:
 373   case vmIntrinsics::_isDigit:
 374   case vmIntrinsics::_isLowerCase:
 375   case vmIntrinsics::_isUpperCase:
 376   case vmIntrinsics::_isWhitespace:
 377     return true;
 378   default:
 379     return false;
 380   }
 381 }
 382 
 383 bool vmIntrinsics::can_trap(vmIntrinsics::ID id) {
 384   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 385   switch(id) {
 386 #ifdef JFR_HAVE_INTRINSICS
 387   case vmIntrinsics::_counterTime:
 388   case vmIntrinsics::_getClassId:
 389 #endif
 390   case vmIntrinsics::_currentTimeMillis:
 391   case vmIntrinsics::_nanoTime:
 392   case vmIntrinsics::_floatToRawIntBits:
 393   case vmIntrinsics::_intBitsToFloat:
 394   case vmIntrinsics::_doubleToRawLongBits:
 395   case vmIntrinsics::_longBitsToDouble:
 396   case vmIntrinsics::_currentThread:
 397   case vmIntrinsics::_dabs:
 398   case vmIntrinsics::_fabs:
 399   case vmIntrinsics::_iabs:
 400   case vmIntrinsics::_labs:
 401   case vmIntrinsics::_dsqrt:
 402   case vmIntrinsics::_dsin:
 403   case vmIntrinsics::_dcos:
 404   case vmIntrinsics::_dtan:
 405   case vmIntrinsics::_dlog:
 406   case vmIntrinsics::_dlog10:
 407   case vmIntrinsics::_dexp:
 408   case vmIntrinsics::_dpow:
 409   case vmIntrinsics::_updateCRC32:
 410   case vmIntrinsics::_updateBytesCRC32:
 411   case vmIntrinsics::_updateByteBufferCRC32:
 412   case vmIntrinsics::_vectorizedMismatch:
 413   case vmIntrinsics::_fmaD:
 414   case vmIntrinsics::_fmaF:
 415     return false;
 416   default:
 417     return true;
 418   }
 419 }
 420 
 421 // Some intrinsics produce different results if they are not pinned
 422 bool vmIntrinsics::should_be_pinned(vmIntrinsics::ID id) {
 423   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 424   switch(id) {
 425 #ifdef JFR_HAVE_INTRINSICS
 426   case vmIntrinsics::_counterTime:
 427 #endif
 428   case vmIntrinsics::_currentTimeMillis:
 429   case vmIntrinsics::_nanoTime:
 430     return true;
 431   default:
 432     return false;
 433   }
 434 }
 435 
 436 bool vmIntrinsics::does_virtual_dispatch(vmIntrinsics::ID id) {
 437   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 438   switch(id) {
 439   case vmIntrinsics::_hashCode:
 440   case vmIntrinsics::_clone:
 441     return true;
 442     break;
 443   default:
 444     return false;
 445   }
 446 }
 447 
 448 int vmIntrinsics::predicates_needed(vmIntrinsics::ID id) {
 449   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 450   switch (id) {
 451   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 452   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 453   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
 454   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
 455   case vmIntrinsics::_counterMode_AESCrypt:
 456     return 1;
 457   case vmIntrinsics::_digestBase_implCompressMB:
 458     return 3;
 459   default:
 460     return 0;
 461   }
 462 }
 463 
 464 bool vmIntrinsics::disabled_by_jvm_flags(vmIntrinsics::ID id) {
 465   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 466 
 467   // -XX:-InlineNatives disables nearly all intrinsics except the ones listed in
 468   // the following switch statement.
 469   if (!InlineNatives) {
 470     switch (id) {
 471     case vmIntrinsics::_indexOfL:
 472     case vmIntrinsics::_indexOfU:
 473     case vmIntrinsics::_indexOfUL:
 474     case vmIntrinsics::_indexOfIL:
 475     case vmIntrinsics::_indexOfIU:
 476     case vmIntrinsics::_indexOfIUL:
 477     case vmIntrinsics::_indexOfU_char:
 478     case vmIntrinsics::_compareToL:
 479     case vmIntrinsics::_compareToU:
 480     case vmIntrinsics::_compareToLU:
 481     case vmIntrinsics::_compareToUL:
 482     case vmIntrinsics::_equalsL:
 483     case vmIntrinsics::_equalsU:
 484     case vmIntrinsics::_equalsC:
 485     case vmIntrinsics::_getCharStringU:
 486     case vmIntrinsics::_putCharStringU:
 487     case vmIntrinsics::_compressStringC:
 488     case vmIntrinsics::_compressStringB:
 489     case vmIntrinsics::_inflateStringC:
 490     case vmIntrinsics::_inflateStringB:
 491     case vmIntrinsics::_getAndAddInt:
 492     case vmIntrinsics::_getAndAddLong:
 493     case vmIntrinsics::_getAndSetInt:
 494     case vmIntrinsics::_getAndSetLong:
 495     case vmIntrinsics::_getAndSetReference:
 496     case vmIntrinsics::_loadFence:
 497     case vmIntrinsics::_storeFence:
 498     case vmIntrinsics::_fullFence:
 499     case vmIntrinsics::_hasNegatives:
 500     case vmIntrinsics::_Reference_get:
 501       break;
 502     default:
 503       return true;
 504     }
 505   }
 506 
 507   switch (id) {
 508   case vmIntrinsics::_isInstance:
 509   case vmIntrinsics::_isAssignableFrom:
 510   case vmIntrinsics::_getModifiers:
 511   case vmIntrinsics::_isInterface:
 512   case vmIntrinsics::_isArray:
 513   case vmIntrinsics::_isPrimitive:
 514   case vmIntrinsics::_isHidden:
 515   case vmIntrinsics::_getSuperclass:
 516   case vmIntrinsics::_Class_cast:
 517   case vmIntrinsics::_getLength:
 518   case vmIntrinsics::_newArray:
 519   case vmIntrinsics::_getClass:
 520     if (!InlineClassNatives) return true;
 521     break;
 522   case vmIntrinsics::_currentThread:
 523     if (!InlineThreadNatives) return true;
 524     break;
 525   case vmIntrinsics::_floatToRawIntBits:
 526   case vmIntrinsics::_intBitsToFloat:
 527   case vmIntrinsics::_doubleToRawLongBits:
 528   case vmIntrinsics::_longBitsToDouble:
 529   case vmIntrinsics::_ceil:
 530   case vmIntrinsics::_floor:
 531   case vmIntrinsics::_rint:
 532   case vmIntrinsics::_dabs:
 533   case vmIntrinsics::_fabs:
 534   case vmIntrinsics::_iabs:
 535   case vmIntrinsics::_labs:
 536   case vmIntrinsics::_dsqrt:
 537   case vmIntrinsics::_dsin:
 538   case vmIntrinsics::_dcos:
 539   case vmIntrinsics::_dtan:
 540   case vmIntrinsics::_dlog:
 541   case vmIntrinsics::_dexp:
 542   case vmIntrinsics::_dpow:
 543   case vmIntrinsics::_dlog10:
 544   case vmIntrinsics::_datan2:
 545   case vmIntrinsics::_min:
 546   case vmIntrinsics::_max:
 547   case vmIntrinsics::_floatToIntBits:
 548   case vmIntrinsics::_doubleToLongBits:
 549   case vmIntrinsics::_maxF:
 550   case vmIntrinsics::_minF:
 551   case vmIntrinsics::_maxD:
 552   case vmIntrinsics::_minD:
 553     if (!InlineMathNatives) return true;
 554     break;
 555   case vmIntrinsics::_fmaD:
 556   case vmIntrinsics::_fmaF:
 557     if (!InlineMathNatives || !UseFMA) return true;
 558     break;
 559   case vmIntrinsics::_arraycopy:
 560     if (!InlineArrayCopy) return true;
 561     break;
 562   case vmIntrinsics::_updateCRC32:
 563   case vmIntrinsics::_updateBytesCRC32:
 564   case vmIntrinsics::_updateByteBufferCRC32:
 565     if (!UseCRC32Intrinsics) return true;
 566     break;
<a name="1" id="anc1"></a><span class="line-added"> 567   case vmIntrinsics::_makePrivateBuffer:</span>
<span class="line-added"> 568   case vmIntrinsics::_finishPrivateBuffer:</span>
 569   case vmIntrinsics::_getReference:
 570   case vmIntrinsics::_getBoolean:
 571   case vmIntrinsics::_getByte:
 572   case vmIntrinsics::_getShort:
 573   case vmIntrinsics::_getChar:
 574   case vmIntrinsics::_getInt:
 575   case vmIntrinsics::_getLong:
 576   case vmIntrinsics::_getFloat:
 577   case vmIntrinsics::_getDouble:
<a name="2" id="anc2"></a><span class="line-added"> 578   case vmIntrinsics::_getValue:</span>
 579   case vmIntrinsics::_putReference:
 580   case vmIntrinsics::_putBoolean:
 581   case vmIntrinsics::_putByte:
 582   case vmIntrinsics::_putShort:
 583   case vmIntrinsics::_putChar:
 584   case vmIntrinsics::_putInt:
 585   case vmIntrinsics::_putLong:
 586   case vmIntrinsics::_putFloat:
 587   case vmIntrinsics::_putDouble:
<a name="3" id="anc3"></a><span class="line-added"> 588   case vmIntrinsics::_putValue:</span>
 589   case vmIntrinsics::_getReferenceVolatile:
 590   case vmIntrinsics::_getBooleanVolatile:
 591   case vmIntrinsics::_getByteVolatile:
 592   case vmIntrinsics::_getShortVolatile:
 593   case vmIntrinsics::_getCharVolatile:
 594   case vmIntrinsics::_getIntVolatile:
 595   case vmIntrinsics::_getLongVolatile:
 596   case vmIntrinsics::_getFloatVolatile:
 597   case vmIntrinsics::_getDoubleVolatile:
 598   case vmIntrinsics::_putReferenceVolatile:
 599   case vmIntrinsics::_putBooleanVolatile:
 600   case vmIntrinsics::_putByteVolatile:
 601   case vmIntrinsics::_putShortVolatile:
 602   case vmIntrinsics::_putCharVolatile:
 603   case vmIntrinsics::_putIntVolatile:
 604   case vmIntrinsics::_putLongVolatile:
 605   case vmIntrinsics::_putFloatVolatile:
 606   case vmIntrinsics::_putDoubleVolatile:
 607   case vmIntrinsics::_getReferenceAcquire:
 608   case vmIntrinsics::_getBooleanAcquire:
 609   case vmIntrinsics::_getByteAcquire:
 610   case vmIntrinsics::_getShortAcquire:
 611   case vmIntrinsics::_getCharAcquire:
 612   case vmIntrinsics::_getIntAcquire:
 613   case vmIntrinsics::_getLongAcquire:
 614   case vmIntrinsics::_getFloatAcquire:
 615   case vmIntrinsics::_getDoubleAcquire:
 616   case vmIntrinsics::_putReferenceRelease:
 617   case vmIntrinsics::_putBooleanRelease:
 618   case vmIntrinsics::_putByteRelease:
 619   case vmIntrinsics::_putShortRelease:
 620   case vmIntrinsics::_putCharRelease:
 621   case vmIntrinsics::_putIntRelease:
 622   case vmIntrinsics::_putLongRelease:
 623   case vmIntrinsics::_putFloatRelease:
 624   case vmIntrinsics::_putDoubleRelease:
 625   case vmIntrinsics::_getReferenceOpaque:
 626   case vmIntrinsics::_getBooleanOpaque:
 627   case vmIntrinsics::_getByteOpaque:
 628   case vmIntrinsics::_getShortOpaque:
 629   case vmIntrinsics::_getCharOpaque:
 630   case vmIntrinsics::_getIntOpaque:
 631   case vmIntrinsics::_getLongOpaque:
 632   case vmIntrinsics::_getFloatOpaque:
 633   case vmIntrinsics::_getDoubleOpaque:
 634   case vmIntrinsics::_putReferenceOpaque:
 635   case vmIntrinsics::_putBooleanOpaque:
 636   case vmIntrinsics::_putByteOpaque:
 637   case vmIntrinsics::_putShortOpaque:
 638   case vmIntrinsics::_putCharOpaque:
 639   case vmIntrinsics::_putIntOpaque:
 640   case vmIntrinsics::_putLongOpaque:
 641   case vmIntrinsics::_putFloatOpaque:
 642   case vmIntrinsics::_putDoubleOpaque:
 643   case vmIntrinsics::_getAndAddInt:
 644   case vmIntrinsics::_getAndAddLong:
 645   case vmIntrinsics::_getAndSetInt:
 646   case vmIntrinsics::_getAndSetLong:
 647   case vmIntrinsics::_getAndSetReference:
 648   case vmIntrinsics::_loadFence:
 649   case vmIntrinsics::_storeFence:
 650   case vmIntrinsics::_fullFence:
 651   case vmIntrinsics::_compareAndSetLong:
 652   case vmIntrinsics::_weakCompareAndSetLong:
 653   case vmIntrinsics::_weakCompareAndSetLongPlain:
 654   case vmIntrinsics::_weakCompareAndSetLongAcquire:
 655   case vmIntrinsics::_weakCompareAndSetLongRelease:
 656   case vmIntrinsics::_compareAndSetInt:
 657   case vmIntrinsics::_weakCompareAndSetInt:
 658   case vmIntrinsics::_weakCompareAndSetIntPlain:
 659   case vmIntrinsics::_weakCompareAndSetIntAcquire:
 660   case vmIntrinsics::_weakCompareAndSetIntRelease:
 661   case vmIntrinsics::_compareAndSetReference:
 662   case vmIntrinsics::_weakCompareAndSetReference:
 663   case vmIntrinsics::_weakCompareAndSetReferencePlain:
 664   case vmIntrinsics::_weakCompareAndSetReferenceAcquire:
 665   case vmIntrinsics::_weakCompareAndSetReferenceRelease:
 666   case vmIntrinsics::_compareAndExchangeInt:
 667   case vmIntrinsics::_compareAndExchangeIntAcquire:
 668   case vmIntrinsics::_compareAndExchangeIntRelease:
 669   case vmIntrinsics::_compareAndExchangeLong:
 670   case vmIntrinsics::_compareAndExchangeLongAcquire:
 671   case vmIntrinsics::_compareAndExchangeLongRelease:
 672   case vmIntrinsics::_compareAndExchangeReference:
 673   case vmIntrinsics::_compareAndExchangeReferenceAcquire:
 674   case vmIntrinsics::_compareAndExchangeReferenceRelease:
 675     if (!InlineUnsafeOps) return true;
 676     break;
 677   case vmIntrinsics::_getShortUnaligned:
 678   case vmIntrinsics::_getCharUnaligned:
 679   case vmIntrinsics::_getIntUnaligned:
 680   case vmIntrinsics::_getLongUnaligned:
 681   case vmIntrinsics::_putShortUnaligned:
 682   case vmIntrinsics::_putCharUnaligned:
 683   case vmIntrinsics::_putIntUnaligned:
 684   case vmIntrinsics::_putLongUnaligned:
 685   case vmIntrinsics::_allocateInstance:
 686     if (!InlineUnsafeOps || !UseUnalignedAccesses) return true;
 687     break;
 688   case vmIntrinsics::_hashCode:
 689     if (!InlineObjectHash) return true;
 690     break;
 691   case vmIntrinsics::_aescrypt_encryptBlock:
 692   case vmIntrinsics::_aescrypt_decryptBlock:
 693     if (!UseAESIntrinsics) return true;
 694     break;
 695   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 696   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 697     if (!UseAESIntrinsics) return true;
 698     break;
 699   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
 700   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
 701     if (!UseAESIntrinsics) return true;
 702     break;
 703   case vmIntrinsics::_counterMode_AESCrypt:
 704     if (!UseAESCTRIntrinsics) return true;
 705     break;
 706   case vmIntrinsics::_sha_implCompress:
 707     if (!UseSHA1Intrinsics) return true;
 708     break;
 709   case vmIntrinsics::_sha2_implCompress:
 710     if (!UseSHA256Intrinsics) return true;
 711     break;
 712   case vmIntrinsics::_sha5_implCompress:
 713     if (!UseSHA512Intrinsics) return true;
 714     break;
 715   case vmIntrinsics::_digestBase_implCompressMB:
 716     if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) return true;
 717     break;
 718   case vmIntrinsics::_ghash_processBlocks:
 719     if (!UseGHASHIntrinsics) return true;
 720     break;
 721   case vmIntrinsics::_base64_encodeBlock:
 722     if (!UseBASE64Intrinsics) return true;
 723     break;
 724   case vmIntrinsics::_updateBytesCRC32C:
 725   case vmIntrinsics::_updateDirectByteBufferCRC32C:
 726     if (!UseCRC32CIntrinsics) return true;
 727     break;
 728   case vmIntrinsics::_vectorizedMismatch:
 729     if (!UseVectorizedMismatchIntrinsic) return true;
 730     break;
 731   case vmIntrinsics::_updateBytesAdler32:
 732   case vmIntrinsics::_updateByteBufferAdler32:
 733     if (!UseAdler32Intrinsics) return true;
 734     break;
 735   case vmIntrinsics::_copyMemory:
 736     if (!InlineArrayCopy || !InlineUnsafeOps) return true;
 737     break;
 738 #ifdef COMPILER1
 739   case vmIntrinsics::_checkIndex:
 740     if (!InlineNIOCheckIndex) return true;
 741     break;
 742 #endif // COMPILER1
 743 #ifdef COMPILER2
 744   case vmIntrinsics::_clone:
 745   case vmIntrinsics::_copyOf:
 746   case vmIntrinsics::_copyOfRange:
 747     // These intrinsics use both the objectcopy and the arraycopy
 748     // intrinsic mechanism.
 749     if (!InlineObjectCopy || !InlineArrayCopy) return true;
 750     break;
 751   case vmIntrinsics::_compareToL:
 752   case vmIntrinsics::_compareToU:
 753   case vmIntrinsics::_compareToLU:
 754   case vmIntrinsics::_compareToUL:
 755     if (!SpecialStringCompareTo) return true;
 756     break;
 757   case vmIntrinsics::_indexOfL:
 758   case vmIntrinsics::_indexOfU:
 759   case vmIntrinsics::_indexOfUL:
 760   case vmIntrinsics::_indexOfIL:
 761   case vmIntrinsics::_indexOfIU:
 762   case vmIntrinsics::_indexOfIUL:
 763   case vmIntrinsics::_indexOfU_char:
 764     if (!SpecialStringIndexOf) return true;
 765     break;
 766   case vmIntrinsics::_equalsL:
 767   case vmIntrinsics::_equalsU:
 768     if (!SpecialStringEquals) return true;
 769     break;
 770   case vmIntrinsics::_equalsB:
 771   case vmIntrinsics::_equalsC:
 772     if (!SpecialArraysEquals) return true;
 773     break;
 774   case vmIntrinsics::_encodeISOArray:
 775   case vmIntrinsics::_encodeByteISOArray:
 776     if (!SpecialEncodeISOArray) return true;
 777     break;
 778   case vmIntrinsics::_getCallerClass:
 779     if (!InlineReflectionGetCallerClass) return true;
 780     break;
 781   case vmIntrinsics::_multiplyToLen:
 782     if (!UseMultiplyToLenIntrinsic) return true;
 783     break;
 784   case vmIntrinsics::_squareToLen:
 785     if (!UseSquareToLenIntrinsic) return true;
 786     break;
 787   case vmIntrinsics::_mulAdd:
 788     if (!UseMulAddIntrinsic) return true;
 789     break;
 790   case vmIntrinsics::_montgomeryMultiply:
 791     if (!UseMontgomeryMultiplyIntrinsic) return true;
 792     break;
 793   case vmIntrinsics::_montgomerySquare:
 794     if (!UseMontgomerySquareIntrinsic) return true;
 795     break;
 796   case vmIntrinsics::_bigIntegerRightShiftWorker:
 797   case vmIntrinsics::_bigIntegerLeftShiftWorker:
 798     break;
 799   case vmIntrinsics::_addExactI:
 800   case vmIntrinsics::_addExactL:
 801   case vmIntrinsics::_decrementExactI:
 802   case vmIntrinsics::_decrementExactL:
 803   case vmIntrinsics::_incrementExactI:
 804   case vmIntrinsics::_incrementExactL:
 805   case vmIntrinsics::_multiplyExactI:
 806   case vmIntrinsics::_multiplyExactL:
 807   case vmIntrinsics::_negateExactI:
 808   case vmIntrinsics::_negateExactL:
 809   case vmIntrinsics::_subtractExactI:
 810   case vmIntrinsics::_subtractExactL:
 811     if (!UseMathExactIntrinsics || !InlineMathNatives) return true;
 812     break;
 813   case vmIntrinsics::_isDigit:
 814   case vmIntrinsics::_isLowerCase:
 815   case vmIntrinsics::_isUpperCase:
 816   case vmIntrinsics::_isWhitespace:
 817     if (!UseCharacterCompareIntrinsics) return true;
 818     break;
 819 #endif // COMPILER2
 820   default:
 821     return false;
 822   }
 823 
 824   return false;
 825 }
 826 
 827 #define VM_INTRINSIC_INITIALIZE(id, klass, name, sig, flags) #id &quot;\0&quot;
 828 static const char* vm_intrinsic_name_bodies =
 829   VM_INTRINSICS_DO(VM_INTRINSIC_INITIALIZE,
 830                    VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);
 831 
 832 static const char* vm_intrinsic_name_table[vmIntrinsics::ID_LIMIT];
 833 static TriBoolArray&lt;vmIntrinsics::ID_LIMIT, int&gt; vm_intrinsic_control_words;
 834 
 835 static void init_vm_intrinsic_name_table() {
 836   const char** nt = &amp;vm_intrinsic_name_table[0];
 837   char* string = (char*) &amp;vm_intrinsic_name_bodies[0];
 838   for (int index = vmIntrinsics::FIRST_ID; index &lt; vmIntrinsics::ID_LIMIT; index++) {
 839     nt[index] = string;
 840     string += strlen(string); // skip string body
 841     string += 1;              // skip trailing null
 842   }
 843   assert(!strcmp(nt[vmIntrinsics::_hashCode], &quot;_hashCode&quot;), &quot;lined up&quot;);
 844   nt[vmIntrinsics::_none] = &quot;_none&quot;;
 845 }
 846 
 847 const char* vmIntrinsics::name_at(vmIntrinsics::ID id) {
 848   const char** nt = &amp;vm_intrinsic_name_table[0];
 849   if (nt[_none] == NULL) {
 850     init_vm_intrinsic_name_table();
 851   }
 852 
 853   if ((uint)id &lt; (uint)ID_LIMIT)
 854     return vm_intrinsic_name_table[(uint)id];
 855   else
 856     return &quot;(unknown intrinsic)&quot;;
 857 }
 858 
 859 vmIntrinsics::ID vmIntrinsics::find_id(const char* name) {
 860   const char** nt = &amp;vm_intrinsic_name_table[0];
 861   if (nt[_none] == NULL) {
 862     init_vm_intrinsic_name_table();
 863   }
 864 
 865   for (int index = FIRST_ID; index &lt; ID_LIMIT; ++index) {
 866     if (0 == strcmp(name, nt[index])) {
 867       return ID_from(index);
 868     }
 869   }
 870 
 871   return _none;
 872 }
 873 
 874 bool vmIntrinsics::is_disabled_by_flags(const methodHandle&amp; method) {
 875   vmIntrinsics::ID id = method-&gt;intrinsic_id();
 876   return is_disabled_by_flags(id);
 877 }
 878 
 879 bool vmIntrinsics::is_disabled_by_flags(vmIntrinsics::ID id) {
 880   assert(id &gt; _none &amp;&amp; id &lt; ID_LIMIT, &quot;must be a VM intrinsic&quot;);
 881 
 882   // not initialized yet, process Control/DisableIntrinsic
 883   if (vm_intrinsic_control_words[_none].is_default()) {
 884     for (ControlIntrinsicIter iter(ControlIntrinsic); *iter != NULL; ++iter) {
 885       vmIntrinsics::ID id = vmIntrinsics::find_id(*iter);
 886 
 887       if (id != vmIntrinsics::_none) {
 888         vm_intrinsic_control_words[id] = iter.is_enabled() &amp;&amp; !disabled_by_jvm_flags(id);
 889       }
 890     }
 891 
 892     // Order matters, DisableIntrinsic can overwrite ControlIntrinsic
 893     for (ControlIntrinsicIter iter(DisableIntrinsic, true/*disable_all*/); *iter != NULL; ++iter) {
 894       vmIntrinsics::ID id = vmIntrinsics::find_id(*iter);
 895 
 896       if (id != vmIntrinsics::_none) {
 897         vm_intrinsic_control_words[id] = false;
 898       }
 899     }
 900 
 901     vm_intrinsic_control_words[_none] = true;
 902   }
 903 
 904   TriBool b = vm_intrinsic_control_words[id];
 905   if (b.is_default()) {
 906     // unknown yet, query and cache it
 907     b = vm_intrinsic_control_words[id] = !disabled_by_jvm_flags(id);
 908   }
 909 
 910   return !b;
 911 }
 912 
 913 // These are flag-matching functions:
 914 inline bool match_F_R(jshort flags) {
 915   const int req = 0;
 916   const int neg = JVM_ACC_STATIC | JVM_ACC_SYNCHRONIZED;
 917   return (flags &amp; (req | neg)) == req;
 918 }
 919 inline bool match_F_Y(jshort flags) {
 920   const int req = JVM_ACC_SYNCHRONIZED;
 921   const int neg = JVM_ACC_STATIC;
 922   return (flags &amp; (req | neg)) == req;
 923 }
 924 inline bool match_F_RN(jshort flags) {
 925   const int req = JVM_ACC_NATIVE;
 926   const int neg = JVM_ACC_STATIC | JVM_ACC_SYNCHRONIZED;
 927   return (flags &amp; (req | neg)) == req;
 928 }
 929 inline bool match_F_S(jshort flags) {
 930   const int req = JVM_ACC_STATIC;
 931   const int neg = JVM_ACC_SYNCHRONIZED;
 932   return (flags &amp; (req | neg)) == req;
 933 }
 934 inline bool match_F_SN(jshort flags) {
 935   const int req = JVM_ACC_STATIC | JVM_ACC_NATIVE;
 936   const int neg = JVM_ACC_SYNCHRONIZED;
 937   return (flags &amp; (req | neg)) == req;
 938 }
 939 inline bool match_F_RNY(jshort flags) {
 940   const int req = JVM_ACC_NATIVE | JVM_ACC_SYNCHRONIZED;
 941   const int neg = JVM_ACC_STATIC;
 942   return (flags &amp; (req | neg)) == req;
 943 }
 944 
 945 // These are for forming case labels:
 946 #define ID3(x, y, z) (( jlong)(z) +                                  \
 947                       ((jlong)(y) &lt;&lt;    vmSymbols::log2_SID_LIMIT) + \
 948                       ((jlong)(x) &lt;&lt; (2*vmSymbols::log2_SID_LIMIT))  )
 949 #define SID_ENUM(n) vmSymbols::VM_SYMBOL_ENUM_NAME(n)
 950 
 951 vmIntrinsics::ID vmIntrinsics::find_id_impl(vmSymbols::SID holder,
 952                                             vmSymbols::SID name,
 953                                             vmSymbols::SID sig,
 954                                             jshort flags) {
 955   assert((int)vmSymbols::SID_LIMIT &lt;= (1&lt;&lt;vmSymbols::log2_SID_LIMIT), &quot;must fit&quot;);
 956 
 957   // Let the C compiler build the decision tree.
 958 
 959 #define VM_INTRINSIC_CASE(id, klass, name, sig, fcode) \
 960   case ID3(SID_ENUM(klass), SID_ENUM(name), SID_ENUM(sig)): \
 961     if (!match_##fcode(flags))  break; \
 962     return id;
 963 
 964   switch (ID3(holder, name, sig)) {
 965     VM_INTRINSICS_DO(VM_INTRINSIC_CASE,
 966                      VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);
 967   }
 968   return vmIntrinsics::_none;
 969 
 970 #undef VM_INTRINSIC_CASE
 971 }
 972 
 973 
 974 const char* vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID id, char* buf, int buflen) {
 975   const char* str = name_at(id);
 976 #ifndef PRODUCT
 977   const char* kname = vmSymbols::name_for(class_for(id));
 978   const char* mname = vmSymbols::name_for(name_for(id));
 979   const char* sname = vmSymbols::name_for(signature_for(id));
 980   const char* fname = &quot;&quot;;
 981   switch (flags_for(id)) {
 982   case F_Y:  fname = &quot;synchronized &quot;;  break;
 983   case F_RN: fname = &quot;native &quot;;        break;
 984   case F_SN: fname = &quot;native static &quot;; break;
 985   case F_S:  fname = &quot;static &quot;;        break;
 986   case F_RNY:fname = &quot;native synchronized &quot;; break;
 987   default:   break;
 988   }
 989   const char* kptr = strrchr(kname, JVM_SIGNATURE_SLASH);
 990   if (kptr != NULL)  kname = kptr + 1;
 991   int len = jio_snprintf(buf, buflen, &quot;%s: %s%s.%s%s&quot;,
 992                          str, fname, kname, mname, sname);
 993   if (len &lt; buflen)
 994     str = buf;
 995 #endif //PRODUCT
 996   return str;
 997 }
 998 
 999 
1000 // These are to get information about intrinsics.
1001 
1002 #define ID4(x, y, z, f) ((ID3(x, y, z) &lt;&lt; vmIntrinsics::log2_FLAG_LIMIT) | (jlong) (f))
1003 
1004 static const jlong intrinsic_info_array[vmIntrinsics::ID_LIMIT+1] = {
1005 #define VM_INTRINSIC_INFO(ignore_id, klass, name, sig, fcode) \
1006   ID4(SID_ENUM(klass), SID_ENUM(name), SID_ENUM(sig), vmIntrinsics::fcode),
1007 
1008   0, VM_INTRINSICS_DO(VM_INTRINSIC_INFO,
1009                      VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
1010     0
1011 #undef VM_INTRINSIC_INFO
1012 };
1013 
1014 inline jlong intrinsic_info(vmIntrinsics::ID id) {
1015   return intrinsic_info_array[vmIntrinsics::ID_from((int)id)];
1016 }
1017 
1018 vmSymbols::SID vmIntrinsics::class_for(vmIntrinsics::ID id) {
1019   jlong info = intrinsic_info(id);
1020   int shift = 2*vmSymbols::log2_SID_LIMIT + log2_FLAG_LIMIT, mask = right_n_bits(vmSymbols::log2_SID_LIMIT);
1021   assert(((ID4(1021,1022,1023,15) &gt;&gt; shift) &amp; mask) == 1021, &quot;&quot;);
1022   return vmSymbols::SID( (info &gt;&gt; shift) &amp; mask );
1023 }
1024 
1025 vmSymbols::SID vmIntrinsics::name_for(vmIntrinsics::ID id) {
1026   jlong info = intrinsic_info(id);
1027   int shift = vmSymbols::log2_SID_LIMIT + log2_FLAG_LIMIT, mask = right_n_bits(vmSymbols::log2_SID_LIMIT);
1028   assert(((ID4(1021,1022,1023,15) &gt;&gt; shift) &amp; mask) == 1022, &quot;&quot;);
1029   return vmSymbols::SID( (info &gt;&gt; shift) &amp; mask );
1030 }
1031 
1032 vmSymbols::SID vmIntrinsics::signature_for(vmIntrinsics::ID id) {
1033   jlong info = intrinsic_info(id);
1034   int shift = log2_FLAG_LIMIT, mask = right_n_bits(vmSymbols::log2_SID_LIMIT);
1035   assert(((ID4(1021,1022,1023,15) &gt;&gt; shift) &amp; mask) == 1023, &quot;&quot;);
1036   return vmSymbols::SID( (info &gt;&gt; shift) &amp; mask );
1037 }
1038 
1039 vmIntrinsics::Flags vmIntrinsics::flags_for(vmIntrinsics::ID id) {
1040   jlong info = intrinsic_info(id);
1041   int shift = 0, mask = right_n_bits(log2_FLAG_LIMIT);
1042   assert(((ID4(1021,1022,1023,15) &gt;&gt; shift) &amp; mask) == 15, &quot;&quot;);
1043   return Flags( (info &gt;&gt; shift) &amp; mask );
1044 }
1045 
1046 
1047 #ifndef PRODUCT
1048 // verify_method performs an extra check on a matched intrinsic method
1049 
1050 static bool match_method(Method* m, Symbol* n, Symbol* s) {
1051   return (m-&gt;name() == n &amp;&amp;
1052           m-&gt;signature() == s);
1053 }
1054 
1055 static vmIntrinsics::ID match_method_with_klass(Method* m, Symbol* mk) {
1056 #define VM_INTRINSIC_MATCH(id, klassname, namepart, sigpart, flags) \
1057   { Symbol* k = vmSymbols::klassname(); \
1058     if (mk == k) { \
1059       Symbol* n = vmSymbols::namepart(); \
1060       Symbol* s = vmSymbols::sigpart(); \
1061       if (match_method(m, n, s)) \
1062         return vmIntrinsics::id; \
1063     } }
1064   VM_INTRINSICS_DO(VM_INTRINSIC_MATCH,
1065                    VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);
1066   return vmIntrinsics::_none;
1067 #undef VM_INTRINSIC_MATCH
1068 }
1069 
1070 void vmIntrinsics::verify_method(ID actual_id, Method* m) {
1071   Symbol* mk = m-&gt;method_holder()-&gt;name();
1072   ID declared_id = match_method_with_klass(m, mk);
1073 
1074   if (declared_id == actual_id)  return; // success
1075 
1076   if (declared_id == _none &amp;&amp; actual_id != _none &amp;&amp; mk == vmSymbols::java_lang_StrictMath()) {
1077     // Here are a few special cases in StrictMath not declared in vmSymbols.hpp.
1078     switch (actual_id) {
1079     case _min:
1080     case _max:
1081     case _dsqrt:
1082       declared_id = match_method_with_klass(m, vmSymbols::java_lang_Math());
1083       if (declared_id == actual_id)  return; // acceptable alias
1084       break;
1085     default:
1086         break;
1087     }
1088   }
1089 
1090   const char* declared_name = name_at(declared_id);
1091   const char* actual_name   = name_at(actual_id);
1092   m = NULL;
1093   ttyLocker ttyl;
1094   if (xtty != NULL) {
1095     xtty-&gt;begin_elem(&quot;intrinsic_misdeclared actual=&#39;%s&#39; declared=&#39;%s&#39;&quot;,
1096                      actual_name, declared_name);
1097     xtty-&gt;method(m);
1098     xtty-&gt;end_elem(&quot;%s&quot;, &quot;&quot;);
1099   }
1100   if (PrintMiscellaneous &amp;&amp; (WizardMode || Verbose)) {
1101     tty-&gt;print_cr(&quot;*** misidentified method; %s(%d) should be %s(%d):&quot;,
1102                   declared_name, declared_id, actual_name, actual_id);
1103     m-&gt;print_short_name(tty);
1104     tty-&gt;cr();
1105   }
1106 }
1107 #endif //PRODUCT
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>