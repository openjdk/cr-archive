<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  33 #include &quot;classfile/classLoaderExt.hpp&quot;
  34 #include &quot;classfile/dictionary.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/loaderConstraints.hpp&quot;
  38 #include &quot;classfile/packageEntry.hpp&quot;
  39 #include &quot;classfile/placeholders.hpp&quot;
  40 #include &quot;classfile/protectionDomainCache.hpp&quot;
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  50 #include &quot;interpreter/bytecodeStream.hpp&quot;
  51 #include &quot;interpreter/interpreter.hpp&quot;
  52 #include &quot;jfr/jfrEvents.hpp&quot;
  53 #include &quot;logging/log.hpp&quot;
  54 #include &quot;logging/logStream.hpp&quot;
  55 #include &quot;memory/filemap.hpp&quot;
  56 #include &quot;memory/heapShared.hpp&quot;
  57 #include &quot;memory/metaspaceClosure.hpp&quot;
  58 #include &quot;memory/oopFactory.hpp&quot;
  59 #include &quot;memory/resourceArea.hpp&quot;
  60 #include &quot;memory/universe.hpp&quot;
  61 #include &quot;oops/access.inline.hpp&quot;
  62 #include &quot;oops/fieldStreams.inline.hpp&quot;
  63 #include &quot;oops/instanceKlass.hpp&quot;
  64 #include &quot;oops/instanceRefKlass.hpp&quot;
  65 #include &quot;oops/klass.inline.hpp&quot;
  66 #include &quot;oops/method.inline.hpp&quot;
  67 #include &quot;oops/methodData.hpp&quot;
  68 #include &quot;oops/objArrayKlass.hpp&quot;
  69 #include &quot;oops/objArrayOop.inline.hpp&quot;
  70 #include &quot;oops/oop.inline.hpp&quot;
  71 #include &quot;oops/oopHandle.inline.hpp&quot;
  72 #include &quot;oops/symbol.hpp&quot;
  73 #include &quot;oops/typeArrayKlass.hpp&quot;
  74 #include &quot;oops/inlineKlass.inline.hpp&quot;
  75 #include &quot;prims/jvmtiExport.hpp&quot;
  76 #include &quot;prims/methodHandles.hpp&quot;
  77 #include &quot;runtime/arguments.hpp&quot;
  78 #include &quot;runtime/biasedLocking.hpp&quot;
  79 #include &quot;runtime/handles.inline.hpp&quot;
  80 #include &quot;runtime/java.hpp&quot;
  81 #include &quot;runtime/javaCalls.hpp&quot;
  82 #include &quot;runtime/mutexLocker.hpp&quot;
  83 #include &quot;runtime/os.hpp&quot;
  84 #include &quot;runtime/sharedRuntime.hpp&quot;
  85 #include &quot;runtime/signature.hpp&quot;
  86 #include &quot;services/classLoadingService.hpp&quot;
  87 #include &quot;services/diagnosticCommand.hpp&quot;
  88 #include &quot;services/threadService.hpp&quot;
  89 #include &quot;utilities/macros.hpp&quot;
  90 #include &quot;utilities/utf8.hpp&quot;
  91 #if INCLUDE_CDS
  92 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  93 #endif
  94 #if INCLUDE_JFR
  95 #include &quot;jfr/jfr.hpp&quot;
  96 #endif
  97 
  98 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  99 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
 100 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 101 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 102 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 103 
 104 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 105                                                           =  { NULL /*, NULL...*/ };
 106 
 107 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 108 
 109 
 110 OopHandle   SystemDictionary::_system_loader_lock_obj;
 111 OopHandle   SystemDictionary::_java_system_loader;
 112 OopHandle   SystemDictionary::_java_platform_loader;
 113 
 114 // Default ProtectionDomainCacheSize value
 115 
 116 const int defaultProtectionDomainCacheSize = 1009;
 117 
 118 ClassLoadInfo::ClassLoadInfo() {
 119   _protection_domain = Handle();
 120   _unsafe_anonymous_host = NULL;
 121   _cp_patches = NULL;
 122   _class_hidden_info._dynamic_nest_host = NULL;
 123   _class_hidden_info._class_data = Handle();
 124   _is_hidden = false;
 125   _is_strong_hidden = false;
 126   _can_access_vm_annotations = false;
 127 }
 128 
 129 ClassLoadInfo::ClassLoadInfo(Handle protection_domain) {
 130   _protection_domain = protection_domain;
 131   _unsafe_anonymous_host = NULL;
 132   _cp_patches = NULL;
 133   _class_hidden_info._dynamic_nest_host = NULL;
 134   _class_hidden_info._class_data = Handle();
 135   _is_hidden = false;
 136   _is_strong_hidden = false;
 137   _can_access_vm_annotations = false;
 138 }
 139 
 140 ClassLoadInfo::ClassLoadInfo(Handle protection_domain,
 141                              const InstanceKlass* unsafe_anonymous_host,
 142                              GrowableArray&lt;Handle&gt;* cp_patches,
 143                              InstanceKlass* dynamic_nest_host,
 144                              Handle class_data,
 145                              bool is_hidden,
 146                              bool is_strong_hidden,
 147                              bool can_access_vm_annotations) {
 148   _protection_domain = protection_domain;
 149   _unsafe_anonymous_host = unsafe_anonymous_host;
 150   _cp_patches = cp_patches;
 151   _class_hidden_info._dynamic_nest_host = dynamic_nest_host;
 152   _class_hidden_info._class_data = class_data;
 153   _is_hidden = is_hidden;
 154   _is_strong_hidden = is_strong_hidden;
 155   _can_access_vm_annotations = can_access_vm_annotations;
 156 }
 157 
 158 // ----------------------------------------------------------------------------
 159 // Java-level SystemLoader and PlatformLoader
 160 
 161 oop SystemDictionary::system_loader_lock() {
 162   return _system_loader_lock_obj.resolve();
 163 }
 164 
 165 oop SystemDictionary::java_system_loader() {
 166   return _java_system_loader.resolve();
 167 }
 168 
 169 oop SystemDictionary::java_platform_loader() {
 170   return _java_platform_loader.resolve();
 171 }
 172 
 173 void SystemDictionary::compute_java_loaders(TRAPS) {
 174   JavaValue result(T_OBJECT);
 175   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 176   JavaCalls::call_static(&amp;result,
 177                          class_loader_klass,
 178                          vmSymbols::getSystemClassLoader_name(),
 179                          vmSymbols::void_classloader_signature(),
 180                          CHECK);
 181 
 182   _java_system_loader = OopHandle(OopStorageSet::vm_global(), (oop)result.get_jobject());
 183 
 184   JavaCalls::call_static(&amp;result,
 185                          class_loader_klass,
 186                          vmSymbols::getPlatformClassLoader_name(),
 187                          vmSymbols::void_classloader_signature(),
 188                          CHECK);
 189 
 190   _java_platform_loader = OopHandle(OopStorageSet::vm_global(), (oop)result.get_jobject());
 191 }
 192 
 193 ClassLoaderData* SystemDictionary::register_loader(Handle class_loader, bool create_mirror_cld) {
 194   if (create_mirror_cld) {
 195     // Add a new class loader data to the graph.
 196     return ClassLoaderDataGraph::add(class_loader, true);
 197   } else {
 198     return (class_loader() == NULL) ? ClassLoaderData::the_null_class_loader_data() :
 199                                       ClassLoaderDataGraph::find_or_create(class_loader);
 200   }
 201 }
 202 
 203 // ----------------------------------------------------------------------------
 204 // Parallel class loading check
 205 
 206 bool SystemDictionary::is_parallelCapable(Handle class_loader) {
 207   if (class_loader.is_null()) return true;
 208   if (AlwaysLockClassLoader) return false;
 209   return java_lang_ClassLoader::parallelCapable(class_loader());
 210 }
 211 // ----------------------------------------------------------------------------
 212 // ParallelDefineClass flag does not apply to bootclass loader
 213 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 214    if (class_loader.is_null()) return false;
 215    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 216      return true;
 217    }
 218    return false;
 219 }
 220 
 221 // Returns true if the passed class loader is the builtin application class loader
 222 // or a custom system class loader. A customer system class loader can be
 223 // specified via -Djava.system.class.loader.
 224 bool SystemDictionary::is_system_class_loader(oop class_loader) {
 225   if (class_loader == NULL) {
 226     return false;
 227   }
 228   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
 229          class_loader == _java_system_loader.peek());
 230 }
 231 
 232 // Returns true if the passed class loader is the platform class loader.
 233 bool SystemDictionary::is_platform_class_loader(oop class_loader) {
 234   if (class_loader == NULL) {
 235     return false;
 236   }
 237   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());
 238 }
 239 
 240 // ----------------------------------------------------------------------------
 241 // Resolving of classes
 242 
 243 Symbol* SystemDictionary::class_name_symbol(const char* name, Symbol* exception, TRAPS) {
 244   if (name == NULL) {
 245     THROW_MSG_0(exception, &quot;No class name given&quot;);
 246   }
 247   if ((int)strlen(name) &gt; Symbol::max_length()) {
 248     // It&#39;s impossible to create this class;  the name cannot fit
 249     // into the constant pool.
 250     Exceptions::fthrow(THREAD_AND_LOCATION, exception,
 251                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 252                        Symbol::max_length(),
 253                        name);
 254     return NULL;
 255   }
 256   // Callers should ensure that the name is never an illegal UTF8 string.
 257   assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false),
 258          &quot;Class name is not a valid utf8 string.&quot;);
 259 
 260   // Make a new symbol for the class name.
 261   return SymbolTable::new_symbol(name);
 262 }
 263 
 264 // Forwards to resolve_or_null
 265 
 266 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {
 267   Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);
 268   if (HAS_PENDING_EXCEPTION || klass == NULL) {
 269     // can return a null klass
 270     klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);
 271   }
 272   return klass;
 273 }
 274 
 275 Klass* SystemDictionary::handle_resolution_exception(Symbol* class_name,
 276                                                      bool throw_error,
 277                                                      Klass* klass, TRAPS) {
 278   if (HAS_PENDING_EXCEPTION) {
 279     // If we have a pending exception we forward it to the caller, unless throw_error is true,
 280     // in which case we have to check whether the pending exception is a ClassNotFoundException,
 281     // and if so convert it to a NoClassDefFoundError
 282     // And chain the original ClassNotFoundException
 283     if (throw_error &amp;&amp; PENDING_EXCEPTION-&gt;is_a(SystemDictionary::ClassNotFoundException_klass())) {
 284       ResourceMark rm(THREAD);
 285       assert(klass == NULL, &quot;Should not have result with exception pending&quot;);
 286       Handle e(THREAD, PENDING_EXCEPTION);
 287       CLEAR_PENDING_EXCEPTION;
 288       THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string(), e);
 289     } else {
 290       return NULL;
 291     }
 292   }
 293   // Class not found, throw appropriate error or exception depending on value of throw_error
 294   if (klass == NULL) {
 295     ResourceMark rm(THREAD);
 296     if (throw_error) {
 297       THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string());
 298     } else {
 299       THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name-&gt;as_C_string());
 300     }
 301   }
 302   return klass;
 303 }
 304 
 305 
 306 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
 307                                            bool throw_error, TRAPS)
 308 {
 309   return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);
 310 }
 311 
 312 
 313 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 314 
 315 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 316   if (Signature::is_array(class_name)) {
 317     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 318   } else {
 319     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 320   }
 321 }
 322 
 323 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 324 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 325                                                                        Handle class_loader,
 326                                                                        Handle protection_domain,
 327                                                                        TRAPS) {
 328   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 329   if (Signature::has_envelope(class_name)) {
 330     ResourceMark rm(THREAD);
 331     // Ignore wrapping L and ;. (and Q and ; for value types);
 332     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 333                                                  class_name-&gt;utf8_length() - 2);
 334     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 335   } else {
 336     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 337   }
 338 }
 339 
 340 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 341   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 342 }
 343 
 344 // Forwards to resolve_instance_class_or_null
 345 
 346 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 347                                                      Handle class_loader,
 348                                                      Handle protection_domain,
 349                                                      TRAPS) {
 350   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 351   ResourceMark rm(THREAD);
 352   SignatureStream ss(class_name, false);
 353   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 354   Klass* k = NULL;
 355   BasicType t = ss.type();
 356   if (ss.has_envelope()) {
 357     Symbol* obj_class = ss.as_symbol();
 358     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 359                                                          class_loader,
 360                                                          protection_domain,
 361                                                          CHECK_NULL);
 362     if (k != NULL) {
 363       if ((class_name-&gt;is_Q_array_signature() &amp;&amp; !k-&gt;is_inline_klass()) ||
 364           (!class_name-&gt;is_Q_array_signature() &amp;&amp; k-&gt;is_inline_klass())) {
 365             THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), &quot;L/Q mismatch on bottom type&quot;);
 366           }
 367       k = k-&gt;array_klass(ndims, CHECK_NULL);
 368     }
 369   } else {
 370     k = Universe::typeArrayKlassObj(t);
 371     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);
 372   }
 373   return k;
 374 }
 375 
 376 // Must be called for any super-class or super-interface resolution
 377 // during class definition to allow class circularity checking
 378 // super-interface callers:
 379 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 380 // super-class callers:
 381 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 382 //   load_shared_class - while loading a class from shared archive
 383 //   resolve_instance_class_or_null:
 384 //     via: handle_parallel_super_load
 385 //      when resolving a class that has an existing placeholder with
 386 //      a saved superclass [i.e. a defineClass is currently in progress]
 387 //      if another thread is trying to resolve the class, it must do
 388 //      super-class checks on its own thread to catch class circularity
 389 // This last call is critical in class circularity checking for cases
 390 // where classloading is delegated to different threads and the
 391 // classloader lock is released.
 392 // Take the case: Base-&gt;Super-&gt;Base
 393 //   1. If thread T1 tries to do a defineClass of class Base
 394 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 395 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
 396 //    so it tries to load Super
 397 //   3. If we load the class internally, or user classloader uses same thread
 398 //      loadClassFromxxx or defineClass via parseClassFile Super ...
 399 //      3.1 resolve_super_or_fail creates placeholder: T1, Super (super Base)
 400 //      3.3 resolve_instance_class_or_null Base, finds placeholder for Base
 401 //      3.4 calls resolve_super_or_fail Base
 402 //      3.5 finds T1,Base -&gt; throws class circularity
 403 //OR 4. If T2 tries to resolve Super via defineClass Super ...
 404 //      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)
 405 //      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)
 406 //      4.3 calls resolve_super_or_fail Super in parallel on own thread T2
 407 //      4.4 finds T2, Super -&gt; throws class circularity
 408 // Must be called, even if superclass is null, since this is
 409 // where the placeholder entry is created which claims this
 410 // thread is loading this class/classloader.
 411 // Be careful when modifying this code: once you have run
 412 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_SUPER),
 413 // you need to find_and_remove it before returning.
 414 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 415 InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,
 416                                                        Symbol* super_name,
 417                                                        Handle class_loader,
 418                                                        Handle protection_domain,
 419                                                        bool is_superclass,
 420                                                        TRAPS) {
 421   assert(!Signature::is_array(super_name), &quot;invalid super class name&quot;);
 422 #if INCLUDE_CDS
 423   if (DumpSharedSpaces) {
 424     // Special processing for handling UNREGISTERED shared classes.
 425     InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
 426         super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
 427     if (k) {
 428       return k;
 429     }
 430   }
 431 #endif // INCLUDE_CDS
 432 
 433   // Double-check, if child class is already loaded, just return super-class,interface
 434   // Don&#39;t add a placedholder if already loaded, i.e. already in appropriate class loader
 435   // dictionary.
 436   // Make sure there&#39;s a placeholder for the *child* before resolving.
 437   // Used as a claim that this thread is currently loading superclass/classloader
 438   // Used here for ClassCircularity checks and also for heap verification
 439   // (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).
 440   // Must check ClassCircularity before checking if super class is already loaded.
 441   //
 442   // We might not already have a placeholder if this child_name was
 443   // first seen via resolve_from_stream (jni_DefineClass or JVM_DefineClass);
 444   // the name of the class might not be known until the stream is actually
 445   // parsed.
 446   // Bugs 4643874, 4715493
 447 
 448   ClassLoaderData* loader_data = class_loader_data(class_loader);
 449   Dictionary* dictionary = loader_data-&gt;dictionary();
 450   unsigned int d_hash = dictionary-&gt;compute_hash(child_name);
 451   unsigned int p_hash = placeholders()-&gt;compute_hash(child_name);
 452   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 453   // can&#39;t throw error holding a lock
 454   bool child_already_loaded = false;
 455   bool throw_circularity_error = false;
 456   {
 457     MutexLocker mu(THREAD, SystemDictionary_lock);
 458     InstanceKlass* childk = find_class(d_hash, child_name, dictionary);
 459     InstanceKlass* quicksuperk;
 460     // to support // loading: if child done loading, just return superclass
 461     // if super_name, &amp; class_loader don&#39;t match:
 462     // if initial define, SD update will give LinkageError
 463     // if redefine: compare_class_versions will give HIERARCHY_CHANGED
 464     // so we don&#39;t throw an exception here.
 465     // see: nsk redefclass014 &amp; java.lang.instrument Instrument032
 466     if ((childk != NULL ) &amp;&amp; (is_superclass) &amp;&amp;
 467         ((quicksuperk = childk-&gt;java_super()) != NULL) &amp;&amp;
 468          ((quicksuperk-&gt;name() == super_name) &amp;&amp;
 469             (quicksuperk-&gt;class_loader() == class_loader()))) {
 470            return quicksuperk;
 471     } else {
 472       PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, child_name, loader_data);
 473       if (probe &amp;&amp; probe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_SUPER)) {
 474           throw_circularity_error = true;
 475       }
 476     }
 477     if (!throw_circularity_error) {
 478       // Be careful not to exit resolve_super
 479       PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);
 480     }
 481   }
 482   if (throw_circularity_error) {
 483       ResourceMark rm(THREAD);
 484       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name-&gt;as_C_string());
 485   }
 486 
 487 // java.lang.Object should have been found above
 488   assert(super_name != NULL, &quot;null super class for resolving&quot;);
 489   // Resolve the super class or interface, check results on return
 490   InstanceKlass* superk =
 491     SystemDictionary::resolve_instance_class_or_null_helper(super_name,
 492                                                             class_loader,
 493                                                             protection_domain,
 494                                                             THREAD);
 495 
 496   // Clean up of placeholders moved so that each classloadAction registrar self-cleans up
 497   // It is no longer necessary to keep the placeholder table alive until update_dictionary
 498   // or error. GC used to walk the placeholder table as strong roots.
 499   // The instanceKlass is kept alive because the class loader is on the stack,
 500   // which keeps the loader_data alive, as well as all instanceKlasses in
 501   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 502   {
 503     MutexLocker mu(THREAD, SystemDictionary_lock);
 504     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 505     SystemDictionary_lock-&gt;notify_all();
 506   }
 507   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 508     // can null superk
 509     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 510     assert(k == NULL || k == superk, &quot;must be&quot;);
 511     if (k == NULL) {
 512       superk = NULL;
 513     }
 514   }
 515 
 516   return superk;
 517 }
 518 
 519 Klass* SystemDictionary::resolve_inline_type_field_or_fail(AllFieldStream* fs,
 520                                                            Handle class_loader,
 521                                                            Handle protection_domain,
 522                                                            bool throw_error,
 523                                                            TRAPS) {
 524   Symbol* class_name = fs-&gt;signature()-&gt;fundamental_name(THREAD);
 525   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 526   ClassLoaderData* loader_data = class_loader_data(class_loader);
 527   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);
 528   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 529   bool throw_circularity_error = false;
 530   PlaceholderEntry* oldprobe;
 531 
 532   {
 533     MutexLocker mu(THREAD, SystemDictionary_lock);
 534     oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, class_name, loader_data);
 535     if (oldprobe != NULL &amp;&amp;
 536       oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::INLINE_TYPE_FIELD)) {
 537       throw_circularity_error = true;
 538 
 539     } else {
 540       placeholders()-&gt;find_and_add(p_index, p_hash, class_name, loader_data,
 541                                    PlaceholderTable::INLINE_TYPE_FIELD, NULL, THREAD);
 542     }
 543   }
 544 
 545   Klass* klass = NULL;
 546   if (!throw_circularity_error) {
 547     klass = SystemDictionary::resolve_or_fail(class_name, class_loader,
 548                                                protection_domain, true, THREAD);
 549   } else {
 550     ResourceMark rm(THREAD);
 551     THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name-&gt;as_C_string());
 552   }
 553 
 554   {
 555     MutexLocker mu(THREAD, SystemDictionary_lock);
 556     placeholders()-&gt;find_and_remove(p_index, p_hash, class_name, loader_data,
 557                                     PlaceholderTable::INLINE_TYPE_FIELD, THREAD);
 558   }
 559 
 560   class_name-&gt;decrement_refcount();
 561   return klass;
 562 }
 563 
 564 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 565                                                   Handle class_loader,
 566                                                   Handle protection_domain,
 567                                                   TRAPS) {
 568   // Now we have to call back to java to check if the initating class has access
 569   JavaValue result(T_VOID);
 570   LogTarget(Debug, protectiondomain) lt;
 571   if (lt.is_enabled()) {
 572     ResourceMark rm(THREAD);
 573     // Print out trace information
 574     LogStream ls(lt);
 575     ls.print_cr(&quot;Checking package access&quot;);
 576     if (class_loader() != NULL) {
 577       ls.print(&quot;class loader: &quot;);
 578       class_loader()-&gt;print_value_on(&amp;ls);
 579     } else {
 580       ls.print_cr(&quot;class loader: NULL&quot;);
 581     }
 582     if (protection_domain() != NULL) {
 583       ls.print(&quot; protection domain: &quot;);
 584       protection_domain()-&gt;print_value_on(&amp;ls);
 585     } else {
 586       ls.print_cr(&quot; protection domain: NULL&quot;);
 587     }
 588     ls.print(&quot; loading: &quot;); klass-&gt;print_value_on(&amp;ls);
 589     ls.cr();
 590   }
 591 
 592   // This handle and the class_loader handle passed in keeps this class from
 593   // being unloaded through several GC points.
 594   // The class_loader handle passed in is the initiating loader.
 595   Handle mirror(THREAD, klass-&gt;java_mirror());
 596 
 597   InstanceKlass* system_loader = SystemDictionary::ClassLoader_klass();
 598   JavaCalls::call_special(&amp;result,
 599                          class_loader,
 600                          system_loader,
 601                          vmSymbols::checkPackageAccess_name(),
 602                          vmSymbols::class_protectiondomain_signature(),
 603                          mirror,
 604                          protection_domain,
 605                          THREAD);
 606 
 607   if (HAS_PENDING_EXCEPTION) {
 608     log_debug(protectiondomain)(&quot;DENIED !!!!!!!!!!!!!!!!!!!!!&quot;);
 609   } else {
 610    log_debug(protectiondomain)(&quot;granted&quot;);
 611   }
 612 
 613   if (HAS_PENDING_EXCEPTION) return;
 614 
 615   // If no exception has been thrown, we have validated the protection domain
 616   // Insert the protection domain of the initiating class into the set.
 617   {
 618     ClassLoaderData* loader_data = class_loader_data(class_loader);
 619     Dictionary* dictionary = loader_data-&gt;dictionary();
 620 
 621     Symbol*  kn = klass-&gt;name();
 622     unsigned int d_hash = dictionary-&gt;compute_hash(kn);
 623 
 624     MutexLocker mu(THREAD, SystemDictionary_lock);
 625     int d_index = dictionary-&gt;hash_to_index(d_hash);
 626     dictionary-&gt;add_protection_domain(d_index, d_hash, klass,
 627                                       protection_domain, THREAD);
 628   }
 629 }
 630 
 631 // We only get here if this thread finds that another thread
 632 // has already claimed the placeholder token for the current operation,
 633 // but that other thread either never owned or gave up the
 634 // object lock
 635 // Waits on SystemDictionary_lock to indicate placeholder table updated
 636 // On return, caller must recheck placeholder table state
 637 //
 638 // We only get here if
 639 //  1) custom classLoader, i.e. not bootstrap classloader
 640 //  2) custom classLoader has broken the class loader objectLock
 641 //     so another thread got here in parallel
 642 //
 643 // lockObject must be held.
 644 // Complicated dance due to lock ordering:
 645 // Must first release the classloader object lock to
 646 // allow initial definer to complete the class definition
 647 // and to avoid deadlock
 648 // Reclaim classloader lock object with same original recursion count
 649 // Must release SystemDictionary_lock after notify, since
 650 // class loader lock must be claimed before SystemDictionary_lock
 651 // to prevent deadlocks
 652 //
 653 // The notify allows applications that did an untimed wait() on
 654 // the classloader object lock to not hang.
 655 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 656   assert_lock_strong(SystemDictionary_lock);
 657 
 658   bool calledholdinglock
 659       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 660   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
 661   assert((lockObject() != _system_loader_lock_obj.resolve() &amp;&amp;
 662          !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);
 663   ObjectSynchronizer::notifyall(lockObject, THREAD);
 664   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);
 665   SystemDictionary_lock-&gt;wait();
 666   SystemDictionary_lock-&gt;unlock();
 667   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
 668   SystemDictionary_lock-&gt;lock();
 669 }
 670 
 671 // If the class in is in the placeholder table, class loading is in progress
 672 // For cases where the application changes threads to load classes, it
 673 // is critical to ClassCircularity detection that we try loading
 674 // the superclass on the same thread internally, so we do parallel
 675 // super class loading here.
 676 // This also is critical in cases where the original thread gets stalled
 677 // even in non-circularity situations.
 678 // Note: must call resolve_super_or_fail even if null super -
 679 // to force placeholder entry creation for this class for circularity detection
 680 // Caller must check for pending exception
 681 // Returns non-null Klass* if other thread has completed load
 682 // and we are done,
 683 // If return null Klass* and no pending exception, the caller must load the class
 684 InstanceKlass* SystemDictionary::handle_parallel_super_load(
 685     Symbol* name, Symbol* superclassname, Handle class_loader,
 686     Handle protection_domain, Handle lockObject, TRAPS) {
 687 
 688   ClassLoaderData* loader_data = class_loader_data(class_loader);
 689   Dictionary* dictionary = loader_data-&gt;dictionary();
 690   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 691   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 692   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 693 
 694   // superk is not used, resolve_super called for circularity check only
 695   // This code is reached in two situations. One if this thread
 696   // is loading the same class twice (e.g. ClassCircularity, or
 697   // java.lang.instrument).
 698   // The second is if another thread started the resolve_super first
 699   // and has not yet finished.
 700   // In both cases the original caller will clean up the placeholder
 701   // entry on error.
 702   Klass* superk = SystemDictionary::resolve_super_or_fail(name,
 703                                                           superclassname,
 704                                                           class_loader,
 705                                                           protection_domain,
 706                                                           true,
 707                                                           CHECK_NULL);
 708 
 709   // parallelCapable class loaders do NOT wait for parallel superclass loads to complete
 710   // Serial class loaders and bootstrap classloader do wait for superclass loads
 711  if (!class_loader.is_null() &amp;&amp; is_parallelCapable(class_loader)) {
 712     MutexLocker mu(THREAD, SystemDictionary_lock);
 713     // Check if classloading completed while we were loading superclass or waiting
 714     return find_class(d_hash, name, dictionary);
 715   }
 716 
 717   // must loop to both handle other placeholder updates
 718   // and spurious notifications
 719   bool super_load_in_progress = true;
 720   PlaceholderEntry* placeholder;
 721   while (super_load_in_progress) {
 722     MutexLocker mu(THREAD, SystemDictionary_lock);
 723     // Check if classloading completed while we were loading superclass or waiting
 724     InstanceKlass* check = find_class(d_hash, name, dictionary);
 725     if (check != NULL) {
 726       // Klass is already loaded, so just return it
 727       return check;
 728     } else {
 729       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 730       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress() ){
 731         // We only get here if the application has released the
 732         // classloader lock when another thread was in the middle of loading a
 733         // superclass/superinterface for this class, and now
 734         // this thread is also trying to load this class.
 735         // To minimize surprises, the first thread that started to
 736         // load a class should be the one to complete the loading
 737         // with the classfile it initially expected.
 738         // This logic has the current thread wait once it has done
 739         // all the superclass/superinterface loading it can, until
 740         // the original thread completes the class loading or fails
 741         // If it completes we will use the resulting InstanceKlass
 742         // which we will find below in the systemDictionary.
 743         // We also get here for parallel bootstrap classloader
 744         if (class_loader.is_null()) {
 745           SystemDictionary_lock-&gt;wait();
 746         } else {
 747           double_lock_wait(lockObject, THREAD);
 748         }
 749       } else {
 750         // If not in SD and not in PH, other thread&#39;s load must have failed
 751         super_load_in_progress = false;
 752       }
 753     }
 754   }
 755   return NULL;
 756 }
 757 
 758 void SystemDictionary::post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {
 759   assert(event != NULL, &quot;invariant&quot;);
 760   assert(k != NULL, &quot;invariant&quot;);
 761   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 762   event-&gt;set_loadedClass(k);
 763   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 764   event-&gt;set_initiatingClassLoader(init_cld);
 765   event-&gt;commit();
 766 }
 767 
 768 
 769 // Be careful when modifying this code: once you have run
 770 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 771 // you need to find_and_remove it before returning.
 772 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 773 //
 774 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 775 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 776                                                                 Handle class_loader,
 777                                                                 Handle protection_domain,
 778                                                                 TRAPS) {
 779   assert(name != NULL &amp;&amp; !Signature::is_array(name) &amp;&amp;
 780          !Signature::has_envelope(name), &quot;invalid class name&quot;);
 781 
 782   EventClassLoad class_load_start_event;
 783 
 784   HandleMark hm(THREAD);
 785 
 786   // Fix for 4474172; see evaluation for more details
 787   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 788   ClassLoaderData* loader_data = register_loader(class_loader);
 789   Dictionary* dictionary = loader_data-&gt;dictionary();
 790   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 791 
 792   // Do lookup to see if class already exist and the protection domain
 793   // has the right access
 794   // This call uses find which checks protection domain already matches
 795   // All subsequent calls use find_class, and set has_loaded_class so that
 796   // before we return a result we call out to java to check for valid protection domain
 797   // to allow returning the Klass* and add it to the pd_set if it is valid
 798   {
 799     InstanceKlass* probe = dictionary-&gt;find(d_hash, name, protection_domain);
 800     if (probe != NULL) return probe;
 801   }
 802 
 803   // Non-bootstrap class loaders will call out to class loader and
 804   // define via jvm/jni_DefineClass which will acquire the
 805   // class loader object lock to protect against multiple threads
 806   // defining the class in parallel by accident.
 807   // This lock must be acquired here so the waiter will find
 808   // any successful result in the SystemDictionary and not attempt
 809   // the define.
 810   // ParallelCapable Classloaders and the bootstrap classloader
 811   // do not acquire lock here.
 812   bool DoObjectLock = true;
 813   if (is_parallelCapable(class_loader)) {
 814     DoObjectLock = false;
 815   }
 816 
 817   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 818   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 819 
 820   // Class is not in SystemDictionary so we have to do loading.
 821   // Make sure we are synchronized on the class loader before we proceed
 822   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
 823   check_loader_lock_contention(lockObject, THREAD);
 824   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
 825 
 826   // Check again (after locking) if class already exist in SystemDictionary
 827   bool class_has_been_loaded   = false;
 828   bool super_load_in_progress  = false;
 829   bool havesupername = false;
 830   InstanceKlass* k = NULL;
 831   PlaceholderEntry* placeholder;
 832   Symbol* superclassname = NULL;
 833 
 834   assert(THREAD-&gt;can_call_java(),
 835          &quot;can not load classes with compiler thread: class=%s, classloader=%s&quot;,
 836          name-&gt;as_C_string(),
 837          class_loader.is_null() ? &quot;null&quot; : class_loader-&gt;klass()-&gt;name()-&gt;as_C_string());
 838   {
 839     MutexLocker mu(THREAD, SystemDictionary_lock);
 840     InstanceKlass* check = find_class(d_hash, name, dictionary);
 841     if (check != NULL) {
 842       // InstanceKlass is already loaded, so just return it
 843       class_has_been_loaded = true;
 844       k = check;
 845     } else {
 846       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 847       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress()) {
 848          super_load_in_progress = true;
 849          if (placeholder-&gt;havesupername() == true) {
 850            superclassname = placeholder-&gt;supername();
 851            havesupername = true;
 852          }
 853       }
 854     }
 855   }
 856 
 857   // If the class is in the placeholder table, class loading is in progress
 858   if (super_load_in_progress &amp;&amp; havesupername==true) {
 859     k = handle_parallel_super_load(name,
 860                                    superclassname,
 861                                    class_loader,
 862                                    protection_domain,
 863                                    lockObject, THREAD);
 864     if (HAS_PENDING_EXCEPTION) {
 865       return NULL;
 866     }
 867     if (k != NULL) {
 868       class_has_been_loaded = true;
 869     }
 870   }
 871 
 872   bool throw_circularity_error = false;
 873   if (!class_has_been_loaded) {
 874     bool load_instance_added = false;
 875 
 876     // add placeholder entry to record loading instance class
 877     // Five cases:
 878     // All cases need to prevent modifying bootclasssearchpath
 879     // in parallel with a classload of same classname
 880     // Redefineclasses uses existence of the placeholder for the duration
 881     // of the class load to prevent concurrent redefinition of not completely
 882     // defined classes.
 883     // case 1. traditional classloaders that rely on the classloader object lock
 884     //   - no other need for LOAD_INSTANCE
 885     // case 2. traditional classloaders that break the classloader object lock
 886     //    as a deadlock workaround. Detection of this case requires that
 887     //    this check is done while holding the classloader object lock,
 888     //    and that lock is still held when calling classloader&#39;s loadClass.
 889     //    For these classloaders, we ensure that the first requestor
 890     //    completes the load and other requestors wait for completion.
 891     // case 3. Bootstrap classloader - don&#39;t own objectLocker
 892     //    This classloader supports parallelism at the classloader level,
 893     //    but only allows a single load of a class/classloader pair.
 894     //    No performance benefit and no deadlock issues.
 895     // case 4. parallelCapable user level classloaders - without objectLocker
 896     //    Allow parallel classloading of a class/classloader pair
 897 
 898     {
 899       MutexLocker mu(THREAD, SystemDictionary_lock);
 900       if (class_loader.is_null() || !is_parallelCapable(class_loader)) {
 901         PlaceholderEntry* oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 902         if (oldprobe) {
 903           // only need check_seen_thread once, not on each loop
 904           // 6341374 java/lang/Instrument with -Xcomp
 905           if (oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {
 906             throw_circularity_error = true;
 907           } else {
 908             // case 1: traditional: should never see load_in_progress.
 909             while (!class_has_been_loaded &amp;&amp; oldprobe &amp;&amp; oldprobe-&gt;instance_load_in_progress()) {
 910 
 911               // case 3: bootstrap classloader: prevent futile classloading,
 912               // wait on first requestor
 913               if (class_loader.is_null()) {
 914                 SystemDictionary_lock-&gt;wait();
 915               } else {
 916               // case 2: traditional with broken classloader lock. wait on first
 917               // requestor.
 918                 double_lock_wait(lockObject, THREAD);
 919               }
 920               // Check if classloading completed while we were waiting
 921               InstanceKlass* check = find_class(d_hash, name, dictionary);
 922               if (check != NULL) {
 923                 // Klass is already loaded, so just return it
 924                 k = check;
 925                 class_has_been_loaded = true;
 926               }
 927               // check if other thread failed to load and cleaned up
 928               oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 929             }
 930           }
 931         }
 932       }
 933       // All cases: add LOAD_INSTANCE holding SystemDictionary_lock
 934       // case 4: parallelCapable: allow competing threads to try
 935       // LOAD_INSTANCE in parallel
 936 
 937       if (!throw_circularity_error &amp;&amp; !class_has_been_loaded) {
 938         PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, NULL, THREAD);
 939         load_instance_added = true;
 940         // For class loaders that do not acquire the classloader object lock,
 941         // if they did not catch another thread holding LOAD_INSTANCE,
 942         // need a check analogous to the acquire ObjectLocker/find_class
 943         // i.e. now that we hold the LOAD_INSTANCE token on loading this class/CL
 944         // one final check if the load has already completed
 945         // class loaders holding the ObjectLock shouldn&#39;t find the class here
 946         InstanceKlass* check = find_class(d_hash, name, dictionary);
 947         if (check != NULL) {
 948           // Klass is already loaded, so return it after checking/adding protection domain
 949           k = check;
 950           class_has_been_loaded = true;
 951         }
 952       }
 953     }
 954 
 955     // must throw error outside of owning lock
 956     if (throw_circularity_error) {
 957       assert(!HAS_PENDING_EXCEPTION &amp;&amp; load_instance_added == false,&quot;circularity error cleanup&quot;);
 958       ResourceMark rm(THREAD);
 959       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), name-&gt;as_C_string());
 960     }
 961 
 962     if (!class_has_been_loaded) {
 963 
 964       // Do actual loading
 965       k = load_instance_class(name, class_loader, THREAD);
 966 
 967       // If everything was OK (no exceptions, no null return value), and
 968       // class_loader is NOT the defining loader, do a little more bookkeeping.
 969       if (!HAS_PENDING_EXCEPTION &amp;&amp; k != NULL &amp;&amp;
 970         k-&gt;class_loader() != class_loader()) {
 971 
 972         check_constraints(d_hash, k, class_loader, false, THREAD);
 973 
 974         // Need to check for a PENDING_EXCEPTION again; check_constraints
 975         // can throw but we may have to remove entry from the placeholder table below.
 976         if (!HAS_PENDING_EXCEPTION) {
 977           // Record dependency for non-parent delegation.
 978           // This recording keeps the defining class loader of the klass (k) found
 979           // from being unloaded while the initiating class loader is loaded
 980           // even if the reference to the defining class loader is dropped
 981           // before references to the initiating class loader.
 982           loader_data-&gt;record_dependency(k);
 983 
 984           { // Grabbing the Compile_lock prevents systemDictionary updates
 985             // during compilations.
 986             MutexLocker mu(THREAD, Compile_lock);
 987             update_dictionary(d_hash, p_index, p_hash,
 988               k, class_loader, THREAD);
 989           }
 990 
 991           if (JvmtiExport::should_post_class_load()) {
 992             Thread *thread = THREAD;
 993             assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 994             JvmtiExport::post_class_load((JavaThread *) thread, k);
 995           }
 996         }
 997       }
 998     } // load_instance_class
 999 
1000     if (load_instance_added == true) {
1001       // clean up placeholder entries for LOAD_INSTANCE success or error
1002       // This brackets the SystemDictionary updates for both defining
1003       // and initiating loaders
1004       MutexLocker mu(THREAD, SystemDictionary_lock);
1005       placeholders()-&gt;find_and_remove(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);
1006       SystemDictionary_lock-&gt;notify_all();
1007     }
1008   }
1009 
1010   if (HAS_PENDING_EXCEPTION || k == NULL) {
1011     return NULL;
1012   }
1013   if (class_load_start_event.should_commit()) {
1014     post_class_load_event(&amp;class_load_start_event, k, loader_data);
1015   }
1016 #ifdef ASSERT
1017   {
1018     ClassLoaderData* loader_data = k-&gt;class_loader_data();
1019     MutexLocker mu(THREAD, SystemDictionary_lock);
1020     InstanceKlass* kk = find_class(name, loader_data);
1021     assert(kk == k, &quot;should be present in dictionary&quot;);
1022   }
1023 #endif
1024 
1025   // return if the protection domain in NULL
1026   if (protection_domain() == NULL) return k;
1027 
1028   // Check the protection domain has the right access
1029   if (dictionary-&gt;is_valid_protection_domain(d_hash, name,
1030                                              protection_domain)) {
1031     return k;
1032   }
1033 
1034   // Verify protection domain. If it fails an exception is thrown
1035   validate_protection_domain(k, class_loader, protection_domain, CHECK_NULL);
1036 
1037   return k;
1038 }
1039 
1040 
1041 // This routine does not lock the system dictionary.
1042 //
1043 // Since readers don&#39;t hold a lock, we must make sure that system
1044 // dictionary entries are only removed at a safepoint (when only one
1045 // thread is running), and are added to in a safe way (all links must
1046 // be updated in an MT-safe manner).
1047 //
1048 // Callers should be aware that an entry could be added just after
1049 // _dictionary-&gt;bucket(index) is read here, so the caller will not see
1050 // the new entry.
1051 
1052 Klass* SystemDictionary::find(Symbol* class_name,
1053                               Handle class_loader,
1054                               Handle protection_domain,
1055                               TRAPS) {
1056 
1057   // The result of this call should be consistent with the result
1058   // of the call to resolve_instance_class_or_null().
1059   // See evaluation 6790209 and 4474172 for more details.
1060   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
1061   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader());
1062 
1063   if (loader_data == NULL) {
1064     // If the ClassLoaderData has not been setup,
1065     // then the class loader has no entries in the dictionary.
1066     return NULL;
1067   }
1068 
1069   Dictionary* dictionary = loader_data-&gt;dictionary();
1070   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
1071   return dictionary-&gt;find(d_hash, class_name,
1072                           protection_domain);
1073 }
1074 
1075 
1076 // Look for a loaded instance or array klass by name.  Do not do any loading.
1077 // return NULL in case of error.
1078 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
1079                                                       Handle class_loader,
1080                                                       Handle protection_domain,
1081                                                       TRAPS) {
1082   Klass* k = NULL;
1083   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1084 
1085   if (Signature::is_array(class_name)) {
1086     // The name refers to an array.  Parse the name.
1087     // dimension and object_key in FieldArrayInfo are assigned as a
1088     // side-effect of this call
1089     SignatureStream ss(class_name, false);
1090     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1091     BasicType t = ss.type();
1092     if (t != T_OBJECT &amp;&amp; t != T_INLINE_TYPE) {
1093       k = Universe::typeArrayKlassObj(t);
1094     } else {
1095       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1096     }
1097     if (k != NULL) {
1098       k = k-&gt;array_klass_or_null(ndims);
1099     }
1100   } else {
1101     k = find(class_name, class_loader, protection_domain, THREAD);
1102   }
1103   return k;
1104 }
1105 
1106 // Note: this method is much like resolve_from_stream, but
1107 // does not publish the classes via the SystemDictionary.
1108 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
1109 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.
1110 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1111                                               Handle class_loader,
1112                                               ClassFileStream* st,
1113                                               const ClassLoadInfo&amp; cl_info,
1114                                               TRAPS) {
1115 
1116   EventClassLoad class_load_start_event;
1117   ClassLoaderData* loader_data;
1118   bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;
1119 
1120   // - for unsafe anonymous class: create a new CLD whith a class holder that uses
1121   //                               the same class loader as the unsafe_anonymous_host.
1122   // - for hidden classes that are not strong: create a new CLD that has a class holder and
1123   //                                           whose loader is the Lookup class&#39;s loader.
1124   // - for hidden class: add the class to the Lookup class&#39;s loader&#39;s CLD.
1125   if (is_unsafe_anon_class || cl_info.is_hidden()) {
1126     guarantee(!is_unsafe_anon_class || cl_info.unsafe_anonymous_host()-&gt;class_loader() == class_loader(),
1127               &quot;should be NULL or the same&quot;);
1128     bool create_mirror_cld = is_unsafe_anon_class || !cl_info.is_strong_hidden();
1129     loader_data = register_loader(class_loader, create_mirror_cld);
1130   } else {
1131     loader_data = ClassLoaderData::class_loader_data(class_loader());
1132   }
1133 
1134   assert(st != NULL, &quot;invariant&quot;);
1135   assert(st-&gt;need_verify(), &quot;invariant&quot;);
1136 
1137   // Parse stream and create a klass.
1138   // Note that we do this even though this klass might
1139   // already be present in the SystemDictionary, otherwise we would not
1140   // throw potential ClassFormatErrors.
1141 
1142   InstanceKlass* k = KlassFactory::create_from_stream(st,
1143                                                       class_name,
1144                                                       loader_data,
1145                                                       cl_info,
1146                                                       CHECK_NULL);
1147 
1148   if ((cl_info.is_hidden() || is_unsafe_anon_class) &amp;&amp; k != NULL) {
1149     // Hidden classes that are not strong and unsafe anonymous classes must update
1150     // ClassLoaderData holder so that they can be unloaded when the mirror is no
1151     // longer referenced.
1152     if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {
1153       k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));
1154     }
1155 
1156     {
1157       MutexLocker mu_r(THREAD, Compile_lock);
1158 
1159       // Add to class hierarchy, initialize vtables, and do possible
1160       // deoptimizations.
1161       add_to_hierarchy(k, CHECK_NULL); // No exception, but can block
1162       // But, do not add to dictionary.
1163     }
1164 
1165     // Rewrite and patch constant pool here.
1166     k-&gt;link_class(CHECK_NULL);
1167     if (cl_info.cp_patches() != NULL) {
1168       k-&gt;constants()-&gt;patch_resolved_references(cl_info.cp_patches());
1169     }
1170 
1171     // If it&#39;s anonymous, initialize it now, since nobody else will.
1172     if (is_unsafe_anon_class) {
1173       k-&gt;eager_initialize(CHECK_NULL);
1174     }
1175 
1176     // notify jvmti
1177     if (JvmtiExport::should_post_class_load()) {
1178         assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1179         JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1180     }
1181     if (class_load_start_event.should_commit()) {
1182       post_class_load_event(&amp;class_load_start_event, k, loader_data);
1183     }
1184   }
1185   assert(is_unsafe_anon_class || NULL == cl_info.cp_patches(),
1186          &quot;cp_patches only found with unsafe_anonymous_host&quot;);
1187 
1188   return k;
1189 }
1190 
1191 // Add a klass to the system from a stream (called by jni_DefineClass and
1192 // JVM_DefineClass).
1193 // Note: class_name can be NULL. In that case we do not know the name of
1194 // the class until we have parsed the stream.
1195 
1196 InstanceKlass* SystemDictionary::resolve_from_stream(Symbol* class_name,
1197                                                      Handle class_loader,
1198                                                      Handle protection_domain,
1199                                                      ClassFileStream* st,
1200                                                      TRAPS) {
1201 
1202   HandleMark hm(THREAD);
1203 
1204   // Classloaders that support parallelism, e.g. bootstrap classloader,
1205   // do not acquire lock here
1206   bool DoObjectLock = true;
1207   if (is_parallelCapable(class_loader)) {
1208     DoObjectLock = false;
1209   }
1210 
1211   ClassLoaderData* loader_data = register_loader(class_loader);
1212 
1213   // Make sure we are synchronized on the class loader before we proceed
1214   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1215   check_loader_lock_contention(lockObject, THREAD);
1216   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
1217 
1218   assert(st != NULL, &quot;invariant&quot;);
1219 
1220   // Parse the stream and create a klass.
1221   // Note that we do this even though this klass might
1222   // already be present in the SystemDictionary, otherwise we would not
1223   // throw potential ClassFormatErrors.
1224  InstanceKlass* k = NULL;
1225 
1226 #if INCLUDE_CDS
1227   if (!DumpSharedSpaces) {
1228     k = SystemDictionaryShared::lookup_from_stream(class_name,
1229                                                    class_loader,
1230                                                    protection_domain,
1231                                                    st,
1232                                                    CHECK_NULL);
1233   }
1234 #endif
1235 
1236   if (k == NULL) {
1237     if (st-&gt;buffer() == NULL) {
1238       return NULL;
1239     }
1240     ClassLoadInfo cl_info(protection_domain);
1241     k = KlassFactory::create_from_stream(st, class_name, loader_data, cl_info, CHECK_NULL);
1242   }
1243 
1244   assert(k != NULL, &quot;no klass created&quot;);
1245   Symbol* h_name = k-&gt;name();
1246   assert(class_name == NULL || class_name == h_name, &quot;name mismatch&quot;);
1247 
1248   // Add class just loaded
1249   // If a class loader supports parallel classloading handle parallel define requests
1250   // find_or_define_instance_class may return a different InstanceKlass
1251   if (is_parallelCapable(class_loader)) {
1252     InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
1253     if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1254       // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1255       assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1256       loader_data-&gt;add_to_deallocate_list(k);
1257       k = defined_k;
1258     }
1259   } else {
1260     define_instance_class(k, THREAD);
1261   }
1262 
1263   // If defining the class throws an exception register &#39;k&#39; for cleanup.
1264   if (HAS_PENDING_EXCEPTION) {
1265     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1266     loader_data-&gt;add_to_deallocate_list(k);
1267     return NULL;
1268   }
1269 
1270   // Make sure we have an entry in the SystemDictionary on success
1271   debug_only( {
1272     MutexLocker mu(THREAD, SystemDictionary_lock);
1273 
1274     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1275     assert(check == k, &quot;should be present in the dictionary&quot;);
1276   } );
1277 
1278   return k;
1279 }
1280 
1281 #if INCLUDE_CDS
1282 // Load a class for boot loader from the shared spaces. This also
1283 // forces the super class and all interfaces to be loaded.
1284 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
1285                                                         PackageEntry* pkg_entry,
1286                                                         TRAPS) {
1287   assert(UseSharedSpaces, &quot;Sanity check&quot;);
1288   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1289   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
1290     return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);
1291   }
1292   return NULL;
1293 }
1294 
1295 // Check if a shared class can be loaded by the specific classloader.
1296 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1297                                                InstanceKlass* ik,
1298                                                PackageEntry* pkg_entry,
1299                                                Handle class_loader, TRAPS) {
1300   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1301          &quot;Cannot use sharing if java.base is patched&quot;);
1302 
1303   // (1) Check if we are loading into the same loader as in dump time.
1304 
1305   if (ik-&gt;is_shared_boot_class()) {
1306     if (class_loader() != NULL) {
1307       return false;
1308     }
1309   } else if (ik-&gt;is_shared_platform_class()) {
1310     if (class_loader() != java_platform_loader()) {
1311       return false;
1312     }
1313   } else if (ik-&gt;is_shared_app_class()) {
1314     if (class_loader() != java_system_loader()) {
1315       return false;
1316     }
1317   } else {
1318     // ik was loaded by a custom loader during dump time
1319     if (class_loader_data(class_loader)-&gt;is_builtin_class_loader_data()) {
1320       return false;
1321     } else {
1322       return true;
1323     }
1324   }
1325 
1326   // (2) Check if we are loading into the same module from the same location as in dump time.
1327 
1328   if (MetaspaceShared::use_optimized_module_handling()) {
1329     // Class visibility has not changed between dump time and run time, so a class
1330     // that was visible (and thus archived) during dump time is always visible during runtime.
1331     assert(SystemDictionary::is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD),
1332            &quot;visibility cannot change between dump time and runtime&quot;);
1333     return true;
1334   }
1335   return is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD);
1336 }
1337 
1338 bool SystemDictionary::is_shared_class_visible_impl(Symbol* class_name,
1339                                                     InstanceKlass* ik,
1340                                                     PackageEntry* pkg_entry,
1341                                                     Handle class_loader, TRAPS) {
1342   int scp_index = ik-&gt;shared_classpath_index();
1343   assert(!ik-&gt;is_shared_unregistered_class(), &quot;this function should be called for built-in classes only&quot;);
1344   assert(scp_index &gt;= 0, &quot;must be&quot;);
1345   SharedClassPathEntry* scp_entry = FileMapInfo::shared_path(scp_index);
1346   if (!Universe::is_module_initialized()) {
1347     assert(scp_entry != NULL &amp;&amp; scp_entry-&gt;is_modules_image(),
1348            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1349     assert(class_loader.is_null(), &quot;sanity&quot;);
1350     return true;
1351   }
1352 
1353   ModuleEntry* mod_entry = (pkg_entry == NULL) ? NULL : pkg_entry-&gt;module();
1354   bool should_be_in_named_module = (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_named());
1355   bool was_archived_from_named_module = scp_entry-&gt;in_named_module();
1356   bool visible;
1357 
1358   if (was_archived_from_named_module) {
1359     if (should_be_in_named_module) {
1360       // Is the module loaded from the same location as during dump time?
1361       visible = mod_entry-&gt;shared_path_index() == scp_index;
1362       if (visible) {
1363         assert(!mod_entry-&gt;is_patched(), &quot;cannot load archived classes for patched module&quot;);
1364       }
1365     } else {
1366       // During dump time, this class was in a named module, but at run time, this class should be
1367       // in an unnamed module.
1368       visible = false;
1369     }
1370   } else {
1371     if (should_be_in_named_module) {
1372       // During dump time, this class was in an unnamed, but at run time, this class should be
1373       // in a named module.
1374       visible = false;
1375     } else {
1376       visible = true;
1377     }
1378   }
1379 
1380   return visible;
1381 }
1382 
1383 bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,
1384                                                      Handle class_loader,  Handle protection_domain,
1385                                                      bool is_superclass, TRAPS) {
1386   assert(super_type-&gt;is_shared(), &quot;must be&quot;);
1387 
1388   Klass *found = resolve_super_or_fail(child-&gt;name(), super_type-&gt;name(),
1389                                        class_loader, protection_domain, is_superclass, CHECK_0);
1390   if (found == super_type) {
1391     return true;
1392   } else {
1393     // The dynamically resolved super type is not the same as the one we used during dump time,
1394     // so we cannot use the child class.
1395     return false;
1396   }
1397 }
1398 
1399 bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
1400                                                       Handle protection_domain, TRAPS) {
1401   // Check the superclass and interfaces. They must be the same
1402   // as in dump time, because the layout of &lt;ik&gt; depends on
1403   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().
1404   //
1405   // If unexpected superclass or interfaces are found, we cannot
1406   // load &lt;ik&gt; from the shared archive.
1407 
1408   if (ik-&gt;super() != NULL &amp;&amp;
1409       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),
1410                                      class_loader, protection_domain, true, THREAD)) {
1411     return false;
1412   }
1413 
1414   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1415   int num_interfaces = interfaces-&gt;length();
1416   for (int index = 0; index &lt; num_interfaces; index++) {
1417     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {
1418       return false;
1419     }
1420   }
1421 
1422   return true;
1423 }
1424 
1425 InstanceKlass* SystemDictionary::load_shared_lambda_proxy_class(InstanceKlass* ik,
1426                                                                 Handle class_loader,
1427                                                                 Handle protection_domain,
1428                                                                 PackageEntry* pkg_entry,
1429                                                                 TRAPS) {
1430   InstanceKlass* shared_nest_host = SystemDictionaryShared::get_shared_nest_host(ik);
1431   assert(shared_nest_host-&gt;is_shared(), &quot;nest host must be in CDS archive&quot;);
1432   Symbol* cn = shared_nest_host-&gt;name();
1433   Klass *s = resolve_or_fail(cn, class_loader, protection_domain, true, CHECK_NULL);
1434   if (s != shared_nest_host) {
1435     // The dynamically resolved nest_host is not the same as the one we used during dump time,
1436     // so we cannot use ik.
1437     return NULL;
1438   } else {
1439     assert(s-&gt;is_shared(), &quot;must be&quot;);
1440   }
1441 
1442   // The lambda proxy class and its nest host have the same class loader and class loader data,
1443   // as verified in SystemDictionaryShared::add_lambda_proxy_class()
1444   assert(shared_nest_host-&gt;class_loader() == class_loader(), &quot;mismatched class loader&quot;);
1445   assert(shared_nest_host-&gt;class_loader_data() == ClassLoaderData::class_loader_data(class_loader()), &quot;mismatched class loader data&quot;);
1446   ik-&gt;set_nest_host(shared_nest_host, THREAD);
1447 
1448   InstanceKlass* loaded_ik = load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, CHECK_NULL);
1449 
1450   assert(shared_nest_host-&gt;is_same_class_package(ik),
1451          &quot;lambda proxy class and its nest host must be in the same package&quot;);
1452 
1453   return loaded_ik;
1454 }
1455 
1456 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1457                                                    Handle class_loader,
1458                                                    Handle protection_domain,
1459                                                    const ClassFileStream *cfs,
1460                                                    PackageEntry* pkg_entry,
1461                                                    TRAPS) {
1462   assert(ik != NULL, &quot;sanity&quot;);
1463   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1464   Symbol* class_name = ik-&gt;name();
1465 
1466   bool visible = is_shared_class_visible(
1467                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1468   if (!visible) {
1469     return NULL;
1470   }
1471 
1472   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1473     return NULL;
1474   }
1475 
1476 
1477   if (ik-&gt;has_inline_type_fields()) {
1478     for (AllFieldStream fs(ik-&gt;fields(), ik-&gt;constants()); !fs.done(); fs.next()) {
1479       if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE) {
1480         if (!fs.access_flags().is_static()) {
1481           // Pre-load inline class
1482           Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,
1483             class_loader, protection_domain, true, CHECK_NULL);
1484           Klass* k = ik-&gt;get_inline_type_field_klass_or_null(fs.index());
1485           if (real_k != k) {
1486             // oops, the app has substituted a different version of k!
1487             return NULL;
1488           }
1489         }
1490       }
1491     }
1492   }
1493 
1494   InstanceKlass* new_ik = NULL;
1495   // CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).
1496   // It will be skipped for shared VM hidden lambda proxy classes.
1497   if (!SystemDictionaryShared::is_hidden_lambda_proxy(ik)) {
1498     new_ik = KlassFactory::check_shared_class_file_load_hook(
1499       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1500   }
1501   if (new_ik != NULL) {
1502     // The class is changed by CFLH. Return the new class. The shared class is
1503     // not used.
1504     return new_ik;
1505   }
1506 
1507   // Adjust methods to recover missing data.  They need addresses for
1508   // interpreter entry points and their default native method address
1509   // must be reset.
1510 
1511   // Updating methods must be done under a lock so multiple
1512   // threads don&#39;t update these in parallel
1513   //
1514   // Shared classes are all currently loaded by either the bootstrap or
1515   // internal parallel class loaders, so this will never cause a deadlock
1516   // on a custom class loader lock.
1517 
1518   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1519   {
1520     HandleMark hm(THREAD);
1521     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1522     check_loader_lock_contention(lockObject, THREAD);
1523     ObjectLocker ol(lockObject, THREAD, true);
1524     // prohibited package check assumes all classes loaded from archive call
1525     // restore_unshareable_info which calls ik-&gt;set_package()
1526     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1527   }
1528 
1529   load_shared_class_misc(ik, loader_data, CHECK_NULL);
1530 
1531   if (ik-&gt;is_inline_klass()) {
1532     InlineKlass* vk = InlineKlass::cast(ik);
1533     oop val = ik-&gt;allocate_instance(CHECK_NULL);
1534     vk-&gt;set_default_value(val);
1535   }
1536 
1537   return ik;
1538 }
1539 
1540 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1541   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1542 
1543   // For boot loader, ensure that GetSystemPackage knows that a class in this
1544   // package was loaded.
1545   if (loader_data-&gt;is_the_null_class_loader_data()) {
1546     int path_index = ik-&gt;shared_classpath_index();
1547     ik-&gt;set_classpath_index(path_index, THREAD);
1548   }
1549 
1550   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1551     // Only dump the classes that can be stored into CDS archive
1552     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1553       ResourceMark rm(THREAD);
1554       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1555       classlist_file-&gt;flush();
1556     }
1557   }
1558 
1559   // notify a class loaded from shared object
1560   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1561 
1562   ik-&gt;set_has_passed_fingerprint_check(false);
1563   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1564     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1565     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1566     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1567       // This class matches with a class saved in an AOT library
1568       ik-&gt;set_has_passed_fingerprint_check(true);
1569     } else {
1570       if (log_is_enabled(Info, class, fingerprint)) {
1571         ResourceMark rm(THREAD);
1572         log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
1573       }
1574     }
1575   }
1576 }
1577 
1578 void SystemDictionary::quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) {
1579   assert(!Universe::is_fully_initialized(), &quot;We can make short cuts only during VM initialization&quot;);
1580   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1581   if (klass-&gt;class_loader_data() != NULL) {
1582     return;
1583   }
1584 
1585   // add super and interfaces first
1586   Klass* super = klass-&gt;super();
1587   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1588     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1589     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1590   }
1591 
1592   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1593   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1594     InstanceKlass* ik = ifs-&gt;at(i);
1595     if (ik-&gt;class_loader_data()  == NULL) {
1596       quick_resolve(ik, loader_data, domain, CHECK);
1597     }
1598   }
1599 
1600   if (klass-&gt;has_inline_type_fields()) {
1601     for (AllFieldStream fs(klass-&gt;fields(), klass-&gt;constants()); !fs.done(); fs.next()) {
1602       if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE) {
1603         if (!fs.access_flags().is_static()) {
1604           Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,
1605             Handle(THREAD, loader_data-&gt;class_loader()), domain, true, CHECK);
1606           Klass* k = klass-&gt;get_inline_type_field_klass_or_null(fs.index());
1607           assert(real_k == k, &quot;oops, the app has substituted a different version of k!&quot;);
1608         } else {
1609           klass-&gt;reset_inline_type_field_klass(fs.index());
1610         }
1611       }
1612     }
1613   }
1614 
1615   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);
1616   load_shared_class_misc(klass, loader_data, CHECK);
1617   Dictionary* dictionary = loader_data-&gt;dictionary();
1618   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1619   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1620   add_to_hierarchy(klass, CHECK);
1621   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1622 }
1623 #endif // INCLUDE_CDS
1624 
1625 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1626 
1627   if (class_loader.is_null()) {
1628     ResourceMark rm(THREAD);
1629     PackageEntry* pkg_entry = NULL;
1630     bool search_only_bootloader_append = false;
1631     ClassLoaderData *loader_data = class_loader_data(class_loader);
1632 
1633     // Find the package in the boot loader&#39;s package entry table.
1634     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
1635     if (pkg_name != NULL) {
1636       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1637     }
1638 
1639     // Prior to attempting to load the class, enforce the boot loader&#39;s
1640     // visibility boundaries.
1641     if (!Universe::is_module_initialized()) {
1642       // During bootstrapping, prior to module initialization, any
1643       // class attempting to be loaded must be checked against the
1644       // java.base packages in the boot loader&#39;s PackageEntryTable.
1645       // No class outside of java.base is allowed to be loaded during
1646       // this bootstrapping window.
1647       if (pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1648         // Class is either in the unnamed package or in
1649         // a named package within the unnamed module.  Either
1650         // case is outside of java.base, do not attempt to
1651         // load the class post java.base definition.  If
1652         // java.base has not been defined, let the class load
1653         // and its package will be checked later by
1654         // ModuleEntryTable::verify_javabase_packages.
1655         if (ModuleEntryTable::javabase_defined()) {
1656           return NULL;
1657         }
1658       } else {
1659         // Check that the class&#39; package is defined within java.base.
1660         ModuleEntry* mod_entry = pkg_entry-&gt;module();
1661         Symbol* mod_entry_name = mod_entry-&gt;name();
1662         if (mod_entry_name-&gt;fast_compare(vmSymbols::java_base()) != 0) {
1663           return NULL;
1664         }
1665       }
1666     } else {
1667       // After the module system has been initialized, check if the class&#39;
1668       // package is in a module defined to the boot loader.
1669       if (pkg_name == NULL || pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1670         // Class is either in the unnamed package, in a named package
1671         // within a module not defined to the boot loader or in a
1672         // a named package within the unnamed module.  In all cases,
1673         // limit visibility to search for the class only in the boot
1674         // loader&#39;s append path.
1675         if (!ClassLoader::has_bootclasspath_append()) {
1676            // If there is no bootclasspath append entry, no need to continue
1677            // searching.
1678            return NULL;
1679         }
1680         search_only_bootloader_append = true;
1681       }
1682     }
1683 
1684     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1685     // of the boot loader&#39;s module path
1686     assert(Universe::is_module_initialized() ||
1687            !search_only_bootloader_append,
1688            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1689 
1690     // Search for classes in the CDS archive.
1691     InstanceKlass* k = NULL;
1692 
1693 #if INCLUDE_CDS
1694     if (UseSharedSpaces)
1695     {
1696       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
1697       k = load_shared_boot_class(class_name, pkg_entry, THREAD);
1698     }
1699 #endif
1700 
1701     if (k == NULL) {
1702       // Use VM class loader
1703       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
1704       k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);
1705     }
1706 
1707     // find_or_define_instance_class may return a different InstanceKlass
1708     if (k != NULL) {
1709       InstanceKlass* defined_k =
1710         find_or_define_instance_class(class_name, class_loader, k, THREAD);
1711       if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1712         // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1713         assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1714         loader_data-&gt;add_to_deallocate_list(k);
1715         k = defined_k;
1716       } else if (HAS_PENDING_EXCEPTION) {
1717         loader_data-&gt;add_to_deallocate_list(k);
1718         return NULL;
1719       }
1720     }
1721     return k;
1722   } else {
1723     // Use user specified class loader to load class. Call loadClass operation on class_loader.
1724     ResourceMark rm(THREAD);
1725 
1726     assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1727     JavaThread* jt = (JavaThread*) THREAD;
1728 
1729     PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(),
1730                                ClassLoader::perf_app_classload_selftime(),
1731                                ClassLoader::perf_app_classload_count(),
1732                                jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1733                                jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1734                                PerfClassTraceTime::CLASS_LOAD);
1735 
1736     Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);
1737     // Translate to external class name format, i.e., convert &#39;/&#39; chars to &#39;.&#39;
1738     Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);
1739 
1740     JavaValue result(T_OBJECT);
1741 
1742     InstanceKlass* spec_klass = SystemDictionary::ClassLoader_klass();
1743 
1744     // Call public unsynchronized loadClass(String) directly for all class loaders.
1745     // For parallelCapable class loaders, JDK &gt;=7, loadClass(String, boolean) will
1746     // acquire a class-name based lock rather than the class loader object lock.
1747     // JDK &lt; 7 already acquire the class loader lock in loadClass(String, boolean).
1748     JavaCalls::call_virtual(&amp;result,
1749                             class_loader,
1750                             spec_klass,
1751                             vmSymbols::loadClass_name(),
1752                             vmSymbols::string_class_signature(),
1753                             string,
1754                             CHECK_NULL);
1755 
1756     assert(result.get_type() == T_OBJECT, &quot;just checking&quot;);
1757     oop obj = (oop) result.get_jobject();
1758 
1759     // Primitive classes return null since forName() can not be
1760     // used to obtain any of the Class objects representing primitives or void
1761     if ((obj != NULL) &amp;&amp; !(java_lang_Class::is_primitive(obj))) {
1762       InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(obj));
1763       // For user defined Java class loaders, check that the name returned is
1764       // the same as that requested.  This check is done for the bootstrap
1765       // loader when parsing the class file.
1766       if (class_name == k-&gt;name()) {
1767         return k;
1768       }
1769     }
1770     // Class is not found or has the wrong name, return NULL
1771     return NULL;
1772   }
1773 }
1774 
1775 static void post_class_define_event(InstanceKlass* k, const ClassLoaderData* def_cld) {
1776   EventClassDefine event;
1777   if (event.should_commit()) {
1778     event.set_definedClass(k);
1779     event.set_definingClassLoader(def_cld);
1780     event.commit();
1781   }
1782 }
1783 
1784 void SystemDictionary::define_instance_class(InstanceKlass* k, TRAPS) {
1785 
1786   HandleMark hm(THREAD);
1787   ClassLoaderData* loader_data = k-&gt;class_loader_data();
1788   Handle class_loader_h(THREAD, loader_data-&gt;class_loader());
1789 
1790  // for bootstrap and other parallel classloaders don&#39;t acquire lock,
1791  // use placeholder token
1792  // If a parallelCapable class loader calls define_instance_class instead of
1793  // find_or_define_instance_class to get here, we have a timing
1794  // hole with systemDictionary updates and check_constraints
1795  if (!class_loader_h.is_null() &amp;&amp; !is_parallelCapable(class_loader_h)) {
1796     assert(ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD,
1797          compute_loader_lock_object(class_loader_h, THREAD)),
1798          &quot;define called without lock&quot;);
1799   }
1800 
1801   // Check class-loading constraints. Throw exception if violation is detected.
1802   // Grabs and releases SystemDictionary_lock
1803   // The check_constraints/find_class call and update_dictionary sequence
1804   // must be &quot;atomic&quot; for a specific class/classloader pair so we never
1805   // define two different instanceKlasses for that class/classloader pair.
1806   // Existing classloaders will call define_instance_class with the
1807   // classloader lock held
1808   // Parallel classloaders will call find_or_define_instance_class
1809   // which will require a token to perform the define class
1810   Symbol*  name_h = k-&gt;name();
1811   Dictionary* dictionary = loader_data-&gt;dictionary();
1812   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1813   check_constraints(d_hash, k, class_loader_h, true, CHECK);
1814 
1815   // Register class just loaded with class loader (placed in ArrayList)
1816   // Note we do this before updating the dictionary, as this can
1817   // fail with an OutOfMemoryError (if it does, we will *not* put this
1818   // class in the dictionary and will not update the class hierarchy).
1819   // JVMTI FollowReferences needs to find the classes this way.
1820   if (k-&gt;class_loader() != NULL) {
1821     methodHandle m(THREAD, Universe::loader_addClass_method());
1822     JavaValue result(T_VOID);
1823     JavaCallArguments args(class_loader_h);
1824     args.push_oop(Handle(THREAD, k-&gt;java_mirror()));
1825     JavaCalls::call(&amp;result, m, &amp;args, CHECK);
1826   }
1827 
1828   // Add the new class. We need recompile lock during update of CHA.
1829   {
1830     unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1831     int p_index = placeholders()-&gt;hash_to_index(p_hash);
1832 
1833     MutexLocker mu_r(THREAD, Compile_lock);
1834 
1835     // Add to class hierarchy, initialize vtables, and do possible
1836     // deoptimizations.
1837     add_to_hierarchy(k, CHECK); // No exception, but can block
1838 
1839     // Add to systemDictionary - so other classes can see it.
1840     // Grabs and releases SystemDictionary_lock
1841     update_dictionary(d_hash, p_index, p_hash,
1842                       k, class_loader_h, THREAD);
1843   }
1844   k-&gt;eager_initialize(THREAD);
1845 
1846   // notify jvmti
1847   if (JvmtiExport::should_post_class_load()) {
1848       assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1849       JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1850 
1851   }
1852   post_class_define_event(k, loader_data);
1853 }
1854 
1855 // Support parallel classloading
1856 // All parallel class loaders, including bootstrap classloader
1857 // lock a placeholder entry for this class/class_loader pair
1858 // to allow parallel defines of different classes for this class loader
1859 // With AllowParallelDefine flag==true, in case they do not synchronize around
1860 // FindLoadedClass/DefineClass, calls, we check for parallel
1861 // loading for them, wait if a defineClass is in progress
1862 // and return the initial requestor&#39;s results
1863 // This flag does not apply to the bootstrap classloader.
1864 // With AllowParallelDefine flag==false, call through to define_instance_class
1865 // which will throw LinkageError: duplicate class definition.
1866 // False is the requested default.
1867 // For better performance, the class loaders should synchronize
1868 // findClass(), i.e. FindLoadedClass/DefineClassIfAbsent or they
1869 // potentially waste time reading and parsing the bytestream.
1870 // Note: VM callers should ensure consistency of k/class_name,class_loader
1871 // Be careful when modifying this code: once you have run
1872 // placeholders()-&gt;find_and_add(PlaceholderTable::DEFINE_CLASS),
1873 // you need to find_and_remove it before returning.
1874 // So be careful to not exit with a CHECK_ macro betweeen these calls.
1875 InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,
1876                                                                InstanceKlass* k, TRAPS) {
1877 
1878   Symbol*  name_h = k-&gt;name(); // passed in class_name may be null
1879   ClassLoaderData* loader_data = class_loader_data(class_loader);
1880   Dictionary* dictionary = loader_data-&gt;dictionary();
1881 
1882   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1883 
1884   // Hold SD lock around find_class and placeholder creation for DEFINE_CLASS
1885   unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1886   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1887   PlaceholderEntry* probe;
1888 
1889   {
1890     MutexLocker mu(THREAD, SystemDictionary_lock);
1891     // First check if class already defined
1892     if (is_parallelDefine(class_loader)) {
1893       InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1894       if (check != NULL) {
1895         return check;
1896       }
1897     }
1898 
1899     // Acquire define token for this class/classloader
1900     probe = placeholders()-&gt;find_and_add(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, NULL, THREAD);
1901     // Wait if another thread defining in parallel
1902     // All threads wait - even those that will throw duplicate class: otherwise
1903     // caller is surprised by LinkageError: duplicate, but findLoadedClass fails
1904     // if other thread has not finished updating dictionary
1905     while (probe-&gt;definer() != NULL) {
1906       SystemDictionary_lock-&gt;wait();
1907     }
1908     // Only special cases allow parallel defines and can use other thread&#39;s results
1909     // Other cases fall through, and may run into duplicate defines
1910     // caught by finding an entry in the SystemDictionary
1911     if (is_parallelDefine(class_loader) &amp;&amp; (probe-&gt;instance_klass() != NULL)) {
1912         placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1913         SystemDictionary_lock-&gt;notify_all();
1914 #ifdef ASSERT
1915         InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1916         assert(check != NULL, &quot;definer missed recording success&quot;);
1917 #endif
1918         return probe-&gt;instance_klass();
1919     } else {
1920       // This thread will define the class (even if earlier thread tried and had an error)
1921       probe-&gt;set_definer(THREAD);
1922     }
1923   }
1924 
1925   define_instance_class(k, THREAD);
1926 
1927   Handle linkage_exception = Handle(); // null handle
1928 
1929   // definer must notify any waiting threads
1930   {
1931     MutexLocker mu(THREAD, SystemDictionary_lock);
1932     PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, name_h, loader_data);
1933     assert(probe != NULL, &quot;DEFINE_CLASS placeholder lost?&quot;);
1934     if (probe != NULL) {
1935       if (HAS_PENDING_EXCEPTION) {
1936         linkage_exception = Handle(THREAD,PENDING_EXCEPTION);
1937         CLEAR_PENDING_EXCEPTION;
1938       } else {
1939         probe-&gt;set_instance_klass(k);
1940       }
1941       probe-&gt;set_definer(NULL);
1942       placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1943       SystemDictionary_lock-&gt;notify_all();
1944     }
1945   }
1946 
1947   // Can&#39;t throw exception while holding lock due to rank ordering
1948   if (linkage_exception() != NULL) {
1949     THROW_OOP_(linkage_exception(), NULL); // throws exception and returns
1950   }
1951 
1952   return k;
1953 }
1954 
1955 Handle SystemDictionary::compute_loader_lock_object(Handle class_loader, TRAPS) {
1956   // If class_loader is NULL we synchronize on _system_loader_lock_obj
1957   if (class_loader.is_null()) {
1958     return Handle(THREAD, _system_loader_lock_obj.resolve());
1959   } else {
1960     return class_loader;
1961   }
1962 }
1963 
1964 // This method is added to check how often we have to wait to grab loader
1965 // lock. The results are being recorded in the performance counters defined in
1966 // ClassLoader::_sync_systemLoaderLockContentionRate and
1967 // ClassLoader::_sync_nonSystemLoaderLockConteionRate.
1968 void SystemDictionary::check_loader_lock_contention(Handle loader_lock, TRAPS) {
1969   if (!UsePerfData) {
1970     return;
1971   }
1972 
1973   assert(!loader_lock.is_null(), &quot;NULL lock object&quot;);
1974 
1975   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
1976       == ObjectSynchronizer::owner_other) {
1977     // contention will likely happen, so increment the corresponding
1978     // contention counter.
1979     if (loader_lock() == _system_loader_lock_obj.resolve()) {
1980       ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
1981     } else {
1982       ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
1983     }
1984   }
1985 }
1986 
1987 // ----------------------------------------------------------------------------
1988 // Lookup
1989 
1990 InstanceKlass* SystemDictionary::find_class(unsigned int hash,
1991                                             Symbol* class_name,
1992                                             Dictionary* dictionary) {
1993   assert_locked_or_safepoint(SystemDictionary_lock);
1994   int index = dictionary-&gt;hash_to_index(hash);
1995   return dictionary-&gt;find_class(index, hash, class_name);
1996 }
1997 
1998 
1999 // Basic find on classes in the midst of being loaded
2000 Symbol* SystemDictionary::find_placeholder(Symbol* class_name,
2001                                            ClassLoaderData* loader_data) {
2002   assert_locked_or_safepoint(SystemDictionary_lock);
2003   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);
2004   int p_index = placeholders()-&gt;hash_to_index(p_hash);
2005   return placeholders()-&gt;find_entry(p_index, p_hash, class_name, loader_data);
2006 }
2007 
2008 
2009 // Used for assertions and verification only
2010 // Precalculating the hash and index is an optimization because there are many lookups
2011 // before adding the class.
2012 InstanceKlass* SystemDictionary::find_class(Symbol* class_name, ClassLoaderData* loader_data) {
2013   assert_locked_or_safepoint(SystemDictionary_lock);
2014   #ifndef ASSERT
2015   guarantee(VerifyBeforeGC      ||
2016             VerifyDuringGC      ||
2017             VerifyBeforeExit    ||
2018             VerifyDuringStartup ||
2019             VerifyAfterGC, &quot;too expensive&quot;);
2020   #endif
2021 
2022   Dictionary* dictionary = loader_data-&gt;dictionary();
2023   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
2024   return find_class(d_hash, class_name, dictionary);
2025 }
2026 
2027 
2028 // ----------------------------------------------------------------------------
2029 // Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Recompile_lock
2030 // is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in
2031 // before a new class is used.
2032 
2033 void SystemDictionary::add_to_hierarchy(InstanceKlass* k, TRAPS) {
2034   assert(k != NULL, &quot;just checking&quot;);
2035   if (Universe::is_fully_initialized()) {
2036     assert_locked_or_safepoint(Compile_lock);
2037   }
2038 
2039   k-&gt;set_init_state(InstanceKlass::loaded);
2040   // make sure init_state store is already done.
2041   // The compiler reads the hierarchy outside of the Compile_lock.
2042   // Access ordering is used to add to hierarchy.
2043 
2044   // Link into hierachy.
2045   k-&gt;append_to_sibling_list();                    // add to superklass/sibling list
2046   k-&gt;process_interfaces(THREAD);                  // handle all &quot;implements&quot; declarations
2047 
2048   // Now flush all code that depended on old class hierarchy.
2049   // Note: must be done *after* linking k into the hierarchy (was bug 12/9/97)
2050   if (Universe::is_fully_initialized()) {
2051     CodeCache::flush_dependents_on(k);
2052   }
2053 }
2054 
2055 // ----------------------------------------------------------------------------
2056 // GC support
2057 
2058 // Assumes classes in the SystemDictionary are only unloaded at a safepoint
2059 // Note: anonymous classes are not in the SD.
2060 bool SystemDictionary::do_unloading(GCTimer* gc_timer) {
2061 
2062   bool unloading_occurred;
2063   bool is_concurrent = !SafepointSynchronize::is_at_safepoint();
2064   {
2065     GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
2066     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
2067     // First, mark for unload all ClassLoaderData referencing a dead class loader.
2068     unloading_occurred = ClassLoaderDataGraph::do_unloading();
2069     if (unloading_occurred) {
2070       MutexLocker ml2(is_concurrent ? Module_lock : NULL);
2071       JFR_ONLY(Jfr::on_unloading_classes();)
2072 
2073       MutexLocker ml1(is_concurrent ? SystemDictionary_lock : NULL);
2074       ClassLoaderDataGraph::clean_module_and_package_info();
2075       constraints()-&gt;purge_loader_constraints();
2076       resolution_errors()-&gt;purge_resolution_errors();
2077     }
2078   }
2079 
2080   GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);
2081 
2082   if (unloading_occurred) {
2083     SymbolTable::trigger_cleanup();
2084 
2085     // Oops referenced by the protection domain cache table may get unreachable independently
2086     // of the class loader (eg. cached protection domain oops). So we need to
2087     // explicitly unlink them here.
2088     // All protection domain oops are linked to the caller class, so if nothing
2089     // unloads, this is not needed.
2090     _pd_cache_table-&gt;trigger_cleanup();
2091   }
2092 
2093   return unloading_occurred;
2094 }
2095 
2096 // CDS: scan and relocate all classes referenced by _well_known_klasses[].
2097 void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
2098   for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
2099     it-&gt;push(well_known_klass_addr((WKID)id));
2100   }
2101 }
2102 
2103 void SystemDictionary::methods_do(void f(Method*)) {
2104   // Walk methods in loaded classes
2105   MutexLocker ml(ClassLoaderDataGraph_lock);
2106   ClassLoaderDataGraph::methods_do(f);
2107   // Walk method handle intrinsics
2108   invoke_method_table()-&gt;methods_do(f);
2109 }
2110 
2111 // ----------------------------------------------------------------------------
2112 // Initialization
2113 
2114 void SystemDictionary::initialize(TRAPS) {
2115   // Allocate arrays
2116   _placeholders        = new PlaceholderTable(_placeholder_table_size);
2117   _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);
2118   _resolution_errors   = new ResolutionErrorTable(_resolution_error_size);
2119   _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);
2120   _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);
2121 
2122   // Allocate private object used as system class loader lock
2123   oop lock_obj = oopFactory::new_intArray(0, CHECK);
2124   _system_loader_lock_obj = OopHandle(OopStorageSet::vm_global(), lock_obj);
2125 
2126   // Initialize basic classes
2127   resolve_well_known_classes(CHECK);
2128 }
2129 
2130 // Compact table of directions on the initialization of klasses:
2131 static const short wk_init_info[] = {
2132   #define WK_KLASS_INIT_INFO(name, symbol) \
2133     ((short)vmSymbols::VM_SYMBOL_ENUM_NAME(symbol)),
2134 
2135   WK_KLASSES_DO(WK_KLASS_INIT_INFO)
2136   #undef WK_KLASS_INIT_INFO
2137   0
2138 };
2139 
2140 #ifdef ASSERT
2141 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
2142   int sid;
2143   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
2144     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2145     if (class_name == symbol) {
2146       return true;
2147     }
2148   }
2149   return false;
2150 }
2151 #endif
2152 
2153 bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {
2154   assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
2155   int sid = wk_init_info[id - FIRST_WKID];
2156   Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2157   InstanceKlass** klassp = &amp;_well_known_klasses[id];
2158 
2159 #if INCLUDE_CDS
2160   if (UseSharedSpaces &amp;&amp; !JvmtiExport::should_post_class_prepare()) {
2161     InstanceKlass* k = *klassp;
2162     assert(k-&gt;is_shared_boot_class(), &quot;must be&quot;);
2163 
2164     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
2165     quick_resolve(k, loader_data, Handle(), CHECK_false);
2166     return true;
2167   }
2168 #endif // INCLUDE_CDS
2169 
2170   if (!is_wk_klass_loaded(*klassp)) {
2171     Klass* k = resolve_or_fail(symbol, true, CHECK_false);
2172     (*klassp) = InstanceKlass::cast(k);
2173   }
2174   return ((*klassp) != NULL);
2175 }
2176 
2177 void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS) {
2178   assert((int)start_id &lt;= (int)limit_id, &quot;IDs are out of order!&quot;);
2179   for (int id = (int)start_id; id &lt; (int)limit_id; id++) {
2180     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
2181     resolve_wk_klass((WKID)id, CHECK);
2182   }
2183 
2184   // move the starting value forward to the limit:
2185   start_id = limit_id;
2186 }
2187 
2188 void SystemDictionary::resolve_well_known_classes(TRAPS) {
2189   assert(!Object_klass_loaded(), &quot;well-known classes should only be initialized once&quot;);
2190 
2191   // Create the ModuleEntry for java.base.  This call needs to be done here,
2192   // after vmSymbols::initialize() is called but before any classes are pre-loaded.
2193   ClassLoader::classLoader_init2(CHECK);
2194 
2195   // Preload commonly used klasses
2196   WKID scan = FIRST_WKID;
2197   // first do Object, then String, Class
2198 #if INCLUDE_CDS
2199   if (UseSharedSpaces) {
2200     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Object_klass), scan, CHECK);
2201 
2202     // It&#39;s unsafe to access the archived heap regions before they
2203     // are fixed up, so we must do the fixup as early as possible
2204     // before the archived java objects are accessed by functions
2205     // such as java_lang_Class::restore_archived_mirror and
2206     // ConstantPool::restore_unshareable_info (restores the archived
2207     // resolved_references array object).
2208     //
2209     // HeapShared::fixup_mapped_heap_regions() fills the empty
2210     // spaces in the archived heap regions and may use
2211     // SystemDictionary::Object_klass(), so we can do this only after
2212     // Object_klass is resolved. See the above resolve_wk_klasses_through()
2213     // call. No mirror objects are accessed/restored in the above call.
2214     // Mirrors are restored after java.lang.Class is loaded.
2215     HeapShared::fixup_mapped_heap_regions();
2216 
2217     // Initialize the constant pool for the Object_class
2218     assert(Object_klass()-&gt;is_shared(), &quot;must be&quot;);
2219     Object_klass()-&gt;constants()-&gt;restore_unshareable_info(CHECK);
2220     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2221   } else
2222 #endif
2223   {
2224     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2225   }
2226 
2227   assert(WK_KLASS(Object_klass) != NULL, &quot;well-known classes should now be initialized&quot;);
2228 
2229   java_lang_Object::register_natives(CHECK);
2230 
2231   // Calculate offsets for String and Class classes since they are loaded and
2232   // can be used after this point.
2233   java_lang_String::compute_offsets();
2234   java_lang_Class::compute_offsets();
2235 
2236   // Fixup mirrors for classes loaded before java.lang.Class.
2237   Universe::initialize_basic_type_mirrors(CHECK);
2238   Universe::fixup_mirrors(CHECK);
2239 
2240   // do a bunch more:
2241   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
2242 
2243   // The offsets for jlr.Reference must be computed before
2244   // InstanceRefKlass::update_nonstatic_oop_maps is called. That function uses
2245   // the offsets to remove the referent and discovered fields from the oop maps,
2246   // as they are treated in a special way by the GC. Removing these oops from the
2247   // oop maps must be done before the usual subclasses of jlr.Reference are loaded.
2248   java_lang_ref_Reference::compute_offsets();
2249 
2250   // Preload ref klasses and set reference types
2251   WK_KLASS(Reference_klass)-&gt;set_reference_type(REF_OTHER);
2252   InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
2253 
2254   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
2255   WK_KLASS(SoftReference_klass)-&gt;set_reference_type(REF_SOFT);
2256   WK_KLASS(WeakReference_klass)-&gt;set_reference_type(REF_WEAK);
2257   WK_KLASS(FinalReference_klass)-&gt;set_reference_type(REF_FINAL);
2258   WK_KLASS(PhantomReference_klass)-&gt;set_reference_type(REF_PHANTOM);
2259 
2260   // JSR 292 classes
2261   WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
2262   WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
2263   resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
2264   resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
2265   WKID last = WKID_LIMIT;
2266   resolve_wk_klasses_until(last, scan, CHECK);
2267 
2268   _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
2269   _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
2270   _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
2271   _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);
2272   _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);
2273   _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);
2274   _box_klasses[T_INT]     = WK_KLASS(Integer_klass);
2275   _box_klasses[T_LONG]    = WK_KLASS(Long_klass);
2276   //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
2277   //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
2278 
2279 #ifdef ASSERT
2280   if (UseSharedSpaces) {
2281     JVMTI_ONLY(assert(JvmtiExport::is_early_phase(),
2282                       &quot;All well known classes must be resolved in JVMTI early phase&quot;));
2283     for (int i = FIRST_WKID; i &lt; last; i++) {
2284       InstanceKlass* k = _well_known_klasses[i];
2285       assert(k-&gt;is_shared(), &quot;must not be replaced by JVMTI class file load hook&quot;);
2286     }
2287   }
2288 #endif
2289 }
2290 
2291 // Tells if a given klass is a box (wrapper class, such as java.lang.Integer).
2292 // If so, returns the basic type it holds.  If not, returns T_OBJECT.
2293 BasicType SystemDictionary::box_klass_type(Klass* k) {
2294   assert(k != NULL, &quot;&quot;);
2295   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
2296     if (_box_klasses[i] == k)
2297       return (BasicType)i;
2298   }
2299   return T_OBJECT;
2300 }
2301 
2302 // Constraints on class loaders. The details of the algorithm can be
2303 // found in the OOPSLA&#39;98 paper &quot;Dynamic Class Loading in the Java
2304 // Virtual Machine&quot; by Sheng Liang and Gilad Bracha.  The basic idea is
2305 // that the dictionary needs to maintain a set of contraints that
2306 // must be satisfied by all classes in the dictionary.
2307 // if defining is true, then LinkageError if already in dictionary
2308 // if initiating loader, then ok if InstanceKlass matches existing entry
2309 
2310 void SystemDictionary::check_constraints(unsigned int d_hash,
2311                                          InstanceKlass* k,
2312                                          Handle class_loader,
2313                                          bool defining,
2314                                          TRAPS) {
2315   ResourceMark rm(THREAD);
2316   stringStream ss;
2317   bool throwException = false;
2318 
2319   {
2320     Symbol *name = k-&gt;name();
2321     ClassLoaderData *loader_data = class_loader_data(class_loader);
2322 
2323     MutexLocker mu(THREAD, SystemDictionary_lock);
2324 
2325     InstanceKlass* check = find_class(d_hash, name, loader_data-&gt;dictionary());
2326     if (check != NULL) {
2327       // If different InstanceKlass - duplicate class definition,
2328       // else - ok, class loaded by a different thread in parallel.
2329       // We should only have found it if it was done loading and ok to use.
2330       // The dictionary only holds instance classes, placeholders
2331       // also hold array classes.
2332 
2333       assert(check-&gt;is_instance_klass(), &quot;noninstance in systemdictionary&quot;);
2334       if ((defining == true) || (k != check)) {
2335         throwException = true;
2336         ss.print(&quot;loader %s&quot;, loader_data-&gt;loader_name_and_id());
2337         ss.print(&quot; attempted duplicate %s definition for %s. (%s)&quot;,
2338                  k-&gt;external_kind(), k-&gt;external_name(), k-&gt;class_in_module_of_loader(false, true));
2339       } else {
2340         return;
2341       }
2342     }
2343 
2344 #ifdef ASSERT
2345     Symbol* ph_check = find_placeholder(name, loader_data);
2346     assert(ph_check == NULL || ph_check == name, &quot;invalid symbol&quot;);
2347 #endif
2348 
2349     if (throwException == false) {
2350       if (constraints()-&gt;check_or_update(k, class_loader, name) == false) {
2351         throwException = true;
2352         ss.print(&quot;loader constraint violation: loader %s&quot;, loader_data-&gt;loader_name_and_id());
2353         ss.print(&quot; wants to load %s %s.&quot;,
2354                  k-&gt;external_kind(), k-&gt;external_name());
2355         Klass *existing_klass = constraints()-&gt;find_constrained_klass(name, class_loader);
2356         if (existing_klass != NULL &amp;&amp; existing_klass-&gt;class_loader() != class_loader()) {
2357           ss.print(&quot; A different %s with the same name was previously loaded by %s. (%s)&quot;,
2358                    existing_klass-&gt;external_kind(),
2359                    existing_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
2360                    existing_klass-&gt;class_in_module_of_loader(false, true));
2361         } else {
2362           ss.print(&quot; (%s)&quot;, k-&gt;class_in_module_of_loader(false, true));
2363         }
2364       }
2365     }
2366   }
2367 
2368   // Throw error now if needed (cannot throw while holding
2369   // SystemDictionary_lock because of rank ordering)
2370   if (throwException == true) {
2371     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
2372   }
2373 }
2374 
2375 // Update class loader data dictionary - done after check_constraint and add_to_hierachy
2376 // have been called.
2377 void SystemDictionary::update_dictionary(unsigned int d_hash,
2378                                          int p_index, unsigned int p_hash,
2379                                          InstanceKlass* k,
2380                                          Handle class_loader,
2381                                          TRAPS) {
2382   // Compile_lock prevents systemDictionary updates during compilations
2383   assert_locked_or_safepoint(Compile_lock);
2384   Symbol*  name  = k-&gt;name();
2385   ClassLoaderData *loader_data = class_loader_data(class_loader);
2386 
2387   {
2388     MutexLocker mu1(THREAD, SystemDictionary_lock);
2389 
2390     // Make a new dictionary entry.
2391     Dictionary* dictionary = loader_data-&gt;dictionary();
2392     InstanceKlass* sd_check = find_class(d_hash, name, dictionary);
2393     if (sd_check == NULL) {
2394       dictionary-&gt;add_klass(d_hash, name, k);
2395     }
2396   #ifdef ASSERT
2397     sd_check = find_class(d_hash, name, dictionary);
2398     assert (sd_check != NULL, &quot;should have entry in dictionary&quot;);
2399     // Note: there may be a placeholder entry: for circularity testing
2400     // or for parallel defines
2401   #endif
2402     SystemDictionary_lock-&gt;notify_all();
2403   }
2404 }
2405 
2406 
2407 // Try to find a class name using the loader constraints.  The
2408 // loader constraints might know about a class that isn&#39;t fully loaded
2409 // yet and these will be ignored.
2410 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2411                     Symbol* class_name, Handle class_loader, TRAPS) {
2412 
2413   // First see if it has been loaded directly.
2414   // Force the protection domain to be null.  (This removes protection checks.)
2415   Handle no_protection_domain;
2416   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2417                                               no_protection_domain, CHECK_NULL);
2418   if (klass != NULL)
2419     return klass;
2420 
2421   // Now look to see if it has been loaded elsewhere, and is subject to
2422   // a loader constraint that would require this loader to return the
2423   // klass that is already loaded.
2424   if (Signature::is_array(class_name)) {
2425     // For array classes, their Klass*s are not kept in the
2426     // constraint table. The element Klass*s are.
2427     SignatureStream ss(class_name, false);
2428     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2429     BasicType t = ss.type();
2430     if (t != T_OBJECT &amp;&amp; t != T_INLINE_TYPE) {
2431       klass = Universe::typeArrayKlassObj(t);
2432     } else {
2433       MutexLocker mu(THREAD, SystemDictionary_lock);
2434       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2435     }
2436     // If element class already loaded, allocate array klass
2437     if (klass != NULL) {
2438       klass = klass-&gt;array_klass_or_null(ndims);
2439     }
2440   } else {
2441     MutexLocker mu(THREAD, SystemDictionary_lock);
2442     // Non-array classes are easy: simply check the constraint table.
2443     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2444   }
2445 
2446   return klass;
2447 }
2448 
2449 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2450                                              Klass* klass_being_linked,
2451                                              Handle class_loader1,
2452                                              Handle class_loader2,
2453                                              Thread* THREAD) {
2454   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2455   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2456 
2457   Symbol* constraint_name = NULL;
2458 
2459   if (!Signature::is_array(class_name)) {
2460     constraint_name = class_name;
2461   } else {
2462     // For array classes, their Klass*s are not kept in the
2463     // constraint table. The element classes are.
2464     SignatureStream ss(class_name, false);
2465     ss.skip_array_prefix();  // skip all &#39;[&#39;s
2466     if (!ss.has_envelope()) {
2467       return true;     // primitive types always pass
2468     }
2469     constraint_name = ss.as_symbol();
2470     // Increment refcount to keep constraint_name alive after
2471     // SignatureStream is destructed. It will be decremented below
2472     // before returning.
2473     constraint_name-&gt;increment_refcount();
2474   }
2475 
2476   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2477   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2478 
2479   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2480   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2481 
2482   {
2483     MutexLocker mu_s(THREAD, SystemDictionary_lock);
2484     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2485     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
2486     bool result = constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,
2487                                            klass2, class_loader2);
2488 #if INCLUDE_CDS
2489     if (Arguments::is_dumping_archive() &amp;&amp; klass_being_linked != NULL &amp;&amp;
2490         !klass_being_linked-&gt;is_shared()) {
2491          SystemDictionaryShared::record_linking_constraint(constraint_name,
2492                                      InstanceKlass::cast(klass_being_linked),
2493                                      class_loader1, class_loader2, THREAD);
2494     }
2495 #endif // INCLUDE_CDS
2496     if (Signature::is_array(class_name)) {
2497       constraint_name-&gt;decrement_refcount();
2498     }
2499     return result;
2500   }
2501 }
2502 
2503 // Add entry to resolution error table to record the error when the first
2504 // attempt to resolve a reference to a class has failed.
2505 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2506                                             Symbol* error, Symbol* message) {
2507   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2508   int index = resolution_errors()-&gt;hash_to_index(hash);
2509   {
2510     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2511     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2512   }
2513 }
2514 
2515 // Delete a resolution error for RedefineClasses for a constant pool is going away
2516 void SystemDictionary::delete_resolution_error(ConstantPool* pool) {
2517   resolution_errors()-&gt;delete_entry(pool);
2518 }
2519 
2520 // Lookup resolution error table. Returns error if found, otherwise NULL.
2521 Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
2522                                                 Symbol** message) {
2523   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2524   int index = resolution_errors()-&gt;hash_to_index(hash);
2525   {
2526     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2527     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2528     if (entry != NULL) {
2529       *message = entry-&gt;message();
2530       return entry-&gt;error();
2531     } else {
2532       return NULL;
2533     }
2534   }
2535 }
2536 
2537 // Add an entry to resolution error table to record an error in resolving or
2538 // validating a nest host. This is used to construct informative error
2539 // messages when IllegalAccessError&#39;s occur. If an entry already exists it will
2540 // be updated with the nest host error message.
2541 void SystemDictionary::add_nest_host_error(const constantPoolHandle&amp; pool,
2542                                            int which,
2543                                            const char* message) {
2544   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2545   int index = resolution_errors()-&gt;hash_to_index(hash);
2546   {
2547     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2548     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2549     if (entry != NULL) {
2550       assert(entry-&gt;nest_host_error() == NULL, &quot;Nest host error message already set!&quot;);
2551       entry-&gt;set_nest_host_error(message);
2552     } else {
2553       resolution_errors()-&gt;add_entry(index, hash, pool, which, message);
2554     }
2555   }
2556 }
2557 
2558 // Lookup any nest host error
2559 const char* SystemDictionary::find_nest_host_error(const constantPoolHandle&amp; pool, int which) {
2560   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2561   int index = resolution_errors()-&gt;hash_to_index(hash);
2562   {
2563     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2564     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2565     if (entry != NULL) {
2566       return entry-&gt;nest_host_error();
2567     } else {
2568       return NULL;
2569     }
2570   }
2571 }
2572 
2573 
2574 // Signature constraints ensure that callers and callees agree about
2575 // the meaning of type names in their signatures.  This routine is the
2576 // intake for constraints.  It collects them from several places:
2577 //
2578 //  * LinkResolver::resolve_method (if check_access is true) requires
2579 //    that the resolving class (the caller) and the defining class of
2580 //    the resolved method (the callee) agree on each type in the
2581 //    method&#39;s signature.
2582 //
2583 //  * LinkResolver::resolve_interface_method performs exactly the same
2584 //    checks.
2585 //
2586 //  * LinkResolver::resolve_field requires that the constant pool
2587 //    attempting to link to a field agree with the field&#39;s defining
2588 //    class about the type of the field signature.
2589 //
2590 //  * klassVtable::initialize_vtable requires that, when a class
2591 //    overrides a vtable entry allocated by a superclass, that the
2592 //    overriding method (i.e., the callee) agree with the superclass
2593 //    on each type in the method&#39;s signature.
2594 //
2595 //  * klassItable::initialize_itable requires that, when a class fills
2596 //    in its itables, for each non-abstract method installed in an
2597 //    itable, the method (i.e., the callee) agree with the interface
2598 //    on each type in the method&#39;s signature.
2599 //
2600 // All those methods have a boolean (check_access, checkconstraints)
2601 // which turns off the checks.  This is used from specialized contexts
2602 // such as bootstrapping, dumping, and debugging.
2603 //
2604 // No direct constraint is placed between the class and its
2605 // supertypes.  Constraints are only placed along linked relations
2606 // between callers and callees.  When a method overrides or implements
2607 // an abstract method in a supertype (superclass or interface), the
2608 // constraints are placed as if the supertype were the caller to the
2609 // overriding method.  (This works well, since callers to the
2610 // supertype have already established agreement between themselves and
2611 // the supertype.)  As a result of all this, a class can disagree with
2612 // its supertype about the meaning of a type name, as long as that
2613 // class neither calls a relevant method of the supertype, nor is
2614 // called (perhaps via an override) from the supertype.
2615 //
2616 //
2617 // SystemDictionary::check_signature_loaders(sig, klass_being_linked, l1, l2)
2618 //
2619 // Make sure all class components (including arrays) in the given
2620 // signature will be resolved to the same class in both loaders.
2621 // Returns the name of the type that failed a loader constraint check, or
2622 // NULL if no constraint failed.  No exception except OOME is thrown.
2623 // Arrays are not added to the loader constraint table, their elements are.
2624 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
2625                                                Klass* klass_being_linked,
2626                                                Handle loader1, Handle loader2,
2627                                                bool is_method, TRAPS)  {
2628   // Nothing to do if loaders are the same.
2629   if (loader1() == loader2()) {
2630     return NULL;
2631   }
2632 
2633   for (SignatureStream ss(signature, is_method); !ss.is_done(); ss.next()) {
2634     if (ss.is_reference()) {
2635       Symbol* sig = ss.as_symbol();
2636       // Note: In the future, if template-like types can take
2637       // arguments, we will want to recognize them and dig out class
2638       // names hiding inside the argument lists.
2639       if (!add_loader_constraint(sig, klass_being_linked, loader1, loader2, THREAD)) {
2640         return sig;
2641       }
2642     }
2643   }
2644   return NULL;
2645 }
2646 
2647 Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,
2648                                                        Symbol* signature,
2649                                                        TRAPS) {
2650   methodHandle empty;
2651   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2652          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2653          iid != vmIntrinsics::_invokeGeneric,
2654          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2655 
2656   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2657   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2658   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2659   methodHandle m;
2660   if (spe == NULL || spe-&gt;method() == NULL) {
2661     spe = NULL;
2662     // Must create lots of stuff here, but outside of the SystemDictionary lock.
2663     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);
2664     if (!Arguments::is_interpreter_only()) {
2665       // Generate a compiled form of the MH intrinsic.
2666       AdapterHandlerLibrary::create_native_wrapper(m);
2667       // Check if have the compiled code.
2668       if (!m-&gt;has_compiled_code()) {
2669         THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),
2670                        &quot;Out of space in CodeCache for method handle intrinsic&quot;);
2671       }
2672     }
2673     // Now grab the lock.  We might have to throw away the new method,
2674     // if a racing thread has managed to install one at the same time.
2675     {
2676       MutexLocker ml(THREAD, SystemDictionary_lock);
2677       spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2678       if (spe == NULL)
2679         spe = invoke_method_table()-&gt;add_entry(index, hash, signature, iid);
2680       if (spe-&gt;method() == NULL)
2681         spe-&gt;set_method(m());
2682     }
2683   }
2684 
2685   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2686   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2687          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2688          &quot;MH intrinsic invariant&quot;);
2689   return spe-&gt;method();
2690 }
2691 
2692 // Helper for unpacking the return value from linkMethod and linkCallSite.
2693 static Method* unpack_method_and_appendix(Handle mname,
2694                                           Klass* accessing_klass,
2695                                           objArrayHandle appendix_box,
2696                                           Handle* appendix_result,
2697                                           TRAPS) {
2698   if (mname.not_null()) {
2699     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2700     if (m != NULL) {
2701       oop appendix = appendix_box-&gt;obj_at(0);
2702       LogTarget(Info, methodhandles) lt;
2703       if (lt.develop_is_enabled()) {
2704         ResourceMark rm(THREAD);
2705         LogStream ls(lt);
2706         ls.print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));
2707         m-&gt;print_on(&amp;ls);
2708         if (appendix != NULL) { ls.print(&quot;appendix = &quot;); appendix-&gt;print_on(&amp;ls); }
2709         ls.cr();
2710       }
2711 
2712       (*appendix_result) = Handle(THREAD, appendix);
2713       // the target is stored in the cpCache and if a reference to this
2714       // MemberName is dropped we need a way to make sure the
2715       // class_loader containing this method is kept alive.
2716       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2717       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2718       this_key-&gt;record_dependency(m-&gt;method_holder());
2719       return mh();
2720     }
2721   }
2722   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2723 }
2724 
2725 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2726                                                      Symbol* name,
2727                                                      Symbol* signature,
2728                                                           Klass* accessing_klass,
2729                                                           Handle *appendix_result,
2730                                                           TRAPS) {
2731   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
2732   Handle method_type =
2733     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_NULL);
2734 
2735   int ref_kind = JVM_REF_invokeVirtual;
2736   oop name_oop = StringTable::intern(name, CHECK_NULL);
2737   Handle name_str (THREAD, name_oop);
2738   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_NULL);
2739   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2740 
2741   // This should not happen.  JDK code should take care of that.
2742   if (accessing_klass == NULL || method_type.is_null()) {
2743     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;);
2744   }
2745 
2746   // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
2747   JavaCallArguments args;
2748   args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
2749   args.push_int(ref_kind);
2750   args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
2751   args.push_oop(name_str);
2752   args.push_oop(method_type);
2753   args.push_oop(appendix_box);
2754   JavaValue result(T_OBJECT);
2755   JavaCalls::call_static(&amp;result,
2756                          SystemDictionary::MethodHandleNatives_klass(),
2757                          vmSymbols::linkMethod_name(),
2758                          vmSymbols::linkMethod_signature(),
2759                          &amp;args, CHECK_NULL);
2760   Handle mname(THREAD, (oop) result.get_jobject());
2761   return unpack_method_and_appendix(mname, accessing_klass, appendix_box, appendix_result, THREAD);
2762 }
2763 
2764 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2765 // We must ensure that all class loaders everywhere will reach this class, for any client.
2766 // This is a safe bet for public classes in java.lang, such as Object and String.
2767 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2768 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2769 static bool is_always_visible_class(oop mirror) {
2770   Klass* klass = java_lang_Class::as_Klass(mirror);
2771   if (klass-&gt;is_objArray_klass()) {
2772     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2773   }
2774   if (klass-&gt;is_typeArray_klass()) {
2775     return true; // primitive array
2776   }
2777   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2778   return klass-&gt;is_public() &amp;&amp;
2779          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2780           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2781 }
2782 
2783 // Find or construct the Java mirror (java.lang.Class instance) for
2784 // the given field type signature, as interpreted relative to the
2785 // given class loader.  Handles primitives, void, references, arrays,
2786 // and all other reflectable types, except method types.
2787 // N.B.  Code in reflection should use this entry point.
2788 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2789                                                    Klass* accessing_klass,
2790                                                    Handle class_loader,
2791                                                    Handle protection_domain,
2792                                                    SignatureStream::FailureMode failure_mode,
2793                                                    TRAPS) {
2794   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2795          &quot;one or the other, or perhaps neither&quot;);
2796 
2797   // What we have here must be a valid field descriptor,
2798   // and all valid field descriptors are supported.
2799   // Produce the same java.lang.Class that reflection reports.
2800   if (accessing_klass != NULL) {
2801     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2802     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2803   }
2804   ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);
2805   oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);
2806   if (mirror_oop == NULL) {
2807     return Handle();  // report failure this way
2808   }
2809   Handle mirror(THREAD, mirror_oop);
2810 
2811   if (accessing_klass != NULL) {
2812     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2813     Klass* sel_klass = java_lang_Class::as_Klass(mirror());
2814     if (sel_klass != NULL) {
2815       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_NH);
2816     }
2817   }
2818   return mirror;
2819 }
2820 
2821 
2822 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2823 // signature, as interpreted relative to the given class loader.
2824 // Because of class loader constraints, all method handle usage must be
2825 // consistent with this loader.
2826 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2827                                                  Klass* accessing_klass,
2828                                                  TRAPS) {
2829   Handle empty;
2830   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2831   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2832   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2833   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2834   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2835     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
2836     return Handle(THREAD, spe-&gt;method_type());
2837   } else if (!THREAD-&gt;can_call_java()) {
2838     warning(&quot;SystemDictionary::find_method_handle_type called from compiler thread&quot;);  // FIXME
2839     return Handle();  // do not attempt from within compiler, unless it was cached
2840   }
2841 
2842   Handle class_loader, protection_domain;
2843   if (accessing_klass != NULL) {
2844     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2845     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2846   }
2847   bool can_be_cached = true;
2848   int npts = ArgumentCount(signature).size();
2849   objArrayHandle pts = oopFactory::new_objArray_handle(SystemDictionary::Class_klass(), npts, CHECK_(empty));
2850   int arg = 0;
2851   Handle rt; // the return type from the signature
2852   ResourceMark rm(THREAD);
2853   for (SignatureStream ss(signature); !ss.is_done(); ss.next()) {
2854     oop mirror = NULL;
2855     if (can_be_cached) {
2856       // Use neutral class loader to lookup candidate classes to be placed in the cache.
2857       mirror = ss.as_java_mirror(Handle(), Handle(),
2858                                  SignatureStream::ReturnNull, CHECK_(empty));
2859       if (mirror == NULL || (ss.is_reference() &amp;&amp; !is_always_visible_class(mirror))) {
2860         // Fall back to accessing_klass context.
2861         can_be_cached = false;
2862       }
2863     }
2864     if (!can_be_cached) {
2865       // Resolve, throwing a real error if it doesn&#39;t work.
2866       mirror = ss.as_java_mirror(class_loader, protection_domain,
2867                                  SignatureStream::NCDFError, CHECK_(empty));
2868     }
2869     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2870     if (ss.at_return_type())
2871       rt = Handle(THREAD, mirror);
2872     else
2873       pts-&gt;obj_at_put(arg++, mirror);
2874 
2875     // Check accessibility.
2876     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2877       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2878       mirror = NULL;  // safety
2879       // Emulate ConstantPool::verify_constant_pool_resolve.
2880       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_(empty));
2881     }
2882   }
2883   assert(arg == npts, &quot;&quot;);
2884 
2885   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2886   JavaCallArguments args(Handle(THREAD, rt()));
2887   args.push_oop(pts);
2888   JavaValue result(T_OBJECT);
2889   JavaCalls::call_static(&amp;result,
2890                          SystemDictionary::MethodHandleNatives_klass(),
2891                          vmSymbols::findMethodHandleType_name(),
2892                          vmSymbols::findMethodHandleType_signature(),
2893                          &amp;args, CHECK_(empty));
2894   Handle method_type(THREAD, (oop) result.get_jobject());
2895 
2896   if (can_be_cached) {
2897     // We can cache this MethodType inside the JVM.
2898     MutexLocker ml(THREAD, SystemDictionary_lock);
2899     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2900     if (spe == NULL)
2901       spe = invoke_method_table()-&gt;add_entry(index, hash, signature, null_iid);
2902     if (spe-&gt;method_type() == NULL) {
2903       spe-&gt;set_method_type(method_type());
2904     }
2905   }
2906 
2907   // report back to the caller with the MethodType
2908   return method_type;
2909 }
2910 
2911 Handle SystemDictionary::find_field_handle_type(Symbol* signature,
2912                                                 Klass* accessing_klass,
2913                                                 TRAPS) {
2914   Handle empty;
2915   ResourceMark rm(THREAD);
2916   SignatureStream ss(signature, /*is_method=*/ false);
2917   if (!ss.is_done()) {
2918     Handle class_loader, protection_domain;
2919     if (accessing_klass != NULL) {
2920       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2921       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2922     }
2923     oop mirror = ss.as_java_mirror(class_loader, protection_domain, SignatureStream::NCDFError, CHECK_(empty));
2924     ss.next();
2925     if (ss.is_done()) {
2926       return Handle(THREAD, mirror);
2927     }
2928   }
2929   return empty;
2930 }
2931 
2932 // Ask Java code to find or construct a method handle constant.
2933 Handle SystemDictionary::link_method_handle_constant(Klass* caller,
2934                                                      int ref_kind, //e.g., JVM_REF_invokeVirtual
2935                                                      Klass* callee,
2936                                                      Symbol* name,
2937                                                      Symbol* signature,
2938                                                      TRAPS) {
2939   Handle empty;
2940   if (caller == NULL) {
2941     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad MH constant&quot;, empty);
2942   }
2943   Handle name_str      = java_lang_String::create_from_symbol(name,      CHECK_(empty));
2944   Handle signature_str = java_lang_String::create_from_symbol(signature, CHECK_(empty));
2945 
2946   // Put symbolic info from the MH constant into freshly created MemberName and resolve it.
2947   Handle mname = MemberName_klass()-&gt;allocate_instance_handle(CHECK_(empty));
2948   java_lang_invoke_MemberName::set_clazz(mname(), callee-&gt;java_mirror());
2949   java_lang_invoke_MemberName::set_name (mname(), name_str());
2950   java_lang_invoke_MemberName::set_type (mname(), signature_str());
2951   java_lang_invoke_MemberName::set_flags(mname(), MethodHandles::ref_kind_to_flags(ref_kind));
2952 
2953   if (ref_kind == JVM_REF_invokeVirtual &amp;&amp;
2954       MethodHandles::is_signature_polymorphic_public_name(callee, name)) {
2955     // Skip resolution for public signature polymorphic methods such as
2956     // j.l.i.MethodHandle.invoke()/invokeExact() and those on VarHandle
2957     // They require appendix argument which MemberName resolution doesn&#39;t handle.
2958     // There&#39;s special logic on JDK side to handle them
2959     // (see MethodHandles.linkMethodHandleConstant() and MethodHandles.findVirtualForMH()).
2960   } else {
2961     MethodHandles::resolve_MemberName(mname, caller, /*speculative_resolve*/false, CHECK_(empty));
2962   }
2963 
2964   // After method/field resolution succeeded, it&#39;s safe to resolve MH signature as well.
2965   Handle type = MethodHandles::resolve_MemberName_type(mname, caller, CHECK_(empty));
2966 
2967   // call java.lang.invoke.MethodHandleNatives::linkMethodHandleConstant(Class caller, int refKind, Class callee, String name, Object type) -&gt; MethodHandle
2968   JavaCallArguments args;
2969   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));  // the referring class
2970   args.push_int(ref_kind);
2971   args.push_oop(Handle(THREAD, callee-&gt;java_mirror()));  // the target class
2972   args.push_oop(name_str);
2973   args.push_oop(type);
2974   JavaValue result(T_OBJECT);
2975   JavaCalls::call_static(&amp;result,
2976                          SystemDictionary::MethodHandleNatives_klass(),
2977                          vmSymbols::linkMethodHandleConstant_name(),
2978                          vmSymbols::linkMethodHandleConstant_signature(),
2979                          &amp;args, CHECK_(empty));
2980   return Handle(THREAD, (oop) result.get_jobject());
2981 }
2982 
2983 // Ask Java to run a bootstrap method, in order to create a dynamic call site
2984 // while linking an invokedynamic op, or compute a constant for Dynamic_info CP entry
2985 // with linkage results being stored back into the bootstrap specifier.
2986 void SystemDictionary::invoke_bootstrap_method(BootstrapInfo&amp; bootstrap_specifier, TRAPS) {
2987   // Resolve the bootstrap specifier, its name, type, and static arguments
2988   bootstrap_specifier.resolve_bsm(CHECK);
2989 
2990   // This should not happen.  JDK code should take care of that.
2991   if (bootstrap_specifier.caller() == NULL || bootstrap_specifier.type_arg().is_null()) {
2992     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;Invalid bootstrap method invocation with no caller or type argument&quot;);
2993   }
2994 
2995   bool is_indy = bootstrap_specifier.is_method_call();
2996   objArrayHandle appendix_box;
2997   if (is_indy) {
2998     // Some method calls may require an appendix argument.  Arrange to receive it.
2999     appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK);
3000     assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
3001   }
3002 
3003   // call condy: java.lang.invoke.MethodHandleNatives::linkDynamicConstant(caller, condy_index, bsm, type, info)
3004   //       indy: java.lang.invoke.MethodHandleNatives::linkCallSite(caller, indy_index, bsm, name, mtype, info, &amp;appendix)
3005   JavaCallArguments args;
3006   args.push_oop(Handle(THREAD, bootstrap_specifier.caller_mirror()));
3007   args.push_int(bootstrap_specifier.bss_index());
3008   args.push_oop(bootstrap_specifier.bsm());
3009   args.push_oop(bootstrap_specifier.name_arg());
3010   args.push_oop(bootstrap_specifier.type_arg());
3011   args.push_oop(bootstrap_specifier.arg_values());
3012   if (is_indy) {
3013     args.push_oop(appendix_box);
3014   }
3015   JavaValue result(T_OBJECT);
3016   JavaCalls::call_static(&amp;result,
3017                          SystemDictionary::MethodHandleNatives_klass(),
3018                          is_indy ? vmSymbols::linkCallSite_name() : vmSymbols::linkDynamicConstant_name(),
3019                          is_indy ? vmSymbols::linkCallSite_signature() : vmSymbols::linkDynamicConstant_signature(),
3020                          &amp;args, CHECK);
3021 
3022   Handle value(THREAD, (oop) result.get_jobject());
3023   if (is_indy) {
3024     Handle appendix;
3025     Method* method = unpack_method_and_appendix(value,
3026                                                 bootstrap_specifier.caller(),
3027                                                 appendix_box,
3028                                                 &amp;appendix, CHECK);
3029     methodHandle mh(THREAD, method);
3030     bootstrap_specifier.set_resolved_method(mh, appendix);
3031   } else {
3032     bootstrap_specifier.set_resolved_value(value);
3033   }
3034 
3035   // sanity check
3036   assert(bootstrap_specifier.is_resolved() ||
3037          (bootstrap_specifier.is_method_call() &amp;&amp;
3038           bootstrap_specifier.resolved_method().not_null()), &quot;bootstrap method call failed&quot;);
3039 }
3040 
3041 // Protection domain cache table handling
3042 
3043 ProtectionDomainCacheEntry* SystemDictionary::cache_get(Handle protection_domain) {
3044   return _pd_cache_table-&gt;get(protection_domain);
3045 }
3046 
3047 // ----------------------------------------------------------------------------
3048 
3049 void SystemDictionary::print_on(outputStream *st) {
3050   CDS_ONLY(SystemDictionaryShared::print_on(st));
3051   GCMutexLocker mu(SystemDictionary_lock);
3052 
3053   ClassLoaderDataGraph::print_dictionary(st);
3054 
3055   // Placeholders
3056   placeholders()-&gt;print_on(st);
3057   st-&gt;cr();
3058 
3059   // loader constraints - print under SD_lock
3060   constraints()-&gt;print_on(st);
3061   st-&gt;cr();
3062 
3063   _pd_cache_table-&gt;print_on(st);
3064   st-&gt;cr();
3065 }
3066 
3067 void SystemDictionary::print() { print_on(tty); }
3068 
3069 void SystemDictionary::verify() {
3070   guarantee(constraints() != NULL,
3071             &quot;Verify of loader constraints failed&quot;);
3072   guarantee(placeholders()-&gt;number_of_entries() &gt;= 0,
3073             &quot;Verify of placeholders failed&quot;);
3074 
3075   GCMutexLocker mu(SystemDictionary_lock);
3076 
3077   // Verify dictionary
3078   ClassLoaderDataGraph::verify_dictionary();
3079 
3080   placeholders()-&gt;verify();
3081 
3082   // Verify constraint table
3083   guarantee(constraints() != NULL, &quot;Verify of loader constraints failed&quot;);
3084   constraints()-&gt;verify(placeholders());
3085 
3086   _pd_cache_table-&gt;verify();
3087 }
3088 
3089 void SystemDictionary::dump(outputStream *st, bool verbose) {
3090   assert_locked_or_safepoint(SystemDictionary_lock);
3091   if (verbose) {
3092     print_on(st);
3093   } else {
3094     CDS_ONLY(SystemDictionaryShared::print_table_statistics(st));
3095     ClassLoaderDataGraph::print_table_statistics(st);
3096     placeholders()-&gt;print_table_statistics(st, &quot;Placeholder Table&quot;);
3097     constraints()-&gt;print_table_statistics(st, &quot;LoaderConstraints Table&quot;);
3098     pd_cache_table()-&gt;print_table_statistics(st, &quot;ProtectionDomainCache Table&quot;);
3099   }
3100 }
3101 
3102 TableStatistics SystemDictionary::placeholders_statistics() {
3103   MutexLocker ml(SystemDictionary_lock);
3104   return placeholders()-&gt;statistics_calculate();
3105 }
3106 
3107 TableStatistics SystemDictionary::loader_constraints_statistics() {
3108   MutexLocker ml(SystemDictionary_lock);
3109   return constraints()-&gt;statistics_calculate();
3110 }
3111 
3112 TableStatistics SystemDictionary::protection_domain_cache_statistics() {
3113   MutexLocker ml(SystemDictionary_lock);
3114   return pd_cache_table()-&gt;statistics_calculate();
3115 }
3116 
3117 // Utility for dumping dictionaries.
3118 SystemDictionaryDCmd::SystemDictionaryDCmd(outputStream* output, bool heap) :
3119                                  DCmdWithParser(output, heap),
3120   _verbose(&quot;-verbose&quot;, &quot;Dump the content of each dictionary entry for all class loaders&quot;,
3121            &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
3122   _dcmdparser.add_dcmd_option(&amp;_verbose);
3123 }
3124 
3125 void SystemDictionaryDCmd::execute(DCmdSource source, TRAPS) {
3126   VM_DumpHashtable dumper(output(), VM_DumpHashtable::DumpSysDict,
3127                          _verbose.value());
3128   VMThread::execute(&amp;dumper);
3129 }
3130 
3131 int SystemDictionaryDCmd::num_arguments() {
3132   ResourceMark rm;
3133   SystemDictionaryDCmd* dcmd = new SystemDictionaryDCmd(NULL, false);
3134   if (dcmd != NULL) {
3135     DCmdMark mark(dcmd);
3136     return dcmd-&gt;_dcmdparser.num_arguments();
3137   } else {
3138     return 0;
3139   }
3140 }
    </pre>
  </body>
</html>