<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/javaClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CLASSFILE_JAVACLASSES_HPP
  26 #define SHARE_CLASSFILE_JAVACLASSES_HPP
  27 
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmti.h&quot;
  30 #include &quot;oops/oop.hpp&quot;
  31 #include &quot;runtime/os.hpp&quot;
  32 
  33 class RecordComponent;
  34 
  35 // Interface for manipulating the basic Java classes.
  36 
  37 #define BASIC_JAVA_CLASSES_DO_PART1(f) \
  38   f(java_lang_Class) \
  39   f(java_lang_String) \
  40   f(java_lang_ref_Reference) \
  41   //end
  42 
  43 #define BASIC_JAVA_CLASSES_DO_PART2(f) \
  44   f(java_lang_System) \
  45   f(java_lang_ClassLoader) \
  46   f(java_lang_Throwable) \
  47   f(java_lang_Thread) \
  48   f(java_lang_ThreadGroup) \
  49   f(java_lang_AssertionStatusDirectives) \
  50   f(java_lang_ref_SoftReference) \
  51   f(java_lang_invoke_MethodHandle) \
  52   f(java_lang_invoke_DirectMethodHandle) \
  53   f(java_lang_invoke_MemberName) \
  54   f(java_lang_invoke_ResolvedMethodName) \
  55   f(java_lang_invoke_LambdaForm) \
  56   f(java_lang_invoke_MethodType) \
  57   f(java_lang_invoke_CallSite) \
  58   f(java_lang_invoke_ConstantCallSite) \
  59   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  60   f(java_security_AccessControlContext) \
  61   f(java_lang_reflect_AccessibleObject) \
  62   f(java_lang_reflect_Method) \
  63   f(java_lang_reflect_Constructor) \
  64   f(java_lang_reflect_Field) \
  65   f(java_lang_reflect_RecordComponent) \
  66   f(java_nio_Buffer) \
  67   f(reflect_ConstantPool) \
  68   f(reflect_UnsafeStaticFieldAccessorImpl) \
  69   f(java_lang_reflect_Parameter) \
  70   f(java_lang_Module) \
  71   f(java_lang_StackTraceElement) \
  72   f(java_lang_StackFrameInfo) \
  73   f(java_lang_LiveStackFrameInfo) \
  74   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  75   f(jdk_internal_misc_UnsafeConstants) \
  76   f(java_lang_boxing_object) \
  77   //end
  78 
  79 #define BASIC_JAVA_CLASSES_DO(f) \
  80         BASIC_JAVA_CLASSES_DO_PART1(f) \
  81         BASIC_JAVA_CLASSES_DO_PART2(f)
  82 
  83 #define CHECK_INIT(offset)  assert(offset != 0, &quot;should be initialized&quot;); return offset;
  84 
  85 // Interface to java.lang.Object objects
  86 
  87 class java_lang_Object : AllStatic {
  88  public:
  89   static void register_natives(TRAPS);
  90 };
  91 
  92 // Interface to java.lang.String objects
  93 
  94 class java_lang_String : AllStatic {
  95  private:
  96   static int _value_offset;
  97   static int _hash_offset;
  98   static int _hashIsZero_offset;
  99   static int _coder_offset;
 100 
 101   static bool _initialized;
 102 
 103   static Handle basic_create(int length, bool byte_arr, TRAPS);
 104 
 105   static inline void set_coder(oop string, jbyte coder);
 106 
 107  public:
 108 
 109   // Coders
 110   enum Coder {
 111     CODER_LATIN1 =  0,
 112     CODER_UTF16  =  1
 113   };
 114 
 115   static void compute_offsets();
 116   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 117 
 118   // Instance creation
 119   static Handle create_from_unicode(const jchar* unicode, int len, TRAPS);
 120   static oop    create_oop_from_unicode(const jchar* unicode, int len, TRAPS);
 121   static Handle create_from_str(const char* utf8_str, TRAPS);
 122   static oop    create_oop_from_str(const char* utf8_str, TRAPS);
 123   static Handle create_from_symbol(Symbol* symbol, TRAPS);
 124   static Handle create_from_platform_dependent_str(const char* str, TRAPS);
 125   static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);
 126 
 127   static void set_compact_strings(bool value);
 128 
 129   static int value_offset() { CHECK_INIT(_value_offset); }
 130   static int coder_offset() { CHECK_INIT(_coder_offset); }
 131 
 132   static inline void set_value_raw(oop string, typeArrayOop buffer);
 133   static inline void set_value(oop string, typeArrayOop buffer);
 134 
 135   // Accessors
 136   static inline typeArrayOop value(oop java_string);
 137   static inline typeArrayOop value_no_keepalive(oop java_string);
 138   static inline bool hash_is_set(oop string);
 139   static inline bool is_latin1(oop java_string);
 140   static inline int length(oop java_string);
 141   static inline int length(oop java_string, typeArrayOop string_value);
 142   static int utf8_length(oop java_string);
 143   static int utf8_length(oop java_string, typeArrayOop string_value);
 144 
 145   // String converters
 146   static char*  as_utf8_string(oop java_string);
 147   static char*  as_utf8_string(oop java_string, int&amp; length);
 148   static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; length);
 149   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
 150   static char*  as_utf8_string(oop java_string, int start, int len);
 151   static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);
 152   static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);
 153   static char*  as_platform_dependent_str(Handle java_string, TRAPS);
 154   static jchar* as_unicode_string(oop java_string, int&amp; length, TRAPS);
 155   // produce an ascii string with all other values quoted using \u####
 156   static char*  as_quoted_ascii(oop java_string);
 157 
 158   // Compute the hash value for a java.lang.String object which would
 159   // contain the characters passed in.
 160   //
 161   // As the hash value used by the String object itself, in
 162   // String.hashCode().  This value is normally calculated in Java code
 163   // in the String.hashCode method(), but is precomputed for String
 164   // objects in the shared archive file.
 165   // hash P(31) from Kernighan &amp; Ritchie
 166   //
 167   // For this reason, THIS ALGORITHM MUST MATCH String.hashCode().
 168   static unsigned int hash_code(const jchar* s, int len) {
 169     unsigned int h = 0;
 170     while (len-- &gt; 0) {
 171       h = 31*h + (unsigned int) *s;
 172       s++;
 173     }
 174     return h;
 175   }
 176 
 177   static unsigned int hash_code(const jbyte* s, int len) {
 178     unsigned int h = 0;
 179     while (len-- &gt; 0) {
 180       h = 31*h + (((unsigned int) *s) &amp; 0xFF);
 181       s++;
 182     }
 183     return h;
 184   }
 185 
 186   static unsigned int hash_code(oop java_string);
 187 
 188   static bool equals(oop java_string, const jchar* chars, int len);
 189   static bool equals(oop str1, oop str2);
 190   static inline bool value_equals(typeArrayOop str_value1, typeArrayOop str_value2);
 191 
 192   // Conversion between &#39;.&#39; and &#39;/&#39; formats
 193   static Handle externalize_classname(Handle java_string, TRAPS) {
 194     return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);
 195   }
 196 
 197   // Conversion
 198   static Symbol* as_symbol(oop java_string);
 199   static Symbol* as_symbol_or_null(oop java_string);
 200 
 201   // Testers
 202   static bool is_instance(oop obj);
 203   static inline bool is_instance_inlined(oop obj);
 204 
 205   // Debugging
 206   static void print(oop java_string, outputStream* st);
 207   friend class JavaClasses;
 208   friend class StringTable;
 209 };
 210 
 211 
 212 // Interface to java.lang.Class objects
 213 
 214 #define CLASS_INJECTED_FIELDS(macro)                                       \
 215   macro(java_lang_Class, klass,                  intptr_signature,  false) \
 216   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
 217   macro(java_lang_Class, oop_size,               int_signature,     false) \
 218   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
 219   macro(java_lang_Class, protection_domain,      object_signature,  false) \
 220   macro(java_lang_Class, signers,                object_signature,  false) \
 221   macro(java_lang_Class, source_file,            object_signature,  false) \
 222 
 223 class java_lang_Class : AllStatic {
 224   friend class VMStructs;
 225   friend class JVMCIVMStructs;
 226 
 227  private:
 228 
 229   // The fake offsets are added by the class loader when java.lang.Class is loaded
 230 
 231   static int _klass_offset;
 232   static int _array_klass_offset;
 233 
 234   static int _oop_size_offset;
 235   static int _static_oop_field_count_offset;
 236 
 237   static int _protection_domain_offset;
 238   static int _init_lock_offset;
 239   static int _signers_offset;
 240   static int _class_loader_offset;
 241   static int _module_offset;
 242   static int _component_mirror_offset;
 243   static int _name_offset;
 244   static int _source_file_offset;
 245   static int _classData_offset;
 246   static int _classRedefinedCount_offset;
 247 
 248   static bool _offsets_computed;
 249 
 250   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 251   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 252 
 253   static void set_init_lock(oop java_class, oop init_lock);
 254   static void set_protection_domain(oop java_class, oop protection_domain);
 255   static void set_class_loader(oop java_class, oop class_loader);
 256   static void set_component_mirror(oop java_class, oop comp_mirror);
 257   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,
 258                                        Handle classData, TRAPS);
 259   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 260  public:
 261   static void allocate_fixup_lists();
 262   static void compute_offsets();
 263 
 264   // Instance creation
 265   static void create_mirror(Klass* k, Handle class_loader, Handle module,
 266                             Handle protection_domain, Handle classData, TRAPS);
 267   static void fixup_mirror(Klass* k, TRAPS);
 268   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
 269   static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 270   static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 271 
 272   // Archiving
 273   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 274   static void archive_basic_type_mirrors(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 275   static oop  archive_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 276   static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror, Thread *THREAD)
 277                                       NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 278   static bool restore_archived_mirror(Klass *k, Handle class_loader, Handle module,
 279                                       Handle protection_domain,
 280                                       TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);
 281 
 282   static void fixup_module_field(Klass* k, Handle module);
 283 
 284   // Conversion
 285   static Klass* as_Klass(oop java_class);
 286   static Klass* as_Klass_raw(oop java_class);
 287   static void set_klass(oop java_class, Klass* klass);
 288   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
 289   static Symbol* as_signature(oop java_class, bool intern_if_not_found);
 290   static void print_signature(oop java_class, outputStream *st);
 291   static const char* as_external_name(oop java_class);
 292   // Testing
 293   static bool is_instance(oop obj);
 294 
 295   static bool is_primitive(oop java_class);
 296   static BasicType primitive_type(oop java_class);
 297   static oop primitive_mirror(BasicType t);
 298   // JVM_NewArray support
 299   static Klass* array_klass_acquire(oop java_class);
 300   static void release_set_array_klass(oop java_class, Klass* klass);
 301   // compiler support for class operations
 302   static int klass_offset()                { CHECK_INIT(_klass_offset); }
 303   static int array_klass_offset()          { CHECK_INIT(_array_klass_offset); }
 304   // Support for classRedefinedCount field
 305   static int classRedefinedCount(oop the_class_mirror);
 306   static void set_classRedefinedCount(oop the_class_mirror, int value);
 307 
 308   // Support for embedded per-class oops
 309   static oop  protection_domain(oop java_class);
 310   static oop  init_lock(oop java_class);
 311   static void clear_init_lock(oop java_class) {
 312     set_init_lock(java_class, NULL);
 313   }
 314   static oop  component_mirror(oop java_class);
 315   static objArrayOop  signers(oop java_class);
 316   static void set_signers(oop java_class, objArrayOop signers);
 317   static oop  class_data(oop java_class);
 318   static void set_class_data(oop java_class, oop classData);
 319 
 320   static oop class_loader(oop java_class);
 321   static void set_module(oop java_class, oop module);
 322   static oop module(oop java_class);
 323 
 324   static oop name(Handle java_class, TRAPS);
 325 
 326   static oop source_file(oop java_class);
 327   static void set_source_file(oop java_class, oop source_file);
 328 
 329   static int oop_size(oop java_class);
 330   static int oop_size_raw(oop java_class);
 331   static void set_oop_size(HeapWord* java_class, int size);
 332   static int static_oop_field_count(oop java_class);
 333   static int static_oop_field_count_raw(oop java_class);
 334   static void set_static_oop_field_count(oop java_class, int size);
 335 
 336   static GrowableArray&lt;Klass*&gt;* fixup_mirror_list() {
 337     return _fixup_mirror_list;
 338   }
 339   static void set_fixup_mirror_list(GrowableArray&lt;Klass*&gt;* v) {
 340     _fixup_mirror_list = v;
 341   }
 342 
 343   static GrowableArray&lt;Klass*&gt;* fixup_module_field_list() {
 344     return _fixup_module_field_list;
 345   }
 346   static void set_fixup_module_field_list(GrowableArray&lt;Klass*&gt;* v) {
 347     _fixup_module_field_list = v;
 348   }
 349 
 350   // Debugging
 351   friend class JavaClasses;
 352 };
 353 
 354 // Interface to java.lang.Thread objects
 355 
 356 class java_lang_Thread : AllStatic {
 357  private:
 358   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
 359   // so we compute the offsets at startup rather than hard-wiring them.
 360   static int _name_offset;
 361   static int _group_offset;
 362   static int _contextClassLoader_offset;
 363   static int _inheritedAccessControlContext_offset;
 364   static int _priority_offset;
 365   static int _eetop_offset;
 366   static int _interrupted_offset;
 367   static int _daemon_offset;
 368   static int _stillborn_offset;
 369   static int _stackSize_offset;
 370   static int _tid_offset;
 371   static int _thread_status_offset;
 372   static int _park_blocker_offset;
 373 
 374   static void compute_offsets();
 375 
 376  public:
 377   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 378 
 379   // Instance creation
 380   static oop create();
 381   // Returns the JavaThread associated with the thread obj
 382   static JavaThread* thread(oop java_thread);
 383   // Set JavaThread for instance
 384   static void set_thread(oop java_thread, JavaThread* thread);
 385   // Interrupted status
 386   static bool interrupted(oop java_thread);
 387   static void set_interrupted(oop java_thread, bool val);
 388   // Name
 389   static oop name(oop java_thread);
 390   static void set_name(oop java_thread, oop name);
 391   // Priority
 392   static ThreadPriority priority(oop java_thread);
 393   static void set_priority(oop java_thread, ThreadPriority priority);
 394   // Thread group
 395   static oop  threadGroup(oop java_thread);
 396   // Stillborn
 397   static bool is_stillborn(oop java_thread);
 398   static void set_stillborn(oop java_thread);
 399   // Alive (NOTE: this is not really a field, but provides the correct
 400   // definition without doing a Java call)
 401   static bool is_alive(oop java_thread);
 402   // Daemon
 403   static bool is_daemon(oop java_thread);
 404   static void set_daemon(oop java_thread);
 405   // Context ClassLoader
 406   static oop context_class_loader(oop java_thread);
 407   // Control context
 408   static oop inherited_access_control_context(oop java_thread);
 409   // Stack size hint
 410   static jlong stackSize(oop java_thread);
 411   // Thread ID
 412   static jlong thread_id(oop java_thread);
 413 
 414   // Blocker object responsible for thread parking
 415   static oop park_blocker(oop java_thread);
 416 
 417   // Java Thread Status for JVMTI and M&amp;M use.
 418   // This thread status info is saved in threadStatus field of
 419   // java.lang.Thread java class.
 420   enum ThreadStatus {
 421     NEW                      = 0,
 422     RUNNABLE                 = JVMTI_THREAD_STATE_ALIVE +          // runnable / running
 423                                JVMTI_THREAD_STATE_RUNNABLE,
 424     SLEEPING                 = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
 425                                JVMTI_THREAD_STATE_WAITING +
 426                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 427                                JVMTI_THREAD_STATE_SLEEPING,
 428     IN_OBJECT_WAIT           = JVMTI_THREAD_STATE_ALIVE +          // Object.wait()
 429                                JVMTI_THREAD_STATE_WAITING +
 430                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 431                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 432     IN_OBJECT_WAIT_TIMED     = JVMTI_THREAD_STATE_ALIVE +          // Object.wait(long)
 433                                JVMTI_THREAD_STATE_WAITING +
 434                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 435                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 436     PARKED                   = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park()
 437                                JVMTI_THREAD_STATE_WAITING +
 438                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 439                                JVMTI_THREAD_STATE_PARKED,
 440     PARKED_TIMED             = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park(long)
 441                                JVMTI_THREAD_STATE_WAITING +
 442                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 443                                JVMTI_THREAD_STATE_PARKED,
 444     BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE +          // (re-)entering a synchronization block
 445                                JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
 446     TERMINATED               = JVMTI_THREAD_STATE_TERMINATED
 447   };
 448   // Write thread status info to threadStatus field of java.lang.Thread.
 449   static void set_thread_status(oop java_thread_oop, ThreadStatus status);
 450   // Read thread status info from threadStatus field of java.lang.Thread.
 451   static ThreadStatus get_thread_status(oop java_thread_oop);
 452 
 453   static const char*  thread_status_name(oop java_thread_oop);
 454 
 455   // Debugging
 456   friend class JavaClasses;
 457 };
 458 
 459 // Interface to java.lang.ThreadGroup objects
 460 
 461 class java_lang_ThreadGroup : AllStatic {
 462  private:
 463   static int _parent_offset;
 464   static int _name_offset;
 465   static int _threads_offset;
 466   static int _groups_offset;
 467   static int _maxPriority_offset;
 468   static int _destroyed_offset;
 469   static int _daemon_offset;
 470   static int _nthreads_offset;
 471   static int _ngroups_offset;
 472 
 473   static void compute_offsets();
 474 
 475  public:
 476   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 477 
 478   // parent ThreadGroup
 479   static oop  parent(oop java_thread_group);
 480   // name
 481   static const char* name(oop java_thread_group);
 482   // (&quot;name as oop&quot; accessor is not necessary)
 483   // Number of threads in group
 484   static int nthreads(oop java_thread_group);
 485   // threads
 486   static objArrayOop threads(oop java_thread_group);
 487   // Number of threads in group
 488   static int ngroups(oop java_thread_group);
 489   // groups
 490   static objArrayOop groups(oop java_thread_group);
 491   // maxPriority in group
 492   static ThreadPriority maxPriority(oop java_thread_group);
 493   // Destroyed
 494   static bool is_destroyed(oop java_thread_group);
 495   // Daemon
 496   static bool is_daemon(oop java_thread_group);
 497   // Debugging
 498   friend class JavaClasses;
 499 };
 500 
 501 
 502 
 503 // Interface to java.lang.Throwable objects
 504 
 505 class java_lang_Throwable: AllStatic {
 506   friend class BacktraceBuilder;
 507   friend class BacktraceIterator;
 508 
 509  private:
 510   // Trace constants
 511   enum {
 512     trace_methods_offset = 0,
 513     trace_bcis_offset    = 1,
 514     trace_mirrors_offset = 2,
 515     trace_names_offset   = 3,
 516     trace_next_offset    = 4,
 517     trace_hidden_offset  = 5,
 518     trace_size           = 6,
 519     trace_chunk_size     = 32
 520   };
 521 
 522   static int _backtrace_offset;
 523   static int _detailMessage_offset;
 524   static int _stackTrace_offset;
 525   static int _depth_offset;
 526   static int _static_unassigned_stacktrace_offset;
 527 
 528   // StackTrace (programmatic access, new since 1.4)
 529   static void clear_stacktrace(oop throwable);
 530   // Stacktrace (post JDK 1.7.0 to allow immutability protocol to be followed)
 531   static void set_stacktrace(oop throwable, oop st_element_array);
 532   static oop unassigned_stacktrace();
 533 
 534  public:
 535   // Backtrace
 536   static oop backtrace(oop throwable);
 537   static void set_backtrace(oop throwable, oop value);
 538   static int depth(oop throwable);
 539   static void set_depth(oop throwable, int value);
 540   static int get_detailMessage_offset() { CHECK_INIT(_detailMessage_offset); }
 541   // Message
 542   static oop message(oop throwable);
 543   static void set_message(oop throwable, oop value);
 544   static Symbol* detail_message(oop throwable);
 545   static void print_stack_element(outputStream *st, Method* method, int bci);
 546   static void print_stack_usage(Handle stream);
 547 
 548   static void compute_offsets();
 549   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 550 
 551   // Allocate space for backtrace (created but stack trace not filled in)
 552   static void allocate_backtrace(Handle throwable, TRAPS);
 553   // Fill in current stack trace for throwable with preallocated backtrace (no GC)
 554   static void fill_in_stack_trace_of_preallocated_backtrace(Handle throwable);
 555   // Fill in current stack trace, can cause GC
 556   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS);
 557   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method = methodHandle());
 558   // Programmatic access to stack trace
 559   static void get_stack_trace_elements(Handle throwable, objArrayHandle stack_trace, TRAPS);
 560   // Printing
 561   static void print(oop throwable, outputStream* st);
 562   static void print_stack_trace(Handle throwable, outputStream* st);
 563   static void java_printStackTrace(Handle throwable, TRAPS);
 564   // Debugging
 565   friend class JavaClasses;
 566   // Gets the method and bci of the top frame (TOS). Returns false if this failed.
 567   static bool get_top_method_and_bci(oop throwable, Method** method, int* bci);
 568 };
 569 
 570 
 571 // Interface to java.lang.reflect.AccessibleObject objects
 572 
 573 class java_lang_reflect_AccessibleObject: AllStatic {
 574  private:
 575   // Note that to reduce dependencies on the JDK we compute these
 576   // offsets at run-time.
 577   static int _override_offset;
 578 
 579   static void compute_offsets();
 580 
 581  public:
 582   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 583 
 584   // Accessors
 585   static jboolean override(oop reflect);
 586   static void set_override(oop reflect, jboolean value);
 587 
 588   // Debugging
 589   friend class JavaClasses;
 590 };
 591 
 592 
 593 // Interface to java.lang.reflect.Method objects
 594 
 595 class java_lang_reflect_Method : public java_lang_reflect_AccessibleObject {
 596  private:
 597   // Note that to reduce dependencies on the JDK we compute these
 598   // offsets at run-time.
 599   static int _clazz_offset;
 600   static int _name_offset;
 601   static int _returnType_offset;
 602   static int _parameterTypes_offset;
 603   static int _exceptionTypes_offset;
 604   static int _slot_offset;
 605   static int _modifiers_offset;
 606   static int _signature_offset;
 607   static int _annotations_offset;
 608   static int _parameter_annotations_offset;
 609   static int _annotation_default_offset;
 610 
 611   static void compute_offsets();
 612  public:
 613   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 614 
 615   // Allocation
 616   static Handle create(TRAPS);
 617 
 618   // Accessors
 619   static oop clazz(oop reflect);
 620   static void set_clazz(oop reflect, oop value);
 621 
 622   static void set_name(oop method, oop value);
 623 
 624   static oop return_type(oop method);
 625   static void set_return_type(oop method, oop value);
 626 
 627   static oop parameter_types(oop method);
 628   static void set_parameter_types(oop method, oop value);
 629 
 630   static int slot(oop reflect);
 631   static void set_slot(oop reflect, int value);
 632 
 633   static void set_exception_types(oop method, oop value);
 634   static void set_modifiers(oop method, int value);
 635   static void set_signature(oop method, oop value);
 636   static void set_annotations(oop method, oop value);
 637   static void set_parameter_annotations(oop method, oop value);
 638   static void set_annotation_default(oop method, oop value);
 639 
 640   // Debugging
 641   friend class JavaClasses;
 642 };
 643 
 644 
 645 // Interface to java.lang.reflect.Constructor objects
 646 
 647 class java_lang_reflect_Constructor : public java_lang_reflect_AccessibleObject {
 648  private:
 649   // Note that to reduce dependencies on the JDK we compute these
 650   // offsets at run-time.
 651   static int _clazz_offset;
 652   static int _parameterTypes_offset;
 653   static int _exceptionTypes_offset;
 654   static int _slot_offset;
 655   static int _modifiers_offset;
 656   static int _signature_offset;
 657   static int _annotations_offset;
 658   static int _parameter_annotations_offset;
 659 
 660   static void compute_offsets();
 661  public:
 662   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 663 
 664   // Allocation
 665   static Handle create(TRAPS);
 666 
 667   // Accessors
 668   static oop clazz(oop reflect);
 669   static void set_clazz(oop reflect, oop value);
 670 
 671   static oop parameter_types(oop constructor);
 672   static void set_parameter_types(oop constructor, oop value);
 673 
 674   static int slot(oop reflect);
 675   static void set_slot(oop reflect, int value);
 676 
 677   static void set_exception_types(oop constructor, oop value);
 678   static void set_modifiers(oop constructor, int value);
 679   static void set_signature(oop constructor, oop value);
 680   static void set_annotations(oop constructor, oop value);
 681   static void set_parameter_annotations(oop method, oop value);
 682 
 683   // Debugging
 684   friend class JavaClasses;
 685 };
 686 
 687 
 688 // Interface to java.lang.reflect.Field objects
 689 
 690 class java_lang_reflect_Field : public java_lang_reflect_AccessibleObject {
 691  private:
 692   // Note that to reduce dependencies on the JDK we compute these
 693   // offsets at run-time.
 694   static int _clazz_offset;
 695   static int _name_offset;
 696   static int _type_offset;
 697   static int _slot_offset;
 698   static int _modifiers_offset;
 699   static int _trusted_final_offset;
 700   static int _signature_offset;
 701   static int _annotations_offset;
 702 
 703   static void compute_offsets();
 704 
 705  public:
 706   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 707 
 708   // Allocation
 709   static Handle create(TRAPS);
 710 
 711   // Accessors
 712   static oop clazz(oop reflect);
 713   static void set_clazz(oop reflect, oop value);
 714 
 715   static oop name(oop field);
 716   static void set_name(oop field, oop value);
 717 
 718   static oop type(oop field);
 719   static void set_type(oop field, oop value);
 720 
 721   static int slot(oop reflect);
 722   static void set_slot(oop reflect, int value);
 723 
 724   static int modifiers(oop field);
 725   static void set_modifiers(oop field, int value);
 726 
 727   static void set_trusted_final(oop field);
 728 
 729   static void set_signature(oop constructor, oop value);
 730   static void set_annotations(oop constructor, oop value);
 731   static void set_parameter_annotations(oop method, oop value);
 732   static void set_annotation_default(oop method, oop value);
 733 
 734   // Debugging
 735   friend class JavaClasses;
 736 };
 737 
 738 class java_lang_reflect_Parameter {
 739  private:
 740   // Note that to reduce dependencies on the JDK we compute these
 741   // offsets at run-time.
 742   static int _name_offset;
 743   static int _modifiers_offset;
 744   static int _index_offset;
 745   static int _executable_offset;
 746 
 747   static void compute_offsets();
 748 
 749  public:
 750   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 751 
 752   // Allocation
 753   static Handle create(TRAPS);
 754 
 755   // Accessors
 756   static oop name(oop field);
 757   static void set_name(oop field, oop value);
 758 
 759   static int index(oop reflect);
 760   static void set_index(oop reflect, int value);
 761 
 762   static int modifiers(oop reflect);
 763   static void set_modifiers(oop reflect, int value);
 764 
 765   static oop executable(oop constructor);
 766   static void set_executable(oop constructor, oop value);
 767 
 768   friend class JavaClasses;
 769 };
 770 
 771 #define MODULE_INJECTED_FIELDS(macro)                            \
 772   macro(java_lang_Module, module_entry, intptr_signature, false)
 773 
 774 class java_lang_Module {
 775   private:
 776     static int _loader_offset;
 777     static int _name_offset;
 778     static int _module_entry_offset;
 779 
 780     static void compute_offsets();
 781 
 782   public:
 783     static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 784 
 785     // Allocation
 786     static Handle create(Handle loader, Handle module_name, TRAPS);
 787 
 788     // Testers
 789     static bool is_instance(oop obj);
 790 
 791     // Accessors
 792     static oop loader(oop module);
 793     static void set_loader(oop module, oop value);
 794 
 795     static oop name(oop module);
 796     static void set_name(oop module, oop value);
 797 
 798     static ModuleEntry* module_entry(oop module);
 799     static void set_module_entry(oop module, ModuleEntry* module_entry);
 800 
 801   friend class JavaClasses;
 802 };
 803 
 804 // Interface to jdk.internal.reflect.ConstantPool objects
 805 class reflect_ConstantPool {
 806  private:
 807   // Note that to reduce dependencies on the JDK we compute these
 808   // offsets at run-time.
 809   static int _oop_offset;
 810 
 811   static void compute_offsets();
 812 
 813  public:
 814   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 815 
 816   // Allocation
 817   static Handle create(TRAPS);
 818 
 819   // Accessors
 820   static void set_cp(oop reflect, ConstantPool* value);
 821   static int oop_offset() { CHECK_INIT(_oop_offset); }
 822 
 823   static ConstantPool* get_cp(oop reflect);
 824 
 825   // Debugging
 826   friend class JavaClasses;
 827 };
 828 
 829 // Interface to jdk.internal.reflect.UnsafeStaticFieldAccessorImpl objects
 830 class reflect_UnsafeStaticFieldAccessorImpl {
 831  private:
 832   static int _base_offset;
 833   static void compute_offsets();
 834 
 835  public:
 836   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 837 
 838   static int base_offset() { CHECK_INIT(_base_offset); }
 839 
 840   // Debugging
 841   friend class JavaClasses;
 842 };
 843 
 844 // Interface to java.lang primitive type boxing objects:
 845 //  - java.lang.Boolean
 846 //  - java.lang.Character
 847 //  - java.lang.Float
 848 //  - java.lang.Double
 849 //  - java.lang.Byte
 850 //  - java.lang.Short
 851 //  - java.lang.Integer
 852 //  - java.lang.Long
 853 
 854 // This could be separated out into 8 individual classes.
 855 
 856 class java_lang_boxing_object: AllStatic {
 857  private:
 858   static int _value_offset;
 859   static int _long_value_offset;
 860 
 861   static void compute_offsets();
 862   static oop initialize_and_allocate(BasicType type, TRAPS);
 863  public:
 864   // Allocation. Returns a boxed value, or NULL for invalid type.
 865   static oop create(BasicType type, jvalue* value, TRAPS);
 866   // Accessors. Returns the basic type being boxed, or T_ILLEGAL for invalid oop.
 867   static BasicType get_value(oop box, jvalue* value);
 868   static BasicType set_value(oop box, jvalue* value);
 869   static BasicType basic_type(oop box);
 870   static bool is_instance(oop box)                 { return basic_type(box) != T_ILLEGAL; }
 871   static bool is_instance(oop box, BasicType type) { return basic_type(box) == type; }
 872   static void print(oop box, outputStream* st)     { jvalue value;  print(get_value(box, &amp;value), &amp;value, st); }
 873   static void print(BasicType type, jvalue* value, outputStream* st);
 874 
 875   static int value_offset(BasicType type) {
 876     return is_double_word_type(type) ? _long_value_offset : _value_offset;
 877   }
 878 
 879   static void serialize_offsets(SerializeClosure* f);
 880 
 881   // Debugging
 882   friend class JavaClasses;
 883 };
 884 
 885 
 886 
 887 // Interface to java.lang.ref.Reference objects
 888 
 889 class java_lang_ref_Reference: AllStatic {
 890   static int _referent_offset;
 891   static int _queue_offset;
 892   static int _next_offset;
 893   static int _discovered_offset;
 894 
 895   static bool _offsets_initialized;
 896 
 897  public:
 898   // Accessors
 899   static inline oop referent(oop ref);
 900   static inline void set_referent(oop ref, oop value);
 901   static inline void set_referent_raw(oop ref, oop value);
 902   static inline HeapWord* referent_addr_raw(oop ref);
 903   static inline oop next(oop ref);
 904   static inline void set_next(oop ref, oop value);
 905   static inline void set_next_raw(oop ref, oop value);
 906   static inline HeapWord* next_addr_raw(oop ref);
 907   static inline oop discovered(oop ref);
 908   static inline void set_discovered(oop ref, oop value);
 909   static inline void set_discovered_raw(oop ref, oop value);
 910   static inline HeapWord* discovered_addr_raw(oop ref);
 911   static inline oop queue(oop ref);
 912   static inline void set_queue(oop ref, oop value);
 913   static bool is_referent_field(oop obj, ptrdiff_t offset);
 914   static inline bool is_final(oop ref);
 915   static inline bool is_phantom(oop ref);
 916 
 917   static int referent_offset()    { CHECK_INIT(_referent_offset); }
 918   static int queue_offset()       { CHECK_INIT(_queue_offset); }
 919   static int next_offset()        { CHECK_INIT(_next_offset); }
 920   static int discovered_offset()  { CHECK_INIT(_discovered_offset); }
 921 
 922   static void compute_offsets();
 923   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 924 };
 925 
 926 
 927 // Interface to java.lang.ref.SoftReference objects
 928 
 929 class java_lang_ref_SoftReference: public java_lang_ref_Reference {
 930   static int _timestamp_offset;
 931   static int _static_clock_offset;
 932 
 933  public:
 934   // Accessors
 935   static jlong timestamp(oop ref);
 936 
 937   // Accessors for statics
 938   static jlong clock();
 939   static void set_clock(jlong value);
 940 
 941   static void compute_offsets();
 942   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 943 };
 944 
 945 // Interface to java.lang.invoke.MethodHandle objects
 946 
 947 class MethodHandleEntry;
 948 
 949 class java_lang_invoke_MethodHandle: AllStatic {
 950   friend class JavaClasses;
 951 
 952  private:
 953   static int _type_offset;               // the MethodType of this MH
 954   static int _form_offset;               // the LambdaForm of this MH
 955 
 956   static void compute_offsets();
 957 
 958  public:
 959   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 960 
 961   // Accessors
 962   static oop            type(oop mh);
 963   static void       set_type(oop mh, oop mtype);
 964 
 965   static oop            form(oop mh);
 966   static void       set_form(oop mh, oop lform);
 967 
 968   // Testers
 969   static bool is_subclass(Klass* klass) {
 970     return klass-&gt;is_subclass_of(SystemDictionary::MethodHandle_klass());
 971   }
 972   static bool is_instance(oop obj);
 973 
 974   // Accessors for code generation:
 975   static int type_offset()             { CHECK_INIT(_type_offset); }
 976   static int form_offset()             { CHECK_INIT(_form_offset); }
 977 };
 978 
 979 // Interface to java.lang.invoke.DirectMethodHandle objects
 980 
 981 class java_lang_invoke_DirectMethodHandle: AllStatic {
 982   friend class JavaClasses;
 983 
 984  private:
 985   static int _member_offset;               // the MemberName of this DMH
 986 
 987   static void compute_offsets();
 988 
 989  public:
 990   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 991 
 992   // Accessors
 993   static oop  member(oop mh);
 994 
 995   // Testers
 996   static bool is_subclass(Klass* klass) {
 997     return klass-&gt;is_subclass_of(SystemDictionary::DirectMethodHandle_klass());
 998   }
 999   static bool is_instance(oop obj);
1000 
1001   // Accessors for code generation:
1002   static int member_offset()           { CHECK_INIT(_member_offset); }
1003 };
1004 
1005 // Interface to java.lang.invoke.LambdaForm objects
1006 // (These are a private interface for managing adapter code generation.)
1007 
1008 class java_lang_invoke_LambdaForm: AllStatic {
1009   friend class JavaClasses;
1010 
1011  private:
1012   static int _vmentry_offset;  // type is MemberName
1013 
1014   static void compute_offsets();
1015 
1016  public:
1017   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1018 
1019   // Accessors
1020   static oop            vmentry(oop lform);
1021   static void       set_vmentry(oop lform, oop invoker);
1022 
1023   // Testers
1024   static bool is_subclass(Klass* klass) {
1025     return SystemDictionary::LambdaForm_klass() != NULL &amp;&amp;
1026       klass-&gt;is_subclass_of(SystemDictionary::LambdaForm_klass());
1027   }
1028   static bool is_instance(oop obj);
1029 
1030   // Accessors for code generation:
1031   static int vmentry_offset()          { CHECK_INIT(_vmentry_offset); }
1032 };
1033 
1034 
1035 // Interface to java.lang.invoke.MemberName objects
1036 // (These are a private interface for Java code to query the class hierarchy.)
1037 
1038 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
1039   macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \
1040   macro(java_lang_invoke_ResolvedMethodName, vmtarget, intptr_signature, false)
1041 
1042 class java_lang_invoke_ResolvedMethodName : AllStatic {
1043   friend class JavaClasses;
1044 
1045   static int _vmtarget_offset;
1046   static int _vmholder_offset;
1047 
1048   static void compute_offsets();
1049  public:
1050   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1051 
1052   static int vmtarget_offset() { CHECK_INIT(_vmtarget_offset); }
1053 
1054   static Method* vmtarget(oop resolved_method);
1055   static void set_vmtarget(oop resolved_method, Method* method);
1056 
1057   static void set_vmholder(oop resolved_method, oop holder);
1058 
1059   // find or create resolved member name
1060   static oop find_resolved_method(const methodHandle&amp; m, TRAPS);
1061 
1062   static bool is_instance(oop resolved_method);
1063 };
1064 
1065 
1066 #define MEMBERNAME_INJECTED_FIELDS(macro)                               \
1067   macro(java_lang_invoke_MemberName, vmindex,  intptr_signature, false)
1068 
1069 
1070 class java_lang_invoke_MemberName: AllStatic {
1071   friend class JavaClasses;
1072 
1073  private:
1074   // From java.lang.invoke.MemberName:
1075   //    private Class&lt;?&gt;   clazz;       // class in which the method is defined
1076   //    private String     name;        // may be null if not yet materialized
1077   //    private Object     type;        // may be null if not yet materialized
1078   //    private int        flags;       // modifier bits; see reflect.Modifier
1079   //    private ResolvedMethodName method;    // holds VM-specific target value
1080   //    private intptr_t   vmindex;     // member index within class or interface
1081   static int _clazz_offset;
1082   static int _name_offset;
1083   static int _type_offset;
1084   static int _flags_offset;
1085   static int _method_offset;
1086   static int _vmindex_offset;
1087 
1088   static void compute_offsets();
1089 
1090  public:
1091   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1092   // Accessors
1093   static oop            clazz(oop mname);
1094   static void       set_clazz(oop mname, oop clazz);
1095 
1096   static oop            type(oop mname);
1097   static void       set_type(oop mname, oop type);
1098 
1099   static oop            name(oop mname);
1100   static void       set_name(oop mname, oop name);
1101 
1102   static int            flags(oop mname);
1103   static void       set_flags(oop mname, int flags);
1104 
1105   // Link through ResolvedMethodName field to get Method*
1106   static Method*        vmtarget(oop mname);
1107   static void       set_method(oop mname, oop method);
1108 
1109   static intptr_t       vmindex(oop mname);
1110   static void       set_vmindex(oop mname, intptr_t index);
1111 
1112   // Testers
1113   static bool is_subclass(Klass* klass) {
1114     return klass-&gt;is_subclass_of(SystemDictionary::MemberName_klass());
1115   }
1116   static bool is_instance(oop obj);
1117 
1118   static bool is_method(oop obj);
1119 
1120   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
1121   enum {
1122     MN_IS_METHOD             = 0x00010000, // method (not constructor)
1123     MN_IS_CONSTRUCTOR        = 0x00020000, // constructor
1124     MN_IS_FIELD              = 0x00040000, // field
1125     MN_IS_TYPE               = 0x00080000, // nested type
1126     MN_CALLER_SENSITIVE      = 0x00100000, // @CallerSensitive annotation detected
1127     MN_TRUSTED_FINAL         = 0x00200000, // trusted final field
1128     MN_REFERENCE_KIND_SHIFT  = 24, // refKind
1129     MN_REFERENCE_KIND_MASK   = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,
1130     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
1131     MN_SEARCH_SUPERCLASSES   = 0x00100000, // walk super classes
1132     MN_SEARCH_INTERFACES     = 0x00200000, // walk implemented interfaces
1133     MN_NESTMATE_CLASS        = 0x00000001,
1134     MN_HIDDEN_CLASS          = 0x00000002,
1135     MN_STRONG_LOADER_LINK    = 0x00000004,
1136     MN_ACCESS_VM_ANNOTATIONS = 0x00000008
1137   };
1138 
1139   // Accessors for code generation:
1140   static int clazz_offset()   { CHECK_INIT(_clazz_offset); }
1141   static int type_offset()    { CHECK_INIT(_type_offset); }
1142   static int flags_offset()   { CHECK_INIT(_flags_offset); }
1143   static int method_offset()  { CHECK_INIT(_method_offset); }
1144   static int vmindex_offset() { CHECK_INIT(_vmindex_offset); }
1145 };
1146 
1147 
1148 // Interface to java.lang.invoke.MethodType objects
1149 
1150 class java_lang_invoke_MethodType: AllStatic {
1151   friend class JavaClasses;
1152 
1153  private:
1154   static int _rtype_offset;
1155   static int _ptypes_offset;
1156 
1157   static void compute_offsets();
1158 
1159  public:
1160   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1161   // Accessors
1162   static oop            rtype(oop mt);
1163   static objArrayOop    ptypes(oop mt);
1164 
1165   static oop            ptype(oop mt, int index);
1166   static int            ptype_count(oop mt);
1167 
1168   static int            ptype_slot_count(oop mt);  // extra counts for long/double
1169   static int            rtype_slot_count(oop mt);  // extra counts for long/double
1170 
1171   static Symbol*        as_signature(oop mt, bool intern_if_not_found);
1172   static void           print_signature(oop mt, outputStream* st);
1173 
1174   static bool is_instance(oop obj);
1175 
1176   static bool equals(oop mt1, oop mt2);
1177 
1178   // Accessors for code generation:
1179   static int rtype_offset()  { CHECK_INIT(_rtype_offset); }
1180   static int ptypes_offset() { CHECK_INIT(_ptypes_offset); }
1181 };
1182 
1183 
1184 // Interface to java.lang.invoke.CallSite objects
1185 
1186 class java_lang_invoke_CallSite: AllStatic {
1187   friend class JavaClasses;
1188 
1189 private:
1190   static int _target_offset;
1191   static int _context_offset;
1192 
1193   static void compute_offsets();
1194 
1195 public:
1196   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1197   // Accessors
1198   static oop              target(          oop site);
1199   static void         set_target(          oop site, oop target);
1200   static void         set_target_volatile( oop site, oop target);
1201 
1202   static oop context_no_keepalive(oop site);
1203 
1204   // Testers
1205   static bool is_subclass(Klass* klass) {
1206     return klass-&gt;is_subclass_of(SystemDictionary::CallSite_klass());
1207   }
1208   static bool is_instance(oop obj);
1209 
1210   // Accessors for code generation:
1211   static int target_offset()  { CHECK_INIT(_target_offset); }
1212   static int context_offset() { CHECK_INIT(_context_offset); }
1213 };
1214 
1215 // Interface to java.lang.invoke.ConstantCallSite objects
1216 
1217 class java_lang_invoke_ConstantCallSite: AllStatic {
1218   friend class JavaClasses;
1219 
1220 private:
1221   static int _is_frozen_offset;
1222 
1223   static void compute_offsets();
1224 
1225 public:
1226   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1227   // Accessors
1228   static jboolean is_frozen(oop site);
1229 
1230   // Testers
1231   static bool is_subclass(Klass* klass) {
1232     return klass-&gt;is_subclass_of(SystemDictionary::ConstantCallSite_klass());
1233   }
1234   static bool is_instance(oop obj);
1235 };
1236 
1237 // Interface to java.lang.invoke.MethodHandleNatives$CallSiteContext objects
1238 
1239 #define CALLSITECONTEXT_INJECTED_FIELDS(macro) \
1240   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, vmdependencies, intptr_signature, false) \
1241   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, last_cleanup, long_signature, false)
1242 
1243 class DependencyContext;
1244 
1245 class java_lang_invoke_MethodHandleNatives_CallSiteContext : AllStatic {
1246   friend class JavaClasses;
1247 
1248 private:
1249   static int _vmdependencies_offset;
1250   static int _last_cleanup_offset;
1251 
1252   static void compute_offsets();
1253 
1254 public:
1255   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1256   // Accessors
1257   static DependencyContext vmdependencies(oop context);
1258 
1259   // Testers
1260   static bool is_subclass(Klass* klass) {
1261     return klass-&gt;is_subclass_of(SystemDictionary::Context_klass());
1262   }
1263   static bool is_instance(oop obj);
1264 };
1265 
1266 // Interface to java.security.AccessControlContext objects
1267 
1268 class java_security_AccessControlContext: AllStatic {
1269  private:
1270   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
1271   // so we compute the offsets at startup rather than hard-wiring them.
1272   static int _context_offset;
1273   static int _privilegedContext_offset;
1274   static int _isPrivileged_offset;
1275   static int _isAuthorized_offset;
1276 
1277   static void compute_offsets();
1278  public:
1279   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1280   static oop create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS);
1281 
1282   // Debugging/initialization
1283   friend class JavaClasses;
1284 };
1285 
1286 
1287 // Interface to java.lang.ClassLoader objects
1288 
1289 #define CLASSLOADER_INJECTED_FIELDS(macro)                            \
1290   macro(java_lang_ClassLoader, loader_data,  intptr_signature, false)
1291 
1292 class java_lang_ClassLoader : AllStatic {
1293  private:
1294   static int _loader_data_offset;
1295   static int _parent_offset;
1296   static int _parallelCapable_offset;
1297   static int _name_offset;
1298   static int _nameAndId_offset;
1299   static int _unnamedModule_offset;
1300 
1301   static void compute_offsets();
1302 
1303  public:
1304   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1305 
1306   static ClassLoaderData* loader_data_acquire(oop loader);
1307   static ClassLoaderData* loader_data_raw(oop loader);
1308   static void release_set_loader_data(oop loader, ClassLoaderData* new_data);
1309 
1310   static oop parent(oop loader);
1311   static oop name(oop loader);
1312   static oop nameAndId(oop loader);
1313   static bool isAncestor(oop loader, oop cl);
1314 
1315   // Support for parallelCapable field
1316   static bool parallelCapable(oop the_class_mirror);
1317 
1318   static bool is_trusted_loader(oop loader);
1319 
1320   // Return true if this is one of the class loaders associated with
1321   // the generated bytecodes for reflection.
1322   static bool is_reflection_class_loader(oop loader);
1323 
1324   // Fix for 4474172
1325   static oop  non_reflection_class_loader(oop loader);
1326 
1327   // Testers
1328   static bool is_subclass(Klass* klass) {
1329     return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass());
1330   }
1331   static bool is_instance(oop obj);
1332 
1333   static oop unnamedModule(oop loader);
1334 
1335   // Debugging
1336   friend class JavaClasses;
1337 };
1338 
1339 
1340 // Interface to java.lang.System objects
1341 
1342 class java_lang_System : AllStatic {
1343  private:
1344   static int _static_in_offset;
1345   static int _static_out_offset;
1346   static int _static_err_offset;
1347   static int _static_security_offset;
1348 
1349  public:
1350   static int  in_offset() { CHECK_INIT(_static_in_offset); }
1351   static int out_offset() { CHECK_INIT(_static_out_offset); }
1352   static int err_offset() { CHECK_INIT(_static_err_offset); }
1353 
1354   static void compute_offsets();
1355   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1356 
1357   // Debugging
1358   friend class JavaClasses;
1359 };
1360 
1361 
1362 // Interface to java.lang.StackTraceElement objects
1363 
1364 class java_lang_StackTraceElement: AllStatic {
1365  private:
1366   static int _declaringClassObject_offset;
1367   static int _classLoaderName_offset;
1368   static int _moduleName_offset;
1369   static int _moduleVersion_offset;
1370   static int _declaringClass_offset;
1371   static int _methodName_offset;
1372   static int _fileName_offset;
1373   static int _lineNumber_offset;
1374 
1375   // Setters
1376   static void set_classLoaderName(oop element, oop value);
1377   static void set_moduleName(oop element, oop value);
1378   static void set_moduleVersion(oop element, oop value);
1379   static void set_declaringClass(oop element, oop value);
1380   static void set_methodName(oop element, oop value);
1381   static void set_fileName(oop element, oop value);
1382   static void set_lineNumber(oop element, int value);
1383   static void set_declaringClassObject(oop element, oop value);
1384 
1385   static void decode_file_and_line(Handle java_mirror, InstanceKlass* holder, int version,
1386                                    const methodHandle&amp; method, int bci,
1387                                    Symbol*&amp; source, oop&amp; source_file, int&amp; line_number, TRAPS);
1388 
1389  public:
1390   // Create an instance of StackTraceElement
1391   static oop create(const methodHandle&amp; method, int bci, TRAPS);
1392 
1393   static void fill_in(Handle element, InstanceKlass* holder, const methodHandle&amp; method,
1394                       int version, int bci, Symbol* name, TRAPS);
1395 
1396   static void compute_offsets();
1397   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1398 
1399 #if INCLUDE_JVMCI
1400   static void decode(const methodHandle&amp; method, int bci, Symbol*&amp; fileName, int&amp; lineNumber, TRAPS);
1401 #endif
1402 
1403   // Debugging
1404   friend class JavaClasses;
1405 };
1406 
1407 
1408 class Backtrace: AllStatic {
1409  public:
1410   // Helper backtrace functions to store bci|version together.
1411   static int merge_bci_and_version(int bci, int version);
1412   static int merge_mid_and_cpref(int mid, int cpref);
1413   static int bci_at(unsigned int merged);
1414   static int version_at(unsigned int merged);
1415   static int mid_at(unsigned int merged);
1416   static int cpref_at(unsigned int merged);
1417   static int get_line_number(Method* method, int bci);
1418   static Symbol* get_source_file_name(InstanceKlass* holder, int version);
1419 
1420   // Debugging
1421   friend class JavaClasses;
1422 };
1423 
1424 // Interface to java.lang.StackFrameInfo objects
1425 
1426 #define STACKFRAMEINFO_INJECTED_FIELDS(macro)                      \
1427   macro(java_lang_StackFrameInfo, version, short_signature, false)
1428 
1429 class java_lang_StackFrameInfo: AllStatic {
1430 private:
1431   static int _memberName_offset;
1432   static int _bci_offset;
1433   static int _version_offset;
1434 
1435   static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);
1436 
1437 public:
1438   // Setters
1439   static void set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS);
1440   static void set_bci(oop info, int value);
1441 
1442   static void set_version(oop info, short value);
1443 
1444   static void compute_offsets();
1445   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1446 
1447   static void to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS);
1448 
1449   // Debugging
1450   friend class JavaClasses;
1451 };
1452 
1453 class java_lang_LiveStackFrameInfo: AllStatic {
1454  private:
1455   static int _monitors_offset;
1456   static int _locals_offset;
1457   static int _operands_offset;
1458   static int _mode_offset;
1459 
1460  public:
1461   static void set_monitors(oop info, oop value);
1462   static void set_locals(oop info, oop value);
1463   static void set_operands(oop info, oop value);
1464   static void set_mode(oop info, int value);
1465 
1466   static void compute_offsets();
1467   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1468 
1469   // Debugging
1470   friend class JavaClasses;
1471 };
1472 
1473 // Interface to java.lang.reflect.RecordComponent objects
1474 
1475 class java_lang_reflect_RecordComponent: AllStatic {
1476  private:
1477   static int _clazz_offset;
1478   static int _name_offset;
1479   static int _type_offset;
1480   static int _accessor_offset;
1481   static int _signature_offset;
1482   static int _annotations_offset;
1483   static int _typeAnnotations_offset;
1484 
1485   // Setters
1486   static void set_clazz(oop element, oop value);
1487   static void set_name(oop element, oop value);
1488   static void set_type(oop element, oop value);
1489   static void set_accessor(oop element, oop value);
1490   static void set_signature(oop element, oop value);
1491   static void set_annotations(oop element, oop value);
1492   static void set_typeAnnotations(oop element, oop value);
1493 
1494  public:
1495   // Create an instance of RecordComponent
1496   static oop create(InstanceKlass* holder, RecordComponent* component, TRAPS);
1497 
1498   static void compute_offsets();
1499   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1500 
1501   // Debugging
1502   friend class JavaClasses;
1503 };
1504 
1505 
1506 // Interface to java.lang.AssertionStatusDirectives objects
1507 
1508 class java_lang_AssertionStatusDirectives: AllStatic {
1509  private:
1510   static int _classes_offset;
1511   static int _classEnabled_offset;
1512   static int _packages_offset;
1513   static int _packageEnabled_offset;
1514   static int _deflt_offset;
1515 
1516  public:
1517   // Setters
1518   static void set_classes(oop obj, oop val);
1519   static void set_classEnabled(oop obj, oop val);
1520   static void set_packages(oop obj, oop val);
1521   static void set_packageEnabled(oop obj, oop val);
1522   static void set_deflt(oop obj, bool val);
1523 
1524   static void compute_offsets();
1525   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1526 
1527   // Debugging
1528   friend class JavaClasses;
1529 };
1530 
1531 
1532 class java_nio_Buffer: AllStatic {
1533  private:
1534   static int _limit_offset;
1535 
1536  public:
1537   static int  limit_offset() { CHECK_INIT(_limit_offset); }
1538   static void compute_offsets();
1539   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1540 };
1541 
1542 class java_util_concurrent_locks_AbstractOwnableSynchronizer : AllStatic {
1543  private:
1544   static int  _owner_offset;
1545  public:
1546   static void compute_offsets();
1547   static oop  get_owner_threadObj(oop obj);
1548   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1549 };
1550 
1551  // Interface to jdk.internal.misc.UnsafeConsants
1552 
1553 class jdk_internal_misc_UnsafeConstants : AllStatic {
1554  public:
1555   static void set_unsafe_constants();
1556   static void compute_offsets() { }
1557   static void serialize_offsets(SerializeClosure* f) { }
1558 };
1559 
1560 class java_lang_Integer : AllStatic {
1561 public:
1562   static jint value(oop obj);
1563 };
1564 
1565 class java_lang_Long : AllStatic {
1566 public:
1567   static jlong value(oop obj);
1568 };
1569 
1570 class java_lang_Character : AllStatic {
1571 public:
1572   static jchar value(oop obj);
1573 };
1574 
1575 class java_lang_Short : AllStatic {
1576 public:
1577   static jshort value(oop obj);
1578 };
1579 
1580 class java_lang_Byte : AllStatic {
1581 public:
1582   static jbyte value(oop obj);
1583 };
1584 
1585 class java_lang_Boolean : AllStatic {
1586  private:
1587   static int _static_TRUE_offset;
1588   static int _static_FALSE_offset;
1589  public:
1590   static Symbol* symbol();
1591   static void compute_offsets(InstanceKlass* k);
1592   static oop  get_TRUE(InstanceKlass *k);
1593   static oop  get_FALSE(InstanceKlass *k);
1594   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1595   static jboolean value(oop obj);
1596 };
1597 
1598 class java_lang_Integer_IntegerCache : AllStatic {
1599  private:
1600   static int _static_cache_offset;
1601  public:
1602   static Symbol* symbol();
1603   static void compute_offsets(InstanceKlass* k);
1604   static objArrayOop  cache(InstanceKlass *k);
1605   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1606 };
1607 
1608 class java_lang_Long_LongCache : AllStatic {
1609  private:
1610   static int _static_cache_offset;
1611  public:
1612   static Symbol* symbol();
1613   static void compute_offsets(InstanceKlass* k);
1614   static objArrayOop  cache(InstanceKlass *k);
1615   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1616 };
1617 
1618 class java_lang_Character_CharacterCache : AllStatic {
1619  private:
1620   static int _static_cache_offset;
1621  public:
1622   static Symbol* symbol();
1623   static void compute_offsets(InstanceKlass* k);
1624   static objArrayOop  cache(InstanceKlass *k);
1625   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1626 };
1627 
1628 class java_lang_Short_ShortCache : AllStatic {
1629  private:
1630   static int _static_cache_offset;
1631  public:
1632   static Symbol* symbol();
1633   static void compute_offsets(InstanceKlass* k);
1634   static objArrayOop  cache(InstanceKlass *k);
1635   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1636 };
1637 
1638 class java_lang_Byte_ByteCache : AllStatic {
1639  private:
1640   static int _static_cache_offset;
1641  public:
1642   static Symbol* symbol();
1643   static void compute_offsets(InstanceKlass* k);
1644   static objArrayOop  cache(InstanceKlass *k);
1645   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1646 };
1647 
1648 // Use to declare fields that need to be injected into Java classes
1649 // for the JVM to use.  The name_index and signature_index are
1650 // declared in vmSymbols.  The may_be_java flag is used to declare
1651 // fields that might already exist in Java but should be injected if
1652 // they don&#39;t.  Otherwise the field is unconditionally injected and
1653 // the JVM uses the injected one.  This is to ensure that name
1654 // collisions don&#39;t occur.  In general may_be_java should be false
1655 // unless there&#39;s a good reason.
1656 
1657 class InjectedField {
1658  public:
1659   const SystemDictionary::WKID klass_id;
1660   const vmSymbols::SID name_index;
1661   const vmSymbols::SID signature_index;
1662   const bool           may_be_java;
1663 
1664 
1665   Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }
1666   Symbol* name() const      { return lookup_symbol(name_index); }
1667   Symbol* signature() const { return lookup_symbol(signature_index); }
1668 
1669   int compute_offset();
1670 
1671   // Find the Symbol for this index
1672   static Symbol* lookup_symbol(int symbol_index) {
1673     return vmSymbols::symbol_at((vmSymbols::SID)symbol_index);
1674   }
1675 };
1676 
1677 #define DECLARE_INJECTED_FIELD_ENUM(klass, name, signature, may_be_java) \
1678   klass##_##name##_enum,
1679 
1680 #define ALL_INJECTED_FIELDS(macro)          \
1681   CLASS_INJECTED_FIELDS(macro)              \
1682   CLASSLOADER_INJECTED_FIELDS(macro)        \
1683   RESOLVEDMETHOD_INJECTED_FIELDS(macro)     \
1684   MEMBERNAME_INJECTED_FIELDS(macro)         \
1685   CALLSITECONTEXT_INJECTED_FIELDS(macro)    \
1686   STACKFRAMEINFO_INJECTED_FIELDS(macro)     \
1687   MODULE_INJECTED_FIELDS(macro)
1688 
1689 // Interface to hard-coded offset checking
1690 
1691 class JavaClasses : AllStatic {
1692  private:
1693 
1694   static InjectedField _injected_fields[];
1695 
1696   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1697  public:
1698   enum InjectedFieldID {
1699     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1700     MAX_enum
1701   };
1702 
1703   static int compute_injected_offset(InjectedFieldID id);
1704 
1705   static void compute_offsets();
1706   static void check_offsets() PRODUCT_RETURN;
1707   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1708   static InjectedField* get_injected(Symbol* class_name, int* field_count);
1709   static bool is_supported_for_archiving(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(false);
1710 };
1711 
1712 #undef DECLARE_INJECTED_FIELD_ENUM
1713 
1714 #undef CHECK_INIT
1715 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
    </pre>
  </body>
</html>