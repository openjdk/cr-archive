<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/javaClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CLASSFILE_JAVACLASSES_HPP
  26 #define SHARE_CLASSFILE_JAVACLASSES_HPP
  27 
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmti.h&quot;
  30 #include &quot;oops/oop.hpp&quot;
  31 #include &quot;runtime/os.hpp&quot;
  32 
  33 class RecordComponent;
  34 
  35 // Interface for manipulating the basic Java classes.
  36 
  37 #define BASIC_JAVA_CLASSES_DO_PART1(f) \
  38   f(java_lang_Class) \
  39   f(java_lang_String) \
  40   f(java_lang_ref_Reference) \
  41   //end
  42 
  43 #define BASIC_JAVA_CLASSES_DO_PART2(f) \
  44   f(java_lang_System) \
  45   f(java_lang_ClassLoader) \
  46   f(java_lang_Throwable) \
  47   f(java_lang_Thread) \
  48   f(java_lang_ThreadGroup) \
  49   f(java_lang_AssertionStatusDirectives) \
  50   f(java_lang_ref_SoftReference) \
  51   f(java_lang_invoke_MethodHandle) \
  52   f(java_lang_invoke_DirectMethodHandle) \
  53   f(java_lang_invoke_MemberName) \
  54   f(java_lang_invoke_ResolvedMethodName) \
  55   f(java_lang_invoke_LambdaForm) \
  56   f(java_lang_invoke_MethodType) \
  57   f(java_lang_invoke_CallSite) \
  58   f(java_lang_invoke_ConstantCallSite) \
  59   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  60   f(java_security_AccessControlContext) \
  61   f(java_lang_reflect_AccessibleObject) \
  62   f(java_lang_reflect_Method) \
  63   f(java_lang_reflect_Constructor) \
  64   f(java_lang_reflect_Field) \
  65   f(java_lang_reflect_RecordComponent) \
  66   f(java_nio_Buffer) \
  67   f(reflect_ConstantPool) \
  68   f(reflect_UnsafeStaticFieldAccessorImpl) \
  69   f(java_lang_reflect_Parameter) \
  70   f(java_lang_Module) \
  71   f(java_lang_StackTraceElement) \
  72   f(java_lang_StackFrameInfo) \
  73   f(java_lang_LiveStackFrameInfo) \
  74   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  75   f(jdk_internal_misc_UnsafeConstants) \
  76   f(jdk_internal_vm_jni_SubElementSelector) \
  77   f(java_lang_boxing_object) \
  78   //end
  79 
  80 #define BASIC_JAVA_CLASSES_DO(f) \
  81         BASIC_JAVA_CLASSES_DO_PART1(f) \
  82         BASIC_JAVA_CLASSES_DO_PART2(f)
  83 
  84 #define CHECK_INIT(offset)  assert(offset != 0, &quot;should be initialized&quot;); return offset;
  85 
  86 // Interface to java.lang.Object objects
  87 
  88 class java_lang_Object : AllStatic {
  89  public:
  90   static void register_natives(TRAPS);
  91 };
  92 
  93 // Interface to java.lang.String objects
  94 
  95 class java_lang_String : AllStatic {
  96  private:
  97   static int _value_offset;
  98   static int _hash_offset;
  99   static int _hashIsZero_offset;
 100   static int _coder_offset;
 101 
 102   static bool _initialized;
 103 
 104   static Handle basic_create(int length, bool byte_arr, TRAPS);
 105 
 106   static inline void set_coder(oop string, jbyte coder);
 107 
 108  public:
 109 
 110   // Coders
 111   enum Coder {
 112     CODER_LATIN1 =  0,
 113     CODER_UTF16  =  1
 114   };
 115 
 116   static void compute_offsets();
 117   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 118 
 119   // Instance creation
 120   static Handle create_from_unicode(const jchar* unicode, int len, TRAPS);
 121   static oop    create_oop_from_unicode(const jchar* unicode, int len, TRAPS);
 122   static Handle create_from_str(const char* utf8_str, TRAPS);
 123   static oop    create_oop_from_str(const char* utf8_str, TRAPS);
 124   static Handle create_from_symbol(Symbol* symbol, TRAPS);
 125   static Handle create_from_platform_dependent_str(const char* str, TRAPS);
 126   static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);
 127 
 128   static void set_compact_strings(bool value);
 129 
 130   static int value_offset() { CHECK_INIT(_value_offset); }
 131   static int coder_offset() { CHECK_INIT(_coder_offset); }
 132 
 133   static inline void set_value_raw(oop string, typeArrayOop buffer);
 134   static inline void set_value(oop string, typeArrayOop buffer);
 135 
 136   // Accessors
 137   static inline typeArrayOop value(oop java_string);
 138   static inline typeArrayOop value_no_keepalive(oop java_string);
 139   static inline bool hash_is_set(oop string);
 140   static inline bool is_latin1(oop java_string);
 141   static inline int length(oop java_string);
 142   static inline int length(oop java_string, typeArrayOop string_value);
 143   static int utf8_length(oop java_string);
 144   static int utf8_length(oop java_string, typeArrayOop string_value);
 145 
 146   // String converters
 147   static char*  as_utf8_string(oop java_string);
 148   static char*  as_utf8_string(oop java_string, int&amp; length);
 149   static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; length);
 150   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
 151   static char*  as_utf8_string(oop java_string, int start, int len);
 152   static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);
 153   static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);
 154   static char*  as_platform_dependent_str(Handle java_string, TRAPS);
 155   static jchar* as_unicode_string(oop java_string, int&amp; length, TRAPS);
 156   // produce an ascii string with all other values quoted using \u####
 157   static char*  as_quoted_ascii(oop java_string);
 158 
 159   // Compute the hash value for a java.lang.String object which would
 160   // contain the characters passed in.
 161   //
 162   // As the hash value used by the String object itself, in
 163   // String.hashCode().  This value is normally calculated in Java code
 164   // in the String.hashCode method(), but is precomputed for String
 165   // objects in the shared archive file.
 166   // hash P(31) from Kernighan &amp; Ritchie
 167   //
 168   // For this reason, THIS ALGORITHM MUST MATCH String.hashCode().
 169   static unsigned int hash_code(const jchar* s, int len) {
 170     unsigned int h = 0;
 171     while (len-- &gt; 0) {
 172       h = 31*h + (unsigned int) *s;
 173       s++;
 174     }
 175     return h;
 176   }
 177 
 178   static unsigned int hash_code(const jbyte* s, int len) {
 179     unsigned int h = 0;
 180     while (len-- &gt; 0) {
 181       h = 31*h + (((unsigned int) *s) &amp; 0xFF);
 182       s++;
 183     }
 184     return h;
 185   }
 186 
 187   static unsigned int hash_code(oop java_string);
 188 
 189   static bool equals(oop java_string, const jchar* chars, int len);
 190   static bool equals(oop str1, oop str2);
 191   static inline bool value_equals(typeArrayOop str_value1, typeArrayOop str_value2);
 192 
 193   // Conversion between &#39;.&#39; and &#39;/&#39; formats
 194   static Handle externalize_classname(Handle java_string, TRAPS) {
 195     return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);
 196   }
 197 
 198   // Conversion
 199   static Symbol* as_symbol(oop java_string);
 200   static Symbol* as_symbol_or_null(oop java_string);
 201 
 202   // Testers
 203   static bool is_instance(oop obj);
 204   static inline bool is_instance_inlined(oop obj);
 205 
 206   // Debugging
 207   static void print(oop java_string, outputStream* st);
 208   friend class JavaClasses;
 209   friend class StringTable;
 210 };
 211 
 212 
 213 // Interface to java.lang.Class objects
 214 
 215 #define CLASS_INJECTED_FIELDS(macro)                                       \
 216   macro(java_lang_Class, klass,                  intptr_signature,  false) \
 217   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
 218   macro(java_lang_Class, oop_size,               int_signature,     false) \
 219   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
 220   macro(java_lang_Class, protection_domain,      object_signature,  false) \
 221   macro(java_lang_Class, signers,                object_signature,  false) \
 222   macro(java_lang_Class, source_file,            object_signature,  false) \
 223 
 224 class java_lang_Class : AllStatic {
 225   friend class VMStructs;
 226   friend class JVMCIVMStructs;
 227 
 228  private:
 229 
 230   // The fake offsets are added by the class loader when java.lang.Class is loaded
 231 
 232   static int _klass_offset;
 233   static int _array_klass_offset;
 234 
 235   static int _oop_size_offset;
 236   static int _static_oop_field_count_offset;
 237 
 238   static int _protection_domain_offset;
 239   static int _init_lock_offset;
 240   static int _signers_offset;
 241   static int _class_loader_offset;
 242   static int _module_offset;
 243   static int _component_mirror_offset;
 244   static int _name_offset;
 245   static int _source_file_offset;
 246   static int _val_type_mirror_offset;
 247   static int _ref_type_mirror_offset;
 248   static int _classData_offset;
 249   static int _classRedefinedCount_offset;
 250 
 251   static bool _offsets_computed;
 252 
 253   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 254   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 255 
 256   static void set_init_lock(oop java_class, oop init_lock);
 257   static void set_protection_domain(oop java_class, oop protection_domain);
 258   static void set_class_loader(oop java_class, oop class_loader);
 259   static void set_component_mirror(oop java_class, oop comp_mirror);
 260   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,
 261                                        Handle classData, TRAPS);
 262   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 263  public:
 264   static void allocate_fixup_lists();
 265   static void compute_offsets();
 266 
 267   // Instance creation
 268   static void create_mirror(Klass* k, Handle class_loader, Handle module,
 269                             Handle protection_domain, Handle classData, TRAPS);
 270   static void fixup_mirror(Klass* k, TRAPS);
 271   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
 272   static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 273   static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 274 
 275   // Archiving
 276   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 277   static void archive_basic_type_mirrors(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 278   static oop  archive_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 279   static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror, Thread *THREAD)
 280                                       NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 281   static bool restore_archived_mirror(Klass *k, Handle class_loader, Handle module,
 282                                       Handle protection_domain,
 283                                       TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);
 284 
 285   static void fixup_module_field(Klass* k, Handle module);
 286 
 287   // Conversion
 288   static Klass* as_Klass(oop java_class);
 289   static Klass* as_Klass_raw(oop java_class);
 290   static void set_klass(oop java_class, Klass* klass);
 291   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
 292   static Symbol* as_signature(oop java_class, bool intern_if_not_found);
 293   static void print_signature(oop java_class, outputStream *st);
 294   static const char* as_external_name(oop java_class);
 295   // Testing
 296   static bool is_instance(oop obj);
 297 
 298   static bool is_primitive(oop java_class);
 299   static BasicType primitive_type(oop java_class);
 300   static oop primitive_mirror(BasicType t);
 301   // JVM_NewArray support
 302   static Klass* array_klass_acquire(oop java_class);
 303   static void release_set_array_klass(oop java_class, Klass* klass);
 304   // compiler support for class operations
 305   static int klass_offset()                { CHECK_INIT(_klass_offset); }
 306   static int array_klass_offset()          { CHECK_INIT(_array_klass_offset); }
 307   static int component_mirror_offset()     { CHECK_INIT(_component_mirror_offset); }
 308   // Support for classRedefinedCount field
 309   static int classRedefinedCount(oop the_class_mirror);
 310   static void set_classRedefinedCount(oop the_class_mirror, int value);
 311 
 312   // Support for embedded per-class oops
 313   static oop  protection_domain(oop java_class);
 314   static oop  init_lock(oop java_class);
 315   static void clear_init_lock(oop java_class) {
 316     set_init_lock(java_class, NULL);
 317   }
 318   static oop  component_mirror(oop java_class);
 319   static objArrayOop  signers(oop java_class);
 320   static void set_signers(oop java_class, objArrayOop signers);
 321   static oop  class_data(oop java_class);
 322   static void set_class_data(oop java_class, oop classData);
 323 
 324   static oop class_loader(oop java_class);
 325   static void set_module(oop java_class, oop module);
 326   static oop module(oop java_class);
 327 
 328   static void set_ref_type_mirror(oop java_class, oop mirror);
 329   static oop ref_type_mirror(oop java_class);
 330 
 331   static void set_val_type_mirror(oop java_class, oop mirror);
 332   static oop val_type_mirror(oop java_class);
 333 
 334   static oop name(Handle java_class, TRAPS);
 335 
 336   static oop source_file(oop java_class);
 337   static void set_source_file(oop java_class, oop source_file);
 338 
 339   static int oop_size(oop java_class);
 340   static int oop_size_raw(oop java_class);
 341   static void set_oop_size(HeapWord* java_class, int size);
 342   static int static_oop_field_count(oop java_class);
 343   static int static_oop_field_count_raw(oop java_class);
 344   static void set_static_oop_field_count(oop java_class, int size);
 345 
 346   static GrowableArray&lt;Klass*&gt;* fixup_mirror_list() {
 347     return _fixup_mirror_list;
 348   }
 349   static void set_fixup_mirror_list(GrowableArray&lt;Klass*&gt;* v) {
 350     _fixup_mirror_list = v;
 351   }
 352 
 353   static GrowableArray&lt;Klass*&gt;* fixup_module_field_list() {
 354     return _fixup_module_field_list;
 355   }
 356   static void set_fixup_module_field_list(GrowableArray&lt;Klass*&gt;* v) {
 357     _fixup_module_field_list = v;
 358   }
 359 
 360   // Debugging
 361   friend class JavaClasses;
 362 };
 363 
 364 // Interface to java.lang.Thread objects
 365 
 366 class java_lang_Thread : AllStatic {
 367  private:
 368   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
 369   // so we compute the offsets at startup rather than hard-wiring them.
 370   static int _name_offset;
 371   static int _group_offset;
 372   static int _contextClassLoader_offset;
 373   static int _inheritedAccessControlContext_offset;
 374   static int _priority_offset;
 375   static int _eetop_offset;
 376   static int _interrupted_offset;
 377   static int _daemon_offset;
 378   static int _stillborn_offset;
 379   static int _stackSize_offset;
 380   static int _tid_offset;
 381   static int _thread_status_offset;
 382   static int _park_blocker_offset;
 383 
 384   static void compute_offsets();
 385 
 386  public:
 387   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 388 
 389   // Instance creation
 390   static oop create();
 391   // Returns the JavaThread associated with the thread obj
 392   static JavaThread* thread(oop java_thread);
 393   // Set JavaThread for instance
 394   static void set_thread(oop java_thread, JavaThread* thread);
 395   // Interrupted status
 396   static bool interrupted(oop java_thread);
 397   static void set_interrupted(oop java_thread, bool val);
 398   // Name
 399   static oop name(oop java_thread);
 400   static void set_name(oop java_thread, oop name);
 401   // Priority
 402   static ThreadPriority priority(oop java_thread);
 403   static void set_priority(oop java_thread, ThreadPriority priority);
 404   // Thread group
 405   static oop  threadGroup(oop java_thread);
 406   // Stillborn
 407   static bool is_stillborn(oop java_thread);
 408   static void set_stillborn(oop java_thread);
 409   // Alive (NOTE: this is not really a field, but provides the correct
 410   // definition without doing a Java call)
 411   static bool is_alive(oop java_thread);
 412   // Daemon
 413   static bool is_daemon(oop java_thread);
 414   static void set_daemon(oop java_thread);
 415   // Context ClassLoader
 416   static oop context_class_loader(oop java_thread);
 417   // Control context
 418   static oop inherited_access_control_context(oop java_thread);
 419   // Stack size hint
 420   static jlong stackSize(oop java_thread);
 421   // Thread ID
 422   static jlong thread_id(oop java_thread);
 423 
 424   // Blocker object responsible for thread parking
 425   static oop park_blocker(oop java_thread);
 426 
 427   // Java Thread Status for JVMTI and M&amp;M use.
 428   // This thread status info is saved in threadStatus field of
 429   // java.lang.Thread java class.
 430   enum ThreadStatus {
 431     NEW                      = 0,
 432     RUNNABLE                 = JVMTI_THREAD_STATE_ALIVE +          // runnable / running
 433                                JVMTI_THREAD_STATE_RUNNABLE,
 434     SLEEPING                 = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
 435                                JVMTI_THREAD_STATE_WAITING +
 436                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 437                                JVMTI_THREAD_STATE_SLEEPING,
 438     IN_OBJECT_WAIT           = JVMTI_THREAD_STATE_ALIVE +          // Object.wait()
 439                                JVMTI_THREAD_STATE_WAITING +
 440                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 441                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 442     IN_OBJECT_WAIT_TIMED     = JVMTI_THREAD_STATE_ALIVE +          // Object.wait(long)
 443                                JVMTI_THREAD_STATE_WAITING +
 444                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 445                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 446     PARKED                   = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park()
 447                                JVMTI_THREAD_STATE_WAITING +
 448                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 449                                JVMTI_THREAD_STATE_PARKED,
 450     PARKED_TIMED             = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park(long)
 451                                JVMTI_THREAD_STATE_WAITING +
 452                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 453                                JVMTI_THREAD_STATE_PARKED,
 454     BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE +          // (re-)entering a synchronization block
 455                                JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
 456     TERMINATED               = JVMTI_THREAD_STATE_TERMINATED
 457   };
 458   // Write thread status info to threadStatus field of java.lang.Thread.
 459   static void set_thread_status(oop java_thread_oop, ThreadStatus status);
 460   // Read thread status info from threadStatus field of java.lang.Thread.
 461   static ThreadStatus get_thread_status(oop java_thread_oop);
 462 
 463   static const char*  thread_status_name(oop java_thread_oop);
 464 
 465   // Debugging
 466   friend class JavaClasses;
 467 };
 468 
 469 // Interface to java.lang.ThreadGroup objects
 470 
 471 class java_lang_ThreadGroup : AllStatic {
 472  private:
 473   static int _parent_offset;
 474   static int _name_offset;
 475   static int _threads_offset;
 476   static int _groups_offset;
 477   static int _maxPriority_offset;
 478   static int _destroyed_offset;
 479   static int _daemon_offset;
 480   static int _nthreads_offset;
 481   static int _ngroups_offset;
 482 
 483   static void compute_offsets();
 484 
 485  public:
 486   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 487 
 488   // parent ThreadGroup
 489   static oop  parent(oop java_thread_group);
 490   // name
 491   static const char* name(oop java_thread_group);
 492   // (&quot;name as oop&quot; accessor is not necessary)
 493   // Number of threads in group
 494   static int nthreads(oop java_thread_group);
 495   // threads
 496   static objArrayOop threads(oop java_thread_group);
 497   // Number of threads in group
 498   static int ngroups(oop java_thread_group);
 499   // groups
 500   static objArrayOop groups(oop java_thread_group);
 501   // maxPriority in group
 502   static ThreadPriority maxPriority(oop java_thread_group);
 503   // Destroyed
 504   static bool is_destroyed(oop java_thread_group);
 505   // Daemon
 506   static bool is_daemon(oop java_thread_group);
 507   // Debugging
 508   friend class JavaClasses;
 509 };
 510 
 511 
 512 
 513 // Interface to java.lang.Throwable objects
 514 
 515 class java_lang_Throwable: AllStatic {
 516   friend class BacktraceBuilder;
 517   friend class BacktraceIterator;
 518 
 519  private:
 520   // Trace constants
 521   enum {
 522     trace_methods_offset = 0,
 523     trace_bcis_offset    = 1,
 524     trace_mirrors_offset = 2,
 525     trace_names_offset   = 3,
 526     trace_next_offset    = 4,
 527     trace_hidden_offset  = 5,
 528     trace_size           = 6,
 529     trace_chunk_size     = 32
 530   };
 531 
 532   static int _backtrace_offset;
 533   static int _detailMessage_offset;
 534   static int _stackTrace_offset;
 535   static int _depth_offset;
 536   static int _static_unassigned_stacktrace_offset;
 537 
 538   // StackTrace (programmatic access, new since 1.4)
 539   static void clear_stacktrace(oop throwable);
 540   // Stacktrace (post JDK 1.7.0 to allow immutability protocol to be followed)
 541   static void set_stacktrace(oop throwable, oop st_element_array);
 542   static oop unassigned_stacktrace();
 543 
 544  public:
 545   // Backtrace
 546   static oop backtrace(oop throwable);
 547   static void set_backtrace(oop throwable, oop value);
 548   static int depth(oop throwable);
 549   static void set_depth(oop throwable, int value);
 550   static int get_detailMessage_offset() { CHECK_INIT(_detailMessage_offset); }
 551   // Message
 552   static oop message(oop throwable);
 553   static void set_message(oop throwable, oop value);
 554   static Symbol* detail_message(oop throwable);
 555   static void print_stack_element(outputStream *st, Method* method, int bci);
 556   static void print_stack_usage(Handle stream);
 557 
 558   static void compute_offsets();
 559   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 560 
 561   // Allocate space for backtrace (created but stack trace not filled in)
 562   static void allocate_backtrace(Handle throwable, TRAPS);
 563   // Fill in current stack trace for throwable with preallocated backtrace (no GC)
 564   static void fill_in_stack_trace_of_preallocated_backtrace(Handle throwable);
 565   // Fill in current stack trace, can cause GC
 566   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS);
 567   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method = methodHandle());
 568   // Programmatic access to stack trace
 569   static void get_stack_trace_elements(Handle throwable, objArrayHandle stack_trace, TRAPS);
 570   // Printing
 571   static void print(oop throwable, outputStream* st);
 572   static void print_stack_trace(Handle throwable, outputStream* st);
 573   static void java_printStackTrace(Handle throwable, TRAPS);
 574   // Debugging
 575   friend class JavaClasses;
 576   // Gets the method and bci of the top frame (TOS). Returns false if this failed.
 577   static bool get_top_method_and_bci(oop throwable, Method** method, int* bci);
 578 };
 579 
 580 
 581 // Interface to java.lang.reflect.AccessibleObject objects
 582 
 583 class java_lang_reflect_AccessibleObject: AllStatic {
 584  private:
 585   // Note that to reduce dependencies on the JDK we compute these
 586   // offsets at run-time.
 587   static int _override_offset;
 588 
 589   static void compute_offsets();
 590 
 591  public:
 592   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 593 
 594   // Accessors
 595   static jboolean override(oop reflect);
 596   static void set_override(oop reflect, jboolean value);
 597 
 598   // Debugging
 599   friend class JavaClasses;
 600 };
 601 
 602 
 603 // Interface to java.lang.reflect.Method objects
 604 
 605 class java_lang_reflect_Method : public java_lang_reflect_AccessibleObject {
 606  private:
 607   // Note that to reduce dependencies on the JDK we compute these
 608   // offsets at run-time.
 609   static int _clazz_offset;
 610   static int _name_offset;
 611   static int _returnType_offset;
 612   static int _parameterTypes_offset;
 613   static int _exceptionTypes_offset;
 614   static int _slot_offset;
 615   static int _modifiers_offset;
 616   static int _signature_offset;
 617   static int _annotations_offset;
 618   static int _parameter_annotations_offset;
 619   static int _annotation_default_offset;
 620 
 621   static void compute_offsets();
 622  public:
 623   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 624 
 625   // Allocation
 626   static Handle create(TRAPS);
 627 
 628   // Accessors
 629   static oop clazz(oop reflect);
 630   static void set_clazz(oop reflect, oop value);
 631 
 632   static void set_name(oop method, oop value);
 633 
 634   static oop return_type(oop method);
 635   static void set_return_type(oop method, oop value);
 636 
 637   static oop parameter_types(oop method);
 638   static void set_parameter_types(oop method, oop value);
 639 
 640   static int slot(oop reflect);
 641   static void set_slot(oop reflect, int value);
 642 
 643   static void set_exception_types(oop method, oop value);
 644   static void set_modifiers(oop method, int value);
 645   static void set_signature(oop method, oop value);
 646   static void set_annotations(oop method, oop value);
 647   static void set_parameter_annotations(oop method, oop value);
 648   static void set_annotation_default(oop method, oop value);
 649 
 650   // Debugging
 651   friend class JavaClasses;
 652 };
 653 
 654 
 655 // Interface to java.lang.reflect.Constructor objects
 656 
 657 class java_lang_reflect_Constructor : public java_lang_reflect_AccessibleObject {
 658  private:
 659   // Note that to reduce dependencies on the JDK we compute these
 660   // offsets at run-time.
 661   static int _clazz_offset;
 662   static int _parameterTypes_offset;
 663   static int _exceptionTypes_offset;
 664   static int _slot_offset;
 665   static int _modifiers_offset;
 666   static int _signature_offset;
 667   static int _annotations_offset;
 668   static int _parameter_annotations_offset;
 669 
 670   static void compute_offsets();
 671  public:
 672   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 673 
 674   // Allocation
 675   static Handle create(TRAPS);
 676 
 677   // Accessors
 678   static oop clazz(oop reflect);
 679   static void set_clazz(oop reflect, oop value);
 680 
 681   static oop parameter_types(oop constructor);
 682   static void set_parameter_types(oop constructor, oop value);
 683 
 684   static int slot(oop reflect);
 685   static void set_slot(oop reflect, int value);
 686 
 687   static void set_exception_types(oop constructor, oop value);
 688   static void set_modifiers(oop constructor, int value);
 689   static void set_signature(oop constructor, oop value);
 690   static void set_annotations(oop constructor, oop value);
 691   static void set_parameter_annotations(oop method, oop value);
 692 
 693   // Debugging
 694   friend class JavaClasses;
 695 };
 696 
 697 
 698 // Interface to java.lang.reflect.Field objects
 699 
 700 class java_lang_reflect_Field : public java_lang_reflect_AccessibleObject {
 701  private:
 702   // Note that to reduce dependencies on the JDK we compute these
 703   // offsets at run-time.
 704   static int _clazz_offset;
 705   static int _name_offset;
 706   static int _type_offset;
 707   static int _slot_offset;
 708   static int _modifiers_offset;
 709   static int _trusted_final_offset;
 710   static int _signature_offset;
 711   static int _annotations_offset;
 712 
 713   static void compute_offsets();
 714 
 715  public:
 716   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 717 
 718   // Allocation
 719   static Handle create(TRAPS);
 720 
 721   // Accessors
 722   static oop clazz(oop reflect);
 723   static void set_clazz(oop reflect, oop value);
 724 
 725   static oop name(oop field);
 726   static void set_name(oop field, oop value);
 727 
 728   static oop type(oop field);
 729   static void set_type(oop field, oop value);
 730 
 731   static int slot(oop reflect);
 732   static void set_slot(oop reflect, int value);
 733 
 734   static int modifiers(oop field);
 735   static void set_modifiers(oop field, int value);
 736 
 737   static void set_trusted_final(oop field);
 738 
 739   static void set_signature(oop constructor, oop value);
 740   static void set_annotations(oop constructor, oop value);
 741   static void set_parameter_annotations(oop method, oop value);
 742   static void set_annotation_default(oop method, oop value);
 743 
 744   // Debugging
 745   friend class JavaClasses;
 746 };
 747 
 748 class java_lang_reflect_Parameter {
 749  private:
 750   // Note that to reduce dependencies on the JDK we compute these
 751   // offsets at run-time.
 752   static int _name_offset;
 753   static int _modifiers_offset;
 754   static int _index_offset;
 755   static int _executable_offset;
 756 
 757   static void compute_offsets();
 758 
 759  public:
 760   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 761 
 762   // Allocation
 763   static Handle create(TRAPS);
 764 
 765   // Accessors
 766   static oop name(oop field);
 767   static void set_name(oop field, oop value);
 768 
 769   static int index(oop reflect);
 770   static void set_index(oop reflect, int value);
 771 
 772   static int modifiers(oop reflect);
 773   static void set_modifiers(oop reflect, int value);
 774 
 775   static oop executable(oop constructor);
 776   static void set_executable(oop constructor, oop value);
 777 
 778   friend class JavaClasses;
 779 };
 780 
 781 #define MODULE_INJECTED_FIELDS(macro)                            \
 782   macro(java_lang_Module, module_entry, intptr_signature, false)
 783 
 784 class java_lang_Module {
 785   private:
 786     static int _loader_offset;
 787     static int _name_offset;
 788     static int _module_entry_offset;
 789 
 790     static void compute_offsets();
 791 
 792   public:
 793     static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 794 
 795     // Allocation
 796     static Handle create(Handle loader, Handle module_name, TRAPS);
 797 
 798     // Testers
 799     static bool is_instance(oop obj);
 800 
 801     // Accessors
 802     static oop loader(oop module);
 803     static void set_loader(oop module, oop value);
 804 
 805     static oop name(oop module);
 806     static void set_name(oop module, oop value);
 807 
 808     static ModuleEntry* module_entry(oop module);
 809     static void set_module_entry(oop module, ModuleEntry* module_entry);
 810 
 811   friend class JavaClasses;
 812 };
 813 
 814 // Interface to jdk.internal.reflect.ConstantPool objects
 815 class reflect_ConstantPool {
 816  private:
 817   // Note that to reduce dependencies on the JDK we compute these
 818   // offsets at run-time.
 819   static int _oop_offset;
 820 
 821   static void compute_offsets();
 822 
 823  public:
 824   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 825 
 826   // Allocation
 827   static Handle create(TRAPS);
 828 
 829   // Accessors
 830   static void set_cp(oop reflect, ConstantPool* value);
 831   static int oop_offset() { CHECK_INIT(_oop_offset); }
 832 
 833   static ConstantPool* get_cp(oop reflect);
 834 
 835   // Debugging
 836   friend class JavaClasses;
 837 };
 838 
 839 // Interface to jdk.internal.reflect.UnsafeStaticFieldAccessorImpl objects
 840 class reflect_UnsafeStaticFieldAccessorImpl {
 841  private:
 842   static int _base_offset;
 843   static void compute_offsets();
 844 
 845  public:
 846   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 847 
 848   static int base_offset() { CHECK_INIT(_base_offset); }
 849 
 850   // Debugging
 851   friend class JavaClasses;
 852 };
 853 
 854 // Interface to java.lang primitive type boxing objects:
 855 //  - java.lang.Boolean
 856 //  - java.lang.Character
 857 //  - java.lang.Float
 858 //  - java.lang.Double
 859 //  - java.lang.Byte
 860 //  - java.lang.Short
 861 //  - java.lang.Integer
 862 //  - java.lang.Long
 863 
 864 // This could be separated out into 8 individual classes.
 865 
 866 class java_lang_boxing_object: AllStatic {
 867  private:
 868   static int _value_offset;
 869   static int _long_value_offset;
 870 
 871   static void compute_offsets();
 872   static oop initialize_and_allocate(BasicType type, TRAPS);
 873  public:
 874   // Allocation. Returns a boxed value, or NULL for invalid type.
 875   static oop create(BasicType type, jvalue* value, TRAPS);
 876   // Accessors. Returns the basic type being boxed, or T_ILLEGAL for invalid oop.
 877   static BasicType get_value(oop box, jvalue* value);
 878   static BasicType set_value(oop box, jvalue* value);
 879   static BasicType basic_type(oop box);
 880   static bool is_instance(oop box)                 { return basic_type(box) != T_ILLEGAL; }
 881   static bool is_instance(oop box, BasicType type) { return basic_type(box) == type; }
 882   static void print(oop box, outputStream* st)     { jvalue value;  print(get_value(box, &amp;value), &amp;value, st); }
 883   static void print(BasicType type, jvalue* value, outputStream* st);
 884 
 885   static int value_offset(BasicType type) {
 886     return is_double_word_type(type) ? _long_value_offset : _value_offset;
 887   }
 888 
 889   static void serialize_offsets(SerializeClosure* f);
 890 
 891   // Debugging
 892   friend class JavaClasses;
 893 };
 894 
 895 
 896 
 897 // Interface to java.lang.ref.Reference objects
 898 
 899 class java_lang_ref_Reference: AllStatic {
 900   static int _referent_offset;
 901   static int _queue_offset;
 902   static int _next_offset;
 903   static int _discovered_offset;
 904 
 905   static bool _offsets_initialized;
 906 
 907  public:
 908   // Accessors
 909   static inline oop referent(oop ref);
 910   static inline void set_referent(oop ref, oop value);
 911   static inline void set_referent_raw(oop ref, oop value);
 912   static inline HeapWord* referent_addr_raw(oop ref);
 913   static inline oop next(oop ref);
 914   static inline void set_next(oop ref, oop value);
 915   static inline void set_next_raw(oop ref, oop value);
 916   static inline HeapWord* next_addr_raw(oop ref);
 917   static inline oop discovered(oop ref);
 918   static inline void set_discovered(oop ref, oop value);
 919   static inline void set_discovered_raw(oop ref, oop value);
 920   static inline HeapWord* discovered_addr_raw(oop ref);
 921   static inline oop queue(oop ref);
 922   static inline void set_queue(oop ref, oop value);
 923   static bool is_referent_field(oop obj, ptrdiff_t offset);
 924   static inline bool is_final(oop ref);
 925   static inline bool is_phantom(oop ref);
 926 
 927   static int referent_offset()    { CHECK_INIT(_referent_offset); }
 928   static int queue_offset()       { CHECK_INIT(_queue_offset); }
 929   static int next_offset()        { CHECK_INIT(_next_offset); }
 930   static int discovered_offset()  { CHECK_INIT(_discovered_offset); }
 931 
 932   static void compute_offsets();
 933   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 934 };
 935 
 936 
 937 // Interface to java.lang.ref.SoftReference objects
 938 
 939 class java_lang_ref_SoftReference: public java_lang_ref_Reference {
 940   static int _timestamp_offset;
 941   static int _static_clock_offset;
 942 
 943  public:
 944   // Accessors
 945   static jlong timestamp(oop ref);
 946 
 947   // Accessors for statics
 948   static jlong clock();
 949   static void set_clock(jlong value);
 950 
 951   static void compute_offsets();
 952   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 953 };
 954 
 955 // Interface to java.lang.invoke.MethodHandle objects
 956 
 957 class MethodHandleEntry;
 958 
 959 class java_lang_invoke_MethodHandle: AllStatic {
 960   friend class JavaClasses;
 961 
 962  private:
 963   static int _type_offset;               // the MethodType of this MH
 964   static int _form_offset;               // the LambdaForm of this MH
 965 
 966   static void compute_offsets();
 967 
 968  public:
 969   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 970 
 971   // Accessors
 972   static oop            type(oop mh);
 973   static void       set_type(oop mh, oop mtype);
 974 
 975   static oop            form(oop mh);
 976   static void       set_form(oop mh, oop lform);
 977 
 978   // Testers
 979   static bool is_subclass(Klass* klass) {
 980     return klass-&gt;is_subclass_of(SystemDictionary::MethodHandle_klass());
 981   }
 982   static bool is_instance(oop obj);
 983 
 984   // Accessors for code generation:
 985   static int type_offset()             { CHECK_INIT(_type_offset); }
 986   static int form_offset()             { CHECK_INIT(_form_offset); }
 987 };
 988 
 989 // Interface to java.lang.invoke.DirectMethodHandle objects
 990 
 991 class java_lang_invoke_DirectMethodHandle: AllStatic {
 992   friend class JavaClasses;
 993 
 994  private:
 995   static int _member_offset;               // the MemberName of this DMH
 996 
 997   static void compute_offsets();
 998 
 999  public:
1000   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1001 
1002   // Accessors
1003   static oop  member(oop mh);
1004 
1005   // Testers
1006   static bool is_subclass(Klass* klass) {
1007     return klass-&gt;is_subclass_of(SystemDictionary::DirectMethodHandle_klass());
1008   }
1009   static bool is_instance(oop obj);
1010 
1011   // Accessors for code generation:
1012   static int member_offset()           { CHECK_INIT(_member_offset); }
1013 };
1014 
1015 // Interface to java.lang.invoke.LambdaForm objects
1016 // (These are a private interface for managing adapter code generation.)
1017 
1018 class java_lang_invoke_LambdaForm: AllStatic {
1019   friend class JavaClasses;
1020 
1021  private:
1022   static int _vmentry_offset;  // type is MemberName
1023 
1024   static void compute_offsets();
1025 
1026  public:
1027   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1028 
1029   // Accessors
1030   static oop            vmentry(oop lform);
1031   static void       set_vmentry(oop lform, oop invoker);
1032 
1033   // Testers
1034   static bool is_subclass(Klass* klass) {
1035     return SystemDictionary::LambdaForm_klass() != NULL &amp;&amp;
1036       klass-&gt;is_subclass_of(SystemDictionary::LambdaForm_klass());
1037   }
1038   static bool is_instance(oop obj);
1039 
1040   // Accessors for code generation:
1041   static int vmentry_offset()          { CHECK_INIT(_vmentry_offset); }
1042 };
1043 
1044 
1045 // Interface to java.lang.invoke.MemberName objects
1046 // (These are a private interface for Java code to query the class hierarchy.)
1047 
1048 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
1049   macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \
1050   macro(java_lang_invoke_ResolvedMethodName, vmtarget, intptr_signature, false)
1051 
1052 class java_lang_invoke_ResolvedMethodName : AllStatic {
1053   friend class JavaClasses;
1054 
1055   static int _vmtarget_offset;
1056   static int _vmholder_offset;
1057 
1058   static void compute_offsets();
1059  public:
1060   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1061 
1062   static int vmtarget_offset() { CHECK_INIT(_vmtarget_offset); }
1063 
1064   static Method* vmtarget(oop resolved_method);
1065   static void set_vmtarget(oop resolved_method, Method* method);
1066 
1067   static void set_vmholder(oop resolved_method, oop holder);
1068 
1069   // find or create resolved member name
1070   static oop find_resolved_method(const methodHandle&amp; m, TRAPS);
1071 
1072   static bool is_instance(oop resolved_method);
1073 };
1074 
1075 
1076 #define MEMBERNAME_INJECTED_FIELDS(macro)                               \
1077   macro(java_lang_invoke_MemberName, vmindex,  intptr_signature, false)
1078 
1079 
1080 class java_lang_invoke_MemberName: AllStatic {
1081   friend class JavaClasses;
1082 
1083  private:
1084   // From java.lang.invoke.MemberName:
1085   //    private Class&lt;?&gt;   clazz;       // class in which the method is defined
1086   //    private String     name;        // may be null if not yet materialized
1087   //    private Object     type;        // may be null if not yet materialized
1088   //    private int        flags;       // modifier bits; see reflect.Modifier
1089   //    private ResolvedMethodName method;    // holds VM-specific target value
1090   //    private intptr_t   vmindex;     // member index within class or interface
1091   static int _clazz_offset;
1092   static int _name_offset;
1093   static int _type_offset;
1094   static int _flags_offset;
1095   static int _method_offset;
1096   static int _vmindex_offset;
1097 
1098   static void compute_offsets();
1099 
1100  public:
1101   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1102   // Accessors
1103   static oop            clazz(oop mname);
1104   static void       set_clazz(oop mname, oop clazz);
1105 
1106   static oop            type(oop mname);
1107   static void       set_type(oop mname, oop type);
1108 
1109   static oop            name(oop mname);
1110   static void       set_name(oop mname, oop name);
1111 
1112   static int            flags(oop mname);
1113   static void       set_flags(oop mname, int flags);
1114 
1115   // Link through ResolvedMethodName field to get Method*
1116   static Method*        vmtarget(oop mname);
1117   static void       set_method(oop mname, oop method);
1118 
1119   static intptr_t       vmindex(oop mname);
1120   static void       set_vmindex(oop mname, intptr_t index);
1121 
1122   // Testers
1123   static bool is_subclass(Klass* klass) {
1124     return klass-&gt;is_subclass_of(SystemDictionary::MemberName_klass());
1125   }
1126   static bool is_instance(oop obj);
1127 
1128   static bool is_method(oop obj);
1129 
1130   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
1131   enum {
1132     MN_IS_METHOD             = 0x00010000, // method (not constructor)
1133     MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, // constructor
1134     MN_IS_FIELD              = 0x00040000, // field
1135     MN_IS_TYPE               = 0x00080000, // nested type
1136     MN_CALLER_SENSITIVE      = 0x00100000, // @CallerSensitive annotation detected
1137     MN_TRUSTED_FINAL         = 0x00200000, // trusted final field
1138     MN_REFERENCE_KIND_SHIFT  = 24, // refKind
1139     MN_REFERENCE_KIND_MASK   = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,
1140     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
1141     MN_SEARCH_SUPERCLASSES   = 0x00100000, // walk super classes
1142     MN_SEARCH_INTERFACES     = 0x00200000, // walk implemented interfaces
1143     MN_NESTMATE_CLASS        = 0x00000001,
1144     MN_HIDDEN_CLASS          = 0x00000002,
1145     MN_STRONG_LOADER_LINK    = 0x00000004,
1146     MN_ACCESS_VM_ANNOTATIONS = 0x00000008
1147   };
1148 
1149   // Accessors for code generation:
1150   static int clazz_offset()   { CHECK_INIT(_clazz_offset); }
1151   static int type_offset()    { CHECK_INIT(_type_offset); }
1152   static int flags_offset()   { CHECK_INIT(_flags_offset); }
1153   static int method_offset()  { CHECK_INIT(_method_offset); }
1154   static int vmindex_offset() { CHECK_INIT(_vmindex_offset); }
1155 };
1156 
1157 
1158 // Interface to java.lang.invoke.MethodType objects
1159 
1160 class java_lang_invoke_MethodType: AllStatic {
1161   friend class JavaClasses;
1162 
1163  private:
1164   static int _rtype_offset;
1165   static int _ptypes_offset;
1166 
1167   static void compute_offsets();
1168 
1169  public:
1170   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1171   // Accessors
1172   static oop            rtype(oop mt);
1173   static objArrayOop    ptypes(oop mt);
1174 
1175   static oop            ptype(oop mt, int index);
1176   static int            ptype_count(oop mt);
1177 
1178   static int            ptype_slot_count(oop mt);  // extra counts for long/double
1179   static int            rtype_slot_count(oop mt);  // extra counts for long/double
1180 
1181   static Symbol*        as_signature(oop mt, bool intern_if_not_found);
1182   static void           print_signature(oop mt, outputStream* st);
1183 
1184   static bool is_instance(oop obj);
1185 
1186   static bool equals(oop mt1, oop mt2);
1187 
1188   // Accessors for code generation:
1189   static int rtype_offset()  { CHECK_INIT(_rtype_offset); }
1190   static int ptypes_offset() { CHECK_INIT(_ptypes_offset); }
1191 };
1192 
1193 
1194 // Interface to java.lang.invoke.CallSite objects
1195 
1196 class java_lang_invoke_CallSite: AllStatic {
1197   friend class JavaClasses;
1198 
1199 private:
1200   static int _target_offset;
1201   static int _context_offset;
1202 
1203   static void compute_offsets();
1204 
1205 public:
1206   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1207   // Accessors
1208   static oop              target(          oop site);
1209   static void         set_target(          oop site, oop target);
1210   static void         set_target_volatile( oop site, oop target);
1211 
1212   static oop context_no_keepalive(oop site);
1213 
1214   // Testers
1215   static bool is_subclass(Klass* klass) {
1216     return klass-&gt;is_subclass_of(SystemDictionary::CallSite_klass());
1217   }
1218   static bool is_instance(oop obj);
1219 
1220   // Accessors for code generation:
1221   static int target_offset()  { CHECK_INIT(_target_offset); }
1222   static int context_offset() { CHECK_INIT(_context_offset); }
1223 };
1224 
1225 // Interface to java.lang.invoke.ConstantCallSite objects
1226 
1227 class java_lang_invoke_ConstantCallSite: AllStatic {
1228   friend class JavaClasses;
1229 
1230 private:
1231   static int _is_frozen_offset;
1232 
1233   static void compute_offsets();
1234 
1235 public:
1236   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1237   // Accessors
1238   static jboolean is_frozen(oop site);
1239 
1240   // Testers
1241   static bool is_subclass(Klass* klass) {
1242     return klass-&gt;is_subclass_of(SystemDictionary::ConstantCallSite_klass());
1243   }
1244   static bool is_instance(oop obj);
1245 };
1246 
1247 // Interface to java.lang.invoke.MethodHandleNatives$CallSiteContext objects
1248 
1249 #define CALLSITECONTEXT_INJECTED_FIELDS(macro) \
1250   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, vmdependencies, intptr_signature, false) \
1251   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, last_cleanup, long_signature, false)
1252 
1253 class DependencyContext;
1254 
1255 class java_lang_invoke_MethodHandleNatives_CallSiteContext : AllStatic {
1256   friend class JavaClasses;
1257 
1258 private:
1259   static int _vmdependencies_offset;
1260   static int _last_cleanup_offset;
1261 
1262   static void compute_offsets();
1263 
1264 public:
1265   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1266   // Accessors
1267   static DependencyContext vmdependencies(oop context);
1268 
1269   // Testers
1270   static bool is_subclass(Klass* klass) {
1271     return klass-&gt;is_subclass_of(SystemDictionary::Context_klass());
1272   }
1273   static bool is_instance(oop obj);
1274 };
1275 
1276 // Interface to java.security.AccessControlContext objects
1277 
1278 class java_security_AccessControlContext: AllStatic {
1279  private:
1280   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
1281   // so we compute the offsets at startup rather than hard-wiring them.
1282   static int _context_offset;
1283   static int _privilegedContext_offset;
1284   static int _isPrivileged_offset;
1285   static int _isAuthorized_offset;
1286 
1287   static void compute_offsets();
1288  public:
1289   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1290   static oop create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS);
1291 
1292   // Debugging/initialization
1293   friend class JavaClasses;
1294 };
1295 
1296 
1297 // Interface to java.lang.ClassLoader objects
1298 
1299 #define CLASSLOADER_INJECTED_FIELDS(macro)                            \
1300   macro(java_lang_ClassLoader, loader_data,  intptr_signature, false)
1301 
1302 class java_lang_ClassLoader : AllStatic {
1303  private:
1304   static int _loader_data_offset;
1305   static int _parent_offset;
1306   static int _parallelCapable_offset;
1307   static int _name_offset;
1308   static int _nameAndId_offset;
1309   static int _unnamedModule_offset;
1310 
1311   static void compute_offsets();
1312 
1313  public:
1314   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1315 
1316   static ClassLoaderData* loader_data_acquire(oop loader);
1317   static ClassLoaderData* loader_data_raw(oop loader);
1318   static void release_set_loader_data(oop loader, ClassLoaderData* new_data);
1319 
1320   static oop parent(oop loader);
1321   static oop name(oop loader);
1322   static oop nameAndId(oop loader);
1323   static bool isAncestor(oop loader, oop cl);
1324 
1325   // Support for parallelCapable field
1326   static bool parallelCapable(oop the_class_mirror);
1327 
1328   static bool is_trusted_loader(oop loader);
1329 
1330   // Return true if this is one of the class loaders associated with
1331   // the generated bytecodes for reflection.
1332   static bool is_reflection_class_loader(oop loader);
1333 
1334   // Fix for 4474172
1335   static oop  non_reflection_class_loader(oop loader);
1336 
1337   // Testers
1338   static bool is_subclass(Klass* klass) {
1339     return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass());
1340   }
1341   static bool is_instance(oop obj);
1342 
1343   static oop unnamedModule(oop loader);
1344 
1345   // Debugging
1346   friend class JavaClasses;
1347 };
1348 
1349 
1350 // Interface to java.lang.System objects
1351 
1352 class java_lang_System : AllStatic {
1353  private:
1354   static int _static_in_offset;
1355   static int _static_out_offset;
1356   static int _static_err_offset;
1357   static int _static_security_offset;
1358 
1359  public:
1360   static int  in_offset() { CHECK_INIT(_static_in_offset); }
1361   static int out_offset() { CHECK_INIT(_static_out_offset); }
1362   static int err_offset() { CHECK_INIT(_static_err_offset); }
1363 
1364   static void compute_offsets();
1365   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1366 
1367   // Debugging
1368   friend class JavaClasses;
1369 };
1370 
1371 
1372 // Interface to java.lang.StackTraceElement objects
1373 
1374 class java_lang_StackTraceElement: AllStatic {
1375  private:
1376   static int _declaringClassObject_offset;
1377   static int _classLoaderName_offset;
1378   static int _moduleName_offset;
1379   static int _moduleVersion_offset;
1380   static int _declaringClass_offset;
1381   static int _methodName_offset;
1382   static int _fileName_offset;
1383   static int _lineNumber_offset;
1384 
1385   // Setters
1386   static void set_classLoaderName(oop element, oop value);
1387   static void set_moduleName(oop element, oop value);
1388   static void set_moduleVersion(oop element, oop value);
1389   static void set_declaringClass(oop element, oop value);
1390   static void set_methodName(oop element, oop value);
1391   static void set_fileName(oop element, oop value);
1392   static void set_lineNumber(oop element, int value);
1393   static void set_declaringClassObject(oop element, oop value);
1394 
1395   static void decode_file_and_line(Handle java_mirror, InstanceKlass* holder, int version,
1396                                    const methodHandle&amp; method, int bci,
1397                                    Symbol*&amp; source, oop&amp; source_file, int&amp; line_number, TRAPS);
1398 
1399  public:
1400   // Create an instance of StackTraceElement
1401   static oop create(const methodHandle&amp; method, int bci, TRAPS);
1402 
1403   static void fill_in(Handle element, InstanceKlass* holder, const methodHandle&amp; method,
1404                       int version, int bci, Symbol* name, TRAPS);
1405 
1406   static void compute_offsets();
1407   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1408 
1409 #if INCLUDE_JVMCI
1410   static void decode(const methodHandle&amp; method, int bci, Symbol*&amp; fileName, int&amp; lineNumber, TRAPS);
1411 #endif
1412 
1413   // Debugging
1414   friend class JavaClasses;
1415 };
1416 
1417 
1418 class Backtrace: AllStatic {
1419  public:
1420   // Helper backtrace functions to store bci|version together.
1421   static int merge_bci_and_version(int bci, int version);
1422   static int merge_mid_and_cpref(int mid, int cpref);
1423   static int bci_at(unsigned int merged);
1424   static int version_at(unsigned int merged);
1425   static int mid_at(unsigned int merged);
1426   static int cpref_at(unsigned int merged);
1427   static int get_line_number(Method* method, int bci);
1428   static Symbol* get_source_file_name(InstanceKlass* holder, int version);
1429 
1430   // Debugging
1431   friend class JavaClasses;
1432 };
1433 
1434 // Interface to java.lang.StackFrameInfo objects
1435 
1436 #define STACKFRAMEINFO_INJECTED_FIELDS(macro)                      \
1437   macro(java_lang_StackFrameInfo, version, short_signature, false)
1438 
1439 class java_lang_StackFrameInfo: AllStatic {
1440 private:
1441   static int _memberName_offset;
1442   static int _bci_offset;
1443   static int _version_offset;
1444 
1445   static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);
1446 
1447 public:
1448   // Setters
1449   static void set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS);
1450   static void set_bci(oop info, int value);
1451 
1452   static void set_version(oop info, short value);
1453 
1454   static void compute_offsets();
1455   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1456 
1457   static void to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS);
1458 
1459   // Debugging
1460   friend class JavaClasses;
1461 };
1462 
1463 class java_lang_LiveStackFrameInfo: AllStatic {
1464  private:
1465   static int _monitors_offset;
1466   static int _locals_offset;
1467   static int _operands_offset;
1468   static int _mode_offset;
1469 
1470  public:
1471   static void set_monitors(oop info, oop value);
1472   static void set_locals(oop info, oop value);
1473   static void set_operands(oop info, oop value);
1474   static void set_mode(oop info, int value);
1475 
1476   static void compute_offsets();
1477   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1478 
1479   // Debugging
1480   friend class JavaClasses;
1481 };
1482 
1483 // Interface to java.lang.reflect.RecordComponent objects
1484 
1485 class java_lang_reflect_RecordComponent: AllStatic {
1486  private:
1487   static int _clazz_offset;
1488   static int _name_offset;
1489   static int _type_offset;
1490   static int _accessor_offset;
1491   static int _signature_offset;
1492   static int _annotations_offset;
1493   static int _typeAnnotations_offset;
1494 
1495   // Setters
1496   static void set_clazz(oop element, oop value);
1497   static void set_name(oop element, oop value);
1498   static void set_type(oop element, oop value);
1499   static void set_accessor(oop element, oop value);
1500   static void set_signature(oop element, oop value);
1501   static void set_annotations(oop element, oop value);
1502   static void set_typeAnnotations(oop element, oop value);
1503 
1504  public:
1505   // Create an instance of RecordComponent
1506   static oop create(InstanceKlass* holder, RecordComponent* component, TRAPS);
1507 
1508   static void compute_offsets();
1509   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1510 
1511   // Debugging
1512   friend class JavaClasses;
1513 };
1514 
1515 
1516 // Interface to java.lang.AssertionStatusDirectives objects
1517 
1518 class java_lang_AssertionStatusDirectives: AllStatic {
1519  private:
1520   static int _classes_offset;
1521   static int _classEnabled_offset;
1522   static int _packages_offset;
1523   static int _packageEnabled_offset;
1524   static int _deflt_offset;
1525 
1526  public:
1527   // Setters
1528   static void set_classes(oop obj, oop val);
1529   static void set_classEnabled(oop obj, oop val);
1530   static void set_packages(oop obj, oop val);
1531   static void set_packageEnabled(oop obj, oop val);
1532   static void set_deflt(oop obj, bool val);
1533 
1534   static void compute_offsets();
1535   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1536 
1537   // Debugging
1538   friend class JavaClasses;
1539 };
1540 
1541 
1542 class java_nio_Buffer: AllStatic {
1543  private:
1544   static int _limit_offset;
1545 
1546  public:
1547   static int  limit_offset() { CHECK_INIT(_limit_offset); }
1548   static void compute_offsets();
1549   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1550 };
1551 
1552 class java_util_concurrent_locks_AbstractOwnableSynchronizer : AllStatic {
1553  private:
1554   static int  _owner_offset;
1555  public:
1556   static void compute_offsets();
1557   static oop  get_owner_threadObj(oop obj);
1558   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1559 };
1560 
1561  // Interface to jdk.internal.misc.UnsafeConsants
1562 
1563 class jdk_internal_misc_UnsafeConstants : AllStatic {
1564  public:
1565   static void set_unsafe_constants();
1566   static void compute_offsets() { }
1567   static void serialize_offsets(SerializeClosure* f) { }
1568 };
1569 
1570 class java_lang_Integer : AllStatic {
1571 public:
1572   static jint value(oop obj);
1573 };
1574 
1575 class java_lang_Long : AllStatic {
1576 public:
1577   static jlong value(oop obj);
1578 };
1579 
1580 class java_lang_Character : AllStatic {
1581 public:
1582   static jchar value(oop obj);
1583 };
1584 
1585 class java_lang_Short : AllStatic {
1586 public:
1587   static jshort value(oop obj);
1588 };
1589 
1590 class java_lang_Byte : AllStatic {
1591 public:
1592   static jbyte value(oop obj);
1593 };
1594 
1595 class java_lang_Boolean : AllStatic {
1596  private:
1597   static int _static_TRUE_offset;
1598   static int _static_FALSE_offset;
1599  public:
1600   static Symbol* symbol();
1601   static void compute_offsets(InstanceKlass* k);
1602   static oop  get_TRUE(InstanceKlass *k);
1603   static oop  get_FALSE(InstanceKlass *k);
1604   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1605   static jboolean value(oop obj);
1606 };
1607 
1608 class java_lang_Integer_IntegerCache : AllStatic {
1609  private:
1610   static int _static_cache_offset;
1611  public:
1612   static Symbol* symbol();
1613   static void compute_offsets(InstanceKlass* k);
1614   static objArrayOop  cache(InstanceKlass *k);
1615   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1616 };
1617 
1618 class java_lang_Long_LongCache : AllStatic {
1619  private:
1620   static int _static_cache_offset;
1621  public:
1622   static Symbol* symbol();
1623   static void compute_offsets(InstanceKlass* k);
1624   static objArrayOop  cache(InstanceKlass *k);
1625   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1626 };
1627 
1628 class java_lang_Character_CharacterCache : AllStatic {
1629  private:
1630   static int _static_cache_offset;
1631  public:
1632   static Symbol* symbol();
1633   static void compute_offsets(InstanceKlass* k);
1634   static objArrayOop  cache(InstanceKlass *k);
1635   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1636 };
1637 
1638 class java_lang_Short_ShortCache : AllStatic {
1639  private:
1640   static int _static_cache_offset;
1641  public:
1642   static Symbol* symbol();
1643   static void compute_offsets(InstanceKlass* k);
1644   static objArrayOop  cache(InstanceKlass *k);
1645   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1646 };
1647 
1648 class java_lang_Byte_ByteCache : AllStatic {
1649  private:
1650   static int _static_cache_offset;
1651  public:
1652   static Symbol* symbol();
1653   static void compute_offsets(InstanceKlass* k);
1654   static objArrayOop  cache(InstanceKlass *k);
1655   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1656 };
1657 
1658 class jdk_internal_vm_jni_SubElementSelector : AllStatic {
1659  private:
1660   static int _arrayElementType_offset;
1661   static int _subElementType_offset;
1662   static int _offset_offset;
1663   static int _isInlined_offset;
1664   static int _isInlineType_offset;
1665  public:
1666   static Symbol* symbol();
1667   static void compute_offsets();
1668   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1669 
1670   static oop getArrayElementType(oop obj);
1671   static void setArrayElementType(oop obj, oop type);
1672   static oop getSubElementType(oop obj);
1673   static void setSubElementType(oop obj, oop type);
1674   static int getOffset(oop obj);
1675   static void setOffset(oop obj, int offset);
1676   static bool getIsInlined(oop obj);
1677   static void setIsInlined(oop obj, bool b);
1678   static bool getIsInlineType(oop obj);
1679   static void setIsInlineType(oop obj, bool b);
1680 };
1681 
1682 // Use to declare fields that need to be injected into Java classes
1683 // for the JVM to use.  The name_index and signature_index are
1684 // declared in vmSymbols.  The may_be_java flag is used to declare
1685 // fields that might already exist in Java but should be injected if
1686 // they don&#39;t.  Otherwise the field is unconditionally injected and
1687 // the JVM uses the injected one.  This is to ensure that name
1688 // collisions don&#39;t occur.  In general may_be_java should be false
1689 // unless there&#39;s a good reason.
1690 
1691 class InjectedField {
1692  public:
1693   const SystemDictionary::WKID klass_id;
1694   const vmSymbols::SID name_index;
1695   const vmSymbols::SID signature_index;
1696   const bool           may_be_java;
1697 
1698 
1699   Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }
1700   Symbol* name() const      { return lookup_symbol(name_index); }
1701   Symbol* signature() const { return lookup_symbol(signature_index); }
1702 
1703   int compute_offset();
1704 
1705   // Find the Symbol for this index
1706   static Symbol* lookup_symbol(int symbol_index) {
1707     return vmSymbols::symbol_at((vmSymbols::SID)symbol_index);
1708   }
1709 };
1710 
1711 #define DECLARE_INJECTED_FIELD_ENUM(klass, name, signature, may_be_java) \
1712   klass##_##name##_enum,
1713 
1714 #define ALL_INJECTED_FIELDS(macro)          \
1715   CLASS_INJECTED_FIELDS(macro)              \
1716   CLASSLOADER_INJECTED_FIELDS(macro)        \
1717   RESOLVEDMETHOD_INJECTED_FIELDS(macro)     \
1718   MEMBERNAME_INJECTED_FIELDS(macro)         \
1719   CALLSITECONTEXT_INJECTED_FIELDS(macro)    \
1720   STACKFRAMEINFO_INJECTED_FIELDS(macro)     \
1721   MODULE_INJECTED_FIELDS(macro)
1722 
1723 // Interface to hard-coded offset checking
1724 
1725 class JavaClasses : AllStatic {
1726  private:
1727 
1728   static InjectedField _injected_fields[];
1729 
1730   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1731  public:
1732   enum InjectedFieldID {
1733     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1734     MAX_enum
1735   };
1736 
1737   static int compute_injected_offset(InjectedFieldID id);
1738 
1739   static void compute_offsets();
1740   static void check_offsets() PRODUCT_RETURN;
1741   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1742   static InjectedField* get_injected(Symbol* class_name, int* field_count);
1743   static bool is_supported_for_archiving(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(false);
1744 };
1745 
1746 #undef DECLARE_INJECTED_FIELD_ENUM
1747 
1748 #undef CHECK_INIT
1749 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
    </pre>
  </body>
</html>