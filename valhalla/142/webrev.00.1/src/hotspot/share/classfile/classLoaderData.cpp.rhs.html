<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/classLoaderData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1  /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // A ClassLoaderData identifies the full set of class types that a class
 26 // loader&#39;s name resolution strategy produces for a given configuration of the
 27 // class loader.
 28 // Class types in the ClassLoaderData may be defined by from class file binaries
 29 // provided by the class loader, or from other class loader it interacts with
 30 // according to its name resolution strategy.
 31 //
 32 // Class loaders that implement a deterministic name resolution strategy
 33 // (including with respect to their delegation behavior), such as the boot, the
 34 // platform, and the system loaders of the JDK&#39;s built-in class loader
 35 // hierarchy, always produce the same linkset for a given configuration.
 36 //
 37 // ClassLoaderData carries information related to a linkset (e.g.,
 38 // metaspace holding its klass definitions).
 39 // The System Dictionary and related data structures (e.g., placeholder table,
 40 // loader constraints table) as well as the runtime representation of classes
 41 // only reference ClassLoaderData.
 42 //
 43 // Instances of java.lang.ClassLoader holds a pointer to a ClassLoaderData that
 44 // that represent the loader&#39;s &quot;linking domain&quot; in the JVM.
 45 //
 46 // The bootstrap loader (represented by NULL) also has a ClassLoaderData,
 47 // the singleton class the_null_class_loader_data().
 48 
 49 #include &quot;precompiled.hpp&quot;
 50 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 51 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
 52 #include &quot;classfile/dictionary.hpp&quot;
 53 #include &quot;classfile/javaClasses.hpp&quot;
 54 #include &quot;classfile/moduleEntry.hpp&quot;
 55 #include &quot;classfile/packageEntry.hpp&quot;
 56 #include &quot;classfile/symbolTable.hpp&quot;
 57 #include &quot;classfile/systemDictionary.hpp&quot;
 58 #include &quot;gc/shared/oopStorageSet.hpp&quot;
 59 #include &quot;logging/log.hpp&quot;
 60 #include &quot;logging/logStream.hpp&quot;
 61 #include &quot;memory/allocation.inline.hpp&quot;
 62 #include &quot;memory/metadataFactory.hpp&quot;
 63 #include &quot;memory/resourceArea.hpp&quot;
 64 #include &quot;oops/access.inline.hpp&quot;
 65 #include &quot;oops/oop.inline.hpp&quot;
 66 #include &quot;oops/oopHandle.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 67 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
 68 #include &quot;oops/weakHandle.inline.hpp&quot;
 69 #include &quot;runtime/atomic.hpp&quot;
 70 #include &quot;runtime/handles.inline.hpp&quot;
 71 #include &quot;runtime/mutex.hpp&quot;
 72 #include &quot;runtime/safepoint.hpp&quot;
 73 #include &quot;utilities/growableArray.hpp&quot;
 74 #include &quot;utilities/macros.hpp&quot;
 75 #include &quot;utilities/ostream.hpp&quot;
 76 
 77 ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = NULL;
 78 
 79 void ClassLoaderData::init_null_class_loader_data() {
 80   assert(_the_null_class_loader_data == NULL, &quot;cannot initialize twice&quot;);
 81   assert(ClassLoaderDataGraph::_head == NULL, &quot;cannot initialize twice&quot;);
 82 
 83   _the_null_class_loader_data = new ClassLoaderData(Handle(), false);
 84   ClassLoaderDataGraph::_head = _the_null_class_loader_data;
 85   assert(_the_null_class_loader_data-&gt;is_the_null_class_loader_data(), &quot;Must be&quot;);
 86 
 87   LogTarget(Trace, class, loader, data) lt;
 88   if (lt.is_enabled()) {
 89     ResourceMark rm;
 90     LogStream ls(lt);
 91     ls.print(&quot;create &quot;);
 92     _the_null_class_loader_data-&gt;print_value_on(&amp;ls);
 93     ls.cr();
 94   }
 95 }
 96 
 97 // Obtain and set the class loader&#39;s name within the ClassLoaderData so
 98 // it will be available for error messages, logging, JFR, etc.  The name
 99 // and klass are available after the class_loader oop is no longer alive,
100 // during unloading.
101 void ClassLoaderData::initialize_name(Handle class_loader) {
102   Thread* THREAD = Thread::current();
103   ResourceMark rm(THREAD);
104 
105   // Obtain the class loader&#39;s name.  If the class loader&#39;s name was not
106   // explicitly set during construction, the CLD&#39;s _name field will be null.
107   oop cl_name = java_lang_ClassLoader::name(class_loader());
108   if (cl_name != NULL) {
109     const char* cl_instance_name = java_lang_String::as_utf8_string(cl_name);
110 
111     if (cl_instance_name != NULL &amp;&amp; cl_instance_name[0] != &#39;\0&#39;) {
112       _name = SymbolTable::new_symbol(cl_instance_name);
113     }
114   }
115 
116   // Obtain the class loader&#39;s name and identity hash.  If the class loader&#39;s
117   // name was not explicitly set during construction, the class loader&#39;s name and id
118   // will be set to the qualified class name of the class loader along with its
119   // identity hash.
120   // If for some reason the ClassLoader&#39;s constructor has not been run, instead of
121   // leaving the _name_and_id field null, fall back to the external qualified class
122   // name.  Thus CLD&#39;s _name_and_id field should never have a null value.
123   oop cl_name_and_id = java_lang_ClassLoader::nameAndId(class_loader());
124   const char* cl_instance_name_and_id =
125                   (cl_name_and_id == NULL) ? _class_loader_klass-&gt;external_name() :
126                                              java_lang_String::as_utf8_string(cl_name_and_id);
127   assert(cl_instance_name_and_id != NULL &amp;&amp; cl_instance_name_and_id[0] != &#39;\0&#39;, &quot;class loader has no name and id&quot;);
128   _name_and_id = SymbolTable::new_symbol(cl_instance_name_and_id);
129 }
130 
131 ClassLoaderData::ClassLoaderData(Handle h_class_loader, bool has_class_mirror_holder) :
132   _metaspace(NULL),
133   _metaspace_lock(new Mutex(Mutex::leaf+1, &quot;Metaspace allocation lock&quot;, true,
134                             Mutex::_safepoint_check_never)),
135   _unloading(false), _has_class_mirror_holder(has_class_mirror_holder),
136   _modified_oops(true), _accumulated_modified_oops(false),
137   // An unsafe anonymous class loader data doesn&#39;t have anything to keep
138   // it from being unloaded during parsing of the unsafe anonymous class.
139   // The null-class-loader should always be kept alive.
140   _keep_alive((has_class_mirror_holder || h_class_loader.is_null()) ? 1 : 0),
141   _claim(0),
142   _handles(),
143   _klasses(NULL), _packages(NULL), _modules(NULL), _unnamed_module(NULL), _dictionary(NULL),
144   _jmethod_ids(NULL),
145   _deallocate_list(NULL),
146   _next(NULL),
147   _class_loader_klass(NULL), _name(NULL), _name_and_id(NULL) {
148 
149   if (!h_class_loader.is_null()) {
150     _class_loader = _handles.add(h_class_loader());
151     _class_loader_klass = h_class_loader-&gt;klass();
152     initialize_name(h_class_loader);
153   }
154 
155   if (!has_class_mirror_holder) {
156     // The holder is initialized later for non-strong hidden classes and unsafe anonymous classes,
157     // and before calling anything that call class_loader().
158     initialize_holder(h_class_loader);
159 
160     // A ClassLoaderData created solely for a non-strong hidden class or unsafe anonymous class should
161     // never have a ModuleEntryTable or PackageEntryTable created for it. The defining package
162     // and module for an unsafe anonymous class will be found in its host class.
163     _packages = new PackageEntryTable(PackageEntryTable::_packagetable_entry_size);
164     if (h_class_loader.is_null()) {
165       // Create unnamed module for boot loader
166       _unnamed_module = ModuleEntry::create_boot_unnamed_module(this);
167     } else {
168       // Create unnamed module for all other loaders
169       _unnamed_module = ModuleEntry::create_unnamed_module(this);
170     }
171     _dictionary = create_dictionary();
172   }
173 
174   NOT_PRODUCT(_dependency_count = 0); // number of class loader dependencies
175 
176   JFR_ONLY(INIT_ID(this);)
177 }
178 
179 ClassLoaderData::ChunkedHandleList::~ChunkedHandleList() {
180   Chunk* c = _head;
181   while (c != NULL) {
182     Chunk* next = c-&gt;_next;
183     delete c;
184     c = next;
185   }
186 }
187 
188 OopHandle ClassLoaderData::ChunkedHandleList::add(oop o) {
189   if (_head == NULL || _head-&gt;_size == Chunk::CAPACITY) {
190     Chunk* next = new Chunk(_head);
191     Atomic::release_store(&amp;_head, next);
192   }
193   oop* handle = &amp;_head-&gt;_data[_head-&gt;_size];
194   NativeAccess&lt;IS_DEST_UNINITIALIZED&gt;::oop_store(handle, o);
195   Atomic::release_store(&amp;_head-&gt;_size, _head-&gt;_size + 1);
196   return OopHandle(handle);
197 }
198 
199 int ClassLoaderData::ChunkedHandleList::count() const {
200   int count = 0;
201   Chunk* chunk = _head;
202   while (chunk != NULL) {
203     count += chunk-&gt;_size;
204     chunk = chunk-&gt;_next;
205   }
206   return count;
207 }
208 
209 inline void ClassLoaderData::ChunkedHandleList::oops_do_chunk(OopClosure* f, Chunk* c, const juint size) {
210   for (juint i = 0; i &lt; size; i++) {
211     if (c-&gt;_data[i] != NULL) {
212       f-&gt;do_oop(&amp;c-&gt;_data[i]);
213     }
214   }
215 }
216 
217 void ClassLoaderData::ChunkedHandleList::oops_do(OopClosure* f) {
218   Chunk* head = Atomic::load_acquire(&amp;_head);
219   if (head != NULL) {
220     // Must be careful when reading size of head
221     oops_do_chunk(f, head, Atomic::load_acquire(&amp;head-&gt;_size));
222     for (Chunk* c = head-&gt;_next; c != NULL; c = c-&gt;_next) {
223       oops_do_chunk(f, c, c-&gt;_size);
224     }
225   }
226 }
227 
228 class VerifyContainsOopClosure : public OopClosure {
229   oop  _target;
230   bool _found;
231 
232  public:
233   VerifyContainsOopClosure(oop target) : _target(target), _found(false) {}
234 
235   void do_oop(oop* p) {
236     if (p != NULL &amp;&amp; NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(p) == _target) {
237       _found = true;
238     }
239   }
240 
241   void do_oop(narrowOop* p) {
242     // The ChunkedHandleList should not contain any narrowOop
243     ShouldNotReachHere();
244   }
245 
246   bool found() const {
247     return _found;
248   }
249 };
250 
251 bool ClassLoaderData::ChunkedHandleList::contains(oop p) {
252   VerifyContainsOopClosure cl(p);
253   oops_do(&amp;cl);
254   return cl.found();
255 }
256 
257 #ifndef PRODUCT
258 bool ClassLoaderData::ChunkedHandleList::owner_of(oop* oop_handle) {
259   Chunk* chunk = _head;
260   while (chunk != NULL) {
261     if (&amp;(chunk-&gt;_data[0]) &lt;= oop_handle &amp;&amp; oop_handle &lt; &amp;(chunk-&gt;_data[chunk-&gt;_size])) {
262       return true;
263     }
264     chunk = chunk-&gt;_next;
265   }
266   return false;
267 }
268 #endif // PRODUCT
269 
270 void ClassLoaderData::clear_claim(int claim) {
271   for (;;) {
272     int old_claim = Atomic::load(&amp;_claim);
273     if ((old_claim &amp; claim) == 0) {
274       return;
275     }
276     int new_claim = old_claim &amp; ~claim;
277     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {
278       return;
279     }
280   }
281 }
282 
283 bool ClassLoaderData::try_claim(int claim) {
284   for (;;) {
285     int old_claim = Atomic::load(&amp;_claim);
286     if ((old_claim &amp; claim) == claim) {
287       return false;
288     }
289     int new_claim = old_claim | claim;
290     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {
291       return true;
292     }
293   }
294 }
295 
296 // Weak hidden and unsafe anonymous classes have their own ClassLoaderData that is marked to keep alive
297 // while the class is being parsed, and if the class appears on the module fixup list.
298 // Due to the uniqueness that no other class shares the hidden or unsafe anonymous class&#39; name or
299 // ClassLoaderData, no other non-GC thread has knowledge of the hidden or unsafe anonymous class while
300 // it is being defined, therefore _keep_alive is not volatile or atomic.
301 void ClassLoaderData::inc_keep_alive() {
302   if (has_class_mirror_holder()) {
303     assert(_keep_alive &gt; 0, &quot;Invalid keep alive increment count&quot;);
304     _keep_alive++;
305   }
306 }
307 
308 void ClassLoaderData::dec_keep_alive() {
309   if (has_class_mirror_holder()) {
310     assert(_keep_alive &gt; 0, &quot;Invalid keep alive decrement count&quot;);
311     _keep_alive--;
312   }
313 }
314 
315 void ClassLoaderData::oops_do(OopClosure* f, int claim_value, bool clear_mod_oops) {
316   if (claim_value != ClassLoaderData::_claim_none &amp;&amp; !try_claim(claim_value)) {
317     return;
318   }
319 
320   // Only clear modified_oops after the ClassLoaderData is claimed.
321   if (clear_mod_oops) {
322     clear_modified_oops();
323   }
324 
325   _handles.oops_do(f);
326 }
327 
328 void ClassLoaderData::classes_do(KlassClosure* klass_closure) {
329   // Lock-free access requires load_acquire
330   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
331     klass_closure-&gt;do_klass(k);
332     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
333   }
334 }
335 
336 void ClassLoaderData::classes_do(void f(Klass * const)) {
337   // Lock-free access requires load_acquire
338   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
339     f(k);
340     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
341   }
342 }
343 
344 void ClassLoaderData::methods_do(void f(Method*)) {
345   // Lock-free access requires load_acquire
346   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
347     if (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;is_loaded()) {
348       InstanceKlass::cast(k)-&gt;methods_do(f);
349     }
350   }
351 }
352 
353 void ClassLoaderData::loaded_classes_do(KlassClosure* klass_closure) {
354   // Lock-free access requires load_acquire
355   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
356     // Do not filter ArrayKlass oops here...
357     if (k-&gt;is_array_klass() || (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;is_loaded())) {
358 #ifdef ASSERT
359       oop m = k-&gt;java_mirror();
360       assert(m != NULL, &quot;NULL mirror&quot;);
361       assert(m-&gt;is_a(SystemDictionary::Class_klass()), &quot;invalid mirror&quot;);
362 #endif
363       klass_closure-&gt;do_klass(k);
364     }
365   }
366 }
367 
368 void ClassLoaderData::classes_do(void f(InstanceKlass*)) {
369   // Lock-free access requires load_acquire
370   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
371     if (k-&gt;is_instance_klass()) {
372       f(InstanceKlass::cast(k));
373     }
374     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
375   }
376 }
377 
<a name="2" id="anc2"></a><span class="line-added">378 void ClassLoaderData::inline_classes_do(void f(InlineKlass*)) {</span>
<span class="line-added">379   // Lock-free access requires load_acquire</span>
<span class="line-added">380   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
<span class="line-added">381     if (k-&gt;is_inline_klass()) {</span>
<span class="line-added">382       f(InlineKlass::cast(k));</span>
<span class="line-added">383     }</span>
<span class="line-added">384     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);</span>
<span class="line-added">385   }</span>
<span class="line-added">386 }</span>
<span class="line-added">387 </span>
388 void ClassLoaderData::modules_do(void f(ModuleEntry*)) {
389   assert_locked_or_safepoint(Module_lock);
390   if (_unnamed_module != NULL) {
391     f(_unnamed_module);
392   }
393   if (_modules != NULL) {
394     for (int i = 0; i &lt; _modules-&gt;table_size(); i++) {
395       for (ModuleEntry* entry = _modules-&gt;bucket(i);
396            entry != NULL;
397            entry = entry-&gt;next()) {
398         f(entry);
399       }
400     }
401   }
402 }
403 
404 void ClassLoaderData::packages_do(void f(PackageEntry*)) {
405   assert_locked_or_safepoint(Module_lock);
406   if (_packages != NULL) {
407     for (int i = 0; i &lt; _packages-&gt;table_size(); i++) {
408       for (PackageEntry* entry = _packages-&gt;bucket(i);
409            entry != NULL;
410            entry = entry-&gt;next()) {
411         f(entry);
412       }
413     }
414   }
415 }
416 
417 void ClassLoaderData::record_dependency(const Klass* k) {
418   assert(k != NULL, &quot;invariant&quot;);
419 
420   ClassLoaderData * const from_cld = this;
421   ClassLoaderData * const to_cld = k-&gt;class_loader_data();
422 
423   // Do not need to record dependency if the dependency is to a class whose
424   // class loader data is never freed.  (i.e. the dependency&#39;s class loader
425   // is one of the three builtin class loaders and the dependency&#39;s class
426   // loader data has a ClassLoader holder, not a Class holder.)
427   if (to_cld-&gt;is_permanent_class_loader_data()) {
428     return;
429   }
430 
431   oop to;
432   if (to_cld-&gt;has_class_mirror_holder()) {
433     // Just return if a non-strong hidden class or unsafe anonymous class is attempting to record a dependency
434     // to itself.  (Note that every non-strong hidden class or unsafe anonymous class has its own unique class
435     // loader data.)
436     if (to_cld == from_cld) {
437       return;
438     }
439     // Hidden and unsafe anonymous class dependencies are through the mirror.
440     to = k-&gt;java_mirror();
441   } else {
442     to = to_cld-&gt;class_loader();
443     oop from = from_cld-&gt;class_loader();
444 
445     // Just return if this dependency is to a class with the same or a parent
446     // class_loader.
447     if (from == to || java_lang_ClassLoader::isAncestor(from, to)) {
448       return; // this class loader is in the parent list, no need to add it.
449     }
450   }
451 
452   // It&#39;s a dependency we won&#39;t find through GC, add it.
453   if (!_handles.contains(to)) {
454     NOT_PRODUCT(Atomic::inc(&amp;_dependency_count));
455     LogTarget(Trace, class, loader, data) lt;
456     if (lt.is_enabled()) {
457       ResourceMark rm;
458       LogStream ls(lt);
459       ls.print(&quot;adding dependency from &quot;);
460       print_value_on(&amp;ls);
461       ls.print(&quot; to &quot;);
462       to_cld-&gt;print_value_on(&amp;ls);
463       ls.cr();
464     }
465     Handle dependency(Thread::current(), to);
466     add_handle(dependency);
467     // Added a potentially young gen oop to the ClassLoaderData
468     record_modified_oops();
469   }
470 }
471 
472 void ClassLoaderData::add_class(Klass* k, bool publicize /* true */) {
473   {
474     MutexLocker ml(metaspace_lock(), Mutex::_no_safepoint_check_flag);
475     Klass* old_value = _klasses;
476     k-&gt;set_next_link(old_value);
477     // Link the new item into the list, making sure the linked class is stable
478     // since the list can be walked without a lock
479     Atomic::release_store(&amp;_klasses, k);
480     if (k-&gt;is_array_klass()) {
481       ClassLoaderDataGraph::inc_array_classes(1);
482     } else {
483       ClassLoaderDataGraph::inc_instance_classes(1);
484     }
485   }
486 
487   if (publicize) {
488     LogTarget(Trace, class, loader, data) lt;
489     if (lt.is_enabled()) {
490       ResourceMark rm;
491       LogStream ls(lt);
492       ls.print(&quot;Adding k: &quot; PTR_FORMAT &quot; %s to &quot;, p2i(k), k-&gt;external_name());
493       print_value_on(&amp;ls);
494       ls.cr();
495     }
496   }
497 }
498 
499 void ClassLoaderData::initialize_holder(Handle loader_or_mirror) {
500   if (loader_or_mirror() != NULL) {
501     assert(_holder.is_null(), &quot;never replace holders&quot;);
502     _holder = WeakHandle(OopStorageSet::vm_weak(), loader_or_mirror);
503   }
504 }
505 
506 // Remove a klass from the _klasses list for scratch_class during redefinition
507 // or parsed class in the case of an error.
508 void ClassLoaderData::remove_class(Klass* scratch_class) {
509   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
510 
511   // Adjust global class iterator.
512   ClassLoaderDataGraph::adjust_saved_class(scratch_class);
513 
514   Klass* prev = NULL;
515   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
516     if (k == scratch_class) {
517       if (prev == NULL) {
518         _klasses = k-&gt;next_link();
519       } else {
520         Klass* next = k-&gt;next_link();
521         prev-&gt;set_next_link(next);
522       }
523 
524       if (k-&gt;is_array_klass()) {
525         ClassLoaderDataGraph::dec_array_classes(1);
526       } else {
527         ClassLoaderDataGraph::dec_instance_classes(1);
528       }
529 
530       return;
531     }
532     prev = k;
533     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
534   }
535   ShouldNotReachHere();   // should have found this class!!
536 }
537 
538 void ClassLoaderData::unload() {
539   _unloading = true;
540 
541   LogTarget(Trace, class, loader, data) lt;
542   if (lt.is_enabled()) {
543     ResourceMark rm;
544     LogStream ls(lt);
545     ls.print(&quot;unload&quot;);
546     print_value_on(&amp;ls);
547     ls.cr();
548   }
549 
550   // Some items on the _deallocate_list need to free their C heap structures
551   // if they are not already on the _klasses list.
552   free_deallocate_list_C_heap_structures();
553 
<a name="3" id="anc3"></a><span class="line-added">554   inline_classes_do(InlineKlass::cleanup);</span>
<span class="line-added">555 </span>
556   // Clean up class dependencies and tell serviceability tools
557   // these classes are unloading.  Must be called
558   // after erroneous classes are released.
559   classes_do(InstanceKlass::unload_class);
560 
561   // Clean up global class iterator for compiler
562   ClassLoaderDataGraph::adjust_saved_class(this);
563 }
564 
565 ModuleEntryTable* ClassLoaderData::modules() {
566   // Lazily create the module entry table at first request.
567   // Lock-free access requires load_acquire.
568   ModuleEntryTable* modules = Atomic::load_acquire(&amp;_modules);
569   if (modules == NULL) {
570     MutexLocker m1(Module_lock);
571     // Check if _modules got allocated while we were waiting for this lock.
572     if ((modules = _modules) == NULL) {
573       modules = new ModuleEntryTable(ModuleEntryTable::_moduletable_entry_size);
574 
575       {
576         MutexLocker m1(metaspace_lock(), Mutex::_no_safepoint_check_flag);
577         // Ensure _modules is stable, since it is examined without a lock
578         Atomic::release_store(&amp;_modules, modules);
579       }
580     }
581   }
582   return modules;
583 }
584 
585 const int _boot_loader_dictionary_size    = 1009;
586 const int _default_loader_dictionary_size = 107;
587 
588 Dictionary* ClassLoaderData::create_dictionary() {
589   assert(!has_class_mirror_holder(), &quot;class mirror holder cld does not have a dictionary&quot;);
590   int size;
591   bool resizable = false;
592   if (_the_null_class_loader_data == NULL) {
593     size = _boot_loader_dictionary_size;
594     resizable = true;
595   } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
596     size = 1;  // there&#39;s only one class in relection class loader and no initiated classes
597   } else if (is_system_class_loader_data()) {
598     size = _boot_loader_dictionary_size;
599     resizable = true;
600   } else {
601     size = _default_loader_dictionary_size;
602     resizable = true;
603   }
604   if (!DynamicallyResizeSystemDictionaries || DumpSharedSpaces) {
605     resizable = false;
606   }
607   return new Dictionary(this, size, resizable);
608 }
609 
610 // Tell the GC to keep this klass alive while iterating ClassLoaderDataGraph
611 oop ClassLoaderData::holder_phantom() const {
612   // A klass that was previously considered dead can be looked up in the
613   // CLD/SD, and its _java_mirror or _class_loader can be stored in a root
614   // or a reachable object making it alive again. The SATB part of G1 needs
615   // to get notified about this potential resurrection, otherwise the marking
616   // might not find the object.
617   if (!_holder.is_null()) {  // NULL class_loader
618     return _holder.resolve();
619   } else {
620     return NULL;
621   }
622 }
623 
624 // Let the GC read the holder without keeping it alive.
625 oop ClassLoaderData::holder_no_keepalive() const {
626   if (!_holder.is_null()) {  // NULL class_loader
627     return _holder.peek();
628   } else {
629     return NULL;
630   }
631 }
632 
633 // Unloading support
634 bool ClassLoaderData::is_alive() const {
635   bool alive = keep_alive()         // null class loader and incomplete non-strong hidden class or unsafe anonymous class.
636       || (_holder.peek() != NULL);  // and not cleaned by the GC weak handle processing.
637 
638   return alive;
639 }
640 
641 class ReleaseKlassClosure: public KlassClosure {
642 private:
643   size_t  _instance_class_released;
644   size_t  _array_class_released;
645 public:
646   ReleaseKlassClosure() : _instance_class_released(0), _array_class_released(0) { }
647 
648   size_t instance_class_released() const { return _instance_class_released; }
649   size_t array_class_released()    const { return _array_class_released;    }
650 
651   void do_klass(Klass* k) {
652     if (k-&gt;is_array_klass()) {
653       _array_class_released ++;
654     } else {
655       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
656       _instance_class_released ++;
657     }
658     k-&gt;release_C_heap_structures();
659   }
660 };
661 
662 ClassLoaderData::~ClassLoaderData() {
663   // Release C heap structures for all the classes.
664   ReleaseKlassClosure cl;
665   classes_do(&amp;cl);
666 
667   ClassLoaderDataGraph::dec_array_classes(cl.array_class_released());
668   ClassLoaderDataGraph::dec_instance_classes(cl.instance_class_released());
669 
670   // Release the WeakHandle
671   _holder.release(OopStorageSet::vm_weak());
672 
673   // Release C heap allocated hashtable for all the packages.
674   if (_packages != NULL) {
675     // Destroy the table itself
676     delete _packages;
677     _packages = NULL;
678   }
679 
680   // Release C heap allocated hashtable for all the modules.
681   if (_modules != NULL) {
682     // Destroy the table itself
683     delete _modules;
684     _modules = NULL;
685   }
686 
687   // Release C heap allocated hashtable for the dictionary
688   if (_dictionary != NULL) {
689     // Destroy the table itself
690     delete _dictionary;
691     _dictionary = NULL;
692   }
693 
694   if (_unnamed_module != NULL) {
695     _unnamed_module-&gt;delete_unnamed_module();
696     _unnamed_module = NULL;
697   }
698 
699   // release the metaspace
700   ClassLoaderMetaspace *m = _metaspace;
701   if (m != NULL) {
702     _metaspace = NULL;
703     delete m;
704   }
705   // Clear all the JNI handles for methods
706   // These aren&#39;t deallocated and are going to look like a leak, but that&#39;s
707   // needed because we can&#39;t really get rid of jmethodIDs because we don&#39;t
708   // know when native code is going to stop using them.  The spec says that
709   // they&#39;re &quot;invalid&quot; but existing programs likely rely on their being
710   // NULL after class unloading.
711   if (_jmethod_ids != NULL) {
712     Method::clear_jmethod_ids(this);
713   }
714   // Delete lock
715   delete _metaspace_lock;
716 
717   // Delete free list
718   if (_deallocate_list != NULL) {
719     delete _deallocate_list;
720   }
721 
722   // Decrement refcounts of Symbols if created.
723   if (_name != NULL) {
724     _name-&gt;decrement_refcount();
725   }
726   if (_name_and_id != NULL) {
727     _name_and_id-&gt;decrement_refcount();
728   }
729 }
730 
731 // Returns true if this class loader data is for the app class loader
732 // or a user defined system class loader.  (Note that the class loader
733 // data may have a Class holder.)
734 bool ClassLoaderData::is_system_class_loader_data() const {
735   return SystemDictionary::is_system_class_loader(class_loader());
736 }
737 
738 // Returns true if this class loader data is for the platform class loader.
739 // (Note that the class loader data may have a Class holder.)
740 bool ClassLoaderData::is_platform_class_loader_data() const {
741   return SystemDictionary::is_platform_class_loader(class_loader());
742 }
743 
744 // Returns true if the class loader for this class loader data is one of
745 // the 3 builtin (boot application/system or platform) class loaders,
746 // including a user-defined system class loader.  Note that if the class
747 // loader data is for a non-strong hidden class or unsafe anonymous class then it may
748 // get freed by a GC even if its class loader is one of these loaders.
749 bool ClassLoaderData::is_builtin_class_loader_data() const {
750   return (is_boot_class_loader_data() ||
751           SystemDictionary::is_system_class_loader(class_loader()) ||
752           SystemDictionary::is_platform_class_loader(class_loader()));
753 }
754 
755 // Returns true if this class loader data is a class loader data
756 // that is not ever freed by a GC.  It must be the CLD for one of the builtin
757 // class loaders and not the CLD for a non-strong hidden class or unsafe anonymous class.
758 bool ClassLoaderData::is_permanent_class_loader_data() const {
759   return is_builtin_class_loader_data() &amp;&amp; !has_class_mirror_holder();
760 }
761 
762 ClassLoaderMetaspace* ClassLoaderData::metaspace_non_null() {
763   // If the metaspace has not been allocated, create a new one.  Might want
764   // to create smaller arena for Reflection class loaders also.
765   // The reason for the delayed allocation is because some class loaders are
766   // simply for delegating with no metadata of their own.
767   // Lock-free access requires load_acquire.
768   ClassLoaderMetaspace* metaspace = Atomic::load_acquire(&amp;_metaspace);
769   if (metaspace == NULL) {
770     MutexLocker ml(_metaspace_lock,  Mutex::_no_safepoint_check_flag);
771     // Check if _metaspace got allocated while we were waiting for this lock.
772     if ((metaspace = _metaspace) == NULL) {
773       if (this == the_null_class_loader_data()) {
774         assert (class_loader() == NULL, &quot;Must be&quot;);
775         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::BootMetaspaceType);
776       } else if (has_class_mirror_holder()) {
777         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ClassMirrorHolderMetaspaceType);
778       } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
779         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);
780       } else {
781         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::StandardMetaspaceType);
782       }
783       // Ensure _metaspace is stable, since it is examined without a lock
784       Atomic::release_store(&amp;_metaspace, metaspace);
785     }
786   }
787   return metaspace;
788 }
789 
790 OopHandle ClassLoaderData::add_handle(Handle h) {
791   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
792   record_modified_oops();
793   return _handles.add(h());
794 }
795 
796 void ClassLoaderData::remove_handle(OopHandle h) {
797   assert(!is_unloading(), &quot;Do not remove a handle for a CLD that is unloading&quot;);
798   oop* ptr = h.ptr_raw();
799   if (ptr != NULL) {
800     assert(_handles.owner_of(ptr), &quot;Got unexpected handle &quot; PTR_FORMAT, p2i(ptr));
801     NativeAccess&lt;&gt;::oop_store(ptr, oop(NULL));
802   }
803 }
804 
805 void ClassLoaderData::init_handle_locked(OopHandle&amp; dest, Handle h) {
806   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
807   if (dest.resolve() != NULL) {
808     return;
809   } else {
810     dest = _handles.add(h());
811   }
812 }
813 
814 // Add this metadata pointer to be freed when it&#39;s safe.  This is only during
815 // a safepoint which checks if handles point to this metadata field.
816 void ClassLoaderData::add_to_deallocate_list(Metadata* m) {
817   // Metadata in shared region isn&#39;t deleted.
818   if (!m-&gt;is_shared()) {
819     MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
820     if (_deallocate_list == NULL) {
821       _deallocate_list = new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Metadata*&gt;(100, mtClass);
822     }
823     _deallocate_list-&gt;append_if_missing(m);
824     log_debug(class, loader, data)(&quot;deallocate added for %s&quot;, m-&gt;print_value_string());
825     ClassLoaderDataGraph::set_should_clean_deallocate_lists();
826   }
827 }
828 
829 // Deallocate free metadata on the free list.  How useful the PermGen was!
830 void ClassLoaderData::free_deallocate_list() {
831   // This must be called at a safepoint because it depends on metadata walking at
832   // safepoint cleanup time.
833   assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
834   assert(!is_unloading(), &quot;only called for ClassLoaderData that are not unloading&quot;);
835   if (_deallocate_list == NULL) {
836     return;
837   }
838   // Go backwards because this removes entries that are freed.
839   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
840     Metadata* m = _deallocate_list-&gt;at(i);
841     if (!m-&gt;on_stack()) {
842       _deallocate_list-&gt;remove_at(i);
843       // There are only three types of metadata that we deallocate directly.
844       // Cast them so they can be used by the template function.
845       if (m-&gt;is_method()) {
846         MetadataFactory::free_metadata(this, (Method*)m);
847       } else if (m-&gt;is_constantPool()) {
848         MetadataFactory::free_metadata(this, (ConstantPool*)m);
849       } else if (m-&gt;is_klass()) {
<a name="4" id="anc4"></a><span class="line-modified">850         if (!((Klass*)m)-&gt;is_inline_klass()) {</span>
<span class="line-added">851           MetadataFactory::free_metadata(this, (InstanceKlass*)m);</span>
<span class="line-added">852         } else {</span>
<span class="line-added">853           MetadataFactory::free_metadata(this, (InlineKlass*)m);</span>
<span class="line-added">854         }</span>
855       } else {
856         ShouldNotReachHere();
857       }
858     } else {
859       // Metadata is alive.
860       // If scratch_class is on stack then it shouldn&#39;t be on this list!
861       assert(!m-&gt;is_klass() || !((InstanceKlass*)m)-&gt;is_scratch_class(),
862              &quot;scratch classes on this list should be dead&quot;);
863       // Also should assert that other metadata on the list was found in handles.
864       // Some cleaning remains.
865       ClassLoaderDataGraph::set_should_clean_deallocate_lists();
866     }
867   }
868 }
869 
870 // This is distinct from free_deallocate_list.  For class loader data that are
871 // unloading, this frees the C heap memory for items on the list, and unlinks
872 // scratch or error classes so that unloading events aren&#39;t triggered for these
873 // classes. The metadata is removed with the unloading metaspace.
874 // There isn&#39;t C heap memory allocated for methods, so nothing is done for them.
875 void ClassLoaderData::free_deallocate_list_C_heap_structures() {
876   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
877   assert(is_unloading(), &quot;only called for ClassLoaderData that are unloading&quot;);
878   if (_deallocate_list == NULL) {
879     return;
880   }
881   // Go backwards because this removes entries that are freed.
882   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
883     Metadata* m = _deallocate_list-&gt;at(i);
884     _deallocate_list-&gt;remove_at(i);
885     if (m-&gt;is_constantPool()) {
886       ((ConstantPool*)m)-&gt;release_C_heap_structures();
887     } else if (m-&gt;is_klass()) {
888       InstanceKlass* ik = (InstanceKlass*)m;
889       // also releases ik-&gt;constants() C heap memory
890       ik-&gt;release_C_heap_structures();
891       // Remove the class so unloading events aren&#39;t triggered for
892       // this class (scratch or error class) in do_unloading().
893       remove_class(ik);
894     }
895   }
896 }
897 
898 // Caller needs ResourceMark
899 // If the class loader&#39;s _name has not been explicitly set, the class loader&#39;s
900 // qualified class name is returned.
901 const char* ClassLoaderData::loader_name() const {
902    if (_class_loader_klass == NULL) {
903      return BOOTSTRAP_LOADER_NAME;
904    } else if (_name != NULL) {
905      return _name-&gt;as_C_string();
906    } else {
907      return _class_loader_klass-&gt;external_name();
908    }
909 }
910 
911 // Caller needs ResourceMark
912 // Format of the _name_and_id is as follows:
913 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
914 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
915 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
916 const char* ClassLoaderData::loader_name_and_id() const {
917   if (_class_loader_klass == NULL) {
918     return &quot;&#39;&quot; BOOTSTRAP_LOADER_NAME &quot;&#39;&quot;;
919   } else if (_name_and_id != NULL) {
920     return _name_and_id-&gt;as_C_string();
921   } else {
922     // May be called in a race before _name_and_id is initialized.
923     return _class_loader_klass-&gt;external_name();
924   }
925 }
926 
927 void ClassLoaderData::print_value_on(outputStream* out) const {
928   if (!is_unloading() &amp;&amp; class_loader() != NULL) {
929     out-&gt;print(&quot;loader data: &quot; INTPTR_FORMAT &quot; for instance &quot;, p2i(this));
930     class_loader()-&gt;print_value_on(out);  // includes loader_name_and_id() and address of class loader instance
931   } else {
932     // loader data: 0xsomeaddr of &#39;bootstrap&#39;
933     out-&gt;print(&quot;loader data: &quot; INTPTR_FORMAT &quot; of %s&quot;, p2i(this), loader_name_and_id());
934   }
935   if (_has_class_mirror_holder) {
936     out-&gt;print(&quot; has a class holder&quot;);
937   }
938 }
939 
940 void ClassLoaderData::print_value() const { print_value_on(tty); }
941 
942 #ifndef PRODUCT
943 void ClassLoaderData::print_on(outputStream* out) const {
944   out-&gt;print(&quot;ClassLoaderData CLD: &quot; PTR_FORMAT &quot;, loader: &quot; PTR_FORMAT &quot;, loader_klass: %s {&quot;,
945               p2i(this), p2i(_class_loader.ptr_raw()), loader_name_and_id());
946   if (has_class_mirror_holder()) out-&gt;print(&quot; has a class holder&quot;);
947   if (claimed()) out-&gt;print(&quot; claimed&quot;);
948   if (is_unloading()) out-&gt;print(&quot; unloading&quot;);
949   out-&gt;print(&quot; metaspace: &quot; INTPTR_FORMAT, p2i(metaspace_or_null()));
950 
951   if (_jmethod_ids != NULL) {
952     Method::print_jmethod_ids(this, out);
953   }
954   out-&gt;print(&quot; handles count %d&quot;, _handles.count());
955   out-&gt;print(&quot; dependencies %d&quot;, _dependency_count);
956   out-&gt;print_cr(&quot;}&quot;);
957 }
958 #endif // PRODUCT
959 
960 void ClassLoaderData::print() const { print_on(tty); }
961 
962 void ClassLoaderData::verify() {
963   assert_locked_or_safepoint(_metaspace_lock);
964   oop cl = class_loader();
965 
966   guarantee(this == class_loader_data(cl) || has_class_mirror_holder(), &quot;Must be the same&quot;);
967   guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), &quot;must be&quot;);
968 
969   // Verify the integrity of the allocated space.
970   if (metaspace_or_null() != NULL) {
971     metaspace_or_null()-&gt;verify();
972   }
973 
974   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
975     guarantee(k-&gt;class_loader_data() == this, &quot;Must be the same&quot;);
976     k-&gt;verify();
977     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
978   }
979 }
980 
981 bool ClassLoaderData::contains_klass(Klass* klass) {
982   // Lock-free access requires load_acquire
983   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
984     if (k == klass) return true;
985   }
986   return false;
987 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>