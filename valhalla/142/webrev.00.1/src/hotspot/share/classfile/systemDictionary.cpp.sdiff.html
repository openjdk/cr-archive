<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  50 #include &quot;interpreter/bytecodeStream.hpp&quot;
  51 #include &quot;interpreter/interpreter.hpp&quot;
  52 #include &quot;jfr/jfrEvents.hpp&quot;
  53 #include &quot;logging/log.hpp&quot;
  54 #include &quot;logging/logStream.hpp&quot;
  55 #include &quot;memory/filemap.hpp&quot;
  56 #include &quot;memory/heapShared.hpp&quot;
  57 #include &quot;memory/metaspaceClosure.hpp&quot;
  58 #include &quot;memory/oopFactory.hpp&quot;
  59 #include &quot;memory/resourceArea.hpp&quot;
  60 #include &quot;memory/universe.hpp&quot;
  61 #include &quot;oops/access.inline.hpp&quot;

  62 #include &quot;oops/instanceKlass.hpp&quot;
  63 #include &quot;oops/instanceRefKlass.hpp&quot;
  64 #include &quot;oops/klass.inline.hpp&quot;
  65 #include &quot;oops/method.inline.hpp&quot;
  66 #include &quot;oops/methodData.hpp&quot;
  67 #include &quot;oops/objArrayKlass.hpp&quot;
  68 #include &quot;oops/objArrayOop.inline.hpp&quot;
  69 #include &quot;oops/oop.inline.hpp&quot;
  70 #include &quot;oops/oopHandle.inline.hpp&quot;
  71 #include &quot;oops/symbol.hpp&quot;
  72 #include &quot;oops/typeArrayKlass.hpp&quot;

  73 #include &quot;prims/jvmtiExport.hpp&quot;
  74 #include &quot;prims/methodHandles.hpp&quot;
  75 #include &quot;runtime/arguments.hpp&quot;
  76 #include &quot;runtime/biasedLocking.hpp&quot;
  77 #include &quot;runtime/handles.inline.hpp&quot;
  78 #include &quot;runtime/java.hpp&quot;
  79 #include &quot;runtime/javaCalls.hpp&quot;
  80 #include &quot;runtime/mutexLocker.hpp&quot;

  81 #include &quot;runtime/sharedRuntime.hpp&quot;
  82 #include &quot;runtime/signature.hpp&quot;
  83 #include &quot;services/classLoadingService.hpp&quot;
  84 #include &quot;services/diagnosticCommand.hpp&quot;
  85 #include &quot;services/threadService.hpp&quot;
  86 #include &quot;utilities/macros.hpp&quot;
  87 #include &quot;utilities/utf8.hpp&quot;
  88 #if INCLUDE_CDS
  89 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  90 #endif
  91 #if INCLUDE_JFR
  92 #include &quot;jfr/jfr.hpp&quot;
  93 #endif
  94 
  95 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  96 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  97 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
  98 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
  99 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 100 
</pre>
<hr />
<pre>
 308 
 309 
 310 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 311 
 312 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 313   if (Signature::is_array(class_name)) {
 314     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 315   } else {
 316     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 317   }
 318 }
 319 
 320 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 321 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 322                                                                        Handle class_loader,
 323                                                                        Handle protection_domain,
 324                                                                        TRAPS) {
 325   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 326   if (Signature::has_envelope(class_name)) {
 327     ResourceMark rm(THREAD);
<span class="line-modified"> 328     // Ignore wrapping L and ;.</span>
 329     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 330                                                  class_name-&gt;utf8_length() - 2);
 331     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 332   } else {
 333     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 334   }
 335 }
 336 
 337 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 338   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 339 }
 340 
 341 // Forwards to resolve_instance_class_or_null
 342 
 343 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 344                                                      Handle class_loader,
 345                                                      Handle protection_domain,
 346                                                      TRAPS) {
 347   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 348   ResourceMark rm(THREAD);
 349   SignatureStream ss(class_name, false);
 350   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 351   Klass* k = NULL;
 352   BasicType t = ss.type();
 353   if (ss.has_envelope()) {
 354     Symbol* obj_class = ss.as_symbol();
 355     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 356                                                          class_loader,
 357                                                          protection_domain,
 358                                                          CHECK_NULL);
 359     if (k != NULL) {




 360       k = k-&gt;array_klass(ndims, CHECK_NULL);
 361     }
 362   } else {
 363     k = Universe::typeArrayKlassObj(t);
 364     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);
 365   }
 366   return k;
 367 }
 368 
<span class="line-removed"> 369 </span>
 370 // Must be called for any super-class or super-interface resolution
 371 // during class definition to allow class circularity checking
 372 // super-interface callers:
 373 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 374 // super-class callers:
 375 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 376 //   load_shared_class - while loading a class from shared archive
 377 //   resolve_instance_class_or_null:
 378 //     via: handle_parallel_super_load
 379 //      when resolving a class that has an existing placeholder with
 380 //      a saved superclass [i.e. a defineClass is currently in progress]
 381 //      if another thread is trying to resolve the class, it must do
 382 //      super-class checks on its own thread to catch class circularity
 383 // This last call is critical in class circularity checking for cases
 384 // where classloading is delegated to different threads and the
 385 // classloader lock is released.
 386 // Take the case: Base-&gt;Super-&gt;Base
 387 //   1. If thread T1 tries to do a defineClass of class Base
 388 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 389 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
</pre>
<hr />
<pre>
 493   // The instanceKlass is kept alive because the class loader is on the stack,
 494   // which keeps the loader_data alive, as well as all instanceKlasses in
 495   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 496   {
 497     MutexLocker mu(THREAD, SystemDictionary_lock);
 498     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 499     SystemDictionary_lock-&gt;notify_all();
 500   }
 501   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 502     // can null superk
 503     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 504     assert(k == NULL || k == superk, &quot;must be&quot;);
 505     if (k == NULL) {
 506       superk = NULL;
 507     }
 508   }
 509 
 510   return superk;
 511 }
 512 













































 513 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 514                                                   Handle class_loader,
 515                                                   Handle protection_domain,
 516                                                   TRAPS) {
 517   // Now we have to call back to java to check if the initating class has access
 518   JavaValue result(T_VOID);
 519   LogTarget(Debug, protectiondomain) lt;
 520   if (lt.is_enabled()) {
 521     ResourceMark rm(THREAD);
 522     // Print out trace information
 523     LogStream ls(lt);
 524     ls.print_cr(&quot;Checking package access&quot;);
 525     if (class_loader() != NULL) {
 526       ls.print(&quot;class loader: &quot;);
 527       class_loader()-&gt;print_value_on(&amp;ls);
 528     } else {
 529       ls.print_cr(&quot;class loader: NULL&quot;);
 530     }
 531     if (protection_domain() != NULL) {
 532       ls.print(&quot; protection domain: &quot;);
</pre>
<hr />
<pre>
1021                           protection_domain);
1022 }
1023 
1024 
1025 // Look for a loaded instance or array klass by name.  Do not do any loading.
1026 // return NULL in case of error.
1027 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
1028                                                       Handle class_loader,
1029                                                       Handle protection_domain,
1030                                                       TRAPS) {
1031   Klass* k = NULL;
1032   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1033 
1034   if (Signature::is_array(class_name)) {
1035     // The name refers to an array.  Parse the name.
1036     // dimension and object_key in FieldArrayInfo are assigned as a
1037     // side-effect of this call
1038     SignatureStream ss(class_name, false);
1039     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1040     BasicType t = ss.type();
<span class="line-modified">1041     if (t != T_OBJECT) {</span>
1042       k = Universe::typeArrayKlassObj(t);
1043     } else {
1044       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1045     }
1046     if (k != NULL) {
1047       k = k-&gt;array_klass_or_null(ndims);
1048     }
1049   } else {
1050     k = find(class_name, class_loader, protection_domain, THREAD);
1051   }
1052   return k;
1053 }
1054 
1055 // Note: this method is much like resolve_from_stream, but
1056 // does not publish the classes via the SystemDictionary.
1057 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
1058 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.
1059 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1060                                               Handle class_loader,
1061                                               ClassFileStream* st,
</pre>
<hr />
<pre>
1405 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1406                                                    Handle class_loader,
1407                                                    Handle protection_domain,
1408                                                    const ClassFileStream *cfs,
1409                                                    PackageEntry* pkg_entry,
1410                                                    TRAPS) {
1411   assert(ik != NULL, &quot;sanity&quot;);
1412   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1413   Symbol* class_name = ik-&gt;name();
1414 
1415   bool visible = is_shared_class_visible(
1416                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1417   if (!visible) {
1418     return NULL;
1419   }
1420 
1421   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1422     return NULL;
1423   }
1424 


















1425   InstanceKlass* new_ik = NULL;
1426   // CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).
1427   // It will be skipped for shared VM hidden lambda proxy classes.
1428   if (!SystemDictionaryShared::is_hidden_lambda_proxy(ik)) {
1429     new_ik = KlassFactory::check_shared_class_file_load_hook(
1430       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1431   }
1432   if (new_ik != NULL) {
1433     // The class is changed by CFLH. Return the new class. The shared class is
1434     // not used.
1435     return new_ik;
1436   }
1437 
1438   // Adjust methods to recover missing data.  They need addresses for
1439   // interpreter entry points and their default native method address
1440   // must be reset.
1441 
1442   // Updating methods must be done under a lock so multiple
1443   // threads don&#39;t update these in parallel
1444   //
1445   // Shared classes are all currently loaded by either the bootstrap or
1446   // internal parallel class loaders, so this will never cause a deadlock
1447   // on a custom class loader lock.
1448 
1449   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1450   {
1451     HandleMark hm(THREAD);
1452     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1453     check_loader_lock_contention(lockObject, THREAD);
1454     ObjectLocker ol(lockObject, THREAD, true);
1455     // prohibited package check assumes all classes loaded from archive call
1456     // restore_unshareable_info which calls ik-&gt;set_package()
1457     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1458   }
1459 
1460   load_shared_class_misc(ik, loader_data, CHECK_NULL);







1461   return ik;
1462 }
1463 
1464 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1465   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1466 
1467   // For boot loader, ensure that GetSystemPackage knows that a class in this
1468   // package was loaded.
1469   if (loader_data-&gt;is_the_null_class_loader_data()) {
1470     int path_index = ik-&gt;shared_classpath_index();
1471     ik-&gt;set_classpath_index(path_index, THREAD);
1472   }
1473 
1474   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1475     // Only dump the classes that can be stored into CDS archive
1476     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1477       ResourceMark rm(THREAD);
1478       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1479       classlist_file-&gt;flush();
1480     }
</pre>
<hr />
<pre>
1504   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1505   if (klass-&gt;class_loader_data() != NULL) {
1506     return;
1507   }
1508 
1509   // add super and interfaces first
1510   Klass* super = klass-&gt;super();
1511   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1512     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1513     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1514   }
1515 
1516   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1517   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1518     InstanceKlass* ik = ifs-&gt;at(i);
1519     if (ik-&gt;class_loader_data()  == NULL) {
1520       quick_resolve(ik, loader_data, domain, CHECK);
1521     }
1522   }
1523 















1524   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);
1525   load_shared_class_misc(klass, loader_data, CHECK);
1526   Dictionary* dictionary = loader_data-&gt;dictionary();
1527   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1528   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1529   add_to_hierarchy(klass, CHECK);
1530   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1531 }
1532 #endif // INCLUDE_CDS
1533 
1534 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1535 
1536   if (class_loader.is_null()) {
1537     ResourceMark rm(THREAD);
1538     PackageEntry* pkg_entry = NULL;
1539     bool search_only_bootloader_append = false;
1540     ClassLoaderData *loader_data = class_loader_data(class_loader);
1541 
1542     // Find the package in the boot loader&#39;s package entry table.
1543     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
</pre>
<hr />
<pre>
2319 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2320                     Symbol* class_name, Handle class_loader, TRAPS) {
2321 
2322   // First see if it has been loaded directly.
2323   // Force the protection domain to be null.  (This removes protection checks.)
2324   Handle no_protection_domain;
2325   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2326                                               no_protection_domain, CHECK_NULL);
2327   if (klass != NULL)
2328     return klass;
2329 
2330   // Now look to see if it has been loaded elsewhere, and is subject to
2331   // a loader constraint that would require this loader to return the
2332   // klass that is already loaded.
2333   if (Signature::is_array(class_name)) {
2334     // For array classes, their Klass*s are not kept in the
2335     // constraint table. The element Klass*s are.
2336     SignatureStream ss(class_name, false);
2337     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2338     BasicType t = ss.type();
<span class="line-modified">2339     if (t != T_OBJECT) {</span>
2340       klass = Universe::typeArrayKlassObj(t);
2341     } else {
2342       MutexLocker mu(THREAD, SystemDictionary_lock);
2343       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2344     }
2345     // If element class already loaded, allocate array klass
2346     if (klass != NULL) {
2347       klass = klass-&gt;array_klass_or_null(ndims);
2348     }
2349   } else {
2350     MutexLocker mu(THREAD, SystemDictionary_lock);
2351     // Non-array classes are easy: simply check the constraint table.
2352     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2353   }
2354 
2355   return klass;
2356 }
2357 
2358 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2359                                              Klass* klass_being_linked,
</pre>
</td>
<td>
<hr />
<pre>
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  50 #include &quot;interpreter/bytecodeStream.hpp&quot;
  51 #include &quot;interpreter/interpreter.hpp&quot;
  52 #include &quot;jfr/jfrEvents.hpp&quot;
  53 #include &quot;logging/log.hpp&quot;
  54 #include &quot;logging/logStream.hpp&quot;
  55 #include &quot;memory/filemap.hpp&quot;
  56 #include &quot;memory/heapShared.hpp&quot;
  57 #include &quot;memory/metaspaceClosure.hpp&quot;
  58 #include &quot;memory/oopFactory.hpp&quot;
  59 #include &quot;memory/resourceArea.hpp&quot;
  60 #include &quot;memory/universe.hpp&quot;
  61 #include &quot;oops/access.inline.hpp&quot;
<span class="line-added">  62 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  63 #include &quot;oops/instanceKlass.hpp&quot;
  64 #include &quot;oops/instanceRefKlass.hpp&quot;
  65 #include &quot;oops/klass.inline.hpp&quot;
  66 #include &quot;oops/method.inline.hpp&quot;
  67 #include &quot;oops/methodData.hpp&quot;
  68 #include &quot;oops/objArrayKlass.hpp&quot;
  69 #include &quot;oops/objArrayOop.inline.hpp&quot;
  70 #include &quot;oops/oop.inline.hpp&quot;
  71 #include &quot;oops/oopHandle.inline.hpp&quot;
  72 #include &quot;oops/symbol.hpp&quot;
  73 #include &quot;oops/typeArrayKlass.hpp&quot;
<span class="line-added">  74 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
  75 #include &quot;prims/jvmtiExport.hpp&quot;
  76 #include &quot;prims/methodHandles.hpp&quot;
  77 #include &quot;runtime/arguments.hpp&quot;
  78 #include &quot;runtime/biasedLocking.hpp&quot;
  79 #include &quot;runtime/handles.inline.hpp&quot;
  80 #include &quot;runtime/java.hpp&quot;
  81 #include &quot;runtime/javaCalls.hpp&quot;
  82 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-added">  83 #include &quot;runtime/os.hpp&quot;</span>
  84 #include &quot;runtime/sharedRuntime.hpp&quot;
  85 #include &quot;runtime/signature.hpp&quot;
  86 #include &quot;services/classLoadingService.hpp&quot;
  87 #include &quot;services/diagnosticCommand.hpp&quot;
  88 #include &quot;services/threadService.hpp&quot;
  89 #include &quot;utilities/macros.hpp&quot;
  90 #include &quot;utilities/utf8.hpp&quot;
  91 #if INCLUDE_CDS
  92 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  93 #endif
  94 #if INCLUDE_JFR
  95 #include &quot;jfr/jfr.hpp&quot;
  96 #endif
  97 
  98 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  99 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
 100 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 101 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 102 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 103 
</pre>
<hr />
<pre>
 311 
 312 
 313 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 314 
 315 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 316   if (Signature::is_array(class_name)) {
 317     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 318   } else {
 319     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 320   }
 321 }
 322 
 323 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 324 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 325                                                                        Handle class_loader,
 326                                                                        Handle protection_domain,
 327                                                                        TRAPS) {
 328   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 329   if (Signature::has_envelope(class_name)) {
 330     ResourceMark rm(THREAD);
<span class="line-modified"> 331     // Ignore wrapping L and ;. (and Q and ; for value types);</span>
 332     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 333                                                  class_name-&gt;utf8_length() - 2);
 334     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 335   } else {
 336     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 337   }
 338 }
 339 
 340 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 341   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 342 }
 343 
 344 // Forwards to resolve_instance_class_or_null
 345 
 346 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 347                                                      Handle class_loader,
 348                                                      Handle protection_domain,
 349                                                      TRAPS) {
 350   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 351   ResourceMark rm(THREAD);
 352   SignatureStream ss(class_name, false);
 353   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 354   Klass* k = NULL;
 355   BasicType t = ss.type();
 356   if (ss.has_envelope()) {
 357     Symbol* obj_class = ss.as_symbol();
 358     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 359                                                          class_loader,
 360                                                          protection_domain,
 361                                                          CHECK_NULL);
 362     if (k != NULL) {
<span class="line-added"> 363       if ((class_name-&gt;is_Q_array_signature() &amp;&amp; !k-&gt;is_inline_klass()) ||</span>
<span class="line-added"> 364           (!class_name-&gt;is_Q_array_signature() &amp;&amp; k-&gt;is_inline_klass())) {</span>
<span class="line-added"> 365             THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), &quot;L/Q mismatch on bottom type&quot;);</span>
<span class="line-added"> 366           }</span>
 367       k = k-&gt;array_klass(ndims, CHECK_NULL);
 368     }
 369   } else {
 370     k = Universe::typeArrayKlassObj(t);
 371     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);
 372   }
 373   return k;
 374 }
 375 

 376 // Must be called for any super-class or super-interface resolution
 377 // during class definition to allow class circularity checking
 378 // super-interface callers:
 379 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 380 // super-class callers:
 381 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 382 //   load_shared_class - while loading a class from shared archive
 383 //   resolve_instance_class_or_null:
 384 //     via: handle_parallel_super_load
 385 //      when resolving a class that has an existing placeholder with
 386 //      a saved superclass [i.e. a defineClass is currently in progress]
 387 //      if another thread is trying to resolve the class, it must do
 388 //      super-class checks on its own thread to catch class circularity
 389 // This last call is critical in class circularity checking for cases
 390 // where classloading is delegated to different threads and the
 391 // classloader lock is released.
 392 // Take the case: Base-&gt;Super-&gt;Base
 393 //   1. If thread T1 tries to do a defineClass of class Base
 394 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 395 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
</pre>
<hr />
<pre>
 499   // The instanceKlass is kept alive because the class loader is on the stack,
 500   // which keeps the loader_data alive, as well as all instanceKlasses in
 501   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 502   {
 503     MutexLocker mu(THREAD, SystemDictionary_lock);
 504     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 505     SystemDictionary_lock-&gt;notify_all();
 506   }
 507   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 508     // can null superk
 509     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 510     assert(k == NULL || k == superk, &quot;must be&quot;);
 511     if (k == NULL) {
 512       superk = NULL;
 513     }
 514   }
 515 
 516   return superk;
 517 }
 518 
<span class="line-added"> 519 Klass* SystemDictionary::resolve_inline_type_field_or_fail(AllFieldStream* fs,</span>
<span class="line-added"> 520                                                            Handle class_loader,</span>
<span class="line-added"> 521                                                            Handle protection_domain,</span>
<span class="line-added"> 522                                                            bool throw_error,</span>
<span class="line-added"> 523                                                            TRAPS) {</span>
<span class="line-added"> 524   Symbol* class_name = fs-&gt;signature()-&gt;fundamental_name(THREAD);</span>
<span class="line-added"> 525   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));</span>
<span class="line-added"> 526   ClassLoaderData* loader_data = class_loader_data(class_loader);</span>
<span class="line-added"> 527   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);</span>
<span class="line-added"> 528   int p_index = placeholders()-&gt;hash_to_index(p_hash);</span>
<span class="line-added"> 529   bool throw_circularity_error = false;</span>
<span class="line-added"> 530   PlaceholderEntry* oldprobe;</span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532   {</span>
<span class="line-added"> 533     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
<span class="line-added"> 534     oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, class_name, loader_data);</span>
<span class="line-added"> 535     if (oldprobe != NULL &amp;&amp;</span>
<span class="line-added"> 536       oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::INLINE_TYPE_FIELD)) {</span>
<span class="line-added"> 537       throw_circularity_error = true;</span>
<span class="line-added"> 538 </span>
<span class="line-added"> 539     } else {</span>
<span class="line-added"> 540       placeholders()-&gt;find_and_add(p_index, p_hash, class_name, loader_data,</span>
<span class="line-added"> 541                                    PlaceholderTable::INLINE_TYPE_FIELD, NULL, THREAD);</span>
<span class="line-added"> 542     }</span>
<span class="line-added"> 543   }</span>
<span class="line-added"> 544 </span>
<span class="line-added"> 545   Klass* klass = NULL;</span>
<span class="line-added"> 546   if (!throw_circularity_error) {</span>
<span class="line-added"> 547     klass = SystemDictionary::resolve_or_fail(class_name, class_loader,</span>
<span class="line-added"> 548                                                protection_domain, true, THREAD);</span>
<span class="line-added"> 549   } else {</span>
<span class="line-added"> 550     ResourceMark rm(THREAD);</span>
<span class="line-added"> 551     THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name-&gt;as_C_string());</span>
<span class="line-added"> 552   }</span>
<span class="line-added"> 553 </span>
<span class="line-added"> 554   {</span>
<span class="line-added"> 555     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
<span class="line-added"> 556     placeholders()-&gt;find_and_remove(p_index, p_hash, class_name, loader_data,</span>
<span class="line-added"> 557                                     PlaceholderTable::INLINE_TYPE_FIELD, THREAD);</span>
<span class="line-added"> 558   }</span>
<span class="line-added"> 559 </span>
<span class="line-added"> 560   class_name-&gt;decrement_refcount();</span>
<span class="line-added"> 561   return klass;</span>
<span class="line-added"> 562 }</span>
<span class="line-added"> 563 </span>
 564 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 565                                                   Handle class_loader,
 566                                                   Handle protection_domain,
 567                                                   TRAPS) {
 568   // Now we have to call back to java to check if the initating class has access
 569   JavaValue result(T_VOID);
 570   LogTarget(Debug, protectiondomain) lt;
 571   if (lt.is_enabled()) {
 572     ResourceMark rm(THREAD);
 573     // Print out trace information
 574     LogStream ls(lt);
 575     ls.print_cr(&quot;Checking package access&quot;);
 576     if (class_loader() != NULL) {
 577       ls.print(&quot;class loader: &quot;);
 578       class_loader()-&gt;print_value_on(&amp;ls);
 579     } else {
 580       ls.print_cr(&quot;class loader: NULL&quot;);
 581     }
 582     if (protection_domain() != NULL) {
 583       ls.print(&quot; protection domain: &quot;);
</pre>
<hr />
<pre>
1072                           protection_domain);
1073 }
1074 
1075 
1076 // Look for a loaded instance or array klass by name.  Do not do any loading.
1077 // return NULL in case of error.
1078 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
1079                                                       Handle class_loader,
1080                                                       Handle protection_domain,
1081                                                       TRAPS) {
1082   Klass* k = NULL;
1083   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1084 
1085   if (Signature::is_array(class_name)) {
1086     // The name refers to an array.  Parse the name.
1087     // dimension and object_key in FieldArrayInfo are assigned as a
1088     // side-effect of this call
1089     SignatureStream ss(class_name, false);
1090     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1091     BasicType t = ss.type();
<span class="line-modified">1092     if (t != T_OBJECT &amp;&amp; t != T_INLINE_TYPE) {</span>
1093       k = Universe::typeArrayKlassObj(t);
1094     } else {
1095       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1096     }
1097     if (k != NULL) {
1098       k = k-&gt;array_klass_or_null(ndims);
1099     }
1100   } else {
1101     k = find(class_name, class_loader, protection_domain, THREAD);
1102   }
1103   return k;
1104 }
1105 
1106 // Note: this method is much like resolve_from_stream, but
1107 // does not publish the classes via the SystemDictionary.
1108 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
1109 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.
1110 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1111                                               Handle class_loader,
1112                                               ClassFileStream* st,
</pre>
<hr />
<pre>
1456 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1457                                                    Handle class_loader,
1458                                                    Handle protection_domain,
1459                                                    const ClassFileStream *cfs,
1460                                                    PackageEntry* pkg_entry,
1461                                                    TRAPS) {
1462   assert(ik != NULL, &quot;sanity&quot;);
1463   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1464   Symbol* class_name = ik-&gt;name();
1465 
1466   bool visible = is_shared_class_visible(
1467                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1468   if (!visible) {
1469     return NULL;
1470   }
1471 
1472   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1473     return NULL;
1474   }
1475 
<span class="line-added">1476 </span>
<span class="line-added">1477   if (ik-&gt;has_inline_type_fields()) {</span>
<span class="line-added">1478     for (AllFieldStream fs(ik-&gt;fields(), ik-&gt;constants()); !fs.done(); fs.next()) {</span>
<span class="line-added">1479       if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE) {</span>
<span class="line-added">1480         if (!fs.access_flags().is_static()) {</span>
<span class="line-added">1481           // Pre-load inline class</span>
<span class="line-added">1482           Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,</span>
<span class="line-added">1483             class_loader, protection_domain, true, CHECK_NULL);</span>
<span class="line-added">1484           Klass* k = ik-&gt;get_inline_type_field_klass_or_null(fs.index());</span>
<span class="line-added">1485           if (real_k != k) {</span>
<span class="line-added">1486             // oops, the app has substituted a different version of k!</span>
<span class="line-added">1487             return NULL;</span>
<span class="line-added">1488           }</span>
<span class="line-added">1489         }</span>
<span class="line-added">1490       }</span>
<span class="line-added">1491     }</span>
<span class="line-added">1492   }</span>
<span class="line-added">1493 </span>
1494   InstanceKlass* new_ik = NULL;
1495   // CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).
1496   // It will be skipped for shared VM hidden lambda proxy classes.
1497   if (!SystemDictionaryShared::is_hidden_lambda_proxy(ik)) {
1498     new_ik = KlassFactory::check_shared_class_file_load_hook(
1499       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1500   }
1501   if (new_ik != NULL) {
1502     // The class is changed by CFLH. Return the new class. The shared class is
1503     // not used.
1504     return new_ik;
1505   }
1506 
1507   // Adjust methods to recover missing data.  They need addresses for
1508   // interpreter entry points and their default native method address
1509   // must be reset.
1510 
1511   // Updating methods must be done under a lock so multiple
1512   // threads don&#39;t update these in parallel
1513   //
1514   // Shared classes are all currently loaded by either the bootstrap or
1515   // internal parallel class loaders, so this will never cause a deadlock
1516   // on a custom class loader lock.
1517 
1518   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1519   {
1520     HandleMark hm(THREAD);
1521     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1522     check_loader_lock_contention(lockObject, THREAD);
1523     ObjectLocker ol(lockObject, THREAD, true);
1524     // prohibited package check assumes all classes loaded from archive call
1525     // restore_unshareable_info which calls ik-&gt;set_package()
1526     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1527   }
1528 
1529   load_shared_class_misc(ik, loader_data, CHECK_NULL);
<span class="line-added">1530 </span>
<span class="line-added">1531   if (ik-&gt;is_inline_klass()) {</span>
<span class="line-added">1532     InlineKlass* vk = InlineKlass::cast(ik);</span>
<span class="line-added">1533     oop val = ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">1534     vk-&gt;set_default_value(val);</span>
<span class="line-added">1535   }</span>
<span class="line-added">1536 </span>
1537   return ik;
1538 }
1539 
1540 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1541   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1542 
1543   // For boot loader, ensure that GetSystemPackage knows that a class in this
1544   // package was loaded.
1545   if (loader_data-&gt;is_the_null_class_loader_data()) {
1546     int path_index = ik-&gt;shared_classpath_index();
1547     ik-&gt;set_classpath_index(path_index, THREAD);
1548   }
1549 
1550   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1551     // Only dump the classes that can be stored into CDS archive
1552     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1553       ResourceMark rm(THREAD);
1554       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1555       classlist_file-&gt;flush();
1556     }
</pre>
<hr />
<pre>
1580   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1581   if (klass-&gt;class_loader_data() != NULL) {
1582     return;
1583   }
1584 
1585   // add super and interfaces first
1586   Klass* super = klass-&gt;super();
1587   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1588     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1589     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1590   }
1591 
1592   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1593   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1594     InstanceKlass* ik = ifs-&gt;at(i);
1595     if (ik-&gt;class_loader_data()  == NULL) {
1596       quick_resolve(ik, loader_data, domain, CHECK);
1597     }
1598   }
1599 
<span class="line-added">1600   if (klass-&gt;has_inline_type_fields()) {</span>
<span class="line-added">1601     for (AllFieldStream fs(klass-&gt;fields(), klass-&gt;constants()); !fs.done(); fs.next()) {</span>
<span class="line-added">1602       if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE) {</span>
<span class="line-added">1603         if (!fs.access_flags().is_static()) {</span>
<span class="line-added">1604           Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,</span>
<span class="line-added">1605             Handle(THREAD, loader_data-&gt;class_loader()), domain, true, CHECK);</span>
<span class="line-added">1606           Klass* k = klass-&gt;get_inline_type_field_klass_or_null(fs.index());</span>
<span class="line-added">1607           assert(real_k == k, &quot;oops, the app has substituted a different version of k!&quot;);</span>
<span class="line-added">1608         } else {</span>
<span class="line-added">1609           klass-&gt;reset_inline_type_field_klass(fs.index());</span>
<span class="line-added">1610         }</span>
<span class="line-added">1611       }</span>
<span class="line-added">1612     }</span>
<span class="line-added">1613   }</span>
<span class="line-added">1614 </span>
1615   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);
1616   load_shared_class_misc(klass, loader_data, CHECK);
1617   Dictionary* dictionary = loader_data-&gt;dictionary();
1618   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1619   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1620   add_to_hierarchy(klass, CHECK);
1621   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1622 }
1623 #endif // INCLUDE_CDS
1624 
1625 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1626 
1627   if (class_loader.is_null()) {
1628     ResourceMark rm(THREAD);
1629     PackageEntry* pkg_entry = NULL;
1630     bool search_only_bootloader_append = false;
1631     ClassLoaderData *loader_data = class_loader_data(class_loader);
1632 
1633     // Find the package in the boot loader&#39;s package entry table.
1634     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
</pre>
<hr />
<pre>
2410 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2411                     Symbol* class_name, Handle class_loader, TRAPS) {
2412 
2413   // First see if it has been loaded directly.
2414   // Force the protection domain to be null.  (This removes protection checks.)
2415   Handle no_protection_domain;
2416   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2417                                               no_protection_domain, CHECK_NULL);
2418   if (klass != NULL)
2419     return klass;
2420 
2421   // Now look to see if it has been loaded elsewhere, and is subject to
2422   // a loader constraint that would require this loader to return the
2423   // klass that is already loaded.
2424   if (Signature::is_array(class_name)) {
2425     // For array classes, their Klass*s are not kept in the
2426     // constraint table. The element Klass*s are.
2427     SignatureStream ss(class_name, false);
2428     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2429     BasicType t = ss.type();
<span class="line-modified">2430     if (t != T_OBJECT &amp;&amp; t != T_INLINE_TYPE) {</span>
2431       klass = Universe::typeArrayKlassObj(t);
2432     } else {
2433       MutexLocker mu(THREAD, SystemDictionary_lock);
2434       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2435     }
2436     // If element class already loaded, allocate array klass
2437     if (klass != NULL) {
2438       klass = klass-&gt;array_klass_or_null(ndims);
2439     }
2440   } else {
2441     MutexLocker mu(THREAD, SystemDictionary_lock);
2442     // Non-array classes are easy: simply check the constraint table.
2443     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2444   }
2445 
2446   return klass;
2447 }
2448 
2449 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2450                                              Klass* klass_being_linked,
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>