<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/altHashing.hpp&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  46 #include &quot;oops/flatArrayKlass.hpp&quot;</span>
<span class="line-added">  47 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
  48 #include &quot;oops/instanceKlass.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified">  49 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;</span>
  50 #include &quot;oops/klass.hpp&quot;
  51 #include &quot;oops/method.inline.hpp&quot;
  52 #include &quot;oops/objArrayOop.inline.hpp&quot;
  53 #include &quot;oops/oop.inline.hpp&quot;
  54 #include &quot;oops/symbol.hpp&quot;
  55 #include &quot;oops/recordComponent.hpp&quot;
  56 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  57 #include &quot;prims/jvmtiExport.hpp&quot;
  58 #include &quot;prims/resolvedMethodTable.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/init.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/java.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/jniHandles.inline.hpp&quot;
  67 #include &quot;runtime/safepoint.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
  70 #include &quot;runtime/vframe.inline.hpp&quot;
  71 #include &quot;runtime/vm_version.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/preserveException.hpp&quot;
  74 #include &quot;utilities/utf8.hpp&quot;
  75 #if INCLUDE_JVMCI
  76 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  77 #endif
  78 
  79 #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
  80   klass::_##name##_offset = JavaClasses::compute_injected_offset(JavaClasses::klass##_##name##_enum);
  81 
  82 #if INCLUDE_CDS
  83 #define INJECTED_FIELD_SERIALIZE_OFFSET(klass, name, signature, may_be_java) \
  84   f-&gt;do_u4((u4*)&amp;_##name##_offset);
  85 #endif
  86 
  87 #define DECLARE_INJECTED_FIELD(klass, name, signature, may_be_java)           \
  88   { SystemDictionary::WK_KLASS_ENUM_NAME(klass), vmSymbols::VM_SYMBOL_ENUM_NAME(name##_name), vmSymbols::VM_SYMBOL_ENUM_NAME(signature), may_be_java },
  89 
  90 InjectedField JavaClasses::_injected_fields[] = {
  91   ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD)
  92 };
  93 
  94 // Register native methods of Object
  95 void java_lang_Object::register_natives(TRAPS) {
  96   InstanceKlass* obj = SystemDictionary::Object_klass();
  97   Method::register_native(obj, vmSymbols::hashCode_name(),
  98                           vmSymbols::void_int_signature(), (address) &amp;JVM_IHashCode, CHECK);
  99   Method::register_native(obj, vmSymbols::wait_name(),
 100                           vmSymbols::long_void_signature(), (address) &amp;JVM_MonitorWait, CHECK);
 101   Method::register_native(obj, vmSymbols::notify_name(),
 102                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotify, CHECK);
 103   Method::register_native(obj, vmSymbols::notifyAll_name(),
 104                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotifyAll, CHECK);
 105   Method::register_native(obj, vmSymbols::clone_name(),
 106                           vmSymbols::void_object_signature(), (address) &amp;JVM_Clone, THREAD);
 107 }
 108 
 109 int JavaClasses::compute_injected_offset(InjectedFieldID id) {
 110   return _injected_fields[id].compute_offset();
 111 }
 112 
 113 InjectedField* JavaClasses::get_injected(Symbol* class_name, int* field_count) {
 114   *field_count = 0;
 115 
 116   vmSymbols::SID sid = vmSymbols::find_sid(class_name);
 117   if (sid == vmSymbols::NO_SID) {
 118     // Only well known classes can inject fields
 119     return NULL;
 120   }
 121 
 122   int count = 0;
 123   int start = -1;
 124 
 125 #define LOOKUP_INJECTED_FIELD(klass, name, signature, may_be_java) \
 126   if (sid == vmSymbols::VM_SYMBOL_ENUM_NAME(klass)) {              \
 127     count++;                                                       \
 128     if (start == -1) start = klass##_##name##_enum;                \
 129   }
 130   ALL_INJECTED_FIELDS(LOOKUP_INJECTED_FIELD);
 131 #undef LOOKUP_INJECTED_FIELD
 132 
 133   if (start != -1) {
 134     *field_count = count;
 135     return _injected_fields + start;
 136   }
 137   return NULL;
 138 }
 139 
 140 
 141 // Helpful routine for computing field offsets at run time rather than hardcoding them
 142 // Finds local fields only, including static fields.  Static field offsets are from the
 143 // beginning of the mirror.
 144 static void compute_offset(int &amp;dest_offset,
 145                            InstanceKlass* ik, Symbol* name_symbol, Symbol* signature_symbol,
 146                            bool is_static = false) {
 147   fieldDescriptor fd;
 148   if (ik == NULL) {
 149     ResourceMark rm;
 150     log_error(class)(&quot;Mismatch JDK version for field: %s type: %s&quot;, name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 151     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;);
 152   }
 153 
 154   if (!ik-&gt;find_local_field(name_symbol, signature_symbol, &amp;fd) || fd.is_static() != is_static) {
 155     ResourceMark rm;
 156     log_error(class)(&quot;Invalid layout of %s field: %s type: %s&quot;, ik-&gt;external_name(),
 157                      name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 158 #ifndef PRODUCT
 159     // Prints all fields and offsets
 160     Log(class) lt;
 161     LogStream ls(lt.error());
 162     ik-&gt;print_on(&amp;ls);
 163 #endif //PRODUCT
 164     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 165   }
 166   dest_offset = fd.offset();
 167 }
 168 
 169 // Overloading to pass name as a string.
 170 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 171                            const char* name_string, Symbol* signature_symbol,
 172                            bool is_static = false) {
 173   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 174   if (name == NULL) {
 175     ResourceMark rm;
 176     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 177     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 178   }
 179   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 180 }
 181 
 182 
 183 #if INCLUDE_CDS
 184 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 185   f-&gt;do_u4((u4*)&amp;offset)
 186 #endif
 187 
 188 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 189   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 190 
 191 
 192 // java_lang_String
 193 
 194 int java_lang_String::_value_offset;
 195 int java_lang_String::_hash_offset;
 196 int java_lang_String::_hashIsZero_offset;
 197 int java_lang_String::_coder_offset;
 198 
 199 bool java_lang_String::_initialized;
 200 
 201 bool java_lang_String::is_instance(oop obj) {
 202   return is_instance_inlined(obj);
 203 }
 204 
 205 #define STRING_FIELDS_DO(macro) \
 206   macro(_value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
 207   macro(_hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \
 208   macro(_hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \
 209   macro(_coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);
 210 
 211 void java_lang_String::compute_offsets() {
 212   if (_initialized) {
 213     return;
 214   }
 215 
 216   InstanceKlass* k = SystemDictionary::String_klass();
 217   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 218 
 219   _initialized = true;
 220 }
 221 
 222 #if INCLUDE_CDS
 223 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 224   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 225   f-&gt;do_bool(&amp;_initialized);
 226 }
 227 #endif
 228 
 229 class CompactStringsFixup : public FieldClosure {
 230 private:
 231   bool _value;
 232 
 233 public:
 234   CompactStringsFixup(bool value) : _value(value) {}
 235 
 236   void do_field(fieldDescriptor* fd) {
 237     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 238       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 239       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 240       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 241       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 242     }
 243   }
 244 };
 245 
 246 void java_lang_String::set_compact_strings(bool value) {
 247   CompactStringsFixup fix(value);
 248   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
 249 }
 250 
 251 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
 252   assert(_initialized, &quot;Must be initialized&quot;);
 253   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 254 
 255   // Create the String object first, so there&#39;s a chance that the String
 256   // and the char array it points to end up in the same cache line.
 257   oop obj;
 258   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 259 
 260   // Create the char array.  The String object must be handlized here
 261   // because GC can happen as a result of the allocation attempt.
 262   Handle h_obj(THREAD, obj);
 263   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 264   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 265 
 266   // Point the String at the char array
 267   obj = h_obj();
 268   set_value(obj, buffer);
 269   // No need to zero the offset, allocation zero&#39;ed the entire String object
 270   set_coder(obj, is_latin1 ? CODER_LATIN1 : CODER_UTF16);
 271   return h_obj;
 272 }
 273 
 274 Handle java_lang_String::create_from_unicode(const jchar* unicode, int length, TRAPS) {
 275   bool is_latin1 = CompactStrings &amp;&amp; UNICODE::is_latin1(unicode, length);
 276   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 277   typeArrayOop buffer = value(h_obj());
 278   assert(TypeArrayKlass::cast(buffer-&gt;klass())-&gt;element_type() == T_BYTE, &quot;only byte[]&quot;);
 279   if (is_latin1) {
 280     for (int index = 0; index &lt; length; index++) {
 281       buffer-&gt;byte_at_put(index, (jbyte)unicode[index]);
 282     }
 283   } else {
 284     for (int index = 0; index &lt; length; index++) {
 285       buffer-&gt;char_at_put(index, unicode[index]);
 286     }
 287   }
 288 
 289 #ifdef ASSERT
 290   {
 291     ResourceMark rm;
 292     char* expected = UNICODE::as_utf8(unicode, length);
 293     char* actual = as_utf8_string(h_obj());
 294     if (strcmp(expected, actual) != 0) {
 295       fatal(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);
 296     }
 297   }
 298 #endif
 299 
 300   return h_obj;
 301 }
 302 
 303 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
 304   Handle h_obj = create_from_unicode(unicode, length, CHECK_NULL);
 305   return h_obj();
 306 }
 307 
 308 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 309   if (utf8_str == NULL) {
 310     return Handle();
 311   }
 312   bool has_multibyte, is_latin1;
 313   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 314   if (!CompactStrings) {
 315     has_multibyte = true;
 316     is_latin1 = false;
 317   }
 318 
 319   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 320   if (length &gt; 0) {
 321     if (!has_multibyte) {
 322       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 323       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 324     } else if (is_latin1) {
 325       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 326     } else {
 327       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 328     }
 329   }
 330 
 331 #ifdef ASSERT
 332   // This check is too strict when the input string is not a valid UTF8.
 333   // For example, it may be created with arbitrary content via jni_NewStringUTF.
 334   if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, (int)strlen(utf8_str), false)) {
 335     ResourceMark rm;
 336     const char* expected = utf8_str;
 337     char* actual = as_utf8_string(h_obj());
 338     if (strcmp(expected, actual) != 0) {
 339       fatal(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);
 340     }
 341   }
 342 #endif
 343 
 344   return h_obj;
 345 }
 346 
 347 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
 348   Handle h_obj = create_from_str(utf8_str, CHECK_NULL);
 349   return h_obj();
 350 }
 351 
 352 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 353   const char* utf8_str = (char*)symbol-&gt;bytes();
 354   int utf8_len = symbol-&gt;utf8_length();
 355 
 356   bool has_multibyte, is_latin1;
 357   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 358   if (!CompactStrings) {
 359     has_multibyte = true;
 360     is_latin1 = false;
 361   }
 362 
 363   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 364   if (length &gt; 0) {
 365     if (!has_multibyte) {
 366       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 367       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 368     } else if (is_latin1) {
 369       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 370     } else {
 371       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 372     }
 373   }
 374 
 375 #ifdef ASSERT
 376   {
 377     ResourceMark rm;
 378     const char* expected = symbol-&gt;as_utf8();
 379     char* actual = as_utf8_string(h_obj());
 380     if (strncmp(expected, actual, utf8_len) != 0) {
 381       fatal(&quot;Symbol conversion failure: %s --&gt; %s&quot;, expected, actual);
 382     }
 383   }
 384 #endif
 385 
 386   return h_obj;
 387 }
 388 
 389 // Converts a C string to a Java String based on current encoding
 390 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 391   assert(str != NULL, &quot;bad arguments&quot;);
 392 
 393   typedef jstring (JNICALL *to_java_string_fn_t)(JNIEnv*, const char *);
 394   static to_java_string_fn_t _to_java_string_fn = NULL;
 395 
 396   if (_to_java_string_fn == NULL) {
 397     void *lib_handle = os::native_java_library();
 398     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;JNU_NewStringPlatform&quot;));
 399 #if defined(_WIN32) &amp;&amp; !defined(_WIN64)
 400     if (_to_java_string_fn == NULL) {
 401       // On 32 bit Windows, also try __stdcall decorated name
 402       _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;_JNU_NewStringPlatform@8&quot;));
 403     }
 404 #endif
 405     if (_to_java_string_fn == NULL) {
 406       fatal(&quot;JNU_NewStringPlatform missing&quot;);
 407     }
 408   }
 409 
 410   jstring js = NULL;
 411   {
 412     assert(THREAD-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 413     JavaThread* thread = (JavaThread*)THREAD;
 414     HandleMark hm(thread);
 415     ThreadToNativeFromVM ttn(thread);
 416     js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
 417   }
 418 
 419   Handle native_platform_string(THREAD, JNIHandles::resolve(js));
 420   JNIHandles::destroy_local(js);  // destroy local JNIHandle.
 421   return native_platform_string;
 422 }
 423 
 424 // Converts a Java String to a native C string that can be used for
 425 // native OS calls.
 426 char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
 427   typedef char* (*to_platform_string_fn_t)(JNIEnv*, jstring, bool*);
 428   static to_platform_string_fn_t _to_platform_string_fn = NULL;
 429 
 430   if (_to_platform_string_fn == NULL) {
 431     void *lib_handle = os::native_java_library();
 432     _to_platform_string_fn = CAST_TO_FN_PTR(to_platform_string_fn_t, os::dll_lookup(lib_handle, &quot;GetStringPlatformChars&quot;));
 433     if (_to_platform_string_fn == NULL) {
 434       fatal(&quot;GetStringPlatformChars missing&quot;);
 435     }
 436   }
 437 
 438   char *native_platform_string;
 439   { JavaThread* thread = (JavaThread*)THREAD;
 440     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 441     JNIEnv *env = thread-&gt;jni_environment();
 442     jstring js = (jstring) JNIHandles::make_local(env, java_string());
 443     bool is_copy;
 444     HandleMark hm(thread);
 445     ThreadToNativeFromVM ttn(thread);
 446     native_platform_string = (_to_platform_string_fn)(env, js, &amp;is_copy);
 447     assert(is_copy == JNI_TRUE, &quot;is_copy value changed&quot;);
 448     JNIHandles::destroy_local(js);
 449   }
 450   return native_platform_string;
 451 }
 452 
 453 Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {
 454   oop          obj    = java_string();
 455   // Typical usage is to convert all &#39;/&#39; to &#39;.&#39; in string.
 456   typeArrayOop value  = java_lang_String::value(obj);
 457   int          length = java_lang_String::length(obj, value);
 458   bool      is_latin1 = java_lang_String::is_latin1(obj);
 459 
 460   // First check if any from_char exist
 461   int index; // Declared outside, used later
 462   for (index = 0; index &lt; length; index++) {
 463     jchar c = !is_latin1 ? value-&gt;char_at(index) :
 464                   ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 465     if (c == from_char) {
 466       break;
 467     }
 468   }
 469   if (index == length) {
 470     // No from_char, so do not copy.
 471     return java_string;
 472   }
 473 
 474   // Check if result string will be latin1
 475   bool to_is_latin1 = false;
 476 
 477   // Replacement char must be latin1
 478   if (CompactStrings &amp;&amp; UNICODE::is_latin1(to_char)) {
 479     if (is_latin1) {
 480       // Source string is latin1 as well
 481       to_is_latin1 = true;
 482     } else if (!UNICODE::is_latin1(from_char)) {
 483       // We are replacing an UTF16 char. Scan string to
 484       // check if result can be latin1 encoded.
 485       to_is_latin1 = true;
 486       for (index = 0; index &lt; length; index++) {
 487         jchar c = value-&gt;char_at(index);
 488         if (c != from_char &amp;&amp; !UNICODE::is_latin1(c)) {
 489           to_is_latin1 = false;
 490           break;
 491         }
 492       }
 493     }
 494   }
 495 
 496   // Create new UNICODE (or byte) buffer. Must handlize value because GC
 497   // may happen during String and char array creation.
 498   typeArrayHandle h_value(THREAD, value);
 499   Handle string = basic_create(length, to_is_latin1, CHECK_NH);
 500   typeArrayOop from_buffer = h_value();
 501   typeArrayOop to_buffer = java_lang_String::value(string());
 502 
 503   // Copy contents
 504   for (index = 0; index &lt; length; index++) {
 505     jchar c = (!is_latin1) ? from_buffer-&gt;char_at(index) :
 506                     ((jchar) from_buffer-&gt;byte_at(index)) &amp; 0xff;
 507     if (c == from_char) {
 508       c = to_char;
 509     }
 510     if (!to_is_latin1) {
 511       to_buffer-&gt;char_at_put(index, c);
 512     } else {
 513       to_buffer-&gt;byte_at_put(index, (jbyte) c);
 514     }
 515   }
 516   return string;
 517 }
 518 
 519 jchar* java_lang_String::as_unicode_string(oop java_string, int&amp; length, TRAPS) {
 520   typeArrayOop value  = java_lang_String::value(java_string);
 521                length = java_lang_String::length(java_string, value);
 522   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 523 
 524   jchar* result = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);
 525   if (result != NULL) {
 526     if (!is_latin1) {
 527       for (int index = 0; index &lt; length; index++) {
 528         result[index] = value-&gt;char_at(index);
 529       }
 530     } else {
 531       for (int index = 0; index &lt; length; index++) {
 532         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 533       }
 534     }
 535   } else {
 536     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 537   }
 538   return result;
 539 }
 540 
 541 unsigned int java_lang_String::hash_code(oop java_string) {
 542   // The hash and hashIsZero fields are subject to a benign data race,
 543   // making it crucial to ensure that any observable result of the
 544   // calculation in this method stays correct under any possible read of
 545   // these fields. Necessary restrictions to allow this to be correct
 546   // without explicit memory fences or similar concurrency primitives is
 547   // that we can ever only write to one of these two fields for a given
 548   // String instance, and that the computation is idempotent and derived
 549   // from immutable state
 550   assert(_initialized &amp;&amp; (_hash_offset &gt; 0) &amp;&amp; (_hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);
 551   if (java_lang_String::hash_is_set(java_string)) {
 552     return java_string-&gt;int_field(_hash_offset);
 553   }
 554 
 555   typeArrayOop value = java_lang_String::value(java_string);
 556   int         length = java_lang_String::length(java_string, value);
 557   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 558 
 559   unsigned int hash = 0;
 560   if (length &gt; 0) {
 561     if (is_latin1) {
 562       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);
 563     } else {
 564       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
 565     }
 566   }
 567 
 568   if (hash != 0) {
 569     java_string-&gt;int_field_put(_hash_offset, hash);
 570   } else {
 571     java_string-&gt;bool_field_put(_hashIsZero_offset, true);
 572   }
 573   return hash;
 574 }
 575 
 576 char* java_lang_String::as_quoted_ascii(oop java_string) {
 577   typeArrayOop value  = java_lang_String::value(java_string);
 578   int          length = java_lang_String::length(java_string, value);
 579   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 580 
 581   if (length == 0) return NULL;
 582 
 583   char* result;
 584   int result_length;
 585   if (!is_latin1) {
 586     jchar* base = value-&gt;char_at_addr(0);
 587     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 588     result = NEW_RESOURCE_ARRAY(char, result_length);
 589     UNICODE::as_quoted_ascii(base, length, result, result_length);
 590   } else {
 591     jbyte* base = value-&gt;byte_at_addr(0);
 592     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 593     result = NEW_RESOURCE_ARRAY(char, result_length);
 594     UNICODE::as_quoted_ascii(base, length, result, result_length);
 595   }
 596   assert(result_length &gt;= length + 1, &quot;must not be shorter&quot;);
 597   assert(result_length == (int)strlen(result) + 1, &quot;must match&quot;);
 598   return result;
 599 }
 600 
 601 Symbol* java_lang_String::as_symbol(oop java_string) {
 602   typeArrayOop value  = java_lang_String::value(java_string);
 603   int          length = java_lang_String::length(java_string, value);
 604   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 605   if (!is_latin1) {
 606     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 607     Symbol* sym = SymbolTable::new_symbol(base, length);
 608     return sym;
 609   } else {
 610     ResourceMark rm;
 611     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 612     const char* base = UNICODE::as_utf8(position, length);
 613     Symbol* sym = SymbolTable::new_symbol(base, length);
 614     return sym;
 615   }
 616 }
 617 
 618 Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
 619   typeArrayOop value  = java_lang_String::value(java_string);
 620   int          length = java_lang_String::length(java_string, value);
 621   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 622   if (!is_latin1) {
 623     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 624     return SymbolTable::probe_unicode(base, length);
 625   } else {
 626     ResourceMark rm;
 627     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 628     const char* base = UNICODE::as_utf8(position, length);
 629     return SymbolTable::probe(base, length);
 630   }
 631 }
 632 
 633 int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {
 634   assert(value_equals(value, java_lang_String::value(java_string)),
 635          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 636   int length = java_lang_String::length(java_string, value);
 637   if (length == 0) {
 638     return 0;
 639   }
 640   if (!java_lang_String::is_latin1(java_string)) {
 641     return UNICODE::utf8_length(value-&gt;char_at_addr(0), length);
 642   } else {
 643     return UNICODE::utf8_length(value-&gt;byte_at_addr(0), length);
 644   }
 645 }
 646 
 647 int java_lang_String::utf8_length(oop java_string) {
 648   typeArrayOop value = java_lang_String::value(java_string);
 649   return utf8_length(java_string, value);
 650 }
 651 
 652 char* java_lang_String::as_utf8_string(oop java_string) {
 653   int length;
 654   return as_utf8_string(java_string, length);
 655 }
 656 
 657 char* java_lang_String::as_utf8_string(oop java_string, int&amp; length) {
 658   typeArrayOop value = java_lang_String::value(java_string);
 659   length             = java_lang_String::length(java_string, value);
 660   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 661   if (!is_latin1) {
 662     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 663     return UNICODE::as_utf8(position, length);
 664   } else {
 665     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 666     return UNICODE::as_utf8(position, length);
 667   }
 668 }
 669 
 670 // Uses a provided buffer if it&#39;s sufficiently large, otherwise allocates
 671 // a resource array to fit
 672 char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; utf8_len) {
 673   typeArrayOop value = java_lang_String::value(java_string);
 674   int            len = java_lang_String::length(java_string, value);
 675   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 676   if (!is_latin1) {
 677     jchar *position = (len == 0) ? NULL : value-&gt;char_at_addr(0);
 678     utf8_len = UNICODE::utf8_length(position, len);
 679     if (utf8_len &gt;= buflen) {
 680       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
 681     }
 682     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
 683   } else {
 684     jbyte *position = (len == 0) ? NULL : value-&gt;byte_at_addr(0);
 685     utf8_len = UNICODE::utf8_length(position, len);
 686     if (utf8_len &gt;= buflen) {
 687       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
 688     }
 689     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
 690   }
 691 }
 692 
 693 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {
 694   assert(value_equals(value, java_lang_String::value(java_string)),
 695          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 696   int     length = java_lang_String::length(java_string, value);
 697   bool is_latin1 = java_lang_String::is_latin1(java_string);
 698   if (!is_latin1) {
 699     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 700     return UNICODE::as_utf8(position, length, buf, buflen);
 701   } else {
 702     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 703     return UNICODE::as_utf8(position, length, buf, buflen);
 704   }
 705 }
 706 
 707 char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {
 708   typeArrayOop value = java_lang_String::value(java_string);
 709   return as_utf8_string(java_string, value, buf, buflen);
 710 }
 711 
 712 char* java_lang_String::as_utf8_string(oop java_string, int start, int len) {
 713   typeArrayOop value  = java_lang_String::value(java_string);
 714   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 715   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 716   if (!is_latin1) {
 717     jchar* position = value-&gt;char_at_addr(start);
 718     return UNICODE::as_utf8(position, len);
 719   } else {
 720     jbyte* position = value-&gt;byte_at_addr(start);
 721     return UNICODE::as_utf8(position, len);
 722   }
 723 }
 724 
 725 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {
 726   assert(value_equals(value, java_lang_String::value(java_string)),
 727          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 728   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 729   bool is_latin1 = java_lang_String::is_latin1(java_string);
 730   if (!is_latin1) {
 731     jchar* position = value-&gt;char_at_addr(start);
 732     return UNICODE::as_utf8(position, len, buf, buflen);
 733   } else {
 734     jbyte* position = value-&gt;byte_at_addr(start);
 735     return UNICODE::as_utf8(position, len, buf, buflen);
 736   }
 737 }
 738 
 739 bool java_lang_String::equals(oop java_string, const jchar* chars, int len) {
 740   assert(java_string-&gt;klass() == SystemDictionary::String_klass(),
 741          &quot;must be java_string&quot;);
 742   typeArrayOop value = java_lang_String::value_no_keepalive(java_string);
 743   int length = java_lang_String::length(java_string, value);
 744   if (length != len) {
 745     return false;
 746   }
 747   bool is_latin1 = java_lang_String::is_latin1(java_string);
 748   if (!is_latin1) {
 749     for (int i = 0; i &lt; len; i++) {
 750       if (value-&gt;char_at(i) != chars[i]) {
 751         return false;
 752       }
 753     }
 754   } else {
 755     for (int i = 0; i &lt; len; i++) {
 756       if ((((jchar) value-&gt;byte_at(i)) &amp; 0xff) != chars[i]) {
 757         return false;
 758       }
 759     }
 760   }
 761   return true;
 762 }
 763 
 764 bool java_lang_String::equals(oop str1, oop str2) {
 765   assert(str1-&gt;klass() == SystemDictionary::String_klass(),
 766          &quot;must be java String&quot;);
 767   assert(str2-&gt;klass() == SystemDictionary::String_klass(),
 768          &quot;must be java String&quot;);
 769   typeArrayOop value1    = java_lang_String::value_no_keepalive(str1);
 770   bool         is_latin1 = java_lang_String::is_latin1(str1);
 771   typeArrayOop value2    = java_lang_String::value_no_keepalive(str2);
 772   bool         is_latin2 = java_lang_String::is_latin1(str2);
 773 
 774   if (is_latin1 != is_latin2) {
 775     // Strings with different coders are never equal.
 776     return false;
 777   }
 778   return value_equals(value1, value2);
 779 }
 780 
 781 void java_lang_String::print(oop java_string, outputStream* st) {
 782   assert(java_string-&gt;klass() == SystemDictionary::String_klass(), &quot;must be java_string&quot;);
 783   typeArrayOop value  = java_lang_String::value_no_keepalive(java_string);
 784 
 785   if (value == NULL) {
 786     // This can happen if, e.g., printing a String
 787     // object before its initializer has been called
 788     st-&gt;print(&quot;NULL&quot;);
 789     return;
 790   }
 791 
 792   int length = java_lang_String::length(java_string, value);
 793   bool is_latin1 = java_lang_String::is_latin1(java_string);
 794 
 795   st-&gt;print(&quot;\&quot;&quot;);
 796   for (int index = 0; index &lt; length; index++) {
 797     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 798                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 799   }
 800   st-&gt;print(&quot;\&quot;&quot;);
 801 }
 802 
 803 // java_lang_Class
 804 
 805 int java_lang_Class::_klass_offset;
 806 int java_lang_Class::_array_klass_offset;
 807 int java_lang_Class::_oop_size_offset;
 808 int java_lang_Class::_static_oop_field_count_offset;
 809 int java_lang_Class::_class_loader_offset;
 810 int java_lang_Class::_module_offset;
 811 int java_lang_Class::_protection_domain_offset;
 812 int java_lang_Class::_component_mirror_offset;
<a name="3" id="anc3"></a><span class="line-added"> 813 int java_lang_Class::_val_type_mirror_offset;</span>
<span class="line-added"> 814 int java_lang_Class::_ref_type_mirror_offset;</span>
 815 int java_lang_Class::_init_lock_offset;
 816 int java_lang_Class::_signers_offset;
 817 int java_lang_Class::_name_offset;
 818 int java_lang_Class::_source_file_offset;
 819 int java_lang_Class::_classData_offset;
 820 int java_lang_Class::_classRedefinedCount_offset;
 821 
 822 bool java_lang_Class::_offsets_computed = false;
 823 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
 824 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
 825 
 826 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 827   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 828   if (fd-&gt;has_initial_value()) {
 829     BasicType t = fd-&gt;field_type();
 830     switch (t) {
 831       case T_BYTE:
 832         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 833               break;
 834       case T_BOOLEAN:
 835         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 836               break;
 837       case T_CHAR:
 838         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 839               break;
 840       case T_SHORT:
 841         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 842               break;
 843       case T_INT:
 844         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 845         break;
 846       case T_FLOAT:
 847         mirror()-&gt;float_field_put(fd-&gt;offset(), fd-&gt;float_initial_value());
 848         break;
 849       case T_DOUBLE:
 850         mirror()-&gt;double_field_put(fd-&gt;offset(), fd-&gt;double_initial_value());
 851         break;
 852       case T_LONG:
 853         mirror()-&gt;long_field_put(fd-&gt;offset(), fd-&gt;long_initial_value());
 854         break;
 855       case T_OBJECT:
 856         {
 857           assert(fd-&gt;signature() == vmSymbols::string_signature(),
 858                  &quot;just checking&quot;);
 859           if (DumpSharedSpaces &amp;&amp; HeapShared::is_archived_object(mirror())) {
 860             // Archive the String field and update the pointer.
 861             oop s = mirror()-&gt;obj_field(fd-&gt;offset());
 862             oop archived_s = StringTable::create_archived_string(s, CHECK);
 863             mirror()-&gt;obj_field_put(fd-&gt;offset(), archived_s);
 864           } else {
 865             oop string = fd-&gt;string_initial_value(CHECK);
 866             mirror()-&gt;obj_field_put(fd-&gt;offset(), string);
 867           }
 868         }
 869         break;
 870       default:
 871         THROW_MSG(vmSymbols::java_lang_ClassFormatError(),
 872                   &quot;Illegal ConstantValue attribute in class file&quot;);
 873     }
 874   }
 875 }
 876 
 877 
 878 void java_lang_Class::fixup_mirror(Klass* k, TRAPS) {
 879   assert(InstanceMirrorKlass::offset_of_static_fields() != 0, &quot;must have been computed already&quot;);
 880 
 881   // If the offset was read from the shared archive, it was fixed up already
 882   if (!k-&gt;is_shared()) {
 883     if (k-&gt;is_instance_klass()) {
 884       // During bootstrap, java.lang.Class wasn&#39;t loaded so static field
 885       // offsets were computed without the size added it.  Go back and
 886       // update all the static field offsets to included the size.
 887       for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {
 888         if (fs.access_flags().is_static()) {
 889           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 890           fs.set_offset(real_offset);
 891         }
 892       }
 893     }
 894   }
 895 
 896   if (k-&gt;is_shared() &amp;&amp; k-&gt;has_raw_archived_mirror()) {
 897     if (HeapShared::open_archive_heap_region_mapped()) {
 898       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
 899       assert(present, &quot;Missing archived mirror for %s&quot;, k-&gt;external_name());
 900       return;
 901     } else {
 902       k-&gt;set_java_mirror_handle(OopHandle());
 903       k-&gt;clear_has_raw_archived_mirror();
 904     }
 905   }
 906   create_mirror(k, Handle(), Handle(), Handle(), Handle(), CHECK);
 907 }
 908 
 909 void java_lang_Class::initialize_mirror_fields(Klass* k,
 910                                                Handle mirror,
 911                                                Handle protection_domain,
 912                                                Handle classData,
 913                                                TRAPS) {
 914   // Allocate a simple java object for a lock.
 915   // This needs to be a java object because during class initialization
 916   // it can be held across a java call.
 917   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 918   set_init_lock(mirror(), r);
 919 
 920   // Set protection domain also
 921   set_protection_domain(mirror(), protection_domain());
 922 
 923   // Initialize static fields
 924   InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);
 925 
 926  // Set classData
 927   set_class_data(mirror(), classData());
 928 }
 929 
 930 // Set the java.lang.Module module field in the java_lang_Class mirror
 931 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
 932   if (module.is_null()) {
 933     // During startup, the module may be NULL only if java.base has not been defined yet.
 934     // Put the class on the fixup_module_list to patch later when the java.lang.Module
 935     // for java.base is known. But note that since we captured the NULL module another
 936     // thread may have completed that initialization.
 937 
 938     bool javabase_was_defined = false;
 939     {
 940       MutexLocker m1(THREAD, Module_lock);
 941       // Keep list of classes needing java.base module fixup
 942       if (!ModuleEntryTable::javabase_defined()) {
 943         assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
 944         k-&gt;class_loader_data()-&gt;inc_keep_alive();
 945         assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
 946         fixup_module_field_list()-&gt;push(k);
 947       } else {
 948         javabase_was_defined = true;
 949       }
 950     }
 951 
 952     // If java.base was already defined then patch this particular class with java.base.
 953     if (javabase_was_defined) {
 954       ModuleEntry *javabase_entry = ModuleEntryTable::javabase_moduleEntry();
 955       assert(javabase_entry != NULL &amp;&amp; javabase_entry-&gt;module() != NULL,
 956              &quot;Setting class module field, &quot; JAVA_BASE_NAME &quot; should be defined&quot;);
 957       Handle javabase_handle(THREAD, javabase_entry-&gt;module());
 958       set_module(mirror(), javabase_handle());
 959     }
 960   } else {
 961     assert(Universe::is_module_initialized() ||
 962            (ModuleEntryTable::javabase_defined() &amp;&amp;
 963             (module() == ModuleEntryTable::javabase_moduleEntry()-&gt;module())),
 964            &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
 965     set_module(mirror(), module());
 966   }
 967 }
 968 
 969 // Statically allocate fixup lists because they always get created.
 970 void java_lang_Class::allocate_fixup_lists() {
 971   GrowableArray&lt;Klass*&gt;* mirror_list =
 972     new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, mtClass);
 973   set_fixup_mirror_list(mirror_list);
 974 
 975   GrowableArray&lt;Klass*&gt;* module_list =
 976     new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;Klass*&gt;(500, mtModule);
 977   set_fixup_module_field_list(module_list);
 978 }
 979 
 980 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
 981                                     Handle module, Handle protection_domain,
 982                                     Handle classData, TRAPS) {
 983   assert(k != NULL, &quot;Use create_basic_type_mirror for primitive types&quot;);
 984   assert(k-&gt;java_mirror() == NULL, &quot;should only assign mirror once&quot;);
 985 
 986   // Use this moment of initialization to cache modifier_flags also,
 987   // to support Class.getModifiers().  Instance classes recalculate
 988   // the cached flags after the class file is parsed, but before the
 989   // class is put into the system dictionary.
 990   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 991   k-&gt;set_modifier_flags(computed_modifiers);
 992   // Class_klass has to be loaded because it is used to allocate
 993   // the mirror.
 994   if (SystemDictionary::Class_klass_loaded()) {
 995     // Allocate mirror (java.lang.Class instance)
 996     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 997     Handle mirror(THREAD, mirror_oop);
 998     Handle comp_mirror;
 999 
1000     // Setup indirection from mirror-&gt;klass
1001     java_lang_Class::set_klass(mirror(), k);
1002 
1003     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
1004     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
1005 
1006     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
1007 
1008     // It might also have a component mirror.  This mirror must already exist.
1009     if (k-&gt;is_array_klass()) {
<a name="4" id="anc4"></a><span class="line-modified">1010       if (k-&gt;is_flatArray_klass()) {</span>
<span class="line-added">1011         Klass* element_klass = (Klass*) FlatArrayKlass::cast(k)-&gt;element_klass();</span>
<span class="line-added">1012         assert(element_klass-&gt;is_inline_klass(), &quot;Must be inline type component&quot;);</span>
<span class="line-added">1013         InlineKlass* vk = InlineKlass::cast(InstanceKlass::cast(element_klass));</span>
<span class="line-added">1014         comp_mirror = Handle(THREAD, vk-&gt;java_mirror());</span>
<span class="line-added">1015       } else if (k-&gt;is_typeArray_klass()) {</span>
1016         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
1017         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
1018       } else {
1019         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1020         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1021         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1022         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
1023       }
1024       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
1025 
1026       // Two-way link between the array klass and its component mirror:
1027       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1028       set_component_mirror(mirror(), comp_mirror());
1029       // See below for ordering dependencies between field array_klass in component mirror
1030       // and java_mirror in this klass.
1031     } else {
1032       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1033 
1034       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1035       if (HAS_PENDING_EXCEPTION) {
1036         // If any of the fields throws an exception like OOM remove the klass field
1037         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
1038         // This mirror looks like a primitive type, which logically it is because it
1039         // it represents no class.
1040         java_lang_Class::set_klass(mirror(), NULL);
1041         return;
1042       }
1043     }
1044 
1045     // set the classLoader field in the java_lang_Class instance
1046     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1047     set_class_loader(mirror(), class_loader());
1048 
1049     // Setup indirection from klass-&gt;mirror
1050     // after any exceptions can happen during allocations.
1051     k-&gt;set_java_mirror(mirror);
1052 
1053     // Set the module field in the java_lang_Class instance.  This must be done
1054     // after the mirror is set.
1055     set_mirror_module_field(k, mirror, module, THREAD);
1056 
1057     if (comp_mirror() != NULL) {
1058       // Set after k-&gt;java_mirror() is published, because compiled code running
1059       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1060       release_set_array_klass(comp_mirror(), k);
1061     }
<a name="5" id="anc5"></a><span class="line-added">1062 </span>
<span class="line-added">1063     if (k-&gt;is_inline_klass()) {</span>
<span class="line-added">1064       InstanceKlass* super = k-&gt;java_super();</span>
<span class="line-added">1065       set_val_type_mirror(mirror(), mirror());</span>
<span class="line-added">1066 </span>
<span class="line-added">1067       // if the supertype is a restricted abstract class</span>
<span class="line-added">1068       if (super != SystemDictionary::Object_klass()) {</span>
<span class="line-added">1069         assert(super-&gt;access_flags().is_abstract(), &quot;must be an abstract class&quot;);</span>
<span class="line-added">1070         oop ref_type_oop = super-&gt;java_mirror();</span>
<span class="line-added">1071         // set the reference projection type</span>
<span class="line-added">1072         set_ref_type_mirror(mirror(), ref_type_oop);</span>
<span class="line-added">1073 </span>
<span class="line-added">1074         assert(oopDesc::is_oop(ref_type_oop), &quot;Sanity check&quot;);</span>
<span class="line-added">1075 </span>
<span class="line-added">1076         // set the value and reference projection types</span>
<span class="line-added">1077         set_val_type_mirror(ref_type_oop, mirror());</span>
<span class="line-added">1078         set_ref_type_mirror(ref_type_oop, ref_type_oop);</span>
<span class="line-added">1079       }</span>
<span class="line-added">1080     }</span>
1081   } else {
1082     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1083     fixup_mirror_list()-&gt;push(k);
1084   }
1085 }
1086 
1087 #if INCLUDE_CDS_JAVA_HEAP
1088 // Clears mirror fields. Static final fields with initial values are reloaded
1089 // from constant pool. The object identity hash is in the object header and is
1090 // not affected.
1091 class ResetMirrorField: public FieldClosure {
1092  private:
1093   Handle _m;
1094 
1095  public:
1096   ResetMirrorField(Handle mirror) : _m(mirror) {}
1097 
1098   void do_field(fieldDescriptor* fd) {
1099     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1100     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
1101 
1102     if (fd-&gt;is_static() &amp;&amp; fd-&gt;has_initial_value()) {
1103       initialize_static_field(fd, _m, Thread::current());
1104       return;
1105     }
1106 
1107     BasicType ft = fd-&gt;field_type();
1108     switch (ft) {
1109       case T_BYTE:
1110         _m()-&gt;byte_field_put(fd-&gt;offset(), 0);
1111         break;
1112       case T_CHAR:
1113         _m()-&gt;char_field_put(fd-&gt;offset(), 0);
1114         break;
1115       case T_DOUBLE:
1116         _m()-&gt;double_field_put(fd-&gt;offset(), 0);
1117         break;
1118       case T_FLOAT:
1119         _m()-&gt;float_field_put(fd-&gt;offset(), 0);
1120         break;
1121       case T_INT:
1122         _m()-&gt;int_field_put(fd-&gt;offset(), 0);
1123         break;
1124       case T_LONG:
1125         _m()-&gt;long_field_put(fd-&gt;offset(), 0);
1126         break;
1127       case T_SHORT:
1128         _m()-&gt;short_field_put(fd-&gt;offset(), 0);
1129         break;
1130       case T_BOOLEAN:
1131         _m()-&gt;bool_field_put(fd-&gt;offset(), false);
1132         break;
<a name="6" id="anc6"></a><span class="line-added">1133       case T_INLINE_TYPE:</span>
1134       case T_ARRAY:
1135       case T_OBJECT: {
1136         // It might be useful to cache the String field, but
1137         // for now just clear out any reference field
1138         oop o = _m()-&gt;obj_field(fd-&gt;offset());
1139         _m()-&gt;obj_field_put(fd-&gt;offset(), NULL);
1140         break;
1141       }
1142       default:
1143         ShouldNotReachHere();
1144         break;
1145      }
1146   }
1147 };
1148 
1149 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
1150   assert(HeapShared::is_heap_object_archiving_allowed(),
1151          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1152 
1153   for (int t = 0; t &lt;= T_VOID; t++) {
1154     oop m = Universe::_mirrors[t];
1155     if (m != NULL) {
1156       // Update the field at _array_klass_offset to point to the relocated array klass.
1157       oop archived_m = HeapShared::archive_heap_object(m, THREAD);
1158       assert(archived_m != NULL, &quot;sanity&quot;);
1159       Klass *ak = (Klass*)(archived_m-&gt;metadata_field(_array_klass_offset));
1160       assert(ak != NULL || t == T_VOID, &quot;should not be NULL&quot;);
1161       if (ak != NULL) {
1162         Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak, true);
1163         archived_m-&gt;metadata_field_put(_array_klass_offset, reloc_ak);
1164       }
1165 
1166       // Clear the fields. Just to be safe
1167       Klass *k = m-&gt;klass();
1168       Handle archived_mirror_h(THREAD, archived_m);
1169       ResetMirrorField reset(archived_mirror_h);
1170       InstanceKlass::cast(k)-&gt;do_nonstatic_fields(&amp;reset);
1171 
1172       log_trace(cds, heap, mirror)(
1173         &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1174         type2name((BasicType)t), p2i(Universe::_mirrors[t]), p2i(archived_m));
1175 
1176       Universe::_mirrors[t] = archived_m;
1177     }
1178   }
1179 
1180   assert(Universe::_mirrors[T_INT] != NULL &amp;&amp;
1181          Universe::_mirrors[T_FLOAT] != NULL &amp;&amp;
1182          Universe::_mirrors[T_DOUBLE] != NULL &amp;&amp;
1183          Universe::_mirrors[T_BYTE] != NULL &amp;&amp;
1184          Universe::_mirrors[T_BOOLEAN] != NULL &amp;&amp;
1185          Universe::_mirrors[T_CHAR] != NULL &amp;&amp;
1186          Universe::_mirrors[T_LONG] != NULL &amp;&amp;
1187          Universe::_mirrors[T_SHORT] != NULL &amp;&amp;
1188          Universe::_mirrors[T_VOID] != NULL, &quot;sanity&quot;);
1189 
1190   Universe::set_int_mirror(Universe::_mirrors[T_INT]);
1191   Universe::set_float_mirror(Universe::_mirrors[T_FLOAT]);
1192   Universe::set_double_mirror(Universe::_mirrors[T_DOUBLE]);
1193   Universe::set_byte_mirror(Universe::_mirrors[T_BYTE]);
1194   Universe::set_bool_mirror(Universe::_mirrors[T_BOOLEAN]);
1195   Universe::set_char_mirror(Universe::_mirrors[T_CHAR]);
1196   Universe::set_long_mirror(Universe::_mirrors[T_LONG]);
1197   Universe::set_short_mirror(Universe::_mirrors[T_SHORT]);
1198   Universe::set_void_mirror(Universe::_mirrors[T_VOID]);
1199 }
1200 
1201 //
1202 // After the mirror object is successfully archived, the archived
1203 // klass is set with _has_archived_raw_mirror flag.
1204 //
1205 // The _has_archived_raw_mirror flag is cleared at runtime when the
1206 // archived mirror is restored. If archived java heap data cannot
1207 // be used at runtime, new mirror object is created for the shared
1208 // class. The _has_archived_raw_mirror is cleared also during the process.
1209 oop java_lang_Class::archive_mirror(Klass* k, TRAPS) {
1210   assert(HeapShared::is_heap_object_archiving_allowed(),
1211          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1212 
1213   // Mirror is already archived
1214   if (k-&gt;has_raw_archived_mirror()) {
1215     assert(k-&gt;archived_java_mirror_raw() != NULL, &quot;no archived mirror&quot;);
1216     return k-&gt;archived_java_mirror_raw();
1217   }
1218 
1219   // No mirror
1220   oop mirror = k-&gt;java_mirror();
1221   if (mirror == NULL) {
1222     return NULL;
1223   }
1224 
1225   if (k-&gt;is_instance_klass()) {
1226     InstanceKlass *ik = InstanceKlass::cast(k);
1227     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1228 
1229     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1230           ik-&gt;is_shared_app_class())) {
1231       // Archiving mirror for classes from non-builtin loaders is not
1232       // supported. Clear the _java_mirror within the archived class.
1233       k-&gt;set_java_mirror_handle(OopHandle());
1234       return NULL;
1235     }
1236   }
1237 
<a name="7" id="anc7"></a><span class="line-added">1238   if (k-&gt;is_inline_klass()) {</span>
<span class="line-added">1239     // Inline types have a val type mirror and a ref type mirror. Don&#39;t handle this for now. TODO:CDS</span>
<span class="line-added">1240     k-&gt;set_java_mirror_handle(OopHandle());</span>
<span class="line-added">1241     return NULL;</span>
<span class="line-added">1242   }</span>
<span class="line-added">1243 </span>
1244   // Now start archiving the mirror object
1245   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1246   if (archived_mirror == NULL) {
1247     return NULL;
1248   }
1249 
1250   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1251   if (archived_mirror == NULL) {
1252     return NULL;
1253   }
1254 
1255   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1256 
1257   k-&gt;set_has_raw_archived_mirror();
1258 
1259   ResourceMark rm;
1260   log_trace(cds, heap, mirror)(
1261     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1262     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1263 
1264   return archived_mirror;
1265 }
1266 
1267 // The process is based on create_mirror().
1268 oop java_lang_Class::process_archived_mirror(Klass* k, oop mirror,
1269                                              oop archived_mirror,
1270                                              Thread *THREAD) {
1271   // Clear nonstatic fields in archived mirror. Some of the fields will be set
1272   // to archived metadata and objects below.
1273   Klass *c = archived_mirror-&gt;klass();
1274   Handle archived_mirror_h(THREAD, archived_mirror);
1275   ResetMirrorField reset(archived_mirror_h);
1276   InstanceKlass::cast(c)-&gt;do_nonstatic_fields(&amp;reset);
1277 
1278   if (k-&gt;is_array_klass()) {
1279     oop archived_comp_mirror;
1280     if (k-&gt;is_typeArray_klass()) {
1281       // The primitive type mirrors are already archived. Get the archived mirror.
1282       oop comp_mirror = java_lang_Class::component_mirror(mirror);
1283       archived_comp_mirror = HeapShared::find_archived_heap_object(comp_mirror);
1284       assert(archived_comp_mirror != NULL, &quot;Must be&quot;);
1285     } else {
1286       assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1287       Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1288       assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1289       archived_comp_mirror = archive_mirror(element_klass, THREAD);
1290       if (archived_comp_mirror == NULL) {
1291         return NULL;
1292       }
1293     }
1294     java_lang_Class::set_component_mirror(archived_mirror, archived_comp_mirror);
1295   } else {
1296     assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1297 
1298     // Reset local static fields in the mirror
1299     InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;reset);
1300 
1301     java_lang_Class:set_init_lock(archived_mirror, NULL);
1302 
1303     set_protection_domain(archived_mirror, NULL);
1304   }
1305 
1306   // clear class loader and mirror_module_field
1307   set_class_loader(archived_mirror, NULL);
1308   set_module(archived_mirror, NULL);
1309 
1310   // The archived mirror&#39;s field at _klass_offset is still pointing to the original
1311   // klass. Updated the field in the archived mirror to point to the relocated
1312   // klass in the archive.
1313   Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror), true);
1314   log_debug(cds, heap, mirror)(
1315     &quot;Relocate mirror metadata field at _klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1316     p2i(as_Klass(mirror)), p2i(reloc_k));
1317   archived_mirror-&gt;metadata_field_put(_klass_offset, reloc_k);
1318 
1319   // The field at _array_klass_offset is pointing to the original one dimension
1320   // higher array klass if exists. Relocate the pointer.
1321   Klass *arr = array_klass_acquire(mirror);
1322   if (arr != NULL) {
1323     Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr, true);
1324     log_debug(cds, heap, mirror)(
1325       &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1326       p2i(arr), p2i(reloc_arr));
1327     archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
1328   }
1329   return archived_mirror;
1330 }
1331 
1332 void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {
1333   if (MetaspaceShared::relocation_delta() != 0) {
1334     assert(archived_mirror-&gt;metadata_field(_klass_offset) == NULL, &quot;must be for primitive class&quot;);
1335 
1336     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1337     if (ak != NULL) {
1338       archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1339           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1340     }
1341   }
1342 }
1343 
1344 void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {
1345   assert(MetaspaceShared::relocation_delta() != 0, &quot;must be&quot;);
1346 
1347   Klass* k = ((Klass*)archived_mirror-&gt;metadata_field(_klass_offset));
1348   archived_mirror-&gt;metadata_field_put(_klass_offset,
1349       (Klass*)(address(k) + MetaspaceShared::relocation_delta()));
1350 
1351   Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1352   if (ak != NULL) {
1353     archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1354         (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1355   }
1356 }
1357 
1358 
1359 // Returns true if the mirror is updated, false if no archived mirror
1360 // data is present. After the archived mirror object is restored, the
1361 // shared klass&#39; _has_raw_archived_mirror flag is cleared.
1362 bool java_lang_Class::restore_archived_mirror(Klass *k,
1363                                               Handle class_loader, Handle module,
1364                                               Handle protection_domain, TRAPS) {
1365   // Postpone restoring archived mirror until java.lang.Class is loaded. Please
1366   // see more details in SystemDictionary::resolve_well_known_classes().
1367   if (!SystemDictionary::Class_klass_loaded()) {
1368     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1369     fixup_mirror_list()-&gt;push(k);
1370     return true;
1371   }
1372 
1373   oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
1374   if (m == NULL) {
1375     return false;
1376   }
1377 
1378   // mirror is archived, restore
1379   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));
1380   assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);
1381   assert(as_Klass(m) == k, &quot;must be&quot;);
1382   Handle mirror(THREAD, m);
1383 
1384   if (!k-&gt;is_array_klass()) {
1385     // - local static final fields with initial values were initialized at dump time
1386 
1387     // create the init_lock
1388     typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));
1389     set_init_lock(mirror(), r);
1390 
1391     if (protection_domain.not_null()) {
1392       set_protection_domain(mirror(), protection_domain());
1393     }
1394   }
1395 
1396   assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1397   if (class_loader.not_null()) {
1398     set_class_loader(mirror(), class_loader());
1399   }
1400 
1401   k-&gt;set_java_mirror(mirror);
1402   k-&gt;clear_has_raw_archived_mirror();
1403 
1404   set_mirror_module_field(k, mirror, module, THREAD);
1405 
1406   if (log_is_enabled(Trace, cds, heap, mirror)) {
1407     ResourceMark rm(THREAD);
1408     log_trace(cds, heap, mirror)(
1409         &quot;Restored %s archived mirror &quot; PTR_FORMAT, k-&gt;external_name(), p2i(mirror()));
1410   }
1411 
1412   return true;
1413 }
1414 #endif // INCLUDE_CDS_JAVA_HEAP
1415 
1416 void java_lang_Class::fixup_module_field(Klass* k, Handle module) {
1417   assert(_module_offset != 0, &quot;must have been computed already&quot;);
1418   java_lang_Class::set_module(k-&gt;java_mirror(), module());
1419 }
1420 
1421 int  java_lang_Class::oop_size(oop java_class) {
1422   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1423   int size = java_class-&gt;int_field(_oop_size_offset);
1424   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1425   return size;
1426 }
1427 
1428 
1429 void java_lang_Class::set_oop_size(HeapWord* java_class, int size) {
1430   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1431   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1432   *(int*)(((char*)java_class) + _oop_size_offset) = size;
1433 }
1434 
1435 int  java_lang_Class::static_oop_field_count(oop java_class) {
1436   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1437   return java_class-&gt;int_field(_static_oop_field_count_offset);
1438 }
1439 
1440 int  java_lang_Class::static_oop_field_count_raw(oop java_class) {
1441   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1442   return java_class-&gt;int_field_raw(_static_oop_field_count_offset);
1443 }
1444 
1445 void java_lang_Class::set_static_oop_field_count(oop java_class, int size) {
1446   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1447   java_class-&gt;int_field_put(_static_oop_field_count_offset, size);
1448 }
1449 
1450 oop java_lang_Class::protection_domain(oop java_class) {
1451   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1452   return java_class-&gt;obj_field(_protection_domain_offset);
1453 }
1454 void java_lang_Class::set_protection_domain(oop java_class, oop pd) {
1455   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1456   java_class-&gt;obj_field_put(_protection_domain_offset, pd);
1457 }
1458 
1459 void java_lang_Class::set_component_mirror(oop java_class, oop comp_mirror) {
1460   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1461     java_class-&gt;obj_field_put(_component_mirror_offset, comp_mirror);
1462   }
1463 oop java_lang_Class::component_mirror(oop java_class) {
1464   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1465   return java_class-&gt;obj_field(_component_mirror_offset);
1466 }
1467 
1468 oop java_lang_Class::init_lock(oop java_class) {
1469   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1470   return java_class-&gt;obj_field(_init_lock_offset);
1471 }
1472 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
1473   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1474   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
1475 }
1476 
1477 objArrayOop java_lang_Class::signers(oop java_class) {
1478   assert(_signers_offset != 0, &quot;must be set&quot;);
1479   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
1480 }
1481 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
1482   assert(_signers_offset != 0, &quot;must be set&quot;);
1483   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
1484 }
1485 
1486 oop java_lang_Class::class_data(oop java_class) {
1487   assert(_classData_offset != 0, &quot;must be set&quot;);
1488   return java_class-&gt;obj_field(_classData_offset);
1489 }
1490 void java_lang_Class::set_class_data(oop java_class, oop class_data) {
1491   assert(_classData_offset != 0, &quot;must be set&quot;);
1492   java_class-&gt;obj_field_put(_classData_offset, class_data);
1493 }
1494 
1495 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
1496   assert(_class_loader_offset != 0, &quot;offsets should have been initialized&quot;);
1497   java_class-&gt;obj_field_put(_class_loader_offset, loader);
1498 }
1499 
1500 oop java_lang_Class::class_loader(oop java_class) {
1501   assert(_class_loader_offset != 0, &quot;must be set&quot;);
1502   return java_class-&gt;obj_field(_class_loader_offset);
1503 }
1504 
1505 oop java_lang_Class::module(oop java_class) {
1506   assert(_module_offset != 0, &quot;must be set&quot;);
1507   return java_class-&gt;obj_field(_module_offset);
1508 }
1509 
1510 void java_lang_Class::set_module(oop java_class, oop module) {
1511   assert(_module_offset != 0, &quot;must be set&quot;);
1512   java_class-&gt;obj_field_put(_module_offset, module);
1513 }
1514 
1515 oop java_lang_Class::name(Handle java_class, TRAPS) {
1516   assert(_name_offset != 0, &quot;must be set&quot;);
1517   oop o = java_class-&gt;obj_field(_name_offset);
1518   if (o == NULL) {
1519     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1520     java_class-&gt;obj_field_put(_name_offset, o);
1521   }
1522   return o;
1523 }
1524 
1525 oop java_lang_Class::source_file(oop java_class) {
1526   assert(_source_file_offset != 0, &quot;must be set&quot;);
1527   return java_class-&gt;obj_field(_source_file_offset);
1528 }
1529 
1530 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1531   assert(_source_file_offset != 0, &quot;must be set&quot;);
1532   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1533 }
1534 
<a name="8" id="anc8"></a><span class="line-added">1535 oop java_lang_Class::val_type_mirror(oop java_class) {</span>
<span class="line-added">1536   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1537   return java_class-&gt;obj_field(_val_type_mirror_offset);</span>
<span class="line-added">1538 }</span>
<span class="line-added">1539 </span>
<span class="line-added">1540 void java_lang_Class::set_val_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1541   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1542   java_class-&gt;obj_field_put(_val_type_mirror_offset, mirror);</span>
<span class="line-added">1543 }</span>
<span class="line-added">1544 </span>
<span class="line-added">1545 oop java_lang_Class::ref_type_mirror(oop java_class) {</span>
<span class="line-added">1546   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1547   return java_class-&gt;obj_field(_ref_type_mirror_offset);</span>
<span class="line-added">1548 }</span>
<span class="line-added">1549 </span>
<span class="line-added">1550 void java_lang_Class::set_ref_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1551   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1552   java_class-&gt;obj_field_put(_ref_type_mirror_offset, mirror);</span>
<span class="line-added">1553 }</span>
<span class="line-added">1554 </span>
1555 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1556   // This should be improved by adding a field at the Java level or by
1557   // introducing a new VM klass (see comment in ClassFileParser)
1558   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1559   if (type != T_VOID) {
1560     Klass* aklass = Universe::typeArrayKlassObj(type);
1561     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1562     release_set_array_klass(java_class, aklass);
1563   }
1564 #ifdef ASSERT
1565   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1566   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1567 #endif
1568   return java_class;
1569 }
1570 
1571 
1572 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1573   //%note memory_2
1574   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1575   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1576   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1577   return k;
1578 }
1579 
1580 
1581 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1582   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1583   java_class-&gt;metadata_field_put(_klass_offset, klass);
1584 }
1585 
1586 
1587 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1588   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1589   Symbol* name = NULL;
1590   bool is_instance = false;
<a name="9" id="anc9"></a><span class="line-added">1591   bool is_value = false;</span>
1592   if (is_primitive(java_class)) {
1593     name = vmSymbols::type_signature(primitive_type(java_class));
1594   } else {
1595     Klass* k = as_Klass(java_class);
1596     is_instance = k-&gt;is_instance_klass();
<a name="10" id="anc10"></a><span class="line-added">1597     is_value = k-&gt;is_inline_klass();</span>
1598     name = k-&gt;name();
1599   }
1600   if (name == NULL) {
1601     st-&gt;print(&quot;&lt;null&gt;&quot;);
1602     return;
1603   }
<a name="11" id="anc11"></a><span class="line-modified">1604   if (is_instance)  {</span>
<span class="line-added">1605     if (is_value) {</span>
<span class="line-added">1606       st-&gt;print(&quot;Q&quot;);</span>
<span class="line-added">1607     } else {</span>
<span class="line-added">1608       st-&gt;print(&quot;L&quot;);</span>
<span class="line-added">1609     }</span>
<span class="line-added">1610   }</span>
1611   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1612   if (is_instance)  st-&gt;print(&quot;;&quot;);
1613 }
1614 
1615 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1616   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1617   Symbol* name;
1618   if (is_primitive(java_class)) {
1619     name = vmSymbols::type_signature(primitive_type(java_class));
1620     // Because this can create a new symbol, the caller has to decrement
1621     // the refcount, so make adjustment here and below for symbols returned
1622     // that are not created or incremented due to a successful lookup.
1623     name-&gt;increment_refcount();
1624   } else {
1625     Klass* k = as_Klass(java_class);
1626     if (!k-&gt;is_instance_klass()) {
1627       name = k-&gt;name();
1628       name-&gt;increment_refcount();
1629     } else {
1630       ResourceMark rm;
1631       const char* sigstr = k-&gt;signature_name();
<a name="12" id="anc12"></a><span class="line-modified">1632       int siglen = (int) strlen(sigstr);</span>
1633       if (!intern_if_not_found) {
1634         name = SymbolTable::probe(sigstr, siglen);
1635       } else {
1636         name = SymbolTable::new_symbol(sigstr, siglen);
1637       }
1638     }
1639   }
1640   return name;
1641 }
1642 
1643 // Returns the Java name for this Java mirror (Resource allocated)
1644 // See Klass::external_name().
1645 // For primitive type Java mirrors, its type name is returned.
1646 const char* java_lang_Class::as_external_name(oop java_class) {
1647   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1648   const char* name = NULL;
1649   if (is_primitive(java_class)) {
1650     name = type2name(primitive_type(java_class));
1651   } else {
1652     name = as_Klass(java_class)-&gt;external_name();
1653   }
1654   if (name == NULL) {
1655     name = &quot;&lt;null&gt;&quot;;
1656   }
1657   return name;
1658 }
1659 
1660 Klass* java_lang_Class::array_klass_acquire(oop java_class) {
1661   Klass* k = ((Klass*)java_class-&gt;metadata_field_acquire(_array_klass_offset));
1662   assert(k == NULL || k-&gt;is_klass() &amp;&amp; k-&gt;is_array_klass(), &quot;should be array klass&quot;);
1663   return k;
1664 }
1665 
1666 
1667 void java_lang_Class::release_set_array_klass(oop java_class, Klass* klass) {
1668   assert(klass-&gt;is_klass() &amp;&amp; klass-&gt;is_array_klass(), &quot;should be array klass&quot;);
1669   java_class-&gt;release_metadata_field_put(_array_klass_offset, klass);
1670 }
1671 
1672 
1673 BasicType java_lang_Class::primitive_type(oop java_class) {
1674   assert(java_lang_Class::is_primitive(java_class), &quot;just checking&quot;);
1675   Klass* ak = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
1676   BasicType type = T_VOID;
1677   if (ak != NULL) {
1678     // Note: create_basic_type_mirror above initializes ak to a non-null value.
1679     type = ArrayKlass::cast(ak)-&gt;element_type();
1680   } else {
1681     assert(java_class == Universe::void_mirror(), &quot;only valid non-array primitive&quot;);
1682   }
1683   assert(Universe::java_mirror(type) == java_class, &quot;must be consistent&quot;);
1684   return type;
1685 }
1686 
1687 BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
1688   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1689   if (is_primitive(java_class)) {
1690     if (reference_klass != NULL)
1691       (*reference_klass) = NULL;
1692     return primitive_type(java_class);
1693   } else {
1694     if (reference_klass != NULL)
1695       (*reference_klass) = as_Klass(java_class);
1696     return T_OBJECT;
1697   }
1698 }
1699 
1700 
1701 oop java_lang_Class::primitive_mirror(BasicType t) {
1702   oop mirror = Universe::java_mirror(t);
1703   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1704   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1705   return mirror;
1706 }
1707 
1708 #define CLASS_FIELDS_DO(macro) \
1709   macro(_classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1710   macro(_class_loader_offset,        k, &quot;classLoader&quot;,         classloader_signature, false); \
1711   macro(_component_mirror_offset,    k, &quot;componentType&quot;,       class_signature,       false); \
1712   macro(_module_offset,              k, &quot;module&quot;,              module_signature,      false); \
1713   macro(_name_offset,                k, &quot;name&quot;,                string_signature,      false); \
<a name="13" id="anc13"></a><span class="line-added">1714   macro(_val_type_mirror_offset,     k, &quot;valType&quot;,             class_signature,       false); \</span>
<span class="line-added">1715   macro(_ref_type_mirror_offset,     k, &quot;refType&quot;,             class_signature,       false); \</span>
1716   macro(_classData_offset,           k, &quot;classData&quot;,           object_signature,      false);
1717 
1718 void java_lang_Class::compute_offsets() {
1719   if (_offsets_computed) {
1720     return;
1721   }
1722 
1723   _offsets_computed = true;
1724 
1725   InstanceKlass* k = SystemDictionary::Class_klass();
1726   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1727 
1728   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1729   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1730   // GC treats them the same.
1731   _init_lock_offset = _component_mirror_offset;
1732 
1733   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1734 }
1735 
1736 #if INCLUDE_CDS
1737 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
1738   f-&gt;do_bool(&amp;_offsets_computed);
1739   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1740 
1741   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1742 
1743   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1744 }
1745 #endif
1746 
1747 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
1748   assert(_classRedefinedCount_offset != 0, &quot;offsets should have been initialized&quot;);
1749   return the_class_mirror-&gt;int_field(_classRedefinedCount_offset);
1750 }
1751 
1752 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
1753   assert(_classRedefinedCount_offset != 0, &quot;offsets should have been initialized&quot;);
1754   the_class_mirror-&gt;int_field_put(_classRedefinedCount_offset, value);
1755 }
1756 
1757 
1758 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1759 //       platform thread structure, and a eetop offset which was used for thread
1760 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1761 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1762 //       instead of the privateInfo_offset.
1763 //
1764 // Note: The stackSize field is only present starting in 1.4.
1765 
1766 int java_lang_Thread::_name_offset;
1767 int java_lang_Thread::_group_offset;
1768 int java_lang_Thread::_contextClassLoader_offset;
1769 int java_lang_Thread::_inheritedAccessControlContext_offset;
1770 int java_lang_Thread::_priority_offset;
1771 int java_lang_Thread::_eetop_offset;
1772 int java_lang_Thread::_interrupted_offset;
1773 int java_lang_Thread::_daemon_offset;
1774 int java_lang_Thread::_stillborn_offset;
1775 int java_lang_Thread::_stackSize_offset;
1776 int java_lang_Thread::_tid_offset;
1777 int java_lang_Thread::_thread_status_offset;
1778 int java_lang_Thread::_park_blocker_offset;
1779 
1780 #define THREAD_FIELDS_DO(macro) \
1781   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1782   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1783   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1784   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1785   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1786   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1787   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
1788   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \
1789   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1790   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1791   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1792   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
1793   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false)
1794 
1795 void java_lang_Thread::compute_offsets() {
1796   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1797 
1798   InstanceKlass* k = SystemDictionary::Thread_klass();
1799   THREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1800 }
1801 
1802 #if INCLUDE_CDS
1803 void java_lang_Thread::serialize_offsets(SerializeClosure* f) {
1804   THREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1805 }
1806 #endif
1807 
1808 JavaThread* java_lang_Thread::thread(oop java_thread) {
1809   return (JavaThread*)java_thread-&gt;address_field(_eetop_offset);
1810 }
1811 
1812 
1813 void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
1814   java_thread-&gt;address_field_put(_eetop_offset, (address)thread);
1815 }
1816 
1817 bool java_lang_Thread::interrupted(oop java_thread) {
1818   // Make sure the caller can safely access oops.
1819   assert(Thread::current()-&gt;is_VM_thread() ||
1820          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1821           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1822          &quot;Unsafe access to oop&quot;);
1823   return java_thread-&gt;bool_field_volatile(_interrupted_offset);
1824 }
1825 
1826 void java_lang_Thread::set_interrupted(oop java_thread, bool val) {
1827   // Make sure the caller can safely access oops.
1828   assert(Thread::current()-&gt;is_VM_thread() ||
1829          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1830           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1831          &quot;Unsafe access to oop&quot;);
1832   java_thread-&gt;bool_field_put_volatile(_interrupted_offset, val);
1833 }
1834 
1835 
1836 oop java_lang_Thread::name(oop java_thread) {
1837   return java_thread-&gt;obj_field(_name_offset);
1838 }
1839 
1840 
1841 void java_lang_Thread::set_name(oop java_thread, oop name) {
1842   java_thread-&gt;obj_field_put(_name_offset, name);
1843 }
1844 
1845 
1846 ThreadPriority java_lang_Thread::priority(oop java_thread) {
1847   return (ThreadPriority)java_thread-&gt;int_field(_priority_offset);
1848 }
1849 
1850 
1851 void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {
1852   java_thread-&gt;int_field_put(_priority_offset, priority);
1853 }
1854 
1855 
1856 oop java_lang_Thread::threadGroup(oop java_thread) {
1857   return java_thread-&gt;obj_field(_group_offset);
1858 }
1859 
1860 
1861 bool java_lang_Thread::is_stillborn(oop java_thread) {
1862   return java_thread-&gt;bool_field(_stillborn_offset) != 0;
1863 }
1864 
1865 
1866 // We never have reason to turn the stillborn bit off
1867 void java_lang_Thread::set_stillborn(oop java_thread) {
1868   java_thread-&gt;bool_field_put(_stillborn_offset, true);
1869 }
1870 
1871 
1872 bool java_lang_Thread::is_alive(oop java_thread) {
1873   JavaThread* thr = java_lang_Thread::thread(java_thread);
1874   return (thr != NULL);
1875 }
1876 
1877 
1878 bool java_lang_Thread::is_daemon(oop java_thread) {
1879   return java_thread-&gt;bool_field(_daemon_offset) != 0;
1880 }
1881 
1882 
1883 void java_lang_Thread::set_daemon(oop java_thread) {
1884   java_thread-&gt;bool_field_put(_daemon_offset, true);
1885 }
1886 
1887 oop java_lang_Thread::context_class_loader(oop java_thread) {
1888   return java_thread-&gt;obj_field(_contextClassLoader_offset);
1889 }
1890 
1891 oop java_lang_Thread::inherited_access_control_context(oop java_thread) {
1892   return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
1893 }
1894 
1895 
1896 jlong java_lang_Thread::stackSize(oop java_thread) {
1897   return java_thread-&gt;long_field(_stackSize_offset);
1898 }
1899 
1900 // Write the thread status value to threadStatus field in java.lang.Thread java class.
1901 void java_lang_Thread::set_thread_status(oop java_thread,
1902                                          java_lang_Thread::ThreadStatus status) {
1903   java_thread-&gt;int_field_put(_thread_status_offset, status);
1904 }
1905 
1906 // Read thread status value from threadStatus field in java.lang.Thread java class.
1907 java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
1908   // Make sure the caller is operating on behalf of the VM or is
1909   // running VM code (state == _thread_in_vm).
1910   assert(Threads_lock-&gt;owned_by_self() || Thread::current()-&gt;is_VM_thread() ||
1911          JavaThread::current()-&gt;thread_state() == _thread_in_vm,
1912          &quot;Java Thread is not running in vm&quot;);
1913   return (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1914 }
1915 
1916 
1917 jlong java_lang_Thread::thread_id(oop java_thread) {
1918   return java_thread-&gt;long_field(_tid_offset);
1919 }
1920 
1921 oop java_lang_Thread::park_blocker(oop java_thread) {
1922   return java_thread-&gt;obj_field(_park_blocker_offset);
1923 }
1924 
1925 const char* java_lang_Thread::thread_status_name(oop java_thread) {
1926   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1927   switch (status) {
1928     case NEW                      : return &quot;NEW&quot;;
1929     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1930     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1931     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1932     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1933     case PARKED                   : return &quot;WAITING (parking)&quot;;
1934     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1935     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1936     case TERMINATED               : return &quot;TERMINATED&quot;;
1937     default                       : return &quot;UNKNOWN&quot;;
1938   };
1939 }
1940 int java_lang_ThreadGroup::_parent_offset;
1941 int java_lang_ThreadGroup::_name_offset;
1942 int java_lang_ThreadGroup::_threads_offset;
1943 int java_lang_ThreadGroup::_groups_offset;
1944 int java_lang_ThreadGroup::_maxPriority_offset;
1945 int java_lang_ThreadGroup::_destroyed_offset;
1946 int java_lang_ThreadGroup::_daemon_offset;
1947 int java_lang_ThreadGroup::_nthreads_offset;
1948 int java_lang_ThreadGroup::_ngroups_offset;
1949 
1950 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1951   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1952   return java_thread_group-&gt;obj_field(_parent_offset);
1953 }
1954 
1955 // (&quot;name as oop&quot; accessor is not necessary)
1956 
1957 const char* java_lang_ThreadGroup::name(oop java_thread_group) {
1958   oop name = java_thread_group-&gt;obj_field(_name_offset);
1959   // ThreadGroup.name can be null
1960   if (name != NULL) {
1961     return java_lang_String::as_utf8_string(name);
1962   }
1963   return NULL;
1964 }
1965 
1966 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1967   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1968   return java_thread_group-&gt;int_field(_nthreads_offset);
1969 }
1970 
1971 objArrayOop java_lang_ThreadGroup::threads(oop java_thread_group) {
1972   oop threads = java_thread_group-&gt;obj_field(_threads_offset);
1973   assert(threads != NULL, &quot;threadgroups should have threads&quot;);
1974   assert(threads-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1975   return objArrayOop(threads);
1976 }
1977 
1978 int java_lang_ThreadGroup::ngroups(oop java_thread_group) {
1979   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1980   return java_thread_group-&gt;int_field(_ngroups_offset);
1981 }
1982 
1983 objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {
1984   oop groups = java_thread_group-&gt;obj_field(_groups_offset);
1985   assert(groups == NULL || groups-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1986   return objArrayOop(groups);
1987 }
1988 
1989 ThreadPriority java_lang_ThreadGroup::maxPriority(oop java_thread_group) {
1990   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1991   return (ThreadPriority) java_thread_group-&gt;int_field(_maxPriority_offset);
1992 }
1993 
1994 bool java_lang_ThreadGroup::is_destroyed(oop java_thread_group) {
1995   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1996   return java_thread_group-&gt;bool_field(_destroyed_offset) != 0;
1997 }
1998 
1999 bool java_lang_ThreadGroup::is_daemon(oop java_thread_group) {
2000   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
2001   return java_thread_group-&gt;bool_field(_daemon_offset) != 0;
2002 }
2003 
2004 #define THREADGROUP_FIELDS_DO(macro) \
2005   macro(_parent_offset,      k, vmSymbols::parent_name(),      threadgroup_signature,       false); \
2006   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature,            false); \
2007   macro(_threads_offset,     k, vmSymbols::threads_name(),     thread_array_signature,      false); \
2008   macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature, false); \
2009   macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,               false); \
2010   macro(_destroyed_offset,   k, vmSymbols::destroyed_name(),   bool_signature,              false); \
2011   macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,              false); \
2012   macro(_nthreads_offset,    k, vmSymbols::nthreads_name(),    int_signature,               false); \
2013   macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,               false)
2014 
2015 void java_lang_ThreadGroup::compute_offsets() {
2016   assert(_parent_offset == 0, &quot;offsets should be initialized only once&quot;);
2017 
2018   InstanceKlass* k = SystemDictionary::ThreadGroup_klass();
2019   THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2020 }
2021 
2022 #if INCLUDE_CDS
2023 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
2024   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2025 }
2026 #endif
2027 
2028 // java_lang_Throwable
2029 
2030 int java_lang_Throwable::_backtrace_offset;
2031 int java_lang_Throwable::_detailMessage_offset;
2032 int java_lang_Throwable::_stackTrace_offset;
2033 int java_lang_Throwable::_depth_offset;
2034 int java_lang_Throwable::_static_unassigned_stacktrace_offset;
2035 
2036 #define THROWABLE_FIELDS_DO(macro) \
2037   macro(_backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \
2038   macro(_detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \
2039   macro(_stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \
2040   macro(_depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \
2041   macro(_static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)
2042 
2043 void java_lang_Throwable::compute_offsets() {
2044   InstanceKlass* k = SystemDictionary::Throwable_klass();
2045   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2046 }
2047 
2048 #if INCLUDE_CDS
2049 void java_lang_Throwable::serialize_offsets(SerializeClosure* f) {
2050   THROWABLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2051 }
2052 #endif
2053 
2054 oop java_lang_Throwable::unassigned_stacktrace() {
2055   InstanceKlass* ik = SystemDictionary::Throwable_klass();
2056   oop base = ik-&gt;static_field_base_raw();
2057   return base-&gt;obj_field(_static_unassigned_stacktrace_offset);
2058 }
2059 
2060 oop java_lang_Throwable::backtrace(oop throwable) {
2061   return throwable-&gt;obj_field_acquire(_backtrace_offset);
2062 }
2063 
2064 
2065 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
2066   throwable-&gt;release_obj_field_put(_backtrace_offset, value);
2067 }
2068 
2069 int java_lang_Throwable::depth(oop throwable) {
2070   return throwable-&gt;int_field(_depth_offset);
2071 }
2072 
2073 void java_lang_Throwable::set_depth(oop throwable, int value) {
2074   throwable-&gt;int_field_put(_depth_offset, value);
2075 }
2076 
2077 oop java_lang_Throwable::message(oop throwable) {
2078   return throwable-&gt;obj_field(_detailMessage_offset);
2079 }
2080 
2081 
2082 // Return Symbol for detailed_message or NULL
2083 Symbol* java_lang_Throwable::detail_message(oop throwable) {
2084   PRESERVE_EXCEPTION_MARK;  // Keep original exception
2085   oop detailed_message = java_lang_Throwable::message(throwable);
2086   if (detailed_message != NULL) {
2087     return java_lang_String::as_symbol(detailed_message);
2088   }
2089   return NULL;
2090 }
2091 
2092 void java_lang_Throwable::set_message(oop throwable, oop value) {
2093   throwable-&gt;obj_field_put(_detailMessage_offset, value);
2094 }
2095 
2096 
2097 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
2098   throwable-&gt;obj_field_put(_stackTrace_offset, st_element_array);
2099 }
2100 
2101 void java_lang_Throwable::clear_stacktrace(oop throwable) {
2102   set_stacktrace(throwable, NULL);
2103 }
2104 
2105 
2106 void java_lang_Throwable::print(oop throwable, outputStream* st) {
2107   ResourceMark rm;
2108   Klass* k = throwable-&gt;klass();
2109   assert(k != NULL, &quot;just checking&quot;);
2110   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
2111   oop msg = message(throwable);
2112   if (msg != NULL) {
2113     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
2114   }
2115 }
2116 
2117 // After this many redefines, the stack trace is unreliable.
2118 const int MAX_VERSION = USHRT_MAX;
2119 
2120 static inline bool version_matches(Method* method, int version) {
2121   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
2122   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
2123 }
2124 
2125 // This class provides a simple wrapper over the internal structure of
2126 // exception backtrace to insulate users of the backtrace from needing
2127 // to know what it looks like.
2128 // The code of this class is not GC safe. Allocations can only happen
2129 // in expand().
2130 class BacktraceBuilder: public StackObj {
2131  friend class BacktraceIterator;
2132  private:
2133   Handle          _backtrace;
2134   objArrayOop     _head;
2135   typeArrayOop    _methods;
2136   typeArrayOop    _bcis;
2137   objArrayOop     _mirrors;
2138   typeArrayOop    _names; // Needed to insulate method name against redefinition.
2139   // True if the top frame of the backtrace is omitted because it shall be hidden.
2140   bool            _has_hidden_top_frame;
2141   int             _index;
2142   NoSafepointVerifier _nsv;
2143 
2144   enum {
2145     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
2146     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
2147     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
2148     trace_names_offset   = java_lang_Throwable::trace_names_offset,
2149     trace_next_offset    = java_lang_Throwable::trace_next_offset,
2150     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,
2151     trace_size           = java_lang_Throwable::trace_size,
2152     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
2153   };
2154 
2155   // get info out of chunks
2156   static typeArrayOop get_methods(objArrayHandle chunk) {
2157     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2158     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2159     return methods;
2160   }
2161   static typeArrayOop get_bcis(objArrayHandle chunk) {
2162     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2163     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2164     return bcis;
2165   }
2166   static objArrayOop get_mirrors(objArrayHandle chunk) {
2167     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2168     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2169     return mirrors;
2170   }
2171   static typeArrayOop get_names(objArrayHandle chunk) {
2172     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2173     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2174     return names;
2175   }
2176   static bool has_hidden_top_frame(objArrayHandle chunk) {
2177     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);
2178     return hidden != NULL;
2179   }
2180 
2181  public:
2182 
2183   // constructor for new backtrace
2184   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {
2185     expand(CHECK);
2186     _backtrace = Handle(THREAD, _head);
2187     _index = 0;
2188   }
2189 
2190   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2191     _methods = get_methods(backtrace);
2192     _bcis = get_bcis(backtrace);
2193     _mirrors = get_mirrors(backtrace);
2194     _names = get_names(backtrace);
2195     _has_hidden_top_frame = has_hidden_top_frame(backtrace);
2196     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2197            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2198            _mirrors-&gt;length() == _names-&gt;length(),
2199            &quot;method and source information arrays should match&quot;);
2200 
2201     // head is the preallocated backtrace
2202     _head = backtrace();
2203     _backtrace = Handle(thread, _head);
2204     _index = 0;
2205   }
2206 
2207   void expand(TRAPS) {
2208     objArrayHandle old_head(THREAD, _head);
2209     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2210 
2211     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2212     objArrayHandle new_head(THREAD, head);
2213 
2214     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2215     typeArrayHandle new_methods(THREAD, methods);
2216 
2217     typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);
2218     typeArrayHandle new_bcis(THREAD, bcis);
2219 
2220     objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);
2221     objArrayHandle new_mirrors(THREAD, mirrors);
2222 
2223     typeArrayOop names = oopFactory::new_symbolArray(trace_chunk_size, CHECK);
2224     typeArrayHandle new_names(THREAD, names);
2225 
2226     if (!old_head.is_null()) {
2227       old_head-&gt;obj_at_put(trace_next_offset, new_head());
2228     }
2229     new_head-&gt;obj_at_put(trace_methods_offset, new_methods());
2230     new_head-&gt;obj_at_put(trace_bcis_offset, new_bcis());
2231     new_head-&gt;obj_at_put(trace_mirrors_offset, new_mirrors());
2232     new_head-&gt;obj_at_put(trace_names_offset, new_names());
2233     new_head-&gt;obj_at_put(trace_hidden_offset, NULL);
2234 
2235     _head    = new_head();
2236     _methods = new_methods();
2237     _bcis = new_bcis();
2238     _mirrors = new_mirrors();
2239     _names  = new_names();
2240     _index = 0;
2241   }
2242 
2243   oop backtrace() {
2244     return _backtrace();
2245   }
2246 
2247   inline void push(Method* method, int bci, TRAPS) {
2248     // Smear the -1 bci to 0 since the array only holds unsigned
2249     // shorts.  The later line number lookup would just smear the -1
2250     // to a 0 even if it could be recorded.
2251     if (bci == SynchronizationEntryBCI) bci = 0;
2252 
2253     if (_index &gt;= trace_chunk_size) {
2254       methodHandle mhandle(THREAD, method);
2255       expand(CHECK);
2256       method = mhandle();
2257     }
2258 
2259     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2260     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2261 
2262     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2263     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2264     Symbol* name = method-&gt;name();
2265     _names-&gt;symbol_at_put(_index, name);
2266 
2267     // We need to save the mirrors in the backtrace to keep the class
2268     // from being unloaded while we still have this stack trace.
2269     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2270     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2271     _index++;
2272   }
2273 
2274   void set_has_hidden_top_frame(TRAPS) {
2275     if (!_has_hidden_top_frame) {
2276       // It would be nice to add java/lang/Boolean::TRUE here
2277       // to indicate that this backtrace has a hidden top frame.
2278       // But this code is used before TRUE is allocated.
2279       // Therefore let&#39;s just use an arbitrary legal oop
2280       // available right here. _methods is a short[].
2281       assert(_methods != NULL, &quot;we need a legal oop&quot;);
2282       _has_hidden_top_frame = true;
2283       _head-&gt;obj_at_put(trace_hidden_offset, _methods);
2284     }
2285   }
2286 };
2287 
2288 struct BacktraceElement : public StackObj {
2289   int _method_id;
2290   int _bci;
2291   int _version;
2292   Symbol* _name;
2293   Handle _mirror;
2294   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2295                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2296 };
2297 
2298 class BacktraceIterator : public StackObj {
2299   int _index;
2300   objArrayHandle  _result;
2301   objArrayHandle  _mirrors;
2302   typeArrayHandle _methods;
2303   typeArrayHandle _bcis;
2304   typeArrayHandle _names;
2305 
2306   void init(objArrayHandle result, Thread* thread) {
2307     // Get method id, bci, version and mirror from chunk
2308     _result = result;
2309     if (_result.not_null()) {
2310       _methods = typeArrayHandle(thread, BacktraceBuilder::get_methods(_result));
2311       _bcis = typeArrayHandle(thread, BacktraceBuilder::get_bcis(_result));
2312       _mirrors = objArrayHandle(thread, BacktraceBuilder::get_mirrors(_result));
2313       _names = typeArrayHandle(thread, BacktraceBuilder::get_names(_result));
2314       _index = 0;
2315     }
2316   }
2317  public:
2318   BacktraceIterator(objArrayHandle result, Thread* thread) {
2319     init(result, thread);
2320     assert(_methods.is_null() || _methods-&gt;length() == java_lang_Throwable::trace_chunk_size, &quot;lengths don&#39;t match&quot;);
2321   }
2322 
2323   BacktraceElement next(Thread* thread) {
2324     BacktraceElement e (Handle(thread, _mirrors-&gt;obj_at(_index)),
2325                         _methods-&gt;ushort_at(_index),
2326                         Backtrace::version_at(_bcis-&gt;int_at(_index)),
2327                         Backtrace::bci_at(_bcis-&gt;int_at(_index)),
2328                         _names-&gt;symbol_at(_index));
2329     _index++;
2330 
2331     if (_index &gt;= java_lang_Throwable::trace_chunk_size) {
2332       int next_offset = java_lang_Throwable::trace_next_offset;
2333       // Get next chunk
2334       objArrayHandle result (thread, objArrayOop(_result-&gt;obj_at(next_offset)));
2335       init(result, thread);
2336     }
2337     return e;
2338   }
2339 
2340   bool repeat() {
2341     return _result.not_null() &amp;&amp; _mirrors-&gt;obj_at(_index) != NULL;
2342   }
2343 };
2344 
2345 
2346 // Print stack trace element to resource allocated buffer
2347 static void print_stack_element_to_stream(outputStream* st, Handle mirror, int method_id,
2348                                           int version, int bci, Symbol* name) {
2349   ResourceMark rm;
2350 
2351   // Get strings and string lengths
2352   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(mirror()));
2353   const char* klass_name  = holder-&gt;external_name();
2354   int buf_len = (int)strlen(klass_name);
2355 
2356   char* method_name = name-&gt;as_C_string();
2357   buf_len += (int)strlen(method_name);
2358 
2359   char* source_file_name = NULL;
2360   Symbol* source = Backtrace::get_source_file_name(holder, version);
2361   if (source != NULL) {
2362     source_file_name = source-&gt;as_C_string();
2363     buf_len += (int)strlen(source_file_name);
2364   }
2365 
2366   char *module_name = NULL, *module_version = NULL;
2367   ModuleEntry* module = holder-&gt;module();
2368   if (module-&gt;is_named()) {
2369     module_name = module-&gt;name()-&gt;as_C_string();
2370     buf_len += (int)strlen(module_name);
2371     if (module-&gt;version() != NULL) {
2372       module_version = module-&gt;version()-&gt;as_C_string();
2373       buf_len += (int)strlen(module_version);
2374     }
2375   }
2376 
2377   // Allocate temporary buffer with extra space for formatting and line number
2378   char* buf = NEW_RESOURCE_ARRAY(char, buf_len + 64);
2379 
2380   // Print stack trace line in buffer
2381   sprintf(buf, &quot;\tat %s.%s(&quot;, klass_name, method_name);
2382 
2383   // Print module information
2384   if (module_name != NULL) {
2385     if (module_version != NULL) {
2386       sprintf(buf + (int)strlen(buf), &quot;%s@%s/&quot;, module_name, module_version);
2387     } else {
2388       sprintf(buf + (int)strlen(buf), &quot;%s/&quot;, module_name);
2389     }
2390   }
2391 
2392   // The method can be NULL if the requested class version is gone
2393   Method* method = holder-&gt;method_with_orig_idnum(method_id, version);
2394   if (!version_matches(method, version)) {
2395     strcat(buf, &quot;Redefined)&quot;);
2396   } else {
2397     int line_number = Backtrace::get_line_number(method, bci);
2398     if (line_number == -2) {
2399       strcat(buf, &quot;Native Method)&quot;);
2400     } else {
2401       if (source_file_name != NULL &amp;&amp; (line_number != -1)) {
2402         // Sourcename and linenumber
2403         sprintf(buf + (int)strlen(buf), &quot;%s:%d)&quot;, source_file_name, line_number);
2404       } else if (source_file_name != NULL) {
2405         // Just sourcename
2406         sprintf(buf + (int)strlen(buf), &quot;%s)&quot;, source_file_name);
2407       } else {
2408         // Neither sourcename nor linenumber
2409         sprintf(buf + (int)strlen(buf), &quot;Unknown Source)&quot;);
2410       }
2411       CompiledMethod* nm = method-&gt;code();
2412       if (WizardMode &amp;&amp; nm != NULL) {
2413         sprintf(buf + (int)strlen(buf), &quot;(nmethod &quot; INTPTR_FORMAT &quot;)&quot;, (intptr_t)nm);
2414       }
2415     }
2416   }
2417 
2418   st-&gt;print_cr(&quot;%s&quot;, buf);
2419 }
2420 
2421 void java_lang_Throwable::print_stack_element(outputStream *st, Method* method, int bci) {
2422   Handle mirror (Thread::current(),  method-&gt;method_holder()-&gt;java_mirror());
2423   int method_id = method-&gt;orig_method_idnum();
2424   int version = method-&gt;constants()-&gt;version();
2425   print_stack_element_to_stream(st, mirror, method_id, version, bci, method-&gt;name());
2426 }
2427 
2428 /**
2429  * Print the throwable message and its stack trace plus all causes by walking the
2430  * cause chain.  The output looks the same as of Throwable.printStackTrace().
2431  */
2432 void java_lang_Throwable::print_stack_trace(Handle throwable, outputStream* st) {
2433   // First, print the message.
2434   print(throwable(), st);
2435   st-&gt;cr();
2436 
2437   // Now print the stack trace.
2438   Thread* THREAD = Thread::current();
2439   while (throwable.not_null()) {
2440     objArrayHandle result (THREAD, objArrayOop(backtrace(throwable())));
2441     if (result.is_null()) {
2442       st-&gt;print_raw_cr(&quot;\t&lt;&lt;no stack trace available&gt;&gt;&quot;);
2443       return;
2444     }
2445     BacktraceIterator iter(result, THREAD);
2446 
2447     while (iter.repeat()) {
2448       BacktraceElement bte = iter.next(THREAD);
2449       print_stack_element_to_stream(st, bte._mirror, bte._method_id, bte._version, bte._bci, bte._name);
2450     }
2451     {
2452       // Call getCause() which doesn&#39;t necessarily return the _cause field.
2453       EXCEPTION_MARK;
2454       JavaValue cause(T_OBJECT);
2455       JavaCalls::call_virtual(&amp;cause,
2456                               throwable,
2457                               throwable-&gt;klass(),
2458                               vmSymbols::getCause_name(),
2459                               vmSymbols::void_throwable_signature(),
2460                               THREAD);
2461       // Ignore any exceptions. we are in the middle of exception handling. Same as classic VM.
2462       if (HAS_PENDING_EXCEPTION) {
2463         CLEAR_PENDING_EXCEPTION;
2464         throwable = Handle();
2465       } else {
2466         throwable = Handle(THREAD, (oop) cause.get_jobject());
2467         if (throwable.not_null()) {
2468           st-&gt;print(&quot;Caused by: &quot;);
2469           print(throwable(), st);
2470           st-&gt;cr();
2471         }
2472       }
2473     }
2474   }
2475 }
2476 
2477 /**
2478  * Print the throwable stack trace by calling the Java method java.lang.Throwable.printStackTrace().
2479  */
2480 void java_lang_Throwable::java_printStackTrace(Handle throwable, TRAPS) {
2481   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;Throwable instance expected&quot;);
2482   JavaValue result(T_VOID);
2483   JavaCalls::call_virtual(&amp;result,
2484                           throwable,
2485                           SystemDictionary::Throwable_klass(),
2486                           vmSymbols::printStackTrace_name(),
2487                           vmSymbols::void_method_signature(),
2488                           THREAD);
2489 }
2490 
2491 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS) {
2492   if (!StackTraceInThrowable) return;
2493   ResourceMark rm(THREAD);
2494 
2495   // Start out by clearing the backtrace for this object, in case the VM
2496   // runs out of memory while allocating the stack trace
2497   set_backtrace(throwable(), NULL);
2498   // Clear lazily constructed Java level stacktrace if refilling occurs
2499   // This is unnecessary in 1.7+ but harmless
2500   clear_stacktrace(throwable());
2501 
2502   int max_depth = MaxJavaStackTraceDepth;
2503   JavaThread* thread = (JavaThread*)THREAD;
2504 
2505   BacktraceBuilder bt(CHECK);
2506 
2507   // If there is no Java frame just return the method that was being called
2508   // with bci 0
2509   if (!thread-&gt;has_last_Java_frame()) {
2510     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
2511       bt.push(method(), 0, CHECK);
2512       log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), 1);
2513       set_depth(throwable(), 1);
2514       set_backtrace(throwable(), bt.backtrace());
2515     }
2516     return;
2517   }
2518 
2519   // Instead of using vframe directly, this version of fill_in_stack_trace
2520   // basically handles everything by hand. This significantly improved the
2521   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
2522   // See bug 6333838 for  more details.
2523   // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
2524   // trace as utilizing vframe.
2525 #ifdef ASSERT
2526   vframeStream st(thread);
2527 #endif
2528   int total_count = 0;
2529   RegisterMap map(thread, false);
2530   int decode_offset = 0;
2531   CompiledMethod* nm = NULL;
2532   bool skip_fillInStackTrace_check = false;
2533   bool skip_throwableInit_check = false;
2534   bool skip_hidden = !ShowHiddenFrames;
2535 
2536   for (frame fr = thread-&gt;last_frame(); max_depth == 0 || max_depth != total_count;) {
2537     Method* method = NULL;
2538     int bci = 0;
2539 
2540     // Compiled java method case.
2541     if (decode_offset != 0) {
2542       DebugInfoReadStream stream(nm, decode_offset);
2543       decode_offset = stream.read_int();
2544       method = (Method*)nm-&gt;metadata_at(stream.read_int());
2545       bci = stream.read_bci();
2546     } else {
2547       if (fr.is_first_frame()) break;
2548       address pc = fr.pc();
2549       if (fr.is_interpreted_frame()) {
2550         address bcp = fr.interpreter_frame_bcp();
2551         method = fr.interpreter_frame_method();
2552         bci =  method-&gt;bci_from(bcp);
2553         fr = fr.sender(&amp;map);
2554       } else {
2555         CodeBlob* cb = fr.cb();
2556         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
2557         // but non nmethod
2558         fr = fr.sender(&amp;map);
2559         if (cb == NULL || !cb-&gt;is_compiled()) {
2560           continue;
2561         }
2562         nm = cb-&gt;as_compiled_method();
2563         if (nm-&gt;method()-&gt;is_native()) {
2564           method = nm-&gt;method();
2565           bci = 0;
2566         } else {
2567           PcDesc* pd = nm-&gt;pc_desc_at(pc);
2568           decode_offset = pd-&gt;scope_decode_offset();
2569           // if decode_offset is not equal to 0, it will execute the
2570           // &quot;compiled java method case&quot; at the beginning of the loop.
2571           continue;
2572         }
2573       }
2574     }
2575 #ifdef ASSERT
2576     assert(st.method() == method &amp;&amp; st.bci() == bci,
2577            &quot;Wrong stack trace&quot;);
2578     st.next();
2579 #endif
2580 
2581     // the format of the stacktrace will be:
2582     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2583     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2584     // - rest of the stack
2585 
2586     if (!skip_fillInStackTrace_check) {
2587       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2588           throwable-&gt;is_a(method-&gt;method_holder())) {
2589         continue;
2590       }
2591       else {
2592         skip_fillInStackTrace_check = true; // gone past them all
2593       }
2594     }
2595     if (!skip_throwableInit_check) {
2596       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2597 
2598       // skip &lt;init&gt; methods of the exception class and superclasses
<a name="14" id="anc14"></a><span class="line-modified">2599       // This is similar to classic VM (before HotSpot).</span>
<span class="line-modified">2600       if (method-&gt;is_object_constructor() &amp;&amp;</span>
2601           throwable-&gt;is_a(method-&gt;method_holder())) {
2602         continue;
2603       } else {
2604         // there are none or we&#39;ve seen them all - either way stop checking
2605         skip_throwableInit_check = true;
2606       }
2607     }
2608     if (method-&gt;is_hidden()) {
2609       if (skip_hidden) {
2610         if (total_count == 0) {
2611           // The top frame will be hidden from the stack trace.
2612           bt.set_has_hidden_top_frame(CHECK);
2613         }
2614         continue;
2615       }
2616     }
2617     bt.push(method, bci, CHECK);
2618     total_count++;
2619   }
2620 
2621   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), total_count);
2622 
2623   // Put completed stack trace into throwable object
2624   set_backtrace(throwable(), bt.backtrace());
2625   set_depth(throwable(), total_count);
2626 }
2627 
2628 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method) {
2629   // No-op if stack trace is disabled
2630   if (!StackTraceInThrowable) {
2631     return;
2632   }
2633 
2634   // Disable stack traces for some preallocated out of memory errors
2635   if (!Universe::should_fill_in_stack_trace(throwable)) {
2636     return;
2637   }
2638 
2639   PRESERVE_EXCEPTION_MARK;
2640 
2641   JavaThread* thread = JavaThread::active();
2642   fill_in_stack_trace(throwable, method, thread);
2643   // ignore exceptions thrown during stack trace filling
2644   CLEAR_PENDING_EXCEPTION;
2645 }
2646 
2647 void java_lang_Throwable::allocate_backtrace(Handle throwable, TRAPS) {
2648   // Allocate stack trace - backtrace is created but not filled in
2649 
2650   // No-op if stack trace is disabled
2651   if (!StackTraceInThrowable) return;
2652   BacktraceBuilder bt(CHECK);   // creates a backtrace
2653   set_backtrace(throwable(), bt.backtrace());
2654 }
2655 
2656 
2657 void java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(Handle throwable) {
2658   // Fill in stack trace into preallocated backtrace (no GC)
2659 
2660   // No-op if stack trace is disabled
2661   if (!StackTraceInThrowable) return;
2662 
2663   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;sanity check&quot;);
2664 
2665   JavaThread* THREAD = JavaThread::current();
2666 
2667   objArrayHandle backtrace (THREAD, (objArrayOop)java_lang_Throwable::backtrace(throwable()));
2668   assert(backtrace.not_null(), &quot;backtrace should have been preallocated&quot;);
2669 
2670   ResourceMark rm(THREAD);
2671   vframeStream st(THREAD);
2672 
2673   BacktraceBuilder bt(THREAD, backtrace);
2674 
2675   // Unlike fill_in_stack_trace we do not skip fillInStackTrace or throwable init
2676   // methods as preallocated errors aren&#39;t created by &quot;java&quot; code.
2677 
2678   // fill in as much stack trace as possible
2679   int chunk_count = 0;
2680   for (;!st.at_end(); st.next()) {
2681     bt.push(st.method(), st.bci(), CHECK);
2682     chunk_count++;
2683 
2684     // Bail-out for deep stacks
2685     if (chunk_count &gt;= trace_chunk_size) break;
2686   }
2687   set_depth(throwable(), chunk_count);
2688   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), chunk_count);
2689 
2690   // We support the Throwable immutability protocol defined for Java 7.
2691   java_lang_Throwable::set_stacktrace(throwable(), java_lang_Throwable::unassigned_stacktrace());
2692   assert(java_lang_Throwable::unassigned_stacktrace() != NULL, &quot;not initialized&quot;);
2693 }
2694 
2695 void java_lang_Throwable::get_stack_trace_elements(Handle throwable,
2696                                                    objArrayHandle stack_trace_array_h, TRAPS) {
2697 
2698   if (throwable.is_null() || stack_trace_array_h.is_null()) {
2699     THROW(vmSymbols::java_lang_NullPointerException());
2700   }
2701 
2702   assert(stack_trace_array_h-&gt;is_objArray(), &quot;Stack trace array should be an array of StackTraceElenent&quot;);
2703 
2704   if (stack_trace_array_h-&gt;length() != depth(throwable())) {
2705     THROW(vmSymbols::java_lang_IndexOutOfBoundsException());
2706   }
2707 
2708   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable())));
2709   BacktraceIterator iter(result, THREAD);
2710 
2711   int index = 0;
2712   while (iter.repeat()) {
2713     BacktraceElement bte = iter.next(THREAD);
2714 
2715     Handle stack_trace_element(THREAD, stack_trace_array_h-&gt;obj_at(index++));
2716 
2717     if (stack_trace_element.is_null()) {
2718       THROW(vmSymbols::java_lang_NullPointerException());
2719     }
2720 
2721     InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2722     methodHandle method (THREAD, holder-&gt;method_with_orig_idnum(bte._method_id, bte._version));
2723 
2724     java_lang_StackTraceElement::fill_in(stack_trace_element, holder,
2725                                          method,
2726                                          bte._version,
2727                                          bte._bci,
2728                                          bte._name, CHECK);
2729   }
2730 }
2731 
2732 bool java_lang_Throwable::get_top_method_and_bci(oop throwable, Method** method, int* bci) {
2733   Thread* THREAD = Thread::current();
2734   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable)));
2735   BacktraceIterator iter(result, THREAD);
2736   // No backtrace available.
2737   if (!iter.repeat()) return false;
2738 
2739   // If the exception happened in a frame that has been hidden, i.e.,
2740   // omitted from the back trace, we can not compute the message.
2741   oop hidden = ((objArrayOop)backtrace(throwable))-&gt;obj_at(trace_hidden_offset);
2742   if (hidden != NULL) {
2743     return false;
2744   }
2745 
2746   // Get first backtrace element.
2747   BacktraceElement bte = iter.next(THREAD);
2748 
2749   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2750   assert(holder != NULL, &quot;first element should be non-null&quot;);
2751   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);
2752 
2753   // Original version is no longer available.
2754   if (m == NULL || !version_matches(m, bte._version)) {
2755     return false;
2756   }
2757 
2758   *method = m;
2759   *bci = bte._bci;
2760   return true;
2761 }
2762 
2763 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2764   // Allocate java.lang.StackTraceElement instance
2765   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2766   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2767   if (k-&gt;should_be_initialized()) {
2768     k-&gt;initialize(CHECK_NULL);
2769   }
2770 
2771   Handle element = k-&gt;allocate_instance_handle(CHECK_NULL);
2772 
2773   int version = method-&gt;constants()-&gt;version();
2774   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_NULL);
2775   return element();
2776 }
2777 
2778 void java_lang_StackTraceElement::fill_in(Handle element,
2779                                           InstanceKlass* holder, const methodHandle&amp; method,
2780                                           int version, int bci, Symbol* name, TRAPS) {
2781   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2782 
2783   ResourceMark rm(THREAD);
2784   HandleMark hm(THREAD);
2785 
2786   // Fill in class name
2787   Handle java_class(THREAD, holder-&gt;java_mirror());
2788   oop classname = java_lang_Class::name(java_class, CHECK);
2789   java_lang_StackTraceElement::set_declaringClass(element(), classname);
2790   java_lang_StackTraceElement::set_declaringClassObject(element(), java_class());
2791 
2792   oop loader = holder-&gt;class_loader();
2793   if (loader != NULL) {
2794     oop loader_name = java_lang_ClassLoader::name(loader);
2795     if (loader_name != NULL)
2796       java_lang_StackTraceElement::set_classLoaderName(element(), loader_name);
2797   }
2798 
2799   // Fill in method name
2800   oop methodname = StringTable::intern(name, CHECK);
2801   java_lang_StackTraceElement::set_methodName(element(), methodname);
2802 
2803   // Fill in module name and version
2804   ModuleEntry* module = holder-&gt;module();
2805   if (module-&gt;is_named()) {
2806     oop module_name = StringTable::intern(module-&gt;name(), CHECK);
2807     java_lang_StackTraceElement::set_moduleName(element(), module_name);
2808     oop module_version;
2809     if (module-&gt;version() != NULL) {
2810       module_version = StringTable::intern(module-&gt;version(), CHECK);
2811     } else {
2812       module_version = NULL;
2813     }
2814     java_lang_StackTraceElement::set_moduleVersion(element(), module_version);
2815   }
2816 
2817   if (method() == NULL || !version_matches(method(), version)) {
2818     // The method was redefined, accurate line number information isn&#39;t available
2819     java_lang_StackTraceElement::set_fileName(element(), NULL);
2820     java_lang_StackTraceElement::set_lineNumber(element(), -1);
2821   } else {
2822     Symbol* source;
2823     oop source_file;
2824     int line_number;
2825     decode_file_and_line(java_class, holder, version, method, bci, source, source_file, line_number, CHECK);
2826 
2827     java_lang_StackTraceElement::set_fileName(element(), source_file);
2828     java_lang_StackTraceElement::set_lineNumber(element(), line_number);
2829   }
2830 }
2831 
2832 void java_lang_StackTraceElement::decode_file_and_line(Handle java_class,
2833                                                        InstanceKlass* holder,
2834                                                        int version,
2835                                                        const methodHandle&amp; method,
2836                                                        int bci,
2837                                                        Symbol*&amp; source,
2838                                                        oop&amp; source_file,
2839                                                        int&amp; line_number, TRAPS) {
2840   // Fill in source file name and line number.
2841   source = Backtrace::get_source_file_name(holder, version);
2842   source_file = java_lang_Class::source_file(java_class());
2843   if (source != NULL) {
2844     // Class was not redefined. We can trust its cache if set,
2845     // else we have to initialize it.
2846     if (source_file == NULL) {
2847       source_file = StringTable::intern(source, CHECK);
2848       java_lang_Class::set_source_file(java_class(), source_file);
2849     }
2850   } else {
2851     // Class was redefined. Dump the cache if it was set.
2852     if (source_file != NULL) {
2853       source_file = NULL;
2854       java_lang_Class::set_source_file(java_class(), source_file);
2855     }
2856   }
2857   line_number = Backtrace::get_line_number(method(), bci);
2858 }
2859 
2860 #if INCLUDE_JVMCI
2861 void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,
2862                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {
2863   ResourceMark rm(THREAD);
2864   HandleMark hm(THREAD);
2865 
2866   filename = NULL;
2867   line_number = -1;
2868 
2869   oop source_file;
2870   int version = method-&gt;constants()-&gt;version();
2871   InstanceKlass* holder = method-&gt;method_holder();
2872   Handle java_class(THREAD, holder-&gt;java_mirror());
2873   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
2874 }
2875 #endif // INCLUDE_JVMCI
2876 
2877 // java_lang_StackFrameInfo
2878 
2879 int java_lang_StackFrameInfo::_memberName_offset;
2880 int java_lang_StackFrameInfo::_bci_offset;
2881 int java_lang_StackFrameInfo::_version_offset;
2882 
2883 #define STACKFRAMEINFO_FIELDS_DO(macro) \
2884   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \
2885   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)
2886 
2887 void java_lang_StackFrameInfo::compute_offsets() {
2888   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
2889   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2890   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
2891 }
2892 
2893 #if INCLUDE_CDS
2894 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {
2895   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2896   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
2897 }
2898 #endif
2899 
2900 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2901   HandleMark hm(THREAD);
2902   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2903   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2904   // we should expand MemberName::name when Throwable uses StackTrace
2905   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2906   return method;
2907 }
2908 
2909 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2910   // set Method* or mid/cpref
2911   HandleMark hm(THREAD);
2912   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
2913   InstanceKlass* ik = method-&gt;method_holder();
2914   CallInfo info(method(), ik, CHECK);
2915   MethodHandles::init_method_MemberName(mname, info);
2916   // set bci
2917   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2918   // method may be redefined; store the version
2919   int version = method-&gt;constants()-&gt;version();
2920   assert((jushort)version == version, &quot;version should be short&quot;);
2921   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2922 }
2923 
2924 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2925   ResourceMark rm(THREAD);
2926   HandleMark hm(THREAD);
2927   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2928   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2929   InstanceKlass* holder = InstanceKlass::cast(clazz);
2930   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2931 
2932   short version = stackFrame-&gt;short_field(_version_offset);
2933   int bci = stackFrame-&gt;int_field(_bci_offset);
2934   Symbol* name = method-&gt;name();
2935   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
2936                                        version, bci, name, CHECK);
2937 }
2938 
2939 void java_lang_StackFrameInfo::set_version(oop element, short value) {
2940   element-&gt;short_field_put(_version_offset, value);
2941 }
2942 
2943 void java_lang_StackFrameInfo::set_bci(oop element, int value) {
2944   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);
2945   element-&gt;int_field_put(_bci_offset, value);
2946 }
2947 
2948 int java_lang_LiveStackFrameInfo::_monitors_offset;
2949 int java_lang_LiveStackFrameInfo::_locals_offset;
2950 int java_lang_LiveStackFrameInfo::_operands_offset;
2951 int java_lang_LiveStackFrameInfo::_mode_offset;
2952 
2953 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2954   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2955   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2956   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2957   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2958 
2959 void java_lang_LiveStackFrameInfo::compute_offsets() {
2960   InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();
2961   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2962 }
2963 
2964 #if INCLUDE_CDS
2965 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
2966   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2967 }
2968 #endif
2969 
2970 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
2971   element-&gt;obj_field_put(_monitors_offset, value);
2972 }
2973 
2974 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {
2975   element-&gt;obj_field_put(_locals_offset, value);
2976 }
2977 
2978 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {
2979   element-&gt;obj_field_put(_operands_offset, value);
2980 }
2981 
2982 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {
2983   element-&gt;int_field_put(_mode_offset, value);
2984 }
2985 
2986 
2987 // java_lang_AccessibleObject
2988 
2989 int java_lang_reflect_AccessibleObject::_override_offset;
2990 
2991 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
2992   macro(_override_offset, k, &quot;override&quot;, bool_signature, false)
2993 
2994 void java_lang_reflect_AccessibleObject::compute_offsets() {
2995   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
2996   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2997 }
2998 
2999 #if INCLUDE_CDS
3000 void java_lang_reflect_AccessibleObject::serialize_offsets(SerializeClosure* f) {
3001   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3002 }
3003 #endif
3004 
3005 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
3006   return (jboolean) reflect-&gt;bool_field(_override_offset);
3007 }
3008 
3009 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
3010   reflect-&gt;bool_field_put(_override_offset, (int) value);
3011 }
3012 
3013 // java_lang_reflect_Method
3014 
3015 int java_lang_reflect_Method::_clazz_offset;
3016 int java_lang_reflect_Method::_name_offset;
3017 int java_lang_reflect_Method::_returnType_offset;
3018 int java_lang_reflect_Method::_parameterTypes_offset;
3019 int java_lang_reflect_Method::_exceptionTypes_offset;
3020 int java_lang_reflect_Method::_slot_offset;
3021 int java_lang_reflect_Method::_modifiers_offset;
3022 int java_lang_reflect_Method::_signature_offset;
3023 int java_lang_reflect_Method::_annotations_offset;
3024 int java_lang_reflect_Method::_parameter_annotations_offset;
3025 int java_lang_reflect_Method::_annotation_default_offset;
3026 
3027 #define METHOD_FIELDS_DO(macro) \
3028   macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
3029   macro(_name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \
3030   macro(_returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \
3031   macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
3032   macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
3033   macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
3034   macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
3035   macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
3036   macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
3037   macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \
3038   macro(_annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);
3039 
3040 void java_lang_reflect_Method::compute_offsets() {
3041   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
3042   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3043 }
3044 
3045 #if INCLUDE_CDS
3046 void java_lang_reflect_Method::serialize_offsets(SerializeClosure* f) {
3047   METHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3048 }
3049 #endif
3050 
3051 Handle java_lang_reflect_Method::create(TRAPS) {
3052   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3053   Klass* klass = SystemDictionary::reflect_Method_klass();
3054   // This class is eagerly initialized during VM initialization, since we keep a refence
3055   // to one of the methods
3056   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
3057   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
3058 }
3059 
3060 oop java_lang_reflect_Method::clazz(oop reflect) {
3061   return reflect-&gt;obj_field(_clazz_offset);
3062 }
3063 
3064 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
3065    reflect-&gt;obj_field_put(_clazz_offset, value);
3066 }
3067 
3068 int java_lang_reflect_Method::slot(oop reflect) {
3069   return reflect-&gt;int_field(_slot_offset);
3070 }
3071 
3072 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
3073   reflect-&gt;int_field_put(_slot_offset, value);
3074 }
3075 
3076 void java_lang_reflect_Method::set_name(oop method, oop value) {
3077   method-&gt;obj_field_put(_name_offset, value);
3078 }
3079 
3080 oop java_lang_reflect_Method::return_type(oop method) {
3081   return method-&gt;obj_field(_returnType_offset);
3082 }
3083 
3084 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
3085   method-&gt;obj_field_put(_returnType_offset, value);
3086 }
3087 
3088 oop java_lang_reflect_Method::parameter_types(oop method) {
3089   return method-&gt;obj_field(_parameterTypes_offset);
3090 }
3091 
3092 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
3093   method-&gt;obj_field_put(_parameterTypes_offset, value);
3094 }
3095 
3096 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
3097   method-&gt;obj_field_put(_exceptionTypes_offset, value);
3098 }
3099 
3100 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
3101   method-&gt;int_field_put(_modifiers_offset, value);
3102 }
3103 
3104 void java_lang_reflect_Method::set_signature(oop method, oop value) {
3105   method-&gt;obj_field_put(_signature_offset, value);
3106 }
3107 
3108 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
3109   method-&gt;obj_field_put(_annotations_offset, value);
3110 }
3111 
3112 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
3113   method-&gt;obj_field_put(_parameter_annotations_offset, value);
3114 }
3115 
3116 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
3117   method-&gt;obj_field_put(_annotation_default_offset, value);
3118 }
3119 
3120 int java_lang_reflect_Constructor::_clazz_offset;
3121 int java_lang_reflect_Constructor::_parameterTypes_offset;
3122 int java_lang_reflect_Constructor::_exceptionTypes_offset;
3123 int java_lang_reflect_Constructor::_slot_offset;
3124 int java_lang_reflect_Constructor::_modifiers_offset;
3125 int java_lang_reflect_Constructor::_signature_offset;
3126 int java_lang_reflect_Constructor::_annotations_offset;
3127 int java_lang_reflect_Constructor::_parameter_annotations_offset;
3128 
3129 #define CONSTRUCTOR_FIELDS_DO(macro) \
3130   macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
3131   macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
3132   macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
3133   macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
3134   macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
3135   macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
3136   macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
3137   macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);
3138 
3139 void java_lang_reflect_Constructor::compute_offsets() {
3140   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
3141   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3142 }
3143 
3144 #if INCLUDE_CDS
3145 void java_lang_reflect_Constructor::serialize_offsets(SerializeClosure* f) {
3146   CONSTRUCTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3147 }
3148 #endif
3149 
3150 Handle java_lang_reflect_Constructor::create(TRAPS) {
3151   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3152   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
3153   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3154   InstanceKlass* ik = InstanceKlass::cast(k);
3155   // Ensure it is initialized
3156   ik-&gt;initialize(CHECK_NH);
3157   return ik-&gt;allocate_instance_handle(THREAD);
3158 }
3159 
3160 oop java_lang_reflect_Constructor::clazz(oop reflect) {
3161   return reflect-&gt;obj_field(_clazz_offset);
3162 }
3163 
3164 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
3165    reflect-&gt;obj_field_put(_clazz_offset, value);
3166 }
3167 
3168 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
3169   return constructor-&gt;obj_field(_parameterTypes_offset);
3170 }
3171 
3172 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
3173   constructor-&gt;obj_field_put(_parameterTypes_offset, value);
3174 }
3175 
3176 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
3177   constructor-&gt;obj_field_put(_exceptionTypes_offset, value);
3178 }
3179 
3180 int java_lang_reflect_Constructor::slot(oop reflect) {
3181   return reflect-&gt;int_field(_slot_offset);
3182 }
3183 
3184 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
3185   reflect-&gt;int_field_put(_slot_offset, value);
3186 }
3187 
3188 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
3189   constructor-&gt;int_field_put(_modifiers_offset, value);
3190 }
3191 
3192 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
3193   constructor-&gt;obj_field_put(_signature_offset, value);
3194 }
3195 
3196 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
3197   constructor-&gt;obj_field_put(_annotations_offset, value);
3198 }
3199 
3200 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
3201   method-&gt;obj_field_put(_parameter_annotations_offset, value);
3202 }
3203 
3204 int java_lang_reflect_Field::_clazz_offset;
3205 int java_lang_reflect_Field::_name_offset;
3206 int java_lang_reflect_Field::_type_offset;
3207 int java_lang_reflect_Field::_slot_offset;
3208 int java_lang_reflect_Field::_modifiers_offset;
3209 int java_lang_reflect_Field::_trusted_final_offset;
3210 int java_lang_reflect_Field::_signature_offset;
3211 int java_lang_reflect_Field::_annotations_offset;
3212 
3213 #define FIELD_FIELDS_DO(macro) \
3214   macro(_clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \
3215   macro(_name_offset,      k, vmSymbols::name_name(),      string_signature, false); \
3216   macro(_type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \
3217   macro(_slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \
3218   macro(_modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \
3219   macro(_trusted_final_offset,    k, vmSymbols::trusted_final_name(),    bool_signature,       false); \
3220   macro(_signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \
3221   macro(_annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);
3222 
3223 void java_lang_reflect_Field::compute_offsets() {
3224   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
3225   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3226 }
3227 
3228 #if INCLUDE_CDS
3229 void java_lang_reflect_Field::serialize_offsets(SerializeClosure* f) {
3230   FIELD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3231 }
3232 #endif
3233 
3234 Handle java_lang_reflect_Field::create(TRAPS) {
3235   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3236   Symbol* name = vmSymbols::java_lang_reflect_Field();
3237   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3238   InstanceKlass* ik = InstanceKlass::cast(k);
3239   // Ensure it is initialized
3240   ik-&gt;initialize(CHECK_NH);
3241   return ik-&gt;allocate_instance_handle(THREAD);
3242 }
3243 
3244 oop java_lang_reflect_Field::clazz(oop reflect) {
3245   return reflect-&gt;obj_field(_clazz_offset);
3246 }
3247 
3248 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
3249   reflect-&gt;obj_field_put(_clazz_offset, value);
3250 }
3251 
3252 oop java_lang_reflect_Field::name(oop field) {
3253   return field-&gt;obj_field(_name_offset);
3254 }
3255 
3256 void java_lang_reflect_Field::set_name(oop field, oop value) {
3257   field-&gt;obj_field_put(_name_offset, value);
3258 }
3259 
3260 oop java_lang_reflect_Field::type(oop field) {
3261   return field-&gt;obj_field(_type_offset);
3262 }
3263 
3264 void java_lang_reflect_Field::set_type(oop field, oop value) {
3265   field-&gt;obj_field_put(_type_offset, value);
3266 }
3267 
3268 int java_lang_reflect_Field::slot(oop reflect) {
3269   return reflect-&gt;int_field(_slot_offset);
3270 }
3271 
3272 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
3273   reflect-&gt;int_field_put(_slot_offset, value);
3274 }
3275 
3276 int java_lang_reflect_Field::modifiers(oop field) {
3277   return field-&gt;int_field(_modifiers_offset);
3278 }
3279 
3280 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
3281   field-&gt;int_field_put(_modifiers_offset, value);
3282 }
3283 
3284 void java_lang_reflect_Field::set_trusted_final(oop field) {
3285   field-&gt;bool_field_put(_trusted_final_offset, true);
3286 }
3287 
3288 void java_lang_reflect_Field::set_signature(oop field, oop value) {
3289   field-&gt;obj_field_put(_signature_offset, value);
3290 }
3291 
3292 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
3293   field-&gt;obj_field_put(_annotations_offset, value);
3294 }
3295 
3296 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
3297   // Allocate java.lang.reflect.RecordComponent instance
3298   HandleMark hm(THREAD);
3299   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();
3300   assert(ik != NULL, &quot;must be loaded&quot;);
3301   ik-&gt;initialize(CHECK_NULL);
3302 
3303   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);
3304 
3305   Handle decl_class(THREAD, holder-&gt;java_mirror());
3306   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());
3307 
3308   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8
3309   oop component_name = StringTable::intern(name, CHECK_NULL);
3310   java_lang_reflect_RecordComponent::set_name(element(), component_name);
3311 
3312   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());
3313   Handle component_type_h =
3314     SystemDictionary::find_java_mirror_for_type(type, holder, SignatureStream::NCDFError, CHECK_NULL);
3315   java_lang_reflect_RecordComponent::set_type(element(), component_type_h());
3316 
3317   Method* accessor_method = NULL;
3318   {
3319     // Prepend &quot;()&quot; to type to create the full method signature.
3320     ResourceMark rm(THREAD);
3321     int sig_len = type-&gt;utf8_length() + 3; // &quot;()&quot; and null char
3322     char* sig = NEW_RESOURCE_ARRAY(char, sig_len);
3323     jio_snprintf(sig, sig_len, &quot;%c%c%s&quot;, JVM_SIGNATURE_FUNC, JVM_SIGNATURE_ENDFUNC, type-&gt;as_C_string());
3324     TempNewSymbol full_sig = SymbolTable::new_symbol(sig);
3325     accessor_method = holder-&gt;find_instance_method(name, full_sig, Klass::find_private);
3326   }
3327 
3328   if (accessor_method != NULL) {
3329     methodHandle method(THREAD, accessor_method);
3330     oop m = Reflection::new_method(method, false, CHECK_NULL);
3331     java_lang_reflect_RecordComponent::set_accessor(element(), m);
3332   } else {
3333     java_lang_reflect_RecordComponent::set_accessor(element(), NULL);
3334   }
3335 
3336   int sig_index = component-&gt;generic_signature_index();
3337   if (sig_index &gt; 0) {
3338     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8
3339     oop component_sig = StringTable::intern(sig, CHECK_NULL);
3340     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);
3341   } else {
3342     java_lang_reflect_RecordComponent::set_signature(element(), NULL);
3343   }
3344 
3345   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);
3346   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);
3347 
3348   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);
3349   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
3350 
3351   return element();
3352 }
3353 
3354 int reflect_ConstantPool::_oop_offset;
3355 
3356 #define CONSTANTPOOL_FIELDS_DO(macro) \
3357   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3358 
3359 void reflect_ConstantPool::compute_offsets() {
3360   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3361   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3362   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3363 }
3364 
3365 #if INCLUDE_CDS
3366 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3367   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3368 }
3369 #endif
3370 
3371 int java_lang_reflect_Parameter::_name_offset;
3372 int java_lang_reflect_Parameter::_modifiers_offset;
3373 int java_lang_reflect_Parameter::_index_offset;
3374 int java_lang_reflect_Parameter::_executable_offset;
3375 
3376 #define PARAMETER_FIELDS_DO(macro) \
3377   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature, false); \
3378   macro(_modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \
3379   macro(_index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \
3380   macro(_executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)
3381 
3382 void java_lang_reflect_Parameter::compute_offsets() {
3383   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
3384   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3385 }
3386 
3387 #if INCLUDE_CDS
3388 void java_lang_reflect_Parameter::serialize_offsets(SerializeClosure* f) {
3389   PARAMETER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3390 }
3391 #endif
3392 
3393 Handle java_lang_reflect_Parameter::create(TRAPS) {
3394   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3395   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
3396   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3397   InstanceKlass* ik = InstanceKlass::cast(k);
3398   // Ensure it is initialized
3399   ik-&gt;initialize(CHECK_NH);
3400   return ik-&gt;allocate_instance_handle(THREAD);
3401 }
3402 
3403 oop java_lang_reflect_Parameter::name(oop param) {
3404   return param-&gt;obj_field(_name_offset);
3405 }
3406 
3407 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
3408   param-&gt;obj_field_put(_name_offset, value);
3409 }
3410 
3411 int java_lang_reflect_Parameter::modifiers(oop param) {
3412   return param-&gt;int_field(_modifiers_offset);
3413 }
3414 
3415 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
3416   param-&gt;int_field_put(_modifiers_offset, value);
3417 }
3418 
3419 int java_lang_reflect_Parameter::index(oop param) {
3420   return param-&gt;int_field(_index_offset);
3421 }
3422 
3423 void java_lang_reflect_Parameter::set_index(oop param, int value) {
3424   param-&gt;int_field_put(_index_offset, value);
3425 }
3426 
3427 oop java_lang_reflect_Parameter::executable(oop param) {
3428   return param-&gt;obj_field(_executable_offset);
3429 }
3430 
3431 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
3432   param-&gt;obj_field_put(_executable_offset, value);
3433 }
3434 
3435 // java_lang_Module
3436 
3437 int java_lang_Module::_loader_offset;
3438 int java_lang_Module::_name_offset;
3439 int java_lang_Module::_module_entry_offset;
3440 
3441 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
3442   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3443   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
3444                           vmSymbols::java_lang_module_init_signature(),
3445                           loader, module_name, CHECK_NH);
3446 }
3447 
3448 #define MODULE_FIELDS_DO(macro) \
3449   macro(_loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \
3450   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature,      false)
3451 
3452 void java_lang_Module::compute_offsets() {
3453   InstanceKlass* k = SystemDictionary::Module_klass();
3454   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3455   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3456 }
3457 
3458 #if INCLUDE_CDS
3459 void java_lang_Module::serialize_offsets(SerializeClosure* f) {
3460   MODULE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3461   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3462 }
3463 #endif
3464 
3465 oop java_lang_Module::loader(oop module) {
3466   return module-&gt;obj_field(_loader_offset);
3467 }
3468 
3469 void java_lang_Module::set_loader(oop module, oop value) {
3470   module-&gt;obj_field_put(_loader_offset, value);
3471 }
3472 
3473 oop java_lang_Module::name(oop module) {
3474   return module-&gt;obj_field(_name_offset);
3475 }
3476 
3477 void java_lang_Module::set_name(oop module, oop value) {
3478   module-&gt;obj_field_put(_name_offset, value);
3479 }
3480 
3481 ModuleEntry* java_lang_Module::module_entry(oop module) {
3482   assert(_module_entry_offset != 0, &quot;Uninitialized module_entry_offset&quot;);
3483   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3484   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3485 
3486   ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
3487   if (module_entry == NULL) {
3488     // If the inject field containing the ModuleEntry* is null then return the
3489     // class loader&#39;s unnamed module.
3490     oop loader = java_lang_Module::loader(module);
3491     Handle h_loader = Handle(Thread::current(), loader);
3492     ClassLoaderData* loader_cld = SystemDictionary::register_loader(h_loader);
3493     return loader_cld-&gt;unnamed_module();
3494   }
3495   return module_entry;
3496 }
3497 
3498 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
3499   assert(_module_entry_offset != 0, &quot;Uninitialized module_entry_offset&quot;);
3500   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3501   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3502   module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
3503 }
3504 
3505 Handle reflect_ConstantPool::create(TRAPS) {
3506   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3507   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3508   // Ensure it is initialized
3509   k-&gt;initialize(CHECK_NH);
3510   return k-&gt;allocate_instance_handle(THREAD);
3511 }
3512 
3513 
3514 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
3515   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
3516   // Save the mirror to get back the constant pool.
3517   reflect-&gt;obj_field_put(_oop_offset, mirror);
3518 }
3519 
3520 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {
3521 
3522   oop mirror = reflect-&gt;obj_field(_oop_offset);
3523   Klass* k = java_lang_Class::as_Klass(mirror);
3524   assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
3525 
3526   // Get the constant pool back from the klass.  Since class redefinition
3527   // merges the new constant pool into the old, this is essentially the
3528   // same constant pool as the original.  If constant pool merging is
3529   // no longer done in the future, this will have to change to save
3530   // the original.
3531   return InstanceKlass::cast(k)-&gt;constants();
3532 }
3533 
3534 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
3535 
3536 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3537   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3538 
3539 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3540   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3541   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3542 }
3543 
3544 #if INCLUDE_CDS
3545 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3546   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3547 }
3548 #endif
3549 
3550 // Support for java_lang_ref_Reference
3551 
3552 bool java_lang_ref_Reference::_offsets_initialized;
3553 
3554 int java_lang_ref_Reference::_referent_offset;
3555 int java_lang_ref_Reference::_queue_offset;
3556 int java_lang_ref_Reference::_next_offset;
3557 int java_lang_ref_Reference::_discovered_offset;
3558 
3559 #define REFERENCE_FIELDS_DO(macro) \
3560   macro(_referent_offset,   k, &quot;referent&quot;, object_signature, false); \
3561   macro(_queue_offset,      k, &quot;queue&quot;, referencequeue_signature, false); \
3562   macro(_next_offset,       k, &quot;next&quot;, reference_signature, false); \
3563   macro(_discovered_offset, k, &quot;discovered&quot;, reference_signature, false);
3564 
3565 void java_lang_ref_Reference::compute_offsets() {
3566   if (_offsets_initialized) {
3567     return;
3568   }
3569   _offsets_initialized = true;
3570   InstanceKlass* k = SystemDictionary::Reference_klass();
3571   REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3572 }
3573 
3574 #if INCLUDE_CDS
3575 void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {
3576   f-&gt;do_bool(&amp;_offsets_initialized);
3577   REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3578 }
3579 #endif
3580 
3581 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {
3582   assert(obj != NULL, &quot;sanity&quot;);
3583   if (offset != _referent_offset) {
3584     return false;
3585   }
3586 
3587   Klass* k = obj-&gt;klass();
3588   if (!k-&gt;is_instance_klass()) {
3589     return false;
3590   }
3591 
3592   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
3593   bool is_reference = ik-&gt;reference_type() != REF_NONE;
3594   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);
3595   return is_reference;
3596 }
3597 
3598 int java_lang_boxing_object::_value_offset;
3599 int java_lang_boxing_object::_long_value_offset;
3600 
3601 #define BOXING_FIELDS_DO(macro) \
3602   macro(_value_offset,      integerKlass, &quot;value&quot;, int_signature, false); \
3603   macro(_long_value_offset, longKlass, &quot;value&quot;, long_signature, false);
3604 
3605 void java_lang_boxing_object::compute_offsets() {
3606   InstanceKlass* integerKlass = SystemDictionary::Integer_klass();
3607   InstanceKlass* longKlass = SystemDictionary::Long_klass();
3608   BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3609 }
3610 
3611 #if INCLUDE_CDS
3612 void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {
3613   BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3614 }
3615 #endif
3616 
3617 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3618   Klass* k = SystemDictionary::box_klass(type);
3619   if (k == NULL)  return NULL;
3620   InstanceKlass* ik = InstanceKlass::cast(k);
3621   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);
3622   return ik-&gt;allocate_instance(THREAD);
3623 }
3624 
3625 
3626 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
3627   oop box = initialize_and_allocate(type, CHECK_NULL);
3628   if (box == NULL)  return NULL;
3629   switch (type) {
3630     case T_BOOLEAN:
3631       box-&gt;bool_field_put(_value_offset, value-&gt;z);
3632       break;
3633     case T_CHAR:
3634       box-&gt;char_field_put(_value_offset, value-&gt;c);
3635       break;
3636     case T_FLOAT:
3637       box-&gt;float_field_put(_value_offset, value-&gt;f);
3638       break;
3639     case T_DOUBLE:
3640       box-&gt;double_field_put(_long_value_offset, value-&gt;d);
3641       break;
3642     case T_BYTE:
3643       box-&gt;byte_field_put(_value_offset, value-&gt;b);
3644       break;
3645     case T_SHORT:
3646       box-&gt;short_field_put(_value_offset, value-&gt;s);
3647       break;
3648     case T_INT:
3649       box-&gt;int_field_put(_value_offset, value-&gt;i);
3650       break;
3651     case T_LONG:
3652       box-&gt;long_field_put(_long_value_offset, value-&gt;j);
3653       break;
3654     default:
3655       return NULL;
3656   }
3657   return box;
3658 }
3659 
3660 
3661 BasicType java_lang_boxing_object::basic_type(oop box) {
3662   if (box == NULL)  return T_ILLEGAL;
3663   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3664   if (type == T_OBJECT)         // &#39;unknown&#39; value returned by SD::bkt
3665     return T_ILLEGAL;
3666   return type;
3667 }
3668 
3669 
3670 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
3671   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3672   switch (type) {
3673   case T_BOOLEAN:
3674     value-&gt;z = box-&gt;bool_field(_value_offset);
3675     break;
3676   case T_CHAR:
3677     value-&gt;c = box-&gt;char_field(_value_offset);
3678     break;
3679   case T_FLOAT:
3680     value-&gt;f = box-&gt;float_field(_value_offset);
3681     break;
3682   case T_DOUBLE:
3683     value-&gt;d = box-&gt;double_field(_long_value_offset);
3684     break;
3685   case T_BYTE:
3686     value-&gt;b = box-&gt;byte_field(_value_offset);
3687     break;
3688   case T_SHORT:
3689     value-&gt;s = box-&gt;short_field(_value_offset);
3690     break;
3691   case T_INT:
3692     value-&gt;i = box-&gt;int_field(_value_offset);
3693     break;
3694   case T_LONG:
3695     value-&gt;j = box-&gt;long_field(_long_value_offset);
3696     break;
3697   default:
3698     return T_ILLEGAL;
3699   } // end switch
3700   return type;
3701 }
3702 
3703 
3704 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
3705   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3706   switch (type) {
3707   case T_BOOLEAN:
3708     box-&gt;bool_field_put(_value_offset, value-&gt;z);
3709     break;
3710   case T_CHAR:
3711     box-&gt;char_field_put(_value_offset, value-&gt;c);
3712     break;
3713   case T_FLOAT:
3714     box-&gt;float_field_put(_value_offset, value-&gt;f);
3715     break;
3716   case T_DOUBLE:
3717     box-&gt;double_field_put(_long_value_offset, value-&gt;d);
3718     break;
3719   case T_BYTE:
3720     box-&gt;byte_field_put(_value_offset, value-&gt;b);
3721     break;
3722   case T_SHORT:
3723     box-&gt;short_field_put(_value_offset, value-&gt;s);
3724     break;
3725   case T_INT:
3726     box-&gt;int_field_put(_value_offset, value-&gt;i);
3727     break;
3728   case T_LONG:
3729     box-&gt;long_field_put(_long_value_offset, value-&gt;j);
3730     break;
3731   default:
3732     return T_ILLEGAL;
3733   } // end switch
3734   return type;
3735 }
3736 
3737 
3738 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
3739   switch (type) {
3740   case T_BOOLEAN:   st-&gt;print(&quot;%s&quot;, value-&gt;z ? &quot;true&quot; : &quot;false&quot;);   break;
3741   case T_CHAR:      st-&gt;print(&quot;%d&quot;, value-&gt;c);                      break;
3742   case T_BYTE:      st-&gt;print(&quot;%d&quot;, value-&gt;b);                      break;
3743   case T_SHORT:     st-&gt;print(&quot;%d&quot;, value-&gt;s);                      break;
3744   case T_INT:       st-&gt;print(&quot;%d&quot;, value-&gt;i);                      break;
3745   case T_LONG:      st-&gt;print(JLONG_FORMAT, value-&gt;j);              break;
3746   case T_FLOAT:     st-&gt;print(&quot;%f&quot;, value-&gt;f);                      break;
3747   case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
3748   default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
3749   }
3750 }
3751 
3752 
3753 // Support for java_lang_ref_SoftReference
3754 //
3755 
3756 int java_lang_ref_SoftReference::_timestamp_offset;
3757 int java_lang_ref_SoftReference::_static_clock_offset;
3758 
3759 #define SOFTREFERENCE_FIELDS_DO(macro) \
3760   macro(_timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \
3761   macro(_static_clock_offset, k, &quot;clock&quot;,     long_signature, true)
3762 
3763 void java_lang_ref_SoftReference::compute_offsets() {
3764   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3765   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3766 }
3767 
3768 #if INCLUDE_CDS
3769 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3770   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3771 }
3772 #endif
3773 
3774 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
3775   return ref-&gt;long_field(_timestamp_offset);
3776 }
3777 
3778 jlong java_lang_ref_SoftReference::clock() {
3779   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3780   oop base = ik-&gt;static_field_base_raw();
3781   return base-&gt;long_field(_static_clock_offset);
3782 }
3783 
3784 void java_lang_ref_SoftReference::set_clock(jlong value) {
3785   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3786   oop base = ik-&gt;static_field_base_raw();
3787   base-&gt;long_field_put(_static_clock_offset, value);
3788 }
3789 
3790 // Support for java_lang_invoke_DirectMethodHandle
3791 
3792 int java_lang_invoke_DirectMethodHandle::_member_offset;
3793 
3794 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
3795   oop member_name = NULL;
3796   assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
3797          &quot;a DirectMethodHandle oop is expected&quot;);
3798   return dmh-&gt;obj_field(_member_offset);
3799 }
3800 
3801 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
3802   macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
3803 
3804 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
3805   InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();
3806   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3807 }
3808 
3809 #if INCLUDE_CDS
3810 void java_lang_invoke_DirectMethodHandle::serialize_offsets(SerializeClosure* f) {
3811   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3812 }
3813 #endif
3814 
3815 // Support for java_lang_invoke_MethodHandle
3816 
3817 int java_lang_invoke_MethodHandle::_type_offset;
3818 int java_lang_invoke_MethodHandle::_form_offset;
3819 
3820 int java_lang_invoke_MemberName::_clazz_offset;
3821 int java_lang_invoke_MemberName::_name_offset;
3822 int java_lang_invoke_MemberName::_type_offset;
3823 int java_lang_invoke_MemberName::_flags_offset;
3824 int java_lang_invoke_MemberName::_method_offset;
3825 int java_lang_invoke_MemberName::_vmindex_offset;
3826 
3827 int java_lang_invoke_ResolvedMethodName::_vmtarget_offset;
3828 int java_lang_invoke_ResolvedMethodName::_vmholder_offset;
3829 
3830 int java_lang_invoke_LambdaForm::_vmentry_offset;
3831 
3832 #define METHODHANDLE_FIELDS_DO(macro) \
3833   macro(_type_offset, k, vmSymbols::type_name(), java_lang_invoke_MethodType_signature, false); \
3834   macro(_form_offset, k, &quot;form&quot;,                 java_lang_invoke_LambdaForm_signature, false)
3835 
3836 void java_lang_invoke_MethodHandle::compute_offsets() {
3837   InstanceKlass* k = SystemDictionary::MethodHandle_klass();
3838   METHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3839 }
3840 
3841 #if INCLUDE_CDS
3842 void java_lang_invoke_MethodHandle::serialize_offsets(SerializeClosure* f) {
3843   METHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3844 }
3845 #endif
3846 
3847 #define MEMBERNAME_FIELDS_DO(macro) \
3848   macro(_clazz_offset,   k, vmSymbols::clazz_name(),   class_signature,  false); \
3849   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature, false); \
3850   macro(_type_offset,    k, vmSymbols::type_name(),    object_signature, false); \
3851   macro(_flags_offset,   k, vmSymbols::flags_name(),   int_signature,    false); \
3852   macro(_method_offset,  k, vmSymbols::method_name(),  java_lang_invoke_ResolvedMethodName_signature, false)
3853 
3854 void java_lang_invoke_MemberName::compute_offsets() {
3855   InstanceKlass* k = SystemDictionary::MemberName_klass();
3856   MEMBERNAME_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3857   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3858 }
3859 
3860 #if INCLUDE_CDS
3861 void java_lang_invoke_MemberName::serialize_offsets(SerializeClosure* f) {
3862   MEMBERNAME_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3863   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3864 }
3865 #endif
3866 
3867 void java_lang_invoke_ResolvedMethodName::compute_offsets() {
3868   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3869   assert(k != NULL, &quot;jdk mismatch&quot;);
3870   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3871 }
3872 
3873 #if INCLUDE_CDS
3874 void java_lang_invoke_ResolvedMethodName::serialize_offsets(SerializeClosure* f) {
3875   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3876 }
3877 #endif
3878 
3879 #define LAMBDAFORM_FIELDS_DO(macro) \
3880   macro(_vmentry_offset, k, &quot;vmentry&quot;, java_lang_invoke_MemberName_signature, false)
3881 
3882 void java_lang_invoke_LambdaForm::compute_offsets() {
3883   InstanceKlass* k = SystemDictionary::LambdaForm_klass();
3884   assert (k != NULL, &quot;jdk mismatch&quot;);
3885   LAMBDAFORM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3886 }
3887 
3888 #if INCLUDE_CDS
3889 void java_lang_invoke_LambdaForm::serialize_offsets(SerializeClosure* f) {
3890   LAMBDAFORM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3891 }
3892 #endif
3893 
3894 bool java_lang_invoke_LambdaForm::is_instance(oop obj) {
3895   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
3896 }
3897 
3898 
3899 oop java_lang_invoke_MethodHandle::type(oop mh) {
3900   return mh-&gt;obj_field(_type_offset);
3901 }
3902 
3903 void java_lang_invoke_MethodHandle::set_type(oop mh, oop mtype) {
3904   mh-&gt;obj_field_put(_type_offset, mtype);
3905 }
3906 
3907 oop java_lang_invoke_MethodHandle::form(oop mh) {
3908   assert(_form_offset != 0, &quot;&quot;);
3909   return mh-&gt;obj_field(_form_offset);
3910 }
3911 
3912 void java_lang_invoke_MethodHandle::set_form(oop mh, oop lform) {
3913   assert(_form_offset != 0, &quot;&quot;);
3914   mh-&gt;obj_field_put(_form_offset, lform);
3915 }
3916 
3917 /// MemberName accessors
3918 
3919 oop java_lang_invoke_MemberName::clazz(oop mname) {
3920   assert(is_instance(mname), &quot;wrong type&quot;);
3921   return mname-&gt;obj_field(_clazz_offset);
3922 }
3923 
3924 void java_lang_invoke_MemberName::set_clazz(oop mname, oop clazz) {
3925   assert(is_instance(mname), &quot;wrong type&quot;);
3926   mname-&gt;obj_field_put(_clazz_offset, clazz);
3927 }
3928 
3929 oop java_lang_invoke_MemberName::name(oop mname) {
3930   assert(is_instance(mname), &quot;wrong type&quot;);
3931   return mname-&gt;obj_field(_name_offset);
3932 }
3933 
3934 void java_lang_invoke_MemberName::set_name(oop mname, oop name) {
3935   assert(is_instance(mname), &quot;wrong type&quot;);
3936   mname-&gt;obj_field_put(_name_offset, name);
3937 }
3938 
3939 oop java_lang_invoke_MemberName::type(oop mname) {
3940   assert(is_instance(mname), &quot;wrong type&quot;);
3941   return mname-&gt;obj_field(_type_offset);
3942 }
3943 
3944 void java_lang_invoke_MemberName::set_type(oop mname, oop type) {
3945   assert(is_instance(mname), &quot;wrong type&quot;);
3946   mname-&gt;obj_field_put(_type_offset, type);
3947 }
3948 
3949 int java_lang_invoke_MemberName::flags(oop mname) {
3950   assert(is_instance(mname), &quot;wrong type&quot;);
3951   return mname-&gt;int_field(_flags_offset);
3952 }
3953 
3954 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3955   assert(is_instance(mname), &quot;wrong type&quot;);
3956   mname-&gt;int_field_put(_flags_offset, flags);
3957 }
3958 
3959 
3960 // Return vmtarget from ResolvedMethodName method field through indirection
3961 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3962   assert(is_instance(mname), &quot;wrong type&quot;);
3963   oop method = mname-&gt;obj_field(_method_offset);
3964   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3965 }
3966 
3967 bool java_lang_invoke_MemberName::is_method(oop mname) {
3968   assert(is_instance(mname), &quot;must be MemberName&quot;);
<a name="15" id="anc15"></a><span class="line-modified">3969   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) &gt; 0;</span>
3970 }
3971 
3972 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3973   assert(is_instance(mname), &quot;wrong type&quot;);
3974   mname-&gt;obj_field_put(_method_offset, resolved_method);
3975 }
3976 
3977 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3978   assert(is_instance(mname), &quot;wrong type&quot;);
3979   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3980 }
3981 
3982 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3983   assert(is_instance(mname), &quot;wrong type&quot;);
3984   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3985 }
3986 
3987 
3988 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3989   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3990   Method* m = (Method*)resolved_method-&gt;address_field(_vmtarget_offset);
3991   assert(m-&gt;is_method(), &quot;must be&quot;);
3992   return m;
3993 }
3994 
3995 // Used by redefinition to change Method* to new Method* with same hash (name, signature)
3996 void java_lang_invoke_ResolvedMethodName::set_vmtarget(oop resolved_method, Method* m) {
3997   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3998   resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m);
3999 }
4000 
4001 void java_lang_invoke_ResolvedMethodName::set_vmholder(oop resolved_method, oop holder) {
4002   assert(is_instance(resolved_method), &quot;wrong type&quot;);
4003   resolved_method-&gt;obj_field_put(_vmholder_offset, holder);
4004 }
4005 
4006 oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle&amp; m, TRAPS) {
4007   const Method* method = m();
4008 
4009   // lookup ResolvedMethod oop in the table, or create a new one and intern it
4010   oop resolved_method = ResolvedMethodTable::find_method(method);
4011   if (resolved_method != NULL) {
4012     return resolved_method;
4013   }
4014 
4015   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
4016   if (!k-&gt;is_initialized()) {
4017     k-&gt;initialize(CHECK_NULL);
4018   }
4019 
4020   oop new_resolved_method = k-&gt;allocate_instance(CHECK_NULL);
4021 
4022   NoSafepointVerifier nsv;
4023 
4024   if (method-&gt;is_old()) {
4025     method = (method-&gt;is_deleted()) ? Universe::throw_no_such_method_error() :
4026                                       method-&gt;get_new_method();
4027   }
4028 
4029   InstanceKlass* holder = method-&gt;method_holder();
4030 
4031   set_vmtarget(new_resolved_method, const_cast&lt;Method*&gt;(method));
4032   // Add a reference to the loader (actually mirror because unsafe anonymous classes will not have
4033   // distinct loaders) to ensure the metadata is kept alive.
4034   // This mirror may be different than the one in clazz field.
4035   set_vmholder(new_resolved_method, holder-&gt;java_mirror());
4036 
4037   // Set flag in class to indicate this InstanceKlass has entries in the table
4038   // to avoid walking table during redefinition if none of the redefined classes
4039   // have any membernames in the table.
4040   holder-&gt;set_has_resolved_methods();
4041 
4042   return ResolvedMethodTable::add_method(method, Handle(THREAD, new_resolved_method));
4043 }
4044 
4045 oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
4046   assert(is_instance(lform), &quot;wrong type&quot;);
4047   return lform-&gt;obj_field(_vmentry_offset);
4048 }
4049 
4050 
4051 // Support for java_lang_invoke_MethodType
4052 
4053 int java_lang_invoke_MethodType::_rtype_offset;
4054 int java_lang_invoke_MethodType::_ptypes_offset;
4055 
4056 #define METHODTYPE_FIELDS_DO(macro) \
4057   macro(_rtype_offset,  k, &quot;rtype&quot;,  class_signature,       false); \
4058   macro(_ptypes_offset, k, &quot;ptypes&quot;, class_array_signature, false)
4059 
4060 void java_lang_invoke_MethodType::compute_offsets() {
4061   InstanceKlass* k = SystemDictionary::MethodType_klass();
4062   METHODTYPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4063 }
4064 
4065 #if INCLUDE_CDS
4066 void java_lang_invoke_MethodType::serialize_offsets(SerializeClosure* f) {
4067   METHODTYPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4068 }
4069 #endif
4070 
4071 void java_lang_invoke_MethodType::print_signature(oop mt, outputStream* st) {
4072   st-&gt;print(&quot;(&quot;);
4073   objArrayOop pts = ptypes(mt);
4074   for (int i = 0, limit = pts-&gt;length(); i &lt; limit; i++) {
4075     java_lang_Class::print_signature(pts-&gt;obj_at(i), st);
4076   }
4077   st-&gt;print(&quot;)&quot;);
4078   java_lang_Class::print_signature(rtype(mt), st);
4079 }
4080 
4081 Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found) {
4082   ResourceMark rm;
4083   stringStream buffer(128);
4084   print_signature(mt, &amp;buffer);
4085   const char* sigstr =       buffer.base();
4086   int         siglen = (int) buffer.size();
4087   Symbol *name;
4088   if (!intern_if_not_found) {
4089     name = SymbolTable::probe(sigstr, siglen);
4090   } else {
4091     name = SymbolTable::new_symbol(sigstr, siglen);
4092   }
4093   return name;
4094 }
4095 
4096 bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
4097   if (mt1 == mt2)
4098     return true;
4099   if (rtype(mt1) != rtype(mt2))
4100     return false;
4101   if (ptype_count(mt1) != ptype_count(mt2))
4102     return false;
4103   for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
4104     if (ptype(mt1, i) != ptype(mt2, i))
4105       return false;
4106   }
4107   return true;
4108 }
4109 
4110 oop java_lang_invoke_MethodType::rtype(oop mt) {
4111   assert(is_instance(mt), &quot;must be a MethodType&quot;);
4112   return mt-&gt;obj_field(_rtype_offset);
4113 }
4114 
4115 objArrayOop java_lang_invoke_MethodType::ptypes(oop mt) {
4116   assert(is_instance(mt), &quot;must be a MethodType&quot;);
4117   return (objArrayOop) mt-&gt;obj_field(_ptypes_offset);
4118 }
4119 
4120 oop java_lang_invoke_MethodType::ptype(oop mt, int idx) {
4121   return ptypes(mt)-&gt;obj_at(idx);
4122 }
4123 
4124 int java_lang_invoke_MethodType::ptype_count(oop mt) {
4125   return ptypes(mt)-&gt;length();
4126 }
4127 
4128 int java_lang_invoke_MethodType::ptype_slot_count(oop mt) {
4129   objArrayOop pts = ptypes(mt);
4130   int count = pts-&gt;length();
4131   int slots = 0;
4132   for (int i = 0; i &lt; count; i++) {
4133     BasicType bt = java_lang_Class::as_BasicType(pts-&gt;obj_at(i));
4134     slots += type2size[bt];
4135   }
4136   return slots;
4137 }
4138 
4139 int java_lang_invoke_MethodType::rtype_slot_count(oop mt) {
4140   BasicType bt = java_lang_Class::as_BasicType(rtype(mt));
4141   return type2size[bt];
4142 }
4143 
4144 
4145 // Support for java_lang_invoke_CallSite
4146 
4147 int java_lang_invoke_CallSite::_target_offset;
4148 int java_lang_invoke_CallSite::_context_offset;
4149 
4150 #define CALLSITE_FIELDS_DO(macro) \
4151   macro(_target_offset,  k, &quot;target&quot;, java_lang_invoke_MethodHandle_signature, false); \
4152   macro(_context_offset, k, &quot;context&quot;, java_lang_invoke_MethodHandleNatives_CallSiteContext_signature, false)
4153 
4154 void java_lang_invoke_CallSite::compute_offsets() {
4155   InstanceKlass* k = SystemDictionary::CallSite_klass();
4156   CALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4157 }
4158 
4159 #if INCLUDE_CDS
4160 void java_lang_invoke_CallSite::serialize_offsets(SerializeClosure* f) {
4161   CALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4162 }
4163 #endif
4164 
4165 oop java_lang_invoke_CallSite::context_no_keepalive(oop call_site) {
4166   assert(java_lang_invoke_CallSite::is_instance(call_site), &quot;&quot;);
4167 
4168   oop dep_oop = call_site-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(_context_offset);
4169   return dep_oop;
4170 }
4171 
4172 // Support for java_lang_invoke_ConstantCallSite
4173 
4174 int java_lang_invoke_ConstantCallSite::_is_frozen_offset;
4175 
4176 #define CONSTANTCALLSITE_FIELDS_DO(macro) \
4177   macro(_is_frozen_offset, k, &quot;isFrozen&quot;, bool_signature, false)
4178 
4179 void java_lang_invoke_ConstantCallSite::compute_offsets() {
4180   InstanceKlass* k = SystemDictionary::ConstantCallSite_klass();
4181   CONSTANTCALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4182 }
4183 
4184 #if INCLUDE_CDS
4185 void java_lang_invoke_ConstantCallSite::serialize_offsets(SerializeClosure* f) {
4186   CONSTANTCALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4187 }
4188 #endif
4189 
4190 // Support for java_lang_invoke_MethodHandleNatives_CallSiteContext
4191 
4192 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_vmdependencies_offset;
4193 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_last_cleanup_offset;
4194 
4195 void java_lang_invoke_MethodHandleNatives_CallSiteContext::compute_offsets() {
4196   InstanceKlass* k = SystemDictionary::Context_klass();
4197   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4198 }
4199 
4200 #if INCLUDE_CDS
4201 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
4202   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4203 }
4204 #endif
4205 
4206 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
4207   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
4208   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
4209   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
4210   DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);
4211   return dep_ctx;
4212 }
4213 
4214 // Support for java_security_AccessControlContext
4215 
4216 int java_security_AccessControlContext::_context_offset;
4217 int java_security_AccessControlContext::_privilegedContext_offset;
4218 int java_security_AccessControlContext::_isPrivileged_offset;
4219 int java_security_AccessControlContext::_isAuthorized_offset;
4220 
4221 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
4222   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
4223   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4224   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4225   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4226 
4227 void java_security_AccessControlContext::compute_offsets() {
4228   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4229   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4230   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4231 }
4232 
4233 #if INCLUDE_CDS
4234 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4235   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4236 }
4237 #endif
4238 
4239 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4240   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
4241   assert(_isAuthorized_offset != 0, &quot;offsets should have been initialized&quot;);
4242   // Ensure klass is initialized
4243   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
4244   // Allocate result
4245   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
4246   // Fill in values
4247   result-&gt;obj_field_put(_context_offset, context());
4248   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4249   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4250   // whitelist AccessControlContexts created by the JVM
4251   result-&gt;bool_field_put(_isAuthorized_offset, true);
4252   return result;
4253 }
4254 
4255 
4256 // Support for java_lang_ClassLoader
4257 
4258 int  java_lang_ClassLoader::_loader_data_offset;
4259 int  java_lang_ClassLoader::_parallelCapable_offset;
4260 int  java_lang_ClassLoader::_name_offset;
4261 int  java_lang_ClassLoader::_nameAndId_offset;
4262 int  java_lang_ClassLoader::_unnamedModule_offset;
4263 int  java_lang_ClassLoader::_parent_offset;
4264 
4265 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
4266   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4267   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4268   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
4269 }
4270 
4271 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
4272   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4273   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4274   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
4275 }
4276 
4277 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
4278   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4279   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4280   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
4281 }
4282 
4283 #define CLASSLOADER_FIELDS_DO(macro) \
4284   macro(_parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \
4285   macro(_name_offset,            k1, vmSymbols::name_name(), string_signature, false); \
4286   macro(_nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \
4287   macro(_unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \
4288   macro(_parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)
4289 
4290 void java_lang_ClassLoader::compute_offsets() {
4291   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
4292   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4293 
4294   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4295 }
4296 
4297 #if INCLUDE_CDS
4298 void java_lang_ClassLoader::serialize_offsets(SerializeClosure* f) {
4299   CLASSLOADER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4300   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4301 }
4302 #endif
4303 
4304 oop java_lang_ClassLoader::parent(oop loader) {
4305   assert(is_instance(loader), &quot;loader must be oop&quot;);
4306   return loader-&gt;obj_field(_parent_offset);
4307 }
4308 
4309 // Returns the name field of this class loader.  If the name field has not
4310 // been set, null will be returned.
4311 oop java_lang_ClassLoader::name(oop loader) {
4312   assert(is_instance(loader), &quot;loader must be oop&quot;);
4313   return loader-&gt;obj_field(_name_offset);
4314 }
4315 
4316 // Returns the nameAndId field of this class loader. The format is
4317 // as follows:
4318 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
4319 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
4320 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
4321 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
4322 oop java_lang_ClassLoader::nameAndId(oop loader) {
4323   assert(is_instance(loader), &quot;loader must be oop&quot;);
4324   return loader-&gt;obj_field(_nameAndId_offset);
4325 }
4326 
4327 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
4328   assert(is_instance(loader), &quot;loader must be oop&quot;);
4329   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
4330   oop acl = loader;
4331   debug_only(jint loop_count = 0);
4332   // This loop taken verbatim from ClassLoader.java:
4333   do {
4334     acl = parent(acl);
4335     if (cl == acl) {
4336       return true;
4337     }
4338     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
4339   } while (acl != NULL);
4340   return false;
4341 }
4342 
4343 bool java_lang_ClassLoader::is_instance(oop obj) {
4344   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
4345 }
4346 
4347 
4348 // For class loader classes, parallelCapable defined
4349 // based on non-null field
4350 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
4351 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
4352   assert(_parallelCapable_offset != 0, &quot;offsets should have been initialized&quot;);
4353   return (class_loader-&gt;obj_field(_parallelCapable_offset) != NULL);
4354 }
4355 
4356 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
4357   // Fix for 4474172; see evaluation for more details
4358   loader = non_reflection_class_loader(loader);
4359 
4360   oop cl = SystemDictionary::java_system_loader();
4361   while(cl != NULL) {
4362     if (cl == loader) return true;
4363     cl = parent(cl);
4364   }
4365   return false;
4366 }
4367 
4368 // Return true if this is one of the class loaders associated with
4369 // the generated bytecodes for reflection.
4370 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
4371   if (loader != NULL) {
4372     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
4373     // This might be null in non-1.4 JDKs
4374     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
4375   }
4376   return false;
4377 }
4378 
4379 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
4380   // See whether this is one of the class loaders associated with
4381   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
4382   // delegate to its parent to prevent class loading from occurring
4383   // in places where applications using reflection didn&#39;t expect it.
4384   if (is_reflection_class_loader(loader)) {
4385     return parent(loader);
4386   }
4387   return loader;
4388 }
4389 
4390 oop java_lang_ClassLoader::unnamedModule(oop loader) {
4391   assert(is_instance(loader), &quot;loader must be oop&quot;);
4392   return loader-&gt;obj_field(_unnamedModule_offset);
4393 }
4394 
4395 // Support for java_lang_System
4396 //
4397 
4398 int java_lang_System::_static_in_offset;
4399 int java_lang_System::_static_out_offset;
4400 int java_lang_System::_static_err_offset;
4401 int java_lang_System::_static_security_offset;
4402 
4403 #define SYSTEM_FIELDS_DO(macro) \
4404   macro(_static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \
4405   macro(_static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \
4406   macro(_static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \
4407   macro(_static_security_offset, k, &quot;security&quot;, security_manager_signature, true)
4408 
4409 void java_lang_System::compute_offsets() {
4410   InstanceKlass* k = SystemDictionary::System_klass();
4411   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4412 }
4413 
4414 #if INCLUDE_CDS
4415 void java_lang_System::serialize_offsets(SerializeClosure* f) {
4416    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4417 }
4418 #endif
4419 
4420 // Support for jdk_internal_misc_UnsafeConstants
4421 //
4422 class UnsafeConstantsFixup : public FieldClosure {
4423 private:
4424   int _address_size;
4425   int _page_size;
4426   bool _big_endian;
4427   bool _use_unaligned_access;
4428   int _data_cache_line_flush_size;
4429 public:
4430   UnsafeConstantsFixup() {
4431     // round up values for all static final fields
4432     _address_size = sizeof(void*);
4433     _page_size = os::vm_page_size();
4434     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);
4435     _use_unaligned_access = UseUnalignedAccesses;
4436     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();
4437   }
4438 
4439   void do_field(fieldDescriptor* fd) {
4440     oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
4441     assert(mirror != NULL, &quot;UnsafeConstants must have mirror already&quot;);
4442     assert(fd-&gt;field_holder() == SystemDictionary::UnsafeConstants_klass(), &quot;Should be UnsafeConstants&quot;);
4443     assert(fd-&gt;is_final(), &quot;fields of UnsafeConstants must be final&quot;);
4444     assert(fd-&gt;is_static(), &quot;fields of UnsafeConstants must be static&quot;);
4445     if (fd-&gt;name() == vmSymbols::address_size_name()) {
4446       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);
4447     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {
4448       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);
4449     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {
4450       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);
4451     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {
4452       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);
4453     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {
4454       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4455     } else {
4456       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4457     }
4458   }
4459 };
4460 
4461 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4462   UnsafeConstantsFixup fixup;
4463   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4464 }
4465 
4466 
4467 // java_lang_StackTraceElement
4468 
4469 int java_lang_StackTraceElement::_methodName_offset;
4470 int java_lang_StackTraceElement::_fileName_offset;
4471 int java_lang_StackTraceElement::_lineNumber_offset;
4472 int java_lang_StackTraceElement::_moduleName_offset;
4473 int java_lang_StackTraceElement::_moduleVersion_offset;
4474 int java_lang_StackTraceElement::_classLoaderName_offset;
4475 int java_lang_StackTraceElement::_declaringClass_offset;
4476 int java_lang_StackTraceElement::_declaringClassObject_offset;
4477 
4478 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4479   macro(_declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4480   macro(_classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4481   macro(_moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4482   macro(_moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4483   macro(_declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4484   macro(_methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4485   macro(_fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4486   macro(_lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4487 
4488 // Support for java_lang_StackTraceElement
4489 void java_lang_StackTraceElement::compute_offsets() {
4490   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4491   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4492 }
4493 
4494 #if INCLUDE_CDS
4495 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
4496   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4497 }
4498 #endif
4499 
4500 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
4501   element-&gt;obj_field_put(_fileName_offset, value);
4502 }
4503 
4504 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
4505   element-&gt;obj_field_put(_declaringClass_offset, value);
4506 }
4507 
4508 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
4509   element-&gt;obj_field_put(_methodName_offset, value);
4510 }
4511 
4512 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
4513   element-&gt;int_field_put(_lineNumber_offset, value);
4514 }
4515 
4516 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
4517   element-&gt;obj_field_put(_moduleName_offset, value);
4518 }
4519 
4520 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
4521   element-&gt;obj_field_put(_moduleVersion_offset, value);
4522 }
4523 
4524 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
4525   element-&gt;obj_field_put(_classLoaderName_offset, value);
4526 }
4527 
4528 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
4529   element-&gt;obj_field_put(_declaringClassObject_offset, value);
4530 }
4531 
4532 
4533 // java_lang_AssertionStatusDirectives
4534 
4535 int java_lang_AssertionStatusDirectives::_classes_offset;
4536 int java_lang_AssertionStatusDirectives::_classEnabled_offset;
4537 int java_lang_AssertionStatusDirectives::_packages_offset;
4538 int java_lang_AssertionStatusDirectives::_packageEnabled_offset;
4539 int java_lang_AssertionStatusDirectives::_deflt_offset;
4540 
4541 // Support for java Assertions - java_lang_AssertionStatusDirectives.
4542 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
4543   macro(_classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \
4544   macro(_classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \
4545   macro(_packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \
4546   macro(_packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \
4547   macro(_deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)
4548 
4549 void java_lang_AssertionStatusDirectives::compute_offsets() {
4550   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
4551   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4552 }
4553 
4554 #if INCLUDE_CDS
4555 void java_lang_AssertionStatusDirectives::serialize_offsets(SerializeClosure* f) {
4556   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4557 }
4558 #endif
4559 
4560 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
4561   o-&gt;obj_field_put(_classes_offset, val);
4562 }
4563 
4564 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
4565   o-&gt;obj_field_put(_classEnabled_offset, val);
4566 }
4567 
4568 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
4569   o-&gt;obj_field_put(_packages_offset, val);
4570 }
4571 
4572 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
4573   o-&gt;obj_field_put(_packageEnabled_offset, val);
4574 }
4575 
4576 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
4577   o-&gt;bool_field_put(_deflt_offset, val);
4578 }
4579 
4580 
4581 // Support for intrinsification of java.nio.Buffer.checkIndex
4582 
4583 int java_nio_Buffer::_limit_offset;
4584 
4585 #define BUFFER_FIELDS_DO(macro) \
4586   macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
4587 
4588 void java_nio_Buffer::compute_offsets() {
4589   InstanceKlass* k = SystemDictionary::nio_Buffer_klass();
4590   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
4591   BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4592 }
4593 
4594 #if INCLUDE_CDS
4595 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
4596   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4597 }
4598 #endif
4599 
4600 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4601 
4602 #define AOS_FIELDS_DO(macro) \
4603   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4604 
4605 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4606   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4607   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4608 }
4609 
4610 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4611   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4612   return obj-&gt;obj_field(_owner_offset);
4613 }
4614 
4615 #if INCLUDE_CDS
4616 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4617   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4618 }
4619 #endif
4620 
4621 int java_lang_Integer_IntegerCache::_static_cache_offset;
4622 int java_lang_Long_LongCache::_static_cache_offset;
4623 int java_lang_Character_CharacterCache::_static_cache_offset;
4624 int java_lang_Short_ShortCache::_static_cache_offset;
4625 int java_lang_Byte_ByteCache::_static_cache_offset;
4626 
4627 #define INTEGER_CACHE_FIELDS_DO(macro) \
4628   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)
4629 
4630 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
4631   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4632   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4633 }
4634 
4635 objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {
4636   oop base = ik-&gt;static_field_base_raw();
4637   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4638 }
4639 
4640 Symbol* java_lang_Integer_IntegerCache::symbol() {
4641   return vmSymbols::java_lang_Integer_IntegerCache();
4642 }
4643 
4644 #if INCLUDE_CDS
4645 void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {
4646   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4647 }
4648 #endif
4649 #undef INTEGER_CACHE_FIELDS_DO
4650 
4651 jint java_lang_Integer::value(oop obj) {
4652    jvalue v;
4653    java_lang_boxing_object::get_value(obj, &amp;v);
4654    return v.i;
4655 }
4656 
4657 #define LONG_CACHE_FIELDS_DO(macro) \
4658   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Long_array_signature, true)
4659 
4660 void java_lang_Long_LongCache::compute_offsets(InstanceKlass *k) {
4661   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4662   LONG_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4663 }
4664 
4665 objArrayOop java_lang_Long_LongCache::cache(InstanceKlass *ik) {
4666   oop base = ik-&gt;static_field_base_raw();
4667   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4668 }
4669 
4670 Symbol* java_lang_Long_LongCache::symbol() {
4671   return vmSymbols::java_lang_Long_LongCache();
4672 }
4673 
4674 #if INCLUDE_CDS
4675 void java_lang_Long_LongCache::serialize_offsets(SerializeClosure* f) {
4676   LONG_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4677 }
4678 #endif
4679 #undef LONG_CACHE_FIELDS_DO
4680 
4681 jlong java_lang_Long::value(oop obj) {
4682    jvalue v;
4683    java_lang_boxing_object::get_value(obj, &amp;v);
4684    return v.j;
4685 }
4686 
4687 #define CHARACTER_CACHE_FIELDS_DO(macro) \
4688   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Character_array_signature, true)
4689 
4690 void java_lang_Character_CharacterCache::compute_offsets(InstanceKlass *k) {
4691   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4692   CHARACTER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4693 }
4694 
4695 objArrayOop java_lang_Character_CharacterCache::cache(InstanceKlass *ik) {
4696   oop base = ik-&gt;static_field_base_raw();
4697   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4698 }
4699 
4700 Symbol* java_lang_Character_CharacterCache::symbol() {
4701   return vmSymbols::java_lang_Character_CharacterCache();
4702 }
4703 
4704 #if INCLUDE_CDS
4705 void java_lang_Character_CharacterCache::serialize_offsets(SerializeClosure* f) {
4706   CHARACTER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4707 }
4708 #endif
4709 #undef CHARACTER_CACHE_FIELDS_DO
4710 
4711 jchar java_lang_Character::value(oop obj) {
4712    jvalue v;
4713    java_lang_boxing_object::get_value(obj, &amp;v);
4714    return v.c;
4715 }
4716 
4717 #define SHORT_CACHE_FIELDS_DO(macro) \
4718   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Short_array_signature, true)
4719 
4720 void java_lang_Short_ShortCache::compute_offsets(InstanceKlass *k) {
4721   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4722   SHORT_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4723 }
4724 
4725 objArrayOop java_lang_Short_ShortCache::cache(InstanceKlass *ik) {
4726   oop base = ik-&gt;static_field_base_raw();
4727   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4728 }
4729 
4730 Symbol* java_lang_Short_ShortCache::symbol() {
4731   return vmSymbols::java_lang_Short_ShortCache();
4732 }
4733 
4734 #if INCLUDE_CDS
4735 void java_lang_Short_ShortCache::serialize_offsets(SerializeClosure* f) {
4736   SHORT_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4737 }
4738 #endif
4739 #undef SHORT_CACHE_FIELDS_DO
4740 
4741 jshort java_lang_Short::value(oop obj) {
4742    jvalue v;
4743    java_lang_boxing_object::get_value(obj, &amp;v);
4744    return v.s;
4745 }
4746 
4747 #define BYTE_CACHE_FIELDS_DO(macro) \
4748   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Byte_array_signature, true)
4749 
4750 void java_lang_Byte_ByteCache::compute_offsets(InstanceKlass *k) {
4751   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4752   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4753 }
4754 
4755 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4756   oop base = ik-&gt;static_field_base_raw();
4757   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4758 }
4759 
4760 Symbol* java_lang_Byte_ByteCache::symbol() {
4761   return vmSymbols::java_lang_Byte_ByteCache();
4762 }
4763 
4764 #if INCLUDE_CDS
4765 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4766   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4767 }
4768 #endif
4769 #undef BYTE_CACHE_FIELDS_DO
4770 
<a name="16" id="anc16"></a><span class="line-added">4771 // jdk_internal_vm_jni_SubElementSelector</span>
<span class="line-added">4772 </span>
<span class="line-added">4773 int jdk_internal_vm_jni_SubElementSelector::_arrayElementType_offset;</span>
<span class="line-added">4774 int jdk_internal_vm_jni_SubElementSelector::_subElementType_offset;</span>
<span class="line-added">4775 int jdk_internal_vm_jni_SubElementSelector::_offset_offset;</span>
<span class="line-added">4776 int jdk_internal_vm_jni_SubElementSelector::_isInlined_offset;</span>
<span class="line-added">4777 int jdk_internal_vm_jni_SubElementSelector::_isInlineType_offset;</span>
<span class="line-added">4778 </span>
<span class="line-added">4779 #define SUBELEMENT_SELECTOR_FIELDS_DO(macro) \</span>
<span class="line-added">4780   macro(_arrayElementType_offset,  k, &quot;arrayElementType&quot;, class_signature, false); \</span>
<span class="line-added">4781   macro(_subElementType_offset,    k, &quot;subElementType&quot;,   class_signature, false); \</span>
<span class="line-added">4782   macro(_offset_offset,            k, &quot;offset&quot;,           int_signature,   false); \</span>
<span class="line-added">4783   macro(_isInlined_offset,         k, &quot;isInlined&quot;,        bool_signature,  false); \</span>
<span class="line-added">4784   macro(_isInlineType_offset,      k, &quot;isInlineType&quot;,     bool_signature,  false);</span>
<span class="line-added">4785 </span>
<span class="line-added">4786 void jdk_internal_vm_jni_SubElementSelector::compute_offsets() {</span>
<span class="line-added">4787   InstanceKlass* k = SystemDictionary::jdk_internal_vm_jni_SubElementSelector_klass();</span>
<span class="line-added">4788   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4789 }</span>
<span class="line-added">4790 </span>
<span class="line-added">4791 #if INCLUDE_CDS</span>
<span class="line-added">4792 void jdk_internal_vm_jni_SubElementSelector::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4793   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4794 }</span>
<span class="line-added">4795 #endif</span>
<span class="line-added">4796 #undef SUBELEMENT_SELECTOR_FIELDS_DO</span>
<span class="line-added">4797 </span>
<span class="line-added">4798 Symbol* jdk_internal_vm_jni_SubElementSelector::symbol() {</span>
<span class="line-added">4799   return vmSymbols::jdk_internal_vm_jni_SubElementSelector();</span>
<span class="line-added">4800 }</span>
<span class="line-added">4801 </span>
<span class="line-added">4802 oop jdk_internal_vm_jni_SubElementSelector::getArrayElementType(oop obj) {</span>
<span class="line-added">4803   return obj-&gt;obj_field(_arrayElementType_offset);</span>
<span class="line-added">4804 }</span>
<span class="line-added">4805 </span>
<span class="line-added">4806 void jdk_internal_vm_jni_SubElementSelector::setArrayElementType(oop obj, oop type) {</span>
<span class="line-added">4807   obj-&gt;obj_field_put(_arrayElementType_offset, type);</span>
<span class="line-added">4808 }</span>
<span class="line-added">4809 </span>
<span class="line-added">4810 oop jdk_internal_vm_jni_SubElementSelector::getSubElementType(oop obj) {</span>
<span class="line-added">4811   return obj-&gt;obj_field(_subElementType_offset);</span>
<span class="line-added">4812 }</span>
<span class="line-added">4813 </span>
<span class="line-added">4814 void jdk_internal_vm_jni_SubElementSelector::setSubElementType(oop obj, oop type) {</span>
<span class="line-added">4815   obj-&gt;obj_field_put(_subElementType_offset, type);</span>
<span class="line-added">4816 }</span>
<span class="line-added">4817 </span>
<span class="line-added">4818 int jdk_internal_vm_jni_SubElementSelector::getOffset(oop obj) {</span>
<span class="line-added">4819   return obj-&gt;int_field(_offset_offset);</span>
<span class="line-added">4820 }</span>
<span class="line-added">4821 </span>
<span class="line-added">4822 void jdk_internal_vm_jni_SubElementSelector::setOffset(oop obj, int offset) {</span>
<span class="line-added">4823   obj-&gt;int_field_put(_offset_offset, offset);</span>
<span class="line-added">4824 }</span>
<span class="line-added">4825 </span>
<span class="line-added">4826 bool jdk_internal_vm_jni_SubElementSelector::getIsInlined(oop obj) {</span>
<span class="line-added">4827   return obj-&gt;bool_field(_isInlined_offset);</span>
<span class="line-added">4828 }</span>
<span class="line-added">4829 </span>
<span class="line-added">4830 void jdk_internal_vm_jni_SubElementSelector::setIsInlined(oop obj, bool b) {</span>
<span class="line-added">4831   obj-&gt;bool_field_put(_isInlined_offset, b);</span>
<span class="line-added">4832 }</span>
<span class="line-added">4833 </span>
<span class="line-added">4834 bool jdk_internal_vm_jni_SubElementSelector::getIsInlineType(oop obj) {</span>
<span class="line-added">4835   return obj-&gt;bool_field(_isInlineType_offset);</span>
<span class="line-added">4836 }</span>
<span class="line-added">4837 </span>
<span class="line-added">4838 void jdk_internal_vm_jni_SubElementSelector::setIsInlineType(oop obj, bool b) {</span>
<span class="line-added">4839   obj-&gt;bool_field_put(_isInlineType_offset, b);</span>
<span class="line-added">4840 }</span>
<span class="line-added">4841 </span>
4842 jbyte java_lang_Byte::value(oop obj) {
4843    jvalue v;
4844    java_lang_boxing_object::get_value(obj, &amp;v);
4845    return v.b;
4846 }
4847 
4848 int java_lang_Boolean::_static_TRUE_offset;
4849 int java_lang_Boolean::_static_FALSE_offset;
4850 
4851 #define BOOLEAN_FIELDS_DO(macro) \
4852   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4853   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4854 
4855 
4856 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4857   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4858   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4859 }
4860 
4861 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4862   oop base = ik-&gt;static_field_base_raw();
4863   return base-&gt;obj_field(_static_TRUE_offset);
4864 }
4865 
4866 oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {
4867   oop base = ik-&gt;static_field_base_raw();
4868   return base-&gt;obj_field(_static_FALSE_offset);
4869 }
4870 
4871 Symbol* java_lang_Boolean::symbol() {
4872   return vmSymbols::java_lang_Boolean();
4873 }
4874 
4875 #if INCLUDE_CDS
4876 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4877   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4878 }
4879 #endif
4880 #undef BOOLEAN_CACHE_FIELDS_DO
4881 
4882 jboolean java_lang_Boolean::value(oop obj) {
4883    jvalue v;
4884    java_lang_boxing_object::get_value(obj, &amp;v);
4885    return v.z;
4886 }
4887 
4888 // java_lang_reflect_RecordComponent
4889 
4890 int java_lang_reflect_RecordComponent::_clazz_offset;
4891 int java_lang_reflect_RecordComponent::_name_offset;
4892 int java_lang_reflect_RecordComponent::_type_offset;
4893 int java_lang_reflect_RecordComponent::_accessor_offset;
4894 int java_lang_reflect_RecordComponent::_signature_offset;
4895 int java_lang_reflect_RecordComponent::_annotations_offset;
4896 int java_lang_reflect_RecordComponent::_typeAnnotations_offset;
4897 
4898 #define RECORDCOMPONENT_FIELDS_DO(macro) \
4899   macro(_clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \
4900   macro(_name_offset,        k, &quot;name&quot;,        string_signature, false); \
4901   macro(_type_offset,        k, &quot;type&quot;,        class_signature,  false); \
4902   macro(_accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \
4903   macro(_signature_offset,   k, &quot;signature&quot;,   string_signature, false); \
4904   macro(_annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \
4905   macro(_typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);
4906 
4907 // Support for java_lang_reflect_RecordComponent
4908 void java_lang_reflect_RecordComponent::compute_offsets() {
4909   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4910   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4911 }
4912 
4913 #if INCLUDE_CDS
4914 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4915   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4916 }
4917 #endif
4918 
4919 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
4920   element-&gt;obj_field_put(_clazz_offset, value);
4921 }
4922 
4923 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
4924   element-&gt;obj_field_put(_name_offset, value);
4925 }
4926 
4927 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
4928   element-&gt;obj_field_put(_type_offset, value);
4929 }
4930 
4931 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
4932   element-&gt;obj_field_put(_accessor_offset, value);
4933 }
4934 
4935 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
4936   element-&gt;obj_field_put(_signature_offset, value);
4937 }
4938 
4939 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
4940   element-&gt;obj_field_put(_annotations_offset, value);
4941 }
4942 
4943 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
4944   element-&gt;obj_field_put(_typeAnnotations_offset, value);
4945 }
4946 
4947 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4948 
4949 // Compute field offsets of all the classes in this file
4950 void JavaClasses::compute_offsets() {
4951   if (UseSharedSpaces) {
4952     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4953                                                          JvmtiExport::has_early_class_hook_env()),
4954                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4955     // None of the classes used by the rest of this function can be replaced by
4956     // JVMTI ClassFileLoadHook.
4957     // We are safe to use the archived offsets, which have already been restored
4958     // by JavaClasses::serialize_offsets, without computing the offsets again.
4959     return;
4960   }
4961 
4962   // We have already called the compute_offsets() of the
4963   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String, java_lang_Class and
4964   // java_lang_ref_Reference) earlier inside SystemDictionary::resolve_well_known_classes()
4965   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4966 }
4967 
4968 #if INCLUDE_CDS
4969 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4970 
4971 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4972   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4973 }
4974 #endif
4975 
4976 #if INCLUDE_CDS_JAVA_HEAP
4977 bool JavaClasses::is_supported_for_archiving(oop obj) {
4978   Klass* klass = obj-&gt;klass();
4979 
4980   if (klass == SystemDictionary::ClassLoader_klass() ||  // ClassLoader::loader_data is malloc&#39;ed.
4981       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
4982       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
4983       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
4984       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
4985       // So for now we cannot not support these classes for archiving.
4986       //
4987       // These objects typically are not referenced by static fields, but rather by resolved
4988       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.
4989       klass == SystemDictionary::ResolvedMethodName_klass() ||
4990       klass == SystemDictionary::MemberName_klass() ||
4991       klass == SystemDictionary::Context_klass()) {
4992     return false;
4993   }
4994 
4995   return true;
4996 }
4997 #endif
4998 
4999 #ifndef PRODUCT
5000 
5001 // These functions exist to assert the validity of de-serialized offsets in boxing object as a sanity check.
5002 
5003 bool JavaClasses::check_offset(const char *klass_name, int deserialized_offset, const char *field_name,
5004                                const char* field_sig) {
5005   EXCEPTION_MARK;
5006   fieldDescriptor fd;
5007   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
5008   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
5009   InstanceKlass* ik = InstanceKlass::cast(k);
5010   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);
5011   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);
5012   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
5013     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
5014     return false;
5015   }
5016   if (fd.is_static()) {
5017     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
5018     return false;
5019   }
5020   if (fd.offset() == deserialized_offset ) {
5021     return true;
5022   } else {
5023     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is deserialized as %d but should really be %d.&quot;,
5024                   klass_name, field_name, deserialized_offset, fd.offset());
5025     return false;
5026   }
5027 }
5028 
5029 void JavaClasses::check_offsets() {
5030   bool valid = true;
5031 
5032 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
5033   valid &amp;= check_offset(klass_name, cpp_klass_name :: _##field_name ## _offset, #field_name, field_sig)
5034 
5035 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
5036   valid &amp;= check_offset(klass_name, cpp_klass_name :: _##long_ ## field_name ## _offset, #field_name, field_sig)
5037 
5038   // Boxed primitive objects (java_lang_boxing_object)
5039 
5040   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
5041   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
5042   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
5043   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
5044   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
5045   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
5046   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
5047   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
5048 
5049   if (!valid) vm_exit_during_initialization(&quot;Field offset verification failed&quot;);
5050 }
5051 
5052 #endif // PRODUCT
5053 
5054 int InjectedField::compute_offset() {
5055   InstanceKlass* ik = InstanceKlass::cast(klass());
5056   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
5057     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
5058       // Only look at injected fields
5059       continue;
5060     }
5061     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
5062       return fs.offset();
5063     }
5064   }
5065   ResourceMark rm;
5066   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
5067 #ifndef PRODUCT
5068   ik-&gt;print();
5069   tty-&gt;print_cr(&quot;all fields:&quot;);
5070   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
5071     tty-&gt;print_cr(&quot;  name: %s, sig: %s, flags: %08x&quot;, fs.name()-&gt;as_C_string(), fs.signature()-&gt;as_C_string(), fs.access_flags().as_int());
5072   }
5073 #endif //PRODUCT
5074   vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
5075   return -1;
5076 }
5077 
5078 void javaClasses_init() {
5079   JavaClasses::compute_offsets();
5080   JavaClasses::check_offsets();
5081   FilteredFieldsMap::initialize();  // must be done after computing offsets.
5082 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>