<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/deoptimization.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arguments.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldDescriptor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/deoptimization.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-removed">   1 </span>
<span class="line-removed">   2 </span>
   3 /*
   4  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   5  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   6  *
   7  * This code is free software; you can redistribute it and/or modify it
   8  * under the terms of the GNU General Public License version 2 only, as
   9  * published by the Free Software Foundation.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  26 
  27 #include &quot;precompiled.hpp&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;code/codeCache.hpp&quot;
  33 #include &quot;code/debugInfoRec.hpp&quot;
  34 #include &quot;code/nmethod.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;code/scopeDesc.hpp&quot;
  37 #include &quot;compiler/compilationPolicy.hpp&quot;
  38 #include &quot;interpreter/bytecode.hpp&quot;
  39 #include &quot;interpreter/interpreter.hpp&quot;
  40 #include &quot;interpreter/oopMapCache.hpp&quot;
  41 #include &quot;memory/allocation.inline.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/constantPool.hpp&quot;


  46 #include &quot;oops/method.hpp&quot;
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.inline.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;oops/fieldStreams.inline.hpp&quot;

  51 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  52 #include &quot;oops/verifyOopClosure.hpp&quot;
  53 #include &quot;prims/jvmtiThreadState.hpp&quot;
  54 #include &quot;runtime/atomic.hpp&quot;
  55 #include &quot;runtime/biasedLocking.hpp&quot;
  56 #include &quot;runtime/deoptimization.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.hpp&quot;
  58 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  59 #include &quot;runtime/frame.inline.hpp&quot;
  60 #include &quot;runtime/handles.inline.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/jniHandles.inline.hpp&quot;
  63 #include &quot;runtime/safepointVerifiers.hpp&quot;
  64 #include &quot;runtime/sharedRuntime.hpp&quot;
  65 #include &quot;runtime/signature.hpp&quot;
  66 #include &quot;runtime/stubRoutines.hpp&quot;
  67 #include &quot;runtime/thread.hpp&quot;
  68 #include &quot;runtime/threadSMR.hpp&quot;
  69 #include &quot;runtime/vframe.hpp&quot;
  70 #include &quot;runtime/vframeArray.hpp&quot;
</pre>
<hr />
<pre>
 165   return fetch_unroll_info_helper(thread, exec_mode);
 166 JRT_END
 167 
 168 #if COMPILER2_OR_JVMCI
 169 static bool eliminate_allocations(JavaThread* thread, int exec_mode, CompiledMethod* compiled_method,
 170                                   frame&amp; deoptee, RegisterMap&amp; map, GrowableArray&lt;compiledVFrame*&gt;* chunk) {
 171   bool realloc_failures = false;
 172   assert (chunk-&gt;at(0)-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);
 173 
 174   GrowableArray&lt;ScopeValue*&gt;* objects = chunk-&gt;at(0)-&gt;scope()-&gt;objects();
 175 
 176   // The flag return_oop() indicates call sites which return oop
 177   // in compiled code. Such sites include java method calls,
 178   // runtime calls (for example, used to allocate new objects/arrays
 179   // on slow code path) and any other calls generated in compiled code.
 180   // It is not guaranteed that we can get such information here only
 181   // by analyzing bytecode in deoptimized frames. This is why this flag
 182   // is set during method compilation (see Compile::Process_OopMap_Node()).
 183   // If the previous frame was popped or if we are dispatching an exception,
 184   // we don&#39;t have an oop result.
<span class="line-modified"> 185   bool save_oop_result = chunk-&gt;at(0)-&gt;scope()-&gt;return_oop() &amp;&amp; !thread-&gt;popframe_forcing_deopt_reexecution() &amp;&amp; (exec_mode == Deoptimization::Unpack_deopt);</span>
<span class="line-modified"> 186   Handle return_value;</span>











 187   if (save_oop_result) {
 188     // Reallocation may trigger GC. If deoptimization happened on return from
 189     // call which returns oop we need to save it since it is not in oopmap.
 190     oop result = deoptee.saved_oop_result(&amp;map);
 191     assert(oopDesc::is_oop_or_null(result), &quot;must be oop&quot;);
<span class="line-modified"> 192     return_value = Handle(thread, result);</span>
 193     assert(Universe::heap()-&gt;is_in_or_null(result), &quot;must be heap pointer&quot;);
 194     if (TraceDeoptimization) {
 195       ttyLocker ttyl;
 196       tty-&gt;print_cr(&quot;SAVED OOP RESULT &quot; INTPTR_FORMAT &quot; in thread &quot; INTPTR_FORMAT, p2i(result), p2i(thread));
 197     }
 198   }
<span class="line-modified"> 199   if (objects != NULL) {</span>

 200     JRT_BLOCK
<span class="line-modified"> 201       realloc_failures = Deoptimization::realloc_objects(thread, &amp;deoptee, &amp;map, objects, THREAD);</span>






 202     JRT_END
<span class="line-removed"> 203     bool skip_internal = (compiled_method != NULL) &amp;&amp; !compiled_method-&gt;is_compiled_by_jvmci();</span>
<span class="line-removed"> 204     Deoptimization::reassign_fields(&amp;deoptee, &amp;map, objects, realloc_failures, skip_internal);</span>
 205 #ifndef PRODUCT
 206     if (TraceDeoptimization) {
 207       ttyLocker ttyl;
 208       tty-&gt;print_cr(&quot;REALLOC OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));
<span class="line-modified"> 209       Deoptimization::print_objects(objects, realloc_failures);</span>





 210     }
 211 #endif
 212   }
<span class="line-modified"> 213   if (save_oop_result) {</span>
 214     // Restore result.
<span class="line-modified"> 215     deoptee.set_saved_oop_result(&amp;map, return_value());</span>

 216   }
 217   return realloc_failures;
 218 }
 219 
 220 static void eliminate_locks(JavaThread* thread, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
 221 #ifndef PRODUCT
 222   bool first = true;
 223 #endif
 224   for (int i = 0; i &lt; chunk-&gt;length(); i++) {
 225     compiledVFrame* cvf = chunk-&gt;at(i);
 226     assert (cvf-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);
 227     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
 228     if (monitors-&gt;is_nonempty()) {
 229       Deoptimization::relock_objects(monitors, thread, realloc_failures);
 230 #ifndef PRODUCT
 231       if (PrintDeoptimizationDetails) {
 232         ttyLocker ttyl;
 233         for (int j = 0; j &lt; monitors-&gt;length(); j++) {
 234           MonitorInfo* mi = monitors-&gt;at(j);
 235           if (mi-&gt;eliminated()) {
</pre>
<hr />
<pre>
 496   // its caller&#39;s stack by. If the caller is a compiled frame then
 497   // we pretend that the callee has no parameters so that the
 498   // extension counts for the full amount of locals and not just
 499   // locals-parms. This is because without a c2i adapter the parm
 500   // area as created by the compiled frame will not be usable by
 501   // the interpreter. (Depending on the calling convention there
 502   // may not even be enough space).
 503 
 504   // QQQ I&#39;d rather see this pushed down into last_frame_adjust
 505   // and have it take the sender (aka caller).
 506 
 507   if (deopt_sender.is_compiled_frame() || caller_was_method_handle) {
 508     caller_adjustment = last_frame_adjust(0, callee_locals);
 509   } else if (callee_locals &gt; callee_parameters) {
 510     // The caller frame may need extending to accommodate
 511     // non-parameter locals of the first unpacked interpreted frame.
 512     // Compute that adjustment.
 513     caller_adjustment = last_frame_adjust(callee_parameters, callee_locals);
 514   }
 515 
<span class="line-modified"> 516   // If the sender is deoptimized the we must retrieve the address of the handler</span>
 517   // since the frame will &quot;magically&quot; show the original pc before the deopt
 518   // and we&#39;d undo the deopt.
 519 
 520   frame_pcs[0] = deopt_sender.raw_pc();
 521 
 522   assert(CodeCache::find_blob_unsafe(frame_pcs[0]) != NULL, &quot;bad pc&quot;);
 523 
 524 #if INCLUDE_JVMCI
 525   if (exceptionObject() != NULL) {
 526     thread-&gt;set_exception_oop(exceptionObject());
 527     exec_mode = Unpack_exception;
 528   }
 529 #endif
 530 
 531   if (thread-&gt;frames_to_pop_failed_realloc() &gt; 0 &amp;&amp; exec_mode != Unpack_uncommon_trap) {
 532     assert(thread-&gt;has_pending_exception(), &quot;should have thrown OOME&quot;);
 533     thread-&gt;set_exception_oop(thread-&gt;pending_exception());
 534     thread-&gt;clear_pending_exception();
 535     exec_mode = Unpack_exception;
 536   }
</pre>
<hr />
<pre>
 987 
 988     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
 989     oop obj = NULL;
 990 
 991     if (k-&gt;is_instance_klass()) {
 992 #if INCLUDE_JVMCI || INCLUDE_AOT
 993       CompiledMethod* cm = fr-&gt;cb()-&gt;as_compiled_method_or_null();
 994       if (cm-&gt;is_compiled_by_jvmci() &amp;&amp; sv-&gt;is_auto_box()) {
 995         AutoBoxObjectValue* abv = (AutoBoxObjectValue*) sv;
 996         obj = get_cached_box(abv, fr, reg_map, THREAD);
 997         if (obj != NULL) {
 998           // Set the flag to indicate the box came from a cache, so that we can skip the field reassignment for it.
 999           abv-&gt;set_cached(true);
1000         }
1001       }
1002 #endif // INCLUDE_JVMCI || INCLUDE_AOT
1003       InstanceKlass* ik = InstanceKlass::cast(k);
1004       if (obj == NULL) {
1005         obj = ik-&gt;allocate_instance(THREAD);
1006       }




1007     } else if (k-&gt;is_typeArray_klass()) {
1008       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1009       assert(sv-&gt;field_size() % type2size[ak-&gt;element_type()] == 0, &quot;non-integral array length&quot;);
1010       int len = sv-&gt;field_size() / type2size[ak-&gt;element_type()];
1011       obj = ak-&gt;allocate(len, THREAD);
1012     } else if (k-&gt;is_objArray_klass()) {
1013       ObjArrayKlass* ak = ObjArrayKlass::cast(k);
1014       obj = ak-&gt;allocate(sv-&gt;field_size(), THREAD);
1015     }
1016 
1017     if (obj == NULL) {
1018       failures = true;
1019     }
1020 
1021     assert(sv-&gt;value().is_null(), &quot;redundant reallocation&quot;);
1022     assert(obj != NULL || HAS_PENDING_EXCEPTION, &quot;allocation should succeed or we should get an exception&quot;);
1023     CLEAR_PENDING_EXCEPTION;
1024     sv-&gt;set_value(obj);
1025   }
1026 
1027   if (failures) {
1028     THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), failures);
1029   } else if (pending_exception.not_null()) {
1030     thread-&gt;set_pending_exception(pending_exception(), exception_file, exception_line);
1031   }
1032 
1033   return failures;
1034 }
1035 















1036 #if INCLUDE_JVMCI
1037 /**
1038  * For primitive types whose kind gets &quot;erased&quot; at runtime (shorts become stack ints),
1039  * we need to somehow be able to recover the actual kind to be able to write the correct
1040  * amount of bytes.
1041  * For that purpose, this method assumes that, for an entry spanning n bytes at index i,
1042  * the entries at index n + 1 to n + i are &#39;markers&#39;.
1043  * For example, if we were writing a short at index 4 of a byte array of size 8, the
1044  * expected form of the array would be:
1045  *
1046  * {b0, b1, b2, b3, INT, marker, b6, b7}
1047  *
1048  * Thus, in order to get back the size of the entry, we simply need to count the number
1049  * of marked entries
1050  *
1051  * @param virtualArray the virtualized byte array
1052  * @param i index of the virtual entry we are recovering
1053  * @return The number of bytes the entry spans
1054  */
1055 static int count_number_of_bytes_for_entry(ObjectValue *virtualArray, int i) {
</pre>
<hr />
<pre>
1188       default:
1189         ShouldNotReachHere();
1190     }
1191     index++;
1192   }
1193 }
1194 
1195 // restore fields of an eliminated object array
1196 void Deoptimization::reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj) {
1197   for (int i = 0; i &lt; sv-&gt;field_size(); i++) {
1198     StackValue* value = StackValue::create_stack_value(fr, reg_map, sv-&gt;field_at(i));
1199     assert(value-&gt;type() == T_OBJECT, &quot;object element expected&quot;);
1200     obj-&gt;obj_at_put(i, value-&gt;get_obj()());
1201   }
1202 }
1203 
1204 class ReassignedField {
1205 public:
1206   int _offset;
1207   BasicType _type;

1208 public:
1209   ReassignedField() {
1210     _offset = 0;
1211     _type = T_ILLEGAL;

1212   }
1213 };
1214 
1215 int compare(ReassignedField* left, ReassignedField* right) {
1216   return left-&gt;_offset - right-&gt;_offset;
1217 }
1218 
1219 // Restore fields of an eliminated instance object using the same field order
1220 // returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)
<span class="line-modified">1221 static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal) {</span>

1222   GrowableArray&lt;ReassignedField&gt;* fields = new GrowableArray&lt;ReassignedField&gt;();
1223   InstanceKlass* ik = klass;
1224   while (ik != NULL) {
1225     for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
1226       if (!fs.access_flags().is_static() &amp;&amp; (!skip_internal || !fs.access_flags().is_internal())) {
1227         ReassignedField field;
1228         field._offset = fs.offset();
1229         field._type = Signature::basic_type(fs.signature());









1230         fields-&gt;append(field);
1231       }
1232     }
1233     ik = ik-&gt;superklass();
1234   }
1235   fields-&gt;sort(compare);
1236   for (int i = 0; i &lt; fields-&gt;length(); i++) {
1237     intptr_t val;
1238     ScopeValue* scope_field = sv-&gt;field_at(svIndex);
1239     StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);
<span class="line-modified">1240     int offset = fields-&gt;at(i)._offset;</span>
1241     BasicType type = fields-&gt;at(i)._type;
1242     switch (type) {
<span class="line-modified">1243       case T_OBJECT: case T_ARRAY:</span>

1244         assert(value-&gt;type() == T_OBJECT, &quot;Agreement.&quot;);
1245         obj-&gt;obj_field_put(offset, value-&gt;get_obj()());
1246         break;
1247 









1248       // Have to cast to INT (32 bits) pointer to avoid little/big-endian problem.
1249       case T_INT: case T_FLOAT: { // 4 bytes.
1250         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1251         bool big_value = false;
1252         if (i+1 &lt; fields-&gt;length() &amp;&amp; fields-&gt;at(i+1)._type == T_INT) {
1253           if (scope_field-&gt;is_location()) {
1254             Location::Type type = ((LocationValue*) scope_field)-&gt;location().type();
1255             if (type == Location::dbl || type == Location::lng) {
1256               big_value = true;
1257             }
1258           }
1259           if (scope_field-&gt;is_constant_int()) {
1260             ScopeValue* next_scope_field = sv-&gt;field_at(svIndex + 1);
1261             if (next_scope_field-&gt;is_constant_long() || next_scope_field-&gt;is_constant_double()) {
1262               big_value = true;
1263             }
1264           }
1265         }
1266 
1267         if (big_value) {
</pre>
<hr />
<pre>
1303       case T_BYTE:
1304         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1305         val = value-&gt;get_int();
1306         obj-&gt;byte_field_put(offset, (jbyte)*((jint*)&amp;val));
1307         break;
1308 
1309       case T_BOOLEAN:
1310         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1311         val = value-&gt;get_int();
1312         obj-&gt;bool_field_put(offset, (jboolean)*((jint*)&amp;val));
1313         break;
1314 
1315       default:
1316         ShouldNotReachHere();
1317     }
1318     svIndex++;
1319   }
1320   return svIndex;
1321 }
1322 














1323 // restore fields of all eliminated objects and arrays
<span class="line-modified">1324 void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures, bool skip_internal) {</span>
1325   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1326     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1327     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1328     Handle obj = sv-&gt;value();
1329     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);
1330     if (PrintDeoptimizationDetails) {
1331       tty-&gt;print_cr(&quot;reassign fields for object of type %s!&quot;, k-&gt;name()-&gt;as_C_string());
1332     }
1333     if (obj.is_null()) {
1334       continue;
1335     }
1336 #if INCLUDE_JVMCI || INCLUDE_AOT
1337     // Don&#39;t reassign fields of boxes that came from a cache. Caches may be in CDS.
1338     if (sv-&gt;is_auto_box() &amp;&amp; ((AutoBoxObjectValue*) sv)-&gt;is_cached()) {
1339       continue;
1340     }
1341 #endif // INCLUDE_JVMCI || INCLUDE_AOT
1342     if (k-&gt;is_instance_klass()) {
1343       InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">1344       reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal);</span>



1345     } else if (k-&gt;is_typeArray_klass()) {
1346       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1347       reassign_type_array_elements(fr, reg_map, sv, (typeArrayOop) obj(), ak-&gt;element_type());
1348     } else if (k-&gt;is_objArray_klass()) {
1349       reassign_object_array_elements(fr, reg_map, sv, (objArrayOop) obj());
1350     }
1351   }
1352 }
1353 
1354 
1355 // relock objects for which synchronization was eliminated
1356 void Deoptimization::relock_objects(GrowableArray&lt;MonitorInfo*&gt;* monitors, JavaThread* thread, bool realloc_failures) {
1357   for (int i = 0; i &lt; monitors-&gt;length(); i++) {
1358     MonitorInfo* mon_info = monitors-&gt;at(i);
1359     if (mon_info-&gt;eliminated()) {
1360       assert(!mon_info-&gt;owner_is_scalar_replaced() || realloc_failures, &quot;reallocation was missed&quot;);
1361       if (!mon_info-&gt;owner_is_scalar_replaced()) {
1362         Handle obj(thread, mon_info-&gt;owner());
1363         markWord mark = obj-&gt;mark();
1364         if (UseBiasedLocking &amp;&amp; mark.has_bias_pattern()) {
</pre>
<hr />
<pre>
1367           // where the thread-local object is bias locked to the current thread.
1368           assert(mark.is_biased_anonymously() ||
1369                  mark.biased_locker() == thread, &quot;should be locked to current thread&quot;);
1370           // Reset mark word to unbiased prototype.
1371           markWord unbiased_prototype = markWord::prototype().set_age(mark.age());
1372           obj-&gt;set_mark(unbiased_prototype);
1373         }
1374         BasicLock* lock = mon_info-&gt;lock();
1375         ObjectSynchronizer::enter(obj, lock, thread);
1376         assert(mon_info-&gt;owner()-&gt;is_locked(), &quot;object must be locked now&quot;);
1377       }
1378     }
1379   }
1380 }
1381 
1382 
1383 #ifndef PRODUCT
1384 // print information about reallocated objects
1385 void Deoptimization::print_objects(GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures) {
1386   fieldDescriptor fd;
<span class="line-removed">1387 </span>
1388   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1389     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1390     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
<span class="line-modified">1391     Handle obj = sv-&gt;value();</span>


1392 
<span class="line-modified">1393     tty-&gt;print(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; of type &quot;, p2i(sv-&gt;value()()));</span>
<span class="line-modified">1394     k-&gt;print_value();</span>
<span class="line-modified">1395     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);</span>
<span class="line-modified">1396     if (obj.is_null()) {</span>
<span class="line-modified">1397       tty-&gt;print(&quot; allocation failed&quot;);</span>
<span class="line-modified">1398     } else {</span>
<span class="line-modified">1399       tty-&gt;print(&quot; allocated (%d bytes)&quot;, obj-&gt;size() * HeapWordSize);</span>
<span class="line-modified">1400     }</span>
<span class="line-modified">1401     tty-&gt;cr();</span>

1402 
<span class="line-modified">1403     if (Verbose &amp;&amp; !obj.is_null()) {</span>
<span class="line-modified">1404       k-&gt;oop_print_on(obj(), tty);</span>
<span class="line-removed">1405     }</span>
1406   }
1407 }
1408 #endif
1409 #endif // COMPILER2_OR_JVMCI
1410 
1411 vframeArray* Deoptimization::create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
1412   Events::log_deopt_message(thread, &quot;DEOPT PACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(fr.pc()), p2i(fr.sp()));
1413 
1414 #ifndef PRODUCT
1415   if (PrintDeoptimizationDetails) {
1416     ttyLocker ttyl;
1417     tty-&gt;print(&quot;DEOPT PACKING thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(thread));
1418     fr.print_on(tty);
1419     tty-&gt;print_cr(&quot;     Virtual frames (innermost first):&quot;);
1420     for (int index = 0; index &lt; chunk-&gt;length(); index++) {
1421       compiledVFrame* vf = chunk-&gt;at(index);
1422       tty-&gt;print(&quot;       %2d - &quot;, index);
1423       vf-&gt;print_value();
1424       int bci = chunk-&gt;at(index)-&gt;raw_bci();
1425       const char* code_name;
</pre>
<hr />
<pre>
1558 
1559     ttyLocker ttyl;
1560     xtty-&gt;begin_head(&quot;deoptimized thread=&#39;&quot; UINTX_FORMAT &quot;&#39; reason=&#39;%s&#39; pc=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;,(uintx)thread-&gt;osthread()-&gt;thread_id(), trap_reason_name(reason), p2i(fr.pc()));
1561     cm-&gt;log_identity(xtty);
1562     xtty-&gt;end_head();
1563     for (ScopeDesc* sd = cm-&gt;scope_desc_at(fr.pc()); ; sd = sd-&gt;sender()) {
1564       xtty-&gt;begin_elem(&quot;jvms bci=&#39;%d&#39;&quot;, sd-&gt;bci());
1565       xtty-&gt;method(sd-&gt;method());
1566       xtty-&gt;end_elem();
1567       if (sd-&gt;is_top())  break;
1568     }
1569     xtty-&gt;tail(&quot;deoptimized&quot;);
1570   }
1571 
1572   // Patch the compiled method so that when execution returns to it we will
1573   // deopt the execution state and return to the interpreter.
1574   fr.deoptimize(thread);
1575 }
1576 
1577 void Deoptimization::deoptimize(JavaThread* thread, frame fr, DeoptReason reason) {
<span class="line-modified">1578   // Deoptimize only if the frame comes from compile code.</span>
1579   // Do not deoptimize the frame which is already patched
1580   // during the execution of the loops below.
1581   if (!fr.is_compiled_frame() || fr.is_deoptimized_frame()) {
1582     return;
1583   }
1584   ResourceMark rm;
1585   DeoptimizationMarker dm;
1586   deoptimize_single_frame(thread, fr, reason);
1587 }
1588 
1589 #if INCLUDE_JVMCI
1590 address Deoptimization::deoptimize_for_missing_exception_handler(CompiledMethod* cm) {
1591   // there is no exception handler for this pc =&gt; deoptimize
1592   cm-&gt;make_not_entrant();
1593 
1594   // Use Deoptimization::deoptimize for all of its side-effects:
1595   // gathering traps statistics, logging...
1596   // it also patches the return pc but we do not care about that
1597   // since we return a continuation to the deopt_blob below.
1598   JavaThread* thread = JavaThread::current();
</pre>
</td>
<td>
<hr />
<pre>


   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;code/codeCache.hpp&quot;
  31 #include &quot;code/debugInfoRec.hpp&quot;
  32 #include &quot;code/nmethod.hpp&quot;
  33 #include &quot;code/pcDesc.hpp&quot;
  34 #include &quot;code/scopeDesc.hpp&quot;
  35 #include &quot;compiler/compilationPolicy.hpp&quot;
  36 #include &quot;interpreter/bytecode.hpp&quot;
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;interpreter/oopMapCache.hpp&quot;
  39 #include &quot;memory/allocation.inline.hpp&quot;
  40 #include &quot;memory/oopFactory.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;memory/universe.hpp&quot;
  43 #include &quot;oops/constantPool.hpp&quot;
<span class="line-added">  44 #include &quot;oops/flatArrayKlass.hpp&quot;</span>
<span class="line-added">  45 #include &quot;oops/flatArrayOop.hpp&quot;</span>
  46 #include &quot;oops/method.hpp&quot;
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.inline.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;oops/fieldStreams.inline.hpp&quot;
<span class="line-added">  51 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  53 #include &quot;oops/verifyOopClosure.hpp&quot;
  54 #include &quot;prims/jvmtiThreadState.hpp&quot;
  55 #include &quot;runtime/atomic.hpp&quot;
  56 #include &quot;runtime/biasedLocking.hpp&quot;
  57 #include &quot;runtime/deoptimization.hpp&quot;
  58 #include &quot;runtime/fieldDescriptor.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  63 #include &quot;runtime/jniHandles.inline.hpp&quot;
  64 #include &quot;runtime/safepointVerifiers.hpp&quot;
  65 #include &quot;runtime/sharedRuntime.hpp&quot;
  66 #include &quot;runtime/signature.hpp&quot;
  67 #include &quot;runtime/stubRoutines.hpp&quot;
  68 #include &quot;runtime/thread.hpp&quot;
  69 #include &quot;runtime/threadSMR.hpp&quot;
  70 #include &quot;runtime/vframe.hpp&quot;
  71 #include &quot;runtime/vframeArray.hpp&quot;
</pre>
<hr />
<pre>
 166   return fetch_unroll_info_helper(thread, exec_mode);
 167 JRT_END
 168 
 169 #if COMPILER2_OR_JVMCI
 170 static bool eliminate_allocations(JavaThread* thread, int exec_mode, CompiledMethod* compiled_method,
 171                                   frame&amp; deoptee, RegisterMap&amp; map, GrowableArray&lt;compiledVFrame*&gt;* chunk) {
 172   bool realloc_failures = false;
 173   assert (chunk-&gt;at(0)-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);
 174 
 175   GrowableArray&lt;ScopeValue*&gt;* objects = chunk-&gt;at(0)-&gt;scope()-&gt;objects();
 176 
 177   // The flag return_oop() indicates call sites which return oop
 178   // in compiled code. Such sites include java method calls,
 179   // runtime calls (for example, used to allocate new objects/arrays
 180   // on slow code path) and any other calls generated in compiled code.
 181   // It is not guaranteed that we can get such information here only
 182   // by analyzing bytecode in deoptimized frames. This is why this flag
 183   // is set during method compilation (see Compile::Process_OopMap_Node()).
 184   // If the previous frame was popped or if we are dispatching an exception,
 185   // we don&#39;t have an oop result.
<span class="line-modified"> 186   ScopeDesc* scope = chunk-&gt;at(0)-&gt;scope();</span>
<span class="line-modified"> 187   bool save_oop_result = scope-&gt;return_oop() &amp;&amp; !thread-&gt;popframe_forcing_deopt_reexecution() &amp;&amp; (exec_mode == Deoptimization::Unpack_deopt);</span>
<span class="line-added"> 188   // In case of the return of multiple values, we must take care</span>
<span class="line-added"> 189   // of all oop return values.</span>
<span class="line-added"> 190   GrowableArray&lt;Handle&gt; return_oops;</span>
<span class="line-added"> 191   InlineKlass* vk = NULL;</span>
<span class="line-added"> 192   if (save_oop_result &amp;&amp; scope-&gt;return_vt()) {</span>
<span class="line-added"> 193     vk = InlineKlass::returned_inline_klass(map);</span>
<span class="line-added"> 194     if (vk != NULL) {</span>
<span class="line-added"> 195       vk-&gt;save_oop_fields(map, return_oops);</span>
<span class="line-added"> 196       save_oop_result = false;</span>
<span class="line-added"> 197     }</span>
<span class="line-added"> 198   }</span>
 199   if (save_oop_result) {
 200     // Reallocation may trigger GC. If deoptimization happened on return from
 201     // call which returns oop we need to save it since it is not in oopmap.
 202     oop result = deoptee.saved_oop_result(&amp;map);
 203     assert(oopDesc::is_oop_or_null(result), &quot;must be oop&quot;);
<span class="line-modified"> 204     return_oops.push(Handle(thread, result));</span>
 205     assert(Universe::heap()-&gt;is_in_or_null(result), &quot;must be heap pointer&quot;);
 206     if (TraceDeoptimization) {
 207       ttyLocker ttyl;
 208       tty-&gt;print_cr(&quot;SAVED OOP RESULT &quot; INTPTR_FORMAT &quot; in thread &quot; INTPTR_FORMAT, p2i(result), p2i(thread));
 209     }
 210   }
<span class="line-modified"> 211   if (objects != NULL || vk != NULL) {</span>
<span class="line-added"> 212     bool skip_internal = (compiled_method != NULL) &amp;&amp; !compiled_method-&gt;is_compiled_by_jvmci();</span>
 213     JRT_BLOCK
<span class="line-modified"> 214       if (vk != NULL) {</span>
<span class="line-added"> 215         realloc_failures = Deoptimization::realloc_inline_type_result(vk, map, return_oops, THREAD);</span>
<span class="line-added"> 216       }</span>
<span class="line-added"> 217       if (objects != NULL) {</span>
<span class="line-added"> 218         realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &amp;deoptee, &amp;map, objects, THREAD);</span>
<span class="line-added"> 219         Deoptimization::reassign_fields(&amp;deoptee, &amp;map, objects, realloc_failures, skip_internal, THREAD);</span>
<span class="line-added"> 220       }</span>
 221     JRT_END


 222 #ifndef PRODUCT
 223     if (TraceDeoptimization) {
 224       ttyLocker ttyl;
 225       tty-&gt;print_cr(&quot;REALLOC OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));
<span class="line-modified"> 226       if (objects != NULL) {</span>
<span class="line-added"> 227         Deoptimization::print_objects(objects, realloc_failures);</span>
<span class="line-added"> 228       } else {</span>
<span class="line-added"> 229         Handle obj = realloc_failures ? Handle() : return_oops.first();</span>
<span class="line-added"> 230         Deoptimization::print_object(vk, obj, realloc_failures);</span>
<span class="line-added"> 231       }</span>
 232     }
 233 #endif
 234   }
<span class="line-modified"> 235   if (save_oop_result || vk != NULL) {</span>
 236     // Restore result.
<span class="line-modified"> 237     assert(return_oops.length() == 1, &quot;no inline type&quot;);</span>
<span class="line-added"> 238     deoptee.set_saved_oop_result(&amp;map, return_oops.pop()());</span>
 239   }
 240   return realloc_failures;
 241 }
 242 
 243 static void eliminate_locks(JavaThread* thread, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
 244 #ifndef PRODUCT
 245   bool first = true;
 246 #endif
 247   for (int i = 0; i &lt; chunk-&gt;length(); i++) {
 248     compiledVFrame* cvf = chunk-&gt;at(i);
 249     assert (cvf-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);
 250     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
 251     if (monitors-&gt;is_nonempty()) {
 252       Deoptimization::relock_objects(monitors, thread, realloc_failures);
 253 #ifndef PRODUCT
 254       if (PrintDeoptimizationDetails) {
 255         ttyLocker ttyl;
 256         for (int j = 0; j &lt; monitors-&gt;length(); j++) {
 257           MonitorInfo* mi = monitors-&gt;at(j);
 258           if (mi-&gt;eliminated()) {
</pre>
<hr />
<pre>
 519   // its caller&#39;s stack by. If the caller is a compiled frame then
 520   // we pretend that the callee has no parameters so that the
 521   // extension counts for the full amount of locals and not just
 522   // locals-parms. This is because without a c2i adapter the parm
 523   // area as created by the compiled frame will not be usable by
 524   // the interpreter. (Depending on the calling convention there
 525   // may not even be enough space).
 526 
 527   // QQQ I&#39;d rather see this pushed down into last_frame_adjust
 528   // and have it take the sender (aka caller).
 529 
 530   if (deopt_sender.is_compiled_frame() || caller_was_method_handle) {
 531     caller_adjustment = last_frame_adjust(0, callee_locals);
 532   } else if (callee_locals &gt; callee_parameters) {
 533     // The caller frame may need extending to accommodate
 534     // non-parameter locals of the first unpacked interpreted frame.
 535     // Compute that adjustment.
 536     caller_adjustment = last_frame_adjust(callee_parameters, callee_locals);
 537   }
 538 
<span class="line-modified"> 539   // If the sender is deoptimized we must retrieve the address of the handler</span>
 540   // since the frame will &quot;magically&quot; show the original pc before the deopt
 541   // and we&#39;d undo the deopt.
 542 
 543   frame_pcs[0] = deopt_sender.raw_pc();
 544 
 545   assert(CodeCache::find_blob_unsafe(frame_pcs[0]) != NULL, &quot;bad pc&quot;);
 546 
 547 #if INCLUDE_JVMCI
 548   if (exceptionObject() != NULL) {
 549     thread-&gt;set_exception_oop(exceptionObject());
 550     exec_mode = Unpack_exception;
 551   }
 552 #endif
 553 
 554   if (thread-&gt;frames_to_pop_failed_realloc() &gt; 0 &amp;&amp; exec_mode != Unpack_uncommon_trap) {
 555     assert(thread-&gt;has_pending_exception(), &quot;should have thrown OOME&quot;);
 556     thread-&gt;set_exception_oop(thread-&gt;pending_exception());
 557     thread-&gt;clear_pending_exception();
 558     exec_mode = Unpack_exception;
 559   }
</pre>
<hr />
<pre>
1010 
1011     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1012     oop obj = NULL;
1013 
1014     if (k-&gt;is_instance_klass()) {
1015 #if INCLUDE_JVMCI || INCLUDE_AOT
1016       CompiledMethod* cm = fr-&gt;cb()-&gt;as_compiled_method_or_null();
1017       if (cm-&gt;is_compiled_by_jvmci() &amp;&amp; sv-&gt;is_auto_box()) {
1018         AutoBoxObjectValue* abv = (AutoBoxObjectValue*) sv;
1019         obj = get_cached_box(abv, fr, reg_map, THREAD);
1020         if (obj != NULL) {
1021           // Set the flag to indicate the box came from a cache, so that we can skip the field reassignment for it.
1022           abv-&gt;set_cached(true);
1023         }
1024       }
1025 #endif // INCLUDE_JVMCI || INCLUDE_AOT
1026       InstanceKlass* ik = InstanceKlass::cast(k);
1027       if (obj == NULL) {
1028         obj = ik-&gt;allocate_instance(THREAD);
1029       }
<span class="line-added">1030     } else if (k-&gt;is_flatArray_klass()) {</span>
<span class="line-added">1031       FlatArrayKlass* ak = FlatArrayKlass::cast(k);</span>
<span class="line-added">1032       // Inline type array must be zeroed because not all memory is reassigned</span>
<span class="line-added">1033       obj = ak-&gt;allocate(sv-&gt;field_size(), THREAD);</span>
1034     } else if (k-&gt;is_typeArray_klass()) {
1035       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1036       assert(sv-&gt;field_size() % type2size[ak-&gt;element_type()] == 0, &quot;non-integral array length&quot;);
1037       int len = sv-&gt;field_size() / type2size[ak-&gt;element_type()];
1038       obj = ak-&gt;allocate(len, THREAD);
1039     } else if (k-&gt;is_objArray_klass()) {
1040       ObjArrayKlass* ak = ObjArrayKlass::cast(k);
1041       obj = ak-&gt;allocate(sv-&gt;field_size(), THREAD);
1042     }
1043 
1044     if (obj == NULL) {
1045       failures = true;
1046     }
1047 
1048     assert(sv-&gt;value().is_null(), &quot;redundant reallocation&quot;);
1049     assert(obj != NULL || HAS_PENDING_EXCEPTION, &quot;allocation should succeed or we should get an exception&quot;);
1050     CLEAR_PENDING_EXCEPTION;
1051     sv-&gt;set_value(obj);
1052   }
1053 
1054   if (failures) {
1055     THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), failures);
1056   } else if (pending_exception.not_null()) {
1057     thread-&gt;set_pending_exception(pending_exception(), exception_file, exception_line);
1058   }
1059 
1060   return failures;
1061 }
1062 
<span class="line-added">1063 // We&#39;re deoptimizing at the return of a call, inline type fields are</span>
<span class="line-added">1064 // in registers. When we go back to the interpreter, it will expect a</span>
<span class="line-added">1065 // reference to an inline type instance. Allocate and initialize it from</span>
<span class="line-added">1066 // the register values here.</span>
<span class="line-added">1067 bool Deoptimization::realloc_inline_type_result(InlineKlass* vk, const RegisterMap&amp; map, GrowableArray&lt;Handle&gt;&amp; return_oops, TRAPS) {</span>
<span class="line-added">1068   oop new_vt = vk-&gt;realloc_result(map, return_oops, THREAD);</span>
<span class="line-added">1069   if (new_vt == NULL) {</span>
<span class="line-added">1070     CLEAR_PENDING_EXCEPTION;</span>
<span class="line-added">1071     THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), true);</span>
<span class="line-added">1072   }</span>
<span class="line-added">1073   return_oops.clear();</span>
<span class="line-added">1074   return_oops.push(Handle(THREAD, new_vt));</span>
<span class="line-added">1075   return false;</span>
<span class="line-added">1076 }</span>
<span class="line-added">1077 </span>
1078 #if INCLUDE_JVMCI
1079 /**
1080  * For primitive types whose kind gets &quot;erased&quot; at runtime (shorts become stack ints),
1081  * we need to somehow be able to recover the actual kind to be able to write the correct
1082  * amount of bytes.
1083  * For that purpose, this method assumes that, for an entry spanning n bytes at index i,
1084  * the entries at index n + 1 to n + i are &#39;markers&#39;.
1085  * For example, if we were writing a short at index 4 of a byte array of size 8, the
1086  * expected form of the array would be:
1087  *
1088  * {b0, b1, b2, b3, INT, marker, b6, b7}
1089  *
1090  * Thus, in order to get back the size of the entry, we simply need to count the number
1091  * of marked entries
1092  *
1093  * @param virtualArray the virtualized byte array
1094  * @param i index of the virtual entry we are recovering
1095  * @return The number of bytes the entry spans
1096  */
1097 static int count_number_of_bytes_for_entry(ObjectValue *virtualArray, int i) {
</pre>
<hr />
<pre>
1230       default:
1231         ShouldNotReachHere();
1232     }
1233     index++;
1234   }
1235 }
1236 
1237 // restore fields of an eliminated object array
1238 void Deoptimization::reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj) {
1239   for (int i = 0; i &lt; sv-&gt;field_size(); i++) {
1240     StackValue* value = StackValue::create_stack_value(fr, reg_map, sv-&gt;field_at(i));
1241     assert(value-&gt;type() == T_OBJECT, &quot;object element expected&quot;);
1242     obj-&gt;obj_at_put(i, value-&gt;get_obj()());
1243   }
1244 }
1245 
1246 class ReassignedField {
1247 public:
1248   int _offset;
1249   BasicType _type;
<span class="line-added">1250   InstanceKlass* _klass;</span>
1251 public:
1252   ReassignedField() {
1253     _offset = 0;
1254     _type = T_ILLEGAL;
<span class="line-added">1255     _klass = NULL;</span>
1256   }
1257 };
1258 
1259 int compare(ReassignedField* left, ReassignedField* right) {
1260   return left-&gt;_offset - right-&gt;_offset;
1261 }
1262 
1263 // Restore fields of an eliminated instance object using the same field order
1264 // returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)
<span class="line-modified">1265 static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal, int base_offset, TRAPS) {</span>
<span class="line-added">1266 </span>
1267   GrowableArray&lt;ReassignedField&gt;* fields = new GrowableArray&lt;ReassignedField&gt;();
1268   InstanceKlass* ik = klass;
1269   while (ik != NULL) {
1270     for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
1271       if (!fs.access_flags().is_static() &amp;&amp; (!skip_internal || !fs.access_flags().is_internal())) {
1272         ReassignedField field;
1273         field._offset = fs.offset();
1274         field._type = Signature::basic_type(fs.signature());
<span class="line-added">1275         if (field._type == T_INLINE_TYPE) {</span>
<span class="line-added">1276           field._type = T_OBJECT;</span>
<span class="line-added">1277         }</span>
<span class="line-added">1278         if (fs.is_inlined()) {</span>
<span class="line-added">1279           // Resolve klass of flattened inline type field</span>
<span class="line-added">1280           Klass* vk = klass-&gt;get_inline_type_field_klass(fs.index());</span>
<span class="line-added">1281           field._klass = InlineKlass::cast(vk);</span>
<span class="line-added">1282           field._type = T_INLINE_TYPE;</span>
<span class="line-added">1283         }</span>
1284         fields-&gt;append(field);
1285       }
1286     }
1287     ik = ik-&gt;superklass();
1288   }
1289   fields-&gt;sort(compare);
1290   for (int i = 0; i &lt; fields-&gt;length(); i++) {
1291     intptr_t val;
1292     ScopeValue* scope_field = sv-&gt;field_at(svIndex);
1293     StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);
<span class="line-modified">1294     int offset = base_offset + fields-&gt;at(i)._offset;</span>
1295     BasicType type = fields-&gt;at(i)._type;
1296     switch (type) {
<span class="line-modified">1297       case T_OBJECT:</span>
<span class="line-added">1298       case T_ARRAY:</span>
1299         assert(value-&gt;type() == T_OBJECT, &quot;Agreement.&quot;);
1300         obj-&gt;obj_field_put(offset, value-&gt;get_obj()());
1301         break;
1302 
<span class="line-added">1303       case T_INLINE_TYPE: {</span>
<span class="line-added">1304         // Recursively re-assign flattened inline type fields</span>
<span class="line-added">1305         InstanceKlass* vk = fields-&gt;at(i)._klass;</span>
<span class="line-added">1306         assert(vk != NULL, &quot;must be resolved&quot;);</span>
<span class="line-added">1307         offset -= InlineKlass::cast(vk)-&gt;first_field_offset(); // Adjust offset to omit oop header</span>
<span class="line-added">1308         svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, skip_internal, offset, CHECK_0);</span>
<span class="line-added">1309         continue; // Continue because we don&#39;t need to increment svIndex</span>
<span class="line-added">1310       }</span>
<span class="line-added">1311 </span>
1312       // Have to cast to INT (32 bits) pointer to avoid little/big-endian problem.
1313       case T_INT: case T_FLOAT: { // 4 bytes.
1314         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1315         bool big_value = false;
1316         if (i+1 &lt; fields-&gt;length() &amp;&amp; fields-&gt;at(i+1)._type == T_INT) {
1317           if (scope_field-&gt;is_location()) {
1318             Location::Type type = ((LocationValue*) scope_field)-&gt;location().type();
1319             if (type == Location::dbl || type == Location::lng) {
1320               big_value = true;
1321             }
1322           }
1323           if (scope_field-&gt;is_constant_int()) {
1324             ScopeValue* next_scope_field = sv-&gt;field_at(svIndex + 1);
1325             if (next_scope_field-&gt;is_constant_long() || next_scope_field-&gt;is_constant_double()) {
1326               big_value = true;
1327             }
1328           }
1329         }
1330 
1331         if (big_value) {
</pre>
<hr />
<pre>
1367       case T_BYTE:
1368         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1369         val = value-&gt;get_int();
1370         obj-&gt;byte_field_put(offset, (jbyte)*((jint*)&amp;val));
1371         break;
1372 
1373       case T_BOOLEAN:
1374         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1375         val = value-&gt;get_int();
1376         obj-&gt;bool_field_put(offset, (jboolean)*((jint*)&amp;val));
1377         break;
1378 
1379       default:
1380         ShouldNotReachHere();
1381     }
1382     svIndex++;
1383   }
1384   return svIndex;
1385 }
1386 
<span class="line-added">1387 // restore fields of an eliminated inline type array</span>
<span class="line-added">1388 void Deoptimization::reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, TRAPS) {</span>
<span class="line-added">1389   InlineKlass* vk = vak-&gt;element_klass();</span>
<span class="line-added">1390   assert(vk-&gt;flatten_array(), &quot;should only be used for flattened inline type arrays&quot;);</span>
<span class="line-added">1391   // Adjust offset to omit oop header</span>
<span class="line-added">1392   int base_offset = arrayOopDesc::base_offset_in_bytes(T_INLINE_TYPE) - InlineKlass::cast(vk)-&gt;first_field_offset();</span>
<span class="line-added">1393   // Initialize all elements of the flattened inline type array</span>
<span class="line-added">1394   for (int i = 0; i &lt; sv-&gt;field_size(); i++) {</span>
<span class="line-added">1395     ScopeValue* val = sv-&gt;field_at(i);</span>
<span class="line-added">1396     int offset = base_offset + (i &lt;&lt; Klass::layout_helper_log2_element_size(vak-&gt;layout_helper()));</span>
<span class="line-added">1397     reassign_fields_by_klass(vk, fr, reg_map, val-&gt;as_ObjectValue(), 0, (oop)obj, false /* skip_internal */, offset, CHECK);</span>
<span class="line-added">1398   }</span>
<span class="line-added">1399 }</span>
<span class="line-added">1400 </span>
1401 // restore fields of all eliminated objects and arrays
<span class="line-modified">1402 void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures, bool skip_internal, TRAPS) {</span>
1403   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1404     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1405     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1406     Handle obj = sv-&gt;value();
1407     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);
1408     if (PrintDeoptimizationDetails) {
1409       tty-&gt;print_cr(&quot;reassign fields for object of type %s!&quot;, k-&gt;name()-&gt;as_C_string());
1410     }
1411     if (obj.is_null()) {
1412       continue;
1413     }
1414 #if INCLUDE_JVMCI || INCLUDE_AOT
1415     // Don&#39;t reassign fields of boxes that came from a cache. Caches may be in CDS.
1416     if (sv-&gt;is_auto_box() &amp;&amp; ((AutoBoxObjectValue*) sv)-&gt;is_cached()) {
1417       continue;
1418     }
1419 #endif // INCLUDE_JVMCI || INCLUDE_AOT
1420     if (k-&gt;is_instance_klass()) {
1421       InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">1422       reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal, 0, CHECK);</span>
<span class="line-added">1423     } else if (k-&gt;is_flatArray_klass()) {</span>
<span class="line-added">1424       FlatArrayKlass* vak = FlatArrayKlass::cast(k);</span>
<span class="line-added">1425       reassign_flat_array_elements(fr, reg_map, sv, (flatArrayOop) obj(), vak, CHECK);</span>
1426     } else if (k-&gt;is_typeArray_klass()) {
1427       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1428       reassign_type_array_elements(fr, reg_map, sv, (typeArrayOop) obj(), ak-&gt;element_type());
1429     } else if (k-&gt;is_objArray_klass()) {
1430       reassign_object_array_elements(fr, reg_map, sv, (objArrayOop) obj());
1431     }
1432   }
1433 }
1434 
1435 
1436 // relock objects for which synchronization was eliminated
1437 void Deoptimization::relock_objects(GrowableArray&lt;MonitorInfo*&gt;* monitors, JavaThread* thread, bool realloc_failures) {
1438   for (int i = 0; i &lt; monitors-&gt;length(); i++) {
1439     MonitorInfo* mon_info = monitors-&gt;at(i);
1440     if (mon_info-&gt;eliminated()) {
1441       assert(!mon_info-&gt;owner_is_scalar_replaced() || realloc_failures, &quot;reallocation was missed&quot;);
1442       if (!mon_info-&gt;owner_is_scalar_replaced()) {
1443         Handle obj(thread, mon_info-&gt;owner());
1444         markWord mark = obj-&gt;mark();
1445         if (UseBiasedLocking &amp;&amp; mark.has_bias_pattern()) {
</pre>
<hr />
<pre>
1448           // where the thread-local object is bias locked to the current thread.
1449           assert(mark.is_biased_anonymously() ||
1450                  mark.biased_locker() == thread, &quot;should be locked to current thread&quot;);
1451           // Reset mark word to unbiased prototype.
1452           markWord unbiased_prototype = markWord::prototype().set_age(mark.age());
1453           obj-&gt;set_mark(unbiased_prototype);
1454         }
1455         BasicLock* lock = mon_info-&gt;lock();
1456         ObjectSynchronizer::enter(obj, lock, thread);
1457         assert(mon_info-&gt;owner()-&gt;is_locked(), &quot;object must be locked now&quot;);
1458       }
1459     }
1460   }
1461 }
1462 
1463 
1464 #ifndef PRODUCT
1465 // print information about reallocated objects
1466 void Deoptimization::print_objects(GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures) {
1467   fieldDescriptor fd;

1468   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1469     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1470     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
<span class="line-modified">1471     print_object(k, sv-&gt;value(), realloc_failures);</span>
<span class="line-added">1472   }</span>
<span class="line-added">1473 }</span>
1474 
<span class="line-modified">1475 void Deoptimization::print_object(Klass* k, Handle obj, bool realloc_failures) {</span>
<span class="line-modified">1476   tty-&gt;print(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; of type &quot;, p2i(obj()));</span>
<span class="line-modified">1477   k-&gt;print_value();</span>
<span class="line-modified">1478   assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);</span>
<span class="line-modified">1479   if (obj.is_null()) {</span>
<span class="line-modified">1480     tty-&gt;print(&quot; allocation failed&quot;);</span>
<span class="line-modified">1481   } else {</span>
<span class="line-modified">1482     tty-&gt;print(&quot; allocated (%d bytes)&quot;, obj-&gt;size() * HeapWordSize);</span>
<span class="line-modified">1483   }</span>
<span class="line-added">1484   tty-&gt;cr();</span>
1485 
<span class="line-modified">1486   if (Verbose &amp;&amp; !obj.is_null()) {</span>
<span class="line-modified">1487     k-&gt;oop_print_on(obj(), tty);</span>

1488   }
1489 }
1490 #endif
1491 #endif // COMPILER2_OR_JVMCI
1492 
1493 vframeArray* Deoptimization::create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
1494   Events::log_deopt_message(thread, &quot;DEOPT PACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(fr.pc()), p2i(fr.sp()));
1495 
1496 #ifndef PRODUCT
1497   if (PrintDeoptimizationDetails) {
1498     ttyLocker ttyl;
1499     tty-&gt;print(&quot;DEOPT PACKING thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(thread));
1500     fr.print_on(tty);
1501     tty-&gt;print_cr(&quot;     Virtual frames (innermost first):&quot;);
1502     for (int index = 0; index &lt; chunk-&gt;length(); index++) {
1503       compiledVFrame* vf = chunk-&gt;at(index);
1504       tty-&gt;print(&quot;       %2d - &quot;, index);
1505       vf-&gt;print_value();
1506       int bci = chunk-&gt;at(index)-&gt;raw_bci();
1507       const char* code_name;
</pre>
<hr />
<pre>
1640 
1641     ttyLocker ttyl;
1642     xtty-&gt;begin_head(&quot;deoptimized thread=&#39;&quot; UINTX_FORMAT &quot;&#39; reason=&#39;%s&#39; pc=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;,(uintx)thread-&gt;osthread()-&gt;thread_id(), trap_reason_name(reason), p2i(fr.pc()));
1643     cm-&gt;log_identity(xtty);
1644     xtty-&gt;end_head();
1645     for (ScopeDesc* sd = cm-&gt;scope_desc_at(fr.pc()); ; sd = sd-&gt;sender()) {
1646       xtty-&gt;begin_elem(&quot;jvms bci=&#39;%d&#39;&quot;, sd-&gt;bci());
1647       xtty-&gt;method(sd-&gt;method());
1648       xtty-&gt;end_elem();
1649       if (sd-&gt;is_top())  break;
1650     }
1651     xtty-&gt;tail(&quot;deoptimized&quot;);
1652   }
1653 
1654   // Patch the compiled method so that when execution returns to it we will
1655   // deopt the execution state and return to the interpreter.
1656   fr.deoptimize(thread);
1657 }
1658 
1659 void Deoptimization::deoptimize(JavaThread* thread, frame fr, DeoptReason reason) {
<span class="line-modified">1660   // Deoptimize only if the frame comes from compiled code.</span>
1661   // Do not deoptimize the frame which is already patched
1662   // during the execution of the loops below.
1663   if (!fr.is_compiled_frame() || fr.is_deoptimized_frame()) {
1664     return;
1665   }
1666   ResourceMark rm;
1667   DeoptimizationMarker dm;
1668   deoptimize_single_frame(thread, fr, reason);
1669 }
1670 
1671 #if INCLUDE_JVMCI
1672 address Deoptimization::deoptimize_for_missing_exception_handler(CompiledMethod* cm) {
1673   // there is no exception handler for this pc =&gt; deoptimize
1674   cm-&gt;make_not_entrant();
1675 
1676   // Use Deoptimization::deoptimize for all of its side-effects:
1677   // gathering traps statistics, logging...
1678   // it also patches the return pc but we do not care about that
1679   // since we return a continuation to the deopt_blob below.
1680   JavaThread* thread = JavaThread::current();
</pre>
</td>
</tr>
</table>
<center><a href="arguments.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldDescriptor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>