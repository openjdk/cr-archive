<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/reflection.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/verifier.hpp&quot;
  33 #include &quot;classfile/vmSymbols.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/oopFactory.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
<a name="1" id="anc1"></a>
  39 #include &quot;oops/instanceKlass.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  44 #include &quot;prims/jvmtiExport.hpp&quot;
  45 #include &quot;runtime/arguments.hpp&quot;
  46 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  47 #include &quot;runtime/handles.inline.hpp&quot;
  48 #include &quot;runtime/javaCalls.hpp&quot;
  49 #include &quot;runtime/reflection.hpp&quot;
  50 #include &quot;runtime/reflectionUtils.hpp&quot;
  51 #include &quot;runtime/signature.hpp&quot;
  52 #include &quot;runtime/thread.inline.hpp&quot;
  53 #include &quot;runtime/vframe.inline.hpp&quot;
<a name="2" id="anc2"></a>
  54 
  55 static void trace_class_resolution(oop mirror) {
  56   if (mirror == NULL || java_lang_Class::is_primitive(mirror)) {
  57     return;
  58   }
  59   Klass* to_class = java_lang_Class::as_Klass(mirror);
  60   ResourceMark rm;
  61   int line_number = -1;
  62   const char * source_file = NULL;
  63   Klass* caller = NULL;
  64   JavaThread* jthread = JavaThread::current();
  65   if (jthread-&gt;has_last_Java_frame()) {
  66     vframeStream vfst(jthread);
  67     // skip over any frames belonging to java.lang.Class
  68     while (!vfst.at_end() &amp;&amp;
  69            vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class()) {
  70       vfst.next();
  71     }
  72     if (!vfst.at_end()) {
  73       // this frame is a likely suspect
  74       caller = vfst.method()-&gt;method_holder();
  75       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
  76       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
  77       if (s != NULL) {
  78         source_file = s-&gt;as_C_string();
  79       }
  80     }
  81   }
  82   if (caller != NULL) {
  83     const char * from = caller-&gt;external_name();
  84     const char * to = to_class-&gt;external_name();
  85     // print in a single call to reduce interleaving between threads
  86     if (source_file != NULL) {
  87       log_debug(class, resolve)(&quot;%s %s %s:%d (reflection)&quot;, from, to, source_file, line_number);
  88     } else {
  89       log_debug(class, resolve)(&quot;%s %s (reflection)&quot;, from, to);
  90     }
  91   }
  92 }
  93 
  94 
  95 oop Reflection::box(jvalue* value, BasicType type, TRAPS) {
  96   if (type == T_VOID) {
  97     return NULL;
  98   }
  99   if (is_reference_type(type)) {
 100     // regular objects are not boxed
 101     return (oop) value-&gt;l;
 102   }
 103   oop result = java_lang_boxing_object::create(type, value, CHECK_NULL);
 104   if (result == NULL) {
 105     THROW_(vmSymbols::java_lang_IllegalArgumentException(), result);
 106   }
 107   return result;
 108 }
 109 
 110 
 111 BasicType Reflection::unbox_for_primitive(oop box, jvalue* value, TRAPS) {
 112   if (box == NULL) {
 113     THROW_(vmSymbols::java_lang_IllegalArgumentException(), T_ILLEGAL);
 114   }
 115   return java_lang_boxing_object::get_value(box, value);
 116 }
 117 
 118 BasicType Reflection::unbox_for_regular_object(oop box, jvalue* value) {
 119   // Note:  box is really the unboxed oop.  It might even be a Short, etc.!
 120   value-&gt;l = cast_from_oop&lt;jobject&gt;(box);
 121   return T_OBJECT;
 122 }
 123 
 124 
 125 void Reflection::widen(jvalue* value, BasicType current_type, BasicType wide_type, TRAPS) {
 126   assert(wide_type != current_type, &quot;widen should not be called with identical types&quot;);
 127   switch (wide_type) {
 128     case T_BOOLEAN:
 129     case T_BYTE:
 130     case T_CHAR:
 131       break;  // fail
 132     case T_SHORT:
 133       switch (current_type) {
 134         case T_BYTE:
 135           value-&gt;s = (jshort) value-&gt;b;
 136           return;
 137         default:
 138           break;
 139       }
 140       break;  // fail
 141     case T_INT:
 142       switch (current_type) {
 143         case T_BYTE:
 144           value-&gt;i = (jint) value-&gt;b;
 145           return;
 146         case T_CHAR:
 147           value-&gt;i = (jint) value-&gt;c;
 148           return;
 149         case T_SHORT:
 150           value-&gt;i = (jint) value-&gt;s;
 151           return;
 152         default:
 153           break;
 154       }
 155       break;  // fail
 156     case T_LONG:
 157       switch (current_type) {
 158         case T_BYTE:
 159           value-&gt;j = (jlong) value-&gt;b;
 160           return;
 161         case T_CHAR:
 162           value-&gt;j = (jlong) value-&gt;c;
 163           return;
 164         case T_SHORT:
 165           value-&gt;j = (jlong) value-&gt;s;
 166           return;
 167         case T_INT:
 168           value-&gt;j = (jlong) value-&gt;i;
 169           return;
 170         default:
 171           break;
 172       }
 173       break;  // fail
 174     case T_FLOAT:
 175       switch (current_type) {
 176         case T_BYTE:
 177           value-&gt;f = (jfloat) value-&gt;b;
 178           return;
 179         case T_CHAR:
 180           value-&gt;f = (jfloat) value-&gt;c;
 181           return;
 182         case T_SHORT:
 183           value-&gt;f = (jfloat) value-&gt;s;
 184           return;
 185         case T_INT:
 186           value-&gt;f = (jfloat) value-&gt;i;
 187           return;
 188         case T_LONG:
 189           value-&gt;f = (jfloat) value-&gt;j;
 190           return;
 191         default:
 192           break;
 193       }
 194       break;  // fail
 195     case T_DOUBLE:
 196       switch (current_type) {
 197         case T_BYTE:
 198           value-&gt;d = (jdouble) value-&gt;b;
 199           return;
 200         case T_CHAR:
 201           value-&gt;d = (jdouble) value-&gt;c;
 202           return;
 203         case T_SHORT:
 204           value-&gt;d = (jdouble) value-&gt;s;
 205           return;
 206         case T_INT:
 207           value-&gt;d = (jdouble) value-&gt;i;
 208           return;
 209         case T_FLOAT:
 210           value-&gt;d = (jdouble) value-&gt;f;
 211           return;
 212         case T_LONG:
 213           value-&gt;d = (jdouble) value-&gt;j;
 214           return;
 215         default:
 216           break;
 217       }
 218       break;  // fail
 219     default:
 220       break;  // fail
 221   }
 222   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
 223 }
 224 
 225 
 226 BasicType Reflection::array_get(jvalue* value, arrayOop a, int index, TRAPS) {
 227   if (!a-&gt;is_within_bounds(index)) {
 228     THROW_(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), T_ILLEGAL);
 229   }
 230   if (a-&gt;is_objArray()) {
 231     value-&gt;l = cast_from_oop&lt;jobject&gt;(objArrayOop(a)-&gt;obj_at(index));
 232     return T_OBJECT;
 233   } else {
 234     assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
 235     BasicType type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 236     switch (type) {
 237       case T_BOOLEAN:
 238         value-&gt;z = typeArrayOop(a)-&gt;bool_at(index);
 239         break;
 240       case T_CHAR:
 241         value-&gt;c = typeArrayOop(a)-&gt;char_at(index);
 242         break;
 243       case T_FLOAT:
 244         value-&gt;f = typeArrayOop(a)-&gt;float_at(index);
 245         break;
 246       case T_DOUBLE:
 247         value-&gt;d = typeArrayOop(a)-&gt;double_at(index);
 248         break;
 249       case T_BYTE:
 250         value-&gt;b = typeArrayOop(a)-&gt;byte_at(index);
 251         break;
 252       case T_SHORT:
 253         value-&gt;s = typeArrayOop(a)-&gt;short_at(index);
 254         break;
 255       case T_INT:
 256         value-&gt;i = typeArrayOop(a)-&gt;int_at(index);
 257         break;
 258       case T_LONG:
 259         value-&gt;j = typeArrayOop(a)-&gt;long_at(index);
 260         break;
 261       default:
 262         return T_ILLEGAL;
 263     }
 264     return type;
 265   }
 266 }
 267 
 268 
 269 void Reflection::array_set(jvalue* value, arrayOop a, int index, BasicType value_type, TRAPS) {
 270   if (!a-&gt;is_within_bounds(index)) {
 271     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
 272   }
 273   if (a-&gt;is_objArray()) {
 274     if (value_type == T_OBJECT) {
 275       oop obj = (oop) value-&gt;l;
 276       if (obj != NULL) {
 277         Klass* element_klass = ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass();
 278         if (!obj-&gt;is_a(element_klass)) {
 279           THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;array element type mismatch&quot;);
 280         }
 281       }
 282       objArrayOop(a)-&gt;obj_at_put(index, obj);
 283     }
 284   } else {
 285     assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
 286     BasicType array_type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 287     if (array_type != value_type) {
 288       // The widen operation can potentially throw an exception, but cannot block,
 289       // so typeArrayOop a is safe if the call succeeds.
 290       widen(value, value_type, array_type, CHECK);
 291     }
 292     switch (array_type) {
 293       case T_BOOLEAN:
 294         typeArrayOop(a)-&gt;bool_at_put(index, value-&gt;z);
 295         break;
 296       case T_CHAR:
 297         typeArrayOop(a)-&gt;char_at_put(index, value-&gt;c);
 298         break;
 299       case T_FLOAT:
 300         typeArrayOop(a)-&gt;float_at_put(index, value-&gt;f);
 301         break;
 302       case T_DOUBLE:
 303         typeArrayOop(a)-&gt;double_at_put(index, value-&gt;d);
 304         break;
 305       case T_BYTE:
 306         typeArrayOop(a)-&gt;byte_at_put(index, value-&gt;b);
 307         break;
 308       case T_SHORT:
 309         typeArrayOop(a)-&gt;short_at_put(index, value-&gt;s);
 310         break;
 311       case T_INT:
 312         typeArrayOop(a)-&gt;int_at_put(index, value-&gt;i);
 313         break;
 314       case T_LONG:
 315         typeArrayOop(a)-&gt;long_at_put(index, value-&gt;j);
 316         break;
 317       default:
 318         THROW(vmSymbols::java_lang_IllegalArgumentException());
 319     }
 320   }
 321 }
 322 
 323 static Klass* basic_type_mirror_to_arrayklass(oop basic_type_mirror, TRAPS) {
 324   assert(java_lang_Class::is_primitive(basic_type_mirror), &quot;just checking&quot;);
 325   BasicType type = java_lang_Class::primitive_type(basic_type_mirror);
 326   if (type == T_VOID) {
 327     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 328   }
 329   else {
 330     return Universe::typeArrayKlassObj(type);
 331   }
 332 }
 333 
 334 arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
 335   if (element_mirror == NULL) {
 336     THROW_0(vmSymbols::java_lang_NullPointerException());
 337   }
 338   if (length &lt; 0) {
 339     THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
 340   }
 341   if (java_lang_Class::is_primitive(element_mirror)) {
 342     Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 343     return TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);
 344   } else {
 345     Klass* k = java_lang_Class::as_Klass(element_mirror);
 346     if (k-&gt;is_array_klass() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) {
 347       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 348     }
<a name="3" id="anc3"></a><span class="line-modified"> 349     return oopFactory::new_objArray(k, length, THREAD);</span>




 350   }
 351 }
 352 
 353 
 354 arrayOop Reflection::reflect_new_multi_array(oop element_mirror, typeArrayOop dim_array, TRAPS) {
 355   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
 356   assert(TypeArrayKlass::cast(dim_array-&gt;klass())-&gt;element_type() == T_INT, &quot;just checking&quot;);
 357 
 358   if (element_mirror == NULL) {
 359     THROW_0(vmSymbols::java_lang_NullPointerException());
 360   }
 361 
 362   int len = dim_array-&gt;length();
 363   if (len &lt;= 0 || len &gt; MAX_DIM) {
 364     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 365   }
 366 
 367   jint dimensions[MAX_DIM];   // C array copy of intArrayOop
 368   for (int i = 0; i &lt; len; i++) {
 369     int d = dim_array-&gt;int_at(i);
 370     if (d &lt; 0) {
 371       THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, d));
 372     }
 373     dimensions[i] = d;
 374   }
 375 
 376   Klass* klass;
 377   int dim = len;
 378   if (java_lang_Class::is_primitive(element_mirror)) {
 379     klass = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 380   } else {
 381     klass = java_lang_Class::as_Klass(element_mirror);
 382     if (klass-&gt;is_array_klass()) {
 383       int k_dim = ArrayKlass::cast(klass)-&gt;dimension();
 384       if (k_dim + len &gt; MAX_DIM) {
 385         THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 386       }
 387       dim += k_dim;
 388     }
 389   }
 390   klass = klass-&gt;array_klass(dim, CHECK_NULL);
 391   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(len, dimensions, CHECK_NULL);
 392   assert(obj-&gt;is_array(), &quot;just checking&quot;);
 393   return arrayOop(obj);
 394 }
 395 
 396 
 397 static bool under_unsafe_anonymous_host(const InstanceKlass* ik, const InstanceKlass* unsafe_anonymous_host) {
 398   DEBUG_ONLY(int inf_loop_check = 1000 * 1000 * 1000);
 399   for (;;) {
 400     const InstanceKlass* hc = ik-&gt;unsafe_anonymous_host();
 401     if (hc == NULL)        return false;
 402     if (hc == unsafe_anonymous_host)  return true;
 403     ik = hc;
 404 
 405     // There&#39;s no way to make a host class loop short of patching memory.
 406     // Therefore there cannot be a loop here unless there&#39;s another bug.
 407     // Still, let&#39;s check for it.
 408     assert(--inf_loop_check &gt; 0, &quot;no unsafe_anonymous_host loop&quot;);
 409   }
 410 }
 411 
 412 static bool can_relax_access_check_for(const Klass* accessor,
 413                                        const Klass* accessee,
 414                                        bool classloader_only) {
 415 
 416   const InstanceKlass* accessor_ik = InstanceKlass::cast(accessor);
 417   const InstanceKlass* accessee_ik = InstanceKlass::cast(accessee);
 418 
 419   // If either is on the other&#39;s unsafe_anonymous_host chain, access is OK,
 420   // because one is inside the other.
 421   if (under_unsafe_anonymous_host(accessor_ik, accessee_ik) ||
 422     under_unsafe_anonymous_host(accessee_ik, accessor_ik))
 423     return true;
 424 
 425   if (RelaxAccessControlCheck &amp;&amp;
 426     accessor_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION &amp;&amp;
 427     accessee_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION) {
 428     return classloader_only &amp;&amp;
 429       Verifier::relax_access_for(accessor_ik-&gt;class_loader()) &amp;&amp;
 430       accessor_ik-&gt;protection_domain() == accessee_ik-&gt;protection_domain() &amp;&amp;
 431       accessor_ik-&gt;class_loader() == accessee_ik-&gt;class_loader();
 432   }
 433 
 434   return false;
 435 }
 436 
 437 /*
 438     Type Accessibility check for public types: Callee Type T is accessible to Caller Type S if:
 439 
 440                         Callee T in             Callee T in package PT,
 441                         unnamed module          runtime module MT
 442  ------------------------------------------------------------------------------------------------
 443 
 444  Caller S in package     If MS is loose: YES      If same classloader/package (PS == PT): YES
 445  PS, runtime module MS   If MS can read T&#39;s       If same runtime module: (MS == MT): YES
 446                          unnamed module: YES
 447                                                   Else if (MS can read MT (establish readability) &amp;&amp;
 448                                                     ((MT exports PT to MS or to all modules) ||
 449                                                      (MT is open))): YES
 450 
 451  ------------------------------------------------------------------------------------------------
 452  Caller S in unnamed         YES                  Readability exists because unnamed module
 453  module UM                                            &quot;reads&quot; all modules
 454                                                   if (MT exports PT to UM or to all modules): YES
 455 
 456  ------------------------------------------------------------------------------------------------
 457 
 458  Note: a loose module is a module that can read all current and future unnamed modules.
 459 */
 460 Reflection::VerifyClassAccessResults Reflection::verify_class_access(
 461   const Klass* current_class, const InstanceKlass* new_class, bool classloader_only) {
 462 
 463   // Verify that current_class can access new_class.  If the classloader_only
 464   // flag is set, we automatically allow any accesses in which current_class
 465   // doesn&#39;t have a classloader.
 466   if ((current_class == NULL) ||
 467       (current_class == new_class) ||
 468       is_same_class_package(current_class, new_class)) {
 469     return ACCESS_OK;
 470   }
 471   // Allow all accesses from jdk/internal/reflect/MagicAccessorImpl subclasses to
 472   // succeed trivially.
 473   if (SystemDictionary::reflect_MagicAccessorImpl_klass_is_loaded() &amp;&amp;
 474       current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 475     return ACCESS_OK;
 476   }
 477 
 478   // module boundaries
 479   if (new_class-&gt;is_public()) {
 480     // Ignore modules for DumpSharedSpaces because we do not have any package
 481     // or module information for modules other than java.base.
 482     if (DumpSharedSpaces) {
 483       return ACCESS_OK;
 484     }
 485 
 486     // Find the module entry for current_class, the accessor
 487     ModuleEntry* module_from = current_class-&gt;module();
 488     // Find the module entry for new_class, the accessee
 489     ModuleEntry* module_to = new_class-&gt;module();
 490 
 491     // both in same (possibly unnamed) module
 492     if (module_from == module_to) {
 493       return ACCESS_OK;
 494     }
 495 
 496     // Acceptable access to a type in an unnamed module. Note that since
 497     // unnamed modules can read all unnamed modules, this also handles the
 498     // case where module_from is also unnamed but in a different class loader.
 499     if (!module_to-&gt;is_named() &amp;&amp;
 500         (module_from-&gt;can_read_all_unnamed() || module_from-&gt;can_read(module_to))) {
 501       return ACCESS_OK;
 502     }
 503 
 504     // Establish readability, check if module_from is allowed to read module_to.
 505     if (!module_from-&gt;can_read(module_to)) {
 506       return MODULE_NOT_READABLE;
 507     }
 508 
 509     // Access is allowed if module_to is open, i.e. all its packages are unqualifiedly exported
 510     if (module_to-&gt;is_open()) {
 511       return ACCESS_OK;
 512     }
 513 
 514     PackageEntry* package_to = new_class-&gt;package();
 515     assert(package_to != NULL, &quot;can not obtain new_class&#39; package&quot;);
 516 
 517     {
 518       MutexLocker m1(Module_lock);
 519 
 520       // Once readability is established, if module_to exports T unqualifiedly,
 521       // (to all modules), than whether module_from is in the unnamed module
 522       // or not does not matter, access is allowed.
 523       if (package_to-&gt;is_unqual_exported()) {
 524         return ACCESS_OK;
 525       }
 526 
 527       // Access is allowed if both 1 &amp; 2 hold:
 528       //   1. Readability, module_from can read module_to (established above).
 529       //   2. Either module_to exports T to module_from qualifiedly.
 530       //      or
 531       //      module_to exports T to all unnamed modules and module_from is unnamed.
 532       //      or
 533       //      module_to exports T unqualifiedly to all modules (checked above).
 534       if (!package_to-&gt;is_qexported_to(module_from)) {
 535         return TYPE_NOT_EXPORTED;
 536       }
 537     }
 538     return ACCESS_OK;
 539   }
 540 
 541   if (can_relax_access_check_for(current_class, new_class, classloader_only)) {
 542     return ACCESS_OK;
 543   }
 544   return OTHER_PROBLEM;
 545 }
 546 
 547 // Return an error message specific to the specified Klass*&#39;s and result.
 548 // This function must be called from within a block containing a ResourceMark.
 549 char* Reflection::verify_class_access_msg(const Klass* current_class,
 550                                           const InstanceKlass* new_class,
 551                                           const VerifyClassAccessResults result) {
 552   assert(result != ACCESS_OK, &quot;must be failure result&quot;);
 553   char * msg = NULL;
 554   if (result != OTHER_PROBLEM &amp;&amp; new_class != NULL &amp;&amp; current_class != NULL) {
 555     // Find the module entry for current_class, the accessor
 556     ModuleEntry* module_from = current_class-&gt;module();
 557     const char * module_from_name = module_from-&gt;is_named() ? module_from-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
 558     const char * current_class_name = current_class-&gt;external_name();
 559 
 560     // Find the module entry for new_class, the accessee
 561     ModuleEntry* module_to = NULL;
 562     module_to = new_class-&gt;module();
 563     const char * module_to_name = module_to-&gt;is_named() ? module_to-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
 564     const char * new_class_name = new_class-&gt;external_name();
 565 
 566     if (result == MODULE_NOT_READABLE) {
 567       assert(module_from-&gt;is_named(), &quot;Unnamed modules can read all modules&quot;);
 568       if (module_to-&gt;is_named()) {
 569         size_t len = 100 + strlen(current_class_name) + 2*strlen(module_from_name) +
 570           strlen(new_class_name) + 2*strlen(module_to_name);
 571         msg = NEW_RESOURCE_ARRAY(char, len);
 572         jio_snprintf(msg, len - 1,
 573           &quot;class %s (in module %s) cannot access class %s (in module %s) because module %s does not read module %s&quot;,
 574           current_class_name, module_from_name, new_class_name,
 575           module_to_name, module_from_name, module_to_name);
 576       } else {
 577         oop jlm = module_to-&gt;module();
 578         assert(jlm != NULL, &quot;Null jlm in module_to ModuleEntry&quot;);
 579         intptr_t identity_hash = jlm-&gt;identity_hash();
 580         size_t len = 160 + strlen(current_class_name) + 2*strlen(module_from_name) +
 581           strlen(new_class_name) + 2*sizeof(uintx);
 582         msg = NEW_RESOURCE_ARRAY(char, len);
 583         jio_snprintf(msg, len - 1,
 584           &quot;class %s (in module %s) cannot access class %s (in unnamed module @&quot; SIZE_FORMAT_HEX &quot;) because module %s does not read unnamed module @&quot; SIZE_FORMAT_HEX,
 585           current_class_name, module_from_name, new_class_name, uintx(identity_hash),
 586           module_from_name, uintx(identity_hash));
 587       }
 588 
 589     } else if (result == TYPE_NOT_EXPORTED) {
 590       assert(new_class-&gt;package() != NULL,
 591              &quot;Unnamed packages are always exported&quot;);
 592       const char * package_name =
 593         new_class-&gt;package()-&gt;name()-&gt;as_klass_external_name();
 594       assert(module_to-&gt;is_named(), &quot;Unnamed modules export all packages&quot;);
 595       if (module_from-&gt;is_named()) {
 596         size_t len = 118 + strlen(current_class_name) + 2*strlen(module_from_name) +
 597           strlen(new_class_name) + 2*strlen(module_to_name) + strlen(package_name);
 598         msg = NEW_RESOURCE_ARRAY(char, len);
 599         jio_snprintf(msg, len - 1,
 600           &quot;class %s (in module %s) cannot access class %s (in module %s) because module %s does not export %s to module %s&quot;,
 601           current_class_name, module_from_name, new_class_name,
 602           module_to_name, module_to_name, package_name, module_from_name);
 603       } else {
 604         oop jlm = module_from-&gt;module();
 605         assert(jlm != NULL, &quot;Null jlm in module_from ModuleEntry&quot;);
 606         intptr_t identity_hash = jlm-&gt;identity_hash();
 607         size_t len = 170 + strlen(current_class_name) + strlen(new_class_name) +
 608           2*strlen(module_to_name) + strlen(package_name) + 2*sizeof(uintx);
 609         msg = NEW_RESOURCE_ARRAY(char, len);
 610         jio_snprintf(msg, len - 1,
 611           &quot;class %s (in unnamed module @&quot; SIZE_FORMAT_HEX &quot;) cannot access class %s (in module %s) because module %s does not export %s to unnamed module @&quot; SIZE_FORMAT_HEX,
 612           current_class_name, uintx(identity_hash), new_class_name, module_to_name,
 613           module_to_name, package_name, uintx(identity_hash));
 614       }
 615     } else {
 616         ShouldNotReachHere();
 617     }
 618   }  // result != OTHER_PROBLEM...
 619   return msg;
 620 }
 621 
 622 bool Reflection::verify_member_access(const Klass* current_class,
 623                                       const Klass* resolved_class,
 624                                       const Klass* member_class,
 625                                       AccessFlags access,
 626                                       bool classloader_only,
 627                                       bool protected_restriction,
 628                                       TRAPS) {
 629   // Verify that current_class can access a member of member_class, where that
 630   // field&#39;s access bits are &quot;access&quot;.  We assume that we&#39;ve already verified
 631   // that current_class can access member_class.
 632   //
 633   // If the classloader_only flag is set, we automatically allow any accesses
 634   // in which current_class doesn&#39;t have a classloader.
 635   //
 636   // &quot;resolved_class&quot; is the runtime type of &quot;member_class&quot;. Sometimes we don&#39;t
 637   // need this distinction (e.g. if all we have is the runtime type, or during
 638   // class file parsing when we only care about the static type); in that case
 639   // callers should ensure that resolved_class == member_class.
 640   //
 641   if ((current_class == NULL) ||
 642       (current_class == member_class) ||
 643       access.is_public()) {
 644     return true;
 645   }
 646 
 647   const Klass* host_class = current_class;
 648   if (current_class-&gt;is_instance_klass() &amp;&amp;
 649       InstanceKlass::cast(current_class)-&gt;is_unsafe_anonymous()) {
 650     host_class = InstanceKlass::cast(current_class)-&gt;unsafe_anonymous_host();
 651     assert(host_class != NULL, &quot;Unsafe anonymous class has null host class&quot;);
 652     assert(!(host_class-&gt;is_instance_klass() &amp;&amp;
 653            InstanceKlass::cast(host_class)-&gt;is_unsafe_anonymous()),
 654            &quot;unsafe_anonymous_host should not be unsafe anonymous itself&quot;);
 655   }
 656   if (host_class == member_class) {
 657     return true;
 658   }
 659 
 660   if (access.is_protected()) {
 661     if (!protected_restriction) {
 662       // See if current_class (or outermost host class) is a subclass of member_class
 663       // An interface may not access protected members of j.l.Object
 664       if (!host_class-&gt;is_interface() &amp;&amp; host_class-&gt;is_subclass_of(member_class)) {
 665         if (access.is_static() || // static fields are ok, see 6622385
 666             current_class == resolved_class ||
 667             member_class == resolved_class ||
 668             host_class-&gt;is_subclass_of(resolved_class) ||
 669             resolved_class-&gt;is_subclass_of(host_class)) {
 670           return true;
 671         }
 672       }
 673     }
 674   }
 675 
 676   // package access
 677   if (!access.is_private() &amp;&amp; is_same_class_package(current_class, member_class)) {
 678     return true;
 679   }
 680 
 681   // private access between different classes needs a nestmate check, but
 682   // not for unsafe anonymous classes - so check host_class
 683   if (access.is_private() &amp;&amp; host_class == current_class) {
 684     if (current_class-&gt;is_instance_klass() &amp;&amp; member_class-&gt;is_instance_klass() ) {
 685       InstanceKlass* cur_ik = const_cast&lt;InstanceKlass*&gt;(InstanceKlass::cast(current_class));
 686       InstanceKlass* field_ik = const_cast&lt;InstanceKlass*&gt;(InstanceKlass::cast(member_class));
 687       // Nestmate access checks may require resolution and validation of the nest-host.
 688       // It is up to the caller to check for pending exceptions and handle appropriately.
 689       bool access = cur_ik-&gt;has_nestmate_access_to(field_ik, CHECK_false);
 690       if (access) {
 691         guarantee(resolved_class-&gt;is_subclass_of(member_class), &quot;must be!&quot;);
 692         return true;
 693       }
 694     }
 695   }
 696 
 697   // Allow all accesses from jdk/internal/reflect/MagicAccessorImpl subclasses to
 698   // succeed trivially.
 699   if (current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 700     return true;
 701   }
 702 
 703   // Check for special relaxations
 704   return can_relax_access_check_for(current_class, member_class, classloader_only);
 705 }
 706 
 707 bool Reflection::is_same_class_package(const Klass* class1, const Klass* class2) {
 708   return InstanceKlass::cast(class1)-&gt;is_same_class_package(class2);
 709 }
 710 
 711 // Checks that the &#39;outer&#39; klass has declared &#39;inner&#39; as being an inner klass. If not,
 712 // throw an incompatible class change exception
 713 // If inner_is_member, require the inner to be a member of the outer.
 714 // If !inner_is_member, require the inner to be hidden or unsafe anonymous (non-members).
 715 // Caller is responsible for figuring out in advance which case must be true.
 716 void Reflection::check_for_inner_class(const InstanceKlass* outer, const InstanceKlass* inner,
 717                                        bool inner_is_member, TRAPS) {
 718   InnerClassesIterator iter(outer);
 719   constantPoolHandle cp   (THREAD, outer-&gt;constants());
 720   for (; !iter.done(); iter.next()) {
 721     int ioff = iter.inner_class_info_index();
 722     int ooff = iter.outer_class_info_index();
 723 
 724     if (inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff != 0) {
 725       if (cp-&gt;klass_name_at_matches(outer, ooff) &amp;&amp;
 726           cp-&gt;klass_name_at_matches(inner, ioff)) {
 727         Klass* o = cp-&gt;klass_at(ooff, CHECK);
 728         if (o == outer) {
 729           Klass* i = cp-&gt;klass_at(ioff, CHECK);
 730           if (i == inner) {
 731             return;
 732           }
 733         }
 734       }
 735     }
 736 
 737     if (!inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff == 0 &amp;&amp;
 738         cp-&gt;klass_name_at_matches(inner, ioff)) {
 739       Klass* i = cp-&gt;klass_at(ioff, CHECK);
 740       if (i == inner) {
 741         return;
 742       }
 743     }
 744   }
 745 
 746   // &#39;inner&#39; not declared as an inner klass in outer
 747   ResourceMark rm(THREAD);
 748   Exceptions::fthrow(
 749     THREAD_AND_LOCATION,
 750     vmSymbols::java_lang_IncompatibleClassChangeError(),
 751     &quot;%s and %s disagree on InnerClasses attribute&quot;,
 752     outer-&gt;external_name(),
 753     inner-&gt;external_name()
 754   );
 755 }
 756 
 757 static objArrayHandle get_parameter_types(const methodHandle&amp; method,
 758                                           int parameter_count,
 759                                           oop* return_type,
 760                                           TRAPS) {
 761   // Allocate array holding parameter types (java.lang.Class instances)
 762   objArrayOop m = oopFactory::new_objArray(SystemDictionary::Class_klass(), parameter_count, CHECK_(objArrayHandle()));
 763   objArrayHandle mirrors(THREAD, m);
 764   int index = 0;
 765   // Collect parameter types
 766   ResourceMark rm(THREAD);
 767   for (ResolvingSignatureStream ss(method()); !ss.is_done(); ss.next()) {
 768     oop mirror = ss.as_java_mirror(SignatureStream::NCDFError, CHECK_(objArrayHandle()));
 769     if (log_is_enabled(Debug, class, resolve)) {
 770       trace_class_resolution(mirror);
 771     }
 772     if (!ss.at_return_type()) {
 773       mirrors-&gt;obj_at_put(index++, mirror);
 774     } else if (return_type != NULL) {
 775       // Collect return type as well
 776       assert(ss.at_return_type(), &quot;return type should be present&quot;);
 777       *return_type = mirror;
 778     }
 779   }
 780   assert(index == parameter_count, &quot;invalid parameter count&quot;);
 781   return mirrors;
 782 }
 783 
 784 static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
 785   return method-&gt;resolved_checked_exceptions(THREAD);
 786 }
 787 
 788 static Handle new_type(Symbol* signature, Klass* k, TRAPS) {
 789   ResolvingSignatureStream ss(signature, k, false);
 790   oop nt = ss.as_java_mirror(SignatureStream::NCDFError, CHECK_NH);
<a name="4" id="anc4"></a><span class="line-removed"> 791   if (log_is_enabled(Debug, class, resolve)) {</span>
<span class="line-removed"> 792     trace_class_resolution(nt);</span>
<span class="line-removed"> 793   }</span>
 794   return Handle(THREAD, nt);
 795 }
 796 
 797 
 798 oop Reflection::new_method(const methodHandle&amp; method, bool for_constant_pool_access, TRAPS) {
 799   // Allow sun.reflect.ConstantPool to refer to &lt;clinit&gt; methods as java.lang.reflect.Methods.
<a name="5" id="anc5"></a><span class="line-modified"> 800   assert(!method()-&gt;is_initializer() ||</span>
<span class="line-removed"> 801          (for_constant_pool_access &amp;&amp; method()-&gt;is_static()),</span>
 802          &quot;should call new_constructor instead&quot;);
 803   InstanceKlass* holder = method-&gt;method_holder();
 804   int slot = method-&gt;method_idnum();
 805 
 806   Symbol*  signature  = method-&gt;signature();
 807   int parameter_count = ArgumentCount(signature).size();
 808   oop return_type_oop = NULL;
 809   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, &amp;return_type_oop, CHECK_NULL);
 810   if (parameter_types.is_null() || return_type_oop == NULL) return NULL;
 811 
 812   Handle return_type(THREAD, return_type_oop);
 813 
 814   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 815 
 816   if (exception_types.is_null()) return NULL;
 817 
 818   Symbol*  method_name = method-&gt;name();
 819   oop name_oop = StringTable::intern(method_name, CHECK_NULL);
 820   Handle name = Handle(THREAD, name_oop);
 821   if (name == NULL) return NULL;
 822 
 823   const int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 824 
 825   Handle mh = java_lang_reflect_Method::create(CHECK_NULL);
 826 
 827   java_lang_reflect_Method::set_clazz(mh(), holder-&gt;java_mirror());
 828   java_lang_reflect_Method::set_slot(mh(), slot);
 829   java_lang_reflect_Method::set_name(mh(), name());
 830   java_lang_reflect_Method::set_return_type(mh(), return_type());
 831   java_lang_reflect_Method::set_parameter_types(mh(), parameter_types());
 832   java_lang_reflect_Method::set_exception_types(mh(), exception_types());
 833   java_lang_reflect_Method::set_modifiers(mh(), modifiers);
 834   java_lang_reflect_Method::set_override(mh(), false);
 835   if (method-&gt;generic_signature() != NULL) {
 836     Symbol*  gs = method-&gt;generic_signature();
 837     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 838     java_lang_reflect_Method::set_signature(mh(), sig());
 839   }
 840   typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 841   java_lang_reflect_Method::set_annotations(mh(), an_oop);
 842   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 843   java_lang_reflect_Method::set_parameter_annotations(mh(), an_oop);
 844   an_oop = Annotations::make_java_array(method-&gt;annotation_default(), CHECK_NULL);
 845   java_lang_reflect_Method::set_annotation_default(mh(), an_oop);
 846   return mh();
 847 }
 848 
 849 
 850 oop Reflection::new_constructor(const methodHandle&amp; method, TRAPS) {
<a name="6" id="anc6"></a><span class="line-modified"> 851   assert(method()-&gt;is_initializer(), &quot;should call new_method instead&quot;);</span>


 852 
 853   InstanceKlass* holder = method-&gt;method_holder();
 854   int slot = method-&gt;method_idnum();
 855 
 856   Symbol*  signature  = method-&gt;signature();
 857   int parameter_count = ArgumentCount(signature).size();
 858   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, NULL, CHECK_NULL);
 859   if (parameter_types.is_null()) return NULL;
 860 
 861   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 862   if (exception_types.is_null()) return NULL;
 863 
 864   const int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 865 
 866   Handle ch = java_lang_reflect_Constructor::create(CHECK_NULL);
 867 
 868   java_lang_reflect_Constructor::set_clazz(ch(), holder-&gt;java_mirror());
 869   java_lang_reflect_Constructor::set_slot(ch(), slot);
 870   java_lang_reflect_Constructor::set_parameter_types(ch(), parameter_types());
 871   java_lang_reflect_Constructor::set_exception_types(ch(), exception_types());
 872   java_lang_reflect_Constructor::set_modifiers(ch(), modifiers);
 873   java_lang_reflect_Constructor::set_override(ch(), false);
 874   if (method-&gt;generic_signature() != NULL) {
 875     Symbol*  gs = method-&gt;generic_signature();
 876     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 877     java_lang_reflect_Constructor::set_signature(ch(), sig());
 878   }
 879   typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 880   java_lang_reflect_Constructor::set_annotations(ch(), an_oop);
 881   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 882   java_lang_reflect_Constructor::set_parameter_annotations(ch(), an_oop);
 883   return ch();
 884 }
 885 
 886 
 887 oop Reflection::new_field(fieldDescriptor* fd, TRAPS) {
 888   Symbol*  field_name = fd-&gt;name();
 889   oop name_oop = StringTable::intern(field_name, CHECK_NULL);
 890   Handle name = Handle(THREAD, name_oop);
 891   Symbol*  signature  = fd-&gt;signature();
 892   InstanceKlass* holder = fd-&gt;field_holder();
 893   Handle type = new_type(signature, holder, CHECK_NULL);
 894   Handle rh  = java_lang_reflect_Field::create(CHECK_NULL);
 895 
 896   java_lang_reflect_Field::set_clazz(rh(), fd-&gt;field_holder()-&gt;java_mirror());
 897   java_lang_reflect_Field::set_slot(rh(), fd-&gt;index());
 898   java_lang_reflect_Field::set_name(rh(), name());
 899   java_lang_reflect_Field::set_type(rh(), type());
 900   if (fd-&gt;is_trusted_final()) {
 901     java_lang_reflect_Field::set_trusted_final(rh());
 902   }
 903   // Note the ACC_ANNOTATION bit, which is a per-class access flag, is never set here.
<a name="7" id="anc7"></a><span class="line-modified"> 904   java_lang_reflect_Field::set_modifiers(rh(), fd-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS);</span>




 905   java_lang_reflect_Field::set_override(rh(), false);
 906   if (fd-&gt;has_generic_signature()) {
 907     Symbol*  gs = fd-&gt;generic_signature();
 908     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 909     java_lang_reflect_Field::set_signature(rh(), sig());
 910   }
 911   typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;annotations(), CHECK_NULL);
 912   java_lang_reflect_Field::set_annotations(rh(), an_oop);
 913   return rh();
 914 }
 915 
 916 oop Reflection::new_parameter(Handle method, int index, Symbol* sym,
 917                               int flags, TRAPS) {
 918 
 919   Handle rh = java_lang_reflect_Parameter::create(CHECK_NULL);
 920 
 921   if(NULL != sym) {
 922     Handle name = java_lang_String::create_from_symbol(sym, CHECK_NULL);
 923     java_lang_reflect_Parameter::set_name(rh(), name());
 924   } else {
 925     java_lang_reflect_Parameter::set_name(rh(), NULL);
 926   }
 927 
 928   java_lang_reflect_Parameter::set_modifiers(rh(), flags);
 929   java_lang_reflect_Parameter::set_executable(rh(), method());
 930   java_lang_reflect_Parameter::set_index(rh(), index);
 931   return rh();
 932 }
 933 
 934 
 935 static methodHandle resolve_interface_call(InstanceKlass* klass,
 936                                            const methodHandle&amp; method,
 937                                            Klass* recv_klass,
 938                                            Handle receiver,
 939                                            TRAPS) {
 940 
 941   assert(!method.is_null() , &quot;method should not be null&quot;);
 942 
 943   CallInfo info;
 944   Symbol*  signature  = method-&gt;signature();
 945   Symbol*  name       = method-&gt;name();
 946   LinkResolver::resolve_interface_call(info, receiver, recv_klass,
 947                                        LinkInfo(klass, name, signature),
 948                                        true,
 949                                        CHECK_(methodHandle()));
 950   return methodHandle(THREAD, info.selected_method());
 951 }
 952 
 953 // Conversion
 954 static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {
 955   assert(java_lang_Class::is_primitive(basic_type_mirror),
 956     &quot;just checking&quot;);
 957   return java_lang_Class::primitive_type(basic_type_mirror);
 958 }
 959 
 960 // Narrowing of basic types. Used to create correct jvalues for
 961 // boolean, byte, char and short return return values from interpreter
 962 // which are returned as ints. Throws IllegalArgumentException.
 963 static void narrow(jvalue* value, BasicType narrow_type, TRAPS) {
 964   switch (narrow_type) {
 965   case T_BOOLEAN:
 966     value-&gt;z = (jboolean) (value-&gt;i &amp; 1);
 967     return;
 968   case T_BYTE:
 969     value-&gt;b = (jbyte)value-&gt;i;
 970     return;
 971   case T_CHAR:
 972     value-&gt;c = (jchar)value-&gt;i;
 973     return;
 974   case T_SHORT:
 975     value-&gt;s = (jshort)value-&gt;i;
 976     return;
 977   default:
 978     break; // fail
 979   }
 980   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
 981 }
 982 
 983 
 984 // Method call (shared by invoke_method and invoke_constructor)
 985 static oop invoke(InstanceKlass* klass,
 986                   const methodHandle&amp; reflected_method,
 987                   Handle receiver,
 988                   bool override,
 989                   objArrayHandle ptypes,
 990                   BasicType rtype,
 991                   objArrayHandle args,
 992                   bool is_method_invoke,
 993                   TRAPS) {
 994 
 995   ResourceMark rm(THREAD);
 996 
 997   methodHandle method;      // actual method to invoke
 998   Klass* target_klass;      // target klass, receiver&#39;s klass for non-static
 999 
1000   // Ensure klass is initialized
1001   klass-&gt;initialize(CHECK_NULL);
1002 
1003   bool is_static = reflected_method-&gt;is_static();
1004   if (is_static) {
1005     // ignore receiver argument
1006     method = reflected_method;
1007     target_klass = klass;
1008   } else {
1009     // check for null receiver
1010     if (receiver.is_null()) {
1011       THROW_0(vmSymbols::java_lang_NullPointerException());
1012     }
1013     // Check class of receiver against class declaring method
1014     if (!receiver-&gt;is_a(klass)) {
1015       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;object is not an instance of declaring class&quot;);
1016     }
1017     // target klass is receiver&#39;s klass
1018     target_klass = receiver-&gt;klass();
1019     // no need to resolve if method is private or &lt;init&gt;
1020     if (reflected_method-&gt;is_private() || reflected_method-&gt;name() == vmSymbols::object_initializer_name()) {
1021       method = reflected_method;
1022     } else {
1023       // resolve based on the receiver
1024       if (reflected_method-&gt;method_holder()-&gt;is_interface()) {
1025         // resolve interface call
1026         //
1027         // Match resolution errors with those thrown due to reflection inlining
1028         // Linktime resolution &amp; IllegalAccessCheck already done by Class.getMethod()
1029         method = resolve_interface_call(klass, reflected_method, target_klass, receiver, THREAD);
1030         if (HAS_PENDING_EXCEPTION) {
1031           // Method resolution threw an exception; wrap it in an InvocationTargetException
1032           oop resolution_exception = PENDING_EXCEPTION;
1033           CLEAR_PENDING_EXCEPTION;
1034           // JVMTI has already reported the pending exception
1035           // JVMTI internal flag reset is needed in order to report InvocationTargetException
1036           if (THREAD-&gt;is_Java_thread()) {
1037             JvmtiExport::clear_detected_exception((JavaThread*)THREAD);
1038           }
1039           JavaCallArguments args(Handle(THREAD, resolution_exception));
1040           THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1041                       vmSymbols::throwable_void_signature(),
1042                       &amp;args);
1043         }
1044       }  else {
1045         // if the method can be overridden, we resolve using the vtable index.
1046         assert(!reflected_method-&gt;has_itable_index(), &quot;&quot;);
1047         int index = reflected_method-&gt;vtable_index();
1048         method = reflected_method;
1049         if (index != Method::nonvirtual_vtable_index) {
1050           method = methodHandle(THREAD, target_klass-&gt;method_at_vtable(index));
1051         }
1052         if (!method.is_null()) {
1053           // Check for abstract methods as well
1054           if (method-&gt;is_abstract()) {
1055             // new default: 6531596
1056             ResourceMark rm(THREAD);
1057             stringStream ss;
1058             ss.print(&quot;&#39;&quot;);
1059             Method::print_external_name(&amp;ss, target_klass, method-&gt;name(), method-&gt;signature());
1060             ss.print(&quot;&#39;&quot;);
1061             Handle h_origexception = Exceptions::new_exception(THREAD,
1062               vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1063             JavaCallArguments args(h_origexception);
1064             THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1065               vmSymbols::throwable_void_signature(),
1066               &amp;args);
1067           }
1068         }
1069       }
1070     }
1071   }
1072 
1073   // I believe this is a ShouldNotGetHere case which requires
1074   // an internal vtable bug. If you ever get this please let Karen know.
1075   if (method.is_null()) {
1076     ResourceMark rm(THREAD);
1077     stringStream ss;
1078     ss.print(&quot;&#39;&quot;);
1079     Method::print_external_name(&amp;ss, klass,
1080                                      reflected_method-&gt;name(),
1081                                      reflected_method-&gt;signature());
1082     ss.print(&quot;&#39;&quot;);
1083     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), ss.as_string());
1084   }
1085 
1086   assert(ptypes-&gt;is_objArray(), &quot;just checking&quot;);
1087   int args_len = args.is_null() ? 0 : args-&gt;length();
1088   // Check number of arguments
1089   if (ptypes-&gt;length() != args_len) {
1090     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1091                 &quot;wrong number of arguments&quot;);
1092   }
1093 
1094   // Create object to contain parameters for the JavaCall
1095   JavaCallArguments java_args(method-&gt;size_of_parameters());
1096 
1097   if (!is_static) {
1098     java_args.push_oop(receiver);
1099   }
1100 
1101   for (int i = 0; i &lt; args_len; i++) {
1102     oop type_mirror = ptypes-&gt;obj_at(i);
1103     oop arg = args-&gt;obj_at(i);
1104     if (java_lang_Class::is_primitive(type_mirror)) {
1105       jvalue value;
1106       BasicType ptype = basic_type_mirror_to_basic_type(type_mirror, CHECK_NULL);
1107       BasicType atype = Reflection::unbox_for_primitive(arg, &amp;value, CHECK_NULL);
1108       if (ptype != atype) {
1109         Reflection::widen(&amp;value, atype, ptype, CHECK_NULL);
1110       }
1111       switch (ptype) {
1112         case T_BOOLEAN:     java_args.push_int(value.z);    break;
1113         case T_CHAR:        java_args.push_int(value.c);    break;
1114         case T_BYTE:        java_args.push_int(value.b);    break;
1115         case T_SHORT:       java_args.push_int(value.s);    break;
1116         case T_INT:         java_args.push_int(value.i);    break;
1117         case T_LONG:        java_args.push_long(value.j);   break;
1118         case T_FLOAT:       java_args.push_float(value.f);  break;
1119         case T_DOUBLE:      java_args.push_double(value.d); break;
1120         default:
1121           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
1122       }
1123     } else {
1124       if (arg != NULL) {
1125         Klass* k = java_lang_Class::as_Klass(type_mirror);
1126         if (!arg-&gt;is_a(k)) {
1127           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1128                       &quot;argument type mismatch&quot;);
1129         }
1130       }
1131       Handle arg_handle(THREAD, arg);         // Create handle for argument
1132       java_args.push_oop(arg_handle); // Push handle
1133     }
1134   }
1135 
1136   assert(java_args.size_of_parameters() == method-&gt;size_of_parameters(),
1137     &quot;just checking&quot;);
1138 
1139   // All oops (including receiver) is passed in as Handles. An potential oop is returned as an
1140   // oop (i.e., NOT as an handle)
1141   JavaValue result(rtype);
1142   JavaCalls::call(&amp;result, method, &amp;java_args, THREAD);
1143 
1144   if (HAS_PENDING_EXCEPTION) {
1145     // Method threw an exception; wrap it in an InvocationTargetException
1146     oop target_exception = PENDING_EXCEPTION;
1147     CLEAR_PENDING_EXCEPTION;
1148     // JVMTI has already reported the pending exception
1149     // JVMTI internal flag reset is needed in order to report InvocationTargetException
1150     if (THREAD-&gt;is_Java_thread()) {
1151       JvmtiExport::clear_detected_exception((JavaThread*)THREAD);
1152     }
1153 
1154     JavaCallArguments args(Handle(THREAD, target_exception));
1155     THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1156                 vmSymbols::throwable_void_signature(),
1157                 &amp;args);
1158   } else {
1159     if (rtype == T_BOOLEAN || rtype == T_BYTE || rtype == T_CHAR || rtype == T_SHORT) {
1160       narrow((jvalue*)result.get_value_addr(), rtype, CHECK_NULL);
1161     }
1162     return Reflection::box((jvalue*)result.get_value_addr(), rtype, THREAD);
1163   }
1164 }
1165 
1166 // This would be nicer if, say, java.lang.reflect.Method was a subclass
1167 // of java.lang.reflect.Constructor
1168 
1169 oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
1170   oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
1171   int slot               = java_lang_reflect_Method::slot(method_mirror);
1172   bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
1173   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));
1174 
1175   oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
1176   BasicType rtype;
1177   if (java_lang_Class::is_primitive(return_type_mirror)) {
1178     rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
<a name="8" id="anc8"></a>

1179   } else {
1180     rtype = T_OBJECT;
1181   }
1182 
1183   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1184   Method* m = klass-&gt;method_with_idnum(slot);
1185   if (m == NULL) {
1186     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1187   }
1188   methodHandle method(THREAD, m);
1189 
1190   return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
1191 }
1192 
1193 
1194 oop Reflection::invoke_constructor(oop constructor_mirror, objArrayHandle args, TRAPS) {
1195   oop mirror             = java_lang_reflect_Constructor::clazz(constructor_mirror);
1196   int slot               = java_lang_reflect_Constructor::slot(constructor_mirror);
1197   bool override          = java_lang_reflect_Constructor::override(constructor_mirror) != 0;
1198   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Constructor::parameter_types(constructor_mirror)));
1199 
1200   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1201   Method* m = klass-&gt;method_with_idnum(slot);
1202   if (m == NULL) {
1203     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1204   }
1205   methodHandle method(THREAD, m);
1206   assert(method-&gt;name() == vmSymbols::object_initializer_name(), &quot;invalid constructor&quot;);
1207 
1208   // Make sure klass gets initialize
1209   klass-&gt;initialize(CHECK_NULL);
1210 
1211   // Create new instance (the receiver)
1212   klass-&gt;check_valid_for_instantiation(false, CHECK_NULL);
<a name="9" id="anc9"></a>















1213   Handle receiver = klass-&gt;allocate_instance_handle(CHECK_NULL);
1214 
1215   // Ignore result from call and return receiver
1216   invoke(klass, method, receiver, override, ptypes, T_VOID, args, false, CHECK_NULL);
1217   return receiver();
1218 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>