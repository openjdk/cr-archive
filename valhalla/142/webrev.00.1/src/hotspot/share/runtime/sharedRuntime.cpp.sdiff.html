<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/sharedRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="safepoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/stringTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/compiledIC.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/compiledMethod.inline.hpp&quot;
  35 #include &quot;code/scopeDesc.hpp&quot;
  36 #include &quot;code/vtableStubs.hpp&quot;
  37 #include &quot;compiler/abstractCompiler.hpp&quot;
  38 #include &quot;compiler/compileBroker.hpp&quot;
  39 #include &quot;compiler/disassembler.hpp&quot;
  40 #include &quot;gc/shared/barrierSet.hpp&quot;
  41 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  42 #include &quot;interpreter/interpreter.hpp&quot;
  43 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  44 #include &quot;jfr/jfrEvents.hpp&quot;
  45 #include &quot;logging/log.hpp&quot;
  46 #include &quot;memory/metaspaceShared.hpp&quot;

  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;


  49 #include &quot;oops/klass.hpp&quot;
  50 #include &quot;oops/method.inline.hpp&quot;
  51 #include &quot;oops/objArrayKlass.hpp&quot;

  52 #include &quot;oops/oop.inline.hpp&quot;

  53 #include &quot;prims/forte.hpp&quot;
  54 #include &quot;prims/jvmtiExport.hpp&quot;
  55 #include &quot;prims/methodHandles.hpp&quot;
  56 #include &quot;prims/nativeLookup.hpp&quot;
  57 #include &quot;runtime/arguments.hpp&quot;
  58 #include &quot;runtime/atomic.hpp&quot;
  59 #include &quot;runtime/biasedLocking.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/init.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/java.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/sharedRuntime.hpp&quot;
  67 #include &quot;runtime/stubRoutines.hpp&quot;
  68 #include &quot;runtime/synchronizer.hpp&quot;
  69 #include &quot;runtime/vframe.inline.hpp&quot;
  70 #include &quot;runtime/vframeArray.hpp&quot;
  71 #include &quot;utilities/copy.hpp&quot;
  72 #include &quot;utilities/dtrace.hpp&quot;
  73 #include &quot;utilities/events.hpp&quot;
  74 #include &quot;utilities/hashtable.inline.hpp&quot;
  75 #include &quot;utilities/macros.hpp&quot;
  76 #include &quot;utilities/xmlstream.hpp&quot;
  77 #ifdef COMPILER1
  78 #include &quot;c1/c1_Runtime1.hpp&quot;
  79 #endif
  80 
  81 // Shared stub locations
  82 RuntimeStub*        SharedRuntime::_wrong_method_blob;
  83 RuntimeStub*        SharedRuntime::_wrong_method_abstract_blob;
  84 RuntimeStub*        SharedRuntime::_ic_miss_blob;
  85 RuntimeStub*        SharedRuntime::_resolve_opt_virtual_call_blob;
  86 RuntimeStub*        SharedRuntime::_resolve_virtual_call_blob;
  87 RuntimeStub*        SharedRuntime::_resolve_static_call_blob;
<span class="line-removed">  88 address             SharedRuntime::_resolve_static_call_entry;</span>
  89 
  90 DeoptimizationBlob* SharedRuntime::_deopt_blob;
  91 SafepointBlob*      SharedRuntime::_polling_page_vectors_safepoint_handler_blob;
  92 SafepointBlob*      SharedRuntime::_polling_page_safepoint_handler_blob;
  93 SafepointBlob*      SharedRuntime::_polling_page_return_handler_blob;
  94 
  95 #ifdef COMPILER2
  96 UncommonTrapBlob*   SharedRuntime::_uncommon_trap_blob;
  97 #endif // COMPILER2
  98 
  99 
 100 //----------------------------generate_stubs-----------------------------------
 101 void SharedRuntime::generate_stubs() {
 102   _wrong_method_blob                   = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method),          &quot;wrong_method_stub&quot;);
 103   _wrong_method_abstract_blob          = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_abstract), &quot;wrong_method_abstract_stub&quot;);
 104   _ic_miss_blob                        = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_ic_miss),  &quot;ic_miss_stub&quot;);
 105   _resolve_opt_virtual_call_blob       = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_opt_virtual_call_C),   &quot;resolve_opt_virtual_call&quot;);
 106   _resolve_virtual_call_blob           = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_virtual_call_C),       &quot;resolve_virtual_call&quot;);
 107   _resolve_static_call_blob            = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_static_call_C),        &quot;resolve_static_call&quot;);
<span class="line-removed"> 108   _resolve_static_call_entry           = _resolve_static_call_blob-&gt;entry_point();</span>
 109 
 110 #if COMPILER2_OR_JVMCI
 111   // Vectors are generated only by C2 and JVMCI.
 112   bool support_wide = is_wide_vector(MaxVectorSize);
 113   if (support_wide) {
 114     _polling_page_vectors_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_VECTOR_LOOP);
 115   }
 116 #endif // COMPILER2_OR_JVMCI
 117   _polling_page_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_LOOP);
 118   _polling_page_return_handler_blob    = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_RETURN);
 119 
 120   generate_deopt_blob();
 121 
 122 #ifdef COMPILER2
 123   generate_uncommon_trap_blob();
 124 #endif // COMPILER2
 125 }
 126 
 127 #include &lt;math.h&gt;
 128 
</pre>
<hr />
<pre>
1030   }
1031   return NULL;
1032 }
1033 
1034 // Finds receiver, CallInfo (i.e. receiver method), and calling bytecode
1035 // for a call current in progress, i.e., arguments has been pushed on stack
1036 // but callee has not been invoked yet.  Caller frame must be compiled.
1037 Handle SharedRuntime::find_callee_info_helper(JavaThread* thread,
1038                                               vframeStream&amp; vfst,
1039                                               Bytecodes::Code&amp; bc,
1040                                               CallInfo&amp; callinfo, TRAPS) {
1041   Handle receiver;
1042   Handle nullHandle;  //create a handy null handle for exception returns
1043 
1044   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
1045 
1046   // Find caller and bci from vframe
1047   methodHandle caller(THREAD, vfst.method());
1048   int          bci   = vfst.bci();
1049 















1050   Bytecode_invoke bytecode(caller, bci);
1051   int bytecode_index = bytecode.index();
1052   bc = bytecode.invoke_code();
1053 
1054   methodHandle attached_method(THREAD, extract_attached_method(vfst));
1055   if (attached_method.not_null()) {
1056     Method* callee = bytecode.static_target(CHECK_NH);
1057     vmIntrinsics::ID id = callee-&gt;intrinsic_id();
1058     // When VM replaces MH.invokeBasic/linkTo* call with a direct/virtual call,
1059     // it attaches statically resolved method to the call site.
1060     if (MethodHandles::is_signature_polymorphic(id) &amp;&amp;
1061         MethodHandles::is_signature_polymorphic_intrinsic(id)) {
1062       bc = MethodHandles::signature_polymorphic_intrinsic_bytecode(id);
1063 
1064       // Adjust invocation mode according to the attached method.
1065       switch (bc) {
1066         case Bytecodes::_invokevirtual:
1067           if (attached_method-&gt;method_holder()-&gt;is_interface()) {
1068             bc = Bytecodes::_invokeinterface;
1069           }
1070           break;
1071         case Bytecodes::_invokeinterface:
1072           if (!attached_method-&gt;method_holder()-&gt;is_interface()) {
1073             bc = Bytecodes::_invokevirtual;
1074           }
1075           break;
1076         case Bytecodes::_invokehandle:
1077           if (!MethodHandles::is_signature_polymorphic_method(attached_method())) {
1078             bc = attached_method-&gt;is_static() ? Bytecodes::_invokestatic
1079                                               : Bytecodes::_invokevirtual;
1080           }
1081           break;
1082         default:
1083           break;
1084       }






1085     }
1086   }
1087 
1088   assert(bc != Bytecodes::_illegal, &quot;not initialized&quot;);
1089 
1090   bool has_receiver = bc != Bytecodes::_invokestatic &amp;&amp;
1091                       bc != Bytecodes::_invokedynamic &amp;&amp;
1092                       bc != Bytecodes::_invokehandle;

1093 
1094   // Find receiver for non-static call
1095   if (has_receiver) {
1096     // This register map must be update since we need to find the receiver for
1097     // compiled frames. The receiver might be in a register.
1098     RegisterMap reg_map2(thread);
1099     frame stubFrame   = thread-&gt;last_frame();
1100     // Caller-frame is a compiled frame
1101     frame callerFrame = stubFrame.sender(&amp;reg_map2);

1102 
<span class="line-modified">1103     if (attached_method.is_null()) {</span>
<span class="line-modified">1104       Method* callee = bytecode.static_target(CHECK_NH);</span>





1105       if (callee == NULL) {
1106         THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
1107       }
1108     }
<span class="line-modified">1109 </span>
<span class="line-modified">1110     // Retrieve from a compiled argument list</span>
<span class="line-modified">1111     receiver = Handle(THREAD, callerFrame.retrieve_receiver(&amp;reg_map2));</span>
<span class="line-modified">1112 </span>
<span class="line-modified">1113     if (receiver.is_null()) {</span>
<span class="line-modified">1114       THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);</span>









1115     }
1116   }
1117 
1118   // Resolve method
1119   if (attached_method.not_null()) {
1120     // Parameterized by attached method.
<span class="line-modified">1121     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, CHECK_NH);</span>
1122   } else {
1123     // Parameterized by bytecode.
1124     constantPoolHandle constants(THREAD, caller-&gt;constants());
1125     LinkResolver::resolve_invoke(callinfo, receiver, constants, bytecode_index, bc, CHECK_NH);
1126   }
1127 
1128 #ifdef ASSERT
1129   // Check that the receiver klass is of the right subtype and that it is initialized for virtual calls
<span class="line-modified">1130   if (has_receiver) {</span>
1131     assert(receiver.not_null(), &quot;should have thrown exception&quot;);
1132     Klass* receiver_klass = receiver-&gt;klass();
1133     Klass* rk = NULL;
1134     if (attached_method.not_null()) {
1135       // In case there&#39;s resolved method attached, use its holder during the check.
1136       rk = attached_method-&gt;method_holder();
1137     } else {
1138       // Klass is already loaded.
1139       constantPoolHandle constants(THREAD, caller-&gt;constants());
1140       rk = constants-&gt;klass_ref_at(bytecode_index, CHECK_NH);
1141     }
1142     Klass* static_receiver_klass = rk;
1143     assert(receiver_klass-&gt;is_subtype_of(static_receiver_klass),
1144            &quot;actual receiver must be subclass of static receiver klass&quot;);
1145     if (receiver_klass-&gt;is_instance_klass()) {
1146       if (InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized()) {
1147         tty-&gt;print_cr(&quot;ERROR: Klass not yet initialized!!&quot;);
1148         receiver_klass-&gt;print();
1149       }
1150       assert(!InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized(), &quot;receiver_klass must be initialized&quot;);
</pre>
<hr />
<pre>
1169     RegisterMap reg_map(thread, false);
1170     frame fr = thread-&gt;last_frame();
1171     assert(fr.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
1172     fr = fr.sender(&amp;reg_map);
1173     assert(fr.is_entry_frame(), &quot;must be&quot;);
1174     // fr is now pointing to the entry frame.
1175     callee_method = methodHandle(THREAD, fr.entry_frame_call_wrapper()-&gt;callee_method());
1176   } else {
1177     Bytecodes::Code bc;
1178     CallInfo callinfo;
1179     find_callee_info_helper(thread, vfst, bc, callinfo, CHECK_(methodHandle()));
1180     callee_method = methodHandle(THREAD, callinfo.selected_method());
1181   }
1182   assert(callee_method()-&gt;is_method(), &quot;must be&quot;);
1183   return callee_method;
1184 }
1185 
1186 // Resolves a call.
1187 methodHandle SharedRuntime::resolve_helper(JavaThread *thread,
1188                                            bool is_virtual,
<span class="line-modified">1189                                            bool is_optimized, TRAPS) {</span>

1190   methodHandle callee_method;
<span class="line-modified">1191   callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, THREAD);</span>
1192   if (JvmtiExport::can_hotswap_or_post_breakpoint()) {
1193     int retry_count = 0;
1194     while (!HAS_PENDING_EXCEPTION &amp;&amp; callee_method-&gt;is_old() &amp;&amp;
1195            callee_method-&gt;method_holder() != SystemDictionary::Object_klass()) {
1196       // If has a pending exception then there is no need to re-try to
1197       // resolve this method.
1198       // If the method has been redefined, we need to try again.
1199       // Hack: we have no way to update the vtables of arrays, so don&#39;t
1200       // require that java.lang.Object has been updated.
1201 
1202       // It is very unlikely that method is redefined more than 100 times
1203       // in the middle of resolve. If it is looping here more than 100 times
1204       // means then there could be a bug here.
1205       guarantee((retry_count++ &lt; 100),
1206                 &quot;Could not resolve to latest version of redefined method&quot;);
1207       // method is redefined in the middle of resolve so re-try.
<span class="line-modified">1208       callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, THREAD);</span>
1209     }
1210   }
1211   return callee_method;
1212 }
1213 
1214 // This fails if resolution required refilling of IC stubs
1215 bool SharedRuntime::resolve_sub_helper_internal(methodHandle callee_method, const frame&amp; caller_frame,
1216                                                 CompiledMethod* caller_nm, bool is_virtual, bool is_optimized,
1217                                                 Handle receiver, CallInfo&amp; call_info, Bytecodes::Code invoke_code, TRAPS) {
1218   StaticCallInfo static_call_info;
1219   CompiledICInfo virtual_call_info;
1220 
1221   // Make sure the callee nmethod does not get deoptimized and removed before
1222   // we are done patching the code.
1223   CompiledMethod* callee = callee_method-&gt;code();
1224 
1225   if (callee != NULL) {
1226     assert(callee-&gt;is_compiled(), &quot;must be nmethod for patching&quot;);
1227   }
1228 
1229   if (callee != NULL &amp;&amp; !callee-&gt;is_in_use()) {
1230     // Patch call site to C2I adapter if callee nmethod is deoptimized or unloaded.
1231     callee = NULL;
1232   }
1233   nmethodLocker nl_callee(callee);
1234 #ifdef ASSERT
1235   address dest_entry_point = callee == NULL ? 0 : callee-&gt;entry_point(); // used below
1236 #endif
1237 
1238   bool is_nmethod = caller_nm-&gt;is_nmethod();

1239 
1240   if (is_virtual) {
<span class="line-modified">1241     assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, &quot;sanity check&quot;);</span>








1242     bool static_bound = call_info.resolved_method()-&gt;can_be_statically_bound();
<span class="line-modified">1243     Klass* klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver-&gt;klass();</span>
<span class="line-modified">1244     CompiledIC::compute_monomorphic_entry(callee_method, klass,</span>
<span class="line-removed">1245                      is_optimized, static_bound, is_nmethod, virtual_call_info,</span>
1246                      CHECK_false);
1247   } else {
1248     // static call
<span class="line-modified">1249     CompiledStaticCall::compute_entry(callee_method, is_nmethod, static_call_info);</span>
1250   }
1251 
1252   // grab lock, check for deoptimization and potentially patch caller
1253   {
1254     CompiledICLocker ml(caller_nm);
1255 
1256     // Lock blocks for safepoint during which both nmethods can change state.
1257 
1258     // Now that we are ready to patch if the Method* was redefined then
1259     // don&#39;t update call site and let the caller retry.
1260     // Don&#39;t update call site if callee nmethod was unloaded or deoptimized.
1261     // Don&#39;t update call site if callee nmethod was replaced by an other nmethod
1262     // which may happen when multiply alive nmethod (tiered compilation)
1263     // will be supported.
1264     if (!callee_method-&gt;is_old() &amp;&amp;
1265         (callee == NULL || (callee-&gt;is_in_use() &amp;&amp; callee_method-&gt;code() == callee))) {
1266       NoSafepointVerifier nsv;
1267 #ifdef ASSERT
1268       // We must not try to patch to jump to an already unloaded method.
1269       if (dest_entry_point != 0) {
</pre>
<hr />
<pre>
1281         }
1282       } else {
1283         if (VM_Version::supports_fast_class_init_checks() &amp;&amp;
1284             invoke_code == Bytecodes::_invokestatic &amp;&amp;
1285             callee_method-&gt;needs_clinit_barrier() &amp;&amp;
1286             callee != NULL &amp;&amp; (callee-&gt;is_compiled_by_jvmci() || callee-&gt;is_aot())) {
1287           return true; // skip patching for JVMCI or AOT code
1288         }
1289         CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_before(caller_frame.pc());
1290         if (ssc-&gt;is_clean()) ssc-&gt;set(static_call_info);
1291       }
1292     }
1293   } // unlock CompiledICLocker
1294   return true;
1295 }
1296 
1297 // Resolves a call.  The compilers generate code for calls that go here
1298 // and are patched with the real destination of the call.
1299 methodHandle SharedRuntime::resolve_sub_helper(JavaThread *thread,
1300                                                bool is_virtual,
<span class="line-modified">1301                                                bool is_optimized, TRAPS) {</span>

1302 
1303   ResourceMark rm(thread);
1304   RegisterMap cbl_map(thread, false);
1305   frame caller_frame = thread-&gt;last_frame().sender(&amp;cbl_map);
1306 
1307   CodeBlob* caller_cb = caller_frame.cb();
1308   guarantee(caller_cb != NULL &amp;&amp; caller_cb-&gt;is_compiled(), &quot;must be called from compiled method&quot;);
1309   CompiledMethod* caller_nm = caller_cb-&gt;as_compiled_method_or_null();

1310 
1311   // make sure caller is not getting deoptimized
1312   // and removed before we are done with it.
1313   // CLEANUP - with lazy deopt shouldn&#39;t need this lock
1314   nmethodLocker caller_lock(caller_nm);
1315 
1316   // determine call info &amp; receiver
1317   // note: a) receiver is NULL for static calls
1318   //       b) an exception is thrown if receiver is NULL for non-static calls
1319   CallInfo call_info;
1320   Bytecodes::Code invoke_code = Bytecodes::_illegal;
1321   Handle receiver = find_callee_info(thread, invoke_code,
1322                                      call_info, CHECK_(methodHandle()));
1323   methodHandle callee_method(THREAD, call_info.selected_method());
1324 
1325   assert((!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokestatic ) ||
1326          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokespecial) ||
1327          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokehandle ) ||
1328          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokedynamic) ||
1329          ( is_virtual &amp;&amp; invoke_code != Bytecodes::_invokestatic ), &quot;inconsistent bytecode&quot;);
</pre>
<hr />
<pre>
1391       return callee_method;
1392     } else {
1393       InlineCacheBuffer::refill_ic_stubs();
1394     }
1395   }
1396 
1397 }
1398 
1399 
1400 // Inline caches exist only in compiled code
1401 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_ic_miss(JavaThread* thread))
1402 #ifdef ASSERT
1403   RegisterMap reg_map(thread, false);
1404   frame stub_frame = thread-&gt;last_frame();
1405   assert(stub_frame.is_runtime_frame(), &quot;sanity check&quot;);
1406   frame caller_frame = stub_frame.sender(&amp;reg_map);
1407   assert(!caller_frame.is_interpreted_frame() &amp;&amp; !caller_frame.is_entry_frame(), &quot;unexpected frame&quot;);
1408 #endif /* ASSERT */
1409 
1410   methodHandle callee_method;


1411   JRT_BLOCK
<span class="line-modified">1412     callee_method = SharedRuntime::handle_ic_miss_helper(thread, CHECK_NULL);</span>
1413     // Return Method* through TLS
1414     thread-&gt;set_vm_result_2(callee_method());
1415   JRT_BLOCK_END
1416   // return compiled code entry point after potential safepoints
<span class="line-modified">1417   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-removed">1418   return callee_method-&gt;verified_code_entry();</span>
1419 JRT_END
1420 
1421 
1422 // Handle call site that has been made non-entrant
1423 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method(JavaThread* thread))
1424   // 6243940 We might end up in here if the callee is deoptimized
1425   // as we race to call it.  We don&#39;t want to take a safepoint if
1426   // the caller was interpreted because the caller frame will look
1427   // interpreted to the stack walkers and arguments are now
1428   // &quot;compiled&quot; so it is much better to make this transition
1429   // invisible to the stack walking code. The i2c path will
1430   // place the callee method in the callee_target. It is stashed
1431   // there because if we try and find the callee by normal means a
1432   // safepoint is possible and have trouble gc&#39;ing the compiled args.
1433   RegisterMap reg_map(thread, false);
1434   frame stub_frame = thread-&gt;last_frame();
1435   assert(stub_frame.is_runtime_frame(), &quot;sanity check&quot;);
1436   frame caller_frame = stub_frame.sender(&amp;reg_map);
1437 
1438   if (caller_frame.is_interpreted_frame() ||
</pre>
<hr />
<pre>
1441     guarantee(callee != NULL &amp;&amp; callee-&gt;is_method(), &quot;bad handshake&quot;);
1442     thread-&gt;set_vm_result_2(callee);
1443     thread-&gt;set_callee_target(NULL);
1444     if (caller_frame.is_entry_frame() &amp;&amp; VM_Version::supports_fast_class_init_checks()) {
1445       // Bypass class initialization checks in c2i when caller is in native.
1446       // JNI calls to static methods don&#39;t have class initialization checks.
1447       // Fast class initialization checks are present in c2i adapters and call into
1448       // SharedRuntime::handle_wrong_method() on the slow path.
1449       //
1450       // JVM upcalls may land here as well, but there&#39;s a proper check present in
1451       // LinkResolver::resolve_static_call (called from JavaCalls::call_static),
1452       // so bypassing it in c2i adapter is benign.
1453       return callee-&gt;get_c2i_no_clinit_check_entry();
1454     } else {
1455       return callee-&gt;get_c2i_entry();
1456     }
1457   }
1458 
1459   // Must be compiled to compiled path which is safe to stackwalk
1460   methodHandle callee_method;



1461   JRT_BLOCK
1462     // Force resolving of caller (if we called from compiled frame)
<span class="line-modified">1463     callee_method = SharedRuntime::reresolve_call_site(thread, CHECK_NULL);</span>
1464     thread-&gt;set_vm_result_2(callee_method());
1465   JRT_BLOCK_END
1466   // return compiled code entry point after potential safepoints
<span class="line-modified">1467   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-removed">1468   return callee_method-&gt;verified_code_entry();</span>
1469 JRT_END
1470 
1471 // Handle abstract method call
1472 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_abstract(JavaThread* thread))
1473   // Verbose error message for AbstractMethodError.
1474   // Get the called method from the invoke bytecode.
1475   vframeStream vfst(thread, true);
1476   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
1477   methodHandle caller(thread, vfst.method());
1478   Bytecode_invoke invoke(caller, vfst.bci());
1479   DEBUG_ONLY( invoke.verify(); )
1480 
1481   // Find the compiled caller frame.
1482   RegisterMap reg_map(thread);
1483   frame stubFrame = thread-&gt;last_frame();
1484   assert(stubFrame.is_runtime_frame(), &quot;must be&quot;);
1485   frame callerFrame = stubFrame.sender(&amp;reg_map);
1486   assert(callerFrame.is_compiled_frame(), &quot;must be&quot;);
1487 
1488   // Install exception and return forward entry.
1489   address res = StubRoutines::throw_AbstractMethodError_entry();
1490   JRT_BLOCK
1491     methodHandle callee(thread, invoke.static_target(thread));
1492     if (!callee.is_null()) {
1493       oop recv = callerFrame.retrieve_receiver(&amp;reg_map);
1494       Klass *recv_klass = (recv != NULL) ? recv-&gt;klass() : NULL;
1495       LinkResolver::throw_abstract_method_error(callee, recv_klass, thread);
1496       res = StubRoutines::forward_exception_entry();
1497     }
1498   JRT_BLOCK_END
1499   return res;
1500 JRT_END
1501 
1502 
1503 // resolve a static call and patch code
1504 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_static_call_C(JavaThread *thread ))
1505   methodHandle callee_method;

1506   JRT_BLOCK
<span class="line-modified">1507     callee_method = SharedRuntime::resolve_helper(thread, false, false, CHECK_NULL);</span>
1508     thread-&gt;set_vm_result_2(callee_method());
1509   JRT_BLOCK_END
1510   // return compiled code entry point after potential safepoints
<span class="line-modified">1511   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-modified">1512   return callee_method-&gt;verified_code_entry();</span>


1513 JRT_END
1514 
1515 
1516 // resolve virtual call and update inline cache to monomorphic
1517 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_virtual_call_C(JavaThread *thread ))
1518   methodHandle callee_method;

1519   JRT_BLOCK
<span class="line-modified">1520     callee_method = SharedRuntime::resolve_helper(thread, true, false, CHECK_NULL);</span>
1521     thread-&gt;set_vm_result_2(callee_method());
1522   JRT_BLOCK_END
1523   // return compiled code entry point after potential safepoints
<span class="line-modified">1524   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-modified">1525   return callee_method-&gt;verified_code_entry();</span>


1526 JRT_END
1527 
1528 
1529 // Resolve a virtual call that can be statically bound (e.g., always
1530 // monomorphic, so it has no inline cache).  Patch code to resolved target.
1531 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_opt_virtual_call_C(JavaThread *thread))
1532   methodHandle callee_method;

1533   JRT_BLOCK
<span class="line-modified">1534     callee_method = SharedRuntime::resolve_helper(thread, true, true, CHECK_NULL);</span>
1535     thread-&gt;set_vm_result_2(callee_method());
1536   JRT_BLOCK_END
1537   // return compiled code entry point after potential safepoints
<span class="line-modified">1538   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-modified">1539   return callee_method-&gt;verified_code_entry();</span>


1540 JRT_END
1541 
1542 // The handle_ic_miss_helper_internal function returns false if it failed due
1543 // to either running out of vtable stubs or ic stubs due to IC transitions
1544 // to transitional states. The needs_ic_stub_refill value will be set if
1545 // the failure was due to running out of IC stubs, in which case handle_ic_miss_helper
1546 // refills the IC stubs and tries again.
1547 bool SharedRuntime::handle_ic_miss_helper_internal(Handle receiver, CompiledMethod* caller_nm,
1548                                                    const frame&amp; caller_frame, methodHandle callee_method,
1549                                                    Bytecodes::Code bc, CallInfo&amp; call_info,
<span class="line-modified">1550                                                    bool&amp; needs_ic_stub_refill, TRAPS) {</span>
1551   CompiledICLocker ml(caller_nm);
1552   CompiledIC* inline_cache = CompiledIC_before(caller_nm, caller_frame.pc());
1553   bool should_be_mono = false;
1554   if (inline_cache-&gt;is_optimized()) {
1555     if (TraceCallFixup) {
1556       ResourceMark rm(THREAD);
1557       tty-&gt;print(&quot;OPTIMIZED IC miss (%s) call to&quot;, Bytecodes::name(bc));
1558       callee_method-&gt;print_short_name(tty);
1559       tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1560     }

1561     should_be_mono = true;
1562   } else if (inline_cache-&gt;is_icholder_call()) {
1563     CompiledICHolder* ic_oop = inline_cache-&gt;cached_icholder();
1564     if (ic_oop != NULL) {
1565       if (!ic_oop-&gt;is_loader_alive()) {
1566         // Deferred IC cleaning due to concurrent class unloading
1567         if (!inline_cache-&gt;set_to_clean()) {
1568           needs_ic_stub_refill = true;
1569           return false;
1570         }
1571       } else if (receiver()-&gt;klass() == ic_oop-&gt;holder_klass()) {
1572         // This isn&#39;t a real miss. We must have seen that compiled code
1573         // is now available and we want the call site converted to a
1574         // monomorphic compiled call site.
1575         // We can&#39;t assert for callee_method-&gt;code() != NULL because it
1576         // could have been deoptimized in the meantime
1577         if (TraceCallFixup) {
1578           ResourceMark rm(THREAD);
1579           tty-&gt;print(&quot;FALSE IC miss (%s) converting to compiled call to&quot;, Bytecodes::name(bc));
1580           callee_method-&gt;print_short_name(tty);
1581           tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1582         }
1583         should_be_mono = true;
1584       }
1585     }
1586   }
1587 
1588   if (should_be_mono) {
1589     // We have a path that was monomorphic but was going interpreted
1590     // and now we have (or had) a compiled entry. We correct the IC
1591     // by using a new icBuffer.
1592     CompiledICInfo info;
1593     Klass* receiver_klass = receiver()-&gt;klass();
1594     inline_cache-&gt;compute_monomorphic_entry(callee_method,
1595                                             receiver_klass,
1596                                             inline_cache-&gt;is_optimized(),
1597                                             false, caller_nm-&gt;is_nmethod(),

1598                                             info, CHECK_false);
1599     if (!inline_cache-&gt;set_to_monomorphic(info)) {
1600       needs_ic_stub_refill = true;
1601       return false;
1602     }
1603   } else if (!inline_cache-&gt;is_megamorphic() &amp;&amp; !inline_cache-&gt;is_clean()) {
1604     // Potential change to megamorphic
1605 
<span class="line-modified">1606     bool successful = inline_cache-&gt;set_to_megamorphic(&amp;call_info, bc, needs_ic_stub_refill, CHECK_false);</span>
1607     if (needs_ic_stub_refill) {
1608       return false;
1609     }
1610     if (!successful) {
1611       if (!inline_cache-&gt;set_to_clean()) {
1612         needs_ic_stub_refill = true;
1613         return false;
1614       }
1615     }
1616   } else {
1617     // Either clean or megamorphic
1618   }
1619   return true;
1620 }
1621 
<span class="line-modified">1622 methodHandle SharedRuntime::handle_ic_miss_helper(JavaThread *thread, TRAPS) {</span>
1623   ResourceMark rm(thread);
1624   CallInfo call_info;
1625   Bytecodes::Code bc;
1626 
1627   // receiver is NULL for static calls. An exception is thrown for NULL
1628   // receivers for non-static calls
1629   Handle receiver = find_callee_info(thread, bc, call_info,
1630                                      CHECK_(methodHandle()));
1631   // Compiler1 can produce virtual call sites that can actually be statically bound
1632   // If we fell thru to below we would think that the site was going megamorphic
1633   // when in fact the site can never miss. Worse because we&#39;d think it was megamorphic
1634   // we&#39;d try and do a vtable dispatch however methods that can be statically bound
1635   // don&#39;t have vtable entries (vtable_index &lt; 0) and we&#39;d blow up. So we force a
1636   // reresolution of the  call site (as if we did a handle_wrong_method and not an
1637   // plain ic_miss) and the site will be converted to an optimized virtual call site
1638   // never to miss again. I don&#39;t believe C2 will produce code like this but if it
1639   // did this would still be the correct thing to do for it too, hence no ifdef.
1640   //
1641   if (call_info.resolved_method()-&gt;can_be_statically_bound()) {
<span class="line-modified">1642     methodHandle callee_method = SharedRuntime::reresolve_call_site(thread, CHECK_(methodHandle()));</span>


1643     if (TraceCallFixup) {
1644       RegisterMap reg_map(thread, false);
1645       frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
1646       ResourceMark rm(thread);
1647       tty-&gt;print(&quot;converting IC miss to reresolve (%s) call to&quot;, Bytecodes::name(bc));
1648       callee_method-&gt;print_short_name(tty);
1649       tty-&gt;print_cr(&quot; from pc: &quot; INTPTR_FORMAT, p2i(caller_frame.pc()));
1650       tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1651     }
1652     return callee_method;
1653   }
1654 
1655   methodHandle callee_method(thread, call_info.selected_method());
1656 
1657 #ifndef PRODUCT
1658   Atomic::inc(&amp;_ic_miss_ctr);
1659 
1660   // Statistics &amp; Tracing
1661   if (TraceCallFixup) {
1662     ResourceMark rm(thread);
</pre>
<hr />
<pre>
1672     // produce statistics under the lock
1673     trace_ic_miss(f.pc());
1674   }
1675 #endif
1676 
1677   // install an event collector so that when a vtable stub is created the
1678   // profiler can be notified via a DYNAMIC_CODE_GENERATED event. The
1679   // event can&#39;t be posted when the stub is created as locks are held
1680   // - instead the event will be deferred until the event collector goes
1681   // out of scope.
1682   JvmtiDynamicCodeEventCollector event_collector;
1683 
1684   // Update inline cache to megamorphic. Skip update if we are called from interpreted.
1685   // Transitioning IC caches may require transition stubs. If we run out
1686   // of transition stubs, we have to drop locks and perform a safepoint
1687   // that refills them.
1688   RegisterMap reg_map(thread, false);
1689   frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
1690   CodeBlob* cb = caller_frame.cb();
1691   CompiledMethod* caller_nm = cb-&gt;as_compiled_method();

1692 
1693   for (;;) {
1694     ICRefillVerifier ic_refill_verifier;
1695     bool needs_ic_stub_refill = false;
1696     bool successful = handle_ic_miss_helper_internal(receiver, caller_nm, caller_frame, callee_method,
<span class="line-modified">1697                                                      bc, call_info, needs_ic_stub_refill, CHECK_(methodHandle()));</span>
1698     if (successful || !needs_ic_stub_refill) {
1699       return callee_method;
1700     } else {
1701       InlineCacheBuffer::refill_ic_stubs();
1702     }
1703   }
1704 }
1705 
1706 static bool clear_ic_at_addr(CompiledMethod* caller_nm, address call_addr, bool is_static_call) {
1707   CompiledICLocker ml(caller_nm);
1708   if (is_static_call) {
1709     CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_at(call_addr);
1710     if (!ssc-&gt;is_clean()) {
1711       return ssc-&gt;set_to_clean();
1712     }
1713   } else {
1714     // compiled, dispatched call (which used to call an interpreted method)
1715     CompiledIC* inline_cache = CompiledIC_at(caller_nm, call_addr);
1716     if (!inline_cache-&gt;is_clean()) {
1717       return inline_cache-&gt;set_to_clean();
1718     }
1719   }
1720   return true;
1721 }
1722 
1723 //
1724 // Resets a call-site in compiled code so it will get resolved again.
1725 // This routines handles both virtual call sites, optimized virtual call
1726 // sites, and static call sites. Typically used to change a call sites
1727 // destination from compiled to interpreted.
1728 //
<span class="line-modified">1729 methodHandle SharedRuntime::reresolve_call_site(JavaThread *thread, TRAPS) {</span>
1730   ResourceMark rm(thread);
1731   RegisterMap reg_map(thread, false);
1732   frame stub_frame = thread-&gt;last_frame();
1733   assert(stub_frame.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
1734   frame caller = stub_frame.sender(&amp;reg_map);
1735 
1736   // Do nothing if the frame isn&#39;t a live compiled frame.
1737   // nmethod could be deoptimized by the time we get here
1738   // so no update to the caller is needed.
1739 
1740   if (caller.is_compiled_frame() &amp;&amp; !caller.is_deoptimized_frame()) {
1741 
1742     address pc = caller.pc();
1743 
1744     // Check for static or virtual call
<span class="line-modified">1745     bool is_static_call = false;</span>
1746     CompiledMethod* caller_nm = CodeCache::find_compiled(pc);
1747 
1748     // Default call_addr is the location of the &quot;basic&quot; call.
1749     // Determine the address of the call we a reresolving. With
1750     // Inline Caches we will always find a recognizable call.
1751     // With Inline Caches disabled we may or may not find a
1752     // recognizable call. We will always find a call for static
1753     // calls and for optimized virtual calls. For vanilla virtual
1754     // calls it depends on the state of the UseInlineCaches switch.
1755     //
1756     // With Inline Caches disabled we can get here for a virtual call
1757     // for two reasons:
1758     //   1 - calling an abstract method. The vtable for abstract methods
1759     //       will run us thru handle_wrong_method and we will eventually
1760     //       end up in the interpreter to throw the ame.
1761     //   2 - a racing deoptimization. We could be doing a vanilla vtable
1762     //       call and between the time we fetch the entry address and
1763     //       we jump to it the target gets deoptimized. Similar to 1
1764     //       we will wind up in the interprter (thru a c2i with c2).
1765     //
</pre>
<hr />
<pre>
1770       CompiledICLocker ml(caller_nm);
1771       // Location of call instruction
1772       call_addr = caller_nm-&gt;call_instruction_address(pc);
1773     }
1774     // Make sure nmethod doesn&#39;t get deoptimized and removed until
1775     // this is done with it.
1776     // CLEANUP - with lazy deopt shouldn&#39;t need this lock
1777     nmethodLocker nmlock(caller_nm);
1778 
1779     if (call_addr != NULL) {
1780       RelocIterator iter(caller_nm, call_addr, call_addr+1);
1781       int ret = iter.next(); // Get item
1782       if (ret) {
1783         assert(iter.addr() == call_addr, &quot;must find call&quot;);
1784         if (iter.type() == relocInfo::static_call_type) {
1785           is_static_call = true;
1786         } else {
1787           assert(iter.type() == relocInfo::virtual_call_type ||
1788                  iter.type() == relocInfo::opt_virtual_call_type
1789                 , &quot;unexpected relocInfo. type&quot;);

1790         }
1791       } else {
1792         assert(!UseInlineCaches, &quot;relocation info. must exist for this address&quot;);
1793       }
1794 
1795       // Cleaning the inline cache will force a new resolve. This is more robust
1796       // than directly setting it to the new destination, since resolving of calls
1797       // is always done through the same code path. (experience shows that it
1798       // leads to very hard to track down bugs, if an inline cache gets updated
1799       // to a wrong method). It should not be performance critical, since the
1800       // resolve is only done once.
1801 
1802       for (;;) {
1803         ICRefillVerifier ic_refill_verifier;
1804         if (!clear_ic_at_addr(caller_nm, call_addr, is_static_call)) {
1805           InlineCacheBuffer::refill_ic_stubs();
1806         } else {
1807           break;
1808         }
1809       }
1810     }
1811   }
1812 
1813   methodHandle callee_method = find_callee_method(thread, CHECK_(methodHandle()));
1814 
<span class="line-removed">1815 </span>
1816 #ifndef PRODUCT
1817   Atomic::inc(&amp;_wrong_method_ctr);
1818 
1819   if (TraceCallFixup) {
1820     ResourceMark rm(thread);
1821     tty-&gt;print(&quot;handle_wrong_method reresolving call to&quot;);
1822     callee_method-&gt;print_short_name(tty);
1823     tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1824   }
1825 #endif
1826 
1827   return callee_method;
1828 }
1829 
1830 address SharedRuntime::handle_unsafe_access(JavaThread* thread, address next_pc) {
1831   // The faulting unsafe accesses should be changed to throw the error
1832   // synchronously instead. Meanwhile the faulting instruction will be
1833   // skipped over (effectively turning it into a no-op) and an
1834   // asynchronous exception will be raised which the thread will
1835   // handle at a later point. If the instruction is a load it will
</pre>
<hr />
<pre>
1890     }
1891   } else {
1892     if (TraceCallFixup) {
1893       tty-&gt;print(&quot;already patched callsite at &quot; INTPTR_FORMAT &quot; to compiled code for&quot;, p2i(caller_pc));
1894       moop-&gt;print_short_name(tty);
1895       tty-&gt;print_cr(&quot; to &quot; INTPTR_FORMAT, p2i(entry_point));
1896     }
1897   }
1898   return false;
1899 }
1900 
1901 // ---------------------------------------------------------------------------
1902 // We are calling the interpreter via a c2i. Normally this would mean that
1903 // we were called by a compiled method. However we could have lost a race
1904 // where we went int -&gt; i2c -&gt; c2i and so the caller could in fact be
1905 // interpreted. If the caller is compiled we attempt to patch the caller
1906 // so he no longer calls into the interpreter.
1907 JRT_LEAF(void, SharedRuntime::fixup_callers_callsite(Method* method, address caller_pc))
1908   Method* moop(method);
1909 
<span class="line-removed">1910   address entry_point = moop-&gt;from_compiled_entry_no_trampoline();</span>
<span class="line-removed">1911 </span>
1912   // It&#39;s possible that deoptimization can occur at a call site which hasn&#39;t
1913   // been resolved yet, in which case this function will be called from
1914   // an nmethod that has been patched for deopt and we can ignore the
1915   // request for a fixup.
1916   // Also it is possible that we lost a race in that from_compiled_entry
1917   // is now back to the i2c in that case we don&#39;t need to patch and if
1918   // we did we&#39;d leap into space because the callsite needs to use
1919   // &quot;to interpreter&quot; stub in order to load up the Method*. Don&#39;t
1920   // ask me how I know this...
1921 
1922   CodeBlob* cb = CodeCache::find_blob(caller_pc);
<span class="line-modified">1923   if (cb == NULL || !cb-&gt;is_compiled() || entry_point == moop-&gt;get_c2i_entry()) {</span>




1924     return;
1925   }
1926 
1927   // The check above makes sure this is a nmethod.
1928   CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
1929   assert(nm, &quot;must be&quot;);
1930 
1931   // Get the return PC for the passed caller PC.
1932   address return_pc = caller_pc + frame::pc_return_offset;
1933 
1934   // There is a benign race here. We could be attempting to patch to a compiled
1935   // entry point at the same time the callee is being deoptimized. If that is
1936   // the case then entry_point may in fact point to a c2i and we&#39;d patch the
1937   // call site with the same old data. clear_code will set code() to NULL
1938   // at the end of it. If we happen to see that NULL then we can skip trying
1939   // to patch. If we hit the window where the callee has a c2i in the
1940   // from_compiled_entry and the NULL isn&#39;t present yet then we lose the race
1941   // and patch the code with the same old data. Asi es la vida.
1942 
1943   if (moop-&gt;code() == NULL) return;
</pre>
<hr />
<pre>
2264  private:
2265   enum {
2266     _basic_type_bits = 4,
2267     _basic_type_mask = right_n_bits(_basic_type_bits),
2268     _basic_types_per_int = BitsPerInt / _basic_type_bits,
2269     _compact_int_count = 3
2270   };
2271   // TO DO:  Consider integrating this with a more global scheme for compressing signatures.
2272   // For now, 4 bits per components (plus T_VOID gaps after double/long) is not excessive.
2273 
2274   union {
2275     int  _compact[_compact_int_count];
2276     int* _fingerprint;
2277   } _value;
2278   int _length; // A negative length indicates the fingerprint is in the compact form,
2279                // Otherwise _value._fingerprint is the array.
2280 
2281   // Remap BasicTypes that are handled equivalently by the adapters.
2282   // These are correct for the current system but someday it might be
2283   // necessary to make this mapping platform dependent.
<span class="line-modified">2284   static int adapter_encoding(BasicType in) {</span>
2285     switch (in) {
2286       case T_BOOLEAN:
2287       case T_BYTE:
2288       case T_SHORT:
<span class="line-modified">2289       case T_CHAR:</span>
<span class="line-modified">2290         // There are all promoted to T_INT in the calling convention</span>
<span class="line-modified">2291         return T_INT;</span>













2292 
2293       case T_OBJECT:
2294       case T_ARRAY:
2295         // In other words, we assume that any register good enough for
2296         // an int or long is good enough for a managed pointer.
2297 #ifdef _LP64
2298         return T_LONG;
2299 #else
2300         return T_INT;
2301 #endif
2302 
2303       case T_INT:
2304       case T_LONG:
2305       case T_FLOAT:
2306       case T_DOUBLE:
2307       case T_VOID:
2308         return in;
2309 
2310       default:
2311         ShouldNotReachHere();
2312         return T_CONFLICT;
2313     }
2314   }
2315 
2316  public:
<span class="line-modified">2317   AdapterFingerPrint(int total_args_passed, BasicType* sig_bt) {</span>
2318     // The fingerprint is based on the BasicType signature encoded
2319     // into an array of ints with eight entries per int.

2320     int* ptr;
2321     int len = (total_args_passed + (_basic_types_per_int-1)) / _basic_types_per_int;
2322     if (len &lt;= _compact_int_count) {
2323       assert(_compact_int_count == 3, &quot;else change next line&quot;);
2324       _value._compact[0] = _value._compact[1] = _value._compact[2] = 0;
2325       // Storing the signature encoded as signed chars hits about 98%
2326       // of the time.
2327       _length = -len;
2328       ptr = _value._compact;
2329     } else {
2330       _length = len;
2331       _value._fingerprint = NEW_C_HEAP_ARRAY(int, _length, mtCode);
2332       ptr = _value._fingerprint;
2333     }
2334 
2335     // Now pack the BasicTypes with 8 per int
2336     int sig_index = 0;


2337     for (int index = 0; index &lt; len; index++) {
2338       int value = 0;
2339       for (int byte = 0; byte &lt; _basic_types_per_int; byte++) {
<span class="line-modified">2340         int bt = ((sig_index &lt; total_args_passed)</span>
<span class="line-modified">2341                   ? adapter_encoding(sig_bt[sig_index++])</span>
<span class="line-modified">2342                   : 0);</span>

















2343         assert((bt &amp; _basic_type_mask) == bt, &quot;must fit in 4 bits&quot;);
2344         value = (value &lt;&lt; _basic_type_bits) | bt;
2345       }
2346       ptr[index] = value;
2347     }

2348   }
2349 
2350   ~AdapterFingerPrint() {
2351     if (_length &gt; 0) {
2352       FREE_C_HEAP_ARRAY(int, _value._fingerprint);
2353     }
2354   }
2355 
2356   int value(int index) {
2357     if (_length &lt; 0) {
2358       return _value._compact[index];
2359     }
2360     return _value._fingerprint[index];
2361   }
2362   int length() {
2363     if (_length &lt; 0) return -_length;
2364     return _length;
2365   }
2366 
2367   bool is_compact() {
</pre>
<hr />
<pre>
2413 
2414  private:
2415 
2416 #ifndef PRODUCT
2417   static int _lookups; // number of calls to lookup
2418   static int _buckets; // number of buckets checked
2419   static int _equals;  // number of buckets checked with matching hash
2420   static int _hits;    // number of successful lookups
2421   static int _compact; // number of equals calls with compact signature
2422 #endif
2423 
2424   AdapterHandlerEntry* bucket(int i) {
2425     return (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::bucket(i);
2426   }
2427 
2428  public:
2429   AdapterHandlerTable()
2430     : BasicHashtable&lt;mtCode&gt;(293, (DumpSharedSpaces ? sizeof(CDSAdapterHandlerEntry) : sizeof(AdapterHandlerEntry))) { }
2431 
2432   // Create a new entry suitable for insertion in the table
<span class="line-modified">2433   AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry) {</span>


2434     AdapterHandlerEntry* entry = (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::new_entry(fingerprint-&gt;compute_hash());
<span class="line-modified">2435     entry-&gt;init(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>

2436     if (DumpSharedSpaces) {
2437       ((CDSAdapterHandlerEntry*)entry)-&gt;init();
2438     }
2439     return entry;
2440   }
2441 
2442   // Insert an entry into the table
2443   void add(AdapterHandlerEntry* entry) {
2444     int index = hash_to_index(entry-&gt;hash());
2445     add_entry(index, entry);
2446   }
2447 
2448   void free_entry(AdapterHandlerEntry* entry) {
2449     entry-&gt;deallocate();
2450     BasicHashtable&lt;mtCode&gt;::free_entry(entry);
2451   }
2452 
2453   // Find a entry with the same fingerprint if it exists
<span class="line-modified">2454   AdapterHandlerEntry* lookup(int total_args_passed, BasicType* sig_bt) {</span>
2455     NOT_PRODUCT(_lookups++);
<span class="line-modified">2456     AdapterFingerPrint fp(total_args_passed, sig_bt);</span>
2457     unsigned int hash = fp.compute_hash();
2458     int index = hash_to_index(hash);
2459     for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e-&gt;next()) {
2460       NOT_PRODUCT(_buckets++);
2461       if (e-&gt;hash() == hash) {
2462         NOT_PRODUCT(_equals++);
2463         if (fp.equals(e-&gt;fingerprint())) {
2464 #ifndef PRODUCT
2465           if (fp.is_compact()) _compact++;
2466           _hits++;
2467 #endif
2468           return e;
2469         }
2470       }
2471     }
2472     return NULL;
2473   }
2474 
2475 #ifndef PRODUCT
2476   void print_statistics() {
</pre>
<hr />
<pre>
2532   bool has_next() {
2533     return _current != NULL;
2534   }
2535   AdapterHandlerEntry* next() {
2536     if (_current != NULL) {
2537       AdapterHandlerEntry* result = _current;
2538       _current = _current-&gt;next();
2539       if (_current == NULL) scan();
2540       return result;
2541     } else {
2542       return NULL;
2543     }
2544   }
2545 };
2546 
2547 
2548 // ---------------------------------------------------------------------------
2549 // Implementation of AdapterHandlerLibrary
2550 AdapterHandlerTable* AdapterHandlerLibrary::_adapters = NULL;
2551 AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = NULL;
<span class="line-modified">2552 const int AdapterHandlerLibrary_size = 16*K;</span>
2553 BufferBlob* AdapterHandlerLibrary::_buffer = NULL;
2554 
2555 BufferBlob* AdapterHandlerLibrary::buffer_blob() {
2556   // Should be called only when AdapterHandlerLibrary_lock is active.
2557   if (_buffer == NULL) // Initialize lazily
2558       _buffer = BufferBlob::create(&quot;adapters&quot;, AdapterHandlerLibrary_size);
2559   return _buffer;
2560 }
2561 
2562 extern &quot;C&quot; void unexpected_adapter_call() {
2563   ShouldNotCallThis();
2564 }
2565 
2566 void AdapterHandlerLibrary::initialize() {
2567   if (_adapters != NULL) return;
2568   _adapters = new AdapterHandlerTable();
2569 
2570   // Create a special handler for abstract methods.  Abstract methods
2571   // are never compiled so an i2c entry is somewhat meaningless, but
2572   // throw AbstractMethodError just in case.
2573   // Pass wrong_method_abstract for the c2i transitions to return
2574   // AbstractMethodError for invalid invocations.
2575   address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();
<span class="line-modified">2576   _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, NULL),</span>
2577                                                               StubRoutines::throw_AbstractMethodError_entry(),

2578                                                               wrong_method_abstract, wrong_method_abstract);
2579 }
2580 
2581 AdapterHandlerEntry* AdapterHandlerLibrary::new_entry(AdapterFingerPrint* fingerprint,
2582                                                       address i2c_entry,
2583                                                       address c2i_entry,


2584                                                       address c2i_unverified_entry,

2585                                                       address c2i_no_clinit_check_entry) {
<span class="line-modified">2586   return _adapters-&gt;new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>















2587 }
2588 
2589 AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter(const methodHandle&amp; method) {
2590   AdapterHandlerEntry* entry = get_adapter0(method);
2591   if (entry != NULL &amp;&amp; method-&gt;is_shared()) {
2592     // See comments around Method::link_method()
2593     MutexLocker mu(AdapterHandlerLibrary_lock);
2594     if (method-&gt;adapter() == NULL) {
2595       method-&gt;update_adapter_trampoline(entry);
2596     }
<span class="line-modified">2597     address trampoline = method-&gt;from_compiled_entry();</span>
<span class="line-modified">2598     if (*(int*)trampoline == 0) {</span>
<span class="line-modified">2599       CodeBuffer buffer(trampoline, (int)SharedRuntime::trampoline_size());</span>
<span class="line-modified">2600       MacroAssembler _masm(&amp;buffer);</span>
<span class="line-modified">2601       SharedRuntime::generate_trampoline(&amp;_masm, entry-&gt;get_c2i_entry());</span>
<span class="line-modified">2602       assert(*(int*)trampoline != 0, &quot;Instruction(s) for trampoline must not be encoded as zeros.&quot;);</span>
<span class="line-modified">2603       _masm.flush();</span>

2604 
<span class="line-modified">2605       if (PrintInterpreter) {</span>
<span class="line-modified">2606         Disassembler::decode(buffer.insts_begin(), buffer.insts_end());</span>


























2607       }


2608     }
2609   }



2610 
<span class="line-modified">2611   return entry;</span>



























































































































































2612 }
2613 
2614 AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter0(const methodHandle&amp; method) {
2615   // Use customized signature handler.  Need to lock around updates to
2616   // the AdapterHandlerTable (it is not safe for concurrent readers
2617   // and a single writer: this could be fixed if it becomes a
2618   // problem).
2619 
2620   ResourceMark rm;
2621 
<span class="line-modified">2622   NOT_PRODUCT(int insts_size);</span>
2623   AdapterBlob* new_adapter = NULL;
2624   AdapterHandlerEntry* entry = NULL;
2625   AdapterFingerPrint* fingerprint = NULL;

2626   {
2627     MutexLocker mu(AdapterHandlerLibrary_lock);
2628     // make sure data structure is initialized
2629     initialize();
2630 
<span class="line-modified">2631     if (method-&gt;is_abstract()) {</span>
<span class="line-modified">2632       return _abstract_method_handler;</span>


2633     }






2634 
<span class="line-modified">2635     // Fill in the signature array, for the calling-convention call.</span>
<span class="line-modified">2636     int total_args_passed = method-&gt;size_of_parameters(); // All args on stack</span>



2637 
<span class="line-modified">2638     BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_args_passed);</span>
<span class="line-modified">2639     VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);</span>
<span class="line-modified">2640     int i = 0;</span>
<span class="line-modified">2641     if (!method-&gt;is_static())  // Pass in receiver first</span>
<span class="line-modified">2642       sig_bt[i++] = T_OBJECT;</span>
<span class="line-modified">2643     for (SignatureStream ss(method-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-modified">2644       sig_bt[i++] = ss.type();  // Collect remaining bits of signature</span>
<span class="line-modified">2645       if (ss.type() == T_LONG || ss.type() == T_DOUBLE)</span>
<span class="line-modified">2646         sig_bt[i++] = T_VOID;   // Longs &amp; doubles take 2 Java slots</span>






2647     }
<span class="line-removed">2648     assert(i == total_args_passed, &quot;&quot;);</span>
2649 
2650     // Lookup method signature&#39;s fingerprint
<span class="line-modified">2651     entry = _adapters-&gt;lookup(total_args_passed, sig_bt);</span>
2652 
2653 #ifdef ASSERT
2654     AdapterHandlerEntry* shared_entry = NULL;
2655     // Start adapter sharing verification only after the VM is booted.
2656     if (VerifyAdapterSharing &amp;&amp; (entry != NULL)) {
2657       shared_entry = entry;
2658       entry = NULL;
2659     }
2660 #endif
2661 
2662     if (entry != NULL) {
2663       return entry;
2664     }
2665 
<span class="line-modified">2666     // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage</span>
<span class="line-removed">2667     int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, false);</span>
<span class="line-removed">2668 </span>
<span class="line-removed">2669     // Make a C heap allocated version of the fingerprint to store in the adapter</span>
2670     fingerprint = new AdapterFingerPrint(total_args_passed, sig_bt);
2671 
2672     // StubRoutines::code2() is initialized after this function can be called. As a result,
2673     // VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated
2674     // prior to StubRoutines::code2() being set. Checks refer to checks generated in an I2C
2675     // stub that ensure that an I2C stub is called from an interpreter frame.
2676     bool contains_all_checks = StubRoutines::code2() != NULL;
2677 
2678     // Create I2C &amp; C2I handlers
2679     BufferBlob* buf = buffer_blob(); // the temporary code buffer in CodeCache
2680     if (buf != NULL) {
2681       CodeBuffer buffer(buf);
2682       short buffer_locs[20];
2683       buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
2684                                              sizeof(buffer_locs)/sizeof(relocInfo));
2685 
2686       MacroAssembler _masm(&amp;buffer);
2687       entry = SharedRuntime::generate_i2c2i_adapters(&amp;_masm,
<span class="line-modified">2688                                                      total_args_passed,</span>
<span class="line-modified">2689                                                      comp_args_on_stack,</span>
<span class="line-removed">2690                                                      sig_bt,</span>
2691                                                      regs,
<span class="line-modified">2692                                                      fingerprint);</span>













2693 #ifdef ASSERT
2694       if (VerifyAdapterSharing) {
2695         if (shared_entry != NULL) {



2696           assert(shared_entry-&gt;compare_code(buf-&gt;code_begin(), buffer.insts_size()), &quot;code must match&quot;);
2697           // Release the one just created and return the original
2698           _adapters-&gt;free_entry(entry);
2699           return shared_entry;
2700         } else  {
2701           entry-&gt;save_code(buf-&gt;code_begin(), buffer.insts_size());
2702         }
2703       }
2704 #endif
2705 
<span class="line-removed">2706       new_adapter = AdapterBlob::create(&amp;buffer);</span>
2707       NOT_PRODUCT(insts_size = buffer.insts_size());
2708     }
2709     if (new_adapter == NULL) {
2710       // CodeCache is full, disable compilation
2711       // Ought to log this but compile log is only per compile thread
2712       // and we&#39;re some non descript Java thread.
2713       return NULL; // Out of CodeCache space
2714     }
2715     entry-&gt;relocate(new_adapter-&gt;content_begin());
2716 #ifndef PRODUCT
2717     // debugging suppport
2718     if (PrintAdapterHandlers || PrintStubCode) {
2719       ttyLocker ttyl;
2720       entry-&gt;print_adapter_on(tty);
2721       tty-&gt;print_cr(&quot;i2c argument handler #%d for: %s %s %s (%d bytes generated)&quot;,
2722                     _adapters-&gt;number_of_entries(), (method-&gt;is_static() ? &quot;static&quot; : &quot;receiver&quot;),
2723                     method-&gt;signature()-&gt;as_C_string(), fingerprint-&gt;as_string(), insts_size);
2724       tty-&gt;print_cr(&quot;c2i argument handler starts at %p&quot;, entry-&gt;get_c2i_entry());
2725       if (Verbose || PrintStubCode) {
2726         address first_pc = entry-&gt;base_address();
</pre>
<hr />
<pre>
2742     char blob_id[256];
2743     jio_snprintf(blob_id,
2744                  sizeof(blob_id),
2745                  &quot;%s(%s)@&quot; PTR_FORMAT,
2746                  new_adapter-&gt;name(),
2747                  fingerprint-&gt;as_string(),
2748                  new_adapter-&gt;content_begin());
2749     Forte::register_stub(blob_id, new_adapter-&gt;content_begin(), new_adapter-&gt;content_end());
2750 
2751     if (JvmtiExport::should_post_dynamic_code_generated()) {
2752       JvmtiExport::post_dynamic_code_generated(blob_id, new_adapter-&gt;content_begin(), new_adapter-&gt;content_end());
2753     }
2754   }
2755   return entry;
2756 }
2757 
2758 address AdapterHandlerEntry::base_address() {
2759   address base = _i2c_entry;
2760   if (base == NULL)  base = _c2i_entry;
2761   assert(base &lt;= _c2i_entry || _c2i_entry == NULL, &quot;&quot;);


2762   assert(base &lt;= _c2i_unverified_entry || _c2i_unverified_entry == NULL, &quot;&quot;);

2763   assert(base &lt;= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == NULL, &quot;&quot;);
2764   return base;
2765 }
2766 
2767 void AdapterHandlerEntry::relocate(address new_base) {
2768   address old_base = base_address();
2769   assert(old_base != NULL, &quot;&quot;);
2770   ptrdiff_t delta = new_base - old_base;
2771   if (_i2c_entry != NULL)
2772     _i2c_entry += delta;
2773   if (_c2i_entry != NULL)
2774     _c2i_entry += delta;




2775   if (_c2i_unverified_entry != NULL)
2776     _c2i_unverified_entry += delta;


2777   if (_c2i_no_clinit_check_entry != NULL)
2778     _c2i_no_clinit_check_entry += delta;
2779   assert(base_address() == new_base, &quot;&quot;);
2780 }
2781 
2782 
2783 void AdapterHandlerEntry::deallocate() {
2784   delete _fingerprint;



2785 #ifdef ASSERT
2786   FREE_C_HEAP_ARRAY(unsigned char, _saved_code);
2787 #endif
2788 }
2789 
2790 
2791 #ifdef ASSERT
2792 // Capture the code before relocation so that it can be compared
2793 // against other versions.  If the code is captured after relocation
2794 // then relative instructions won&#39;t be equivalent.
2795 void AdapterHandlerEntry::save_code(unsigned char* buffer, int length) {
2796   _saved_code = NEW_C_HEAP_ARRAY(unsigned char, length, mtCode);
2797   _saved_code_length = length;
2798   memcpy(_saved_code, buffer, length);
2799 }
2800 
2801 
2802 bool AdapterHandlerEntry::compare_code(unsigned char* buffer, int length) {
2803   if (length != _saved_code_length) {
2804     return false;
</pre>
<hr />
<pre>
2848       double locs_buf[20];
2849       buffer.insts()-&gt;initialize_shared_locs((relocInfo*)locs_buf, sizeof(locs_buf) / sizeof(relocInfo));
2850 #if defined(AARCH64)
2851       // On AArch64 with ZGC and nmethod entry barriers, we need all oops to be
2852       // in the constant pool to ensure ordering between the barrier and oops
2853       // accesses. For native_wrappers we need a constant.
2854       buffer.initialize_consts_size(8);
2855 #endif
2856       MacroAssembler _masm(&amp;buffer);
2857 
2858       // Fill in the signature array, for the calling-convention call.
2859       const int total_args_passed = method-&gt;size_of_parameters();
2860 
2861       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_args_passed);
2862       VMRegPair*   regs = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);
2863       int i=0;
2864       if (!method-&gt;is_static())  // Pass in receiver first
2865         sig_bt[i++] = T_OBJECT;
2866       SignatureStream ss(method-&gt;signature());
2867       for (; !ss.at_return_type(); ss.next()) {
<span class="line-modified">2868         sig_bt[i++] = ss.type();  // Collect remaining bits of signature</span>

2869         if (ss.type() == T_LONG || ss.type() == T_DOUBLE)
2870           sig_bt[i++] = T_VOID;   // Longs &amp; doubles take 2 Java slots
2871       }
2872       assert(i == total_args_passed, &quot;&quot;);
2873       BasicType ret_type = ss.type();
2874 
2875       // Now get the compiled-Java layout as input (or output) arguments.
2876       // NOTE: Stubs for compiled entry points of method handle intrinsics
2877       // are just trampolines so the argument registers must be outgoing ones.
2878       const bool is_outgoing = method-&gt;is_method_handle_intrinsic();
2879       int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, is_outgoing);
2880 
2881       // Generate the compiled-to-native wrapper code
2882       nm = SharedRuntime::generate_native_wrapper(&amp;_masm, method, compile_id, sig_bt, regs, ret_type, critical_entry);
2883 
2884       if (nm != NULL) {
2885         {
2886           MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
2887           if (nm-&gt;make_in_use()) {
2888             method-&gt;set_code(method, nm);
</pre>
<hr />
<pre>
3101   AdapterHandlerTableIterator iter(_adapters);
3102   while (iter.has_next()) {
3103     AdapterHandlerEntry* a = iter.next();
3104     if (b == CodeCache::find_blob(a-&gt;get_i2c_entry())) {
3105       st-&gt;print(&quot;Adapter for signature: &quot;);
3106       a-&gt;print_adapter_on(tty);
3107       return;
3108     }
3109   }
3110   assert(false, &quot;Should have found handler&quot;);
3111 }
3112 
3113 void AdapterHandlerEntry::print_adapter_on(outputStream* st) const {
3114   st-&gt;print(&quot;AHE@&quot; INTPTR_FORMAT &quot;: %s&quot;, p2i(this), fingerprint()-&gt;as_string());
3115   if (get_i2c_entry() != NULL) {
3116     st-&gt;print(&quot; i2c: &quot; INTPTR_FORMAT, p2i(get_i2c_entry()));
3117   }
3118   if (get_c2i_entry() != NULL) {
3119     st-&gt;print(&quot; c2i: &quot; INTPTR_FORMAT, p2i(get_c2i_entry()));
3120   }






3121   if (get_c2i_unverified_entry() != NULL) {
<span class="line-modified">3122     st-&gt;print(&quot; c2iUV: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));</span>



3123   }
3124   if (get_c2i_no_clinit_check_entry() != NULL) {
3125     st-&gt;print(&quot; c2iNCI: &quot; INTPTR_FORMAT, p2i(get_c2i_no_clinit_check_entry()));
3126   }
3127   st-&gt;cr();
3128 }
3129 
3130 #if INCLUDE_CDS
3131 
3132 void CDSAdapterHandlerEntry::init() {
3133   assert(DumpSharedSpaces, &quot;used during dump time only&quot;);
3134   _c2i_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());


3135   _adapter_trampoline = (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*));
3136 };
3137 
3138 #endif // INCLUDE_CDS
3139 
3140 
3141 #ifndef PRODUCT
3142 
3143 void AdapterHandlerLibrary::print_statistics() {
3144   _adapters-&gt;print_statistics();
3145 }
3146 
3147 #endif /* PRODUCT */
3148 
3149 JRT_LEAF(void, SharedRuntime::enable_stack_reserved_zone(JavaThread* thread))
3150   assert(thread-&gt;is_Java_thread(), &quot;Only Java threads have a stack reserved zone&quot;);
3151   if (thread-&gt;stack_reserved_zone_disabled()) {
3152   thread-&gt;enable_stack_reserved_zone();
3153   }
3154   thread-&gt;set_reserved_stack_activation(thread-&gt;stack_base());
</pre>
<hr />
<pre>
3200       break;
3201     } else {
3202       fr = fr.java_sender();
3203     }
3204   }
3205   return activation;
3206 }
3207 
3208 void SharedRuntime::on_slowpath_allocation_exit(JavaThread* thread) {
3209   // After any safepoint, just before going back to compiled code,
3210   // we inform the GC that we will be doing initializing writes to
3211   // this object in the future without emitting card-marks, so
3212   // GC may take any compensating steps.
3213 
3214   oop new_obj = thread-&gt;vm_result();
3215   if (new_obj == NULL) return;
3216 
3217   BarrierSet *bs = BarrierSet::barrier_set();
3218   bs-&gt;on_slowpath_allocation_exit(thread, new_obj);
3219 }














































































































































































































</pre>
</td>
<td>
<hr />
<pre>
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/stringTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/compiledIC.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/compiledMethod.inline.hpp&quot;
  35 #include &quot;code/scopeDesc.hpp&quot;
  36 #include &quot;code/vtableStubs.hpp&quot;
  37 #include &quot;compiler/abstractCompiler.hpp&quot;
  38 #include &quot;compiler/compileBroker.hpp&quot;
  39 #include &quot;compiler/disassembler.hpp&quot;
  40 #include &quot;gc/shared/barrierSet.hpp&quot;
  41 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  42 #include &quot;interpreter/interpreter.hpp&quot;
  43 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  44 #include &quot;jfr/jfrEvents.hpp&quot;
  45 #include &quot;logging/log.hpp&quot;
  46 #include &quot;memory/metaspaceShared.hpp&quot;
<span class="line-added">  47 #include &quot;memory/oopFactory.hpp&quot;</span>
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
<span class="line-added">  50 #include &quot;oops/access.hpp&quot;</span>
<span class="line-added">  51 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  52 #include &quot;oops/klass.hpp&quot;
  53 #include &quot;oops/method.inline.hpp&quot;
  54 #include &quot;oops/objArrayKlass.hpp&quot;
<span class="line-added">  55 #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
  56 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  57 #include &quot;oops/inlineKlass.inline.hpp&quot;</span>
  58 #include &quot;prims/forte.hpp&quot;
  59 #include &quot;prims/jvmtiExport.hpp&quot;
  60 #include &quot;prims/methodHandles.hpp&quot;
  61 #include &quot;prims/nativeLookup.hpp&quot;
  62 #include &quot;runtime/arguments.hpp&quot;
  63 #include &quot;runtime/atomic.hpp&quot;
  64 #include &quot;runtime/biasedLocking.hpp&quot;
  65 #include &quot;runtime/frame.inline.hpp&quot;
  66 #include &quot;runtime/handles.inline.hpp&quot;
  67 #include &quot;runtime/init.hpp&quot;
  68 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  69 #include &quot;runtime/java.hpp&quot;
  70 #include &quot;runtime/javaCalls.hpp&quot;
  71 #include &quot;runtime/sharedRuntime.hpp&quot;
  72 #include &quot;runtime/stubRoutines.hpp&quot;
  73 #include &quot;runtime/synchronizer.hpp&quot;
  74 #include &quot;runtime/vframe.inline.hpp&quot;
  75 #include &quot;runtime/vframeArray.hpp&quot;
  76 #include &quot;utilities/copy.hpp&quot;
  77 #include &quot;utilities/dtrace.hpp&quot;
  78 #include &quot;utilities/events.hpp&quot;
  79 #include &quot;utilities/hashtable.inline.hpp&quot;
  80 #include &quot;utilities/macros.hpp&quot;
  81 #include &quot;utilities/xmlstream.hpp&quot;
  82 #ifdef COMPILER1
  83 #include &quot;c1/c1_Runtime1.hpp&quot;
  84 #endif
  85 
  86 // Shared stub locations
  87 RuntimeStub*        SharedRuntime::_wrong_method_blob;
  88 RuntimeStub*        SharedRuntime::_wrong_method_abstract_blob;
  89 RuntimeStub*        SharedRuntime::_ic_miss_blob;
  90 RuntimeStub*        SharedRuntime::_resolve_opt_virtual_call_blob;
  91 RuntimeStub*        SharedRuntime::_resolve_virtual_call_blob;
  92 RuntimeStub*        SharedRuntime::_resolve_static_call_blob;

  93 
  94 DeoptimizationBlob* SharedRuntime::_deopt_blob;
  95 SafepointBlob*      SharedRuntime::_polling_page_vectors_safepoint_handler_blob;
  96 SafepointBlob*      SharedRuntime::_polling_page_safepoint_handler_blob;
  97 SafepointBlob*      SharedRuntime::_polling_page_return_handler_blob;
  98 
  99 #ifdef COMPILER2
 100 UncommonTrapBlob*   SharedRuntime::_uncommon_trap_blob;
 101 #endif // COMPILER2
 102 
 103 
 104 //----------------------------generate_stubs-----------------------------------
 105 void SharedRuntime::generate_stubs() {
 106   _wrong_method_blob                   = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method),          &quot;wrong_method_stub&quot;);
 107   _wrong_method_abstract_blob          = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_abstract), &quot;wrong_method_abstract_stub&quot;);
 108   _ic_miss_blob                        = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_ic_miss),  &quot;ic_miss_stub&quot;);
 109   _resolve_opt_virtual_call_blob       = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_opt_virtual_call_C),   &quot;resolve_opt_virtual_call&quot;);
 110   _resolve_virtual_call_blob           = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_virtual_call_C),       &quot;resolve_virtual_call&quot;);
 111   _resolve_static_call_blob            = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_static_call_C),        &quot;resolve_static_call&quot;);

 112 
 113 #if COMPILER2_OR_JVMCI
 114   // Vectors are generated only by C2 and JVMCI.
 115   bool support_wide = is_wide_vector(MaxVectorSize);
 116   if (support_wide) {
 117     _polling_page_vectors_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_VECTOR_LOOP);
 118   }
 119 #endif // COMPILER2_OR_JVMCI
 120   _polling_page_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_LOOP);
 121   _polling_page_return_handler_blob    = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_RETURN);
 122 
 123   generate_deopt_blob();
 124 
 125 #ifdef COMPILER2
 126   generate_uncommon_trap_blob();
 127 #endif // COMPILER2
 128 }
 129 
 130 #include &lt;math.h&gt;
 131 
</pre>
<hr />
<pre>
1033   }
1034   return NULL;
1035 }
1036 
1037 // Finds receiver, CallInfo (i.e. receiver method), and calling bytecode
1038 // for a call current in progress, i.e., arguments has been pushed on stack
1039 // but callee has not been invoked yet.  Caller frame must be compiled.
1040 Handle SharedRuntime::find_callee_info_helper(JavaThread* thread,
1041                                               vframeStream&amp; vfst,
1042                                               Bytecodes::Code&amp; bc,
1043                                               CallInfo&amp; callinfo, TRAPS) {
1044   Handle receiver;
1045   Handle nullHandle;  //create a handy null handle for exception returns
1046 
1047   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
1048 
1049   // Find caller and bci from vframe
1050   methodHandle caller(THREAD, vfst.method());
1051   int          bci   = vfst.bci();
1052 
<span class="line-added">1053   // Substitutability test implementation piggy backs on static call resolution</span>
<span class="line-added">1054   Bytecodes::Code code = caller-&gt;java_code_at(bci);</span>
<span class="line-added">1055   if (code == Bytecodes::_if_acmpeq || code == Bytecodes::_if_acmpne) {</span>
<span class="line-added">1056     bc = Bytecodes::_invokestatic;</span>
<span class="line-added">1057     methodHandle attached_method(THREAD, extract_attached_method(vfst));</span>
<span class="line-added">1058     assert(attached_method.not_null(), &quot;must have attached method&quot;);</span>
<span class="line-added">1059     SystemDictionary::ValueBootstrapMethods_klass()-&gt;initialize(CHECK_NH);</span>
<span class="line-added">1060     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, false, CHECK_NH);</span>
<span class="line-added">1061 #ifdef ASSERT</span>
<span class="line-added">1062     Method* is_subst = SystemDictionary::ValueBootstrapMethods_klass()-&gt;find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());</span>
<span class="line-added">1063     assert(callinfo.selected_method() == is_subst, &quot;must be isSubstitutable method&quot;);</span>
<span class="line-added">1064 #endif</span>
<span class="line-added">1065     return receiver;</span>
<span class="line-added">1066   }</span>
<span class="line-added">1067 </span>
1068   Bytecode_invoke bytecode(caller, bci);
1069   int bytecode_index = bytecode.index();
1070   bc = bytecode.invoke_code();
1071 
1072   methodHandle attached_method(THREAD, extract_attached_method(vfst));
1073   if (attached_method.not_null()) {
1074     Method* callee = bytecode.static_target(CHECK_NH);
1075     vmIntrinsics::ID id = callee-&gt;intrinsic_id();
1076     // When VM replaces MH.invokeBasic/linkTo* call with a direct/virtual call,
1077     // it attaches statically resolved method to the call site.
1078     if (MethodHandles::is_signature_polymorphic(id) &amp;&amp;
1079         MethodHandles::is_signature_polymorphic_intrinsic(id)) {
1080       bc = MethodHandles::signature_polymorphic_intrinsic_bytecode(id);
1081 
1082       // Adjust invocation mode according to the attached method.
1083       switch (bc) {
1084         case Bytecodes::_invokevirtual:
1085           if (attached_method-&gt;method_holder()-&gt;is_interface()) {
1086             bc = Bytecodes::_invokeinterface;
1087           }
1088           break;
1089         case Bytecodes::_invokeinterface:
1090           if (!attached_method-&gt;method_holder()-&gt;is_interface()) {
1091             bc = Bytecodes::_invokevirtual;
1092           }
1093           break;
1094         case Bytecodes::_invokehandle:
1095           if (!MethodHandles::is_signature_polymorphic_method(attached_method())) {
1096             bc = attached_method-&gt;is_static() ? Bytecodes::_invokestatic
1097                                               : Bytecodes::_invokevirtual;
1098           }
1099           break;
1100         default:
1101           break;
1102       }
<span class="line-added">1103     } else {</span>
<span class="line-added">1104       assert(attached_method-&gt;has_scalarized_args(), &quot;invalid use of attached method&quot;);</span>
<span class="line-added">1105       if (!attached_method-&gt;method_holder()-&gt;is_inline_klass()) {</span>
<span class="line-added">1106         // Ignore the attached method in this case to not confuse below code</span>
<span class="line-added">1107         attached_method = methodHandle(thread, NULL);</span>
<span class="line-added">1108       }</span>
1109     }
1110   }
1111 
1112   assert(bc != Bytecodes::_illegal, &quot;not initialized&quot;);
1113 
1114   bool has_receiver = bc != Bytecodes::_invokestatic &amp;&amp;
1115                       bc != Bytecodes::_invokedynamic &amp;&amp;
1116                       bc != Bytecodes::_invokehandle;
<span class="line-added">1117   bool check_null_and_abstract = true;</span>
1118 
1119   // Find receiver for non-static call
1120   if (has_receiver) {
1121     // This register map must be update since we need to find the receiver for
1122     // compiled frames. The receiver might be in a register.
1123     RegisterMap reg_map2(thread);
1124     frame stubFrame   = thread-&gt;last_frame();
1125     // Caller-frame is a compiled frame
1126     frame callerFrame = stubFrame.sender(&amp;reg_map2);
<span class="line-added">1127     bool caller_is_c1 = false;</span>
1128 
<span class="line-modified">1129     if (callerFrame.is_compiled_frame() &amp;&amp; !callerFrame.is_deoptimized_frame()) {</span>
<span class="line-modified">1130       caller_is_c1 = callerFrame.cb()-&gt;is_compiled_by_c1();</span>
<span class="line-added">1131     }</span>
<span class="line-added">1132 </span>
<span class="line-added">1133     Method* callee = attached_method();</span>
<span class="line-added">1134     if (callee == NULL) {</span>
<span class="line-added">1135       callee = bytecode.static_target(CHECK_NH);</span>
1136       if (callee == NULL) {
1137         THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
1138       }
1139     }
<span class="line-modified">1140     if (!caller_is_c1 &amp;&amp; callee-&gt;has_scalarized_args() &amp;&amp; callee-&gt;method_holder()-&gt;is_inline_klass() &amp;&amp;</span>
<span class="line-modified">1141         InlineKlass::cast(callee-&gt;method_holder())-&gt;can_be_passed_as_fields()) {</span>
<span class="line-modified">1142       // If the receiver is an inline type that is passed as fields, no oop is available</span>
<span class="line-modified">1143       // Resolve the call without receiver null checking.</span>
<span class="line-modified">1144       assert(attached_method.not_null() &amp;&amp; !attached_method-&gt;is_abstract(), &quot;must have non-abstract attached method&quot;);</span>
<span class="line-modified">1145       if (bc == Bytecodes::_invokeinterface) {</span>
<span class="line-added">1146         bc = Bytecodes::_invokevirtual; // C2 optimistically replaces interface calls by virtual calls</span>
<span class="line-added">1147       }</span>
<span class="line-added">1148       check_null_and_abstract = false;</span>
<span class="line-added">1149     } else {</span>
<span class="line-added">1150       // Retrieve from a compiled argument list</span>
<span class="line-added">1151       receiver = Handle(THREAD, callerFrame.retrieve_receiver(&amp;reg_map2));</span>
<span class="line-added">1152       if (receiver.is_null()) {</span>
<span class="line-added">1153         THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);</span>
<span class="line-added">1154       }</span>
1155     }
1156   }
1157 
1158   // Resolve method
1159   if (attached_method.not_null()) {
1160     // Parameterized by attached method.
<span class="line-modified">1161     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, check_null_and_abstract, CHECK_NH);</span>
1162   } else {
1163     // Parameterized by bytecode.
1164     constantPoolHandle constants(THREAD, caller-&gt;constants());
1165     LinkResolver::resolve_invoke(callinfo, receiver, constants, bytecode_index, bc, CHECK_NH);
1166   }
1167 
1168 #ifdef ASSERT
1169   // Check that the receiver klass is of the right subtype and that it is initialized for virtual calls
<span class="line-modified">1170   if (has_receiver &amp;&amp; check_null_and_abstract) {</span>
1171     assert(receiver.not_null(), &quot;should have thrown exception&quot;);
1172     Klass* receiver_klass = receiver-&gt;klass();
1173     Klass* rk = NULL;
1174     if (attached_method.not_null()) {
1175       // In case there&#39;s resolved method attached, use its holder during the check.
1176       rk = attached_method-&gt;method_holder();
1177     } else {
1178       // Klass is already loaded.
1179       constantPoolHandle constants(THREAD, caller-&gt;constants());
1180       rk = constants-&gt;klass_ref_at(bytecode_index, CHECK_NH);
1181     }
1182     Klass* static_receiver_klass = rk;
1183     assert(receiver_klass-&gt;is_subtype_of(static_receiver_klass),
1184            &quot;actual receiver must be subclass of static receiver klass&quot;);
1185     if (receiver_klass-&gt;is_instance_klass()) {
1186       if (InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized()) {
1187         tty-&gt;print_cr(&quot;ERROR: Klass not yet initialized!!&quot;);
1188         receiver_klass-&gt;print();
1189       }
1190       assert(!InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized(), &quot;receiver_klass must be initialized&quot;);
</pre>
<hr />
<pre>
1209     RegisterMap reg_map(thread, false);
1210     frame fr = thread-&gt;last_frame();
1211     assert(fr.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
1212     fr = fr.sender(&amp;reg_map);
1213     assert(fr.is_entry_frame(), &quot;must be&quot;);
1214     // fr is now pointing to the entry frame.
1215     callee_method = methodHandle(THREAD, fr.entry_frame_call_wrapper()-&gt;callee_method());
1216   } else {
1217     Bytecodes::Code bc;
1218     CallInfo callinfo;
1219     find_callee_info_helper(thread, vfst, bc, callinfo, CHECK_(methodHandle()));
1220     callee_method = methodHandle(THREAD, callinfo.selected_method());
1221   }
1222   assert(callee_method()-&gt;is_method(), &quot;must be&quot;);
1223   return callee_method;
1224 }
1225 
1226 // Resolves a call.
1227 methodHandle SharedRuntime::resolve_helper(JavaThread *thread,
1228                                            bool is_virtual,
<span class="line-modified">1229                                            bool is_optimized,</span>
<span class="line-added">1230                                            bool* caller_is_c1, TRAPS) {</span>
1231   methodHandle callee_method;
<span class="line-modified">1232   callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, caller_is_c1, THREAD);</span>
1233   if (JvmtiExport::can_hotswap_or_post_breakpoint()) {
1234     int retry_count = 0;
1235     while (!HAS_PENDING_EXCEPTION &amp;&amp; callee_method-&gt;is_old() &amp;&amp;
1236            callee_method-&gt;method_holder() != SystemDictionary::Object_klass()) {
1237       // If has a pending exception then there is no need to re-try to
1238       // resolve this method.
1239       // If the method has been redefined, we need to try again.
1240       // Hack: we have no way to update the vtables of arrays, so don&#39;t
1241       // require that java.lang.Object has been updated.
1242 
1243       // It is very unlikely that method is redefined more than 100 times
1244       // in the middle of resolve. If it is looping here more than 100 times
1245       // means then there could be a bug here.
1246       guarantee((retry_count++ &lt; 100),
1247                 &quot;Could not resolve to latest version of redefined method&quot;);
1248       // method is redefined in the middle of resolve so re-try.
<span class="line-modified">1249       callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, caller_is_c1, THREAD);</span>
1250     }
1251   }
1252   return callee_method;
1253 }
1254 
1255 // This fails if resolution required refilling of IC stubs
1256 bool SharedRuntime::resolve_sub_helper_internal(methodHandle callee_method, const frame&amp; caller_frame,
1257                                                 CompiledMethod* caller_nm, bool is_virtual, bool is_optimized,
1258                                                 Handle receiver, CallInfo&amp; call_info, Bytecodes::Code invoke_code, TRAPS) {
1259   StaticCallInfo static_call_info;
1260   CompiledICInfo virtual_call_info;
1261 
1262   // Make sure the callee nmethod does not get deoptimized and removed before
1263   // we are done patching the code.
1264   CompiledMethod* callee = callee_method-&gt;code();
1265 
1266   if (callee != NULL) {
1267     assert(callee-&gt;is_compiled(), &quot;must be nmethod for patching&quot;);
1268   }
1269 
1270   if (callee != NULL &amp;&amp; !callee-&gt;is_in_use()) {
1271     // Patch call site to C2I adapter if callee nmethod is deoptimized or unloaded.
1272     callee = NULL;
1273   }
1274   nmethodLocker nl_callee(callee);
1275 #ifdef ASSERT
1276   address dest_entry_point = callee == NULL ? 0 : callee-&gt;entry_point(); // used below
1277 #endif
1278 
1279   bool is_nmethod = caller_nm-&gt;is_nmethod();
<span class="line-added">1280   bool caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();</span>
1281 
1282   if (is_virtual) {
<span class="line-modified">1283     Klass* receiver_klass = NULL;</span>
<span class="line-added">1284     if (!caller_is_c1 &amp;&amp; callee_method-&gt;has_scalarized_args() &amp;&amp; callee_method-&gt;method_holder()-&gt;is_inline_klass() &amp;&amp;</span>
<span class="line-added">1285         InlineKlass::cast(callee_method-&gt;method_holder())-&gt;can_be_passed_as_fields()) {</span>
<span class="line-added">1286       // If the receiver is an inline type that is passed as fields, no oop is available</span>
<span class="line-added">1287       receiver_klass = callee_method-&gt;method_holder();</span>
<span class="line-added">1288     } else {</span>
<span class="line-added">1289       assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, &quot;sanity check&quot;);</span>
<span class="line-added">1290       receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver-&gt;klass();</span>
<span class="line-added">1291     }</span>
1292     bool static_bound = call_info.resolved_method()-&gt;can_be_statically_bound();
<span class="line-modified">1293     CompiledIC::compute_monomorphic_entry(callee_method, receiver_klass,</span>
<span class="line-modified">1294                      is_optimized, static_bound, is_nmethod, caller_is_c1, virtual_call_info,</span>

1295                      CHECK_false);
1296   } else {
1297     // static call
<span class="line-modified">1298     CompiledStaticCall::compute_entry(callee_method, caller_nm, static_call_info);</span>
1299   }
1300 
1301   // grab lock, check for deoptimization and potentially patch caller
1302   {
1303     CompiledICLocker ml(caller_nm);
1304 
1305     // Lock blocks for safepoint during which both nmethods can change state.
1306 
1307     // Now that we are ready to patch if the Method* was redefined then
1308     // don&#39;t update call site and let the caller retry.
1309     // Don&#39;t update call site if callee nmethod was unloaded or deoptimized.
1310     // Don&#39;t update call site if callee nmethod was replaced by an other nmethod
1311     // which may happen when multiply alive nmethod (tiered compilation)
1312     // will be supported.
1313     if (!callee_method-&gt;is_old() &amp;&amp;
1314         (callee == NULL || (callee-&gt;is_in_use() &amp;&amp; callee_method-&gt;code() == callee))) {
1315       NoSafepointVerifier nsv;
1316 #ifdef ASSERT
1317       // We must not try to patch to jump to an already unloaded method.
1318       if (dest_entry_point != 0) {
</pre>
<hr />
<pre>
1330         }
1331       } else {
1332         if (VM_Version::supports_fast_class_init_checks() &amp;&amp;
1333             invoke_code == Bytecodes::_invokestatic &amp;&amp;
1334             callee_method-&gt;needs_clinit_barrier() &amp;&amp;
1335             callee != NULL &amp;&amp; (callee-&gt;is_compiled_by_jvmci() || callee-&gt;is_aot())) {
1336           return true; // skip patching for JVMCI or AOT code
1337         }
1338         CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_before(caller_frame.pc());
1339         if (ssc-&gt;is_clean()) ssc-&gt;set(static_call_info);
1340       }
1341     }
1342   } // unlock CompiledICLocker
1343   return true;
1344 }
1345 
1346 // Resolves a call.  The compilers generate code for calls that go here
1347 // and are patched with the real destination of the call.
1348 methodHandle SharedRuntime::resolve_sub_helper(JavaThread *thread,
1349                                                bool is_virtual,
<span class="line-modified">1350                                                bool is_optimized,</span>
<span class="line-added">1351                                                bool* caller_is_c1, TRAPS) {</span>
1352 
1353   ResourceMark rm(thread);
1354   RegisterMap cbl_map(thread, false);
1355   frame caller_frame = thread-&gt;last_frame().sender(&amp;cbl_map);
1356 
1357   CodeBlob* caller_cb = caller_frame.cb();
1358   guarantee(caller_cb != NULL &amp;&amp; caller_cb-&gt;is_compiled(), &quot;must be called from compiled method&quot;);
1359   CompiledMethod* caller_nm = caller_cb-&gt;as_compiled_method_or_null();
<span class="line-added">1360   *caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();</span>
1361 
1362   // make sure caller is not getting deoptimized
1363   // and removed before we are done with it.
1364   // CLEANUP - with lazy deopt shouldn&#39;t need this lock
1365   nmethodLocker caller_lock(caller_nm);
1366 
1367   // determine call info &amp; receiver
1368   // note: a) receiver is NULL for static calls
1369   //       b) an exception is thrown if receiver is NULL for non-static calls
1370   CallInfo call_info;
1371   Bytecodes::Code invoke_code = Bytecodes::_illegal;
1372   Handle receiver = find_callee_info(thread, invoke_code,
1373                                      call_info, CHECK_(methodHandle()));
1374   methodHandle callee_method(THREAD, call_info.selected_method());
1375 
1376   assert((!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokestatic ) ||
1377          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokespecial) ||
1378          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokehandle ) ||
1379          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokedynamic) ||
1380          ( is_virtual &amp;&amp; invoke_code != Bytecodes::_invokestatic ), &quot;inconsistent bytecode&quot;);
</pre>
<hr />
<pre>
1442       return callee_method;
1443     } else {
1444       InlineCacheBuffer::refill_ic_stubs();
1445     }
1446   }
1447 
1448 }
1449 
1450 
1451 // Inline caches exist only in compiled code
1452 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_ic_miss(JavaThread* thread))
1453 #ifdef ASSERT
1454   RegisterMap reg_map(thread, false);
1455   frame stub_frame = thread-&gt;last_frame();
1456   assert(stub_frame.is_runtime_frame(), &quot;sanity check&quot;);
1457   frame caller_frame = stub_frame.sender(&amp;reg_map);
1458   assert(!caller_frame.is_interpreted_frame() &amp;&amp; !caller_frame.is_entry_frame(), &quot;unexpected frame&quot;);
1459 #endif /* ASSERT */
1460 
1461   methodHandle callee_method;
<span class="line-added">1462   bool is_optimized = false;</span>
<span class="line-added">1463   bool caller_is_c1 = false;</span>
1464   JRT_BLOCK
<span class="line-modified">1465     callee_method = SharedRuntime::handle_ic_miss_helper(thread, is_optimized, caller_is_c1, CHECK_NULL);</span>
1466     // Return Method* through TLS
1467     thread-&gt;set_vm_result_2(callee_method());
1468   JRT_BLOCK_END
1469   // return compiled code entry point after potential safepoints
<span class="line-modified">1470   return entry_for_handle_wrong_method(callee_method, false, is_optimized, caller_is_c1);</span>

1471 JRT_END
1472 
1473 
1474 // Handle call site that has been made non-entrant
1475 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method(JavaThread* thread))
1476   // 6243940 We might end up in here if the callee is deoptimized
1477   // as we race to call it.  We don&#39;t want to take a safepoint if
1478   // the caller was interpreted because the caller frame will look
1479   // interpreted to the stack walkers and arguments are now
1480   // &quot;compiled&quot; so it is much better to make this transition
1481   // invisible to the stack walking code. The i2c path will
1482   // place the callee method in the callee_target. It is stashed
1483   // there because if we try and find the callee by normal means a
1484   // safepoint is possible and have trouble gc&#39;ing the compiled args.
1485   RegisterMap reg_map(thread, false);
1486   frame stub_frame = thread-&gt;last_frame();
1487   assert(stub_frame.is_runtime_frame(), &quot;sanity check&quot;);
1488   frame caller_frame = stub_frame.sender(&amp;reg_map);
1489 
1490   if (caller_frame.is_interpreted_frame() ||
</pre>
<hr />
<pre>
1493     guarantee(callee != NULL &amp;&amp; callee-&gt;is_method(), &quot;bad handshake&quot;);
1494     thread-&gt;set_vm_result_2(callee);
1495     thread-&gt;set_callee_target(NULL);
1496     if (caller_frame.is_entry_frame() &amp;&amp; VM_Version::supports_fast_class_init_checks()) {
1497       // Bypass class initialization checks in c2i when caller is in native.
1498       // JNI calls to static methods don&#39;t have class initialization checks.
1499       // Fast class initialization checks are present in c2i adapters and call into
1500       // SharedRuntime::handle_wrong_method() on the slow path.
1501       //
1502       // JVM upcalls may land here as well, but there&#39;s a proper check present in
1503       // LinkResolver::resolve_static_call (called from JavaCalls::call_static),
1504       // so bypassing it in c2i adapter is benign.
1505       return callee-&gt;get_c2i_no_clinit_check_entry();
1506     } else {
1507       return callee-&gt;get_c2i_entry();
1508     }
1509   }
1510 
1511   // Must be compiled to compiled path which is safe to stackwalk
1512   methodHandle callee_method;
<span class="line-added">1513   bool is_static_call = false;</span>
<span class="line-added">1514   bool is_optimized = false;</span>
<span class="line-added">1515   bool caller_is_c1 = false;</span>
1516   JRT_BLOCK
1517     // Force resolving of caller (if we called from compiled frame)
<span class="line-modified">1518     callee_method = SharedRuntime::reresolve_call_site(thread, is_static_call, is_optimized, caller_is_c1, CHECK_NULL);</span>
1519     thread-&gt;set_vm_result_2(callee_method());
1520   JRT_BLOCK_END
1521   // return compiled code entry point after potential safepoints
<span class="line-modified">1522   return entry_for_handle_wrong_method(callee_method, is_static_call, is_optimized, caller_is_c1);</span>

1523 JRT_END
1524 
1525 // Handle abstract method call
1526 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_abstract(JavaThread* thread))
1527   // Verbose error message for AbstractMethodError.
1528   // Get the called method from the invoke bytecode.
1529   vframeStream vfst(thread, true);
1530   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
1531   methodHandle caller(thread, vfst.method());
1532   Bytecode_invoke invoke(caller, vfst.bci());
1533   DEBUG_ONLY( invoke.verify(); )
1534 
1535   // Find the compiled caller frame.
1536   RegisterMap reg_map(thread);
1537   frame stubFrame = thread-&gt;last_frame();
1538   assert(stubFrame.is_runtime_frame(), &quot;must be&quot;);
1539   frame callerFrame = stubFrame.sender(&amp;reg_map);
1540   assert(callerFrame.is_compiled_frame(), &quot;must be&quot;);
1541 
1542   // Install exception and return forward entry.
1543   address res = StubRoutines::throw_AbstractMethodError_entry();
1544   JRT_BLOCK
1545     methodHandle callee(thread, invoke.static_target(thread));
1546     if (!callee.is_null()) {
1547       oop recv = callerFrame.retrieve_receiver(&amp;reg_map);
1548       Klass *recv_klass = (recv != NULL) ? recv-&gt;klass() : NULL;
1549       LinkResolver::throw_abstract_method_error(callee, recv_klass, thread);
1550       res = StubRoutines::forward_exception_entry();
1551     }
1552   JRT_BLOCK_END
1553   return res;
1554 JRT_END
1555 
1556 
1557 // resolve a static call and patch code
1558 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_static_call_C(JavaThread *thread ))
1559   methodHandle callee_method;
<span class="line-added">1560   bool caller_is_c1;</span>
1561   JRT_BLOCK
<span class="line-modified">1562     callee_method = SharedRuntime::resolve_helper(thread, false, false, &amp;caller_is_c1, CHECK_NULL);</span>
1563     thread-&gt;set_vm_result_2(callee_method());
1564   JRT_BLOCK_END
1565   // return compiled code entry point after potential safepoints
<span class="line-modified">1566   address entry = caller_is_c1 ?</span>
<span class="line-modified">1567     callee_method-&gt;verified_inline_code_entry() : callee_method-&gt;verified_code_entry();</span>
<span class="line-added">1568   assert(entry != NULL, &quot;Jump to zero!&quot;);</span>
<span class="line-added">1569   return entry;</span>
1570 JRT_END
1571 
1572 
1573 // resolve virtual call and update inline cache to monomorphic
1574 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_virtual_call_C(JavaThread *thread ))
1575   methodHandle callee_method;
<span class="line-added">1576   bool caller_is_c1;</span>
1577   JRT_BLOCK
<span class="line-modified">1578     callee_method = SharedRuntime::resolve_helper(thread, true, false, &amp;caller_is_c1, CHECK_NULL);</span>
1579     thread-&gt;set_vm_result_2(callee_method());
1580   JRT_BLOCK_END
1581   // return compiled code entry point after potential safepoints
<span class="line-modified">1582   address entry = caller_is_c1 ?</span>
<span class="line-modified">1583     callee_method-&gt;verified_inline_code_entry() : callee_method-&gt;verified_inline_ro_code_entry();</span>
<span class="line-added">1584   assert(entry != NULL, &quot;Jump to zero!&quot;);</span>
<span class="line-added">1585   return entry;</span>
1586 JRT_END
1587 
1588 
1589 // Resolve a virtual call that can be statically bound (e.g., always
1590 // monomorphic, so it has no inline cache).  Patch code to resolved target.
1591 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_opt_virtual_call_C(JavaThread *thread))
1592   methodHandle callee_method;
<span class="line-added">1593   bool caller_is_c1;</span>
1594   JRT_BLOCK
<span class="line-modified">1595     callee_method = SharedRuntime::resolve_helper(thread, true, true, &amp;caller_is_c1, CHECK_NULL);</span>
1596     thread-&gt;set_vm_result_2(callee_method());
1597   JRT_BLOCK_END
1598   // return compiled code entry point after potential safepoints
<span class="line-modified">1599   address entry = caller_is_c1 ?</span>
<span class="line-modified">1600     callee_method-&gt;verified_inline_code_entry() : callee_method-&gt;verified_code_entry();</span>
<span class="line-added">1601   assert(entry != NULL, &quot;Jump to zero!&quot;);</span>
<span class="line-added">1602   return entry;</span>
1603 JRT_END
1604 
1605 // The handle_ic_miss_helper_internal function returns false if it failed due
1606 // to either running out of vtable stubs or ic stubs due to IC transitions
1607 // to transitional states. The needs_ic_stub_refill value will be set if
1608 // the failure was due to running out of IC stubs, in which case handle_ic_miss_helper
1609 // refills the IC stubs and tries again.
1610 bool SharedRuntime::handle_ic_miss_helper_internal(Handle receiver, CompiledMethod* caller_nm,
1611                                                    const frame&amp; caller_frame, methodHandle callee_method,
1612                                                    Bytecodes::Code bc, CallInfo&amp; call_info,
<span class="line-modified">1613                                                    bool&amp; needs_ic_stub_refill, bool&amp; is_optimized, bool caller_is_c1, TRAPS) {</span>
1614   CompiledICLocker ml(caller_nm);
1615   CompiledIC* inline_cache = CompiledIC_before(caller_nm, caller_frame.pc());
1616   bool should_be_mono = false;
1617   if (inline_cache-&gt;is_optimized()) {
1618     if (TraceCallFixup) {
1619       ResourceMark rm(THREAD);
1620       tty-&gt;print(&quot;OPTIMIZED IC miss (%s) call to&quot;, Bytecodes::name(bc));
1621       callee_method-&gt;print_short_name(tty);
1622       tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1623     }
<span class="line-added">1624     is_optimized = true;</span>
1625     should_be_mono = true;
1626   } else if (inline_cache-&gt;is_icholder_call()) {
1627     CompiledICHolder* ic_oop = inline_cache-&gt;cached_icholder();
1628     if (ic_oop != NULL) {
1629       if (!ic_oop-&gt;is_loader_alive()) {
1630         // Deferred IC cleaning due to concurrent class unloading
1631         if (!inline_cache-&gt;set_to_clean()) {
1632           needs_ic_stub_refill = true;
1633           return false;
1634         }
1635       } else if (receiver()-&gt;klass() == ic_oop-&gt;holder_klass()) {
1636         // This isn&#39;t a real miss. We must have seen that compiled code
1637         // is now available and we want the call site converted to a
1638         // monomorphic compiled call site.
1639         // We can&#39;t assert for callee_method-&gt;code() != NULL because it
1640         // could have been deoptimized in the meantime
1641         if (TraceCallFixup) {
1642           ResourceMark rm(THREAD);
1643           tty-&gt;print(&quot;FALSE IC miss (%s) converting to compiled call to&quot;, Bytecodes::name(bc));
1644           callee_method-&gt;print_short_name(tty);
1645           tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1646         }
1647         should_be_mono = true;
1648       }
1649     }
1650   }
1651 
1652   if (should_be_mono) {
1653     // We have a path that was monomorphic but was going interpreted
1654     // and now we have (or had) a compiled entry. We correct the IC
1655     // by using a new icBuffer.
1656     CompiledICInfo info;
1657     Klass* receiver_klass = receiver()-&gt;klass();
1658     inline_cache-&gt;compute_monomorphic_entry(callee_method,
1659                                             receiver_klass,
1660                                             inline_cache-&gt;is_optimized(),
1661                                             false, caller_nm-&gt;is_nmethod(),
<span class="line-added">1662                                             caller_nm-&gt;is_compiled_by_c1(),</span>
1663                                             info, CHECK_false);
1664     if (!inline_cache-&gt;set_to_monomorphic(info)) {
1665       needs_ic_stub_refill = true;
1666       return false;
1667     }
1668   } else if (!inline_cache-&gt;is_megamorphic() &amp;&amp; !inline_cache-&gt;is_clean()) {
1669     // Potential change to megamorphic
1670 
<span class="line-modified">1671     bool successful = inline_cache-&gt;set_to_megamorphic(&amp;call_info, bc, needs_ic_stub_refill, caller_is_c1, CHECK_false);</span>
1672     if (needs_ic_stub_refill) {
1673       return false;
1674     }
1675     if (!successful) {
1676       if (!inline_cache-&gt;set_to_clean()) {
1677         needs_ic_stub_refill = true;
1678         return false;
1679       }
1680     }
1681   } else {
1682     // Either clean or megamorphic
1683   }
1684   return true;
1685 }
1686 
<span class="line-modified">1687 methodHandle SharedRuntime::handle_ic_miss_helper(JavaThread *thread, bool&amp; is_optimized, bool&amp; caller_is_c1, TRAPS) {</span>
1688   ResourceMark rm(thread);
1689   CallInfo call_info;
1690   Bytecodes::Code bc;
1691 
1692   // receiver is NULL for static calls. An exception is thrown for NULL
1693   // receivers for non-static calls
1694   Handle receiver = find_callee_info(thread, bc, call_info,
1695                                      CHECK_(methodHandle()));
1696   // Compiler1 can produce virtual call sites that can actually be statically bound
1697   // If we fell thru to below we would think that the site was going megamorphic
1698   // when in fact the site can never miss. Worse because we&#39;d think it was megamorphic
1699   // we&#39;d try and do a vtable dispatch however methods that can be statically bound
1700   // don&#39;t have vtable entries (vtable_index &lt; 0) and we&#39;d blow up. So we force a
1701   // reresolution of the  call site (as if we did a handle_wrong_method and not an
1702   // plain ic_miss) and the site will be converted to an optimized virtual call site
1703   // never to miss again. I don&#39;t believe C2 will produce code like this but if it
1704   // did this would still be the correct thing to do for it too, hence no ifdef.
1705   //
1706   if (call_info.resolved_method()-&gt;can_be_statically_bound()) {
<span class="line-modified">1707     bool is_static_call = false;</span>
<span class="line-added">1708     methodHandle callee_method = SharedRuntime::reresolve_call_site(thread, is_static_call, is_optimized, caller_is_c1, CHECK_(methodHandle()));</span>
<span class="line-added">1709     assert(!is_static_call, &quot;IC miss at static call?&quot;);</span>
1710     if (TraceCallFixup) {
1711       RegisterMap reg_map(thread, false);
1712       frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
1713       ResourceMark rm(thread);
1714       tty-&gt;print(&quot;converting IC miss to reresolve (%s) call to&quot;, Bytecodes::name(bc));
1715       callee_method-&gt;print_short_name(tty);
1716       tty-&gt;print_cr(&quot; from pc: &quot; INTPTR_FORMAT, p2i(caller_frame.pc()));
1717       tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1718     }
1719     return callee_method;
1720   }
1721 
1722   methodHandle callee_method(thread, call_info.selected_method());
1723 
1724 #ifndef PRODUCT
1725   Atomic::inc(&amp;_ic_miss_ctr);
1726 
1727   // Statistics &amp; Tracing
1728   if (TraceCallFixup) {
1729     ResourceMark rm(thread);
</pre>
<hr />
<pre>
1739     // produce statistics under the lock
1740     trace_ic_miss(f.pc());
1741   }
1742 #endif
1743 
1744   // install an event collector so that when a vtable stub is created the
1745   // profiler can be notified via a DYNAMIC_CODE_GENERATED event. The
1746   // event can&#39;t be posted when the stub is created as locks are held
1747   // - instead the event will be deferred until the event collector goes
1748   // out of scope.
1749   JvmtiDynamicCodeEventCollector event_collector;
1750 
1751   // Update inline cache to megamorphic. Skip update if we are called from interpreted.
1752   // Transitioning IC caches may require transition stubs. If we run out
1753   // of transition stubs, we have to drop locks and perform a safepoint
1754   // that refills them.
1755   RegisterMap reg_map(thread, false);
1756   frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
1757   CodeBlob* cb = caller_frame.cb();
1758   CompiledMethod* caller_nm = cb-&gt;as_compiled_method();
<span class="line-added">1759   caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();</span>
1760 
1761   for (;;) {
1762     ICRefillVerifier ic_refill_verifier;
1763     bool needs_ic_stub_refill = false;
1764     bool successful = handle_ic_miss_helper_internal(receiver, caller_nm, caller_frame, callee_method,
<span class="line-modified">1765                                                      bc, call_info, needs_ic_stub_refill, is_optimized, caller_is_c1, CHECK_(methodHandle()));</span>
1766     if (successful || !needs_ic_stub_refill) {
1767       return callee_method;
1768     } else {
1769       InlineCacheBuffer::refill_ic_stubs();
1770     }
1771   }
1772 }
1773 
1774 static bool clear_ic_at_addr(CompiledMethod* caller_nm, address call_addr, bool is_static_call) {
1775   CompiledICLocker ml(caller_nm);
1776   if (is_static_call) {
1777     CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_at(call_addr);
1778     if (!ssc-&gt;is_clean()) {
1779       return ssc-&gt;set_to_clean();
1780     }
1781   } else {
1782     // compiled, dispatched call (which used to call an interpreted method)
1783     CompiledIC* inline_cache = CompiledIC_at(caller_nm, call_addr);
1784     if (!inline_cache-&gt;is_clean()) {
1785       return inline_cache-&gt;set_to_clean();
1786     }
1787   }
1788   return true;
1789 }
1790 
1791 //
1792 // Resets a call-site in compiled code so it will get resolved again.
1793 // This routines handles both virtual call sites, optimized virtual call
1794 // sites, and static call sites. Typically used to change a call sites
1795 // destination from compiled to interpreted.
1796 //
<span class="line-modified">1797 methodHandle SharedRuntime::reresolve_call_site(JavaThread *thread, bool&amp; is_static_call, bool&amp; is_optimized, bool&amp; caller_is_c1, TRAPS) {</span>
1798   ResourceMark rm(thread);
1799   RegisterMap reg_map(thread, false);
1800   frame stub_frame = thread-&gt;last_frame();
1801   assert(stub_frame.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
1802   frame caller = stub_frame.sender(&amp;reg_map);
1803 
1804   // Do nothing if the frame isn&#39;t a live compiled frame.
1805   // nmethod could be deoptimized by the time we get here
1806   // so no update to the caller is needed.
1807 
1808   if (caller.is_compiled_frame() &amp;&amp; !caller.is_deoptimized_frame()) {
1809 
1810     address pc = caller.pc();
1811 
1812     // Check for static or virtual call
<span class="line-modified">1813     CompiledMethod* caller_nm = CodeCache::find_compiled(pc);</span>
1814     caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();
1815 
1816     // Default call_addr is the location of the &quot;basic&quot; call.
1817     // Determine the address of the call we a reresolving. With
1818     // Inline Caches we will always find a recognizable call.
1819     // With Inline Caches disabled we may or may not find a
1820     // recognizable call. We will always find a call for static
1821     // calls and for optimized virtual calls. For vanilla virtual
1822     // calls it depends on the state of the UseInlineCaches switch.
1823     //
1824     // With Inline Caches disabled we can get here for a virtual call
1825     // for two reasons:
1826     //   1 - calling an abstract method. The vtable for abstract methods
1827     //       will run us thru handle_wrong_method and we will eventually
1828     //       end up in the interpreter to throw the ame.
1829     //   2 - a racing deoptimization. We could be doing a vanilla vtable
1830     //       call and between the time we fetch the entry address and
1831     //       we jump to it the target gets deoptimized. Similar to 1
1832     //       we will wind up in the interprter (thru a c2i with c2).
1833     //
</pre>
<hr />
<pre>
1838       CompiledICLocker ml(caller_nm);
1839       // Location of call instruction
1840       call_addr = caller_nm-&gt;call_instruction_address(pc);
1841     }
1842     // Make sure nmethod doesn&#39;t get deoptimized and removed until
1843     // this is done with it.
1844     // CLEANUP - with lazy deopt shouldn&#39;t need this lock
1845     nmethodLocker nmlock(caller_nm);
1846 
1847     if (call_addr != NULL) {
1848       RelocIterator iter(caller_nm, call_addr, call_addr+1);
1849       int ret = iter.next(); // Get item
1850       if (ret) {
1851         assert(iter.addr() == call_addr, &quot;must find call&quot;);
1852         if (iter.type() == relocInfo::static_call_type) {
1853           is_static_call = true;
1854         } else {
1855           assert(iter.type() == relocInfo::virtual_call_type ||
1856                  iter.type() == relocInfo::opt_virtual_call_type
1857                 , &quot;unexpected relocInfo. type&quot;);
<span class="line-added">1858           is_optimized = (iter.type() == relocInfo::opt_virtual_call_type);</span>
1859         }
1860       } else {
1861         assert(!UseInlineCaches, &quot;relocation info. must exist for this address&quot;);
1862       }
1863 
1864       // Cleaning the inline cache will force a new resolve. This is more robust
1865       // than directly setting it to the new destination, since resolving of calls
1866       // is always done through the same code path. (experience shows that it
1867       // leads to very hard to track down bugs, if an inline cache gets updated
1868       // to a wrong method). It should not be performance critical, since the
1869       // resolve is only done once.
1870 
1871       for (;;) {
1872         ICRefillVerifier ic_refill_verifier;
1873         if (!clear_ic_at_addr(caller_nm, call_addr, is_static_call)) {
1874           InlineCacheBuffer::refill_ic_stubs();
1875         } else {
1876           break;
1877         }
1878       }
1879     }
1880   }
1881 
1882   methodHandle callee_method = find_callee_method(thread, CHECK_(methodHandle()));
1883 

1884 #ifndef PRODUCT
1885   Atomic::inc(&amp;_wrong_method_ctr);
1886 
1887   if (TraceCallFixup) {
1888     ResourceMark rm(thread);
1889     tty-&gt;print(&quot;handle_wrong_method reresolving call to&quot;);
1890     callee_method-&gt;print_short_name(tty);
1891     tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1892   }
1893 #endif
1894 
1895   return callee_method;
1896 }
1897 
1898 address SharedRuntime::handle_unsafe_access(JavaThread* thread, address next_pc) {
1899   // The faulting unsafe accesses should be changed to throw the error
1900   // synchronously instead. Meanwhile the faulting instruction will be
1901   // skipped over (effectively turning it into a no-op) and an
1902   // asynchronous exception will be raised which the thread will
1903   // handle at a later point. If the instruction is a load it will
</pre>
<hr />
<pre>
1958     }
1959   } else {
1960     if (TraceCallFixup) {
1961       tty-&gt;print(&quot;already patched callsite at &quot; INTPTR_FORMAT &quot; to compiled code for&quot;, p2i(caller_pc));
1962       moop-&gt;print_short_name(tty);
1963       tty-&gt;print_cr(&quot; to &quot; INTPTR_FORMAT, p2i(entry_point));
1964     }
1965   }
1966   return false;
1967 }
1968 
1969 // ---------------------------------------------------------------------------
1970 // We are calling the interpreter via a c2i. Normally this would mean that
1971 // we were called by a compiled method. However we could have lost a race
1972 // where we went int -&gt; i2c -&gt; c2i and so the caller could in fact be
1973 // interpreted. If the caller is compiled we attempt to patch the caller
1974 // so he no longer calls into the interpreter.
1975 JRT_LEAF(void, SharedRuntime::fixup_callers_callsite(Method* method, address caller_pc))
1976   Method* moop(method);
1977 


1978   // It&#39;s possible that deoptimization can occur at a call site which hasn&#39;t
1979   // been resolved yet, in which case this function will be called from
1980   // an nmethod that has been patched for deopt and we can ignore the
1981   // request for a fixup.
1982   // Also it is possible that we lost a race in that from_compiled_entry
1983   // is now back to the i2c in that case we don&#39;t need to patch and if
1984   // we did we&#39;d leap into space because the callsite needs to use
1985   // &quot;to interpreter&quot; stub in order to load up the Method*. Don&#39;t
1986   // ask me how I know this...
1987 
1988   CodeBlob* cb = CodeCache::find_blob(caller_pc);
<span class="line-modified">1989   if (cb == NULL || !cb-&gt;is_compiled()) {</span>
<span class="line-added">1990     return;</span>
<span class="line-added">1991   }</span>
<span class="line-added">1992   address entry_point = moop-&gt;from_compiled_entry_no_trampoline(cb-&gt;is_compiled_by_c1());</span>
<span class="line-added">1993   if (entry_point == moop-&gt;get_c2i_entry()) {</span>
1994     return;
1995   }
1996 
1997   // The check above makes sure this is a nmethod.
1998   CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
1999   assert(nm, &quot;must be&quot;);
2000 
2001   // Get the return PC for the passed caller PC.
2002   address return_pc = caller_pc + frame::pc_return_offset;
2003 
2004   // There is a benign race here. We could be attempting to patch to a compiled
2005   // entry point at the same time the callee is being deoptimized. If that is
2006   // the case then entry_point may in fact point to a c2i and we&#39;d patch the
2007   // call site with the same old data. clear_code will set code() to NULL
2008   // at the end of it. If we happen to see that NULL then we can skip trying
2009   // to patch. If we hit the window where the callee has a c2i in the
2010   // from_compiled_entry and the NULL isn&#39;t present yet then we lose the race
2011   // and patch the code with the same old data. Asi es la vida.
2012 
2013   if (moop-&gt;code() == NULL) return;
</pre>
<hr />
<pre>
2334  private:
2335   enum {
2336     _basic_type_bits = 4,
2337     _basic_type_mask = right_n_bits(_basic_type_bits),
2338     _basic_types_per_int = BitsPerInt / _basic_type_bits,
2339     _compact_int_count = 3
2340   };
2341   // TO DO:  Consider integrating this with a more global scheme for compressing signatures.
2342   // For now, 4 bits per components (plus T_VOID gaps after double/long) is not excessive.
2343 
2344   union {
2345     int  _compact[_compact_int_count];
2346     int* _fingerprint;
2347   } _value;
2348   int _length; // A negative length indicates the fingerprint is in the compact form,
2349                // Otherwise _value._fingerprint is the array.
2350 
2351   // Remap BasicTypes that are handled equivalently by the adapters.
2352   // These are correct for the current system but someday it might be
2353   // necessary to make this mapping platform dependent.
<span class="line-modified">2354   static int adapter_encoding(BasicType in, bool is_inlinetype) {</span>
2355     switch (in) {
2356       case T_BOOLEAN:
2357       case T_BYTE:
2358       case T_SHORT:
<span class="line-modified">2359       case T_CHAR: {</span>
<span class="line-modified">2360         if (is_inlinetype) {</span>
<span class="line-modified">2361           // Do not widen inline type field types</span>
<span class="line-added">2362           assert(InlineTypePassFieldsAsArgs, &quot;must be enabled&quot;);</span>
<span class="line-added">2363           return in;</span>
<span class="line-added">2364         } else {</span>
<span class="line-added">2365           // They are all promoted to T_INT in the calling convention</span>
<span class="line-added">2366           return T_INT;</span>
<span class="line-added">2367         }</span>
<span class="line-added">2368       }</span>
<span class="line-added">2369 </span>
<span class="line-added">2370       case T_INLINE_TYPE: {</span>
<span class="line-added">2371         // If inline types are passed as fields, return &#39;in&#39; to differentiate</span>
<span class="line-added">2372         // between a T_INLINE_TYPE and a T_OBJECT in the signature.</span>
<span class="line-added">2373         return InlineTypePassFieldsAsArgs ? in : adapter_encoding(T_OBJECT, false);</span>
<span class="line-added">2374       }</span>
2375 
2376       case T_OBJECT:
2377       case T_ARRAY:
2378         // In other words, we assume that any register good enough for
2379         // an int or long is good enough for a managed pointer.
2380 #ifdef _LP64
2381         return T_LONG;
2382 #else
2383         return T_INT;
2384 #endif
2385 
2386       case T_INT:
2387       case T_LONG:
2388       case T_FLOAT:
2389       case T_DOUBLE:
2390       case T_VOID:
2391         return in;
2392 
2393       default:
2394         ShouldNotReachHere();
2395         return T_CONFLICT;
2396     }
2397   }
2398 
2399  public:
<span class="line-modified">2400   AdapterFingerPrint(const GrowableArray&lt;SigEntry&gt;* sig, bool has_ro_adapter = false) {</span>
2401     // The fingerprint is based on the BasicType signature encoded
2402     // into an array of ints with eight entries per int.
<span class="line-added">2403     int total_args_passed = (sig != NULL) ? sig-&gt;length() : 0;</span>
2404     int* ptr;
2405     int len = (total_args_passed + (_basic_types_per_int-1)) / _basic_types_per_int;
2406     if (len &lt;= _compact_int_count) {
2407       assert(_compact_int_count == 3, &quot;else change next line&quot;);
2408       _value._compact[0] = _value._compact[1] = _value._compact[2] = 0;
2409       // Storing the signature encoded as signed chars hits about 98%
2410       // of the time.
2411       _length = -len;
2412       ptr = _value._compact;
2413     } else {
2414       _length = len;
2415       _value._fingerprint = NEW_C_HEAP_ARRAY(int, _length, mtCode);
2416       ptr = _value._fingerprint;
2417     }
2418 
2419     // Now pack the BasicTypes with 8 per int
2420     int sig_index = 0;
<span class="line-added">2421     BasicType prev_sbt = T_ILLEGAL;</span>
<span class="line-added">2422     int vt_count = 0;</span>
2423     for (int index = 0; index &lt; len; index++) {
2424       int value = 0;
2425       for (int byte = 0; byte &lt; _basic_types_per_int; byte++) {
<span class="line-modified">2426         int bt = 0;</span>
<span class="line-modified">2427         if (sig_index &lt; total_args_passed) {</span>
<span class="line-modified">2428           BasicType sbt = sig-&gt;at(sig_index++)._bt;</span>
<span class="line-added">2429           if (InlineTypePassFieldsAsArgs &amp;&amp; sbt == T_INLINE_TYPE) {</span>
<span class="line-added">2430             // Found start of inline type in signature</span>
<span class="line-added">2431             vt_count++;</span>
<span class="line-added">2432             if (sig_index == 1 &amp;&amp; has_ro_adapter) {</span>
<span class="line-added">2433               // With a ro_adapter, replace receiver inline type delimiter by T_VOID to prevent matching</span>
<span class="line-added">2434               // with other adapters that have the same inline type as first argument and no receiver.</span>
<span class="line-added">2435               sbt = T_VOID;</span>
<span class="line-added">2436             }</span>
<span class="line-added">2437           } else if (InlineTypePassFieldsAsArgs &amp;&amp; sbt == T_VOID &amp;&amp;</span>
<span class="line-added">2438                      prev_sbt != T_LONG &amp;&amp; prev_sbt != T_DOUBLE) {</span>
<span class="line-added">2439             // Found end of inline type in signature</span>
<span class="line-added">2440             vt_count--;</span>
<span class="line-added">2441             assert(vt_count &gt;= 0, &quot;invalid vt_count&quot;);</span>
<span class="line-added">2442           }</span>
<span class="line-added">2443           bt = adapter_encoding(sbt, vt_count &gt; 0);</span>
<span class="line-added">2444           prev_sbt = sbt;</span>
<span class="line-added">2445         }</span>
2446         assert((bt &amp; _basic_type_mask) == bt, &quot;must fit in 4 bits&quot;);
2447         value = (value &lt;&lt; _basic_type_bits) | bt;
2448       }
2449       ptr[index] = value;
2450     }
<span class="line-added">2451     assert(vt_count == 0, &quot;invalid vt_count&quot;);</span>
2452   }
2453 
2454   ~AdapterFingerPrint() {
2455     if (_length &gt; 0) {
2456       FREE_C_HEAP_ARRAY(int, _value._fingerprint);
2457     }
2458   }
2459 
2460   int value(int index) {
2461     if (_length &lt; 0) {
2462       return _value._compact[index];
2463     }
2464     return _value._fingerprint[index];
2465   }
2466   int length() {
2467     if (_length &lt; 0) return -_length;
2468     return _length;
2469   }
2470 
2471   bool is_compact() {
</pre>
<hr />
<pre>
2517 
2518  private:
2519 
2520 #ifndef PRODUCT
2521   static int _lookups; // number of calls to lookup
2522   static int _buckets; // number of buckets checked
2523   static int _equals;  // number of buckets checked with matching hash
2524   static int _hits;    // number of successful lookups
2525   static int _compact; // number of equals calls with compact signature
2526 #endif
2527 
2528   AdapterHandlerEntry* bucket(int i) {
2529     return (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::bucket(i);
2530   }
2531 
2532  public:
2533   AdapterHandlerTable()
2534     : BasicHashtable&lt;mtCode&gt;(293, (DumpSharedSpaces ? sizeof(CDSAdapterHandlerEntry) : sizeof(AdapterHandlerEntry))) { }
2535 
2536   // Create a new entry suitable for insertion in the table
<span class="line-modified">2537   AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry,</span>
<span class="line-added">2538                                  address c2i_inline_entry, address c2i_inline_ro_entry,</span>
<span class="line-added">2539                                  address c2i_unverified_entry, address c2i_unverified_inline_entry, address c2i_no_clinit_check_entry) {</span>
2540     AdapterHandlerEntry* entry = (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::new_entry(fingerprint-&gt;compute_hash());
<span class="line-modified">2541     entry-&gt;init(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry,</span>
<span class="line-added">2542                 c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);</span>
2543     if (DumpSharedSpaces) {
2544       ((CDSAdapterHandlerEntry*)entry)-&gt;init();
2545     }
2546     return entry;
2547   }
2548 
2549   // Insert an entry into the table
2550   void add(AdapterHandlerEntry* entry) {
2551     int index = hash_to_index(entry-&gt;hash());
2552     add_entry(index, entry);
2553   }
2554 
2555   void free_entry(AdapterHandlerEntry* entry) {
2556     entry-&gt;deallocate();
2557     BasicHashtable&lt;mtCode&gt;::free_entry(entry);
2558   }
2559 
2560   // Find a entry with the same fingerprint if it exists
<span class="line-modified">2561   AdapterHandlerEntry* lookup(const GrowableArray&lt;SigEntry&gt;* sig, bool has_ro_adapter = false) {</span>
2562     NOT_PRODUCT(_lookups++);
<span class="line-modified">2563     AdapterFingerPrint fp(sig, has_ro_adapter);</span>
2564     unsigned int hash = fp.compute_hash();
2565     int index = hash_to_index(hash);
2566     for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e-&gt;next()) {
2567       NOT_PRODUCT(_buckets++);
2568       if (e-&gt;hash() == hash) {
2569         NOT_PRODUCT(_equals++);
2570         if (fp.equals(e-&gt;fingerprint())) {
2571 #ifndef PRODUCT
2572           if (fp.is_compact()) _compact++;
2573           _hits++;
2574 #endif
2575           return e;
2576         }
2577       }
2578     }
2579     return NULL;
2580   }
2581 
2582 #ifndef PRODUCT
2583   void print_statistics() {
</pre>
<hr />
<pre>
2639   bool has_next() {
2640     return _current != NULL;
2641   }
2642   AdapterHandlerEntry* next() {
2643     if (_current != NULL) {
2644       AdapterHandlerEntry* result = _current;
2645       _current = _current-&gt;next();
2646       if (_current == NULL) scan();
2647       return result;
2648     } else {
2649       return NULL;
2650     }
2651   }
2652 };
2653 
2654 
2655 // ---------------------------------------------------------------------------
2656 // Implementation of AdapterHandlerLibrary
2657 AdapterHandlerTable* AdapterHandlerLibrary::_adapters = NULL;
2658 AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = NULL;
<span class="line-modified">2659 const int AdapterHandlerLibrary_size = 32*K;</span>
2660 BufferBlob* AdapterHandlerLibrary::_buffer = NULL;
2661 
2662 BufferBlob* AdapterHandlerLibrary::buffer_blob() {
2663   // Should be called only when AdapterHandlerLibrary_lock is active.
2664   if (_buffer == NULL) // Initialize lazily
2665       _buffer = BufferBlob::create(&quot;adapters&quot;, AdapterHandlerLibrary_size);
2666   return _buffer;
2667 }
2668 
2669 extern &quot;C&quot; void unexpected_adapter_call() {
2670   ShouldNotCallThis();
2671 }
2672 
2673 void AdapterHandlerLibrary::initialize() {
2674   if (_adapters != NULL) return;
2675   _adapters = new AdapterHandlerTable();
2676 
2677   // Create a special handler for abstract methods.  Abstract methods
2678   // are never compiled so an i2c entry is somewhat meaningless, but
2679   // throw AbstractMethodError just in case.
2680   // Pass wrong_method_abstract for the c2i transitions to return
2681   // AbstractMethodError for invalid invocations.
2682   address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();
<span class="line-modified">2683   _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),</span>
2684                                                               StubRoutines::throw_AbstractMethodError_entry(),
<span class="line-added">2685                                                               wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,</span>
2686                                                               wrong_method_abstract, wrong_method_abstract);
2687 }
2688 
2689 AdapterHandlerEntry* AdapterHandlerLibrary::new_entry(AdapterFingerPrint* fingerprint,
2690                                                       address i2c_entry,
2691                                                       address c2i_entry,
<span class="line-added">2692                                                       address c2i_inline_entry,</span>
<span class="line-added">2693                                                       address c2i_inline_ro_entry,</span>
2694                                                       address c2i_unverified_entry,
<span class="line-added">2695                                                       address c2i_unverified_inline_entry,</span>
2696                                                       address c2i_no_clinit_check_entry) {
<span class="line-modified">2697   return _adapters-&gt;new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry,</span>
<span class="line-added">2698                               c2i_unverified_inline_entry, c2i_no_clinit_check_entry);</span>
<span class="line-added">2699 }</span>
<span class="line-added">2700 </span>
<span class="line-added">2701 static void generate_trampoline(address trampoline, address destination) {</span>
<span class="line-added">2702   if (*(int*)trampoline == 0) {</span>
<span class="line-added">2703     CodeBuffer buffer(trampoline, (int)SharedRuntime::trampoline_size());</span>
<span class="line-added">2704     MacroAssembler _masm(&amp;buffer);</span>
<span class="line-added">2705     SharedRuntime::generate_trampoline(&amp;_masm, destination);</span>
<span class="line-added">2706     assert(*(int*)trampoline != 0, &quot;Instruction(s) for trampoline must not be encoded as zeros.&quot;);</span>
<span class="line-added">2707       _masm.flush();</span>
<span class="line-added">2708 </span>
<span class="line-added">2709     if (PrintInterpreter) {</span>
<span class="line-added">2710       Disassembler::decode(buffer.insts_begin(), buffer.insts_end());</span>
<span class="line-added">2711     }</span>
<span class="line-added">2712   }</span>
2713 }
2714 
2715 AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter(const methodHandle&amp; method) {
2716   AdapterHandlerEntry* entry = get_adapter0(method);
2717   if (entry != NULL &amp;&amp; method-&gt;is_shared()) {
2718     // See comments around Method::link_method()
2719     MutexLocker mu(AdapterHandlerLibrary_lock);
2720     if (method-&gt;adapter() == NULL) {
2721       method-&gt;update_adapter_trampoline(entry);
2722     }
<span class="line-modified">2723     generate_trampoline(method-&gt;from_compiled_entry(),           entry-&gt;get_c2i_entry());</span>
<span class="line-modified">2724     generate_trampoline(method-&gt;from_compiled_inline_ro_entry(), entry-&gt;get_c2i_inline_ro_entry());</span>
<span class="line-modified">2725     generate_trampoline(method-&gt;from_compiled_inline_entry(),    entry-&gt;get_c2i_inline_entry());</span>
<span class="line-modified">2726   }</span>
<span class="line-modified">2727 </span>
<span class="line-modified">2728   return entry;</span>
<span class="line-modified">2729 }</span>
<span class="line-added">2730 </span>
2731 
<span class="line-modified">2732 CompiledEntrySignature::CompiledEntrySignature(Method* method) :</span>
<span class="line-modified">2733   _method(method), _num_inline_args(0), _has_inline_recv(false),</span>
<span class="line-added">2734   _sig_cc(NULL), _sig_cc_ro(NULL), _regs(NULL), _regs_cc(NULL), _regs_cc_ro(NULL),</span>
<span class="line-added">2735   _args_on_stack(0), _args_on_stack_cc(0), _args_on_stack_cc_ro(0),</span>
<span class="line-added">2736   _c1_needs_stack_repair(false), _c2_needs_stack_repair(false), _has_scalarized_args(false) {</span>
<span class="line-added">2737   _has_reserved_entries = false;</span>
<span class="line-added">2738   _sig = new GrowableArray&lt;SigEntry&gt;(method-&gt;size_of_parameters());</span>
<span class="line-added">2739 </span>
<span class="line-added">2740 }</span>
<span class="line-added">2741 </span>
<span class="line-added">2742 int CompiledEntrySignature::compute_scalarized_cc(GrowableArray&lt;SigEntry&gt;*&amp; sig_cc, VMRegPair*&amp; regs_cc, bool scalar_receiver) {</span>
<span class="line-added">2743   InstanceKlass* holder = _method-&gt;method_holder();</span>
<span class="line-added">2744   sig_cc = new GrowableArray&lt;SigEntry&gt;(_method-&gt;size_of_parameters());</span>
<span class="line-added">2745   if (!_method-&gt;is_static()) {</span>
<span class="line-added">2746     if (holder-&gt;is_inline_klass() &amp;&amp; scalar_receiver &amp;&amp; InlineKlass::cast(holder)-&gt;can_be_passed_as_fields()) {</span>
<span class="line-added">2747       sig_cc-&gt;appendAll(InlineKlass::cast(holder)-&gt;extended_sig());</span>
<span class="line-added">2748     } else {</span>
<span class="line-added">2749       SigEntry::add_entry(sig_cc, T_OBJECT);</span>
<span class="line-added">2750     }</span>
<span class="line-added">2751   }</span>
<span class="line-added">2752   Thread* THREAD = Thread::current();</span>
<span class="line-added">2753   for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-added">2754     if (ss.type() == T_INLINE_TYPE) {</span>
<span class="line-added">2755       InlineKlass* vk = ss.as_inline_klass(holder);</span>
<span class="line-added">2756       if (vk-&gt;can_be_passed_as_fields()) {</span>
<span class="line-added">2757         sig_cc-&gt;appendAll(vk-&gt;extended_sig());</span>
<span class="line-added">2758       } else {</span>
<span class="line-added">2759         SigEntry::add_entry(sig_cc, T_OBJECT);</span>
2760       }
<span class="line-added">2761     } else {</span>
<span class="line-added">2762       SigEntry::add_entry(sig_cc, ss.type());</span>
2763     }
2764   }
<span class="line-added">2765   regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, sig_cc-&gt;length() + 2);</span>
<span class="line-added">2766   return SharedRuntime::java_calling_convention(sig_cc, regs_cc);</span>
<span class="line-added">2767 }</span>
2768 
<span class="line-modified">2769 int CompiledEntrySignature::insert_reserved_entry(int ret_off) {</span>
<span class="line-added">2770   // Find index in signature that belongs to return address slot</span>
<span class="line-added">2771   BasicType bt = T_ILLEGAL;</span>
<span class="line-added">2772   int i = 0;</span>
<span class="line-added">2773   for (uint off = 0; i &lt; _sig_cc-&gt;length(); ++i) {</span>
<span class="line-added">2774     if (SigEntry::skip_value_delimiters(_sig_cc, i)) {</span>
<span class="line-added">2775       VMReg first = _regs_cc[off++].first();</span>
<span class="line-added">2776       if (first-&gt;is_valid() &amp;&amp; first-&gt;is_stack()) {</span>
<span class="line-added">2777         // Select a type for the reserved entry that will end up on the stack</span>
<span class="line-added">2778         bt = _sig_cc-&gt;at(i)._bt;</span>
<span class="line-added">2779         if (((int)first-&gt;reg2stack() + VMRegImpl::slots_per_word) == ret_off) {</span>
<span class="line-added">2780           break; // Index of the return address found</span>
<span class="line-added">2781         }</span>
<span class="line-added">2782       }</span>
<span class="line-added">2783     }</span>
<span class="line-added">2784   }</span>
<span class="line-added">2785   // Insert reserved entry and re-compute calling convention</span>
<span class="line-added">2786   SigEntry::insert_reserved_entry(_sig_cc, i, bt);</span>
<span class="line-added">2787   return SharedRuntime::java_calling_convention(_sig_cc, _regs_cc);</span>
<span class="line-added">2788 }</span>
<span class="line-added">2789 </span>
<span class="line-added">2790 // See if we can save space by sharing the same entry for VIEP and VIEP(RO),</span>
<span class="line-added">2791 // or the same entry for VEP and VIEP(RO).</span>
<span class="line-added">2792 CodeOffsets::Entries CompiledEntrySignature::c1_inline_ro_entry_type() const {</span>
<span class="line-added">2793   if (!has_scalarized_args()) {</span>
<span class="line-added">2794     // VEP/VIEP/VIEP(RO) all share the same entry. There&#39;s no packing.</span>
<span class="line-added">2795     return CodeOffsets::Verified_Entry;</span>
<span class="line-added">2796   }</span>
<span class="line-added">2797   if (_method-&gt;is_static()) {</span>
<span class="line-added">2798     // Static methods don&#39;t need VIEP(RO)</span>
<span class="line-added">2799     return CodeOffsets::Verified_Entry;</span>
<span class="line-added">2800   }</span>
<span class="line-added">2801 </span>
<span class="line-added">2802   if (has_inline_recv()) {</span>
<span class="line-added">2803     if (num_inline_args() == 1) {</span>
<span class="line-added">2804       // Share same entry for VIEP and VIEP(RO).</span>
<span class="line-added">2805       // This is quite common: we have an instance method in an InlineKlass that has</span>
<span class="line-added">2806       // no inline type args other than &lt;this&gt;.</span>
<span class="line-added">2807       return CodeOffsets::Verified_Inline_Entry;</span>
<span class="line-added">2808     } else {</span>
<span class="line-added">2809       assert(num_inline_args() &gt; 1, &quot;must be&quot;);</span>
<span class="line-added">2810       // No sharing:</span>
<span class="line-added">2811       //   VIEP(RO) -- &lt;this&gt; is passed as object</span>
<span class="line-added">2812       //   VEP      -- &lt;this&gt; is passed as fields</span>
<span class="line-added">2813       return CodeOffsets::Verified_Inline_Entry_RO;</span>
<span class="line-added">2814     }</span>
<span class="line-added">2815   }</span>
<span class="line-added">2816 </span>
<span class="line-added">2817   // Either a static method, or &lt;this&gt; is not an inline type</span>
<span class="line-added">2818   if (args_on_stack_cc() != args_on_stack_cc_ro() || _has_reserved_entries) {</span>
<span class="line-added">2819     // No sharing:</span>
<span class="line-added">2820     // Some arguments are passed on the stack, and we have inserted reserved entries</span>
<span class="line-added">2821     // into the VEP, but we never insert reserved entries into the VIEP(RO).</span>
<span class="line-added">2822     return CodeOffsets::Verified_Inline_Entry_RO;</span>
<span class="line-added">2823   } else {</span>
<span class="line-added">2824     // Share same entry for VEP and VIEP(RO).</span>
<span class="line-added">2825     return CodeOffsets::Verified_Entry;</span>
<span class="line-added">2826   }</span>
<span class="line-added">2827 }</span>
<span class="line-added">2828 </span>
<span class="line-added">2829 </span>
<span class="line-added">2830 void CompiledEntrySignature::compute_calling_conventions() {</span>
<span class="line-added">2831   // Get the (non-scalarized) signature and check for inline type arguments</span>
<span class="line-added">2832   if (!_method-&gt;is_static()) {</span>
<span class="line-added">2833     if (_method-&gt;method_holder()-&gt;is_inline_klass() &amp;&amp; InlineKlass::cast(_method-&gt;method_holder())-&gt;can_be_passed_as_fields()) {</span>
<span class="line-added">2834       _has_inline_recv = true;</span>
<span class="line-added">2835       _num_inline_args++;</span>
<span class="line-added">2836     }</span>
<span class="line-added">2837     SigEntry::add_entry(_sig, T_OBJECT);</span>
<span class="line-added">2838   }</span>
<span class="line-added">2839   for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-added">2840     BasicType bt = ss.type();</span>
<span class="line-added">2841     if (bt == T_INLINE_TYPE) {</span>
<span class="line-added">2842       if (ss.as_inline_klass(_method-&gt;method_holder())-&gt;can_be_passed_as_fields()) {</span>
<span class="line-added">2843         _num_inline_args++;</span>
<span class="line-added">2844       }</span>
<span class="line-added">2845       bt = T_OBJECT;</span>
<span class="line-added">2846     }</span>
<span class="line-added">2847     SigEntry::add_entry(_sig, bt);</span>
<span class="line-added">2848   }</span>
<span class="line-added">2849   if (_method-&gt;is_abstract() &amp;&amp; !has_inline_arg()) {</span>
<span class="line-added">2850     return;</span>
<span class="line-added">2851   }</span>
<span class="line-added">2852 </span>
<span class="line-added">2853   // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage</span>
<span class="line-added">2854   _regs = NEW_RESOURCE_ARRAY(VMRegPair, _sig-&gt;length());</span>
<span class="line-added">2855   _args_on_stack = SharedRuntime::java_calling_convention(_sig, _regs);</span>
<span class="line-added">2856 </span>
<span class="line-added">2857   // Now compute the scalarized calling convention if there are inline types in the signature</span>
<span class="line-added">2858   _sig_cc = _sig;</span>
<span class="line-added">2859   _sig_cc_ro = _sig;</span>
<span class="line-added">2860   _regs_cc = _regs;</span>
<span class="line-added">2861   _regs_cc_ro = _regs;</span>
<span class="line-added">2862   _args_on_stack_cc = _args_on_stack;</span>
<span class="line-added">2863   _args_on_stack_cc_ro = _args_on_stack;</span>
<span class="line-added">2864 </span>
<span class="line-added">2865   if (has_inline_arg() &amp;&amp; !_method-&gt;is_native()) {</span>
<span class="line-added">2866     _args_on_stack_cc = compute_scalarized_cc(_sig_cc, _regs_cc, /* scalar_receiver = */ true);</span>
<span class="line-added">2867 </span>
<span class="line-added">2868     _sig_cc_ro = _sig_cc;</span>
<span class="line-added">2869     _regs_cc_ro = _regs_cc;</span>
<span class="line-added">2870     _args_on_stack_cc_ro = _args_on_stack_cc;</span>
<span class="line-added">2871     if (_has_inline_recv || _args_on_stack_cc &gt; _args_on_stack) {</span>
<span class="line-added">2872       // For interface calls, we need another entry point / adapter to unpack the receiver</span>
<span class="line-added">2873       _args_on_stack_cc_ro = compute_scalarized_cc(_sig_cc_ro, _regs_cc_ro, /* scalar_receiver = */ false);</span>
<span class="line-added">2874     }</span>
<span class="line-added">2875 </span>
<span class="line-added">2876     // Compute the stack extension that is required to convert between the calling conventions.</span>
<span class="line-added">2877     // The stack slots at these offsets are occupied by the return address with the unscalarized</span>
<span class="line-added">2878     // calling convention. Don&#39;t use them for arguments with the scalarized calling convention.</span>
<span class="line-added">2879     int ret_off    = _args_on_stack_cc - _args_on_stack;</span>
<span class="line-added">2880     int ret_off_ro = _args_on_stack_cc - _args_on_stack_cc_ro;</span>
<span class="line-added">2881     assert(ret_off_ro &lt;= 0 || ret_off &gt; 0, &quot;receiver unpacking requires more stack space than expected&quot;);</span>
<span class="line-added">2882 </span>
<span class="line-added">2883     if (ret_off &gt; 0) {</span>
<span class="line-added">2884       // Make sure the stack of the scalarized calling convention with the reserved</span>
<span class="line-added">2885       // entries (2 slots each) remains 16-byte (4 slots) aligned after stack extension.</span>
<span class="line-added">2886       int alignment = StackAlignmentInBytes / VMRegImpl::stack_slot_size;</span>
<span class="line-added">2887       if (ret_off_ro != ret_off &amp;&amp; ret_off_ro &gt;= 0) {</span>
<span class="line-added">2888         ret_off    += 4; // Account for two reserved entries (4 slots)</span>
<span class="line-added">2889         ret_off_ro += 4;</span>
<span class="line-added">2890         ret_off     = align_up(ret_off, alignment);</span>
<span class="line-added">2891         ret_off_ro  = align_up(ret_off_ro, alignment);</span>
<span class="line-added">2892         // TODO can we avoid wasting a stack slot here?</span>
<span class="line-added">2893         //assert(ret_off != ret_off_ro, &quot;fail&quot;);</span>
<span class="line-added">2894         if (ret_off &gt; ret_off_ro) {</span>
<span class="line-added">2895           swap(ret_off, ret_off_ro); // Sort by offset</span>
<span class="line-added">2896         }</span>
<span class="line-added">2897         _args_on_stack_cc = insert_reserved_entry(ret_off);</span>
<span class="line-added">2898         _args_on_stack_cc = insert_reserved_entry(ret_off_ro);</span>
<span class="line-added">2899       } else {</span>
<span class="line-added">2900         ret_off += 2; // Account for one reserved entry (2 slots)</span>
<span class="line-added">2901         ret_off = align_up(ret_off, alignment);</span>
<span class="line-added">2902         _args_on_stack_cc = insert_reserved_entry(ret_off);</span>
<span class="line-added">2903       }</span>
<span class="line-added">2904 </span>
<span class="line-added">2905       _has_reserved_entries = true;</span>
<span class="line-added">2906     }</span>
<span class="line-added">2907 </span>
<span class="line-added">2908     // Upper bound on stack arguments to avoid hitting the argument limit and</span>
<span class="line-added">2909     // bailing out of compilation (&quot;unsupported incoming calling sequence&quot;).</span>
<span class="line-added">2910     // TODO we need a reasonable limit (flag?) here</span>
<span class="line-added">2911     if (_args_on_stack_cc &gt; 50) {</span>
<span class="line-added">2912       // Don&#39;t scalarize inline type arguments</span>
<span class="line-added">2913       _sig_cc = _sig;</span>
<span class="line-added">2914       _sig_cc_ro = _sig;</span>
<span class="line-added">2915       _regs_cc = _regs;</span>
<span class="line-added">2916       _regs_cc_ro = _regs;</span>
<span class="line-added">2917       _args_on_stack_cc = _args_on_stack;</span>
<span class="line-added">2918       _args_on_stack_cc_ro = _args_on_stack;</span>
<span class="line-added">2919     } else {</span>
<span class="line-added">2920       _c1_needs_stack_repair = (_args_on_stack_cc &lt; _args_on_stack) || (_args_on_stack_cc_ro &lt; _args_on_stack);</span>
<span class="line-added">2921       _c2_needs_stack_repair = (_args_on_stack_cc &gt; _args_on_stack) || (_args_on_stack_cc &gt; _args_on_stack_cc_ro);</span>
<span class="line-added">2922       _has_scalarized_args = true;</span>
<span class="line-added">2923     }</span>
<span class="line-added">2924   }</span>
2925 }
2926 
2927 AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter0(const methodHandle&amp; method) {
2928   // Use customized signature handler.  Need to lock around updates to
2929   // the AdapterHandlerTable (it is not safe for concurrent readers
2930   // and a single writer: this could be fixed if it becomes a
2931   // problem).
2932 
2933   ResourceMark rm;
2934 
<span class="line-modified">2935   NOT_PRODUCT(int insts_size = 0);</span>
2936   AdapterBlob* new_adapter = NULL;
2937   AdapterHandlerEntry* entry = NULL;
2938   AdapterFingerPrint* fingerprint = NULL;
<span class="line-added">2939 </span>
2940   {
2941     MutexLocker mu(AdapterHandlerLibrary_lock);
2942     // make sure data structure is initialized
2943     initialize();
2944 
<span class="line-modified">2945     CompiledEntrySignature ces(method());</span>
<span class="line-modified">2946     {</span>
<span class="line-added">2947        MutexUnlocker mul(AdapterHandlerLibrary_lock);</span>
<span class="line-added">2948        ces.compute_calling_conventions();</span>
2949     }
<span class="line-added">2950     GrowableArray&lt;SigEntry&gt;&amp; sig       = ces.sig();</span>
<span class="line-added">2951     GrowableArray&lt;SigEntry&gt;&amp; sig_cc    = ces.sig_cc();</span>
<span class="line-added">2952     GrowableArray&lt;SigEntry&gt;&amp; sig_cc_ro = ces.sig_cc_ro();</span>
<span class="line-added">2953     VMRegPair* regs         = ces.regs();</span>
<span class="line-added">2954     VMRegPair* regs_cc      = ces.regs_cc();</span>
<span class="line-added">2955     VMRegPair* regs_cc_ro   = ces.regs_cc_ro();</span>
2956 
<span class="line-modified">2957     if (ces.has_scalarized_args()) {</span>
<span class="line-modified">2958       method-&gt;set_has_scalarized_args(true);</span>
<span class="line-added">2959       method-&gt;set_c1_needs_stack_repair(ces.c1_needs_stack_repair());</span>
<span class="line-added">2960       method-&gt;set_c2_needs_stack_repair(ces.c2_needs_stack_repair());</span>
<span class="line-added">2961     }</span>
2962 
<span class="line-modified">2963     if (method-&gt;is_abstract()) {</span>
<span class="line-modified">2964       if (ces.has_scalarized_args()) {</span>
<span class="line-modified">2965         // Save a C heap allocated version of the signature for abstract methods with scalarized inline type arguments</span>
<span class="line-modified">2966         address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();</span>
<span class="line-modified">2967         entry = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),</span>
<span class="line-modified">2968                                                  StubRoutines::throw_AbstractMethodError_entry(),</span>
<span class="line-modified">2969                                                  wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,</span>
<span class="line-modified">2970                                                  wrong_method_abstract, wrong_method_abstract);</span>
<span class="line-modified">2971         GrowableArray&lt;SigEntry&gt;* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;SigEntry&gt;(sig_cc_ro.length(), mtInternal);</span>
<span class="line-added">2972         heap_sig-&gt;appendAll(&amp;sig_cc_ro);</span>
<span class="line-added">2973         entry-&gt;set_sig_cc(heap_sig);</span>
<span class="line-added">2974         return entry;</span>
<span class="line-added">2975       } else {</span>
<span class="line-added">2976         return _abstract_method_handler;</span>
<span class="line-added">2977       }</span>
2978     }

2979 
2980     // Lookup method signature&#39;s fingerprint
<span class="line-modified">2981     entry = _adapters-&gt;lookup(&amp;sig_cc, regs_cc != regs_cc_ro);</span>
2982 
2983 #ifdef ASSERT
2984     AdapterHandlerEntry* shared_entry = NULL;
2985     // Start adapter sharing verification only after the VM is booted.
2986     if (VerifyAdapterSharing &amp;&amp; (entry != NULL)) {
2987       shared_entry = entry;
2988       entry = NULL;
2989     }
2990 #endif
2991 
2992     if (entry != NULL) {
2993       return entry;
2994     }
2995 
<span class="line-modified">2996     // Make a C heap allocated version of the fingerprint to store in the adapter</span>



2997     fingerprint = new AdapterFingerPrint(&amp;sig_cc, regs_cc != regs_cc_ro);
2998 
2999     // StubRoutines::code2() is initialized after this function can be called. As a result,
3000     // VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated
3001     // prior to StubRoutines::code2() being set. Checks refer to checks generated in an I2C
3002     // stub that ensure that an I2C stub is called from an interpreter frame.
3003     bool contains_all_checks = StubRoutines::code2() != NULL;
3004 
3005     // Create I2C &amp; C2I handlers
3006     BufferBlob* buf = buffer_blob(); // the temporary code buffer in CodeCache
3007     if (buf != NULL) {
3008       CodeBuffer buffer(buf);
3009       short buffer_locs[20];
3010       buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
3011                                              sizeof(buffer_locs)/sizeof(relocInfo));
3012 
3013       MacroAssembler _masm(&amp;buffer);
3014       entry = SharedRuntime::generate_i2c2i_adapters(&amp;_masm,
<span class="line-modified">3015                                                      ces.args_on_stack(),</span>
<span class="line-modified">3016                                                      &amp;sig,</span>

3017                                                      regs,
<span class="line-modified">3018                                                      &amp;sig_cc,</span>
<span class="line-added">3019                                                      regs_cc,</span>
<span class="line-added">3020                                                      &amp;sig_cc_ro,</span>
<span class="line-added">3021                                                      regs_cc_ro,</span>
<span class="line-added">3022                                                      fingerprint,</span>
<span class="line-added">3023                                                      new_adapter);</span>
<span class="line-added">3024 </span>
<span class="line-added">3025       if (ces.has_scalarized_args()) {</span>
<span class="line-added">3026         // Save a C heap allocated version of the scalarized signature and store it in the adapter</span>
<span class="line-added">3027         GrowableArray&lt;SigEntry&gt;* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;SigEntry&gt;(sig_cc.length(), mtInternal);</span>
<span class="line-added">3028         heap_sig-&gt;appendAll(&amp;sig_cc);</span>
<span class="line-added">3029         entry-&gt;set_sig_cc(heap_sig);</span>
<span class="line-added">3030       }</span>
<span class="line-added">3031 </span>
3032 #ifdef ASSERT
3033       if (VerifyAdapterSharing) {
3034         if (shared_entry != NULL) {
<span class="line-added">3035           if (!shared_entry-&gt;compare_code(buf-&gt;code_begin(), buffer.insts_size())) {</span>
<span class="line-added">3036             method-&gt;print();</span>
<span class="line-added">3037           }</span>
3038           assert(shared_entry-&gt;compare_code(buf-&gt;code_begin(), buffer.insts_size()), &quot;code must match&quot;);
3039           // Release the one just created and return the original
3040           _adapters-&gt;free_entry(entry);
3041           return shared_entry;
3042         } else  {
3043           entry-&gt;save_code(buf-&gt;code_begin(), buffer.insts_size());
3044         }
3045       }
3046 #endif
3047 

3048       NOT_PRODUCT(insts_size = buffer.insts_size());
3049     }
3050     if (new_adapter == NULL) {
3051       // CodeCache is full, disable compilation
3052       // Ought to log this but compile log is only per compile thread
3053       // and we&#39;re some non descript Java thread.
3054       return NULL; // Out of CodeCache space
3055     }
3056     entry-&gt;relocate(new_adapter-&gt;content_begin());
3057 #ifndef PRODUCT
3058     // debugging suppport
3059     if (PrintAdapterHandlers || PrintStubCode) {
3060       ttyLocker ttyl;
3061       entry-&gt;print_adapter_on(tty);
3062       tty-&gt;print_cr(&quot;i2c argument handler #%d for: %s %s %s (%d bytes generated)&quot;,
3063                     _adapters-&gt;number_of_entries(), (method-&gt;is_static() ? &quot;static&quot; : &quot;receiver&quot;),
3064                     method-&gt;signature()-&gt;as_C_string(), fingerprint-&gt;as_string(), insts_size);
3065       tty-&gt;print_cr(&quot;c2i argument handler starts at %p&quot;, entry-&gt;get_c2i_entry());
3066       if (Verbose || PrintStubCode) {
3067         address first_pc = entry-&gt;base_address();
</pre>
<hr />
<pre>
3083     char blob_id[256];
3084     jio_snprintf(blob_id,
3085                  sizeof(blob_id),
3086                  &quot;%s(%s)@&quot; PTR_FORMAT,
3087                  new_adapter-&gt;name(),
3088                  fingerprint-&gt;as_string(),
3089                  new_adapter-&gt;content_begin());
3090     Forte::register_stub(blob_id, new_adapter-&gt;content_begin(), new_adapter-&gt;content_end());
3091 
3092     if (JvmtiExport::should_post_dynamic_code_generated()) {
3093       JvmtiExport::post_dynamic_code_generated(blob_id, new_adapter-&gt;content_begin(), new_adapter-&gt;content_end());
3094     }
3095   }
3096   return entry;
3097 }
3098 
3099 address AdapterHandlerEntry::base_address() {
3100   address base = _i2c_entry;
3101   if (base == NULL)  base = _c2i_entry;
3102   assert(base &lt;= _c2i_entry || _c2i_entry == NULL, &quot;&quot;);
<span class="line-added">3103   assert(base &lt;= _c2i_inline_entry || _c2i_inline_entry == NULL, &quot;&quot;);</span>
<span class="line-added">3104   assert(base &lt;= _c2i_inline_ro_entry || _c2i_inline_ro_entry == NULL, &quot;&quot;);</span>
3105   assert(base &lt;= _c2i_unverified_entry || _c2i_unverified_entry == NULL, &quot;&quot;);
<span class="line-added">3106   assert(base &lt;= _c2i_unverified_inline_entry || _c2i_unverified_inline_entry == NULL, &quot;&quot;);</span>
3107   assert(base &lt;= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == NULL, &quot;&quot;);
3108   return base;
3109 }
3110 
3111 void AdapterHandlerEntry::relocate(address new_base) {
3112   address old_base = base_address();
3113   assert(old_base != NULL, &quot;&quot;);
3114   ptrdiff_t delta = new_base - old_base;
3115   if (_i2c_entry != NULL)
3116     _i2c_entry += delta;
3117   if (_c2i_entry != NULL)
3118     _c2i_entry += delta;
<span class="line-added">3119   if (_c2i_inline_entry != NULL)</span>
<span class="line-added">3120     _c2i_inline_entry += delta;</span>
<span class="line-added">3121   if (_c2i_inline_ro_entry != NULL)</span>
<span class="line-added">3122     _c2i_inline_ro_entry += delta;</span>
3123   if (_c2i_unverified_entry != NULL)
3124     _c2i_unverified_entry += delta;
<span class="line-added">3125   if (_c2i_unverified_inline_entry != NULL)</span>
<span class="line-added">3126     _c2i_unverified_inline_entry += delta;</span>
3127   if (_c2i_no_clinit_check_entry != NULL)
3128     _c2i_no_clinit_check_entry += delta;
3129   assert(base_address() == new_base, &quot;&quot;);
3130 }
3131 
3132 
3133 void AdapterHandlerEntry::deallocate() {
3134   delete _fingerprint;
<span class="line-added">3135   if (_sig_cc != NULL) {</span>
<span class="line-added">3136     delete _sig_cc;</span>
<span class="line-added">3137   }</span>
3138 #ifdef ASSERT
3139   FREE_C_HEAP_ARRAY(unsigned char, _saved_code);
3140 #endif
3141 }
3142 
3143 
3144 #ifdef ASSERT
3145 // Capture the code before relocation so that it can be compared
3146 // against other versions.  If the code is captured after relocation
3147 // then relative instructions won&#39;t be equivalent.
3148 void AdapterHandlerEntry::save_code(unsigned char* buffer, int length) {
3149   _saved_code = NEW_C_HEAP_ARRAY(unsigned char, length, mtCode);
3150   _saved_code_length = length;
3151   memcpy(_saved_code, buffer, length);
3152 }
3153 
3154 
3155 bool AdapterHandlerEntry::compare_code(unsigned char* buffer, int length) {
3156   if (length != _saved_code_length) {
3157     return false;
</pre>
<hr />
<pre>
3201       double locs_buf[20];
3202       buffer.insts()-&gt;initialize_shared_locs((relocInfo*)locs_buf, sizeof(locs_buf) / sizeof(relocInfo));
3203 #if defined(AARCH64)
3204       // On AArch64 with ZGC and nmethod entry barriers, we need all oops to be
3205       // in the constant pool to ensure ordering between the barrier and oops
3206       // accesses. For native_wrappers we need a constant.
3207       buffer.initialize_consts_size(8);
3208 #endif
3209       MacroAssembler _masm(&amp;buffer);
3210 
3211       // Fill in the signature array, for the calling-convention call.
3212       const int total_args_passed = method-&gt;size_of_parameters();
3213 
3214       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_args_passed);
3215       VMRegPair*   regs = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);
3216       int i=0;
3217       if (!method-&gt;is_static())  // Pass in receiver first
3218         sig_bt[i++] = T_OBJECT;
3219       SignatureStream ss(method-&gt;signature());
3220       for (; !ss.at_return_type(); ss.next()) {
<span class="line-modified">3221         BasicType bt = ss.type();</span>
<span class="line-added">3222         sig_bt[i++] = bt;  // Collect remaining bits of signature</span>
3223         if (ss.type() == T_LONG || ss.type() == T_DOUBLE)
3224           sig_bt[i++] = T_VOID;   // Longs &amp; doubles take 2 Java slots
3225       }
3226       assert(i == total_args_passed, &quot;&quot;);
3227       BasicType ret_type = ss.type();
3228 
3229       // Now get the compiled-Java layout as input (or output) arguments.
3230       // NOTE: Stubs for compiled entry points of method handle intrinsics
3231       // are just trampolines so the argument registers must be outgoing ones.
3232       const bool is_outgoing = method-&gt;is_method_handle_intrinsic();
3233       int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, is_outgoing);
3234 
3235       // Generate the compiled-to-native wrapper code
3236       nm = SharedRuntime::generate_native_wrapper(&amp;_masm, method, compile_id, sig_bt, regs, ret_type, critical_entry);
3237 
3238       if (nm != NULL) {
3239         {
3240           MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
3241           if (nm-&gt;make_in_use()) {
3242             method-&gt;set_code(method, nm);
</pre>
<hr />
<pre>
3455   AdapterHandlerTableIterator iter(_adapters);
3456   while (iter.has_next()) {
3457     AdapterHandlerEntry* a = iter.next();
3458     if (b == CodeCache::find_blob(a-&gt;get_i2c_entry())) {
3459       st-&gt;print(&quot;Adapter for signature: &quot;);
3460       a-&gt;print_adapter_on(tty);
3461       return;
3462     }
3463   }
3464   assert(false, &quot;Should have found handler&quot;);
3465 }
3466 
3467 void AdapterHandlerEntry::print_adapter_on(outputStream* st) const {
3468   st-&gt;print(&quot;AHE@&quot; INTPTR_FORMAT &quot;: %s&quot;, p2i(this), fingerprint()-&gt;as_string());
3469   if (get_i2c_entry() != NULL) {
3470     st-&gt;print(&quot; i2c: &quot; INTPTR_FORMAT, p2i(get_i2c_entry()));
3471   }
3472   if (get_c2i_entry() != NULL) {
3473     st-&gt;print(&quot; c2i: &quot; INTPTR_FORMAT, p2i(get_c2i_entry()));
3474   }
<span class="line-added">3475   if (get_c2i_entry() != NULL) {</span>
<span class="line-added">3476     st-&gt;print(&quot; c2iVE: &quot; INTPTR_FORMAT, p2i(get_c2i_inline_entry()));</span>
<span class="line-added">3477   }</span>
<span class="line-added">3478   if (get_c2i_entry() != NULL) {</span>
<span class="line-added">3479     st-&gt;print(&quot; c2iVROE: &quot; INTPTR_FORMAT, p2i(get_c2i_inline_ro_entry()));</span>
<span class="line-added">3480   }</span>
3481   if (get_c2i_unverified_entry() != NULL) {
<span class="line-modified">3482     st-&gt;print(&quot; c2iUE: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));</span>
<span class="line-added">3483   }</span>
<span class="line-added">3484   if (get_c2i_unverified_entry() != NULL) {</span>
<span class="line-added">3485     st-&gt;print(&quot; c2iUVE: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_inline_entry()));</span>
3486   }
3487   if (get_c2i_no_clinit_check_entry() != NULL) {
3488     st-&gt;print(&quot; c2iNCI: &quot; INTPTR_FORMAT, p2i(get_c2i_no_clinit_check_entry()));
3489   }
3490   st-&gt;cr();
3491 }
3492 
3493 #if INCLUDE_CDS
3494 
3495 void CDSAdapterHandlerEntry::init() {
3496   assert(DumpSharedSpaces, &quot;used during dump time only&quot;);
3497   _c2i_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());
<span class="line-added">3498   _c2i_inline_ro_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());</span>
<span class="line-added">3499   _c2i_inline_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());</span>
3500   _adapter_trampoline = (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*));
3501 };
3502 
3503 #endif // INCLUDE_CDS
3504 
3505 
3506 #ifndef PRODUCT
3507 
3508 void AdapterHandlerLibrary::print_statistics() {
3509   _adapters-&gt;print_statistics();
3510 }
3511 
3512 #endif /* PRODUCT */
3513 
3514 JRT_LEAF(void, SharedRuntime::enable_stack_reserved_zone(JavaThread* thread))
3515   assert(thread-&gt;is_Java_thread(), &quot;Only Java threads have a stack reserved zone&quot;);
3516   if (thread-&gt;stack_reserved_zone_disabled()) {
3517   thread-&gt;enable_stack_reserved_zone();
3518   }
3519   thread-&gt;set_reserved_stack_activation(thread-&gt;stack_base());
</pre>
<hr />
<pre>
3565       break;
3566     } else {
3567       fr = fr.java_sender();
3568     }
3569   }
3570   return activation;
3571 }
3572 
3573 void SharedRuntime::on_slowpath_allocation_exit(JavaThread* thread) {
3574   // After any safepoint, just before going back to compiled code,
3575   // we inform the GC that we will be doing initializing writes to
3576   // this object in the future without emitting card-marks, so
3577   // GC may take any compensating steps.
3578 
3579   oop new_obj = thread-&gt;vm_result();
3580   if (new_obj == NULL) return;
3581 
3582   BarrierSet *bs = BarrierSet::barrier_set();
3583   bs-&gt;on_slowpath_allocation_exit(thread, new_obj);
3584 }
<span class="line-added">3585 </span>
<span class="line-added">3586 // We are at a compiled code to interpreter call. We need backing</span>
<span class="line-added">3587 // buffers for all inline type arguments. Allocate an object array to</span>
<span class="line-added">3588 // hold them (convenient because once we&#39;re done with it we don&#39;t have</span>
<span class="line-added">3589 // to worry about freeing it).</span>
<span class="line-added">3590 oop SharedRuntime::allocate_inline_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS) {</span>
<span class="line-added">3591   assert(InlineTypePassFieldsAsArgs, &quot;no reason to call this&quot;);</span>
<span class="line-added">3592   ResourceMark rm;</span>
<span class="line-added">3593 </span>
<span class="line-added">3594   int nb_slots = 0;</span>
<span class="line-added">3595   InstanceKlass* holder = callee-&gt;method_holder();</span>
<span class="line-added">3596   allocate_receiver &amp;= !callee-&gt;is_static() &amp;&amp; holder-&gt;is_inline_klass();</span>
<span class="line-added">3597   if (allocate_receiver) {</span>
<span class="line-added">3598     nb_slots++;</span>
<span class="line-added">3599   }</span>
<span class="line-added">3600   for (SignatureStream ss(callee-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-added">3601     if (ss.type() == T_INLINE_TYPE) {</span>
<span class="line-added">3602       nb_slots++;</span>
<span class="line-added">3603     }</span>
<span class="line-added">3604   }</span>
<span class="line-added">3605   objArrayOop array_oop = oopFactory::new_objectArray(nb_slots, CHECK_NULL);</span>
<span class="line-added">3606   objArrayHandle array(THREAD, array_oop);</span>
<span class="line-added">3607   int i = 0;</span>
<span class="line-added">3608   if (allocate_receiver) {</span>
<span class="line-added">3609     InlineKlass* vk = InlineKlass::cast(holder);</span>
<span class="line-added">3610     oop res = vk-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">3611     array-&gt;obj_at_put(i, res);</span>
<span class="line-added">3612     i++;</span>
<span class="line-added">3613   }</span>
<span class="line-added">3614   for (SignatureStream ss(callee-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-added">3615     if (ss.type() == T_INLINE_TYPE) {</span>
<span class="line-added">3616       InlineKlass* vk = ss.as_inline_klass(holder);</span>
<span class="line-added">3617       oop res = vk-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">3618       array-&gt;obj_at_put(i, res);</span>
<span class="line-added">3619       i++;</span>
<span class="line-added">3620     }</span>
<span class="line-added">3621   }</span>
<span class="line-added">3622   return array();</span>
<span class="line-added">3623 }</span>
<span class="line-added">3624 </span>
<span class="line-added">3625 JRT_ENTRY(void, SharedRuntime::allocate_inline_types(JavaThread* thread, Method* callee_method, bool allocate_receiver))</span>
<span class="line-added">3626   methodHandle callee(thread, callee_method);</span>
<span class="line-added">3627   oop array = SharedRuntime::allocate_inline_types_impl(thread, callee, allocate_receiver, CHECK);</span>
<span class="line-added">3628   thread-&gt;set_vm_result(array);</span>
<span class="line-added">3629   thread-&gt;set_vm_result_2(callee()); // TODO: required to keep callee live?</span>
<span class="line-added">3630 JRT_END</span>
<span class="line-added">3631 </span>
<span class="line-added">3632 // TODO remove this once the AARCH64 dependency is gone</span>
<span class="line-added">3633 // Iterate over the array of heap allocated inline types and apply the GC post barrier to all reference fields.</span>
<span class="line-added">3634 // This is called from the C2I adapter after inline type arguments are heap allocated and initialized.</span>
<span class="line-added">3635 JRT_LEAF(void, SharedRuntime::apply_post_barriers(JavaThread* thread, objArrayOopDesc* array))</span>
<span class="line-added">3636 {</span>
<span class="line-added">3637   assert(InlineTypePassFieldsAsArgs, &quot;no reason to call this&quot;);</span>
<span class="line-added">3638   assert(oopDesc::is_oop(array), &quot;should be oop&quot;);</span>
<span class="line-added">3639   for (int i = 0; i &lt; array-&gt;length(); ++i) {</span>
<span class="line-added">3640     instanceOop valueOop = (instanceOop)array-&gt;obj_at(i);</span>
<span class="line-added">3641     InlineKlass* vk = InlineKlass::cast(valueOop-&gt;klass());</span>
<span class="line-added">3642     if (vk-&gt;contains_oops()) {</span>
<span class="line-added">3643       const address dst_oop_addr = ((address) (void*) valueOop);</span>
<span class="line-added">3644       OopMapBlock* map = vk-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">3645       OopMapBlock* const end = map + vk-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">3646       while (map != end) {</span>
<span class="line-added">3647         address doop_address = dst_oop_addr + map-&gt;offset();</span>
<span class="line-added">3648         barrier_set_cast&lt;ModRefBarrierSet&gt;(BarrierSet::barrier_set())-&gt;</span>
<span class="line-added">3649           write_ref_array((HeapWord*) doop_address, map-&gt;count());</span>
<span class="line-added">3650         map++;</span>
<span class="line-added">3651       }</span>
<span class="line-added">3652     }</span>
<span class="line-added">3653   }</span>
<span class="line-added">3654 }</span>
<span class="line-added">3655 JRT_END</span>
<span class="line-added">3656 </span>
<span class="line-added">3657 // We&#39;re returning from an interpreted method: load each field into a</span>
<span class="line-added">3658 // register following the calling convention</span>
<span class="line-added">3659 JRT_LEAF(void, SharedRuntime::load_inline_type_fields_in_regs(JavaThread* thread, oopDesc* res))</span>
<span class="line-added">3660 {</span>
<span class="line-added">3661   assert(res-&gt;klass()-&gt;is_inline_klass(), &quot;only inline types here&quot;);</span>
<span class="line-added">3662   ResourceMark rm;</span>
<span class="line-added">3663   RegisterMap reg_map(thread);</span>
<span class="line-added">3664   frame stubFrame = thread-&gt;last_frame();</span>
<span class="line-added">3665   frame callerFrame = stubFrame.sender(&amp;reg_map);</span>
<span class="line-added">3666   assert(callerFrame.is_interpreted_frame(), &quot;should be coming from interpreter&quot;);</span>
<span class="line-added">3667 </span>
<span class="line-added">3668   InlineKlass* vk = InlineKlass::cast(res-&gt;klass());</span>
<span class="line-added">3669 </span>
<span class="line-added">3670   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();</span>
<span class="line-added">3671   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();</span>
<span class="line-added">3672 </span>
<span class="line-added">3673   if (regs == NULL) {</span>
<span class="line-added">3674     // The fields of the inline klass don&#39;t fit in registers, bail out</span>
<span class="line-added">3675     return;</span>
<span class="line-added">3676   }</span>
<span class="line-added">3677 </span>
<span class="line-added">3678   int j = 1;</span>
<span class="line-added">3679   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {</span>
<span class="line-added">3680     BasicType bt = sig_vk-&gt;at(i)._bt;</span>
<span class="line-added">3681     if (bt == T_INLINE_TYPE) {</span>
<span class="line-added">3682       continue;</span>
<span class="line-added">3683     }</span>
<span class="line-added">3684     if (bt == T_VOID) {</span>
<span class="line-added">3685       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||</span>
<span class="line-added">3686           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {</span>
<span class="line-added">3687         j++;</span>
<span class="line-added">3688       }</span>
<span class="line-added">3689       continue;</span>
<span class="line-added">3690     }</span>
<span class="line-added">3691     int off = sig_vk-&gt;at(i)._offset;</span>
<span class="line-added">3692     assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="line-added">3693     VMRegPair pair = regs-&gt;at(j);</span>
<span class="line-added">3694     address loc = reg_map.location(pair.first());</span>
<span class="line-added">3695     switch(bt) {</span>
<span class="line-added">3696     case T_BOOLEAN:</span>
<span class="line-added">3697       *(jboolean*)loc = res-&gt;bool_field(off);</span>
<span class="line-added">3698       break;</span>
<span class="line-added">3699     case T_CHAR:</span>
<span class="line-added">3700       *(jchar*)loc = res-&gt;char_field(off);</span>
<span class="line-added">3701       break;</span>
<span class="line-added">3702     case T_BYTE:</span>
<span class="line-added">3703       *(jbyte*)loc = res-&gt;byte_field(off);</span>
<span class="line-added">3704       break;</span>
<span class="line-added">3705     case T_SHORT:</span>
<span class="line-added">3706       *(jshort*)loc = res-&gt;short_field(off);</span>
<span class="line-added">3707       break;</span>
<span class="line-added">3708     case T_INT: {</span>
<span class="line-added">3709       *(jint*)loc = res-&gt;int_field(off);</span>
<span class="line-added">3710       break;</span>
<span class="line-added">3711     }</span>
<span class="line-added">3712     case T_LONG:</span>
<span class="line-added">3713 #ifdef _LP64</span>
<span class="line-added">3714       *(intptr_t*)loc = res-&gt;long_field(off);</span>
<span class="line-added">3715 #else</span>
<span class="line-added">3716       Unimplemented();</span>
<span class="line-added">3717 #endif</span>
<span class="line-added">3718       break;</span>
<span class="line-added">3719     case T_OBJECT:</span>
<span class="line-added">3720     case T_ARRAY: {</span>
<span class="line-added">3721       *(oop*)loc = res-&gt;obj_field(off);</span>
<span class="line-added">3722       break;</span>
<span class="line-added">3723     }</span>
<span class="line-added">3724     case T_FLOAT:</span>
<span class="line-added">3725       *(jfloat*)loc = res-&gt;float_field(off);</span>
<span class="line-added">3726       break;</span>
<span class="line-added">3727     case T_DOUBLE:</span>
<span class="line-added">3728       *(jdouble*)loc = res-&gt;double_field(off);</span>
<span class="line-added">3729       break;</span>
<span class="line-added">3730     default:</span>
<span class="line-added">3731       ShouldNotReachHere();</span>
<span class="line-added">3732     }</span>
<span class="line-added">3733     j++;</span>
<span class="line-added">3734   }</span>
<span class="line-added">3735   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);</span>
<span class="line-added">3736 </span>
<span class="line-added">3737 #ifdef ASSERT</span>
<span class="line-added">3738   VMRegPair pair = regs-&gt;at(0);</span>
<span class="line-added">3739   address loc = reg_map.location(pair.first());</span>
<span class="line-added">3740   assert(*(oopDesc**)loc == res, &quot;overwritten object&quot;);</span>
<span class="line-added">3741 #endif</span>
<span class="line-added">3742 </span>
<span class="line-added">3743   thread-&gt;set_vm_result(res);</span>
<span class="line-added">3744 }</span>
<span class="line-added">3745 JRT_END</span>
<span class="line-added">3746 </span>
<span class="line-added">3747 // We&#39;ve returned to an interpreted method, the interpreter needs a</span>
<span class="line-added">3748 // reference to an inline type instance. Allocate it and initialize it</span>
<span class="line-added">3749 // from field&#39;s values in registers.</span>
<span class="line-added">3750 JRT_BLOCK_ENTRY(void, SharedRuntime::store_inline_type_fields_to_buf(JavaThread* thread, intptr_t res))</span>
<span class="line-added">3751 {</span>
<span class="line-added">3752   ResourceMark rm;</span>
<span class="line-added">3753   RegisterMap reg_map(thread);</span>
<span class="line-added">3754   frame stubFrame = thread-&gt;last_frame();</span>
<span class="line-added">3755   frame callerFrame = stubFrame.sender(&amp;reg_map);</span>
<span class="line-added">3756 </span>
<span class="line-added">3757 #ifdef ASSERT</span>
<span class="line-added">3758   InlineKlass* verif_vk = InlineKlass::returned_inline_klass(reg_map);</span>
<span class="line-added">3759 #endif</span>
<span class="line-added">3760 </span>
<span class="line-added">3761   if (!is_set_nth_bit(res, 0)) {</span>
<span class="line-added">3762     // We&#39;re not returning with inline type fields in registers (the</span>
<span class="line-added">3763     // calling convention didn&#39;t allow it for this inline klass)</span>
<span class="line-added">3764     assert(!Metaspace::contains((void*)res), &quot;should be oop or pointer in buffer area&quot;);</span>
<span class="line-added">3765     thread-&gt;set_vm_result((oopDesc*)res);</span>
<span class="line-added">3766     assert(verif_vk == NULL, &quot;broken calling convention&quot;);</span>
<span class="line-added">3767     return;</span>
<span class="line-added">3768   }</span>
<span class="line-added">3769 </span>
<span class="line-added">3770   clear_nth_bit(res, 0);</span>
<span class="line-added">3771   InlineKlass* vk = (InlineKlass*)res;</span>
<span class="line-added">3772   assert(verif_vk == vk, &quot;broken calling convention&quot;);</span>
<span class="line-added">3773   assert(Metaspace::contains((void*)res), &quot;should be klass&quot;);</span>
<span class="line-added">3774 </span>
<span class="line-added">3775   // Allocate handles for every oop field so they are safe in case of</span>
<span class="line-added">3776   // a safepoint when allocating</span>
<span class="line-added">3777   GrowableArray&lt;Handle&gt; handles;</span>
<span class="line-added">3778   vk-&gt;save_oop_fields(reg_map, handles);</span>
<span class="line-added">3779 </span>
<span class="line-added">3780   // It&#39;s unsafe to safepoint until we are here</span>
<span class="line-added">3781   JRT_BLOCK;</span>
<span class="line-added">3782   {</span>
<span class="line-added">3783     Thread* THREAD = thread;</span>
<span class="line-added">3784     oop vt = vk-&gt;realloc_result(reg_map, handles, CHECK);</span>
<span class="line-added">3785     thread-&gt;set_vm_result(vt);</span>
<span class="line-added">3786   }</span>
<span class="line-added">3787   JRT_BLOCK_END;</span>
<span class="line-added">3788 }</span>
<span class="line-added">3789 JRT_END</span>
<span class="line-added">3790 </span>
</pre>
</td>
</tr>
</table>
<center><a href="safepoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>