<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../.hgtags.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1623,10 ***</span>
<span class="line-new-header">--- 1623,12 ---</span>
  
  void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
    C2_MacroAssembler _masm(&amp;cbuf);
  
<span class="line-added">+   __ verified_entry(C, 0);</span>
<span class="line-added">+   __ bind(*_verified_entry);</span>
    // n.b. frame size includes space for return pc and rfp
    const long framesize = C-&gt;output()-&gt;frame_size_in_bytes();
    assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
  
    // insert a nop at the start of the prolog so we can patch in a
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1965,12 ***</span>
  uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
    // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_).
    return 4;
  }
  
<span class="line-modified">! //=============================================================================</span>
  
  #ifndef PRODUCT
  void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  {
    st-&gt;print_cr(&quot;# MachUEPNode&quot;);
    if (UseCompressedClassPointers) {
<span class="line-new-header">--- 1967,50 ---</span>
  uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
    // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_).
    return 4;
  }
  
<span class="line-modified">! ///=============================================================================</span>
<span class="line-added">+ #ifndef PRODUCT</span>
<span class="line-added">+ void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+   st-&gt;print_cr(&quot;# MachVEPNode&quot;);</span>
<span class="line-added">+   if (!_verified) {</span>
<span class="line-added">+     st-&gt;print_cr(&quot;\t load_class&quot;);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     st-&gt;print_cr(&quot;\t unpack_inline_arg&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+   MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!_verified) {</span>
<span class="line-added">+     Label skip;</span>
<span class="line-added">+     __ cmp_klass(j_rarg0, rscratch2, rscratch1);</span>
<span class="line-added">+     __ br(Assembler::EQ, skip);</span>
<span class="line-added">+       __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));</span>
<span class="line-added">+     __ bind(skip);</span>
<span class="line-added">+ </span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // Unpack inline type args passed as oop and then jump to</span>
<span class="line-added">+     // the verified entry point (skipping the unverified entry).</span>
<span class="line-added">+     __ unpack_inline_args(ra_-&gt;C, _receiver_only);</span>
<span class="line-added">+     __ b(*_verified_entry);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ uint MachVEPNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return MachNode::size(ra_); // too many variables; just compute it the hard way</span>
<span class="line-added">+ }</span>
  
<span class="line-added">+ </span>
<span class="line-added">+ //=============================================================================</span>
  #ifndef PRODUCT
  void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  {
    st-&gt;print_cr(&quot;# MachUEPNode&quot;);
    if (UseCompressedClassPointers) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1988,13 ***</span>
  
  void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  {
    // This is the unverified entry point.
    C2_MacroAssembler _masm(&amp;cbuf);
  
    __ cmp_klass(j_rarg0, rscratch2, rscratch1);
<span class="line-modified">!   Label skip;</span>
    // TODO
    // can we avoid this skip and still use a reloc?
    __ br(Assembler::EQ, skip);
    __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
    __ bind(skip);
<span class="line-new-header">--- 2028,15 ---</span>
  
  void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  {
    // This is the unverified entry point.
    C2_MacroAssembler _masm(&amp;cbuf);
<span class="line-added">+   Label skip;</span>
  
<span class="line-added">+   // UseCompressedClassPointers logic are inside cmp_klass</span>
    __ cmp_klass(j_rarg0, rscratch2, rscratch1);
<span class="line-modified">! </span>
    // TODO
    // can we avoid this skip and still use a reloc?
    __ br(Assembler::EQ, skip);
    __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
    __ bind(skip);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2397,11 ***</span>
  }
  
  void Compile::reshape_address(AddPNode* addp) {
  }
  
<span class="line-removed">- </span>
  #define MOV_VOLATILE(REG, BASE, INDEX, SCALE, DISP, SCRATCH, INSN)      \
    C2_MacroAssembler _masm(&amp;cbuf);                                       \
    {                                                                     \
      guarantee(INDEX == -1, &quot;mode not permitted for volatile&quot;);          \
      guarantee(DISP == 0, &quot;mode not permitted for volatile&quot;);            \
<span class="line-new-header">--- 2439,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8257,10 ***</span>
<span class="line-new-header">--- 8298,25 ---</span>
    %}
  
    ins_pipe(ialu_reg);
  %}
  
<span class="line-added">+ instruct castN2X(iRegLNoSp dst, iRegN src) %{</span>
<span class="line-added">+   match(Set dst (CastP2X src));</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_cost(INSN_COST);</span>
<span class="line-added">+   format %{ &quot;mov $dst, $src\t# ptr -&gt; long&quot; %}</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added">+       __ mov(as_Register($dst$$reg), as_Register($src$$reg));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   %}</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_pipe(ialu_reg);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  instruct castP2X(iRegLNoSp dst, iRegP src) %{
    match(Set dst (CastP2X src));
  
    ins_cost(INSN_COST);
    format %{ &quot;mov $dst, $src\t# ptr -&gt; long&quot; %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8272,10 ***</span>
<span class="line-new-header">--- 8328,41 ---</span>
    %}
  
    ins_pipe(ialu_reg);
  %}
  
<span class="line-added">+ instruct castN2I(iRegINoSp dst, iRegN src) %{</span>
<span class="line-added">+   match(Set dst (CastN2I src));</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_cost(INSN_COST);</span>
<span class="line-added">+   format %{ &quot;movw $dst, $src\t# compressed ptr -&gt; int&quot; %}</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added">+       __ movw(as_Register($dst$$reg), as_Register($src$$reg));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   %}</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_pipe(ialu_reg);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct castI2N(iRegNNoSp dst, iRegI src) %{</span>
<span class="line-added">+   match(Set dst (CastI2N src));</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_cost(INSN_COST);</span>
<span class="line-added">+   format %{ &quot;movw $dst, $src\t# int -&gt; compressed ptr&quot; %}</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added">+       __ movw(as_Register($dst$$reg), as_Register($src$$reg));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   %}</span>
<span class="line-added">+ </span>
<span class="line-added">+   ins_pipe(ialu_reg);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  // Convert oop into int for vectors alignment masking
  instruct convP2I(iRegINoSp dst, iRegP src) %{
    match(Set dst (ConvL2I (CastP2X src)));
  
    ins_cost(INSN_COST);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13840,37 ***</span>
  %}
  
  // ============================================================================
  // clearing of an array
  
<span class="line-modified">! instruct clearArray_reg_reg(iRegL_R11 cnt, iRegP_R10 base, Universe dummy, rFlagsReg cr)</span>
  %{
<span class="line-modified">!   match(Set dummy (ClearArray cnt base));</span>
    effect(USE_KILL cnt, USE_KILL base, KILL cr);
  
    ins_cost(4 * INSN_COST);
<span class="line-modified">!   format %{ &quot;ClearArray $cnt, $base&quot; %}</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ zero_words($base$$Register, $cnt$$Register);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ins_pipe(pipe_class_memory);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct clearArray_imm_reg(immL cnt, iRegP_R10 base, Universe dummy, rFlagsReg cr)</span>
<span class="line-removed">- %{</span>
<span class="line-removed">-   predicate((u_int64_t)n-&gt;in(2)-&gt;get_long()</span>
<span class="line-removed">-             &lt; (u_int64_t)(BlockZeroingLowLimit &gt;&gt; LogBytesPerWord));</span>
<span class="line-removed">-   match(Set dummy (ClearArray cnt base));</span>
<span class="line-removed">-   effect(USE_KILL base);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ins_cost(4 * INSN_COST);</span>
<span class="line-removed">-   format %{ &quot;ClearArray $cnt, $base&quot; %}</span>
  
    ins_encode %{
<span class="line-modified">!     __ zero_words($base$$Register, (u_int64_t)$cnt$$constant);</span>
    %}
  
    ins_pipe(pipe_class_memory);
  %}
  
<span class="line-new-header">--- 13927,20 ---</span>
  %}
  
  // ============================================================================
  // clearing of an array
  
<span class="line-modified">! instruct clearArray_reg_reg(iRegL_R11 cnt, iRegP_R10 base, iRegL val, Universe dummy, rFlagsReg cr)</span>
  %{
<span class="line-modified">!   match(Set dummy (ClearArray (Binary cnt base) val));</span>
    effect(USE_KILL cnt, USE_KILL base, KILL cr);
  
    ins_cost(4 * INSN_COST);
<span class="line-modified">!   format %{ &quot;ClearArray $cnt, $base, $val&quot; %}</span>
  
    ins_encode %{
<span class="line-modified">!     __ fill_words($base$$Register, $cnt$$Register, $val$$Register);</span>
    %}
  
    ins_pipe(pipe_class_memory);
  %}
  
</pre>
<center><a href="../../../../.hgtags.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame_aarch64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>