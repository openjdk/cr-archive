<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../doclint/Checker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LambdaToMethod.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;
<span class="line-removed">  30 import java.util.stream.Collectors;</span>
  31 
  32 import javax.lang.model.element.ElementKind;
  33 import javax.tools.JavaFileObject;
  34 
  35 import com.sun.source.tree.CaseTree;
  36 import com.sun.source.tree.IdentifierTree;
  37 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  38 import com.sun.source.tree.MemberSelectTree;
  39 import com.sun.source.tree.TreeVisitor;
  40 import com.sun.source.util.SimpleTreeVisitor;
  41 import com.sun.tools.javac.code.*;
  42 import com.sun.tools.javac.code.Lint.LintCategory;
  43 import com.sun.tools.javac.code.Scope.WriteableScope;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Symbol.*;
  46 import com.sun.tools.javac.code.Type.*;
  47 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  48 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  49 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  50 import com.sun.tools.javac.comp.Check.CheckContext;
</pre>
<hr />
<pre>
 149         target = Target.instance(context);
 150         types = Types.instance(context);
 151         preview = Preview.instance(context);
 152         diags = JCDiagnostic.Factory.instance(context);
 153         annotate = Annotate.instance(context);
 154         typeAnnotations = TypeAnnotations.instance(context);
 155         deferredLintHandler = DeferredLintHandler.instance(context);
 156         typeEnvs = TypeEnvs.instance(context);
 157         dependencies = Dependencies.instance(context);
 158         argumentAttr = ArgumentAttr.instance(context);
 159         matchBindingsComputer = MatchBindingsComputer.instance(context);
 160 
 161         Options options = Options.instance(context);
 162 
 163         Source source = Source.instance(context);
 164         allowPoly = Feature.POLY.allowedInSource(source);
 165         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 166         allowLambda = Feature.LAMBDA.allowedInSource(source);
 167         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 168         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);

 169         allowReifiableTypesInInstanceof =
 170                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;
 171                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
 172         sourceName = source.name;
 173         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);


 174 
 175         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 176         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 177         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 178         methodAttrInfo = new MethodAttrInfo();
 179         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 180         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 181         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 182     }
 183 
 184     /** Switch: support target-typing inference
 185      */
 186     boolean allowPoly;
 187 
 188     /** Switch: support type annotations.
 189      */
 190     boolean allowTypeAnnos;
 191 
 192     /** Switch: support lambda expressions ?
 193      */
 194     boolean allowLambda;
 195 
 196     /** Switch: support default methods ?
 197      */
 198     boolean allowDefaultMethods;
 199 




 200     /** Switch: static interface methods enabled?
 201      */
 202     boolean allowStaticInterfaceMethods;
 203 
 204     /** Switch: reifiable types in instanceof enabled?
 205      */
 206     boolean allowReifiableTypesInInstanceof;
 207 
 208     /**
 209      * Switch: warn about use of variable before declaration?
 210      * RFE: 6425594
 211      */
 212     boolean useBeforeDeclarationWarning;
 213 










 214     /**
 215      * Switch: name of source level; used for error reporting.
 216      */
 217     String sourceName;
 218 
 219     /** Check kind and type of given tree against protokind and prototype.
 220      *  If check succeeds, store type in tree and return it.
 221      *  If check fails, store errType in tree and return it.
 222      *  No checks are performed if the prototype is a method type.
 223      *  It is not necessary in this case since we know that kind and type
 224      *  are correct.
 225      *
 226      *  @param tree     The tree whose kind and type is checked
 227      *  @param found    The computed type of the tree
 228      *  @param ownkind  The computed kind of the tree
 229      *  @param resultInfo  The expected result of the tree
 230      */
 231     Type check(final JCTree tree,
 232                final Type found,
 233                final KindSelector ownkind,
</pre>
<hr />
<pre>
 292      *  @param pos    The current source code position.
 293      *  @param v      The assigned variable
 294      *  @param base   If the variable is referred to in a Select, the part
 295      *                to the left of the `.&#39;, null otherwise.
 296      *  @param env    The current environment.
 297      */
 298     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 299         if (v.name == names._this) {
 300             log.error(pos, Errors.CantAssignValToThis);
 301         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 302             ((v.flags() &amp; HASINIT) != 0
 303              ||
 304              !((base == null ||
 305                TreeInfo.isThisQualifier(base)) &amp;&amp;
 306                isAssignableAsBlankFinal(v, env)))) {
 307             if (v.isResourceVariable()) { //TWR resource
 308                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
 309             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {
 310                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));
 311             } else {
<span class="line-modified"> 312                 log.error(pos, Errors.CantAssignValToFinalVar(v));</span>










 313             }
 314         }
 315     }
 316 
 317     /** Does tree represent a static reference to an identifier?
 318      *  It is assumed that tree is either a SELECT or an IDENT.
 319      *  We have to weed out selects from non-type names here.
 320      *  @param tree    The candidate tree.
 321      */
 322     boolean isStaticReference(JCTree tree) {
 323         if (tree.hasTag(SELECT)) {
 324             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 325             if (lsym == null || lsym.kind != TYP) {
 326                 return false;
 327             }
 328         }
 329         return true;
 330     }
 331 
 332     /** Is this symbol a type?
</pre>
<hr />
<pre>
 784     /** Attribute a type argument list, returning a list of types.
 785      *  Check that all the types are references.
 786      */
 787     List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 788         List&lt;Type&gt; types = attribAnyTypes(trees, env);
 789         return chk.checkRefTypes(trees, types);
 790     }
 791 
 792     /**
 793      * Attribute type variables (of generic classes or methods).
 794      * Compound types are attributed later in attribBounds.
 795      * @param typarams the type variables to enter
 796      * @param env      the current environment
 797      */
 798     void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env, boolean checkCyclic) {
 799         for (JCTypeParameter tvar : typarams) {
 800             TypeVar a = (TypeVar)tvar.type;
 801             a.tsym.flags_field |= UNATTRIBUTED;
 802             a.setUpperBound(Type.noType);
 803             if (!tvar.bounds.isEmpty()) {
<span class="line-modified"> 804                 List&lt;Type&gt; bounds = List.of(attribType(tvar.bounds.head, env));</span>
 805                 for (JCExpression bound : tvar.bounds.tail)
<span class="line-modified"> 806                     bounds = bounds.prepend(attribType(bound, env));</span>
 807                 types.setBounds(a, bounds.reverse());
 808             } else {
 809                 // if no bounds are given, assume a single bound of
 810                 // java.lang.Object.
 811                 types.setBounds(a, List.of(syms.objectType));
 812             }
 813             a.tsym.flags_field &amp;= ~UNATTRIBUTED;
 814         }
 815         if (checkCyclic) {
 816             for (JCTypeParameter tvar : typarams) {
 817                 chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
 818             }
 819         }
 820     }
 821 
 822     /**
 823      * Attribute the type references in a list of annotations.
 824      */
 825     void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
 826                                Env&lt;AttrContext&gt; env) {
</pre>
<hr />
<pre>
 947                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 948                     enter.classEnter(tree, env);
 949             }
 950 
 951             ClassSymbol c = tree.sym;
 952             if (c == null) {
 953                 // exit in case something drastic went wrong during enter.
 954                 result = null;
 955             } else {
 956                 // make sure class has been completed:
 957                 c.complete();
 958 
 959                 // If this class appears as an anonymous class
 960                 // in a superclass constructor call
 961                 // disable implicit outer instance from being passed.
 962                 // (This would be an illegal access to &quot;this before super&quot;).
 963                 if (env.info.isSelfCall &amp;&amp;
 964                         env.tree.hasTag(NEWCLASS)) {
 965                     c.flags_field |= NOOUTERTHIS;
 966                 }



 967                 attribClass(tree.pos(), c);
 968                 result = tree.type = c.type;
 969             }
 970         } finally {
 971             localCacheContext.ifPresent(LocalCacheContext::leave);
 972         }
 973     }
 974 
 975     public void visitMethodDef(JCMethodDecl tree) {
 976         MethodSymbol m = tree.sym;
 977         boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
 978 
 979         Lint lint = env.info.lint.augment(m);
 980         Lint prevLint = chk.setLint(lint);
 981         MethodSymbol prevMethod = chk.setMethod(m);
 982         try {
 983             deferredLintHandler.flush(tree.pos());
 984             chk.checkDeprecatedAnnotation(tree.pos(), m);
 985 
 986 
</pre>
<hr />
<pre>
1168                         log.error(tree.pos(),
1169                                   Errors.DefaultAllowedInIntfAnnotationMember);
1170                 }
1171                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1172                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1173             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1174                 if ((owner.flags() &amp; INTERFACE) != 0) {
1175                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1176                 } else {
1177                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1178                 }
1179             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1180                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1181             } else {
1182                 // Add an implicit super() call unless an explicit call to
1183                 // super(...) or this(...) is given
1184                 // or we are compiling class java.lang.Object.
1185                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1186                     JCBlock body = tree.body;
1187                     if (body.stats.isEmpty() ||
<span class="line-modified">1188                             TreeInfo.getConstructorInvocationName(body.stats, names) == names.empty) {</span>
1189                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1190                                 make.Ident(names._super), make.Idents(List.nil())));
1191                         body.stats = body.stats.prepend(supCall);
1192                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1193                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1194                             TreeInfo.isSuperCall(body.stats.head)) {
1195                         // enum constructors are not allowed to call super
1196                         // directly, so make sure there aren&#39;t any super calls
1197                         // in enum constructors, except in the compiler
1198                         // generated one.
1199                         log.error(tree.body.stats.head.pos(),
1200                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1201                     }
1202                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1203                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1204                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1205                         if (!initParamNames.equals(recordComponentNames)) {
1206                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1207                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1208                         }
1209                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1210                             log.error(tree,
1211                                     Errors.InvalidCanonicalConstructorInRecord(
1212                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1213                                             env.enclClass.sym.name,
1214                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1215                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1216                         }
1217                     }
1218                 }






1219 
1220                 // Attribute all type annotations in the body
1221                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1222                 annotate.flush();
1223 
1224                 // Attribute method body.
1225                 attribStat(tree.body, localEnv);
1226             }
1227 
1228             localEnv.info.scope.leave();
1229             result = tree.type = m.type;
1230         } finally {
1231             chk.setLint(prevLint);
1232             chk.setMethod(prevMethod);
1233         }
1234     }
1235 
1236     public void visitVarDef(JCVariableDecl tree) {
1237         // Local variables have not been entered yet, so we need to do it now:
1238         if (env.info.scope.owner.kind == MTH || env.info.scope.owner.kind == VAR) {
</pre>
<hr />
<pre>
1268                 annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());
1269                 annotate.flush();
1270             }
1271         }
1272 
1273         VarSymbol v = tree.sym;
1274         Lint lint = env.info.lint.augment(v);
1275         Lint prevLint = chk.setLint(lint);
1276 
1277         // Check that the variable&#39;s declared type is well-formed.
1278         boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;
1279                 ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1280                 (tree.sym.flags() &amp; PARAMETER) != 0;
1281         chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
1282 
1283         try {
1284             v.getConstValue(); // ensure compile-time constant initializer is evaluated
1285             deferredLintHandler.flush(tree.pos());
1286             chk.checkDeprecatedAnnotation(tree.pos(), v);
1287 



1288             if (tree.init != null) {
<span class="line-modified">1289                 if ((v.flags_field &amp; FINAL) == 0 ||</span>
1290                     !memberEnter.needsLazyConstValue(tree.init)) {
1291                     // Not a compile-time constant
1292                     // Attribute initializer in a new environment
1293                     // with the declared variable as owner.
1294                     // Check that initializer conforms to variable&#39;s declared type.
1295                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1296                     initEnv.info.lint = lint;
1297                     // In order to catch self-references, we set the variable&#39;s
1298                     // declaration position to maximal possible value, effectively
1299                     // marking the variable as undefined.
1300                     initEnv.info.enclVar = v;
1301                     attribExpr(tree.init, initEnv, v.type);
1302                     if (tree.isImplicitlyTyped()) {
1303                         //fixup local variable type
1304                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1305                     }
1306                 }
1307                 if (tree.isImplicitlyTyped()) {
1308                     setSyntheticVariableType(tree, v.type);
1309                 }
</pre>
<hr />
<pre>
1393             }
1394         }
1395     }
1396 
1397     public void visitSkip(JCSkip tree) {
1398         result = null;
1399     }
1400 
1401     public void visitBlock(JCBlock tree) {
1402         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {
1403             // Block is a static or instance initializer;
1404             // let the owner of the environment be a freshly
1405             // created BLOCK-method.
1406             Symbol fakeOwner =
1407                 new MethodSymbol(tree.flags | BLOCK |
1408                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1409                     env.info.scope.owner);
1410             final Env&lt;AttrContext&gt; localEnv =
1411                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1412 
<span class="line-modified">1413             if ((tree.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;</span>




1414             // Attribute all type annotations in the block
1415             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1416             annotate.flush();
1417             attribStats(tree.stats, localEnv);
1418 
1419             {
1420                 // Store init and clinit type annotations with the ClassSymbol
1421                 // to allow output in Gen.normalizeDefs.
1422                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
1423                 List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();
1424                 if ((tree.flags &amp; STATIC) != 0) {
1425                     cs.appendClassInitTypeAttributes(tas);
1426                 } else {
1427                     cs.appendInitTypeAttributes(tas);
1428                 }
1429             }
1430         } else {
1431             // Create a new local environment with a local scope.
1432             Env&lt;AttrContext&gt; localEnv =
1433                 env.dup(tree, env.info.dup(env.info.scope.dup()));
</pre>
<hr />
<pre>
1458         // include condition&#39;s bindings when true in the body:
1459         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1460         try {
1461             attribStat(tree.body, whileEnv.dup(tree));
1462         } finally {
1463             whileEnv.info.scope.leave();
1464         }
1465         if (!breaksOutOf(tree, tree.body)) {
1466             //include condition&#39;s bindings when false after the while, if cannot get out of the loop
1467             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1468             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1469         }
1470         result = null;
1471     }
1472 
1473     private boolean breaksOutOf(JCTree loop, JCTree body) {
1474         preFlow(body);
1475         return flow.breaksOutOf(env, loop, body, make);
1476     }
1477 

































1478     public void visitForLoop(JCForLoop tree) {
1479         Env&lt;AttrContext&gt; loopEnv =
1480             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1481         MatchBindings condBindings = MatchBindingsComputer.EMPTY;
1482         try {
1483             attribStats(tree.init, loopEnv);
1484             if (tree.cond != null) {
1485                 attribExpr(tree.cond, loopEnv, syms.booleanType);
1486                 // include condition&#39;s bindings when true in the body and step:
1487                 condBindings = matchBindings;
1488             }
1489             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);
1490             try {
1491                 bodyEnv.tree = tree; // before, we were not in loop!
1492                 attribStats(tree.step, bodyEnv);
1493                 attribStat(tree.body, bodyEnv);
1494             } finally {
1495                 bodyEnv.info.scope.leave();
1496             }
1497             result = null;
</pre>
<hr />
<pre>
1501         }
1502         if (!breaksOutOf(tree, tree.body)) {
1503             //include condition&#39;s body when false after the while, if cannot get out of the loop
1504             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1505             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1506         }
1507     }
1508 
1509     public void visitForeachLoop(JCEnhancedForLoop tree) {
1510         Env&lt;AttrContext&gt; loopEnv =
1511             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1512         try {
1513             //the Formal Parameter of a for-each loop is not in the scope when
1514             //attributing the for-each expression; we mimic this by attributing
1515             //the for-each expression first (against original scope).
1516             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1517             chk.checkNonVoid(tree.pos(), exprType);
1518             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1519             if (elemtype == null) {
1520                 // or perhaps expr implements Iterable&lt;T&gt;?
<span class="line-modified">1521                 Type base = types.asSuper(exprType, syms.iterableType.tsym);</span>
1522                 if (base == null) {
1523                     log.error(tree.expr.pos(),
1524                               Errors.ForeachNotApplicableToType(exprType,
1525                                                                 Fragments.TypeReqArrayOrIterable));
1526                     elemtype = types.createErrorType(exprType);
1527                 } else {
1528                     List&lt;Type&gt; iterableParams = base.allparams();
1529                     elemtype = iterableParams.isEmpty()
1530                         ? syms.objectType
1531                         : types.wildUpperBound(iterableParams.head);
1532                 }
1533             }
1534             if (tree.var.isImplicitlyTyped()) {
1535                 Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);
1536                 setSyntheticVariableType(tree.var, inferredType);
1537             }
1538             attribStat(tree.var, loopEnv);
1539             chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
1540             loopEnv.tree = tree; // before, we were not in loop!
1541             attribStat(tree.body, loopEnv);
</pre>
<hr />
<pre>
1715     // where
1716     /** Return the selected enumeration constant symbol, or null. */
1717     private Symbol enumConstant(JCTree tree, Type enumType) {
1718         if (tree.hasTag(IDENT)) {
1719             JCIdent ident = (JCIdent)tree;
1720             Name name = ident.name;
1721             for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {
1722                 if (sym.kind == VAR) {
1723                     Symbol s = ident.sym = sym;
1724                     ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated
1725                     ident.type = s.type;
1726                     return ((s.flags_field &amp; Flags.ENUM) == 0)
1727                         ? null : s;
1728                 }
1729             }
1730         }
1731         return null;
1732     }
1733 
1734     public void visitSynchronized(JCSynchronized tree) {
<span class="line-modified">1735         chk.checkRefType(tree.pos(), attribExpr(tree.lock, env));</span>
1736         attribStat(tree.body, env);
1737         result = null;
1738     }
1739 
1740     public void visitTry(JCTry tree) {
1741         // Create a new local environment with a local
1742         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
1743         try {
1744             boolean isTryWithResource = tree.resources.nonEmpty();
1745             // Create a nested environment for attributing the try block if needed
1746             Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
1747                 env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
1748                 localEnv;
1749             try {
1750                 // Attribute resource declarations
1751                 for (JCTree resource : tree.resources) {
1752                     CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
1753                         @Override
1754                         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1755                             chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
</pre>
<hr />
<pre>
1796                     chk.checkType(c.param.vartype.pos(),
1797                                   chk.checkClassType(c.param.vartype.pos(), ctype),
1798                                   syms.throwableType);
1799                     attribStat(c.body, catchEnv);
1800                 } finally {
1801                     catchEnv.info.scope.leave();
1802                 }
1803             }
1804 
1805             // Attribute finalizer
1806             if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);
1807             result = null;
1808         }
1809         finally {
1810             localEnv.info.scope.leave();
1811         }
1812     }
1813 
1814     void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {
1815         if (!resource.isErroneous() &amp;&amp;
<span class="line-modified">1816             types.asSuper(resource, syms.autoCloseableType.tsym) != null &amp;&amp;</span>
1817             !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself
1818             Symbol close = syms.noSymbol;
1819             Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
1820             try {
1821                 close = rs.resolveQualifiedMethod(pos,
1822                         env,
1823                         types.skipTypeVars(resource, false),
1824                         names.close,
1825                         List.nil(),
1826                         List.nil());
1827             }
1828             finally {
1829                 log.popDiagnosticHandler(discardHandler);
1830             }
1831             if (close.kind == MTH &amp;&amp;
1832                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1833                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1834                     env.info.lint.isEnabled(LintCategory.TRY)) {
1835                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1836             }
</pre>
<hr />
<pre>
2396             // ... and attribute the method using as a prototype a methodtype
2397             // whose formal argument types is exactly the list of actual
2398             // arguments (this will also set the method symbol).
2399             Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2400             localEnv.info.pendingResolutionPhase = null;
2401             Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
2402 
2403             // Compute the result type.
2404             Type restype = mtype.getReturnType();
2405             if (restype.hasTag(WILDCARD))
2406                 throw new AssertionError(mtype);
2407 
2408             Type qualifier = (tree.meth.hasTag(SELECT))
2409                     ? ((JCFieldAccess) tree.meth).selected.type
2410                     : env.enclClass.sym.type;
2411             Symbol msym = TreeInfo.symbol(tree.meth);
2412             restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
2413 
2414             chk.checkRefTypes(tree.typeargs, typeargtypes);
2415 




































2416             // Check that value of resulting type is admissible in the
2417             // current context.  Also, capture the return type
2418             Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);
2419             result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
2420         }
2421         chk.validate(tree.typeargs, localEnv);
2422     }
2423     //where
2424         Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {
2425             if (msym != null &amp;&amp;
2426                     msym.owner == syms.objectType.tsym &amp;&amp;
2427                     methodName == names.getClass &amp;&amp;
2428                     argtypes.isEmpty()) {
2429                 // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;









2430                 return new ClassType(restype.getEnclosingType(),
<span class="line-modified">2431                         List.of(new WildcardType(types.erasure(qualifierType),</span>
2432                                 BoundKind.EXTENDS,
2433                                 syms.boundClass)),
2434                         restype.tsym,
2435                         restype.getMetadata());
2436             } else if (msym != null &amp;&amp;
2437                     msym.owner == syms.arrayClass &amp;&amp;
2438                     methodName == names.clone &amp;&amp;
2439                     types.isArray(qualifierType)) {
2440                 // as a special case, array.clone() has a result that is
2441                 // the same as static type of the array being cloned
2442                 return qualifierType;
2443             } else {
2444                 return restype;
2445             }
2446         }
2447 
2448         /** Check that given application node appears as first statement
2449          *  in a constructor call.
2450          *  @param tree          The application node
2451          *  @param enclMethod    The enclosing method of the application.
</pre>
<hr />
<pre>
2584         }
2585 
2586         // Attribute constructor arguments.
2587         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2588         final KindSelector pkind =
2589             attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2590         List&lt;Type&gt; argtypes = argtypesBuf.toList();
2591         List&lt;Type&gt; typeargtypes = attribTypes(tree.typeargs, localEnv);
2592 
2593         if (clazztype.hasTag(CLASS) || clazztype.hasTag(ERROR)) {
2594             // Enums may not be instantiated except implicitly
2595             if ((clazztype.tsym.flags_field &amp; Flags.ENUM) != 0 &amp;&amp;
2596                 (!env.tree.hasTag(VARDEF) ||
2597                  (((JCVariableDecl) env.tree).mods.flags &amp; Flags.ENUM) == 0 ||
2598                  ((JCVariableDecl) env.tree).init != tree))
2599                 log.error(tree.pos(), Errors.EnumCantBeInstantiated);
2600 
2601             boolean isSpeculativeDiamondInferenceRound = TreeInfo.isDiamond(tree) &amp;&amp;
2602                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
2603             boolean skipNonDiamondPath = false;








2604             // Check that class is not abstract
2605             if (cdef == null &amp;&amp; !isSpeculativeDiamondInferenceRound &amp;&amp; // class body may be nulled out in speculative tree copy
2606                 (clazztype.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
2607                 log.error(tree.pos(),
2608                           Errors.AbstractCantBeInstantiated(clazztype.tsym));
2609                 skipNonDiamondPath = true;
2610             } else if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2611                 // Check that no constructor arguments are given to
2612                 // anonymous classes implementing an interface
2613                 if (!argtypes.isEmpty())
2614                     log.error(tree.args.head.pos(), Errors.AnonClassImplIntfNoArgs);
2615 
2616                 if (!typeargtypes.isEmpty())
2617                     log.error(tree.typeargs.head.pos(), Errors.AnonClassImplIntfNoTypeargs);
2618 
2619                 // Error recovery: pretend no arguments were supplied.
2620                 argtypes = List.nil();
2621                 typeargtypes = List.nil();
2622                 skipNonDiamondPath = true;
2623             }
</pre>
<hr />
<pre>
2755                                 this.resultInfo = prevResult;
2756                             }
2757                         });
2758             } else {
2759                 if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
2760                     List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
2761                     if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {
2762                         // One or more types inferred in the previous steps is non-denotable.
2763                         Fragment fragment = Diamond(clazztype.tsym);
2764                         log.error(tree.clazz.pos(),
2765                                 Errors.CantApplyDiamond1(
2766                                         fragment,
2767                                         invalidDiamondArgs.size() &gt; 1 ?
2768                                                 DiamondInvalidArgs(invalidDiamondArgs, fragment) :
2769                                                 DiamondInvalidArg(invalidDiamondArgs, fragment)));
2770                     }
2771                     // For &lt;&gt;(){}, inferred types must also be accessible.
2772                     for (Type t : clazztype.getTypeArguments()) {
2773                         rs.checkAccessibleType(env, t);
2774                     }

2775                 }
2776 
2777                 // If we already errored, be careful to avoid a further avalanche. ErrorType answers
2778                 // false for isInterface call even when the original type is an interface.
2779                 boolean implementing = clazztype.tsym.isInterface() ||
2780                         clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
2781                         clazztype.getOriginalType().tsym.isInterface();
2782 
2783                 if (implementing) {
2784                     cdef.implementing = List.of(clazz);
2785                 } else {
2786                     cdef.extending = clazz;
2787                 }
2788 
2789                 if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
2790                     isSerializable(clazztype)) {
2791                     localEnv.info.isSerializable = true;
2792                 }
2793 
2794                 attribStat(cdef, localEnv);
</pre>
<hr />
<pre>
2827             result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));
2828             chk.validate(tree.typeargs, localEnv);
2829         }
2830 
2831         CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {
2832             return new Check.NestedCheckContext(checkContext) {
2833                 @Override
2834                 public void report(DiagnosticPosition _unused, JCDiagnostic details) {
2835                     enclosingContext.report(clazz.clazz,
2836                             diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
2837                 }
2838             };
2839         }
2840 
2841     /** Make an attributed null check tree.
2842      */
2843     public JCExpression makeNullCheck(JCExpression arg) {
2844         // optimization: new Outer() can never be null; skip null check
2845         if (arg.getTag() == NEWCLASS)
2846             return arg;



2847         // optimization: X.this is never null; skip null check
2848         Name name = TreeInfo.name(arg);
2849         if (name == names._this || name == names._super) return arg;
2850 
2851         JCTree.Tag optag = NULLCHK;
2852         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
2853         tree.operator = operators.resolveUnary(arg, optag, arg.type);
2854         tree.type = arg.type;
2855         return tree;
2856     }
2857 
2858     public void visitNewArray(JCNewArray tree) {
2859         Type owntype = types.createErrorType(tree.type);
2860         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2861         Type elemtype;
2862         if (tree.elemtype != null) {
2863             elemtype = attribType(tree.elemtype, localEnv);
2864             chk.validate(tree.elemtype, localEnv);
2865             owntype = elemtype;
2866             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
</pre>
<hr />
<pre>
3840         if (operator != operators.noOpSymbol &amp;&amp;
3841                 !left.isErroneous() &amp;&amp;
3842                 !right.isErroneous()) {
3843             owntype = operator.type.getReturnType();
3844             int opc = ((OperatorSymbol)operator).opcode;
3845             // If both arguments are constants, fold them.
3846             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3847                 Type ctype = cfolder.fold2(opc, left, right);
3848                 if (ctype != null) {
3849                     owntype = cfolder.coerce(ctype, owntype);
3850                 }
3851             }
3852 
3853             // Check that argument types of a reference ==, != are
3854             // castable to each other, (JLS 15.21).  Note: unboxing
3855             // comparisons will not have an acmp* opc at this point.
3856             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
3857                 if (!types.isCastable(left, right, new Warner(tree.pos()))) {
3858                     log.error(tree.pos(), Errors.IncomparableTypes(left, right));
3859                 }

3860             }
3861 
3862             chk.checkDivZero(tree.rhs.pos(), operator, right);
3863         }
3864         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3865     }
3866 
3867     public void visitTypeCast(final JCTypeCast tree) {
3868         Type clazztype = attribType(tree.clazz, env);
3869         chk.validate(tree.clazz, env, false);
3870         //a fresh environment is required for 292 inference to work properly ---
3871         //see Infer.instantiatePolymorphicSignatureInstance()
3872         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
3873         //should we propagate the target type?
3874         final ResultInfo castInfo;
3875         JCExpression expr = TreeInfo.skipParens(tree.expr);
3876         boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
3877         if (isPoly) {
3878             //expression is a poly - we need to propagate target type info
3879             castInfo = new ResultInfo(KindSelector.VAL, clazztype,
</pre>
<hr />
<pre>
4037         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4038             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4039             // If the found symbol is inaccessible, then it is
4040             // accessed through an enclosing instance.  Locate this
4041             // enclosing instance:
4042             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4043                 env1 = env1.outer;
4044         }
4045 
4046         if (env.info.isSerializable) {
4047             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4048         }
4049 
4050         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4051     }
4052 
4053     public void visitSelect(JCFieldAccess tree) {
4054         // Determine the expected kind of the qualifier expression.
4055         KindSelector skind = KindSelector.NIL;
4056         if (tree.name == names._this || tree.name == names._super ||
<span class="line-modified">4057                 tree.name == names._class)</span>
4058         {




4059             skind = KindSelector.TYP;
4060         } else {
4061             if (pkind().contains(KindSelector.PCK))
4062                 skind = KindSelector.of(skind, KindSelector.PCK);
4063             if (pkind().contains(KindSelector.TYP))
4064                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4065             if (pkind().contains(KindSelector.VAL_MTH))
4066                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4067         }
4068 
4069         // Attribute the qualifier expression, and determine its symbol (if any).
4070         Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));
4071         if (!pkind().contains(KindSelector.TYP_PCK))
4072             site = capture(site); // Capture field access
4073 
4074         // don&#39;t allow T.class T[].class, etc
4075         if (skind == KindSelector.TYP) {
4076             Type elt = site;
4077             while (elt.hasTag(ARRAY))
4078                 elt = ((ArrayType)elt).elemtype;
4079             if (elt.hasTag(TYPEVAR)) {
<span class="line-modified">4080                 log.error(tree.pos(), Errors.TypeVarCantBeDeref);</span>
<span class="line-modified">4081                 result = tree.type = types.createErrorType(tree.name, site.tsym, site);</span>
<span class="line-modified">4082                 tree.sym = tree.type.tsym;</span>
<span class="line-modified">4083                 return ;</span>





4084             }
4085         }
4086 
4087         // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;
4088         // for the selection. This is relevant for determining whether
4089         // protected symbols are accessible.
4090         Symbol sitesym = TreeInfo.symbol(tree.selected);

4091         boolean selectSuperPrev = env.info.selectSuper;
4092         env.info.selectSuper =
4093             sitesym != null &amp;&amp;
4094             sitesym.name == names._super;
4095 
4096         // Determine the symbol represented by the selection.
4097         env.info.pendingResolutionPhase = null;
4098         Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
4099         if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
4100             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
4101             sym = syms.errSymbol;
4102         }
4103         if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
4104             site = capture(site);
4105             sym = selectSym(tree, sitesym, site, env, resultInfo);
4106         }
4107         boolean varArgs = env.info.lastResolveVarargs();
4108         tree.sym = sym;
4109 
4110         if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
</pre>
<hr />
<pre>
4206                                  Env&lt;AttrContext&gt; env,
4207                                  ResultInfo resultInfo) {
4208             DiagnosticPosition pos = tree.pos();
4209             Name name = tree.name;
4210             switch (site.getTag()) {
4211             case PACKAGE:
4212                 return rs.accessBase(
4213                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),
4214                     pos, location, site, name, true);
4215             case ARRAY:
4216             case CLASS:
4217                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4218                     return rs.resolveQualifiedMethod(
4219                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4220                 } else if (name == names._this || name == names._super) {
4221                     return rs.resolveSelf(pos, env, site.tsym, name);
4222                 } else if (name == names._class) {
4223                     // In this case, we have already made sure in
4224                     // visitSelect that qualifier expression is a type.
4225                     return syms.getClassField(site, types);






4226                 } else {
4227                     // We are seeing a plain identifier as selector.
4228                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
4229                         sym = rs.accessBase(sym, pos, location, site, name, true);
4230                     return sym;
4231                 }
4232             case WILDCARD:
4233                 throw new AssertionError(tree);
4234             case TYPEVAR:




4235                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4236                 // It should only happen during memberEnter/attribBase
4237                 // when determining the super type which *must* be
4238                 // done before attributing the type variables.  In
4239                 // other words, we are seeing this illegal program:
4240                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4241                 Symbol sym = (site.getUpperBound() != null)
4242                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4243                     : null;
4244                 if (sym == null) {
4245                     log.error(pos, Errors.TypeVarCantBeDeref);
4246                     return syms.errSymbol;
4247                 } else {
4248                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4249                         rs.new AccessError(env, site, sym) :
4250                                 sym;
4251                     rs.accessBase(sym2, pos, location, site, name, true);
4252                     return sym;
4253                 }
4254             case ERROR:
4255                 // preserve identifier names through errors
4256                 return types.createErrorType(name, site.tsym, site).tsym;
4257             default:
4258                 // The qualifier expression is of a primitive type -- only
<span class="line-modified">4259                 // .class is allowed for these.</span>
4260                 if (name == names._class) {
4261                     // In this case, we have already made sure in Select that
4262                     // qualifier expression is a type.
4263                     return syms.getClassField(site, types);


4264                 } else {
4265                     log.error(pos, Errors.CantDeref(site));
4266                     return syms.errSymbol;
4267                 }
4268             }
4269         }
4270 
4271         /** Determine type of identifier or select expression and check that
4272          *  (1) the referenced symbol is not deprecated
4273          *  (2) the symbol&#39;s type is safe (@see checkSafe)
4274          *  (3) if symbol is a variable, check that its type and kind are
4275          *      compatible with the prototype and protokind.
4276          *  (4) if symbol is an instance field of a raw type,
4277          *      which is being assigned to, issue an unchecked warning if its
4278          *      type changes under erasure.
4279          *  (5) if symbol is an instance method of a raw type, issue an
4280          *      unchecked warning if its argument types change under erasure.
4281          *  If checks succeed:
4282          *    If symbol is a constant, return its constant type
4283          *    else if symbol is a method, return its result type
</pre>
<hr />
<pre>
4855         if (bounds.length() == 0) {
4856             return syms.objectType;
4857         } else if (bounds.length() == 1) {
4858             return bounds.head.type;
4859         } else {
4860             Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));
4861             // ... the variable&#39;s bound is a class type flagged COMPOUND
4862             // (see comment for TypeVar.bound).
4863             // In this case, generate a class tree that represents the
4864             // bound class, ...
4865             JCExpression extending;
4866             List&lt;JCExpression&gt; implementing;
4867             if (!bounds.head.type.isInterface()) {
4868                 extending = bounds.head;
4869                 implementing = bounds.tail;
4870             } else {
4871                 extending = null;
4872                 implementing = bounds;
4873             }
4874             JCClassDecl cd = make.at(tree).ClassDef(
<span class="line-modified">4875                 make.Modifiers(PUBLIC | ABSTRACT),</span>
4876                 names.empty, List.nil(),
4877                 extending, implementing, List.nil());
4878 
4879             ClassSymbol c = (ClassSymbol)owntype.tsym;
4880             Assert.check((c.flags() &amp; COMPOUND) != 0);
4881             cd.sym = c;
4882             c.sourcefile = env.toplevel.sourcefile;
4883 
4884             // ... and attribute the bound class
4885             c.flags_field |= UNATTRIBUTED;
4886             Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);
4887             typeEnvs.put(c, cenv);
4888             attribClass(c);
4889             return owntype;
4890         }
4891     }
4892 
4893     public void visitWildcard(JCWildcard tree) {
4894         //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
4895         Type type = (tree.kind.kind == BoundKind.UNBOUND)
4896             ? syms.objectType
4897             : attribType(tree.inner, env);
<span class="line-modified">4898         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),</span>
4899                                               tree.kind.kind,
4900                                               syms.boundClass),
4901                 KindSelector.TYP, resultInfo);
4902     }
4903 
4904     public void visitAnnotation(JCAnnotation tree) {
4905         Assert.error(&quot;should be handled in annotate&quot;);
4906     }
4907 
4908     public void visitAnnotatedType(JCAnnotatedType tree) {
4909         attribAnnotationTypes(tree.annotations, env);
4910         Type underlyingType = attribType(tree.underlyingType, env);
4911         Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);
4912 
4913         if (!env.info.isNewClass)
4914             annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
4915         result = tree.type = annotatedType;
4916     }
4917 
4918     public void visitErroneous(JCErroneous tree) {
</pre>
<hr />
<pre>
4982             chk.completionError(pos, ex);
4983         }
4984     }
4985 
4986     void attribModule(ModuleSymbol m) {
4987         // Get environment current at the point of module definition.
4988         Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
4989         attribStat(env.tree, env);
4990     }
4991 
4992     /** Main method: attribute class definition associated with given class symbol.
4993      *  reporting completion failures at the given position.
4994      *  @param pos The source position at which completion errors are to be
4995      *             reported.
4996      *  @param c   The class symbol whose definition will be attributed.
4997      */
4998     public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
4999         try {
5000             annotate.flush();
5001             attribClass(c);







5002         } catch (CompletionFailure ex) {
5003             chk.completionError(pos, ex);
5004         }
5005     }
5006 
5007     /** Attribute class definition associated with given class symbol.
5008      *  @param c   The class symbol whose definition will be attributed.
5009      */
5010     void attribClass(ClassSymbol c) throws CompletionFailure {
5011         if (c.type.hasTag(ERROR)) return;
5012 
5013         // Check for cycles in the inheritance graph, which can arise from
5014         // ill-formed class files.
5015         chk.checkNonCyclic(null, c.type);
5016 
5017         Type st = types.supertype(c.type);
5018         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5019             // First, attribute superclass.
5020             if (st.hasTag(CLASS))
5021                 attribClass((ClassSymbol)st.tsym);
</pre>
<hr />
<pre>
5088                         }
5089                     }
5090                 }
5091             }
5092 
5093             List&lt;ClassSymbol&gt; sealedSupers = types.directSupertypes(c.type)
5094                                                   .stream()
5095                                                   .filter(s -&gt; s.tsym.isSealed())
5096                                                   .map(s -&gt; (ClassSymbol) s.tsym)
5097                                                   .collect(List.collector());
5098 
5099             if (sealedSupers.isEmpty()) {
5100                 if ((c.flags_field &amp; Flags.NON_SEALED) != 0) {
5101                     boolean hasErrorSuper = types.directSupertypes(c.type)
5102                                                  .stream()
5103                                                  .anyMatch(s -&gt; s.tsym.kind == Kind.ERR);
5104                     if (!hasErrorSuper) {
5105                         log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));
5106                     }
5107                 }
<span class="line-modified">5108             } else {</span>
5109                 if (c.isLocal() &amp;&amp; !c.isEnum()) {
5110                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed);
5111                 }
5112 
5113                 for (ClassSymbol supertypeSym : sealedSupers) {
5114                     if (!supertypeSym.permitted.contains(c.type.tsym)) {
5115                         log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));
5116                     }
5117                 }
5118                 if (!c.isNonSealed() &amp;&amp; !c.isFinal() &amp;&amp; !c.isSealed()) {
5119                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree),
5120                             c.isInterface() ?
5121                                     Errors.NonSealedOrSealedExpected :
5122                                     Errors.NonSealedSealedOrFinalExpected);
5123                 }
5124             }
5125 
5126             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5127             // because the annotations were not available at the time the env was created. Therefore,
5128             // we look up the environment chain for the first enclosing environment for which the
</pre>
<hr />
<pre>
5143                 deferredLintHandler.flush(env.tree);
5144                 env.info.returnResult = null;
5145                 // java.lang.Enum may not be subclassed by a non-enum
5146                 if (st.tsym == syms.enumSym &amp;&amp;
5147                     ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))
5148                     log.error(env.tree.pos(), Errors.EnumNoSubclassing);
5149 
5150                 // Enums may not be extended by source-level classes
5151                 if (st.tsym != null &amp;&amp;
5152                     ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;
5153                     ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {
5154                     log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);
5155                 }
5156 
5157                 if (isSerializable(c.type)) {
5158                     env.info.isSerializable = true;
5159                 }
5160 
5161                 attribClassBody(env, c);
5162 








5163                 chk.checkDeprecatedAnnotation(env.tree.pos(), c);
5164                 chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
5165                 chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
5166                 chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);
5167             } finally {
5168                 env.info.returnResult = prevReturnRes;
5169                 log.useSource(prev);
5170                 chk.setLint(prevLint);
5171             }
5172 
5173         }
5174     }
5175 
5176     public void visitImport(JCImport tree) {
5177         // nothing to do
5178     }
5179 
5180     public void visitModuleDef(JCModuleDecl tree) {
5181         tree.sym.completeUsesProvides();
5182         ModuleSymbol msym = tree.sym;
</pre>
<hr />
<pre>
5248         chk.checkClassBounds(tree.pos(), c.type);
5249 
5250         tree.type = c.type;
5251 
5252         for (List&lt;JCTypeParameter&gt; l = tree.typarams;
5253              l.nonEmpty(); l = l.tail) {
5254              Assert.checkNonNull(env.info.scope.findFirst(l.head.name));
5255         }
5256 
5257         // Check that a generic class doesn&#39;t extend Throwable
5258         if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))
5259             log.error(tree.extending.pos(), Errors.GenericThrowable);
5260 
5261         // Check that all methods which implement some
5262         // method conform to the method they implement.
5263         chk.checkImplementations(tree);
5264 
5265         //check that a resource implementing AutoCloseable cannot throw InterruptedException
5266         checkAutoCloseable(tree.pos(), env, c.type);
5267 

5268         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
5269             // Attribute declaration
5270             attribStat(l.head, env);




5271             // Check that declarations in inner classes are not static (JLS 8.1.2)
5272             // Make an exception for static constants.
5273             if (c.owner.kind != PCK &amp;&amp;
5274                 ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
5275                 (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
5276                 Symbol sym = null;
5277                 if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
5278                 if (sym == null ||
5279                     sym.kind != VAR ||
5280                     ((VarSymbol) sym).getConstValue() == null)
5281                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5282             }
5283         }



5284 
5285         // Check for cycles among non-initial constructors.
5286         chk.checkCyclicConstructors(tree);
5287 
5288         // Check for cycles among annotation elements.
5289         chk.checkNonCyclicElements(tree);
5290 
5291         // Check for proper use of serialVersionUID
5292         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5293                 &amp;&amp; isSerializable(c.type)
5294                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5295                 &amp;&amp; !c.isAnonymous()) {
5296             checkSerialVersionUID(tree, c);
5297         }
5298         if (allowTypeAnnos) {
5299             // Correctly organize the positions of the type annotations
5300             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5301 
5302             // Check type annotations applicability rules
5303             validateTypeAnnotations(tree, false);
</pre>
</td>
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;

  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileObject;
  33 
  34 import com.sun.source.tree.CaseTree;
  35 import com.sun.source.tree.IdentifierTree;
  36 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  37 import com.sun.source.tree.MemberSelectTree;
  38 import com.sun.source.tree.TreeVisitor;
  39 import com.sun.source.util.SimpleTreeVisitor;
  40 import com.sun.tools.javac.code.*;
  41 import com.sun.tools.javac.code.Lint.LintCategory;
  42 import com.sun.tools.javac.code.Scope.WriteableScope;
  43 import com.sun.tools.javac.code.Source.Feature;
  44 import com.sun.tools.javac.code.Symbol.*;
  45 import com.sun.tools.javac.code.Type.*;
  46 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  47 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  48 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  49 import com.sun.tools.javac.comp.Check.CheckContext;
</pre>
<hr />
<pre>
 148         target = Target.instance(context);
 149         types = Types.instance(context);
 150         preview = Preview.instance(context);
 151         diags = JCDiagnostic.Factory.instance(context);
 152         annotate = Annotate.instance(context);
 153         typeAnnotations = TypeAnnotations.instance(context);
 154         deferredLintHandler = DeferredLintHandler.instance(context);
 155         typeEnvs = TypeEnvs.instance(context);
 156         dependencies = Dependencies.instance(context);
 157         argumentAttr = ArgumentAttr.instance(context);
 158         matchBindingsComputer = MatchBindingsComputer.instance(context);
 159 
 160         Options options = Options.instance(context);
 161 
 162         Source source = Source.instance(context);
 163         allowPoly = Feature.POLY.allowedInSource(source);
 164         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 165         allowLambda = Feature.LAMBDA.allowedInSource(source);
 166         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 167         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);
<span class="line-added"> 168         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);</span>
 169         allowReifiableTypesInInstanceof =
 170                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;
 171                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
 172         sourceName = source.name;
 173         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
<span class="line-added"> 174         allowEmptyValues = options.isSet(&quot;allowEmptyValues&quot;);</span>
<span class="line-added"> 175         allowValueMemberCycles = options.isSet(&quot;allowValueMemberCycles&quot;);</span>
 176 
 177         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 178         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 179         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 180         methodAttrInfo = new MethodAttrInfo();
 181         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 182         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 183         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 184     }
 185 
 186     /** Switch: support target-typing inference
 187      */
 188     boolean allowPoly;
 189 
 190     /** Switch: support type annotations.
 191      */
 192     boolean allowTypeAnnos;
 193 
 194     /** Switch: support lambda expressions ?
 195      */
 196     boolean allowLambda;
 197 
 198     /** Switch: support default methods ?
 199      */
 200     boolean allowDefaultMethods;
 201 
<span class="line-added"> 202     /** Switch: allow inline types?</span>
<span class="line-added"> 203      */</span>
<span class="line-added"> 204     boolean allowInlineTypes;</span>
<span class="line-added"> 205 </span>
 206     /** Switch: static interface methods enabled?
 207      */
 208     boolean allowStaticInterfaceMethods;
 209 
 210     /** Switch: reifiable types in instanceof enabled?
 211      */
 212     boolean allowReifiableTypesInInstanceof;
 213 
 214     /**
 215      * Switch: warn about use of variable before declaration?
 216      * RFE: 6425594
 217      */
 218     boolean useBeforeDeclarationWarning;
 219 
<span class="line-added"> 220     /**</span>
<span class="line-added"> 221      * Switch: Allow value types with no instance state?</span>
<span class="line-added"> 222      */</span>
<span class="line-added"> 223     boolean allowEmptyValues;</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225     /**</span>
<span class="line-added"> 226      * Switch: Allow value type member cycles?</span>
<span class="line-added"> 227      */</span>
<span class="line-added"> 228     boolean allowValueMemberCycles;</span>
<span class="line-added"> 229 </span>
 230     /**
 231      * Switch: name of source level; used for error reporting.
 232      */
 233     String sourceName;
 234 
 235     /** Check kind and type of given tree against protokind and prototype.
 236      *  If check succeeds, store type in tree and return it.
 237      *  If check fails, store errType in tree and return it.
 238      *  No checks are performed if the prototype is a method type.
 239      *  It is not necessary in this case since we know that kind and type
 240      *  are correct.
 241      *
 242      *  @param tree     The tree whose kind and type is checked
 243      *  @param found    The computed type of the tree
 244      *  @param ownkind  The computed kind of the tree
 245      *  @param resultInfo  The expected result of the tree
 246      */
 247     Type check(final JCTree tree,
 248                final Type found,
 249                final KindSelector ownkind,
</pre>
<hr />
<pre>
 308      *  @param pos    The current source code position.
 309      *  @param v      The assigned variable
 310      *  @param base   If the variable is referred to in a Select, the part
 311      *                to the left of the `.&#39;, null otherwise.
 312      *  @param env    The current environment.
 313      */
 314     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 315         if (v.name == names._this) {
 316             log.error(pos, Errors.CantAssignValToThis);
 317         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 318             ((v.flags() &amp; HASINIT) != 0
 319              ||
 320              !((base == null ||
 321                TreeInfo.isThisQualifier(base)) &amp;&amp;
 322                isAssignableAsBlankFinal(v, env)))) {
 323             if (v.isResourceVariable()) { //TWR resource
 324                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
 325             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {
 326                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));
 327             } else {
<span class="line-modified"> 328                 boolean complain = true;</span>
<span class="line-added"> 329                 /* Allow updates to instance fields of value classes by any method in the same nest via the</span>
<span class="line-added"> 330                    withfield operator -This does not result in mutation of final fields; the code generator</span>
<span class="line-added"> 331                    would implement `copy on write&#39; semantics via the opcode `withfield&#39;.</span>
<span class="line-added"> 332                 */</span>
<span class="line-added"> 333                 if (env.info.inWithField &amp;&amp; v.getKind() == ElementKind.FIELD &amp;&amp; (v.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) {</span>
<span class="line-added"> 334                     if (env.enclClass.sym.outermostClass() == v.owner.outermostClass())</span>
<span class="line-added"> 335                         complain = false;</span>
<span class="line-added"> 336                 }</span>
<span class="line-added"> 337                 if (complain)</span>
<span class="line-added"> 338                     log.error(pos, Errors.CantAssignValToFinalVar(v));</span>
 339             }
 340         }
 341     }
 342 
 343     /** Does tree represent a static reference to an identifier?
 344      *  It is assumed that tree is either a SELECT or an IDENT.
 345      *  We have to weed out selects from non-type names here.
 346      *  @param tree    The candidate tree.
 347      */
 348     boolean isStaticReference(JCTree tree) {
 349         if (tree.hasTag(SELECT)) {
 350             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 351             if (lsym == null || lsym.kind != TYP) {
 352                 return false;
 353             }
 354         }
 355         return true;
 356     }
 357 
 358     /** Is this symbol a type?
</pre>
<hr />
<pre>
 810     /** Attribute a type argument list, returning a list of types.
 811      *  Check that all the types are references.
 812      */
 813     List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 814         List&lt;Type&gt; types = attribAnyTypes(trees, env);
 815         return chk.checkRefTypes(trees, types);
 816     }
 817 
 818     /**
 819      * Attribute type variables (of generic classes or methods).
 820      * Compound types are attributed later in attribBounds.
 821      * @param typarams the type variables to enter
 822      * @param env      the current environment
 823      */
 824     void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env, boolean checkCyclic) {
 825         for (JCTypeParameter tvar : typarams) {
 826             TypeVar a = (TypeVar)tvar.type;
 827             a.tsym.flags_field |= UNATTRIBUTED;
 828             a.setUpperBound(Type.noType);
 829             if (!tvar.bounds.isEmpty()) {
<span class="line-modified"> 830                 List&lt;Type&gt; bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));</span>
 831                 for (JCExpression bound : tvar.bounds.tail)
<span class="line-modified"> 832                     bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));</span>
 833                 types.setBounds(a, bounds.reverse());
 834             } else {
 835                 // if no bounds are given, assume a single bound of
 836                 // java.lang.Object.
 837                 types.setBounds(a, List.of(syms.objectType));
 838             }
 839             a.tsym.flags_field &amp;= ~UNATTRIBUTED;
 840         }
 841         if (checkCyclic) {
 842             for (JCTypeParameter tvar : typarams) {
 843                 chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
 844             }
 845         }
 846     }
 847 
 848     /**
 849      * Attribute the type references in a list of annotations.
 850      */
 851     void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
 852                                Env&lt;AttrContext&gt; env) {
</pre>
<hr />
<pre>
 973                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 974                     enter.classEnter(tree, env);
 975             }
 976 
 977             ClassSymbol c = tree.sym;
 978             if (c == null) {
 979                 // exit in case something drastic went wrong during enter.
 980                 result = null;
 981             } else {
 982                 // make sure class has been completed:
 983                 c.complete();
 984 
 985                 // If this class appears as an anonymous class
 986                 // in a superclass constructor call
 987                 // disable implicit outer instance from being passed.
 988                 // (This would be an illegal access to &quot;this before super&quot;).
 989                 if (env.info.isSelfCall &amp;&amp;
 990                         env.tree.hasTag(NEWCLASS)) {
 991                     c.flags_field |= NOOUTERTHIS;
 992                 }
<span class="line-added"> 993                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; types.isValue(c.getSuperclass())) {</span>
<span class="line-added"> 994                     c.flags_field |= VALUE; // avoid further secondary errors.</span>
<span class="line-added"> 995                 }</span>
 996                 attribClass(tree.pos(), c);
 997                 result = tree.type = c.type;
 998             }
 999         } finally {
1000             localCacheContext.ifPresent(LocalCacheContext::leave);
1001         }
1002     }
1003 
1004     public void visitMethodDef(JCMethodDecl tree) {
1005         MethodSymbol m = tree.sym;
1006         boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
1007 
1008         Lint lint = env.info.lint.augment(m);
1009         Lint prevLint = chk.setLint(lint);
1010         MethodSymbol prevMethod = chk.setMethod(m);
1011         try {
1012             deferredLintHandler.flush(tree.pos());
1013             chk.checkDeprecatedAnnotation(tree.pos(), m);
1014 
1015 
</pre>
<hr />
<pre>
1197                         log.error(tree.pos(),
1198                                   Errors.DefaultAllowedInIntfAnnotationMember);
1199                 }
1200                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1201                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1202             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1203                 if ((owner.flags() &amp; INTERFACE) != 0) {
1204                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1205                 } else {
1206                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1207                 }
1208             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1209                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1210             } else {
1211                 // Add an implicit super() call unless an explicit call to
1212                 // super(...) or this(...) is given
1213                 // or we are compiling class java.lang.Object.
1214                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1215                     JCBlock body = tree.body;
1216                     if (body.stats.isEmpty() ||
<span class="line-modified">1217                             TreeInfo.getConstructorInvocationName(body.stats, names, true) == names.empty) {</span>
1218                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1219                                 make.Ident(names._super), make.Idents(List.nil())));
1220                         body.stats = body.stats.prepend(supCall);
1221                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1222                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1223                             TreeInfo.isSuperCall(body.stats.head)) {
1224                         // enum constructors are not allowed to call super
1225                         // directly, so make sure there aren&#39;t any super calls
1226                         // in enum constructors, except in the compiler
1227                         // generated one.
1228                         log.error(tree.body.stats.head.pos(),
1229                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1230                     }
1231                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1232                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1233                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1234                         if (!initParamNames.equals(recordComponentNames)) {
1235                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1236                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1237                         }
1238                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1239                             log.error(tree,
1240                                     Errors.InvalidCanonicalConstructorInRecord(
1241                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1242                                             env.enclClass.sym.name,
1243                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1244                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1245                         }
1246                     }
1247                 }
<span class="line-added">1248                 if (m.isConstructor() &amp;&amp; m.type.getParameterTypes().size() == 0) {</span>
<span class="line-added">1249                     if ((owner.type == syms.objectType) ||</span>
<span class="line-added">1250                             (tree.body.stats.size() == 1 &amp;&amp; TreeInfo.getConstructorInvocationName(tree.body.stats, names, false) == names._super)) {</span>
<span class="line-added">1251                         m.flags_field |= EMPTYNOARGCONSTR;</span>
<span class="line-added">1252                     }</span>
<span class="line-added">1253                 }</span>
1254 
1255                 // Attribute all type annotations in the body
1256                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1257                 annotate.flush();
1258 
1259                 // Attribute method body.
1260                 attribStat(tree.body, localEnv);
1261             }
1262 
1263             localEnv.info.scope.leave();
1264             result = tree.type = m.type;
1265         } finally {
1266             chk.setLint(prevLint);
1267             chk.setMethod(prevMethod);
1268         }
1269     }
1270 
1271     public void visitVarDef(JCVariableDecl tree) {
1272         // Local variables have not been entered yet, so we need to do it now:
1273         if (env.info.scope.owner.kind == MTH || env.info.scope.owner.kind == VAR) {
</pre>
<hr />
<pre>
1303                 annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());
1304                 annotate.flush();
1305             }
1306         }
1307 
1308         VarSymbol v = tree.sym;
1309         Lint lint = env.info.lint.augment(v);
1310         Lint prevLint = chk.setLint(lint);
1311 
1312         // Check that the variable&#39;s declared type is well-formed.
1313         boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;
1314                 ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1315                 (tree.sym.flags() &amp; PARAMETER) != 0;
1316         chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
1317 
1318         try {
1319             v.getConstValue(); // ensure compile-time constant initializer is evaluated
1320             deferredLintHandler.flush(tree.pos());
1321             chk.checkDeprecatedAnnotation(tree.pos(), v);
1322 
<span class="line-added">1323             /* Don&#39;t want constant propagation/folding for instance fields of value classes,</span>
<span class="line-added">1324                as these can undergo updates via copy on write.</span>
<span class="line-added">1325             */</span>
1326             if (tree.init != null) {
<span class="line-modified">1327                 if ((v.flags_field &amp; FINAL) == 0 || ((v.flags_field &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) ||</span>
1328                     !memberEnter.needsLazyConstValue(tree.init)) {
1329                     // Not a compile-time constant
1330                     // Attribute initializer in a new environment
1331                     // with the declared variable as owner.
1332                     // Check that initializer conforms to variable&#39;s declared type.
1333                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1334                     initEnv.info.lint = lint;
1335                     // In order to catch self-references, we set the variable&#39;s
1336                     // declaration position to maximal possible value, effectively
1337                     // marking the variable as undefined.
1338                     initEnv.info.enclVar = v;
1339                     attribExpr(tree.init, initEnv, v.type);
1340                     if (tree.isImplicitlyTyped()) {
1341                         //fixup local variable type
1342                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1343                     }
1344                 }
1345                 if (tree.isImplicitlyTyped()) {
1346                     setSyntheticVariableType(tree, v.type);
1347                 }
</pre>
<hr />
<pre>
1431             }
1432         }
1433     }
1434 
1435     public void visitSkip(JCSkip tree) {
1436         result = null;
1437     }
1438 
1439     public void visitBlock(JCBlock tree) {
1440         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {
1441             // Block is a static or instance initializer;
1442             // let the owner of the environment be a freshly
1443             // created BLOCK-method.
1444             Symbol fakeOwner =
1445                 new MethodSymbol(tree.flags | BLOCK |
1446                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1447                     env.info.scope.owner);
1448             final Env&lt;AttrContext&gt; localEnv =
1449                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1450 
<span class="line-modified">1451             if ((tree.flags &amp; STATIC) != 0)</span>
<span class="line-added">1452                 localEnv.info.staticLevel++;</span>
<span class="line-added">1453             else if (tree.stats.size() &gt; 0)</span>
<span class="line-added">1454                 env.info.scope.owner.flags_field |= HASINITBLOCK;</span>
<span class="line-added">1455 </span>
1456             // Attribute all type annotations in the block
1457             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1458             annotate.flush();
1459             attribStats(tree.stats, localEnv);
1460 
1461             {
1462                 // Store init and clinit type annotations with the ClassSymbol
1463                 // to allow output in Gen.normalizeDefs.
1464                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
1465                 List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();
1466                 if ((tree.flags &amp; STATIC) != 0) {
1467                     cs.appendClassInitTypeAttributes(tas);
1468                 } else {
1469                     cs.appendInitTypeAttributes(tas);
1470                 }
1471             }
1472         } else {
1473             // Create a new local environment with a local scope.
1474             Env&lt;AttrContext&gt; localEnv =
1475                 env.dup(tree, env.info.dup(env.info.scope.dup()));
</pre>
<hr />
<pre>
1500         // include condition&#39;s bindings when true in the body:
1501         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1502         try {
1503             attribStat(tree.body, whileEnv.dup(tree));
1504         } finally {
1505             whileEnv.info.scope.leave();
1506         }
1507         if (!breaksOutOf(tree, tree.body)) {
1508             //include condition&#39;s bindings when false after the while, if cannot get out of the loop
1509             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1510             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1511         }
1512         result = null;
1513     }
1514 
1515     private boolean breaksOutOf(JCTree loop, JCTree body) {
1516         preFlow(body);
1517         return flow.breaksOutOf(env, loop, body, make);
1518     }
1519 
<span class="line-added">1520     public void visitWithField(JCWithField tree) {</span>
<span class="line-added">1521         boolean inWithField = env.info.inWithField;</span>
<span class="line-added">1522         try {</span>
<span class="line-added">1523             env.info.inWithField = true;</span>
<span class="line-added">1524             Type fieldtype = attribTree(tree.field, env.dup(tree), varAssignmentInfo);</span>
<span class="line-added">1525             attribExpr(tree.value, env, fieldtype);</span>
<span class="line-added">1526             Type capturedType = syms.errType;</span>
<span class="line-added">1527             if (tree.field.type != null &amp;&amp; !tree.field.type.isErroneous()) {</span>
<span class="line-added">1528                 final Symbol sym = TreeInfo.symbol(tree.field);</span>
<span class="line-added">1529                 if (sym == null || sym.kind != VAR || sym.owner.kind != TYP ||</span>
<span class="line-added">1530                         (sym.flags() &amp; STATIC) != 0 || !types.isValue(sym.owner.type)) {</span>
<span class="line-added">1531                     log.error(tree.field.pos(), Errors.ValueInstanceFieldExpectedHere);</span>
<span class="line-added">1532                 } else {</span>
<span class="line-added">1533                     Type ownType = sym.owner.type;</span>
<span class="line-added">1534                     switch(tree.field.getTag()) {</span>
<span class="line-added">1535                         case IDENT:</span>
<span class="line-added">1536                             JCIdent ident = (JCIdent) tree.field;</span>
<span class="line-added">1537                             ownType = ident.sym.owner.type;</span>
<span class="line-added">1538                             break;</span>
<span class="line-added">1539                         case SELECT:</span>
<span class="line-added">1540                             JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;</span>
<span class="line-added">1541                             ownType = fieldAccess.selected.type;</span>
<span class="line-added">1542                             break;</span>
<span class="line-added">1543                     }</span>
<span class="line-added">1544                     capturedType = capture(ownType);</span>
<span class="line-added">1545                 }</span>
<span class="line-added">1546             }</span>
<span class="line-added">1547             result = check(tree, capturedType, KindSelector.VAL, resultInfo);</span>
<span class="line-added">1548         } finally {</span>
<span class="line-added">1549             env.info.inWithField = inWithField;</span>
<span class="line-added">1550         }</span>
<span class="line-added">1551     }</span>
<span class="line-added">1552 </span>
1553     public void visitForLoop(JCForLoop tree) {
1554         Env&lt;AttrContext&gt; loopEnv =
1555             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1556         MatchBindings condBindings = MatchBindingsComputer.EMPTY;
1557         try {
1558             attribStats(tree.init, loopEnv);
1559             if (tree.cond != null) {
1560                 attribExpr(tree.cond, loopEnv, syms.booleanType);
1561                 // include condition&#39;s bindings when true in the body and step:
1562                 condBindings = matchBindings;
1563             }
1564             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);
1565             try {
1566                 bodyEnv.tree = tree; // before, we were not in loop!
1567                 attribStats(tree.step, bodyEnv);
1568                 attribStat(tree.body, bodyEnv);
1569             } finally {
1570                 bodyEnv.info.scope.leave();
1571             }
1572             result = null;
</pre>
<hr />
<pre>
1576         }
1577         if (!breaksOutOf(tree, tree.body)) {
1578             //include condition&#39;s body when false after the while, if cannot get out of the loop
1579             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1580             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1581         }
1582     }
1583 
1584     public void visitForeachLoop(JCEnhancedForLoop tree) {
1585         Env&lt;AttrContext&gt; loopEnv =
1586             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1587         try {
1588             //the Formal Parameter of a for-each loop is not in the scope when
1589             //attributing the for-each expression; we mimic this by attributing
1590             //the for-each expression first (against original scope).
1591             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1592             chk.checkNonVoid(tree.pos(), exprType);
1593             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1594             if (elemtype == null) {
1595                 // or perhaps expr implements Iterable&lt;T&gt;?
<span class="line-modified">1596                 Type base = types.asSuper(exprType, syms.iterableType.tsym, true);</span>
1597                 if (base == null) {
1598                     log.error(tree.expr.pos(),
1599                               Errors.ForeachNotApplicableToType(exprType,
1600                                                                 Fragments.TypeReqArrayOrIterable));
1601                     elemtype = types.createErrorType(exprType);
1602                 } else {
1603                     List&lt;Type&gt; iterableParams = base.allparams();
1604                     elemtype = iterableParams.isEmpty()
1605                         ? syms.objectType
1606                         : types.wildUpperBound(iterableParams.head);
1607                 }
1608             }
1609             if (tree.var.isImplicitlyTyped()) {
1610                 Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);
1611                 setSyntheticVariableType(tree.var, inferredType);
1612             }
1613             attribStat(tree.var, loopEnv);
1614             chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
1615             loopEnv.tree = tree; // before, we were not in loop!
1616             attribStat(tree.body, loopEnv);
</pre>
<hr />
<pre>
1790     // where
1791     /** Return the selected enumeration constant symbol, or null. */
1792     private Symbol enumConstant(JCTree tree, Type enumType) {
1793         if (tree.hasTag(IDENT)) {
1794             JCIdent ident = (JCIdent)tree;
1795             Name name = ident.name;
1796             for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {
1797                 if (sym.kind == VAR) {
1798                     Symbol s = ident.sym = sym;
1799                     ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated
1800                     ident.type = s.type;
1801                     return ((s.flags_field &amp; Flags.ENUM) == 0)
1802                         ? null : s;
1803                 }
1804             }
1805         }
1806         return null;
1807     }
1808 
1809     public void visitSynchronized(JCSynchronized tree) {
<span class="line-modified">1810         chk.checkRefType(tree.pos(), attribExpr(tree.lock, env), false);</span>
1811         attribStat(tree.body, env);
1812         result = null;
1813     }
1814 
1815     public void visitTry(JCTry tree) {
1816         // Create a new local environment with a local
1817         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
1818         try {
1819             boolean isTryWithResource = tree.resources.nonEmpty();
1820             // Create a nested environment for attributing the try block if needed
1821             Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
1822                 env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
1823                 localEnv;
1824             try {
1825                 // Attribute resource declarations
1826                 for (JCTree resource : tree.resources) {
1827                     CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
1828                         @Override
1829                         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1830                             chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
</pre>
<hr />
<pre>
1871                     chk.checkType(c.param.vartype.pos(),
1872                                   chk.checkClassType(c.param.vartype.pos(), ctype),
1873                                   syms.throwableType);
1874                     attribStat(c.body, catchEnv);
1875                 } finally {
1876                     catchEnv.info.scope.leave();
1877                 }
1878             }
1879 
1880             // Attribute finalizer
1881             if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);
1882             result = null;
1883         }
1884         finally {
1885             localEnv.info.scope.leave();
1886         }
1887     }
1888 
1889     void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {
1890         if (!resource.isErroneous() &amp;&amp;
<span class="line-modified">1891             types.asSuper(resource, syms.autoCloseableType.tsym, true) != null &amp;&amp;</span>
1892             !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself
1893             Symbol close = syms.noSymbol;
1894             Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
1895             try {
1896                 close = rs.resolveQualifiedMethod(pos,
1897                         env,
1898                         types.skipTypeVars(resource, false),
1899                         names.close,
1900                         List.nil(),
1901                         List.nil());
1902             }
1903             finally {
1904                 log.popDiagnosticHandler(discardHandler);
1905             }
1906             if (close.kind == MTH &amp;&amp;
1907                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1908                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1909                     env.info.lint.isEnabled(LintCategory.TRY)) {
1910                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1911             }
</pre>
<hr />
<pre>
2471             // ... and attribute the method using as a prototype a methodtype
2472             // whose formal argument types is exactly the list of actual
2473             // arguments (this will also set the method symbol).
2474             Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2475             localEnv.info.pendingResolutionPhase = null;
2476             Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
2477 
2478             // Compute the result type.
2479             Type restype = mtype.getReturnType();
2480             if (restype.hasTag(WILDCARD))
2481                 throw new AssertionError(mtype);
2482 
2483             Type qualifier = (tree.meth.hasTag(SELECT))
2484                     ? ((JCFieldAccess) tree.meth).selected.type
2485                     : env.enclClass.sym.type;
2486             Symbol msym = TreeInfo.symbol(tree.meth);
2487             restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
2488 
2489             chk.checkRefTypes(tree.typeargs, typeargtypes);
2490 
<span class="line-added">2491             final Symbol symbol = TreeInfo.symbol(tree.meth);</span>
<span class="line-added">2492             if (symbol != null) {</span>
<span class="line-added">2493                 /* Is this an ill conceived attempt to invoke jlO methods not available on value types ??</span>
<span class="line-added">2494                  */</span>
<span class="line-added">2495                 boolean superCallOnValueReceiver = types.isValue(env.enclClass.sym.type)</span>
<span class="line-added">2496                         &amp;&amp; (tree.meth.hasTag(SELECT))</span>
<span class="line-added">2497                         &amp;&amp; ((JCFieldAccess)tree.meth).selected.hasTag(IDENT)</span>
<span class="line-added">2498                         &amp;&amp; TreeInfo.name(((JCFieldAccess)tree.meth).selected) == names._super;</span>
<span class="line-added">2499                 if (types.isValue(qualifier) || superCallOnValueReceiver) {</span>
<span class="line-added">2500                     int argSize = argtypes.size();</span>
<span class="line-added">2501                     Name name = symbol.name;</span>
<span class="line-added">2502                     switch (name.toString()) {</span>
<span class="line-added">2503                         case &quot;wait&quot;:</span>
<span class="line-added">2504                             if (argSize == 0</span>
<span class="line-added">2505                                     || (types.isConvertible(argtypes.head, syms.longType) &amp;&amp;</span>
<span class="line-added">2506                                     (argSize == 1 || (argSize == 2 &amp;&amp; types.isConvertible(argtypes.tail.head, syms.intType))))) {</span>
<span class="line-added">2507                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));</span>
<span class="line-added">2508                             }</span>
<span class="line-added">2509                             break;</span>
<span class="line-added">2510                         case &quot;notify&quot;:</span>
<span class="line-added">2511                         case &quot;notifyAll&quot;:</span>
<span class="line-added">2512                         case &quot;clone&quot;:</span>
<span class="line-added">2513                         case &quot;finalize&quot;:</span>
<span class="line-added">2514                             if (argSize == 0)</span>
<span class="line-added">2515                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));</span>
<span class="line-added">2516                             break;</span>
<span class="line-added">2517                         case &quot;hashCode&quot;:</span>
<span class="line-added">2518                         case &quot;equals&quot;:</span>
<span class="line-added">2519                         case &quot;toString&quot;:</span>
<span class="line-added">2520                             if (superCallOnValueReceiver)</span>
<span class="line-added">2521                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(names.fromString(&quot;invocation of super.&quot; + name)));</span>
<span class="line-added">2522                             break;</span>
<span class="line-added">2523                     }</span>
<span class="line-added">2524                 }</span>
<span class="line-added">2525             }</span>
<span class="line-added">2526 </span>
2527             // Check that value of resulting type is admissible in the
2528             // current context.  Also, capture the return type
2529             Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);
2530             result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
2531         }
2532         chk.validate(tree.typeargs, localEnv);
2533     }
2534     //where
2535         Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {
2536             if (msym != null &amp;&amp;
2537                     msym.owner == syms.objectType.tsym &amp;&amp;
2538                     methodName == names.getClass &amp;&amp;
2539                     argtypes.isEmpty()) {
2540                 // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;
<span class="line-added">2541                 // Temporary treatment for inline class: Given an inline class V that implements</span>
<span class="line-added">2542                 // I1, I2, ... In, v.getClass() is typed to be Class&lt;? extends Object &amp; I1 &amp; I2 .. &amp; In&gt;</span>
<span class="line-added">2543                 Type wcb;</span>
<span class="line-added">2544                 if (qualifierType.isValue()) {</span>
<span class="line-added">2545                     List&lt;Type&gt; bounds = List.of(syms.objectType).appendList(((ClassSymbol) qualifierType.tsym).getInterfaces());</span>
<span class="line-added">2546                     wcb = bounds.size() &gt; 1 ? types.makeIntersectionType(bounds) : syms.objectType;</span>
<span class="line-added">2547                 } else {</span>
<span class="line-added">2548                     wcb = types.erasure(qualifierType);</span>
<span class="line-added">2549                 }</span>
2550                 return new ClassType(restype.getEnclosingType(),
<span class="line-modified">2551                         List.of(new WildcardType(wcb,</span>
2552                                 BoundKind.EXTENDS,
2553                                 syms.boundClass)),
2554                         restype.tsym,
2555                         restype.getMetadata());
2556             } else if (msym != null &amp;&amp;
2557                     msym.owner == syms.arrayClass &amp;&amp;
2558                     methodName == names.clone &amp;&amp;
2559                     types.isArray(qualifierType)) {
2560                 // as a special case, array.clone() has a result that is
2561                 // the same as static type of the array being cloned
2562                 return qualifierType;
2563             } else {
2564                 return restype;
2565             }
2566         }
2567 
2568         /** Check that given application node appears as first statement
2569          *  in a constructor call.
2570          *  @param tree          The application node
2571          *  @param enclMethod    The enclosing method of the application.
</pre>
<hr />
<pre>
2704         }
2705 
2706         // Attribute constructor arguments.
2707         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2708         final KindSelector pkind =
2709             attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2710         List&lt;Type&gt; argtypes = argtypesBuf.toList();
2711         List&lt;Type&gt; typeargtypes = attribTypes(tree.typeargs, localEnv);
2712 
2713         if (clazztype.hasTag(CLASS) || clazztype.hasTag(ERROR)) {
2714             // Enums may not be instantiated except implicitly
2715             if ((clazztype.tsym.flags_field &amp; Flags.ENUM) != 0 &amp;&amp;
2716                 (!env.tree.hasTag(VARDEF) ||
2717                  (((JCVariableDecl) env.tree).mods.flags &amp; Flags.ENUM) == 0 ||
2718                  ((JCVariableDecl) env.tree).init != tree))
2719                 log.error(tree.pos(), Errors.EnumCantBeInstantiated);
2720 
2721             boolean isSpeculativeDiamondInferenceRound = TreeInfo.isDiamond(tree) &amp;&amp;
2722                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
2723             boolean skipNonDiamondPath = false;
<span class="line-added">2724             // Check that it is an instantiation of a class and not a projection type</span>
<span class="line-added">2725             if (clazz.hasTag(SELECT)) {</span>
<span class="line-added">2726                 JCFieldAccess fieldAccess = (JCFieldAccess) clazz;</span>
<span class="line-added">2727                 if (fieldAccess.selected.type.isValue() &amp;&amp;</span>
<span class="line-added">2728                         (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {</span>
<span class="line-added">2729                     log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);</span>
<span class="line-added">2730                 }</span>
<span class="line-added">2731             }</span>
2732             // Check that class is not abstract
2733             if (cdef == null &amp;&amp; !isSpeculativeDiamondInferenceRound &amp;&amp; // class body may be nulled out in speculative tree copy
2734                 (clazztype.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
2735                 log.error(tree.pos(),
2736                           Errors.AbstractCantBeInstantiated(clazztype.tsym));
2737                 skipNonDiamondPath = true;
2738             } else if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2739                 // Check that no constructor arguments are given to
2740                 // anonymous classes implementing an interface
2741                 if (!argtypes.isEmpty())
2742                     log.error(tree.args.head.pos(), Errors.AnonClassImplIntfNoArgs);
2743 
2744                 if (!typeargtypes.isEmpty())
2745                     log.error(tree.typeargs.head.pos(), Errors.AnonClassImplIntfNoTypeargs);
2746 
2747                 // Error recovery: pretend no arguments were supplied.
2748                 argtypes = List.nil();
2749                 typeargtypes = List.nil();
2750                 skipNonDiamondPath = true;
2751             }
</pre>
<hr />
<pre>
2883                                 this.resultInfo = prevResult;
2884                             }
2885                         });
2886             } else {
2887                 if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
2888                     List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
2889                     if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {
2890                         // One or more types inferred in the previous steps is non-denotable.
2891                         Fragment fragment = Diamond(clazztype.tsym);
2892                         log.error(tree.clazz.pos(),
2893                                 Errors.CantApplyDiamond1(
2894                                         fragment,
2895                                         invalidDiamondArgs.size() &gt; 1 ?
2896                                                 DiamondInvalidArgs(invalidDiamondArgs, fragment) :
2897                                                 DiamondInvalidArg(invalidDiamondArgs, fragment)));
2898                     }
2899                     // For &lt;&gt;(){}, inferred types must also be accessible.
2900                     for (Type t : clazztype.getTypeArguments()) {
2901                         rs.checkAccessibleType(env, t);
2902                     }
<span class="line-added">2903                     chk.checkParameterizationWithValues(tree, clazztype);</span>
2904                 }
2905 
2906                 // If we already errored, be careful to avoid a further avalanche. ErrorType answers
2907                 // false for isInterface call even when the original type is an interface.
2908                 boolean implementing = clazztype.tsym.isInterface() ||
2909                         clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
2910                         clazztype.getOriginalType().tsym.isInterface();
2911 
2912                 if (implementing) {
2913                     cdef.implementing = List.of(clazz);
2914                 } else {
2915                     cdef.extending = clazz;
2916                 }
2917 
2918                 if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
2919                     isSerializable(clazztype)) {
2920                     localEnv.info.isSerializable = true;
2921                 }
2922 
2923                 attribStat(cdef, localEnv);
</pre>
<hr />
<pre>
2956             result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));
2957             chk.validate(tree.typeargs, localEnv);
2958         }
2959 
2960         CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {
2961             return new Check.NestedCheckContext(checkContext) {
2962                 @Override
2963                 public void report(DiagnosticPosition _unused, JCDiagnostic details) {
2964                     enclosingContext.report(clazz.clazz,
2965                             diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
2966                 }
2967             };
2968         }
2969 
2970     /** Make an attributed null check tree.
2971      */
2972     public JCExpression makeNullCheck(JCExpression arg) {
2973         // optimization: new Outer() can never be null; skip null check
2974         if (arg.getTag() == NEWCLASS)
2975             return arg;
<span class="line-added">2976         // Likewise arg can&#39;t be null if it is a value.</span>
<span class="line-added">2977         if (types.isValue(arg.type))</span>
<span class="line-added">2978             return arg;</span>
2979         // optimization: X.this is never null; skip null check
2980         Name name = TreeInfo.name(arg);
2981         if (name == names._this || name == names._super) return arg;
2982 
2983         JCTree.Tag optag = NULLCHK;
2984         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
2985         tree.operator = operators.resolveUnary(arg, optag, arg.type);
2986         tree.type = arg.type;
2987         return tree;
2988     }
2989 
2990     public void visitNewArray(JCNewArray tree) {
2991         Type owntype = types.createErrorType(tree.type);
2992         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2993         Type elemtype;
2994         if (tree.elemtype != null) {
2995             elemtype = attribType(tree.elemtype, localEnv);
2996             chk.validate(tree.elemtype, localEnv);
2997             owntype = elemtype;
2998             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
</pre>
<hr />
<pre>
3972         if (operator != operators.noOpSymbol &amp;&amp;
3973                 !left.isErroneous() &amp;&amp;
3974                 !right.isErroneous()) {
3975             owntype = operator.type.getReturnType();
3976             int opc = ((OperatorSymbol)operator).opcode;
3977             // If both arguments are constants, fold them.
3978             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3979                 Type ctype = cfolder.fold2(opc, left, right);
3980                 if (ctype != null) {
3981                     owntype = cfolder.coerce(ctype, owntype);
3982                 }
3983             }
3984 
3985             // Check that argument types of a reference ==, != are
3986             // castable to each other, (JLS 15.21).  Note: unboxing
3987             // comparisons will not have an acmp* opc at this point.
3988             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
3989                 if (!types.isCastable(left, right, new Warner(tree.pos()))) {
3990                     log.error(tree.pos(), Errors.IncomparableTypes(left, right));
3991                 }
<span class="line-added">3992                 chk.checkForSuspectClassLiteralComparison(tree, left, right);</span>
3993             }
3994 
3995             chk.checkDivZero(tree.rhs.pos(), operator, right);
3996         }
3997         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3998     }
3999 
4000     public void visitTypeCast(final JCTypeCast tree) {
4001         Type clazztype = attribType(tree.clazz, env);
4002         chk.validate(tree.clazz, env, false);
4003         //a fresh environment is required for 292 inference to work properly ---
4004         //see Infer.instantiatePolymorphicSignatureInstance()
4005         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
4006         //should we propagate the target type?
4007         final ResultInfo castInfo;
4008         JCExpression expr = TreeInfo.skipParens(tree.expr);
4009         boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
4010         if (isPoly) {
4011             //expression is a poly - we need to propagate target type info
4012             castInfo = new ResultInfo(KindSelector.VAL, clazztype,
</pre>
<hr />
<pre>
4170         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4171             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4172             // If the found symbol is inaccessible, then it is
4173             // accessed through an enclosing instance.  Locate this
4174             // enclosing instance:
4175             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4176                 env1 = env1.outer;
4177         }
4178 
4179         if (env.info.isSerializable) {
4180             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4181         }
4182 
4183         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4184     }
4185 
4186     public void visitSelect(JCFieldAccess tree) {
4187         // Determine the expected kind of the qualifier expression.
4188         KindSelector skind = KindSelector.NIL;
4189         if (tree.name == names._this || tree.name == names._super ||
<span class="line-modified">4190                 tree.name == names._class || tree.name == names._default)</span>
4191         {
<span class="line-added">4192             if (tree.name == names._default &amp;&amp; !allowInlineTypes) {</span>
<span class="line-added">4193                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),</span>
<span class="line-added">4194                         Feature.INLINE_TYPES.error(sourceName));</span>
<span class="line-added">4195             }</span>
4196             skind = KindSelector.TYP;
4197         } else {
4198             if (pkind().contains(KindSelector.PCK))
4199                 skind = KindSelector.of(skind, KindSelector.PCK);
4200             if (pkind().contains(KindSelector.TYP))
4201                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4202             if (pkind().contains(KindSelector.VAL_MTH))
4203                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4204         }
4205 
4206         // Attribute the qualifier expression, and determine its symbol (if any).
4207         Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));
4208         if (!pkind().contains(KindSelector.TYP_PCK))
4209             site = capture(site); // Capture field access
4210 
4211         // don&#39;t allow T.class T[].class, etc
4212         if (skind == KindSelector.TYP) {
4213             Type elt = site;
4214             while (elt.hasTag(ARRAY))
4215                 elt = ((ArrayType)elt).elemtype;
4216             if (elt.hasTag(TYPEVAR)) {
<span class="line-modified">4217                 if (tree.name == names._default) {</span>
<span class="line-modified">4218                     result = check(tree, litType(BOT).constType(null),</span>
<span class="line-modified">4219                             KindSelector.VAL, resultInfo);</span>
<span class="line-modified">4220                 } else {</span>
<span class="line-added">4221                     log.error(tree.pos(), Errors.TypeVarCantBeDeref);</span>
<span class="line-added">4222                     result = tree.type = types.createErrorType(tree.name, site.tsym, site);</span>
<span class="line-added">4223                     tree.sym = tree.type.tsym;</span>
<span class="line-added">4224                     return;</span>
<span class="line-added">4225                 }</span>
4226             }
4227         }
4228 
4229         // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;
4230         // for the selection. This is relevant for determining whether
4231         // protected symbols are accessible.
4232         Symbol sitesym = TreeInfo.symbol(tree.selected);
<span class="line-added">4233 </span>
4234         boolean selectSuperPrev = env.info.selectSuper;
4235         env.info.selectSuper =
4236             sitesym != null &amp;&amp;
4237             sitesym.name == names._super;
4238 
4239         // Determine the symbol represented by the selection.
4240         env.info.pendingResolutionPhase = null;
4241         Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
4242         if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
4243             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
4244             sym = syms.errSymbol;
4245         }
4246         if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
4247             site = capture(site);
4248             sym = selectSym(tree, sitesym, site, env, resultInfo);
4249         }
4250         boolean varArgs = env.info.lastResolveVarargs();
4251         tree.sym = sym;
4252 
4253         if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
</pre>
<hr />
<pre>
4349                                  Env&lt;AttrContext&gt; env,
4350                                  ResultInfo resultInfo) {
4351             DiagnosticPosition pos = tree.pos();
4352             Name name = tree.name;
4353             switch (site.getTag()) {
4354             case PACKAGE:
4355                 return rs.accessBase(
4356                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),
4357                     pos, location, site, name, true);
4358             case ARRAY:
4359             case CLASS:
4360                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4361                     return rs.resolveQualifiedMethod(
4362                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4363                 } else if (name == names._this || name == names._super) {
4364                     return rs.resolveSelf(pos, env, site.tsym, name);
4365                 } else if (name == names._class) {
4366                     // In this case, we have already made sure in
4367                     // visitSelect that qualifier expression is a type.
4368                     return syms.getClassField(site, types);
<span class="line-added">4369                 } else if (name == names._default) {</span>
<span class="line-added">4370                     return new VarSymbol(STATIC, names._default, site, site.tsym);</span>
<span class="line-added">4371                 } else if (name == names.ref &amp;&amp; site.isValue() &amp;&amp; resultInfo.pkind.contains(KindSelector.TYP)) {</span>
<span class="line-added">4372                     return site.tsym.referenceProjection();</span>
<span class="line-added">4373                 } else if (name == names.val &amp;&amp; site.isValue() &amp;&amp; resultInfo.pkind.contains(KindSelector.TYP)) {</span>
<span class="line-added">4374                     return site.tsym;</span>
4375                 } else {
4376                     // We are seeing a plain identifier as selector.
4377                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
4378                         sym = rs.accessBase(sym, pos, location, site, name, true);
4379                     return sym;
4380                 }
4381             case WILDCARD:
4382                 throw new AssertionError(tree);
4383             case TYPEVAR:
<span class="line-added">4384                 if (name == names._default) {</span>
<span class="line-added">4385                     // Be sure to return the default value before examining bounds</span>
<span class="line-added">4386                     return new VarSymbol(STATIC, names._default, site, site.tsym);</span>
<span class="line-added">4387                 }</span>
4388                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4389                 // It should only happen during memberEnter/attribBase
4390                 // when determining the super type which *must* be
4391                 // done before attributing the type variables.  In
4392                 // other words, we are seeing this illegal program:
4393                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4394                 Symbol sym = (site.getUpperBound() != null)
4395                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4396                     : null;
4397                 if (sym == null) {
4398                     log.error(pos, Errors.TypeVarCantBeDeref);
4399                     return syms.errSymbol;
4400                 } else {
4401                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4402                         rs.new AccessError(env, site, sym) :
4403                                 sym;
4404                     rs.accessBase(sym2, pos, location, site, name, true);
4405                     return sym;
4406                 }
4407             case ERROR:
4408                 // preserve identifier names through errors
4409                 return types.createErrorType(name, site.tsym, site).tsym;
4410             default:
4411                 // The qualifier expression is of a primitive type -- only
<span class="line-modified">4412                 // .class and .default is allowed for these.</span>
4413                 if (name == names._class) {
4414                     // In this case, we have already made sure in Select that
4415                     // qualifier expression is a type.
4416                     return syms.getClassField(site, types);
<span class="line-added">4417                 } else if (name == names._default) {</span>
<span class="line-added">4418                     return new VarSymbol(STATIC, names._default, site, site.tsym);</span>
4419                 } else {
4420                     log.error(pos, Errors.CantDeref(site));
4421                     return syms.errSymbol;
4422                 }
4423             }
4424         }
4425 
4426         /** Determine type of identifier or select expression and check that
4427          *  (1) the referenced symbol is not deprecated
4428          *  (2) the symbol&#39;s type is safe (@see checkSafe)
4429          *  (3) if symbol is a variable, check that its type and kind are
4430          *      compatible with the prototype and protokind.
4431          *  (4) if symbol is an instance field of a raw type,
4432          *      which is being assigned to, issue an unchecked warning if its
4433          *      type changes under erasure.
4434          *  (5) if symbol is an instance method of a raw type, issue an
4435          *      unchecked warning if its argument types change under erasure.
4436          *  If checks succeed:
4437          *    If symbol is a constant, return its constant type
4438          *    else if symbol is a method, return its result type
</pre>
<hr />
<pre>
5010         if (bounds.length() == 0) {
5011             return syms.objectType;
5012         } else if (bounds.length() == 1) {
5013             return bounds.head.type;
5014         } else {
5015             Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));
5016             // ... the variable&#39;s bound is a class type flagged COMPOUND
5017             // (see comment for TypeVar.bound).
5018             // In this case, generate a class tree that represents the
5019             // bound class, ...
5020             JCExpression extending;
5021             List&lt;JCExpression&gt; implementing;
5022             if (!bounds.head.type.isInterface()) {
5023                 extending = bounds.head;
5024                 implementing = bounds.tail;
5025             } else {
5026                 extending = null;
5027                 implementing = bounds;
5028             }
5029             JCClassDecl cd = make.at(tree).ClassDef(
<span class="line-modified">5030                 make.Modifiers(PUBLIC | ABSTRACT | (extending != null &amp;&amp; TreeInfo.symbol(extending).isValue() ? VALUE : 0)),</span>
5031                 names.empty, List.nil(),
5032                 extending, implementing, List.nil());
5033 
5034             ClassSymbol c = (ClassSymbol)owntype.tsym;
5035             Assert.check((c.flags() &amp; COMPOUND) != 0);
5036             cd.sym = c;
5037             c.sourcefile = env.toplevel.sourcefile;
5038 
5039             // ... and attribute the bound class
5040             c.flags_field |= UNATTRIBUTED;
5041             Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);
5042             typeEnvs.put(c, cenv);
5043             attribClass(c);
5044             return owntype;
5045         }
5046     }
5047 
5048     public void visitWildcard(JCWildcard tree) {
5049         //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
5050         Type type = (tree.kind.kind == BoundKind.UNBOUND)
5051             ? syms.objectType
5052             : attribType(tree.inner, env);
<span class="line-modified">5053         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),</span>
5054                                               tree.kind.kind,
5055                                               syms.boundClass),
5056                 KindSelector.TYP, resultInfo);
5057     }
5058 
5059     public void visitAnnotation(JCAnnotation tree) {
5060         Assert.error(&quot;should be handled in annotate&quot;);
5061     }
5062 
5063     public void visitAnnotatedType(JCAnnotatedType tree) {
5064         attribAnnotationTypes(tree.annotations, env);
5065         Type underlyingType = attribType(tree.underlyingType, env);
5066         Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);
5067 
5068         if (!env.info.isNewClass)
5069             annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
5070         result = tree.type = annotatedType;
5071     }
5072 
5073     public void visitErroneous(JCErroneous tree) {
</pre>
<hr />
<pre>
5137             chk.completionError(pos, ex);
5138         }
5139     }
5140 
5141     void attribModule(ModuleSymbol m) {
5142         // Get environment current at the point of module definition.
5143         Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
5144         attribStat(env.tree, env);
5145     }
5146 
5147     /** Main method: attribute class definition associated with given class symbol.
5148      *  reporting completion failures at the given position.
5149      *  @param pos The source position at which completion errors are to be
5150      *             reported.
5151      *  @param c   The class symbol whose definition will be attributed.
5152      */
5153     public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
5154         try {
5155             annotate.flush();
5156             attribClass(c);
<span class="line-added">5157             if (types.isValue(c.type)) {</span>
<span class="line-added">5158                 final Env&lt;AttrContext&gt; env = typeEnvs.get(c);</span>
<span class="line-added">5159                 if (!allowValueMemberCycles) {</span>
<span class="line-added">5160                     if (env != null &amp;&amp; env.tree != null &amp;&amp; env.tree.hasTag(CLASSDEF))</span>
<span class="line-added">5161                         chk.checkNonCyclicMembership((JCClassDecl)env.tree);</span>
<span class="line-added">5162                 }</span>
<span class="line-added">5163             }</span>
5164         } catch (CompletionFailure ex) {
5165             chk.completionError(pos, ex);
5166         }
5167     }
5168 
5169     /** Attribute class definition associated with given class symbol.
5170      *  @param c   The class symbol whose definition will be attributed.
5171      */
5172     void attribClass(ClassSymbol c) throws CompletionFailure {
5173         if (c.type.hasTag(ERROR)) return;
5174 
5175         // Check for cycles in the inheritance graph, which can arise from
5176         // ill-formed class files.
5177         chk.checkNonCyclic(null, c.type);
5178 
5179         Type st = types.supertype(c.type);
5180         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5181             // First, attribute superclass.
5182             if (st.hasTag(CLASS))
5183                 attribClass((ClassSymbol)st.tsym);
</pre>
<hr />
<pre>
5250                         }
5251                     }
5252                 }
5253             }
5254 
5255             List&lt;ClassSymbol&gt; sealedSupers = types.directSupertypes(c.type)
5256                                                   .stream()
5257                                                   .filter(s -&gt; s.tsym.isSealed())
5258                                                   .map(s -&gt; (ClassSymbol) s.tsym)
5259                                                   .collect(List.collector());
5260 
5261             if (sealedSupers.isEmpty()) {
5262                 if ((c.flags_field &amp; Flags.NON_SEALED) != 0) {
5263                     boolean hasErrorSuper = types.directSupertypes(c.type)
5264                                                  .stream()
5265                                                  .anyMatch(s -&gt; s.tsym.kind == Kind.ERR);
5266                     if (!hasErrorSuper) {
5267                         log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));
5268                     }
5269                 }
<span class="line-modified">5270             } else if ((c.flags_field &amp; Flags.COMPOUND) == 0) {</span>
5271                 if (c.isLocal() &amp;&amp; !c.isEnum()) {
5272                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed);
5273                 }
5274 
5275                 for (ClassSymbol supertypeSym : sealedSupers) {
5276                     if (!supertypeSym.permitted.contains(c.type.tsym)) {
5277                         log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));
5278                     }
5279                 }
5280                 if (!c.isNonSealed() &amp;&amp; !c.isFinal() &amp;&amp; !c.isSealed()) {
5281                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree),
5282                             c.isInterface() ?
5283                                     Errors.NonSealedOrSealedExpected :
5284                                     Errors.NonSealedSealedOrFinalExpected);
5285                 }
5286             }
5287 
5288             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5289             // because the annotations were not available at the time the env was created. Therefore,
5290             // we look up the environment chain for the first enclosing environment for which the
</pre>
<hr />
<pre>
5305                 deferredLintHandler.flush(env.tree);
5306                 env.info.returnResult = null;
5307                 // java.lang.Enum may not be subclassed by a non-enum
5308                 if (st.tsym == syms.enumSym &amp;&amp;
5309                     ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))
5310                     log.error(env.tree.pos(), Errors.EnumNoSubclassing);
5311 
5312                 // Enums may not be extended by source-level classes
5313                 if (st.tsym != null &amp;&amp;
5314                     ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;
5315                     ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {
5316                     log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);
5317                 }
5318 
5319                 if (isSerializable(c.type)) {
5320                     env.info.isSerializable = true;
5321                 }
5322 
5323                 attribClassBody(env, c);
5324 
<span class="line-added">5325                 if ((c.flags() &amp; (VALUE | ABSTRACT)) == VALUE) { // for non-intersection, concrete values.</span>
<span class="line-added">5326                     Assert.check(env.tree.hasTag(CLASSDEF));</span>
<span class="line-added">5327                     JCClassDecl classDecl = (JCClassDecl) env.tree;</span>
<span class="line-added">5328                     if (classDecl.extending != null) {</span>
<span class="line-added">5329                         chk.checkConstraintsOfInlineSuper(env.tree.pos(), c);</span>
<span class="line-added">5330                     }</span>
<span class="line-added">5331                 }</span>
<span class="line-added">5332 </span>
5333                 chk.checkDeprecatedAnnotation(env.tree.pos(), c);
5334                 chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
5335                 chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
5336                 chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);
5337             } finally {
5338                 env.info.returnResult = prevReturnRes;
5339                 log.useSource(prev);
5340                 chk.setLint(prevLint);
5341             }
5342 
5343         }
5344     }
5345 
5346     public void visitImport(JCImport tree) {
5347         // nothing to do
5348     }
5349 
5350     public void visitModuleDef(JCModuleDecl tree) {
5351         tree.sym.completeUsesProvides();
5352         ModuleSymbol msym = tree.sym;
</pre>
<hr />
<pre>
5418         chk.checkClassBounds(tree.pos(), c.type);
5419 
5420         tree.type = c.type;
5421 
5422         for (List&lt;JCTypeParameter&gt; l = tree.typarams;
5423              l.nonEmpty(); l = l.tail) {
5424              Assert.checkNonNull(env.info.scope.findFirst(l.head.name));
5425         }
5426 
5427         // Check that a generic class doesn&#39;t extend Throwable
5428         if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))
5429             log.error(tree.extending.pos(), Errors.GenericThrowable);
5430 
5431         // Check that all methods which implement some
5432         // method conform to the method they implement.
5433         chk.checkImplementations(tree);
5434 
5435         //check that a resource implementing AutoCloseable cannot throw InterruptedException
5436         checkAutoCloseable(tree.pos(), env, c.type);
5437 
<span class="line-added">5438         boolean hasInstanceFields = false;</span>
5439         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
5440             // Attribute declaration
5441             attribStat(l.head, env);
<span class="line-added">5442 </span>
<span class="line-added">5443             if (l.head.hasTag(VARDEF) &amp;&amp; (TreeInfo.flags(l.head) &amp; STATIC) == 0)</span>
<span class="line-added">5444                 hasInstanceFields = true;</span>
<span class="line-added">5445 </span>
5446             // Check that declarations in inner classes are not static (JLS 8.1.2)
5447             // Make an exception for static constants.
5448             if (c.owner.kind != PCK &amp;&amp;
5449                 ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
5450                 (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
5451                 Symbol sym = null;
5452                 if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
5453                 if (sym == null ||
5454                     sym.kind != VAR ||
5455                     ((VarSymbol) sym).getConstValue() == null)
5456                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5457             }
5458         }
<span class="line-added">5459         if (!allowEmptyValues &amp;&amp; !hasInstanceFields &amp;&amp; (c.flags() &amp; (VALUE | SYNTHETIC)) == VALUE) {</span>
<span class="line-added">5460             log.error(tree.pos(), Errors.EmptyValueNotYet);</span>
<span class="line-added">5461         }</span>
5462 
5463         // Check for cycles among non-initial constructors.
5464         chk.checkCyclicConstructors(tree);
5465 
5466         // Check for cycles among annotation elements.
5467         chk.checkNonCyclicElements(tree);
5468 
5469         // Check for proper use of serialVersionUID
5470         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5471                 &amp;&amp; isSerializable(c.type)
5472                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5473                 &amp;&amp; !c.isAnonymous()) {
5474             checkSerialVersionUID(tree, c);
5475         }
5476         if (allowTypeAnnos) {
5477             // Correctly organize the positions of the type annotations
5478             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5479 
5480             // Check type annotations applicability rules
5481             validateTypeAnnotations(tree, false);
</pre>
</td>
</tr>
</table>
<center><a href="../../doclint/Checker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LambdaToMethod.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>