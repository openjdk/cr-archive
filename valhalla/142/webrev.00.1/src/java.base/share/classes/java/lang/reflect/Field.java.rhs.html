<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/reflect/Field.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.reflect;
  27 
  28 import jdk.internal.access.SharedSecrets;
  29 import jdk.internal.reflect.CallerSensitive;
  30 import jdk.internal.reflect.FieldAccessor;
  31 import jdk.internal.reflect.Reflection;
  32 import jdk.internal.vm.annotation.ForceInline;
  33 import sun.reflect.generics.repository.FieldRepository;
  34 import sun.reflect.generics.factory.CoreReflectionFactory;
  35 import sun.reflect.generics.factory.GenericsFactory;
  36 import sun.reflect.generics.scope.ClassScope;
  37 import java.lang.annotation.Annotation;
  38 import java.util.Map;
  39 import java.util.Objects;
  40 import sun.reflect.annotation.AnnotationParser;
  41 import sun.reflect.annotation.AnnotationSupport;
  42 import sun.reflect.annotation.TypeAnnotation;
  43 import sun.reflect.annotation.TypeAnnotationParser;
  44 
  45 /**
  46  * A {@code Field} provides information about, and dynamic access to, a
  47  * single field of a class or an interface.  The reflected field may
  48  * be a class (static) field or an instance field.
  49  *
  50  * &lt;p&gt;A {@code Field} permits widening conversions to occur during a get or
  51  * set access operation, but throws an {@code IllegalArgumentException} if a
  52  * narrowing conversion would occur.
  53  *
  54  * @see Member
  55  * @see java.lang.Class
  56  * @see java.lang.Class#getFields()
  57  * @see java.lang.Class#getField(String)
  58  * @see java.lang.Class#getDeclaredFields()
  59  * @see java.lang.Class#getDeclaredField(String)
  60  *
  61  * @author Kenneth Russell
  62  * @author Nakul Saraiya
  63  * @since 1.1
  64  */
  65 public final
  66 class Field extends AccessibleObject implements Member {
  67 
  68     private Class&lt;?&gt;            clazz;
  69     private int                 slot;
  70     // This is guaranteed to be interned by the VM in the 1.4
  71     // reflection implementation
  72     private String              name;
  73     private Class&lt;?&gt;            type;
  74     private int                 modifiers;
  75     private boolean             trustedFinal;
  76     // Generics and annotations support
  77     private transient String    signature;
  78     // generic info repository; lazily initialized
  79     private transient FieldRepository genericInfo;
  80     private byte[]              annotations;
  81     // Cached field accessor created without override
  82     private FieldAccessor fieldAccessor;
  83     // Cached field accessor created with override
  84     private FieldAccessor overrideFieldAccessor;
  85     // For sharing of FieldAccessors. This branching structure is
  86     // currently only two levels deep (i.e., one root Field and
  87     // potentially many Field objects pointing to it.)
  88     //
  89     // If this branching structure would ever contain cycles, deadlocks can
  90     // occur in annotation code.
  91     private Field               root;
  92 
  93     // Generics infrastructure
  94 
  95     private String getGenericSignature() {return signature;}
  96 
  97     // Accessor for factory
  98     private GenericsFactory getFactory() {
  99         Class&lt;?&gt; c = getDeclaringClass();
 100         // create scope and factory
 101         return CoreReflectionFactory.make(c, ClassScope.make(c));
 102     }
 103 
 104     // Accessor for generic info repository
 105     private FieldRepository getGenericInfo() {
 106         // lazily initialize repository if necessary
 107         if (genericInfo == null) {
 108             // create and cache generic info repository
 109             genericInfo = FieldRepository.make(getGenericSignature(),
 110                                                getFactory());
 111         }
 112         return genericInfo; //return cached repository
 113     }
 114 
 115 
 116     /**
 117      * Package-private constructor
 118      */
 119     Field(Class&lt;?&gt; declaringClass,
 120           String name,
 121           Class&lt;?&gt; type,
 122           int modifiers,
 123           boolean trustedFinal,
 124           int slot,
 125           String signature,
 126           byte[] annotations)
 127     {
 128         this.clazz = declaringClass;
 129         this.name = name;
 130         this.type = type;
 131         this.modifiers = modifiers;
 132         this.trustedFinal = trustedFinal;
 133         this.slot = slot;
 134         this.signature = signature;
 135         this.annotations = annotations;
 136     }
 137 
 138     /**
 139      * Package-private routine (exposed to java.lang.Class via
 140      * ReflectAccess) which returns a copy of this Field. The copy&#39;s
 141      * &quot;root&quot; field points to this Field.
 142      */
 143     Field copy() {
 144         // This routine enables sharing of FieldAccessor objects
 145         // among Field objects which refer to the same underlying
 146         // method in the VM. (All of this contortion is only necessary
 147         // because of the &quot;accessibility&quot; bit in AccessibleObject,
 148         // which implicitly requires that new java.lang.reflect
 149         // objects be fabricated for each reflective call on Class
 150         // objects.)
 151         if (this.root != null)
 152             throw new IllegalArgumentException(&quot;Can not copy a non-root Field&quot;);
 153 
 154         Field res = new Field(clazz, name, type, modifiers, trustedFinal, slot, signature, annotations);
 155         res.root = this;
 156         // Might as well eagerly propagate this if already present
 157         res.fieldAccessor = fieldAccessor;
 158         res.overrideFieldAccessor = overrideFieldAccessor;
 159 
 160         return res;
 161     }
 162 
 163     /**
 164      * @throws InaccessibleObjectException {@inheritDoc}
 165      * @throws SecurityException {@inheritDoc}
 166      */
 167     @Override
 168     @CallerSensitive
 169     public void setAccessible(boolean flag) {
 170         AccessibleObject.checkPermission();
<a name="1" id="anc1"></a><span class="line-modified"> 171 </span>
<span class="line-added"> 172         if (flag) {</span>
<span class="line-added"> 173             checkCanSetAccessible(Reflection.getCallerClass());</span>
<span class="line-added"> 174         }</span>
 175         setAccessible0(flag);
 176     }
 177 
 178     @Override
 179     void checkCanSetAccessible(Class&lt;?&gt; caller) {
 180         checkCanSetAccessible(caller, clazz);
 181     }
 182 
 183     /**
 184      * Returns the {@code Class} object representing the class or interface
 185      * that declares the field represented by this {@code Field} object.
 186      */
 187     @Override
 188     public Class&lt;?&gt; getDeclaringClass() {
 189         return clazz;
 190     }
 191 
 192     /**
 193      * Returns the name of the field represented by this {@code Field} object.
 194      */
 195     public String getName() {
 196         return name;
 197     }
 198 
 199     /**
 200      * Returns the Java language modifiers for the field represented
 201      * by this {@code Field} object, as an integer. The {@code Modifier} class should
 202      * be used to decode the modifiers.
 203      *
 204      * @see Modifier
 205      */
 206     public int getModifiers() {
 207         return modifiers;
 208     }
 209 
 210     /**
 211      * Returns {@code true} if this field represents an element of
 212      * an enumerated type; returns {@code false} otherwise.
 213      *
 214      * @return {@code true} if and only if this field represents an element of
 215      * an enumerated type.
 216      * @since 1.5
 217      */
 218     public boolean isEnumConstant() {
 219         return (getModifiers() &amp; Modifier.ENUM) != 0;
 220     }
 221 
 222     /**
 223      * Returns {@code true} if this field is a synthetic
 224      * field; returns {@code false} otherwise.
 225      *
 226      * @return true if and only if this field is a synthetic
 227      * field as defined by the Java Language Specification.
 228      * @since 1.5
 229      */
 230     public boolean isSynthetic() {
 231         return Modifier.isSynthetic(getModifiers());
 232     }
 233 
 234     /**
 235      * Returns a {@code Class} object that identifies the
 236      * declared type for the field represented by this
 237      * {@code Field} object.
 238      *
 239      * @return a {@code Class} object identifying the declared
 240      * type of the field represented by this object
 241      */
 242     public Class&lt;?&gt; getType() {
 243         return type;
 244     }
 245 
 246     /**
 247      * Returns a {@code Type} object that represents the declared type for
 248      * the field represented by this {@code Field} object.
 249      *
 250      * &lt;p&gt;If the declared type of the field is a parameterized type,
 251      * the {@code Type} object returned must accurately reflect the
 252      * actual type arguments used in the source code.
 253      *
 254      * &lt;p&gt;If the type of the underlying field is a type variable or a
 255      * parameterized type, it is created. Otherwise, it is resolved.
 256      *
 257      * @return a {@code Type} object that represents the declared type for
 258      *     the field represented by this {@code Field} object
 259      * @throws GenericSignatureFormatError if the generic field
 260      *     signature does not conform to the format specified in
 261      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 262      * @throws TypeNotPresentException if the generic type
 263      *     signature of the underlying field refers to a non-existent
 264      *     type declaration
 265      * @throws MalformedParameterizedTypeException if the generic
 266      *     signature of the underlying field refers to a parameterized type
 267      *     that cannot be instantiated for any reason
 268      * @since 1.5
 269      */
 270     public Type getGenericType() {
 271         if (getGenericSignature() != null)
 272             return getGenericInfo().getGenericType();
 273         else
 274             return getType();
 275     }
 276 
 277 
 278     /**
 279      * Compares this {@code Field} against the specified object.  Returns
 280      * true if the objects are the same.  Two {@code Field} objects are the same if
 281      * they were declared by the same class and have the same name
 282      * and type.
 283      */
 284     public boolean equals(Object obj) {
 285         if (obj != null &amp;&amp; obj instanceof Field) {
 286             Field other = (Field)obj;
 287             return (getDeclaringClass() == other.getDeclaringClass())
 288                 &amp;&amp; (getName() == other.getName())
 289                 &amp;&amp; (getType() == other.getType());
 290         }
 291         return false;
 292     }
 293 
 294     /**
 295      * Returns a hashcode for this {@code Field}.  This is computed as the
 296      * exclusive-or of the hashcodes for the underlying field&#39;s
 297      * declaring class name and its name.
 298      */
 299     public int hashCode() {
 300         return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
 301     }
 302 
 303     /**
 304      * Returns a string describing this {@code Field}.  The format is
 305      * the access modifiers for the field, if any, followed
 306      * by the field type, followed by a space, followed by
 307      * the fully-qualified name of the class declaring the field,
 308      * followed by a period, followed by the name of the field.
 309      * For example:
 310      * &lt;pre&gt;
 311      *    public static final int java.lang.Thread.MIN_PRIORITY
 312      *    private int java.io.FileDescriptor.fd
 313      * &lt;/pre&gt;
 314      *
 315      * &lt;p&gt;The modifiers are placed in canonical order as specified by
 316      * &quot;The Java Language Specification&quot;.  This is {@code public},
 317      * {@code protected} or {@code private} first, and then other
 318      * modifiers in the following order: {@code static}, {@code final},
 319      * {@code transient}, {@code volatile}.
 320      *
 321      * @return a string describing this {@code Field}
 322      * @jls 8.3.1 Field Modifiers
 323      */
 324     public String toString() {
 325         int mod = getModifiers();
 326         return (((mod == 0) ? &quot;&quot; : (Modifier.toString(mod) + &quot; &quot;))
 327             + getType().getTypeName() + &quot; &quot;
 328             + getDeclaringClass().getTypeName() + &quot;.&quot;
 329             + getName());
 330     }
 331 
 332     @Override
 333     String toShortString() {
 334         return &quot;field &quot; + getDeclaringClass().getTypeName() + &quot;.&quot; + getName();
 335     }
 336 
 337     /**
 338      * Returns a string describing this {@code Field}, including
 339      * its generic type.  The format is the access modifiers for the
 340      * field, if any, followed by the generic field type, followed by
 341      * a space, followed by the fully-qualified name of the class
 342      * declaring the field, followed by a period, followed by the name
 343      * of the field.
 344      *
 345      * &lt;p&gt;The modifiers are placed in canonical order as specified by
 346      * &quot;The Java Language Specification&quot;.  This is {@code public},
 347      * {@code protected} or {@code private} first, and then other
 348      * modifiers in the following order: {@code static}, {@code final},
 349      * {@code transient}, {@code volatile}.
 350      *
 351      * @return a string describing this {@code Field}, including
 352      * its generic type
 353      *
 354      * @since 1.5
 355      * @jls 8.3.1 Field Modifiers
 356      */
 357     public String toGenericString() {
 358         int mod = getModifiers();
 359         Type fieldType = getGenericType();
 360         return (((mod == 0) ? &quot;&quot; : (Modifier.toString(mod) + &quot; &quot;))
 361             + fieldType.getTypeName() + &quot; &quot;
 362             + getDeclaringClass().getTypeName() + &quot;.&quot;
 363             + getName());
 364     }
 365 
 366     /**
 367      * Returns the value of the field represented by this {@code Field}, on
 368      * the specified object. The value is automatically wrapped in an
 369      * object if it has a primitive type.
 370      *
 371      * &lt;p&gt;The underlying field&#39;s value is obtained as follows:
 372      *
 373      * &lt;p&gt;If the underlying field is a static field, the {@code obj} argument
 374      * is ignored; it may be null.
 375      *
 376      * &lt;p&gt;Otherwise, the underlying field is an instance field.  If the
 377      * specified {@code obj} argument is null, the method throws a
 378      * {@code NullPointerException}. If the specified object is not an
 379      * instance of the class or interface declaring the underlying
 380      * field, the method throws an {@code IllegalArgumentException}.
 381      *
 382      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 383      * the underlying field is inaccessible, the method throws an
 384      * {@code IllegalAccessException}.
 385      * If the underlying field is static, the class that declared the
 386      * field is initialized if it has not already been initialized.
 387      *
 388      * &lt;p&gt;Otherwise, the value is retrieved from the underlying instance
 389      * or static field.  If the field has a primitive type, the value
 390      * is wrapped in an object before being returned, otherwise it is
 391      * returned as is.
 392      *
 393      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 394      * the field&#39;s value is obtained according to the preceding rules.
 395      *
 396      * @param obj object from which the represented field&#39;s value is
 397      * to be extracted
 398      * @return the value of the represented field in object
 399      * {@code obj}; primitive values are wrapped in an appropriate
 400      * object before being returned
 401      *
 402      * @throws    IllegalAccessException    if this {@code Field} object
 403      *              is enforcing Java language access control and the underlying
 404      *              field is inaccessible.
 405      * @throws    IllegalArgumentException  if the specified object is not an
 406      *              instance of the class or interface declaring the underlying
 407      *              field (or a subclass or implementor thereof).
 408      * @throws    NullPointerException      if the specified object is null
 409      *              and the field is an instance field.
 410      * @throws    ExceptionInInitializerError if the initialization provoked
 411      *              by this method fails.
 412      */
 413     @CallerSensitive
 414     @ForceInline // to ensure Reflection.getCallerClass optimization
 415     public Object get(Object obj)
 416         throws IllegalArgumentException, IllegalAccessException
 417     {
 418         if (!override) {
 419             Class&lt;?&gt; caller = Reflection.getCallerClass();
 420             checkAccess(caller, obj);
 421         }
 422         return getFieldAccessor(obj).get(obj);
 423     }
 424 
 425     /**
 426      * Gets the value of a static or instance {@code boolean} field.
 427      *
 428      * @param obj the object to extract the {@code boolean} value
 429      * from
 430      * @return the value of the {@code boolean} field
 431      *
 432      * @throws    IllegalAccessException    if this {@code Field} object
 433      *              is enforcing Java language access control and the underlying
 434      *              field is inaccessible.
 435      * @throws    IllegalArgumentException  if the specified object is not
 436      *              an instance of the class or interface declaring the
 437      *              underlying field (or a subclass or implementor
 438      *              thereof), or if the field value cannot be
 439      *              converted to the type {@code boolean} by a
 440      *              widening conversion.
 441      * @throws    NullPointerException      if the specified object is null
 442      *              and the field is an instance field.
 443      * @throws    ExceptionInInitializerError if the initialization provoked
 444      *              by this method fails.
 445      * @see       Field#get
 446      */
 447     @CallerSensitive
 448     @ForceInline // to ensure Reflection.getCallerClass optimization
 449     public boolean getBoolean(Object obj)
 450         throws IllegalArgumentException, IllegalAccessException
 451     {
 452         if (!override) {
 453             Class&lt;?&gt; caller = Reflection.getCallerClass();
 454             checkAccess(caller, obj);
 455         }
 456         return getFieldAccessor(obj).getBoolean(obj);
 457     }
 458 
 459     /**
 460      * Gets the value of a static or instance {@code byte} field.
 461      *
 462      * @param obj the object to extract the {@code byte} value
 463      * from
 464      * @return the value of the {@code byte} field
 465      *
 466      * @throws    IllegalAccessException    if this {@code Field} object
 467      *              is enforcing Java language access control and the underlying
 468      *              field is inaccessible.
 469      * @throws    IllegalArgumentException  if the specified object is not
 470      *              an instance of the class or interface declaring the
 471      *              underlying field (or a subclass or implementor
 472      *              thereof), or if the field value cannot be
 473      *              converted to the type {@code byte} by a
 474      *              widening conversion.
 475      * @throws    NullPointerException      if the specified object is null
 476      *              and the field is an instance field.
 477      * @throws    ExceptionInInitializerError if the initialization provoked
 478      *              by this method fails.
 479      * @see       Field#get
 480      */
 481     @CallerSensitive
 482     @ForceInline // to ensure Reflection.getCallerClass optimization
 483     public byte getByte(Object obj)
 484         throws IllegalArgumentException, IllegalAccessException
 485     {
 486         if (!override) {
 487             Class&lt;?&gt; caller = Reflection.getCallerClass();
 488             checkAccess(caller, obj);
 489         }
 490         return getFieldAccessor(obj).getByte(obj);
 491     }
 492 
 493     /**
 494      * Gets the value of a static or instance field of type
 495      * {@code char} or of another primitive type convertible to
 496      * type {@code char} via a widening conversion.
 497      *
 498      * @param obj the object to extract the {@code char} value
 499      * from
 500      * @return the value of the field converted to type {@code char}
 501      *
 502      * @throws    IllegalAccessException    if this {@code Field} object
 503      *              is enforcing Java language access control and the underlying
 504      *              field is inaccessible.
 505      * @throws    IllegalArgumentException  if the specified object is not
 506      *              an instance of the class or interface declaring the
 507      *              underlying field (or a subclass or implementor
 508      *              thereof), or if the field value cannot be
 509      *              converted to the type {@code char} by a
 510      *              widening conversion.
 511      * @throws    NullPointerException      if the specified object is null
 512      *              and the field is an instance field.
 513      * @throws    ExceptionInInitializerError if the initialization provoked
 514      *              by this method fails.
 515      * @see Field#get
 516      */
 517     @CallerSensitive
 518     @ForceInline // to ensure Reflection.getCallerClass optimization
 519     public char getChar(Object obj)
 520         throws IllegalArgumentException, IllegalAccessException
 521     {
 522         if (!override) {
 523             Class&lt;?&gt; caller = Reflection.getCallerClass();
 524             checkAccess(caller, obj);
 525         }
 526         return getFieldAccessor(obj).getChar(obj);
 527     }
 528 
 529     /**
 530      * Gets the value of a static or instance field of type
 531      * {@code short} or of another primitive type convertible to
 532      * type {@code short} via a widening conversion.
 533      *
 534      * @param obj the object to extract the {@code short} value
 535      * from
 536      * @return the value of the field converted to type {@code short}
 537      *
 538      * @throws    IllegalAccessException    if this {@code Field} object
 539      *              is enforcing Java language access control and the underlying
 540      *              field is inaccessible.
 541      * @throws    IllegalArgumentException  if the specified object is not
 542      *              an instance of the class or interface declaring the
 543      *              underlying field (or a subclass or implementor
 544      *              thereof), or if the field value cannot be
 545      *              converted to the type {@code short} by a
 546      *              widening conversion.
 547      * @throws    NullPointerException      if the specified object is null
 548      *              and the field is an instance field.
 549      * @throws    ExceptionInInitializerError if the initialization provoked
 550      *              by this method fails.
 551      * @see       Field#get
 552      */
 553     @CallerSensitive
 554     @ForceInline // to ensure Reflection.getCallerClass optimization
 555     public short getShort(Object obj)
 556         throws IllegalArgumentException, IllegalAccessException
 557     {
 558         if (!override) {
 559             Class&lt;?&gt; caller = Reflection.getCallerClass();
 560             checkAccess(caller, obj);
 561         }
 562         return getFieldAccessor(obj).getShort(obj);
 563     }
 564 
 565     /**
 566      * Gets the value of a static or instance field of type
 567      * {@code int} or of another primitive type convertible to
 568      * type {@code int} via a widening conversion.
 569      *
 570      * @param obj the object to extract the {@code int} value
 571      * from
 572      * @return the value of the field converted to type {@code int}
 573      *
 574      * @throws    IllegalAccessException    if this {@code Field} object
 575      *              is enforcing Java language access control and the underlying
 576      *              field is inaccessible.
 577      * @throws    IllegalArgumentException  if the specified object is not
 578      *              an instance of the class or interface declaring the
 579      *              underlying field (or a subclass or implementor
 580      *              thereof), or if the field value cannot be
 581      *              converted to the type {@code int} by a
 582      *              widening conversion.
 583      * @throws    NullPointerException      if the specified object is null
 584      *              and the field is an instance field.
 585      * @throws    ExceptionInInitializerError if the initialization provoked
 586      *              by this method fails.
 587      * @see       Field#get
 588      */
 589     @CallerSensitive
 590     @ForceInline // to ensure Reflection.getCallerClass optimization
 591     public int getInt(Object obj)
 592         throws IllegalArgumentException, IllegalAccessException
 593     {
 594         if (!override) {
 595             Class&lt;?&gt; caller = Reflection.getCallerClass();
 596             checkAccess(caller, obj);
 597         }
 598         return getFieldAccessor(obj).getInt(obj);
 599     }
 600 
 601     /**
 602      * Gets the value of a static or instance field of type
 603      * {@code long} or of another primitive type convertible to
 604      * type {@code long} via a widening conversion.
 605      *
 606      * @param obj the object to extract the {@code long} value
 607      * from
 608      * @return the value of the field converted to type {@code long}
 609      *
 610      * @throws    IllegalAccessException    if this {@code Field} object
 611      *              is enforcing Java language access control and the underlying
 612      *              field is inaccessible.
 613      * @throws    IllegalArgumentException  if the specified object is not
 614      *              an instance of the class or interface declaring the
 615      *              underlying field (or a subclass or implementor
 616      *              thereof), or if the field value cannot be
 617      *              converted to the type {@code long} by a
 618      *              widening conversion.
 619      * @throws    NullPointerException      if the specified object is null
 620      *              and the field is an instance field.
 621      * @throws    ExceptionInInitializerError if the initialization provoked
 622      *              by this method fails.
 623      * @see       Field#get
 624      */
 625     @CallerSensitive
 626     @ForceInline // to ensure Reflection.getCallerClass optimization
 627     public long getLong(Object obj)
 628         throws IllegalArgumentException, IllegalAccessException
 629     {
 630         if (!override) {
 631             Class&lt;?&gt; caller = Reflection.getCallerClass();
 632             checkAccess(caller, obj);
 633         }
 634         return getFieldAccessor(obj).getLong(obj);
 635     }
 636 
 637     /**
 638      * Gets the value of a static or instance field of type
 639      * {@code float} or of another primitive type convertible to
 640      * type {@code float} via a widening conversion.
 641      *
 642      * @param obj the object to extract the {@code float} value
 643      * from
 644      * @return the value of the field converted to type {@code float}
 645      *
 646      * @throws    IllegalAccessException    if this {@code Field} object
 647      *              is enforcing Java language access control and the underlying
 648      *              field is inaccessible.
 649      * @throws    IllegalArgumentException  if the specified object is not
 650      *              an instance of the class or interface declaring the
 651      *              underlying field (or a subclass or implementor
 652      *              thereof), or if the field value cannot be
 653      *              converted to the type {@code float} by a
 654      *              widening conversion.
 655      * @throws    NullPointerException      if the specified object is null
 656      *              and the field is an instance field.
 657      * @throws    ExceptionInInitializerError if the initialization provoked
 658      *              by this method fails.
 659      * @see Field#get
 660      */
 661     @CallerSensitive
 662     @ForceInline // to ensure Reflection.getCallerClass optimization
 663     public float getFloat(Object obj)
 664         throws IllegalArgumentException, IllegalAccessException
 665     {
 666         if (!override) {
 667             Class&lt;?&gt; caller = Reflection.getCallerClass();
 668             checkAccess(caller, obj);
 669         }
 670         return getFieldAccessor(obj).getFloat(obj);
 671     }
 672 
 673     /**
 674      * Gets the value of a static or instance field of type
 675      * {@code double} or of another primitive type convertible to
 676      * type {@code double} via a widening conversion.
 677      *
 678      * @param obj the object to extract the {@code double} value
 679      * from
 680      * @return the value of the field converted to type {@code double}
 681      *
 682      * @throws    IllegalAccessException    if this {@code Field} object
 683      *              is enforcing Java language access control and the underlying
 684      *              field is inaccessible.
 685      * @throws    IllegalArgumentException  if the specified object is not
 686      *              an instance of the class or interface declaring the
 687      *              underlying field (or a subclass or implementor
 688      *              thereof), or if the field value cannot be
 689      *              converted to the type {@code double} by a
 690      *              widening conversion.
 691      * @throws    NullPointerException      if the specified object is null
 692      *              and the field is an instance field.
 693      * @throws    ExceptionInInitializerError if the initialization provoked
 694      *              by this method fails.
 695      * @see       Field#get
 696      */
 697     @CallerSensitive
 698     @ForceInline // to ensure Reflection.getCallerClass optimization
 699     public double getDouble(Object obj)
 700         throws IllegalArgumentException, IllegalAccessException
 701     {
 702         if (!override) {
 703             Class&lt;?&gt; caller = Reflection.getCallerClass();
 704             checkAccess(caller, obj);
 705         }
 706         return getFieldAccessor(obj).getDouble(obj);
 707     }
 708 
 709     /**
 710      * Sets the field represented by this {@code Field} object on the
 711      * specified object argument to the specified new value. The new
 712      * value is automatically unwrapped if the underlying field has a
 713      * primitive type.
 714      *
 715      * &lt;p&gt;The operation proceeds as follows:
 716      *
 717      * &lt;p&gt;If the underlying field is static, the {@code obj} argument is
 718      * ignored; it may be null.
 719      *
 720      * &lt;p&gt;Otherwise the underlying field is an instance field.  If the
 721      * specified object argument is null, the method throws a
 722      * {@code NullPointerException}.  If the specified object argument is not
 723      * an instance of the class or interface declaring the underlying
 724      * field, the method throws an {@code IllegalArgumentException}.
 725      *
 726      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 727      * the underlying field is inaccessible, the method throws an
 728      * {@code IllegalAccessException}.
 729      *
 730      * &lt;p&gt;If the underlying field is final, this {@code Field} object has
 731      * &lt;em&gt;write&lt;/em&gt; access if and only if the following conditions are met:
 732      * &lt;ul&gt;
 733      * &lt;li&gt;{@link #setAccessible(boolean) setAccessible(true)} has succeeded for
 734      *     this {@code Field} object;&lt;/li&gt;
 735      * &lt;li&gt;the field is non-static; and&lt;/li&gt;
 736      * &lt;li&gt;the field&#39;s declaring class is not a {@linkplain Class#isHidden()
 737      *     hidden class}; and&lt;/li&gt;
 738      * &lt;li&gt;the field&#39;s declaring class is not a {@linkplain Class#isRecord()
 739      *     record class}.&lt;/li&gt;
 740      * &lt;/ul&gt;
 741      * If any of the above checks is not met, this method throws an
 742      * {@code IllegalAccessException}.
 743      *
 744      * &lt;p&gt; Setting a final field in this way
 745      * is meaningful only during deserialization or reconstruction of
 746      * instances of classes with blank final fields, before they are
 747      * made available for access by other parts of a program. Use in
 748      * any other context may have unpredictable effects, including cases
 749      * in which other parts of a program continue to use the original
 750      * value of this field.
 751      *
 752      * &lt;p&gt;If the underlying field is of a primitive type, an unwrapping
 753      * conversion is attempted to convert the new value to a value of
 754      * a primitive type.  If this attempt fails, the method throws an
 755      * {@code IllegalArgumentException}.
 756      *
 757      * &lt;p&gt;If, after possible unwrapping, the new value cannot be
 758      * converted to the type of the underlying field by an identity or
 759      * widening conversion, the method throws an
 760      * {@code IllegalArgumentException}.
 761      *
 762      * &lt;p&gt;If the underlying field is static, the class that declared the
 763      * field is initialized if it has not already been initialized.
 764      *
 765      * &lt;p&gt;The field is set to the possibly unwrapped and widened new value.
 766      *
 767      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 768      * the field&#39;s value is set according to the preceding rules.
 769      *
 770      * @param obj the object whose field should be modified
 771      * @param value the new value for the field of {@code obj}
 772      * being modified
 773      *
 774      * @throws    IllegalAccessException    if this {@code Field} object
 775      *              is enforcing Java language access control and the underlying
 776      *              field is inaccessible or final;
 777      *              or if this {@code Field} object has no write access.
 778      * @throws    IllegalArgumentException  if the specified object is not an
 779      *              instance of the class or interface declaring the underlying
 780      *              field (or a subclass or implementor thereof),
 781      *              or if an unwrapping conversion fails.
 782      * @throws    NullPointerException      if the specified object is null
 783      *              and the field is an instance field.
 784      * @throws    ExceptionInInitializerError if the initialization provoked
 785      *              by this method fails.
 786      */
 787     @CallerSensitive
 788     @ForceInline // to ensure Reflection.getCallerClass optimization
 789     public void set(Object obj, Object value)
 790         throws IllegalArgumentException, IllegalAccessException
 791     {
 792         if (!override) {
 793             Class&lt;?&gt; caller = Reflection.getCallerClass();
 794             checkAccess(caller, obj);
 795         }
 796         getFieldAccessor(obj).set(obj, value);
 797     }
 798 
 799     /**
 800      * Sets the value of a field as a {@code boolean} on the specified object.
 801      * This method is equivalent to
 802      * {@code set(obj, zObj)},
 803      * where {@code zObj} is a {@code Boolean} object and
 804      * {@code zObj.booleanValue() == z}.
 805      *
 806      * @param obj the object whose field should be modified
 807      * @param z   the new value for the field of {@code obj}
 808      * being modified
 809      *
 810      * @throws    IllegalAccessException    if this {@code Field} object
 811      *              is enforcing Java language access control and the underlying
 812      *              field is either inaccessible or final;
 813      *              or if this {@code Field} object has no write access.
 814      * @throws    IllegalArgumentException  if the specified object is not an
 815      *              instance of the class or interface declaring the underlying
 816      *              field (or a subclass or implementor thereof),
 817      *              or if an unwrapping conversion fails.
 818      * @throws    NullPointerException      if the specified object is null
 819      *              and the field is an instance field.
 820      * @throws    ExceptionInInitializerError if the initialization provoked
 821      *              by this method fails.
 822      * @see       Field#set
 823      */
 824     @CallerSensitive
 825     @ForceInline // to ensure Reflection.getCallerClass optimization
 826     public void setBoolean(Object obj, boolean z)
 827         throws IllegalArgumentException, IllegalAccessException
 828     {
 829         if (!override) {
 830             Class&lt;?&gt; caller = Reflection.getCallerClass();
 831             checkAccess(caller, obj);
 832         }
 833         getFieldAccessor(obj).setBoolean(obj, z);
 834     }
 835 
 836     /**
 837      * Sets the value of a field as a {@code byte} on the specified object.
 838      * This method is equivalent to
 839      * {@code set(obj, bObj)},
 840      * where {@code bObj} is a {@code Byte} object and
 841      * {@code bObj.byteValue() == b}.
 842      *
 843      * @param obj the object whose field should be modified
 844      * @param b   the new value for the field of {@code obj}
 845      * being modified
 846      *
 847      * @throws    IllegalAccessException    if this {@code Field} object
 848      *              is enforcing Java language access control and the underlying
 849      *              field is either inaccessible or final;
 850      *              or if this {@code Field} object has no write access.
 851      * @throws    IllegalArgumentException  if the specified object is not an
 852      *              instance of the class or interface declaring the underlying
 853      *              field (or a subclass or implementor thereof),
 854      *              or if an unwrapping conversion fails.
 855      * @throws    NullPointerException      if the specified object is null
 856      *              and the field is an instance field.
 857      * @throws    ExceptionInInitializerError if the initialization provoked
 858      *              by this method fails.
 859      * @see       Field#set
 860      */
 861     @CallerSensitive
 862     @ForceInline // to ensure Reflection.getCallerClass optimization
 863     public void setByte(Object obj, byte b)
 864         throws IllegalArgumentException, IllegalAccessException
 865     {
 866         if (!override) {
 867             Class&lt;?&gt; caller = Reflection.getCallerClass();
 868             checkAccess(caller, obj);
 869         }
 870         getFieldAccessor(obj).setByte(obj, b);
 871     }
 872 
 873     /**
 874      * Sets the value of a field as a {@code char} on the specified object.
 875      * This method is equivalent to
 876      * {@code set(obj, cObj)},
 877      * where {@code cObj} is a {@code Character} object and
 878      * {@code cObj.charValue() == c}.
 879      *
 880      * @param obj the object whose field should be modified
 881      * @param c   the new value for the field of {@code obj}
 882      * being modified
 883      *
 884      * @throws    IllegalAccessException    if this {@code Field} object
 885      *              is enforcing Java language access control and the underlying
 886      *              field is either inaccessible or final;
 887      *              or if this {@code Field} object has no write access.
 888      * @throws    IllegalArgumentException  if the specified object is not an
 889      *              instance of the class or interface declaring the underlying
 890      *              field (or a subclass or implementor thereof),
 891      *              or if an unwrapping conversion fails.
 892      * @throws    NullPointerException      if the specified object is null
 893      *              and the field is an instance field.
 894      * @throws    ExceptionInInitializerError if the initialization provoked
 895      *              by this method fails.
 896      * @see       Field#set
 897      */
 898     @CallerSensitive
 899     @ForceInline // to ensure Reflection.getCallerClass optimization
 900     public void setChar(Object obj, char c)
 901         throws IllegalArgumentException, IllegalAccessException
 902     {
 903         if (!override) {
 904             Class&lt;?&gt; caller = Reflection.getCallerClass();
 905             checkAccess(caller, obj);
 906         }
 907         getFieldAccessor(obj).setChar(obj, c);
 908     }
 909 
 910     /**
 911      * Sets the value of a field as a {@code short} on the specified object.
 912      * This method is equivalent to
 913      * {@code set(obj, sObj)},
 914      * where {@code sObj} is a {@code Short} object and
 915      * {@code sObj.shortValue() == s}.
 916      *
 917      * @param obj the object whose field should be modified
 918      * @param s   the new value for the field of {@code obj}
 919      * being modified
 920      *
 921      * @throws    IllegalAccessException    if this {@code Field} object
 922      *              is enforcing Java language access control and the underlying
 923      *              field is either inaccessible or final;
 924      *              or if this {@code Field} object has no write access.
 925      * @throws    IllegalArgumentException  if the specified object is not an
 926      *              instance of the class or interface declaring the underlying
 927      *              field (or a subclass or implementor thereof),
 928      *              or if an unwrapping conversion fails.
 929      * @throws    NullPointerException      if the specified object is null
 930      *              and the field is an instance field.
 931      * @throws    ExceptionInInitializerError if the initialization provoked
 932      *              by this method fails.
 933      * @see       Field#set
 934      */
 935     @CallerSensitive
 936     @ForceInline // to ensure Reflection.getCallerClass optimization
 937     public void setShort(Object obj, short s)
 938         throws IllegalArgumentException, IllegalAccessException
 939     {
 940         if (!override) {
 941             Class&lt;?&gt; caller = Reflection.getCallerClass();
 942             checkAccess(caller, obj);
 943         }
 944         getFieldAccessor(obj).setShort(obj, s);
 945     }
 946 
 947     /**
 948      * Sets the value of a field as an {@code int} on the specified object.
 949      * This method is equivalent to
 950      * {@code set(obj, iObj)},
 951      * where {@code iObj} is an {@code Integer} object and
 952      * {@code iObj.intValue() == i}.
 953      *
 954      * @param obj the object whose field should be modified
 955      * @param i   the new value for the field of {@code obj}
 956      * being modified
 957      *
 958      * @throws    IllegalAccessException    if this {@code Field} object
 959      *              is enforcing Java language access control and the underlying
 960      *              field is either inaccessible or final;
 961      *              or if this {@code Field} object has no write access.
 962      * @throws    IllegalArgumentException  if the specified object is not an
 963      *              instance of the class or interface declaring the underlying
 964      *              field (or a subclass or implementor thereof),
 965      *              or if an unwrapping conversion fails.
 966      * @throws    NullPointerException      if the specified object is null
 967      *              and the field is an instance field.
 968      * @throws    ExceptionInInitializerError if the initialization provoked
 969      *              by this method fails.
 970      * @see       Field#set
 971      */
 972     @CallerSensitive
 973     @ForceInline // to ensure Reflection.getCallerClass optimization
 974     public void setInt(Object obj, int i)
 975         throws IllegalArgumentException, IllegalAccessException
 976     {
 977         if (!override) {
 978             Class&lt;?&gt; caller = Reflection.getCallerClass();
 979             checkAccess(caller, obj);
 980         }
 981         getFieldAccessor(obj).setInt(obj, i);
 982     }
 983 
 984     /**
 985      * Sets the value of a field as a {@code long} on the specified object.
 986      * This method is equivalent to
 987      * {@code set(obj, lObj)},
 988      * where {@code lObj} is a {@code Long} object and
 989      * {@code lObj.longValue() == l}.
 990      *
 991      * @param obj the object whose field should be modified
 992      * @param l   the new value for the field of {@code obj}
 993      * being modified
 994      *
 995      * @throws    IllegalAccessException    if this {@code Field} object
 996      *              is enforcing Java language access control and the underlying
 997      *              field is either inaccessible or final;
 998      *              or if this {@code Field} object has no write access.
 999      * @throws    IllegalArgumentException  if the specified object is not an
1000      *              instance of the class or interface declaring the underlying
1001      *              field (or a subclass or implementor thereof),
1002      *              or if an unwrapping conversion fails.
1003      * @throws    NullPointerException      if the specified object is null
1004      *              and the field is an instance field.
1005      * @throws    ExceptionInInitializerError if the initialization provoked
1006      *              by this method fails.
1007      * @see       Field#set
1008      */
1009     @CallerSensitive
1010     @ForceInline // to ensure Reflection.getCallerClass optimization
1011     public void setLong(Object obj, long l)
1012         throws IllegalArgumentException, IllegalAccessException
1013     {
1014         if (!override) {
1015             Class&lt;?&gt; caller = Reflection.getCallerClass();
1016             checkAccess(caller, obj);
1017         }
1018         getFieldAccessor(obj).setLong(obj, l);
1019     }
1020 
1021     /**
1022      * Sets the value of a field as a {@code float} on the specified object.
1023      * This method is equivalent to
1024      * {@code set(obj, fObj)},
1025      * where {@code fObj} is a {@code Float} object and
1026      * {@code fObj.floatValue() == f}.
1027      *
1028      * @param obj the object whose field should be modified
1029      * @param f   the new value for the field of {@code obj}
1030      * being modified
1031      *
1032      * @throws    IllegalAccessException    if this {@code Field} object
1033      *              is enforcing Java language access control and the underlying
1034      *              field is either inaccessible or final;
1035      *              or if this {@code Field} object has no write access.
1036      * @throws    IllegalArgumentException  if the specified object is not an
1037      *              instance of the class or interface declaring the underlying
1038      *              field (or a subclass or implementor thereof),
1039      *              or if an unwrapping conversion fails.
1040      * @throws    NullPointerException      if the specified object is null
1041      *              and the field is an instance field.
1042      * @throws    ExceptionInInitializerError if the initialization provoked
1043      *              by this method fails.
1044      * @see       Field#set
1045      */
1046     @CallerSensitive
1047     @ForceInline // to ensure Reflection.getCallerClass optimization
1048     public void setFloat(Object obj, float f)
1049         throws IllegalArgumentException, IllegalAccessException
1050     {
1051         if (!override) {
1052             Class&lt;?&gt; caller = Reflection.getCallerClass();
1053             checkAccess(caller, obj);
1054         }
1055         getFieldAccessor(obj).setFloat(obj, f);
1056     }
1057 
1058     /**
1059      * Sets the value of a field as a {@code double} on the specified object.
1060      * This method is equivalent to
1061      * {@code set(obj, dObj)},
1062      * where {@code dObj} is a {@code Double} object and
1063      * {@code dObj.doubleValue() == d}.
1064      *
1065      * @param obj the object whose field should be modified
1066      * @param d   the new value for the field of {@code obj}
1067      * being modified
1068      *
1069      * @throws    IllegalAccessException    if this {@code Field} object
1070      *              is enforcing Java language access control and the underlying
1071      *              field is either inaccessible or final;
1072      *              or if this {@code Field} object has no write access.
1073      * @throws    IllegalArgumentException  if the specified object is not an
1074      *              instance of the class or interface declaring the underlying
1075      *              field (or a subclass or implementor thereof),
1076      *              or if an unwrapping conversion fails.
1077      * @throws    NullPointerException      if the specified object is null
1078      *              and the field is an instance field.
1079      * @throws    ExceptionInInitializerError if the initialization provoked
1080      *              by this method fails.
1081      * @see       Field#set
1082      */
1083     @CallerSensitive
1084     @ForceInline // to ensure Reflection.getCallerClass optimization
1085     public void setDouble(Object obj, double d)
1086         throws IllegalArgumentException, IllegalAccessException
1087     {
1088         if (!override) {
1089             Class&lt;?&gt; caller = Reflection.getCallerClass();
1090             checkAccess(caller, obj);
1091         }
1092         getFieldAccessor(obj).setDouble(obj, d);
1093     }
1094 
1095     // check access to field
1096     private void checkAccess(Class&lt;?&gt; caller, Object obj)
1097         throws IllegalAccessException
1098     {
1099         checkAccess(caller, clazz,
1100                     Modifier.isStatic(modifiers) ? null : obj.getClass(),
1101                     modifiers);
1102     }
1103 
1104     // security check is done before calling this method
1105     private FieldAccessor getFieldAccessor(Object obj)
1106         throws IllegalAccessException
1107     {
1108         boolean ov = override;
1109         FieldAccessor a = (ov) ? overrideFieldAccessor : fieldAccessor;
1110         return (a != null) ? a : acquireFieldAccessor(ov);
1111     }
1112 
1113     // NOTE that there is no synchronization used here. It is correct
1114     // (though not efficient) to generate more than one FieldAccessor
1115     // for a given Field. However, avoiding synchronization will
1116     // probably make the implementation more scalable.
1117     private FieldAccessor acquireFieldAccessor(boolean overrideFinalCheck) {
1118         // First check to see if one has been created yet, and take it
1119         // if so
1120         FieldAccessor tmp = null;
1121         if (root != null) tmp = root.getFieldAccessor(overrideFinalCheck);
1122         if (tmp != null) {
1123             if (overrideFinalCheck)
1124                 overrideFieldAccessor = tmp;
1125             else
1126                 fieldAccessor = tmp;
1127         } else {
1128             // Otherwise fabricate one and propagate it up to the root
1129             tmp = reflectionFactory.newFieldAccessor(this, overrideFinalCheck);
1130             setFieldAccessor(tmp, overrideFinalCheck);
1131         }
1132 
1133         return tmp;
1134     }
1135 
1136     // Returns FieldAccessor for this Field object, not looking up
1137     // the chain to the root
1138     private FieldAccessor getFieldAccessor(boolean overrideFinalCheck) {
1139         return (overrideFinalCheck)? overrideFieldAccessor : fieldAccessor;
1140     }
1141 
1142     // Sets the FieldAccessor for this Field object and
1143     // (recursively) its root
1144     private void setFieldAccessor(FieldAccessor accessor, boolean overrideFinalCheck) {
1145         if (overrideFinalCheck)
1146             overrideFieldAccessor = accessor;
1147         else
1148             fieldAccessor = accessor;
1149         // Propagate up
1150         if (root != null) {
1151             root.setFieldAccessor(accessor, overrideFinalCheck);
1152         }
1153     }
1154 
1155     @Override
1156     /* package-private */ Field getRoot() {
1157         return root;
1158     }
1159 
1160     /* package-private */ boolean isTrustedFinal() {
1161         return trustedFinal;
1162     }
1163 
1164     /**
1165      * {@inheritDoc}
1166      *
1167      * @throws NullPointerException {@inheritDoc}
1168      * @since 1.5
1169      */
1170     @Override
1171     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
1172         Objects.requireNonNull(annotationClass);
1173         return annotationClass.cast(declaredAnnotations().get(annotationClass));
1174     }
1175 
1176     /**
1177      * {@inheritDoc}
1178      *
1179      * @throws NullPointerException {@inheritDoc}
1180      * @since 1.8
1181      */
1182     @Override
1183     public &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) {
1184         Objects.requireNonNull(annotationClass);
1185 
1186         return AnnotationSupport.getDirectlyAndIndirectlyPresent(declaredAnnotations(), annotationClass);
1187     }
1188 
1189     /**
1190      * {@inheritDoc}
1191      */
1192     @Override
1193     public Annotation[] getDeclaredAnnotations()  {
1194         return AnnotationParser.toArray(declaredAnnotations());
1195     }
1196 
1197     private transient volatile Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
1198 
1199     private Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations() {
1200         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declAnnos;
1201         if ((declAnnos = declaredAnnotations) == null) {
1202             synchronized (this) {
1203                 if ((declAnnos = declaredAnnotations) == null) {
1204                     Field root = this.root;
1205                     if (root != null) {
1206                         declAnnos = root.declaredAnnotations();
1207                     } else {
1208                         declAnnos = AnnotationParser.parseAnnotations(
1209                                 annotations,
1210                                 SharedSecrets.getJavaLangAccess()
1211                                         .getConstantPool(getDeclaringClass()),
1212                                 getDeclaringClass());
1213                     }
1214                     declaredAnnotations = declAnnos;
1215                 }
1216             }
1217         }
1218         return declAnnos;
1219     }
1220 
1221     private native byte[] getTypeAnnotationBytes0();
1222 
1223     /**
1224      * Returns an AnnotatedType object that represents the use of a type to specify
1225      * the declared type of the field represented by this Field.
1226      * @return an object representing the declared type of the field
1227      * represented by this Field
1228      *
1229      * @since 1.8
1230      */
1231     public AnnotatedType getAnnotatedType() {
1232         return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),
1233                                                        SharedSecrets.getJavaLangAccess().
1234                                                            getConstantPool(getDeclaringClass()),
1235                                                        this,
1236                                                        getDeclaringClass(),
1237                                                        getGenericType(),
1238                                                        TypeAnnotation.TypeAnnotationTarget.FIELD);
1239 }
1240 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>