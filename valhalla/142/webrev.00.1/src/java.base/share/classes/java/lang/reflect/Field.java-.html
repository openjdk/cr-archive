<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/reflect/Field.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.reflect;
  27 
  28 import jdk.internal.access.SharedSecrets;
  29 import jdk.internal.reflect.CallerSensitive;
  30 import jdk.internal.reflect.FieldAccessor;
  31 import jdk.internal.reflect.Reflection;
  32 import jdk.internal.vm.annotation.ForceInline;
  33 import sun.reflect.generics.repository.FieldRepository;
  34 import sun.reflect.generics.factory.CoreReflectionFactory;
  35 import sun.reflect.generics.factory.GenericsFactory;
  36 import sun.reflect.generics.scope.ClassScope;
  37 import java.lang.annotation.Annotation;
  38 import java.util.Map;
  39 import java.util.Objects;
  40 import sun.reflect.annotation.AnnotationParser;
  41 import sun.reflect.annotation.AnnotationSupport;
  42 import sun.reflect.annotation.TypeAnnotation;
  43 import sun.reflect.annotation.TypeAnnotationParser;
  44 
  45 /**
  46  * A {@code Field} provides information about, and dynamic access to, a
  47  * single field of a class or an interface.  The reflected field may
  48  * be a class (static) field or an instance field.
  49  *
  50  * &lt;p&gt;A {@code Field} permits widening conversions to occur during a get or
  51  * set access operation, but throws an {@code IllegalArgumentException} if a
  52  * narrowing conversion would occur.
  53  *
  54  * @see Member
  55  * @see java.lang.Class
  56  * @see java.lang.Class#getFields()
  57  * @see java.lang.Class#getField(String)
  58  * @see java.lang.Class#getDeclaredFields()
  59  * @see java.lang.Class#getDeclaredField(String)
  60  *
  61  * @author Kenneth Russell
  62  * @author Nakul Saraiya
  63  * @since 1.1
  64  */
  65 public final
  66 class Field extends AccessibleObject implements Member {
  67 
  68     private Class&lt;?&gt;            clazz;
  69     private int                 slot;
  70     // This is guaranteed to be interned by the VM in the 1.4
  71     // reflection implementation
  72     private String              name;
  73     private Class&lt;?&gt;            type;
  74     private int                 modifiers;
  75     private boolean             trustedFinal;
  76     // Generics and annotations support
  77     private transient String    signature;
  78     // generic info repository; lazily initialized
  79     private transient FieldRepository genericInfo;
  80     private byte[]              annotations;
  81     // Cached field accessor created without override
  82     private FieldAccessor fieldAccessor;
  83     // Cached field accessor created with override
  84     private FieldAccessor overrideFieldAccessor;
  85     // For sharing of FieldAccessors. This branching structure is
  86     // currently only two levels deep (i.e., one root Field and
  87     // potentially many Field objects pointing to it.)
  88     //
  89     // If this branching structure would ever contain cycles, deadlocks can
  90     // occur in annotation code.
  91     private Field               root;
  92 
  93     // Generics infrastructure
  94 
  95     private String getGenericSignature() {return signature;}
  96 
  97     // Accessor for factory
  98     private GenericsFactory getFactory() {
  99         Class&lt;?&gt; c = getDeclaringClass();
 100         // create scope and factory
 101         return CoreReflectionFactory.make(c, ClassScope.make(c));
 102     }
 103 
 104     // Accessor for generic info repository
 105     private FieldRepository getGenericInfo() {
 106         // lazily initialize repository if necessary
 107         if (genericInfo == null) {
 108             // create and cache generic info repository
 109             genericInfo = FieldRepository.make(getGenericSignature(),
 110                                                getFactory());
 111         }
 112         return genericInfo; //return cached repository
 113     }
 114 
 115 
 116     /**
 117      * Package-private constructor
 118      */
 119     Field(Class&lt;?&gt; declaringClass,
 120           String name,
 121           Class&lt;?&gt; type,
 122           int modifiers,
 123           boolean trustedFinal,
 124           int slot,
 125           String signature,
 126           byte[] annotations)
 127     {
 128         this.clazz = declaringClass;
 129         this.name = name;
 130         this.type = type;
 131         this.modifiers = modifiers;
 132         this.trustedFinal = trustedFinal;
 133         this.slot = slot;
 134         this.signature = signature;
 135         this.annotations = annotations;
 136     }
 137 
 138     /**
 139      * Package-private routine (exposed to java.lang.Class via
 140      * ReflectAccess) which returns a copy of this Field. The copy&#39;s
 141      * &quot;root&quot; field points to this Field.
 142      */
 143     Field copy() {
 144         // This routine enables sharing of FieldAccessor objects
 145         // among Field objects which refer to the same underlying
 146         // method in the VM. (All of this contortion is only necessary
 147         // because of the &quot;accessibility&quot; bit in AccessibleObject,
 148         // which implicitly requires that new java.lang.reflect
 149         // objects be fabricated for each reflective call on Class
 150         // objects.)
 151         if (this.root != null)
 152             throw new IllegalArgumentException(&quot;Can not copy a non-root Field&quot;);
 153 
 154         Field res = new Field(clazz, name, type, modifiers, trustedFinal, slot, signature, annotations);
 155         res.root = this;
 156         // Might as well eagerly propagate this if already present
 157         res.fieldAccessor = fieldAccessor;
 158         res.overrideFieldAccessor = overrideFieldAccessor;
 159 
 160         return res;
 161     }
 162 
 163     /**
 164      * @throws InaccessibleObjectException {@inheritDoc}
 165      * @throws SecurityException {@inheritDoc}
 166      */
 167     @Override
 168     @CallerSensitive
 169     public void setAccessible(boolean flag) {
 170         AccessibleObject.checkPermission();
 171         if (flag) checkCanSetAccessible(Reflection.getCallerClass());
 172         setAccessible0(flag);
 173     }
 174 
 175     @Override
 176     void checkCanSetAccessible(Class&lt;?&gt; caller) {
 177         checkCanSetAccessible(caller, clazz);
 178     }
 179 
 180     /**
 181      * Returns the {@code Class} object representing the class or interface
 182      * that declares the field represented by this {@code Field} object.
 183      */
 184     @Override
 185     public Class&lt;?&gt; getDeclaringClass() {
 186         return clazz;
 187     }
 188 
 189     /**
 190      * Returns the name of the field represented by this {@code Field} object.
 191      */
 192     public String getName() {
 193         return name;
 194     }
 195 
 196     /**
 197      * Returns the Java language modifiers for the field represented
 198      * by this {@code Field} object, as an integer. The {@code Modifier} class should
 199      * be used to decode the modifiers.
 200      *
 201      * @see Modifier
 202      */
 203     public int getModifiers() {
 204         return modifiers;
 205     }
 206 
 207     /**
 208      * Returns {@code true} if this field represents an element of
 209      * an enumerated type; returns {@code false} otherwise.
 210      *
 211      * @return {@code true} if and only if this field represents an element of
 212      * an enumerated type.
 213      * @since 1.5
 214      */
 215     public boolean isEnumConstant() {
 216         return (getModifiers() &amp; Modifier.ENUM) != 0;
 217     }
 218 
 219     /**
 220      * Returns {@code true} if this field is a synthetic
 221      * field; returns {@code false} otherwise.
 222      *
 223      * @return true if and only if this field is a synthetic
 224      * field as defined by the Java Language Specification.
 225      * @since 1.5
 226      */
 227     public boolean isSynthetic() {
 228         return Modifier.isSynthetic(getModifiers());
 229     }
 230 
 231     /**
 232      * Returns a {@code Class} object that identifies the
 233      * declared type for the field represented by this
 234      * {@code Field} object.
 235      *
 236      * @return a {@code Class} object identifying the declared
 237      * type of the field represented by this object
 238      */
 239     public Class&lt;?&gt; getType() {
 240         return type;
 241     }
 242 
 243     /**
 244      * Returns a {@code Type} object that represents the declared type for
 245      * the field represented by this {@code Field} object.
 246      *
 247      * &lt;p&gt;If the declared type of the field is a parameterized type,
 248      * the {@code Type} object returned must accurately reflect the
 249      * actual type arguments used in the source code.
 250      *
 251      * &lt;p&gt;If the type of the underlying field is a type variable or a
 252      * parameterized type, it is created. Otherwise, it is resolved.
 253      *
 254      * @return a {@code Type} object that represents the declared type for
 255      *     the field represented by this {@code Field} object
 256      * @throws GenericSignatureFormatError if the generic field
 257      *     signature does not conform to the format specified in
 258      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 259      * @throws TypeNotPresentException if the generic type
 260      *     signature of the underlying field refers to a non-existent
 261      *     type declaration
 262      * @throws MalformedParameterizedTypeException if the generic
 263      *     signature of the underlying field refers to a parameterized type
 264      *     that cannot be instantiated for any reason
 265      * @since 1.5
 266      */
 267     public Type getGenericType() {
 268         if (getGenericSignature() != null)
 269             return getGenericInfo().getGenericType();
 270         else
 271             return getType();
 272     }
 273 
 274 
 275     /**
 276      * Compares this {@code Field} against the specified object.  Returns
 277      * true if the objects are the same.  Two {@code Field} objects are the same if
 278      * they were declared by the same class and have the same name
 279      * and type.
 280      */
 281     public boolean equals(Object obj) {
 282         if (obj != null &amp;&amp; obj instanceof Field) {
 283             Field other = (Field)obj;
 284             return (getDeclaringClass() == other.getDeclaringClass())
 285                 &amp;&amp; (getName() == other.getName())
 286                 &amp;&amp; (getType() == other.getType());
 287         }
 288         return false;
 289     }
 290 
 291     /**
 292      * Returns a hashcode for this {@code Field}.  This is computed as the
 293      * exclusive-or of the hashcodes for the underlying field&#39;s
 294      * declaring class name and its name.
 295      */
 296     public int hashCode() {
 297         return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
 298     }
 299 
 300     /**
 301      * Returns a string describing this {@code Field}.  The format is
 302      * the access modifiers for the field, if any, followed
 303      * by the field type, followed by a space, followed by
 304      * the fully-qualified name of the class declaring the field,
 305      * followed by a period, followed by the name of the field.
 306      * For example:
 307      * &lt;pre&gt;
 308      *    public static final int java.lang.Thread.MIN_PRIORITY
 309      *    private int java.io.FileDescriptor.fd
 310      * &lt;/pre&gt;
 311      *
 312      * &lt;p&gt;The modifiers are placed in canonical order as specified by
 313      * &quot;The Java Language Specification&quot;.  This is {@code public},
 314      * {@code protected} or {@code private} first, and then other
 315      * modifiers in the following order: {@code static}, {@code final},
 316      * {@code transient}, {@code volatile}.
 317      *
 318      * @return a string describing this {@code Field}
 319      * @jls 8.3.1 Field Modifiers
 320      */
 321     public String toString() {
 322         int mod = getModifiers();
 323         return (((mod == 0) ? &quot;&quot; : (Modifier.toString(mod) + &quot; &quot;))
 324             + getType().getTypeName() + &quot; &quot;
 325             + getDeclaringClass().getTypeName() + &quot;.&quot;
 326             + getName());
 327     }
 328 
 329     @Override
 330     String toShortString() {
 331         return &quot;field &quot; + getDeclaringClass().getTypeName() + &quot;.&quot; + getName();
 332     }
 333 
 334     /**
 335      * Returns a string describing this {@code Field}, including
 336      * its generic type.  The format is the access modifiers for the
 337      * field, if any, followed by the generic field type, followed by
 338      * a space, followed by the fully-qualified name of the class
 339      * declaring the field, followed by a period, followed by the name
 340      * of the field.
 341      *
 342      * &lt;p&gt;The modifiers are placed in canonical order as specified by
 343      * &quot;The Java Language Specification&quot;.  This is {@code public},
 344      * {@code protected} or {@code private} first, and then other
 345      * modifiers in the following order: {@code static}, {@code final},
 346      * {@code transient}, {@code volatile}.
 347      *
 348      * @return a string describing this {@code Field}, including
 349      * its generic type
 350      *
 351      * @since 1.5
 352      * @jls 8.3.1 Field Modifiers
 353      */
 354     public String toGenericString() {
 355         int mod = getModifiers();
 356         Type fieldType = getGenericType();
 357         return (((mod == 0) ? &quot;&quot; : (Modifier.toString(mod) + &quot; &quot;))
 358             + fieldType.getTypeName() + &quot; &quot;
 359             + getDeclaringClass().getTypeName() + &quot;.&quot;
 360             + getName());
 361     }
 362 
 363     /**
 364      * Returns the value of the field represented by this {@code Field}, on
 365      * the specified object. The value is automatically wrapped in an
 366      * object if it has a primitive type.
 367      *
 368      * &lt;p&gt;The underlying field&#39;s value is obtained as follows:
 369      *
 370      * &lt;p&gt;If the underlying field is a static field, the {@code obj} argument
 371      * is ignored; it may be null.
 372      *
 373      * &lt;p&gt;Otherwise, the underlying field is an instance field.  If the
 374      * specified {@code obj} argument is null, the method throws a
 375      * {@code NullPointerException}. If the specified object is not an
 376      * instance of the class or interface declaring the underlying
 377      * field, the method throws an {@code IllegalArgumentException}.
 378      *
 379      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 380      * the underlying field is inaccessible, the method throws an
 381      * {@code IllegalAccessException}.
 382      * If the underlying field is static, the class that declared the
 383      * field is initialized if it has not already been initialized.
 384      *
 385      * &lt;p&gt;Otherwise, the value is retrieved from the underlying instance
 386      * or static field.  If the field has a primitive type, the value
 387      * is wrapped in an object before being returned, otherwise it is
 388      * returned as is.
 389      *
 390      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 391      * the field&#39;s value is obtained according to the preceding rules.
 392      *
 393      * @param obj object from which the represented field&#39;s value is
 394      * to be extracted
 395      * @return the value of the represented field in object
 396      * {@code obj}; primitive values are wrapped in an appropriate
 397      * object before being returned
 398      *
 399      * @throws    IllegalAccessException    if this {@code Field} object
 400      *              is enforcing Java language access control and the underlying
 401      *              field is inaccessible.
 402      * @throws    IllegalArgumentException  if the specified object is not an
 403      *              instance of the class or interface declaring the underlying
 404      *              field (or a subclass or implementor thereof).
 405      * @throws    NullPointerException      if the specified object is null
 406      *              and the field is an instance field.
 407      * @throws    ExceptionInInitializerError if the initialization provoked
 408      *              by this method fails.
 409      */
 410     @CallerSensitive
 411     @ForceInline // to ensure Reflection.getCallerClass optimization
 412     public Object get(Object obj)
 413         throws IllegalArgumentException, IllegalAccessException
 414     {
 415         if (!override) {
 416             Class&lt;?&gt; caller = Reflection.getCallerClass();
 417             checkAccess(caller, obj);
 418         }
 419         return getFieldAccessor(obj).get(obj);
 420     }
 421 
 422     /**
 423      * Gets the value of a static or instance {@code boolean} field.
 424      *
 425      * @param obj the object to extract the {@code boolean} value
 426      * from
 427      * @return the value of the {@code boolean} field
 428      *
 429      * @throws    IllegalAccessException    if this {@code Field} object
 430      *              is enforcing Java language access control and the underlying
 431      *              field is inaccessible.
 432      * @throws    IllegalArgumentException  if the specified object is not
 433      *              an instance of the class or interface declaring the
 434      *              underlying field (or a subclass or implementor
 435      *              thereof), or if the field value cannot be
 436      *              converted to the type {@code boolean} by a
 437      *              widening conversion.
 438      * @throws    NullPointerException      if the specified object is null
 439      *              and the field is an instance field.
 440      * @throws    ExceptionInInitializerError if the initialization provoked
 441      *              by this method fails.
 442      * @see       Field#get
 443      */
 444     @CallerSensitive
 445     @ForceInline // to ensure Reflection.getCallerClass optimization
 446     public boolean getBoolean(Object obj)
 447         throws IllegalArgumentException, IllegalAccessException
 448     {
 449         if (!override) {
 450             Class&lt;?&gt; caller = Reflection.getCallerClass();
 451             checkAccess(caller, obj);
 452         }
 453         return getFieldAccessor(obj).getBoolean(obj);
 454     }
 455 
 456     /**
 457      * Gets the value of a static or instance {@code byte} field.
 458      *
 459      * @param obj the object to extract the {@code byte} value
 460      * from
 461      * @return the value of the {@code byte} field
 462      *
 463      * @throws    IllegalAccessException    if this {@code Field} object
 464      *              is enforcing Java language access control and the underlying
 465      *              field is inaccessible.
 466      * @throws    IllegalArgumentException  if the specified object is not
 467      *              an instance of the class or interface declaring the
 468      *              underlying field (or a subclass or implementor
 469      *              thereof), or if the field value cannot be
 470      *              converted to the type {@code byte} by a
 471      *              widening conversion.
 472      * @throws    NullPointerException      if the specified object is null
 473      *              and the field is an instance field.
 474      * @throws    ExceptionInInitializerError if the initialization provoked
 475      *              by this method fails.
 476      * @see       Field#get
 477      */
 478     @CallerSensitive
 479     @ForceInline // to ensure Reflection.getCallerClass optimization
 480     public byte getByte(Object obj)
 481         throws IllegalArgumentException, IllegalAccessException
 482     {
 483         if (!override) {
 484             Class&lt;?&gt; caller = Reflection.getCallerClass();
 485             checkAccess(caller, obj);
 486         }
 487         return getFieldAccessor(obj).getByte(obj);
 488     }
 489 
 490     /**
 491      * Gets the value of a static or instance field of type
 492      * {@code char} or of another primitive type convertible to
 493      * type {@code char} via a widening conversion.
 494      *
 495      * @param obj the object to extract the {@code char} value
 496      * from
 497      * @return the value of the field converted to type {@code char}
 498      *
 499      * @throws    IllegalAccessException    if this {@code Field} object
 500      *              is enforcing Java language access control and the underlying
 501      *              field is inaccessible.
 502      * @throws    IllegalArgumentException  if the specified object is not
 503      *              an instance of the class or interface declaring the
 504      *              underlying field (or a subclass or implementor
 505      *              thereof), or if the field value cannot be
 506      *              converted to the type {@code char} by a
 507      *              widening conversion.
 508      * @throws    NullPointerException      if the specified object is null
 509      *              and the field is an instance field.
 510      * @throws    ExceptionInInitializerError if the initialization provoked
 511      *              by this method fails.
 512      * @see Field#get
 513      */
 514     @CallerSensitive
 515     @ForceInline // to ensure Reflection.getCallerClass optimization
 516     public char getChar(Object obj)
 517         throws IllegalArgumentException, IllegalAccessException
 518     {
 519         if (!override) {
 520             Class&lt;?&gt; caller = Reflection.getCallerClass();
 521             checkAccess(caller, obj);
 522         }
 523         return getFieldAccessor(obj).getChar(obj);
 524     }
 525 
 526     /**
 527      * Gets the value of a static or instance field of type
 528      * {@code short} or of another primitive type convertible to
 529      * type {@code short} via a widening conversion.
 530      *
 531      * @param obj the object to extract the {@code short} value
 532      * from
 533      * @return the value of the field converted to type {@code short}
 534      *
 535      * @throws    IllegalAccessException    if this {@code Field} object
 536      *              is enforcing Java language access control and the underlying
 537      *              field is inaccessible.
 538      * @throws    IllegalArgumentException  if the specified object is not
 539      *              an instance of the class or interface declaring the
 540      *              underlying field (or a subclass or implementor
 541      *              thereof), or if the field value cannot be
 542      *              converted to the type {@code short} by a
 543      *              widening conversion.
 544      * @throws    NullPointerException      if the specified object is null
 545      *              and the field is an instance field.
 546      * @throws    ExceptionInInitializerError if the initialization provoked
 547      *              by this method fails.
 548      * @see       Field#get
 549      */
 550     @CallerSensitive
 551     @ForceInline // to ensure Reflection.getCallerClass optimization
 552     public short getShort(Object obj)
 553         throws IllegalArgumentException, IllegalAccessException
 554     {
 555         if (!override) {
 556             Class&lt;?&gt; caller = Reflection.getCallerClass();
 557             checkAccess(caller, obj);
 558         }
 559         return getFieldAccessor(obj).getShort(obj);
 560     }
 561 
 562     /**
 563      * Gets the value of a static or instance field of type
 564      * {@code int} or of another primitive type convertible to
 565      * type {@code int} via a widening conversion.
 566      *
 567      * @param obj the object to extract the {@code int} value
 568      * from
 569      * @return the value of the field converted to type {@code int}
 570      *
 571      * @throws    IllegalAccessException    if this {@code Field} object
 572      *              is enforcing Java language access control and the underlying
 573      *              field is inaccessible.
 574      * @throws    IllegalArgumentException  if the specified object is not
 575      *              an instance of the class or interface declaring the
 576      *              underlying field (or a subclass or implementor
 577      *              thereof), or if the field value cannot be
 578      *              converted to the type {@code int} by a
 579      *              widening conversion.
 580      * @throws    NullPointerException      if the specified object is null
 581      *              and the field is an instance field.
 582      * @throws    ExceptionInInitializerError if the initialization provoked
 583      *              by this method fails.
 584      * @see       Field#get
 585      */
 586     @CallerSensitive
 587     @ForceInline // to ensure Reflection.getCallerClass optimization
 588     public int getInt(Object obj)
 589         throws IllegalArgumentException, IllegalAccessException
 590     {
 591         if (!override) {
 592             Class&lt;?&gt; caller = Reflection.getCallerClass();
 593             checkAccess(caller, obj);
 594         }
 595         return getFieldAccessor(obj).getInt(obj);
 596     }
 597 
 598     /**
 599      * Gets the value of a static or instance field of type
 600      * {@code long} or of another primitive type convertible to
 601      * type {@code long} via a widening conversion.
 602      *
 603      * @param obj the object to extract the {@code long} value
 604      * from
 605      * @return the value of the field converted to type {@code long}
 606      *
 607      * @throws    IllegalAccessException    if this {@code Field} object
 608      *              is enforcing Java language access control and the underlying
 609      *              field is inaccessible.
 610      * @throws    IllegalArgumentException  if the specified object is not
 611      *              an instance of the class or interface declaring the
 612      *              underlying field (or a subclass or implementor
 613      *              thereof), or if the field value cannot be
 614      *              converted to the type {@code long} by a
 615      *              widening conversion.
 616      * @throws    NullPointerException      if the specified object is null
 617      *              and the field is an instance field.
 618      * @throws    ExceptionInInitializerError if the initialization provoked
 619      *              by this method fails.
 620      * @see       Field#get
 621      */
 622     @CallerSensitive
 623     @ForceInline // to ensure Reflection.getCallerClass optimization
 624     public long getLong(Object obj)
 625         throws IllegalArgumentException, IllegalAccessException
 626     {
 627         if (!override) {
 628             Class&lt;?&gt; caller = Reflection.getCallerClass();
 629             checkAccess(caller, obj);
 630         }
 631         return getFieldAccessor(obj).getLong(obj);
 632     }
 633 
 634     /**
 635      * Gets the value of a static or instance field of type
 636      * {@code float} or of another primitive type convertible to
 637      * type {@code float} via a widening conversion.
 638      *
 639      * @param obj the object to extract the {@code float} value
 640      * from
 641      * @return the value of the field converted to type {@code float}
 642      *
 643      * @throws    IllegalAccessException    if this {@code Field} object
 644      *              is enforcing Java language access control and the underlying
 645      *              field is inaccessible.
 646      * @throws    IllegalArgumentException  if the specified object is not
 647      *              an instance of the class or interface declaring the
 648      *              underlying field (or a subclass or implementor
 649      *              thereof), or if the field value cannot be
 650      *              converted to the type {@code float} by a
 651      *              widening conversion.
 652      * @throws    NullPointerException      if the specified object is null
 653      *              and the field is an instance field.
 654      * @throws    ExceptionInInitializerError if the initialization provoked
 655      *              by this method fails.
 656      * @see Field#get
 657      */
 658     @CallerSensitive
 659     @ForceInline // to ensure Reflection.getCallerClass optimization
 660     public float getFloat(Object obj)
 661         throws IllegalArgumentException, IllegalAccessException
 662     {
 663         if (!override) {
 664             Class&lt;?&gt; caller = Reflection.getCallerClass();
 665             checkAccess(caller, obj);
 666         }
 667         return getFieldAccessor(obj).getFloat(obj);
 668     }
 669 
 670     /**
 671      * Gets the value of a static or instance field of type
 672      * {@code double} or of another primitive type convertible to
 673      * type {@code double} via a widening conversion.
 674      *
 675      * @param obj the object to extract the {@code double} value
 676      * from
 677      * @return the value of the field converted to type {@code double}
 678      *
 679      * @throws    IllegalAccessException    if this {@code Field} object
 680      *              is enforcing Java language access control and the underlying
 681      *              field is inaccessible.
 682      * @throws    IllegalArgumentException  if the specified object is not
 683      *              an instance of the class or interface declaring the
 684      *              underlying field (or a subclass or implementor
 685      *              thereof), or if the field value cannot be
 686      *              converted to the type {@code double} by a
 687      *              widening conversion.
 688      * @throws    NullPointerException      if the specified object is null
 689      *              and the field is an instance field.
 690      * @throws    ExceptionInInitializerError if the initialization provoked
 691      *              by this method fails.
 692      * @see       Field#get
 693      */
 694     @CallerSensitive
 695     @ForceInline // to ensure Reflection.getCallerClass optimization
 696     public double getDouble(Object obj)
 697         throws IllegalArgumentException, IllegalAccessException
 698     {
 699         if (!override) {
 700             Class&lt;?&gt; caller = Reflection.getCallerClass();
 701             checkAccess(caller, obj);
 702         }
 703         return getFieldAccessor(obj).getDouble(obj);
 704     }
 705 
 706     /**
 707      * Sets the field represented by this {@code Field} object on the
 708      * specified object argument to the specified new value. The new
 709      * value is automatically unwrapped if the underlying field has a
 710      * primitive type.
 711      *
 712      * &lt;p&gt;The operation proceeds as follows:
 713      *
 714      * &lt;p&gt;If the underlying field is static, the {@code obj} argument is
 715      * ignored; it may be null.
 716      *
 717      * &lt;p&gt;Otherwise the underlying field is an instance field.  If the
 718      * specified object argument is null, the method throws a
 719      * {@code NullPointerException}.  If the specified object argument is not
 720      * an instance of the class or interface declaring the underlying
 721      * field, the method throws an {@code IllegalArgumentException}.
 722      *
 723      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 724      * the underlying field is inaccessible, the method throws an
 725      * {@code IllegalAccessException}.
 726      *
 727      * &lt;p&gt;If the underlying field is final, this {@code Field} object has
 728      * &lt;em&gt;write&lt;/em&gt; access if and only if the following conditions are met:
 729      * &lt;ul&gt;
 730      * &lt;li&gt;{@link #setAccessible(boolean) setAccessible(true)} has succeeded for
 731      *     this {@code Field} object;&lt;/li&gt;
 732      * &lt;li&gt;the field is non-static; and&lt;/li&gt;
 733      * &lt;li&gt;the field&#39;s declaring class is not a {@linkplain Class#isHidden()
 734      *     hidden class}; and&lt;/li&gt;
 735      * &lt;li&gt;the field&#39;s declaring class is not a {@linkplain Class#isRecord()
 736      *     record class}.&lt;/li&gt;
 737      * &lt;/ul&gt;
 738      * If any of the above checks is not met, this method throws an
 739      * {@code IllegalAccessException}.
 740      *
 741      * &lt;p&gt; Setting a final field in this way
 742      * is meaningful only during deserialization or reconstruction of
 743      * instances of classes with blank final fields, before they are
 744      * made available for access by other parts of a program. Use in
 745      * any other context may have unpredictable effects, including cases
 746      * in which other parts of a program continue to use the original
 747      * value of this field.
 748      *
 749      * &lt;p&gt;If the underlying field is of a primitive type, an unwrapping
 750      * conversion is attempted to convert the new value to a value of
 751      * a primitive type.  If this attempt fails, the method throws an
 752      * {@code IllegalArgumentException}.
 753      *
 754      * &lt;p&gt;If, after possible unwrapping, the new value cannot be
 755      * converted to the type of the underlying field by an identity or
 756      * widening conversion, the method throws an
 757      * {@code IllegalArgumentException}.
 758      *
 759      * &lt;p&gt;If the underlying field is static, the class that declared the
 760      * field is initialized if it has not already been initialized.
 761      *
 762      * &lt;p&gt;The field is set to the possibly unwrapped and widened new value.
 763      *
 764      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 765      * the field&#39;s value is set according to the preceding rules.
 766      *
 767      * @param obj the object whose field should be modified
 768      * @param value the new value for the field of {@code obj}
 769      * being modified
 770      *
 771      * @throws    IllegalAccessException    if this {@code Field} object
 772      *              is enforcing Java language access control and the underlying
 773      *              field is inaccessible or final;
 774      *              or if this {@code Field} object has no write access.
 775      * @throws    IllegalArgumentException  if the specified object is not an
 776      *              instance of the class or interface declaring the underlying
 777      *              field (or a subclass or implementor thereof),
 778      *              or if an unwrapping conversion fails.
 779      * @throws    NullPointerException      if the specified object is null
 780      *              and the field is an instance field.
 781      * @throws    ExceptionInInitializerError if the initialization provoked
 782      *              by this method fails.
 783      */
 784     @CallerSensitive
 785     @ForceInline // to ensure Reflection.getCallerClass optimization
 786     public void set(Object obj, Object value)
 787         throws IllegalArgumentException, IllegalAccessException
 788     {
 789         if (!override) {
 790             Class&lt;?&gt; caller = Reflection.getCallerClass();
 791             checkAccess(caller, obj);
 792         }
 793         getFieldAccessor(obj).set(obj, value);
 794     }
 795 
 796     /**
 797      * Sets the value of a field as a {@code boolean} on the specified object.
 798      * This method is equivalent to
 799      * {@code set(obj, zObj)},
 800      * where {@code zObj} is a {@code Boolean} object and
 801      * {@code zObj.booleanValue() == z}.
 802      *
 803      * @param obj the object whose field should be modified
 804      * @param z   the new value for the field of {@code obj}
 805      * being modified
 806      *
 807      * @throws    IllegalAccessException    if this {@code Field} object
 808      *              is enforcing Java language access control and the underlying
 809      *              field is either inaccessible or final;
 810      *              or if this {@code Field} object has no write access.
 811      * @throws    IllegalArgumentException  if the specified object is not an
 812      *              instance of the class or interface declaring the underlying
 813      *              field (or a subclass or implementor thereof),
 814      *              or if an unwrapping conversion fails.
 815      * @throws    NullPointerException      if the specified object is null
 816      *              and the field is an instance field.
 817      * @throws    ExceptionInInitializerError if the initialization provoked
 818      *              by this method fails.
 819      * @see       Field#set
 820      */
 821     @CallerSensitive
 822     @ForceInline // to ensure Reflection.getCallerClass optimization
 823     public void setBoolean(Object obj, boolean z)
 824         throws IllegalArgumentException, IllegalAccessException
 825     {
 826         if (!override) {
 827             Class&lt;?&gt; caller = Reflection.getCallerClass();
 828             checkAccess(caller, obj);
 829         }
 830         getFieldAccessor(obj).setBoolean(obj, z);
 831     }
 832 
 833     /**
 834      * Sets the value of a field as a {@code byte} on the specified object.
 835      * This method is equivalent to
 836      * {@code set(obj, bObj)},
 837      * where {@code bObj} is a {@code Byte} object and
 838      * {@code bObj.byteValue() == b}.
 839      *
 840      * @param obj the object whose field should be modified
 841      * @param b   the new value for the field of {@code obj}
 842      * being modified
 843      *
 844      * @throws    IllegalAccessException    if this {@code Field} object
 845      *              is enforcing Java language access control and the underlying
 846      *              field is either inaccessible or final;
 847      *              or if this {@code Field} object has no write access.
 848      * @throws    IllegalArgumentException  if the specified object is not an
 849      *              instance of the class or interface declaring the underlying
 850      *              field (or a subclass or implementor thereof),
 851      *              or if an unwrapping conversion fails.
 852      * @throws    NullPointerException      if the specified object is null
 853      *              and the field is an instance field.
 854      * @throws    ExceptionInInitializerError if the initialization provoked
 855      *              by this method fails.
 856      * @see       Field#set
 857      */
 858     @CallerSensitive
 859     @ForceInline // to ensure Reflection.getCallerClass optimization
 860     public void setByte(Object obj, byte b)
 861         throws IllegalArgumentException, IllegalAccessException
 862     {
 863         if (!override) {
 864             Class&lt;?&gt; caller = Reflection.getCallerClass();
 865             checkAccess(caller, obj);
 866         }
 867         getFieldAccessor(obj).setByte(obj, b);
 868     }
 869 
 870     /**
 871      * Sets the value of a field as a {@code char} on the specified object.
 872      * This method is equivalent to
 873      * {@code set(obj, cObj)},
 874      * where {@code cObj} is a {@code Character} object and
 875      * {@code cObj.charValue() == c}.
 876      *
 877      * @param obj the object whose field should be modified
 878      * @param c   the new value for the field of {@code obj}
 879      * being modified
 880      *
 881      * @throws    IllegalAccessException    if this {@code Field} object
 882      *              is enforcing Java language access control and the underlying
 883      *              field is either inaccessible or final;
 884      *              or if this {@code Field} object has no write access.
 885      * @throws    IllegalArgumentException  if the specified object is not an
 886      *              instance of the class or interface declaring the underlying
 887      *              field (or a subclass or implementor thereof),
 888      *              or if an unwrapping conversion fails.
 889      * @throws    NullPointerException      if the specified object is null
 890      *              and the field is an instance field.
 891      * @throws    ExceptionInInitializerError if the initialization provoked
 892      *              by this method fails.
 893      * @see       Field#set
 894      */
 895     @CallerSensitive
 896     @ForceInline // to ensure Reflection.getCallerClass optimization
 897     public void setChar(Object obj, char c)
 898         throws IllegalArgumentException, IllegalAccessException
 899     {
 900         if (!override) {
 901             Class&lt;?&gt; caller = Reflection.getCallerClass();
 902             checkAccess(caller, obj);
 903         }
 904         getFieldAccessor(obj).setChar(obj, c);
 905     }
 906 
 907     /**
 908      * Sets the value of a field as a {@code short} on the specified object.
 909      * This method is equivalent to
 910      * {@code set(obj, sObj)},
 911      * where {@code sObj} is a {@code Short} object and
 912      * {@code sObj.shortValue() == s}.
 913      *
 914      * @param obj the object whose field should be modified
 915      * @param s   the new value for the field of {@code obj}
 916      * being modified
 917      *
 918      * @throws    IllegalAccessException    if this {@code Field} object
 919      *              is enforcing Java language access control and the underlying
 920      *              field is either inaccessible or final;
 921      *              or if this {@code Field} object has no write access.
 922      * @throws    IllegalArgumentException  if the specified object is not an
 923      *              instance of the class or interface declaring the underlying
 924      *              field (or a subclass or implementor thereof),
 925      *              or if an unwrapping conversion fails.
 926      * @throws    NullPointerException      if the specified object is null
 927      *              and the field is an instance field.
 928      * @throws    ExceptionInInitializerError if the initialization provoked
 929      *              by this method fails.
 930      * @see       Field#set
 931      */
 932     @CallerSensitive
 933     @ForceInline // to ensure Reflection.getCallerClass optimization
 934     public void setShort(Object obj, short s)
 935         throws IllegalArgumentException, IllegalAccessException
 936     {
 937         if (!override) {
 938             Class&lt;?&gt; caller = Reflection.getCallerClass();
 939             checkAccess(caller, obj);
 940         }
 941         getFieldAccessor(obj).setShort(obj, s);
 942     }
 943 
 944     /**
 945      * Sets the value of a field as an {@code int} on the specified object.
 946      * This method is equivalent to
 947      * {@code set(obj, iObj)},
 948      * where {@code iObj} is an {@code Integer} object and
 949      * {@code iObj.intValue() == i}.
 950      *
 951      * @param obj the object whose field should be modified
 952      * @param i   the new value for the field of {@code obj}
 953      * being modified
 954      *
 955      * @throws    IllegalAccessException    if this {@code Field} object
 956      *              is enforcing Java language access control and the underlying
 957      *              field is either inaccessible or final;
 958      *              or if this {@code Field} object has no write access.
 959      * @throws    IllegalArgumentException  if the specified object is not an
 960      *              instance of the class or interface declaring the underlying
 961      *              field (or a subclass or implementor thereof),
 962      *              or if an unwrapping conversion fails.
 963      * @throws    NullPointerException      if the specified object is null
 964      *              and the field is an instance field.
 965      * @throws    ExceptionInInitializerError if the initialization provoked
 966      *              by this method fails.
 967      * @see       Field#set
 968      */
 969     @CallerSensitive
 970     @ForceInline // to ensure Reflection.getCallerClass optimization
 971     public void setInt(Object obj, int i)
 972         throws IllegalArgumentException, IllegalAccessException
 973     {
 974         if (!override) {
 975             Class&lt;?&gt; caller = Reflection.getCallerClass();
 976             checkAccess(caller, obj);
 977         }
 978         getFieldAccessor(obj).setInt(obj, i);
 979     }
 980 
 981     /**
 982      * Sets the value of a field as a {@code long} on the specified object.
 983      * This method is equivalent to
 984      * {@code set(obj, lObj)},
 985      * where {@code lObj} is a {@code Long} object and
 986      * {@code lObj.longValue() == l}.
 987      *
 988      * @param obj the object whose field should be modified
 989      * @param l   the new value for the field of {@code obj}
 990      * being modified
 991      *
 992      * @throws    IllegalAccessException    if this {@code Field} object
 993      *              is enforcing Java language access control and the underlying
 994      *              field is either inaccessible or final;
 995      *              or if this {@code Field} object has no write access.
 996      * @throws    IllegalArgumentException  if the specified object is not an
 997      *              instance of the class or interface declaring the underlying
 998      *              field (or a subclass or implementor thereof),
 999      *              or if an unwrapping conversion fails.
1000      * @throws    NullPointerException      if the specified object is null
1001      *              and the field is an instance field.
1002      * @throws    ExceptionInInitializerError if the initialization provoked
1003      *              by this method fails.
1004      * @see       Field#set
1005      */
1006     @CallerSensitive
1007     @ForceInline // to ensure Reflection.getCallerClass optimization
1008     public void setLong(Object obj, long l)
1009         throws IllegalArgumentException, IllegalAccessException
1010     {
1011         if (!override) {
1012             Class&lt;?&gt; caller = Reflection.getCallerClass();
1013             checkAccess(caller, obj);
1014         }
1015         getFieldAccessor(obj).setLong(obj, l);
1016     }
1017 
1018     /**
1019      * Sets the value of a field as a {@code float} on the specified object.
1020      * This method is equivalent to
1021      * {@code set(obj, fObj)},
1022      * where {@code fObj} is a {@code Float} object and
1023      * {@code fObj.floatValue() == f}.
1024      *
1025      * @param obj the object whose field should be modified
1026      * @param f   the new value for the field of {@code obj}
1027      * being modified
1028      *
1029      * @throws    IllegalAccessException    if this {@code Field} object
1030      *              is enforcing Java language access control and the underlying
1031      *              field is either inaccessible or final;
1032      *              or if this {@code Field} object has no write access.
1033      * @throws    IllegalArgumentException  if the specified object is not an
1034      *              instance of the class or interface declaring the underlying
1035      *              field (or a subclass or implementor thereof),
1036      *              or if an unwrapping conversion fails.
1037      * @throws    NullPointerException      if the specified object is null
1038      *              and the field is an instance field.
1039      * @throws    ExceptionInInitializerError if the initialization provoked
1040      *              by this method fails.
1041      * @see       Field#set
1042      */
1043     @CallerSensitive
1044     @ForceInline // to ensure Reflection.getCallerClass optimization
1045     public void setFloat(Object obj, float f)
1046         throws IllegalArgumentException, IllegalAccessException
1047     {
1048         if (!override) {
1049             Class&lt;?&gt; caller = Reflection.getCallerClass();
1050             checkAccess(caller, obj);
1051         }
1052         getFieldAccessor(obj).setFloat(obj, f);
1053     }
1054 
1055     /**
1056      * Sets the value of a field as a {@code double} on the specified object.
1057      * This method is equivalent to
1058      * {@code set(obj, dObj)},
1059      * where {@code dObj} is a {@code Double} object and
1060      * {@code dObj.doubleValue() == d}.
1061      *
1062      * @param obj the object whose field should be modified
1063      * @param d   the new value for the field of {@code obj}
1064      * being modified
1065      *
1066      * @throws    IllegalAccessException    if this {@code Field} object
1067      *              is enforcing Java language access control and the underlying
1068      *              field is either inaccessible or final;
1069      *              or if this {@code Field} object has no write access.
1070      * @throws    IllegalArgumentException  if the specified object is not an
1071      *              instance of the class or interface declaring the underlying
1072      *              field (or a subclass or implementor thereof),
1073      *              or if an unwrapping conversion fails.
1074      * @throws    NullPointerException      if the specified object is null
1075      *              and the field is an instance field.
1076      * @throws    ExceptionInInitializerError if the initialization provoked
1077      *              by this method fails.
1078      * @see       Field#set
1079      */
1080     @CallerSensitive
1081     @ForceInline // to ensure Reflection.getCallerClass optimization
1082     public void setDouble(Object obj, double d)
1083         throws IllegalArgumentException, IllegalAccessException
1084     {
1085         if (!override) {
1086             Class&lt;?&gt; caller = Reflection.getCallerClass();
1087             checkAccess(caller, obj);
1088         }
1089         getFieldAccessor(obj).setDouble(obj, d);
1090     }
1091 
1092     // check access to field
1093     private void checkAccess(Class&lt;?&gt; caller, Object obj)
1094         throws IllegalAccessException
1095     {
1096         checkAccess(caller, clazz,
1097                     Modifier.isStatic(modifiers) ? null : obj.getClass(),
1098                     modifiers);
1099     }
1100 
1101     // security check is done before calling this method
1102     private FieldAccessor getFieldAccessor(Object obj)
1103         throws IllegalAccessException
1104     {
1105         boolean ov = override;
1106         FieldAccessor a = (ov) ? overrideFieldAccessor : fieldAccessor;
1107         return (a != null) ? a : acquireFieldAccessor(ov);
1108     }
1109 
1110     // NOTE that there is no synchronization used here. It is correct
1111     // (though not efficient) to generate more than one FieldAccessor
1112     // for a given Field. However, avoiding synchronization will
1113     // probably make the implementation more scalable.
1114     private FieldAccessor acquireFieldAccessor(boolean overrideFinalCheck) {
1115         // First check to see if one has been created yet, and take it
1116         // if so
1117         FieldAccessor tmp = null;
1118         if (root != null) tmp = root.getFieldAccessor(overrideFinalCheck);
1119         if (tmp != null) {
1120             if (overrideFinalCheck)
1121                 overrideFieldAccessor = tmp;
1122             else
1123                 fieldAccessor = tmp;
1124         } else {
1125             // Otherwise fabricate one and propagate it up to the root
1126             tmp = reflectionFactory.newFieldAccessor(this, overrideFinalCheck);
1127             setFieldAccessor(tmp, overrideFinalCheck);
1128         }
1129 
1130         return tmp;
1131     }
1132 
1133     // Returns FieldAccessor for this Field object, not looking up
1134     // the chain to the root
1135     private FieldAccessor getFieldAccessor(boolean overrideFinalCheck) {
1136         return (overrideFinalCheck)? overrideFieldAccessor : fieldAccessor;
1137     }
1138 
1139     // Sets the FieldAccessor for this Field object and
1140     // (recursively) its root
1141     private void setFieldAccessor(FieldAccessor accessor, boolean overrideFinalCheck) {
1142         if (overrideFinalCheck)
1143             overrideFieldAccessor = accessor;
1144         else
1145             fieldAccessor = accessor;
1146         // Propagate up
1147         if (root != null) {
1148             root.setFieldAccessor(accessor, overrideFinalCheck);
1149         }
1150     }
1151 
1152     @Override
1153     /* package-private */ Field getRoot() {
1154         return root;
1155     }
1156 
1157     /* package-private */ boolean isTrustedFinal() {
1158         return trustedFinal;
1159     }
1160 
1161     /**
1162      * {@inheritDoc}
1163      *
1164      * @throws NullPointerException {@inheritDoc}
1165      * @since 1.5
1166      */
1167     @Override
1168     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
1169         Objects.requireNonNull(annotationClass);
1170         return annotationClass.cast(declaredAnnotations().get(annotationClass));
1171     }
1172 
1173     /**
1174      * {@inheritDoc}
1175      *
1176      * @throws NullPointerException {@inheritDoc}
1177      * @since 1.8
1178      */
1179     @Override
1180     public &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) {
1181         Objects.requireNonNull(annotationClass);
1182 
1183         return AnnotationSupport.getDirectlyAndIndirectlyPresent(declaredAnnotations(), annotationClass);
1184     }
1185 
1186     /**
1187      * {@inheritDoc}
1188      */
1189     @Override
1190     public Annotation[] getDeclaredAnnotations()  {
1191         return AnnotationParser.toArray(declaredAnnotations());
1192     }
1193 
1194     private transient volatile Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
1195 
1196     private Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations() {
1197         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declAnnos;
1198         if ((declAnnos = declaredAnnotations) == null) {
1199             synchronized (this) {
1200                 if ((declAnnos = declaredAnnotations) == null) {
1201                     Field root = this.root;
1202                     if (root != null) {
1203                         declAnnos = root.declaredAnnotations();
1204                     } else {
1205                         declAnnos = AnnotationParser.parseAnnotations(
1206                                 annotations,
1207                                 SharedSecrets.getJavaLangAccess()
1208                                         .getConstantPool(getDeclaringClass()),
1209                                 getDeclaringClass());
1210                     }
1211                     declaredAnnotations = declAnnos;
1212                 }
1213             }
1214         }
1215         return declAnnos;
1216     }
1217 
1218     private native byte[] getTypeAnnotationBytes0();
1219 
1220     /**
1221      * Returns an AnnotatedType object that represents the use of a type to specify
1222      * the declared type of the field represented by this Field.
1223      * @return an object representing the declared type of the field
1224      * represented by this Field
1225      *
1226      * @since 1.8
1227      */
1228     public AnnotatedType getAnnotatedType() {
1229         return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),
1230                                                        SharedSecrets.getJavaLangAccess().
1231                                                            getConstantPool(getDeclaringClass()),
1232                                                        this,
1233                                                        getDeclaringClass(),
1234                                                        getGenericType(),
1235                                                        TypeAnnotation.TypeAnnotationTarget.FIELD);
1236 }
1237 }
    </pre>
  </body>
</html>