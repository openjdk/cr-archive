<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MemberName.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../hotspot/share/utilities/growableArray.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleNatives.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MemberName.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 176         }
 177         if (!isInvocable()) {
 178             throw newIllegalArgumentException(&quot;not invocable, no method type&quot;);
 179         }
 180 
 181         // Get a snapshot of type which doesn&#39;t get changed by racing threads.
 182         final Object type = this.type;
 183         if (type instanceof String) {
 184             return (String) type;
 185         } else {
 186             return getMethodType().toMethodDescriptorString();
 187         }
 188     }
 189 
 190     /** Return the actual type under which this method or constructor must be invoked.
 191      *  For non-static methods or constructors, this is the type with a leading parameter,
 192      *  a reference to declaring class.  For static methods, it is the same as the declared type.
 193      */
 194     public MethodType getInvocationType() {
 195         MethodType itype = getMethodOrFieldType();
<span class="line-modified"> 196         if (isConstructor() &amp;&amp; getReferenceKind() == REF_newInvokeSpecial)</span>
 197             return itype.changeReturnType(clazz);
 198         if (!isStatic())
 199             return itype.insertParameterTypes(0, clazz);
 200         return itype;
 201     }
 202 
 203     /** Utility method producing the parameter types of the method type. */
 204     public Class&lt;?&gt;[] getParameterTypes() {
 205         return getMethodType().parameterArray();
 206     }
 207 
 208     /** Utility method producing the return type of the method type. */
 209     public Class&lt;?&gt; getReturnType() {
 210         return getMethodType().returnType();
 211     }
 212 
 213     /** Return the declared type of this member, which
 214      *  must be a field or type.
 215      *  If it is a type member, that type itself is returned.
 216      */
</pre>
<hr />
<pre>
 269     }
 270 
 271     /** Return the modifier flags of this member.
 272      *  @see java.lang.reflect.Modifier
 273      */
 274     public int getModifiers() {
 275         return (flags &amp; RECOGNIZED_MODIFIERS);
 276     }
 277 
 278     /** Return the reference kind of this member, or zero if none.
 279      */
 280     public byte getReferenceKind() {
 281         return (byte) ((flags &gt;&gt;&gt; MN_REFERENCE_KIND_SHIFT) &amp; MN_REFERENCE_KIND_MASK);
 282     }
 283     private boolean referenceKindIsConsistent() {
 284         byte refKind = getReferenceKind();
 285         if (refKind == REF_NONE)  return isType();
 286         if (isField()) {
 287             assert(staticIsConsistent());
 288             assert(MethodHandleNatives.refKindIsField(refKind));
<span class="line-modified"> 289         } else if (isConstructor()) {</span>
 290             assert(refKind == REF_newInvokeSpecial || refKind == REF_invokeSpecial);
 291         } else if (isMethod()) {
 292             assert(staticIsConsistent());
 293             assert(MethodHandleNatives.refKindIsMethod(refKind));
 294             if (clazz.isInterface())
 295                 assert(refKind == REF_invokeInterface ||
 296                        refKind == REF_invokeStatic    ||
 297                        refKind == REF_invokeSpecial   ||
 298                        refKind == REF_invokeVirtual &amp;&amp; isObjectPublicMethod());
 299         } else {
 300             assert(false);
 301         }
 302         return true;
 303     }
 304     private boolean isObjectPublicMethod() {
 305         if (clazz == Object.class)  return true;
 306         MethodType mtype = getMethodType();
 307         if (name.equals(&quot;toString&quot;) &amp;&amp; mtype.returnType() == String.class &amp;&amp; mtype.parameterCount() == 0)
 308             return true;
 309         if (name.equals(&quot;hashCode&quot;) &amp;&amp; mtype.returnType() == int.class &amp;&amp; mtype.parameterCount() == 0)
</pre>
<hr />
<pre>
 413     private static final int MH_INVOKE_MODS = Modifier.NATIVE | Modifier.FINAL | Modifier.PUBLIC;
 414 
 415     /** Utility method to query the modifier flags of this member. */
 416     public boolean isStatic() {
 417         return Modifier.isStatic(flags);
 418     }
 419     /** Utility method to query the modifier flags of this member. */
 420     public boolean isPublic() {
 421         return Modifier.isPublic(flags);
 422     }
 423     /** Utility method to query the modifier flags of this member. */
 424     public boolean isPrivate() {
 425         return Modifier.isPrivate(flags);
 426     }
 427     /** Utility method to query the modifier flags of this member. */
 428     public boolean isProtected() {
 429         return Modifier.isProtected(flags);
 430     }
 431     /** Utility method to query the modifier flags of this member. */
 432     public boolean isFinal() {


 433         return Modifier.isFinal(flags);
 434     }
 435     /** Utility method to query whether this member or its defining class is final. */
 436     public boolean canBeStaticallyBound() {
 437         return Modifier.isFinal(flags | clazz.getModifiers());
 438     }
 439     /** Utility method to query the modifier flags of this member. */
 440     public boolean isVolatile() {
 441         return Modifier.isVolatile(flags);
 442     }
 443     /** Utility method to query the modifier flags of this member. */
 444     public boolean isAbstract() {
 445         return Modifier.isAbstract(flags);
 446     }
 447     /** Utility method to query the modifier flags of this member. */
 448     public boolean isNative() {
 449         return Modifier.isNative(flags);
 450     }
 451     // let the rest (native, volatile, transient, etc.) be tested via Modifier.isFoo
 452 
 453     // unofficial modifier flags, used by HotSpot:
<span class="line-modified"> 454     static final int BRIDGE    = 0x00000040;</span>
<span class="line-modified"> 455     static final int VARARGS   = 0x00000080;</span>
<span class="line-modified"> 456     static final int SYNTHETIC = 0x00001000;</span>
<span class="line-modified"> 457     static final int ANNOTATION= 0x00002000;</span>
<span class="line-modified"> 458     static final int ENUM      = 0x00004000;</span>


 459     /** Utility method to query the modifier flags of this member; returns false if the member is not a method. */
 460     public boolean isBridge() {
 461         return testAllFlags(IS_METHOD | BRIDGE);
 462     }
 463     /** Utility method to query the modifier flags of this member; returns false if the member is not a method. */
 464     public boolean isVarargs() {
 465         return testAllFlags(VARARGS) &amp;&amp; isInvocable();
 466     }
 467     /** Utility method to query the modifier flags of this member; returns false if the member is not a method. */
 468     public boolean isSynthetic() {
 469         return testAllFlags(SYNTHETIC);
 470     }
 471 












 472     static final String CONSTRUCTOR_NAME = &quot;&lt;init&gt;&quot;;  // the ever-popular
 473 
 474     // modifiers exported by the JVM:
 475     static final int RECOGNIZED_MODIFIERS = 0xFFFF;
 476 
 477     // private flags, not part of RECOGNIZED_MODIFIERS:
 478     static final int
<span class="line-modified"> 479             IS_METHOD        = MN_IS_METHOD,        // method (not constructor)</span>
<span class="line-modified"> 480             IS_CONSTRUCTOR   = MN_IS_CONSTRUCTOR,   // constructor</span>
<span class="line-modified"> 481             IS_FIELD         = MN_IS_FIELD,         // field</span>
<span class="line-modified"> 482             IS_TYPE          = MN_IS_TYPE,          // nested type</span>
<span class="line-modified"> 483             CALLER_SENSITIVE = MN_CALLER_SENSITIVE, // @CallerSensitive annotation detected</span>
<span class="line-modified"> 484             TRUSTED_FINAL    = MN_TRUSTED_FINAL;    // trusted final field</span>
 485 
 486     static final int ALL_ACCESS = Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED;
<span class="line-modified"> 487     static final int ALL_KINDS = IS_METHOD | IS_CONSTRUCTOR | IS_FIELD | IS_TYPE;</span>
<span class="line-modified"> 488     static final int IS_INVOCABLE = IS_METHOD | IS_CONSTRUCTOR;</span>
 489     static final int IS_FIELD_OR_METHOD = IS_METHOD | IS_FIELD;
 490     static final int SEARCH_ALL_SUPERS = MN_SEARCH_SUPERCLASSES | MN_SEARCH_INTERFACES;
 491 
 492     /** Utility method to query whether this member is a method or constructor. */
 493     public boolean isInvocable() {
 494         return testAnyFlags(IS_INVOCABLE);
 495     }
 496     /** Utility method to query whether this member is a method, constructor, or field. */
 497     public boolean isFieldOrMethod() {
 498         return testAnyFlags(IS_FIELD_OR_METHOD);
 499     }
 500     /** Query whether this member is a method. */
 501     public boolean isMethod() {
 502         return testAllFlags(IS_METHOD);
 503     }
 504     /** Query whether this member is a constructor. */
<span class="line-modified"> 505     public boolean isConstructor() {</span>
<span class="line-modified"> 506         return testAllFlags(IS_CONSTRUCTOR);</span>




 507     }
 508     /** Query whether this member is a field. */
 509     public boolean isField() {
 510         return testAllFlags(IS_FIELD);
 511     }
 512     /** Query whether this member is a type. */
 513     public boolean isType() {
 514         return testAllFlags(IS_TYPE);
 515     }
 516     /** Utility method to query whether this member is neither public, private, nor protected. */
 517     public boolean isPackage() {
 518         return !testAnyFlags(ALL_ACCESS);
 519     }
 520     /** Query whether this member has a CallerSensitive annotation. */
 521     public boolean isCallerSensitive() {
 522         return testAllFlags(CALLER_SENSITIVE);
 523     }
 524     /** Query whether this member is a trusted final field. */
 525     public boolean isTrustedFinalField() { return testAllFlags(TRUSTED_FINAL|IS_FIELD); }
 526 
</pre>
<hr />
<pre>
 617                 throw new AbstractMethodError(this.toString());
 618             if (getReferenceKind() == REF_invokeVirtual)
 619                 changeReferenceKind(REF_invokeSpecial, REF_invokeVirtual);
 620             else if (getReferenceKind() == REF_invokeInterface)
 621                 // invokeSpecial on a default method
 622                 changeReferenceKind(REF_invokeSpecial, REF_invokeInterface);
 623         }
 624     }
 625     public MemberName asSpecial() {
 626         switch (getReferenceKind()) {
 627         case REF_invokeSpecial:     return this;
 628         case REF_invokeVirtual:     return clone().changeReferenceKind(REF_invokeSpecial, REF_invokeVirtual);
 629         case REF_invokeInterface:   return clone().changeReferenceKind(REF_invokeSpecial, REF_invokeInterface);
 630         case REF_newInvokeSpecial:  return clone().changeReferenceKind(REF_invokeSpecial, REF_newInvokeSpecial);
 631         }
 632         throw new IllegalArgumentException(this.toString());
 633     }
 634     /** If this MN is not REF_newInvokeSpecial, return a clone with that ref. kind.
 635      *  In that case it must already be REF_invokeSpecial.
 636      */
<span class="line-modified"> 637     public MemberName asConstructor() {</span>
 638         switch (getReferenceKind()) {
 639         case REF_invokeSpecial:     return clone().changeReferenceKind(REF_newInvokeSpecial, REF_invokeSpecial);
 640         case REF_newInvokeSpecial:  return this;
 641         }
 642         throw new IllegalArgumentException(this.toString());
 643     }
 644     /** If this MN is a REF_invokeSpecial, return a clone with the &quot;normal&quot; kind
 645      *  REF_invokeVirtual; also switch either to REF_invokeInterface if clazz.isInterface.
 646      *  The end result is to get a fully virtualized version of the MN.
 647      *  (Note that resolving in the JVM will sometimes devirtualize, changing
 648      *  REF_invokeVirtual of a final to REF_invokeSpecial, and REF_invokeInterface
 649      *  in some corner cases to either of the previous two; this transform
 650      *  undoes that change under the assumption that it occurred.)
 651      */
 652     public MemberName asNormalOriginal() {
 653         byte normalVirtual = clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;
 654         byte refKind = getReferenceKind();
 655         byte newRefKind = refKind;
 656         MemberName result = this;
 657         switch (refKind) {
 658         case REF_invokeInterface:
 659         case REF_invokeVirtual:
 660         case REF_invokeSpecial:
 661             newRefKind = normalVirtual;
 662             break;
 663         }
 664         if (newRefKind == refKind)
 665             return this;
 666         result = clone().changeReferenceKind(newRefKind, refKind);
 667         assert(this.referenceKindIsConsistentWith(result.getReferenceKind()));
 668         return result;
 669     }
 670     /** Create a name for the given reflected constructor.  The resulting name will be in a resolved state. */
 671     @SuppressWarnings(&quot;LeakingThisInConstructor&quot;)
 672     public MemberName(Constructor&lt;?&gt; ctor) {
 673         Objects.requireNonNull(ctor);
 674         // fill in vmtarget, vmindex while we have ctor in hand:
 675         MethodHandleNatives.init(this, ctor);
 676         assert(isResolved() &amp;&amp; this.clazz != null);
 677         this.name = CONSTRUCTOR_NAME;
<span class="line-modified"> 678         if (this.type == null)</span>
<span class="line-modified"> 679             this.type = new Object[] { void.class, ctor.getParameterTypes() };</span>






 680     }
 681     /** Create a name for the given reflected field.  The resulting name will be in a resolved state.
 682      */
 683     public MemberName(Field fld) {
 684         this(fld, false);
 685     }
 686     @SuppressWarnings(&quot;LeakingThisInConstructor&quot;)
 687     public MemberName(Field fld, boolean makeSetter) {
 688         Objects.requireNonNull(fld);
 689         // fill in vmtarget, vmindex while we have fld in hand:
 690         MethodHandleNatives.init(this, fld);
 691         assert(isResolved() &amp;&amp; this.clazz != null);
 692         this.name = fld.getName();
 693         this.type = fld.getType();
 694         assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));
 695         byte refKind = this.getReferenceKind();
 696         assert(refKind == (isStatic() ? REF_getStatic : REF_getField));
 697         if (makeSetter) {
 698             changeReferenceKind((byte)(refKind + (REF_putStatic - REF_getStatic)), refKind);
 699         }
</pre>
<hr />
<pre>
 800     }
 801 
 802     // Construction from symbolic parts, for queries:
 803     /** Create a field or type name from the given components:
 804      *  Declaring class, name, type, reference kind.
 805      *  The declaring class may be supplied as null if this is to be a bare name and type.
 806      *  The resulting name will in an unresolved state.
 807      */
 808     public MemberName(Class&lt;?&gt; defClass, String name, Class&lt;?&gt; type, byte refKind) {
 809         init(defClass, name, type, flagsMods(IS_FIELD, 0, refKind));
 810         initResolved(false);
 811     }
 812     /** Create a method or constructor name from the given components:
 813      *  Declaring class, name, type, reference kind.
 814      *  It will be a constructor if and only if the name is {@code &quot;&lt;init&gt;&quot;}.
 815      *  The declaring class may be supplied as null if this is to be a bare name and type.
 816      *  The last argument is optional, a boolean which requests REF_invokeSpecial.
 817      *  The resulting name will in an unresolved state.
 818      */
 819     public MemberName(Class&lt;?&gt; defClass, String name, MethodType type, byte refKind) {
<span class="line-modified"> 820         int initFlags = (name != null &amp;&amp; name.equals(CONSTRUCTOR_NAME) ? IS_CONSTRUCTOR : IS_METHOD);</span>
 821         init(defClass, name, type, flagsMods(initFlags, 0, refKind));
 822         initResolved(false);
 823     }
 824     /** Create a method, constructor, or field name from the given components:
 825      *  Reference kind, declaring class, name, type.
 826      */
 827     public MemberName(byte refKind, Class&lt;?&gt; defClass, String name, Object type) {
 828         int kindFlags;
 829         if (MethodHandleNatives.refKindIsField(refKind)) {
 830             kindFlags = IS_FIELD;
 831             if (!(type instanceof Class))
 832                 throw newIllegalArgumentException(&quot;not a field type&quot;);
 833         } else if (MethodHandleNatives.refKindIsMethod(refKind)) {
 834             kindFlags = IS_METHOD;
 835             if (!(type instanceof MethodType))
 836                 throw newIllegalArgumentException(&quot;not a method type&quot;);
 837         } else if (refKind == REF_newInvokeSpecial) {
<span class="line-modified"> 838             kindFlags = IS_CONSTRUCTOR;</span>
 839             if (!(type instanceof MethodType) ||
 840                 !CONSTRUCTOR_NAME.equals(name))
 841                 throw newIllegalArgumentException(&quot;not a constructor type or name&quot;);
 842         } else {
 843             throw newIllegalArgumentException(&quot;bad reference kind &quot;+refKind);
 844         }
 845         init(defClass, name, type, flagsMods(kindFlags, 0, refKind));
 846         initResolved(false);
 847     }
 848     /** Query whether this member name is resolved to a non-static, non-final method.
 849      */
 850     public boolean hasReceiverTypeDispatch() {
 851         return MethodHandleNatives.refKindDoesDispatch(getReferenceKind());
 852     }
 853 
 854     /** Query whether this member name is resolved.
 855      *  A resolved member name is one for which the JVM has found
 856      *  a method, constructor, field, or type binding corresponding exactly to the name.
 857      *  (Document?)
 858      */
</pre>
<hr />
<pre>
 942                     MethodHandles.Lookup lookup = (MethodHandles.Lookup)from;
 943                     from = lookup.lookupClass();
 944                     m = lookup.lookupClass().getModule();
 945                     plc = lookup.previousLookupClass();
 946                 } else {
 947                     m = ((Class&lt;?&gt;)from).getModule();
 948                     plc = null;
 949                 }
 950                 message += &quot;, from &quot; + from + &quot; (&quot; + m + &quot;)&quot;;
 951                 if (plc != null) {
 952                     message += &quot;, previous lookup &quot; +
 953                         plc.getName() + &quot; (&quot; + plc.getModule() + &quot;)&quot;;
 954                 }
 955             }
 956         }
 957         return new IllegalAccessException(message);
 958     }
 959     private String message() {
 960         if (isResolved())
 961             return &quot;no access&quot;;
<span class="line-modified"> 962         else if (isConstructor())</span>
 963             return &quot;no such constructor&quot;;
 964         else if (isMethod())
 965             return &quot;no such method&quot;;
 966         else
 967             return &quot;no such field&quot;;
 968     }
 969     public ReflectiveOperationException makeAccessException() {
 970         String message = message() + &quot;: &quot;+ toString();
 971         ReflectiveOperationException ex;
 972         if (isResolved() || !(resolution instanceof NoSuchMethodError ||
 973                               resolution instanceof NoSuchFieldError))
 974             ex = new IllegalAccessException(message);
<span class="line-modified"> 975         else if (isConstructor())</span>
 976             ex = new NoSuchMethodException(message);
 977         else if (isMethod())
 978             ex = new NoSuchMethodException(message);
 979         else
 980             ex = new NoSuchFieldException(message);
 981         if (resolution instanceof Throwable)
 982             ex.initCause((Throwable) resolution);
 983         return ex;
 984     }
 985 
 986     /** Actually making a query requires an access check. */
 987     /*non-public*/
 988     static Factory getFactory() {
 989         return Factory.INSTANCE;
 990     }
 991     /** A factory type for resolving member names with the help of the VM.
 992      *  TBD: Define access-safe public constructors for this factory.
 993      */
 994     /*non-public*/
 995     static class Factory {
</pre>
<hr />
<pre>
1133         /** Return a list of all methods defined by the given class.
1134          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1135          *  Access checking is performed on behalf of the given {@code lookupClass}.
1136          *  Inaccessible members are not added to the last.
1137          */
1138         public List&lt;MemberName&gt; getMethods(Class&lt;?&gt; defc, boolean searchSupers,
1139                 Class&lt;?&gt; lookupClass) {
1140             return getMethods(defc, searchSupers, null, null, lookupClass);
1141         }
1142         /** Return a list of matching methods defined by the given class.
1143          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1144          *  Returned methods will match the name (if not null) and the type (if not null).
1145          *  Access checking is performed on behalf of the given {@code lookupClass}.
1146          *  Inaccessible members are not added to the last.
1147          */
1148         public List&lt;MemberName&gt; getMethods(Class&lt;?&gt; defc, boolean searchSupers,
1149                 String name, MethodType type, Class&lt;?&gt; lookupClass) {
1150             int matchFlags = IS_METHOD | (searchSupers ? SEARCH_ALL_SUPERS : 0);
1151             return getMembers(defc, name, type, matchFlags, lookupClass);
1152         }
<span class="line-modified">1153         /** Return a list of all constructors defined by the given class.</span>
1154          *  Access checking is performed on behalf of the given {@code lookupClass}.
1155          *  Inaccessible members are not added to the last.
1156          */
<span class="line-modified">1157         public List&lt;MemberName&gt; getConstructors(Class&lt;?&gt; defc, Class&lt;?&gt; lookupClass) {</span>
<span class="line-modified">1158             return getMembers(defc, null, null, IS_CONSTRUCTOR, lookupClass);</span>
1159         }
1160         /** Return a list of all fields defined by the given class.
1161          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1162          *  Access checking is performed on behalf of the given {@code lookupClass}.
1163          *  Inaccessible members are not added to the last.
1164          */
1165         public List&lt;MemberName&gt; getFields(Class&lt;?&gt; defc, boolean searchSupers,
1166                 Class&lt;?&gt; lookupClass) {
1167             return getFields(defc, searchSupers, null, null, lookupClass);
1168         }
1169         /** Return a list of all fields defined by the given class.
1170          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1171          *  Returned fields will match the name (if not null) and the type (if not null).
1172          *  Access checking is performed on behalf of the given {@code lookupClass}.
1173          *  Inaccessible members are not added to the last.
1174          */
1175         public List&lt;MemberName&gt; getFields(Class&lt;?&gt; defc, boolean searchSupers,
1176                 String name, Class&lt;?&gt; type, Class&lt;?&gt; lookupClass) {
1177             int matchFlags = IS_FIELD | (searchSupers ? SEARCH_ALL_SUPERS : 0);
1178             return getMembers(defc, name, type, matchFlags, lookupClass);
</pre>
</td>
<td>
<hr />
<pre>
 176         }
 177         if (!isInvocable()) {
 178             throw newIllegalArgumentException(&quot;not invocable, no method type&quot;);
 179         }
 180 
 181         // Get a snapshot of type which doesn&#39;t get changed by racing threads.
 182         final Object type = this.type;
 183         if (type instanceof String) {
 184             return (String) type;
 185         } else {
 186             return getMethodType().toMethodDescriptorString();
 187         }
 188     }
 189 
 190     /** Return the actual type under which this method or constructor must be invoked.
 191      *  For non-static methods or constructors, this is the type with a leading parameter,
 192      *  a reference to declaring class.  For static methods, it is the same as the declared type.
 193      */
 194     public MethodType getInvocationType() {
 195         MethodType itype = getMethodOrFieldType();
<span class="line-modified"> 196         if (isObjectConstructor() &amp;&amp; getReferenceKind() == REF_newInvokeSpecial)</span>
 197             return itype.changeReturnType(clazz);
 198         if (!isStatic())
 199             return itype.insertParameterTypes(0, clazz);
 200         return itype;
 201     }
 202 
 203     /** Utility method producing the parameter types of the method type. */
 204     public Class&lt;?&gt;[] getParameterTypes() {
 205         return getMethodType().parameterArray();
 206     }
 207 
 208     /** Utility method producing the return type of the method type. */
 209     public Class&lt;?&gt; getReturnType() {
 210         return getMethodType().returnType();
 211     }
 212 
 213     /** Return the declared type of this member, which
 214      *  must be a field or type.
 215      *  If it is a type member, that type itself is returned.
 216      */
</pre>
<hr />
<pre>
 269     }
 270 
 271     /** Return the modifier flags of this member.
 272      *  @see java.lang.reflect.Modifier
 273      */
 274     public int getModifiers() {
 275         return (flags &amp; RECOGNIZED_MODIFIERS);
 276     }
 277 
 278     /** Return the reference kind of this member, or zero if none.
 279      */
 280     public byte getReferenceKind() {
 281         return (byte) ((flags &gt;&gt;&gt; MN_REFERENCE_KIND_SHIFT) &amp; MN_REFERENCE_KIND_MASK);
 282     }
 283     private boolean referenceKindIsConsistent() {
 284         byte refKind = getReferenceKind();
 285         if (refKind == REF_NONE)  return isType();
 286         if (isField()) {
 287             assert(staticIsConsistent());
 288             assert(MethodHandleNatives.refKindIsField(refKind));
<span class="line-modified"> 289         } else if (isObjectConstructor()) {</span>
 290             assert(refKind == REF_newInvokeSpecial || refKind == REF_invokeSpecial);
 291         } else if (isMethod()) {
 292             assert(staticIsConsistent());
 293             assert(MethodHandleNatives.refKindIsMethod(refKind));
 294             if (clazz.isInterface())
 295                 assert(refKind == REF_invokeInterface ||
 296                        refKind == REF_invokeStatic    ||
 297                        refKind == REF_invokeSpecial   ||
 298                        refKind == REF_invokeVirtual &amp;&amp; isObjectPublicMethod());
 299         } else {
 300             assert(false);
 301         }
 302         return true;
 303     }
 304     private boolean isObjectPublicMethod() {
 305         if (clazz == Object.class)  return true;
 306         MethodType mtype = getMethodType();
 307         if (name.equals(&quot;toString&quot;) &amp;&amp; mtype.returnType() == String.class &amp;&amp; mtype.parameterCount() == 0)
 308             return true;
 309         if (name.equals(&quot;hashCode&quot;) &amp;&amp; mtype.returnType() == int.class &amp;&amp; mtype.parameterCount() == 0)
</pre>
<hr />
<pre>
 413     private static final int MH_INVOKE_MODS = Modifier.NATIVE | Modifier.FINAL | Modifier.PUBLIC;
 414 
 415     /** Utility method to query the modifier flags of this member. */
 416     public boolean isStatic() {
 417         return Modifier.isStatic(flags);
 418     }
 419     /** Utility method to query the modifier flags of this member. */
 420     public boolean isPublic() {
 421         return Modifier.isPublic(flags);
 422     }
 423     /** Utility method to query the modifier flags of this member. */
 424     public boolean isPrivate() {
 425         return Modifier.isPrivate(flags);
 426     }
 427     /** Utility method to query the modifier flags of this member. */
 428     public boolean isProtected() {
 429         return Modifier.isProtected(flags);
 430     }
 431     /** Utility method to query the modifier flags of this member. */
 432     public boolean isFinal() {
<span class="line-added"> 433         // all fields declared in a value type are effectively final</span>
<span class="line-added"> 434         assert(!clazz.isInlineClass() || !isField() || Modifier.isFinal(flags));</span>
 435         return Modifier.isFinal(flags);
 436     }
 437     /** Utility method to query whether this member or its defining class is final. */
 438     public boolean canBeStaticallyBound() {
 439         return Modifier.isFinal(flags | clazz.getModifiers());
 440     }
 441     /** Utility method to query the modifier flags of this member. */
 442     public boolean isVolatile() {
 443         return Modifier.isVolatile(flags);
 444     }
 445     /** Utility method to query the modifier flags of this member. */
 446     public boolean isAbstract() {
 447         return Modifier.isAbstract(flags);
 448     }
 449     /** Utility method to query the modifier flags of this member. */
 450     public boolean isNative() {
 451         return Modifier.isNative(flags);
 452     }
 453     // let the rest (native, volatile, transient, etc.) be tested via Modifier.isFoo
 454 
 455     // unofficial modifier flags, used by HotSpot:
<span class="line-modified"> 456     static final int BRIDGE      = 0x00000040;</span>
<span class="line-modified"> 457     static final int VARARGS     = 0x00000080;</span>
<span class="line-modified"> 458     static final int SYNTHETIC   = 0x00001000;</span>
<span class="line-modified"> 459     static final int ANNOTATION  = 0x00002000;</span>
<span class="line-modified"> 460     static final int ENUM        = 0x00004000;</span>
<span class="line-added"> 461     static final int FLATTENED   = 0x00008000;</span>
<span class="line-added"> 462 </span>
 463     /** Utility method to query the modifier flags of this member; returns false if the member is not a method. */
 464     public boolean isBridge() {
 465         return testAllFlags(IS_METHOD | BRIDGE);
 466     }
 467     /** Utility method to query the modifier flags of this member; returns false if the member is not a method. */
 468     public boolean isVarargs() {
 469         return testAllFlags(VARARGS) &amp;&amp; isInvocable();
 470     }
 471     /** Utility method to query the modifier flags of this member; returns false if the member is not a method. */
 472     public boolean isSynthetic() {
 473         return testAllFlags(SYNTHETIC);
 474     }
 475 
<span class="line-added"> 476     /** Query whether this member is a flattened field */</span>
<span class="line-added"> 477     public boolean isFlattened() { return (flags &amp; FLATTENED) == FLATTENED; }</span>
<span class="line-added"> 478 </span>
<span class="line-added"> 479     /** Query whether this member is a field of an inline class. */</span>
<span class="line-added"> 480     public boolean isInlineableField()  {</span>
<span class="line-added"> 481         if (isField()) {</span>
<span class="line-added"> 482             Class&lt;?&gt; type = getFieldType();</span>
<span class="line-added"> 483             return type.isInlineClass();</span>
<span class="line-added"> 484         }</span>
<span class="line-added"> 485         return false;</span>
<span class="line-added"> 486     }</span>
<span class="line-added"> 487 </span>
 488     static final String CONSTRUCTOR_NAME = &quot;&lt;init&gt;&quot;;  // the ever-popular
 489 
 490     // modifiers exported by the JVM:
 491     static final int RECOGNIZED_MODIFIERS = 0xFFFF;
 492 
 493     // private flags, not part of RECOGNIZED_MODIFIERS:
 494     static final int
<span class="line-modified"> 495             IS_METHOD             = MN_IS_METHOD,              // method (not object constructor)</span>
<span class="line-modified"> 496             IS_OBJECT_CONSTRUCTOR = MN_IS_OBJECT_CONSTRUCTOR,  // object constructor</span>
<span class="line-modified"> 497             IS_FIELD              = MN_IS_FIELD,               // field</span>
<span class="line-modified"> 498             IS_TYPE               = MN_IS_TYPE,                // nested type</span>
<span class="line-modified"> 499             CALLER_SENSITIVE      = MN_CALLER_SENSITIVE,       // @CallerSensitive annotation detected</span>
<span class="line-modified"> 500             TRUSTED_FINAL         = MN_TRUSTED_FINAL;    // trusted final field</span>
 501 
 502     static final int ALL_ACCESS = Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED;
<span class="line-modified"> 503     static final int ALL_KINDS = IS_METHOD | IS_OBJECT_CONSTRUCTOR | IS_FIELD | IS_TYPE;</span>
<span class="line-modified"> 504     static final int IS_INVOCABLE = IS_METHOD | IS_OBJECT_CONSTRUCTOR;</span>
 505     static final int IS_FIELD_OR_METHOD = IS_METHOD | IS_FIELD;
 506     static final int SEARCH_ALL_SUPERS = MN_SEARCH_SUPERCLASSES | MN_SEARCH_INTERFACES;
 507 
 508     /** Utility method to query whether this member is a method or constructor. */
 509     public boolean isInvocable() {
 510         return testAnyFlags(IS_INVOCABLE);
 511     }
 512     /** Utility method to query whether this member is a method, constructor, or field. */
 513     public boolean isFieldOrMethod() {
 514         return testAnyFlags(IS_FIELD_OR_METHOD);
 515     }
 516     /** Query whether this member is a method. */
 517     public boolean isMethod() {
 518         return testAllFlags(IS_METHOD);
 519     }
 520     /** Query whether this member is a constructor. */
<span class="line-modified"> 521     public boolean isObjectConstructor() {</span>
<span class="line-modified"> 522         return testAllFlags(IS_OBJECT_CONSTRUCTOR);</span>
<span class="line-added"> 523     }</span>
<span class="line-added"> 524     /** Query whether this member is an object constructor or static &lt;init&gt; factory */</span>
<span class="line-added"> 525     public boolean isObjectConstructorOrStaticInitMethod() {</span>
<span class="line-added"> 526         return isObjectConstructor() || (getName().equals(CONSTRUCTOR_NAME) &amp;&amp; testAllFlags(IS_METHOD));</span>
 527     }
 528     /** Query whether this member is a field. */
 529     public boolean isField() {
 530         return testAllFlags(IS_FIELD);
 531     }
 532     /** Query whether this member is a type. */
 533     public boolean isType() {
 534         return testAllFlags(IS_TYPE);
 535     }
 536     /** Utility method to query whether this member is neither public, private, nor protected. */
 537     public boolean isPackage() {
 538         return !testAnyFlags(ALL_ACCESS);
 539     }
 540     /** Query whether this member has a CallerSensitive annotation. */
 541     public boolean isCallerSensitive() {
 542         return testAllFlags(CALLER_SENSITIVE);
 543     }
 544     /** Query whether this member is a trusted final field. */
 545     public boolean isTrustedFinalField() { return testAllFlags(TRUSTED_FINAL|IS_FIELD); }
 546 
</pre>
<hr />
<pre>
 637                 throw new AbstractMethodError(this.toString());
 638             if (getReferenceKind() == REF_invokeVirtual)
 639                 changeReferenceKind(REF_invokeSpecial, REF_invokeVirtual);
 640             else if (getReferenceKind() == REF_invokeInterface)
 641                 // invokeSpecial on a default method
 642                 changeReferenceKind(REF_invokeSpecial, REF_invokeInterface);
 643         }
 644     }
 645     public MemberName asSpecial() {
 646         switch (getReferenceKind()) {
 647         case REF_invokeSpecial:     return this;
 648         case REF_invokeVirtual:     return clone().changeReferenceKind(REF_invokeSpecial, REF_invokeVirtual);
 649         case REF_invokeInterface:   return clone().changeReferenceKind(REF_invokeSpecial, REF_invokeInterface);
 650         case REF_newInvokeSpecial:  return clone().changeReferenceKind(REF_invokeSpecial, REF_newInvokeSpecial);
 651         }
 652         throw new IllegalArgumentException(this.toString());
 653     }
 654     /** If this MN is not REF_newInvokeSpecial, return a clone with that ref. kind.
 655      *  In that case it must already be REF_invokeSpecial.
 656      */
<span class="line-modified"> 657     public MemberName asObjectConstructor() {</span>
 658         switch (getReferenceKind()) {
 659         case REF_invokeSpecial:     return clone().changeReferenceKind(REF_newInvokeSpecial, REF_invokeSpecial);
 660         case REF_newInvokeSpecial:  return this;
 661         }
 662         throw new IllegalArgumentException(this.toString());
 663     }
 664     /** If this MN is a REF_invokeSpecial, return a clone with the &quot;normal&quot; kind
 665      *  REF_invokeVirtual; also switch either to REF_invokeInterface if clazz.isInterface.
 666      *  The end result is to get a fully virtualized version of the MN.
 667      *  (Note that resolving in the JVM will sometimes devirtualize, changing
 668      *  REF_invokeVirtual of a final to REF_invokeSpecial, and REF_invokeInterface
 669      *  in some corner cases to either of the previous two; this transform
 670      *  undoes that change under the assumption that it occurred.)
 671      */
 672     public MemberName asNormalOriginal() {
 673         byte normalVirtual = clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;
 674         byte refKind = getReferenceKind();
 675         byte newRefKind = refKind;
 676         MemberName result = this;
 677         switch (refKind) {
 678         case REF_invokeInterface:
 679         case REF_invokeVirtual:
 680         case REF_invokeSpecial:
 681             newRefKind = normalVirtual;
 682             break;
 683         }
 684         if (newRefKind == refKind)
 685             return this;
 686         result = clone().changeReferenceKind(newRefKind, refKind);
 687         assert(this.referenceKindIsConsistentWith(result.getReferenceKind()));
 688         return result;
 689     }
 690     /** Create a name for the given reflected constructor.  The resulting name will be in a resolved state. */
 691     @SuppressWarnings(&quot;LeakingThisInConstructor&quot;)
 692     public MemberName(Constructor&lt;?&gt; ctor) {
 693         Objects.requireNonNull(ctor);
 694         // fill in vmtarget, vmindex while we have ctor in hand:
 695         MethodHandleNatives.init(this, ctor);
 696         assert(isResolved() &amp;&amp; this.clazz != null);
 697         this.name = CONSTRUCTOR_NAME;
<span class="line-modified"> 698         if (this.type == null) {</span>
<span class="line-modified"> 699             Class&lt;?&gt; rtype = void.class;</span>
<span class="line-added"> 700             if (isStatic()) {  // a static init factory, not a true constructor</span>
<span class="line-added"> 701                 rtype = getDeclaringClass();</span>
<span class="line-added"> 702                 // FIXME: If it&#39;s a hidden class, this sig won&#39;t work.</span>
<span class="line-added"> 703             }</span>
<span class="line-added"> 704             this.type = new Object[] { rtype, ctor.getParameterTypes() };</span>
<span class="line-added"> 705         }</span>
 706     }
 707     /** Create a name for the given reflected field.  The resulting name will be in a resolved state.
 708      */
 709     public MemberName(Field fld) {
 710         this(fld, false);
 711     }
 712     @SuppressWarnings(&quot;LeakingThisInConstructor&quot;)
 713     public MemberName(Field fld, boolean makeSetter) {
 714         Objects.requireNonNull(fld);
 715         // fill in vmtarget, vmindex while we have fld in hand:
 716         MethodHandleNatives.init(this, fld);
 717         assert(isResolved() &amp;&amp; this.clazz != null);
 718         this.name = fld.getName();
 719         this.type = fld.getType();
 720         assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));
 721         byte refKind = this.getReferenceKind();
 722         assert(refKind == (isStatic() ? REF_getStatic : REF_getField));
 723         if (makeSetter) {
 724             changeReferenceKind((byte)(refKind + (REF_putStatic - REF_getStatic)), refKind);
 725         }
</pre>
<hr />
<pre>
 826     }
 827 
 828     // Construction from symbolic parts, for queries:
 829     /** Create a field or type name from the given components:
 830      *  Declaring class, name, type, reference kind.
 831      *  The declaring class may be supplied as null if this is to be a bare name and type.
 832      *  The resulting name will in an unresolved state.
 833      */
 834     public MemberName(Class&lt;?&gt; defClass, String name, Class&lt;?&gt; type, byte refKind) {
 835         init(defClass, name, type, flagsMods(IS_FIELD, 0, refKind));
 836         initResolved(false);
 837     }
 838     /** Create a method or constructor name from the given components:
 839      *  Declaring class, name, type, reference kind.
 840      *  It will be a constructor if and only if the name is {@code &quot;&lt;init&gt;&quot;}.
 841      *  The declaring class may be supplied as null if this is to be a bare name and type.
 842      *  The last argument is optional, a boolean which requests REF_invokeSpecial.
 843      *  The resulting name will in an unresolved state.
 844      */
 845     public MemberName(Class&lt;?&gt; defClass, String name, MethodType type, byte refKind) {
<span class="line-modified"> 846         int initFlags = (name != null &amp;&amp; name.equals(CONSTRUCTOR_NAME) &amp;&amp; type.returnType() == void.class ? IS_OBJECT_CONSTRUCTOR : IS_METHOD);</span>
 847         init(defClass, name, type, flagsMods(initFlags, 0, refKind));
 848         initResolved(false);
 849     }
 850     /** Create a method, constructor, or field name from the given components:
 851      *  Reference kind, declaring class, name, type.
 852      */
 853     public MemberName(byte refKind, Class&lt;?&gt; defClass, String name, Object type) {
 854         int kindFlags;
 855         if (MethodHandleNatives.refKindIsField(refKind)) {
 856             kindFlags = IS_FIELD;
 857             if (!(type instanceof Class))
 858                 throw newIllegalArgumentException(&quot;not a field type&quot;);
 859         } else if (MethodHandleNatives.refKindIsMethod(refKind)) {
 860             kindFlags = IS_METHOD;
 861             if (!(type instanceof MethodType))
 862                 throw newIllegalArgumentException(&quot;not a method type&quot;);
 863         } else if (refKind == REF_newInvokeSpecial) {
<span class="line-modified"> 864             kindFlags = IS_OBJECT_CONSTRUCTOR;</span>
 865             if (!(type instanceof MethodType) ||
 866                 !CONSTRUCTOR_NAME.equals(name))
 867                 throw newIllegalArgumentException(&quot;not a constructor type or name&quot;);
 868         } else {
 869             throw newIllegalArgumentException(&quot;bad reference kind &quot;+refKind);
 870         }
 871         init(defClass, name, type, flagsMods(kindFlags, 0, refKind));
 872         initResolved(false);
 873     }
 874     /** Query whether this member name is resolved to a non-static, non-final method.
 875      */
 876     public boolean hasReceiverTypeDispatch() {
 877         return MethodHandleNatives.refKindDoesDispatch(getReferenceKind());
 878     }
 879 
 880     /** Query whether this member name is resolved.
 881      *  A resolved member name is one for which the JVM has found
 882      *  a method, constructor, field, or type binding corresponding exactly to the name.
 883      *  (Document?)
 884      */
</pre>
<hr />
<pre>
 968                     MethodHandles.Lookup lookup = (MethodHandles.Lookup)from;
 969                     from = lookup.lookupClass();
 970                     m = lookup.lookupClass().getModule();
 971                     plc = lookup.previousLookupClass();
 972                 } else {
 973                     m = ((Class&lt;?&gt;)from).getModule();
 974                     plc = null;
 975                 }
 976                 message += &quot;, from &quot; + from + &quot; (&quot; + m + &quot;)&quot;;
 977                 if (plc != null) {
 978                     message += &quot;, previous lookup &quot; +
 979                         plc.getName() + &quot; (&quot; + plc.getModule() + &quot;)&quot;;
 980                 }
 981             }
 982         }
 983         return new IllegalAccessException(message);
 984     }
 985     private String message() {
 986         if (isResolved())
 987             return &quot;no access&quot;;
<span class="line-modified"> 988         else if (isObjectConstructor())</span>
 989             return &quot;no such constructor&quot;;
 990         else if (isMethod())
 991             return &quot;no such method&quot;;
 992         else
 993             return &quot;no such field&quot;;
 994     }
 995     public ReflectiveOperationException makeAccessException() {
 996         String message = message() + &quot;: &quot;+ toString();
 997         ReflectiveOperationException ex;
 998         if (isResolved() || !(resolution instanceof NoSuchMethodError ||
 999                               resolution instanceof NoSuchFieldError))
1000             ex = new IllegalAccessException(message);
<span class="line-modified">1001         else if (isObjectConstructor())</span>
1002             ex = new NoSuchMethodException(message);
1003         else if (isMethod())
1004             ex = new NoSuchMethodException(message);
1005         else
1006             ex = new NoSuchFieldException(message);
1007         if (resolution instanceof Throwable)
1008             ex.initCause((Throwable) resolution);
1009         return ex;
1010     }
1011 
1012     /** Actually making a query requires an access check. */
1013     /*non-public*/
1014     static Factory getFactory() {
1015         return Factory.INSTANCE;
1016     }
1017     /** A factory type for resolving member names with the help of the VM.
1018      *  TBD: Define access-safe public constructors for this factory.
1019      */
1020     /*non-public*/
1021     static class Factory {
</pre>
<hr />
<pre>
1159         /** Return a list of all methods defined by the given class.
1160          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1161          *  Access checking is performed on behalf of the given {@code lookupClass}.
1162          *  Inaccessible members are not added to the last.
1163          */
1164         public List&lt;MemberName&gt; getMethods(Class&lt;?&gt; defc, boolean searchSupers,
1165                 Class&lt;?&gt; lookupClass) {
1166             return getMethods(defc, searchSupers, null, null, lookupClass);
1167         }
1168         /** Return a list of matching methods defined by the given class.
1169          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1170          *  Returned methods will match the name (if not null) and the type (if not null).
1171          *  Access checking is performed on behalf of the given {@code lookupClass}.
1172          *  Inaccessible members are not added to the last.
1173          */
1174         public List&lt;MemberName&gt; getMethods(Class&lt;?&gt; defc, boolean searchSupers,
1175                 String name, MethodType type, Class&lt;?&gt; lookupClass) {
1176             int matchFlags = IS_METHOD | (searchSupers ? SEARCH_ALL_SUPERS : 0);
1177             return getMembers(defc, name, type, matchFlags, lookupClass);
1178         }
<span class="line-modified">1179         /** Return a list of all object constructors defined by the given class.</span>
1180          *  Access checking is performed on behalf of the given {@code lookupClass}.
1181          *  Inaccessible members are not added to the last.
1182          */
<span class="line-modified">1183         public List&lt;MemberName&gt; getObjectConstructors(Class&lt;?&gt; defc, Class&lt;?&gt; lookupClass) {</span>
<span class="line-modified">1184             return getMembers(defc, null, null, IS_OBJECT_CONSTRUCTOR, lookupClass);</span>
1185         }
1186         /** Return a list of all fields defined by the given class.
1187          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1188          *  Access checking is performed on behalf of the given {@code lookupClass}.
1189          *  Inaccessible members are not added to the last.
1190          */
1191         public List&lt;MemberName&gt; getFields(Class&lt;?&gt; defc, boolean searchSupers,
1192                 Class&lt;?&gt; lookupClass) {
1193             return getFields(defc, searchSupers, null, null, lookupClass);
1194         }
1195         /** Return a list of all fields defined by the given class.
1196          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1197          *  Returned fields will match the name (if not null) and the type (if not null).
1198          *  Access checking is performed on behalf of the given {@code lookupClass}.
1199          *  Inaccessible members are not added to the last.
1200          */
1201         public List&lt;MemberName&gt; getFields(Class&lt;?&gt; defc, boolean searchSupers,
1202                 String name, Class&lt;?&gt; type, Class&lt;?&gt; lookupClass) {
1203             int matchFlags = IS_FIELD | (searchSupers ? SEARCH_ALL_SUPERS : 0);
1204             return getMembers(defc, name, type, matchFlags, lookupClass);
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../hotspot/share/utilities/growableArray.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleNatives.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>