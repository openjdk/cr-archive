<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleNatives.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/AccessibleObject.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2379 ...
2380 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
2381   &quot;asList&quot;, methodType(List.class, Object[].class));
2382 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
2383          * }&lt;/pre&gt;&lt;/blockquote&gt;
2384          * @param refc the class from which the method is accessed
2385          * @param name the name of the method
2386          * @param type the type of the method
2387          * @return the desired method handle
2388          * @throws NoSuchMethodException if the method does not exist
2389          * @throws IllegalAccessException if access checking fails,
2390          *                                or if the method is not {@code static},
2391          *                                or if the method&#39;s variable arity modifier bit
2392          *                                is set and {@code asVarargsCollector} fails
2393          * @throws    SecurityException if a security manager is present and it
2394          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2395          * @throws NullPointerException if any argument is null
2396          */
2397         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2398             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);






2399             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));
2400         }
2401 
2402         /**
2403          * Produces a method handle for a virtual method.
2404          * The type of the method handle will be that of the method,
2405          * with the receiver type (usually {@code refc}) prepended.
2406          * The method and all its argument types must be accessible to the lookup object.
2407          * &lt;p&gt;
2408          * When called, the handle will treat the first argument as a receiver
2409          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
2410          * implementation to enter.
2411          * For private methods the named method in {@code refc} will be invoked on the receiver.
2412          * (The dispatching action is identical with that performed by an
2413          * {@code invokevirtual} or {@code invokeinterface} instruction.)
2414          * &lt;p&gt;
2415          * The first argument will be of type {@code refc} if the lookup
2416          * class has full privileges to access the member.  Otherwise
2417          * the member must be {@code protected} and the first argument
2418          * will be restricted in type to the lookup class.
</pre>
<hr />
<pre>
2524          * If the returned method handle is invoked, the constructor&#39;s class will
2525          * be initialized, if it has not already been initialized.
2526          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2527          * &lt;blockquote&gt;&lt;pre&gt;{@code
2528 import static java.lang.invoke.MethodHandles.*;
2529 import static java.lang.invoke.MethodType.*;
2530 ...
2531 MethodHandle MH_newArrayList = publicLookup().findConstructor(
2532   ArrayList.class, methodType(void.class, Collection.class));
2533 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
2534 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
2535 assert(orig != copy);
2536 assertEquals(orig, copy);
2537 // a variable-arity constructor:
2538 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
2539   ProcessBuilder.class, methodType(void.class, String[].class));
2540 ProcessBuilder pb = (ProcessBuilder)
2541   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
2542 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
2543          * }&lt;/pre&gt;&lt;/blockquote&gt;







2544          * @param refc the class or interface from which the method is accessed
2545          * @param type the type of the method, with the receiver argument omitted, and a void return type
2546          * @return the desired method handle
2547          * @throws NoSuchMethodException if the constructor does not exist
2548          * @throws IllegalAccessException if access checking fails
2549          *                                or if the method&#39;s variable arity modifier bit
2550          *                                is set and {@code asVarargsCollector} fails
2551          * @throws    SecurityException if a security manager is present and it
2552          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2553          * @throws NullPointerException if any argument is null
2554          */
2555         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2556             if (refc.isArray()) {
2557                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
2558             }



2559             String name = &quot;&lt;init&gt;&quot;;
2560             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
2561             return getDirectConstructor(refc, ctor);
2562         }
2563 
2564         /**
2565          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,
2566          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.
2567          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,
2568          * and then determines whether the class is accessible to this lookup object.
2569          * &lt;p&gt;
2570          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2571          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2572          *
2573          * @param targetName the fully qualified name of the class to be looked up.
2574          * @return the requested class.
2575          * @throws SecurityException if a security manager is present and it
2576          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2577          * @throws LinkageError if the linkage fails
2578          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
</pre>
<hr />
<pre>
3193          * arguments passed to the method handle.
3194          * &lt;p&gt;
3195          * If the constructor&#39;s {@code accessible} flag is not set,
3196          * access checking is performed immediately on behalf of the lookup class.
3197          * &lt;p&gt;
3198          * The returned method handle will have
3199          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3200          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3201          * &lt;p&gt;
3202          * If the returned method handle is invoked, the constructor&#39;s class will
3203          * be initialized, if it has not already been initialized.
3204          * @param c the reflected constructor
3205          * @return a method handle which can invoke the reflected constructor
3206          * @throws IllegalAccessException if access checking fails
3207          *                                or if the method&#39;s variable arity modifier bit
3208          *                                is set and {@code asVarargsCollector} fails
3209          * @throws NullPointerException if the argument is null
3210          */
3211         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
3212             MemberName ctor = new MemberName(c);
<span class="line-modified">3213             assert(ctor.isConstructor());</span>
3214             @SuppressWarnings(&quot;deprecation&quot;)
3215             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
<span class="line-modified">3216             return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);</span>








3217         }
3218 
3219         /**
3220          * Produces a method handle giving read access to a reflected field.
3221          * The type of the method handle will have a return type of the field&#39;s
3222          * value type.
3223          * If the field is {@code static}, the method handle will take no arguments.
3224          * Otherwise, its single argument will be the instance containing
3225          * the field.
3226          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
3227          * access checking is performed immediately on behalf of the lookup class.
3228          * &lt;p&gt;
3229          * If the field is static, and
3230          * if the returned method handle is invoked, the field&#39;s class will
3231          * be initialized, if it has not already been initialized.
3232          * @param f the reflected field
3233          * @return a method handle which can load values from the reflected field
3234          * @throws IllegalAccessException if access checking fails
3235          * @throws NullPointerException if the argument is null
3236          */
</pre>
<hr />
<pre>
3449             }
3450             Objects.requireNonNull(member.getName());
3451             Objects.requireNonNull(member.getType());
3452             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
3453         }
3454 
3455         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
3456             if (!isClassAccessible(refc)) {
3457                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
3458             }
3459         }
3460 
3461         boolean isClassAccessible(Class&lt;?&gt; refc) {
3462             Objects.requireNonNull(refc);
3463             Class&lt;?&gt; caller = lookupClassOrNull();
3464             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);
3465         }
3466 
3467         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
3468         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
<span class="line-modified">3469             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial)</span>
<span class="line-modified">3470                 throw new NoSuchMethodException(&quot;illegal method name: &quot;+name);</span>



3471         }
3472 
<span class="line-removed">3473 </span>
3474         /**
3475          * Find my trustable caller class if m is a caller sensitive method.
3476          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3477          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
3478          */
3479         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {
3480             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {
3481                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods
3482                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3483             }
3484             return this;
3485         }
3486 
3487         /**
3488          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3489          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3490          *
3491          * @deprecated This method was originally designed to test {@code PRIVATE} access
3492          * that implies full privilege access but {@code MODULE} access has since become
3493          * independent of {@code PRIVATE} access.  It is recommended to call
</pre>
<hr />
<pre>
3538                 }
3539                 return;
3540             }
3541 
3542             // Step 2a:
3543             if (m.isPublic()) return;
3544             if (!fullPowerLookup) {
3545                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3546             }
3547 
3548             // Step 3:
3549             Class&lt;?&gt; defc = m.getDeclaringClass();
3550             if (!fullPowerLookup &amp;&amp; defc != refc) {
3551                 ReflectUtil.checkPackageAccess(defc);
3552             }
3553         }
3554 
3555         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3556             boolean wantStatic = (refKind == REF_invokeStatic);
3557             String message;
<span class="line-modified">3558             if (m.isConstructor())</span>
3559                 message = &quot;expected a method, not a constructor&quot;;
3560             else if (!m.isMethod())
3561                 message = &quot;expected a method&quot;;
3562             else if (wantStatic != m.isStatic())
3563                 message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;
3564             else
3565                 { checkAccess(refKind, refc, m); return; }
3566             throw m.makeAccessException(message, this);
3567         }
3568 
3569         void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3570             boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);
3571             String message;
3572             if (wantStatic != m.isStatic())
3573                 message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;
3574             else
3575                 { checkAccess(refKind, refc, m); return; }
3576             throw m.makeAccessException(message, this);
3577         }
3578 
</pre>
<hr />
<pre>
3837                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3838                 }
3839                 refc = lookupClass();
3840             }
3841             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),
3842                                               this.allowedModes == TRUSTED &amp;&amp; !getField.isTrustedFinalField());
3843         }
3844         /** Check access and get the requested constructor. */
3845         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3846             final boolean checkSecurity = true;
3847             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3848         }
3849         /** Check access and get the requested constructor, eliding security manager checks. */
3850         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3851             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3852             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3853         }
3854         /** Common code for all constructors; do not call directly except from immediately above. */
3855         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3856                                                   boolean checkSecurity) throws IllegalAccessException {
<span class="line-modified">3857             assert(ctor.isConstructor());</span>
3858             checkAccess(REF_newInvokeSpecial, refc, ctor);
3859             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3860             if (checkSecurity)
3861                 checkSecurityManager(refc, ctor);
3862             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3863             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3864         }
3865 
3866         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3867          */
3868         /*non-public*/
3869         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)
3870                 throws ReflectiveOperationException {
3871             if (!(type instanceof Class || type instanceof MethodType))
3872                 throw new InternalError(&quot;unresolved MemberName&quot;);
3873             MemberName member = new MemberName(refKind, defc, name, type);
3874             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3875             if (mh != null) {
3876                 checkSymbolicClass(defc);
3877                 return mh;
</pre>
<hr />
<pre>
4027      * Produces a method handle giving write access to elements of an array,
4028      * as if by the {@code astore} bytecode.
4029      * The type of the method handle will have a void return type.
4030      * Its last argument will be the array&#39;s element type.
4031      * The first and second arguments will be the array type and int.
4032      *
4033      * &lt;p&gt; When the returned method handle is invoked,
4034      * the array reference and array index are checked.
4035      * A {@code NullPointerException} will be thrown if the array reference
4036      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
4037      * thrown if the index is negative or if it is greater than or equal to
4038      * the length of the array.
4039      *
4040      * @param arrayClass the class of an array
4041      * @return a method handle which can store values into the array type
4042      * @throws NullPointerException if the argument is null
4043      * @throws IllegalArgumentException if arrayClass is not an array type
4044      * @jvms 6.5 {@code aastore} Instruction
4045      */
4046     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {



4047         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
4048     }
4049 
4050     /**
4051      * Produces a VarHandle giving access to elements of an array of type
4052      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
4053      * of {@code arrayClass} and the list of coordinate types is
4054      * {@code (arrayClass, int)}, where the {@code int} coordinate type
4055      * corresponds to an argument that is an index into an array.
4056      * &lt;p&gt;
4057      * Certain access modes of the returned VarHandle are unsupported under
4058      * the following conditions:
4059      * &lt;ul&gt;
4060      * &lt;li&gt;if the component type is anything other than {@code byte},
4061      *     {@code short}, {@code char}, {@code int}, {@code long},
4062      *     {@code float}, or {@code double} then numeric atomic update access
4063      *     modes are unsupported.
4064      * &lt;li&gt;if the component type is anything other than {@code boolean},
4065      *     {@code byte}, {@code short}, {@code char}, {@code int} or
4066      *     {@code long} then bitwise atomic update access modes are
</pre>
<hr />
<pre>
4787     }
4788 
4789     /**
4790      * Produces a constant method handle of the requested return type which
4791      * returns the default value for that type every time it is invoked.
4792      * The resulting constant method handle will have no side effects.
4793      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4794      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4795      * since {@code explicitCastArguments} converts {@code null} to default values.
4796      * @param type the expected return type of the desired method handle
4797      * @return a constant method handle that takes no arguments
4798      *         and returns the default value of the given type (or void, if the type is void)
4799      * @throws NullPointerException if the argument is null
4800      * @see MethodHandles#constant
4801      * @see MethodHandles#empty
4802      * @see MethodHandles#explicitCastArguments
4803      * @since 9
4804      */
4805     public static MethodHandle zero(Class&lt;?&gt; type) {
4806         Objects.requireNonNull(type);
<span class="line-modified">4807         return type.isPrimitive() ?  zero(Wrapper.forPrimitiveType(type), type) : zero(Wrapper.OBJECT, type);</span>






4808     }
4809 
4810     private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
4811         return type == void.class ? zero(type) : identity(type);
4812     }
4813 
4814     /**
4815      * Produces a method handle of the requested type which ignores any arguments, does nothing,
4816      * and returns a suitable default depending on the return type.
4817      * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
4818      * &lt;p&gt;The returned method handle is equivalent to
4819      * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
4820      *
4821      * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
4822      * {@code guardWithTest(pred, target, empty(target.type())}.
4823      * @param type the type of the desired method handle
4824      * @return a constant method handle of the given type, which returns a default value of the given return type
4825      * @throws NullPointerException if the argument is null
4826      * @see MethodHandles#zero
4827      * @see MethodHandles#constant
4828      * @since 9
4829      */
4830     public static  MethodHandle empty(MethodType type) {
4831         Objects.requireNonNull(type);
4832         return dropArguments(zero(type.returnType()), 0, type.parameterList());
4833     }
4834 
4835     private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
4836     private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
<span class="line-modified">4837         MethodType mtype = methodType(ptype, ptype);</span>
4838         LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
4839         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
4840     }
4841 
4842     private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
4843         int pos = btw.ordinal();
4844         MethodHandle zero = ZERO_MHS[pos];
4845         if (zero == null) {
4846             zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
4847         }
4848         if (zero.type().returnType() == rtype)
4849             return zero;
4850         assert(btw == Wrapper.OBJECT);
4851         return makeZero(rtype);
4852     }
4853     private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
4854     private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
4855         MethodType mtype = methodType(rtype);
4856         LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
4857         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
</pre>
</td>
<td>
<hr />
<pre>
2379 ...
2380 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
2381   &quot;asList&quot;, methodType(List.class, Object[].class));
2382 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
2383          * }&lt;/pre&gt;&lt;/blockquote&gt;
2384          * @param refc the class from which the method is accessed
2385          * @param name the name of the method
2386          * @param type the type of the method
2387          * @return the desired method handle
2388          * @throws NoSuchMethodException if the method does not exist
2389          * @throws IllegalAccessException if access checking fails,
2390          *                                or if the method is not {@code static},
2391          *                                or if the method&#39;s variable arity modifier bit
2392          *                                is set and {@code asVarargsCollector} fails
2393          * @throws    SecurityException if a security manager is present and it
2394          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2395          * @throws NullPointerException if any argument is null
2396          */
2397         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2398             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);
<span class="line-added">2399             // resolveOrFail could return a non-static &lt;init&gt; method if present</span>
<span class="line-added">2400             // detect and throw NSME before producing a MethodHandle</span>
<span class="line-added">2401             if (!method.isStatic() &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;)) {</span>
<span class="line-added">2402                 throw new NoSuchMethodException(&quot;illegal method name: &quot; + name);</span>
<span class="line-added">2403             }</span>
<span class="line-added">2404 </span>
2405             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));
2406         }
2407 
2408         /**
2409          * Produces a method handle for a virtual method.
2410          * The type of the method handle will be that of the method,
2411          * with the receiver type (usually {@code refc}) prepended.
2412          * The method and all its argument types must be accessible to the lookup object.
2413          * &lt;p&gt;
2414          * When called, the handle will treat the first argument as a receiver
2415          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
2416          * implementation to enter.
2417          * For private methods the named method in {@code refc} will be invoked on the receiver.
2418          * (The dispatching action is identical with that performed by an
2419          * {@code invokevirtual} or {@code invokeinterface} instruction.)
2420          * &lt;p&gt;
2421          * The first argument will be of type {@code refc} if the lookup
2422          * class has full privileges to access the member.  Otherwise
2423          * the member must be {@code protected} and the first argument
2424          * will be restricted in type to the lookup class.
</pre>
<hr />
<pre>
2530          * If the returned method handle is invoked, the constructor&#39;s class will
2531          * be initialized, if it has not already been initialized.
2532          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2533          * &lt;blockquote&gt;&lt;pre&gt;{@code
2534 import static java.lang.invoke.MethodHandles.*;
2535 import static java.lang.invoke.MethodType.*;
2536 ...
2537 MethodHandle MH_newArrayList = publicLookup().findConstructor(
2538   ArrayList.class, methodType(void.class, Collection.class));
2539 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
2540 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
2541 assert(orig != copy);
2542 assertEquals(orig, copy);
2543 // a variable-arity constructor:
2544 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
2545   ProcessBuilder.class, methodType(void.class, String[].class));
2546 ProcessBuilder pb = (ProcessBuilder)
2547   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
2548 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
2549          * }&lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-added">2550          *</span>
<span class="line-added">2551          * @apiNote</span>
<span class="line-added">2552          * This method does not find a static {@code &lt;init&gt;} factory method as it is invoked</span>
<span class="line-added">2553          * via {@code invokestatic} bytecode as opposed to {@code invokespecial} for an</span>
<span class="line-added">2554          * object constructor.  To look up static {@code &lt;init&gt;} factory method, use</span>
<span class="line-added">2555          * the {@link #findStatic(Class, String, MethodType) findStatic} method.</span>
<span class="line-added">2556          *</span>
2557          * @param refc the class or interface from which the method is accessed
2558          * @param type the type of the method, with the receiver argument omitted, and a void return type
2559          * @return the desired method handle
2560          * @throws NoSuchMethodException if the constructor does not exist
2561          * @throws IllegalAccessException if access checking fails
2562          *                                or if the method&#39;s variable arity modifier bit
2563          *                                is set and {@code asVarargsCollector} fails
2564          * @throws    SecurityException if a security manager is present and it
2565          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2566          * @throws NullPointerException if any argument is null
2567          */
2568         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2569             if (refc.isArray()) {
2570                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
2571             }
<span class="line-added">2572             if (type.returnType() != void.class) {</span>
<span class="line-added">2573                 throw new NoSuchMethodException(&quot;Constructors must have void return type: &quot; + refc.getName());</span>
<span class="line-added">2574             }</span>
2575             String name = &quot;&lt;init&gt;&quot;;
2576             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
2577             return getDirectConstructor(refc, ctor);
2578         }
2579 
2580         /**
2581          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,
2582          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.
2583          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,
2584          * and then determines whether the class is accessible to this lookup object.
2585          * &lt;p&gt;
2586          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2587          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2588          *
2589          * @param targetName the fully qualified name of the class to be looked up.
2590          * @return the requested class.
2591          * @throws SecurityException if a security manager is present and it
2592          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2593          * @throws LinkageError if the linkage fails
2594          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
</pre>
<hr />
<pre>
3209          * arguments passed to the method handle.
3210          * &lt;p&gt;
3211          * If the constructor&#39;s {@code accessible} flag is not set,
3212          * access checking is performed immediately on behalf of the lookup class.
3213          * &lt;p&gt;
3214          * The returned method handle will have
3215          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3216          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3217          * &lt;p&gt;
3218          * If the returned method handle is invoked, the constructor&#39;s class will
3219          * be initialized, if it has not already been initialized.
3220          * @param c the reflected constructor
3221          * @return a method handle which can invoke the reflected constructor
3222          * @throws IllegalAccessException if access checking fails
3223          *                                or if the method&#39;s variable arity modifier bit
3224          *                                is set and {@code asVarargsCollector} fails
3225          * @throws NullPointerException if the argument is null
3226          */
3227         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
3228             MemberName ctor = new MemberName(c);
<span class="line-modified">3229             assert(ctor.isObjectConstructorOrStaticInitMethod());</span>
3230             @SuppressWarnings(&quot;deprecation&quot;)
3231             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
<span class="line-modified">3232             if (ctor.isObjectConstructor()) {</span>
<span class="line-added">3233                 assert(ctor.getReturnType() == void.class);</span>
<span class="line-added">3234                 return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);</span>
<span class="line-added">3235             } else {</span>
<span class="line-added">3236                 // static init factory is a static method</span>
<span class="line-added">3237                 assert(ctor.isMethod() &amp;&amp; ctor.getReturnType() == ctor.getDeclaringClass() &amp;&amp; ctor.getReferenceKind() == REF_invokeStatic);</span>
<span class="line-added">3238                 assert(!MethodHandleNatives.isCallerSensitive(ctor));  // must not be caller-sensitive</span>
<span class="line-added">3239                 return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), ctor.getDeclaringClass(), ctor, lookup);</span>
<span class="line-added">3240             }</span>
3241         }
3242 
3243         /**
3244          * Produces a method handle giving read access to a reflected field.
3245          * The type of the method handle will have a return type of the field&#39;s
3246          * value type.
3247          * If the field is {@code static}, the method handle will take no arguments.
3248          * Otherwise, its single argument will be the instance containing
3249          * the field.
3250          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
3251          * access checking is performed immediately on behalf of the lookup class.
3252          * &lt;p&gt;
3253          * If the field is static, and
3254          * if the returned method handle is invoked, the field&#39;s class will
3255          * be initialized, if it has not already been initialized.
3256          * @param f the reflected field
3257          * @return a method handle which can load values from the reflected field
3258          * @throws IllegalAccessException if access checking fails
3259          * @throws NullPointerException if the argument is null
3260          */
</pre>
<hr />
<pre>
3473             }
3474             Objects.requireNonNull(member.getName());
3475             Objects.requireNonNull(member.getType());
3476             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
3477         }
3478 
3479         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
3480             if (!isClassAccessible(refc)) {
3481                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
3482             }
3483         }
3484 
3485         boolean isClassAccessible(Class&lt;?&gt; refc) {
3486             Objects.requireNonNull(refc);
3487             Class&lt;?&gt; caller = lookupClassOrNull();
3488             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);
3489         }
3490 
3491         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
3492         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
<span class="line-modified">3493             // &quot;&lt;init&gt;&quot; can only be invoked via invokespecial or it&#39;s a static init factory</span>
<span class="line-modified">3494             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial &amp;&amp;</span>
<span class="line-added">3495                     !(refKind == REF_invokeStatic &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;))) {</span>
<span class="line-added">3496                     throw new NoSuchMethodException(&quot;illegal method name: &quot; + name);</span>
<span class="line-added">3497             }</span>
3498         }
3499 

3500         /**
3501          * Find my trustable caller class if m is a caller sensitive method.
3502          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3503          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
3504          */
3505         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {
3506             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {
3507                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods
3508                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3509             }
3510             return this;
3511         }
3512 
3513         /**
3514          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3515          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3516          *
3517          * @deprecated This method was originally designed to test {@code PRIVATE} access
3518          * that implies full privilege access but {@code MODULE} access has since become
3519          * independent of {@code PRIVATE} access.  It is recommended to call
</pre>
<hr />
<pre>
3564                 }
3565                 return;
3566             }
3567 
3568             // Step 2a:
3569             if (m.isPublic()) return;
3570             if (!fullPowerLookup) {
3571                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3572             }
3573 
3574             // Step 3:
3575             Class&lt;?&gt; defc = m.getDeclaringClass();
3576             if (!fullPowerLookup &amp;&amp; defc != refc) {
3577                 ReflectUtil.checkPackageAccess(defc);
3578             }
3579         }
3580 
3581         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3582             boolean wantStatic = (refKind == REF_invokeStatic);
3583             String message;
<span class="line-modified">3584             if (m.isObjectConstructor())</span>
3585                 message = &quot;expected a method, not a constructor&quot;;
3586             else if (!m.isMethod())
3587                 message = &quot;expected a method&quot;;
3588             else if (wantStatic != m.isStatic())
3589                 message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;
3590             else
3591                 { checkAccess(refKind, refc, m); return; }
3592             throw m.makeAccessException(message, this);
3593         }
3594 
3595         void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3596             boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);
3597             String message;
3598             if (wantStatic != m.isStatic())
3599                 message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;
3600             else
3601                 { checkAccess(refKind, refc, m); return; }
3602             throw m.makeAccessException(message, this);
3603         }
3604 
</pre>
<hr />
<pre>
3863                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3864                 }
3865                 refc = lookupClass();
3866             }
3867             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),
3868                                               this.allowedModes == TRUSTED &amp;&amp; !getField.isTrustedFinalField());
3869         }
3870         /** Check access and get the requested constructor. */
3871         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3872             final boolean checkSecurity = true;
3873             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3874         }
3875         /** Check access and get the requested constructor, eliding security manager checks. */
3876         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3877             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3878             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3879         }
3880         /** Common code for all constructors; do not call directly except from immediately above. */
3881         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3882                                                   boolean checkSecurity) throws IllegalAccessException {
<span class="line-modified">3883             assert(ctor.isObjectConstructor());</span>
3884             checkAccess(REF_newInvokeSpecial, refc, ctor);
3885             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3886             if (checkSecurity)
3887                 checkSecurityManager(refc, ctor);
3888             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3889             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3890         }
3891 
3892         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3893          */
3894         /*non-public*/
3895         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)
3896                 throws ReflectiveOperationException {
3897             if (!(type instanceof Class || type instanceof MethodType))
3898                 throw new InternalError(&quot;unresolved MemberName&quot;);
3899             MemberName member = new MemberName(refKind, defc, name, type);
3900             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3901             if (mh != null) {
3902                 checkSymbolicClass(defc);
3903                 return mh;
</pre>
<hr />
<pre>
4053      * Produces a method handle giving write access to elements of an array,
4054      * as if by the {@code astore} bytecode.
4055      * The type of the method handle will have a void return type.
4056      * Its last argument will be the array&#39;s element type.
4057      * The first and second arguments will be the array type and int.
4058      *
4059      * &lt;p&gt; When the returned method handle is invoked,
4060      * the array reference and array index are checked.
4061      * A {@code NullPointerException} will be thrown if the array reference
4062      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
4063      * thrown if the index is negative or if it is greater than or equal to
4064      * the length of the array.
4065      *
4066      * @param arrayClass the class of an array
4067      * @return a method handle which can store values into the array type
4068      * @throws NullPointerException if the argument is null
4069      * @throws IllegalArgumentException if arrayClass is not an array type
4070      * @jvms 6.5 {@code aastore} Instruction
4071      */
4072     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
<span class="line-added">4073         if (arrayClass.isInlineClass()) {</span>
<span class="line-added">4074             throw new UnsupportedOperationException();</span>
<span class="line-added">4075         }</span>
4076         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
4077     }
4078 
4079     /**
4080      * Produces a VarHandle giving access to elements of an array of type
4081      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
4082      * of {@code arrayClass} and the list of coordinate types is
4083      * {@code (arrayClass, int)}, where the {@code int} coordinate type
4084      * corresponds to an argument that is an index into an array.
4085      * &lt;p&gt;
4086      * Certain access modes of the returned VarHandle are unsupported under
4087      * the following conditions:
4088      * &lt;ul&gt;
4089      * &lt;li&gt;if the component type is anything other than {@code byte},
4090      *     {@code short}, {@code char}, {@code int}, {@code long},
4091      *     {@code float}, or {@code double} then numeric atomic update access
4092      *     modes are unsupported.
4093      * &lt;li&gt;if the component type is anything other than {@code boolean},
4094      *     {@code byte}, {@code short}, {@code char}, {@code int} or
4095      *     {@code long} then bitwise atomic update access modes are
</pre>
<hr />
<pre>
4816     }
4817 
4818     /**
4819      * Produces a constant method handle of the requested return type which
4820      * returns the default value for that type every time it is invoked.
4821      * The resulting constant method handle will have no side effects.
4822      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4823      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4824      * since {@code explicitCastArguments} converts {@code null} to default values.
4825      * @param type the expected return type of the desired method handle
4826      * @return a constant method handle that takes no arguments
4827      *         and returns the default value of the given type (or void, if the type is void)
4828      * @throws NullPointerException if the argument is null
4829      * @see MethodHandles#constant
4830      * @see MethodHandles#empty
4831      * @see MethodHandles#explicitCastArguments
4832      * @since 9
4833      */
4834     public static MethodHandle zero(Class&lt;?&gt; type) {
4835         Objects.requireNonNull(type);
<span class="line-modified">4836         if (type.isPrimitive()) {</span>
<span class="line-added">4837             return zero(Wrapper.forPrimitiveType(type), type);</span>
<span class="line-added">4838         } else if (type.isInlineClass()) {</span>
<span class="line-added">4839             throw new UnsupportedOperationException();</span>
<span class="line-added">4840         } else {</span>
<span class="line-added">4841             return zero(Wrapper.OBJECT, type);</span>
<span class="line-added">4842         }</span>
4843     }
4844 
4845     private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
4846         return type == void.class ? zero(type) : identity(type);
4847     }
4848 
4849     /**
4850      * Produces a method handle of the requested type which ignores any arguments, does nothing,
4851      * and returns a suitable default depending on the return type.
4852      * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
4853      * &lt;p&gt;The returned method handle is equivalent to
4854      * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
4855      *
4856      * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
4857      * {@code guardWithTest(pred, target, empty(target.type())}.
4858      * @param type the type of the desired method handle
4859      * @return a constant method handle of the given type, which returns a default value of the given return type
4860      * @throws NullPointerException if the argument is null
4861      * @see MethodHandles#zero
4862      * @see MethodHandles#constant
4863      * @since 9
4864      */
4865     public static  MethodHandle empty(MethodType type) {
4866         Objects.requireNonNull(type);
4867         return dropArguments(zero(type.returnType()), 0, type.parameterList());
4868     }
4869 
4870     private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
4871     private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
<span class="line-modified">4872         MethodType mtype = MethodType.methodType(ptype, ptype);</span>
4873         LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
4874         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
4875     }
4876 
4877     private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
4878         int pos = btw.ordinal();
4879         MethodHandle zero = ZERO_MHS[pos];
4880         if (zero == null) {
4881             zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
4882         }
4883         if (zero.type().returnType() == rtype)
4884             return zero;
4885         assert(btw == Wrapper.OBJECT);
4886         return makeZero(rtype);
4887     }
4888     private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
4889     private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
4890         MethodType mtype = methodType(rtype);
4891         LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
4892         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandleNatives.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/AccessibleObject.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>