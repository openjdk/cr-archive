<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.Supplier;
  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileManager;
  33 
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.Compound;
  36 import com.sun.tools.javac.code.Directive.ExportsDirective;
  37 import com.sun.tools.javac.code.Directive.RequiresDirective;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  40 import com.sun.tools.javac.jvm.*;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  51 import com.sun.tools.javac.util.List;
  52 
  53 import com.sun.tools.javac.code.Lint;
  54 import com.sun.tools.javac.code.Lint.LintCategory;
  55 import com.sun.tools.javac.code.Scope.WriteableScope;
  56 import com.sun.tools.javac.code.Type.*;
  57 import com.sun.tools.javac.code.Symbol.*;
  58 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  59 import com.sun.tools.javac.tree.JCTree.*;
  60 
  61 import static com.sun.tools.javac.code.Flags.*;
  62 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  63 import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;
  64 import static com.sun.tools.javac.code.Kinds.*;
  65 import static com.sun.tools.javac.code.Kinds.Kind.*;
  66 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  67 import static com.sun.tools.javac.code.TypeTag.*;
  68 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  69 
  70 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  71 
  72 /** Type checking helper class for the attribution phase.
  73  *
  74  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  75  *  If you write code that depends on this, you do so at your own risk.
  76  *  This code and its internal interfaces are subject to change or
  77  *  deletion without notice.&lt;/b&gt;
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;
  98     private final boolean allowValueBasedClasses;
  99 
 100     // The set of lint options currently in effect. It is initialized
 101     // from the context, and then is set/reset as needed by Attr as it
 102     // visits all the various parts of the trees during attribution.
 103     private Lint lint;
 104 
 105     // The method being analyzed in Attr - it is set/reset as needed by
 106     // Attr as it visits new method declarations.
 107     private MethodSymbol method;
 108 
 109     public static Check instance(Context context) {
 110         Check instance = context.get(checkKey);
 111         if (instance == null)
 112             instance = new Check(context);
 113         return instance;
 114     }
 115 
 116     protected Check(Context context) {
 117         context.put(checkKey, this);
 118 
 119         names = Names.instance(context);
 120         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 121             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 122             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 123         log = Log.instance(context);
 124         rs = Resolve.instance(context);
 125         syms = Symtab.instance(context);
 126         enter = Enter.instance(context);
 127         deferredAttr = DeferredAttr.instance(context);
 128         infer = Infer.instance(context);
 129         types = Types.instance(context);
 130         typeAnnotations = TypeAnnotations.instance(context);
 131         diags = JCDiagnostic.Factory.instance(context);
 132         Options options = Options.instance(context);
 133         lint = Lint.instance(context);
 134         fileManager = context.get(JavaFileManager.class);
 135 
 136         source = Source.instance(context);
 137         target = Target.instance(context);
 138         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
 139         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 140         Target target = Target.instance(context);
 141         syntheticNameChar = target.syntheticNameChar();
 142 
 143         profile = Profile.instance(context);
 144         preview = Preview.instance(context);
 145 
 146         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 147         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 148         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 149         boolean enforceMandatoryWarnings = true;
 150 
 151         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 152                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 153         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 154                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 155         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 156                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 157         sunApiHandler = new MandatoryWarningHandler(log, false,
 158                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 159 
 160         deferredLintHandler = DeferredLintHandler.instance(context);
 161 
 162         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 163                 Feature.RECORDS.allowedInSource(source);
 164         allowSealed = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 165                 Feature.SEALED_CLASSES.allowedInSource(source);
 166     }
 167 
 168     /** Character for synthetic names
 169      */
 170     char syntheticNameChar;
 171 
 172     /** A table mapping flat names of all compiled classes for each module in this run
 173      *  to their symbols; maintained from outside.
 174      */
 175     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 176 
 177     /** A handler for messages about deprecated usage.
 178      */
 179     private MandatoryWarningHandler deprecationHandler;
 180 
 181     /** A handler for messages about deprecated-for-removal usage.
 182      */
 183     private MandatoryWarningHandler removalHandler;
 184 
 185     /** A handler for messages about unchecked or unsafe usage.
 186      */
 187     private MandatoryWarningHandler uncheckedHandler;
 188 
 189     /** A handler for messages about using proprietary API.
 190      */
 191     private MandatoryWarningHandler sunApiHandler;
 192 
 193     /** A handler for deferred lint warnings.
 194      */
 195     private DeferredLintHandler deferredLintHandler;
 196 
 197     /** Are records allowed
 198      */
 199     private final boolean allowRecords;
 200 
 201     /** Are sealed classes allowed
 202      */
 203     private final boolean allowSealed;
 204 
 205 /* *************************************************************************
 206  * Errors and Warnings
 207  **************************************************************************/
 208 
 209     Lint setLint(Lint newLint) {
 210         Lint prev = lint;
 211         lint = newLint;
 212         return prev;
 213     }
 214 
 215     MethodSymbol setMethod(MethodSymbol newMethod) {
 216         MethodSymbol prev = method;
 217         method = newMethod;
 218         return prev;
 219     }
 220 
 221     /** Warn about deprecated symbol.
 222      *  @param pos        Position to be used for error reporting.
 223      *  @param sym        The deprecated symbol.
 224      */
 225     void warnDeprecated(DiagnosticPosition pos, Symbol sym) {
 226         if (sym.isDeprecatedForRemoval()) {
 227             if (!lint.isSuppressed(LintCategory.REMOVAL)) {
 228                 if (sym.kind == MDL) {
 229                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemovalModule(sym));
 230                 } else {
 231                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemoval(sym, sym.location()));
 232                 }
 233             }
 234         } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {
 235             if (sym.kind == MDL) {
 236                 deprecationHandler.report(pos, Warnings.HasBeenDeprecatedModule(sym));
 237             } else {
 238                 deprecationHandler.report(pos, Warnings.HasBeenDeprecated(sym, sym.location()));
 239             }
 240         }
 241     }
 242 
 243     /** Warn about deprecated symbol.
 244      *  @param pos        Position to be used for error reporting.
 245      *  @param sym        The deprecated symbol.
 246      */
 247     void warnPreview(DiagnosticPosition pos, Symbol sym) {
 248         warnPreview(pos, Warnings.IsPreview(sym));
 249     }
 250 
 251     /** Log a preview warning.
 252      *  @param pos        Position to be used for error reporting.
 253      *  @param msg        A Warning describing the problem.
 254      */
 255     public void warnPreview(DiagnosticPosition pos, Warning warnKey) {
 256         if (!lint.isSuppressed(LintCategory.PREVIEW))
 257             preview.reportPreviewWarning(pos, warnKey);
 258     }
 259 
 260     /** Warn about unchecked operation.
 261      *  @param pos        Position to be used for error reporting.
 262      *  @param msg        A string describing the problem.
 263      */
 264     public void warnUnchecked(DiagnosticPosition pos, Warning warnKey) {
 265         if (!lint.isSuppressed(LintCategory.UNCHECKED))
 266             uncheckedHandler.report(pos, warnKey);
 267     }
 268 
 269     /** Warn about unsafe vararg method decl.
 270      *  @param pos        Position to be used for error reporting.
 271      */
 272     void warnUnsafeVararg(DiagnosticPosition pos, Warning warnKey) {
 273         if (lint.isEnabled(LintCategory.VARARGS))
 274             log.warning(LintCategory.VARARGS, pos, warnKey);
 275     }
 276 
 277     public void warnStatic(DiagnosticPosition pos, Warning warnKey) {
 278         if (lint.isEnabled(LintCategory.STATIC))
 279             log.warning(LintCategory.STATIC, pos, warnKey);
 280     }
 281 
 282     /** Warn about division by integer constant zero.
 283      *  @param pos        Position to be used for error reporting.
 284      */
 285     void warnDivZero(DiagnosticPosition pos) {
 286         if (lint.isEnabled(LintCategory.DIVZERO))
 287             log.warning(LintCategory.DIVZERO, pos, Warnings.DivZero);
 288     }
 289 
 290     /**
 291      * Report any deferred diagnostics.
 292      */
 293     public void reportDeferredDiagnostics() {
 294         deprecationHandler.reportDeferredDiagnostic();
 295         removalHandler.reportDeferredDiagnostic();
 296         uncheckedHandler.reportDeferredDiagnostic();
 297         sunApiHandler.reportDeferredDiagnostic();
 298     }
 299 
 300 
 301     /** Report a failure to complete a class.
 302      *  @param pos        Position to be used for error reporting.
 303      *  @param ex         The failure to report.
 304      */
 305     public Type completionError(DiagnosticPosition pos, CompletionFailure ex) {
 306         log.error(JCDiagnostic.DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));
 307         return syms.errType;
 308     }
 309 
 310     /** Report an error that wrong type tag was found.
 311      *  @param pos        Position to be used for error reporting.
 312      *  @param required   An internationalized string describing the type tag
 313      *                    required.
 314      *  @param found      The type that was found.
 315      */
 316     Type typeTagError(DiagnosticPosition pos, JCDiagnostic required, Object found) {
 317         // this error used to be raised by the parser,
 318         // but has been delayed to this point:
 319         if (found instanceof Type &amp;&amp; ((Type)found).hasTag(VOID)) {
 320             log.error(pos, Errors.IllegalStartOfType);
 321             return syms.errType;
 322         }
 323         log.error(pos, Errors.TypeFoundReq(found, required));
 324         return types.createErrorType(found instanceof Type ? (Type)found : syms.errType);
 325     }
 326 
 327     /** Report an error that symbol cannot be referenced before super
 328      *  has been called.
 329      *  @param pos        Position to be used for error reporting.
 330      *  @param sym        The referenced symbol.
 331      */
 332     void earlyRefError(DiagnosticPosition pos, Symbol sym) {
 333         log.error(pos, Errors.CantRefBeforeCtorCalled(sym));
 334     }
 335 
 336     /** Report duplicate declaration error.
 337      */
 338     void duplicateError(DiagnosticPosition pos, Symbol sym) {
 339         if (!sym.type.isErroneous()) {
 340             Symbol location = sym.location();
 341             if (location.kind == MTH &amp;&amp;
 342                     ((MethodSymbol)location).isStaticOrInstanceInit()) {
 343                 log.error(pos,
 344                           Errors.AlreadyDefinedInClinit(kindName(sym),
 345                                                         sym,
 346                                                         kindName(sym.location()),
 347                                                         kindName(sym.location().enclClass()),
 348                                                         sym.location().enclClass()));
 349             } else {
 350                 /* dont error if this is a duplicated parameter of a generated canonical constructor
 351                  * as we should have issued an error for the duplicated fields
 352                  */
 353                 if (location.kind != MTH ||
 354                         ((sym.owner.flags_field &amp; GENERATEDCONSTR) == 0) ||
 355                         ((sym.owner.flags_field &amp; RECORD) == 0)) {
 356                     log.error(pos,
 357                             Errors.AlreadyDefined(kindName(sym),
 358                                     sym,
 359                                     kindName(sym.location()),
 360                                     sym.location()));
 361                 }
 362             }
 363         }
 364     }
 365 
 366     /** Report array/varargs duplicate declaration
 367      */
 368     void varargsDuplicateError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
 369         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
 370             log.error(pos, Errors.ArrayAndVarargs(sym1, sym2, sym2.location()));
 371         }
 372     }
 373 
 374 /* ************************************************************************
 375  * duplicate declaration checking
 376  *************************************************************************/
 377 
 378     /** Check that variable does not hide variable with same name in
 379      *  immediately enclosing local scope.
 380      *  @param pos           Position for error reporting.
 381      *  @param v             The symbol.
 382      *  @param s             The scope.
 383      */
 384     void checkTransparentVar(DiagnosticPosition pos, VarSymbol v, Scope s) {
 385         for (Symbol sym : s.getSymbolsByName(v.name)) {
 386             if (sym.owner != v.owner) break;
 387             if (sym.kind == VAR &amp;&amp;
 388                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 389                 v.name != names.error) {
 390                 duplicateError(pos, sym);
 391                 return;
 392             }
 393         }
 394     }
 395 
 396     /** Check that a class or interface does not hide a class or
 397      *  interface with same name in immediately enclosing local scope.
 398      *  @param pos           Position for error reporting.
 399      *  @param c             The symbol.
 400      *  @param s             The scope.
 401      */
 402     void checkTransparentClass(DiagnosticPosition pos, ClassSymbol c, Scope s) {
 403         for (Symbol sym : s.getSymbolsByName(c.name)) {
 404             if (sym.owner != c.owner) break;
 405             if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR) &amp;&amp;
 406                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 407                 c.name != names.error) {
 408                 duplicateError(pos, sym);
 409                 return;
 410             }
 411         }
 412     }
 413 
 414     /** Check that class does not have the same name as one of
 415      *  its enclosing classes, or as a class defined in its enclosing scope.
 416      *  return true if class is unique in its enclosing scope.
 417      *  @param pos           Position for error reporting.
 418      *  @param name          The class name.
 419      *  @param s             The enclosing scope.
 420      */
 421     boolean checkUniqueClassName(DiagnosticPosition pos, Name name, Scope s) {
 422         for (Symbol sym : s.getSymbolsByName(name, NON_RECURSIVE)) {
 423             if (sym.kind == TYP &amp;&amp; sym.name != names.error) {
 424                 duplicateError(pos, sym);
 425                 return false;
 426             }
 427         }
 428         for (Symbol sym = s.owner; sym != null; sym = sym.owner) {
 429             if (sym.kind == TYP &amp;&amp; sym.name == name &amp;&amp; sym.name != names.error) {
 430                 duplicateError(pos, sym);
 431                 return true;
 432             }
 433         }
 434         return true;
 435     }
 436 
 437 /* *************************************************************************
 438  * Class name generation
 439  **************************************************************************/
 440 
 441 
 442     private Map&lt;Pair&lt;Name, Name&gt;, Integer&gt; localClassNameIndexes = new HashMap&lt;&gt;();
 443 
 444     /** Return name of local class.
 445      *  This is of the form   {@code &lt;enclClass&gt; $ n &lt;classname&gt; }
 446      *  where
 447      *    enclClass is the flat name of the enclosing class,
 448      *    classname is the simple name of the local class
 449      */
 450     public Name localClassName(ClassSymbol c) {
 451         Name enclFlatname = c.owner.enclClass().flatname;
 452         String enclFlatnameStr = enclFlatname.toString();
 453         Pair&lt;Name, Name&gt; key = new Pair&lt;&gt;(enclFlatname, c.name);
 454         Integer index = localClassNameIndexes.get(key);
 455         for (int i = (index == null) ? 1 : index; ; i++) {
 456             Name flatname = names.fromString(enclFlatnameStr
 457                     + syntheticNameChar + i + c.name);
 458             if (getCompiled(c.packge().modle, flatname) == null) {
 459                 localClassNameIndexes.put(key, i + 1);
 460                 return flatname;
 461             }
 462         }
 463     }
 464 
 465     public void clearLocalClassNameIndexes(ClassSymbol c) {
 466         if (c.owner != null &amp;&amp; c.owner.kind != NIL) {
 467             localClassNameIndexes.remove(new Pair&lt;&gt;(
 468                     c.owner.enclClass().flatname, c.name));
 469         }
 470     }
 471 
 472     public void newRound() {
 473         compiled.clear();
 474         localClassNameIndexes.clear();
 475     }
 476 
 477     public void clear() {
 478         deprecationHandler.clear();
 479         removalHandler.clear();
 480         uncheckedHandler.clear();
 481         sunApiHandler.clear();
 482     }
 483 
 484     public void putCompiled(ClassSymbol csym) {
 485         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 486     }
 487 
 488     public ClassSymbol getCompiled(ClassSymbol csym) {
 489         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 490     }
 491 
 492     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 493         return compiled.get(Pair.of(msym, flatname));
 494     }
 495 
 496     public void removeCompiled(ClassSymbol csym) {
 497         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 498     }
 499 
 500     /* *************************************************************************
 501  * Type Checking
 502  **************************************************************************/
 503 
 504     /**
 505      * A check context is an object that can be used to perform compatibility
 506      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 507      * vary significantly.
 508      */
 509     public interface CheckContext {
 510         /**
 511          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 512          */
 513         boolean compatible(Type found, Type req, Warner warn);
 514         /**
 515          * Report a check error
 516          */
 517         void report(DiagnosticPosition pos, JCDiagnostic details);
 518         /**
 519          * Obtain a warner for this check context
 520          */
 521         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req);
 522 
 523         public InferenceContext inferenceContext();
 524 
 525         public DeferredAttr.DeferredAttrContext deferredAttrContext();
 526     }
 527 
 528     /**
 529      * This class represent a check context that is nested within another check
 530      * context - useful to check sub-expressions. The default behavior simply
 531      * redirects all method calls to the enclosing check context leveraging
 532      * the forwarding pattern.
 533      */
 534     static class NestedCheckContext implements CheckContext {
 535         CheckContext enclosingContext;
 536 
 537         NestedCheckContext(CheckContext enclosingContext) {
 538             this.enclosingContext = enclosingContext;
 539         }
 540 
 541         public boolean compatible(Type found, Type req, Warner warn) {
 542             return enclosingContext.compatible(found, req, warn);
 543         }
 544 
 545         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 546             enclosingContext.report(pos, details);
 547         }
 548 
 549         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 550             return enclosingContext.checkWarner(pos, found, req);
 551         }
 552 
 553         public InferenceContext inferenceContext() {
 554             return enclosingContext.inferenceContext();
 555         }
 556 
 557         public DeferredAttrContext deferredAttrContext() {
 558             return enclosingContext.deferredAttrContext();
 559         }
 560     }
 561 
 562     /**
 563      * Check context to be used when evaluating assignment/return statements
 564      */
 565     CheckContext basicHandler = new CheckContext() {
 566         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 567             log.error(pos, Errors.ProbFoundReq(details));
 568         }
 569         public boolean compatible(Type found, Type req, Warner warn) {
 570             return types.isAssignable(found, req, warn);
 571         }
 572 
 573         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 574             return convertWarner(pos, found, req);
 575         }
 576 
 577         public InferenceContext inferenceContext() {
 578             return infer.emptyContext;
 579         }
 580 
 581         public DeferredAttrContext deferredAttrContext() {
 582             return deferredAttr.emptyDeferredAttrContext;
 583         }
 584 
 585         @Override
 586         public String toString() {
 587             return &quot;CheckContext: basicHandler&quot;;
 588         }
 589     };
 590 
 591     /** Check that a given type is assignable to a given proto-type.
 592      *  If it is, return the type, otherwise return errType.
 593      *  @param pos        Position to be used for error reporting.
 594      *  @param found      The type that was found.
 595      *  @param req        The type that was required.
 596      */
 597     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 598         return checkType(pos, found, req, basicHandler);
 599     }
 600 
 601     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 602         final InferenceContext inferenceContext = checkContext.inferenceContext();
 603         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 604             inferenceContext.addFreeTypeListener(List.of(req, found),
 605                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));
 606         } else {
 607             if (found.hasTag(CLASS)) {
 608                 if (inferenceContext != infer.emptyContext)
 609                     checkParameterizationWithValues(pos, found);
 610             }
 611         }
 612         if (req.hasTag(ERROR))
 613             return req;
 614         if (req.hasTag(NONE))
 615             return found;
 616         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {
 617             if (found.hasTag(BOT) &amp;&amp; types.isValueBased(req)) {
 618                 log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));
 619             }
 620             return found;
 621         } else {
 622             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 623                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 624                 return types.createErrorType(found);
 625             }
 626             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 627             return types.createErrorType(found);
 628         }
 629     }
 630 
 631     /** Check that a given type can be cast to a given target type.
 632      *  Return the result of the cast.
 633      *  @param pos        Position to be used for error reporting.
 634      *  @param found      The type that is being cast.
 635      *  @param req        The target type of the cast.
 636      */
 637     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 638         return checkCastable(pos, found, req, basicHandler);
 639     }
 640     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 641         if (types.isCastable(found, req, castWarner(pos, found, req))) {
 642             if (types.isValueBased(req)) {
 643                 if (found.hasTag(BOT)) {
 644                     log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));
 645                 } else if (!types.isValueBased(found)) {
 646                     log.warning(pos, Warnings.PotentialNullPollution(found));
 647                 }
 648             }
 649             return req;
 650         } else {
 651             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 652             return types.createErrorType(found);
 653         }
 654     }
 655 
 656     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 657      * The problem should only be reported for non-292 cast
 658      */
 659     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 660         if (!tree.type.isErroneous()
 661                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 662                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 663                 &amp;&amp; !is292targetTypeCast(tree)) {
 664             deferredLintHandler.report(() -&gt; {
 665                 if (lint.isEnabled(LintCategory.CAST))
 666                     log.warning(LintCategory.CAST,
 667                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 668             });
 669         }
 670     }
 671     //where
 672         private boolean is292targetTypeCast(JCTypeCast tree) {
 673             boolean is292targetTypeCast = false;
 674             JCExpression expr = TreeInfo.skipParens(tree.expr);
 675             if (expr.hasTag(APPLY)) {
 676                 JCMethodInvocation apply = (JCMethodInvocation)expr;
 677                 Symbol sym = TreeInfo.symbol(apply.meth);
 678                 is292targetTypeCast = sym != null &amp;&amp;
 679                     sym.kind == MTH &amp;&amp;
 680                     (sym.flags() &amp; HYPOTHETICAL) != 0;
 681             }
 682             return is292targetTypeCast;
 683         }
 684 
 685         private static final boolean ignoreAnnotatedCasts = true;
 686 
 687     /** Check that a type is within some bounds.
 688      *
 689      *  Used in TypeApply to verify that, e.g., X in {@code V&lt;X&gt;} is a valid
 690      *  type argument.
 691      *  @param a             The type that should be bounded by bs.
 692      *  @param bound         The bound.
 693      */
 694     private boolean checkExtends(Type a, Type bound) {
 695          if (a.isUnbound()) {
 696              return true;
 697          } else if (!a.hasTag(WILDCARD)) {
 698              a = types.cvarUpperBound(a);
 699              return types.isSubtype(a, bound);
 700          } else if (a.isExtendsBound()) {
 701              return types.isCastable(bound, types.wildUpperBound(a), types.noWarnings);
 702          } else if (a.isSuperBound()) {
 703              return !types.notSoftSubtype(types.wildLowerBound(a), bound);
 704          }
 705          return true;
 706      }
 707 
 708     /** Check that type is different from &#39;void&#39;.
 709      *  @param pos           Position to be used for error reporting.
 710      *  @param t             The type to be checked.
 711      */
 712     Type checkNonVoid(DiagnosticPosition pos, Type t) {
 713         if (t.hasTag(VOID)) {
 714             log.error(pos, Errors.VoidNotAllowedHere);
 715             return types.createErrorType(t);
 716         } else {
 717             return t;
 718         }
 719     }
 720 
 721     Type checkClassOrArrayType(DiagnosticPosition pos, Type t) {
 722         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ARRAY) &amp;&amp; !t.hasTag(ERROR)) {
 723             return typeTagError(pos,
 724                                 diags.fragment(Fragments.TypeReqClassArray),
 725                                 asTypeParam(t));
 726         } else {
 727             return t;
 728         }
 729     }
 730 
 731     /** Check that type is a class or interface type.
 732      *  @param pos           Position to be used for error reporting.
 733      *  @param t             The type to be checked.
 734      */
 735     Type checkClassType(DiagnosticPosition pos, Type t) {
 736         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 737             return typeTagError(pos,
 738                                 diags.fragment(Fragments.TypeReqClass),
 739                                 asTypeParam(t));
 740         } else {
 741             return t;
 742         }
 743     }
 744     //where
 745         private Object asTypeParam(Type t) {
 746             return (t.hasTag(TYPEVAR))
 747                                     ? diags.fragment(Fragments.TypeParameter(t))
 748                                     : t;
 749         }
 750 
 751     void checkConstraintsOfInlineSuper(DiagnosticPosition pos, ClassSymbol c) {
 752         for(Type st = types.supertype(c.type); st != Type.noType; st = types.supertype(st)) {
 753             if (st == null || st.tsym == null || st.tsym.kind == ERR)
 754                 return;
 755             if  (st.tsym == syms.objectType.tsym)
 756                 return;
 757             if (!st.tsym.isAbstract()) {
 758                 log.error(pos, Errors.ConcreteSupertypeForInlineClass(c, st));
 759             }
 760             if ((st.tsym.flags() &amp; HASINITBLOCK) != 0) {
 761                 log.error(pos, Errors.SuperClassDeclaresInitBlock(c, st));
 762             }
 763             // No instance fields and no arged constructors both mean inner classes cannot be inline supers.
 764             Type encl = st.getEnclosingType();
 765             if (encl != null &amp;&amp; encl.hasTag(CLASS)) {
 766                 log.error(pos, Errors.SuperClassCannotBeInner(c, st));
 767             }
 768             for (Symbol s : st.tsym.members().getSymbols(NON_RECURSIVE)) {
 769                 switch (s.kind) {
 770                 case VAR:
 771                     if ((s.flags() &amp; STATIC) == 0) {
 772                         log.error(pos, Errors.SuperFieldNotAllowed(s, c, st));
 773                     }
 774                     break;
 775                 case MTH:
 776                     if ((s.flags() &amp; SYNCHRONIZED) != 0) {
 777                         log.error(pos, Errors.SuperMethodCannotBeSynchronized(s, c, st));
 778                     } else if (s.isConstructor()) {
 779                         MethodSymbol m = (MethodSymbol)s;
 780                         if (m.getParameters().size() &gt; 0) {
 781                             log.error(pos, Errors.SuperConstructorCannotTakeArguments(m, c, st));
 782                         } else {
 783                             if ((m.flags() &amp; (GENERATEDCONSTR | EMPTYNOARGCONSTR)) == 0) {
 784                                 log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, c, st));
 785                             }
 786                         }
 787                     }
 788                     break;
 789                 }
 790             }
 791         }
 792     }
 793 
 794     /** Check that type is a valid qualifier for a constructor reference expression
 795      */
<a name="1" id="anc1"></a><span class="line-modified"> 796     Type checkConstructorRefType(JCExpression expr, Type t) {</span>
<span class="line-modified"> 797         t = checkClassOrArrayType(expr, t);</span>
 798         if (t.hasTag(CLASS)) {
 799             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
<a name="2" id="anc2"></a><span class="line-modified"> 800                 log.error(expr, Errors.AbstractCantBeInstantiated(t.tsym));</span>
 801                 t = types.createErrorType(t);
 802             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
<a name="3" id="anc3"></a><span class="line-modified"> 803                 log.error(expr, Errors.EnumCantBeInstantiated);</span>
 804                 t = types.createErrorType(t);
 805             } else {
<a name="4" id="anc4"></a><span class="line-modified"> 806                 // Projection types may not be mentioned in constructor references</span>
<span class="line-added"> 807                 if (expr.hasTag(SELECT)) {</span>
<span class="line-added"> 808                     JCFieldAccess fieldAccess = (JCFieldAccess) expr;</span>
<span class="line-added"> 809                     if (fieldAccess.selected.type.isValue() &amp;&amp;</span>
<span class="line-added"> 810                             (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {</span>
<span class="line-added"> 811                         log.error(expr, Errors.ProjectionCantBeInstantiated);</span>
<span class="line-added"> 812                         t = types.createErrorType(t);</span>
<span class="line-added"> 813                     }</span>
<span class="line-added"> 814                 }</span>
<span class="line-added"> 815                 t = checkClassType(expr, t, true);</span>
 816             }
 817         } else if (t.hasTag(ARRAY)) {
 818             if (!types.isReifiable(((ArrayType)t).elemtype)) {
<a name="5" id="anc5"></a><span class="line-modified"> 819                 log.error(expr, Errors.GenericArrayCreation);</span>
 820                 t = types.createErrorType(t);
 821             }
 822         }
 823         return t;
 824     }
 825 
 826     /** Check that type is a class or interface type.
 827      *  @param pos           Position to be used for error reporting.
 828      *  @param t             The type to be checked.
 829      *  @param noBounds    True if type bounds are illegal here.
 830      */
 831     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 832         t = checkClassType(pos, t);
 833         if (noBounds &amp;&amp; t.isParameterized()) {
 834             List&lt;Type&gt; args = t.getTypeArguments();
 835             while (args.nonEmpty()) {
 836                 if (args.head.hasTag(WILDCARD))
 837                     return typeTagError(pos,
 838                                         diags.fragment(Fragments.TypeReqExact),
 839                                         args.head);
 840                 args = args.tail;
 841             }
 842         }
 843         return t;
 844     }
 845 
 846     /** Check that type is a reference type, i.e. a class, interface or array type
 847      *  or a type variable.
 848      *  @param pos           Position to be used for error reporting.
 849      *  @param t             The type to be checked.
 850      *  @param valueOK       If false, a value class does not qualify
 851      */
 852     Type checkRefType(DiagnosticPosition pos, Type t, boolean valueOK) {
 853         if (t.isReference() &amp;&amp; (valueOK || !types.isValue(t)))
 854             return t;
 855         else
 856             return typeTagError(pos,
 857                                 diags.fragment(Fragments.TypeReqRef),
 858                                 t);
 859     }
 860 
 861     /** Check that type is a reference type, i.e. a class, interface or array type
 862      *  or a type variable.
 863      *  @param pos           Position to be used for error reporting.
 864      *  @param t             The type to be checked.
 865      */
 866     Type checkRefType(DiagnosticPosition pos, Type t) {
 867         return checkRefType(pos, t, true);
 868     }
 869 
 870     /** Check that each type is a reference type, i.e. a class, interface or array type
 871      *  or a type variable.
 872      *  @param trees         Original trees, used for error reporting.
 873      *  @param types         The types to be checked.
 874      */
 875     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 876         List&lt;JCExpression&gt; tl = trees;
 877         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
 878             l.head = checkRefType(tl.head.pos(), l.head, false);
 879             tl = tl.tail;
 880         }
 881         return types;
 882     }
 883 
 884     /** Check that type is a null or reference type.
 885      *  @param pos           Position to be used for error reporting.
 886      *  @param t             The type to be checked.
 887      */
 888     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 889         if (t.isReference() || t.hasTag(BOT))
 890             return t;
 891         else
 892             return typeTagError(pos,
 893                                 diags.fragment(Fragments.TypeReqRef),
 894                                 t);
 895     }
 896 
 897     /** Check that flag set does not contain elements of two conflicting sets. s
 898      *  Return true if it doesn&#39;t.
 899      *  @param pos           Position to be used for error reporting.
 900      *  @param flags         The set of flags to be checked.
 901      *  @param set1          Conflicting flags set #1.
 902      *  @param set2          Conflicting flags set #2.
 903      */
 904     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 905         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 906             log.error(pos,
 907                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 908                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 909             return false;
 910         } else
 911             return true;
 912     }
 913 
 914     void checkParameterizationWithValues(DiagnosticPosition pos, Type t) {
 915         valueParameterizationChecker.visit(t, pos);
 916     }
 917 
 918     /** valueParameterizationChecker: A type visitor that descends down the given type looking for instances of value types
 919      *  being used as type arguments and issues error against those usages.
 920      */
 921     private final Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt; valueParameterizationChecker = new Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt;() {
 922 
 923         @Override
 924         public Void visitType(Type t, DiagnosticPosition pos) {
 925             return null;
 926         }
 927 
 928         @Override
 929         public Void visitClassType(ClassType t, DiagnosticPosition pos) {
 930             for (Type targ : t.allparams()) {
 931                 if (types.isValue(targ)) {
 932                     log.error(pos, Errors.GenericParameterizationWithValueType(t));
 933                 }
 934                 visit(targ, pos);
 935             }
 936             return null;
 937         }
 938 
 939         @Override
 940         public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {
 941              return null;
 942         }
 943 
 944         @Override
 945         public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {
 946             return null;
 947         }
 948 
 949         @Override
 950         public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {
 951             return visit(t.elemtype, pos);
 952         }
 953 
 954         @Override
 955         public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {
 956             return visit(t.type, pos);
 957         }
 958     };
 959 
 960 
 961 
 962     /** Check that usage of diamond operator is correct (i.e. diamond should not
 963      * be used with non-generic classes or in anonymous class creation expressions)
 964      */
 965     Type checkDiamond(JCNewClass tree, Type t) {
 966         if (!TreeInfo.isDiamond(tree) ||
 967                 t.isErroneous()) {
 968             return checkClassType(tree.clazz.pos(), t, true);
 969         } else {
 970             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 971                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 972                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 973             }
 974             if (t.tsym.type.getTypeArguments().isEmpty()) {
 975                 log.error(tree.clazz.pos(),
 976                           Errors.CantApplyDiamond1(t,
 977                                                    Fragments.DiamondNonGeneric(t)));
 978                 return types.createErrorType(t);
 979             } else if (tree.typeargs != null &amp;&amp;
 980                     tree.typeargs.nonEmpty()) {
 981                 log.error(tree.clazz.pos(),
 982                           Errors.CantApplyDiamond1(t,
 983                                                    Fragments.DiamondAndExplicitParams(t)));
 984                 return types.createErrorType(t);
 985             } else {
 986                 return t;
 987             }
 988         }
 989     }
 990 
 991     /** Check that the type inferred using the diamond operator does not contain
 992      *  non-denotable types such as captured types or intersection types.
 993      *  @param t the type inferred using the diamond operator
 994      *  @return  the (possibly empty) list of non-denotable types.
 995      */
 996     List&lt;Type&gt; checkDiamondDenotable(ClassType t) {
 997         ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
 998         for (Type arg : t.allparams()) {
 999             if (!checkDenotable(arg)) {
1000                 buf.append(arg);
1001             }
1002         }
1003         return buf.toList();
1004     }
1005 
1006     public boolean checkDenotable(Type t) {
1007         return denotableChecker.visit(t, null);
1008     }
1009         // where
1010 
1011         /** diamondTypeChecker: A type visitor that descends down the given type looking for non-denotable
1012          *  types. The visit methods return false as soon as a non-denotable type is encountered and true
1013          *  otherwise.
1014          */
1015         private static final Types.SimpleVisitor&lt;Boolean, Void&gt; denotableChecker = new Types.SimpleVisitor&lt;Boolean, Void&gt;() {
1016             @Override
1017             public Boolean visitType(Type t, Void s) {
1018                 return true;
1019             }
1020             @Override
1021             public Boolean visitClassType(ClassType t, Void s) {
1022                 if (t.isUnion() || t.isIntersection()) {
1023                     return false;
1024                 }
1025                 for (Type targ : t.allparams()) {
1026                     if (!visit(targ, s)) {
1027                         return false;
1028                     }
1029                 }
1030                 return true;
1031             }
1032 
1033             @Override
1034             public Boolean visitTypeVar(TypeVar t, Void s) {
1035                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
1036                   (i.e cannot have been produced by inference (18.4))
1037                 */
1038                 return (t.tsym.flags() &amp; SYNTHETIC) == 0;
1039             }
1040 
1041             @Override
1042             public Boolean visitCapturedType(CapturedType t, Void s) {
1043                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
1044                   (i.e cannot have been produced by capture conversion (5.1.10))
1045                 */
1046                 return false;
1047             }
1048 
1049             @Override
1050             public Boolean visitArrayType(ArrayType t, Void s) {
1051                 return visit(t.elemtype, s);
1052             }
1053 
1054             @Override
1055             public Boolean visitWildcardType(WildcardType t, Void s) {
1056                 return visit(t.type, s);
1057             }
1058         };
1059 
1060     void checkVarargsMethodDecl(Env&lt;AttrContext&gt; env, JCMethodDecl tree) {
1061         MethodSymbol m = tree.sym;
1062         boolean hasTrustMeAnno = m.attribute(syms.trustMeType.tsym) != null;
1063         Type varargElemType = null;
1064         if (m.isVarArgs()) {
1065             varargElemType = types.elemtype(tree.params.last().type);
1066         }
1067         if (hasTrustMeAnno &amp;&amp; !isTrustMeAllowedOnMethod(m)) {
1068             if (varargElemType != null) {
1069                 JCDiagnostic msg = Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ?
1070                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargs(m)) :
1071                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargsFinalOnly(m));
1072                 log.error(tree,
1073                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
1074                                                            msg));
1075             } else {
1076                 log.error(tree,
1077                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
1078                                                            Fragments.VarargsTrustmeOnNonVarargsMeth(m)));
1079             }
1080         } else if (hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
1081                             types.isReifiable(varargElemType)) {
1082             warnUnsafeVararg(tree, Warnings.VarargsRedundantTrustmeAnno(
1083                                 syms.trustMeType.tsym,
1084                                 diags.fragment(Fragments.VarargsTrustmeOnReifiableVarargs(varargElemType))));
1085         }
1086         else if (!hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
1087                 !types.isReifiable(varargElemType)) {
1088             warnUnchecked(tree.params.head.pos(), Warnings.UncheckedVarargsNonReifiableType(varargElemType));
1089         }
1090     }
1091     //where
1092         private boolean isTrustMeAllowedOnMethod(Symbol s) {
1093             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
1094                 (s.isConstructor() ||
1095                     (s.flags() &amp; (STATIC | FINAL |
1096                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
1097         }
1098 
1099     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
1100         //check that resulting type is not the null type
1101         if (t.hasTag(BOT)) {
1102             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
1103             return types.createErrorType(t);
1104         } else if (t.hasTag(VOID)) {
1105             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
1106             return types.createErrorType(t);
1107         }
1108 
1109         //upward project the initializer type
1110         Type varType = types.upward(t, types.captures(t));
1111         if (varType.hasTag(CLASS)) {
1112             checkParameterizationWithValues(pos, varType);
1113         }
1114         return varType;
1115     }
1116 
1117     public void checkForSuspectClassLiteralComparison(
1118             final JCBinary tree,
1119             final Type leftType,
1120             final Type rightType) {
1121 
1122         if (lint.isEnabled(LintCategory.MIGRATION)) {
1123             if (isInvocationOfGetClass(tree.lhs) &amp;&amp; isClassOfSomeInterface(rightType) ||
1124                     isInvocationOfGetClass(tree.rhs) &amp;&amp; isClassOfSomeInterface(leftType)) {
1125                 log.warning(LintCategory.MIGRATION, tree.pos(), Warnings.GetClassComparedWithInterface);
1126             }
1127         }
1128     }
1129     //where
1130     private boolean isClassOfSomeInterface(Type someClass) {
1131         if (someClass.tsym.flatName() == names.java_lang_Class) {
1132             List&lt;Type&gt; arguments = someClass.getTypeArguments();
1133             if (arguments.length() == 1) {
1134                 return arguments.head.isInterface();
1135             }
1136         }
1137         return false;
1138     }
1139     //where
1140     private boolean isInvocationOfGetClass(JCExpression tree) {
1141         tree = TreeInfo.skipParens(tree);
1142         if (tree.hasTag(APPLY)) {
1143             JCMethodInvocation apply = (JCMethodInvocation)tree;
1144             MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(apply.meth);
1145             return msym.name == names.getClass &amp;&amp; msym.implementedIn(syms.objectType.tsym, types) != null;
1146         }
1147         return false;
1148     }
1149 
1150     Type checkMethod(final Type mtype,
1151             final Symbol sym,
1152             final Env&lt;AttrContext&gt; env,
1153             final List&lt;JCExpression&gt; argtrees,
1154             final List&lt;Type&gt; argtypes,
1155             final boolean useVarargs,
1156             InferenceContext inferenceContext) {
1157         // System.out.println(&quot;call   : &quot; + env.tree);
1158         // System.out.println(&quot;method : &quot; + owntype);
1159         // System.out.println(&quot;actuals: &quot; + argtypes);
1160         if (inferenceContext.free(mtype)) {
1161             inferenceContext.addFreeTypeListener(List.of(mtype),
1162                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
1163             return mtype;
1164         }
1165         Type owntype = mtype;
1166         List&lt;Type&gt; formals = owntype.getParameterTypes();
1167         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
1168         if (nonInferred.length() != formals.length()) nonInferred = formals;
1169         Type last = useVarargs ? formals.last() : null;
1170         if (sym.name == names.init &amp;&amp; sym.owner == syms.enumSym) {
1171             formals = formals.tail.tail;
1172             nonInferred = nonInferred.tail.tail;
1173         }
1174         if ((sym.flags() &amp; ANONCONSTR_BASED) != 0) {
1175             formals = formals.tail;
1176             nonInferred = nonInferred.tail;
1177         }
1178         List&lt;JCExpression&gt; args = argtrees;
1179         if (args != null) {
1180             //this is null when type-checking a method reference
1181             while (formals.head != last) {
1182                 JCTree arg = args.head;
1183                 Warner warn = convertWarner(arg.pos(), arg.type, nonInferred.head);
1184                 assertConvertible(arg, arg.type, formals.head, warn);
1185                 args = args.tail;
1186                 formals = formals.tail;
1187                 nonInferred = nonInferred.tail;
1188             }
1189             if (useVarargs) {
1190                 Type varArg = types.elemtype(last);
1191                 while (args.tail != null) {
1192                     JCTree arg = args.head;
1193                     Warner warn = convertWarner(arg.pos(), arg.type, varArg);
1194                     assertConvertible(arg, arg.type, varArg, warn);
1195                     args = args.tail;
1196                 }
1197             } else if ((sym.flags() &amp; (VARARGS | SIGNATURE_POLYMORPHIC)) == VARARGS) {
1198                 // non-varargs call to varargs method
1199                 Type varParam = owntype.getParameterTypes().last();
1200                 Type lastArg = argtypes.last();
1201                 if (types.isSubtypeUnchecked(lastArg, types.elemtype(varParam)) &amp;&amp;
1202                     !types.isSameType(types.erasure(varParam), types.erasure(lastArg)))
1203                     log.warning(argtrees.last().pos(),
1204                                 Warnings.InexactNonVarargsCall(types.elemtype(varParam),varParam));
1205             }
1206         }
1207         if (useVarargs) {
1208             Type argtype = owntype.getParameterTypes().last();
1209             if (!types.isReifiable(argtype) &amp;&amp;
1210                 (sym.baseSymbol().attribute(syms.trustMeType.tsym) == null ||
1211                  !isTrustMeAllowedOnMethod(sym))) {
1212                 warnUnchecked(env.tree.pos(), Warnings.UncheckedGenericArrayCreation(argtype));
1213             }
1214             TreeInfo.setVarargsElement(env.tree, types.elemtype(argtype));
1215          }
1216          return owntype;
1217     }
1218     //where
1219     private void assertConvertible(JCTree tree, Type actual, Type formal, Warner warn) {
1220         if (types.isConvertible(actual, formal, warn))
1221             return;
1222 
1223         if (formal.isCompound()
1224             &amp;&amp; types.isSubtype(actual, types.supertype(formal))
1225             &amp;&amp; types.isSubtypeUnchecked(actual, types.interfaces(formal), warn))
1226             return;
1227     }
1228 
1229     /**
1230      * Check that type &#39;t&#39; is a valid instantiation of a generic class
1231      * (see JLS 4.5)
1232      *
1233      * @param t class type to be checked
1234      * @return true if &#39;t&#39; is well-formed
1235      */
1236     public boolean checkValidGenericType(Type t) {
1237         return firstIncompatibleTypeArg(t) == null;
1238     }
1239     //WHERE
1240         private Type firstIncompatibleTypeArg(Type type) {
1241             List&lt;Type&gt; formals = type.tsym.type.allparams();
1242             List&lt;Type&gt; actuals = type.allparams();
1243             List&lt;Type&gt; args = type.getTypeArguments();
1244             List&lt;Type&gt; forms = type.tsym.type.getTypeArguments();
1245             ListBuffer&lt;Type&gt; bounds_buf = new ListBuffer&lt;&gt;();
1246 
1247             // For matching pairs of actual argument types `a&#39; and
1248             // formal type parameters with declared bound `b&#39; ...
1249             while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1250                 // exact type arguments needs to know their
1251                 // bounds (for upper and lower bound
1252                 // calculations).  So we create new bounds where
1253                 // type-parameters are replaced with actuals argument types.
1254                 bounds_buf.append(types.subst(forms.head.getUpperBound(), formals, actuals));
1255                 args = args.tail;
1256                 forms = forms.tail;
1257             }
1258 
1259             args = type.getTypeArguments();
1260             List&lt;Type&gt; tvars_cap = types.substBounds(formals,
1261                                       formals,
1262                                       types.capture(type).allparams());
1263             while (args.nonEmpty() &amp;&amp; tvars_cap.nonEmpty()) {
1264                 // Let the actual arguments know their bound
1265                 args.head.withTypeVar((TypeVar)tvars_cap.head);
1266                 args = args.tail;
1267                 tvars_cap = tvars_cap.tail;
1268             }
1269 
1270             args = type.getTypeArguments();
1271             List&lt;Type&gt; bounds = bounds_buf.toList();
1272 
1273             while (args.nonEmpty() &amp;&amp; bounds.nonEmpty()) {
1274                 Type actual = args.head;
1275                 if (!isTypeArgErroneous(actual) &amp;&amp;
1276                         !bounds.head.isErroneous() &amp;&amp;
1277                         !checkExtends(actual, bounds.head)) {
1278                     return args.head;
1279                 }
1280                 args = args.tail;
1281                 bounds = bounds.tail;
1282             }
1283 
1284             args = type.getTypeArguments();
1285             bounds = bounds_buf.toList();
1286 
1287             for (Type arg : types.capture(type).getTypeArguments()) {
1288                 if (arg.hasTag(TYPEVAR) &amp;&amp;
1289                         arg.getUpperBound().isErroneous() &amp;&amp;
1290                         !bounds.head.isErroneous() &amp;&amp;
1291                         !isTypeArgErroneous(args.head)) {
1292                     return args.head;
1293                 }
1294                 bounds = bounds.tail;
1295                 args = args.tail;
1296             }
1297 
1298             return null;
1299         }
1300         //where
1301         boolean isTypeArgErroneous(Type t) {
1302             return isTypeArgErroneous.visit(t);
1303         }
1304 
1305         Types.UnaryVisitor&lt;Boolean&gt; isTypeArgErroneous = new Types.UnaryVisitor&lt;Boolean&gt;() {
1306             public Boolean visitType(Type t, Void s) {
1307                 return t.isErroneous();
1308             }
1309             @Override
1310             public Boolean visitTypeVar(TypeVar t, Void s) {
1311                 return visit(t.getUpperBound());
1312             }
1313             @Override
1314             public Boolean visitCapturedType(CapturedType t, Void s) {
1315                 return visit(t.getUpperBound()) ||
1316                         visit(t.getLowerBound());
1317             }
1318             @Override
1319             public Boolean visitWildcardType(WildcardType t, Void s) {
1320                 return visit(t.type);
1321             }
1322         };
1323 
1324     /** Check that given modifiers are legal for given symbol and
1325      *  return modifiers together with any implicit modifiers for that symbol.
1326      *  Warning: we can&#39;t use flags() here since this method
1327      *  is called during class enter, when flags() would cause a premature
1328      *  completion.
1329      *  @param pos           Position to be used for error reporting.
1330      *  @param flags         The set of modifiers given in a definition.
1331      *  @param sym           The defined symbol.
1332      */
1333     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1334         long mask;
1335         long implicit = 0;
1336 
1337         switch (sym.kind) {
1338         case VAR:
1339             if (TreeInfo.isReceiverParam(tree))
1340                 mask = ReceiverParamFlags;
1341             else if (sym.owner.kind != TYP)
1342                 mask = LocalVarFlags;
1343             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1344                 mask = implicit = InterfaceVarFlags;
1345             else {
1346                 mask = VarFlags;
1347                 if (types.isValue(sym.owner.type) &amp;&amp; (flags &amp; STATIC) == 0) {
1348                     implicit |= FINAL;
1349                 }
1350             }
1351             break;
1352         case MTH:
1353             if (sym.name == names.init) {
1354                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1355                     // enum constructors cannot be declared public or
1356                     // protected and must be implicitly or explicitly
1357                     // private
1358                     implicit = PRIVATE;
1359                     mask = PRIVATE;
1360                 } else
1361                     mask = ConstructorFlags;
1362             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1363                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1364                     mask = AnnotationTypeElementMask;
1365                     implicit = PUBLIC | ABSTRACT;
1366                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1367                     mask = InterfaceMethodMask;
1368                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1369                     if ((flags &amp; DEFAULT) != 0) {
1370                         implicit |= ABSTRACT;
1371                     }
1372                 } else {
1373                     mask = implicit = InterfaceMethodFlags;
1374                 }
1375             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1376                 mask = RecordMethodFlags;
1377             } else {
1378                 // instance methods of value types do not have a monitor associated with their `this&#39;
1379                 mask = ((sym.owner.flags_field &amp; VALUE) != 0 &amp;&amp; (flags &amp; Flags.STATIC) == 0) ?
1380                         MethodFlags &amp; ~SYNCHRONIZED : MethodFlags;
1381             }
1382             // Imply STRICTFP if owner has STRICTFP set.
1383             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1384                 ((flags) &amp; Flags.DEFAULT) != 0)
1385                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1386             break;
1387         case TYP:
1388             if (sym.isLocal()) {
1389                 boolean implicitlyStatic = !sym.isAnonymous() &amp;&amp;
1390                         ((flags &amp; RECORD) != 0 || (flags &amp; ENUM) != 0 || (flags &amp; INTERFACE) != 0);
1391                 boolean staticOrImplicitlyStatic = (flags &amp; STATIC) != 0 || implicitlyStatic;
1392                 mask = staticOrImplicitlyStatic &amp;&amp; allowRecords ? StaticLocalFlags : LocalClassFlags;
1393                 implicit = implicitlyStatic ? STATIC : implicit;
1394                 if (staticOrImplicitlyStatic) {
1395                     if (sym.owner.kind == TYP) {
1396                         log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1397                     }
1398                 }
1399             } else if (sym.owner.kind == TYP) {
1400                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : ExtendedMemberClassFlags;
1401                 if (sym.owner.owner.kind == PCK ||
1402                     (sym.owner.flags_field &amp; STATIC) != 0)
1403                     mask |= STATIC;
1404                 else if ((flags &amp; ENUM) != 0 || (flags &amp; RECORD) != 0) {
1405                     log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1406                 }
1407                 // Nested interfaces and enums are always STATIC (Spec ???)
1408                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1409             } else {
1410                 mask = ExtendedClassFlags;
1411             }
1412             // Interfaces are always ABSTRACT
1413             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1414 
1415             if ((flags &amp; ENUM) != 0) {
1416                 // enums can&#39;t be declared abstract, final, sealed or non-sealed or value type
1417                 mask &amp;= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | VALUE);
1418                 implicit |= implicitEnumFinalFlag(tree);
1419             }
1420             if ((flags &amp; RECORD) != 0) {
1421                 // records can&#39;t be declared abstract
1422                 mask &amp;= ~ABSTRACT;
1423                 implicit |= FINAL;
1424             }
1425             // Imply STRICTFP if owner has STRICTFP set.
1426             implicit |= sym.owner.flags_field &amp; STRICTFP;
1427             break;
1428         default:
1429             throw new AssertionError();
1430         }
1431         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1432         if (illegal != 0) {
1433             if ((illegal &amp; INTERFACE) != 0) {
1434                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1435                 mask |= INTERFACE;
1436             }
1437             else {
1438                 log.error(pos,
1439                         Errors.ModNotAllowedHere(asFlagSet(illegal)));
1440             }
1441         }
1442         else if ((sym.kind == TYP ||
1443                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1444                   // in the presence of inner classes. Should it be deleted here?
1445                   checkDisjoint(pos, flags,
1446                                 ABSTRACT,
1447                                 PRIVATE | STATIC | DEFAULT))
1448                  &amp;&amp;
1449                  checkDisjoint(pos, flags,
1450                                 STATIC | PRIVATE,
1451                                 DEFAULT)
1452                  &amp;&amp;
1453                  checkDisjoint(pos, flags,
1454                                ABSTRACT | INTERFACE,
1455                                FINAL | NATIVE | SYNCHRONIZED | VALUE)
1456                  &amp;&amp;
1457                  checkDisjoint(pos, flags,
1458                                PUBLIC,
1459                                PRIVATE | PROTECTED)
1460                  &amp;&amp;
1461                  checkDisjoint(pos, flags,
1462                                PRIVATE,
1463                                PUBLIC | PROTECTED)
1464                  &amp;&amp;
1465                  checkDisjoint(pos, (flags | implicit), // complain against volatile &amp; implcitly final entities too.
1466                                FINAL,
1467                                VOLATILE)
1468                  &amp;&amp;
1469                  (sym.kind == TYP ||
1470                   checkDisjoint(pos, flags,
1471                                 ABSTRACT | NATIVE,
1472                                 STRICTFP))
1473                  &amp;&amp; checkDisjoint(pos, flags,
1474                                 FINAL,
1475                            SEALED | NON_SEALED)
1476                  &amp;&amp; checkDisjoint(pos, flags,
1477                                 SEALED,
1478                            FINAL | NON_SEALED)) {
1479             // skip
1480         }
1481         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1482     }
1483 
1484 
1485     /** Determine if this enum should be implicitly final.
1486      *
1487      *  If the enum has no specialized enum constants, it is final.
1488      *
1489      *  If the enum does have specialized enum constants, it is
1490      *  &lt;i&gt;not&lt;/i&gt; final.
1491      */
1492     private long implicitEnumFinalFlag(JCTree tree) {
1493         if (!tree.hasTag(CLASSDEF)) return 0;
1494         class SpecialTreeVisitor extends JCTree.Visitor {
1495             boolean specialized;
1496             SpecialTreeVisitor() {
1497                 this.specialized = false;
1498             }
1499 
1500             @Override
1501             public void visitTree(JCTree tree) { /* no-op */ }
1502 
1503             @Override
1504             public void visitVarDef(JCVariableDecl tree) {
1505                 if ((tree.mods.flags &amp; ENUM) != 0) {
1506                     if (tree.init instanceof JCNewClass &amp;&amp;
1507                         ((JCNewClass) tree.init).def != null) {
1508                         specialized = true;
1509                     }
1510                 }
1511             }
1512         }
1513 
1514         SpecialTreeVisitor sts = new SpecialTreeVisitor();
1515         JCClassDecl cdef = (JCClassDecl) tree;
1516         for (JCTree defs: cdef.defs) {
1517             defs.accept(sts);
1518             if (sts.specialized) return allowSealed ? SEALED : 0;
1519         }
1520         return FINAL;
1521     }
1522 
1523 /* *************************************************************************
1524  * Type Validation
1525  **************************************************************************/
1526 
1527     /** Validate a type expression. That is,
1528      *  check that all type arguments of a parametric type are within
1529      *  their bounds. This must be done in a second phase after type attribution
1530      *  since a class might have a subclass as type parameter bound. E.g:
1531      *
1532      *  &lt;pre&gt;{@code
1533      *  class B&lt;A extends C&gt; { ... }
1534      *  class C extends B&lt;C&gt; { ... }
1535      *  }&lt;/pre&gt;
1536      *
1537      *  and we can&#39;t make sure that the bound is already attributed because
1538      *  of possible cycles.
1539      *
1540      * Visitor method: Validate a type expression, if it is not null, catching
1541      *  and reporting any completion failures.
1542      */
1543     void validate(JCTree tree, Env&lt;AttrContext&gt; env) {
1544         validate(tree, env, true);
1545     }
1546     void validate(JCTree tree, Env&lt;AttrContext&gt; env, boolean checkRaw) {
1547         new Validator(env).validateTree(tree, checkRaw, true);
1548     }
1549 
1550     /** Visitor method: Validate a list of type expressions.
1551      */
1552     void validate(List&lt;? extends JCTree&gt; trees, Env&lt;AttrContext&gt; env) {
1553         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1554             validate(l.head, env);
1555     }
1556 
1557     /** A visitor class for type validation.
1558      */
1559     class Validator extends JCTree.Visitor {
1560 
1561         boolean checkRaw;
1562         boolean isOuter;
1563         Env&lt;AttrContext&gt; env;
1564 
1565         Validator(Env&lt;AttrContext&gt; env) {
1566             this.env = env;
1567         }
1568 
1569         @Override
1570         public void visitTypeArray(JCArrayTypeTree tree) {
1571             validateTree(tree.elemtype, checkRaw, isOuter);
1572         }
1573 
1574         @Override
1575         public void visitTypeApply(JCTypeApply tree) {
1576             if (tree.type.hasTag(CLASS)) {
1577                 List&lt;JCExpression&gt; args = tree.arguments;
1578                 List&lt;Type&gt; forms = tree.type.tsym.type.getTypeArguments();
1579 
1580                 Type incompatibleArg = firstIncompatibleTypeArg(tree.type);
1581                 if (incompatibleArg != null) {
1582                     for (JCTree arg : tree.arguments) {
1583                         if (arg.type == incompatibleArg) {
1584                             log.error(arg, Errors.NotWithinBounds(incompatibleArg, forms.head));
1585                         }
1586                         forms = forms.tail;
1587                      }
1588                  }
1589 
1590                 forms = tree.type.tsym.type.getTypeArguments();
1591 
1592                 boolean is_java_lang_Class = tree.type.tsym.flatName() == names.java_lang_Class;
1593 
1594                 // For matching pairs of actual argument types `a&#39; and
1595                 // formal type parameters with declared bound `b&#39; ...
1596                 while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1597                     validateTree(args.head,
1598                             !(isOuter &amp;&amp; is_java_lang_Class),
1599                             false);
1600                     args = args.tail;
1601                     forms = forms.tail;
1602                 }
1603 
1604                 // Check that this type is either fully parameterized, or
1605                 // not parameterized at all.
1606                 if (tree.type.getEnclosingType().isRaw())
1607                     log.error(tree.pos(), Errors.ImproperlyFormedTypeInnerRawParam);
1608                 if (tree.clazz.hasTag(SELECT))
1609                     visitSelectInternal((JCFieldAccess)tree.clazz);
1610             }
1611         }
1612 
1613         @Override
1614         public void visitTypeParameter(JCTypeParameter tree) {
1615             validateTrees(tree.bounds, true, isOuter);
1616             checkClassBounds(tree.pos(), tree.type);
1617         }
1618 
1619         @Override
1620         public void visitWildcard(JCWildcard tree) {
1621             if (tree.inner != null)
1622                 validateTree(tree.inner, true, isOuter);
1623         }
1624 
1625         @Override
1626         public void visitSelect(JCFieldAccess tree) {
1627             if (tree.type.hasTag(CLASS)) {
1628                 visitSelectInternal(tree);
1629 
1630                 // Check that this type is either fully parameterized, or
1631                 // not parameterized at all.
1632                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1633                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1634             }
1635         }
1636 
1637         public void visitSelectInternal(JCFieldAccess tree) {
1638             if (tree.type.tsym.isStatic() &amp;&amp;
1639                 tree.selected.type.isParameterized() &amp;&amp;
1640                     (tree.name != names.ref || !tree.type.isReferenceProjection())) {
1641                 // The enclosing type is not a class, so we are
1642                 // looking at a static member type.  However, the
1643                 // qualifying expression is parameterized.
1644                 // Tolerate the pseudo-select V.ref: V&lt;T&gt;.ref will be static if V&lt;T&gt; is and
1645                 // should not be confused as selecting a static member of a parameterized type.
1646                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1647             } else {
1648                 // otherwise validate the rest of the expression
1649                 tree.selected.accept(this);
1650             }
1651         }
1652 
1653         @Override
1654         public void visitAnnotatedType(JCAnnotatedType tree) {
1655             tree.underlyingType.accept(this);
1656         }
1657 
1658         @Override
1659         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1660             if (that.type.hasTag(TypeTag.VOID)) {
1661                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1662             }
1663             super.visitTypeIdent(that);
1664         }
1665 
1666         /** Default visitor method: do nothing.
1667          */
1668         @Override
1669         public void visitTree(JCTree tree) {
1670         }
1671 
1672         public void validateTree(JCTree tree, boolean checkRaw, boolean isOuter) {
1673             if (tree != null) {
1674                 boolean prevCheckRaw = this.checkRaw;
1675                 this.checkRaw = checkRaw;
1676                 this.isOuter = isOuter;
1677 
1678                 try {
1679                     tree.accept(this);
1680                     if (checkRaw)
1681                         checkRaw(tree, env);
1682                 } catch (CompletionFailure ex) {
1683                     completionError(tree.pos(), ex);
1684                 } finally {
1685                     this.checkRaw = prevCheckRaw;
1686                 }
1687             }
1688         }
1689 
1690         public void validateTrees(List&lt;? extends JCTree&gt; trees, boolean checkRaw, boolean isOuter) {
1691             for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1692                 validateTree(l.head, checkRaw, isOuter);
1693         }
1694     }
1695 
1696     void checkRaw(JCTree tree, Env&lt;AttrContext&gt; env) {
1697         if (lint.isEnabled(LintCategory.RAW) &amp;&amp;
1698             tree.type.hasTag(CLASS) &amp;&amp;
1699             !TreeInfo.isDiamond(tree) &amp;&amp;
1700             !withinAnonConstr(env) &amp;&amp;
1701             tree.type.isRaw()) {
1702             log.warning(LintCategory.RAW,
1703                     tree.pos(), Warnings.RawClassUse(tree.type, tree.type.tsym.type));
1704         }
1705     }
1706     //where
1707         private boolean withinAnonConstr(Env&lt;AttrContext&gt; env) {
1708             return env.enclClass.name.isEmpty() &amp;&amp;
1709                     env.enclMethod != null &amp;&amp; env.enclMethod.name == names.init;
1710         }
1711 
1712 /* *************************************************************************
1713  * Exception checking
1714  **************************************************************************/
1715 
1716     /* The following methods treat classes as sets that contain
1717      * the class itself and all their subclasses
1718      */
1719 
1720     /** Is given type a subtype of some of the types in given list?
1721      */
1722     boolean subset(Type t, List&lt;Type&gt; ts) {
1723         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1724             if (types.isSubtype(t, l.head)) return true;
1725         return false;
1726     }
1727 
1728     /** Is given type a subtype or supertype of
1729      *  some of the types in given list?
1730      */
1731     boolean intersects(Type t, List&lt;Type&gt; ts) {
1732         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1733             if (types.isSubtype(t, l.head) || types.isSubtype(l.head, t)) return true;
1734         return false;
1735     }
1736 
1737     /** Add type set to given type list, unless it is a subclass of some class
1738      *  in the list.
1739      */
1740     List&lt;Type&gt; incl(Type t, List&lt;Type&gt; ts) {
1741         return subset(t, ts) ? ts : excl(t, ts).prepend(t);
1742     }
1743 
1744     /** Remove type set from type set list.
1745      */
1746     List&lt;Type&gt; excl(Type t, List&lt;Type&gt; ts) {
1747         if (ts.isEmpty()) {
1748             return ts;
1749         } else {
1750             List&lt;Type&gt; ts1 = excl(t, ts.tail);
1751             if (types.isSubtype(ts.head, t)) return ts1;
1752             else if (ts1 == ts.tail) return ts;
1753             else return ts1.prepend(ts.head);
1754         }
1755     }
1756 
1757     /** Form the union of two type set lists.
1758      */
1759     List&lt;Type&gt; union(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1760         List&lt;Type&gt; ts = ts1;
1761         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1762             ts = incl(l.head, ts);
1763         return ts;
1764     }
1765 
1766     /** Form the difference of two type lists.
1767      */
1768     List&lt;Type&gt; diff(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1769         List&lt;Type&gt; ts = ts1;
1770         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1771             ts = excl(l.head, ts);
1772         return ts;
1773     }
1774 
1775     /** Form the intersection of two type lists.
1776      */
1777     public List&lt;Type&gt; intersect(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1778         List&lt;Type&gt; ts = List.nil();
1779         for (List&lt;Type&gt; l = ts1; l.nonEmpty(); l = l.tail)
1780             if (subset(l.head, ts2)) ts = incl(l.head, ts);
1781         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1782             if (subset(l.head, ts1)) ts = incl(l.head, ts);
1783         return ts;
1784     }
1785 
1786     /** Is exc an exception symbol that need not be declared?
1787      */
1788     boolean isUnchecked(ClassSymbol exc) {
1789         return
1790             exc.kind == ERR ||
1791             exc.isSubClass(syms.errorType.tsym, types) ||
1792             exc.isSubClass(syms.runtimeExceptionType.tsym, types);
1793     }
1794 
1795     /** Is exc an exception type that need not be declared?
1796      */
1797     boolean isUnchecked(Type exc) {
1798         return
1799             (exc.hasTag(TYPEVAR)) ? isUnchecked(types.supertype(exc)) :
1800             (exc.hasTag(CLASS)) ? isUnchecked((ClassSymbol)exc.tsym) :
1801             exc.hasTag(BOT);
1802     }
1803 
1804     boolean isChecked(Type exc) {
1805         return !isUnchecked(exc);
1806     }
1807 
1808     /** Same, but handling completion failures.
1809      */
1810     boolean isUnchecked(DiagnosticPosition pos, Type exc) {
1811         try {
1812             return isUnchecked(exc);
1813         } catch (CompletionFailure ex) {
1814             completionError(pos, ex);
1815             return true;
1816         }
1817     }
1818 
1819     /** Is exc handled by given exception list?
1820      */
1821     boolean isHandled(Type exc, List&lt;Type&gt; handled) {
1822         return isUnchecked(exc) || subset(exc, handled);
1823     }
1824 
1825     /** Return all exceptions in thrown list that are not in handled list.
1826      *  @param thrown     The list of thrown exceptions.
1827      *  @param handled    The list of handled exceptions.
1828      */
1829     List&lt;Type&gt; unhandled(List&lt;Type&gt; thrown, List&lt;Type&gt; handled) {
1830         List&lt;Type&gt; unhandled = List.nil();
1831         for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1832             if (!isHandled(l.head, handled)) unhandled = unhandled.prepend(l.head);
1833         return unhandled;
1834     }
1835 
1836 /* *************************************************************************
1837  * Overriding/Implementation checking
1838  **************************************************************************/
1839 
1840     /** The level of access protection given by a flag set,
1841      *  where PRIVATE is highest and PUBLIC is lowest.
1842      */
1843     static int protection(long flags) {
1844         switch ((short)(flags &amp; AccessFlags)) {
1845         case PRIVATE: return 3;
1846         case PROTECTED: return 1;
1847         default:
1848         case PUBLIC: return 0;
1849         case 0: return 2;
1850         }
1851     }
1852 
1853     /** A customized &quot;cannot override&quot; error message.
1854      *  @param m      The overriding method.
1855      *  @param other  The overridden method.
1856      *  @return       An internationalized string.
1857      */
1858     Fragment cannotOverride(MethodSymbol m, MethodSymbol other) {
1859         Symbol mloc = m.location();
1860         Symbol oloc = other.location();
1861 
1862         if ((other.owner.flags() &amp; INTERFACE) == 0)
1863             return Fragments.CantOverride(m, mloc, other, oloc);
1864         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1865             return Fragments.CantImplement(m, mloc, other, oloc);
1866         else
1867             return Fragments.ClashesWith(m, mloc, other, oloc);
1868     }
1869 
1870     /** A customized &quot;override&quot; warning message.
1871      *  @param m      The overriding method.
1872      *  @param other  The overridden method.
1873      *  @return       An internationalized string.
1874      */
1875     Fragment uncheckedOverrides(MethodSymbol m, MethodSymbol other) {
1876         Symbol mloc = m.location();
1877         Symbol oloc = other.location();
1878 
1879         if ((other.owner.flags() &amp; INTERFACE) == 0)
1880             return Fragments.UncheckedOverride(m, mloc, other, oloc);
1881         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1882             return Fragments.UncheckedImplement(m, mloc, other, oloc);
1883         else
1884             return Fragments.UncheckedClashWith(m, mloc, other, oloc);
1885     }
1886 
1887     /** A customized &quot;override&quot; warning message.
1888      *  @param m      The overriding method.
1889      *  @param other  The overridden method.
1890      *  @return       An internationalized string.
1891      */
1892     Fragment varargsOverrides(MethodSymbol m, MethodSymbol other) {
1893         Symbol mloc = m.location();
1894         Symbol oloc = other.location();
1895 
1896         if ((other.owner.flags() &amp; INTERFACE) == 0)
1897             return Fragments.VarargsOverride(m, mloc, other, oloc);
1898         else  if ((m.owner.flags() &amp; INTERFACE) == 0)
1899             return Fragments.VarargsImplement(m, mloc, other, oloc);
1900         else
1901             return Fragments.VarargsClashWith(m, mloc, other, oloc);
1902     }
1903 
1904     /** Check that this method conforms with overridden method &#39;other&#39;.
1905      *  where `origin&#39; is the class where checking started.
1906      *  Complications:
1907      *  (1) Do not check overriding of synthetic methods
1908      *      (reason: they might be final).
1909      *      todo: check whether this is still necessary.
1910      *  (2) Admit the case where an interface proxy throws fewer exceptions
1911      *      than the method it implements. Augment the proxy methods with the
1912      *      undeclared exceptions in this case.
1913      *  (3) When generics are enabled, admit the case where an interface proxy
1914      *      has a result type
1915      *      extended by the result type of the method it implements.
1916      *      Change the proxies result type to the smaller type in this case.
1917      *
1918      *  @param tree         The tree from which positions
1919      *                      are extracted for errors.
1920      *  @param m            The overriding method.
1921      *  @param other        The overridden method.
1922      *  @param origin       The class of which the overriding method
1923      *                      is a member.
1924      */
1925     void checkOverride(JCTree tree,
1926                        MethodSymbol m,
1927                        MethodSymbol other,
1928                        ClassSymbol origin) {
1929         // Don&#39;t check overriding of synthetic methods or by bridge methods.
1930         if ((m.flags() &amp; (SYNTHETIC|BRIDGE)) != 0 || (other.flags() &amp; SYNTHETIC) != 0) {
1931             return;
1932         }
1933 
1934         // Error if static method overrides instance method (JLS 8.4.6.2).
1935         if ((m.flags() &amp; STATIC) != 0 &amp;&amp;
1936                    (other.flags() &amp; STATIC) == 0) {
1937             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1938                       Errors.OverrideStatic(cannotOverride(m, other)));
1939             m.flags_field |= BAD_OVERRIDE;
1940             return;
1941         }
1942 
1943         // Error if instance method overrides static or final
1944         // method (JLS 8.4.6.1).
1945         if ((other.flags() &amp; FINAL) != 0 ||
1946                  (m.flags() &amp; STATIC) == 0 &amp;&amp;
1947                  (other.flags() &amp; STATIC) != 0) {
1948             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1949                       Errors.OverrideMeth(cannotOverride(m, other),
1950                                           asFlagSet(other.flags() &amp; (FINAL | STATIC))));
1951             m.flags_field |= BAD_OVERRIDE;
1952             return;
1953         }
1954 
1955         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1956             // handled in validateAnnotationMethod
1957             return;
1958         }
1959 
1960         // Error if overriding method has weaker access (JLS 8.4.6.3).
1961         if (protection(m.flags()) &gt; protection(other.flags())) {
1962             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1963                       (other.flags() &amp; AccessFlags) == 0 ?
1964                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1965                                                           &quot;package&quot;) :
1966                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1967                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1968             m.flags_field |= BAD_OVERRIDE;
1969             return;
1970         }
1971 
1972         if (origin.isValue() &amp;&amp; other.owner == syms.objectType.tsym &amp;&amp; m.type.getParameterTypes().size() == 0) {
1973             if (m.name == names.clone || m.name == names.finalize) {
1974                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1975                         Errors.InlineClassMayNotOverride(m.name));
1976                 m.flags_field |= BAD_OVERRIDE;
1977                 return;
1978             }
1979         }
1980 
1981         Type mt = types.memberType(origin.type, m);
1982         Type ot = types.memberType(origin.type, other);
1983         // Error if overriding result type is different
1984         // (or, in the case of generics mode, not a subtype) of
1985         // overridden result type. We have to rename any type parameters
1986         // before comparing types.
1987         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1988         List&lt;Type&gt; otvars = ot.getTypeArguments();
1989         Type mtres = mt.getReturnType();
1990         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1991 
1992         overrideWarner.clear();
1993         boolean resultTypesOK =
1994             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1995         if (!resultTypesOK) {
1996             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1997                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1998                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1999                                         other.location()), mtres, otres));
2000                 m.flags_field |= BAD_OVERRIDE;
2001             } else {
2002                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
2003                           Errors.OverrideIncompatibleRet(cannotOverride(m, other), mtres, otres));
2004                 m.flags_field |= BAD_OVERRIDE;
2005             }
2006             return;
2007         } else if (overrideWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
2008             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
2009                     Warnings.OverrideUncheckedRet(uncheckedOverrides(m, other), mtres, otres));
2010         }
2011 
2012         // Error if overriding method throws an exception not reported
2013         // by overridden method.
2014         List&lt;Type&gt; otthrown = types.subst(ot.getThrownTypes(), otvars, mtvars);
2015         List&lt;Type&gt; unhandledErased = unhandled(mt.getThrownTypes(), types.erasure(otthrown));
2016         List&lt;Type&gt; unhandledUnerased = unhandled(mt.getThrownTypes(), otthrown);
2017         if (unhandledErased.nonEmpty()) {
2018             log.error(TreeInfo.diagnosticPositionFor(m, tree),
2019                       Errors.OverrideMethDoesntThrow(cannotOverride(m, other), unhandledUnerased.head));
2020             m.flags_field |= BAD_OVERRIDE;
2021             return;
2022         }
2023         else if (unhandledUnerased.nonEmpty()) {
2024             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
2025                           Warnings.OverrideUncheckedThrown(cannotOverride(m, other), unhandledUnerased.head));
2026             return;
2027         }
2028 
2029         // Optional warning if varargs don&#39;t agree
2030         if ((((m.flags() ^ other.flags()) &amp; Flags.VARARGS) != 0)
2031             &amp;&amp; lint.isEnabled(LintCategory.OVERRIDES)) {
2032             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
2033                         ((m.flags() &amp; Flags.VARARGS) != 0)
2034                         ? Warnings.OverrideVarargsMissing(varargsOverrides(m, other))
2035                         : Warnings.OverrideVarargsExtra(varargsOverrides(m, other)));
2036         }
2037 
2038         // Warn if instance method overrides bridge method (compiler spec ??)
2039         if ((other.flags() &amp; BRIDGE) != 0) {
2040             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
2041                         Warnings.OverrideBridge(uncheckedOverrides(m, other)));
2042         }
2043 
2044         // Warn if a deprecated method overridden by a non-deprecated one.
2045         if (!isDeprecatedOverrideIgnorable(other, origin)) {
2046             Lint prevLint = setLint(lint.augment(m));
2047             try {
2048                 checkDeprecated(() -&gt; TreeInfo.diagnosticPositionFor(m, tree), m, other);
2049             } finally {
2050                 setLint(prevLint);
2051             }
2052         }
2053     }
2054     // where
2055         private boolean isDeprecatedOverrideIgnorable(MethodSymbol m, ClassSymbol origin) {
2056             // If the method, m, is defined in an interface, then ignore the issue if the method
2057             // is only inherited via a supertype and also implemented in the supertype,
2058             // because in that case, we will rediscover the issue when examining the method
2059             // in the supertype.
2060             // If the method, m, is not defined in an interface, then the only time we need to
2061             // address the issue is when the method is the supertype implementation: any other
2062             // case, we will have dealt with when examining the supertype classes
2063             ClassSymbol mc = m.enclClass();
2064             Type st = types.supertype(origin.type);
2065             if (!st.hasTag(CLASS))
2066                 return true;
2067             MethodSymbol stimpl = m.implementation((ClassSymbol)st.tsym, types, false);
2068 
2069             if (mc != null &amp;&amp; ((mc.flags() &amp; INTERFACE) != 0)) {
2070                 List&lt;Type&gt; intfs = types.interfaces(origin.type);
2071                 return (intfs.contains(mc.type) ? false : (stimpl != null));
2072             }
2073             else
2074                 return (stimpl != m);
2075         }
2076 
2077 
2078     // used to check if there were any unchecked conversions
2079     Warner overrideWarner = new Warner();
2080 
2081     /** Check that a class does not inherit two concrete methods
2082      *  with the same signature.
2083      *  @param pos          Position to be used for error reporting.
2084      *  @param site         The class type to be checked.
2085      */
2086     public void checkCompatibleConcretes(DiagnosticPosition pos, Type site) {
2087         Type sup = types.supertype(site);
2088         if (!sup.hasTag(CLASS)) return;
2089 
2090         for (Type t1 = sup;
2091              t1.hasTag(CLASS) &amp;&amp; t1.tsym.type.isParameterized();
2092              t1 = types.supertype(t1)) {
2093             for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
2094                 if (s1.kind != MTH ||
2095                     (s1.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
2096                     !s1.isInheritedIn(site.tsym, types) ||
2097                     ((MethodSymbol)s1).implementation(site.tsym,
2098                                                       types,
2099                                                       true) != s1)
2100                     continue;
2101                 Type st1 = types.memberType(t1, s1);
2102                 int s1ArgsLength = st1.getParameterTypes().length();
2103                 if (st1 == s1.type) continue;
2104 
2105                 for (Type t2 = sup;
2106                      t2.hasTag(CLASS);
2107                      t2 = types.supertype(t2)) {
2108                     for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2109                         if (s2 == s1 ||
2110                             s2.kind != MTH ||
2111                             (s2.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
2112                             s2.type.getParameterTypes().length() != s1ArgsLength ||
2113                             !s2.isInheritedIn(site.tsym, types) ||
2114                             ((MethodSymbol)s2).implementation(site.tsym,
2115                                                               types,
2116                                                               true) != s2)
2117                             continue;
2118                         Type st2 = types.memberType(t2, s2);
2119                         if (types.overrideEquivalent(st1, st2))
2120                             log.error(pos,
2121                                       Errors.ConcreteInheritanceConflict(s1, t1, s2, t2, sup));
2122                     }
2123                 }
2124             }
2125         }
2126     }
2127 
2128     /** Check that classes (or interfaces) do not each define an abstract
2129      *  method with same name and arguments but incompatible return types.
2130      *  @param pos          Position to be used for error reporting.
2131      *  @param t1           The first argument type.
2132      *  @param t2           The second argument type.
2133      */
2134     public boolean checkCompatibleAbstracts(DiagnosticPosition pos,
2135                                             Type t1,
2136                                             Type t2,
2137                                             Type site) {
2138         if ((site.tsym.flags() &amp; COMPOUND) != 0) {
2139             // special case for intersections: need to eliminate wildcards in supertypes
2140             t1 = types.capture(t1);
2141             t2 = types.capture(t2);
2142         }
2143         return firstIncompatibility(pos, t1, t2, site) == null;
2144     }
2145 
2146     /** Return the first method which is defined with same args
2147      *  but different return types in two given interfaces, or null if none
2148      *  exists.
2149      *  @param t1     The first type.
2150      *  @param t2     The second type.
2151      *  @param site   The most derived type.
2152      *  @return symbol from t2 that conflicts with one in t1.
2153      */
2154     private Symbol firstIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
2155         Map&lt;TypeSymbol,Type&gt; interfaces1 = new HashMap&lt;&gt;();
2156         closure(t1, interfaces1);
2157         Map&lt;TypeSymbol,Type&gt; interfaces2;
2158         if (t1 == t2)
2159             interfaces2 = interfaces1;
2160         else
2161             closure(t2, interfaces1, interfaces2 = new HashMap&lt;&gt;());
2162 
2163         for (Type t3 : interfaces1.values()) {
2164             for (Type t4 : interfaces2.values()) {
2165                 Symbol s = firstDirectIncompatibility(pos, t3, t4, site);
2166                 if (s != null) return s;
2167             }
2168         }
2169         return null;
2170     }
2171 
2172     /** Compute all the supertypes of t, indexed by type symbol. */
2173     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typeMap) {
2174         if (!t.hasTag(CLASS)) return;
2175         if (typeMap.put(t.tsym, t) == null) {
2176             closure(types.supertype(t), typeMap);
2177             for (Type i : types.interfaces(t))
2178                 closure(i, typeMap);
2179         }
2180     }
2181 
2182     /** Compute all the supertypes of t, indexed by type symbol (except those in typesSkip). */
2183     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typesSkip, Map&lt;TypeSymbol,Type&gt; typeMap) {
2184         if (!t.hasTag(CLASS)) return;
2185         if (typesSkip.get(t.tsym) != null) return;
2186         if (typeMap.put(t.tsym, t) == null) {
2187             closure(types.supertype(t), typesSkip, typeMap);
2188             for (Type i : types.interfaces(t))
2189                 closure(i, typesSkip, typeMap);
2190         }
2191     }
2192 
2193     /** Return the first method in t2 that conflicts with a method from t1. */
2194     private Symbol firstDirectIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
2195         for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
2196             Type st1 = null;
2197             if (s1.kind != MTH || !s1.isInheritedIn(site.tsym, types) ||
2198                     (s1.flags() &amp; SYNTHETIC) != 0) continue;
2199             Symbol impl = ((MethodSymbol)s1).implementation(site.tsym, types, false);
2200             if (impl != null &amp;&amp; (impl.flags() &amp; ABSTRACT) == 0) continue;
2201             for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2202                 if (s1 == s2) continue;
2203                 if (s2.kind != MTH || !s2.isInheritedIn(site.tsym, types) ||
2204                         (s2.flags() &amp; SYNTHETIC) != 0) continue;
2205                 if (st1 == null) st1 = types.memberType(t1, s1);
2206                 Type st2 = types.memberType(t2, s2);
2207                 if (types.overrideEquivalent(st1, st2)) {
2208                     List&lt;Type&gt; tvars1 = st1.getTypeArguments();
2209                     List&lt;Type&gt; tvars2 = st2.getTypeArguments();
2210                     Type rt1 = st1.getReturnType();
2211                     Type rt2 = types.subst(st2.getReturnType(), tvars2, tvars1);
2212                     boolean compat =
2213                         types.isSameType(rt1, rt2) ||
2214                         !rt1.isPrimitiveOrVoid() &amp;&amp;
2215                         !rt2.isPrimitiveOrVoid() &amp;&amp;
2216                         (types.covariantReturnType(rt1, rt2, types.noWarnings) ||
2217                          types.covariantReturnType(rt2, rt1, types.noWarnings)) ||
2218                          checkCommonOverriderIn(s1,s2,site);
2219                     if (!compat) {
2220                         log.error(pos, Errors.TypesIncompatible(t1, t2,
2221                                 Fragments.IncompatibleDiffRet(s2.name, types.memberType(t2, s2).getParameterTypes())));
2222                         return s2;
2223                     }
2224                 } else if (checkNameClash((ClassSymbol)site.tsym, s1, s2) &amp;&amp;
2225                         !checkCommonOverriderIn(s1, s2, site)) {
2226                     log.error(pos, Errors.NameClashSameErasureNoOverride(
2227                             s1.name, types.memberType(site, s1).asMethodType().getParameterTypes(), s1.location(),
2228                             s2.name, types.memberType(site, s2).asMethodType().getParameterTypes(), s2.location()));
2229                     return s2;
2230                 }
2231             }
2232         }
2233         return null;
2234     }
2235     //WHERE
2236     boolean checkCommonOverriderIn(Symbol s1, Symbol s2, Type site) {
2237         Map&lt;TypeSymbol,Type&gt; supertypes = new HashMap&lt;&gt;();
2238         Type st1 = types.memberType(site, s1);
2239         Type st2 = types.memberType(site, s2);
2240         closure(site, supertypes);
2241         for (Type t : supertypes.values()) {
2242             for (Symbol s3 : t.tsym.members().getSymbolsByName(s1.name)) {
2243                 if (s3 == s1 || s3 == s2 || s3.kind != MTH || (s3.flags() &amp; (BRIDGE|SYNTHETIC)) != 0) continue;
2244                 Type st3 = types.memberType(site,s3);
2245                 if (types.overrideEquivalent(st3, st1) &amp;&amp;
2246                         types.overrideEquivalent(st3, st2) &amp;&amp;
2247                         types.returnTypeSubstitutable(st3, st1) &amp;&amp;
2248                         types.returnTypeSubstitutable(st3, st2)) {
2249                     return true;
2250                 }
2251             }
2252         }
2253         return false;
2254     }
2255 
2256     /** Check that a given method conforms with any method it overrides.
2257      *  @param tree         The tree from which positions are extracted
2258      *                      for errors.
2259      *  @param m            The overriding method.
2260      */
2261     void checkOverride(Env&lt;AttrContext&gt; env, JCMethodDecl tree, MethodSymbol m) {
2262         ClassSymbol origin = (ClassSymbol)m.owner;
2263         if ((origin.flags() &amp; ENUM) != 0 &amp;&amp; names.finalize.equals(m.name)) {
2264             if (m.overrides(syms.enumFinalFinalize, origin, types, false)) {
2265                 log.error(tree.pos(), Errors.EnumNoFinalize);
2266                 return;
2267             }
2268         }
2269         if (allowRecords &amp;&amp; origin.isRecord()) {
2270             // let&#39;s find out if this is a user defined accessor in which case the @Override annotation is acceptable
2271             Optional&lt;? extends RecordComponent&gt; recordComponent = origin.getRecordComponents().stream()
2272                     .filter(rc -&gt; rc.accessor == tree.sym &amp;&amp; (rc.accessor.flags_field &amp; GENERATED_MEMBER) == 0).findFirst();
2273             if (recordComponent.isPresent()) {
2274                 return;
2275             }
2276         }
2277 
2278         for (Type t = origin.type; t.hasTag(CLASS);
2279              t = types.supertype(t)) {
2280             if (t != origin.type) {
2281                 checkOverride(tree, t, origin, m);
2282             }
2283             for (Type t2 : types.interfaces(t)) {
2284                 checkOverride(tree, t2, origin, m);
2285             }
2286         }
2287 
2288         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2289         // Check if this method must override a super method due to being annotated with @Override
2290         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2291         // be treated &quot;as if as they were annotated&quot; with @Override.
2292         boolean mustOverride = explicitOverride ||
2293                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate() &amp;&amp;
2294                         (!m.owner.isValue() || (tree.body.flags &amp; SYNTHETIC) == 0));
2295         if (mustOverride &amp;&amp; !isOverrider(m)) {
2296             DiagnosticPosition pos = tree.pos();
2297             for (JCAnnotation a : tree.getModifiers().annotations) {
2298                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2299                     pos = a.pos();
2300                     break;
2301                 }
2302             }
2303             log.error(pos,
2304                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2305                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2306         }
2307     }
2308 
2309     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2310         TypeSymbol c = site.tsym;
2311         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2312             if (m.overrides(sym, origin, types, false)) {
2313                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2314                     checkOverride(tree, m, (MethodSymbol)sym, origin);
2315                 }
2316             }
2317         }
2318     }
2319 
2320     private Filter&lt;Symbol&gt; equalsHasCodeFilter = s -&gt; MethodSymbol.implementation_filter.accepts(s) &amp;&amp;
2321             (s.flags() &amp; BAD_OVERRIDE) == 0;
2322 
2323     public void checkClassOverrideEqualsAndHashIfNeeded(DiagnosticPosition pos,
2324             ClassSymbol someClass) {
2325         /* At present, annotations cannot possibly have a method that is override
2326          * equivalent with Object.equals(Object) but in any case the condition is
2327          * fine for completeness.
2328          */
2329         if (someClass == (ClassSymbol)syms.objectType.tsym ||
2330             someClass.isInterface() || someClass.isEnum() ||
2331             (someClass.flags() &amp; ANNOTATION) != 0 ||
2332             (someClass.flags() &amp; ABSTRACT) != 0) return;
2333         //anonymous inner classes implementing interfaces need especial treatment
2334         if (someClass.isAnonymous()) {
2335             List&lt;Type&gt; interfaces =  types.interfaces(someClass.type);
2336             if (interfaces != null &amp;&amp; !interfaces.isEmpty() &amp;&amp;
2337                 interfaces.head.tsym == syms.comparatorType.tsym) return;
2338         }
2339         checkClassOverrideEqualsAndHash(pos, someClass);
2340     }
2341 
2342     private void checkClassOverrideEqualsAndHash(DiagnosticPosition pos,
2343             ClassSymbol someClass) {
2344         if (lint.isEnabled(LintCategory.OVERRIDES)) {
2345             MethodSymbol equalsAtObject = (MethodSymbol)syms.objectType
2346                     .tsym.members().findFirst(names.equals);
2347             MethodSymbol hashCodeAtObject = (MethodSymbol)syms.objectType
2348                     .tsym.members().findFirst(names.hashCode);
2349             MethodSymbol equalsImpl = types.implementation(equalsAtObject,
2350                     someClass, false, equalsHasCodeFilter);
2351             boolean overridesEquals = equalsImpl != null &amp;&amp;
2352                                       equalsImpl.owner == someClass;
2353             boolean overridesHashCode = types.implementation(hashCodeAtObject,
2354                 someClass, false, equalsHasCodeFilter) != hashCodeAtObject;
2355 
2356             if (overridesEquals &amp;&amp; !overridesHashCode) {
2357                 log.warning(LintCategory.OVERRIDES, pos,
2358                             Warnings.OverrideEqualsButNotHashcode(someClass));
2359             }
2360         }
2361     }
2362 
2363     public void checkModuleName (JCModuleDecl tree) {
2364         Name moduleName = tree.sym.name;
2365         Assert.checkNonNull(moduleName);
2366         if (lint.isEnabled(LintCategory.MODULE)) {
2367             JCExpression qualId = tree.qualId;
2368             while (qualId != null) {
2369                 Name componentName;
2370                 DiagnosticPosition pos;
2371                 switch (qualId.getTag()) {
2372                     case SELECT:
2373                         JCFieldAccess selectNode = ((JCFieldAccess) qualId);
2374                         componentName = selectNode.name;
2375                         pos = selectNode.pos();
2376                         qualId = selectNode.selected;
2377                         break;
2378                     case IDENT:
2379                         componentName = ((JCIdent) qualId).name;
2380                         pos = qualId.pos();
2381                         qualId = null;
2382                         break;
2383                     default:
2384                         throw new AssertionError(&quot;Unexpected qualified identifier: &quot; + qualId.toString());
2385                 }
2386                 if (componentName != null) {
2387                     String moduleNameComponentString = componentName.toString();
2388                     int nameLength = moduleNameComponentString.length();
2389                     if (nameLength &gt; 0 &amp;&amp; Character.isDigit(moduleNameComponentString.charAt(nameLength - 1))) {
2390                         log.warning(Lint.LintCategory.MODULE, pos, Warnings.PoorChoiceForModuleName(componentName));
2391                     }
2392                 }
2393             }
2394         }
2395     }
2396 
2397     private boolean checkNameClash(ClassSymbol origin, Symbol s1, Symbol s2) {
2398         ClashFilter cf = new ClashFilter(origin.type);
2399         return (cf.accepts(s1) &amp;&amp;
2400                 cf.accepts(s2) &amp;&amp;
2401                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2402     }
2403 
2404 
2405     /** Check that all abstract members of given class have definitions.
2406      *  @param pos          Position to be used for error reporting.
2407      *  @param c            The class.
2408      */
2409     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2410         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2411         if (undef != null) {
2412             MethodSymbol undef1 =
2413                 new MethodSymbol(undef.flags(), undef.name,
2414                                  types.memberType(c.type, undef), undef.owner);
2415             log.error(pos,
2416                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2417         }
2418     }
2419 
2420     // A value class cannot contain a field of its own type either or indirectly.
2421     void checkNonCyclicMembership(JCClassDecl tree) {
2422         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
2423         try {
2424             tree.sym.flags_field |= LOCKED;
2425             for (List&lt;? extends JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2426                 if (l.head.hasTag(VARDEF)) {
2427                     JCVariableDecl field = (JCVariableDecl) l.head;
2428                     if (cyclePossible(field.sym)) {
2429                         Type fieldType = field.sym.type;
2430                         checkNonCyclicMembership((ClassSymbol) fieldType.tsym, field.pos());
2431                     }
2432                 }
2433             }
2434         } finally {
2435             tree.sym.flags_field &amp;= ~LOCKED;
2436         }
2437 
2438     }
2439     // where
2440     private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {
2441         if ((c.flags_field &amp; LOCKED) != 0) {
2442             log.error(pos, Errors.CyclicValueTypeMembership(c));
2443             return;
2444         }
2445         try {
2446             c.flags_field |= LOCKED;
2447             for (Symbol fld : c.members().getSymbols(s -&gt; s.kind == VAR &amp;&amp; cyclePossible((VarSymbol) s), NON_RECURSIVE)) {
2448                 checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);
2449             }
2450         } finally {
2451             c.flags_field &amp;= ~LOCKED;
2452         }
2453     }
2454         // where
2455         private boolean cyclePossible(VarSymbol symbol) {
2456             return (symbol.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(symbol.type);
2457         }
2458 
2459     void checkNonCyclicDecl(JCClassDecl tree) {
2460         CycleChecker cc = new CycleChecker();
2461         cc.scan(tree);
2462         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2463             tree.sym.flags_field |= ACYCLIC;
2464         }
2465     }
2466 
2467     class CycleChecker extends TreeScanner {
2468 
2469         List&lt;Symbol&gt; seenClasses = List.nil();
2470         boolean errorFound = false;
2471         boolean partialCheck = false;
2472 
2473         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2474             if (sym != null &amp;&amp; sym.kind == TYP) {
2475                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2476                 if (classEnv != null) {
2477                     DiagnosticSource prevSource = log.currentSource();
2478                     try {
2479                         log.useSource(classEnv.toplevel.sourcefile);
2480                         scan(classEnv.tree);
2481                     }
2482                     finally {
2483                         log.useSource(prevSource.getFile());
2484                     }
2485                 } else if (sym.kind == TYP) {
2486                     checkClass(pos, sym, List.nil());
2487                 }
2488             } else {
2489                 //not completed yet
2490                 partialCheck = true;
2491             }
2492         }
2493 
2494         @Override
2495         public void visitSelect(JCFieldAccess tree) {
2496             super.visitSelect(tree);
2497             checkSymbol(tree.pos(), tree.sym);
2498         }
2499 
2500         @Override
2501         public void visitIdent(JCIdent tree) {
2502             checkSymbol(tree.pos(), tree.sym);
2503         }
2504 
2505         @Override
2506         public void visitTypeApply(JCTypeApply tree) {
2507             scan(tree.clazz);
2508         }
2509 
2510         @Override
2511         public void visitTypeArray(JCArrayTypeTree tree) {
2512             scan(tree.elemtype);
2513         }
2514 
2515         @Override
2516         public void visitClassDef(JCClassDecl tree) {
2517             List&lt;JCTree&gt; supertypes = List.nil();
2518             if (tree.getExtendsClause() != null) {
2519                 supertypes = supertypes.prepend(tree.getExtendsClause());
2520             }
2521             if (tree.getImplementsClause() != null) {
2522                 for (JCTree intf : tree.getImplementsClause()) {
2523                     supertypes = supertypes.prepend(intf);
2524                 }
2525             }
2526             checkClass(tree.pos(), tree.sym, supertypes);
2527         }
2528 
2529         void checkClass(DiagnosticPosition pos, Symbol c, List&lt;JCTree&gt; supertypes) {
2530             if ((c.flags_field &amp; ACYCLIC) != 0)
2531                 return;
2532             if (seenClasses.contains(c)) {
2533                 errorFound = true;
2534                 noteCyclic(pos, (ClassSymbol)c);
2535             } else if (!c.type.isErroneous()) {
2536                 try {
2537                     seenClasses = seenClasses.prepend(c);
2538                     if (c.type.hasTag(CLASS)) {
2539                         if (supertypes.nonEmpty()) {
2540                             scan(supertypes);
2541                         }
2542                         else {
2543                             ClassType ct = (ClassType)c.type;
2544                             if (ct.supertype_field == null ||
2545                                     ct.interfaces_field == null) {
2546                                 //not completed yet
2547                                 partialCheck = true;
2548                                 return;
2549                             }
2550                             checkSymbol(pos, ct.supertype_field.tsym);
2551                             for (Type intf : ct.interfaces_field) {
2552                                 checkSymbol(pos, intf.tsym);
2553                             }
2554                         }
2555                         if (c.owner.kind == TYP) {
2556                             checkSymbol(pos, c.owner);
2557                         }
2558                     }
2559                 } finally {
2560                     seenClasses = seenClasses.tail;
2561                 }
2562             }
2563         }
2564     }
2565 
2566     /** Check for cyclic references. Issue an error if the
2567      *  symbol of the type referred to has a LOCKED flag set.
2568      *
2569      *  @param pos      Position to be used for error reporting.
2570      *  @param t        The type referred to.
2571      */
2572     void checkNonCyclic(DiagnosticPosition pos, Type t) {
2573         checkNonCyclicInternal(pos, t);
2574     }
2575 
2576 
2577     void checkNonCyclic(DiagnosticPosition pos, TypeVar t) {
2578         checkNonCyclic1(pos, t, List.nil());
2579     }
2580 
2581     private void checkNonCyclic1(DiagnosticPosition pos, Type t, List&lt;TypeVar&gt; seen) {
2582         final TypeVar tv;
2583         if  (t.hasTag(TYPEVAR) &amp;&amp; (t.tsym.flags() &amp; UNATTRIBUTED) != 0)
2584             return;
2585         if (seen.contains(t)) {
2586             tv = (TypeVar)t;
2587             tv.setUpperBound(types.createErrorType(t));
2588             log.error(pos, Errors.CyclicInheritance(t));
2589         } else if (t.hasTag(TYPEVAR)) {
2590             tv = (TypeVar)t;
2591             seen = seen.prepend(tv);
2592             for (Type b : types.getBounds(tv))
2593                 checkNonCyclic1(pos, b, seen);
2594         }
2595     }
2596 
2597     /** Check for cyclic references. Issue an error if the
2598      *  symbol of the type referred to has a LOCKED flag set.
2599      *
2600      *  @param pos      Position to be used for error reporting.
2601      *  @param t        The type referred to.
2602      *  @returns        True if the check completed on all attributed classes
2603      */
2604     private boolean checkNonCyclicInternal(DiagnosticPosition pos, Type t) {
2605         boolean complete = true; // was the check complete?
2606         //- System.err.println(&quot;checkNonCyclicInternal(&quot;+t+&quot;);&quot;);//DEBUG
2607         Symbol c = t.tsym;
2608         if ((c.flags_field &amp; ACYCLIC) != 0) return true;
2609 
2610         if ((c.flags_field &amp; LOCKED) != 0) {
2611             noteCyclic(pos, (ClassSymbol)c);
2612         } else if (!c.type.isErroneous()) {
2613             try {
2614                 c.flags_field |= LOCKED;
2615                 if (c.type.hasTag(CLASS)) {
2616                     ClassType clazz = (ClassType)c.type;
2617                     if (clazz.interfaces_field != null)
2618                         for (List&lt;Type&gt; l=clazz.interfaces_field; l.nonEmpty(); l=l.tail)
2619                             complete &amp;= checkNonCyclicInternal(pos, l.head);
2620                     if (clazz.supertype_field != null) {
2621                         Type st = clazz.supertype_field;
2622                         if (st != null &amp;&amp; st.hasTag(CLASS))
2623                             complete &amp;= checkNonCyclicInternal(pos, st);
2624                     }
2625                     if (c.owner.kind == TYP)
2626                         complete &amp;= checkNonCyclicInternal(pos, c.owner.type);
2627                 }
2628             } finally {
2629                 c.flags_field &amp;= ~LOCKED;
2630             }
2631         }
2632         if (complete)
2633             complete = ((c.flags_field &amp; UNATTRIBUTED) == 0) &amp;&amp; c.isCompleted();
2634         if (complete) c.flags_field |= ACYCLIC;
2635         return complete;
2636     }
2637 
2638     /** Note that we found an inheritance cycle. */
2639     private void noteCyclic(DiagnosticPosition pos, ClassSymbol c) {
2640         log.error(pos, Errors.CyclicInheritance(c));
2641         for (List&lt;Type&gt; l=types.interfaces(c.type); l.nonEmpty(); l=l.tail)
2642             l.head = types.createErrorType((ClassSymbol)l.head.tsym, Type.noType);
2643         Type st = types.supertype(c.type);
2644         if (st.hasTag(CLASS))
2645             ((ClassType)c.type).supertype_field = types.createErrorType((ClassSymbol)st.tsym, Type.noType);
2646         c.type = types.createErrorType(c, c.type);
2647         c.flags_field |= ACYCLIC;
2648     }
2649 
2650     /** Check that all methods which implement some
2651      *  method conform to the method they implement.
2652      *  @param tree         The class definition whose members are checked.
2653      */
2654     void checkImplementations(JCClassDecl tree) {
2655         checkImplementations(tree, tree.sym, tree.sym);
2656     }
2657     //where
2658         /** Check that all methods which implement some
2659          *  method in `ic&#39; conform to the method they implement.
2660          */
2661         void checkImplementations(JCTree tree, ClassSymbol origin, ClassSymbol ic) {
2662             for (List&lt;Type&gt; l = types.closure(ic.type); l.nonEmpty(); l = l.tail) {
2663                 ClassSymbol lc = (ClassSymbol)l.head.tsym;
2664                 if ((lc.flags() &amp; ABSTRACT) != 0) {
2665                     for (Symbol sym : lc.members().getSymbols(NON_RECURSIVE)) {
2666                         if (sym.kind == MTH &amp;&amp;
2667                             (sym.flags() &amp; (STATIC|ABSTRACT)) == ABSTRACT) {
2668                             MethodSymbol absmeth = (MethodSymbol)sym;
2669                             MethodSymbol implmeth = absmeth.implementation(origin, types, false);
2670                             if (implmeth != null &amp;&amp; implmeth != absmeth &amp;&amp;
2671                                 (implmeth.owner.flags() &amp; INTERFACE) ==
2672                                 (origin.flags() &amp; INTERFACE)) {
2673                                 // don&#39;t check if implmeth is in a class, yet
2674                                 // origin is an interface. This case arises only
2675                                 // if implmeth is declared in Object. The reason is
2676                                 // that interfaces really don&#39;t inherit from
2677                                 // Object it&#39;s just that the compiler represents
2678                                 // things that way.
2679                                 checkOverride(tree, implmeth, absmeth, origin);
2680                             }
2681                         }
2682                     }
2683                 }
2684             }
2685         }
2686 
2687     /** Check that all abstract methods implemented by a class are
2688      *  mutually compatible.
2689      *  @param pos          Position to be used for error reporting.
2690      *  @param c            The class whose interfaces are checked.
2691      */
2692     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2693         List&lt;Type&gt; supertypes = types.interfaces(c);
2694         Type supertype = types.supertype(c);
2695         if (supertype.hasTag(CLASS) &amp;&amp;
2696             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2697             supertypes = supertypes.prepend(supertype);
2698         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2699             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2700                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2701                 return;
2702             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2703                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2704                     return;
2705         }
2706         checkCompatibleConcretes(pos, c);
2707 
2708         if (c.isValue() &amp;&amp; types.asSuper(c, syms.identityObjectType.tsym, true) != null) {
2709             log.error(pos, Errors.InlineTypeMustNotImplementIdentityObject(c));
2710         }
2711     }
2712 
2713     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2714      *  are mutually compatible (JLS 8.4.8/9.4.1).
2715      *
2716      *  @param pos  Position to be used for error reporting.
2717      *  @param site The class whose methods are checked.
2718      *  @param sym  The method symbol to be checked.
2719      */
2720     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2721          ClashFilter cf = new ClashFilter(site);
2722         //for each method m1 that is overridden (directly or indirectly)
2723         //by method &#39;sym&#39; in &#39;site&#39;...
2724 
2725         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2726         boolean overridesAny = false;
2727         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2728         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2729         for (Symbol m1 : symbolsByName) {
2730             if (!sym.overrides(m1, site.tsym, types, false)) {
2731                 if (m1 == sym) {
2732                     continue;
2733                 }
2734 
2735                 if (!overridesAny) {
2736                     potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);
2737                 }
2738                 continue;
2739             }
2740 
2741             if (m1 != sym) {
2742                 overridesAny = true;
2743                 potentiallyAmbiguousList = List.nil();
2744             }
2745 
2746             //...check each method m2 that is a member of &#39;site&#39;
2747             for (Symbol m2 : symbolsByName) {
2748                 if (m2 == m1) continue;
2749                 //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2750                 //a member of &#39;site&#39;) and (ii) m1 has the same erasure as m2, issue an error
2751                 if (!types.isSubSignature(sym.type, types.memberType(site, m2), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source)) &amp;&amp;
2752                         types.hasSameArgs(m2.erasure(types), m1.erasure(types))) {
2753                     sym.flags_field |= CLASH;
2754                     if (m1 == sym) {
2755                         log.error(pos, Errors.NameClashSameErasureNoOverride(
2756                             m1.name, types.memberType(site, m1).asMethodType().getParameterTypes(), m1.location(),
2757                             m2.name, types.memberType(site, m2).asMethodType().getParameterTypes(), m2.location()));
2758                     } else {
2759                         ClassType ct = (ClassType)site;
2760                         String kind = ct.isInterface() ? &quot;interface&quot; : &quot;class&quot;;
2761                         log.error(pos, Errors.NameClashSameErasureNoOverride1(
2762                             kind,
2763                             ct.tsym.name,
2764                             m1.name,
2765                             types.memberType(site, m1).asMethodType().getParameterTypes(),
2766                             m1.location(),
2767                             m2.name,
2768                             types.memberType(site, m2).asMethodType().getParameterTypes(),
2769                             m2.location()));
2770                     }
2771                     return;
2772                 }
2773             }
2774         }
2775 
2776         if (!overridesAny) {
2777             for (MethodSymbol m: potentiallyAmbiguousList) {
2778                 checkPotentiallyAmbiguousOverloads(pos, site, sym, m);
2779             }
2780         }
2781     }
2782 
2783     /** Check that all static methods accessible from &#39;site&#39; are
2784      *  mutually compatible (JLS 8.4.8).
2785      *
2786      *  @param pos  Position to be used for error reporting.
2787      *  @param site The class whose methods are checked.
2788      *  @param sym  The method symbol to be checked.
2789      */
2790     void checkHideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2791         ClashFilter cf = new ClashFilter(site);
2792         //for each method m1 that is a member of &#39;site&#39;...
2793         for (Symbol s : types.membersClosure(site, true).getSymbolsByName(sym.name, cf)) {
2794             //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2795             //a member of &#39;site&#39;) and (ii) &#39;sym&#39; has the same erasure as m1, issue an error
2796             if (!types.isSubSignature(sym.type, types.memberType(site, s), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source))) {
2797                 if (types.hasSameArgs(s.erasure(types), sym.erasure(types))) {
2798                     log.error(pos,
2799                               Errors.NameClashSameErasureNoHide(sym, sym.location(), s, s.location()));
2800                     return;
2801                 } else {
2802                     checkPotentiallyAmbiguousOverloads(pos, site, sym, (MethodSymbol)s);
2803                 }
2804             }
2805          }
2806      }
2807 
2808      //where
2809      private class ClashFilter implements Filter&lt;Symbol&gt; {
2810 
2811          Type site;
2812 
2813          ClashFilter(Type site) {
2814              this.site = site;
2815          }
2816 
2817          boolean shouldSkip(Symbol s) {
2818              return (s.flags() &amp; CLASH) != 0 &amp;&amp;
2819                 s.owner == site.tsym;
2820          }
2821 
2822          public boolean accepts(Symbol s) {
2823              return s.kind == MTH &amp;&amp;
2824                      (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
2825                      !shouldSkip(s) &amp;&amp;
2826                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2827                      !s.isConstructor();
2828          }
2829      }
2830 
2831     void checkDefaultMethodClashes(DiagnosticPosition pos, Type site) {
2832         DefaultMethodClashFilter dcf = new DefaultMethodClashFilter(site);
2833         for (Symbol m : types.membersClosure(site, false).getSymbols(dcf)) {
2834             Assert.check(m.kind == MTH);
2835             List&lt;MethodSymbol&gt; prov = types.interfaceCandidates(site, (MethodSymbol)m);
2836             if (prov.size() &gt; 1) {
2837                 ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
2838                 ListBuffer&lt;Symbol&gt; defaults = new ListBuffer&lt;&gt;();
2839                 for (MethodSymbol provSym : prov) {
2840                     if ((provSym.flags() &amp; DEFAULT) != 0) {
2841                         defaults = defaults.append(provSym);
2842                     } else if ((provSym.flags() &amp; ABSTRACT) != 0) {
2843                         abstracts = abstracts.append(provSym);
2844                     }
2845                     if (defaults.nonEmpty() &amp;&amp; defaults.size() + abstracts.size() &gt;= 2) {
2846                         //strong semantics - issue an error if two sibling interfaces
2847                         //have two override-equivalent defaults - or if one is abstract
2848                         //and the other is default
2849                         Fragment diagKey;
2850                         Symbol s1 = defaults.first();
2851                         Symbol s2;
2852                         if (defaults.size() &gt; 1) {
2853                             s2 = defaults.toList().tail.head;
2854                             diagKey = Fragments.IncompatibleUnrelatedDefaults(Kinds.kindName(site.tsym), site,
2855                                     m.name, types.memberType(site, m).getParameterTypes(),
2856                                     s1.location(), s2.location());
2857 
2858                         } else {
2859                             s2 = abstracts.first();
2860                             diagKey = Fragments.IncompatibleAbstractDefault(Kinds.kindName(site.tsym), site,
2861                                     m.name, types.memberType(site, m).getParameterTypes(),
2862                                     s1.location(), s2.location());
2863                         }
2864                         log.error(pos, Errors.TypesIncompatible(s1.location().type, s2.location().type, diagKey));
2865                         break;
2866                     }
2867                 }
2868             }
2869         }
2870     }
2871 
2872     //where
2873      private class DefaultMethodClashFilter implements Filter&lt;Symbol&gt; {
2874 
2875          Type site;
2876 
2877          DefaultMethodClashFilter(Type site) {
2878              this.site = site;
2879          }
2880 
2881          public boolean accepts(Symbol s) {
2882              return s.kind == MTH &amp;&amp;
2883                      (s.flags() &amp; DEFAULT) != 0 &amp;&amp;
2884                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2885                      !s.isConstructor();
2886          }
2887      }
2888 
2889     /**
2890       * Report warnings for potentially ambiguous method declarations. Two declarations
2891       * are potentially ambiguous if they feature two unrelated functional interface
2892       * in same argument position (in which case, a call site passing an implicit
2893       * lambda would be ambiguous).
2894       */
2895     void checkPotentiallyAmbiguousOverloads(DiagnosticPosition pos, Type site,
2896             MethodSymbol msym1, MethodSymbol msym2) {
2897         if (msym1 != msym2 &amp;&amp;
2898                 Feature.DEFAULT_METHODS.allowedInSource(source) &amp;&amp;
2899                 lint.isEnabled(LintCategory.OVERLOADS) &amp;&amp;
2900                 (msym1.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0 &amp;&amp;
2901                 (msym2.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0) {
2902             Type mt1 = types.memberType(site, msym1);
2903             Type mt2 = types.memberType(site, msym2);
2904             //if both generic methods, adjust type variables
2905             if (mt1.hasTag(FORALL) &amp;&amp; mt2.hasTag(FORALL) &amp;&amp;
2906                     types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {
2907                 mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);
2908             }
2909             //expand varargs methods if needed
2910             int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());
2911             List&lt;Type&gt; args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);
2912             List&lt;Type&gt; args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);
2913             //if arities don&#39;t match, exit
2914             if (args1.length() != args2.length()) return;
2915             boolean potentiallyAmbiguous = false;
2916             while (args1.nonEmpty() &amp;&amp; args2.nonEmpty()) {
2917                 Type s = args1.head;
2918                 Type t = args2.head;
2919                 if (!types.isSubtype(t, s) &amp;&amp; !types.isSubtype(s, t)) {
2920                     if (types.isFunctionalInterface(s) &amp;&amp; types.isFunctionalInterface(t) &amp;&amp;
2921                             types.findDescriptorType(s).getParameterTypes().length() &gt; 0 &amp;&amp;
2922                             types.findDescriptorType(s).getParameterTypes().length() ==
2923                             types.findDescriptorType(t).getParameterTypes().length()) {
2924                         potentiallyAmbiguous = true;
2925                     } else {
2926                         return;
2927                     }
2928                 }
2929                 args1 = args1.tail;
2930                 args2 = args2.tail;
2931             }
2932             if (potentiallyAmbiguous) {
2933                 //we found two incompatible functional interfaces with same arity
2934                 //this means a call site passing an implicit lambda would be ambiguous
2935                 msym1.flags_field |= POTENTIALLY_AMBIGUOUS;
2936                 msym2.flags_field |= POTENTIALLY_AMBIGUOUS;
2937                 log.warning(LintCategory.OVERLOADS, pos,
2938                             Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),
2939                                                                   msym2, msym2.location()));
2940                 return;
2941             }
2942         }
2943     }
2944 
2945     void checkAccessFromSerializableElement(final JCTree tree, boolean isLambda) {
2946         if (warnOnAnyAccessToMembers ||
2947             (lint.isEnabled(LintCategory.SERIAL) &amp;&amp;
2948             !lint.isSuppressed(LintCategory.SERIAL) &amp;&amp;
2949             isLambda)) {
2950             Symbol sym = TreeInfo.symbol(tree);
2951             if (!sym.kind.matches(KindSelector.VAL_MTH)) {
2952                 return;
2953             }
2954 
2955             if (sym.kind == VAR) {
2956                 if ((sym.flags() &amp; PARAMETER) != 0 ||
2957                     sym.isLocal() ||
2958                     sym.name == names._this ||
2959                     sym.name == names._super) {
2960                     return;
2961                 }
2962             }
2963 
2964             if (!types.isSubtype(sym.owner.type, syms.serializableType) &amp;&amp;
2965                 isEffectivelyNonPublic(sym)) {
2966                 if (isLambda) {
2967                     if (belongsToRestrictedPackage(sym)) {
2968                         log.warning(LintCategory.SERIAL, tree.pos(),
2969                                     Warnings.AccessToMemberFromSerializableLambda(sym));
2970                     }
2971                 } else {
2972                     log.warning(tree.pos(),
2973                                 Warnings.AccessToMemberFromSerializableElement(sym));
2974                 }
2975             }
2976         }
2977     }
2978 
2979     private boolean isEffectivelyNonPublic(Symbol sym) {
2980         if (sym.packge() == syms.rootPackage) {
2981             return false;
2982         }
2983 
2984         while (sym.kind != PCK) {
2985             if ((sym.flags() &amp; PUBLIC) == 0) {
2986                 return true;
2987             }
2988             sym = sym.owner;
2989         }
2990         return false;
2991     }
2992 
2993     private boolean belongsToRestrictedPackage(Symbol sym) {
2994         String fullName = sym.packge().fullname.toString();
2995         return fullName.startsWith(&quot;java.&quot;) ||
2996                 fullName.startsWith(&quot;javax.&quot;) ||
2997                 fullName.startsWith(&quot;sun.&quot;) ||
2998                 fullName.contains(&quot;.internal.&quot;);
2999     }
3000 
3001     /** Check that class c does not implement directly or indirectly
3002      *  the same parameterized interface with two different argument lists.
3003      *  @param pos          Position to be used for error reporting.
3004      *  @param type         The type whose interfaces are checked.
3005      */
3006     void checkClassBounds(DiagnosticPosition pos, Type type) {
3007         checkClassBounds(pos, new HashMap&lt;TypeSymbol,Type&gt;(), type);
3008     }
3009 //where
3010         /** Enter all interfaces of type `type&#39; into the hash table `seensofar&#39;
3011          *  with their class symbol as key and their type as value. Make
3012          *  sure no class is entered with two different types.
3013          */
3014         void checkClassBounds(DiagnosticPosition pos,
3015                               Map&lt;TypeSymbol,Type&gt; seensofar,
3016                               Type type) {
3017             if (type.isErroneous()) return;
3018             for (List&lt;Type&gt; l = types.interfaces(type); l.nonEmpty(); l = l.tail) {
3019                 Type it = l.head;
3020                 if (type.hasTag(CLASS) &amp;&amp; !it.hasTag(CLASS)) continue; // JLS 8.1.5
3021 
3022                 Type oldit = seensofar.put(it.tsym, it);
3023                 if (oldit != null) {
3024                     List&lt;Type&gt; oldparams = oldit.allparams();
3025                     List&lt;Type&gt; newparams = it.allparams();
3026                     if (!types.containsTypeEquivalent(oldparams, newparams))
3027                         log.error(pos,
3028                                   Errors.CantInheritDiffArg(it.tsym,
3029                                                             Type.toString(oldparams),
3030                                                             Type.toString(newparams)));
3031                 }
3032                 checkClassBounds(pos, seensofar, it);
3033             }
3034             Type st = types.supertype(type);
3035             if (type.hasTag(CLASS) &amp;&amp; !st.hasTag(CLASS)) return; // JLS 8.1.4
3036             if (st != Type.noType) checkClassBounds(pos, seensofar, st);
3037         }
3038 
3039     /** Enter interface into into set.
3040      *  If it existed already, issue a &quot;repeated interface&quot; error.
3041      */
3042     void checkNotRepeated(DiagnosticPosition pos, Type it, Set&lt;Type&gt; its) {
3043         if (its.contains(it))
3044             log.error(pos, Errors.RepeatedInterface);
3045         else {
3046             its.add(it);
3047         }
3048     }
3049 
3050 /* *************************************************************************
3051  * Check annotations
3052  **************************************************************************/
3053 
3054     /**
3055      * Recursively validate annotations values
3056      */
3057     void validateAnnotationTree(JCTree tree) {
3058         class AnnotationValidator extends TreeScanner {
3059             @Override
3060             public void visitAnnotation(JCAnnotation tree) {
3061                 if (!tree.type.isErroneous() &amp;&amp; tree.type.tsym.isAnnotationType()) {
3062                     super.visitAnnotation(tree);
3063                     validateAnnotation(tree);
3064                 }
3065             }
3066         }
3067         tree.accept(new AnnotationValidator());
3068     }
3069 
3070     /**
3071      *  {@literal
3072      *  Annotation types are restricted to primitives, String, an
3073      *  enum, an annotation, Class, Class&lt;?&gt;, Class&lt;? extends
3074      *  Anything&gt;, arrays of the preceding.
3075      *  }
3076      */
3077     void validateAnnotationType(JCTree restype) {
3078         // restype may be null if an error occurred, so don&#39;t bother validating it
3079         if (restype != null) {
3080             validateAnnotationType(restype.pos(), restype.type);
3081         }
3082     }
3083 
3084     void validateAnnotationType(DiagnosticPosition pos, Type type) {
3085         if (type.isPrimitive()) return;
3086         if (types.isSameType(type, syms.stringType)) return;
3087         if ((type.tsym.flags() &amp; Flags.ENUM) != 0) return;
3088         if ((type.tsym.flags() &amp; Flags.ANNOTATION) != 0) return;
3089         if (types.cvarLowerBound(type).tsym == syms.classType.tsym) return;
3090         if (types.isArray(type) &amp;&amp; !types.isArray(types.elemtype(type))) {
3091             validateAnnotationType(pos, types.elemtype(type));
3092             return;
3093         }
3094         log.error(pos, Errors.InvalidAnnotationMemberType);
3095     }
3096 
3097     /**
3098      * &quot;It is also a compile-time error if any method declared in an
3099      * annotation type has a signature that is override-equivalent to
3100      * that of any public or protected method declared in class Object
3101      * or in the interface annotation.Annotation.&quot;
3102      *
3103      * @jls 9.6 Annotation Types
3104      */
3105     void validateAnnotationMethod(DiagnosticPosition pos, MethodSymbol m) {
3106         for (Type sup = syms.annotationType; sup.hasTag(CLASS); sup = types.supertype(sup)) {
3107             Scope s = sup.tsym.members();
3108             for (Symbol sym : s.getSymbolsByName(m.name)) {
3109                 if (sym.kind == MTH &amp;&amp;
3110                     (sym.flags() &amp; (PUBLIC | PROTECTED)) != 0 &amp;&amp;
3111                     types.overrideEquivalent(m.type, sym.type))
3112                     log.error(pos, Errors.IntfAnnotationMemberClash(sym, sup));
3113             }
3114         }
3115     }
3116 
3117     /** Check the annotations of a symbol.
3118      */
3119     public void validateAnnotations(List&lt;JCAnnotation&gt; annotations, JCTree declarationTree, Symbol s) {
3120         for (JCAnnotation a : annotations)
3121             validateAnnotation(a, declarationTree, s);
3122     }
3123 
3124     /** Check the type annotations.
3125      */
3126     public void validateTypeAnnotations(List&lt;JCAnnotation&gt; annotations, boolean isTypeParameter) {
3127         for (JCAnnotation a : annotations)
3128             validateTypeAnnotation(a, isTypeParameter);
3129     }
3130 
3131     /** Check an annotation of a symbol.
3132      */
3133     private void validateAnnotation(JCAnnotation a, JCTree declarationTree, Symbol s) {
3134         validateAnnotationTree(a);
3135         boolean isRecordMember = (s.flags_field &amp; RECORD) != 0 || s.enclClass() != null &amp;&amp; s.enclClass().isRecord();
3136 
3137         boolean isRecordField = isRecordMember &amp;&amp;
3138                 (s.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
3139                 declarationTree.hasTag(VARDEF) &amp;&amp;
3140                 s.owner.kind == TYP;
3141 
3142         if (isRecordField) {
3143             // first we need to check if the annotation is applicable to records
3144             Name[] targets = getTargetNames(a);
3145             boolean appliesToRecords = false;
3146             for (Name target : targets) {
3147                 appliesToRecords =
3148                                 target == names.FIELD ||
3149                                 target == names.PARAMETER ||
3150                                 target == names.METHOD ||
3151                                 target == names.TYPE_USE ||
3152                                 target == names.RECORD_COMPONENT;
3153                 if (appliesToRecords) {
3154                     break;
3155                 }
3156             }
3157             if (!appliesToRecords) {
3158                 log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3159             } else {
3160                 /* lets now find the annotations in the field that are targeted to record components and append them to
3161                  * the corresponding record component
3162                  */
3163                 ClassSymbol recordClass = (ClassSymbol) s.owner;
3164                 RecordComponent rc = recordClass.getRecordComponent((VarSymbol)s);
3165                 SymbolMetadata metadata = rc.getMetadata();
3166                 if (metadata == null || metadata.isEmpty()) {
3167                     /* if not is empty then we have already been here, which is the case if multiple annotations are applied
3168                      * to the record component declaration
3169                      */
3170                     rc.appendAttributes(s.getRawAttributes().stream().filter(anno -&gt;
3171                             Arrays.stream(getTargetNames(anno.type.tsym)).anyMatch(name -&gt; name == names.RECORD_COMPONENT)
3172                     ).collect(List.collector()));
3173                     rc.setTypeAttributes(s.getRawTypeAttributes());
3174                     // to get all the type annotations applied to the type
3175                     rc.type = s.type;
3176                 }
3177             }
3178         }
3179 
3180         /* the section below is tricky. Annotations applied to record components are propagated to the corresponding
3181          * record member so if an annotation has target: FIELD, it is propagated to the corresponding FIELD, if it has
3182          * target METHOD, it is propagated to the accessor and so on. But at the moment when method members are generated
3183          * there is no enough information to propagate only the right annotations. So all the annotations are propagated
3184          * to all the possible locations.
3185          *
3186          * At this point we need to remove all the annotations that are not in place before going on with the annotation
3187          * party. On top of the above there is the issue that there is no AST representing record components, just symbols
3188          * so the corresponding field has been holding all the annotations and it&#39;s metadata has been modified as if it
3189          * was both a field and a record component.
3190          *
3191          * So there are two places where we need to trim annotations from: the metadata of the symbol and / or the modifiers
3192          * in the AST. Whatever is in the metadata will be written to the class file, whatever is in the modifiers could
3193          * be see by annotation processors.
3194          *
3195          * The metadata contains both type annotations and declaration annotations. At this point of the game we don&#39;t
3196          * need to care about type annotations, they are all in the right place. But we could need to remove declaration
3197          * annotations. So for declaration annotations if they are not applicable to the record member, excluding type
3198          * annotations which are already correct, then we will remove it. For the AST modifiers if the annotation is not
3199          * applicable either as type annotation and or declaration annotation, only in that case it will be removed.
3200          *
3201          * So it could be that annotation is removed as a declaration annotation but it is kept in the AST modifier for
3202          * further inspection by annotation processors.
3203          *
3204          * For example:
3205          *
3206          *     import java.lang.annotation.*;
3207          *
3208          *     @Target({ElementType.TYPE_USE, ElementType.RECORD_COMPONENT})
3209          *     @Retention(RetentionPolicy.RUNTIME)
3210          *     @interface Anno { }
3211          *
3212          *     record R(@Anno String s) {}
3213          *
3214          * at this point we will have for the case of the generated field:
3215          *   - @Anno in the modifier
3216          *   - @Anno as a type annotation
3217          *   - @Anno as a declaration annotation
3218          *
3219          * the last one should be removed because the annotation has not FIELD as target but it was applied as a
3220          * declaration annotation because the field was being treated both as a field and as a record component
3221          * as we have already copied the annotations to the record component, now the field doesn&#39;t need to hold
3222          * annotations that are not intended for it anymore. Still @Anno has to be kept in the AST&#39;s modifiers as it
3223          * is applicable as a type annotation to the type of the field.
3224          */
3225 
3226         if (a.type.tsym.isAnnotationType()) {
3227             Optional&lt;Set&lt;Name&gt;&gt; applicableTargetsOp = getApplicableTargets(a, s);
3228             if (!applicableTargetsOp.isEmpty()) {
3229                 Set&lt;Name&gt; applicableTargets = applicableTargetsOp.get();
3230                 boolean notApplicableOrIsTypeUseOnly = applicableTargets.isEmpty() ||
3231                         applicableTargets.size() == 1 &amp;&amp; applicableTargets.contains(names.TYPE_USE);
3232                 boolean isRecordMemberWithNonApplicableDeclAnno =
3233                         isRecordMember &amp;&amp; (s.flags_field &amp; Flags.GENERATED_MEMBER) != 0 &amp;&amp; notApplicableOrIsTypeUseOnly;
3234 
3235                 if (applicableTargets.isEmpty() || isRecordMemberWithNonApplicableDeclAnno) {
3236                     if (isRecordMemberWithNonApplicableDeclAnno) {
3237                             /* so we have found an annotation that is not applicable to a record member that was generated by the
3238                              * compiler. This was intentionally done at TypeEnter, now is the moment strip away the annotations
3239                              * that are not applicable to the given record member
3240                              */
3241                         JCModifiers modifiers = TreeInfo.getModifiers(declarationTree);
3242                             /* lets first remove the annotation from the modifier if it is not applicable, we have to check again as
3243                              * it could be a type annotation
3244                              */
3245                         if (modifiers != null &amp;&amp; applicableTargets.isEmpty()) {
3246                             ListBuffer&lt;JCAnnotation&gt; newAnnotations = new ListBuffer&lt;&gt;();
3247                             for (JCAnnotation anno : modifiers.annotations) {
3248                                 if (anno != a) {
3249                                     newAnnotations.add(anno);
3250                                 }
3251                             }
3252                             modifiers.annotations = newAnnotations.toList();
3253                         }
3254                         // now lets remove it from the symbol
3255                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3256                     } else {
3257                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3258                     }
3259                 }
3260             }
3261         }
3262 
3263         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3264             if (s.kind != TYP) {
3265                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3266             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3267                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3268             }
3269         }
3270         if (a.annotationType.type.tsym == syms.valueBasedType.tsym) {
3271             if (s.isInterface() || s.isEnum()) {
3272                 log.error(a.pos(), Errors.BadValueBasedAnno);
3273             } else if (allowValueBasedClasses) {
3274                 s.flags_field |= VALUEBASED;
3275             }
3276         }
3277     }
3278 
3279     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3280         Assert.checkNonNull(a.type);
3281         validateAnnotationTree(a);
3282 
3283         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3284                 !a.annotationType.type.isErroneous() &amp;&amp;
3285                 !isTypeAnnotation(a, isTypeParameter)) {
3286             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3287         }
3288     }
3289 
3290     /**
3291      * Validate the proposed container &#39;repeatable&#39; on the
3292      * annotation type symbol &#39;s&#39;. Report errors at position
3293      * &#39;pos&#39;.
3294      *
3295      * @param s The (annotation)type declaration annotated with a @Repeatable
3296      * @param repeatable the @Repeatable on &#39;s&#39;
3297      * @param pos where to report errors
3298      */
3299     public void validateRepeatable(TypeSymbol s, Attribute.Compound repeatable, DiagnosticPosition pos) {
3300         Assert.check(types.isSameType(repeatable.type, syms.repeatableType));
3301 
3302         Type t = null;
3303         List&lt;Pair&lt;MethodSymbol,Attribute&gt;&gt; l = repeatable.values;
3304         if (!l.isEmpty()) {
3305             Assert.check(l.head.fst.name == names.value);
3306             t = ((Attribute.Class)l.head.snd).getValue();
3307         }
3308 
3309         if (t == null) {
3310             // errors should already have been reported during Annotate
3311             return;
3312         }
3313 
3314         validateValue(t.tsym, s, pos);
3315         validateRetention(t.tsym, s, pos);
3316         validateDocumented(t.tsym, s, pos);
3317         validateInherited(t.tsym, s, pos);
3318         validateTarget(t.tsym, s, pos);
3319         validateDefault(t.tsym, pos);
3320     }
3321 
3322     private void validateValue(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3323         Symbol sym = container.members().findFirst(names.value);
3324         if (sym != null &amp;&amp; sym.kind == MTH) {
3325             MethodSymbol m = (MethodSymbol) sym;
3326             Type ret = m.getReturnType();
3327             if (!(ret.hasTag(ARRAY) &amp;&amp; types.isSameType(((ArrayType)ret).elemtype, contained.type))) {
3328                 log.error(pos,
3329                           Errors.InvalidRepeatableAnnotationValueReturn(container,
3330                                                                         ret,
3331                                                                         types.makeArrayType(contained.type)));
3332             }
3333         } else {
3334             log.error(pos, Errors.InvalidRepeatableAnnotationNoValue(container));
3335         }
3336     }
3337 
3338     private void validateRetention(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3339         Attribute.RetentionPolicy containerRetention = types.getRetention(container);
3340         Attribute.RetentionPolicy containedRetention = types.getRetention(contained);
3341 
3342         boolean error = false;
3343         switch (containedRetention) {
3344         case RUNTIME:
3345             if (containerRetention != Attribute.RetentionPolicy.RUNTIME) {
3346                 error = true;
3347             }
3348             break;
3349         case CLASS:
3350             if (containerRetention == Attribute.RetentionPolicy.SOURCE)  {
3351                 error = true;
3352             }
3353         }
3354         if (error ) {
3355             log.error(pos,
3356                       Errors.InvalidRepeatableAnnotationRetention(container,
3357                                                                   containerRetention.name(),
3358                                                                   contained,
3359                                                                   containedRetention.name()));
3360         }
3361     }
3362 
3363     private void validateDocumented(Symbol container, Symbol contained, DiagnosticPosition pos) {
3364         if (contained.attribute(syms.documentedType.tsym) != null) {
3365             if (container.attribute(syms.documentedType.tsym) == null) {
3366                 log.error(pos, Errors.InvalidRepeatableAnnotationNotDocumented(container, contained));
3367             }
3368         }
3369     }
3370 
3371     private void validateInherited(Symbol container, Symbol contained, DiagnosticPosition pos) {
3372         if (contained.attribute(syms.inheritedType.tsym) != null) {
3373             if (container.attribute(syms.inheritedType.tsym) == null) {
3374                 log.error(pos, Errors.InvalidRepeatableAnnotationNotInherited(container, contained));
3375             }
3376         }
3377     }
3378 
3379     private void validateTarget(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3380         // The set of targets the container is applicable to must be a subset
3381         // (with respect to annotation target semantics) of the set of targets
3382         // the contained is applicable to. The target sets may be implicit or
3383         // explicit.
3384 
3385         Set&lt;Name&gt; containerTargets;
3386         Attribute.Array containerTarget = getAttributeTargetAttribute(container);
3387         if (containerTarget == null) {
3388             containerTargets = getDefaultTargetSet();
3389         } else {
3390             containerTargets = new HashSet&lt;&gt;();
3391             for (Attribute app : containerTarget.values) {
3392                 if (!(app instanceof Attribute.Enum)) {
3393                     continue; // recovery
3394                 }
3395                 Attribute.Enum e = (Attribute.Enum)app;
3396                 containerTargets.add(e.value.name);
3397             }
3398         }
3399 
3400         Set&lt;Name&gt; containedTargets;
3401         Attribute.Array containedTarget = getAttributeTargetAttribute(contained);
3402         if (containedTarget == null) {
3403             containedTargets = getDefaultTargetSet();
3404         } else {
3405             containedTargets = new HashSet&lt;&gt;();
3406             for (Attribute app : containedTarget.values) {
3407                 if (!(app instanceof Attribute.Enum)) {
3408                     continue; // recovery
3409                 }
3410                 Attribute.Enum e = (Attribute.Enum)app;
3411                 containedTargets.add(e.value.name);
3412             }
3413         }
3414 
3415         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
3416             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
3417         }
3418     }
3419 
3420     /* get a set of names for the default target */
3421     private Set&lt;Name&gt; getDefaultTargetSet() {
3422         if (defaultTargets == null) {
3423             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
3424             targets.add(names.ANNOTATION_TYPE);
3425             targets.add(names.CONSTRUCTOR);
3426             targets.add(names.FIELD);
3427             if (allowRecords) {
3428                 targets.add(names.RECORD_COMPONENT);
3429             }
3430             targets.add(names.LOCAL_VARIABLE);
3431             targets.add(names.METHOD);
3432             targets.add(names.PACKAGE);
3433             targets.add(names.PARAMETER);
3434             targets.add(names.TYPE);
3435 
3436             defaultTargets = java.util.Collections.unmodifiableSet(targets);
3437         }
3438 
3439         return defaultTargets;
3440     }
3441     private Set&lt;Name&gt; defaultTargets;
3442 
3443 
3444     /** Checks that s is a subset of t, with respect to ElementType
3445      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3446      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3447      * TYPE_PARAMETER}.
3448      */
3449     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
3450         // Check that all elements in s are present in t
3451         for (Name n2 : s) {
3452             boolean currentElementOk = false;
3453             for (Name n1 : t) {
3454                 if (n1 == n2) {
3455                     currentElementOk = true;
3456                     break;
3457                 } else if (n1 == names.TYPE &amp;&amp; n2 == names.ANNOTATION_TYPE) {
3458                     currentElementOk = true;
3459                     break;
3460                 } else if (n1 == names.TYPE_USE &amp;&amp;
3461                         (n2 == names.TYPE ||
3462                          n2 == names.ANNOTATION_TYPE ||
3463                          n2 == names.TYPE_PARAMETER)) {
3464                     currentElementOk = true;
3465                     break;
3466                 }
3467             }
3468             if (!currentElementOk)
3469                 return false;
3470         }
3471         return true;
3472     }
3473 
3474     private void validateDefault(Symbol container, DiagnosticPosition pos) {
3475         // validate that all other elements of containing type has defaults
3476         Scope scope = container.members();
3477         for(Symbol elm : scope.getSymbols()) {
3478             if (elm.name != names.value &amp;&amp;
3479                 elm.kind == MTH &amp;&amp;
3480                 ((MethodSymbol)elm).defaultValue == null) {
3481                 log.error(pos,
3482                           Errors.InvalidRepeatableAnnotationElemNondefault(container, elm));
3483             }
3484         }
3485     }
3486 
3487     /** Is s a method symbol that overrides a method in a superclass? */
3488     boolean isOverrider(Symbol s) {
3489         if (s.kind != MTH || s.isStatic())
3490             return false;
3491         MethodSymbol m = (MethodSymbol)s;
3492         TypeSymbol owner = (TypeSymbol)m.owner;
3493         for (Type sup : types.closure(owner.type)) {
3494             if (sup == owner.type)
3495                 continue; // skip &quot;this&quot;
3496             Scope scope = sup.tsym.members();
3497             for (Symbol sym : scope.getSymbolsByName(m.name)) {
3498                 if (!sym.isStatic() &amp;&amp; m.overrides(sym, owner, types, true))
3499                     return true;
3500             }
3501         }
3502         return false;
3503     }
3504 
3505     /** Is the annotation applicable to types? */
3506     protected boolean isTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3507         List&lt;Attribute&gt; targets = typeAnnotations.annotationTargets(a.annotationType.type.tsym);
3508         return (targets == null) ?
3509                 false :
3510                 targets.stream()
3511                         .anyMatch(attr -&gt; isTypeAnnotation(attr, isTypeParameter));
3512     }
3513     //where
3514         boolean isTypeAnnotation(Attribute a, boolean isTypeParameter) {
3515             Attribute.Enum e = (Attribute.Enum)a;
3516             return (e.value.name == names.TYPE_USE ||
3517                     (isTypeParameter &amp;&amp; e.value.name == names.TYPE_PARAMETER));
3518         }
3519 
3520     /** Is the annotation applicable to the symbol? */
3521     Name[] getTargetNames(JCAnnotation a) {
3522         return getTargetNames(a.annotationType.type.tsym);
3523     }
3524 
3525     public Name[] getTargetNames(TypeSymbol annoSym) {
3526         Attribute.Array arr = getAttributeTargetAttribute(annoSym);
3527         Name[] targets;
3528         if (arr == null) {
3529             targets = defaultTargetMetaInfo();
3530         } else {
3531             // TODO: can we optimize this?
3532             targets = new Name[arr.values.length];
3533             for (int i=0; i&lt;arr.values.length; ++i) {
3534                 Attribute app = arr.values[i];
3535                 if (!(app instanceof Attribute.Enum)) {
3536                     return new Name[0];
3537                 }
3538                 Attribute.Enum e = (Attribute.Enum) app;
3539                 targets[i] = e.value.name;
3540             }
3541         }
3542         return targets;
3543     }
3544 
3545     boolean annotationApplicable(JCAnnotation a, Symbol s) {
3546         Optional&lt;Set&lt;Name&gt;&gt; targets = getApplicableTargets(a, s);
3547         /* the optional could be emtpy if the annotation is unknown in that case
3548          * we return that it is applicable and if it is erroneous that should imply
3549          * an error at the declaration site
3550          */
3551         return targets.isEmpty() || targets.isPresent() &amp;&amp; !targets.get().isEmpty();
3552     }
3553 
3554     @SuppressWarnings(&quot;preview&quot;)
3555     Optional&lt;Set&lt;Name&gt;&gt; getApplicableTargets(JCAnnotation a, Symbol s) {
3556         Attribute.Array arr = getAttributeTargetAttribute(a.annotationType.type.tsym);
3557         Name[] targets;
3558         Set&lt;Name&gt; applicableTargets = new HashSet&lt;&gt;();
3559 
3560         if (arr == null) {
3561             targets = defaultTargetMetaInfo();
3562         } else {
3563             // TODO: can we optimize this?
3564             targets = new Name[arr.values.length];
3565             for (int i=0; i&lt;arr.values.length; ++i) {
3566                 Attribute app = arr.values[i];
3567                 if (!(app instanceof Attribute.Enum)) {
3568                     // recovery
3569                     return Optional.empty();
3570                 }
3571                 Attribute.Enum e = (Attribute.Enum) app;
3572                 targets[i] = e.value.name;
3573             }
3574         }
3575         for (Name target : targets) {
3576             if (target == names.TYPE) {
3577                 if (s.kind == TYP)
3578                     applicableTargets.add(names.TYPE);
3579             } else if (target == names.FIELD) {
3580                 if (s.kind == VAR &amp;&amp; s.owner.kind != MTH)
3581                     applicableTargets.add(names.FIELD);
3582             } else if (target == names.RECORD_COMPONENT) {
3583                 if (s.getKind() == ElementKind.RECORD_COMPONENT) {
3584                     applicableTargets.add(names.RECORD_COMPONENT);
3585                 }
3586             } else if (target == names.METHOD) {
3587                 if (s.kind == MTH &amp;&amp; !s.isConstructor())
3588                     applicableTargets.add(names.METHOD);
3589             } else if (target == names.PARAMETER) {
3590                 if (s.kind == VAR &amp;&amp;
3591                     (s.owner.kind == MTH &amp;&amp; (s.flags() &amp; PARAMETER) != 0)) {
3592                     applicableTargets.add(names.PARAMETER);
3593                 }
3594             } else if (target == names.CONSTRUCTOR) {
3595                 if (s.kind == MTH &amp;&amp; s.isConstructor())
3596                     applicableTargets.add(names.CONSTRUCTOR);
3597             } else if (target == names.LOCAL_VARIABLE) {
3598                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp;
3599                       (s.flags() &amp; PARAMETER) == 0) {
3600                     applicableTargets.add(names.LOCAL_VARIABLE);
3601                 }
3602             } else if (target == names.ANNOTATION_TYPE) {
3603                 if (s.kind == TYP &amp;&amp; (s.flags() &amp; ANNOTATION) != 0) {
3604                     applicableTargets.add(names.ANNOTATION_TYPE);
3605                 }
3606             } else if (target == names.PACKAGE) {
3607                 if (s.kind == PCK)
3608                     applicableTargets.add(names.PACKAGE);
3609             } else if (target == names.TYPE_USE) {
3610                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp; s.type.hasTag(NONE)) {
3611                     //cannot type annotate implicitly typed locals
3612                     continue;
3613                 } else if (s.kind == TYP || s.kind == VAR ||
3614                         (s.kind == MTH &amp;&amp; !s.isConstructor() &amp;&amp;
3615                                 !s.type.getReturnType().hasTag(VOID)) ||
3616                         (s.kind == MTH &amp;&amp; s.isConstructor())) {
3617                     applicableTargets.add(names.TYPE_USE);
3618                 }
3619             } else if (target == names.TYPE_PARAMETER) {
3620                 if (s.kind == TYP &amp;&amp; s.type.hasTag(TYPEVAR))
3621                     applicableTargets.add(names.TYPE_PARAMETER);
3622             } else
3623                 return Optional.empty(); // Unknown ElementType. This should be an error at declaration site,
3624                                          // assume applicable.
3625         }
3626         return Optional.of(applicableTargets);
3627     }
3628 
3629     Attribute.Array getAttributeTargetAttribute(TypeSymbol s) {
3630         Attribute.Compound atTarget = s.getAnnotationTypeMetadata().getTarget();
3631         if (atTarget == null) return null; // ok, is applicable
3632         Attribute atValue = atTarget.member(names.value);
3633         if (!(atValue instanceof Attribute.Array)) return null; // error recovery
3634         return (Attribute.Array) atValue;
3635     }
3636 
3637     public final Name[] dfltTargetMeta;
3638     private Name[] defaultTargetMetaInfo() {
3639         return dfltTargetMeta;
3640     }
3641 
3642     /** Check an annotation value.
3643      *
3644      * @param a The annotation tree to check
3645      * @return true if this annotation tree is valid, otherwise false
3646      */
3647     public boolean validateAnnotationDeferErrors(JCAnnotation a) {
3648         boolean res = false;
3649         final Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
3650         try {
3651             res = validateAnnotation(a);
3652         } finally {
3653             log.popDiagnosticHandler(diagHandler);
3654         }
3655         return res;
3656     }
3657 
3658     private boolean validateAnnotation(JCAnnotation a) {
3659         boolean isValid = true;
3660         AnnotationTypeMetadata metadata = a.annotationType.type.tsym.getAnnotationTypeMetadata();
3661 
3662         // collect an inventory of the annotation elements
3663         Set&lt;MethodSymbol&gt; elements = metadata.getAnnotationElements();
3664 
3665         // remove the ones that are assigned values
3666         for (JCTree arg : a.args) {
3667             if (!arg.hasTag(ASSIGN)) continue; // recovery
3668             JCAssign assign = (JCAssign)arg;
3669             Symbol m = TreeInfo.symbol(assign.lhs);
3670             if (m == null || m.type.isErroneous()) continue;
3671             if (!elements.remove(m)) {
3672                 isValid = false;
3673                 log.error(assign.lhs.pos(),
3674                           Errors.DuplicateAnnotationMemberValue(m.name, a.type));
3675             }
3676         }
3677 
3678         // all the remaining ones better have default values
3679         List&lt;Name&gt; missingDefaults = List.nil();
3680         Set&lt;MethodSymbol&gt; membersWithDefault = metadata.getAnnotationElementsWithDefault();
3681         for (MethodSymbol m : elements) {
3682             if (m.type.isErroneous())
3683                 continue;
3684 
3685             if (!membersWithDefault.contains(m))
3686                 missingDefaults = missingDefaults.append(m.name);
3687         }
3688         missingDefaults = missingDefaults.reverse();
3689         if (missingDefaults.nonEmpty()) {
3690             isValid = false;
3691             Error errorKey = (missingDefaults.size() &gt; 1)
3692                     ? Errors.AnnotationMissingDefaultValue1(a.type, missingDefaults)
3693                     : Errors.AnnotationMissingDefaultValue(a.type, missingDefaults);
3694             log.error(a.pos(), errorKey);
3695         }
3696 
3697         return isValid &amp;&amp; validateTargetAnnotationValue(a);
3698     }
3699 
3700     /* Validate the special java.lang.annotation.Target annotation */
3701     boolean validateTargetAnnotationValue(JCAnnotation a) {
3702         // special case: java.lang.annotation.Target must not have
3703         // repeated values in its value member
3704         if (a.annotationType.type.tsym != syms.annotationTargetType.tsym ||
3705                 a.args.tail == null)
3706             return true;
3707 
3708         boolean isValid = true;
3709         if (!a.args.head.hasTag(ASSIGN)) return false; // error recovery
3710         JCAssign assign = (JCAssign) a.args.head;
3711         Symbol m = TreeInfo.symbol(assign.lhs);
3712         if (m.name != names.value) return false;
3713         JCTree rhs = assign.rhs;
3714         if (!rhs.hasTag(NEWARRAY)) return false;
3715         JCNewArray na = (JCNewArray) rhs;
3716         Set&lt;Symbol&gt; targets = new HashSet&lt;&gt;();
3717         for (JCTree elem : na.elems) {
3718             if (!targets.add(TreeInfo.symbol(elem))) {
3719                 isValid = false;
3720                 log.error(elem.pos(), Errors.RepeatedAnnotationTarget);
3721             }
3722         }
3723         return isValid;
3724     }
3725 
3726     void checkDeprecatedAnnotation(DiagnosticPosition pos, Symbol s) {
3727         if (lint.isEnabled(LintCategory.DEP_ANN) &amp;&amp; s.isDeprecatableViaAnnotation() &amp;&amp;
3728             (s.flags() &amp; DEPRECATED) != 0 &amp;&amp;
3729             !syms.deprecatedType.isErroneous() &amp;&amp;
3730             s.attribute(syms.deprecatedType.tsym) == null) {
3731             log.warning(LintCategory.DEP_ANN,
3732                     pos, Warnings.MissingDeprecatedAnnotation);
3733         }
3734         // Note: @Deprecated has no effect on local variables, parameters and package decls.
3735         if (lint.isEnabled(LintCategory.DEPRECATION) &amp;&amp; !s.isDeprecatableViaAnnotation()) {
3736             if (!syms.deprecatedType.isErroneous() &amp;&amp; s.attribute(syms.deprecatedType.tsym) != null) {
3737                 log.warning(LintCategory.DEPRECATION, pos,
3738                             Warnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));
3739             }
3740         }
3741     }
3742 
3743     void checkDeprecated(final DiagnosticPosition pos, final Symbol other, final Symbol s) {
3744         checkDeprecated(() -&gt; pos, other, s);
3745     }
3746 
3747     void checkDeprecated(Supplier&lt;DiagnosticPosition&gt; pos, final Symbol other, final Symbol s) {
3748         if ( (s.isDeprecatedForRemoval()
3749                 || s.isDeprecated() &amp;&amp; !other.isDeprecated())
3750                 &amp;&amp; (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)) {
3751             deferredLintHandler.report(() -&gt; warnDeprecated(pos.get(), s));
3752         }
3753     }
3754 
3755     void checkSunAPI(final DiagnosticPosition pos, final Symbol s) {
3756         if ((s.flags() &amp; PROPRIETARY) != 0) {
3757             deferredLintHandler.report(() -&gt; {
3758                 log.mandatoryWarning(pos, Warnings.SunProprietary(s));
3759             });
3760         }
3761     }
3762 
3763     void checkProfile(final DiagnosticPosition pos, final Symbol s) {
3764         if (profile != Profile.DEFAULT &amp;&amp; (s.flags() &amp; NOT_IN_PROFILE) != 0) {
3765             log.error(pos, Errors.NotInProfile(s, profile));
3766         }
3767     }
3768 
3769     void checkPreview(DiagnosticPosition pos, Symbol s) {
3770         if ((s.flags() &amp; PREVIEW_API) != 0) {
3771             if ((s.flags() &amp; PREVIEW_ESSENTIAL_API) != 0 &amp;&amp; !preview.isEnabled()) {
3772                 log.error(pos, Errors.IsPreview(s));
3773             } else {
3774                 deferredLintHandler.report(() -&gt; warnPreview(pos, s));
3775             }
3776         }
3777     }
3778 
3779 /* *************************************************************************
3780  * Check for recursive annotation elements.
3781  **************************************************************************/
3782 
3783     /** Check for cycles in the graph of annotation elements.
3784      */
3785     void checkNonCyclicElements(JCClassDecl tree) {
3786         if ((tree.sym.flags_field &amp; ANNOTATION) == 0) return;
3787         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
3788         try {
3789             tree.sym.flags_field |= LOCKED;
3790             for (JCTree def : tree.defs) {
3791                 if (!def.hasTag(METHODDEF)) continue;
3792                 JCMethodDecl meth = (JCMethodDecl)def;
3793                 checkAnnotationResType(meth.pos(), meth.restype.type);
3794             }
3795         } finally {
3796             tree.sym.flags_field &amp;= ~LOCKED;
3797             tree.sym.flags_field |= ACYCLIC_ANN;
3798         }
3799     }
3800 
3801     void checkNonCyclicElementsInternal(DiagnosticPosition pos, TypeSymbol tsym) {
3802         if ((tsym.flags_field &amp; ACYCLIC_ANN) != 0)
3803             return;
3804         if ((tsym.flags_field &amp; LOCKED) != 0) {
3805             log.error(pos, Errors.CyclicAnnotationElement(tsym));
3806             return;
3807         }
3808         try {
3809             tsym.flags_field |= LOCKED;
3810             for (Symbol s : tsym.members().getSymbols(NON_RECURSIVE)) {
3811                 if (s.kind != MTH)
3812                     continue;
3813                 checkAnnotationResType(pos, ((MethodSymbol)s).type.getReturnType());
3814             }
3815         } finally {
3816             tsym.flags_field &amp;= ~LOCKED;
3817             tsym.flags_field |= ACYCLIC_ANN;
3818         }
3819     }
3820 
3821     void checkAnnotationResType(DiagnosticPosition pos, Type type) {
3822         switch (type.getTag()) {
3823         case CLASS:
3824             if ((type.tsym.flags() &amp; ANNOTATION) != 0)
3825                 checkNonCyclicElementsInternal(pos, type.tsym);
3826             break;
3827         case ARRAY:
3828             checkAnnotationResType(pos, types.elemtype(type));
3829             break;
3830         default:
3831             break; // int etc
3832         }
3833     }
3834 
3835 /* *************************************************************************
3836  * Check for cycles in the constructor call graph.
3837  **************************************************************************/
3838 
3839     /** Check for cycles in the graph of constructors calling other
3840      *  constructors.
3841      */
3842     void checkCyclicConstructors(JCClassDecl tree) {
3843         Map&lt;Symbol,Symbol&gt; callMap = new HashMap&lt;&gt;();
3844 
3845         // enter each constructor this-call into the map
3846         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
3847             JCMethodInvocation app = TreeInfo.firstConstructorCall(l.head);
3848             if (app == null) continue;
3849             JCMethodDecl meth = (JCMethodDecl) l.head;
3850             if (TreeInfo.name(app.meth) == names._this) {
3851                 callMap.put(meth.sym, TreeInfo.symbol(app.meth));
3852             } else {
3853                 meth.sym.flags_field |= ACYCLIC;
3854             }
3855         }
3856 
3857         // Check for cycles in the map
3858         Symbol[] ctors = new Symbol[0];
3859         ctors = callMap.keySet().toArray(ctors);
3860         for (Symbol caller : ctors) {
3861             checkCyclicConstructor(tree, caller, callMap);
3862         }
3863     }
3864 
3865     /** Look in the map to see if the given constructor is part of a
3866      *  call cycle.
3867      */
3868     private void checkCyclicConstructor(JCClassDecl tree, Symbol ctor,
3869                                         Map&lt;Symbol,Symbol&gt; callMap) {
3870         if (ctor != null &amp;&amp; (ctor.flags_field &amp; ACYCLIC) == 0) {
3871             if ((ctor.flags_field &amp; LOCKED) != 0) {
3872                 log.error(TreeInfo.diagnosticPositionFor(ctor, tree),
3873                           Errors.RecursiveCtorInvocation);
3874             } else {
3875                 ctor.flags_field |= LOCKED;
3876                 checkCyclicConstructor(tree, callMap.remove(ctor), callMap);
3877                 ctor.flags_field &amp;= ~LOCKED;
3878             }
3879             ctor.flags_field |= ACYCLIC;
3880         }
3881     }
3882 
3883 /* *************************************************************************
3884  * Miscellaneous
3885  **************************************************************************/
3886 
3887     /**
3888      *  Check for division by integer constant zero
3889      *  @param pos           Position for error reporting.
3890      *  @param operator      The operator for the expression
3891      *  @param operand       The right hand operand for the expression
3892      */
3893     void checkDivZero(final DiagnosticPosition pos, Symbol operator, Type operand) {
3894         if (operand.constValue() != null
3895             &amp;&amp; operand.getTag().isSubRangeOf(LONG)
3896             &amp;&amp; ((Number) (operand.constValue())).longValue() == 0) {
3897             int opc = ((OperatorSymbol)operator).opcode;
3898             if (opc == ByteCodes.idiv || opc == ByteCodes.imod
3899                 || opc == ByteCodes.ldiv || opc == ByteCodes.lmod) {
3900                 deferredLintHandler.report(() -&gt; warnDivZero(pos));
3901             }
3902         }
3903     }
3904 
3905     /**
3906      * Check for empty statements after if
3907      */
3908     void checkEmptyIf(JCIf tree) {
3909         if (tree.thenpart.hasTag(SKIP) &amp;&amp; tree.elsepart == null &amp;&amp;
3910                 lint.isEnabled(LintCategory.EMPTY))
3911             log.warning(LintCategory.EMPTY, tree.thenpart.pos(), Warnings.EmptyIf);
3912     }
3913 
3914     /** Check that symbol is unique in given scope.
3915      *  @param pos           Position for error reporting.
3916      *  @param sym           The symbol.
3917      *  @param s             The scope.
3918      */
3919     boolean checkUnique(DiagnosticPosition pos, Symbol sym, Scope s) {
3920         if (sym.type.isErroneous())
3921             return true;
3922         if (sym.owner.name == names.any) return false;
3923         for (Symbol byName : s.getSymbolsByName(sym.name, NON_RECURSIVE)) {
3924             if (sym != byName &amp;&amp;
3925                     (byName.flags() &amp; CLASH) == 0 &amp;&amp;
3926                     sym.kind == byName.kind &amp;&amp;
3927                     sym.name != names.error &amp;&amp;
3928                     (sym.kind != MTH ||
3929                      types.hasSameArgs(sym.type, byName.type) ||
3930                      types.hasSameArgs(types.erasure(sym.type), types.erasure(byName.type)))) {
3931                 if ((sym.flags() &amp; VARARGS) != (byName.flags() &amp; VARARGS)) {
3932                     sym.flags_field |= CLASH;
3933                     varargsDuplicateError(pos, sym, byName);
3934                     return true;
3935                 } else if (sym.kind == MTH &amp;&amp; !types.hasSameArgs(sym.type, byName.type, false)) {
3936                     duplicateErasureError(pos, sym, byName);
3937                     sym.flags_field |= CLASH;
3938                     return true;
3939                 } else if ((sym.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3940                            (byName.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3941                            (byName.flags() &amp; MATCH_BINDING_TO_OUTER) == 0) {
3942                     if (!sym.type.isErroneous()) {
3943                         log.error(pos, Errors.MatchBindingExists);
3944                         sym.flags_field |= CLASH;
3945                     }
3946                     return false;
3947                 } else {
3948                     duplicateError(pos, byName);
3949                     return false;
3950                 }
3951             }
3952         }
3953         return true;
3954     }
3955 
3956     /** Report duplicate declaration error.
3957      */
3958     void duplicateErasureError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
3959         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
3960             log.error(pos, Errors.NameClashSameErasure(sym1, sym2));
3961         }
3962     }
3963 
3964     /**Check that types imported through the ordinary imports don&#39;t clash with types imported
3965      * by other (static or ordinary) imports. Note that two static imports may import two clashing
3966      * types without an error on the imports.
3967      * @param toplevel       The toplevel tree for which the test should be performed.
3968      */
3969     void checkImportsUnique(JCCompilationUnit toplevel) {
3970         WriteableScope ordinallyImportedSoFar = WriteableScope.create(toplevel.packge);
3971         WriteableScope staticallyImportedSoFar = WriteableScope.create(toplevel.packge);
3972         WriteableScope topLevelScope = toplevel.toplevelScope;
3973 
3974         for (JCTree def : toplevel.defs) {
3975             if (!def.hasTag(IMPORT))
3976                 continue;
3977 
3978             JCImport imp = (JCImport) def;
3979 
3980             if (imp.importScope == null)
3981                 continue;
3982 
3983             for (Symbol sym : imp.importScope.getSymbols(sym -&gt; sym.kind == TYP)) {
3984                 if (imp.isStatic()) {
3985                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, true);
3986                     staticallyImportedSoFar.enter(sym);
3987                 } else {
3988                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, false);
3989                     ordinallyImportedSoFar.enter(sym);
3990                 }
3991             }
3992 
3993             imp.importScope = null;
3994         }
3995     }
3996 
3997     /** Check that single-type import is not already imported or top-level defined,
3998      *  but make an exception for two single-type imports which denote the same type.
3999      *  @param pos                     Position for error reporting.
4000      *  @param ordinallyImportedSoFar  A Scope containing types imported so far through
4001      *                                 ordinary imports.
4002      *  @param staticallyImportedSoFar A Scope containing types imported so far through
4003      *                                 static imports.
4004      *  @param topLevelScope           The current file&#39;s top-level Scope
4005      *  @param sym                     The symbol.
4006      *  @param staticImport            Whether or not this was a static import
4007      */
4008     private boolean checkUniqueImport(DiagnosticPosition pos, Scope ordinallyImportedSoFar,
4009                                       Scope staticallyImportedSoFar, Scope topLevelScope,
4010                                       Symbol sym, boolean staticImport) {
4011         Filter&lt;Symbol&gt; duplicates = candidate -&gt; candidate != sym &amp;&amp; !candidate.type.isErroneous();
4012         Symbol ordinaryClashing = ordinallyImportedSoFar.findFirst(sym.name, duplicates);
4013         Symbol staticClashing = null;
4014         if (ordinaryClashing == null &amp;&amp; !staticImport) {
4015             staticClashing = staticallyImportedSoFar.findFirst(sym.name, duplicates);
4016         }
4017         if (ordinaryClashing != null || staticClashing != null) {
4018             if (ordinaryClashing != null)
4019                 log.error(pos, Errors.AlreadyDefinedSingleImport(ordinaryClashing));
4020             else
4021                 log.error(pos, Errors.AlreadyDefinedStaticSingleImport(staticClashing));
4022             return false;
4023         }
4024         Symbol clashing = topLevelScope.findFirst(sym.name, duplicates);
4025         if (clashing != null) {
4026             log.error(pos, Errors.AlreadyDefinedThisUnit(clashing));
4027             return false;
4028         }
4029         return true;
4030     }
4031 
4032     /** Check that a qualified name is in canonical form (for import decls).
4033      */
4034     public void checkCanonical(JCTree tree) {
4035         if (!isCanonical(tree))
4036             log.error(tree.pos(),
4037                       Errors.ImportRequiresCanonical(TreeInfo.symbol(tree)));
4038     }
4039         // where
4040         private boolean isCanonical(JCTree tree) {
4041             while (tree.hasTag(SELECT)) {
4042                 JCFieldAccess s = (JCFieldAccess) tree;
4043                 if (s.sym.owner.getQualifiedName() != TreeInfo.symbol(s.selected).getQualifiedName())
4044                     return false;
4045                 tree = s.selected;
4046             }
4047             return true;
4048         }
4049 
4050     /** Check that an auxiliary class is not accessed from any other file than its own.
4051      */
4052     void checkForBadAuxiliaryClassAccess(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, ClassSymbol c) {
4053         if (lint.isEnabled(Lint.LintCategory.AUXILIARYCLASS) &amp;&amp;
4054             (c.flags() &amp; AUXILIARY) != 0 &amp;&amp;
4055             rs.isAccessible(env, c) &amp;&amp;
4056             !fileManager.isSameFile(c.sourcefile, env.toplevel.sourcefile))
4057         {
4058             log.warning(pos,
4059                         Warnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));
4060         }
4061     }
4062 
4063     private class ConversionWarner extends Warner {
4064         final String uncheckedKey;
4065         final Type found;
4066         final Type expected;
4067         public ConversionWarner(DiagnosticPosition pos, String uncheckedKey, Type found, Type expected) {
4068             super(pos);
4069             this.uncheckedKey = uncheckedKey;
4070             this.found = found;
4071             this.expected = expected;
4072         }
4073 
4074         @Override
4075         public void warn(LintCategory lint) {
4076             boolean warned = this.warned;
4077             super.warn(lint);
4078             if (warned) return; // suppress redundant diagnostics
4079             switch (lint) {
4080                 case UNCHECKED:
4081                     Check.this.warnUnchecked(pos(), Warnings.ProbFoundReq(diags.fragment(uncheckedKey), found, expected));
4082                     break;
4083                 case VARARGS:
4084                     if (method != null &amp;&amp;
4085                             method.attribute(syms.trustMeType.tsym) != null &amp;&amp;
4086                             isTrustMeAllowedOnMethod(method) &amp;&amp;
4087                             !types.isReifiable(method.type.getParameterTypes().last())) {
4088                         Check.this.warnUnsafeVararg(pos(), Warnings.VarargsUnsafeUseVarargsParam(method.params.last()));
4089                     }
4090                     break;
4091                 default:
4092                     throw new AssertionError(&quot;Unexpected lint: &quot; + lint);
4093             }
4094         }
4095     }
4096 
4097     public Warner castWarner(DiagnosticPosition pos, Type found, Type expected) {
4098         return new ConversionWarner(pos, &quot;unchecked.cast.to.type&quot;, found, expected);
4099     }
4100 
4101     public Warner convertWarner(DiagnosticPosition pos, Type found, Type expected) {
4102         return new ConversionWarner(pos, &quot;unchecked.assign&quot;, found, expected);
4103     }
4104 
4105     public void checkFunctionalInterface(JCClassDecl tree, ClassSymbol cs) {
4106         Compound functionalType = cs.attribute(syms.functionalInterfaceType.tsym);
4107 
4108         if (functionalType != null) {
4109             try {
4110                 types.findDescriptorSymbol((TypeSymbol)cs);
4111             } catch (Types.FunctionDescriptorLookupError ex) {
4112                 DiagnosticPosition pos = tree.pos();
4113                 for (JCAnnotation a : tree.getModifiers().annotations) {
4114                     if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
4115                         pos = a.pos();
4116                         break;
4117                     }
4118                 }
4119                 log.error(pos, Errors.BadFunctionalIntfAnno1(ex.getDiagnostic()));
4120             }
4121         }
4122     }
4123 
4124     public void checkImportsResolvable(final JCCompilationUnit toplevel) {
4125         for (final JCImport imp : toplevel.getImports()) {
4126             if (!imp.staticImport || !imp.qualid.hasTag(SELECT))
4127                 continue;
4128             final JCFieldAccess select = (JCFieldAccess) imp.qualid;
4129             final Symbol origin;
4130             if (select.name == names.asterisk || (origin = TreeInfo.symbol(select.selected)) == null || origin.kind != TYP)
4131                 continue;
4132 
4133             TypeSymbol site = (TypeSymbol) TreeInfo.symbol(select.selected);
4134             if (!checkTypeContainsImportableElement(site, site, toplevel.packge, select.name, new HashSet&lt;Symbol&gt;())) {
4135                 log.error(imp.pos(),
4136                           Errors.CantResolveLocation(KindName.STATIC,
4137                                                      select.name,
4138                                                      null,
4139                                                      null,
4140                                                      Fragments.Location(kindName(site),
4141                                                                         site,
4142                                                                         null)));
4143             }
4144         }
4145     }
4146 
4147     // Check that packages imported are in scope (JLS 7.4.3, 6.3, 6.5.3.1, 6.5.3.2)
4148     public void checkImportedPackagesObservable(final JCCompilationUnit toplevel) {
4149         OUTER: for (JCImport imp : toplevel.getImports()) {
4150             if (!imp.staticImport &amp;&amp; TreeInfo.name(imp.qualid) == names.asterisk) {
4151                 TypeSymbol tsym = ((JCFieldAccess)imp.qualid).selected.type.tsym;
4152                 if (tsym.kind == PCK &amp;&amp; tsym.members().isEmpty() &amp;&amp;
4153                     !(Feature.IMPORT_ON_DEMAND_OBSERVABLE_PACKAGES.allowedInSource(source) &amp;&amp; tsym.exists())) {
4154                     log.error(DiagnosticFlag.RESOLVE_ERROR, imp.pos, Errors.DoesntExist(tsym));
4155                 }
4156             }
4157         }
4158     }
4159 
4160     private boolean checkTypeContainsImportableElement(TypeSymbol tsym, TypeSymbol origin, PackageSymbol packge, Name name, Set&lt;Symbol&gt; processed) {
4161         if (tsym == null || !processed.add(tsym))
4162             return false;
4163 
4164             // also search through inherited names
4165         if (checkTypeContainsImportableElement(types.supertype(tsym.type).tsym, origin, packge, name, processed))
4166             return true;
4167 
4168         for (Type t : types.interfaces(tsym.type))
4169             if (checkTypeContainsImportableElement(t.tsym, origin, packge, name, processed))
4170                 return true;
4171 
4172         for (Symbol sym : tsym.members().getSymbolsByName(name)) {
4173             if (sym.isStatic() &amp;&amp;
4174                 importAccessible(sym, packge) &amp;&amp;
4175                 sym.isMemberOf(origin, types)) {
4176                 return true;
4177             }
4178         }
4179 
4180         return false;
4181     }
4182 
4183     // is the sym accessible everywhere in packge?
4184     public boolean importAccessible(Symbol sym, PackageSymbol packge) {
4185         try {
4186             int flags = (int)(sym.flags() &amp; AccessFlags);
4187             switch (flags) {
4188             default:
4189             case PUBLIC:
4190                 return true;
4191             case PRIVATE:
4192                 return false;
4193             case 0:
4194             case PROTECTED:
4195                 return sym.packge() == packge;
4196             }
4197         } catch (ClassFinder.BadClassFile err) {
4198             throw err;
4199         } catch (CompletionFailure ex) {
4200             return false;
4201         }
4202     }
4203 
4204     public void checkLeaksNotAccessible(Env&lt;AttrContext&gt; env, JCClassDecl check) {
4205         JCCompilationUnit toplevel = env.toplevel;
4206 
4207         if (   toplevel.modle == syms.unnamedModule
4208             || toplevel.modle == syms.noModule
4209             || (check.sym.flags() &amp; COMPOUND) != 0) {
4210             return ;
4211         }
4212 
4213         ExportsDirective currentExport = findExport(toplevel.packge);
4214 
4215         if (   currentExport == null //not exported
4216             || currentExport.modules != null) //don&#39;t check classes in qualified export
4217             return ;
4218 
4219         new TreeScanner() {
4220             Lint lint = env.info.lint;
4221             boolean inSuperType;
4222 
4223             @Override
4224             public void visitBlock(JCBlock tree) {
4225             }
4226             @Override
4227             public void visitMethodDef(JCMethodDecl tree) {
4228                 if (!isAPISymbol(tree.sym))
4229                     return;
4230                 Lint prevLint = lint;
4231                 try {
4232                     lint = lint.augment(tree.sym);
4233                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4234                         super.visitMethodDef(tree);
4235                     }
4236                 } finally {
4237                     lint = prevLint;
4238                 }
4239             }
4240             @Override
4241             public void visitVarDef(JCVariableDecl tree) {
4242                 if (!isAPISymbol(tree.sym) &amp;&amp; tree.sym.owner.kind != MTH)
4243                     return;
4244                 Lint prevLint = lint;
4245                 try {
4246                     lint = lint.augment(tree.sym);
4247                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4248                         scan(tree.mods);
4249                         scan(tree.vartype);
4250                     }
4251                 } finally {
4252                     lint = prevLint;
4253                 }
4254             }
4255             @Override
4256             public void visitClassDef(JCClassDecl tree) {
4257                 if (tree != check)
4258                     return ;
4259 
4260                 if (!isAPISymbol(tree.sym))
4261                     return ;
4262 
4263                 Lint prevLint = lint;
4264                 try {
4265                     lint = lint.augment(tree.sym);
4266                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4267                         scan(tree.mods);
4268                         scan(tree.typarams);
4269                         try {
4270                             inSuperType = true;
4271                             scan(tree.extending);
4272                             scan(tree.implementing);
4273                         } finally {
4274                             inSuperType = false;
4275                         }
4276                         scan(tree.defs);
4277                     }
4278                 } finally {
4279                     lint = prevLint;
4280                 }
4281             }
4282             @Override
4283             public void visitTypeApply(JCTypeApply tree) {
4284                 scan(tree.clazz);
4285                 boolean oldInSuperType = inSuperType;
4286                 try {
4287                     inSuperType = false;
4288                     scan(tree.arguments);
4289                 } finally {
4290                     inSuperType = oldInSuperType;
4291                 }
4292             }
4293             @Override
4294             public void visitIdent(JCIdent tree) {
4295                 Symbol sym = TreeInfo.symbol(tree);
4296                 if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR)) {
4297                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4298                 }
4299             }
4300 
4301             @Override
4302             public void visitSelect(JCFieldAccess tree) {
4303                 Symbol sym = TreeInfo.symbol(tree);
4304                 Symbol sitesym = TreeInfo.symbol(tree.selected);
4305                 if (sym.kind == TYP &amp;&amp; sitesym.kind == PCK) {
4306                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4307                 } else {
4308                     super.visitSelect(tree);
4309                 }
4310             }
4311 
4312             @Override
4313             public void visitAnnotation(JCAnnotation tree) {
4314                 if (tree.attribute.type.tsym.getAnnotation(java.lang.annotation.Documented.class) != null)
4315                     super.visitAnnotation(tree);
4316             }
4317 
4318         }.scan(check);
4319     }
4320         //where:
4321         private ExportsDirective findExport(PackageSymbol pack) {
4322             for (ExportsDirective d : pack.modle.exports) {
4323                 if (d.packge == pack)
4324                     return d;
4325             }
4326 
4327             return null;
4328         }
4329         private boolean isAPISymbol(Symbol sym) {
4330             while (sym.kind != PCK) {
4331                 if ((sym.flags() &amp; Flags.PUBLIC) == 0 &amp;&amp; (sym.flags() &amp; Flags.PROTECTED) == 0) {
4332                     return false;
4333                 }
4334                 sym = sym.owner;
4335             }
4336             return true;
4337         }
4338         private void checkVisible(DiagnosticPosition pos, Symbol what, PackageSymbol inPackage, boolean inSuperType) {
4339             if (!isAPISymbol(what) &amp;&amp; !inSuperType) { //package private/private element
4340                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessible(kindName(what), what, what.packge().modle));
4341                 return ;
4342             }
4343 
4344             PackageSymbol whatPackage = what.packge();
4345             ExportsDirective whatExport = findExport(whatPackage);
4346             ExportsDirective inExport = findExport(inPackage);
4347 
4348             if (whatExport == null) { //package not exported:
4349                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexported(kindName(what), what, what.packge().modle));
4350                 return ;
4351             }
4352 
4353             if (whatExport.modules != null) {
4354                 if (inExport.modules == null || !whatExport.modules.containsAll(inExport.modules)) {
4355                     log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexportedQualified(kindName(what), what, what.packge().modle));
4356                 }
4357             }
4358 
4359             if (whatPackage.modle != inPackage.modle &amp;&amp; whatPackage.modle != syms.java_base) {
4360                 //check that relativeTo.modle requires transitive what.modle, somehow:
4361                 List&lt;ModuleSymbol&gt; todo = List.of(inPackage.modle);
4362 
4363                 while (todo.nonEmpty()) {
4364                     ModuleSymbol current = todo.head;
4365                     todo = todo.tail;
4366                     if (current == whatPackage.modle)
4367                         return ; //OK
4368                     if ((current.flags() &amp; Flags.AUTOMATIC_MODULE) != 0)
4369                         continue; //for automatic modules, don&#39;t look into their dependencies
4370                     for (RequiresDirective req : current.requires) {
4371                         if (req.isTransitive()) {
4372                             todo = todo.prepend(req.module);
4373                         }
4374                     }
4375                 }
4376 
4377                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleNotRequiredTransitive(kindName(what), what, what.packge().modle));
4378             }
4379         }
4380 
4381     void checkModuleExists(final DiagnosticPosition pos, ModuleSymbol msym) {
4382         if (msym.kind != MDL) {
4383             deferredLintHandler.report(() -&gt; {
4384                 if (lint.isEnabled(LintCategory.MODULE))
4385                     log.warning(LintCategory.MODULE, pos, Warnings.ModuleNotFound(msym));
4386             });
4387         }
4388     }
4389 
4390     void checkPackageExistsForOpens(final DiagnosticPosition pos, PackageSymbol packge) {
4391         if (packge.members().isEmpty() &amp;&amp;
4392             ((packge.flags() &amp; Flags.HAS_RESOURCE) == 0)) {
4393             deferredLintHandler.report(() -&gt; {
4394                 if (lint.isEnabled(LintCategory.OPENS))
4395                     log.warning(pos, Warnings.PackageEmptyOrNotFound(packge));
4396             });
4397         }
4398     }
4399 
4400     void checkModuleRequires(final DiagnosticPosition pos, final RequiresDirective rd) {
4401         if ((rd.module.flags() &amp; Flags.AUTOMATIC_MODULE) != 0) {
4402             deferredLintHandler.report(() -&gt; {
4403                 if (rd.isTransitive() &amp;&amp; lint.isEnabled(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC)) {
4404                     log.warning(pos, Warnings.RequiresTransitiveAutomatic);
4405                 } else if (lint.isEnabled(LintCategory.REQUIRES_AUTOMATIC)) {
4406                     log.warning(pos, Warnings.RequiresAutomatic);
4407                 }
4408             });
4409         }
4410     }
4411 
4412 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>