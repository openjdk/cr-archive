diff a/src/hotspot/share/c1/c1_Instruction.cpp b/src/hotspot/share/c1/c1_Instruction.cpp
--- a/src/hotspot/share/c1/c1_Instruction.cpp
+++ b/src/hotspot/share/c1/c1_Instruction.cpp
@@ -144,11 +144,11 @@
         if (element_klass->can_be_inline_klass() && (!element_klass->is_inlinetype() || element_klass->as_inline_klass()->flatten_array())) {
           return true;
         }
       } else if (type->is_flat_array_klass()) {
         ciKlass* element_klass = type->as_flat_array_klass()->element_klass();
-        assert(!element_klass->is_loaded() || element_klass->as_inline_klass()->flatten_array(), "must be flattened");
+        assert(!element_klass->is_loaded() || element_klass->flatten_array(), "must be flattened");
         return true;
       } else if (type->is_klass() && type->as_klass()->is_java_lang_Object()) {
         // This can happen as a parameter to System.arraycopy()
         return true;
       }
diff a/src/hotspot/share/ci/ciArrayKlass.cpp b/src/hotspot/share/ci/ciArrayKlass.cpp
--- a/src/hotspot/share/ci/ciArrayKlass.cpp
+++ b/src/hotspot/share/ci/ciArrayKlass.cpp
@@ -102,11 +102,11 @@
 //
 // What type is obtained when this array is indexed as many times as possible?
 ciArrayKlass* ciArrayKlass::make(ciType* element_type) {
   if (element_type->is_primitive_type()) {
     return ciTypeArrayKlass::make(element_type->basic_type());
-  } else if (element_type->is_inlinetype() && element_type->as_inline_klass()->flatten_array()) {
+  } else if (element_type->flatten_array()) {
     return ciFlatArrayKlass::make(element_type->as_klass());
   } else {
     return ciObjArrayKlass::make(element_type->as_klass());
   }
 }
diff a/src/hotspot/share/opto/castnode.cpp b/src/hotspot/share/opto/castnode.cpp
--- a/src/hotspot/share/opto/castnode.cpp
+++ b/src/hotspot/share/opto/castnode.cpp
@@ -311,10 +311,17 @@
 
   const TypePtr *in_type   = inn->isa_ptr();
   const TypePtr *my_type   = _type->isa_ptr();
   const Type *result = _type;
   if( in_type != NULL && my_type != NULL ) {
+    if (my_type->isa_aryptr() && in_type->isa_aryptr()) {
+      // Propagate array properties (not flat/null-free)
+      my_type = my_type->is_aryptr()->update_properties(in_type->is_aryptr());
+      if (my_type == NULL) {
+        return Type::TOP; // Inconsistent properties
+      }
+    }
     TypePtr::PTR   in_ptr    = in_type->ptr();
     if (in_ptr == TypePtr::Null) {
       result = in_type;
     } else if (in_ptr == TypePtr::Constant) {
       if (my_type->isa_rawptr()) {
diff a/src/hotspot/share/opto/compile.cpp b/src/hotspot/share/opto/compile.cpp
--- a/src/hotspot/share/opto/compile.cpp
+++ b/src/hotspot/share/opto/compile.cpp
@@ -1311,11 +1311,11 @@
     if (ta->elem()->isa_oopptr() && ta->elem() != TypeInstPtr::BOTTOM) {
       const TypeAry *tary = TypeAry::make(TypeInstPtr::BOTTOM, ta->size());
       tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,Type::Offset(offset), ta->field_offset());
     }
     // Initially all flattened array accesses share a single slice
-    if (ta->elem()->isa_inlinetype() && ta->elem() != TypeInlineType::BOTTOM && _flattened_accesses_share_alias) {
+    if (ta->is_flat() && ta->elem() != TypeInlineType::BOTTOM && _flattened_accesses_share_alias) {
       const TypeAry *tary = TypeAry::make(TypeInlineType::BOTTOM, ta->size());
       tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,Type::Offset(offset), Type::Offset(Type::OffsetBot));
     }
     // Arrays of bytes and of booleans both use 'bastore' and 'baload' so
     // cannot be distinguished by bytecode alone.
@@ -1340,29 +1340,29 @@
       if (to->klass() != ciEnv::current()->Class_klass() ||
           offset < k->size_helper() * wordSize) {
         // No constant oop pointers (such as Strings); they alias with
         // unknown strings.
         assert(!is_known_inst, "not scalarizable allocation");
-        tj = to = TypeInstPtr::make(TypePtr::BotPTR,to->klass(),false,0,Type::Offset(offset), to->klass()->flatten_array());
+        tj = to = TypeInstPtr::make(TypePtr::BotPTR,to->klass(),false,0,Type::Offset(offset));
       }
     } else if( is_known_inst ) {
       tj = to; // Keep NotNull and klass_is_exact for instance type
     } else if( ptr == TypePtr::NotNull || to->klass_is_exact() ) {
       // During the 2nd round of IterGVN, NotNull castings are removed.
       // Make sure the Bottom and NotNull variants alias the same.
       // Also, make sure exact and non-exact variants alias the same.
-      tj = to = TypeInstPtr::make(TypePtr::BotPTR,to->klass(),false,0,Type::Offset(offset), to->klass()->flatten_array());
+      tj = to = TypeInstPtr::make(TypePtr::BotPTR,to->klass(),false,0,Type::Offset(offset));
     }
     if (to->speculative() != NULL) {
       tj = to = TypeInstPtr::make(to->ptr(),to->klass(),to->klass_is_exact(),to->const_oop(),Type::Offset(to->offset()), to->klass()->flatten_array(), to->instance_id());
     }
     // Canonicalize the holder of this field
     if (offset >= 0 && offset < instanceOopDesc::base_offset_in_bytes()) {
       // First handle header references such as a LoadKlassNode, even if the
       // object's klass is unloaded at compile time (4965979).
       if (!is_known_inst) { // Do it only for non-instance types
-        tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()->Object_klass(), false, NULL, Type::Offset(offset), false);
+        tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()->Object_klass(), false, NULL, Type::Offset(offset));
       }
     } else if (offset < 0 || offset >= k->size_helper() * wordSize) {
       // Static fields are in the space above the normal instance
       // fields in the java.lang.Class instance.
       if (to->klass() != ciEnv::current()->Class_klass()) {
@@ -1374,11 +1374,11 @@
       ciInstanceKlass *canonical_holder = k->get_canonical_holder(offset);
       if (!k->equals(canonical_holder) || tj->offset() != offset) {
         if( is_known_inst ) {
           tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, NULL, Type::Offset(offset), canonical_holder->flatten_array(), to->instance_id());
         } else {
-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, NULL, Type::Offset(offset), canonical_holder->flatten_array());
+          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, NULL, Type::Offset(offset));
         }
       }
     }
   }
 
@@ -1391,20 +1391,19 @@
     // use NotNull as the PTR.
     if ( offset == Type::OffsetBot || (offset >= 0 && (size_t)offset < sizeof(Klass)) ) {
 
       tj = tk = TypeKlassPtr::make(TypePtr::NotNull,
                                    TypeKlassPtr::OBJECT->klass(),
-                                   Type::Offset(offset),
-                                   false);
+                                   Type::Offset(offset));
     }
 
     ciKlass* klass = tk->klass();
     if (klass != NULL && klass->is_obj_array_klass()) {
       ciKlass* k = TypeAryPtr::OOPS->klass();
       if( !k || !k->is_loaded() )                  // Only fails for some -Xcomp runs
         k = TypeInstPtr::BOTTOM->klass();
-      tj = tk = TypeKlassPtr::make(TypePtr::NotNull, k, Type::Offset(offset), false);
+      tj = tk = TypeKlassPtr::make(TypePtr::NotNull, k, Type::Offset(offset));
     }
 
     // Check for precise loads from the primary supertype array and force them
     // to the supertype cache alias index.  Check for generic array loads from
     // the primary supertype array and also force them to the supertype cache
@@ -1416,11 +1415,11 @@
     if (offset == Type::OffsetBot ||
         (offset >= primary_supers_offset &&
          offset < (int)(primary_supers_offset + Klass::primary_super_limit() * wordSize)) ||
         offset == (int)in_bytes(Klass::secondary_super_cache_offset())) {
       offset = in_bytes(Klass::secondary_super_cache_offset());
-      tj = tk = TypeKlassPtr::make(TypePtr::NotNull, tk->klass(), Type::Offset(offset), tk->flat_array());
+      tj = tk = TypeKlassPtr::make(TypePtr::NotNull, tk->klass(), Type::Offset(offset));
     }
   }
 
   // Flatten all Raw pointers together.
   if (tj->base() == Type::RawPtr)
@@ -1680,11 +1679,11 @@
     // Set field() and is_rewritable() attributes.
     if (field != NULL) {
       alias_type(idx)->set_field(field);
       if (flat->isa_aryptr()) {
         // Fields of flat arrays are rewritable although they are declared final
-        assert(flat->is_aryptr()->elem()->isa_inlinetype(), "must be a flat array");
+        assert(flat->is_aryptr()->is_flat(), "must be a flat array");
         alias_type(idx)->set_rewritable(true);
       }
     }
   }
 
@@ -1999,11 +1998,11 @@
     // them.
     for (uint i = 0; i < AliasCacheSize; i++) {
       AliasCacheEntry* ace = &_alias_cache[i];
       if (ace->_adr_type != NULL &&
           ace->_adr_type->isa_aryptr() &&
-          ace->_adr_type->is_aryptr()->elem()->isa_inlinetype()) {
+          ace->_adr_type->is_aryptr()->is_flat()) {
         ace->_adr_type = NULL;
         ace->_index = (i != 0) ? 0 : AliasIdxTop; // Make sure the NULL adr_type resolves to AliasIdxTop
       }
     }
 
@@ -2122,11 +2121,11 @@
               igvn.replace_input_of(m, idx, mm);
               if (idx == m->req()-1) {
                 Node* r = m->in(0);
                 for (uint j = (uint)start_alias; j <= (uint)stop_alias; j++) {
                   const Type* adr_type = get_adr_type(j);
-                  if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->elem()->isa_inlinetype()) {
+                  if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat()) {
                     continue;
                   }
                   Node* phi = new PhiNode(r, Type::MEMORY, get_adr_type(j));
                   igvn.register_new_node_with_optimizer(phi);
                   for (uint k = 1; k < m->req(); k++) {
@@ -2152,11 +2151,11 @@
               assert(m->is_Proj(), "projection expected");
               Node* ctrl = m->in(0)->in(TypeFunc::Control);
               igvn.replace_input_of(m->in(0), TypeFunc::Control, top());
               for (uint j = (uint)start_alias; j <= (uint)stop_alias; j++) {
                 const Type* adr_type = get_adr_type(j);
-                if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->elem()->isa_inlinetype()) {
+                if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat()) {
                   continue;
                 }
                 MemBarNode* mb = new MemBarCPUOrderNode(this, j, NULL);
                 igvn.register_new_node_with_optimizer(mb);
                 Node* mem = mm->memory_at(j);
@@ -2195,11 +2194,11 @@
       } while(stack.size() > 0);
       // Fix the memory state at the MergeMem we started from
       igvn.rehash_node_delayed(current);
       for (uint j = (uint)start_alias; j <= (uint)stop_alias; j++) {
         const Type* adr_type = get_adr_type(j);
-        if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->elem()->isa_inlinetype()) {
+        if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat()) {
           continue;
         }
         current->set_memory_at(j, mm);
       }
       current->set_memory_at(index, current->base_memory());
diff a/src/hotspot/share/opto/escape.cpp b/src/hotspot/share/opto/escape.cpp
--- a/src/hotspot/share/opto/escape.cpp
+++ b/src/hotspot/share/opto/escape.cpp
@@ -992,11 +992,11 @@
                  aat->isa_ptr() != NULL, "expecting an Ptr");
           bool arg_has_oops = aat->isa_oopptr() &&
                               (aat->isa_oopptr()->klass() == NULL || aat->isa_instptr() ||
                                (aat->isa_aryptr() && aat->isa_aryptr()->klass()->is_obj_array_klass()) ||
                                (aat->isa_aryptr() && aat->isa_aryptr()->elem() != NULL &&
-                                aat->isa_aryptr()->elem()->isa_inlinetype() &&
+                                aat->isa_aryptr()->is_flat() &&
                                 aat->isa_aryptr()->elem()->inline_klass()->contains_oops()));
           if (i == TypeFunc::Parms) {
             src_has_oops = arg_has_oops;
           }
           //
@@ -2496,10 +2496,15 @@
   const TypePtr* tinst = base_t->add_offset(t->offset());
   if (tinst->isa_aryptr() && t->isa_aryptr()) {
     // In the case of a flattened inline type array, each field has its
     // own slice so we need to keep track of the field being accessed.
     tinst = tinst->is_aryptr()->with_field_offset(t->is_aryptr()->field_offset().get());
+    // Keep array properties (not flat/null-free)
+    tinst = tinst->is_aryptr()->update_properties(t->is_aryptr());
+    if (tinst == NULL) {
+      return false; // Skip dead path with inconsistent properties
+    }
   }
 
   // Do NOT remove the next line: ensure a new alias index is allocated
   // for the instance type. Note: C++ will not remove it since the call
   // has side effect.
@@ -3177,10 +3182,17 @@
           tn_t = tn_type->make_ptr()->isa_oopptr();
         } else {
           tn_t = tn_type->isa_oopptr();
         }
         if (tn_t != NULL && tinst->klass()->is_subtype_of(tn_t->klass())) {
+          if (tn_t->isa_aryptr()) {
+            // Keep array properties (not flat/null-free)
+            tinst = tinst->is_aryptr()->update_properties(tn_t->is_aryptr());
+            if (tinst == NULL) {
+              continue; // Skip dead path with inconsistent properties
+            }
+          }
           if (tn_type->isa_narrowoop()) {
             tn_type = tinst->make_narrowoop();
           } else {
             tn_type = tinst;
           }
diff a/src/hotspot/share/opto/graphKit.cpp b/src/hotspot/share/opto/graphKit.cpp
--- a/src/hotspot/share/opto/graphKit.cpp
+++ b/src/hotspot/share/opto/graphKit.cpp
@@ -3803,11 +3803,11 @@
     assert(klass != NULL, "klass should not be NULL");
     bool    xklass = inst_klass->klass_is_exact();
     bool can_be_flattened = false;
     if (UseFlatArray && klass->is_obj_array_klass()) {
       ciKlass* elem = klass->as_obj_array_klass()->element_klass();
-      can_be_flattened = elem->can_be_inline_klass() && (!elem->is_inlinetype() || elem->as_inline_klass()->flatten_array());
+      can_be_flattened = elem->can_be_inline_klass() && (!elem->is_inlinetype() || elem->flatten_array());
     }
     if (xklass || (klass->is_array_klass() && !can_be_flattened)) {
       jint lhelper = klass->layout_helper();
       if (lhelper != Klass::_lh_neutral_value) {
         constant_value = lhelper;
@@ -4437,11 +4437,11 @@
 }
 
 Node* GraphKit::load_String_value(Node* str, bool set_ctrl) {
   int value_offset = java_lang_String::value_offset();
   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C->env()->String_klass(),
-                                                     false, NULL, Type::Offset(0), false);
+                                                     false, NULL, Type::Offset(0));
   const TypePtr* value_field_type = string_type->add_offset(value_offset);
   const TypeAryPtr* value_type = TypeAryPtr::make(TypePtr::NotNull,
                                                   TypeAry::make(TypeInt::BYTE, TypeInt::POS, false, true, true),
                                                   ciTypeArrayKlass::make(T_BYTE), true, Type::Offset(0));
   Node* p = basic_plus_adr(str, str, value_offset);
@@ -4454,11 +4454,11 @@
   if (!CompactStrings) {
     return intcon(java_lang_String::CODER_UTF16);
   }
   int coder_offset = java_lang_String::coder_offset();
   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C->env()->String_klass(),
-                                                     false, NULL, Type::Offset(0), false);
+                                                     false, NULL, Type::Offset(0));
   const TypePtr* coder_field_type = string_type->add_offset(coder_offset);
 
   Node* p = basic_plus_adr(str, str, coder_offset);
   Node* load = access_load_at(str, p, coder_field_type, TypeInt::BYTE, T_BYTE,
                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
@@ -4466,21 +4466,21 @@
 }
 
 void GraphKit::store_String_value(Node* str, Node* value) {
   int value_offset = java_lang_String::value_offset();
   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C->env()->String_klass(),
-                                                     false, NULL, Type::Offset(0), false);
+                                                     false, NULL, Type::Offset(0));
   const TypePtr* value_field_type = string_type->add_offset(value_offset);
 
   access_store_at(str,  basic_plus_adr(str, value_offset), value_field_type,
                   value, TypeAryPtr::BYTES, T_OBJECT, IN_HEAP | MO_UNORDERED);
 }
 
 void GraphKit::store_String_coder(Node* str, Node* value) {
   int coder_offset = java_lang_String::coder_offset();
   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C->env()->String_klass(),
-                                                     false, NULL, Type::Offset(0), false);
+                                                     false, NULL, Type::Offset(0));
   const TypePtr* coder_field_type = string_type->add_offset(coder_offset);
 
   access_store_at(str, basic_plus_adr(str, coder_offset), coder_field_type,
                   value, TypeInt::BYTE, T_BYTE, IN_HEAP | MO_UNORDERED);
 }
diff a/src/hotspot/share/opto/library_call.cpp b/src/hotspot/share/opto/library_call.cpp
--- a/src/hotspot/share/opto/library_call.cpp
+++ b/src/hotspot/share/opto/library_call.cpp
@@ -3891,23 +3891,10 @@
   Node* original          = argument(0);
   Node* start             = is_copyOfRange? argument(1): intcon(0);
   Node* end               = is_copyOfRange? argument(2): argument(1);
   Node* array_type_mirror = is_copyOfRange? argument(3): argument(2);
 
-  const TypeAryPtr* original_t = _gvn.type(original)->isa_aryptr();
-  const TypeInstPtr* mirror_t = _gvn.type(array_type_mirror)->isa_instptr();
-  if (EnableValhalla && UseFlatArray &&
-      (original_t == NULL || mirror_t == NULL ||
-       (mirror_t->java_mirror_type() == NULL &&
-        (original_t->elem()->isa_inlinetype() ||
-         (original_t->elem()->make_oopptr() != NULL &&
-          original_t->elem()->make_oopptr()->can_be_inline_type()))))) {
-    // We need to know statically if the copy is to a flattened array
-    // or not but can't tell.
-    return false;
-  }
-
   Node* newcopy = NULL;
 
   // Set the original stack and the reexecute bit for the interpreter to reexecute
   // the bytecode that invokes Arrays.copyOf if deoptimization happens.
   { PreserveReexecuteState preexecs(this);
@@ -3935,11 +3922,11 @@
     Node* not_objArray = !bs->array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing) ?
         generate_typeArray_guard(klass_node, bailout) : generate_non_objArray_guard(klass_node, bailout);
     if (not_objArray != NULL) {
       // Improve the klass node's type from the new optimistic assumption:
       ciKlass* ak = ciArrayKlass::make(env()->Object_klass());
-      const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0), false);
+      const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0));
       Node* cast = new CastPPNode(klass_node, akls);
       cast->init_req(0, control());
       klass_node = _gvn.transform(cast);
     }
 
@@ -3966,20 +3953,21 @@
     }
 
     if (UseFlatArray) {
       // Either both or neither new array klass and original array
       // klass must be flattened
+      const TypeAryPtr* t_original = _gvn.type(original)->isa_aryptr();
       Node* is_flat = generate_flatArray_guard(klass_node, NULL);
-      if (!original_t->is_not_flat()) {
+      if (t_original == NULL || !t_original->is_not_flat()) {
         generate_flatArray_guard(original_kls, bailout);
       }
       if (is_flat != NULL) {
         RegionNode* r = new RegionNode(2);
         record_for_igvn(r);
         r->init_req(1, control());
         set_control(is_flat);
-        if (!original_t->is_not_flat()) {
+        if (t_original == NULL || !t_original->is_not_flat()) {
           generate_flatArray_guard(original_kls, r);
         }
         bailout->add_req(control());
         set_control(_gvn.transform(r));
       }
@@ -5063,13 +5051,17 @@
       }
       if (could_have_src && could_have_dest) {
         // If we can have both exact types, emit the missing guards
         if (could_have_src && !src_spec) {
           src = maybe_cast_profiled_obj(src, src_k, true);
+          src_type = _gvn.type(src);
+          top_src = src_type->isa_aryptr();
         }
         if (could_have_dest && !dest_spec) {
           dest = maybe_cast_profiled_obj(dest, dest_k, true);
+          dest_type = _gvn.type(dest);
+          top_dest = dest_type->isa_aryptr();
         }
       }
     }
   }
 
@@ -5141,17 +5133,20 @@
     const Type* toop = TypeOopPtr::make_from_klass(dest_klass_t->klass());
     src = _gvn.transform(new CheckCastPPNode(control(), src, toop));
     src_type = _gvn.type(src);
     top_src  = src_type->isa_aryptr();
 
-    if (top_dest != NULL && !top_dest->elem()->isa_inlinetype() && !top_dest->is_not_flat()) {
+    if (top_dest != NULL && !top_dest->is_flat() && !top_dest->is_not_flat()) {
       generate_flatArray_guard(dest_klass, slow_region);
+      top_dest = top_dest->cast_to_not_flat();
+      dest = _gvn.transform(new CheckCastPPNode(control(), dest, top_dest));
     }
-
-    if (top_src != NULL && !top_src->elem()->isa_inlinetype() && !top_src->is_not_flat()) {
+    if (top_src != NULL && !top_src->is_flat() && !top_src->is_not_flat()) {
       Node* src_klass = load_object_klass(src);
       generate_flatArray_guard(src_klass, slow_region);
+      top_src = top_src->cast_to_not_flat();
+      src = _gvn.transform(new CheckCastPPNode(control(), src, top_src));
     }
 
     {
       PreserveJVMState pjvms(this);
       set_control(_gvn.transform(slow_region));
diff a/src/hotspot/share/opto/macroArrayCopy.cpp b/src/hotspot/share/opto/macroArrayCopy.cpp
--- a/src/hotspot/share/opto/macroArrayCopy.cpp
+++ b/src/hotspot/share/opto/macroArrayCopy.cpp
@@ -1412,15 +1412,15 @@
                          slow_region);
 
     // (9) each element of an oop array must be assignable
     // The generate_arraycopy subroutine checks this.
 
-    if (dest_elem == T_OBJECT && !top_dest->elem()->isa_inlinetype() && !top_dest->is_not_flat()) {
+    if (dest_elem == T_OBJECT && !top_dest->is_flat() && !top_dest->is_not_flat()) {
       generate_flattened_array_guard(&ctrl, merge_mem, dest, slow_region);
     }
 
-    if (src_elem == T_OBJECT && !top_src->elem()->isa_inlinetype() && !top_src->is_not_flat()) {
+    if (src_elem == T_OBJECT && !top_src->is_flat() && !top_src->is_not_flat()) {
       generate_flattened_array_guard(&ctrl, merge_mem, src, slow_region);
     }
   }
 
   // This is where the memory effects are placed:
diff a/src/hotspot/share/opto/memnode.cpp b/src/hotspot/share/opto/memnode.cpp
--- a/src/hotspot/share/opto/memnode.cpp
+++ b/src/hotspot/share/opto/memnode.cpp
@@ -220,15 +220,10 @@
            ->is_oopptr()->cast_to_ptr_type(t_oop->ptr())
             ->is_oopptr()->cast_to_instance_id(t_oop->instance_id()) == t_oop)) {
       // clone the Phi with our address type
       result = mphi->split_out_instance(t_adr, igvn);
     } else {
-      if (t->isa_aryptr()) {
-        // In the case of a flattened inline type array, each field has its own slice.
-        // TODO This should be re-evaluated with JDK-8251039
-        t = t->is_aryptr()->with_field_offset(t_adr->is_aryptr()->field_offset().get());
-      }
       assert(phase->C->get_alias_index(t) == phase->C->get_alias_index(t_adr), "correct memory chain");
     }
   }
   return result;
 }
@@ -2274,11 +2269,11 @@
         // Return precise klass
         return TypeKlassPtr::make(ik);
       }
 
       // Return root of possible klass
-      return TypeKlassPtr::make(TypePtr::NotNull, ik, Type::Offset(0), tinst->flat_array());
+      return TypeKlassPtr::make(TypePtr::NotNull, ik, Type::Offset(0), tinst->flatten_array());
     }
   }
 
   // Check for loading klass from an array
   const TypeAryPtr *tary = tp->isa_aryptr();
@@ -2305,13 +2300,12 @@
             }
             // Return precise array klass
             return TypeKlassPtr::make(ak);
           }
         }
-        return TypeKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0), false);
+        return TypeKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0));
       } else if (ak->is_type_array_klass()) {
-        //assert(!UseExactTypes, "this code should be useless with exact types");
         return TypeKlassPtr::make(ak); // These are always precise
       }
     }
   }
 
@@ -2329,15 +2323,15 @@
       // // e.g., element type could be object and array may contain strings
       // return TypeKlassPtr::make(TypePtr::Constant, elem, 0);
 
       // The array's TypeKlassPtr was declared 'precise' or 'not precise'
       // according to the element type's subclassing.
-      return TypeKlassPtr::make(tkls->ptr(), elem, Type::Offset(0), elem->flatten_array());
+      return TypeKlassPtr::make(tkls->ptr(), elem, Type::Offset(0));
     } else if (klass->is_flat_array_klass() &&
                tkls->offset() == in_bytes(ObjArrayKlass::element_klass_offset())) {
       ciKlass* elem = klass->as_flat_array_klass()->element_klass();
-      return TypeKlassPtr::make(tkls->ptr(), elem, Type::Offset(0), /* flat_array= */ true);
+      return TypeKlassPtr::make(tkls->ptr(), elem, Type::Offset(0), /* flatten_array= */ true);
     }
     if( klass->is_instance_klass() && tkls->klass_is_exact() &&
         tkls->offset() == in_bytes(Klass::super_offset())) {
       ciKlass* sup = klass->as_instance_klass()->super();
       // The field is Klass::_super.  Return its (constant) value.
diff a/src/hotspot/share/opto/parse2.cpp b/src/hotspot/share/opto/parse2.cpp
--- a/src/hotspot/share/opto/parse2.cpp
+++ b/src/hotspot/share/opto/parse2.cpp
@@ -79,17 +79,17 @@
   Node* ary = pop();
 
   // Handle inline type arrays
   const TypeOopPtr* elemptr = elemtype->make_oopptr();
   const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();
-  if (elemtype->isa_inlinetype() != NULL) {
+  if (ary_t->is_flat()) {
     C->set_flattened_accesses();
     // Load from flattened inline type array
     Node* vt = InlineTypeNode::make_from_flattened(this, elemtype->inline_klass(), ary, adr);
     push(vt);
     return;
-  } else if (elemptr != NULL && elemptr->is_inlinetypeptr() && !elemptr->maybe_null()) {
+  } else if (ary_t->is_null_free()) {
     // Load from non-flattened inline type array (elements can never be null)
     bt = T_INLINE_TYPE;
   } else if (!ary_t->is_not_flat()) {
     // Cannot statically determine if array is flattened, emit runtime check
     assert(UseFlatArray && is_reference_type(bt) && elemptr->can_be_inline_type() && !ary_t->klass_is_exact() && !ary_t->is_not_null_free() &&
@@ -187,11 +187,11 @@
         // Prevent any use of the newly allocated inline type before it is fully initialized
         alloc_obj = new CastPPNode(alloc_obj, _gvn.type(alloc_obj), true);
         alloc_obj->set_req(0, control());
         alloc_obj = _gvn.transform(alloc_obj);
 
-        const Type* unknown_value = elemptr->is_instptr()->cast_to_flat_array();
+        const Type* unknown_value = elemptr->is_instptr()->cast_to_flatten_array();
         alloc_obj = _gvn.transform(new CheckCastPPNode(control(), alloc_obj, unknown_value));
 
         ideal.sync_kit(this);
         ideal.set(res, alloc_obj);
       }
@@ -269,11 +269,11 @@
       Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
       replace_in_map(ary, cast);
       ary = cast;
     }
 
-    if (ary_t->elem()->isa_inlinetype() != NULL) {
+    if (ary_t->is_flat()) {
       // Store to flattened inline type array
       C->set_flattened_accesses();
       if (!cast_val->is_InlineType()) {
         inc_sp(3);
         cast_val = null_check(cast_val);
@@ -285,11 +285,11 @@
       PreserveReexecuteState preexecs(this);
       inc_sp(3);
       jvms()->set_should_reexecute(true);
       cast_val->as_InlineType()->store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);
       return;
-    } else if (elemtype->is_inlinetypeptr() && !elemtype->maybe_null()) {
+    } else if (ary_t->is_null_free()) {
       // Store to non-flattened inline type array (elements can never be null)
       if (!cast_val->is_InlineType() && tval->maybe_null()) {
         inc_sp(3);
         cast_val = null_check(cast_val);
         if (stopped()) return;
diff a/src/hotspot/share/opto/subnode.cpp b/src/hotspot/share/opto/subnode.cpp
--- a/src/hotspot/share/opto/subnode.cpp
+++ b/src/hotspot/share/opto/subnode.cpp
@@ -939,14 +939,17 @@
         // If klass0's type is PRECISE, then classes are unrelated.
         unrelated_classes = xklass0;
       } else {                  // Neither subtypes the other
         unrelated_classes = true;
       }
-      if ((r0->flat_array() && (!r1->can_be_inline_type() || (klass1->is_inlinetype() && !klass1->flatten_array()))) ||
-          (r1->flat_array() && (!r0->can_be_inline_type() || (klass0->is_inlinetype() && !klass0->flatten_array())))) {
-        // One type is flattened in arrays and the other type is not. Must be unrelated.
-        unrelated_classes = true;
+      if (!unrelated_classes) {
+        // Handle inline type arrays
+        if ((r0->flatten_array() && (!r1->can_be_inline_type() || (klass1->is_inlinetype() && !klass1->flatten_array()))) ||
+            (r1->flatten_array() && (!r0->can_be_inline_type() || (klass0->is_inlinetype() && !klass0->flatten_array())))) {
+          // One type is flattened in arrays but the other type is not. Must be unrelated.
+          unrelated_classes = true;
+        }
       }
       if (unrelated_classes) {
         // The oops classes are known to be unrelated. If the joined PTRs of
         // two oops is not Null and not Bottom, then we are sure that one
         // of the two oops is non-null, and the comparison will always fail.
diff a/src/hotspot/share/opto/subtypenode.cpp b/src/hotspot/share/opto/subtypenode.cpp
--- a/src/hotspot/share/opto/subtypenode.cpp
+++ b/src/hotspot/share/opto/subtypenode.cpp
@@ -74,15 +74,23 @@
     } else {
       // Neither class subtypes the other: they are unrelated and this
       // type check is known to fail.
       unrelated_classes = true;
     }
-    // Ignore exactness of constant supertype (the type of the corresponding object may be non-exact).
-    const TypeKlassPtr* casted_sup = super_t->is_klassptr()->cast_to_exactness(false)->is_klassptr();
-    if (sub_t->is_ptr()->flat_array() && (!casted_sup->can_be_inline_type() || (superk->is_inlinetype() && !superk->flatten_array()))) {
-      // Subtype is flattened in arrays but supertype is not. Must be unrelated.
-      unrelated_classes = true;
+    if (!unrelated_classes) {
+      // Handle inline type arrays
+      if (sub_t->isa_aryptr() && sub_t->is_aryptr()->is_not_flat() && superk->is_flat_array_klass()) {
+        // Subtype is not a flat array but supertype is. Must be unrelated.
+        unrelated_classes = true;
+      } else if (sub_t->isa_aryptr() && sub_t->is_aryptr()->is_not_null_free() &&
+                 superk->is_obj_array_klass() && superk->as_obj_array_klass()->element_klass()->is_inlinetype()) {
+        // Subtype is not a null-free array but supertype is. Must be unrelated.
+        unrelated_classes = true;
+      } else if (sub_t->is_ptr()->flatten_array() && (!superk->can_be_inline_klass() || (superk->is_inlinetype() && !superk->flatten_array()))) {
+        // Subtype is flattened in arrays but supertype is not. Must be unrelated.
+        unrelated_classes = true;
+      }
     }
     if (unrelated_classes) {
       TypePtr::PTR jp = sub_t->is_ptr()->join_ptr(super_t->is_ptr()->_ptr);
       if (jp != TypePtr::Null && jp != TypePtr::BotPTR) {
         return TypeInt::CC_GT;
diff a/src/hotspot/share/opto/type.cpp b/src/hotspot/share/opto/type.cpp
--- a/src/hotspot/share/opto/type.cpp
+++ b/src/hotspot/share/opto/type.cpp
@@ -587,13 +587,13 @@
 
   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current->env()->Object_klass());
   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current->env()->Object_klass());
   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current->env()->Class_klass());
   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current->env()->Object_klass(),
-                                           false, 0, Offset(oopDesc::mark_offset_in_bytes()), false);
+                                           false, 0, Offset(oopDesc::mark_offset_in_bytes()));
   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current->env()->Object_klass(),
-                                           false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);
+                                           false, 0, Offset(oopDesc::klass_offset_in_bytes()));
   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
 
   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
 
   TypeInlineType::BOTTOM = TypeInlineType::make(NULL);
@@ -648,12 +648,12 @@
   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 
-  TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current->env()->Object_klass(), Offset(0), false);
-  TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current->env()->Object_klass(), Offset(0), false);
+  TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current->env()->Object_klass(), Offset(0));
+  TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current->env()->Object_klass(), Offset(0));
 
   const Type **fi2c = TypeTuple::fields(2);
   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
@@ -3337,23 +3337,10 @@
   // There is no such thing as an exact general oop.
   // Return self unchanged.
   return this;
 }
 
-
-//------------------------------as_klass_type----------------------------------
-// Return the klass type corresponding to this instance or array type.
-// It is the type that is loaded from an object of this type.
-const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
-  ciKlass* k = klass();
-  bool    xk = klass_is_exact();
-  if (k == NULL)
-    return TypeKlassPtr::OBJECT;
-  else
-    return TypeKlassPtr::make(xk? Constant: NotNull, k, Offset(0), isa_instptr() && is_instptr()->flat_array());
-}
-
 //------------------------------meet-------------------------------------------
 // Compute the MEET of two types.  It returns a new Type object.
 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
   // Perform a fast test for common case; meeting the same types together.
   if( this == t ) return this;  // Meeting same type-rep?
@@ -3459,11 +3446,11 @@
         // Add a dependence; if concrete subclass added we need to recompile
         deps->assert_leaf_type(ik);
         klass_is_exact = true;
       }
     }
-    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass->flatten_array());
+    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0));
   } else if (klass->is_obj_array_klass()) {
     // Element is an object or inline type array. Recursively call ourself.
     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), /* klass_change= */ false, try_for_exact);
     if (etype->is_inlinetypeptr()) {
       etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();
@@ -3515,11 +3502,11 @@
   if (klass->is_instance_klass() || klass->is_inlinetype()) {
     // Element is an instance or inline type
     if (make_constant) {
       return TypeInstPtr::make(o);
     } else {
-      return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass->flatten_array());
+      return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0));
     }
   } else if (klass->is_obj_array_klass()) {
     // Element is an object array. Recursively call ourself.
     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass->as_array_klass()->element_klass());
     bool null_free = false;
@@ -3772,28 +3759,28 @@
 const TypeInstPtr *TypeInstPtr::MARK;
 const TypeInstPtr *TypeInstPtr::KLASS;
 
 //------------------------------TypeInstPtr-------------------------------------
 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,
-                         bool flat_array, int instance_id, const TypePtr* speculative,
+                         bool flatten_array, int instance_id, const TypePtr* speculative,
                          int inline_depth)
   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
-    _name(k->name()), _flat_array(flat_array) {
-   assert(k != NULL &&
-          (k->is_loaded() || o == NULL),
-          "cannot have constants with non-loaded klass");
-   assert(!klass()->is_inlinetype() || !klass()->flatten_array() || flat_array, "incorrect flatten array bit");
-   assert(!flat_array || can_be_inline_type(), "incorrect flatten array bit");
+    _name(k->name()), _flatten_array(flatten_array) {
+  assert(k != NULL &&
+         (k->is_loaded() || o == NULL),
+         "cannot have constants with non-loaded klass");
+  assert(!klass()->flatten_array() || flatten_array, "Should be flat in array");
+  assert(!flatten_array || can_be_inline_type(), "Only inline types can be flat in array");
 };
 
 //------------------------------make-------------------------------------------
 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
                                      ciKlass* k,
                                      bool xk,
                                      ciObject* o,
                                      Offset offset,
-                                     bool flat_array,
+                                     bool flatten_array,
                                      int instance_id,
                                      const TypePtr* speculative,
                                      int inline_depth) {
   assert( !k->is_loaded() || k->is_instance_klass(), "Must be for instance");
   // Either const_oop() is NULL or else ptr is Constant
@@ -3810,13 +3797,16 @@
     ciInstanceKlass* ik = k->as_instance_klass();
     if (!xk && ik->is_final())     xk = true;   // no inexact final klass
     if (xk && ik->is_interface())  xk = false;  // no exact interface
   }
 
+  // Check if this type is known to be flat in arrays
+  flatten_array = flatten_array || k->flatten_array();
+
   // Now hash this baby
   TypeInstPtr *result =
-    (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, flat_array, instance_id, speculative, inline_depth))->hashcons();
+    (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o, offset, flatten_array, instance_id, speculative, inline_depth))->hashcons();
 
   return result;
 }
 
 /**
@@ -3845,28 +3835,28 @@
 //------------------------------cast_to_ptr_type-------------------------------
 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
   if( ptr == _ptr ) return this;
   // Reconstruct _sig info here since not a problem with later lazy
   // construction, _sig will show up on demand.
-  return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);
+  return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flatten_array, _instance_id, _speculative, _inline_depth);
 }
 
 
 //-----------------------------cast_to_exactness-------------------------------
 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
   if( klass_is_exact == _klass_is_exact ) return this;
   if (!_klass->is_loaded())  return this;
   ciInstanceKlass* ik = _klass->as_instance_klass();
   if( (ik->is_final() || _const_oop) )  return this;  // cannot clear xk
   if( ik->is_interface() )              return this;  // cannot set xk
-  return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);
+  return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flatten_array, _instance_id, _speculative, _inline_depth);
 }
 
 //-----------------------------cast_to_instance_id----------------------------
 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
   if( instance_id == _instance_id ) return this;
-  return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flat_array, instance_id, _speculative, _inline_depth);
+  return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flatten_array, instance_id, _speculative, _inline_depth);
 }
 
 //------------------------------xmeet_unloaded---------------------------------
 // Compute the MEET of two InstPtrs when at least one is unloaded.
 // Assume classes are different since called after check for same name/class-loader
@@ -3958,11 +3948,11 @@
     case TopPTR:
     case AnyNull:                // Fall 'down' to dual of object klass
       // For instances when a subclass meets a superclass we fall
       // below the centerline when the superclass is exact. We need to
       // do the same here.
-      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact() && !flat_array()) {
+      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact() && !flatten_array()) {
         return TypeAryPtr::make(ptr, tp->ary(), tp->klass(), tp->klass_is_exact(), offset, tp->field_offset(), instance_id, speculative, depth);
       } else {
         // cannot subclass, so the meet has to fall badly below the centerline
         ptr = NotNull;
         instance_id = InstanceBot;
@@ -3976,11 +3966,11 @@
         // If 'this' (InstPtr) is above the centerline and it is Object class
         // then we can subclass in the Java class hierarchy.
         // For instances when a subclass meets a superclass we fall
         // below the centerline when the superclass is exact. We need
         // to do the same here.
-        if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact() && !flat_array()) {
+        if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact() && !flatten_array()) {
           // that is, tp's array type is a subtype of my klass
           return TypeAryPtr::make(ptr, (ptr == Constant ? tp->const_oop() : NULL),
                                   tp->ary(), tp->klass(), tp->klass_is_exact(), offset, tp->field_offset(), instance_id, speculative, depth);
         }
       }
@@ -4004,11 +3994,11 @@
     case AnyNull: {
       int instance_id = meet_instance_id(InstanceTop);
       const TypePtr* speculative = xmeet_speculative(tp);
       int depth = meet_inline_depth(tp->inline_depth());
       return make(ptr, klass(), klass_is_exact(),
-                  (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);
+                  (ptr == Constant ? const_oop() : NULL), offset, flatten_array(), instance_id, speculative, depth);
     }
     case NotNull:
     case BotPTR: {
       int instance_id = meet_instance_id(tp->instance_id());
       const TypePtr* speculative = xmeet_speculative(tp);
@@ -4032,11 +4022,11 @@
       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
       // else fall through to AnyNull
     case TopPTR:
     case AnyNull: {
       return make(ptr, klass(), klass_is_exact(),
-                  (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);
+                  (ptr == Constant ? const_oop() : NULL), offset, flatten_array(), instance_id, speculative, depth);
     }
     case NotNull:
     case BotPTR:
       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
     default: typerr(t);
@@ -4071,21 +4061,21 @@
     // Check for easy case; klasses are equal (and perhaps not loaded!)
     // If we have constants, then we created oops so classes are loaded
     // and we can handle the constants further down.  This case handles
     // both-not-loaded or both-loaded classes
     if (ptr != Constant && klass()->equals(tinst->klass()) && klass_is_exact() == tinst->klass_is_exact() &&
-        flat_array() == tinst->flat_array()) {
-      return make(ptr, klass(), klass_is_exact(), NULL, off, flat_array(), instance_id, speculative, depth);
+        flatten_array() == tinst->flatten_array()) {
+      return make(ptr, klass(), klass_is_exact(), NULL, off, flatten_array(), instance_id, speculative, depth);
     }
 
     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
     ciKlass* tinst_klass = tinst->klass();
     ciKlass* this_klass  = this->klass();
     bool tinst_xk = tinst->klass_is_exact();
     bool this_xk  = this->klass_is_exact();
-    bool tinst_flat_array = tinst->flat_array();
-    bool this_flat_array  = this->flat_array();
+    bool tinst_flatten_array = tinst->flatten_array();
+    bool this_flatten_array  = this->flatten_array();
     if (!tinst_klass->is_loaded() || !this_klass->is_loaded() ) {
       // One of these classes has not been loaded
       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
 #ifndef PRODUCT
       if( PrintOpto && Verbose ) {
@@ -4104,13 +4094,13 @@
       tinst_klass = this_klass;
       this_klass = tmp;
       bool tmp2 = tinst_xk;
       tinst_xk = this_xk;
       this_xk = tmp2;
-      tmp2 = tinst_flat_array;
-      tinst_flat_array = this_flat_array;
-      this_flat_array = tmp2;
+      tmp2 = tinst_flatten_array;
+      tinst_flatten_array = this_flatten_array;
+      this_flatten_array = tmp2;
     }
     if (tinst_klass->is_interface() &&
         !(this_klass->is_interface() ||
           // Treat java/lang/Object as an honorary interface,
           // because we need a bottom for the interface hierarchy.
@@ -4127,18 +4117,18 @@
         // below the centerline.  If we are on the centerline
         // (e.g., Constant vs. AnyNull interface), use the constant.
         k  = below_centerline(ptr) ? tinst_klass : this_klass;
         // If we are keeping this_klass, keep its exactness too.
         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
-        flat_array = below_centerline(ptr) ? tinst_flat_array    : this_flat_array;
+        flat_array = below_centerline(ptr) ? tinst_flatten_array    : this_flatten_array;
       } else {                  // Does not implement, fall to Object
         // Oop does not implement interface, so mixing falls to Object
         // just like the verifier does (if both are above the
         // centerline fall to interface)
         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()->Object_klass();
         xk = above_centerline(ptr) ? tinst_xk : false;
-        flat_array = above_centerline(ptr) ? tinst_flat_array : false;
+        flat_array = above_centerline(ptr) ? tinst_flatten_array : false;
         // Watch out for Constant vs. AnyNull interface.
         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
         instance_id = InstanceBot;
       }
       ciObject* o = NULL;  // the Constant value, if any
@@ -4180,37 +4170,37 @@
     bool subtype_exact = false;
     bool flat_array = false;
     if (tinst_klass->equals(this_klass)) {
       subtype = this_klass;
       subtype_exact = below_centerline(ptr) ? (this_xk && tinst_xk) : (this_xk || tinst_xk);
-      flat_array = below_centerline(ptr) ? (this_flat_array && tinst_flat_array) : (this_flat_array || tinst_flat_array);
-    } else if(!tinst_xk && this_klass->is_subtype_of(tinst_klass) && (!tinst_flat_array || this_flat_array)) {
+      flat_array = below_centerline(ptr) ? (this_flatten_array && tinst_flatten_array) : (this_flatten_array || tinst_flatten_array);
+    } else if(!tinst_xk && this_klass->is_subtype_of(tinst_klass) && (!tinst_flatten_array || this_flatten_array)) {
       subtype = this_klass;     // Pick subtyping class
       subtype_exact = this_xk;
-      flat_array = this_flat_array;
-    } else if(!this_xk && tinst_klass->is_subtype_of(this_klass) && (!this_flat_array || tinst_flat_array)) {
+      flat_array = this_flatten_array;
+    } else if(!this_xk && tinst_klass->is_subtype_of(this_klass) && (!this_flatten_array || tinst_flatten_array)) {
       subtype = tinst_klass;    // Pick subtyping class
       subtype_exact = tinst_xk;
-      flat_array = tinst_flat_array;
+      flat_array = tinst_flatten_array;
     }
 
     if (subtype) {
       if (above_centerline(ptr)) { // both are up?
         this_klass = tinst_klass = subtype;
         this_xk = tinst_xk = subtype_exact;
-        this_flat_array = tinst_flat_array = flat_array;
+        this_flatten_array = tinst_flatten_array = flat_array;
       } else if (above_centerline(this ->_ptr) && !above_centerline(tinst->_ptr)) {
         this_klass = tinst_klass; // tinst is down; keep down man
         this_xk = tinst_xk;
-        this_flat_array = tinst_flat_array;
+        this_flatten_array = tinst_flatten_array;
       } else if (above_centerline(tinst->_ptr) && !above_centerline(this ->_ptr)) {
         tinst_klass = this_klass; // this is down; keep down man
         tinst_xk = this_xk;
-        tinst_flat_array = this_flat_array;
+        tinst_flatten_array = this_flatten_array;
       } else {
         this_xk = subtype_exact;  // either they are equal, or we'll do an LCA
-        this_flat_array = flat_array;
+        this_flatten_array = flat_array;
       }
     }
 
     // Check for classes now being equal
     if (tinst_klass->equals(this_klass)) {
@@ -4229,11 +4219,11 @@
         else if (above_centerline(tinst ->_ptr))
           o = this_oop;
         else
           ptr = NotNull;
       }
-      return make(ptr, this_klass, this_xk, o, off, this_flat_array, instance_id, speculative, depth);
+      return make(ptr, this_klass, this_xk, o, off, this_flatten_array, instance_id, speculative, depth);
     } // Else classes are not equal
 
     // Since klasses are different, we require a LCA in the Java
     // class hierarchy - which means we have to fall to at least NotNull.
     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
@@ -4285,27 +4275,27 @@
 
 //------------------------------xdual------------------------------------------
 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
 // inheritance mechanism.
 const Type *TypeInstPtr::xdual() const {
-  return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flat_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());
+  return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flatten_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());
 }
 
 //------------------------------eq---------------------------------------------
 // Structural equality check for Type representations
 bool TypeInstPtr::eq( const Type *t ) const {
   const TypeInstPtr *p = t->is_instptr();
   return
     klass()->equals(p->klass()) &&
-    flat_array() == p->flat_array() &&
+    flatten_array() == p->flatten_array() &&
     TypeOopPtr::eq(p);          // Check sub-type stuff
 }
 
 //------------------------------hash-------------------------------------------
 // Type-specific hashing function.
 int TypeInstPtr::hash(void) const {
-  int hash = java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), (jint)flat_array());
+  int hash = java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), (jint)flatten_array());
   return hash;
 }
 
 //------------------------------dump2------------------------------------------
 // Dump oop Type
@@ -4337,11 +4327,11 @@
 
   _offset.dump2(st);
 
   st->print(" *");
 
-  if (flat_array() && !klass()->is_inlinetype()) {
+  if (flatten_array() && !klass()->is_inlinetype()) {
     st->print(" (flatten array)");
   }
 
   if (_instance_id == InstanceTop)
     st->print(",iid=top");
@@ -4353,36 +4343,36 @@
 }
 #endif
 
 //------------------------------add_offset-------------------------------------
 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
-  return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flat_array(),
+  return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flatten_array(),
               _instance_id, add_offset_speculative(offset), _inline_depth);
 }
 
 const Type *TypeInstPtr::remove_speculative() const {
   if (_speculative == NULL) {
     return this;
   }
   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, "non speculative type shouldn't have inline depth");
-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(),
+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(),
               _instance_id, NULL, _inline_depth);
 }
 
 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
   if (!UseInlineDepthForSpeculativeTypes) {
     return this;
   }
-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), _instance_id, _speculative, depth);
+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(), _instance_id, _speculative, depth);
 }
 
 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
   assert(is_known_instance(), "should be known");
-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), instance_id, _speculative, _inline_depth);
+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(), instance_id, _speculative, _inline_depth);
 }
 
-const TypeInstPtr *TypeInstPtr::cast_to_flat_array() const {
+const TypeInstPtr *TypeInstPtr::cast_to_flatten_array() const {
   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);
 }
 
 
 //=============================================================================
@@ -4521,10 +4511,25 @@
   // Not null free implies not flat
   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);
   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
 }
 
+//---------------------------------update_properties---------------------------
+const TypeAryPtr* TypeAryPtr::update_properties(const TypeAryPtr* from) const {
+  if ((from->is_flat()          && is_not_flat()) ||
+      (from->is_not_flat()      && is_flat()) ||
+      (from->is_null_free()     && is_not_null_free()) ||
+      (from->is_not_null_free() && is_null_free())) {
+    return NULL; // Inconsistent properties
+  } else if (from->is_not_null_free()) {
+    return cast_to_not_null_free(); // Implies not flat
+  } else if (from->is_not_flat()) {
+    return cast_to_not_flat();
+  }
+  return this;
+}
+
 //------------------------------cast_to_stable---------------------------------
 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
   if (stable_dimension <= 0 || (stable_dimension == 1 && stable == this->is_stable()))
     return this;
 
@@ -4699,12 +4704,12 @@
       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
     } else if (klass() != NULL && tap->klass() != NULL && klass()->is_flat_array_klass() != tap->klass()->is_flat_array_klass()) {
       // Meeting flattened inline type array with non-flattened array. Adjust (field) offset accordingly.
       if (tary->_elem->isa_inlinetype()) {
         // Result is flattened
-        off = Offset(elem()->isa_inlinetype() ? offset() : tap->offset());
-        field_off = elem()->isa_inlinetype() ? field_offset() : tap->field_offset();
+        off = Offset(is_flat() ? offset() : tap->offset());
+        field_off = is_flat() ? field_offset() : tap->field_offset();
       } else if (tary->_elem->make_oopptr() != NULL && tary->_elem->make_oopptr()->isa_instptr() && below_centerline(ptr)) {
         // Result is non-flattened
         off = Offset(flattened_offset()).meet(Offset(tap->flattened_offset()));
         field_off = Offset::bottom;
       }
@@ -4765,11 +4770,11 @@
     case TopPTR:
     case AnyNull:                // Fall 'down' to dual of object klass
       // For instances when a subclass meets a superclass we fall
       // below the centerline when the superclass is exact. We need to
       // do the same here.
-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact() && !tp->flat_array()) {
+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact() && !tp->flatten_array()) {
         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
       } else {
         // cannot subclass, so the meet has to fall badly below the centerline
         ptr = NotNull;
         instance_id = InstanceBot;
@@ -4783,11 +4788,11 @@
         // If 'tp'  is above the centerline and it is Object class
         // then we can subclass in the Java class hierarchy.
         // For instances when a subclass meets a superclass we fall
         // below the centerline when the superclass is exact. We need
         // to do the same here.
-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact() && !tp->flat_array()) {
+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact() && !tp->flatten_array()) {
           // that is, my array type is a subtype of 'tp' klass
           return make(ptr, (ptr == Constant ? const_oop() : NULL),
                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
         }
       }
@@ -4864,11 +4869,11 @@
     break;
   default:
     break;
   }
 
-  if (elem()->isa_inlinetype()) {
+  if (is_flat()) {
     st->print("(");
     _field_offset.dump2(st);
     st->print(")");
   }
   if (offset() != 0) {
@@ -5335,34 +5340,36 @@
 // Not-null object klass or below
 const TypeKlassPtr *TypeKlassPtr::OBJECT;
 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
 
 //------------------------------TypeKlassPtr-----------------------------------
-TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)
-  : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {
-   assert(!klass->is_inlinetype() || !klass->flatten_array() || flat_array, "incorrect flatten array bit");
-   assert(!flat_array || can_be_inline_type(), "incorrect flatten array bit");
+TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flatten_array)
+  : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flatten_array(flatten_array) {
+  assert(!klass->flatten_array() || flatten_array, "Should be flat in array");
+  assert(!flatten_array || can_be_inline_type(), "Only inline types can be flat in array");
 }
 
 //------------------------------make-------------------------------------------
 // ptr to klass 'k', if Constant, or possibly to a sub-klass if not a Constant
-const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {
+const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array) {
   assert(k == NULL || k->is_instance_klass() || k->is_array_klass(), "Incorrect type of klass oop");
-  return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flat_array))->hashcons();
+  // Check if this type is known to be flat in arrays
+  flatten_array = flatten_array || k->flatten_array();
+  return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flatten_array))->hashcons();
 }
 
 //------------------------------eq---------------------------------------------
 // Structural equality check for Type representations
 bool TypeKlassPtr::eq( const Type *t ) const {
   const TypeKlassPtr *p = t->is_klassptr();
-  return klass() == p->klass() && TypePtr::eq(p) && flat_array() == p->flat_array();
+  return klass() == p->klass() && TypePtr::eq(p) && flatten_array() == p->flatten_array();
 }
 
 //------------------------------hash-------------------------------------------
 // Type-specific hashing function.
 int TypeKlassPtr::hash(void) const {
-  return java_add(java_add(klass() != NULL ? klass()->hash() : (jint)0, (jint)TypePtr::hash()), (jint)flat_array());
+  return java_add(java_add(klass() != NULL ? klass()->hash() : (jint)0, (jint)TypePtr::hash()), (jint)flatten_array());
 }
 
 //------------------------------singleton--------------------------------------
 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
 // constants
@@ -5492,25 +5499,25 @@
 
 
 //------------------------------add_offset-------------------------------------
 // Access internals of klass object
 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
-  return make(_ptr, klass(), xadd_offset(offset), flat_array());
+  return make(_ptr, klass(), xadd_offset(offset), flatten_array());
 }
 
 //------------------------------cast_to_ptr_type-------------------------------
 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
   assert(_base == KlassPtr, "subclass must override cast_to_ptr_type");
   if( ptr == _ptr ) return this;
-  return make(ptr, _klass, _offset, _flat_array);
+  return make(ptr, _klass, _offset, _flatten_array);
 }
 
 
 //-----------------------------cast_to_exactness-------------------------------
 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
   if( klass_is_exact == _klass_is_exact ) return this;
-  return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flat_array);
+  return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flatten_array);
 }
 
 
 //-----------------------------as_instance_type--------------------------------
 // Corresponding type for an instance of the given class.
@@ -5521,12 +5528,12 @@
   bool    xk = klass_is_exact();
   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
   guarantee(toop != NULL, "need type for given klass");
   toop = toop->cast_to_ptr_type(TypePtr::NotNull)->is_oopptr();
-  if (flat_array() && !klass()->is_inlinetype()) {
-    toop = toop->is_instptr()->cast_to_flat_array();
+  if (flatten_array() && !klass()->is_inlinetype()) {
+    toop = toop->is_instptr()->cast_to_flatten_array();
   }
   return toop->cast_to_exactness(xk)->is_oopptr();
 }
 
 
@@ -5566,11 +5573,11 @@
     case TopPTR:
       return this;
     case Null:
       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp->speculative(), tp->inline_depth());
     case AnyNull:
-      return make(ptr, klass(), offset, flat_array());
+      return make(ptr, klass(), offset, flatten_array());
     case BotPTR:
     case NotNull:
       return TypePtr::make(AnyPtr, ptr, offset, tp->speculative(), tp->inline_depth());
     default: typerr(t);
     }
@@ -5607,29 +5614,29 @@
     if (klass() == NULL || tkls->klass() == NULL) {
       ciKlass* k = NULL;
       if (ptr == Constant) {
         k = (klass() == NULL) ? tkls->klass() : klass();
       }
-      return make(ptr, k, off, false);
+      return make(ptr, k, off);
     }
 
     // Check for easy case; klasses are equal (and perhaps not loaded!)
     // If we have constants, then we created oops so classes are loaded
     // and we can handle the constants further down.  This case handles
     // not-loaded classes
-    if (ptr != Constant && tkls->klass()->equals(klass()) && flat_array() == tkls->flat_array()) {
-      return make(ptr, klass(), off, flat_array());
+    if (ptr != Constant && tkls->klass()->equals(klass()) && flatten_array() == tkls->flatten_array()) {
+      return make(ptr, klass(), off, flatten_array());
     }
 
     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
     ciKlass* tkls_klass = tkls->klass();
     ciKlass* this_klass = this->klass();
     assert( tkls_klass->is_loaded(), "This class should have been loaded.");
     assert( this_klass->is_loaded(), "This class should have been loaded.");
-    bool tkls_flat_array = tkls->flat_array();
-    bool this_flat_array  = this->flat_array();
-    bool flat_array = below_centerline(ptr) ? (this_flat_array && tkls_flat_array) : (this_flat_array || tkls_flat_array);
+    bool tkls_flatten_array = tkls->flatten_array();
+    bool this_flatten_array  = this->flatten_array();
+    bool flatten_array = below_centerline(ptr) ? (this_flatten_array && tkls_flatten_array) : (this_flatten_array || tkls_flatten_array);
 
     // If 'this' type is above the centerline and is a superclass of the
     // other, we can treat 'this' as having the same type as the other.
     if ((above_centerline(this->ptr())) &&
         tkls_klass->is_subtype_of(this_klass)) {
@@ -5653,30 +5660,30 @@
         else if (above_centerline(this->ptr()));
         else if (above_centerline(tkls->ptr()));
         else
           ptr = NotNull;
       }
-      return make(ptr, this_klass, off, flat_array);
+      return make(ptr, this_klass, off, flatten_array);
     } // Else classes are not equal
 
     // Since klasses are different, we require the LCA in the Java
     // class hierarchy - which means we have to fall to at least NotNull.
     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
       ptr = NotNull;
     // Now we find the LCA of Java classes
     ciKlass* k = this_klass->least_common_ancestor(tkls_klass);
-    return   make(ptr, k, off, k->is_inlinetype() && k->flatten_array());
+    return   make(ptr, k, off);
   } // End of case KlassPtr
 
   } // End of switch
   return this;                  // Return the double constant
 }
 
 //------------------------------xdual------------------------------------------
 // Dual: compute field-by-field dual
 const Type    *TypeKlassPtr::xdual() const {
-  return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flat_array());
+  return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flatten_array());
 }
 
 //------------------------------get_con----------------------------------------
 intptr_t TypeKlassPtr::get_con() const {
   assert( _ptr == Null || _ptr == Constant, "" );
diff a/src/hotspot/share/opto/type.hpp b/src/hotspot/share/opto/type.hpp
--- a/src/hotspot/share/opto/type.hpp
+++ b/src/hotspot/share/opto/type.hpp
@@ -974,11 +974,11 @@
   virtual const TypePtr* with_inline_depth(int depth) const;
 
   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 
   virtual bool can_be_inline_type() const { return false; }
-  virtual bool flat_array() const { return false; }
+  virtual bool flatten_array() const { return false; }
 
   // Tests for relation to centerline of type lattice:
   static bool above_centerline(PTR ptr) { return (ptr <= AnyNull); }
   static bool below_centerline(PTR ptr) { return (ptr >= NotNull); }
   // Convenience common pre-built types.
@@ -1111,13 +1111,10 @@
 
   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
 
   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
 
-  // corresponding pointer to klass, for a given instance
-  const TypeKlassPtr* as_klass_type() const;
-
   virtual const TypePtr *add_offset( intptr_t offset ) const;
 
   // Speculative type helper methods.
   virtual const Type* remove_speculative() const;
   virtual const Type* cleanup_speculative() const;
@@ -1140,50 +1137,50 @@
 //------------------------------TypeInstPtr------------------------------------
 // Class of Java object pointers, pointing either to non-array Java instances
 // or to a Klass* (including array klasses).
 class TypeInstPtr : public TypeOopPtr {
   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
-              bool is_value, int instance_id, const TypePtr* speculative,
+              bool flatten_array, int instance_id, const TypePtr* speculative,
               int inline_depth);
   virtual bool eq( const Type *t ) const;
   virtual int  hash() const;             // Type specific hashing
 
   ciSymbol*  _name;        // class name
-  bool _flat_array;
+  bool _flatten_array;     // Type is flat in arrays
 
  public:
   ciSymbol* name()         const { return _name; }
 
   bool  is_loaded() const { return _klass->is_loaded(); }
 
   // Make a pointer to a constant oop.
   static const TypeInstPtr *make(ciObject* o) {
-    return make(TypePtr::Constant, o->klass(), true, o, Offset(0), o->klass()->is_inlinetype() && o->klass()->as_inline_klass()->flatten_array(), InstanceBot);
+    return make(TypePtr::Constant, o->klass(), true, o, Offset(0));
   }
   // Make a pointer to a constant oop with offset.
   static const TypeInstPtr* make(ciObject* o, Offset offset) {
-    return make(TypePtr::Constant, o->klass(), true, o, offset, o->klass()->is_inlinetype() && o->klass()->as_inline_klass()->flatten_array(), InstanceBot);
+    return make(TypePtr::Constant, o->klass(), true, o, offset);
   }
 
   // Make a pointer to some value of type klass.
   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
-    return make(ptr, klass, false, NULL, Offset(0), klass->is_inlinetype() && klass->as_inline_klass()->flatten_array(), InstanceBot);
+    return make(ptr, klass, false, NULL, Offset(0));
   }
 
   // Make a pointer to some non-polymorphic value of exactly type klass.
   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
-    return make(ptr, klass, true, NULL, Offset(0), klass->is_inlinetype() && klass->as_inline_klass()->flatten_array(), InstanceBot);
+    return make(ptr, klass, true, NULL, Offset(0));
   }
 
   // Make a pointer to some value of type klass with offset.
   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, Offset offset) {
-    return make(ptr, klass, false, NULL, offset, klass->is_inlinetype() && klass->as_inline_klass()->flatten_array(), InstanceBot);
+    return make(ptr, klass, false, NULL, offset);
   }
 
   // Make a pointer to an oop.
   static const TypeInstPtr* make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
-                                 bool flat_array,
+                                 bool flatten_array = false,
                                  int instance_id = InstanceBot,
                                  const TypePtr* speculative = NULL,
                                  int inline_depth = InlineDepthBottom);
 
   /** Create constant type for a constant boxed value */
@@ -1205,16 +1202,12 @@
   // Speculative type helper methods.
   virtual const Type* remove_speculative() const;
   virtual const TypePtr* with_inline_depth(int depth) const;
   virtual const TypePtr* with_instance_id(int instance_id) const;
 
-  virtual const TypeInstPtr* cast_to_flat_array() const;
-  virtual bool flat_array() const {
-    assert(!klass()->is_inlinetype() || !klass()->as_inline_klass()->flatten_array() || _flat_array, "incorrect value bit");
-    assert(!_flat_array || can_be_inline_type(), "incorrect value bit");
-    return _flat_array;
-  }
+  virtual const TypeInstPtr* cast_to_flatten_array() const;
+  virtual bool flatten_array() const { return _flatten_array; }
 
   // the core of the computation of the meet of 2 types
   virtual const Type *xmeet_helper(const Type *t) const;
   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
   virtual const Type *xdual() const;    // Compute dual right now.
@@ -1278,11 +1271,13 @@
   const Type*    elem() const { return _ary->_elem; }
   const TypeInt* size() const { return _ary->_size; }
   bool      is_stable() const { return _ary->_stable; }
 
   // Inline type array properties
+  bool is_flat()          const { return _ary->_elem->isa_inlinetype() != NULL; }
   bool is_not_flat()      const { return _ary->_not_flat; }
+  bool is_null_free()     const { return is_flat() || (_ary->_elem->make_ptr() != NULL && _ary->_elem->make_ptr()->is_inlinetypeptr()); }
   bool is_not_null_free() const { return _ary->_not_null_free; }
 
   bool is_autobox_cache() const { return _is_autobox_cache; }
 
   static const TypeAryPtr* make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
@@ -1319,12 +1314,14 @@
 
   // the core of the computation of the meet of 2 types
   virtual const Type *xmeet_helper(const Type *t) const;
   virtual const Type *xdual() const;    // Compute dual right now.
 
+  // Inline type array properties
   const TypeAryPtr* cast_to_not_flat(bool not_flat = true) const;
   const TypeAryPtr* cast_to_not_null_free(bool not_null_free = true) const;
+  const TypeAryPtr* update_properties(const TypeAryPtr* new_type) const;
 
   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
   int stable_dimension() const;
 
   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
@@ -1407,11 +1404,11 @@
 };
 
 //------------------------------TypeKlassPtr-----------------------------------
 // Class of Java Klass pointers
 class TypeKlassPtr : public TypePtr {
-  TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array);
+  TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flatten_array);
 
 protected:
   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
  public:
   virtual bool eq( const Type *t ) const;
@@ -1420,32 +1417,28 @@
  private:
 
   ciKlass* _klass;
 
   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
-  bool          _klass_is_exact;
-  bool _flat_array;
+  bool _klass_is_exact;
+  bool _flatten_array; // Type is flat in arrays
 
 public:
   ciKlass* klass() const { return  _klass; }
   bool klass_is_exact()    const { return _klass_is_exact; }
 
   virtual bool can_be_inline_type() const { return EnableValhalla && (_klass == NULL || _klass->can_be_inline_klass(_klass_is_exact)); }
-  virtual bool flat_array() const {
-    assert(!klass()->is_inlinetype() || !klass()->as_inline_klass()->flatten_array() || _flat_array, "incorrect value bit");
-    assert(!_flat_array || can_be_inline_type(), "incorrect value bit");
-    return _flat_array;
-  }
+  virtual bool flatten_array() const { return _flatten_array; }
 
   bool  is_loaded() const { return klass() != NULL && klass()->is_loaded(); }
 
   // ptr to klass 'k'
-  static const TypeKlassPtr* make(ciKlass* k) { return make( TypePtr::Constant, k, Offset(0), k->is_inlinetype() && k->as_inline_klass()->flatten_array()); }
+  static const TypeKlassPtr* make(ciKlass* k) { return make( TypePtr::Constant, k, Offset(0)); }
   // ptr to klass 'k' with offset
-  static const TypeKlassPtr* make(ciKlass* k, Offset offset) { return make( TypePtr::Constant, k, offset, k->is_inlinetype() && k->as_inline_klass()->flatten_array()); }
+  static const TypeKlassPtr* make(ciKlass* k, Offset offset) { return make( TypePtr::Constant, k, offset); }
   // ptr to klass 'k' or sub-klass
-  static const TypeKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool flat_array);
+  static const TypeKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array = false);
 
   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 
   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
 
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/InlineTypeTest.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/InlineTypeTest.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/InlineTypeTest.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/InlineTypeTest.java
@@ -115,11 +115,11 @@
     protected static final int COMP_LEVEL_FULL_PROFILE      =  3;     // C1, invocation & backedge counters + mdo
     protected static final int COMP_LEVEL_FULL_OPTIMIZATION =  4;     // C2 or JVMCI
 
     protected static final boolean TieredCompilation = (Boolean)WHITE_BOX.getVMFlag("TieredCompilation");
     protected static final long TieredStopAtLevel = (Long)WHITE_BOX.getVMFlag("TieredStopAtLevel");
-    static final boolean TEST_C1 = TieredStopAtLevel < COMP_LEVEL_FULL_OPTIMIZATION;
+    static final boolean TEST_C1 = TieredCompilation && TieredStopAtLevel < COMP_LEVEL_FULL_OPTIMIZATION;
 
     // Random test values
     public static final int  rI = Utils.getRandomInstance().nextInt() % 1000;
     public static final long rL = Utils.getRandomInstance().nextLong() % 1000;
 
@@ -220,10 +220,11 @@
     protected static final String NULL_CHECK_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*null_check" + END;
     protected static final String RANGE_CHECK_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*range_check" + END;
     protected static final String UNHANDLED_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*unhandled" + END;
     protected static final String PREDICATE_TRAP = START + "CallStaticJava" + MID + "uncommon_trap.*predicate" + END;
     protected static final String MEMBAR = START + "MemBar" + MID + END;
+    protected static final String CHECKCAST_ARRAY = "(cmp.*precise klass \\[(L|Q)compiler/valhalla/inlinetypes/MyValue.*" + END;
 
     public static String[] concat(String prefix[], String... extra) {
         ArrayList<String> list = new ArrayList<String>();
         if (prefix != null) {
             for (String s : prefix) {
@@ -674,21 +675,23 @@
             int warmup = anno == null ? WARMUP : anno.value();
             for (int i = 0; i < warmup; ++i) {
                 verifier.invoke(this, true);
             }
             boolean osrOnly = (test.getAnnotation(OSRCompileOnly.class) != null);
+            int compLevel = getCompLevel(test.getAnnotation(Test.class));
 
             // C1 generates a lot of code when VerifyOops is enabled and may run out of space (for a small
             // number of test cases).
             boolean maybeCodeBufferOverflow = (TEST_C1 && VerifyOops);
 
             if (osrOnly) {
                 long started = System.currentTimeMillis();
                 boolean stateCleared = false;
                 for (;;) {
                     long elapsed = System.currentTimeMillis() - started;
-                    if (maybeCodeBufferOverflow && elapsed > 5000 && !WHITE_BOX.isMethodCompiled(test, false)) {
+                    int level = WHITE_BOX.getMethodCompilationLevel(test);
+                    if (maybeCodeBufferOverflow && elapsed > 5000 && (!WHITE_BOX.isMethodCompiled(test, false) || level != compLevel)) {
                         System.out.println("Temporarily disabling VerifyOops");
                         try {
                             WHITE_BOX.setBooleanVMFlag("VerifyOops", false);
                             if (!stateCleared) {
                                 WHITE_BOX.clearMethodState(test);
@@ -711,23 +714,25 @@
                         // Don't control compilation if -Xcomp is enabled, or if compiler is disabled
                         break;
                     }
                     Asserts.assertTrue(OSR_TEST_TIMEOUT < 0 || elapsed < OSR_TEST_TIMEOUT, test + " not compiled after " + OSR_TEST_TIMEOUT + " ms");
                 }
-                Asserts.assertTrue(XCOMP || STRESS_CC || !USE_COMPILER || WHITE_BOX.isMethodCompiled(test, false), test + " not compiled");
             } else {
-                int compLevel = getCompLevel(test.getAnnotation(Test.class));
                 // Trigger compilation
                 enqueueMethodForCompilation(test, compLevel);
                 if (maybeCodeBufferOverflow && !WHITE_BOX.isMethodCompiled(test, false)) {
                     // Let's disable VerifyOops temporarily and retry.
                     WHITE_BOX.setBooleanVMFlag("VerifyOops", false);
                     WHITE_BOX.clearMethodState(test);
                     enqueueMethodForCompilation(test, compLevel);
                     WHITE_BOX.setBooleanVMFlag("VerifyOops", true);
                 }
-                Asserts.assertTrue(STRESS_CC || !USE_COMPILER || WHITE_BOX.isMethodCompiled(test, false), test + " not compiled");
+                if (!STRESS_CC && USE_COMPILER) {
+                    Asserts.assertTrue(WHITE_BOX.isMethodCompiled(test, false), test + " not compiled");
+                    int level = WHITE_BOX.getMethodCompilationLevel(test);
+                    Asserts.assertEQ(level, compLevel, "Unexpected compilation level for " + test);
+                }
                 // Check result
                 verifier.invoke(this, false);
             }
             if (PRINT_TIMES || VERBOSE) {
                 long endTime = System.nanoTime();
@@ -783,11 +788,11 @@
             }
         }
         if (!TEST_C1 && compLevel < COMP_LEVEL_FULL_OPTIMIZATION) {
             compLevel = COMP_LEVEL_FULL_OPTIMIZATION;
         }
-        if (compLevel > (int)TieredStopAtLevel) {
+        if (TieredCompilation && compLevel > (int)TieredStopAtLevel) {
             compLevel = (int)TieredStopAtLevel;
         }
         return compLevel;
     }
 
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestArrays.java
@@ -2275,6 +2275,179 @@
             long res = test94(src, i, !warmup);
             long expected = src[i].hash() + 9*MyValue2.default.hash();
             Asserts.assertEQ(res, expected);
         }
     }
+
+    // Test propagation of not null-free/flat information
+    @Test(failOn = CHECKCAST_ARRAY)
+    public MyValue1[] test95(Object[] array) {
+        array[0] = null;
+        // Always throws a ClassCastException because we just successfully
+        // stored null and therefore the array can't be an inline type array.
+        return (MyValue1[])array;
+    }
+
+    @DontCompile
+    public void test95_verifier(boolean warmup) {
+        MyValue1[] array1 = new MyValue1[1];
+        Integer[] array2 = new Integer[1];
+        try {
+            test95(array1);
+            throw new RuntimeException("Should throw NullPointerException");
+        } catch (NullPointerException e) {
+            // Expected
+        }
+        try {
+            test95(array2);
+            throw new RuntimeException("Should throw ClassCastException");
+        } catch (ClassCastException e) {
+            // Expected
+        }
+    }
+
+    // Same as test95 but with cmp user of cast result
+    @Test(failOn = CHECKCAST_ARRAY)
+    public boolean test96(Object[] array) {
+        array[0] = null;
+        // Always throws a ClassCastException because we just successfully
+        // stored null and therefore the array can't be an inline type array.
+        MyValue1[] casted = (MyValue1[])array;
+        return casted != null;
+    }
+
+    @DontCompile
+    public void test96_verifier(boolean warmup) {
+        MyValue1[] array1 = new MyValue1[1];
+        Integer[] array2 = new Integer[1];
+        try {
+            test96(array1);
+            throw new RuntimeException("Should throw NullPointerException");
+        } catch (NullPointerException e) {
+            // Expected
+        }
+        try {
+            test96(array2);
+            throw new RuntimeException("Should throw ClassCastException");
+        } catch (ClassCastException e) {
+            // Expected
+        }
+    }
+
+    // Same as test95 but with instanceof instead of cast
+    @Test(failOn = CHECKCAST_ARRAY)
+    public boolean test97(Object[] array) {
+        array[0] = 42;
+        // Always throws a ClassCastException because we just successfully stored
+        // a non-inline value and therefore the array can't be an inline type array.
+        return array instanceof MyValue1[];
+    }
+
+    @DontCompile
+    public void test97_verifier(boolean warmup) {
+        MyValue1[] array1 = new MyValue1[1];
+        Integer[] array2 = new Integer[1];
+        try {
+            test97(array1);
+            throw new RuntimeException("Should throw ArrayStoreException");
+        } catch (ArrayStoreException e) {
+            // Expected
+        }
+        boolean res = test97(array2);
+        Asserts.assertFalse(res);
+    }
+
+    // Same as test95 but with non-flattenable store
+    @Test(valid = InlineTypeArrayFlattenOn, failOn = CHECKCAST_ARRAY)
+    @Test(valid = InlineTypeArrayFlattenOff)
+    public MyValue1[] test98(Object[] array) {
+        array[0] = NotFlattenable.default;
+        // Always throws a ClassCastException because we just successfully stored a
+        // non-flattenable value and therefore the array can't be a flat array.
+        return (MyValue1[])array;
+    }
+
+    @DontCompile
+    public void test98_verifier(boolean warmup) {
+        MyValue1[] array1 = new MyValue1[1];
+        NotFlattenable[] array2 = new NotFlattenable[1];
+        try {
+            test98(array1);
+            throw new RuntimeException("Should throw ArrayStoreException");
+        } catch (ArrayStoreException e) {
+            // Expected
+        }
+        try {
+            test98(array2);
+            throw new RuntimeException("Should throw ClassCastException");
+        } catch (ClassCastException e) {
+            // Expected
+        }
+    }
+
+    // Same as test98 but with cmp user of cast result
+    @Test(valid = InlineTypeArrayFlattenOn, failOn = CHECKCAST_ARRAY)
+    @Test(valid = InlineTypeArrayFlattenOff)
+    public boolean test99(Object[] array) {
+        array[0] = NotFlattenable.default;
+        // Always throws a ClassCastException because we just successfully stored a
+        // non-flattenable value and therefore the array can't be a flat array.
+        MyValue1[] casted = (MyValue1[])array;
+        return casted != null;
+    }
+
+    @DontCompile
+    public void test99_verifier(boolean warmup) {
+        MyValue1[] array1 = new MyValue1[1];
+        NotFlattenable[] array2 = new NotFlattenable[1];
+        try {
+            test99(array1);
+            throw new RuntimeException("Should throw ArrayStoreException");
+        } catch (ArrayStoreException e) {
+            // Expected
+        }
+        try {
+            test99(array2);
+            throw new RuntimeException("Should throw ClassCastException");
+        } catch (ClassCastException e) {
+            // Expected
+        }
+    }
+
+    // Same as test98 but with instanceof instead of cast
+    @Test(valid = InlineTypeArrayFlattenOn, failOn = CHECKCAST_ARRAY)
+    @Test(valid = InlineTypeArrayFlattenOff)
+    public boolean test100(Object[] array) {
+        array[0] = NotFlattenable.default;
+        // Always throws a ClassCastException because we just successfully stored a
+        // non-flattenable value and therefore the array can't be a flat array.
+        return array instanceof MyValue1[];
+    }
+
+    @DontCompile
+    public void test100_verifier(boolean warmup) {
+        MyValue1[] array1 = new MyValue1[1];
+        NotFlattenable[] array2 = new NotFlattenable[1];
+        try {
+            test100(array1);
+            throw new RuntimeException("Should throw ArrayStoreException");
+        } catch (ArrayStoreException e) {
+            // Expected
+        }
+        boolean res = test100(array2);
+        Asserts.assertFalse(res);
+    }
+
+    // Test that CHECKCAST_ARRAY matching works as expected
+    @Test(match = { CHECKCAST_ARRAY }, matchCount = { 1 })
+    public boolean test101(Object[] array) {
+        return array instanceof MyValue1[];
+    }
+
+    @DontCompile
+    public void test101_verifier(boolean warmup) {
+        MyValue1[] array1 = new MyValue1[1];
+        NotFlattenable[] array2 = new NotFlattenable[1];
+        Asserts.assertTrue(test101(array1));
+        Asserts.assertFalse(test101(array2));
+    }
 }
diff a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java
@@ -2866,6 +2866,20 @@
 
     @DontCompile
     public void test110_verifier(boolean warmup) {
         test110();
     }
+
+    // Same as test109 but with Arrays.copyOf
+    @Test()
+    public static void test111() {
+        MyValue1[] src = new MyValue1[1];
+        src[0] = testValue1;
+        MyValue1.ref[] dst = Arrays.copyOf(src, src.length, MyValue1.ref[].class);
+        Asserts.assertEquals(src[0], dst[0]);
+    }
+
+    @DontCompile
+    public void test111_verifier(boolean warmup) {
+        test111();
+    }
 }
