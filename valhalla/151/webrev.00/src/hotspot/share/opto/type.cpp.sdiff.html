<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="subtypenode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 572 
 573   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, Offset(0));
 574   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, Offset::bottom);
 575   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, Offset::bottom);
 576 
 577   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 578   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 579 
 580   const Type **fmembar = TypeTuple::fields(0);
 581   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 582 
 583   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 584   fsc[0] = TypeInt::CC;
 585   fsc[1] = Type::MEMORY;
 586   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 587 
 588   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 589   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 590   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 591   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified"> 592                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()), false);</span>
 593   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified"> 594                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);</span>
 595   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
 596 
 597   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
 598 
 599   TypeInlineType::BOTTOM = TypeInlineType::make(NULL);
 600 
 601   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 602   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 603 
 604   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 605 
 606   mreg2type[Op_Node] = Type::BOTTOM;
 607   mreg2type[Op_Set ] = 0;
 608   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 609   mreg2type[Op_RegI] = TypeInt::INT;
 610   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 611   mreg2type[Op_RegF] = Type::FLOAT;
 612   mreg2type[Op_RegD] = Type::DOUBLE;
 613   mreg2type[Op_RegL] = TypeLong::LONG;
 614   mreg2type[Op_RegFlags] = TypeInt::CC;
</pre>
<hr />
<pre>
 633   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);
 634   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);
 635   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);
 636   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);
 637   TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInlineType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);
 638 
 639   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 640   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 641   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 642   TypeAryPtr::_array_body_type[T_INLINE_TYPE] = TypeAryPtr::OOPS;
 643   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 644   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 645   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 646   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 647   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 648   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 649   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 650   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 651   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 652 
<span class="line-modified"> 653   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0), false);</span>
<span class="line-modified"> 654   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0), false);</span>
 655 
 656   const Type **fi2c = TypeTuple::fields(2);
 657   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 658   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 659   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 660 
 661   const Type **intpair = TypeTuple::fields(2);
 662   intpair[0] = TypeInt::INT;
 663   intpair[1] = TypeInt::INT;
 664   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 665 
 666   const Type **longpair = TypeTuple::fields(2);
 667   longpair[0] = TypeLong::LONG;
 668   longpair[1] = TypeLong::LONG;
 669   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 670 
 671   const Type **intccpair = TypeTuple::fields(2);
 672   intccpair[0] = TypeInt::INT;
 673   intccpair[1] = TypeInt::CC;
 674   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
</pre>
<hr />
<pre>
3322 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3323   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3324   if( ptr == _ptr ) return this;
3325   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3326 }
3327 
3328 //-----------------------------cast_to_instance_id----------------------------
3329 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3330   // There are no instances of a general oop.
3331   // Return self unchanged.
3332   return this;
3333 }
3334 
3335 //-----------------------------cast_to_exactness-------------------------------
3336 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3337   // There is no such thing as an exact general oop.
3338   // Return self unchanged.
3339   return this;
3340 }
3341 
<span class="line-removed">3342 </span>
<span class="line-removed">3343 //------------------------------as_klass_type----------------------------------</span>
<span class="line-removed">3344 // Return the klass type corresponding to this instance or array type.</span>
<span class="line-removed">3345 // It is the type that is loaded from an object of this type.</span>
<span class="line-removed">3346 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {</span>
<span class="line-removed">3347   ciKlass* k = klass();</span>
<span class="line-removed">3348   bool    xk = klass_is_exact();</span>
<span class="line-removed">3349   if (k == NULL)</span>
<span class="line-removed">3350     return TypeKlassPtr::OBJECT;</span>
<span class="line-removed">3351   else</span>
<span class="line-removed">3352     return TypeKlassPtr::make(xk? Constant: NotNull, k, Offset(0), isa_instptr() &amp;&amp; is_instptr()-&gt;flat_array());</span>
<span class="line-removed">3353 }</span>
<span class="line-removed">3354 </span>
3355 //------------------------------meet-------------------------------------------
3356 // Compute the MEET of two types.  It returns a new Type object.
3357 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3358   // Perform a fast test for common case; meeting the same types together.
3359   if( this == t ) return this;  // Meeting same type-rep?
3360 
3361   // Current &quot;this-&gt;_base&quot; is OopPtr
3362   switch (t-&gt;base()) {          // switch on original type
3363 
3364   case Int:                     // Mixing ints &amp; oops happens when javac
3365   case Long:                    // reuses local variables
3366   case FloatTop:
3367   case FloatCon:
3368   case FloatBot:
3369   case DoubleTop:
3370   case DoubleCon:
3371   case DoubleBot:
3372   case NarrowOop:
3373   case NarrowKlass:
3374   case Bottom:                  // Ye Olde Default
</pre>
<hr />
<pre>
3444     if (klass-&gt;is_loaded()) {
3445       // Try to set klass_is_exact.
3446       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3447       klass_is_exact = ik-&gt;is_final();
3448       if (!klass_is_exact &amp;&amp; klass_change
3449           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3450         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3451         if (sub != NULL) {
3452           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3453           klass = ik = sub;
3454           klass_is_exact = sub-&gt;is_final();
3455         }
3456       }
3457       if (!klass_is_exact &amp;&amp; try_for_exact &amp;&amp; deps != NULL &amp;&amp;
3458           !ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3459         // Add a dependence; if concrete subclass added we need to recompile
3460         deps-&gt;assert_leaf_type(ik);
3461         klass_is_exact = true;
3462       }
3463     }
<span class="line-modified">3464     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());</span>
3465   } else if (klass-&gt;is_obj_array_klass()) {
3466     // Element is an object or inline type array. Recursively call ourself.
3467     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);
3468     if (etype-&gt;is_inlinetypeptr()) {
3469       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3470     }
3471     // Determine null-free/flattened properties
3472     const TypeOopPtr* exact_etype = etype;
3473     if (etype-&gt;can_be_inline_type()) {
3474       // Use exact type if element can be an inline type
3475       exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);
3476     }
3477     bool not_null_free = !exact_etype-&gt;can_be_inline_type();
3478     bool not_flat = !UseFlatArray || not_null_free || (exact_etype-&gt;is_inlinetypeptr() &amp;&amp; !exact_etype-&gt;inline_klass()-&gt;flatten_array());
3479 
3480     bool xk = etype-&gt;klass_is_exact();
3481     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
3482     // We used to pass NotNull in here, asserting that the sub-arrays
3483     // are all not-null.  This is not true in generally, as code can
3484     // slam NULLs down in the subarrays.
</pre>
<hr />
<pre>
3500     return arr;
3501   } else {
3502     ShouldNotReachHere();
3503     return NULL;
3504   }
3505 }
3506 
3507 //------------------------------make_from_constant-----------------------------
3508 // Make a java pointer from an oop constant
3509 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3510   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3511 
3512   const bool make_constant = require_constant || o-&gt;should_be_constant();
3513 
3514   ciKlass* klass = o-&gt;klass();
3515   if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {
3516     // Element is an instance or inline type
3517     if (make_constant) {
3518       return TypeInstPtr::make(o);
3519     } else {
<span class="line-modified">3520       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());</span>
3521     }
3522   } else if (klass-&gt;is_obj_array_klass()) {
3523     // Element is an object array. Recursively call ourself.
3524     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
3525     bool null_free = false;
3526     if (etype-&gt;is_inlinetypeptr()) {
3527       null_free = true;
3528       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3529     }
3530     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3531                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);
3532     // We used to pass NotNull in here, asserting that the sub-arrays
3533     // are all not-null.  This is not true in generally, as code can
3534     // slam NULLs down in the subarrays.
3535     if (make_constant) {
3536       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3537     } else {
3538       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3539     }
3540   } else if (klass-&gt;is_type_array_klass()) {
</pre>
<hr />
<pre>
3757  * @return  true if type profile is valuable
3758  */
3759 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3760   // no way to improve an already exact type
3761   if (klass_is_exact()) {
3762     return false;
3763   }
3764   return TypePtr::would_improve_type(exact_kls, inline_depth);
3765 }
3766 
3767 //=============================================================================
3768 // Convenience common pre-built types.
3769 const TypeInstPtr *TypeInstPtr::NOTNULL;
3770 const TypeInstPtr *TypeInstPtr::BOTTOM;
3771 const TypeInstPtr *TypeInstPtr::MIRROR;
3772 const TypeInstPtr *TypeInstPtr::MARK;
3773 const TypeInstPtr *TypeInstPtr::KLASS;
3774 
3775 //------------------------------TypeInstPtr-------------------------------------
3776 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,
<span class="line-modified">3777                          bool flat_array, int instance_id, const TypePtr* speculative,</span>
3778                          int inline_depth)
3779   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
<span class="line-modified">3780     _name(k-&gt;name()), _flat_array(flat_array) {</span>
<span class="line-modified">3781    assert(k != NULL &amp;&amp;</span>
<span class="line-modified">3782           (k-&gt;is_loaded() || o == NULL),</span>
<span class="line-modified">3783           &quot;cannot have constants with non-loaded klass&quot;);</span>
<span class="line-modified">3784    assert(!klass()-&gt;is_inlinetype() || !klass()-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-modified">3785    assert(!flat_array || can_be_inline_type(), &quot;incorrect flatten array bit&quot;);</span>
3786 };
3787 
3788 //------------------------------make-------------------------------------------
3789 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3790                                      ciKlass* k,
3791                                      bool xk,
3792                                      ciObject* o,
3793                                      Offset offset,
<span class="line-modified">3794                                      bool flat_array,</span>
3795                                      int instance_id,
3796                                      const TypePtr* speculative,
3797                                      int inline_depth) {
3798   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3799   // Either const_oop() is NULL or else ptr is Constant
3800   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3801           &quot;constant pointers must have a value supplied&quot; );
3802   // Ptr is never Null
3803   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3804 
3805   assert(instance_id &lt;= 0 || xk, &quot;instances are always exactly typed&quot;);
3806   if (ptr == Constant) {
3807     // Note:  This case includes meta-object constants, such as methods.
3808     xk = true;
3809   } else if (k-&gt;is_loaded()) {
3810     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3811     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3812     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3813   }
3814 



3815   // Now hash this baby
3816   TypeInstPtr *result =
<span class="line-modified">3817     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, flat_array, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
3818 
3819   return result;
3820 }
3821 
3822 /**
3823  *  Create constant type for a constant boxed value
3824  */
3825 const Type* TypeInstPtr::get_const_boxed_value() const {
3826   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3827   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3828   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3829   BasicType bt = constant.basic_type();
3830   switch (bt) {
3831     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3832     case T_INT:      return TypeInt::make(constant.as_int());
3833     case T_CHAR:     return TypeInt::make(constant.as_char());
3834     case T_BYTE:     return TypeInt::make(constant.as_byte());
3835     case T_SHORT:    return TypeInt::make(constant.as_short());
3836     case T_FLOAT:    return TypeF::make(constant.as_float());
3837     case T_DOUBLE:   return TypeD::make(constant.as_double());
3838     case T_LONG:     return TypeLong::make(constant.as_long());
3839     default:         break;
3840   }
3841   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3842   return NULL;
3843 }
3844 
3845 //------------------------------cast_to_ptr_type-------------------------------
3846 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3847   if( ptr == _ptr ) return this;
3848   // Reconstruct _sig info here since not a problem with later lazy
3849   // construction, _sig will show up on demand.
<span class="line-modified">3850   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);</span>
3851 }
3852 
3853 
3854 //-----------------------------cast_to_exactness-------------------------------
3855 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3856   if( klass_is_exact == _klass_is_exact ) return this;
3857   if (!_klass-&gt;is_loaded())  return this;
3858   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3859   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3860   if( ik-&gt;is_interface() )              return this;  // cannot set xk
<span class="line-modified">3861   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);</span>
3862 }
3863 
3864 //-----------------------------cast_to_instance_id----------------------------
3865 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3866   if( instance_id == _instance_id ) return this;
<span class="line-modified">3867   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flat_array, instance_id, _speculative, _inline_depth);</span>
3868 }
3869 
3870 //------------------------------xmeet_unloaded---------------------------------
3871 // Compute the MEET of two InstPtrs when at least one is unloaded.
3872 // Assume classes are different since called after check for same name/class-loader
3873 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3874     Offset off = meet_offset(tinst-&gt;offset());
3875     PTR ptr = meet_ptr(tinst-&gt;ptr());
3876     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3877     const TypePtr* speculative = xmeet_speculative(tinst);
3878     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3879 
3880     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3881     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3882     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3883       //
3884       // Meet unloaded class with java/lang/Object
3885       //
3886       // Meet
3887       //          |                     Unloaded Class
</pre>
<hr />
<pre>
3943   default:                      // All else is a mistake
3944     typerr(t);
3945 
3946   case MetadataPtr:
3947   case KlassPtr:
3948   case RawPtr: return TypePtr::BOTTOM;
3949 
3950   case AryPtr: {                // All arrays inherit from Object class
3951     const TypeAryPtr *tp = t-&gt;is_aryptr();
3952     Offset offset = meet_offset(tp-&gt;offset());
3953     PTR ptr = meet_ptr(tp-&gt;ptr());
3954     int instance_id = meet_instance_id(tp-&gt;instance_id());
3955     const TypePtr* speculative = xmeet_speculative(tp);
3956     int depth = meet_inline_depth(tp-&gt;inline_depth());
3957     switch (ptr) {
3958     case TopPTR:
3959     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3960       // For instances when a subclass meets a superclass we fall
3961       // below the centerline when the superclass is exact. We need to
3962       // do the same here.
<span class="line-modified">3963       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {</span>
3964         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3965       } else {
3966         // cannot subclass, so the meet has to fall badly below the centerline
3967         ptr = NotNull;
3968         instance_id = InstanceBot;
3969         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3970       }
3971     case Constant:
3972     case NotNull:
3973     case BotPTR:                // Fall down to object klass
3974       // LCA is object_klass, but if we subclass from the top we can do better
3975       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3976         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3977         // then we can subclass in the Java class hierarchy.
3978         // For instances when a subclass meets a superclass we fall
3979         // below the centerline when the superclass is exact. We need
3980         // to do the same here.
<span class="line-modified">3981         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {</span>
3982           // that is, tp&#39;s array type is a subtype of my klass
3983           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
3984                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3985         }
3986       }
3987       // The other case cannot happen, since I cannot be a subtype of an array.
3988       // The meet falls down to Object class below centerline.
3989       if( ptr == Constant )
3990          ptr = NotNull;
3991       instance_id = InstanceBot;
3992       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3993     default: typerr(t);
3994     }
3995   }
3996 
3997   case OopPtr: {                // Meeting to OopPtrs
3998     // Found a OopPtr type vs self-InstPtr type
3999     const TypeOopPtr *tp = t-&gt;is_oopptr();
4000     Offset offset = meet_offset(tp-&gt;offset());
4001     PTR ptr = meet_ptr(tp-&gt;ptr());
4002     switch (tp-&gt;ptr()) {
4003     case TopPTR:
4004     case AnyNull: {
4005       int instance_id = meet_instance_id(InstanceTop);
4006       const TypePtr* speculative = xmeet_speculative(tp);
4007       int depth = meet_inline_depth(tp-&gt;inline_depth());
4008       return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">4009                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);</span>
4010     }
4011     case NotNull:
4012     case BotPTR: {
4013       int instance_id = meet_instance_id(tp-&gt;instance_id());
4014       const TypePtr* speculative = xmeet_speculative(tp);
4015       int depth = meet_inline_depth(tp-&gt;inline_depth());
4016       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4017     }
4018     default: typerr(t);
4019     }
4020   }
4021 
4022   case AnyPtr: {                // Meeting to AnyPtrs
4023     // Found an AnyPtr type vs self-InstPtr type
4024     const TypePtr *tp = t-&gt;is_ptr();
4025     Offset offset = meet_offset(tp-&gt;offset());
4026     PTR ptr = meet_ptr(tp-&gt;ptr());
4027     int instance_id = meet_instance_id(InstanceTop);
4028     const TypePtr* speculative = xmeet_speculative(tp);
4029     int depth = meet_inline_depth(tp-&gt;inline_depth());
4030     switch (tp-&gt;ptr()) {
4031     case Null:
4032       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4033       // else fall through to AnyNull
4034     case TopPTR:
4035     case AnyNull: {
4036       return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">4037                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);</span>
4038     }
4039     case NotNull:
4040     case BotPTR:
4041       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
4042     default: typerr(t);
4043     }
4044   }
4045 
4046   /*
4047                  A-top         }
4048                /   |   \       }  Tops
4049            B-top A-any C-top   }
4050               | /  |  \ |      }  Any-nulls
4051            B-any   |   C-any   }
4052               |    |    |
4053            B-con A-con C-con   } constants; not comparable across classes
4054               |    |    |
4055            B-not   |   C-not   }
4056               | \  |  / |      }  not-nulls
4057            B-bot A-not C-bot   }
4058                \   |   /       }  Bottoms
4059                  A-bot         }
4060   */
4061 
4062   case InstPtr: {                // Meeting 2 Oops?
4063     // Found an InstPtr sub-type vs self-InstPtr type
4064     const TypeInstPtr *tinst = t-&gt;is_instptr();
4065     Offset off = meet_offset( tinst-&gt;offset() );
4066     PTR ptr = meet_ptr( tinst-&gt;ptr() );
4067     int instance_id = meet_instance_id(tinst-&gt;instance_id());
4068     const TypePtr* speculative = xmeet_speculative(tinst);
4069     int depth = meet_inline_depth(tinst-&gt;inline_depth());
4070 
4071     // Check for easy case; klasses are equal (and perhaps not loaded!)
4072     // If we have constants, then we created oops so classes are loaded
4073     // and we can handle the constants further down.  This case handles
4074     // both-not-loaded or both-loaded classes
4075     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact() &amp;&amp;
<span class="line-modified">4076         flat_array() == tinst-&gt;flat_array()) {</span>
<span class="line-modified">4077       return make(ptr, klass(), klass_is_exact(), NULL, off, flat_array(), instance_id, speculative, depth);</span>
4078     }
4079 
4080     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
4081     ciKlass* tinst_klass = tinst-&gt;klass();
4082     ciKlass* this_klass  = this-&gt;klass();
4083     bool tinst_xk = tinst-&gt;klass_is_exact();
4084     bool this_xk  = this-&gt;klass_is_exact();
<span class="line-modified">4085     bool tinst_flat_array = tinst-&gt;flat_array();</span>
<span class="line-modified">4086     bool this_flat_array  = this-&gt;flat_array();</span>
4087     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
4088       // One of these classes has not been loaded
4089       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
4090 #ifndef PRODUCT
4091       if( PrintOpto &amp;&amp; Verbose ) {
4092         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
4093         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
4094         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
4095       }
4096 #endif
4097       return unloaded_meet;
4098     }
4099 
4100     // Handle mixing oops and interfaces first.
4101     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
4102                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
4103       ciKlass *tmp = tinst_klass; // Swap interface around
4104       tinst_klass = this_klass;
4105       this_klass = tmp;
4106       bool tmp2 = tinst_xk;
4107       tinst_xk = this_xk;
4108       this_xk = tmp2;
<span class="line-modified">4109       tmp2 = tinst_flat_array;</span>
<span class="line-modified">4110       tinst_flat_array = this_flat_array;</span>
<span class="line-modified">4111       this_flat_array = tmp2;</span>
4112     }
4113     if (tinst_klass-&gt;is_interface() &amp;&amp;
4114         !(this_klass-&gt;is_interface() ||
4115           // Treat java/lang/Object as an honorary interface,
4116           // because we need a bottom for the interface hierarchy.
4117           this_klass == ciEnv::current()-&gt;Object_klass())) {
4118       // Oop meets interface!
4119 
4120       // See if the oop subtypes (implements) interface.
4121       ciKlass *k;
4122       bool xk;
4123       bool flat_array;
4124       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
4125         // Oop indeed subtypes.  Now keep oop or interface depending
4126         // on whether we are both above the centerline or either is
4127         // below the centerline.  If we are on the centerline
4128         // (e.g., Constant vs. AnyNull interface), use the constant.
4129         k  = below_centerline(ptr) ? tinst_klass : this_klass;
4130         // If we are keeping this_klass, keep its exactness too.
4131         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
<span class="line-modified">4132         flat_array = below_centerline(ptr) ? tinst_flat_array    : this_flat_array;</span>
4133       } else {                  // Does not implement, fall to Object
4134         // Oop does not implement interface, so mixing falls to Object
4135         // just like the verifier does (if both are above the
4136         // centerline fall to interface)
4137         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
4138         xk = above_centerline(ptr) ? tinst_xk : false;
<span class="line-modified">4139         flat_array = above_centerline(ptr) ? tinst_flat_array : false;</span>
4140         // Watch out for Constant vs. AnyNull interface.
4141         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
4142         instance_id = InstanceBot;
4143       }
4144       ciObject* o = NULL;  // the Constant value, if any
4145       if (ptr == Constant) {
4146         // Find out which constant.
4147         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
4148       }
4149       return make(ptr, k, xk, o, off, flat_array, instance_id, speculative, depth);
4150     }
4151 
4152     // Either oop vs oop or interface vs interface or interface vs Object
4153 
4154     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
4155     // If we split one up &amp; one down AND they subtype, take the down man.
4156     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4157     // If both are up and they subtype, take the subtype class.
4158     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4159     // If both are down and they subtype, take the supertype class.
</pre>
<hr />
<pre>
4165     // If we split one up &amp; one down AND they subtype, take the down man.
4166     // If both are up and they subtype, take the subtype class.
4167 
4168     // If both are down and they subtype, &quot;fall hard&quot;.
4169     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4170     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4171     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4172 
4173     // If a proper subtype is exact, and we return it, we return it exactly.
4174     // If a proper supertype is exact, there can be no subtyping relationship!
4175     // If both types are equal to the subtype, exactness is and-ed below the
4176     // centerline and or-ed above it.  (N.B. Constants are always exact.)
4177 
4178     // Check for subtyping:
4179     ciKlass *subtype = NULL;
4180     bool subtype_exact = false;
4181     bool flat_array = false;
4182     if (tinst_klass-&gt;equals(this_klass)) {
4183       subtype = this_klass;
4184       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
<span class="line-modified">4185       flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tinst_flat_array) : (this_flat_array || tinst_flat_array);</span>
<span class="line-modified">4186     } else if(!tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of(tinst_klass) &amp;&amp; (!tinst_flat_array || this_flat_array)) {</span>
4187       subtype = this_klass;     // Pick subtyping class
4188       subtype_exact = this_xk;
<span class="line-modified">4189       flat_array = this_flat_array;</span>
<span class="line-modified">4190     } else if(!this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of(this_klass) &amp;&amp; (!this_flat_array || tinst_flat_array)) {</span>
4191       subtype = tinst_klass;    // Pick subtyping class
4192       subtype_exact = tinst_xk;
<span class="line-modified">4193       flat_array = tinst_flat_array;</span>
4194     }
4195 
4196     if (subtype) {
4197       if (above_centerline(ptr)) { // both are up?
4198         this_klass = tinst_klass = subtype;
4199         this_xk = tinst_xk = subtype_exact;
<span class="line-modified">4200         this_flat_array = tinst_flat_array = flat_array;</span>
4201       } else if (above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr)) {
4202         this_klass = tinst_klass; // tinst is down; keep down man
4203         this_xk = tinst_xk;
<span class="line-modified">4204         this_flat_array = tinst_flat_array;</span>
4205       } else if (above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr)) {
4206         tinst_klass = this_klass; // this is down; keep down man
4207         tinst_xk = this_xk;
<span class="line-modified">4208         tinst_flat_array = this_flat_array;</span>
4209       } else {
4210         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
<span class="line-modified">4211         this_flat_array = flat_array;</span>
4212       }
4213     }
4214 
4215     // Check for classes now being equal
4216     if (tinst_klass-&gt;equals(this_klass)) {
4217       // If the klasses are equal, the constants may still differ.  Fall to
4218       // NotNull if they do (neither constant is NULL; that is a special case
4219       // handled elsewhere).
4220       ciObject* o = NULL;             // Assume not constant when done
4221       ciObject* this_oop  = const_oop();
4222       ciObject* tinst_oop = tinst-&gt;const_oop();
4223       if( ptr == Constant ) {
4224         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
4225             this_oop-&gt;equals(tinst_oop) )
4226           o = this_oop;
4227         else if (above_centerline(this -&gt;_ptr))
4228           o = tinst_oop;
4229         else if (above_centerline(tinst -&gt;_ptr))
4230           o = this_oop;
4231         else
4232           ptr = NotNull;
4233       }
<span class="line-modified">4234       return make(ptr, this_klass, this_xk, o, off, this_flat_array, instance_id, speculative, depth);</span>
4235     } // Else classes are not equal
4236 
4237     // Since klasses are different, we require a LCA in the Java
4238     // class hierarchy - which means we have to fall to at least NotNull.
4239     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
4240       ptr = NotNull;
4241 
4242     instance_id = InstanceBot;
4243 
4244     // Now we find the LCA of Java classes
4245     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
4246     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);
4247   } // End of case InstPtr
4248 
4249   case InlineType: {
4250     const TypeInlineType* tv = t-&gt;is_inlinetype();
4251     if (above_centerline(ptr())) {
4252       if (tv-&gt;inline_klass()-&gt;is_subtype_of(_klass)) {
4253         return t;
4254       } else {
</pre>
<hr />
<pre>
4270   } // End of switch
4271   return this;                  // Return the double constant
4272 }
4273 
4274 
4275 //------------------------java_mirror_type--------------------------------------
4276 ciType* TypeInstPtr::java_mirror_type() const {
4277   // must be a singleton type
4278   if( const_oop() == NULL )  return NULL;
4279 
4280   // must be of type java.lang.Class
4281   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
4282   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
4283 }
4284 
4285 
4286 //------------------------------xdual------------------------------------------
4287 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
4288 // inheritance mechanism.
4289 const Type *TypeInstPtr::xdual() const {
<span class="line-modified">4290   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flat_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
4291 }
4292 
4293 //------------------------------eq---------------------------------------------
4294 // Structural equality check for Type representations
4295 bool TypeInstPtr::eq( const Type *t ) const {
4296   const TypeInstPtr *p = t-&gt;is_instptr();
4297   return
4298     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
<span class="line-modified">4299     flat_array() == p-&gt;flat_array() &amp;&amp;</span>
4300     TypeOopPtr::eq(p);          // Check sub-type stuff
4301 }
4302 
4303 //------------------------------hash-------------------------------------------
4304 // Type-specific hashing function.
4305 int TypeInstPtr::hash(void) const {
<span class="line-modified">4306   int hash = java_add(java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash()), (jint)flat_array());</span>
4307   return hash;
4308 }
4309 
4310 //------------------------------dump2------------------------------------------
4311 // Dump oop Type
4312 #ifndef PRODUCT
4313 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4314   // Print the name of the klass.
4315   klass()-&gt;print_name_on(st);
4316 
4317   switch( _ptr ) {
4318   case Constant:
4319     // TO DO: Make CI print the hex address of the underlying oop.
4320     if (WizardMode || Verbose) {
4321       const_oop()-&gt;print_oop(st);
4322     }
4323   case BotPTR:
4324     if (!WizardMode &amp;&amp; !Verbose) {
4325       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4326       break;
4327     }
4328   case TopPTR:
4329   case AnyNull:
4330   case NotNull:
4331     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4332     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4333     break;
4334   default:
4335     break;
4336   }
4337 
4338   _offset.dump2(st);
4339 
4340   st-&gt;print(&quot; *&quot;);
4341 
<span class="line-modified">4342   if (flat_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
4343     st-&gt;print(&quot; (flatten array)&quot;);
4344   }
4345 
4346   if (_instance_id == InstanceTop)
4347     st-&gt;print(&quot;,iid=top&quot;);
4348   else if (_instance_id != InstanceBot)
4349     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4350 
4351   dump_inline_depth(st);
4352   dump_speculative(st);
4353 }
4354 #endif
4355 
4356 //------------------------------add_offset-------------------------------------
4357 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
<span class="line-modified">4358   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flat_array(),</span>
4359               _instance_id, add_offset_speculative(offset), _inline_depth);
4360 }
4361 
4362 const Type *TypeInstPtr::remove_speculative() const {
4363   if (_speculative == NULL) {
4364     return this;
4365   }
4366   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="line-modified">4367   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(),</span>
4368               _instance_id, NULL, _inline_depth);
4369 }
4370 
4371 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4372   if (!UseInlineDepthForSpeculativeTypes) {
4373     return this;
4374   }
<span class="line-modified">4375   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), _instance_id, _speculative, depth);</span>
4376 }
4377 
4378 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4379   assert(is_known_instance(), &quot;should be known&quot;);
<span class="line-modified">4380   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), instance_id, _speculative, _inline_depth);</span>
4381 }
4382 
<span class="line-modified">4383 const TypeInstPtr *TypeInstPtr::cast_to_flat_array() const {</span>
4384   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);
4385 }
4386 
4387 
4388 //=============================================================================
4389 // Convenience common pre-built types.
4390 const TypeAryPtr *TypeAryPtr::RANGE;
4391 const TypeAryPtr *TypeAryPtr::OOPS;
4392 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4393 const TypeAryPtr *TypeAryPtr::BYTES;
4394 const TypeAryPtr *TypeAryPtr::SHORTS;
4395 const TypeAryPtr *TypeAryPtr::CHARS;
4396 const TypeAryPtr *TypeAryPtr::INTS;
4397 const TypeAryPtr *TypeAryPtr::LONGS;
4398 const TypeAryPtr *TypeAryPtr::FLOATS;
4399 const TypeAryPtr *TypeAryPtr::DOUBLES;
4400 const TypeAryPtr *TypeAryPtr::INLINES;
4401 
4402 //------------------------------make-------------------------------------------
4403 const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
</pre>
<hr />
<pre>
4506 
4507 //-------------------------------cast_to_not_flat------------------------------
4508 const TypeAryPtr* TypeAryPtr::cast_to_not_flat(bool not_flat) const {
4509   if (not_flat == is_not_flat()) {
4510     return this;
4511   }
4512   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_flat, is_not_null_free());
4513   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4514 }
4515 
4516 //-------------------------------cast_to_not_null_free-------------------------
4517 const TypeAryPtr* TypeAryPtr::cast_to_not_null_free(bool not_null_free) const {
4518   if (not_null_free == is_not_null_free()) {
4519     return this;
4520   }
4521   // Not null free implies not flat
4522   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);
4523   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4524 }
4525 















4526 //------------------------------cast_to_stable---------------------------------
4527 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4528   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4529     return this;
4530 
4531   const Type* elem = this-&gt;elem();
4532   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4533 
4534   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4535     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4536     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4537   }
4538 
4539   const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_not_flat(), is_not_null_free());
4540 
4541   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4542 }
4543 
4544 //-----------------------------stable_dimension--------------------------------
4545 int TypeAryPtr::stable_dimension() const {
</pre>
<hr />
<pre>
4684     } else // Non integral arrays.
4685       // Must fall to bottom if exact klasses in upper lattice
4686       // are not equal or super klass is exact.
4687       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4688           // meet with top[] and bottom[] are processed further down:
4689           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4690           // both are exact and not equal:
4691           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4692            // &#39;tap&#39; is exact and super or unrelated:
4693            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4694            // &#39;this&#39; is exact and super or unrelated:
4695            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4696       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4697         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4698       }
4699       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
4700     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_flat_array_klass() != tap-&gt;klass()-&gt;is_flat_array_klass()) {
4701       // Meeting flattened inline type array with non-flattened array. Adjust (field) offset accordingly.
4702       if (tary-&gt;_elem-&gt;isa_inlinetype()) {
4703         // Result is flattened
<span class="line-modified">4704         off = Offset(elem()-&gt;isa_inlinetype() ? offset() : tap-&gt;offset());</span>
<span class="line-modified">4705         field_off = elem()-&gt;isa_inlinetype() ? field_offset() : tap-&gt;field_offset();</span>
4706       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
4707         // Result is non-flattened
4708         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
4709         field_off = Offset::bottom;
4710       }
4711     }
4712 
4713     bool xk = false;
4714     switch (tap-&gt;ptr()) {
4715     case AnyNull:
4716     case TopPTR:
4717       // Compute new klass on demand, do not use tap-&gt;_klass
4718       if (below_centerline(this-&gt;_ptr)) {
4719         xk = this-&gt;_klass_is_exact;
4720       } else {
4721         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4722       }
4723       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4724     case Constant: {
4725       ciObject* o = const_oop();
</pre>
<hr />
<pre>
4750               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4751       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4752     default: ShouldNotReachHere();
4753     }
4754   }
4755 
4756   // All arrays inherit from Object class
4757   case InstPtr: {
4758     const TypeInstPtr *tp = t-&gt;is_instptr();
4759     Offset offset = meet_offset(tp-&gt;offset());
4760     PTR ptr = meet_ptr(tp-&gt;ptr());
4761     int instance_id = meet_instance_id(tp-&gt;instance_id());
4762     const TypePtr* speculative = xmeet_speculative(tp);
4763     int depth = meet_inline_depth(tp-&gt;inline_depth());
4764     switch (ptr) {
4765     case TopPTR:
4766     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4767       // For instances when a subclass meets a superclass we fall
4768       // below the centerline when the superclass is exact. We need to
4769       // do the same here.
<span class="line-modified">4770       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {</span>
4771         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4772       } else {
4773         // cannot subclass, so the meet has to fall badly below the centerline
4774         ptr = NotNull;
4775         instance_id = InstanceBot;
4776         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4777       }
4778     case Constant:
4779     case NotNull:
4780     case BotPTR:                // Fall down to object klass
4781       // LCA is object_klass, but if we subclass from the top we can do better
4782       if (above_centerline(tp-&gt;ptr())) {
4783         // If &#39;tp&#39;  is above the centerline and it is Object class
4784         // then we can subclass in the Java class hierarchy.
4785         // For instances when a subclass meets a superclass we fall
4786         // below the centerline when the superclass is exact. We need
4787         // to do the same here.
<span class="line-modified">4788         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {</span>
4789           // that is, my array type is a subtype of &#39;tp&#39; klass
4790           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4791                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4792         }
4793       }
4794       // The other case cannot happen, since t cannot be a subtype of an array.
4795       // The meet falls down to Object class below centerline.
4796       if( ptr == Constant )
4797          ptr = NotNull;
4798       instance_id = InstanceBot;
4799       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4800     default: typerr(t);
4801     }
4802   }
4803 
4804   case InlineType: {
4805     const TypeInlineType* tv = t-&gt;is_inlinetype();
4806     if (above_centerline(ptr())) {
4807       return TypeInstPtr::NOTNULL;
4808     } else {
</pre>
<hr />
<pre>
4849   _ary-&gt;dump2(d,depth,st);
4850   switch( _ptr ) {
4851   case Constant:
4852     const_oop()-&gt;print(st);
4853     break;
4854   case BotPTR:
4855     if (!WizardMode &amp;&amp; !Verbose) {
4856       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4857       break;
4858     }
4859   case TopPTR:
4860   case AnyNull:
4861   case NotNull:
4862     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4863     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4864     break;
4865   default:
4866     break;
4867   }
4868 
<span class="line-modified">4869   if (elem()-&gt;isa_inlinetype()) {</span>
4870     st-&gt;print(&quot;(&quot;);
4871     _field_offset.dump2(st);
4872     st-&gt;print(&quot;)&quot;);
4873   }
4874   if (offset() != 0) {
4875     int header_size = objArrayOopDesc::header_size() * wordSize;
4876     if( _offset == Offset::top )       st-&gt;print(&quot;+undefined&quot;);
4877     else if( _offset == Offset::bottom )  st-&gt;print(&quot;+any&quot;);
4878     else if( offset() &lt; header_size ) st-&gt;print(&quot;+%d&quot;, offset());
4879     else {
4880       BasicType basic_elem_type = elem()-&gt;basic_type();
4881       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4882       int elem_size = type2aelembytes(basic_elem_type);
4883       st-&gt;print(&quot;[%d]&quot;, (offset() - array_base)/elem_size);
4884     }
4885   }
4886   st-&gt;print(&quot; *&quot;);
4887   if (_instance_id == InstanceTop)
4888     st-&gt;print(&quot;,iid=top&quot;);
4889   else if (_instance_id != InstanceBot)
</pre>
<hr />
<pre>
5320 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
5321   return make(Constant, m, Offset(0));
5322 }
5323 
5324 //------------------------------make-------------------------------------------
5325 // Create a meta data constant
5326 const TypeMetadataPtr* TypeMetadataPtr::make(PTR ptr, ciMetadata* m, Offset offset) {
5327   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
5328   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
5329 }
5330 
5331 
5332 //=============================================================================
5333 // Convenience common pre-built types.
5334 
5335 // Not-null object klass or below
5336 const TypeKlassPtr *TypeKlassPtr::OBJECT;
5337 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
5338 
5339 //------------------------------TypeKlassPtr-----------------------------------
<span class="line-modified">5340 TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)</span>
<span class="line-modified">5341   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {</span>
<span class="line-modified">5342    assert(!klass-&gt;is_inlinetype() || !klass-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-modified">5343    assert(!flat_array || can_be_inline_type(), &quot;incorrect flatten array bit&quot;);</span>
5344 }
5345 
5346 //------------------------------make-------------------------------------------
5347 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
<span class="line-modified">5348 const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {</span>
5349   assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
<span class="line-modified">5350   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flat_array))-&gt;hashcons();</span>


5351 }
5352 
5353 //------------------------------eq---------------------------------------------
5354 // Structural equality check for Type representations
5355 bool TypeKlassPtr::eq( const Type *t ) const {
5356   const TypeKlassPtr *p = t-&gt;is_klassptr();
<span class="line-modified">5357   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flat_array() == p-&gt;flat_array();</span>
5358 }
5359 
5360 //------------------------------hash-------------------------------------------
5361 // Type-specific hashing function.
5362 int TypeKlassPtr::hash(void) const {
<span class="line-modified">5363   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flat_array());</span>
5364 }
5365 
5366 //------------------------------singleton--------------------------------------
5367 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5368 // constants
5369 bool TypeKlassPtr::singleton(void) const {
5370   // detune optimizer to not generate constant klass + constant offset as a constant!
5371   // TopPTR, Null, AnyNull, Constant are all singletons
5372   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
5373 }
5374 
5375 // Do not allow interface-vs.-noninterface joins to collapse to top.
5376 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
5377   // logic here mirrors the one from TypeOopPtr::filter. See comments
5378   // there.
5379   const Type* ft = join_helper(kills, include_speculative);
5380   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
5381   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
5382 
5383   if (ft-&gt;empty()) {
</pre>
<hr />
<pre>
5477     // active compilations.  However, the ciKlass which represents
5478     // this Type is *not* shared between compilations, so caching
5479     // this value would result in fetching a dangling pointer.
5480     //
5481     // Recomputing the underlying ciKlass for each request is
5482     // a bit less efficient than caching, but calls to
5483     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5484     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5485     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
5486         offset() != 0 &amp;&amp; offset() != arrayOopDesc::length_offset_in_bytes()) {
5487       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5488     }
5489   }
5490   return k_ary;
5491 }
5492 
5493 
5494 //------------------------------add_offset-------------------------------------
5495 // Access internals of klass object
5496 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
<span class="line-modified">5497   return make(_ptr, klass(), xadd_offset(offset), flat_array());</span>
5498 }
5499 
5500 //------------------------------cast_to_ptr_type-------------------------------
5501 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5502   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5503   if( ptr == _ptr ) return this;
<span class="line-modified">5504   return make(ptr, _klass, _offset, _flat_array);</span>
5505 }
5506 
5507 
5508 //-----------------------------cast_to_exactness-------------------------------
5509 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5510   if( klass_is_exact == _klass_is_exact ) return this;
<span class="line-modified">5511   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flat_array);</span>
5512 }
5513 
5514 
5515 //-----------------------------as_instance_type--------------------------------
5516 // Corresponding type for an instance of the given class.
5517 // It will be NotNull, and exact if and only if the klass type is exact.
5518 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5519   ciKlass* k = klass();
5520   assert(k != NULL, &quot;klass should not be NULL&quot;);
5521   bool    xk = klass_is_exact();
5522   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5523   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5524   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5525   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-modified">5526   if (flat_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
<span class="line-modified">5527     toop = toop-&gt;is_instptr()-&gt;cast_to_flat_array();</span>
5528   }
5529   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5530 }
5531 
5532 
5533 //------------------------------xmeet------------------------------------------
5534 // Compute the MEET of two types, return a new Type object.
5535 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5536   // Perform a fast test for common case; meeting the same types together.
5537   if( this == t ) return this;  // Meeting same type-rep?
5538 
5539   // Current &quot;this-&gt;_base&quot; is Pointer
5540   switch (t-&gt;base()) {          // switch on original type
5541 
5542   case Int:                     // Mixing ints &amp; oops happens when javac
5543   case Long:                    // reuses local variables
5544   case FloatTop:
5545   case FloatCon:
5546   case FloatBot:
5547   case DoubleTop:
</pre>
<hr />
<pre>
5551   case NarrowKlass:
5552   case Bottom:                  // Ye Olde Default
5553     return Type::BOTTOM;
5554   case Top:
5555     return this;
5556 
5557   default:                      // All else is a mistake
5558     typerr(t);
5559 
5560   case AnyPtr: {                // Meeting to AnyPtrs
5561     // Found an AnyPtr type vs self-KlassPtr type
5562     const TypePtr *tp = t-&gt;is_ptr();
5563     Offset offset = meet_offset(tp-&gt;offset());
5564     PTR ptr = meet_ptr(tp-&gt;ptr());
5565     switch (tp-&gt;ptr()) {
5566     case TopPTR:
5567       return this;
5568     case Null:
5569       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5570     case AnyNull:
<span class="line-modified">5571       return make(ptr, klass(), offset, flat_array());</span>
5572     case BotPTR:
5573     case NotNull:
5574       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5575     default: typerr(t);
5576     }
5577   }
5578 
5579   case RawPtr:
5580   case MetadataPtr:
5581   case OopPtr:
5582   case AryPtr:                  // Meet with AryPtr
5583   case InstPtr:                 // Meet with InstPtr
5584     return TypePtr::BOTTOM;
5585 
5586   //
5587   //             A-top         }
5588   //           /   |   \       }  Tops
5589   //       B-top A-any C-top   }
5590   //          | /  |  \ |      }  Any-nulls
5591   //       B-any   |   C-any   }
5592   //          |    |    |
5593   //       B-con A-con C-con   } constants; not comparable across classes
5594   //          |    |    |
5595   //       B-not   |   C-not   }
5596   //          | \  |  / |      }  not-nulls
5597   //       B-bot A-not C-bot   }
5598   //           \   |   /       }  Bottoms
5599   //             A-bot         }
5600   //
5601 
5602   case KlassPtr: {  // Meet two KlassPtr types
5603     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
5604     Offset  off  = meet_offset(tkls-&gt;offset());
5605     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5606 
5607     if (klass() == NULL || tkls-&gt;klass() == NULL) {
5608       ciKlass* k = NULL;
5609       if (ptr == Constant) {
5610         k = (klass() == NULL) ? tkls-&gt;klass() : klass();
5611       }
<span class="line-modified">5612       return make(ptr, k, off, false);</span>
5613     }
5614 
5615     // Check for easy case; klasses are equal (and perhaps not loaded!)
5616     // If we have constants, then we created oops so classes are loaded
5617     // and we can handle the constants further down.  This case handles
5618     // not-loaded classes
<span class="line-modified">5619     if (ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) &amp;&amp; flat_array() == tkls-&gt;flat_array()) {</span>
<span class="line-modified">5620       return make(ptr, klass(), off, flat_array());</span>
5621     }
5622 
5623     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5624     ciKlass* tkls_klass = tkls-&gt;klass();
5625     ciKlass* this_klass = this-&gt;klass();
5626     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5627     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
<span class="line-modified">5628     bool tkls_flat_array = tkls-&gt;flat_array();</span>
<span class="line-modified">5629     bool this_flat_array  = this-&gt;flat_array();</span>
<span class="line-modified">5630     bool flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tkls_flat_array) : (this_flat_array || tkls_flat_array);</span>
5631 
5632     // If &#39;this&#39; type is above the centerline and is a superclass of the
5633     // other, we can treat &#39;this&#39; as having the same type as the other.
5634     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5635         tkls_klass-&gt;is_subtype_of(this_klass)) {
5636       this_klass = tkls_klass;
5637     }
5638     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5639     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5640     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5641         this_klass-&gt;is_subtype_of(tkls_klass)) {
5642       tkls_klass = this_klass;
5643     }
5644 
5645     // Check for classes now being equal
5646     if (tkls_klass-&gt;equals(this_klass)) {
5647       // If the klasses are equal, the constants may still differ.  Fall to
5648       // NotNull if they do (neither constant is NULL; that is a special case
5649       // handled elsewhere).
5650       if( ptr == Constant ) {
5651         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5652             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5653         else if (above_centerline(this-&gt;ptr()));
5654         else if (above_centerline(tkls-&gt;ptr()));
5655         else
5656           ptr = NotNull;
5657       }
<span class="line-modified">5658       return make(ptr, this_klass, off, flat_array);</span>
5659     } // Else classes are not equal
5660 
5661     // Since klasses are different, we require the LCA in the Java
5662     // class hierarchy - which means we have to fall to at least NotNull.
5663     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5664       ptr = NotNull;
5665     // Now we find the LCA of Java classes
5666     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="line-modified">5667     return   make(ptr, k, off, k-&gt;is_inlinetype() &amp;&amp; k-&gt;flatten_array());</span>
5668   } // End of case KlassPtr
5669 
5670   } // End of switch
5671   return this;                  // Return the double constant
5672 }
5673 
5674 //------------------------------xdual------------------------------------------
5675 // Dual: compute field-by-field dual
5676 const Type    *TypeKlassPtr::xdual() const {
<span class="line-modified">5677   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flat_array());</span>
5678 }
5679 
5680 //------------------------------get_con----------------------------------------
5681 intptr_t TypeKlassPtr::get_con() const {
5682   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5683   assert(offset() &gt;= 0, &quot;&quot;);
5684 
5685   if (offset() != 0) {
5686     // After being ported to the compiler interface, the compiler no longer
5687     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5688     // to a handle at compile time.  This handle is embedded in the generated
5689     // code and dereferenced at the time the nmethod is made.  Until that time,
5690     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5691     // have access to the addresses!).  This does not seem to currently happen,
5692     // but this assertion here is to help prevent its occurence.
5693     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5694     ShouldNotReachHere();
5695   }
5696 
5697   return (intptr_t)klass()-&gt;constant_encoding();
</pre>
</td>
<td>
<hr />
<pre>
 572 
 573   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, Offset(0));
 574   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, Offset::bottom);
 575   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, Offset::bottom);
 576 
 577   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 578   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 579 
 580   const Type **fmembar = TypeTuple::fields(0);
 581   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 582 
 583   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 584   fsc[0] = TypeInt::CC;
 585   fsc[1] = Type::MEMORY;
 586   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 587 
 588   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 589   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 590   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 591   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified"> 592                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()));</span>
 593   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified"> 594                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()));</span>
 595   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
 596 
 597   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
 598 
 599   TypeInlineType::BOTTOM = TypeInlineType::make(NULL);
 600 
 601   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 602   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 603 
 604   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 605 
 606   mreg2type[Op_Node] = Type::BOTTOM;
 607   mreg2type[Op_Set ] = 0;
 608   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 609   mreg2type[Op_RegI] = TypeInt::INT;
 610   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 611   mreg2type[Op_RegF] = Type::FLOAT;
 612   mreg2type[Op_RegD] = Type::DOUBLE;
 613   mreg2type[Op_RegL] = TypeLong::LONG;
 614   mreg2type[Op_RegFlags] = TypeInt::CC;
</pre>
<hr />
<pre>
 633   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);
 634   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);
 635   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);
 636   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);
 637   TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInlineType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);
 638 
 639   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 640   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 641   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 642   TypeAryPtr::_array_body_type[T_INLINE_TYPE] = TypeAryPtr::OOPS;
 643   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 644   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 645   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 646   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 647   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 648   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 649   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 650   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 651   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 652 
<span class="line-modified"> 653   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0));</span>
<span class="line-modified"> 654   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0));</span>
 655 
 656   const Type **fi2c = TypeTuple::fields(2);
 657   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 658   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 659   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 660 
 661   const Type **intpair = TypeTuple::fields(2);
 662   intpair[0] = TypeInt::INT;
 663   intpair[1] = TypeInt::INT;
 664   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 665 
 666   const Type **longpair = TypeTuple::fields(2);
 667   longpair[0] = TypeLong::LONG;
 668   longpair[1] = TypeLong::LONG;
 669   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 670 
 671   const Type **intccpair = TypeTuple::fields(2);
 672   intccpair[0] = TypeInt::INT;
 673   intccpair[1] = TypeInt::CC;
 674   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
</pre>
<hr />
<pre>
3322 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3323   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3324   if( ptr == _ptr ) return this;
3325   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3326 }
3327 
3328 //-----------------------------cast_to_instance_id----------------------------
3329 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3330   // There are no instances of a general oop.
3331   // Return self unchanged.
3332   return this;
3333 }
3334 
3335 //-----------------------------cast_to_exactness-------------------------------
3336 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3337   // There is no such thing as an exact general oop.
3338   // Return self unchanged.
3339   return this;
3340 }
3341 













3342 //------------------------------meet-------------------------------------------
3343 // Compute the MEET of two types.  It returns a new Type object.
3344 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3345   // Perform a fast test for common case; meeting the same types together.
3346   if( this == t ) return this;  // Meeting same type-rep?
3347 
3348   // Current &quot;this-&gt;_base&quot; is OopPtr
3349   switch (t-&gt;base()) {          // switch on original type
3350 
3351   case Int:                     // Mixing ints &amp; oops happens when javac
3352   case Long:                    // reuses local variables
3353   case FloatTop:
3354   case FloatCon:
3355   case FloatBot:
3356   case DoubleTop:
3357   case DoubleCon:
3358   case DoubleBot:
3359   case NarrowOop:
3360   case NarrowKlass:
3361   case Bottom:                  // Ye Olde Default
</pre>
<hr />
<pre>
3431     if (klass-&gt;is_loaded()) {
3432       // Try to set klass_is_exact.
3433       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3434       klass_is_exact = ik-&gt;is_final();
3435       if (!klass_is_exact &amp;&amp; klass_change
3436           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3437         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3438         if (sub != NULL) {
3439           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3440           klass = ik = sub;
3441           klass_is_exact = sub-&gt;is_final();
3442         }
3443       }
3444       if (!klass_is_exact &amp;&amp; try_for_exact &amp;&amp; deps != NULL &amp;&amp;
3445           !ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3446         // Add a dependence; if concrete subclass added we need to recompile
3447         deps-&gt;assert_leaf_type(ik);
3448         klass_is_exact = true;
3449       }
3450     }
<span class="line-modified">3451     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0));</span>
3452   } else if (klass-&gt;is_obj_array_klass()) {
3453     // Element is an object or inline type array. Recursively call ourself.
3454     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);
3455     if (etype-&gt;is_inlinetypeptr()) {
3456       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3457     }
3458     // Determine null-free/flattened properties
3459     const TypeOopPtr* exact_etype = etype;
3460     if (etype-&gt;can_be_inline_type()) {
3461       // Use exact type if element can be an inline type
3462       exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);
3463     }
3464     bool not_null_free = !exact_etype-&gt;can_be_inline_type();
3465     bool not_flat = !UseFlatArray || not_null_free || (exact_etype-&gt;is_inlinetypeptr() &amp;&amp; !exact_etype-&gt;inline_klass()-&gt;flatten_array());
3466 
3467     bool xk = etype-&gt;klass_is_exact();
3468     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
3469     // We used to pass NotNull in here, asserting that the sub-arrays
3470     // are all not-null.  This is not true in generally, as code can
3471     // slam NULLs down in the subarrays.
</pre>
<hr />
<pre>
3487     return arr;
3488   } else {
3489     ShouldNotReachHere();
3490     return NULL;
3491   }
3492 }
3493 
3494 //------------------------------make_from_constant-----------------------------
3495 // Make a java pointer from an oop constant
3496 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3497   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3498 
3499   const bool make_constant = require_constant || o-&gt;should_be_constant();
3500 
3501   ciKlass* klass = o-&gt;klass();
3502   if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {
3503     // Element is an instance or inline type
3504     if (make_constant) {
3505       return TypeInstPtr::make(o);
3506     } else {
<span class="line-modified">3507       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0));</span>
3508     }
3509   } else if (klass-&gt;is_obj_array_klass()) {
3510     // Element is an object array. Recursively call ourself.
3511     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
3512     bool null_free = false;
3513     if (etype-&gt;is_inlinetypeptr()) {
3514       null_free = true;
3515       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3516     }
3517     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3518                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);
3519     // We used to pass NotNull in here, asserting that the sub-arrays
3520     // are all not-null.  This is not true in generally, as code can
3521     // slam NULLs down in the subarrays.
3522     if (make_constant) {
3523       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3524     } else {
3525       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3526     }
3527   } else if (klass-&gt;is_type_array_klass()) {
</pre>
<hr />
<pre>
3744  * @return  true if type profile is valuable
3745  */
3746 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3747   // no way to improve an already exact type
3748   if (klass_is_exact()) {
3749     return false;
3750   }
3751   return TypePtr::would_improve_type(exact_kls, inline_depth);
3752 }
3753 
3754 //=============================================================================
3755 // Convenience common pre-built types.
3756 const TypeInstPtr *TypeInstPtr::NOTNULL;
3757 const TypeInstPtr *TypeInstPtr::BOTTOM;
3758 const TypeInstPtr *TypeInstPtr::MIRROR;
3759 const TypeInstPtr *TypeInstPtr::MARK;
3760 const TypeInstPtr *TypeInstPtr::KLASS;
3761 
3762 //------------------------------TypeInstPtr-------------------------------------
3763 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,
<span class="line-modified">3764                          bool flatten_array, int instance_id, const TypePtr* speculative,</span>
3765                          int inline_depth)
3766   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
<span class="line-modified">3767     _name(k-&gt;name()), _flatten_array(flatten_array) {</span>
<span class="line-modified">3768   assert(k != NULL &amp;&amp;</span>
<span class="line-modified">3769          (k-&gt;is_loaded() || o == NULL),</span>
<span class="line-modified">3770          &quot;cannot have constants with non-loaded klass&quot;);</span>
<span class="line-modified">3771   assert(!klass()-&gt;flatten_array() || flatten_array, &quot;Should be flat in array&quot;);</span>
<span class="line-modified">3772   assert(!flatten_array || can_be_inline_type(), &quot;Only inline types can be flat in array&quot;);</span>
3773 };
3774 
3775 //------------------------------make-------------------------------------------
3776 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3777                                      ciKlass* k,
3778                                      bool xk,
3779                                      ciObject* o,
3780                                      Offset offset,
<span class="line-modified">3781                                      bool flatten_array,</span>
3782                                      int instance_id,
3783                                      const TypePtr* speculative,
3784                                      int inline_depth) {
3785   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3786   // Either const_oop() is NULL or else ptr is Constant
3787   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3788           &quot;constant pointers must have a value supplied&quot; );
3789   // Ptr is never Null
3790   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3791 
3792   assert(instance_id &lt;= 0 || xk, &quot;instances are always exactly typed&quot;);
3793   if (ptr == Constant) {
3794     // Note:  This case includes meta-object constants, such as methods.
3795     xk = true;
3796   } else if (k-&gt;is_loaded()) {
3797     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3798     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3799     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3800   }
3801 
<span class="line-added">3802   // Check if this type is known to be flat in arrays</span>
<span class="line-added">3803   flatten_array = flatten_array || k-&gt;flatten_array();</span>
<span class="line-added">3804 </span>
3805   // Now hash this baby
3806   TypeInstPtr *result =
<span class="line-modified">3807     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o, offset, flatten_array, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
3808 
3809   return result;
3810 }
3811 
3812 /**
3813  *  Create constant type for a constant boxed value
3814  */
3815 const Type* TypeInstPtr::get_const_boxed_value() const {
3816   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3817   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3818   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3819   BasicType bt = constant.basic_type();
3820   switch (bt) {
3821     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3822     case T_INT:      return TypeInt::make(constant.as_int());
3823     case T_CHAR:     return TypeInt::make(constant.as_char());
3824     case T_BYTE:     return TypeInt::make(constant.as_byte());
3825     case T_SHORT:    return TypeInt::make(constant.as_short());
3826     case T_FLOAT:    return TypeF::make(constant.as_float());
3827     case T_DOUBLE:   return TypeD::make(constant.as_double());
3828     case T_LONG:     return TypeLong::make(constant.as_long());
3829     default:         break;
3830   }
3831   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3832   return NULL;
3833 }
3834 
3835 //------------------------------cast_to_ptr_type-------------------------------
3836 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3837   if( ptr == _ptr ) return this;
3838   // Reconstruct _sig info here since not a problem with later lazy
3839   // construction, _sig will show up on demand.
<span class="line-modified">3840   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flatten_array, _instance_id, _speculative, _inline_depth);</span>
3841 }
3842 
3843 
3844 //-----------------------------cast_to_exactness-------------------------------
3845 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3846   if( klass_is_exact == _klass_is_exact ) return this;
3847   if (!_klass-&gt;is_loaded())  return this;
3848   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3849   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3850   if( ik-&gt;is_interface() )              return this;  // cannot set xk
<span class="line-modified">3851   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flatten_array, _instance_id, _speculative, _inline_depth);</span>
3852 }
3853 
3854 //-----------------------------cast_to_instance_id----------------------------
3855 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3856   if( instance_id == _instance_id ) return this;
<span class="line-modified">3857   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flatten_array, instance_id, _speculative, _inline_depth);</span>
3858 }
3859 
3860 //------------------------------xmeet_unloaded---------------------------------
3861 // Compute the MEET of two InstPtrs when at least one is unloaded.
3862 // Assume classes are different since called after check for same name/class-loader
3863 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3864     Offset off = meet_offset(tinst-&gt;offset());
3865     PTR ptr = meet_ptr(tinst-&gt;ptr());
3866     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3867     const TypePtr* speculative = xmeet_speculative(tinst);
3868     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3869 
3870     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3871     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3872     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3873       //
3874       // Meet unloaded class with java/lang/Object
3875       //
3876       // Meet
3877       //          |                     Unloaded Class
</pre>
<hr />
<pre>
3933   default:                      // All else is a mistake
3934     typerr(t);
3935 
3936   case MetadataPtr:
3937   case KlassPtr:
3938   case RawPtr: return TypePtr::BOTTOM;
3939 
3940   case AryPtr: {                // All arrays inherit from Object class
3941     const TypeAryPtr *tp = t-&gt;is_aryptr();
3942     Offset offset = meet_offset(tp-&gt;offset());
3943     PTR ptr = meet_ptr(tp-&gt;ptr());
3944     int instance_id = meet_instance_id(tp-&gt;instance_id());
3945     const TypePtr* speculative = xmeet_speculative(tp);
3946     int depth = meet_inline_depth(tp-&gt;inline_depth());
3947     switch (ptr) {
3948     case TopPTR:
3949     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3950       // For instances when a subclass meets a superclass we fall
3951       // below the centerline when the superclass is exact. We need to
3952       // do the same here.
<span class="line-modified">3953       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flatten_array()) {</span>
3954         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3955       } else {
3956         // cannot subclass, so the meet has to fall badly below the centerline
3957         ptr = NotNull;
3958         instance_id = InstanceBot;
3959         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3960       }
3961     case Constant:
3962     case NotNull:
3963     case BotPTR:                // Fall down to object klass
3964       // LCA is object_klass, but if we subclass from the top we can do better
3965       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3966         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3967         // then we can subclass in the Java class hierarchy.
3968         // For instances when a subclass meets a superclass we fall
3969         // below the centerline when the superclass is exact. We need
3970         // to do the same here.
<span class="line-modified">3971         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flatten_array()) {</span>
3972           // that is, tp&#39;s array type is a subtype of my klass
3973           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
3974                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3975         }
3976       }
3977       // The other case cannot happen, since I cannot be a subtype of an array.
3978       // The meet falls down to Object class below centerline.
3979       if( ptr == Constant )
3980          ptr = NotNull;
3981       instance_id = InstanceBot;
3982       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3983     default: typerr(t);
3984     }
3985   }
3986 
3987   case OopPtr: {                // Meeting to OopPtrs
3988     // Found a OopPtr type vs self-InstPtr type
3989     const TypeOopPtr *tp = t-&gt;is_oopptr();
3990     Offset offset = meet_offset(tp-&gt;offset());
3991     PTR ptr = meet_ptr(tp-&gt;ptr());
3992     switch (tp-&gt;ptr()) {
3993     case TopPTR:
3994     case AnyNull: {
3995       int instance_id = meet_instance_id(InstanceTop);
3996       const TypePtr* speculative = xmeet_speculative(tp);
3997       int depth = meet_inline_depth(tp-&gt;inline_depth());
3998       return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">3999                   (ptr == Constant ? const_oop() : NULL), offset, flatten_array(), instance_id, speculative, depth);</span>
4000     }
4001     case NotNull:
4002     case BotPTR: {
4003       int instance_id = meet_instance_id(tp-&gt;instance_id());
4004       const TypePtr* speculative = xmeet_speculative(tp);
4005       int depth = meet_inline_depth(tp-&gt;inline_depth());
4006       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4007     }
4008     default: typerr(t);
4009     }
4010   }
4011 
4012   case AnyPtr: {                // Meeting to AnyPtrs
4013     // Found an AnyPtr type vs self-InstPtr type
4014     const TypePtr *tp = t-&gt;is_ptr();
4015     Offset offset = meet_offset(tp-&gt;offset());
4016     PTR ptr = meet_ptr(tp-&gt;ptr());
4017     int instance_id = meet_instance_id(InstanceTop);
4018     const TypePtr* speculative = xmeet_speculative(tp);
4019     int depth = meet_inline_depth(tp-&gt;inline_depth());
4020     switch (tp-&gt;ptr()) {
4021     case Null:
4022       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4023       // else fall through to AnyNull
4024     case TopPTR:
4025     case AnyNull: {
4026       return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">4027                   (ptr == Constant ? const_oop() : NULL), offset, flatten_array(), instance_id, speculative, depth);</span>
4028     }
4029     case NotNull:
4030     case BotPTR:
4031       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
4032     default: typerr(t);
4033     }
4034   }
4035 
4036   /*
4037                  A-top         }
4038                /   |   \       }  Tops
4039            B-top A-any C-top   }
4040               | /  |  \ |      }  Any-nulls
4041            B-any   |   C-any   }
4042               |    |    |
4043            B-con A-con C-con   } constants; not comparable across classes
4044               |    |    |
4045            B-not   |   C-not   }
4046               | \  |  / |      }  not-nulls
4047            B-bot A-not C-bot   }
4048                \   |   /       }  Bottoms
4049                  A-bot         }
4050   */
4051 
4052   case InstPtr: {                // Meeting 2 Oops?
4053     // Found an InstPtr sub-type vs self-InstPtr type
4054     const TypeInstPtr *tinst = t-&gt;is_instptr();
4055     Offset off = meet_offset( tinst-&gt;offset() );
4056     PTR ptr = meet_ptr( tinst-&gt;ptr() );
4057     int instance_id = meet_instance_id(tinst-&gt;instance_id());
4058     const TypePtr* speculative = xmeet_speculative(tinst);
4059     int depth = meet_inline_depth(tinst-&gt;inline_depth());
4060 
4061     // Check for easy case; klasses are equal (and perhaps not loaded!)
4062     // If we have constants, then we created oops so classes are loaded
4063     // and we can handle the constants further down.  This case handles
4064     // both-not-loaded or both-loaded classes
4065     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact() &amp;&amp;
<span class="line-modified">4066         flatten_array() == tinst-&gt;flatten_array()) {</span>
<span class="line-modified">4067       return make(ptr, klass(), klass_is_exact(), NULL, off, flatten_array(), instance_id, speculative, depth);</span>
4068     }
4069 
4070     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
4071     ciKlass* tinst_klass = tinst-&gt;klass();
4072     ciKlass* this_klass  = this-&gt;klass();
4073     bool tinst_xk = tinst-&gt;klass_is_exact();
4074     bool this_xk  = this-&gt;klass_is_exact();
<span class="line-modified">4075     bool tinst_flatten_array = tinst-&gt;flatten_array();</span>
<span class="line-modified">4076     bool this_flatten_array  = this-&gt;flatten_array();</span>
4077     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
4078       // One of these classes has not been loaded
4079       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
4080 #ifndef PRODUCT
4081       if( PrintOpto &amp;&amp; Verbose ) {
4082         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
4083         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
4084         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
4085       }
4086 #endif
4087       return unloaded_meet;
4088     }
4089 
4090     // Handle mixing oops and interfaces first.
4091     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
4092                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
4093       ciKlass *tmp = tinst_klass; // Swap interface around
4094       tinst_klass = this_klass;
4095       this_klass = tmp;
4096       bool tmp2 = tinst_xk;
4097       tinst_xk = this_xk;
4098       this_xk = tmp2;
<span class="line-modified">4099       tmp2 = tinst_flatten_array;</span>
<span class="line-modified">4100       tinst_flatten_array = this_flatten_array;</span>
<span class="line-modified">4101       this_flatten_array = tmp2;</span>
4102     }
4103     if (tinst_klass-&gt;is_interface() &amp;&amp;
4104         !(this_klass-&gt;is_interface() ||
4105           // Treat java/lang/Object as an honorary interface,
4106           // because we need a bottom for the interface hierarchy.
4107           this_klass == ciEnv::current()-&gt;Object_klass())) {
4108       // Oop meets interface!
4109 
4110       // See if the oop subtypes (implements) interface.
4111       ciKlass *k;
4112       bool xk;
4113       bool flat_array;
4114       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
4115         // Oop indeed subtypes.  Now keep oop or interface depending
4116         // on whether we are both above the centerline or either is
4117         // below the centerline.  If we are on the centerline
4118         // (e.g., Constant vs. AnyNull interface), use the constant.
4119         k  = below_centerline(ptr) ? tinst_klass : this_klass;
4120         // If we are keeping this_klass, keep its exactness too.
4121         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
<span class="line-modified">4122         flat_array = below_centerline(ptr) ? tinst_flatten_array    : this_flatten_array;</span>
4123       } else {                  // Does not implement, fall to Object
4124         // Oop does not implement interface, so mixing falls to Object
4125         // just like the verifier does (if both are above the
4126         // centerline fall to interface)
4127         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
4128         xk = above_centerline(ptr) ? tinst_xk : false;
<span class="line-modified">4129         flat_array = above_centerline(ptr) ? tinst_flatten_array : false;</span>
4130         // Watch out for Constant vs. AnyNull interface.
4131         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
4132         instance_id = InstanceBot;
4133       }
4134       ciObject* o = NULL;  // the Constant value, if any
4135       if (ptr == Constant) {
4136         // Find out which constant.
4137         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
4138       }
4139       return make(ptr, k, xk, o, off, flat_array, instance_id, speculative, depth);
4140     }
4141 
4142     // Either oop vs oop or interface vs interface or interface vs Object
4143 
4144     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
4145     // If we split one up &amp; one down AND they subtype, take the down man.
4146     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4147     // If both are up and they subtype, take the subtype class.
4148     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4149     // If both are down and they subtype, take the supertype class.
</pre>
<hr />
<pre>
4155     // If we split one up &amp; one down AND they subtype, take the down man.
4156     // If both are up and they subtype, take the subtype class.
4157 
4158     // If both are down and they subtype, &quot;fall hard&quot;.
4159     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4160     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4161     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4162 
4163     // If a proper subtype is exact, and we return it, we return it exactly.
4164     // If a proper supertype is exact, there can be no subtyping relationship!
4165     // If both types are equal to the subtype, exactness is and-ed below the
4166     // centerline and or-ed above it.  (N.B. Constants are always exact.)
4167 
4168     // Check for subtyping:
4169     ciKlass *subtype = NULL;
4170     bool subtype_exact = false;
4171     bool flat_array = false;
4172     if (tinst_klass-&gt;equals(this_klass)) {
4173       subtype = this_klass;
4174       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
<span class="line-modified">4175       flat_array = below_centerline(ptr) ? (this_flatten_array &amp;&amp; tinst_flatten_array) : (this_flatten_array || tinst_flatten_array);</span>
<span class="line-modified">4176     } else if(!tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of(tinst_klass) &amp;&amp; (!tinst_flatten_array || this_flatten_array)) {</span>
4177       subtype = this_klass;     // Pick subtyping class
4178       subtype_exact = this_xk;
<span class="line-modified">4179       flat_array = this_flatten_array;</span>
<span class="line-modified">4180     } else if(!this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of(this_klass) &amp;&amp; (!this_flatten_array || tinst_flatten_array)) {</span>
4181       subtype = tinst_klass;    // Pick subtyping class
4182       subtype_exact = tinst_xk;
<span class="line-modified">4183       flat_array = tinst_flatten_array;</span>
4184     }
4185 
4186     if (subtype) {
4187       if (above_centerline(ptr)) { // both are up?
4188         this_klass = tinst_klass = subtype;
4189         this_xk = tinst_xk = subtype_exact;
<span class="line-modified">4190         this_flatten_array = tinst_flatten_array = flat_array;</span>
4191       } else if (above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr)) {
4192         this_klass = tinst_klass; // tinst is down; keep down man
4193         this_xk = tinst_xk;
<span class="line-modified">4194         this_flatten_array = tinst_flatten_array;</span>
4195       } else if (above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr)) {
4196         tinst_klass = this_klass; // this is down; keep down man
4197         tinst_xk = this_xk;
<span class="line-modified">4198         tinst_flatten_array = this_flatten_array;</span>
4199       } else {
4200         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
<span class="line-modified">4201         this_flatten_array = flat_array;</span>
4202       }
4203     }
4204 
4205     // Check for classes now being equal
4206     if (tinst_klass-&gt;equals(this_klass)) {
4207       // If the klasses are equal, the constants may still differ.  Fall to
4208       // NotNull if they do (neither constant is NULL; that is a special case
4209       // handled elsewhere).
4210       ciObject* o = NULL;             // Assume not constant when done
4211       ciObject* this_oop  = const_oop();
4212       ciObject* tinst_oop = tinst-&gt;const_oop();
4213       if( ptr == Constant ) {
4214         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
4215             this_oop-&gt;equals(tinst_oop) )
4216           o = this_oop;
4217         else if (above_centerline(this -&gt;_ptr))
4218           o = tinst_oop;
4219         else if (above_centerline(tinst -&gt;_ptr))
4220           o = this_oop;
4221         else
4222           ptr = NotNull;
4223       }
<span class="line-modified">4224       return make(ptr, this_klass, this_xk, o, off, this_flatten_array, instance_id, speculative, depth);</span>
4225     } // Else classes are not equal
4226 
4227     // Since klasses are different, we require a LCA in the Java
4228     // class hierarchy - which means we have to fall to at least NotNull.
4229     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
4230       ptr = NotNull;
4231 
4232     instance_id = InstanceBot;
4233 
4234     // Now we find the LCA of Java classes
4235     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
4236     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);
4237   } // End of case InstPtr
4238 
4239   case InlineType: {
4240     const TypeInlineType* tv = t-&gt;is_inlinetype();
4241     if (above_centerline(ptr())) {
4242       if (tv-&gt;inline_klass()-&gt;is_subtype_of(_klass)) {
4243         return t;
4244       } else {
</pre>
<hr />
<pre>
4260   } // End of switch
4261   return this;                  // Return the double constant
4262 }
4263 
4264 
4265 //------------------------java_mirror_type--------------------------------------
4266 ciType* TypeInstPtr::java_mirror_type() const {
4267   // must be a singleton type
4268   if( const_oop() == NULL )  return NULL;
4269 
4270   // must be of type java.lang.Class
4271   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
4272   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
4273 }
4274 
4275 
4276 //------------------------------xdual------------------------------------------
4277 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
4278 // inheritance mechanism.
4279 const Type *TypeInstPtr::xdual() const {
<span class="line-modified">4280   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flatten_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
4281 }
4282 
4283 //------------------------------eq---------------------------------------------
4284 // Structural equality check for Type representations
4285 bool TypeInstPtr::eq( const Type *t ) const {
4286   const TypeInstPtr *p = t-&gt;is_instptr();
4287   return
4288     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
<span class="line-modified">4289     flatten_array() == p-&gt;flatten_array() &amp;&amp;</span>
4290     TypeOopPtr::eq(p);          // Check sub-type stuff
4291 }
4292 
4293 //------------------------------hash-------------------------------------------
4294 // Type-specific hashing function.
4295 int TypeInstPtr::hash(void) const {
<span class="line-modified">4296   int hash = java_add(java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash()), (jint)flatten_array());</span>
4297   return hash;
4298 }
4299 
4300 //------------------------------dump2------------------------------------------
4301 // Dump oop Type
4302 #ifndef PRODUCT
4303 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4304   // Print the name of the klass.
4305   klass()-&gt;print_name_on(st);
4306 
4307   switch( _ptr ) {
4308   case Constant:
4309     // TO DO: Make CI print the hex address of the underlying oop.
4310     if (WizardMode || Verbose) {
4311       const_oop()-&gt;print_oop(st);
4312     }
4313   case BotPTR:
4314     if (!WizardMode &amp;&amp; !Verbose) {
4315       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4316       break;
4317     }
4318   case TopPTR:
4319   case AnyNull:
4320   case NotNull:
4321     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4322     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4323     break;
4324   default:
4325     break;
4326   }
4327 
4328   _offset.dump2(st);
4329 
4330   st-&gt;print(&quot; *&quot;);
4331 
<span class="line-modified">4332   if (flatten_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
4333     st-&gt;print(&quot; (flatten array)&quot;);
4334   }
4335 
4336   if (_instance_id == InstanceTop)
4337     st-&gt;print(&quot;,iid=top&quot;);
4338   else if (_instance_id != InstanceBot)
4339     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4340 
4341   dump_inline_depth(st);
4342   dump_speculative(st);
4343 }
4344 #endif
4345 
4346 //------------------------------add_offset-------------------------------------
4347 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
<span class="line-modified">4348   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flatten_array(),</span>
4349               _instance_id, add_offset_speculative(offset), _inline_depth);
4350 }
4351 
4352 const Type *TypeInstPtr::remove_speculative() const {
4353   if (_speculative == NULL) {
4354     return this;
4355   }
4356   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="line-modified">4357   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(),</span>
4358               _instance_id, NULL, _inline_depth);
4359 }
4360 
4361 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4362   if (!UseInlineDepthForSpeculativeTypes) {
4363     return this;
4364   }
<span class="line-modified">4365   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(), _instance_id, _speculative, depth);</span>
4366 }
4367 
4368 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4369   assert(is_known_instance(), &quot;should be known&quot;);
<span class="line-modified">4370   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(), instance_id, _speculative, _inline_depth);</span>
4371 }
4372 
<span class="line-modified">4373 const TypeInstPtr *TypeInstPtr::cast_to_flatten_array() const {</span>
4374   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);
4375 }
4376 
4377 
4378 //=============================================================================
4379 // Convenience common pre-built types.
4380 const TypeAryPtr *TypeAryPtr::RANGE;
4381 const TypeAryPtr *TypeAryPtr::OOPS;
4382 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4383 const TypeAryPtr *TypeAryPtr::BYTES;
4384 const TypeAryPtr *TypeAryPtr::SHORTS;
4385 const TypeAryPtr *TypeAryPtr::CHARS;
4386 const TypeAryPtr *TypeAryPtr::INTS;
4387 const TypeAryPtr *TypeAryPtr::LONGS;
4388 const TypeAryPtr *TypeAryPtr::FLOATS;
4389 const TypeAryPtr *TypeAryPtr::DOUBLES;
4390 const TypeAryPtr *TypeAryPtr::INLINES;
4391 
4392 //------------------------------make-------------------------------------------
4393 const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
</pre>
<hr />
<pre>
4496 
4497 //-------------------------------cast_to_not_flat------------------------------
4498 const TypeAryPtr* TypeAryPtr::cast_to_not_flat(bool not_flat) const {
4499   if (not_flat == is_not_flat()) {
4500     return this;
4501   }
4502   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_flat, is_not_null_free());
4503   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4504 }
4505 
4506 //-------------------------------cast_to_not_null_free-------------------------
4507 const TypeAryPtr* TypeAryPtr::cast_to_not_null_free(bool not_null_free) const {
4508   if (not_null_free == is_not_null_free()) {
4509     return this;
4510   }
4511   // Not null free implies not flat
4512   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);
4513   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4514 }
4515 
<span class="line-added">4516 //---------------------------------update_properties---------------------------</span>
<span class="line-added">4517 const TypeAryPtr* TypeAryPtr::update_properties(const TypeAryPtr* from) const {</span>
<span class="line-added">4518   if ((from-&gt;is_flat()          &amp;&amp; is_not_flat()) ||</span>
<span class="line-added">4519       (from-&gt;is_not_flat()      &amp;&amp; is_flat()) ||</span>
<span class="line-added">4520       (from-&gt;is_null_free()     &amp;&amp; is_not_null_free()) ||</span>
<span class="line-added">4521       (from-&gt;is_not_null_free() &amp;&amp; is_null_free())) {</span>
<span class="line-added">4522     return NULL; // Inconsistent properties</span>
<span class="line-added">4523   } else if (from-&gt;is_not_null_free()) {</span>
<span class="line-added">4524     return cast_to_not_null_free(); // Implies not flat</span>
<span class="line-added">4525   } else if (from-&gt;is_not_flat()) {</span>
<span class="line-added">4526     return cast_to_not_flat();</span>
<span class="line-added">4527   }</span>
<span class="line-added">4528   return this;</span>
<span class="line-added">4529 }</span>
<span class="line-added">4530 </span>
4531 //------------------------------cast_to_stable---------------------------------
4532 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4533   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4534     return this;
4535 
4536   const Type* elem = this-&gt;elem();
4537   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4538 
4539   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4540     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4541     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4542   }
4543 
4544   const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_not_flat(), is_not_null_free());
4545 
4546   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4547 }
4548 
4549 //-----------------------------stable_dimension--------------------------------
4550 int TypeAryPtr::stable_dimension() const {
</pre>
<hr />
<pre>
4689     } else // Non integral arrays.
4690       // Must fall to bottom if exact klasses in upper lattice
4691       // are not equal or super klass is exact.
4692       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4693           // meet with top[] and bottom[] are processed further down:
4694           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4695           // both are exact and not equal:
4696           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4697            // &#39;tap&#39; is exact and super or unrelated:
4698            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4699            // &#39;this&#39; is exact and super or unrelated:
4700            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4701       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4702         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4703       }
4704       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
4705     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_flat_array_klass() != tap-&gt;klass()-&gt;is_flat_array_klass()) {
4706       // Meeting flattened inline type array with non-flattened array. Adjust (field) offset accordingly.
4707       if (tary-&gt;_elem-&gt;isa_inlinetype()) {
4708         // Result is flattened
<span class="line-modified">4709         off = Offset(is_flat() ? offset() : tap-&gt;offset());</span>
<span class="line-modified">4710         field_off = is_flat() ? field_offset() : tap-&gt;field_offset();</span>
4711       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
4712         // Result is non-flattened
4713         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
4714         field_off = Offset::bottom;
4715       }
4716     }
4717 
4718     bool xk = false;
4719     switch (tap-&gt;ptr()) {
4720     case AnyNull:
4721     case TopPTR:
4722       // Compute new klass on demand, do not use tap-&gt;_klass
4723       if (below_centerline(this-&gt;_ptr)) {
4724         xk = this-&gt;_klass_is_exact;
4725       } else {
4726         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4727       }
4728       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4729     case Constant: {
4730       ciObject* o = const_oop();
</pre>
<hr />
<pre>
4755               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4756       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4757     default: ShouldNotReachHere();
4758     }
4759   }
4760 
4761   // All arrays inherit from Object class
4762   case InstPtr: {
4763     const TypeInstPtr *tp = t-&gt;is_instptr();
4764     Offset offset = meet_offset(tp-&gt;offset());
4765     PTR ptr = meet_ptr(tp-&gt;ptr());
4766     int instance_id = meet_instance_id(tp-&gt;instance_id());
4767     const TypePtr* speculative = xmeet_speculative(tp);
4768     int depth = meet_inline_depth(tp-&gt;inline_depth());
4769     switch (ptr) {
4770     case TopPTR:
4771     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4772       // For instances when a subclass meets a superclass we fall
4773       // below the centerline when the superclass is exact. We need to
4774       // do the same here.
<span class="line-modified">4775       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flatten_array()) {</span>
4776         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4777       } else {
4778         // cannot subclass, so the meet has to fall badly below the centerline
4779         ptr = NotNull;
4780         instance_id = InstanceBot;
4781         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4782       }
4783     case Constant:
4784     case NotNull:
4785     case BotPTR:                // Fall down to object klass
4786       // LCA is object_klass, but if we subclass from the top we can do better
4787       if (above_centerline(tp-&gt;ptr())) {
4788         // If &#39;tp&#39;  is above the centerline and it is Object class
4789         // then we can subclass in the Java class hierarchy.
4790         // For instances when a subclass meets a superclass we fall
4791         // below the centerline when the superclass is exact. We need
4792         // to do the same here.
<span class="line-modified">4793         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flatten_array()) {</span>
4794           // that is, my array type is a subtype of &#39;tp&#39; klass
4795           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4796                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4797         }
4798       }
4799       // The other case cannot happen, since t cannot be a subtype of an array.
4800       // The meet falls down to Object class below centerline.
4801       if( ptr == Constant )
4802          ptr = NotNull;
4803       instance_id = InstanceBot;
4804       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4805     default: typerr(t);
4806     }
4807   }
4808 
4809   case InlineType: {
4810     const TypeInlineType* tv = t-&gt;is_inlinetype();
4811     if (above_centerline(ptr())) {
4812       return TypeInstPtr::NOTNULL;
4813     } else {
</pre>
<hr />
<pre>
4854   _ary-&gt;dump2(d,depth,st);
4855   switch( _ptr ) {
4856   case Constant:
4857     const_oop()-&gt;print(st);
4858     break;
4859   case BotPTR:
4860     if (!WizardMode &amp;&amp; !Verbose) {
4861       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4862       break;
4863     }
4864   case TopPTR:
4865   case AnyNull:
4866   case NotNull:
4867     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4868     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4869     break;
4870   default:
4871     break;
4872   }
4873 
<span class="line-modified">4874   if (is_flat()) {</span>
4875     st-&gt;print(&quot;(&quot;);
4876     _field_offset.dump2(st);
4877     st-&gt;print(&quot;)&quot;);
4878   }
4879   if (offset() != 0) {
4880     int header_size = objArrayOopDesc::header_size() * wordSize;
4881     if( _offset == Offset::top )       st-&gt;print(&quot;+undefined&quot;);
4882     else if( _offset == Offset::bottom )  st-&gt;print(&quot;+any&quot;);
4883     else if( offset() &lt; header_size ) st-&gt;print(&quot;+%d&quot;, offset());
4884     else {
4885       BasicType basic_elem_type = elem()-&gt;basic_type();
4886       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4887       int elem_size = type2aelembytes(basic_elem_type);
4888       st-&gt;print(&quot;[%d]&quot;, (offset() - array_base)/elem_size);
4889     }
4890   }
4891   st-&gt;print(&quot; *&quot;);
4892   if (_instance_id == InstanceTop)
4893     st-&gt;print(&quot;,iid=top&quot;);
4894   else if (_instance_id != InstanceBot)
</pre>
<hr />
<pre>
5325 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
5326   return make(Constant, m, Offset(0));
5327 }
5328 
5329 //------------------------------make-------------------------------------------
5330 // Create a meta data constant
5331 const TypeMetadataPtr* TypeMetadataPtr::make(PTR ptr, ciMetadata* m, Offset offset) {
5332   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
5333   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
5334 }
5335 
5336 
5337 //=============================================================================
5338 // Convenience common pre-built types.
5339 
5340 // Not-null object klass or below
5341 const TypeKlassPtr *TypeKlassPtr::OBJECT;
5342 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
5343 
5344 //------------------------------TypeKlassPtr-----------------------------------
<span class="line-modified">5345 TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flatten_array)</span>
<span class="line-modified">5346   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flatten_array(flatten_array) {</span>
<span class="line-modified">5347   assert(!klass-&gt;flatten_array() || flatten_array, &quot;Should be flat in array&quot;);</span>
<span class="line-modified">5348   assert(!flatten_array || can_be_inline_type(), &quot;Only inline types can be flat in array&quot;);</span>
5349 }
5350 
5351 //------------------------------make-------------------------------------------
5352 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
<span class="line-modified">5353 const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array) {</span>
5354   assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
<span class="line-modified">5355   // Check if this type is known to be flat in arrays</span>
<span class="line-added">5356   flatten_array = flatten_array || k-&gt;flatten_array();</span>
<span class="line-added">5357   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flatten_array))-&gt;hashcons();</span>
5358 }
5359 
5360 //------------------------------eq---------------------------------------------
5361 // Structural equality check for Type representations
5362 bool TypeKlassPtr::eq( const Type *t ) const {
5363   const TypeKlassPtr *p = t-&gt;is_klassptr();
<span class="line-modified">5364   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flatten_array() == p-&gt;flatten_array();</span>
5365 }
5366 
5367 //------------------------------hash-------------------------------------------
5368 // Type-specific hashing function.
5369 int TypeKlassPtr::hash(void) const {
<span class="line-modified">5370   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flatten_array());</span>
5371 }
5372 
5373 //------------------------------singleton--------------------------------------
5374 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5375 // constants
5376 bool TypeKlassPtr::singleton(void) const {
5377   // detune optimizer to not generate constant klass + constant offset as a constant!
5378   // TopPTR, Null, AnyNull, Constant are all singletons
5379   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
5380 }
5381 
5382 // Do not allow interface-vs.-noninterface joins to collapse to top.
5383 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
5384   // logic here mirrors the one from TypeOopPtr::filter. See comments
5385   // there.
5386   const Type* ft = join_helper(kills, include_speculative);
5387   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
5388   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
5389 
5390   if (ft-&gt;empty()) {
</pre>
<hr />
<pre>
5484     // active compilations.  However, the ciKlass which represents
5485     // this Type is *not* shared between compilations, so caching
5486     // this value would result in fetching a dangling pointer.
5487     //
5488     // Recomputing the underlying ciKlass for each request is
5489     // a bit less efficient than caching, but calls to
5490     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5491     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5492     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
5493         offset() != 0 &amp;&amp; offset() != arrayOopDesc::length_offset_in_bytes()) {
5494       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5495     }
5496   }
5497   return k_ary;
5498 }
5499 
5500 
5501 //------------------------------add_offset-------------------------------------
5502 // Access internals of klass object
5503 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
<span class="line-modified">5504   return make(_ptr, klass(), xadd_offset(offset), flatten_array());</span>
5505 }
5506 
5507 //------------------------------cast_to_ptr_type-------------------------------
5508 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5509   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5510   if( ptr == _ptr ) return this;
<span class="line-modified">5511   return make(ptr, _klass, _offset, _flatten_array);</span>
5512 }
5513 
5514 
5515 //-----------------------------cast_to_exactness-------------------------------
5516 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5517   if( klass_is_exact == _klass_is_exact ) return this;
<span class="line-modified">5518   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flatten_array);</span>
5519 }
5520 
5521 
5522 //-----------------------------as_instance_type--------------------------------
5523 // Corresponding type for an instance of the given class.
5524 // It will be NotNull, and exact if and only if the klass type is exact.
5525 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5526   ciKlass* k = klass();
5527   assert(k != NULL, &quot;klass should not be NULL&quot;);
5528   bool    xk = klass_is_exact();
5529   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5530   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5531   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5532   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-modified">5533   if (flatten_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
<span class="line-modified">5534     toop = toop-&gt;is_instptr()-&gt;cast_to_flatten_array();</span>
5535   }
5536   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5537 }
5538 
5539 
5540 //------------------------------xmeet------------------------------------------
5541 // Compute the MEET of two types, return a new Type object.
5542 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5543   // Perform a fast test for common case; meeting the same types together.
5544   if( this == t ) return this;  // Meeting same type-rep?
5545 
5546   // Current &quot;this-&gt;_base&quot; is Pointer
5547   switch (t-&gt;base()) {          // switch on original type
5548 
5549   case Int:                     // Mixing ints &amp; oops happens when javac
5550   case Long:                    // reuses local variables
5551   case FloatTop:
5552   case FloatCon:
5553   case FloatBot:
5554   case DoubleTop:
</pre>
<hr />
<pre>
5558   case NarrowKlass:
5559   case Bottom:                  // Ye Olde Default
5560     return Type::BOTTOM;
5561   case Top:
5562     return this;
5563 
5564   default:                      // All else is a mistake
5565     typerr(t);
5566 
5567   case AnyPtr: {                // Meeting to AnyPtrs
5568     // Found an AnyPtr type vs self-KlassPtr type
5569     const TypePtr *tp = t-&gt;is_ptr();
5570     Offset offset = meet_offset(tp-&gt;offset());
5571     PTR ptr = meet_ptr(tp-&gt;ptr());
5572     switch (tp-&gt;ptr()) {
5573     case TopPTR:
5574       return this;
5575     case Null:
5576       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5577     case AnyNull:
<span class="line-modified">5578       return make(ptr, klass(), offset, flatten_array());</span>
5579     case BotPTR:
5580     case NotNull:
5581       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5582     default: typerr(t);
5583     }
5584   }
5585 
5586   case RawPtr:
5587   case MetadataPtr:
5588   case OopPtr:
5589   case AryPtr:                  // Meet with AryPtr
5590   case InstPtr:                 // Meet with InstPtr
5591     return TypePtr::BOTTOM;
5592 
5593   //
5594   //             A-top         }
5595   //           /   |   \       }  Tops
5596   //       B-top A-any C-top   }
5597   //          | /  |  \ |      }  Any-nulls
5598   //       B-any   |   C-any   }
5599   //          |    |    |
5600   //       B-con A-con C-con   } constants; not comparable across classes
5601   //          |    |    |
5602   //       B-not   |   C-not   }
5603   //          | \  |  / |      }  not-nulls
5604   //       B-bot A-not C-bot   }
5605   //           \   |   /       }  Bottoms
5606   //             A-bot         }
5607   //
5608 
5609   case KlassPtr: {  // Meet two KlassPtr types
5610     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
5611     Offset  off  = meet_offset(tkls-&gt;offset());
5612     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5613 
5614     if (klass() == NULL || tkls-&gt;klass() == NULL) {
5615       ciKlass* k = NULL;
5616       if (ptr == Constant) {
5617         k = (klass() == NULL) ? tkls-&gt;klass() : klass();
5618       }
<span class="line-modified">5619       return make(ptr, k, off);</span>
5620     }
5621 
5622     // Check for easy case; klasses are equal (and perhaps not loaded!)
5623     // If we have constants, then we created oops so classes are loaded
5624     // and we can handle the constants further down.  This case handles
5625     // not-loaded classes
<span class="line-modified">5626     if (ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) &amp;&amp; flatten_array() == tkls-&gt;flatten_array()) {</span>
<span class="line-modified">5627       return make(ptr, klass(), off, flatten_array());</span>
5628     }
5629 
5630     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5631     ciKlass* tkls_klass = tkls-&gt;klass();
5632     ciKlass* this_klass = this-&gt;klass();
5633     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5634     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
<span class="line-modified">5635     bool tkls_flatten_array = tkls-&gt;flatten_array();</span>
<span class="line-modified">5636     bool this_flatten_array  = this-&gt;flatten_array();</span>
<span class="line-modified">5637     bool flatten_array = below_centerline(ptr) ? (this_flatten_array &amp;&amp; tkls_flatten_array) : (this_flatten_array || tkls_flatten_array);</span>
5638 
5639     // If &#39;this&#39; type is above the centerline and is a superclass of the
5640     // other, we can treat &#39;this&#39; as having the same type as the other.
5641     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5642         tkls_klass-&gt;is_subtype_of(this_klass)) {
5643       this_klass = tkls_klass;
5644     }
5645     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5646     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5647     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5648         this_klass-&gt;is_subtype_of(tkls_klass)) {
5649       tkls_klass = this_klass;
5650     }
5651 
5652     // Check for classes now being equal
5653     if (tkls_klass-&gt;equals(this_klass)) {
5654       // If the klasses are equal, the constants may still differ.  Fall to
5655       // NotNull if they do (neither constant is NULL; that is a special case
5656       // handled elsewhere).
5657       if( ptr == Constant ) {
5658         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5659             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5660         else if (above_centerline(this-&gt;ptr()));
5661         else if (above_centerline(tkls-&gt;ptr()));
5662         else
5663           ptr = NotNull;
5664       }
<span class="line-modified">5665       return make(ptr, this_klass, off, flatten_array);</span>
5666     } // Else classes are not equal
5667 
5668     // Since klasses are different, we require the LCA in the Java
5669     // class hierarchy - which means we have to fall to at least NotNull.
5670     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5671       ptr = NotNull;
5672     // Now we find the LCA of Java classes
5673     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="line-modified">5674     return   make(ptr, k, off);</span>
5675   } // End of case KlassPtr
5676 
5677   } // End of switch
5678   return this;                  // Return the double constant
5679 }
5680 
5681 //------------------------------xdual------------------------------------------
5682 // Dual: compute field-by-field dual
5683 const Type    *TypeKlassPtr::xdual() const {
<span class="line-modified">5684   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flatten_array());</span>
5685 }
5686 
5687 //------------------------------get_con----------------------------------------
5688 intptr_t TypeKlassPtr::get_con() const {
5689   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5690   assert(offset() &gt;= 0, &quot;&quot;);
5691 
5692   if (offset() != 0) {
5693     // After being ported to the compiler interface, the compiler no longer
5694     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5695     // to a handle at compile time.  This handle is embedded in the generated
5696     // code and dereferenced at the time the nmethod is made.  Until that time,
5697     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5698     // have access to the addresses!).  This does not seem to currently happen,
5699     // but this assertion here is to help prevent its occurence.
5700     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5701     ShouldNotReachHere();
5702   }
5703 
5704   return (intptr_t)klass()-&gt;constant_encoding();
</pre>
</td>
</tr>
</table>
<center><a href="subtypenode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>