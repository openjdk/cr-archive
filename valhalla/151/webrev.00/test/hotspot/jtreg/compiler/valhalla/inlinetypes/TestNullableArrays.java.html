<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.inlinetypes;
  25 
  26 import jdk.test.lib.Asserts;
  27 import java.lang.reflect.Method;
  28 import java.util.Arrays;
  29 
  30 /*
  31  * @test
  32  * @key randomness
  33  * @summary Test nullable inline type arrays
  34  * @library /testlibrary /test/lib /compiler/whitebox /
  35  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  36  * @compile TestNullableArrays.java
  37  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  38  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  39  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  40  *                               compiler.valhalla.inlinetypes.InlineTypeTest
  41  *                               compiler.valhalla.inlinetypes.TestNullableArrays
  42  */
  43 public class TestNullableArrays extends InlineTypeTest {
  44     // Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to
  45     // a normal method invocation when encountering flattened arrays.
  46     private static void assertDeoptimizedByC2(Method m) {
  47         if (isCompiledByC2(m)) {
  48             throw new RuntimeException(&quot;Type check should have caused it to deoptimize&quot;);
  49         }
  50     }
  51 
  52     // Extra VM parameters for some test scenarios. See InlineTypeTest.getVMParameters()
  53     @Override
  54     public String[] getExtraVMParameters(int scenario) {
  55         switch (scenario) {
  56         case 2: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  57         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  58         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  59         case 5: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  60         }
  61         return null;
  62     }
  63 
  64     public static void main(String[] args) throws Throwable {
  65         TestNullableArrays test = new TestNullableArrays();
  66         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  67     }
  68 
  69     // Helper methods
  70 
  71     protected long hash() {
  72         return hash(rI, rL);
  73     }
  74 
  75     protected long hash(int x, long y) {
  76         return MyValue1.createWithFieldsInline(x, y).hash();
  77     }
  78 
  79     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  80 
  81     // Test nullable inline type array creation and initialization
  82     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
  83     @Test(valid = InlineTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
  84     public MyValue1.ref[] test1(int len) {
  85         MyValue1.ref[] va = new MyValue1.ref[len];
  86         if (len &gt; 0) {
  87             va[0] = null;
  88         }
  89         for (int i = 1; i &lt; len; ++i) {
  90             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  91         }
  92         return va;
  93     }
  94 
  95     @DontCompile
  96     public void test1_verifier(boolean warmup) {
  97         int len = Math.abs(rI % 10);
  98         MyValue1.ref[] va = test1(len);
  99         if (len &gt; 0) {
 100             Asserts.assertEQ(va[0], null);
 101         }
 102         for (int i = 1; i &lt; len; ++i) {
 103             Asserts.assertEQ(va[i].hash(), hash());
 104         }
 105     }
 106 
 107     // Test creation of an inline type array and element access
 108     @Test
 109     // TODO 8227588
 110     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 111     public long test2() {
 112         MyValue1.ref[] va = new MyValue1.ref[1];
 113         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 114         return va[0].hash();
 115     }
 116 
 117     @DontCompile
 118     public void test2_verifier(boolean warmup) {
 119         long result = test2();
 120         Asserts.assertEQ(result, hash());
 121     }
 122 
 123     // Test receiving an inline type array from the interpreter,
 124     // updating its elements in a loop and computing a hash.
 125     @Test(failOn = ALLOCA)
 126     public long test3(MyValue1.ref[] va) {
 127         long result = 0;
 128         for (int i = 0; i &lt; 10; ++i) {
 129             if (va[i] != null) {
 130                 result += va[i].hash();
 131             }
 132             va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 133         }
 134         va[0] = null;
 135         return result;
 136     }
 137 
 138     @DontCompile
 139     public void test3_verifier(boolean warmup) {
 140         MyValue1.ref[] va = new MyValue1.ref[10];
 141         long expected = 0;
 142         for (int i = 1; i &lt; 10; ++i) {
 143             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 144             expected += va[i].hash();
 145         }
 146         long result = test3(va);
 147         Asserts.assertEQ(expected, result);
 148         Asserts.assertEQ(va[0], null);
 149         for (int i = 1; i &lt; 10; ++i) {
 150             if (va[i].hash() != hash(rI + 1, rL + 1)) {
 151                 Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));
 152             }
 153         }
 154     }
 155 
 156     // Test returning an inline type array received from the interpreter
 157     @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
 158     public MyValue1.ref[] test4(MyValue1.ref[] va) {
 159         return va;
 160     }
 161 
 162     @DontCompile
 163     public void test4_verifier(boolean warmup) {
 164         MyValue1.ref[] va = new MyValue1.ref[10];
 165         for (int i = 0; i &lt; 10; ++i) {
 166             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 167         }
 168         va = test4(va);
 169         for (int i = 0; i &lt; 10; ++i) {
 170             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 171         }
 172     }
 173 
 174     // Merge inline type arrays created from two branches
 175     @Test
 176     public MyValue1.ref[] test5(boolean b) {
 177         MyValue1.ref[] va;
 178         if (b) {
 179             va = new MyValue1.ref[5];
 180             for (int i = 0; i &lt; 5; ++i) {
 181                 va[i] = MyValue1.createWithFieldsInline(rI, rL);
 182             }
 183             va[4] = null;
 184         } else {
 185             va = new MyValue1.ref[10];
 186             for (int i = 0; i &lt; 10; ++i) {
 187                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
 188             }
 189             va[9] = null;
 190         }
 191         long sum = va[0].hashInterpreted();
 192         if (b) {
 193             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
 194         } else {
 195             va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);
 196         }
 197         return va;
 198     }
 199 
 200     @DontCompile
 201     public void test5_verifier(boolean warmup) {
 202         MyValue1.ref[] va = test5(true);
 203         Asserts.assertEQ(va.length, 5);
 204         Asserts.assertEQ(va[0].hash(), hash(rI, hash()));
 205         for (int i = 1; i &lt; 4; ++i) {
 206             Asserts.assertEQ(va[i].hash(), hash());
 207         }
 208         Asserts.assertEQ(va[4], null);
 209         va = test5(false);
 210         Asserts.assertEQ(va.length, 10);
 211         Asserts.assertEQ(va[0].hash(), hash(rI + 1, hash(rI, rL) + 1));
 212         for (int i = 1; i &lt; 9; ++i) {
 213             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 214         }
 215         Asserts.assertEQ(va[9], null);
 216     }
 217 
 218     // Test creation of inline type array with single element
 219     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 220     public MyValue1.ref test6() {
 221         MyValue1.ref[] va = new MyValue1.ref[1];
 222         return va[0];
 223     }
 224 
 225     @DontCompile
 226     public void test6_verifier(boolean warmup) {
 227         MyValue1.ref[] va = new MyValue1.ref[1];
 228         MyValue1.ref v = test6();
 229         Asserts.assertEQ(v, null);
 230     }
 231 
 232     // Test default initialization of inline type arrays
 233     @Test(failOn = LOAD)
 234     public MyValue1.ref[] test7(int len) {
 235         return new MyValue1.ref[len];
 236     }
 237 
 238     @DontCompile
 239     public void test7_verifier(boolean warmup) {
 240         int len = Math.abs(rI % 10);
 241         MyValue1.ref[] va = test7(len);
 242         for (int i = 0; i &lt; len; ++i) {
 243             Asserts.assertEQ(va[i], null);
 244             va[i] = null;
 245         }
 246     }
 247 
 248     // Test creation of inline type array with zero length
 249     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
 250     public MyValue1.ref[] test8() {
 251         return new MyValue1.ref[0];
 252     }
 253 
 254     @DontCompile
 255     public void test8_verifier(boolean warmup) {
 256         MyValue1.ref[] va = test8();
 257         Asserts.assertEQ(va.length, 0);
 258     }
 259 
 260     static MyValue1.ref[] test9_va;
 261 
 262     // Test that inline type array loaded from field has correct type
 263     @Test(failOn = LOOP)
 264     public long test9() {
 265         return test9_va[0].hash();
 266     }
 267 
 268     @DontCompile
 269     public void test9_verifier(boolean warmup) {
 270         test9_va = new MyValue1.ref[1];
 271         test9_va[0] = testValue1;
 272         long result = test9();
 273         Asserts.assertEQ(result, hash());
 274     }
 275 
 276     // Multi-dimensional arrays
 277     @Test
 278     public MyValue1.ref[][][] test10(int len1, int len2, int len3) {
 279         MyValue1.ref[][][] arr = new MyValue1.ref[len1][len2][len3];
 280         for (int i = 0; i &lt; len1; i++) {
 281             for (int j = 0; j &lt; len2; j++) {
 282                 for (int k = 0; k &lt; len3; k++) {
 283                     arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);
 284                     if (k == 0) {
 285                         arr[i][j][k] = null;
 286                     }
 287                 }
 288             }
 289         }
 290         return arr;
 291     }
 292 
 293     @DontCompile
 294     public void test10_verifier(boolean warmup) {
 295         MyValue1.ref[][][] arr = test10(2, 3, 4);
 296         for (int i = 0; i &lt; 2; i++) {
 297             for (int j = 0; j &lt; 3; j++) {
 298                 for (int k = 0; k &lt; 4; k++) {
 299                     if (k == 0) {
 300                         Asserts.assertEQ(arr[i][j][k], null);
 301                     } else {
 302                         Asserts.assertEQ(arr[i][j][k].hash(), MyValue1.createWithFieldsDontInline(rI + i , rL + j + k).hash());
 303                     }
 304                     arr[i][j][k] = null;
 305                 }
 306             }
 307         }
 308     }
 309 
 310     @Test
 311     public void test11(MyValue1.ref[][][] arr, long[] res) {
 312         int l = 0;
 313         for (int i = 0; i &lt; arr.length; i++) {
 314             for (int j = 0; j &lt; arr[i].length; j++) {
 315                 for (int k = 0; k &lt; arr[i][j].length; k++) {
 316                     if (arr[i][j][k] != null) {
 317                         res[l] = arr[i][j][k].hash();
 318                     }
 319                     arr[i][j][k] = null;
 320                     l++;
 321                 }
 322             }
 323         }
 324     }
 325 
 326     @DontCompile
 327     public void test11_verifier(boolean warmup) {
 328         MyValue1.ref[][][] arr = new MyValue1.ref[2][3][4];
 329         long[] res = new long[2*3*4];
 330         long[] verif = new long[2*3*4];
 331         int l = 0;
 332         for (int i = 0; i &lt; 2; i++) {
 333             for (int j = 0; j &lt; 3; j++) {
 334                 for (int k = 0; k &lt; 4; k++) {
 335                     if (j != 2) {
 336                         arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i, rL + j + k);
 337                         verif[l] = arr[i][j][k].hash();
 338                     }
 339                     l++;
 340                 }
 341             }
 342         }
 343         test11(arr, res);
 344         for (int i = 0; i &lt; verif.length; i++) {
 345             Asserts.assertEQ(res[i], verif[i]);
 346         }
 347     }
 348 
 349     // Array load out of bounds (upper bound) at compile time
 350     @Test
 351     public int test12() {
 352         int arraySize = Math.abs(rI) % 10;
 353         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 354 
 355         for (int i = 0; i &lt; arraySize; i++) {
 356             va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 357         }
 358 
 359         try {
 360             return va[arraySize + 1].x;
 361         } catch (ArrayIndexOutOfBoundsException e) {
 362             return rI;
 363         }
 364     }
 365 
 366     public void test12_verifier(boolean warmup) {
 367         Asserts.assertEQ(test12(), rI);
 368     }
 369 
 370     // Array load  out of bounds (lower bound) at compile time
 371     @Test
 372     public int test13() {
 373         int arraySize = Math.abs(rI) % 10;
 374         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 375 
 376         for (int i = 0; i &lt; arraySize; i++) {
 377             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);
 378         }
 379 
 380         try {
 381             return va[-arraySize].x;
 382         } catch (ArrayIndexOutOfBoundsException e) {
 383             return rI;
 384         }
 385     }
 386 
 387     public void test13_verifier(boolean warmup) {
 388         Asserts.assertEQ(test13(), rI);
 389     }
 390 
 391     // Array load out of bound not known to compiler (both lower and upper bound)
 392     @Test
 393     public int test14(MyValue1.ref[] va, int index)  {
 394         return va[index].x;
 395     }
 396 
 397     public void test14_verifier(boolean warmup) {
 398         int arraySize = Math.abs(rI) % 10;
 399         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 400 
 401         for (int i = 0; i &lt; arraySize; i++) {
 402             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 403         }
 404 
 405         int result;
 406         for (int i = -20; i &lt; 20; i++) {
 407             try {
 408                 result = test14(va, i);
 409             } catch (ArrayIndexOutOfBoundsException e) {
 410                 result = rI;
 411             }
 412             Asserts.assertEQ(result, rI);
 413         }
 414     }
 415 
 416     // Array store out of bounds (upper bound) at compile time
 417     @Test
 418     public int test15() {
 419         int arraySize = Math.abs(rI) % 10;
 420         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 421 
 422         try {
 423             for (int i = 0; i &lt;= arraySize; i++) {
 424                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 425             }
 426             return rI - 1;
 427         } catch (ArrayIndexOutOfBoundsException e) {
 428             return rI;
 429         }
 430     }
 431 
 432     public void test15_verifier(boolean warmup) {
 433         Asserts.assertEQ(test15(), rI);
 434     }
 435 
 436     // Array store out of bounds (lower bound) at compile time
 437     @Test
 438     public int test16() {
 439         int arraySize = Math.abs(rI) % 10;
 440         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 441 
 442         try {
 443             for (int i = -1; i &lt;= arraySize; i++) {
 444                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 445             }
 446             return rI - 1;
 447         } catch (ArrayIndexOutOfBoundsException e) {
 448             return rI;
 449         }
 450     }
 451 
 452     public void test16_verifier(boolean warmup) {
 453         Asserts.assertEQ(test16(), rI);
 454     }
 455 
 456     // Array store out of bound not known to compiler (both lower and upper bound)
 457     @Test
 458     public int test17(MyValue1.ref[] va, int index, MyValue1 vt)  {
 459         va[index] = vt;
 460         return va[index].x;
 461     }
 462 
 463     @DontCompile
 464     public void test17_verifier(boolean warmup) {
 465         int arraySize = Math.abs(rI) % 10;
 466         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 467 
 468         for (int i = 0; i &lt; arraySize; i++) {
 469             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 470         }
 471 
 472         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 473         int result;
 474         for (int i = -20; i &lt; 20; i++) {
 475             try {
 476                 result = test17(va, i, vt);
 477             } catch (ArrayIndexOutOfBoundsException e) {
 478                 result = rI + 1;
 479             }
 480             Asserts.assertEQ(result, rI + 1);
 481         }
 482 
 483         for (int i = 0; i &lt; arraySize; i++) {
 484             Asserts.assertEQ(va[i].x, rI + 1);
 485         }
 486     }
 487 
 488     // clone() as stub call
 489     @Test
 490     public MyValue1.ref[] test18(MyValue1.ref[] va) {
 491         return va.clone();
 492     }
 493 
 494     @DontCompile
 495     public void test18_verifier(boolean warmup) {
 496         int len = Math.abs(rI) % 10;
 497         MyValue1.ref[] va1 = new MyValue1.ref[len];
 498         MyValue1[]  va2 = new MyValue1[len];
 499         for (int i = 1; i &lt; len; ++i) {
 500             va1[i] = testValue1;
 501             va2[i] = testValue1;
 502         }
 503         MyValue1.ref[] result1 = test18(va1);
 504         if (len &gt; 0) {
 505             Asserts.assertEQ(result1[0], null);
 506         }
 507         for (int i = 1; i &lt; len; ++i) {
 508             Asserts.assertEQ(result1[i].hash(), va1[i].hash());
 509         }
 510         // make sure we do deopt: GraphKit::new_array assumes an
 511         // array of references
 512         for (int j = 0; j &lt; 10; j++) {
 513             MyValue1.ref[] result2 = test18(va2);
 514 
 515             for (int i = 0; i &lt; len; ++i) {
 516                 Asserts.assertEQ(result2[i].hash(), va2[i].hash());
 517             }
 518         }
 519         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test18&quot;)) {
 520             MyValue1.ref[] result2 = test18(va2);
 521             for (int i = 0; i &lt; len; ++i) {
 522                 Asserts.assertEQ(result2[i].hash(), va2[i].hash());
 523             }
 524         }
 525     }
 526 
 527     // clone() as series of loads/stores
 528     static MyValue1.ref[] test19_orig = null;
 529 
 530     @Test
 531     public MyValue1.ref[] test19() {
 532         MyValue1.ref[] va = new MyValue1.ref[8];
 533         for (int i = 1; i &lt; va.length; ++i) {
 534             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 535         }
 536         test19_orig = va;
 537 
 538         return va.clone();
 539     }
 540 
 541     @DontCompile
 542     public void test19_verifier(boolean warmup) {
 543         MyValue1.ref[] result = test19();
 544         Asserts.assertEQ(result[0], null);
 545         for (int i = 1; i &lt; test19_orig.length; ++i) {
 546             Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
 547         }
 548     }
 549 
 550     // arraycopy() of inline type array with oop fields
 551     @Test
 552     public void test20(MyValue1.ref[] src, MyValue1.ref[] dst) {
 553         System.arraycopy(src, 0, dst, 0, src.length);
 554     }
 555 
 556     @DontCompile
 557     public void test20_verifier(boolean warmup) {
 558         int len = Math.abs(rI) % 10;
 559         MyValue1.ref[] src1 = new MyValue1.ref[len];
 560         MyValue1.ref[] src2 = new MyValue1.ref[len];
 561         MyValue1[]  src3 = new MyValue1[len];
 562         MyValue1[]  src4 = new MyValue1[len];
 563         MyValue1.ref[] dst1 = new MyValue1.ref[len];
 564         MyValue1[]  dst2 = new MyValue1[len];
 565         MyValue1.ref[] dst3 = new MyValue1.ref[len];
 566         MyValue1[]  dst4 = new MyValue1[len];
 567         if (len &gt; 0) {
 568             src2[0] = testValue1;
 569         }
 570         for (int i = 1; i &lt; len; ++i) {
 571             src1[i] = testValue1;
 572             src2[i] = testValue1;
 573             src3[i] = testValue1;
 574             src4[i] = testValue1;
 575         }
 576         test20(src1, dst1);
 577         test20(src2, dst2);
 578         test20(src3, dst3);
 579         test20(src4, dst4);
 580         if (len &gt; 0) {
 581             Asserts.assertEQ(dst1[0], null);
 582             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 583             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 584             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 585         }
 586         for (int i = 1; i &lt; len; ++i) {
 587             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 588             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 589             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 590             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 591         }
 592     }
 593 
 594     // arraycopy() of inline type array with no oop field
 595     @Test
 596     public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {
 597         System.arraycopy(src, 0, dst, 0, src.length);
 598     }
 599 
 600     @DontCompile
 601     public void test21_verifier(boolean warmup) {
 602         int len = Math.abs(rI) % 10;
 603         MyValue2.ref[] src1 = new MyValue2.ref[len];
 604         MyValue2.ref[] src2 = new MyValue2.ref[len];
 605         MyValue2[]  src3 = new MyValue2[len];
 606         MyValue2[]  src4 = new MyValue2[len];
 607         MyValue2.ref[] dst1 = new MyValue2.ref[len];
 608         MyValue2[]  dst2 = new MyValue2[len];
 609         MyValue2.ref[] dst3 = new MyValue2.ref[len];
 610         MyValue2[]  dst4 = new MyValue2[len];
 611         if (len &gt; 0) {
 612             src2[0] = MyValue2.createWithFieldsInline(rI, true);
 613         }
 614         for (int i = 1; i &lt; len; ++i) {
 615             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 616             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 617             src3[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 618             src4[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 619         }
 620         test21(src1, dst1);
 621         test21(src2, dst2);
 622         test21(src3, dst3);
 623         test21(src4, dst4);
 624         if (len &gt; 0) {
 625             Asserts.assertEQ(dst1[0], null);
 626             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 627             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 628             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 629         }
 630         for (int i = 1; i &lt; len; ++i) {
 631             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 632             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 633             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 634             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 635         }
 636     }
 637 
 638     // arraycopy() of inline type array with oop field and tightly
 639     // coupled allocation as dest
 640     @Test
 641     public MyValue1.ref[] test22(MyValue1.ref[] src) {
 642         MyValue1.ref[] dst = new MyValue1.ref[src.length];
 643         System.arraycopy(src, 0, dst, 0, src.length);
 644         return dst;
 645     }
 646 
 647     @DontCompile
 648     public void test22_verifier(boolean warmup) {
 649         int len = Math.abs(rI) % 10;
 650         MyValue1.ref[] src1 = new MyValue1.ref[len];
 651         MyValue1[]  src2 = new MyValue1[len];
 652         for (int i = 1; i &lt; len; ++i) {
 653             src1[i] = testValue1;
 654             src2[i] = testValue1;
 655         }
 656         MyValue1.ref[] dst1 = test22(src1);
 657         MyValue1.ref[] dst2 = test22(src2);
 658         if (len &gt; 0) {
 659             Asserts.assertEQ(dst1[0], null);
 660             Asserts.assertEQ(dst2[0].hash(), MyValue1.default.hash());
 661         }
 662         for (int i = 1; i &lt; len; ++i) {
 663             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 664             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 665         }
 666     }
 667 
 668     // arraycopy() of inline type array with oop fields and tightly
 669     // coupled allocation as dest
 670     @Test
 671     public MyValue1.ref[] test23(MyValue1.ref[] src) {
 672         MyValue1.ref[] dst = new MyValue1.ref[src.length + 10];
 673         System.arraycopy(src, 0, dst, 5, src.length);
 674         return dst;
 675     }
 676 
 677     @DontCompile
 678     public void test23_verifier(boolean warmup) {
 679         int len = Math.abs(rI) % 10;
 680         MyValue1.ref[] src1 = new MyValue1.ref[len];
 681         MyValue1[] src2 = new MyValue1[len];
 682         for (int i = 0; i &lt; len; ++i) {
 683             src1[i] = testValue1;
 684             src2[i] = testValue1;
 685         }
 686         MyValue1.ref[] dst1 = test23(src1);
 687         MyValue1.ref[] dst2 = test23(src2);
 688         for (int i = 0; i &lt; 5; ++i) {
 689             Asserts.assertEQ(dst1[i], null);
 690             Asserts.assertEQ(dst2[i], null);
 691         }
 692         for (int i = 5; i &lt; len; ++i) {
 693             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 694             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 695         }
 696     }
 697 
 698     // arraycopy() of inline type array passed as Object
 699     @Test
 700     public void test24(MyValue1.ref[] src, Object dst) {
 701         System.arraycopy(src, 0, dst, 0, src.length);
 702     }
 703 
 704     @DontCompile
 705     public void test24_verifier(boolean warmup) {
 706         int len = Math.abs(rI) % 10;
 707         MyValue1.ref[] src1 = new MyValue1.ref[len];
 708         MyValue1.ref[] src2 = new MyValue1.ref[len];
 709         MyValue1[]  src3 = new MyValue1[len];
 710         MyValue1[]  src4 = new MyValue1[len];
 711         MyValue1.ref[] dst1 = new MyValue1.ref[len];
 712         MyValue1[]  dst2 = new MyValue1[len];
 713         MyValue1.ref[] dst3 = new MyValue1.ref[len];
 714         MyValue1[]  dst4 = new MyValue1[len];
 715         if (len &gt; 0) {
 716             src2[0] = testValue1;
 717         }
 718         for (int i = 1; i &lt; len; ++i) {
 719             src1[i] = testValue1;
 720             src2[i] = testValue1;
 721             src3[i] = testValue1;
 722             src4[i] = testValue1;
 723         }
 724         test24(src1, dst1);
 725         test24(src2, dst2);
 726         test24(src3, dst3);
 727         test24(src4, dst4);
 728         if (len &gt; 0) {
 729             Asserts.assertEQ(dst1[0], null);
 730             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 731             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 732             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 733         }
 734         for (int i = 1; i &lt; len; ++i) {
 735             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 736             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 737             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 738             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 739         }
 740     }
 741 
 742     // short arraycopy() with no oop field
 743     @Test
 744     public void test25(MyValue2.ref[] src, MyValue2.ref[] dst) {
 745         System.arraycopy(src, 0, dst, 0, 8);
 746     }
 747 
 748     @DontCompile
 749     public void test25_verifier(boolean warmup) {
 750         MyValue2.ref[] src1 = new MyValue2.ref[8];
 751         MyValue2.ref[] src2 = new MyValue2.ref[8];
 752         MyValue2[]  src3 = new MyValue2[8];
 753         MyValue2[]  src4 = new MyValue2[8];
 754         MyValue2.ref[] dst1 = new MyValue2.ref[8];
 755         MyValue2[]  dst2 = new MyValue2[8];
 756         MyValue2.ref[] dst3 = new MyValue2.ref[8];
 757         MyValue2[]  dst4 = new MyValue2[8];
 758         src2[0] = MyValue2.createWithFieldsInline(rI, true);
 759         for (int i = 1; i &lt; 8; ++i) {
 760             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 761             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 762             src3[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 763             src4[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 764         }
 765         test25(src1, dst1);
 766         test25(src2, dst2);
 767         test25(src3, dst3);
 768         test25(src4, dst4);
 769         Asserts.assertEQ(dst1[0], null);
 770         Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 771         Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 772         Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 773         for (int i = 1; i &lt; 8; ++i) {
 774             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 775             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 776             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 777             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 778         }
 779     }
 780 
 781     // short arraycopy() with oop fields
 782     @Test
 783     public void test26(MyValue1.ref[] src, MyValue1.ref[] dst) {
 784         System.arraycopy(src, 0, dst, 0, 8);
 785     }
 786 
 787     @DontCompile
 788     public void test26_verifier(boolean warmup) {
 789         MyValue1.ref[] src1 = new MyValue1.ref[8];
 790         MyValue1.ref[] src2 = new MyValue1.ref[8];
 791         MyValue1[]  src3 = new MyValue1[8];
 792         MyValue1[]  src4 = new MyValue1[8];
 793         MyValue1.ref[] dst1 = new MyValue1.ref[8];
 794         MyValue1[]  dst2 = new MyValue1[8];
 795         MyValue1.ref[] dst3 = new MyValue1.ref[8];
 796         MyValue1[]  dst4 = new MyValue1[8];
 797         src2[0] = testValue1;
 798         for (int i = 1; i &lt; 8 ; ++i) {
 799             src1[i] = testValue1;
 800             src2[i] = testValue1;
 801             src3[i] = testValue1;
 802             src4[i] = testValue1;
 803         }
 804         test26(src1, dst1);
 805         test26(src2, dst2);
 806         test26(src3, dst3);
 807         test26(src4, dst4);
 808         Asserts.assertEQ(dst1[0], null);
 809         Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 810         Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 811         Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 812         for (int i = 1; i &lt; 8; ++i) {
 813             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 814             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 815             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 816             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 817         }
 818     }
 819 
 820     // short arraycopy() with oop fields and offsets
 821     @Test
 822     public void test27(MyValue1.ref[] src, MyValue1.ref[] dst) {
 823         System.arraycopy(src, 1, dst, 2, 6);
 824     }
 825 
 826     @DontCompile
 827     public void test27_verifier(boolean warmup) {
 828         MyValue1.ref[] src1 = new MyValue1.ref[8];
 829         MyValue1.ref[] src2 = new MyValue1.ref[8];
 830         MyValue1[]  src3 = new MyValue1[8];
 831         MyValue1[]  src4 = new MyValue1[8];
 832         MyValue1.ref[] dst1 = new MyValue1.ref[8];
 833         MyValue1[]  dst2 = new MyValue1[8];
 834         MyValue1.ref[] dst3 = new MyValue1.ref[8];
 835         MyValue1[]  dst4 = new MyValue1[8];
 836         for (int i = 1; i &lt; 8; ++i) {
 837             src1[i] = testValue1;
 838             src2[i] = testValue1;
 839             src3[i] = testValue1;
 840             src4[i] = testValue1;
 841         }
 842         test27(src1, dst1);
 843         test27(src2, dst2);
 844         test27(src3, dst3);
 845         test27(src4, dst4);
 846         for (int i = 0; i &lt; 2; ++i) {
 847             Asserts.assertEQ(dst1[i], null);
 848             Asserts.assertEQ(dst2[i].hash(), MyValue1.default.hash());
 849             Asserts.assertEQ(dst3[i], null);
 850             Asserts.assertEQ(dst4[i].hash(), MyValue1.default.hash());
 851         }
 852         for (int i = 2; i &lt; 8; ++i) {
 853             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 854             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 855             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 856             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 857         }
 858     }
 859 
 860     // non escaping allocations
 861     // TODO ZGC does not support the clone intrinsic, remove this once JDK-8232896 is fixed
 862     @Test(valid = ZGCOff, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 863     @Test(valid = ZGCOn)
 864     public MyValue2.ref test28() {
 865         MyValue2.ref[] src = new MyValue2.ref[10];
 866         src[0] = null;
 867         MyValue2.ref[] dst = (MyValue2.ref[])src.clone();
 868         return dst[0];
 869     }
 870 
 871     @DontCompile
 872     public void test28_verifier(boolean warmup) {
 873         MyValue2 v = MyValue2.createWithFieldsInline(rI, false);
 874         MyValue2.ref result = test28();
 875         Asserts.assertEQ(result, null);
 876     }
 877 
 878     // non escaping allocations
 879     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
 880     @Test(failOn = ALLOCA + LOOP + TRAP)
 881     public MyValue2.ref test29(MyValue2.ref[] src) {
 882         MyValue2.ref[] dst = new MyValue2.ref[10];
 883         System.arraycopy(src, 0, dst, 0, 10);
 884         return dst[0];
 885     }
 886 
 887     @DontCompile
 888     public void test29_verifier(boolean warmup) {
 889         MyValue2.ref[] src1 = new MyValue2.ref[10];
 890         MyValue2.val[] src2 = new MyValue2.val[10];
 891         for (int i = 0; i &lt; 10; ++i) {
 892             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 893             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 894         }
 895         MyValue2.ref v = test29(src1);
 896         Asserts.assertEQ(src1[0].hash(), v.hash());
 897         if (!warmup) {
 898             v = test29(src2);
 899             Asserts.assertEQ(src2[0].hash(), v.hash());
 900         }
 901     }
 902 
 903     // non escaping allocation with uncommon trap that needs
 904     // eliminated inline type array element as debug info
 905     @Test
 906     @Warmup(10000)
 907     public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {
 908         MyValue2.ref[] dst = new MyValue2.ref[10];
 909         System.arraycopy(src, 0, dst, 0, 10);
 910         if (flag) { }
 911         return dst[0];
 912     }
 913 
 914     @DontCompile
 915     public void test30_verifier(boolean warmup) {
 916         MyValue2.ref[] src1 = new MyValue2.ref[10];
 917         MyValue2.val[] src2 = new MyValue2.val[10];
 918         for (int i = 0; i &lt; 10; ++i) {
 919             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 920             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 921         }
 922         MyValue2.ref v = test30(src1, !warmup);
 923         Asserts.assertEQ(src1[0].hash(), v.hash());
 924         if (!warmup) {
 925             v = test30(src2, true);
 926             Asserts.assertEQ(src2[0].hash(), v.hash());
 927         }
 928     }
 929 
 930     // non escaping allocation with memory phi
 931     @Test()
 932     // TODO 8227588
 933     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 934     public long test31(boolean b, boolean deopt) {
 935         MyValue2.ref[] src = new MyValue2.ref[1];
 936         if (b) {
 937             src[0] = MyValue2.createWithFieldsInline(rI, true);
 938         } else {
 939             src[0] = MyValue2.createWithFieldsInline(rI, false);
 940         }
 941         if (deopt) {
 942             // uncommon trap
 943             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test31&quot;));
 944         }
 945         return src[0].hash();
 946     }
 947 
 948     @DontCompile
 949     public void test31_verifier(boolean warmup) {
 950         MyValue2 v1 = MyValue2.createWithFieldsInline(rI, true);
 951         long result1 = test31(true, !warmup);
 952         Asserts.assertEQ(result1, v1.hash());
 953         MyValue2 v2 = MyValue2.createWithFieldsInline(rI, false);
 954         long result2 = test31(false, !warmup);
 955         Asserts.assertEQ(result2, v2.hash());
 956     }
 957 
 958     // Tests with Object arrays and clone/arraycopy
 959     // clone() as stub call
 960     @Test
 961     public Object[] test32(Object[] va) {
 962         return va.clone();
 963     }
 964 
 965     @DontCompile
 966     public void test32_verifier(boolean warmup) {
 967         int len = Math.abs(rI) % 10;
 968         MyValue1.ref[] va1 = new MyValue1.ref[len];
 969         MyValue1[] va2 = new MyValue1[len];
 970         for (int i = 1; i &lt; len; ++i) {
 971             va1[i] = testValue1;
 972             va2[i] = testValue1;
 973         }
 974         MyValue1.ref[] result1 = (MyValue1.ref[])test32(va1);
 975         MyValue1.ref[] result2 = (MyValue1.ref[])test32(va2);
 976         if (len &gt; 0) {
 977             Asserts.assertEQ(result1[0], null);
 978             Asserts.assertEQ(result2[0].hash(), MyValue1.default.hash());
 979         }
 980         for (int i = 1; i &lt; len; ++i) {
 981             Asserts.assertEQ(((MyValue1)result1[i]).hash(), ((MyValue1)va1[i]).hash());
 982             Asserts.assertEQ(((MyValue1)result2[i]).hash(), ((MyValue1)va2[i]).hash());
 983         }
 984     }
 985 
 986     @Test
 987     public Object[] test33(Object[] va) {
 988         return va.clone();
 989     }
 990 
 991     @DontCompile
 992     public void test33_verifier(boolean warmup) {
 993         int len = Math.abs(rI) % 10;
 994         Object[] va = new Object[len];
 995         for (int i = 0; i &lt; len; ++i) {
 996             va[i] = testValue1;
 997         }
 998         Object[] result = test33(va);
 999         for (int i = 0; i &lt; len; ++i) {
1000             Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());
1001         }
1002     }
1003 
1004     // clone() as series of loads/stores
1005     static Object[] test34_orig = null;
1006 
1007     @ForceInline
1008     public Object[] test34_helper(boolean flag) {
1009         Object[] va = null;
1010         if (flag) {
1011             va = new MyValue1.ref[8];
1012             for (int i = 0; i &lt; va.length; ++i) {
1013                 va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
1014             }
1015         } else {
1016             va = new Object[8];
1017         }
1018         return va;
1019     }
1020 
1021     @Test
1022     public Object[] test34(boolean flag) {
1023         Object[] va = test34_helper(flag);
1024         test34_orig = va;
1025         return va.clone();
1026     }
1027 
1028     @DontCompile
1029     public void test34_verifier(boolean warmup) {
1030         test34(false);
1031         for (int i = 0; i &lt; 10; i++) { // make sure we do deopt
1032             Object[] result = test34(true);
1033             verify(test34_orig, result);
1034         }
1035         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test34&quot;)) {
1036             Object[] result = test34(true);
1037             verify(test34_orig, result);
1038         }
1039     }
1040 
1041     static void verify(Object[] src, Object[] dst) {
1042         for (int i = 0; i &lt; src.length; ++i) {
1043             if (src[i] != null) {
1044                 Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());
1045             } else {
1046                 Asserts.assertEQ(dst[i], null);
1047             }
1048         }
1049     }
1050 
1051     static void verify(MyValue1.ref[] src, MyValue1.ref[] dst) {
1052         for (int i = 0; i &lt; src.length; ++i) {
1053             if (src[i] != null) {
1054                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1055             } else {
1056                 Asserts.assertEQ(dst[i], null);
1057             }
1058         }
1059     }
1060 
1061     static void verify(MyValue1.ref[] src, Object[] dst) {
1062         for (int i = 0; i &lt; src.length; ++i) {
1063             if (src[i] != null) {
1064                 Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
1065             } else {
1066                 Asserts.assertEQ(dst[i], null);
1067             }
1068         }
1069     }
1070 
1071     static void verify(MyValue2.ref[] src, MyValue2.ref[] dst) {
1072         for (int i = 0; i &lt; src.length; ++i) {
1073             if (src[i] != null) {
1074                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1075             } else {
1076                 Asserts.assertEQ(dst[i], null);
1077             }
1078         }
1079     }
1080 
1081     static void verify(MyValue2.ref[] src, Object[] dst) {
1082         for (int i = 0; i &lt; src.length; ++i) {
1083             if (src[i] != null) {
1084                 Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
1085             } else {
1086                 Asserts.assertEQ(dst[i], null);
1087             }
1088         }
1089     }
1090 
1091     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
1092         if (!warmup) {
1093             Method m = tests.get(test);
1094             if (USE_COMPILER &amp;&amp;  !WHITE_BOX.isMethodCompiled(m, false)) {
1095                 if (!InlineTypeArrayFlatten &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1096                     throw new RuntimeException(&quot;Unexpected deoptimization&quot;);
1097                 }
1098                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1099                 return true;
1100             }
1101         }
1102         return false;
1103     }
1104 
1105     // arraycopy() of inline type array of unknown size
1106     @Test
1107     public void test35(Object src, Object dst, int len) {
1108         System.arraycopy(src, 0, dst, 0, len);
1109     }
1110 
1111     @DontCompile
1112     public void test35_verifier(boolean warmup) {
1113         int len = Math.abs(rI) % 10;
1114         MyValue1.ref[] src = new MyValue1.ref[len];
1115         MyValue1.ref[] dst = new MyValue1.ref[len];
1116         for (int i = 1; i &lt; len; ++i) {
1117             src[i] = testValue1;
1118         }
1119         test35(src, dst, src.length);
1120         verify(src, dst);
1121         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test35&quot;)) {
1122             test35(src, dst, src.length);
1123             verify(src, dst);
1124         }
1125     }
1126 
1127     @Test
1128     public void test36(Object src, MyValue2.ref[] dst) {
1129         System.arraycopy(src, 0, dst, 0, dst.length);
1130     }
1131 
1132     @DontCompile
1133     public void test36_verifier(boolean warmup) {
1134         int len = Math.abs(rI) % 10;
1135         MyValue2.ref[] src = new MyValue2.ref[len];
1136         MyValue2.ref[] dst = new MyValue2.ref[len];
1137         for (int i = 1; i &lt; len; ++i) {
1138             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1139         }
1140         test36(src, dst);
1141         verify(src, dst);
1142         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test36&quot;)) {
1143             test36(src, dst);
1144             verify(src, dst);
1145         }
1146     }
1147 
1148     @Test
1149     public void test37(MyValue2.ref[] src, Object dst) {
1150         System.arraycopy(src, 0, dst, 0, src.length);
1151     }
1152 
1153     @DontCompile
1154     public void test37_verifier(boolean warmup) {
1155         int len = Math.abs(rI) % 10;
1156         MyValue2.ref[] src = new MyValue2.ref[len];
1157         MyValue2.ref[] dst = new MyValue2.ref[len];
1158         for (int i = 1; i &lt; len; ++i) {
1159             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1160         }
1161         test37(src, dst);
1162         verify(src, dst);
1163         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test37&quot;)) {
1164             test37(src, dst);
1165             verify(src, dst);
1166         }
1167     }
1168 
1169     @Test
1170     @Warmup(1) // Avoid early compilation
1171     public void test38(Object src, MyValue2.ref[] dst) {
1172         System.arraycopy(src, 0, dst, 0, dst.length);
1173     }
1174 
1175     @DontCompile
1176     public void test38_verifier(boolean warmup) {
1177         int len = Math.abs(rI) % 10;
1178         Object[] src = new Object[len];
1179         MyValue2.ref[] dst = new MyValue2.ref[len];
1180         for (int i = 1; i &lt; len; ++i) {
1181             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1182         }
1183         test38(src, dst);
1184         verify(dst, src);
1185         if (!warmup) {
1186             Method m = tests.get(&quot;TestNullableArrays::test38&quot;);
1187             assertDeoptimizedByC2(m);
1188             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1189             test38(src, dst);
1190             verify(dst, src);
1191             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1192                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1193             }
1194         }
1195     }
1196 
1197     @Test
1198     public void test39(MyValue2.ref[] src, Object dst) {
1199         System.arraycopy(src, 0, dst, 0, src.length);
1200     }
1201 
1202     @DontCompile
1203     public void test39_verifier(boolean warmup) {
1204         int len = Math.abs(rI) % 10;
1205         MyValue2.ref[] src = new MyValue2.ref[len];
1206         Object[] dst = new Object[len];
1207         for (int i = 1; i &lt; len; ++i) {
1208             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1209         }
1210         test39(src, dst);
1211         verify(src, dst);
1212         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test39&quot;)) {
1213             test39(src, dst);
1214             verify(src, dst);
1215         }
1216     }
1217 
1218     @Test
1219     @Warmup(1) // Avoid early compilation
1220     public void test40(Object[] src, Object dst) {
1221         System.arraycopy(src, 0, dst, 0, src.length);
1222     }
1223 
1224     @DontCompile
1225     public void test40_verifier(boolean warmup) {
1226         int len = Math.abs(rI) % 10;
1227         Object[] src = new Object[len];
1228         MyValue2.ref[] dst = new MyValue2.ref[len];
1229         for (int i = 1; i &lt; len; ++i) {
1230             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1231         }
1232         test40(src, dst);
1233         verify(dst, src);
1234         if (!warmup) {
1235             Method m = tests.get(&quot;TestNullableArrays::test40&quot;);
1236             assertDeoptimizedByC2(m);
1237             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1238             test40(src, dst);
1239             verify(dst, src);
1240             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1241                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1242             }
1243         }
1244     }
1245 
1246     @Test
1247     public void test41(Object src, Object[] dst) {
1248         System.arraycopy(src, 0, dst, 0, dst.length);
1249     }
1250 
1251     @DontCompile
1252     public void test41_verifier(boolean warmup) {
1253         int len = Math.abs(rI) % 10;
1254         MyValue2.ref[] src = new MyValue2.ref[len];
1255         Object[] dst = new Object[len];
1256         for (int i = 1; i &lt; len; ++i) {
1257             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1258         }
1259         test41(src, dst);
1260         verify(src, dst);
1261         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test41&quot;)) {
1262             test41(src, dst);
1263             verify(src, dst);
1264         }
1265     }
1266 
1267     @Test
1268     public void test42(Object[] src, Object[] dst) {
1269         System.arraycopy(src, 0, dst, 0, src.length);
1270     }
1271 
1272     @DontCompile
1273     public void test42_verifier(boolean warmup) {
1274         int len = Math.abs(rI) % 10;
1275         Object[] src = new Object[len];
1276         Object[] dst = new Object[len];
1277         for (int i = 1; i &lt; len; ++i) {
1278             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1279         }
1280         test42(src, dst);
1281         verify(src, dst);
1282         if (!warmup) {
1283             Method m = tests.get(&quot;TestNullableArrays::test42&quot;);
1284             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1285                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1286             }
1287         }
1288     }
1289 
1290     // short arraycopy()&#39;s
1291     @Test
1292     public void test43(Object src, Object dst) {
1293         System.arraycopy(src, 0, dst, 0, 8);
1294     }
1295 
1296     @DontCompile
1297     public void test43_verifier(boolean warmup) {
1298         MyValue1.ref[] src = new MyValue1.ref[8];
1299         MyValue1.ref[] dst = new MyValue1.ref[8];
1300         for (int i = 1; i &lt; 8; ++i) {
1301             src[i] = testValue1;
1302         }
1303         test43(src, dst);
1304         verify(src, dst);
1305         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test43&quot;)) {
1306             test43(src, dst);
1307             verify(src, dst);
1308         }
1309     }
1310 
1311     @Test
1312     public void test44(Object src, MyValue2.ref[] dst) {
1313         System.arraycopy(src, 0, dst, 0, 8);
1314     }
1315 
1316     @DontCompile
1317     public void test44_verifier(boolean warmup) {
1318         MyValue2.ref[] src = new MyValue2.ref[8];
1319         MyValue2.ref[] dst = new MyValue2.ref[8];
1320         for (int i = 1; i &lt; 8; ++i) {
1321             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1322         }
1323         test44(src, dst);
1324         verify(src, dst);
1325         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test44&quot;)) {
1326             test44(src, dst);
1327             verify(src, dst);
1328         }
1329     }
1330 
1331     @Test
1332     public void test45(MyValue2.ref[] src, Object dst) {
1333         System.arraycopy(src, 0, dst, 0, 8);
1334     }
1335 
1336     @DontCompile
1337     public void test45_verifier(boolean warmup) {
1338         MyValue2.ref[] src = new MyValue2.ref[8];
1339         MyValue2.ref[] dst = new MyValue2.ref[8];
1340         for (int i = 1; i &lt; 8; ++i) {
1341             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1342         }
1343         test45(src, dst);
1344         verify(src, dst);
1345         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test45&quot;)) {
1346             test45(src, dst);
1347             verify(src, dst);
1348         }
1349     }
1350 
1351     @Test
1352     @Warmup(1) // Avoid early compilation
1353     public void test46(Object[] src, MyValue2.ref[] dst) {
1354         System.arraycopy(src, 0, dst, 0, 8);
1355     }
1356 
1357     @DontCompile
1358     public void test46_verifier(boolean warmup) {
1359         Object[] src = new Object[8];
1360         MyValue2.ref[] dst = new MyValue2.ref[8];
1361         for (int i = 1; i &lt; 8; ++i) {
1362             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1363         }
1364         test46(src, dst);
1365         verify(dst, src);
1366         if (!warmup) {
1367             Method m = tests.get(&quot;TestNullableArrays::test46&quot;);
1368             assertDeoptimizedByC2(m);
1369             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1370             test46(src, dst);
1371             verify(dst, src);
1372             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1373                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1374             }
1375         }
1376     }
1377 
1378     @Test
1379     public void test47(MyValue2.ref[] src, Object[] dst) {
1380         System.arraycopy(src, 0, dst, 0, 8);
1381     }
1382 
1383     @DontCompile
1384     public void test47_verifier(boolean warmup) {
1385         MyValue2.ref[] src = new MyValue2.ref[8];
1386         Object[] dst = new Object[8];
1387         for (int i = 1; i &lt; 8; ++i) {
1388             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1389         }
1390         test47(src, dst);
1391         verify(src, dst);
1392         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test47&quot;)) {
1393             test47(src, dst);
1394             verify(src, dst);
1395         }
1396     }
1397 
1398     @Test
1399     @Warmup(1) // Avoid early compilation
1400     public void test48(Object[] src, Object dst) {
1401         System.arraycopy(src, 0, dst, 0, 8);
1402     }
1403 
1404     @DontCompile
1405     public void test48_verifier(boolean warmup) {
1406         Object[] src = new Object[8];
1407         MyValue2.ref[] dst = new MyValue2.ref[8];
1408         for (int i = 1; i &lt; 8; ++i) {
1409             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1410         }
1411         test48(src, dst);
1412         verify(dst, src);
1413         if (!warmup) {
1414             Method m = tests.get(&quot;TestNullableArrays::test48&quot;);
1415             assertDeoptimizedByC2(m);
1416             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1417             test48(src, dst);
1418             verify(dst, src);
1419             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1420                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1421             }
1422         }
1423     }
1424 
1425     @Test
1426     public void test49(Object src, Object[] dst) {
1427         System.arraycopy(src, 0, dst, 0, 8);
1428     }
1429 
1430     @DontCompile
1431     public void test49_verifier(boolean warmup) {
1432         MyValue2.ref[] src = new MyValue2.ref[8];
1433         Object[] dst = new Object[8];
1434         for (int i = 1; i &lt; 8; ++i) {
1435             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1436         }
1437         test49(src, dst);
1438         verify(src, dst);
1439         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test49&quot;)) {
1440             test49(src, dst);
1441             verify(src, dst);
1442         }
1443     }
1444 
1445     @Test
1446     public void test50(Object[] src, Object[] dst) {
1447         System.arraycopy(src, 0, dst, 0, 8);
1448     }
1449 
1450     @DontCompile
1451     public void test50_verifier(boolean warmup) {
1452         Object[] src = new Object[8];
1453         Object[] dst = new Object[8];
1454         for (int i = 1; i &lt; 8; ++i) {
1455             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1456         }
1457         test50(src, dst);
1458         verify(src, dst);
1459         if (!warmup) {
1460             Method m = tests.get(&quot;TestNullableArrays::test50&quot;);
1461             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1462                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1463             }
1464         }
1465     }
1466 
1467     @Test
1468     public MyValue1.ref[] test51(MyValue1.ref[] va) {
1469         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1470     }
1471 
1472     @DontCompile
1473     public void test51_verifier(boolean warmup) {
1474         int len = Math.abs(rI) % 10;
1475         MyValue1.ref[] va = new MyValue1.ref[len];
1476         for (int i = 1; i &lt; len; ++i) {
1477             va[i] = testValue1;
1478         }
1479         MyValue1.ref[] result = test51(va);
1480         verify(va, result);
1481     }
1482 
1483     static final MyValue1.ref[] test52_va = new MyValue1.ref[8];
1484 
1485     @Test
1486     public MyValue1.ref[] test52() {
1487         return Arrays.copyOf(test52_va, 8, MyValue1.ref[].class);
1488     }
1489 
1490     @DontCompile
1491     public void test52_verifier(boolean warmup) {
1492         for (int i = 1; i &lt; 8; ++i) {
1493             test52_va[i] = testValue1;
1494         }
1495         MyValue1.ref[] result = test52();
1496         verify(test52_va, result);
1497     }
1498 
1499     @Test
1500     public MyValue1.ref[] test53(Object[] va) {
1501         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1502     }
1503 
1504     @DontCompile
1505     public void test53_verifier(boolean warmup) {
1506         int len = Math.abs(rI) % 10;
1507         MyValue1.ref[] va = new MyValue1.ref[len];
1508         for (int i = 1; i &lt; len; ++i) {
1509             va[i] = testValue1;
1510         }
1511         MyValue1.ref[] result = test53(va);
1512         verify(result, va);
1513     }
1514 
1515     @Test
1516     public Object[] test54(MyValue1.ref[] va) {
1517         return Arrays.copyOf(va, va.length, Object[].class);
1518     }
1519 
1520     @DontCompile
1521     public void test54_verifier(boolean warmup) {
1522         int len = Math.abs(rI) % 10;
1523         MyValue1.ref[] va = new MyValue1.ref[len];
1524         for (int i = 1; i &lt; len; ++i) {
1525             va[i] = testValue1;
1526         }
1527         Object[] result = test54(va);
1528         verify(va, result);
1529     }
1530 
1531     @Test
1532     public Object[] test55(Object[] va) {
1533         return Arrays.copyOf(va, va.length, Object[].class);
1534     }
1535 
1536     @DontCompile
1537     public void test55_verifier(boolean warmup) {
1538         int len = Math.abs(rI) % 10;
1539         MyValue1.ref[] va = new MyValue1.ref[len];
1540         for (int i = 1; i &lt; len; ++i) {
1541             va[i] = testValue1;
1542         }
1543         Object[] result = test55(va);
1544         verify(va, result);
1545     }
1546 
1547     @Test
1548     public MyValue1.ref[] test56(Object[] va) {
1549         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1550     }
1551 
1552     @DontCompile
1553     public void test56_verifier(boolean warmup) {
1554         int len = Math.abs(rI) % 10;
1555         Object[] va = new Object[len];
1556         for (int i = 1; i &lt; len; ++i) {
1557             va[i] = testValue1;
1558         }
1559         MyValue1.ref[] result = test56(va);
1560         verify(result, va);
1561     }
1562 
1563    @Test
1564     public Object[] test57(Object[] va, Class klass) {
1565         return Arrays.copyOf(va, va.length, klass);
1566     }
1567 
1568     @DontCompile
1569     public void test57_verifier(boolean warmup) {
1570         int len = Math.abs(rI) % 10;
1571         Object[] va = new MyValue1.ref[len];
1572         for (int i = 1; i &lt; len; ++i) {
1573             va[i] = testValue1;
1574         }
1575         Object[] result = test57(va, MyValue1.ref[].class);
1576         verify(va, result);
1577     }
1578 
1579     @Test
1580     public Object[] test58(MyValue1.ref[] va, Class klass) {
1581         return Arrays.copyOf(va, va.length, klass);
1582     }
1583 
1584     @DontCompile
1585     public void test58_verifier(boolean warmup) {
1586         int len = Math.abs(rI) % 10;
1587         MyValue1.ref[] va = new MyValue1.ref[len];
1588         for (int i = 1; i &lt; len; ++i) {
1589             va[i] = testValue1;
1590         }
1591         for (int i = 1; i &lt; 10; i++) {
1592             Object[] result = test58(va, MyValue1.ref[].class);
1593             verify(va, result);
1594         }
1595         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test58&quot;)) {
1596             Object[] result = test58(va, MyValue1.ref[].class);
1597             verify(va, result);
1598         }
1599     }
1600 
1601     @Test
1602     public Object[] test59(MyValue1.ref[] va) {
1603         return Arrays.copyOf(va, va.length+1, MyValue1.ref[].class);
1604     }
1605 
1606     @DontCompile
1607     public void test59_verifier(boolean warmup) {
1608         int len = Math.abs(rI) % 10;
1609         MyValue1.ref[] va = new MyValue1.ref[len];
1610         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1611         for (int i = 1; i &lt; len; ++i) {
1612             va[i] = testValue1;
1613             verif[i] = va[i];
1614         }
1615         Object[] result = test59(va);
1616         verify(verif, result);
1617     }
1618 
1619     @Test
1620     public Object[] test60(Object[] va, Class klass) {
1621         return Arrays.copyOf(va, va.length+1, klass);
1622     }
1623 
1624     @DontCompile
1625     public void test60_verifier(boolean warmup) {
1626         int len = Math.abs(rI) % 10;
1627         MyValue1.ref[] va = new MyValue1.ref[len];
1628         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1629         for (int i = 1; i &lt; len; ++i) {
1630             va[i] = testValue1;
1631             verif[i] = (MyValue1)va[i];
1632         }
1633         Object[] result = test60(va, MyValue1.ref[].class);
1634         verify(verif, result);
1635     }
1636 
1637     @Test
1638     public Object[] test61(Object[] va, Class klass) {
1639         return Arrays.copyOf(va, va.length+1, klass);
1640     }
1641 
1642     @DontCompile
1643     public void test61_verifier(boolean warmup) {
1644         int len = Math.abs(rI) % 10;
1645         Object[] va = new Integer[len];
1646         for (int i = 1; i &lt; len; ++i) {
1647             va[i] = new Integer(rI);
1648         }
1649         Object[] result = test61(va, Integer[].class);
1650         for (int i = 0; i &lt; va.length; ++i) {
1651             Asserts.assertEQ(va[i], result[i]);
1652         }
1653     }
1654 
1655     @ForceInline
1656     public Object[] test62_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1657         Object[] arr = null;
1658         if (i == 10) {
1659             arr = oa;
1660         } else {
1661             arr = va;
1662         }
1663         return arr;
1664     }
1665 
1666     @Test
1667     public Object[] test62(MyValue1.ref[] va, Integer[] oa) {
1668         int i = 0;
1669         for (; i &lt; 10; i++);
1670 
1671         Object[] arr = test62_helper(i, va, oa);
1672 
1673         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1674     }
1675 
1676     @DontCompile
1677     public void test62_verifier(boolean warmup) {
1678         int len = Math.abs(rI) % 10;
1679         MyValue1.ref[] va = new MyValue1.ref[len];
1680         Integer[] oa = new Integer[len];
1681         for (int i = 1; i &lt; len; ++i) {
1682             oa[i] = new Integer(rI);
1683         }
1684         test62_helper(42, va, oa);
1685         Object[] result = test62(va, oa);
1686         for (int i = 0; i &lt; va.length; ++i) {
1687             Asserts.assertEQ(oa[i], result[i]);
1688         }
1689     }
1690 
1691     @ForceInline
1692     public Object[] test63_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1693         Object[] arr = null;
1694         if (i == 10) {
1695             arr = va;
1696         } else {
1697             arr = oa;
1698         }
1699         return arr;
1700     }
1701 
1702     @Test
1703     public Object[] test63(MyValue1.ref[] va, Integer[] oa) {
1704         int i = 0;
1705         for (; i &lt; 10; i++);
1706 
1707         Object[] arr = test63_helper(i, va, oa);
1708 
1709         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1710     }
1711 
1712     @DontCompile
1713     public void test63_verifier(boolean warmup) {
1714         int len = Math.abs(rI) % 10;
1715         MyValue1.ref[] va = new MyValue1.ref[len];
1716         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1717         for (int i = 1; i &lt; len; ++i) {
1718             va[i] = testValue1;
1719             verif[i] = va[i];
1720         }
1721         Integer[] oa = new Integer[len];
1722         test63_helper(42, va, oa);
1723         Object[] result = test63(va, oa);
1724         verify(verif, result);
1725     }
1726 
1727     // Test default initialization of inline type arrays: small array
1728     @Test
1729     public MyValue1.ref[] test64() {
1730         return new MyValue1.ref[8];
1731     }
1732 
1733     @DontCompile
1734     public void test64_verifier(boolean warmup) {
1735         MyValue1.ref[] va = test64();
1736         for (int i = 0; i &lt; 8; ++i) {
1737             Asserts.assertEQ(va[i], null);
1738         }
1739     }
1740 
1741     // Test default initialization of inline type arrays: large array
1742     @Test
1743     public MyValue1.ref[] test65() {
1744         return new MyValue1.ref[32];
1745     }
1746 
1747     @DontCompile
1748     public void test65_verifier(boolean warmup) {
1749         MyValue1.ref[] va = test65();
1750         for (int i = 0; i &lt; 32; ++i) {
1751             Asserts.assertEQ(va[i], null);
1752         }
1753     }
1754 
1755     // Check init store elimination
1756     @Test(match = { ALLOCA }, matchCount = { 1 })
1757     public MyValue1.ref[] test66(MyValue1.ref vt) {
1758         MyValue1.ref[] va = new MyValue1.ref[1];
1759         va[0] = vt;
1760         return va;
1761     }
1762 
1763     @DontCompile
1764     public void test66_verifier(boolean warmup) {
1765         MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);
1766         MyValue1.ref[] va = test66(vt);
1767         Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());
1768     }
1769 
1770     // Zeroing elimination and arraycopy
1771     @Test
1772     public MyValue1.ref[] test67(MyValue1.ref[] src) {
1773         MyValue1.ref[] dst = new MyValue1.ref[16];
1774         System.arraycopy(src, 0, dst, 0, 13);
1775         return dst;
1776     }
1777 
1778     @DontCompile
1779     public void test67_verifier(boolean warmup) {
1780         MyValue1.ref[] va = new MyValue1.ref[16];
1781         MyValue1.ref[] var = test67(va);
1782         for (int i = 0; i &lt; 16; ++i) {
1783             Asserts.assertEQ(var[i], null);
1784         }
1785     }
1786 
1787     // A store with a default value can be eliminated
1788     @Test
1789     public MyValue1.ref[] test68() {
1790         MyValue1.ref[] va = new MyValue1.ref[2];
1791         va[0] = va[1];
1792         return va;
1793     }
1794 
1795     @DontCompile
1796     public void test68_verifier(boolean warmup) {
1797         MyValue1.ref[] va = test68();
1798         for (int i = 0; i &lt; 2; ++i) {
1799             Asserts.assertEQ(va[i], null);
1800         }
1801     }
1802 
1803     // Requires individual stores to init array
1804     @Test
1805     public MyValue1.ref[] test69(MyValue1.ref vt) {
1806         MyValue1.ref[] va = new MyValue1.ref[4];
1807         va[0] = vt;
1808         va[3] = vt;
1809         return va;
1810     }
1811 
1812     @DontCompile
1813     public void test69_verifier(boolean warmup) {
1814         MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);
1815         MyValue1.ref[] va = new MyValue1.ref[4];
1816         va[0] = vt;
1817         va[3] = vt;
1818         MyValue1.ref[] var = test69(vt);
1819         for (int i = 0; i &lt; va.length; ++i) {
1820             Asserts.assertEQ(va[i], var[i]);
1821         }
1822     }
1823 
1824     // A store with a default value can be eliminated: same as test68
1825     // but store is farther away from allocation
1826     @Test
1827     public MyValue1.ref[] test70(MyValue1.ref[] other) {
1828         other[1] = other[0];
1829         MyValue1.ref[] va = new MyValue1.ref[2];
1830         other[0] = va[1];
1831         va[0] = va[1];
1832         return va;
1833     }
1834 
1835     @DontCompile
1836     public void test70_verifier(boolean warmup) {
1837         MyValue1.ref[] va = new MyValue1.ref[2];
1838         MyValue1.ref[] var = test70(va);
1839         for (int i = 0; i &lt; 2; ++i) {
1840             Asserts.assertEQ(va[i], var[i]);
1841         }
1842     }
1843 
1844     // EA needs to consider oop fields in flattened arrays
1845     @Test
1846     public void test71() {
1847         int len = 10;
1848         MyValue2.ref[] src = new MyValue2.ref[len];
1849         MyValue2.ref[] dst = new MyValue2.ref[len];
1850         for (int i = 1; i &lt; len; ++i) {
1851             src[i] = MyValue2.createWithFieldsDontInline(rI, (i % 2) == 0);
1852         }
1853         System.arraycopy(src, 0, dst, 0, src.length);
1854         for (int i = 0; i &lt; len; ++i) {
1855             if (src[i] == null) {
1856                 Asserts.assertEQ(dst[i], null);
1857             } else {
1858                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1859             }
1860         }
1861     }
1862 
1863     @DontCompile
1864     public void test71_verifier(boolean warmup) {
1865         test71();
1866     }
1867 
1868     // Test EA with leaf call to &#39;store_unknown_value&#39;
1869     @Test
1870     public void test72(Object[] o, boolean b, Object element) {
1871         Object[] arr1 = new Object[10];
1872         Object[] arr2 = new Object[10];
1873         if (b) {
1874             arr1 = o;
1875         }
1876         arr1[0] = element;
1877         arr2[0] = element;
1878     }
1879 
1880     @DontCompile
1881     public void test72_verifier(boolean warmup) {
1882         Object[] arr = new Object[1];
1883         Object elem = new Object();
1884         test72(arr, true, elem);
1885         test72(arr, false, elem);
1886     }
1887 
1888     @Test
1889     public void test73(Object[] oa, MyValue1.ref v, Object o) {
1890         // TestLWorld.test38 use a C1 Phi node for the array. This test
1891         // adds the case where the stored value is a C1 Phi node.
1892         Object o2 = (o == null) ? v : o;
1893         oa[0] = v;  // The stored value is known to be flattenable
1894         oa[1] = o;  // The stored value may be flattenable
1895         oa[2] = o2; // The stored value may be flattenable (a C1 Phi node)
1896         oa[0] = oa; // The stored value is known to be not flattenable (an Object[])
1897     }
1898 
1899     @DontCompile
1900     public void test73_verifier(boolean warmup) {
1901         MyValue1.ref v0 = MyValue1.createWithFieldsDontInline(rI, rL);
1902         MyValue1.ref v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);
1903         MyValue1.ref[] arr = new MyValue1.ref[3];
1904         try {
1905             test73(arr, v0, v1);
1906             throw new RuntimeException(&quot;ArrayStoreException expected&quot;);
1907         } catch (ArrayStoreException t) {
1908             // expected
1909         }
1910         Asserts.assertEQ(arr[0].hash(), v0.hash());
1911         Asserts.assertEQ(arr[1].hash(), v1.hash());
1912         Asserts.assertEQ(arr[2].hash(), v1.hash());
1913     }
1914 
1915     // Some more array clone tests
1916     @ForceInline
1917     public Object[] test74_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1918         Object[] arr = null;
1919         if (i == 10) {
1920             arr = oa;
1921         } else {
1922             arr = va;
1923         }
1924         return arr;
1925     }
1926 
1927     @Test
1928     public Object[] test74(MyValue1.ref[] va, Integer[] oa) {
1929         int i = 0;
1930         for (; i &lt; 10; i++);
1931 
1932         Object[] arr = test74_helper(i, va, oa);
1933         return arr.clone();
1934     }
1935 
1936     @DontCompile
1937     public void test74_verifier(boolean warmup) {
1938         int len = Math.abs(rI) % 10;
1939         MyValue1.ref[] va = new MyValue1.ref[len];
1940         Integer[] oa = new Integer[len];
1941         for (int i = 1; i &lt; len; ++i) {
1942             oa[i] = new Integer(rI);
1943         }
1944         test74_helper(42, va, oa);
1945         Object[] result = test74(va, oa);
1946 
1947         for (int i = 0; i &lt; va.length; ++i) {
1948             Asserts.assertEQ(oa[i], result[i]);
1949             // Check that array has correct properties (null-ok)
1950             result[i] = null;
1951         }
1952     }
1953 
1954     @ForceInline
1955     public Object[] test75_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1956         Object[] arr = null;
1957         if (i == 10) {
1958             arr = va;
1959         } else {
1960             arr = oa;
1961         }
1962         return arr;
1963     }
1964 
1965     @Test
1966     public Object[] test75(MyValue1.ref[] va, Integer[] oa) {
1967         int i = 0;
1968         for (; i &lt; 10; i++);
1969 
1970         Object[] arr = test75_helper(i, va, oa);
1971         return arr.clone();
1972     }
1973 
1974     @DontCompile
1975     public void test75_verifier(boolean warmup) {
1976         int len = Math.abs(rI) % 10;
1977         MyValue1.ref[] va = new MyValue1.ref[len];
1978         MyValue1.ref[] verif = new MyValue1.ref[len];
1979         for (int i = 1; i &lt; len; ++i) {
1980             va[i] = testValue1;
1981             verif[i] = va[i];
1982         }
1983         Integer[] oa = new Integer[len];
1984         test75_helper(42, va, oa);
1985         Object[] result = test75(va, oa);
1986         verify(verif, result);
1987         if (len &gt; 0) {
1988             // Check that array has correct properties (null-ok)
1989             result[0] = null;
1990         }
1991     }
1992 
1993     // Test mixing nullable and non-nullable arrays
1994     @Test
1995     public Object[] test76(MyValue1[] vva, MyValue1.ref[] vba, MyValue1 vt, Object[] out, int n) {
1996         Object[] result = null;
1997         if (n == 0) {
1998             result = vva;
1999         } else if (n == 1) {
2000             result = vba;
2001         } else if (n == 2) {
2002             result = new MyValue1[42];
2003         } else if (n == 3) {
2004             result = new MyValue1.ref[42];
2005         }
2006         result[0] = vt;
2007         out[0] = result[1];
2008         return result;
2009     }
2010 
2011     @DontCompile
2012     public void test76_verifier(boolean warmup) {
2013         MyValue1 vt = testValue1;
2014         Object[] out = new Object[1];
2015         MyValue1[] vva = new MyValue1[42];
2016         MyValue1[] vva_r = new MyValue1[42];
2017         vva_r[0] = vt;
2018         MyValue1.ref[] vba = new MyValue1.ref[42];
2019         MyValue1.ref[] vba_r = new MyValue1.ref[42];
2020         vba_r[0] = vt;
2021         Object[] result = test76(vva, vba, vt, out, 0);
2022         verify(result, vva_r);
2023         Asserts.assertEQ(out[0], vva_r[1]);
2024         result = test76(vva, vba, vt, out, 1);
2025         verify(result, vba_r);
2026         Asserts.assertEQ(out[0], vba_r[1]);
2027         result = test76(vva, vba, vt, out, 2);
2028         verify(result, vva_r);
2029         Asserts.assertEQ(out[0], vva_r[1]);
2030         result = test76(vva, vba, vt, out, 3);
2031         verify(result, vba_r);
2032         Asserts.assertEQ(out[0], vba_r[1]);
2033     }
2034 
2035     @Test
2036     public Object[] test77(boolean b) {
2037         Object[] va;
2038         if (b) {
2039             va = new MyValue1.ref[5];
2040             for (int i = 0; i &lt; 5; ++i) {
2041                 va[i] = testValue1;
2042             }
2043         } else {
2044             va = new MyValue1[10];
2045             for (int i = 0; i &lt; 10; ++i) {
2046                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
2047             }
2048         }
2049         long sum = ((MyValue1)va[0]).hashInterpreted();
2050         if (b) {
2051             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
2052         } else {
2053             va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);
2054         }
2055         return va;
2056     }
2057 
2058     @DontCompile
2059     public void test77_verifier(boolean warmup) {
2060         Object[] va = test77(true);
2061         Asserts.assertEQ(va.length, 5);
2062         Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI, hash()));
2063         for (int i = 1; i &lt; 5; ++i) {
2064             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash());
2065         }
2066         va = test77(false);
2067         Asserts.assertEQ(va.length, 10);
2068         Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI + 1, hash(rI, rL) + 1));
2069         for (int i = 1; i &lt; 10; ++i) {
2070             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash(rI + i, rL + i));
2071         }
2072     }
2073 
2074     // Same as test76 but with non inline type array cases
2075     @Test
2076     public Object[] test78(MyValue1[] vva, MyValue1.ref[] vba, Object val, Object[] out, int n) {
2077         Object[] result = null;
2078         if (n == 0) {
2079             result = vva;
2080         } else if (n == 1) {
2081             result = vba;
2082         } else if (n == 2) {
2083             result = new MyValue1[42];
2084         } else if (n == 3) {
2085             result = new MyValue1.ref[42];
2086         } else if (n == 4) {
2087             result = new Integer[42];
2088         }
2089         result[0] = val;
2090         out[0] = result[1];
2091         return result;
2092     }
2093 
2094     @DontCompile
2095     public void test78_verifier(boolean warmup) {
2096         MyValue1 vt = testValue1;
2097         Integer i = new Integer(42);
2098         Object[] out = new Object[1];
2099         MyValue1[] vva = new MyValue1[42];
2100         MyValue1[] vva_r = new MyValue1[42];
2101         vva_r[0] = vt;
2102         MyValue1.ref[] vba = new MyValue1.ref[42];
2103         MyValue1.ref[] vba_r = new MyValue1.ref[42];
2104         vba_r[0] = vt;
2105         Object[] result = test78(vva, vba, vt, out, 0);
2106         verify(result, vva_r);
2107         Asserts.assertEQ(out[0], vva_r[1]);
2108         result = test78(vva, vba, vt, out, 1);
2109         verify(result, vba_r);
2110         Asserts.assertEQ(out[0], vba_r[1]);
2111         result = test78(vva, vba, vt, out, 2);
2112         verify(result, vva_r);
2113         Asserts.assertEQ(out[0], vva_r[1]);
2114         result = test78(vva, vba, vt, out, 3);
2115         verify(result, vba_r);
2116         Asserts.assertEQ(out[0], vba_r[1]);
2117         result = test78(vva, vba, i, out, 4);
2118         Asserts.assertEQ(result[0], i);
2119         Asserts.assertEQ(out[0], null);
2120     }
2121 
2122     // Test widening conversions from [Q to [L
2123     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2124     public static MyValue1.ref[] test79(MyValue1[] va) {
2125         return va;
2126     }
2127 
2128     @DontCompile
2129     public void test79_verifier(boolean warmup) {
2130         MyValue1[] va = new MyValue1[1];
2131         va[0] = testValue1;
2132         MyValue1.ref[] res = test79(va);
2133         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2134         try {
2135             res[0] = null;
2136             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2137         } catch (NullPointerException npe) {
2138             // Expected
2139         }
2140         res[0] = testValue1;
2141         test79(null); // Should not throw NPE
2142     }
2143 
2144     // Same as test79 but with explicit cast and Object return
2145     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2146     public static Object[] test80(MyValue1[] va) {
2147         return (MyValue1.ref[])va;
2148     }
2149 
2150     @DontCompile
2151     public void test80_verifier(boolean warmup) {
2152         MyValue1[] va = new MyValue1[1];
2153         va[0] = testValue1;
2154         Object[] res = test80(va);
2155         Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());
2156         try {
2157             res[0] = null;
2158             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2159         } catch (NullPointerException npe) {
2160             // Expected
2161         }
2162         res[0] = testValue1;
2163         test80(null); // Should not throw NPE
2164     }
2165 
2166     // Test mixing widened and boxed array type
2167     @Test()
2168     public static long test81(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt, boolean b, boolean shouldThrow) {
2169         MyValue1.ref[] result = b ? va1 : va2;
2170         try {
2171             result[0] = vt;
2172         } catch (NullPointerException npe) {
2173             // Ignored
2174         }
2175         return result[1].hash();
2176     }
2177 
2178     @DontCompile
2179     public void test81_verifier(boolean warmup) {
2180         MyValue1[] va = new MyValue1[2];
2181         MyValue1.ref[] vaB = new MyValue1.ref[2];
2182         va[1] = testValue1;
2183         vaB[1] = testValue1;
2184         long res = test81(va, vaB, testValue1, true, true);
2185         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2186         Asserts.assertEquals(res, testValue1.hash());
2187         res = test81(va, vaB, testValue1, false, false);
2188         Asserts.assertEquals(vaB[0].hash(), testValue1.hash());
2189         Asserts.assertEquals(res, testValue1.hash());
2190         res = test81(va, va, testValue1, false, true);
2191         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2192         Asserts.assertEquals(res, testValue1.hash());
2193     }
2194 
2195     // Same as test81 but more cases and null writes
2196     @Test()
2197     public static long test82(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt1, MyValue1.ref vt2, int i, boolean shouldThrow) {
2198         MyValue1.ref[] result = null;
2199         if (i == 0) {
2200             result = va1;
2201         } else if (i == 1) {
2202             result = va2;
2203         } else if (i == 2) {
2204             result = new MyValue1.ref[2];
2205             result[1] = vt1;
2206         } else if (i == 3) {
2207             result = new MyValue1[2];
2208             result[1] = vt1;
2209         }
2210         try {
2211             result[0] = (i &lt;= 1) ? null : vt2;
2212             if (shouldThrow) {
2213                 throw new RuntimeException(&quot;NullPointerException expected&quot;);
2214             }
2215         } catch (NullPointerException npe) {
2216             Asserts.assertTrue(shouldThrow, &quot;NullPointerException thrown&quot;);
2217         }
2218         result[0] = vt1;
2219         return result[1].hash();
2220     }
2221 
2222     @DontCompile
2223     public void test82_verifier(boolean warmup) {
2224         MyValue1[] va = new MyValue1[2];
2225         MyValue1.ref[] vaB = new MyValue1.ref[2];
2226         va[1] = testValue1;
2227         vaB[1] = testValue1;
2228         long res = test82(va, vaB, testValue1, testValue1, 0, true);
2229         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2230         Asserts.assertEquals(res, testValue1.hash());
2231         res = test82(va, vaB, testValue1, testValue1, 1, false);
2232         Asserts.assertEquals(vaB[0].hash(), testValue1.hash());
2233         Asserts.assertEquals(res, testValue1.hash());
2234         res = test82(va, va, testValue1, testValue1, 1, true);
2235         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2236         Asserts.assertEquals(res, testValue1.hash());
2237         res = test82(va, va, testValue1, null, 2, false);
2238         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2239         Asserts.assertEquals(res, testValue1.hash());
2240         res = test82(va, va, testValue1, null, 3, true);
2241         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2242         Asserts.assertEquals(res, testValue1.hash());
2243     }
2244 
2245     @Test(failOn = ALLOC + ALLOCA + STORE)
2246     public static long test83(MyValue1[] va) {
2247         MyValue1.ref[] result = va;
2248         return result[0].hash();
2249     }
2250 
2251     @DontCompile
2252     public void test83_verifier(boolean warmup) {
2253         MyValue1[] va = new MyValue1[42];
2254         va[0] = testValue1;
2255         long res = test83(va);
2256         Asserts.assertEquals(res, testValue1.hash());
2257     }
2258 
2259     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + LOOP + STORE + TRAP)
2260     @Test(valid = InlineTypeArrayFlattenOff)
2261     public static MyValue1.ref[] test84(MyValue1 vt1, MyValue1.ref vt2) {
2262         MyValue1.ref[] result = new MyValue1[2];
2263         result[0] = vt1;
2264         result[1] = vt2;
2265         return result;
2266     }
2267 
2268     @DontCompile
2269     public void test84_verifier(boolean warmup) {
2270         MyValue1.ref[] res = test84(testValue1, testValue1);
2271         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2272         Asserts.assertEquals(res[1].hash(), testValue1.hash());
2273         try {
2274             test84(testValue1, null);
2275             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2276         } catch (NullPointerException npe) {
2277             // Expected
2278         }
2279     }
2280 
2281     @Test()
2282     public static long test85(MyValue1.ref[] va, MyValue1 val) {
2283         va[0] = val;
2284         return va[1].hash();
2285     }
2286 
2287     @DontCompile
2288     public void test85_verifier(boolean warmup) {
2289         MyValue1[] va = new MyValue1[2];
2290         MyValue1.ref[] vab = new MyValue1.ref[2];
2291         va[1] = testValue1;
2292         vab[1] = testValue1;
2293         long res = test85(va, testValue1);
2294         Asserts.assertEquals(res, testValue1.hash());
2295         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2296         res = test85(vab, testValue1);
2297         Asserts.assertEquals(res, testValue1.hash());
2298         Asserts.assertEquals(vab[0].hash(), testValue1.hash());
2299     }
2300 
2301     // Same as test85 but with ref value
2302     @Test()
2303     public static long test86(MyValue1.ref[] va, MyValue1.ref val) {
2304         va[0] = val;
2305         return va[1].hash();
2306     }
2307 
2308     @DontCompile
2309     public void test86_verifier(boolean warmup) {
2310         MyValue1[] va = new MyValue1[2];
2311         MyValue1.ref[] vab = new MyValue1.ref[2];
2312         va[1] = testValue1;
2313         vab[1] = testValue1;
2314         long res = test86(va, testValue1);
2315         Asserts.assertEquals(res, testValue1.hash());
2316         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2317         try {
2318             test86(va, null);
2319             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2320         } catch (NullPointerException npe) {
2321             // Expected
2322         }
2323         res = test86(vab, testValue1);
2324         Asserts.assertEquals(res, testValue1.hash());
2325         Asserts.assertEquals(vab[0].hash(), testValue1.hash());
2326         res = test86(vab, null);
2327         Asserts.assertEquals(res, testValue1.hash());
2328         Asserts.assertEquals(vab[0], null);
2329     }
2330 
2331     // Test initialization of nullable array with constant
2332     @Test()
2333     public long test87() {
2334         MyValue1.ref[] va = new MyValue1.ref[1];
2335         va[0] = testValue1;
2336         return va[0].hash();
2337     }
2338 
2339     @DontCompile
2340     public void test87_verifier(boolean warmup) {
2341         long result = test87();
2342         Asserts.assertEQ(result, hash());
2343     }
2344 
2345     // Test narrowing conversion from [L to [Q
2346     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2347     public static MyValue1[] test88(MyValue1.ref[] va) {
2348         return (MyValue1[])va;
2349     }
2350 
2351     @DontCompile
2352     public void test88_verifier(boolean warmup) {
2353         MyValue1[] va = new MyValue1[1];
2354         va[0] = testValue1;
2355         MyValue1[] res = test88(va);
2356         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2357         res[0] = testValue1;
2358         test88(null); // Should not throw NPE
2359         try {
2360             test88(new MyValue1.ref[1]);
2361             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2362         } catch (ClassCastException cce) {
2363             // Expected
2364         }
2365     }
2366 
2367     // Same as test88 but with explicit cast and Object argument
2368     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2369     public static MyValue1[] test89(Object[] va) {
2370         return (MyValue1[])va;
2371     }
2372 
2373     @DontCompile
2374     public void test89_verifier(boolean warmup) {
2375         MyValue1[] va = new MyValue1[1];
2376         va[0] = testValue1;
2377         MyValue1[] res = test89(va);
2378         Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());
2379         res[0] = testValue1;
2380         test89(null); // Should not throw NPE
2381         try {
2382             test89(new MyValue1.ref[1]);
2383             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2384         } catch (ClassCastException cce) {
2385             // Expected
2386         }
2387     }
2388 
2389     // More cast tests
2390     @Test()
2391     public static MyValue1.ref[] test90(Object va) {
2392         return (MyValue1.ref[])va;
2393     }
2394 
2395     @DontCompile
2396     public void test90_verifier(boolean warmup) {
2397         MyValue1[] va = new MyValue1[1];
2398         MyValue1.ref[] vab = new MyValue1.ref[1];
2399         try {
2400           // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
2401           test90(new Integer[0]);
2402         } catch (ClassCastException cce) {
2403           // Expected
2404         }
2405         test90(va);
2406         test90(vab);
2407         test90(null);
2408     }
2409 
2410     @Test()
2411     public static MyValue1.ref[] test91(Object[] va) {
2412         return (MyValue1.ref[])va;
2413     }
2414 
2415     @DontCompile
2416     public void test91_verifier(boolean warmup) {
2417         MyValue1[] va = new MyValue1[1];
2418         MyValue1.ref[] vab = new MyValue1.ref[1];
2419         try {
2420           // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
2421           test91(new Integer[0]);
2422         } catch (ClassCastException cce) {
2423           // Expected
2424         }
2425         test91(va);
2426         test91(vab);
2427         test91(null);
2428     }
2429 
2430     // Test if arraycopy intrinsic correctly checks for flattened source array
2431     @Test()
2432     public static void test92(MyValue1.ref[] src, MyValue1.ref[] dst) {
2433         System.arraycopy(src, 0, dst, 0, 2);
2434     }
2435 
2436     @DontCompile
2437     public void test92_verifier(boolean warmup) {
2438         MyValue1[]  va = new MyValue1[2];
2439         MyValue1.ref[] vab = new MyValue1.ref[2];
2440         va[0] = testValue1;
2441         vab[0] = testValue1;
2442         test92(va, vab);
2443         Asserts.assertEquals(va[0], vab[0]);
2444         Asserts.assertEquals(va[1], vab[1]);
2445     }
2446 
2447     @Test()
2448     public static void test93(Object src, MyValue1.ref[] dst) {
2449         System.arraycopy(src, 0, dst, 0, 2);
2450     }
2451 
2452     @DontCompile
2453     public void test93_verifier(boolean warmup) {
2454         MyValue1[]  va = new MyValue1[2];
2455         MyValue1.ref[] vab = new MyValue1.ref[2];
2456         va[0] = testValue1;
2457         vab[0] = testValue1;
2458         test93(va, vab);
2459         Asserts.assertEquals(va[0], vab[0]);
2460         Asserts.assertEquals(va[1], vab[1]);
2461     }
2462 
2463     // Test non-escaping allocation with arraycopy
2464     // that does not modify loaded array element.
2465     @Test()
2466     public static long test94() {
2467         MyValue1.ref[] src = new MyValue1.ref[8];
2468         MyValue1[]  dst = new MyValue1[8];
2469         for (int i = 1; i &lt; 8; ++i) {
2470             src[i] = testValue1;
2471         }
2472         System.arraycopy(src, 1, dst, 2, 6);
2473         return dst[0].hash();
2474     }
2475 
2476     @DontCompile
2477     public static void test94_verifier(boolean warmup) {
2478         long result = test94();
2479         Asserts.assertEquals(result, MyValue1.default.hash());
2480     }
2481 
2482     // Test meeting constant TypeInstPtr with InlineTypeNode
2483     @ForceInline
2484     public long test95_callee() {
2485         MyValue1.ref[] va = new MyValue1.ref[1];
2486         va[0] = testValue1;
2487         return va[0].hashInterpreted();
2488     }
2489 
2490     @Test()
2491     @Warmup(0)
2492     public long test95() {
2493         return test95_callee();
2494     }
2495 
2496     @DontCompile
2497     public void test95_verifier(boolean warmup) {
2498         long result = test95();
2499         Asserts.assertEQ(result, hash());
2500     }
2501 
2502     // Matrix multiplication test to exercise type flow analysis with nullable inline type arrays
2503     inline static class Complex {
2504         private final double re;
2505         private final double im;
2506 
2507         Complex(double re, double im) {
2508             this.re = re;
2509             this.im = im;
2510         }
2511 
2512         public Complex add(Complex that) {
2513             return new Complex(this.re + that.re, this.im + that.im);
2514         }
2515 
2516         public Complex mul(Complex that) {
2517             return new Complex(this.re * that.re - this.im * that.im,
2518                                this.re * that.im + this.im * that.re);
2519         }
2520     }
2521 
2522     @Test()
2523     public Complex.ref[][] test96(Complex.ref[][] A, Complex.ref[][] B) {
2524         int size = A.length;
2525         Complex.ref[][] R = new Complex.ref[size][size];
2526         for (int i = 0; i &lt; size; i++) {
2527             for (int k = 0; k &lt; size; k++) {
2528                 Complex.ref aik = A[i][k];
2529                 for (int j = 0; j &lt; size; j++) {
2530                     R[i][j] = B[i][j].add(aik.mul((Complex)B[k][j]));
2531                 }
2532             }
2533         }
2534         return R;
2535     }
2536 
2537     static Complex.ref[][] test96_A = new Complex.ref[10][10];
2538     static Complex.ref[][] test96_B = new Complex.ref[10][10];
2539     static Complex.ref[][] test96_R;
2540 
2541     static {
2542         for (int i = 0; i &lt; 10; i++) {
2543             for (int j = 0; j &lt; 10; j++) {
2544                 test96_A[i][j] = new Complex(rI, rI);
2545                 test96_B[i][j] = new Complex(rI, rI);
2546             }
2547         }
2548     }
2549 
2550     @DontCompile
2551     public void test96_verifier(boolean warmup) {
2552         Complex.ref[][] result = test96(test96_A, test96_B);
2553         if (test96_R == null) {
2554             test96_R = result;
2555         }
2556         for (int i = 0; i &lt; 10; i++) {
2557             for (int j = 0; j &lt; 10; j++) {
2558                 Asserts.assertEQ(result[i][j], test96_R[i][j]);
2559             }
2560         }
2561     }
2562 
2563     // Test loads from vararg arrays
2564     @Test(failOn = LOAD_UNKNOWN_INLINE)
2565     public static Object test97(Object... args) {
2566         return args[0];
2567     }
2568 
2569     @DontCompile
2570     public static void test97_verifier(boolean warmup) {
2571         Object obj = new Object();
2572         Object result = test97(obj);
2573         Asserts.assertEquals(result, obj);
2574         Integer[] myInt = new Integer[1];
2575         myInt[0] = rI;
2576         result = test97((Object[])myInt);
2577         Asserts.assertEquals(result, rI);
2578     }
2579 
2580     @Test()
2581     public static Object test98(Object... args) {
2582         return args[0];
2583     }
2584 
2585     @DontCompile
2586     public static void test98_verifier(boolean warmup) {
2587         Object obj = new Object();
2588         Object result = test98(obj);
2589         Asserts.assertEquals(result, obj);
2590         Integer[] myInt = new Integer[1];
2591         myInt[0] = rI;
2592         result = test98((Object[])myInt);
2593         Asserts.assertEquals(result, rI);
2594         if (!warmup) {
2595             MyValue1[] va = new MyValue1[1];
2596             MyValue1.ref[] vab = new MyValue1.ref[1];
2597             result = test98((Object[])va);
2598             Asserts.assertEquals(((MyValue1)result).hash(), MyValue1.default.hash());
2599             result = test98((Object[])vab);
2600             Asserts.assertEquals(result, null);
2601         }
2602     }
2603 
2604     @Test()
2605     public static Object test99(Object... args) {
2606         return args[0];
2607     }
2608 
2609     @DontCompile
2610     public static void test99_verifier(boolean warmup) {
2611         Object obj = new Object();
2612         Object result = test99(obj);
2613         Asserts.assertEquals(result, obj);
2614         Integer[] myInt = new Integer[1];
2615         myInt[0] = rI;
2616         result = test99((Object[])myInt);
2617         Asserts.assertEquals(result, rI);
2618         if (!warmup) {
2619             try {
2620                 test99((Object[])null);
2621                 throw new RuntimeException(&quot;No NPE thrown&quot;);
2622             } catch (NullPointerException npe) {
2623                 // Expected
2624             }
2625         }
2626     }
2627 
2628     @Test()
2629     public static Object test100(Object... args) {
2630         return args[0];
2631     }
2632 
2633     @DontCompile
2634     public static void test100_verifier(boolean warmup) {
2635         Object obj = new Object();
2636         Object result = test100(obj);
2637         Asserts.assertEquals(result, obj);
2638         Integer[] myInt = new Integer[1];
2639         myInt[0] = rI;
2640         result = test100((Object[])myInt);
2641         Asserts.assertEquals(result, rI);
2642         if (!warmup) {
2643             try {
2644                 test100();
2645                 throw new RuntimeException(&quot;No AIOOBE thrown&quot;);
2646             } catch (ArrayIndexOutOfBoundsException aioobe) {
2647                 // Expected
2648             }
2649         }
2650     }
2651 
2652     // Test stores to varag arrays
2653     @Test(failOn = STORE_UNKNOWN_INLINE)
2654     public static void test101(Object val, Object... args) {
2655         args[0] = val;
2656     }
2657 
2658     @DontCompile
2659     public static void test101_verifier(boolean warmup) {
2660         Object obj = new Object();
2661         test101(obj, obj);
2662         Integer[] myInt = new Integer[1];
2663         test101(rI, (Object[])myInt);
2664         Asserts.assertEquals(myInt[0], rI);
2665         test101(null, (Object[])myInt);
2666         Asserts.assertEquals(myInt[0], null);
2667     }
2668 
2669     @Test()
2670     public static void test102(Object val, Object... args) {
2671         args[0] = val;
2672     }
2673 
2674     @DontCompile
2675     public static void test102_verifier(boolean warmup) {
2676         Object obj = new Object();
2677         test102(obj, obj);
2678         Integer[] myInt = new Integer[1];
2679         test102(rI, (Object[])myInt);
2680         Asserts.assertEquals(myInt[0], rI);
2681         test102(null, (Object[])myInt);
2682         Asserts.assertEquals(myInt[0], null);
2683         if (!warmup) {
2684             MyValue1[] va = new MyValue1[1];
2685             MyValue1.ref[] vab = new MyValue1.ref[1];
2686             test102(testValue1, (Object[])va);
2687             Asserts.assertEquals(va[0].hash(), testValue1.hash());
2688             test102(testValue1, (Object[])vab);
2689             Asserts.assertEquals(vab[0].hash(), testValue1.hash());
2690             test102(null, (Object[])vab);
2691             Asserts.assertEquals(vab[0], null);
2692         }
2693     }
2694 
2695     @Test()
2696     public static void test103(Object val, Object... args) {
2697         args[0] = val;
2698     }
2699 
2700     @DontCompile
2701     public static void test103_verifier(boolean warmup) {
2702         Object obj = new Object();
2703         test103(obj, obj);
2704         Integer[] myInt = new Integer[1];
2705         test103(rI, (Object[])myInt);
2706         Asserts.assertEquals(myInt[0], rI);
2707         test103(null, (Object[])myInt);
2708         Asserts.assertEquals(myInt[0], null);
2709         if (!warmup) {
2710             MyValue1[] va = new MyValue1[1];
2711             try {
2712                 test103(null, (Object[])va);
2713                 throw new RuntimeException(&quot;No NPE thrown&quot;);
2714             } catch (NullPointerException npe) {
2715                 // Expected
2716             }
2717         }
2718     }
2719 
2720     @Test()
2721     public static void test104(Object val, Object... args) {
2722         args[0] = val;
2723     }
2724 
2725     @DontCompile
2726     public static void test104_verifier(boolean warmup) {
2727         Object obj = new Object();
2728         test104(obj, obj);
2729         Integer[] myInt = new Integer[1];
2730         test104(rI, (Object[])myInt);
2731         Asserts.assertEquals(myInt[0], rI);
2732         test104(null, (Object[])myInt);
2733         Asserts.assertEquals(myInt[0], null);
2734         if (!warmup) {
2735             try {
2736                 test104(testValue1);
2737                 throw new RuntimeException(&quot;No AIOOBE thrown&quot;);
2738             } catch (ArrayIndexOutOfBoundsException aioobe) {
2739                 // Expected
2740             }
2741         }
2742     }
2743 
2744     @Test()
2745     public static void test105(Object val, Object... args) {
2746         args[0] = val;
2747     }
2748 
2749     @DontCompile
2750     public static void test105_verifier(boolean warmup) {
2751         Object obj = new Object();
2752         test105(obj, obj);
2753         Integer[] myInt = new Integer[1];
2754         test105(rI, (Object[])myInt);
2755         Asserts.assertEquals(myInt[0], rI);
2756         test105(null, (Object[])myInt);
2757         Asserts.assertEquals(myInt[0], null);
2758         if (!warmup) {
2759             try {
2760                 test105(testValue1, (Object[])null);
2761                 throw new RuntimeException(&quot;No NPE thrown&quot;);
2762             } catch (NullPointerException npe) {
2763                 // Expected
2764             }
2765         }
2766     }
2767 
2768     @Test()
2769     public static Object[] test106(Object[] dst, Object... args) {
2770         // Access array to speculate on non-flatness
2771         if (args[0] == null) {
2772             args[0] = testValue1;
2773         }
2774         System.arraycopy(args, 0, dst, 0, args.length);
2775         System.arraycopy(dst, 0, args, 0, dst.length);
2776         Object[] clone = args.clone();
2777         if (clone[0] == null) {
2778             throw new RuntimeException(&quot;Unexpected null&quot;);
2779         }
2780         return Arrays.copyOf(args, args.length, Object[].class);
2781     }
2782 
2783     @DontCompile
2784     public static void test106_verifier(boolean warmup) {
2785         Object[] dst = new Object[1];
2786         Object obj = new Object();
2787         Object[] result = test106(dst, obj);
2788         Asserts.assertEquals(result[0], obj);
2789         Integer[] myInt = new Integer[1];
2790         myInt[0] = rI;
2791         result = test106(myInt, (Object[])myInt);
2792         Asserts.assertEquals(result[0], rI);
2793         if (!warmup) {
2794             MyValue1[] va = new MyValue1[1];
2795             MyValue1.ref[] vab = new MyValue1.ref[1];
2796             result = test106(va, (Object[])va);
2797             Asserts.assertEquals(((MyValue1)result[0]).hash(), MyValue1.default.hash());
2798             result = test106(vab, (Object[])vab);
2799             Asserts.assertEquals(((MyValue1)result[0]).hash(), testValue1.hash());
2800         }
2801     }
2802 
2803     // Test that allocation is not replaced by non-dominating allocation
2804     public long test107_helper(MyValue1.ref[] va, MyValue1 vt) {
2805         try {
2806             va[0] = vt;
2807         } catch (NullPointerException npe) { }
2808         return va[1].hash();
2809     }
2810 
2811     @Test()
2812     public void test107() {
2813         MyValue1[] va = new MyValue1[2];
2814         MyValue1.ref[] tmp = new MyValue1.ref[2];
2815         long res1 = test107_helper(va, testValue1);
2816         long res2 = test107_helper(va, testValue1);
2817         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2818         Asserts.assertEquals(res1, MyValue1.default.hash());
2819         Asserts.assertEquals(res2, MyValue1.default.hash());
2820     }
2821 
2822     @DontCompile
2823     public void test107_verifier(boolean warmup) {
2824         test107();
2825     }
2826 
2827     @Test
2828     @Warmup(10000)
2829     public Object test108(MyValue1.ref[] src, boolean flag) {
2830         MyValue1.ref[] dst = new MyValue1.ref[8];
2831         System.arraycopy(src, 1, dst, 2, 6);
2832         if (flag) {} // uncommon trap
2833         return dst[2];
2834     }
2835 
2836     @DontCompile
2837     public void test108_verifier(boolean warmup) {
2838         MyValue1.ref[] src = new MyValue1.ref[8];
2839         test108(src, !warmup);
2840     }
2841 
2842     // Test LoadNode::can_see_arraycopy_value optimization
2843     @Test()
2844     public static void test109() {
2845         MyValue1[] src = new MyValue1[1];
2846         MyValue1.ref[] dst = new MyValue1.ref[1];
2847         src[0] = testValue1;
2848         System.arraycopy(src, 0, dst, 0, 1);
2849         Asserts.assertEquals(src[0], dst[0]);
2850     }
2851 
2852     @DontCompile
2853     public void test109_verifier(boolean warmup) {
2854         test109();
2855     }
2856 
2857     // Same as test109 but with Object destination array
2858     @Test()
2859     public static void test110() {
2860         MyValue1[] src = new MyValue1[1];
2861         Object[] dst = new Object[1];
2862         src[0] = testValue1;
2863         System.arraycopy(src, 0, dst, 0, 1);
2864         Asserts.assertEquals(src[0], dst[0]);
2865     }
2866 
2867     @DontCompile
2868     public void test110_verifier(boolean warmup) {
2869         test110();
2870     }
2871 
2872     // Same as test109 but with Arrays.copyOf
2873     @Test()
2874     public static void test111() {
2875         MyValue1[] src = new MyValue1[1];
2876         src[0] = testValue1;
2877         MyValue1.ref[] dst = Arrays.copyOf(src, src.length, MyValue1.ref[].class);
2878         Asserts.assertEquals(src[0], dst[0]);
2879     }
2880 
2881     @DontCompile
2882     public void test111_verifier(boolean warmup) {
2883         test111();
2884     }
2885 }
    </pre>
  </body>
</html>