<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/c1/c1_Instruction.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_IR.hpp&quot;
  27 #include &quot;c1/c1_Instruction.hpp&quot;
  28 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciFlatArrayKlass.hpp&quot;
  31 #include &quot;ci/ciInlineKlass.hpp&quot;
  32 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  33 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  34 #include &quot;utilities/bitMap.inline.hpp&quot;
  35 
  36 
  37 // Implementation of Instruction
  38 
  39 
  40 int Instruction::dominator_depth() {
  41   int result = -1;
  42   if (block()) {
  43     result = block()-&gt;dominator_depth();
  44   }
  45   assert(result != -1 || this-&gt;as_Local(), &quot;Only locals have dominator depth -1&quot;);
  46   return result;
  47 }
  48 
  49 Instruction::Condition Instruction::mirror(Condition cond) {
  50   switch (cond) {
  51     case eql: return eql;
  52     case neq: return neq;
  53     case lss: return gtr;
  54     case leq: return geq;
  55     case gtr: return lss;
  56     case geq: return leq;
  57     case aeq: return beq;
  58     case beq: return aeq;
  59   }
  60   ShouldNotReachHere();
  61   return eql;
  62 }
  63 
  64 
  65 Instruction::Condition Instruction::negate(Condition cond) {
  66   switch (cond) {
  67     case eql: return neq;
  68     case neq: return eql;
  69     case lss: return geq;
  70     case leq: return gtr;
  71     case gtr: return leq;
  72     case geq: return lss;
  73     case aeq: assert(false, &quot;Above equal cannot be negated&quot;);
  74     case beq: assert(false, &quot;Below equal cannot be negated&quot;);
  75   }
  76   ShouldNotReachHere();
  77   return eql;
  78 }
  79 
  80 void Instruction::update_exception_state(ValueStack* state) {
  81   if (state != NULL &amp;&amp; (state-&gt;kind() == ValueStack::EmptyExceptionState || state-&gt;kind() == ValueStack::ExceptionState)) {
  82     assert(state-&gt;kind() == ValueStack::EmptyExceptionState || Compilation::current()-&gt;env()-&gt;should_retain_local_variables(), &quot;unexpected state kind&quot;);
  83     _exception_state = state;
  84   } else {
  85     _exception_state = NULL;
  86   }
  87 }
  88 
  89 // Prev without need to have BlockBegin
  90 Instruction* Instruction::prev() {
  91   Instruction* p = NULL;
  92   Instruction* q = block();
  93   while (q != this) {
  94     assert(q != NULL, &quot;this is not in the block&#39;s instruction list&quot;);
  95     p = q; q = q-&gt;next();
  96   }
  97   return p;
  98 }
  99 
 100 
 101 void Instruction::state_values_do(ValueVisitor* f) {
 102   if (state_before() != NULL) {
 103     state_before()-&gt;values_do(f);
 104   }
 105   if (exception_state() != NULL){
 106     exception_state()-&gt;values_do(f);
 107   }
 108 }
 109 
 110 ciType* Instruction::exact_type() const {
 111   ciType* t =  declared_type();
 112   if (t != NULL &amp;&amp; t-&gt;is_klass()) {
 113     return t-&gt;as_klass()-&gt;exact_klass();
 114   }
 115   return NULL;
 116 }
 117 
 118 ciKlass* Instruction::as_loaded_klass_or_null() const {
 119   ciType* type = declared_type();
 120   if (type != NULL &amp;&amp; type-&gt;is_klass()) {
 121     ciKlass* klass = type-&gt;as_klass();
 122     if (klass-&gt;is_loaded()) {
 123       return klass;
 124     }
 125   }
 126   return NULL;
 127 }
 128 
 129 bool Instruction::is_loaded_flattened_array() const {
 130   if (UseFlatArray) {
 131     ciType* type = declared_type();
 132     return type != NULL &amp;&amp; type-&gt;is_flat_array_klass();
 133   }
 134   return false;
 135 }
 136 
 137 bool Instruction::maybe_flattened_array() {
 138   if (UseFlatArray) {
 139     ciType* type = declared_type();
 140     if (type != NULL) {
 141       if (type-&gt;is_obj_array_klass()) {
 142         // Due to array covariance, the runtime type might be a flattened array.
 143         ciKlass* element_klass = type-&gt;as_obj_array_klass()-&gt;element_klass();
 144         if (element_klass-&gt;can_be_inline_klass() &amp;&amp; (!element_klass-&gt;is_inlinetype() || element_klass-&gt;as_inline_klass()-&gt;flatten_array())) {
 145           return true;
 146         }
 147       } else if (type-&gt;is_flat_array_klass()) {
 148         ciKlass* element_klass = type-&gt;as_flat_array_klass()-&gt;element_klass();
 149         assert(!element_klass-&gt;is_loaded() || element_klass-&gt;flatten_array(), &quot;must be flattened&quot;);
 150         return true;
 151       } else if (type-&gt;is_klass() &amp;&amp; type-&gt;as_klass()-&gt;is_java_lang_Object()) {
 152         // This can happen as a parameter to System.arraycopy()
 153         return true;
 154       }
 155     } else {
 156       // Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a
 157       // flattened array, so we should do a runtime check.
 158       return true;
 159     }
 160   }
 161   return false;
 162 }
 163 
 164 bool Instruction::maybe_null_free_array() {
 165   ciType* type = declared_type();
 166   if (type != NULL) {
 167     if (type-&gt;is_obj_array_klass()) {
 168       // Due to array covariance, the runtime type might be a null-free array.
 169       ciKlass* element_klass = type-&gt;as_obj_array_klass()-&gt;element_klass();
 170       if (element_klass-&gt;can_be_inline_klass()) {
 171         return true;
 172       }
 173     }
 174   } else {
 175     // Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a
 176     // null-free array, so we should do a runtime check.
 177     return true;
 178   }
 179   return false;
 180 }
 181 
 182 #ifndef PRODUCT
 183 void Instruction::check_state(ValueStack* state) {
 184   if (state != NULL) {
 185     state-&gt;verify();
 186   }
 187 }
 188 
 189 
 190 void Instruction::print() {
 191   InstructionPrinter ip;
 192   print(ip);
 193 }
 194 
 195 
 196 void Instruction::print_line() {
 197   InstructionPrinter ip;
 198   ip.print_line(this);
 199 }
 200 
 201 
 202 void Instruction::print(InstructionPrinter&amp; ip) {
 203   ip.print_head();
 204   ip.print_line(this);
 205   tty-&gt;cr();
 206 }
 207 #endif // PRODUCT
 208 
 209 
 210 // perform constant and interval tests on index value
 211 bool AccessIndexed::compute_needs_range_check() {
 212   if (length()) {
 213     Constant* clength = length()-&gt;as_Constant();
 214     Constant* cindex = index()-&gt;as_Constant();
 215     if (clength &amp;&amp; cindex) {
 216       IntConstant* l = clength-&gt;type()-&gt;as_IntConstant();
 217       IntConstant* i = cindex-&gt;type()-&gt;as_IntConstant();
 218       if (l &amp;&amp; i &amp;&amp; i-&gt;value() &lt; l-&gt;value() &amp;&amp; i-&gt;value() &gt;= 0) {
 219         return false;
 220       }
 221     }
 222   }
 223 
 224   if (!this-&gt;check_flag(NeedsRangeCheckFlag)) {
 225     return false;
 226   }
 227 
 228   return true;
 229 }
 230 
 231 
 232 ciType* Constant::exact_type() const {
 233   if (type()-&gt;is_object() &amp;&amp; type()-&gt;as_ObjectType()-&gt;is_loaded()) {
 234     return type()-&gt;as_ObjectType()-&gt;exact_type();
 235   }
 236   return NULL;
 237 }
 238 
 239 ciType* LoadIndexed::exact_type() const {
 240   ciType* array_type = array()-&gt;exact_type();
 241   if (array_type != NULL) {
 242     assert(array_type-&gt;is_array_klass(), &quot;what else?&quot;);
 243     ciArrayKlass* ak = (ciArrayKlass*)array_type;
 244 
 245     if (ak-&gt;element_type()-&gt;is_instance_klass()) {
 246       ciInstanceKlass* ik = (ciInstanceKlass*)ak-&gt;element_type();
 247       if (ik-&gt;is_loaded() &amp;&amp; ik-&gt;is_final()) {
 248         return ik;
 249       }
 250     }
 251   }
 252   return Instruction::exact_type();
 253 }
 254 
 255 
 256 ciType* LoadIndexed::declared_type() const {
 257   ciType* array_type = array()-&gt;declared_type();
 258   if (array_type == NULL || !array_type-&gt;is_loaded()) {
 259     return NULL;
 260   }
 261   assert(array_type-&gt;is_array_klass(), &quot;what else?&quot;);
 262   ciArrayKlass* ak = (ciArrayKlass*)array_type;
 263   return ak-&gt;element_type();
 264 }
 265 
 266 bool StoreIndexed::is_exact_flattened_array_store() const {
 267   if (array()-&gt;is_loaded_flattened_array() &amp;&amp; value()-&gt;as_Constant() == NULL &amp;&amp; value()-&gt;declared_type() != NULL) {
 268     ciKlass* element_klass = array()-&gt;declared_type()-&gt;as_flat_array_klass()-&gt;element_klass();
 269     ciKlass* actual_klass = value()-&gt;declared_type()-&gt;as_klass();
 270 
 271     // The following check can fail with inlining:
 272     //     void test45_inline(Object[] oa, Object o, int index) { oa[index] = o; }
 273     //     void test45(MyValue1[] va, int index, MyValue2 v) { test45_inline(va, v, index); }
 274     if (element_klass == actual_klass) {
 275       return true;
 276     }
 277   }
 278   return false;
 279 }
 280 
 281 ciType* LoadField::declared_type() const {
 282   return field()-&gt;type();
 283 }
 284 
 285 
 286 ciType* NewTypeArray::exact_type() const {
 287   return ciTypeArrayKlass::make(elt_type());
 288 }
 289 
 290 ciType* NewObjectArray::exact_type() const {
 291   return ciArrayKlass::make(klass());
 292 }
 293 
 294 ciType* NewMultiArray::exact_type() const {
 295   return _klass;
 296 }
 297 
 298 ciType* NewArray::declared_type() const {
 299   return exact_type();
 300 }
 301 
 302 ciType* NewInstance::exact_type() const {
 303   return klass();
 304 }
 305 
 306 ciType* NewInstance::declared_type() const {
 307   return exact_type();
 308 }
 309 
 310 Value NewInlineTypeInstance::depends_on() {
 311   if (_depends_on != this) {
 312     if (_depends_on-&gt;as_NewInlineTypeInstance() != NULL) {
 313       return _depends_on-&gt;as_NewInlineTypeInstance()-&gt;depends_on();
 314     }
 315   }
 316   return _depends_on;
 317 }
 318 
 319 ciType* NewInlineTypeInstance::exact_type() const {
 320   return klass();
 321 }
 322 
 323 ciType* NewInlineTypeInstance::declared_type() const {
 324   return exact_type();
 325 }
 326 
 327 ciType* CheckCast::declared_type() const {
 328   return klass();
 329 }
 330 
 331 // Implementation of ArithmeticOp
 332 
 333 bool ArithmeticOp::is_commutative() const {
 334   switch (op()) {
 335     case Bytecodes::_iadd: // fall through
 336     case Bytecodes::_ladd: // fall through
 337     case Bytecodes::_fadd: // fall through
 338     case Bytecodes::_dadd: // fall through
 339     case Bytecodes::_imul: // fall through
 340     case Bytecodes::_lmul: // fall through
 341     case Bytecodes::_fmul: // fall through
 342     case Bytecodes::_dmul: return true;
 343     default              : return false;
 344   }
 345 }
 346 
 347 
 348 bool ArithmeticOp::can_trap() const {
 349   switch (op()) {
 350     case Bytecodes::_idiv: // fall through
 351     case Bytecodes::_ldiv: // fall through
 352     case Bytecodes::_irem: // fall through
 353     case Bytecodes::_lrem: return true;
 354     default              : return false;
 355   }
 356 }
 357 
 358 
 359 // Implementation of LogicOp
 360 
 361 bool LogicOp::is_commutative() const {
 362 #ifdef ASSERT
 363   switch (op()) {
 364     case Bytecodes::_iand: // fall through
 365     case Bytecodes::_land: // fall through
 366     case Bytecodes::_ior : // fall through
 367     case Bytecodes::_lor : // fall through
 368     case Bytecodes::_ixor: // fall through
 369     case Bytecodes::_lxor: break;
 370     default              : ShouldNotReachHere(); break;
 371   }
 372 #endif
 373   // all LogicOps are commutative
 374   return true;
 375 }
 376 
 377 
 378 // Implementation of IfOp
 379 
 380 bool IfOp::is_commutative() const {
 381   return cond() == eql || cond() == neq;
 382 }
 383 
 384 
 385 // Implementation of StateSplit
 386 
 387 void StateSplit::substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block) {
 388   NOT_PRODUCT(bool assigned = false;)
 389   for (int i = 0; i &lt; list.length(); i++) {
 390     BlockBegin** b = list.adr_at(i);
 391     if (*b == old_block) {
 392       *b = new_block;
 393       NOT_PRODUCT(assigned = true;)
 394     }
 395   }
 396   assert(assigned == true, &quot;should have assigned at least once&quot;);
 397 }
 398 
 399 
 400 IRScope* StateSplit::scope() const {
 401   return _state-&gt;scope();
 402 }
 403 
 404 
 405 void StateSplit::state_values_do(ValueVisitor* f) {
 406   Instruction::state_values_do(f);
 407   if (state() != NULL) state()-&gt;values_do(f);
 408 }
 409 
 410 
 411 void BlockBegin::state_values_do(ValueVisitor* f) {
 412   StateSplit::state_values_do(f);
 413 
 414   if (is_set(BlockBegin::exception_entry_flag)) {
 415     for (int i = 0; i &lt; number_of_exception_states(); i++) {
 416       exception_state_at(i)-&gt;values_do(f);
 417     }
 418   }
 419 }
 420 
 421 
 422 StoreField::StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 423                        ValueStack* state_before, bool needs_patching)
 424   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 425   , _value(value)
 426 {
 427   set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())-&gt;is_object());
 428 #ifdef ASSERT
 429   AssertValues assert_value;
 430   values_do(&amp;assert_value);
 431 #endif
 432   pin();
 433   if (value-&gt;as_NewInlineTypeInstance() != NULL) {
 434     value-&gt;as_NewInlineTypeInstance()-&gt;set_not_larva_anymore();
 435   }
 436 }
 437 
 438 StoreIndexed::StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value,
 439                            ValueStack* state_before, bool check_boolean, bool mismatched)
 440   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
 441   , _value(value), _check_boolean(check_boolean)
 442 {
 443   set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));
 444   set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)-&gt;is_object()));
 445 #ifdef ASSERT
 446   AssertValues assert_value;
 447   values_do(&amp;assert_value);
 448 #endif
 449   pin();
 450   if (value-&gt;as_NewInlineTypeInstance() != NULL) {
 451     value-&gt;as_NewInlineTypeInstance()-&gt;set_not_larva_anymore();
 452   }
 453 }
 454 
 455 
 456 // Implementation of Invoke
 457 
 458 
 459 Invoke::Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
 460                int vtable_index, ciMethod* target, ValueStack* state_before, bool null_free)
 461   : StateSplit(result_type, state_before)
 462   , _code(code)
 463   , _recv(recv)
 464   , _args(args)
 465   , _vtable_index(vtable_index)
 466   , _target(target)
 467 {
 468   set_flag(TargetIsLoadedFlag,   target-&gt;is_loaded());
 469   set_flag(TargetIsFinalFlag,    target_is_loaded() &amp;&amp; target-&gt;is_final_method());
 470   set_flag(TargetIsStrictfpFlag, target_is_loaded() &amp;&amp; target-&gt;is_strict());
 471   set_null_free(null_free);
 472 
 473   assert(args != NULL, &quot;args must exist&quot;);
 474 #ifdef ASSERT
 475   AssertValues assert_value;
 476   values_do(&amp;assert_value);
 477 #endif
 478 
 479   // provide an initial guess of signature size.
 480   _signature = new BasicTypeList(number_of_arguments() + (has_receiver() ? 1 : 0));
 481   if (has_receiver()) {
 482     _signature-&gt;append(as_BasicType(receiver()-&gt;type()));
 483     if (receiver()-&gt;as_NewInlineTypeInstance() != NULL) {
 484       receiver()-&gt;as_NewInlineTypeInstance()-&gt;set_not_larva_anymore();
 485     }
 486   }
 487   for (int i = 0; i &lt; number_of_arguments(); i++) {
 488     Value v = argument_at(i);
 489     ValueType* t = v-&gt;type();
 490     BasicType bt = as_BasicType(t);
 491     _signature-&gt;append(bt);
 492     if (v-&gt;as_NewInlineTypeInstance() != NULL) {
 493       v-&gt;as_NewInlineTypeInstance()-&gt;set_not_larva_anymore();
 494     }
 495   }
 496 }
 497 
 498 
 499 void Invoke::state_values_do(ValueVisitor* f) {
 500   StateSplit::state_values_do(f);
 501   if (state_before() != NULL) state_before()-&gt;values_do(f);
 502   if (state()        != NULL) state()-&gt;values_do(f);
 503 }
 504 
 505 ciType* Invoke::declared_type() const {
 506   ciSignature* declared_signature = state()-&gt;scope()-&gt;method()-&gt;get_declared_signature_at_bci(state()-&gt;bci());
 507   ciType *t = declared_signature-&gt;return_type();
 508   assert(t-&gt;basic_type() != T_VOID, &quot;need return value of void method?&quot;);
 509   return t;
 510 }
 511 
 512 // Implementation of Contant
 513 intx Constant::hash() const {
 514   if (state_before() == NULL) {
 515     switch (type()-&gt;tag()) {
 516     case intTag:
 517       return HASH2(name(), type()-&gt;as_IntConstant()-&gt;value());
 518     case addressTag:
 519       return HASH2(name(), type()-&gt;as_AddressConstant()-&gt;value());
 520     case longTag:
 521       {
 522         jlong temp = type()-&gt;as_LongConstant()-&gt;value();
 523         return HASH3(name(), high(temp), low(temp));
 524       }
 525     case floatTag:
 526       return HASH2(name(), jint_cast(type()-&gt;as_FloatConstant()-&gt;value()));
 527     case doubleTag:
 528       {
 529         jlong temp = jlong_cast(type()-&gt;as_DoubleConstant()-&gt;value());
 530         return HASH3(name(), high(temp), low(temp));
 531       }
 532     case objectTag:
 533       assert(type()-&gt;as_ObjectType()-&gt;is_loaded(), &quot;can&#39;t handle unloaded values&quot;);
 534       return HASH2(name(), type()-&gt;as_ObjectType()-&gt;constant_value());
 535     case metaDataTag:
 536       assert(type()-&gt;as_MetadataType()-&gt;is_loaded(), &quot;can&#39;t handle unloaded values&quot;);
 537       return HASH2(name(), type()-&gt;as_MetadataType()-&gt;constant_value());
 538     default:
 539       ShouldNotReachHere();
 540     }
 541   }
 542   return 0;
 543 }
 544 
 545 bool Constant::is_equal(Value v) const {
 546   if (v-&gt;as_Constant() == NULL) return false;
 547 
 548   switch (type()-&gt;tag()) {
 549     case intTag:
 550       {
 551         IntConstant* t1 =    type()-&gt;as_IntConstant();
 552         IntConstant* t2 = v-&gt;type()-&gt;as_IntConstant();
 553         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 554                 t1-&gt;value() == t2-&gt;value());
 555       }
 556     case longTag:
 557       {
 558         LongConstant* t1 =    type()-&gt;as_LongConstant();
 559         LongConstant* t2 = v-&gt;type()-&gt;as_LongConstant();
 560         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 561                 t1-&gt;value() == t2-&gt;value());
 562       }
 563     case floatTag:
 564       {
 565         FloatConstant* t1 =    type()-&gt;as_FloatConstant();
 566         FloatConstant* t2 = v-&gt;type()-&gt;as_FloatConstant();
 567         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 568                 jint_cast(t1-&gt;value()) == jint_cast(t2-&gt;value()));
 569       }
 570     case doubleTag:
 571       {
 572         DoubleConstant* t1 =    type()-&gt;as_DoubleConstant();
 573         DoubleConstant* t2 = v-&gt;type()-&gt;as_DoubleConstant();
 574         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 575                 jlong_cast(t1-&gt;value()) == jlong_cast(t2-&gt;value()));
 576       }
 577     case objectTag:
 578       {
 579         ObjectType* t1 =    type()-&gt;as_ObjectType();
 580         ObjectType* t2 = v-&gt;type()-&gt;as_ObjectType();
 581         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 582                 t1-&gt;is_loaded() &amp;&amp; t2-&gt;is_loaded() &amp;&amp;
 583                 t1-&gt;constant_value() == t2-&gt;constant_value());
 584       }
 585     case metaDataTag:
 586       {
 587         MetadataType* t1 =    type()-&gt;as_MetadataType();
 588         MetadataType* t2 = v-&gt;type()-&gt;as_MetadataType();
 589         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 590                 t1-&gt;is_loaded() &amp;&amp; t2-&gt;is_loaded() &amp;&amp;
 591                 t1-&gt;constant_value() == t2-&gt;constant_value());
 592       }
 593     default:
 594       return false;
 595   }
 596 }
 597 
 598 Constant::CompareResult Constant::compare(Instruction::Condition cond, Value right) const {
 599   Constant* rc = right-&gt;as_Constant();
 600   // other is not a constant
 601   if (rc == NULL) return not_comparable;
 602 
 603   ValueType* lt = type();
 604   ValueType* rt = rc-&gt;type();
 605   // different types
 606   if (lt-&gt;base() != rt-&gt;base()) return not_comparable;
 607   switch (lt-&gt;tag()) {
 608   case intTag: {
 609     int x = lt-&gt;as_IntConstant()-&gt;value();
 610     int y = rt-&gt;as_IntConstant()-&gt;value();
 611     switch (cond) {
 612     case If::eql: return x == y ? cond_true : cond_false;
 613     case If::neq: return x != y ? cond_true : cond_false;
 614     case If::lss: return x &lt;  y ? cond_true : cond_false;
 615     case If::leq: return x &lt;= y ? cond_true : cond_false;
 616     case If::gtr: return x &gt;  y ? cond_true : cond_false;
 617     case If::geq: return x &gt;= y ? cond_true : cond_false;
 618     default     : break;
 619     }
 620     break;
 621   }
 622   case longTag: {
 623     jlong x = lt-&gt;as_LongConstant()-&gt;value();
 624     jlong y = rt-&gt;as_LongConstant()-&gt;value();
 625     switch (cond) {
 626     case If::eql: return x == y ? cond_true : cond_false;
 627     case If::neq: return x != y ? cond_true : cond_false;
 628     case If::lss: return x &lt;  y ? cond_true : cond_false;
 629     case If::leq: return x &lt;= y ? cond_true : cond_false;
 630     case If::gtr: return x &gt;  y ? cond_true : cond_false;
 631     case If::geq: return x &gt;= y ? cond_true : cond_false;
 632     default     : break;
 633     }
 634     break;
 635   }
 636   case objectTag: {
 637     ciObject* xvalue = lt-&gt;as_ObjectType()-&gt;constant_value();
 638     ciObject* yvalue = rt-&gt;as_ObjectType()-&gt;constant_value();
 639     assert(xvalue != NULL &amp;&amp; yvalue != NULL, &quot;not constants&quot;);
 640     if (xvalue-&gt;is_loaded() &amp;&amp; yvalue-&gt;is_loaded()) {
 641       switch (cond) {
 642       case If::eql: return xvalue == yvalue ? cond_true : cond_false;
 643       case If::neq: return xvalue != yvalue ? cond_true : cond_false;
 644       default     : break;
 645       }
 646     }
 647     break;
 648   }
 649   case metaDataTag: {
 650     ciMetadata* xvalue = lt-&gt;as_MetadataType()-&gt;constant_value();
 651     ciMetadata* yvalue = rt-&gt;as_MetadataType()-&gt;constant_value();
 652     assert(xvalue != NULL &amp;&amp; yvalue != NULL, &quot;not constants&quot;);
 653     if (xvalue-&gt;is_loaded() &amp;&amp; yvalue-&gt;is_loaded()) {
 654       switch (cond) {
 655       case If::eql: return xvalue == yvalue ? cond_true : cond_false;
 656       case If::neq: return xvalue != yvalue ? cond_true : cond_false;
 657       default     : break;
 658       }
 659     }
 660     break;
 661   }
 662   default:
 663     break;
 664   }
 665   return not_comparable;
 666 }
 667 
 668 
 669 // Implementation of BlockBegin
 670 
 671 void BlockBegin::set_end(BlockEnd* end) {
 672   assert(end != NULL, &quot;should not reset block end to NULL&quot;);
 673   if (end == _end) {
 674     return;
 675   }
 676   clear_end();
 677 
 678   // Set the new end
 679   _end = end;
 680 
 681   _successors.clear();
 682   // Now reset successors list based on BlockEnd
 683   for (int i = 0; i &lt; end-&gt;number_of_sux(); i++) {
 684     BlockBegin* sux = end-&gt;sux_at(i);
 685     _successors.append(sux);
 686     sux-&gt;_predecessors.append(this);
 687   }
 688   _end-&gt;set_begin(this);
 689 }
 690 
 691 
 692 void BlockBegin::clear_end() {
 693   // Must make the predecessors/successors match up with the
 694   // BlockEnd&#39;s notion.
 695   if (_end != NULL) {
 696     // disconnect from the old end
 697     _end-&gt;set_begin(NULL);
 698 
 699     // disconnect this block from it&#39;s current successors
 700     for (int i = 0; i &lt; _successors.length(); i++) {
 701       _successors.at(i)-&gt;remove_predecessor(this);
 702     }
 703     _end = NULL;
 704   }
 705 }
 706 
 707 
 708 void BlockBegin::disconnect_edge(BlockBegin* from, BlockBegin* to) {
 709   // disconnect any edges between from and to
 710 #ifndef PRODUCT
 711   if (PrintIR &amp;&amp; Verbose) {
 712     tty-&gt;print_cr(&quot;Disconnected edge B%d -&gt; B%d&quot;, from-&gt;block_id(), to-&gt;block_id());
 713   }
 714 #endif
 715   for (int s = 0; s &lt; from-&gt;number_of_sux();) {
 716     BlockBegin* sux = from-&gt;sux_at(s);
 717     if (sux == to) {
 718       int index = sux-&gt;_predecessors.find(from);
 719       if (index &gt;= 0) {
 720         sux-&gt;_predecessors.remove_at(index);
 721       }
 722       from-&gt;_successors.remove_at(s);
 723     } else {
 724       s++;
 725     }
 726   }
 727 }
 728 
 729 
 730 void BlockBegin::disconnect_from_graph() {
 731   // disconnect this block from all other blocks
 732   for (int p = 0; p &lt; number_of_preds(); p++) {
 733     pred_at(p)-&gt;remove_successor(this);
 734   }
 735   for (int s = 0; s &lt; number_of_sux(); s++) {
 736     sux_at(s)-&gt;remove_predecessor(this);
 737   }
 738 }
 739 
 740 void BlockBegin::substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux) {
 741   // modify predecessors before substituting successors
 742   for (int i = 0; i &lt; number_of_sux(); i++) {
 743     if (sux_at(i) == old_sux) {
 744       // remove old predecessor before adding new predecessor
 745       // otherwise there is a dead predecessor in the list
 746       new_sux-&gt;remove_predecessor(old_sux);
 747       new_sux-&gt;add_predecessor(this);
 748     }
 749   }
 750   old_sux-&gt;remove_predecessor(this);
 751   end()-&gt;substitute_sux(old_sux, new_sux);
 752 }
 753 
 754 
 755 
 756 // In general it is not possible to calculate a value for the field &quot;depth_first_number&quot;
 757 // of the inserted block, without recomputing the values of the other blocks
 758 // in the CFG. Therefore the value of &quot;depth_first_number&quot; in BlockBegin becomes meaningless.
 759 BlockBegin* BlockBegin::insert_block_between(BlockBegin* sux) {
 760   int bci = sux-&gt;bci();
 761   // critical edge splitting may introduce a goto after a if and array
 762   // bound check elimination may insert a predicate between the if and
 763   // goto. The bci of the goto can&#39;t be the one of the if otherwise
 764   // the state and bci are inconsistent and a deoptimization triggered
 765   // by the predicate would lead to incorrect execution/a crash.
 766   BlockBegin* new_sux = new BlockBegin(bci);
 767 
 768   // mark this block (special treatment when block order is computed)
 769   new_sux-&gt;set(critical_edge_split_flag);
 770 
 771   // This goto is not a safepoint.
 772   Goto* e = new Goto(sux, false);
 773   new_sux-&gt;set_next(e, bci);
 774   new_sux-&gt;set_end(e);
 775   // setup states
 776   ValueStack* s = end()-&gt;state();
 777   new_sux-&gt;set_state(s-&gt;copy(s-&gt;kind(), bci));
 778   e-&gt;set_state(s-&gt;copy(s-&gt;kind(), bci));
 779   assert(new_sux-&gt;state()-&gt;locals_size() == s-&gt;locals_size(), &quot;local size mismatch!&quot;);
 780   assert(new_sux-&gt;state()-&gt;stack_size() == s-&gt;stack_size(), &quot;stack size mismatch!&quot;);
 781   assert(new_sux-&gt;state()-&gt;locks_size() == s-&gt;locks_size(), &quot;locks size mismatch!&quot;);
 782 
 783   // link predecessor to new block
 784   end()-&gt;substitute_sux(sux, new_sux);
 785 
 786   // The ordering needs to be the same, so remove the link that the
 787   // set_end call above added and substitute the new_sux for this
 788   // block.
 789   sux-&gt;remove_predecessor(new_sux);
 790 
 791   // the successor could be the target of a switch so it might have
 792   // multiple copies of this predecessor, so substitute the new_sux
 793   // for the first and delete the rest.
 794   bool assigned = false;
 795   BlockList&amp; list = sux-&gt;_predecessors;
 796   for (int i = 0; i &lt; list.length(); i++) {
 797     BlockBegin** b = list.adr_at(i);
 798     if (*b == this) {
 799       if (assigned) {
 800         list.remove_at(i);
 801         // reprocess this index
 802         i--;
 803       } else {
 804         assigned = true;
 805         *b = new_sux;
 806       }
 807       // link the new block back to it&#39;s predecessors.
 808       new_sux-&gt;add_predecessor(this);
 809     }
 810   }
 811   assert(assigned == true, &quot;should have assigned at least once&quot;);
 812   return new_sux;
 813 }
 814 
 815 
 816 void BlockBegin::remove_successor(BlockBegin* pred) {
 817   int idx;
 818   while ((idx = _successors.find(pred)) &gt;= 0) {
 819     _successors.remove_at(idx);
 820   }
 821 }
 822 
 823 
 824 void BlockBegin::add_predecessor(BlockBegin* pred) {
 825   _predecessors.append(pred);
 826 }
 827 
 828 
 829 void BlockBegin::remove_predecessor(BlockBegin* pred) {
 830   int idx;
 831   while ((idx = _predecessors.find(pred)) &gt;= 0) {
 832     _predecessors.remove_at(idx);
 833   }
 834 }
 835 
 836 
 837 void BlockBegin::add_exception_handler(BlockBegin* b) {
 838   assert(b != NULL &amp;&amp; (b-&gt;is_set(exception_entry_flag)), &quot;exception handler must exist&quot;);
 839   // add only if not in the list already
 840   if (!_exception_handlers.contains(b)) _exception_handlers.append(b);
 841 }
 842 
 843 int BlockBegin::add_exception_state(ValueStack* state) {
 844   assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;);
 845   if (_exception_states == NULL) {
 846     _exception_states = new ValueStackStack(4);
 847   }
 848   _exception_states-&gt;append(state);
 849   return _exception_states-&gt;length() - 1;
 850 }
 851 
 852 
 853 void BlockBegin::iterate_preorder(boolArray&amp; mark, BlockClosure* closure) {
 854   if (!mark.at(block_id())) {
 855     mark.at_put(block_id(), true);
 856     closure-&gt;block_do(this);
 857     BlockEnd* e = end(); // must do this after block_do because block_do may change it!
 858     { for (int i = number_of_exception_handlers() - 1; i &gt;= 0; i--) exception_handler_at(i)-&gt;iterate_preorder(mark, closure); }
 859     { for (int i = e-&gt;number_of_sux            () - 1; i &gt;= 0; i--) e-&gt;sux_at           (i)-&gt;iterate_preorder(mark, closure); }
 860   }
 861 }
 862 
 863 
 864 void BlockBegin::iterate_postorder(boolArray&amp; mark, BlockClosure* closure) {
 865   if (!mark.at(block_id())) {
 866     mark.at_put(block_id(), true);
 867     BlockEnd* e = end();
 868     { for (int i = number_of_exception_handlers() - 1; i &gt;= 0; i--) exception_handler_at(i)-&gt;iterate_postorder(mark, closure); }
 869     { for (int i = e-&gt;number_of_sux            () - 1; i &gt;= 0; i--) e-&gt;sux_at           (i)-&gt;iterate_postorder(mark, closure); }
 870     closure-&gt;block_do(this);
 871   }
 872 }
 873 
 874 
 875 void BlockBegin::iterate_preorder(BlockClosure* closure) {
 876   int mark_len = number_of_blocks();
 877   boolArray mark(mark_len, mark_len, false);
 878   iterate_preorder(mark, closure);
 879 }
 880 
 881 
 882 void BlockBegin::iterate_postorder(BlockClosure* closure) {
 883   int mark_len = number_of_blocks();
 884   boolArray mark(mark_len, mark_len, false);
 885   iterate_postorder(mark, closure);
 886 }
 887 
 888 
 889 void BlockBegin::block_values_do(ValueVisitor* f) {
 890   for (Instruction* n = this; n != NULL; n = n-&gt;next()) n-&gt;values_do(f);
 891 }
 892 
 893 
 894 #ifndef PRODUCT
 895    #define TRACE_PHI(code) if (PrintPhiFunctions) { code; }
 896 #else
 897    #define TRACE_PHI(coce)
 898 #endif
 899 
 900 
 901 bool BlockBegin::try_merge(ValueStack* new_state) {
 902   TRACE_PHI(tty-&gt;print_cr(&quot;********** try_merge for block B%d&quot;, block_id()));
 903 
 904   // local variables used for state iteration
 905   int index;
 906   Value new_value, existing_value;
 907 
 908   ValueStack* existing_state = state();
 909   if (existing_state == NULL) {
 910     TRACE_PHI(tty-&gt;print_cr(&quot;first call of try_merge for this block&quot;));
 911 
 912     if (is_set(BlockBegin::was_visited_flag)) {
 913       // this actually happens for complicated jsr/ret structures
 914       return false; // BAILOUT in caller
 915     }
 916 
 917     // copy state because it is altered
 918     new_state = new_state-&gt;copy(ValueStack::BlockBeginState, bci());
 919 
 920     // Use method liveness to invalidate dead locals
 921     MethodLivenessResult liveness = new_state-&gt;scope()-&gt;method()-&gt;liveness_at_bci(bci());
 922     if (liveness.is_valid()) {
 923       assert((int)liveness.size() == new_state-&gt;locals_size(), &quot;error in use of liveness&quot;);
 924 
 925       for_each_local_value(new_state, index, new_value) {
 926         if (!liveness.at(index) || new_value-&gt;type()-&gt;is_illegal()) {
 927           new_state-&gt;invalidate_local(index);
 928           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating dead local %d&quot;, index));
 929         }
 930       }
 931     }
 932 
 933     if (is_set(BlockBegin::parser_loop_header_flag)) {
 934       TRACE_PHI(tty-&gt;print_cr(&quot;loop header block, initializing phi functions&quot;));
 935 
 936       for_each_stack_value(new_state, index, new_value) {
 937         new_state-&gt;setup_phi_for_stack(this, index);
 938         TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for stack %d&quot;, new_state-&gt;stack_at(index)-&gt;type()-&gt;tchar(), new_state-&gt;stack_at(index)-&gt;id(), index));
 939       }
 940 
 941       BitMap&amp; requires_phi_function = new_state-&gt;scope()-&gt;requires_phi_function();
 942 
 943       for_each_local_value(new_state, index, new_value) {
 944         bool requires_phi = requires_phi_function.at(index) || (new_value-&gt;type()-&gt;is_double_word() &amp;&amp; requires_phi_function.at(index + 1));
 945         if (requires_phi || !SelectivePhiFunctions) {
 946           new_state-&gt;setup_phi_for_local(this, index);
 947           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for local %d&quot;, new_state-&gt;local_at(index)-&gt;type()-&gt;tchar(), new_state-&gt;local_at(index)-&gt;id(), index));
 948         }
 949       }
 950     }
 951 
 952     // initialize state of block
 953     set_state(new_state);
 954 
 955   } else if (existing_state-&gt;is_same(new_state)) {
 956     TRACE_PHI(tty-&gt;print_cr(&quot;exisiting state found&quot;));
 957 
 958     assert(existing_state-&gt;scope() == new_state-&gt;scope(), &quot;not matching&quot;);
 959     assert(existing_state-&gt;locals_size() == new_state-&gt;locals_size(), &quot;not matching&quot;);
 960     assert(existing_state-&gt;stack_size() == new_state-&gt;stack_size(), &quot;not matching&quot;);
 961 
 962     if (is_set(BlockBegin::was_visited_flag)) {
 963       TRACE_PHI(tty-&gt;print_cr(&quot;loop header block, phis must be present&quot;));
 964 
 965       if (!is_set(BlockBegin::parser_loop_header_flag)) {
 966         // this actually happens for complicated jsr/ret structures
 967         return false; // BAILOUT in caller
 968       }
 969 
 970       for_each_local_value(existing_state, index, existing_value) {
 971         Value new_value = new_state-&gt;local_at(index);
 972         if (new_value == NULL || new_value-&gt;type()-&gt;tag() != existing_value-&gt;type()-&gt;tag()) {
 973           Phi* existing_phi = existing_value-&gt;as_Phi();
 974           if (existing_phi == NULL) {
 975             return false; // BAILOUT in caller
 976           }
 977           // Invalidate the phi function here. This case is very rare except for
 978           // JVMTI capability &quot;can_access_local_variables&quot;.
 979           // In really rare cases we will bail out in LIRGenerator::move_to_phi.
 980           existing_phi-&gt;make_illegal();
 981           existing_state-&gt;invalidate_local(index);
 982           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating local %d because of type mismatch&quot;, index));
 983         }
 984       }
 985 
 986 #ifdef ASSERT
 987       // check that all necessary phi functions are present
 988       for_each_stack_value(existing_state, index, existing_value) {
 989         assert(existing_value-&gt;as_Phi() != NULL &amp;&amp; existing_value-&gt;as_Phi()-&gt;block() == this, &quot;phi function required&quot;);
 990       }
 991       for_each_local_value(existing_state, index, existing_value) {
 992         assert(existing_value == new_state-&gt;local_at(index) || (existing_value-&gt;as_Phi() != NULL &amp;&amp; existing_value-&gt;as_Phi()-&gt;as_Phi()-&gt;block() == this), &quot;phi function required&quot;);
 993       }
 994 #endif
 995 
 996     } else {
 997       TRACE_PHI(tty-&gt;print_cr(&quot;creating phi functions on demand&quot;));
 998 
 999       // create necessary phi functions for stack
1000       for_each_stack_value(existing_state, index, existing_value) {
1001         Value new_value = new_state-&gt;stack_at(index);
1002         Phi* existing_phi = existing_value-&gt;as_Phi();
1003 
1004         if (new_value != existing_value &amp;&amp; (existing_phi == NULL || existing_phi-&gt;block() != this)) {
1005           existing_state-&gt;setup_phi_for_stack(this, index);
1006           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for stack %d&quot;, existing_state-&gt;stack_at(index)-&gt;type()-&gt;tchar(), existing_state-&gt;stack_at(index)-&gt;id(), index));
1007           if (new_value-&gt;as_NewInlineTypeInstance() != NULL) {new_value-&gt;as_NewInlineTypeInstance()-&gt;set_not_larva_anymore(); }
1008           if (existing_value-&gt;as_NewInlineTypeInstance() != NULL) {existing_value-&gt;as_NewInlineTypeInstance()-&gt;set_not_larva_anymore(); }
1009         }
1010       }
1011 
1012       // create necessary phi functions for locals
1013       for_each_local_value(existing_state, index, existing_value) {
1014         Value new_value = new_state-&gt;local_at(index);
1015         Phi* existing_phi = existing_value-&gt;as_Phi();
1016 
1017         if (new_value == NULL || new_value-&gt;type()-&gt;tag() != existing_value-&gt;type()-&gt;tag()) {
1018           existing_state-&gt;invalidate_local(index);
1019           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating local %d because of type mismatch&quot;, index));
1020         } else if (new_value != existing_value &amp;&amp; (existing_phi == NULL || existing_phi-&gt;block() != this)) {
1021           existing_state-&gt;setup_phi_for_local(this, index);
1022           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for local %d&quot;, existing_state-&gt;local_at(index)-&gt;type()-&gt;tchar(), existing_state-&gt;local_at(index)-&gt;id(), index));
1023           if (new_value-&gt;as_NewInlineTypeInstance() != NULL) {new_value-&gt;as_NewInlineTypeInstance()-&gt;set_not_larva_anymore(); }
1024           if (existing_value-&gt;as_NewInlineTypeInstance() != NULL) {existing_value-&gt;as_NewInlineTypeInstance()-&gt;set_not_larva_anymore(); }
1025         }
1026       }
1027     }
1028 
1029     assert(existing_state-&gt;caller_state() == new_state-&gt;caller_state(), &quot;caller states must be equal&quot;);
1030 
1031   } else {
1032     assert(false, &quot;stack or locks not matching (invalid bytecodes)&quot;);
1033     return false;
1034   }
1035 
1036   TRACE_PHI(tty-&gt;print_cr(&quot;********** try_merge for block B%d successful&quot;, block_id()));
1037 
1038   return true;
1039 }
1040 
1041 
1042 #ifndef PRODUCT
1043 void BlockBegin::print_block() {
1044   InstructionPrinter ip;
1045   print_block(ip, false);
1046 }
1047 
1048 
1049 void BlockBegin::print_block(InstructionPrinter&amp; ip, bool live_only) {
1050   ip.print_instr(this); tty-&gt;cr();
1051   ip.print_stack(this-&gt;state()); tty-&gt;cr();
1052   ip.print_inline_level(this);
1053   ip.print_head();
1054   for (Instruction* n = next(); n != NULL; n = n-&gt;next()) {
1055     if (!live_only || n-&gt;is_pinned() || n-&gt;use_count() &gt; 0) {
1056       ip.print_line(n);
1057     }
1058   }
1059   tty-&gt;cr();
1060 }
1061 #endif // PRODUCT
1062 
1063 
1064 // Implementation of BlockList
1065 
1066 void BlockList::iterate_forward (BlockClosure* closure) {
1067   const int l = length();
1068   for (int i = 0; i &lt; l; i++) closure-&gt;block_do(at(i));
1069 }
1070 
1071 
1072 void BlockList::iterate_backward(BlockClosure* closure) {
1073   for (int i = length() - 1; i &gt;= 0; i--) closure-&gt;block_do(at(i));
1074 }
1075 
1076 
1077 void BlockList::blocks_do(void f(BlockBegin*)) {
1078   for (int i = length() - 1; i &gt;= 0; i--) f(at(i));
1079 }
1080 
1081 
1082 void BlockList::values_do(ValueVisitor* f) {
1083   for (int i = length() - 1; i &gt;= 0; i--) at(i)-&gt;block_values_do(f);
1084 }
1085 
1086 
1087 #ifndef PRODUCT
1088 void BlockList::print(bool cfg_only, bool live_only) {
1089   InstructionPrinter ip;
1090   for (int i = 0; i &lt; length(); i++) {
1091     BlockBegin* block = at(i);
1092     if (cfg_only) {
1093       ip.print_instr(block); tty-&gt;cr();
1094     } else {
1095       block-&gt;print_block(ip, live_only);
1096     }
1097   }
1098 }
1099 #endif // PRODUCT
1100 
1101 
1102 // Implementation of BlockEnd
1103 
1104 void BlockEnd::set_begin(BlockBegin* begin) {
1105   BlockList* sux = NULL;
1106   if (begin != NULL) {
1107     sux = begin-&gt;successors();
1108   } else if (this-&gt;begin() != NULL) {
1109     // copy our sux list
1110     BlockList* sux = new BlockList(this-&gt;begin()-&gt;number_of_sux());
1111     for (int i = 0; i &lt; this-&gt;begin()-&gt;number_of_sux(); i++) {
1112       sux-&gt;append(this-&gt;begin()-&gt;sux_at(i));
1113     }
1114   }
1115   _sux = sux;
1116 }
1117 
1118 
1119 void BlockEnd::substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux) {
1120   substitute(*_sux, old_sux, new_sux);
1121 }
1122 
1123 
1124 // Implementation of Phi
1125 
1126 // Normal phi functions take their operands from the last instruction of the
1127 // predecessor. Special handling is needed for xhanlder entries because there
1128 // the state of arbitrary instructions are needed.
1129 
1130 Value Phi::operand_at(int i) const {
1131   ValueStack* state;
1132   if (_block-&gt;is_set(BlockBegin::exception_entry_flag)) {
1133     state = _block-&gt;exception_state_at(i);
1134   } else {
1135     state = _block-&gt;pred_at(i)-&gt;end()-&gt;state();
1136   }
1137   assert(state != NULL, &quot;&quot;);
1138 
1139   if (is_local()) {
1140     return state-&gt;local_at(local_index());
1141   } else {
1142     return state-&gt;stack_at(stack_index());
1143   }
1144 }
1145 
1146 
1147 int Phi::operand_count() const {
1148   if (_block-&gt;is_set(BlockBegin::exception_entry_flag)) {
1149     return _block-&gt;number_of_exception_states();
1150   } else {
1151     return _block-&gt;number_of_preds();
1152   }
1153 }
1154 
1155 #ifdef ASSERT
1156 // Constructor of Assert
1157 Assert::Assert(Value x, Condition cond, bool unordered_is_true, Value y) : Instruction(illegalType)
1158   , _x(x)
1159   , _cond(cond)
1160   , _y(y)
1161 {
1162   set_flag(UnorderedIsTrueFlag, unordered_is_true);
1163   assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1164   pin();
1165 
1166   stringStream strStream;
1167   Compilation::current()-&gt;method()-&gt;print_name(&amp;strStream);
1168 
1169   stringStream strStream1;
1170   InstructionPrinter ip1(1, &amp;strStream1);
1171   ip1.print_instr(x);
1172 
1173   stringStream strStream2;
1174   InstructionPrinter ip2(1, &amp;strStream2);
1175   ip2.print_instr(y);
1176 
1177   stringStream ss;
1178   ss.print(&quot;Assertion %s %s %s in method %s&quot;, strStream1.as_string(), ip2.cond_name(cond), strStream2.as_string(), strStream.as_string());
1179 
1180   _message = ss.as_string();
1181 }
1182 #endif
1183 
1184 void RangeCheckPredicate::check_state() {
1185   assert(state()-&gt;kind() != ValueStack::EmptyExceptionState &amp;&amp; state()-&gt;kind() != ValueStack::ExceptionState, &quot;will deopt with empty state&quot;);
1186 }
1187 
1188 void ProfileInvoke::state_values_do(ValueVisitor* f) {
1189   if (state() != NULL) state()-&gt;values_do(f);
1190 }
1191 
    </pre>
  </body>
</html>