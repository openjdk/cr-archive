<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_TYPE_HPP
  26 #define SHARE_OPTO_TYPE_HPP
  27 
  28 #include &quot;ci/ciInlineKlass.hpp&quot;
  29 #include &quot;opto/adlcVMDeps.hpp&quot;
  30 #include &quot;runtime/handles.hpp&quot;
  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 
  33 // Portions of code courtesy of Clifford Click
  34 
  35 // Optimization - Graph Style
  36 
  37 
  38 // This class defines a Type lattice.  The lattice is used in the constant
  39 // propagation algorithms, and for some type-checking of the iloc code.
  40 // Basic types include RSD&#39;s (lower bound, upper bound, stride for integers),
  41 // float &amp; double precision constants, sets of data-labels and code-labels.
  42 // The complete lattice is described below.  Subtypes have no relationship to
  43 // up or down in the lattice; that is entirely determined by the behavior of
  44 // the MEET/JOIN functions.
  45 
  46 class Dict;
  47 class Type;
  48 class   TypeD;
  49 class   TypeF;
  50 class   TypeInt;
  51 class   TypeLong;
  52 class   TypeNarrowPtr;
  53 class     TypeNarrowOop;
  54 class     TypeNarrowKlass;
  55 class   TypeAry;
  56 class   TypeTuple;
  57 class   TypeInlineType;
  58 class   TypeVect;
  59 class     TypeVectS;
  60 class     TypeVectD;
  61 class     TypeVectX;
  62 class     TypeVectY;
  63 class     TypeVectZ;
  64 class   TypePtr;
  65 class     TypeRawPtr;
  66 class     TypeOopPtr;
  67 class       TypeInstPtr;
  68 class       TypeAryPtr;
  69 class     TypeKlassPtr;
  70 class     TypeMetadataPtr;
  71 
  72 //------------------------------Type-------------------------------------------
  73 // Basic Type object, represents a set of primitive Values.
  74 // Types are hash-cons&#39;d into a private class dictionary, so only one of each
  75 // different kind of Type exists.  Types are never modified after creation, so
  76 // all their interesting fields are constant.
  77 class Type {
  78   friend class VMStructs;
  79 
  80 public:
  81   enum TYPES {
  82     Bad=0,                      // Type check
  83     Control,                    // Control of code (not in lattice)
  84     Top,                        // Top of the lattice
  85     Int,                        // Integer range (lo-hi)
  86     Long,                       // Long integer range (lo-hi)
  87     Half,                       // Placeholder half of doubleword
  88     NarrowOop,                  // Compressed oop pointer
  89     NarrowKlass,                // Compressed klass pointer
  90 
  91     Tuple,                      // Method signature or object layout
  92     Array,                      // Array types
  93     VectorS,                    //  32bit Vector types
  94     VectorD,                    //  64bit Vector types
  95     VectorX,                    // 128bit Vector types
  96     VectorY,                    // 256bit Vector types
  97     VectorZ,                    // 512bit Vector types
  98     InlineType,                 // Inline type
  99 
 100     AnyPtr,                     // Any old raw, klass, inst, or array pointer
 101     RawPtr,                     // Raw (non-oop) pointers
 102     OopPtr,                     // Any and all Java heap entities
 103     InstPtr,                    // Instance pointers (non-array objects)
 104     AryPtr,                     // Array pointers
 105     // (Ptr order matters:  See is_ptr, isa_ptr, is_oopptr, isa_oopptr.)
 106 
 107     MetadataPtr,                // Generic metadata
 108     KlassPtr,                   // Klass pointers
 109 
 110     Function,                   // Function signature
 111     Abio,                       // Abstract I/O
 112     Return_Address,             // Subroutine return address
 113     Memory,                     // Abstract store
 114     FloatTop,                   // No float value
 115     FloatCon,                   // Floating point constant
 116     FloatBot,                   // Any float value
 117     DoubleTop,                  // No double value
 118     DoubleCon,                  // Double precision constant
 119     DoubleBot,                  // Any double value
 120     Bottom,                     // Bottom of lattice
 121     lastype                     // Bogus ending type (not in lattice)
 122   };
 123 
 124   // Signal values for offsets from a base pointer
 125   enum OFFSET_SIGNALS {
 126     OffsetTop = -2000000000,    // undefined offset
 127     OffsetBot = -2000000001     // any possible offset
 128   };
 129 
 130   class Offset {
 131   private:
 132     int _offset;
 133 
 134   public:
 135     explicit Offset(int offset) : _offset(offset) {}
 136 
 137     const Offset meet(const Offset other) const;
 138     const Offset dual() const;
 139     const Offset add(intptr_t offset) const;
 140     bool operator==(const Offset&amp; other) const {
 141       return _offset == other._offset;
 142     }
 143     bool operator!=(const Offset&amp; other) const {
 144       return _offset != other._offset;
 145     }
 146     int get() const { return _offset; }
 147 
 148     void dump2(outputStream *st) const;
 149 
 150     static const Offset top;
 151     static const Offset bottom;
 152   };
 153 
 154   // Min and max WIDEN values.
 155   enum WIDEN {
 156     WidenMin = 0,
 157     WidenMax = 3
 158   };
 159 
 160 private:
 161   typedef struct {
 162     TYPES                dual_type;
 163     BasicType            basic_type;
 164     const char*          msg;
 165     bool                 isa_oop;
 166     uint                 ideal_reg;
 167     relocInfo::relocType reloc;
 168   } TypeInfo;
 169 
 170   // Dictionary of types shared among compilations.
 171   static Dict* _shared_type_dict;
 172   static const TypeInfo _type_info[];
 173 
 174   static int uhash( const Type *const t );
 175   // Structural equality check.  Assumes that cmp() has already compared
 176   // the _base types and thus knows it can cast &#39;t&#39; appropriately.
 177   virtual bool eq( const Type *t ) const;
 178 
 179   // Top-level hash-table of types
 180   static Dict *type_dict() {
 181     return Compile::current()-&gt;type_dict();
 182   }
 183 
 184   // DUAL operation: reflect around lattice centerline.  Used instead of
 185   // join to ensure my lattice is symmetric up and down.  Dual is computed
 186   // lazily, on demand, and cached in _dual.
 187   const Type *_dual;            // Cached dual value
 188   // Table for efficient dualing of base types
 189   static const TYPES dual_type[lastype];
 190 
 191 #ifdef ASSERT
 192   // One type is interface, the other is oop
 193   virtual bool interface_vs_oop_helper(const Type *t) const;
 194 #endif
 195 
 196   const Type *meet_helper(const Type *t, bool include_speculative) const;
 197   void check_symmetrical(const Type *t, const Type *mt) const;
 198 
 199 protected:
 200   // Each class of type is also identified by its base.
 201   const TYPES _base;            // Enum of Types type
 202 
 203   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 204   // ~Type();                   // Use fast deallocation
 205   const Type *hashcons();       // Hash-cons the type
 206   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 207   const Type *join_helper(const Type *t, bool include_speculative) const {
 208     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 209   }
 210 
 211 public:
 212 
 213   inline void* operator new( size_t x ) throw() {
 214     Compile* compile = Compile::current();
 215     compile-&gt;set_type_last_size(x);
 216     return compile-&gt;type_arena()-&gt;Amalloc_D(x);
 217   }
 218   inline void operator delete( void* ptr ) {
 219     Compile* compile = Compile::current();
 220     compile-&gt;type_arena()-&gt;Afree(ptr,compile-&gt;type_last_size());
 221   }
 222 
 223   // Initialize the type system for a particular compilation.
 224   static void Initialize(Compile* compile);
 225 
 226   // Initialize the types shared by all compilations.
 227   static void Initialize_shared(Compile* compile);
 228 
 229   TYPES base() const {
 230     assert(_base &gt; Bad &amp;&amp; _base &lt; lastype, &quot;sanity&quot;);
 231     return _base;
 232   }
 233 
 234   // Create a new hash-consd type
 235   static const Type *make(enum TYPES);
 236   // Test for equivalence of types
 237   static int cmp( const Type *const t1, const Type *const t2 );
 238   // Test for higher or equal in lattice
 239   // Variant that drops the speculative part of the types
 240   bool higher_equal(const Type *t) const {
 241     return !cmp(meet(t),t-&gt;remove_speculative());
 242   }
 243   // Variant that keeps the speculative part of the types
 244   bool higher_equal_speculative(const Type *t) const {
 245     return !cmp(meet_speculative(t),t);
 246   }
 247 
 248   // MEET operation; lower in lattice.
 249   // Variant that drops the speculative part of the types
 250   const Type *meet(const Type *t) const {
 251     return meet_helper(t, false);
 252   }
 253   // Variant that keeps the speculative part of the types
 254   const Type *meet_speculative(const Type *t) const {
 255     return meet_helper(t, true)-&gt;cleanup_speculative();
 256   }
 257   // WIDEN: &#39;widens&#39; for Ints and other range types
 258   virtual const Type *widen( const Type *old, const Type* limit ) const { return this; }
 259   // NARROW: complement for widen, used by pessimistic phases
 260   virtual const Type *narrow( const Type *old ) const { return this; }
 261 
 262   // DUAL operation: reflect around lattice centerline.  Used instead of
 263   // join to ensure my lattice is symmetric up and down.
 264   const Type *dual() const { return _dual; }
 265 
 266   // Compute meet dependent on base type
 267   virtual const Type *xmeet( const Type *t ) const;
 268   virtual const Type *xdual() const;    // Compute dual right now.
 269 
 270   // JOIN operation; higher in lattice.  Done by finding the dual of the
 271   // meet of the dual of the 2 inputs.
 272   // Variant that drops the speculative part of the types
 273   const Type *join(const Type *t) const {
 274     return join_helper(t, false);
 275   }
 276   // Variant that keeps the speculative part of the types
 277   const Type *join_speculative(const Type *t) const {
 278     return join_helper(t, true)-&gt;cleanup_speculative();
 279   }
 280 
 281   // Modified version of JOIN adapted to the needs Node::Value.
 282   // Normalizes all empty values to TOP.  Does not kill _widen bits.
 283   // Currently, it also works around limitations involving interface types.
 284   // Variant that drops the speculative part of the types
 285   const Type *filter(const Type *kills) const {
 286     return filter_helper(kills, false);
 287   }
 288   // Variant that keeps the speculative part of the types
 289   const Type *filter_speculative(const Type *kills) const {
 290     return filter_helper(kills, true)-&gt;cleanup_speculative();
 291   }
 292 
 293 #ifdef ASSERT
 294   // One type is interface, the other is oop
 295   virtual bool interface_vs_oop(const Type *t) const;
 296 #endif
 297 
 298   // Returns true if this pointer points at memory which contains a
 299   // compressed oop references.
 300   bool is_ptr_to_narrowoop() const;
 301   bool is_ptr_to_narrowklass() const;
 302 
 303   // Convenience access
 304   float getf() const;
 305   double getd() const;
 306 
 307   const TypeInt    *is_int() const;
 308   const TypeInt    *isa_int() const;             // Returns NULL if not an Int
 309   const TypeLong   *is_long() const;
 310   const TypeLong   *isa_long() const;            // Returns NULL if not a Long
 311   const TypeD      *isa_double() const;          // Returns NULL if not a Double{Top,Con,Bot}
 312   const TypeD      *is_double_constant() const;  // Asserts it is a DoubleCon
 313   const TypeD      *isa_double_constant() const; // Returns NULL if not a DoubleCon
 314   const TypeF      *isa_float() const;           // Returns NULL if not a Float{Top,Con,Bot}
 315   const TypeF      *is_float_constant() const;   // Asserts it is a FloatCon
 316   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 317   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 318   const TypeAry    *is_ary() const;              // Array, NOT array pointer
 319   const TypeAry    *isa_ary() const;             // Returns NULL of not ary
 320   const TypeVect   *is_vect() const;             // Vector
 321   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 322   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 323   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 324   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 325   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 326   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 327   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 328   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 329   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 330   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 331   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 332   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 333   const TypeInstPtr  *is_instptr() const;        // Instance
 334   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 335   const TypeAryPtr   *is_aryptr() const;         // Array oop
 336   const TypeInlineType* isa_inlinetype() const;  // Returns NULL if not Inline Type
 337   const TypeInlineType* is_inlinetype() const;   // Inline Type
 338 
 339   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 340   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 341   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
 342   const TypeKlassPtr      *is_klassptr() const;       // assert if not KlassPtr
 343 
 344   virtual bool      is_finite() const;           // Has a finite value
 345   virtual bool      is_nan()    const;           // Is not a number (NaN)
 346 
 347   bool is_inlinetypeptr() const;
 348   virtual ciInlineKlass* inline_klass() const;
 349 
 350   // Returns this ptr type or the equivalent ptr type for this compressed pointer.
 351   const TypePtr* make_ptr() const;
 352 
 353   // Returns this oopptr type or the equivalent oopptr type for this compressed pointer.
 354   // Asserts if the underlying type is not an oopptr or narrowoop.
 355   const TypeOopPtr* make_oopptr() const;
 356 
 357   // Returns this compressed pointer or the equivalent compressed version
 358   // of this pointer type.
 359   const TypeNarrowOop* make_narrowoop() const;
 360 
 361   // Returns this compressed klass pointer or the equivalent
 362   // compressed version of this pointer type.
 363   const TypeNarrowKlass* make_narrowklass() const;
 364 
 365   // Special test for register pressure heuristic
 366   bool is_floatingpoint() const;        // True if Float or Double base type
 367 
 368   // Do you have memory, directly or through a tuple?
 369   bool has_memory( ) const;
 370 
 371   // TRUE if type is a singleton
 372   virtual bool singleton(void) const;
 373 
 374   // TRUE if type is above the lattice centerline, and is therefore vacuous
 375   virtual bool empty(void) const;
 376 
 377   // Return a hash for this type.  The hash function is public so ConNode
 378   // (constants) can hash on their constant, which is represented by a Type.
 379   virtual int hash() const;
 380 
 381   // Map ideal registers (machine types) to ideal types
 382   static const Type *mreg2type[];
 383 
 384   // Printing, statistics
 385 #ifndef PRODUCT
 386   void         dump_on(outputStream *st) const;
 387   void         dump() const {
 388     dump_on(tty);
 389   }
 390   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 391   static  void dump_stats();
 392 
 393   static const char* str(const Type* t);
 394 #endif
 395   void typerr(const Type *t) const; // Mixing types error
 396 
 397   // Create basic type
 398   static const Type* get_const_basic_type(BasicType type) {
 399     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _const_basic_type[type] != NULL, &quot;bad type&quot;);
 400     return _const_basic_type[type];
 401   }
 402 
 403   // For two instance arrays of same dimension, return the base element types.
 404   // Otherwise or if the arrays have different dimensions, return NULL.
 405   static void get_arrays_base_elements(const Type *a1, const Type *a2,
 406                                        const TypeInstPtr **e1, const TypeInstPtr **e2);
 407 
 408   // Mapping to the array element&#39;s basic type.
 409   BasicType array_element_basic_type() const;
 410 
 411   // Create standard type for a ciType:
 412   static const Type* get_const_type(ciType* type);
 413 
 414   // Create standard zero value:
 415   static const Type* get_zero_type(BasicType type) {
 416     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _zero_type[type] != NULL, &quot;bad type&quot;);
 417     return _zero_type[type];
 418   }
 419 
 420   // Report if this is a zero value (not top).
 421   bool is_zero_type() const {
 422     BasicType type = basic_type();
 423     if (type == T_VOID || type &gt;= T_CONFLICT)
 424       return false;
 425     else
 426       return (this == _zero_type[type]);
 427   }
 428 
 429   // Convenience common pre-built types.
 430   static const Type *ABIO;
 431   static const Type *BOTTOM;
 432   static const Type *CONTROL;
 433   static const Type *DOUBLE;
 434   static const Type *FLOAT;
 435   static const Type *HALF;
 436   static const Type *MEMORY;
 437   static const Type *MULTI;
 438   static const Type *RETURN_ADDRESS;
 439   static const Type *TOP;
 440 
 441   // Mapping from compiler type to VM BasicType
 442   BasicType basic_type() const       { return _type_info[_base].basic_type; }
 443   uint ideal_reg() const             { return _type_info[_base].ideal_reg; }
 444   const char* msg() const            { return _type_info[_base].msg; }
 445   bool isa_oop_ptr() const           { return _type_info[_base].isa_oop; }
 446   relocInfo::relocType reloc() const { return _type_info[_base].reloc; }
 447 
 448   // Mapping from CI type system to compiler type:
 449   static const Type* get_typeflow_type(ciType* type);
 450 
 451   static const Type* make_from_constant(ciConstant constant,
 452                                         bool require_constant = false,
 453                                         int stable_dimension = 0,
 454                                         bool is_narrow = false,
 455                                         bool is_autobox_cache = false);
 456 
 457   static const Type* make_constant_from_field(ciInstance* holder,
 458                                               int off,
 459                                               bool is_unsigned_load,
 460                                               BasicType loadbt);
 461 
 462   static const Type* make_constant_from_field(ciField* field,
 463                                               ciInstance* holder,
 464                                               BasicType loadbt,
 465                                               bool is_unsigned_load);
 466 
 467   static const Type* make_constant_from_array_element(ciArray* array,
 468                                                       int off,
 469                                                       int stable_dimension,
 470                                                       BasicType loadbt,
 471                                                       bool is_unsigned_load);
 472 
 473   // Speculative type helper methods. See TypePtr.
 474   virtual const TypePtr* speculative() const                                  { return NULL; }
 475   virtual ciKlass* speculative_type() const                                   { return NULL; }
 476   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 477   virtual bool speculative_maybe_null() const                                 { return true; }
 478   virtual bool speculative_always_null() const                                { return true; }
 479   virtual const Type* remove_speculative() const                              { return this; }
 480   virtual const Type* cleanup_speculative() const                             { return this; }
 481   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 482   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 483   const Type* maybe_remove_speculative(bool include_speculative) const;
 484 
 485   virtual bool maybe_null() const { return true; }
 486   virtual bool is_known_instance() const { return false; }
 487 
 488 private:
 489   // support arrays
 490   static const Type*        _zero_type[T_CONFLICT+1];
 491   static const Type* _const_basic_type[T_CONFLICT+1];
 492 };
 493 
 494 //------------------------------TypeF------------------------------------------
 495 // Class of Float-Constant Types.
 496 class TypeF : public Type {
 497   TypeF( float f ) : Type(FloatCon), _f(f) {};
 498 public:
 499   virtual bool eq( const Type *t ) const;
 500   virtual int  hash() const;             // Type specific hashing
 501   virtual bool singleton(void) const;    // TRUE if type is a singleton
 502   virtual bool empty(void) const;        // TRUE if type is vacuous
 503 public:
 504   const float _f;               // Float constant
 505 
 506   static const TypeF *make(float f);
 507 
 508   virtual bool        is_finite() const;  // Has a finite value
 509   virtual bool        is_nan()    const;  // Is not a number (NaN)
 510 
 511   virtual const Type *xmeet( const Type *t ) const;
 512   virtual const Type *xdual() const;    // Compute dual right now.
 513   // Convenience common pre-built types.
 514   static const TypeF *ZERO; // positive zero only
 515   static const TypeF *ONE;
 516   static const TypeF *POS_INF;
 517   static const TypeF *NEG_INF;
 518 #ifndef PRODUCT
 519   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 520 #endif
 521 };
 522 
 523 //------------------------------TypeD------------------------------------------
 524 // Class of Double-Constant Types.
 525 class TypeD : public Type {
 526   TypeD( double d ) : Type(DoubleCon), _d(d) {};
 527 public:
 528   virtual bool eq( const Type *t ) const;
 529   virtual int  hash() const;             // Type specific hashing
 530   virtual bool singleton(void) const;    // TRUE if type is a singleton
 531   virtual bool empty(void) const;        // TRUE if type is vacuous
 532 public:
 533   const double _d;              // Double constant
 534 
 535   static const TypeD *make(double d);
 536 
 537   virtual bool        is_finite() const;  // Has a finite value
 538   virtual bool        is_nan()    const;  // Is not a number (NaN)
 539 
 540   virtual const Type *xmeet( const Type *t ) const;
 541   virtual const Type *xdual() const;    // Compute dual right now.
 542   // Convenience common pre-built types.
 543   static const TypeD *ZERO; // positive zero only
 544   static const TypeD *ONE;
 545   static const TypeD *POS_INF;
 546   static const TypeD *NEG_INF;
 547 #ifndef PRODUCT
 548   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 549 #endif
 550 };
 551 
 552 //------------------------------TypeInt----------------------------------------
 553 // Class of integer ranges, the set of integers between a lower bound and an
 554 // upper bound, inclusive.
 555 class TypeInt : public Type {
 556   TypeInt( jint lo, jint hi, int w );
 557 protected:
 558   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 559 
 560 public:
 561   typedef jint NativeType;
 562   virtual bool eq( const Type *t ) const;
 563   virtual int  hash() const;             // Type specific hashing
 564   virtual bool singleton(void) const;    // TRUE if type is a singleton
 565   virtual bool empty(void) const;        // TRUE if type is vacuous
 566   const jint _lo, _hi;          // Lower bound, upper bound
 567   const short _widen;           // Limit on times we widen this sucker
 568 
 569   static const TypeInt *make(jint lo);
 570   // must always specify w
 571   static const TypeInt *make(jint lo, jint hi, int w);
 572 
 573   // Check for single integer
 574   int is_con() const { return _lo==_hi; }
 575   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 576   jint get_con() const { assert( is_con(), &quot;&quot; );  return _lo; }
 577 
 578   virtual bool        is_finite() const;  // Has a finite value
 579 
 580   virtual const Type *xmeet( const Type *t ) const;
 581   virtual const Type *xdual() const;    // Compute dual right now.
 582   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 583   virtual const Type *narrow( const Type *t ) const;
 584   // Do not kill _widen bits.
 585   // Convenience common pre-built types.
 586   static const TypeInt *MINUS_1;
 587   static const TypeInt *ZERO;
 588   static const TypeInt *ONE;
 589   static const TypeInt *BOOL;
 590   static const TypeInt *CC;
 591   static const TypeInt *CC_LT;  // [-1]  == MINUS_1
 592   static const TypeInt *CC_GT;  // [1]   == ONE
 593   static const TypeInt *CC_EQ;  // [0]   == ZERO
 594   static const TypeInt *CC_LE;  // [-1,0]
 595   static const TypeInt *CC_GE;  // [0,1] == BOOL (!)
 596   static const TypeInt *BYTE;
 597   static const TypeInt *UBYTE;
 598   static const TypeInt *CHAR;
 599   static const TypeInt *SHORT;
 600   static const TypeInt *POS;
 601   static const TypeInt *POS1;
 602   static const TypeInt *INT;
 603   static const TypeInt *SYMINT; // symmetric range [-max_jint..max_jint]
 604   static const TypeInt *TYPE_DOMAIN; // alias for TypeInt::INT
 605 
 606   static const TypeInt *as_self(const Type *t) { return t-&gt;is_int(); }
 607 #ifndef PRODUCT
 608   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 609 #endif
 610 };
 611 
 612 
 613 //------------------------------TypeLong---------------------------------------
 614 // Class of long integer ranges, the set of integers between a lower bound and
 615 // an upper bound, inclusive.
 616 class TypeLong : public Type {
 617   TypeLong( jlong lo, jlong hi, int w );
 618 protected:
 619   // Do not kill _widen bits.
 620   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 621 public:
 622   typedef jlong NativeType;
 623   virtual bool eq( const Type *t ) const;
 624   virtual int  hash() const;             // Type specific hashing
 625   virtual bool singleton(void) const;    // TRUE if type is a singleton
 626   virtual bool empty(void) const;        // TRUE if type is vacuous
 627 public:
 628   const jlong _lo, _hi;         // Lower bound, upper bound
 629   const short _widen;           // Limit on times we widen this sucker
 630 
 631   static const TypeLong *make(jlong lo);
 632   // must always specify w
 633   static const TypeLong *make(jlong lo, jlong hi, int w);
 634 
 635   // Check for single integer
 636   int is_con() const { return _lo==_hi; }
 637   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 638   jlong get_con() const { assert( is_con(), &quot;&quot; ); return _lo; }
 639 
 640   // Check for positive 32-bit value.
 641   int is_positive_int() const { return _lo &gt;= 0 &amp;&amp; _hi &lt;= (jlong)max_jint; }
 642 
 643   virtual bool        is_finite() const;  // Has a finite value
 644 
 645 
 646   virtual const Type *xmeet( const Type *t ) const;
 647   virtual const Type *xdual() const;    // Compute dual right now.
 648   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 649   virtual const Type *narrow( const Type *t ) const;
 650   // Convenience common pre-built types.
 651   static const TypeLong *MINUS_1;
 652   static const TypeLong *ZERO;
 653   static const TypeLong *ONE;
 654   static const TypeLong *POS;
 655   static const TypeLong *LONG;
 656   static const TypeLong *INT;    // 32-bit subrange [min_jint..max_jint]
 657   static const TypeLong *UINT;   // 32-bit unsigned [0..max_juint]
 658   static const TypeLong *TYPE_DOMAIN; // alias for TypeLong::LONG
 659 
 660   // static convenience methods.
 661   static const TypeLong *as_self(const Type *t) { return t-&gt;is_long(); }
 662 
 663 #ifndef PRODUCT
 664   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const;// Specialized per-Type dumping
 665 #endif
 666 };
 667 
 668 //------------------------------TypeTuple--------------------------------------
 669 // Class of Tuple Types, essentially type collections for function signatures
 670 // and class layouts.  It happens to also be a fast cache for the HotSpot
 671 // signature types.
 672 class TypeTuple : public Type {
 673   TypeTuple( uint cnt, const Type **fields ) : Type(Tuple), _cnt(cnt), _fields(fields) { }
 674 
 675   const uint          _cnt;              // Count of fields
 676   const Type ** const _fields;           // Array of field types
 677 
 678 public:
 679   virtual bool eq( const Type *t ) const;
 680   virtual int  hash() const;             // Type specific hashing
 681   virtual bool singleton(void) const;    // TRUE if type is a singleton
 682   virtual bool empty(void) const;        // TRUE if type is vacuous
 683 
 684   // Accessors:
 685   uint cnt() const { return _cnt; }
 686   const Type* field_at(uint i) const {
 687     assert(i &lt; _cnt, &quot;oob&quot;);
 688     return _fields[i];
 689   }
 690   void set_field_at(uint i, const Type* t) {
 691     assert(i &lt; _cnt, &quot;oob&quot;);
 692     _fields[i] = t;
 693   }
 694 
 695   static const TypeTuple *make( uint cnt, const Type **fields );
 696   static const TypeTuple *make_range(ciSignature* sig, bool ret_vt_fields = false);
 697   static const TypeTuple *make_domain(ciMethod* method, bool vt_fields_as_args = false);
 698 
 699   // Subroutine call type with space allocated for argument types
 700   // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
 701   static const Type **fields( uint arg_cnt );
 702 
 703   virtual const Type *xmeet( const Type *t ) const;
 704   virtual const Type *xdual() const;    // Compute dual right now.
 705   // Convenience common pre-built types.
 706   static const TypeTuple *IFBOTH;
 707   static const TypeTuple *IFFALSE;
 708   static const TypeTuple *IFTRUE;
 709   static const TypeTuple *IFNEITHER;
 710   static const TypeTuple *LOOPBODY;
 711   static const TypeTuple *MEMBAR;
 712   static const TypeTuple *STORECONDITIONAL;
 713   static const TypeTuple *START_I2C;
 714   static const TypeTuple *INT_PAIR;
 715   static const TypeTuple *LONG_PAIR;
 716   static const TypeTuple *INT_CC_PAIR;
 717   static const TypeTuple *LONG_CC_PAIR;
 718 #ifndef PRODUCT
 719   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 720 #endif
 721 };
 722 
 723 //------------------------------TypeAry----------------------------------------
 724 // Class of Array Types
 725 class TypeAry : public Type {
 726   TypeAry(const Type* elem, const TypeInt* size, bool stable, bool not_flat, bool not_null_free) : Type(Array),
 727       _elem(elem), _size(size), _stable(stable), _not_flat(not_flat), _not_null_free(not_null_free) {}
 728 public:
 729   virtual bool eq( const Type *t ) const;
 730   virtual int  hash() const;             // Type specific hashing
 731   virtual bool singleton(void) const;    // TRUE if type is a singleton
 732   virtual bool empty(void) const;        // TRUE if type is vacuous
 733 
 734 private:
 735   const Type *_elem;            // Element type of array
 736   const TypeInt *_size;         // Elements in array
 737   const bool _stable;           // Are elements @Stable?
 738 
 739   // Inline type array properties
 740   const bool _not_flat;         // Array is never flattened
 741   const bool _not_null_free;    // Array is never null-free
 742 
 743   friend class TypeAryPtr;
 744 
 745 public:
 746   static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false,
 747                              bool not_flat = false, bool not_null_free = false);
 748 
 749   virtual const Type *xmeet( const Type *t ) const;
 750   virtual const Type *xdual() const;    // Compute dual right now.
 751   bool ary_must_be_exact() const;  // true if arrays of such are never generic
 752   virtual const Type* remove_speculative() const;
 753   virtual const Type* cleanup_speculative() const;
 754 
 755 #ifdef ASSERT
 756   // One type is interface, the other is oop
 757   virtual bool interface_vs_oop(const Type *t) const;
 758 #endif
 759 #ifndef PRODUCT
 760   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 761 #endif
 762 };
 763 
 764 
 765 //------------------------------TypeValue---------------------------------------
 766 // Class of Inline Type Types
 767 class TypeInlineType : public Type {
 768 private:
 769   ciInlineKlass* _vk;
 770   bool _larval;
 771 
 772 protected:
 773   TypeInlineType(ciInlineKlass* vk, bool larval)
 774     : Type(InlineType),
 775       _vk(vk), _larval(larval) {
 776   }
 777 
 778 public:
 779   static const TypeInlineType* make(ciInlineKlass* vk, bool larval = false);
 780   virtual ciInlineKlass* inline_klass() const { return _vk; }
 781   bool larval() const { return _larval; }
 782 
 783   virtual bool eq(const Type* t) const;
 784   virtual int  hash() const;             // Type specific hashing
 785   virtual bool singleton(void) const;    // TRUE if type is a singleton
 786   virtual bool empty(void) const;        // TRUE if type is vacuous
 787 
 788   virtual const Type* xmeet(const Type* t) const;
 789   virtual const Type* xdual() const;     // Compute dual right now.
 790 
 791   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return false; }
 792   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return false; }
 793 
 794   static const TypeInlineType* BOTTOM;
 795 
 796 #ifndef PRODUCT
 797   virtual void dump2(Dict &amp;d, uint, outputStream* st) const; // Specialized per-Type dumping
 798 #endif
 799 };
 800 
 801 //------------------------------TypeVect---------------------------------------
 802 // Class of Vector Types
 803 class TypeVect : public Type {
 804   const Type*   _elem;  // Vector&#39;s element type
 805   const uint  _length;  // Elements in vector (power of 2)
 806 
 807 protected:
 808   TypeVect(TYPES t, const Type* elem, uint length) : Type(t),
 809     _elem(elem), _length(length) {}
 810 
 811 public:
 812   const Type* element_type() const { return _elem; }
 813   BasicType element_basic_type() const { return _elem-&gt;array_element_basic_type(); }
 814   uint length() const { return _length; }
 815   uint length_in_bytes() const {
 816    return _length * type2aelembytes(element_basic_type());
 817   }
 818 
 819   virtual bool eq(const Type *t) const;
 820   virtual int  hash() const;             // Type specific hashing
 821   virtual bool singleton(void) const;    // TRUE if type is a singleton
 822   virtual bool empty(void) const;        // TRUE if type is vacuous
 823 
 824   static const TypeVect *make(const BasicType elem_bt, uint length) {
 825     // Use bottom primitive type.
 826     return make(get_const_basic_type(elem_bt), length);
 827   }
 828   // Used directly by Replicate nodes to construct singleton vector.
 829   static const TypeVect *make(const Type* elem, uint length);
 830 
 831   virtual const Type *xmeet( const Type *t) const;
 832   virtual const Type *xdual() const;     // Compute dual right now.
 833 
 834   static const TypeVect *VECTS;
 835   static const TypeVect *VECTD;
 836   static const TypeVect *VECTX;
 837   static const TypeVect *VECTY;
 838   static const TypeVect *VECTZ;
 839 
 840 #ifndef PRODUCT
 841   virtual void dump2(Dict &amp;d, uint, outputStream *st) const; // Specialized per-Type dumping
 842 #endif
 843 };
 844 
 845 class TypeVectS : public TypeVect {
 846   friend class TypeVect;
 847   TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}
 848 };
 849 
 850 class TypeVectD : public TypeVect {
 851   friend class TypeVect;
 852   TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}
 853 };
 854 
 855 class TypeVectX : public TypeVect {
 856   friend class TypeVect;
 857   TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}
 858 };
 859 
 860 class TypeVectY : public TypeVect {
 861   friend class TypeVect;
 862   TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}
 863 };
 864 
 865 class TypeVectZ : public TypeVect {
 866   friend class TypeVect;
 867   TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}
 868 };
 869 
 870 //------------------------------TypePtr----------------------------------------
 871 // Class of machine Pointer Types: raw data, instances or arrays.
 872 // If the _base enum is AnyPtr, then this refers to all of the above.
 873 // Otherwise the _base will indicate which subset of pointers is affected,
 874 // and the class will be inherited from.
 875 class TypePtr : public Type {
 876   friend class TypeNarrowPtr;
 877 public:
 878   enum PTR { TopPTR, AnyNull, Constant, Null, NotNull, BotPTR, lastPTR };
 879 protected:
 880   TypePtr(TYPES t, PTR ptr, Offset offset,
 881           const TypePtr* speculative = NULL,
 882           int inline_depth = InlineDepthBottom) :
 883     Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset),
 884     _ptr(ptr) {}
 885   static const PTR ptr_meet[lastPTR][lastPTR];
 886   static const PTR ptr_dual[lastPTR];
 887   static const char * const ptr_msg[lastPTR];
 888 
 889   enum {
 890     InlineDepthBottom = INT_MAX,
 891     InlineDepthTop = -InlineDepthBottom
 892   };
 893 
 894   // Extra type information profiling gave us. We propagate it the
 895   // same way the rest of the type info is propagated. If we want to
 896   // use it, then we have to emit a guard: this part of the type is
 897   // not something we know but something we speculate about the type.
 898   const TypePtr*   _speculative;
 899   // For speculative types, we record at what inlining depth the
 900   // profiling point that provided the data is. We want to favor
 901   // profile data coming from outer scopes which are likely better for
 902   // the current compilation.
 903   int _inline_depth;
 904 
 905   // utility methods to work on the speculative part of the type
 906   const TypePtr* dual_speculative() const;
 907   const TypePtr* xmeet_speculative(const TypePtr* other) const;
 908   bool eq_speculative(const TypePtr* other) const;
 909   int hash_speculative() const;
 910   const TypePtr* add_offset_speculative(intptr_t offset) const;
 911 #ifndef PRODUCT
 912   void dump_speculative(outputStream *st) const;
 913 #endif
 914 
 915   // utility methods to work on the inline depth of the type
 916   int dual_inline_depth() const;
 917   int meet_inline_depth(int depth) const;
 918 #ifndef PRODUCT
 919   void dump_inline_depth(outputStream *st) const;
 920 #endif
 921 
 922 public:
 923   const Offset _offset;         // Offset into oop, with TOP &amp; BOT
 924   const PTR _ptr;               // Pointer equivalence class
 925 
 926   const int offset() const { return _offset.get(); }
 927   const PTR ptr()    const { return _ptr; }
 928 
 929   static const TypePtr* make(TYPES t, PTR ptr, Offset offset,
 930                              const TypePtr* speculative = NULL,
 931                              int inline_depth = InlineDepthBottom);
 932 
 933   // Return a &#39;ptr&#39; version of this type
 934   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 935 
 936   virtual intptr_t get_con() const;
 937 
 938   Offset xadd_offset(intptr_t offset) const;
 939   virtual const TypePtr *add_offset( intptr_t offset ) const;
 940   virtual const int flattened_offset() const { return offset(); }
 941 
 942   virtual bool eq(const Type *t) const;
 943   virtual int  hash() const;             // Type specific hashing
 944 
 945   virtual bool singleton(void) const;    // TRUE if type is a singleton
 946   virtual bool empty(void) const;        // TRUE if type is vacuous
 947   virtual const Type *xmeet( const Type *t ) const;
 948   virtual const Type *xmeet_helper( const Type *t ) const;
 949   Offset meet_offset(int offset) const;
 950   Offset dual_offset() const;
 951   virtual const Type *xdual() const;    // Compute dual right now.
 952 
 953   // meet, dual and join over pointer equivalence sets
 954   PTR meet_ptr( const PTR in_ptr ) const { return ptr_meet[in_ptr][ptr()]; }
 955   PTR dual_ptr()                   const { return ptr_dual[ptr()];      }
 956 
 957   // This is textually confusing unless one recalls that
 958   // join(t) == dual()-&gt;meet(t-&gt;dual())-&gt;dual().
 959   PTR join_ptr( const PTR in_ptr ) const {
 960     return ptr_dual[ ptr_meet[ ptr_dual[in_ptr] ] [ dual_ptr() ] ];
 961   }
 962 
 963   // Speculative type helper methods.
 964   virtual const TypePtr* speculative() const { return _speculative; }
 965   int inline_depth() const                   { return _inline_depth; }
 966   virtual ciKlass* speculative_type() const;
 967   virtual ciKlass* speculative_type_not_null() const;
 968   virtual bool speculative_maybe_null() const;
 969   virtual bool speculative_always_null() const;
 970   virtual const Type* remove_speculative() const;
 971   virtual const Type* cleanup_speculative() const;
 972   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
 973   virtual bool would_improve_ptr(ProfilePtrKind maybe_null) const;
 974   virtual const TypePtr* with_inline_depth(int depth) const;
 975 
 976   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 977 
 978   virtual bool can_be_inline_type() const { return false; }
 979   virtual bool flat_array() const { return false; }
 980 
 981   // Tests for relation to centerline of type lattice:
 982   static bool above_centerline(PTR ptr) { return (ptr &lt;= AnyNull); }
 983   static bool below_centerline(PTR ptr) { return (ptr &gt;= NotNull); }
 984   // Convenience common pre-built types.
 985   static const TypePtr *NULL_PTR;
 986   static const TypePtr *NOTNULL;
 987   static const TypePtr *BOTTOM;
 988 #ifndef PRODUCT
 989   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 990 #endif
 991 };
 992 
 993 //------------------------------TypeRawPtr-------------------------------------
 994 // Class of raw pointers, pointers to things other than Oops.  Examples
 995 // include the stack pointer, top of heap, card-marking area, handles, etc.
 996 class TypeRawPtr : public TypePtr {
 997 protected:
 998   TypeRawPtr(PTR ptr, address bits) : TypePtr(RawPtr,ptr,Offset(0)), _bits(bits){}
 999 public:
1000   virtual bool eq( const Type *t ) const;
1001   virtual int  hash() const;     // Type specific hashing
1002 
1003   const address _bits;          // Constant value, if applicable
1004 
1005   static const TypeRawPtr *make( PTR ptr );
1006   static const TypeRawPtr *make( address bits );
1007 
1008   // Return a &#39;ptr&#39; version of this type
1009   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1010 
1011   virtual intptr_t get_con() const;
1012 
1013   virtual const TypePtr *add_offset( intptr_t offset ) const;
1014 
1015   virtual const Type *xmeet( const Type *t ) const;
1016   virtual const Type *xdual() const;    // Compute dual right now.
1017   // Convenience common pre-built types.
1018   static const TypeRawPtr *BOTTOM;
1019   static const TypeRawPtr *NOTNULL;
1020 #ifndef PRODUCT
1021   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
1022 #endif
1023 };
1024 
1025 //------------------------------TypeOopPtr-------------------------------------
1026 // Some kind of oop (Java pointer), either instance or array.
1027 class TypeOopPtr : public TypePtr {
1028 protected:
1029   TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,
1030              int instance_id, const TypePtr* speculative, int inline_depth);
1031 public:
1032   virtual bool eq( const Type *t ) const;
1033   virtual int  hash() const;             // Type specific hashing
1034   virtual bool singleton(void) const;    // TRUE if type is a singleton
1035   enum {
1036    InstanceTop = -1,   // undefined instance
1037    InstanceBot = 0     // any possible instance
1038   };
1039 protected:
1040 
1041   // Oop is NULL, unless this is a constant oop.
1042   ciObject*     _const_oop;   // Constant oop
1043   // If _klass is NULL, then so is _sig.  This is an unloaded klass.
1044   ciKlass*      _klass;       // Klass object
1045   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1046   bool          _klass_is_exact;
1047   bool          _is_ptr_to_narrowoop;
1048   bool          _is_ptr_to_narrowklass;
1049   bool          _is_ptr_to_boxed_value;
1050 
1051   // If not InstanceTop or InstanceBot, indicates that this is
1052   // a particular instance of this type which is distinct.
1053   // This is the node index of the allocation node creating this instance.
1054   int           _instance_id;
1055 
1056   static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
1057 
1058   int dual_instance_id() const;
1059   int meet_instance_id(int uid) const;
1060 
1061   // Do not allow interface-vs.-noninterface joins to collapse to top.
1062   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1063 
1064 public:
1065   // Creates a type given a klass. Correctly handles multi-dimensional arrays
1066   // Respects UseUniqueSubclasses.
1067   // If the klass is final, the resulting type will be exact.
1068   static const TypeOopPtr* make_from_klass(ciKlass* klass) {
1069     return make_from_klass_common(klass, true, false);
1070   }
1071   // Same as before, but will produce an exact type, even if
1072   // the klass is not final, as long as it has exactly one implementation.
1073   static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {
1074     return make_from_klass_common(klass, true, true);
1075   }
1076   // Same as before, but does not respects UseUniqueSubclasses.
1077   // Use this only for creating array element types.
1078   static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {
1079     return make_from_klass_common(klass, false, false);
1080   }
1081   // Creates a singleton type given an object.
1082   // If the object cannot be rendered as a constant,
1083   // may return a non-singleton type.
1084   // If require_constant, produce a NULL if a singleton is not possible.
1085   static const TypeOopPtr* make_from_constant(ciObject* o,
1086                                               bool require_constant = false);
1087 
1088   // Make a generic (unclassed) pointer to an oop.
1089   static const TypeOopPtr* make(PTR ptr, Offset offset, int instance_id,
1090                                 const TypePtr* speculative = NULL,
1091                                 int inline_depth = InlineDepthBottom);
1092 
1093   ciObject* const_oop()    const { return _const_oop; }
1094   virtual ciKlass* klass() const { return _klass;     }
1095   bool klass_is_exact()    const { return _klass_is_exact; }
1096 
1097   // Returns true if this pointer points at memory which contains a
1098   // compressed oop references.
1099   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1100   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1101   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1102   bool is_known_instance()       const { return _instance_id &gt; 0; }
1103   int  instance_id()             const { return _instance_id; }
1104   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset.get() &gt;= 0; }
1105 
1106   virtual bool can_be_inline_type() const { return EnableValhalla &amp;&amp; (_klass == NULL || _klass-&gt;can_be_inline_klass(_klass_is_exact)); }
1107 
1108   virtual intptr_t get_con() const;
1109 
1110   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1111 
1112   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1113 
1114   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1115 
1116   // corresponding pointer to klass, for a given instance
1117   const TypeKlassPtr* as_klass_type() const;
1118 
1119   virtual const TypePtr *add_offset( intptr_t offset ) const;
1120 
1121   // Speculative type helper methods.
1122   virtual const Type* remove_speculative() const;
1123   virtual const Type* cleanup_speculative() const;
1124   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1125   virtual const TypePtr* with_inline_depth(int depth) const;
1126 
1127   virtual const TypePtr* with_instance_id(int instance_id) const;
1128 
1129   virtual const Type *xdual() const;    // Compute dual right now.
1130   // the core of the computation of the meet for TypeOopPtr and for its subclasses
1131   virtual const Type *xmeet_helper(const Type *t) const;
1132 
1133   // Convenience common pre-built type.
1134   static const TypeOopPtr *BOTTOM;
1135 #ifndef PRODUCT
1136   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1137 #endif
1138 };
1139 
1140 //------------------------------TypeInstPtr------------------------------------
1141 // Class of Java object pointers, pointing either to non-array Java instances
1142 // or to a Klass* (including array klasses).
1143 class TypeInstPtr : public TypeOopPtr {
1144   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1145               bool is_value, int instance_id, const TypePtr* speculative,
1146               int inline_depth);
1147   virtual bool eq( const Type *t ) const;
1148   virtual int  hash() const;             // Type specific hashing
1149 
1150   ciSymbol*  _name;        // class name
1151   bool _flat_array;
1152 
1153  public:
1154   ciSymbol* name()         const { return _name; }
1155 
1156   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1157 
1158   // Make a pointer to a constant oop.
1159   static const TypeInstPtr *make(ciObject* o) {
1160     return make(TypePtr::Constant, o-&gt;klass(), true, o, Offset(0), o-&gt;klass()-&gt;is_inlinetype() &amp;&amp; o-&gt;klass()-&gt;as_inline_klass()-&gt;flatten_array(), InstanceBot);
1161   }
1162   // Make a pointer to a constant oop with offset.
1163   static const TypeInstPtr* make(ciObject* o, Offset offset) {
1164     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset, o-&gt;klass()-&gt;is_inlinetype() &amp;&amp; o-&gt;klass()-&gt;as_inline_klass()-&gt;flatten_array(), InstanceBot);
1165   }
1166 
1167   // Make a pointer to some value of type klass.
1168   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
1169     return make(ptr, klass, false, NULL, Offset(0), klass-&gt;is_inlinetype() &amp;&amp; klass-&gt;as_inline_klass()-&gt;flatten_array(), InstanceBot);
1170   }
1171 
1172   // Make a pointer to some non-polymorphic value of exactly type klass.
1173   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
1174     return make(ptr, klass, true, NULL, Offset(0), klass-&gt;is_inlinetype() &amp;&amp; klass-&gt;as_inline_klass()-&gt;flatten_array(), InstanceBot);
1175   }
1176 
1177   // Make a pointer to some value of type klass with offset.
1178   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, Offset offset) {
1179     return make(ptr, klass, false, NULL, offset, klass-&gt;is_inlinetype() &amp;&amp; klass-&gt;as_inline_klass()-&gt;flatten_array(), InstanceBot);
1180   }
1181 
1182   // Make a pointer to an oop.
1183   static const TypeInstPtr* make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1184                                  bool flat_array,
1185                                  int instance_id = InstanceBot,
1186                                  const TypePtr* speculative = NULL,
1187                                  int inline_depth = InlineDepthBottom);
1188 
1189   /** Create constant type for a constant boxed value */
1190   const Type* get_const_boxed_value() const;
1191 
1192   // If this is a java.lang.Class constant, return the type for it or NULL.
1193   // Pass to Type::get_const_type to turn it to a type, which will usually
1194   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1195   ciType* java_mirror_type() const;
1196 
1197   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1198 
1199   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1200 
1201   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1202 
1203   virtual const TypePtr *add_offset( intptr_t offset ) const;
1204 
1205   // Speculative type helper methods.
1206   virtual const Type* remove_speculative() const;
1207   virtual const TypePtr* with_inline_depth(int depth) const;
1208   virtual const TypePtr* with_instance_id(int instance_id) const;
1209 
1210   virtual const TypeInstPtr* cast_to_flat_array() const;
1211   virtual bool flat_array() const {
1212     assert(!klass()-&gt;is_inlinetype() || !klass()-&gt;as_inline_klass()-&gt;flatten_array() || _flat_array, &quot;incorrect value bit&quot;);
1213     assert(!_flat_array || can_be_inline_type(), &quot;incorrect value bit&quot;);
1214     return _flat_array;
1215   }
1216 
1217   // the core of the computation of the meet of 2 types
1218   virtual const Type *xmeet_helper(const Type *t) const;
1219   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1220   virtual const Type *xdual() const;    // Compute dual right now.
1221 
1222   // Convenience common pre-built types.
1223   static const TypeInstPtr *NOTNULL;
1224   static const TypeInstPtr *BOTTOM;
1225   static const TypeInstPtr *MIRROR;
1226   static const TypeInstPtr *MARK;
1227   static const TypeInstPtr *KLASS;
1228 #ifndef PRODUCT
1229   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1230 #endif
1231 };
1232 
1233 //------------------------------TypeAryPtr-------------------------------------
1234 // Class of Java array pointers
1235 class TypeAryPtr : public TypeOopPtr {
1236   TypeAryPtr(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk,
1237              Offset offset, Offset field_offset, int instance_id, bool is_autobox_cache,
1238              const TypePtr* speculative, int inline_depth)
1239     : TypeOopPtr(AryPtr, ptr, k, xk, o, offset, field_offset, instance_id, speculative, inline_depth),
1240     _ary(ary),
1241     _is_autobox_cache(is_autobox_cache),
1242     _field_offset(field_offset)
1243  {
1244 #ifdef ASSERT
1245     if (k != NULL) {
1246       // Verify that specified klass and TypeAryPtr::klass() follow the same rules.
1247       ciKlass* ck = compute_klass(true);
1248       if (k != ck) {
1249         this-&gt;dump(); tty-&gt;cr();
1250         tty-&gt;print(&quot; k: &quot;);
1251         k-&gt;print(); tty-&gt;cr();
1252         tty-&gt;print(&quot;ck: &quot;);
1253         if (ck != NULL) ck-&gt;print();
1254         else tty-&gt;print(&quot;&lt;NULL&gt;&quot;);
1255         tty-&gt;cr();
1256         assert(false, &quot;unexpected TypeAryPtr::_klass&quot;);
1257       }
1258     }
1259 #endif
1260   }
1261   virtual bool eq( const Type *t ) const;
1262   virtual int hash() const;     // Type specific hashing
1263   const TypeAry *_ary;          // Array we point into
1264   const bool     _is_autobox_cache;
1265   // For flattened inline type arrays, each field of the inline type in
1266   // the array has its own memory slice so we need to keep track of
1267   // which field is accessed
1268   const Offset _field_offset;
1269   Offset meet_field_offset(const Type::Offset offset) const;
1270   Offset dual_field_offset() const;
1271 
1272   ciKlass* compute_klass(DEBUG_ONLY(bool verify = false)) const;
1273 
1274 public:
1275   // Accessors
1276   ciKlass* klass() const;
1277   const TypeAry* ary() const  { return _ary; }
1278   const Type*    elem() const { return _ary-&gt;_elem; }
1279   const TypeInt* size() const { return _ary-&gt;_size; }
1280   bool      is_stable() const { return _ary-&gt;_stable; }
1281 
1282   // Inline type array properties
1283   bool is_not_flat()      const { return _ary-&gt;_not_flat; }
1284   bool is_not_null_free() const { return _ary-&gt;_not_null_free; }
1285 
1286   bool is_autobox_cache() const { return _is_autobox_cache; }
1287 
1288   static const TypeAryPtr* make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
1289                                 Offset field_offset = Offset::bottom,
1290                                 int instance_id = InstanceBot,
1291                                 const TypePtr* speculative = NULL,
1292                                 int inline_depth = InlineDepthBottom);
1293   // Constant pointer to array
1294   static const TypeAryPtr* make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
1295                                 Offset field_offset = Offset::bottom,
1296                                 int instance_id = InstanceBot,
1297                                 const TypePtr* speculative = NULL,
1298                                 int inline_depth = InlineDepthBottom,
1299                                 bool is_autobox_cache = false);
1300 
1301   // Return a &#39;ptr&#39; version of this type
1302   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1303 
1304   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1305 
1306   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1307 
1308   virtual const TypeAryPtr* cast_to_size(const TypeInt* size) const;
1309   virtual const TypeInt* narrow_size_type(const TypeInt* size) const;
1310 
1311   virtual bool empty(void) const;        // TRUE if type is vacuous
1312   virtual const TypePtr *add_offset( intptr_t offset ) const;
1313 
1314   // Speculative type helper methods.
1315   virtual const Type* remove_speculative() const;
1316   virtual const Type* cleanup_speculative() const;
1317   virtual const TypePtr* with_inline_depth(int depth) const;
1318   virtual const TypePtr* with_instance_id(int instance_id) const;
1319 
1320   // the core of the computation of the meet of 2 types
1321   virtual const Type *xmeet_helper(const Type *t) const;
1322   virtual const Type *xdual() const;    // Compute dual right now.
1323 
1324   const TypeAryPtr* cast_to_not_flat(bool not_flat = true) const;
1325   const TypeAryPtr* cast_to_not_null_free(bool not_null_free = true) const;
1326 
1327   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1328   int stable_dimension() const;
1329 
1330   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1331 
1332   static jint max_array_length(BasicType etype);
1333 
1334   const int flattened_offset() const;
1335   const Offset field_offset() const { return _field_offset; }
1336   const TypeAryPtr* with_field_offset(int offset) const;
1337   const TypePtr* add_field_offset_and_offset(intptr_t offset) const;
1338 
1339   virtual bool can_be_inline_type() const { return false; }
1340 
1341   // Convenience common pre-built types.
1342   static const TypeAryPtr *RANGE;
1343   static const TypeAryPtr *OOPS;
1344   static const TypeAryPtr *NARROWOOPS;
1345   static const TypeAryPtr *BYTES;
1346   static const TypeAryPtr *SHORTS;
1347   static const TypeAryPtr *CHARS;
1348   static const TypeAryPtr *INTS;
1349   static const TypeAryPtr *LONGS;
1350   static const TypeAryPtr *FLOATS;
1351   static const TypeAryPtr *DOUBLES;
1352   static const TypeAryPtr *INLINES;
1353   // selects one of the above:
1354   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1355     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1356     return _array_body_type[elem];
1357   }
1358   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1359   // sharpen the type of an int which is used as an array size
1360 #ifdef ASSERT
1361   // One type is interface, the other is oop
1362   virtual bool interface_vs_oop(const Type *t) const;
1363 #endif
1364 #ifndef PRODUCT
1365   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1366 #endif
1367 };
1368 
1369 //------------------------------TypeMetadataPtr-------------------------------------
1370 // Some kind of metadata, either Method*, MethodData* or CPCacheOop
1371 class TypeMetadataPtr : public TypePtr {
1372 protected:
1373   TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset);
1374   // Do not allow interface-vs.-noninterface joins to collapse to top.
1375   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1376 public:
1377   virtual bool eq( const Type *t ) const;
1378   virtual int  hash() const;             // Type specific hashing
1379   virtual bool singleton(void) const;    // TRUE if type is a singleton
1380 
1381 private:
1382   ciMetadata*   _metadata;
1383 
1384 public:
1385   static const TypeMetadataPtr* make(PTR ptr, ciMetadata* m, Offset offset);
1386 
1387   static const TypeMetadataPtr* make(ciMethod* m);
1388   static const TypeMetadataPtr* make(ciMethodData* m);
1389 
1390   ciMetadata* metadata() const { return _metadata; }
1391 
1392   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1393 
1394   virtual const TypePtr *add_offset( intptr_t offset ) const;
1395 
1396   virtual const Type *xmeet( const Type *t ) const;
1397   virtual const Type *xdual() const;    // Compute dual right now.
1398 
1399   virtual intptr_t get_con() const;
1400 
1401   // Convenience common pre-built types.
1402   static const TypeMetadataPtr *BOTTOM;
1403 
1404 #ifndef PRODUCT
1405   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1406 #endif
1407 };
1408 
1409 //------------------------------TypeKlassPtr-----------------------------------
1410 // Class of Java Klass pointers
1411 class TypeKlassPtr : public TypePtr {
1412   TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array);
1413 
1414 protected:
1415   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1416  public:
1417   virtual bool eq( const Type *t ) const;
1418   virtual int hash() const;             // Type specific hashing
1419   virtual bool singleton(void) const;    // TRUE if type is a singleton
1420  private:
1421 
1422   ciKlass* _klass;
1423 
1424   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1425   bool          _klass_is_exact;
1426   bool _flat_array;
1427 
1428 public:
1429   ciKlass* klass() const { return  _klass; }
1430   bool klass_is_exact()    const { return _klass_is_exact; }
1431 
1432   virtual bool can_be_inline_type() const { return EnableValhalla &amp;&amp; (_klass == NULL || _klass-&gt;can_be_inline_klass(_klass_is_exact)); }
1433   virtual bool flat_array() const {
1434     assert(!klass()-&gt;is_inlinetype() || !klass()-&gt;as_inline_klass()-&gt;flatten_array() || _flat_array, &quot;incorrect value bit&quot;);
1435     assert(!_flat_array || can_be_inline_type(), &quot;incorrect value bit&quot;);
1436     return _flat_array;
1437   }
1438 
1439   bool  is_loaded() const { return klass() != NULL &amp;&amp; klass()-&gt;is_loaded(); }
1440 
1441   // ptr to klass &#39;k&#39;
1442   static const TypeKlassPtr* make(ciKlass* k) { return make( TypePtr::Constant, k, Offset(0), k-&gt;is_inlinetype() &amp;&amp; k-&gt;as_inline_klass()-&gt;flatten_array()); }
1443   // ptr to klass &#39;k&#39; with offset
1444   static const TypeKlassPtr* make(ciKlass* k, Offset offset) { return make( TypePtr::Constant, k, offset, k-&gt;is_inlinetype() &amp;&amp; k-&gt;as_inline_klass()-&gt;flatten_array()); }
1445   // ptr to klass &#39;k&#39; or sub-klass
1446   static const TypeKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool flat_array);
1447 
1448   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1449 
1450   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1451 
1452   // corresponding pointer to instance, for a given class
1453   const TypeOopPtr* as_instance_type() const;
1454 
1455   virtual const TypePtr *add_offset( intptr_t offset ) const;
1456   virtual const Type    *xmeet( const Type *t ) const;
1457   virtual const Type    *xdual() const;      // Compute dual right now.
1458 
1459   virtual intptr_t get_con() const;
1460 
1461   // Convenience common pre-built types.
1462   static const TypeKlassPtr* OBJECT; // Not-null object klass or below
1463   static const TypeKlassPtr* OBJECT_OR_NULL; // Maybe-null version of same
1464 #ifndef PRODUCT
1465   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1466 #endif
1467 };
1468 
1469 class TypeNarrowPtr : public Type {
1470 protected:
1471   const TypePtr* _ptrtype; // Could be TypePtr::NULL_PTR
1472 
1473   TypeNarrowPtr(TYPES t, const TypePtr* ptrtype): Type(t),
1474                                                   _ptrtype(ptrtype) {
1475     assert(ptrtype-&gt;offset() == 0 ||
1476            ptrtype-&gt;offset() == OffsetBot ||
1477            ptrtype-&gt;offset() == OffsetTop, &quot;no real offsets&quot;);
1478   }
1479 
1480   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const = 0;
1481   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const = 0;
1482   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const = 0;
1483   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const = 0;
1484   // Do not allow interface-vs.-noninterface joins to collapse to top.
1485   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1486 public:
1487   virtual bool eq( const Type *t ) const;
1488   virtual int  hash() const;             // Type specific hashing
1489   virtual bool singleton(void) const;    // TRUE if type is a singleton
1490 
1491   virtual const Type *xmeet( const Type *t ) const;
1492   virtual const Type *xdual() const;    // Compute dual right now.
1493 
1494   virtual intptr_t get_con() const;
1495 
1496   virtual bool empty(void) const;        // TRUE if type is vacuous
1497 
1498   // returns the equivalent ptr type for this compressed pointer
1499   const TypePtr *get_ptrtype() const {
1500     return _ptrtype;
1501   }
1502 
1503   bool is_known_instance() const {
1504     return _ptrtype-&gt;is_known_instance();
1505   }
1506 
1507 #ifndef PRODUCT
1508   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1509 #endif
1510 };
1511 
1512 //------------------------------TypeNarrowOop----------------------------------
1513 // A compressed reference to some kind of Oop.  This type wraps around
1514 // a preexisting TypeOopPtr and forwards most of it&#39;s operations to
1515 // the underlying type.  It&#39;s only real purpose is to track the
1516 // oopness of the compressed oop value when we expose the conversion
1517 // between the normal and the compressed form.
1518 class TypeNarrowOop : public TypeNarrowPtr {
1519 protected:
1520   TypeNarrowOop( const TypePtr* ptrtype): TypeNarrowPtr(NarrowOop, ptrtype) {
1521   }
1522 
1523   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1524     return t-&gt;isa_narrowoop();
1525   }
1526 
1527   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1528     return t-&gt;is_narrowoop();
1529   }
1530 
1531   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1532     return new TypeNarrowOop(t);
1533   }
1534 
1535   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1536     return (const TypeNarrowPtr*)((new TypeNarrowOop(t))-&gt;hashcons());
1537   }
1538 
1539 public:
1540 
1541   static const TypeNarrowOop *make( const TypePtr* type);
1542 
1543   static const TypeNarrowOop* make_from_constant(ciObject* con, bool require_constant = false) {
1544     return make(TypeOopPtr::make_from_constant(con, require_constant));
1545   }
1546 
1547   static const TypeNarrowOop *BOTTOM;
1548   static const TypeNarrowOop *NULL_PTR;
1549 
1550   virtual const Type* remove_speculative() const;
1551   virtual const Type* cleanup_speculative() const;
1552 
1553 #ifndef PRODUCT
1554   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1555 #endif
1556 };
1557 
1558 //------------------------------TypeNarrowKlass----------------------------------
1559 // A compressed reference to klass pointer.  This type wraps around a
1560 // preexisting TypeKlassPtr and forwards most of it&#39;s operations to
1561 // the underlying type.
1562 class TypeNarrowKlass : public TypeNarrowPtr {
1563 protected:
1564   TypeNarrowKlass( const TypePtr* ptrtype): TypeNarrowPtr(NarrowKlass, ptrtype) {
1565   }
1566 
1567   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1568     return t-&gt;isa_narrowklass();
1569   }
1570 
1571   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1572     return t-&gt;is_narrowklass();
1573   }
1574 
1575   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1576     return new TypeNarrowKlass(t);
1577   }
1578 
1579   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1580     return (const TypeNarrowPtr*)((new TypeNarrowKlass(t))-&gt;hashcons());
1581   }
1582 
1583 public:
1584   static const TypeNarrowKlass *make( const TypePtr* type);
1585 
1586   // static const TypeNarrowKlass *BOTTOM;
1587   static const TypeNarrowKlass *NULL_PTR;
1588 
1589 #ifndef PRODUCT
1590   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1591 #endif
1592 };
1593 
1594 //------------------------------TypeFunc---------------------------------------
1595 // Class of Array Types
1596 class TypeFunc : public Type {
1597   TypeFunc(const TypeTuple *domain_sig, const TypeTuple *domain_cc, const TypeTuple *range_sig, const TypeTuple *range_cc)
1598     : Type(Function), _domain_sig(domain_sig), _domain_cc(domain_cc), _range_sig(range_sig), _range_cc(range_cc) {}
1599   virtual bool eq( const Type *t ) const;
1600   virtual int  hash() const;             // Type specific hashing
1601   virtual bool singleton(void) const;    // TRUE if type is a singleton
1602   virtual bool empty(void) const;        // TRUE if type is vacuous
1603 
1604   // Domains of inputs: inline type arguments are not passed by
1605   // reference, instead each field of the inline type is passed as an
1606   // argument. We maintain 2 views of the argument list here: one
1607   // based on the signature (with an inline type argument as a single
1608   // slot), one based on the actual calling convention (with a value
1609   // type argument as a list of its fields).
1610   const TypeTuple* const _domain_sig;
1611   const TypeTuple* const _domain_cc;
1612   // Range of results. Similar to domains: an inline type result can be
1613   // returned in registers in which case range_cc lists all fields and
1614   // is the actual calling convention.
1615   const TypeTuple* const _range_sig;
1616   const TypeTuple* const _range_cc;
1617 
1618 public:
1619   // Constants are shared among ADLC and VM
1620   enum { Control    = AdlcVMDeps::Control,
1621          I_O        = AdlcVMDeps::I_O,
1622          Memory     = AdlcVMDeps::Memory,
1623          FramePtr   = AdlcVMDeps::FramePtr,
1624          ReturnAdr  = AdlcVMDeps::ReturnAdr,
1625          Parms      = AdlcVMDeps::Parms
1626   };
1627 
1628 
1629   // Accessors:
1630   const TypeTuple* domain_sig() const { return _domain_sig; }
1631   const TypeTuple* domain_cc()  const { return _domain_cc; }
1632   const TypeTuple* range_sig()  const { return _range_sig; }
1633   const TypeTuple* range_cc()   const { return _range_cc; }
1634 
1635   static const TypeFunc* make(ciMethod* method, bool is_osr_compilation = false);
1636   static const TypeFunc *make(const TypeTuple* domain_sig, const TypeTuple* domain_cc,
1637                               const TypeTuple* range_sig, const TypeTuple* range_cc);
1638   static const TypeFunc *make(const TypeTuple* domain, const TypeTuple* range);
1639 
1640   virtual const Type *xmeet( const Type *t ) const;
1641   virtual const Type *xdual() const;    // Compute dual right now.
1642 
1643   BasicType return_type() const;
1644 
1645   bool returns_inline_type_as_fields() const { return range_sig() != range_cc(); }
1646 
1647 #ifndef PRODUCT
1648   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1649 #endif
1650   // Convenience common pre-built types.
1651 };
1652 
1653 //------------------------------accessors--------------------------------------
1654 inline bool Type::is_ptr_to_narrowoop() const {
1655 #ifdef _LP64
1656   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowoop_nv());
1657 #else
1658   return false;
1659 #endif
1660 }
1661 
1662 inline bool Type::is_ptr_to_narrowklass() const {
1663 #ifdef _LP64
1664   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowklass_nv());
1665 #else
1666   return false;
1667 #endif
1668 }
1669 
1670 inline float Type::getf() const {
1671   assert( _base == FloatCon, &quot;Not a FloatCon&quot; );
1672   return ((TypeF*)this)-&gt;_f;
1673 }
1674 
1675 inline double Type::getd() const {
1676   assert( _base == DoubleCon, &quot;Not a DoubleCon&quot; );
1677   return ((TypeD*)this)-&gt;_d;
1678 }
1679 
1680 inline const TypeInt *Type::is_int() const {
1681   assert( _base == Int, &quot;Not an Int&quot; );
1682   return (TypeInt*)this;
1683 }
1684 
1685 inline const TypeInt *Type::isa_int() const {
1686   return ( _base == Int ? (TypeInt*)this : NULL);
1687 }
1688 
1689 inline const TypeLong *Type::is_long() const {
1690   assert( _base == Long, &quot;Not a Long&quot; );
1691   return (TypeLong*)this;
1692 }
1693 
1694 inline const TypeLong *Type::isa_long() const {
1695   return ( _base == Long ? (TypeLong*)this : NULL);
1696 }
1697 
1698 inline const TypeF *Type::isa_float() const {
1699   return ((_base == FloatTop ||
1700            _base == FloatCon ||
1701            _base == FloatBot) ? (TypeF*)this : NULL);
1702 }
1703 
1704 inline const TypeF *Type::is_float_constant() const {
1705   assert( _base == FloatCon, &quot;Not a Float&quot; );
1706   return (TypeF*)this;
1707 }
1708 
1709 inline const TypeF *Type::isa_float_constant() const {
1710   return ( _base == FloatCon ? (TypeF*)this : NULL);
1711 }
1712 
1713 inline const TypeD *Type::isa_double() const {
1714   return ((_base == DoubleTop ||
1715            _base == DoubleCon ||
1716            _base == DoubleBot) ? (TypeD*)this : NULL);
1717 }
1718 
1719 inline const TypeD *Type::is_double_constant() const {
1720   assert( _base == DoubleCon, &quot;Not a Double&quot; );
1721   return (TypeD*)this;
1722 }
1723 
1724 inline const TypeD *Type::isa_double_constant() const {
1725   return ( _base == DoubleCon ? (TypeD*)this : NULL);
1726 }
1727 
1728 inline const TypeTuple *Type::is_tuple() const {
1729   assert( _base == Tuple, &quot;Not a Tuple&quot; );
1730   return (TypeTuple*)this;
1731 }
1732 
1733 inline const TypeAry *Type::is_ary() const {
1734   assert( _base == Array , &quot;Not an Array&quot; );
1735   return (TypeAry*)this;
1736 }
1737 
1738 inline const TypeAry *Type::isa_ary() const {
1739   return ((_base == Array) ? (TypeAry*)this : NULL);
1740 }
1741 
1742 inline const TypeVect *Type::is_vect() const {
1743   assert( _base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ, &quot;Not a Vector&quot; );
1744   return (TypeVect*)this;
1745 }
1746 
1747 inline const TypeVect *Type::isa_vect() const {
1748   return (_base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ) ? (TypeVect*)this : NULL;
1749 }
1750 
1751 inline const TypePtr *Type::is_ptr() const {
1752   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1753   assert(_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr, &quot;Not a pointer&quot;);
1754   return (TypePtr*)this;
1755 }
1756 
1757 inline const TypePtr *Type::isa_ptr() const {
1758   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1759   return (_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr) ? (TypePtr*)this : NULL;
1760 }
1761 
1762 inline const TypeOopPtr *Type::is_oopptr() const {
1763   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1764   assert(_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr, &quot;Not a Java pointer&quot; ) ;
1765   return (TypeOopPtr*)this;
1766 }
1767 
1768 inline const TypeOopPtr *Type::isa_oopptr() const {
1769   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1770   return (_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr) ? (TypeOopPtr*)this : NULL;
1771 }
1772 
1773 inline const TypeRawPtr *Type::isa_rawptr() const {
1774   return (_base == RawPtr) ? (TypeRawPtr*)this : NULL;
1775 }
1776 
1777 inline const TypeRawPtr *Type::is_rawptr() const {
1778   assert( _base == RawPtr, &quot;Not a raw pointer&quot; );
1779   return (TypeRawPtr*)this;
1780 }
1781 
1782 inline const TypeInstPtr *Type::isa_instptr() const {
1783   return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;
1784 }
1785 
1786 inline const TypeInstPtr *Type::is_instptr() const {
1787   assert( _base == InstPtr, &quot;Not an object pointer&quot; );
1788   return (TypeInstPtr*)this;
1789 }
1790 
1791 inline const TypeAryPtr *Type::isa_aryptr() const {
1792   return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;
1793 }
1794 
1795 inline const TypeAryPtr *Type::is_aryptr() const {
1796   assert( _base == AryPtr, &quot;Not an array pointer&quot; );
1797   return (TypeAryPtr*)this;
1798 }
1799 
1800 inline const TypeInlineType* Type::isa_inlinetype() const {
1801   return (_base == InlineType) ? (TypeInlineType*)this : NULL;
1802 }
1803 
1804 inline const TypeInlineType* Type::is_inlinetype() const {
1805   assert(_base == InlineType, &quot;Not an inline type&quot;);
1806   return (TypeInlineType*)this;
1807 }
1808 
1809 inline const TypeNarrowOop *Type::is_narrowoop() const {
1810   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1811   assert(_base == NarrowOop, &quot;Not a narrow oop&quot; ) ;
1812   return (TypeNarrowOop*)this;
1813 }
1814 
1815 inline const TypeNarrowOop *Type::isa_narrowoop() const {
1816   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1817   return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;
1818 }
1819 
1820 inline const TypeNarrowKlass *Type::is_narrowklass() const {
1821   assert(_base == NarrowKlass, &quot;Not a narrow oop&quot; ) ;
1822   return (TypeNarrowKlass*)this;
1823 }
1824 
1825 inline const TypeNarrowKlass *Type::isa_narrowklass() const {
1826   return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;
1827 }
1828 
1829 inline const TypeMetadataPtr *Type::is_metadataptr() const {
1830   // MetadataPtr is the first and CPCachePtr the last
1831   assert(_base == MetadataPtr, &quot;Not a metadata pointer&quot; ) ;
1832   return (TypeMetadataPtr*)this;
1833 }
1834 
1835 inline const TypeMetadataPtr *Type::isa_metadataptr() const {
1836   return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : NULL;
1837 }
1838 
1839 inline const TypeKlassPtr *Type::isa_klassptr() const {
1840   return (_base == KlassPtr) ? (TypeKlassPtr*)this : NULL;
1841 }
1842 
1843 inline const TypeKlassPtr *Type::is_klassptr() const {
1844   assert( _base == KlassPtr, &quot;Not a klass pointer&quot; );
1845   return (TypeKlassPtr*)this;
1846 }
1847 
1848 inline const TypePtr* Type::make_ptr() const {
1849   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype() :
1850                               ((_base == NarrowKlass) ? is_narrowklass()-&gt;get_ptrtype() :
1851                                                        isa_ptr());
1852 }
1853 
1854 inline const TypeOopPtr* Type::make_oopptr() const {
1855   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype()-&gt;isa_oopptr() : isa_oopptr();
1856 }
1857 
1858 inline const TypeNarrowOop* Type::make_narrowoop() const {
1859   return (_base == NarrowOop) ? is_narrowoop() :
1860                                 (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);
1861 }
1862 
1863 inline const TypeNarrowKlass* Type::make_narrowklass() const {
1864   return (_base == NarrowKlass) ? is_narrowklass() :
1865                                   (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);
1866 }
1867 
1868 inline bool Type::is_floatingpoint() const {
1869   if( (_base == FloatCon)  || (_base == FloatBot) ||
1870       (_base == DoubleCon) || (_base == DoubleBot) )
1871     return true;
1872   return false;
1873 }
1874 
1875 inline bool Type::is_inlinetypeptr() const {
1876   return isa_instptr() != NULL &amp;&amp; is_instptr()-&gt;klass()-&gt;is_inlinetype();
1877 }
1878 
1879 
1880 inline ciInlineKlass* Type::inline_klass() const {
1881   assert(is_inlinetypeptr(), &quot;must be an inline type ptr&quot;);
1882   return is_instptr()-&gt;klass()-&gt;as_inline_klass();
1883 }
1884 
1885 
1886 // ===============================================================
1887 // Things that need to be 64-bits in the 64-bit build but
1888 // 32-bits in the 32-bit build.  Done this way to get full
1889 // optimization AND strong typing.
1890 #ifdef _LP64
1891 
1892 // For type queries and asserts
1893 #define is_intptr_t  is_long
1894 #define isa_intptr_t isa_long
1895 #define find_intptr_t_type find_long_type
1896 #define find_intptr_t_con  find_long_con
1897 #define TypeX        TypeLong
1898 #define Type_X       Type::Long
1899 #define TypeX_X      TypeLong::LONG
1900 #define TypeX_ZERO   TypeLong::ZERO
1901 // For &#39;ideal_reg&#39; machine registers
1902 #define Op_RegX      Op_RegL
1903 // For phase-&gt;intcon variants
1904 #define MakeConX     longcon
1905 #define ConXNode     ConLNode
1906 // For array index arithmetic
1907 #define MulXNode     MulLNode
1908 #define AndXNode     AndLNode
1909 #define OrXNode      OrLNode
1910 #define CmpXNode     CmpLNode
1911 #define CmpUXNode    CmpULNode
1912 #define SubXNode     SubLNode
1913 #define LShiftXNode  LShiftLNode
1914 // For object size computation:
1915 #define AddXNode     AddLNode
1916 #define RShiftXNode  RShiftLNode
1917 // For card marks and hashcodes
1918 #define URShiftXNode URShiftLNode
1919 // UseOptoBiasInlining
1920 #define XorXNode     XorLNode
1921 #define StoreXConditionalNode StoreLConditionalNode
1922 #define LoadXNode    LoadLNode
1923 #define StoreXNode   StoreLNode
1924 // Opcodes
1925 #define Op_LShiftX   Op_LShiftL
1926 #define Op_AndX      Op_AndL
1927 #define Op_AddX      Op_AddL
1928 #define Op_SubX      Op_SubL
1929 #define Op_XorX      Op_XorL
1930 #define Op_URShiftX  Op_URShiftL
1931 #define Op_LoadX     Op_LoadL
1932 #define Op_StoreX    Op_StoreL
1933 // conversions
1934 #define ConvI2X(x)   ConvI2L(x)
1935 #define ConvL2X(x)   (x)
1936 #define ConvX2I(x)   ConvL2I(x)
1937 #define ConvX2L(x)   (x)
1938 #define ConvX2UL(x)  (x)
1939 
1940 #else
1941 
1942 // For type queries and asserts
1943 #define is_intptr_t  is_int
1944 #define isa_intptr_t isa_int
1945 #define find_intptr_t_type find_int_type
1946 #define find_intptr_t_con  find_int_con
1947 #define TypeX        TypeInt
1948 #define Type_X       Type::Int
1949 #define TypeX_X      TypeInt::INT
1950 #define TypeX_ZERO   TypeInt::ZERO
1951 // For &#39;ideal_reg&#39; machine registers
1952 #define Op_RegX      Op_RegI
1953 // For phase-&gt;intcon variants
1954 #define MakeConX     intcon
1955 #define ConXNode     ConINode
1956 // For array index arithmetic
1957 #define MulXNode     MulINode
1958 #define AndXNode     AndINode
1959 #define OrXNode      OrINode
1960 #define CmpXNode     CmpINode
1961 #define CmpUXNode    CmpUNode
1962 #define SubXNode     SubINode
1963 #define LShiftXNode  LShiftINode
1964 // For object size computation:
1965 #define AddXNode     AddINode
1966 #define RShiftXNode  RShiftINode
1967 // For card marks and hashcodes
1968 #define URShiftXNode URShiftINode
1969 // UseOptoBiasInlining
1970 #define XorXNode     XorINode
1971 #define StoreXConditionalNode StoreIConditionalNode
1972 #define LoadXNode    LoadINode
1973 #define StoreXNode   StoreINode
1974 // Opcodes
1975 #define Op_LShiftX   Op_LShiftI
1976 #define Op_AndX      Op_AndI
1977 #define Op_AddX      Op_AddI
1978 #define Op_SubX      Op_SubI
1979 #define Op_XorX      Op_XorI
1980 #define Op_URShiftX  Op_URShiftI
1981 #define Op_LoadX     Op_LoadI
1982 #define Op_StoreX    Op_StoreI
1983 // conversions
1984 #define ConvI2X(x)   (x)
1985 #define ConvL2X(x)   ConvL2I(x)
1986 #define ConvX2I(x)   (x)
1987 #define ConvX2L(x)   ConvI2L(x)
1988 #define ConvX2UL(x)  ConvI2UL(x)
1989 
1990 #endif
1991 
1992 #endif // SHARE_OPTO_TYPE_HPP
    </pre>
  </body>
</html>