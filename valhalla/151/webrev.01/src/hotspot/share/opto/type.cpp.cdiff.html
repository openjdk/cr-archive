<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="subtypenode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 587,13 ***</span>
  
    TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
    TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
    TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
    TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified">!                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()), false);</span>
    TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified">!                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);</span>
    TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
  
    TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
  
    TypeInlineType::BOTTOM = TypeInlineType::make(NULL);
<span class="line-new-header">--- 587,13 ---</span>
  
    TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
    TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
    TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
    TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified">!                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()));</span>
    TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
<span class="line-modified">!                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()));</span>
    TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
  
    TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
  
    TypeInlineType::BOTTOM = TypeInlineType::make(NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 648,12 ***</span>
    TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
    TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
    TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
    TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
  
<span class="line-modified">!   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0), false);</span>
<span class="line-modified">!   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0), false);</span>
  
    const Type **fi2c = TypeTuple::fields(2);
    fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
    fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
    TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
<span class="line-new-header">--- 648,12 ---</span>
    TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
    TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
    TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
    TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
  
<span class="line-modified">!   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0));</span>
<span class="line-modified">!   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0));</span>
  
    const Type **fi2c = TypeTuple::fields(2);
    fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
    fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
    TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3337,23 ***</span>
    // There is no such thing as an exact general oop.
    // Return self unchanged.
    return this;
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- //------------------------------as_klass_type----------------------------------</span>
<span class="line-removed">- // Return the klass type corresponding to this instance or array type.</span>
<span class="line-removed">- // It is the type that is loaded from an object of this type.</span>
<span class="line-removed">- const TypeKlassPtr* TypeOopPtr::as_klass_type() const {</span>
<span class="line-removed">-   ciKlass* k = klass();</span>
<span class="line-removed">-   bool    xk = klass_is_exact();</span>
<span class="line-removed">-   if (k == NULL)</span>
<span class="line-removed">-     return TypeKlassPtr::OBJECT;</span>
<span class="line-removed">-   else</span>
<span class="line-removed">-     return TypeKlassPtr::make(xk? Constant: NotNull, k, Offset(0), isa_instptr() &amp;&amp; is_instptr()-&gt;flat_array());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //------------------------------meet-------------------------------------------
  // Compute the MEET of two types.  It returns a new Type object.
  const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
    // Perform a fast test for common case; meeting the same types together.
    if( this == t ) return this;  // Meeting same type-rep?
<span class="line-new-header">--- 3337,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3459,11 ***</span>
          // Add a dependence; if concrete subclass added we need to recompile
          deps-&gt;assert_leaf_type(ik);
          klass_is_exact = true;
        }
      }
<span class="line-modified">!     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());</span>
    } else if (klass-&gt;is_obj_array_klass()) {
      // Element is an object or inline type array. Recursively call ourself.
      const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);
      if (etype-&gt;is_inlinetypeptr()) {
        etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
<span class="line-new-header">--- 3446,11 ---</span>
          // Add a dependence; if concrete subclass added we need to recompile
          deps-&gt;assert_leaf_type(ik);
          klass_is_exact = true;
        }
      }
<span class="line-modified">!     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0));</span>
    } else if (klass-&gt;is_obj_array_klass()) {
      // Element is an object or inline type array. Recursively call ourself.
      const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);
      if (etype-&gt;is_inlinetypeptr()) {
        etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3515,11 ***</span>
    if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {
      // Element is an instance or inline type
      if (make_constant) {
        return TypeInstPtr::make(o);
      } else {
<span class="line-modified">!       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());</span>
      }
    } else if (klass-&gt;is_obj_array_klass()) {
      // Element is an object array. Recursively call ourself.
      const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
      bool null_free = false;
<span class="line-new-header">--- 3502,11 ---</span>
    if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {
      // Element is an instance or inline type
      if (make_constant) {
        return TypeInstPtr::make(o);
      } else {
<span class="line-modified">!       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0));</span>
      }
    } else if (klass-&gt;is_obj_array_klass()) {
      // Element is an object array. Recursively call ourself.
      const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
      bool null_free = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3772,28 ***</span>
  const TypeInstPtr *TypeInstPtr::MARK;
  const TypeInstPtr *TypeInstPtr::KLASS;
  
  //------------------------------TypeInstPtr-------------------------------------
  TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,
<span class="line-modified">!                          bool flat_array, int instance_id, const TypePtr* speculative,</span>
                           int inline_depth)
    : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
<span class="line-modified">!     _name(k-&gt;name()), _flat_array(flat_array) {</span>
<span class="line-modified">!    assert(k != NULL &amp;&amp;</span>
<span class="line-modified">!           (k-&gt;is_loaded() || o == NULL),</span>
<span class="line-modified">!           &quot;cannot have constants with non-loaded klass&quot;);</span>
<span class="line-modified">!    assert(!klass()-&gt;is_inlinetype() || !klass()-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-modified">!    assert(!flat_array || can_be_inline_type(), &quot;incorrect flatten array bit&quot;);</span>
  };
  
  //------------------------------make-------------------------------------------
  const TypeInstPtr *TypeInstPtr::make(PTR ptr,
                                       ciKlass* k,
                                       bool xk,
                                       ciObject* o,
                                       Offset offset,
<span class="line-modified">!                                      bool flat_array,</span>
                                       int instance_id,
                                       const TypePtr* speculative,
                                       int inline_depth) {
    assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
    // Either const_oop() is NULL or else ptr is Constant
<span class="line-new-header">--- 3759,28 ---</span>
  const TypeInstPtr *TypeInstPtr::MARK;
  const TypeInstPtr *TypeInstPtr::KLASS;
  
  //------------------------------TypeInstPtr-------------------------------------
  TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,
<span class="line-modified">!                          bool flatten_array, int instance_id, const TypePtr* speculative,</span>
                           int inline_depth)
    : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
<span class="line-modified">!     _name(k-&gt;name()), _flatten_array(flatten_array) {</span>
<span class="line-modified">!   assert(k != NULL &amp;&amp;</span>
<span class="line-modified">!          (k-&gt;is_loaded() || o == NULL),</span>
<span class="line-modified">!          &quot;cannot have constants with non-loaded klass&quot;);</span>
<span class="line-modified">!   assert(!klass()-&gt;flatten_array() || flatten_array, &quot;Should be flat in array&quot;);</span>
<span class="line-modified">!   assert(!flatten_array || can_be_inline_type(), &quot;Only inline types can be flat in array&quot;);</span>
  };
  
  //------------------------------make-------------------------------------------
  const TypeInstPtr *TypeInstPtr::make(PTR ptr,
                                       ciKlass* k,
                                       bool xk,
                                       ciObject* o,
                                       Offset offset,
<span class="line-modified">!                                      bool flatten_array,</span>
                                       int instance_id,
                                       const TypePtr* speculative,
                                       int inline_depth) {
    assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
    // Either const_oop() is NULL or else ptr is Constant
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3810,13 ***</span>
      ciInstanceKlass* ik = k-&gt;as_instance_klass();
      if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
      if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
    }
  
    // Now hash this baby
    TypeInstPtr *result =
<span class="line-modified">!     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, flat_array, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
  
    return result;
  }
  
  /**
<span class="line-new-header">--- 3797,16 ---</span>
      ciInstanceKlass* ik = k-&gt;as_instance_klass();
      if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
      if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
    }
  
<span class="line-added">+   // Check if this type is known to be flat in arrays</span>
<span class="line-added">+   flatten_array = flatten_array || k-&gt;flatten_array();</span>
<span class="line-added">+ </span>
    // Now hash this baby
    TypeInstPtr *result =
<span class="line-modified">!     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o, offset, flatten_array, instance_id, speculative, inline_depth))-&gt;hashcons();</span>
  
    return result;
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3845,28 ***</span>
  //------------------------------cast_to_ptr_type-------------------------------
  const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
    if( ptr == _ptr ) return this;
    // Reconstruct _sig info here since not a problem with later lazy
    // construction, _sig will show up on demand.
<span class="line-modified">!   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);</span>
  }
  
  
  //-----------------------------cast_to_exactness-------------------------------
  const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
    if( klass_is_exact == _klass_is_exact ) return this;
    if (!_klass-&gt;is_loaded())  return this;
    ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
    if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
    if( ik-&gt;is_interface() )              return this;  // cannot set xk
<span class="line-modified">!   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);</span>
  }
  
  //-----------------------------cast_to_instance_id----------------------------
  const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
    if( instance_id == _instance_id ) return this;
<span class="line-modified">!   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flat_array, instance_id, _speculative, _inline_depth);</span>
  }
  
  //------------------------------xmeet_unloaded---------------------------------
  // Compute the MEET of two InstPtrs when at least one is unloaded.
  // Assume classes are different since called after check for same name/class-loader
<span class="line-new-header">--- 3835,28 ---</span>
  //------------------------------cast_to_ptr_type-------------------------------
  const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
    if( ptr == _ptr ) return this;
    // Reconstruct _sig info here since not a problem with later lazy
    // construction, _sig will show up on demand.
<span class="line-modified">!   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flatten_array, _instance_id, _speculative, _inline_depth);</span>
  }
  
  
  //-----------------------------cast_to_exactness-------------------------------
  const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
    if( klass_is_exact == _klass_is_exact ) return this;
    if (!_klass-&gt;is_loaded())  return this;
    ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
    if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
    if( ik-&gt;is_interface() )              return this;  // cannot set xk
<span class="line-modified">!   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flatten_array, _instance_id, _speculative, _inline_depth);</span>
  }
  
  //-----------------------------cast_to_instance_id----------------------------
  const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
    if( instance_id == _instance_id ) return this;
<span class="line-modified">!   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flatten_array, instance_id, _speculative, _inline_depth);</span>
  }
  
  //------------------------------xmeet_unloaded---------------------------------
  // Compute the MEET of two InstPtrs when at least one is unloaded.
  // Assume classes are different since called after check for same name/class-loader
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3958,11 ***</span>
      case TopPTR:
      case AnyNull:                // Fall &#39;down&#39; to dual of object klass
        // For instances when a subclass meets a superclass we fall
        // below the centerline when the superclass is exact. We need to
        // do the same here.
<span class="line-modified">!       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {</span>
          return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
        } else {
          // cannot subclass, so the meet has to fall badly below the centerline
          ptr = NotNull;
          instance_id = InstanceBot;
<span class="line-new-header">--- 3948,11 ---</span>
      case TopPTR:
      case AnyNull:                // Fall &#39;down&#39; to dual of object klass
        // For instances when a subclass meets a superclass we fall
        // below the centerline when the superclass is exact. We need to
        // do the same here.
<span class="line-modified">!       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flatten_array()) {</span>
          return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
        } else {
          // cannot subclass, so the meet has to fall badly below the centerline
          ptr = NotNull;
          instance_id = InstanceBot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3976,11 ***</span>
          // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
          // then we can subclass in the Java class hierarchy.
          // For instances when a subclass meets a superclass we fall
          // below the centerline when the superclass is exact. We need
          // to do the same here.
<span class="line-modified">!         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {</span>
            // that is, tp&#39;s array type is a subtype of my klass
            return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
                                    tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
          }
        }
<span class="line-new-header">--- 3966,11 ---</span>
          // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
          // then we can subclass in the Java class hierarchy.
          // For instances when a subclass meets a superclass we fall
          // below the centerline when the superclass is exact. We need
          // to do the same here.
<span class="line-modified">!         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flatten_array()) {</span>
            // that is, tp&#39;s array type is a subtype of my klass
            return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
                                    tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
          }
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4004,11 ***</span>
      case AnyNull: {
        int instance_id = meet_instance_id(InstanceTop);
        const TypePtr* speculative = xmeet_speculative(tp);
        int depth = meet_inline_depth(tp-&gt;inline_depth());
        return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">!                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);</span>
      }
      case NotNull:
      case BotPTR: {
        int instance_id = meet_instance_id(tp-&gt;instance_id());
        const TypePtr* speculative = xmeet_speculative(tp);
<span class="line-new-header">--- 3994,11 ---</span>
      case AnyNull: {
        int instance_id = meet_instance_id(InstanceTop);
        const TypePtr* speculative = xmeet_speculative(tp);
        int depth = meet_inline_depth(tp-&gt;inline_depth());
        return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">!                   (ptr == Constant ? const_oop() : NULL), offset, flatten_array(), instance_id, speculative, depth);</span>
      }
      case NotNull:
      case BotPTR: {
        int instance_id = meet_instance_id(tp-&gt;instance_id());
        const TypePtr* speculative = xmeet_speculative(tp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4032,11 ***</span>
        if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
        // else fall through to AnyNull
      case TopPTR:
      case AnyNull: {
        return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">!                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);</span>
      }
      case NotNull:
      case BotPTR:
        return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
      default: typerr(t);
<span class="line-new-header">--- 4022,11 ---</span>
        if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
        // else fall through to AnyNull
      case TopPTR:
      case AnyNull: {
        return make(ptr, klass(), klass_is_exact(),
<span class="line-modified">!                   (ptr == Constant ? const_oop() : NULL), offset, flatten_array(), instance_id, speculative, depth);</span>
      }
      case NotNull:
      case BotPTR:
        return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
      default: typerr(t);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4071,21 ***</span>
      // Check for easy case; klasses are equal (and perhaps not loaded!)
      // If we have constants, then we created oops so classes are loaded
      // and we can handle the constants further down.  This case handles
      // both-not-loaded or both-loaded classes
      if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact() &amp;&amp;
<span class="line-modified">!         flat_array() == tinst-&gt;flat_array()) {</span>
<span class="line-modified">!       return make(ptr, klass(), klass_is_exact(), NULL, off, flat_array(), instance_id, speculative, depth);</span>
      }
  
      // Classes require inspection in the Java klass hierarchy.  Must be loaded.
      ciKlass* tinst_klass = tinst-&gt;klass();
      ciKlass* this_klass  = this-&gt;klass();
      bool tinst_xk = tinst-&gt;klass_is_exact();
      bool this_xk  = this-&gt;klass_is_exact();
<span class="line-modified">!     bool tinst_flat_array = tinst-&gt;flat_array();</span>
<span class="line-modified">!     bool this_flat_array  = this-&gt;flat_array();</span>
      if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
        // One of these classes has not been loaded
        const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
  #ifndef PRODUCT
        if( PrintOpto &amp;&amp; Verbose ) {
<span class="line-new-header">--- 4061,21 ---</span>
      // Check for easy case; klasses are equal (and perhaps not loaded!)
      // If we have constants, then we created oops so classes are loaded
      // and we can handle the constants further down.  This case handles
      // both-not-loaded or both-loaded classes
      if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact() &amp;&amp;
<span class="line-modified">!         flatten_array() == tinst-&gt;flatten_array()) {</span>
<span class="line-modified">!       return make(ptr, klass(), klass_is_exact(), NULL, off, flatten_array(), instance_id, speculative, depth);</span>
      }
  
      // Classes require inspection in the Java klass hierarchy.  Must be loaded.
      ciKlass* tinst_klass = tinst-&gt;klass();
      ciKlass* this_klass  = this-&gt;klass();
      bool tinst_xk = tinst-&gt;klass_is_exact();
      bool this_xk  = this-&gt;klass_is_exact();
<span class="line-modified">!     bool tinst_flatten_array = tinst-&gt;flatten_array();</span>
<span class="line-modified">!     bool this_flatten_array  = this-&gt;flatten_array();</span>
      if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
        // One of these classes has not been loaded
        const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
  #ifndef PRODUCT
        if( PrintOpto &amp;&amp; Verbose ) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4104,13 ***</span>
        tinst_klass = this_klass;
        this_klass = tmp;
        bool tmp2 = tinst_xk;
        tinst_xk = this_xk;
        this_xk = tmp2;
<span class="line-modified">!       tmp2 = tinst_flat_array;</span>
<span class="line-modified">!       tinst_flat_array = this_flat_array;</span>
<span class="line-modified">!       this_flat_array = tmp2;</span>
      }
      if (tinst_klass-&gt;is_interface() &amp;&amp;
          !(this_klass-&gt;is_interface() ||
            // Treat java/lang/Object as an honorary interface,
            // because we need a bottom for the interface hierarchy.
<span class="line-new-header">--- 4094,13 ---</span>
        tinst_klass = this_klass;
        this_klass = tmp;
        bool tmp2 = tinst_xk;
        tinst_xk = this_xk;
        this_xk = tmp2;
<span class="line-modified">!       tmp2 = tinst_flatten_array;</span>
<span class="line-modified">!       tinst_flatten_array = this_flatten_array;</span>
<span class="line-modified">!       this_flatten_array = tmp2;</span>
      }
      if (tinst_klass-&gt;is_interface() &amp;&amp;
          !(this_klass-&gt;is_interface() ||
            // Treat java/lang/Object as an honorary interface,
            // because we need a bottom for the interface hierarchy.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4127,18 ***</span>
          // below the centerline.  If we are on the centerline
          // (e.g., Constant vs. AnyNull interface), use the constant.
          k  = below_centerline(ptr) ? tinst_klass : this_klass;
          // If we are keeping this_klass, keep its exactness too.
          xk = below_centerline(ptr) ? tinst_xk    : this_xk;
<span class="line-modified">!         flat_array = below_centerline(ptr) ? tinst_flat_array    : this_flat_array;</span>
        } else {                  // Does not implement, fall to Object
          // Oop does not implement interface, so mixing falls to Object
          // just like the verifier does (if both are above the
          // centerline fall to interface)
          k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
          xk = above_centerline(ptr) ? tinst_xk : false;
<span class="line-modified">!         flat_array = above_centerline(ptr) ? tinst_flat_array : false;</span>
          // Watch out for Constant vs. AnyNull interface.
          if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
          instance_id = InstanceBot;
        }
        ciObject* o = NULL;  // the Constant value, if any
<span class="line-new-header">--- 4117,18 ---</span>
          // below the centerline.  If we are on the centerline
          // (e.g., Constant vs. AnyNull interface), use the constant.
          k  = below_centerline(ptr) ? tinst_klass : this_klass;
          // If we are keeping this_klass, keep its exactness too.
          xk = below_centerline(ptr) ? tinst_xk    : this_xk;
<span class="line-modified">!         flat_array = below_centerline(ptr) ? tinst_flatten_array    : this_flatten_array;</span>
        } else {                  // Does not implement, fall to Object
          // Oop does not implement interface, so mixing falls to Object
          // just like the verifier does (if both are above the
          // centerline fall to interface)
          k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
          xk = above_centerline(ptr) ? tinst_xk : false;
<span class="line-modified">!         flat_array = above_centerline(ptr) ? tinst_flatten_array : false;</span>
          // Watch out for Constant vs. AnyNull interface.
          if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
          instance_id = InstanceBot;
        }
        ciObject* o = NULL;  // the Constant value, if any
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4180,37 ***</span>
      bool subtype_exact = false;
      bool flat_array = false;
      if (tinst_klass-&gt;equals(this_klass)) {
        subtype = this_klass;
        subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
<span class="line-modified">!       flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tinst_flat_array) : (this_flat_array || tinst_flat_array);</span>
<span class="line-modified">!     } else if(!tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of(tinst_klass) &amp;&amp; (!tinst_flat_array || this_flat_array)) {</span>
        subtype = this_klass;     // Pick subtyping class
        subtype_exact = this_xk;
<span class="line-modified">!       flat_array = this_flat_array;</span>
<span class="line-modified">!     } else if(!this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of(this_klass) &amp;&amp; (!this_flat_array || tinst_flat_array)) {</span>
        subtype = tinst_klass;    // Pick subtyping class
        subtype_exact = tinst_xk;
<span class="line-modified">!       flat_array = tinst_flat_array;</span>
      }
  
      if (subtype) {
        if (above_centerline(ptr)) { // both are up?
          this_klass = tinst_klass = subtype;
          this_xk = tinst_xk = subtype_exact;
<span class="line-modified">!         this_flat_array = tinst_flat_array = flat_array;</span>
        } else if (above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr)) {
          this_klass = tinst_klass; // tinst is down; keep down man
          this_xk = tinst_xk;
<span class="line-modified">!         this_flat_array = tinst_flat_array;</span>
        } else if (above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr)) {
          tinst_klass = this_klass; // this is down; keep down man
          tinst_xk = this_xk;
<span class="line-modified">!         tinst_flat_array = this_flat_array;</span>
        } else {
          this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
<span class="line-modified">!         this_flat_array = flat_array;</span>
        }
      }
  
      // Check for classes now being equal
      if (tinst_klass-&gt;equals(this_klass)) {
<span class="line-new-header">--- 4170,37 ---</span>
      bool subtype_exact = false;
      bool flat_array = false;
      if (tinst_klass-&gt;equals(this_klass)) {
        subtype = this_klass;
        subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
<span class="line-modified">!       flat_array = below_centerline(ptr) ? (this_flatten_array &amp;&amp; tinst_flatten_array) : (this_flatten_array || tinst_flatten_array);</span>
<span class="line-modified">!     } else if(!tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of(tinst_klass) &amp;&amp; (!tinst_flatten_array || this_flatten_array)) {</span>
        subtype = this_klass;     // Pick subtyping class
        subtype_exact = this_xk;
<span class="line-modified">!       flat_array = this_flatten_array;</span>
<span class="line-modified">!     } else if(!this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of(this_klass) &amp;&amp; (!this_flatten_array || tinst_flatten_array)) {</span>
        subtype = tinst_klass;    // Pick subtyping class
        subtype_exact = tinst_xk;
<span class="line-modified">!       flat_array = tinst_flatten_array;</span>
      }
  
      if (subtype) {
        if (above_centerline(ptr)) { // both are up?
          this_klass = tinst_klass = subtype;
          this_xk = tinst_xk = subtype_exact;
<span class="line-modified">!         this_flatten_array = tinst_flatten_array = flat_array;</span>
        } else if (above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr)) {
          this_klass = tinst_klass; // tinst is down; keep down man
          this_xk = tinst_xk;
<span class="line-modified">!         this_flatten_array = tinst_flatten_array;</span>
        } else if (above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr)) {
          tinst_klass = this_klass; // this is down; keep down man
          tinst_xk = this_xk;
<span class="line-modified">!         tinst_flatten_array = this_flatten_array;</span>
        } else {
          this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
<span class="line-modified">!         this_flatten_array = flat_array;</span>
        }
      }
  
      // Check for classes now being equal
      if (tinst_klass-&gt;equals(this_klass)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4229,11 ***</span>
          else if (above_centerline(tinst -&gt;_ptr))
            o = this_oop;
          else
            ptr = NotNull;
        }
<span class="line-modified">!       return make(ptr, this_klass, this_xk, o, off, this_flat_array, instance_id, speculative, depth);</span>
      } // Else classes are not equal
  
      // Since klasses are different, we require a LCA in the Java
      // class hierarchy - which means we have to fall to at least NotNull.
      if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
<span class="line-new-header">--- 4219,11 ---</span>
          else if (above_centerline(tinst -&gt;_ptr))
            o = this_oop;
          else
            ptr = NotNull;
        }
<span class="line-modified">!       return make(ptr, this_klass, this_xk, o, off, this_flatten_array, instance_id, speculative, depth);</span>
      } // Else classes are not equal
  
      // Since klasses are different, we require a LCA in the Java
      // class hierarchy - which means we have to fall to at least NotNull.
      if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4285,27 ***</span>
  
  //------------------------------xdual------------------------------------------
  // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
  // inheritance mechanism.
  const Type *TypeInstPtr::xdual() const {
<span class="line-modified">!   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flat_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
  }
  
  //------------------------------eq---------------------------------------------
  // Structural equality check for Type representations
  bool TypeInstPtr::eq( const Type *t ) const {
    const TypeInstPtr *p = t-&gt;is_instptr();
    return
      klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
<span class="line-modified">!     flat_array() == p-&gt;flat_array() &amp;&amp;</span>
      TypeOopPtr::eq(p);          // Check sub-type stuff
  }
  
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
  int TypeInstPtr::hash(void) const {
<span class="line-modified">!   int hash = java_add(java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash()), (jint)flat_array());</span>
    return hash;
  }
  
  //------------------------------dump2------------------------------------------
  // Dump oop Type
<span class="line-new-header">--- 4275,27 ---</span>
  
  //------------------------------xdual------------------------------------------
  // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
  // inheritance mechanism.
  const Type *TypeInstPtr::xdual() const {
<span class="line-modified">!   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flatten_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());</span>
  }
  
  //------------------------------eq---------------------------------------------
  // Structural equality check for Type representations
  bool TypeInstPtr::eq( const Type *t ) const {
    const TypeInstPtr *p = t-&gt;is_instptr();
    return
      klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
<span class="line-modified">!     flatten_array() == p-&gt;flatten_array() &amp;&amp;</span>
      TypeOopPtr::eq(p);          // Check sub-type stuff
  }
  
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
  int TypeInstPtr::hash(void) const {
<span class="line-modified">!   int hash = java_add(java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash()), (jint)flatten_array());</span>
    return hash;
  }
  
  //------------------------------dump2------------------------------------------
  // Dump oop Type
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4337,11 ***</span>
  
    _offset.dump2(st);
  
    st-&gt;print(&quot; *&quot;);
  
<span class="line-modified">!   if (flat_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
      st-&gt;print(&quot; (flatten array)&quot;);
    }
  
    if (_instance_id == InstanceTop)
      st-&gt;print(&quot;,iid=top&quot;);
<span class="line-new-header">--- 4327,11 ---</span>
  
    _offset.dump2(st);
  
    st-&gt;print(&quot; *&quot;);
  
<span class="line-modified">!   if (flatten_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
      st-&gt;print(&quot; (flatten array)&quot;);
    }
  
    if (_instance_id == InstanceTop)
      st-&gt;print(&quot;,iid=top&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4353,36 ***</span>
  }
  #endif
  
  //------------------------------add_offset-------------------------------------
  const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
<span class="line-modified">!   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flat_array(),</span>
                _instance_id, add_offset_speculative(offset), _inline_depth);
  }
  
  const Type *TypeInstPtr::remove_speculative() const {
    if (_speculative == NULL) {
      return this;
    }
    assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="line-modified">!   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(),</span>
                _instance_id, NULL, _inline_depth);
  }
  
  const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
    if (!UseInlineDepthForSpeculativeTypes) {
      return this;
    }
<span class="line-modified">!   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), _instance_id, _speculative, depth);</span>
  }
  
  const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
    assert(is_known_instance(), &quot;should be known&quot;);
<span class="line-modified">!   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), instance_id, _speculative, _inline_depth);</span>
  }
  
<span class="line-modified">! const TypeInstPtr *TypeInstPtr::cast_to_flat_array() const {</span>
    return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);
  }
  
  
  //=============================================================================
<span class="line-new-header">--- 4343,36 ---</span>
  }
  #endif
  
  //------------------------------add_offset-------------------------------------
  const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
<span class="line-modified">!   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flatten_array(),</span>
                _instance_id, add_offset_speculative(offset), _inline_depth);
  }
  
  const Type *TypeInstPtr::remove_speculative() const {
    if (_speculative == NULL) {
      return this;
    }
    assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
<span class="line-modified">!   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(),</span>
                _instance_id, NULL, _inline_depth);
  }
  
  const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
    if (!UseInlineDepthForSpeculativeTypes) {
      return this;
    }
<span class="line-modified">!   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(), _instance_id, _speculative, depth);</span>
  }
  
  const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
    assert(is_known_instance(), &quot;should be known&quot;);
<span class="line-modified">!   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(), instance_id, _speculative, _inline_depth);</span>
  }
  
<span class="line-modified">! const TypeInstPtr *TypeInstPtr::cast_to_flatten_array() const {</span>
    return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);
  }
  
  
  //=============================================================================
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4521,10 ***</span>
<span class="line-new-header">--- 4511,25 ---</span>
    // Not null free implies not flat
    const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);
    return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
  }
  
<span class="line-added">+ //---------------------------------update_properties---------------------------</span>
<span class="line-added">+ const TypeAryPtr* TypeAryPtr::update_properties(const TypeAryPtr* from) const {</span>
<span class="line-added">+   if ((from-&gt;is_flat()          &amp;&amp; is_not_flat()) ||</span>
<span class="line-added">+       (from-&gt;is_not_flat()      &amp;&amp; is_flat()) ||</span>
<span class="line-added">+       (from-&gt;is_null_free()     &amp;&amp; is_not_null_free()) ||</span>
<span class="line-added">+       (from-&gt;is_not_null_free() &amp;&amp; is_null_free())) {</span>
<span class="line-added">+     return NULL; // Inconsistent properties</span>
<span class="line-added">+   } else if (from-&gt;is_not_null_free()) {</span>
<span class="line-added">+     return cast_to_not_null_free(); // Implies not flat</span>
<span class="line-added">+   } else if (from-&gt;is_not_flat()) {</span>
<span class="line-added">+     return cast_to_not_flat();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return this;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  //------------------------------cast_to_stable---------------------------------
  const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
    if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
      return this;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4699,12 ***</span>
        return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
      } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_flat_array_klass() != tap-&gt;klass()-&gt;is_flat_array_klass()) {
        // Meeting flattened inline type array with non-flattened array. Adjust (field) offset accordingly.
        if (tary-&gt;_elem-&gt;isa_inlinetype()) {
          // Result is flattened
<span class="line-modified">!         off = Offset(elem()-&gt;isa_inlinetype() ? offset() : tap-&gt;offset());</span>
<span class="line-modified">!         field_off = elem()-&gt;isa_inlinetype() ? field_offset() : tap-&gt;field_offset();</span>
        } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
          // Result is non-flattened
          off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
          field_off = Offset::bottom;
        }
<span class="line-new-header">--- 4704,12 ---</span>
        return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
      } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_flat_array_klass() != tap-&gt;klass()-&gt;is_flat_array_klass()) {
        // Meeting flattened inline type array with non-flattened array. Adjust (field) offset accordingly.
        if (tary-&gt;_elem-&gt;isa_inlinetype()) {
          // Result is flattened
<span class="line-modified">!         off = Offset(is_flat() ? offset() : tap-&gt;offset());</span>
<span class="line-modified">!         field_off = is_flat() ? field_offset() : tap-&gt;field_offset();</span>
        } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
          // Result is non-flattened
          off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
          field_off = Offset::bottom;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4765,11 ***</span>
      case TopPTR:
      case AnyNull:                // Fall &#39;down&#39; to dual of object klass
        // For instances when a subclass meets a superclass we fall
        // below the centerline when the superclass is exact. We need to
        // do the same here.
<span class="line-modified">!       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {</span>
          return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
        } else {
          // cannot subclass, so the meet has to fall badly below the centerline
          ptr = NotNull;
          instance_id = InstanceBot;
<span class="line-new-header">--- 4770,11 ---</span>
      case TopPTR:
      case AnyNull:                // Fall &#39;down&#39; to dual of object klass
        // For instances when a subclass meets a superclass we fall
        // below the centerline when the superclass is exact. We need to
        // do the same here.
<span class="line-modified">!       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flatten_array()) {</span>
          return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
        } else {
          // cannot subclass, so the meet has to fall badly below the centerline
          ptr = NotNull;
          instance_id = InstanceBot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4783,11 ***</span>
          // If &#39;tp&#39;  is above the centerline and it is Object class
          // then we can subclass in the Java class hierarchy.
          // For instances when a subclass meets a superclass we fall
          // below the centerline when the superclass is exact. We need
          // to do the same here.
<span class="line-modified">!         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {</span>
            // that is, my array type is a subtype of &#39;tp&#39; klass
            return make(ptr, (ptr == Constant ? const_oop() : NULL),
                        _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
          }
        }
<span class="line-new-header">--- 4788,11 ---</span>
          // If &#39;tp&#39;  is above the centerline and it is Object class
          // then we can subclass in the Java class hierarchy.
          // For instances when a subclass meets a superclass we fall
          // below the centerline when the superclass is exact. We need
          // to do the same here.
<span class="line-modified">!         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flatten_array()) {</span>
            // that is, my array type is a subtype of &#39;tp&#39; klass
            return make(ptr, (ptr == Constant ? const_oop() : NULL),
                        _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
          }
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4864,11 ***</span>
      break;
    default:
      break;
    }
  
<span class="line-modified">!   if (elem()-&gt;isa_inlinetype()) {</span>
      st-&gt;print(&quot;(&quot;);
      _field_offset.dump2(st);
      st-&gt;print(&quot;)&quot;);
    }
    if (offset() != 0) {
<span class="line-new-header">--- 4869,11 ---</span>
      break;
    default:
      break;
    }
  
<span class="line-modified">!   if (is_flat()) {</span>
      st-&gt;print(&quot;(&quot;);
      _field_offset.dump2(st);
      st-&gt;print(&quot;)&quot;);
    }
    if (offset() != 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5335,34 ***</span>
  // Not-null object klass or below
  const TypeKlassPtr *TypeKlassPtr::OBJECT;
  const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
  
  //------------------------------TypeKlassPtr-----------------------------------
<span class="line-modified">! TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)</span>
<span class="line-modified">!   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {</span>
<span class="line-modified">!    assert(!klass-&gt;is_inlinetype() || !klass-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);</span>
<span class="line-modified">!    assert(!flat_array || can_be_inline_type(), &quot;incorrect flatten array bit&quot;);</span>
  }
  
  //------------------------------make-------------------------------------------
  // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
<span class="line-modified">! const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {</span>
    assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
<span class="line-modified">!   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flat_array))-&gt;hashcons();</span>
  }
  
  //------------------------------eq---------------------------------------------
  // Structural equality check for Type representations
  bool TypeKlassPtr::eq( const Type *t ) const {
    const TypeKlassPtr *p = t-&gt;is_klassptr();
<span class="line-modified">!   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flat_array() == p-&gt;flat_array();</span>
  }
  
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
  int TypeKlassPtr::hash(void) const {
<span class="line-modified">!   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flat_array());</span>
  }
  
  //------------------------------singleton--------------------------------------
  // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
  // constants
<span class="line-new-header">--- 5340,36 ---</span>
  // Not-null object klass or below
  const TypeKlassPtr *TypeKlassPtr::OBJECT;
  const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
  
  //------------------------------TypeKlassPtr-----------------------------------
<span class="line-modified">! TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flatten_array)</span>
<span class="line-modified">!   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flatten_array(flatten_array) {</span>
<span class="line-modified">!   assert(!klass-&gt;flatten_array() || flatten_array, &quot;Should be flat in array&quot;);</span>
<span class="line-modified">!   assert(!flatten_array || can_be_inline_type(), &quot;Only inline types can be flat in array&quot;);</span>
  }
  
  //------------------------------make-------------------------------------------
  // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
<span class="line-modified">! const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array) {</span>
    assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
<span class="line-modified">!   // Check if this type is known to be flat in arrays</span>
<span class="line-added">+   flatten_array = flatten_array || k-&gt;flatten_array();</span>
<span class="line-added">+   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flatten_array))-&gt;hashcons();</span>
  }
  
  //------------------------------eq---------------------------------------------
  // Structural equality check for Type representations
  bool TypeKlassPtr::eq( const Type *t ) const {
    const TypeKlassPtr *p = t-&gt;is_klassptr();
<span class="line-modified">!   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flatten_array() == p-&gt;flatten_array();</span>
  }
  
  //------------------------------hash-------------------------------------------
  // Type-specific hashing function.
  int TypeKlassPtr::hash(void) const {
<span class="line-modified">!   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flatten_array());</span>
  }
  
  //------------------------------singleton--------------------------------------
  // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
  // constants
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5492,25 ***</span>
  
  
  //------------------------------add_offset-------------------------------------
  // Access internals of klass object
  const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
<span class="line-modified">!   return make(_ptr, klass(), xadd_offset(offset), flat_array());</span>
  }
  
  //------------------------------cast_to_ptr_type-------------------------------
  const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
    assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
    if( ptr == _ptr ) return this;
<span class="line-modified">!   return make(ptr, _klass, _offset, _flat_array);</span>
  }
  
  
  //-----------------------------cast_to_exactness-------------------------------
  const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
    if( klass_is_exact == _klass_is_exact ) return this;
<span class="line-modified">!   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flat_array);</span>
  }
  
  
  //-----------------------------as_instance_type--------------------------------
  // Corresponding type for an instance of the given class.
<span class="line-new-header">--- 5499,25 ---</span>
  
  
  //------------------------------add_offset-------------------------------------
  // Access internals of klass object
  const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
<span class="line-modified">!   return make(_ptr, klass(), xadd_offset(offset), flatten_array());</span>
  }
  
  //------------------------------cast_to_ptr_type-------------------------------
  const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
    assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
    if( ptr == _ptr ) return this;
<span class="line-modified">!   return make(ptr, _klass, _offset, _flatten_array);</span>
  }
  
  
  //-----------------------------cast_to_exactness-------------------------------
  const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
    if( klass_is_exact == _klass_is_exact ) return this;
<span class="line-modified">!   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flatten_array);</span>
  }
  
  
  //-----------------------------as_instance_type--------------------------------
  // Corresponding type for an instance of the given class.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5521,12 ***</span>
    bool    xk = klass_is_exact();
    //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
    const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
    guarantee(toop != NULL, &quot;need type for given klass&quot;);
    toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-modified">!   if (flat_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
<span class="line-modified">!     toop = toop-&gt;is_instptr()-&gt;cast_to_flat_array();</span>
    }
    return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
  }
  
  
<span class="line-new-header">--- 5528,12 ---</span>
    bool    xk = klass_is_exact();
    //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
    const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
    guarantee(toop != NULL, &quot;need type for given klass&quot;);
    toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
<span class="line-modified">!   if (flatten_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {</span>
<span class="line-modified">!     toop = toop-&gt;is_instptr()-&gt;cast_to_flatten_array();</span>
    }
    return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5566,11 ***</span>
      case TopPTR:
        return this;
      case Null:
        if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
      case AnyNull:
<span class="line-modified">!       return make(ptr, klass(), offset, flat_array());</span>
      case BotPTR:
      case NotNull:
        return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
      default: typerr(t);
      }
<span class="line-new-header">--- 5573,11 ---</span>
      case TopPTR:
        return this;
      case Null:
        if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
      case AnyNull:
<span class="line-modified">!       return make(ptr, klass(), offset, flatten_array());</span>
      case BotPTR:
      case NotNull:
        return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
      default: typerr(t);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5607,29 ***</span>
      if (klass() == NULL || tkls-&gt;klass() == NULL) {
        ciKlass* k = NULL;
        if (ptr == Constant) {
          k = (klass() == NULL) ? tkls-&gt;klass() : klass();
        }
<span class="line-modified">!       return make(ptr, k, off, false);</span>
      }
  
      // Check for easy case; klasses are equal (and perhaps not loaded!)
      // If we have constants, then we created oops so classes are loaded
      // and we can handle the constants further down.  This case handles
      // not-loaded classes
<span class="line-modified">!     if (ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) &amp;&amp; flat_array() == tkls-&gt;flat_array()) {</span>
<span class="line-modified">!       return make(ptr, klass(), off, flat_array());</span>
      }
  
      // Classes require inspection in the Java klass hierarchy.  Must be loaded.
      ciKlass* tkls_klass = tkls-&gt;klass();
      ciKlass* this_klass = this-&gt;klass();
      assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
      assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
<span class="line-modified">!     bool tkls_flat_array = tkls-&gt;flat_array();</span>
<span class="line-modified">!     bool this_flat_array  = this-&gt;flat_array();</span>
<span class="line-modified">!     bool flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tkls_flat_array) : (this_flat_array || tkls_flat_array);</span>
  
      // If &#39;this&#39; type is above the centerline and is a superclass of the
      // other, we can treat &#39;this&#39; as having the same type as the other.
      if ((above_centerline(this-&gt;ptr())) &amp;&amp;
          tkls_klass-&gt;is_subtype_of(this_klass)) {
<span class="line-new-header">--- 5614,29 ---</span>
      if (klass() == NULL || tkls-&gt;klass() == NULL) {
        ciKlass* k = NULL;
        if (ptr == Constant) {
          k = (klass() == NULL) ? tkls-&gt;klass() : klass();
        }
<span class="line-modified">!       return make(ptr, k, off);</span>
      }
  
      // Check for easy case; klasses are equal (and perhaps not loaded!)
      // If we have constants, then we created oops so classes are loaded
      // and we can handle the constants further down.  This case handles
      // not-loaded classes
<span class="line-modified">!     if (ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) &amp;&amp; flatten_array() == tkls-&gt;flatten_array()) {</span>
<span class="line-modified">!       return make(ptr, klass(), off, flatten_array());</span>
      }
  
      // Classes require inspection in the Java klass hierarchy.  Must be loaded.
      ciKlass* tkls_klass = tkls-&gt;klass();
      ciKlass* this_klass = this-&gt;klass();
      assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
      assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
<span class="line-modified">!     bool tkls_flatten_array = tkls-&gt;flatten_array();</span>
<span class="line-modified">!     bool this_flatten_array  = this-&gt;flatten_array();</span>
<span class="line-modified">!     bool flatten_array = below_centerline(ptr) ? (this_flatten_array &amp;&amp; tkls_flatten_array) : (this_flatten_array || tkls_flatten_array);</span>
  
      // If &#39;this&#39; type is above the centerline and is a superclass of the
      // other, we can treat &#39;this&#39; as having the same type as the other.
      if ((above_centerline(this-&gt;ptr())) &amp;&amp;
          tkls_klass-&gt;is_subtype_of(this_klass)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5653,30 ***</span>
          else if (above_centerline(this-&gt;ptr()));
          else if (above_centerline(tkls-&gt;ptr()));
          else
            ptr = NotNull;
        }
<span class="line-modified">!       return make(ptr, this_klass, off, flat_array);</span>
      } // Else classes are not equal
  
      // Since klasses are different, we require the LCA in the Java
      // class hierarchy - which means we have to fall to at least NotNull.
      if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
        ptr = NotNull;
      // Now we find the LCA of Java classes
      ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="line-modified">!     return   make(ptr, k, off, k-&gt;is_inlinetype() &amp;&amp; k-&gt;flatten_array());</span>
    } // End of case KlassPtr
  
    } // End of switch
    return this;                  // Return the double constant
  }
  
  //------------------------------xdual------------------------------------------
  // Dual: compute field-by-field dual
  const Type    *TypeKlassPtr::xdual() const {
<span class="line-modified">!   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flat_array());</span>
  }
  
  //------------------------------get_con----------------------------------------
  intptr_t TypeKlassPtr::get_con() const {
    assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
<span class="line-new-header">--- 5660,30 ---</span>
          else if (above_centerline(this-&gt;ptr()));
          else if (above_centerline(tkls-&gt;ptr()));
          else
            ptr = NotNull;
        }
<span class="line-modified">!       return make(ptr, this_klass, off, flatten_array);</span>
      } // Else classes are not equal
  
      // Since klasses are different, we require the LCA in the Java
      // class hierarchy - which means we have to fall to at least NotNull.
      if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
        ptr = NotNull;
      // Now we find the LCA of Java classes
      ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
<span class="line-modified">!     return   make(ptr, k, off);</span>
    } // End of case KlassPtr
  
    } // End of switch
    return this;                  // Return the double constant
  }
  
  //------------------------------xdual------------------------------------------
  // Dual: compute field-by-field dual
  const Type    *TypeKlassPtr::xdual() const {
<span class="line-modified">!   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flatten_array());</span>
  }
  
  //------------------------------get_con----------------------------------------
  intptr_t TypeKlassPtr::get_con() const {
    assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
</pre>
<center><a href="subtypenode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>