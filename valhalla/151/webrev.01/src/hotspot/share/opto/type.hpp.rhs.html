<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_TYPE_HPP
  26 #define SHARE_OPTO_TYPE_HPP
  27 
  28 #include &quot;ci/ciInlineKlass.hpp&quot;
  29 #include &quot;opto/adlcVMDeps.hpp&quot;
  30 #include &quot;runtime/handles.hpp&quot;
  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 
  33 // Portions of code courtesy of Clifford Click
  34 
  35 // Optimization - Graph Style
  36 
  37 
  38 // This class defines a Type lattice.  The lattice is used in the constant
  39 // propagation algorithms, and for some type-checking of the iloc code.
  40 // Basic types include RSD&#39;s (lower bound, upper bound, stride for integers),
  41 // float &amp; double precision constants, sets of data-labels and code-labels.
  42 // The complete lattice is described below.  Subtypes have no relationship to
  43 // up or down in the lattice; that is entirely determined by the behavior of
  44 // the MEET/JOIN functions.
  45 
  46 class Dict;
  47 class Type;
  48 class   TypeD;
  49 class   TypeF;
  50 class   TypeInt;
  51 class   TypeLong;
  52 class   TypeNarrowPtr;
  53 class     TypeNarrowOop;
  54 class     TypeNarrowKlass;
  55 class   TypeAry;
  56 class   TypeTuple;
  57 class   TypeInlineType;
  58 class   TypeVect;
  59 class     TypeVectS;
  60 class     TypeVectD;
  61 class     TypeVectX;
  62 class     TypeVectY;
  63 class     TypeVectZ;
  64 class   TypePtr;
  65 class     TypeRawPtr;
  66 class     TypeOopPtr;
  67 class       TypeInstPtr;
  68 class       TypeAryPtr;
  69 class     TypeKlassPtr;
  70 class     TypeMetadataPtr;
  71 
  72 //------------------------------Type-------------------------------------------
  73 // Basic Type object, represents a set of primitive Values.
  74 // Types are hash-cons&#39;d into a private class dictionary, so only one of each
  75 // different kind of Type exists.  Types are never modified after creation, so
  76 // all their interesting fields are constant.
  77 class Type {
  78   friend class VMStructs;
  79 
  80 public:
  81   enum TYPES {
  82     Bad=0,                      // Type check
  83     Control,                    // Control of code (not in lattice)
  84     Top,                        // Top of the lattice
  85     Int,                        // Integer range (lo-hi)
  86     Long,                       // Long integer range (lo-hi)
  87     Half,                       // Placeholder half of doubleword
  88     NarrowOop,                  // Compressed oop pointer
  89     NarrowKlass,                // Compressed klass pointer
  90 
  91     Tuple,                      // Method signature or object layout
  92     Array,                      // Array types
  93     VectorS,                    //  32bit Vector types
  94     VectorD,                    //  64bit Vector types
  95     VectorX,                    // 128bit Vector types
  96     VectorY,                    // 256bit Vector types
  97     VectorZ,                    // 512bit Vector types
  98     InlineType,                 // Inline type
  99 
 100     AnyPtr,                     // Any old raw, klass, inst, or array pointer
 101     RawPtr,                     // Raw (non-oop) pointers
 102     OopPtr,                     // Any and all Java heap entities
 103     InstPtr,                    // Instance pointers (non-array objects)
 104     AryPtr,                     // Array pointers
 105     // (Ptr order matters:  See is_ptr, isa_ptr, is_oopptr, isa_oopptr.)
 106 
 107     MetadataPtr,                // Generic metadata
 108     KlassPtr,                   // Klass pointers
 109 
 110     Function,                   // Function signature
 111     Abio,                       // Abstract I/O
 112     Return_Address,             // Subroutine return address
 113     Memory,                     // Abstract store
 114     FloatTop,                   // No float value
 115     FloatCon,                   // Floating point constant
 116     FloatBot,                   // Any float value
 117     DoubleTop,                  // No double value
 118     DoubleCon,                  // Double precision constant
 119     DoubleBot,                  // Any double value
 120     Bottom,                     // Bottom of lattice
 121     lastype                     // Bogus ending type (not in lattice)
 122   };
 123 
 124   // Signal values for offsets from a base pointer
 125   enum OFFSET_SIGNALS {
 126     OffsetTop = -2000000000,    // undefined offset
 127     OffsetBot = -2000000001     // any possible offset
 128   };
 129 
 130   class Offset {
 131   private:
 132     int _offset;
 133 
 134   public:
 135     explicit Offset(int offset) : _offset(offset) {}
 136 
 137     const Offset meet(const Offset other) const;
 138     const Offset dual() const;
 139     const Offset add(intptr_t offset) const;
 140     bool operator==(const Offset&amp; other) const {
 141       return _offset == other._offset;
 142     }
 143     bool operator!=(const Offset&amp; other) const {
 144       return _offset != other._offset;
 145     }
 146     int get() const { return _offset; }
 147 
 148     void dump2(outputStream *st) const;
 149 
 150     static const Offset top;
 151     static const Offset bottom;
 152   };
 153 
 154   // Min and max WIDEN values.
 155   enum WIDEN {
 156     WidenMin = 0,
 157     WidenMax = 3
 158   };
 159 
 160 private:
 161   typedef struct {
 162     TYPES                dual_type;
 163     BasicType            basic_type;
 164     const char*          msg;
 165     bool                 isa_oop;
 166     uint                 ideal_reg;
 167     relocInfo::relocType reloc;
 168   } TypeInfo;
 169 
 170   // Dictionary of types shared among compilations.
 171   static Dict* _shared_type_dict;
 172   static const TypeInfo _type_info[];
 173 
 174   static int uhash( const Type *const t );
 175   // Structural equality check.  Assumes that cmp() has already compared
 176   // the _base types and thus knows it can cast &#39;t&#39; appropriately.
 177   virtual bool eq( const Type *t ) const;
 178 
 179   // Top-level hash-table of types
 180   static Dict *type_dict() {
 181     return Compile::current()-&gt;type_dict();
 182   }
 183 
 184   // DUAL operation: reflect around lattice centerline.  Used instead of
 185   // join to ensure my lattice is symmetric up and down.  Dual is computed
 186   // lazily, on demand, and cached in _dual.
 187   const Type *_dual;            // Cached dual value
 188   // Table for efficient dualing of base types
 189   static const TYPES dual_type[lastype];
 190 
 191 #ifdef ASSERT
 192   // One type is interface, the other is oop
 193   virtual bool interface_vs_oop_helper(const Type *t) const;
 194 #endif
 195 
 196   const Type *meet_helper(const Type *t, bool include_speculative) const;
 197   void check_symmetrical(const Type *t, const Type *mt) const;
 198 
 199 protected:
 200   // Each class of type is also identified by its base.
 201   const TYPES _base;            // Enum of Types type
 202 
 203   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 204   // ~Type();                   // Use fast deallocation
 205   const Type *hashcons();       // Hash-cons the type
 206   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 207   const Type *join_helper(const Type *t, bool include_speculative) const {
 208     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 209   }
 210 
 211 public:
 212 
 213   inline void* operator new( size_t x ) throw() {
 214     Compile* compile = Compile::current();
 215     compile-&gt;set_type_last_size(x);
 216     return compile-&gt;type_arena()-&gt;Amalloc_D(x);
 217   }
 218   inline void operator delete( void* ptr ) {
 219     Compile* compile = Compile::current();
 220     compile-&gt;type_arena()-&gt;Afree(ptr,compile-&gt;type_last_size());
 221   }
 222 
 223   // Initialize the type system for a particular compilation.
 224   static void Initialize(Compile* compile);
 225 
 226   // Initialize the types shared by all compilations.
 227   static void Initialize_shared(Compile* compile);
 228 
 229   TYPES base() const {
 230     assert(_base &gt; Bad &amp;&amp; _base &lt; lastype, &quot;sanity&quot;);
 231     return _base;
 232   }
 233 
 234   // Create a new hash-consd type
 235   static const Type *make(enum TYPES);
 236   // Test for equivalence of types
 237   static int cmp( const Type *const t1, const Type *const t2 );
 238   // Test for higher or equal in lattice
 239   // Variant that drops the speculative part of the types
 240   bool higher_equal(const Type *t) const {
 241     return !cmp(meet(t),t-&gt;remove_speculative());
 242   }
 243   // Variant that keeps the speculative part of the types
 244   bool higher_equal_speculative(const Type *t) const {
 245     return !cmp(meet_speculative(t),t);
 246   }
 247 
 248   // MEET operation; lower in lattice.
 249   // Variant that drops the speculative part of the types
 250   const Type *meet(const Type *t) const {
 251     return meet_helper(t, false);
 252   }
 253   // Variant that keeps the speculative part of the types
 254   const Type *meet_speculative(const Type *t) const {
 255     return meet_helper(t, true)-&gt;cleanup_speculative();
 256   }
 257   // WIDEN: &#39;widens&#39; for Ints and other range types
 258   virtual const Type *widen( const Type *old, const Type* limit ) const { return this; }
 259   // NARROW: complement for widen, used by pessimistic phases
 260   virtual const Type *narrow( const Type *old ) const { return this; }
 261 
 262   // DUAL operation: reflect around lattice centerline.  Used instead of
 263   // join to ensure my lattice is symmetric up and down.
 264   const Type *dual() const { return _dual; }
 265 
 266   // Compute meet dependent on base type
 267   virtual const Type *xmeet( const Type *t ) const;
 268   virtual const Type *xdual() const;    // Compute dual right now.
 269 
 270   // JOIN operation; higher in lattice.  Done by finding the dual of the
 271   // meet of the dual of the 2 inputs.
 272   // Variant that drops the speculative part of the types
 273   const Type *join(const Type *t) const {
 274     return join_helper(t, false);
 275   }
 276   // Variant that keeps the speculative part of the types
 277   const Type *join_speculative(const Type *t) const {
 278     return join_helper(t, true)-&gt;cleanup_speculative();
 279   }
 280 
 281   // Modified version of JOIN adapted to the needs Node::Value.
 282   // Normalizes all empty values to TOP.  Does not kill _widen bits.
 283   // Currently, it also works around limitations involving interface types.
 284   // Variant that drops the speculative part of the types
 285   const Type *filter(const Type *kills) const {
 286     return filter_helper(kills, false);
 287   }
 288   // Variant that keeps the speculative part of the types
 289   const Type *filter_speculative(const Type *kills) const {
 290     return filter_helper(kills, true)-&gt;cleanup_speculative();
 291   }
 292 
 293 #ifdef ASSERT
 294   // One type is interface, the other is oop
 295   virtual bool interface_vs_oop(const Type *t) const;
 296 #endif
 297 
 298   // Returns true if this pointer points at memory which contains a
 299   // compressed oop references.
 300   bool is_ptr_to_narrowoop() const;
 301   bool is_ptr_to_narrowklass() const;
 302 
 303   // Convenience access
 304   float getf() const;
 305   double getd() const;
 306 
 307   const TypeInt    *is_int() const;
 308   const TypeInt    *isa_int() const;             // Returns NULL if not an Int
 309   const TypeLong   *is_long() const;
 310   const TypeLong   *isa_long() const;            // Returns NULL if not a Long
 311   const TypeD      *isa_double() const;          // Returns NULL if not a Double{Top,Con,Bot}
 312   const TypeD      *is_double_constant() const;  // Asserts it is a DoubleCon
 313   const TypeD      *isa_double_constant() const; // Returns NULL if not a DoubleCon
 314   const TypeF      *isa_float() const;           // Returns NULL if not a Float{Top,Con,Bot}
 315   const TypeF      *is_float_constant() const;   // Asserts it is a FloatCon
 316   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 317   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 318   const TypeAry    *is_ary() const;              // Array, NOT array pointer
 319   const TypeAry    *isa_ary() const;             // Returns NULL of not ary
 320   const TypeVect   *is_vect() const;             // Vector
 321   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 322   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 323   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 324   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 325   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 326   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 327   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 328   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 329   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 330   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 331   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 332   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 333   const TypeInstPtr  *is_instptr() const;        // Instance
 334   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 335   const TypeAryPtr   *is_aryptr() const;         // Array oop
 336   const TypeInlineType* isa_inlinetype() const;  // Returns NULL if not Inline Type
 337   const TypeInlineType* is_inlinetype() const;   // Inline Type
 338 
 339   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 340   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 341   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
 342   const TypeKlassPtr      *is_klassptr() const;       // assert if not KlassPtr
 343 
 344   virtual bool      is_finite() const;           // Has a finite value
 345   virtual bool      is_nan()    const;           // Is not a number (NaN)
 346 
 347   bool is_inlinetypeptr() const;
 348   virtual ciInlineKlass* inline_klass() const;
 349 
 350   // Returns this ptr type or the equivalent ptr type for this compressed pointer.
 351   const TypePtr* make_ptr() const;
 352 
 353   // Returns this oopptr type or the equivalent oopptr type for this compressed pointer.
 354   // Asserts if the underlying type is not an oopptr or narrowoop.
 355   const TypeOopPtr* make_oopptr() const;
 356 
 357   // Returns this compressed pointer or the equivalent compressed version
 358   // of this pointer type.
 359   const TypeNarrowOop* make_narrowoop() const;
 360 
 361   // Returns this compressed klass pointer or the equivalent
 362   // compressed version of this pointer type.
 363   const TypeNarrowKlass* make_narrowklass() const;
 364 
 365   // Special test for register pressure heuristic
 366   bool is_floatingpoint() const;        // True if Float or Double base type
 367 
 368   // Do you have memory, directly or through a tuple?
 369   bool has_memory( ) const;
 370 
 371   // TRUE if type is a singleton
 372   virtual bool singleton(void) const;
 373 
 374   // TRUE if type is above the lattice centerline, and is therefore vacuous
 375   virtual bool empty(void) const;
 376 
 377   // Return a hash for this type.  The hash function is public so ConNode
 378   // (constants) can hash on their constant, which is represented by a Type.
 379   virtual int hash() const;
 380 
 381   // Map ideal registers (machine types) to ideal types
 382   static const Type *mreg2type[];
 383 
 384   // Printing, statistics
 385 #ifndef PRODUCT
 386   void         dump_on(outputStream *st) const;
 387   void         dump() const {
 388     dump_on(tty);
 389   }
 390   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 391   static  void dump_stats();
 392 
 393   static const char* str(const Type* t);
 394 #endif
 395   void typerr(const Type *t) const; // Mixing types error
 396 
 397   // Create basic type
 398   static const Type* get_const_basic_type(BasicType type) {
 399     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _const_basic_type[type] != NULL, &quot;bad type&quot;);
 400     return _const_basic_type[type];
 401   }
 402 
 403   // For two instance arrays of same dimension, return the base element types.
 404   // Otherwise or if the arrays have different dimensions, return NULL.
 405   static void get_arrays_base_elements(const Type *a1, const Type *a2,
 406                                        const TypeInstPtr **e1, const TypeInstPtr **e2);
 407 
 408   // Mapping to the array element&#39;s basic type.
 409   BasicType array_element_basic_type() const;
 410 
 411   // Create standard type for a ciType:
 412   static const Type* get_const_type(ciType* type);
 413 
 414   // Create standard zero value:
 415   static const Type* get_zero_type(BasicType type) {
 416     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _zero_type[type] != NULL, &quot;bad type&quot;);
 417     return _zero_type[type];
 418   }
 419 
 420   // Report if this is a zero value (not top).
 421   bool is_zero_type() const {
 422     BasicType type = basic_type();
 423     if (type == T_VOID || type &gt;= T_CONFLICT)
 424       return false;
 425     else
 426       return (this == _zero_type[type]);
 427   }
 428 
 429   // Convenience common pre-built types.
 430   static const Type *ABIO;
 431   static const Type *BOTTOM;
 432   static const Type *CONTROL;
 433   static const Type *DOUBLE;
 434   static const Type *FLOAT;
 435   static const Type *HALF;
 436   static const Type *MEMORY;
 437   static const Type *MULTI;
 438   static const Type *RETURN_ADDRESS;
 439   static const Type *TOP;
 440 
 441   // Mapping from compiler type to VM BasicType
 442   BasicType basic_type() const       { return _type_info[_base].basic_type; }
 443   uint ideal_reg() const             { return _type_info[_base].ideal_reg; }
 444   const char* msg() const            { return _type_info[_base].msg; }
 445   bool isa_oop_ptr() const           { return _type_info[_base].isa_oop; }
 446   relocInfo::relocType reloc() const { return _type_info[_base].reloc; }
 447 
 448   // Mapping from CI type system to compiler type:
 449   static const Type* get_typeflow_type(ciType* type);
 450 
 451   static const Type* make_from_constant(ciConstant constant,
 452                                         bool require_constant = false,
 453                                         int stable_dimension = 0,
 454                                         bool is_narrow = false,
 455                                         bool is_autobox_cache = false);
 456 
 457   static const Type* make_constant_from_field(ciInstance* holder,
 458                                               int off,
 459                                               bool is_unsigned_load,
 460                                               BasicType loadbt);
 461 
 462   static const Type* make_constant_from_field(ciField* field,
 463                                               ciInstance* holder,
 464                                               BasicType loadbt,
 465                                               bool is_unsigned_load);
 466 
 467   static const Type* make_constant_from_array_element(ciArray* array,
 468                                                       int off,
 469                                                       int stable_dimension,
 470                                                       BasicType loadbt,
 471                                                       bool is_unsigned_load);
 472 
 473   // Speculative type helper methods. See TypePtr.
 474   virtual const TypePtr* speculative() const                                  { return NULL; }
 475   virtual ciKlass* speculative_type() const                                   { return NULL; }
 476   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 477   virtual bool speculative_maybe_null() const                                 { return true; }
 478   virtual bool speculative_always_null() const                                { return true; }
 479   virtual const Type* remove_speculative() const                              { return this; }
 480   virtual const Type* cleanup_speculative() const                             { return this; }
 481   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 482   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 483   const Type* maybe_remove_speculative(bool include_speculative) const;
 484 
 485   virtual bool maybe_null() const { return true; }
 486   virtual bool is_known_instance() const { return false; }
 487 
 488 private:
 489   // support arrays
 490   static const Type*        _zero_type[T_CONFLICT+1];
 491   static const Type* _const_basic_type[T_CONFLICT+1];
 492 };
 493 
 494 //------------------------------TypeF------------------------------------------
 495 // Class of Float-Constant Types.
 496 class TypeF : public Type {
 497   TypeF( float f ) : Type(FloatCon), _f(f) {};
 498 public:
 499   virtual bool eq( const Type *t ) const;
 500   virtual int  hash() const;             // Type specific hashing
 501   virtual bool singleton(void) const;    // TRUE if type is a singleton
 502   virtual bool empty(void) const;        // TRUE if type is vacuous
 503 public:
 504   const float _f;               // Float constant
 505 
 506   static const TypeF *make(float f);
 507 
 508   virtual bool        is_finite() const;  // Has a finite value
 509   virtual bool        is_nan()    const;  // Is not a number (NaN)
 510 
 511   virtual const Type *xmeet( const Type *t ) const;
 512   virtual const Type *xdual() const;    // Compute dual right now.
 513   // Convenience common pre-built types.
 514   static const TypeF *ZERO; // positive zero only
 515   static const TypeF *ONE;
 516   static const TypeF *POS_INF;
 517   static const TypeF *NEG_INF;
 518 #ifndef PRODUCT
 519   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 520 #endif
 521 };
 522 
 523 //------------------------------TypeD------------------------------------------
 524 // Class of Double-Constant Types.
 525 class TypeD : public Type {
 526   TypeD( double d ) : Type(DoubleCon), _d(d) {};
 527 public:
 528   virtual bool eq( const Type *t ) const;
 529   virtual int  hash() const;             // Type specific hashing
 530   virtual bool singleton(void) const;    // TRUE if type is a singleton
 531   virtual bool empty(void) const;        // TRUE if type is vacuous
 532 public:
 533   const double _d;              // Double constant
 534 
 535   static const TypeD *make(double d);
 536 
 537   virtual bool        is_finite() const;  // Has a finite value
 538   virtual bool        is_nan()    const;  // Is not a number (NaN)
 539 
 540   virtual const Type *xmeet( const Type *t ) const;
 541   virtual const Type *xdual() const;    // Compute dual right now.
 542   // Convenience common pre-built types.
 543   static const TypeD *ZERO; // positive zero only
 544   static const TypeD *ONE;
 545   static const TypeD *POS_INF;
 546   static const TypeD *NEG_INF;
 547 #ifndef PRODUCT
 548   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 549 #endif
 550 };
 551 
 552 //------------------------------TypeInt----------------------------------------
 553 // Class of integer ranges, the set of integers between a lower bound and an
 554 // upper bound, inclusive.
 555 class TypeInt : public Type {
 556   TypeInt( jint lo, jint hi, int w );
 557 protected:
 558   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 559 
 560 public:
 561   typedef jint NativeType;
 562   virtual bool eq( const Type *t ) const;
 563   virtual int  hash() const;             // Type specific hashing
 564   virtual bool singleton(void) const;    // TRUE if type is a singleton
 565   virtual bool empty(void) const;        // TRUE if type is vacuous
 566   const jint _lo, _hi;          // Lower bound, upper bound
 567   const short _widen;           // Limit on times we widen this sucker
 568 
 569   static const TypeInt *make(jint lo);
 570   // must always specify w
 571   static const TypeInt *make(jint lo, jint hi, int w);
 572 
 573   // Check for single integer
 574   int is_con() const { return _lo==_hi; }
 575   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 576   jint get_con() const { assert( is_con(), &quot;&quot; );  return _lo; }
 577 
 578   virtual bool        is_finite() const;  // Has a finite value
 579 
 580   virtual const Type *xmeet( const Type *t ) const;
 581   virtual const Type *xdual() const;    // Compute dual right now.
 582   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 583   virtual const Type *narrow( const Type *t ) const;
 584   // Do not kill _widen bits.
 585   // Convenience common pre-built types.
 586   static const TypeInt *MINUS_1;
 587   static const TypeInt *ZERO;
 588   static const TypeInt *ONE;
 589   static const TypeInt *BOOL;
 590   static const TypeInt *CC;
 591   static const TypeInt *CC_LT;  // [-1]  == MINUS_1
 592   static const TypeInt *CC_GT;  // [1]   == ONE
 593   static const TypeInt *CC_EQ;  // [0]   == ZERO
 594   static const TypeInt *CC_LE;  // [-1,0]
 595   static const TypeInt *CC_GE;  // [0,1] == BOOL (!)
 596   static const TypeInt *BYTE;
 597   static const TypeInt *UBYTE;
 598   static const TypeInt *CHAR;
 599   static const TypeInt *SHORT;
 600   static const TypeInt *POS;
 601   static const TypeInt *POS1;
 602   static const TypeInt *INT;
 603   static const TypeInt *SYMINT; // symmetric range [-max_jint..max_jint]
 604   static const TypeInt *TYPE_DOMAIN; // alias for TypeInt::INT
 605 
 606   static const TypeInt *as_self(const Type *t) { return t-&gt;is_int(); }
 607 #ifndef PRODUCT
 608   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 609 #endif
 610 };
 611 
 612 
 613 //------------------------------TypeLong---------------------------------------
 614 // Class of long integer ranges, the set of integers between a lower bound and
 615 // an upper bound, inclusive.
 616 class TypeLong : public Type {
 617   TypeLong( jlong lo, jlong hi, int w );
 618 protected:
 619   // Do not kill _widen bits.
 620   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 621 public:
 622   typedef jlong NativeType;
 623   virtual bool eq( const Type *t ) const;
 624   virtual int  hash() const;             // Type specific hashing
 625   virtual bool singleton(void) const;    // TRUE if type is a singleton
 626   virtual bool empty(void) const;        // TRUE if type is vacuous
 627 public:
 628   const jlong _lo, _hi;         // Lower bound, upper bound
 629   const short _widen;           // Limit on times we widen this sucker
 630 
 631   static const TypeLong *make(jlong lo);
 632   // must always specify w
 633   static const TypeLong *make(jlong lo, jlong hi, int w);
 634 
 635   // Check for single integer
 636   int is_con() const { return _lo==_hi; }
 637   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 638   jlong get_con() const { assert( is_con(), &quot;&quot; ); return _lo; }
 639 
 640   // Check for positive 32-bit value.
 641   int is_positive_int() const { return _lo &gt;= 0 &amp;&amp; _hi &lt;= (jlong)max_jint; }
 642 
 643   virtual bool        is_finite() const;  // Has a finite value
 644 
 645 
 646   virtual const Type *xmeet( const Type *t ) const;
 647   virtual const Type *xdual() const;    // Compute dual right now.
 648   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 649   virtual const Type *narrow( const Type *t ) const;
 650   // Convenience common pre-built types.
 651   static const TypeLong *MINUS_1;
 652   static const TypeLong *ZERO;
 653   static const TypeLong *ONE;
 654   static const TypeLong *POS;
 655   static const TypeLong *LONG;
 656   static const TypeLong *INT;    // 32-bit subrange [min_jint..max_jint]
 657   static const TypeLong *UINT;   // 32-bit unsigned [0..max_juint]
 658   static const TypeLong *TYPE_DOMAIN; // alias for TypeLong::LONG
 659 
 660   // static convenience methods.
 661   static const TypeLong *as_self(const Type *t) { return t-&gt;is_long(); }
 662 
 663 #ifndef PRODUCT
 664   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const;// Specialized per-Type dumping
 665 #endif
 666 };
 667 
 668 //------------------------------TypeTuple--------------------------------------
 669 // Class of Tuple Types, essentially type collections for function signatures
 670 // and class layouts.  It happens to also be a fast cache for the HotSpot
 671 // signature types.
 672 class TypeTuple : public Type {
 673   TypeTuple( uint cnt, const Type **fields ) : Type(Tuple), _cnt(cnt), _fields(fields) { }
 674 
 675   const uint          _cnt;              // Count of fields
 676   const Type ** const _fields;           // Array of field types
 677 
 678 public:
 679   virtual bool eq( const Type *t ) const;
 680   virtual int  hash() const;             // Type specific hashing
 681   virtual bool singleton(void) const;    // TRUE if type is a singleton
 682   virtual bool empty(void) const;        // TRUE if type is vacuous
 683 
 684   // Accessors:
 685   uint cnt() const { return _cnt; }
 686   const Type* field_at(uint i) const {
 687     assert(i &lt; _cnt, &quot;oob&quot;);
 688     return _fields[i];
 689   }
 690   void set_field_at(uint i, const Type* t) {
 691     assert(i &lt; _cnt, &quot;oob&quot;);
 692     _fields[i] = t;
 693   }
 694 
 695   static const TypeTuple *make( uint cnt, const Type **fields );
 696   static const TypeTuple *make_range(ciSignature* sig, bool ret_vt_fields = false);
 697   static const TypeTuple *make_domain(ciMethod* method, bool vt_fields_as_args = false);
 698 
 699   // Subroutine call type with space allocated for argument types
 700   // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
 701   static const Type **fields( uint arg_cnt );
 702 
 703   virtual const Type *xmeet( const Type *t ) const;
 704   virtual const Type *xdual() const;    // Compute dual right now.
 705   // Convenience common pre-built types.
 706   static const TypeTuple *IFBOTH;
 707   static const TypeTuple *IFFALSE;
 708   static const TypeTuple *IFTRUE;
 709   static const TypeTuple *IFNEITHER;
 710   static const TypeTuple *LOOPBODY;
 711   static const TypeTuple *MEMBAR;
 712   static const TypeTuple *STORECONDITIONAL;
 713   static const TypeTuple *START_I2C;
 714   static const TypeTuple *INT_PAIR;
 715   static const TypeTuple *LONG_PAIR;
 716   static const TypeTuple *INT_CC_PAIR;
 717   static const TypeTuple *LONG_CC_PAIR;
 718 #ifndef PRODUCT
 719   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 720 #endif
 721 };
 722 
 723 //------------------------------TypeAry----------------------------------------
 724 // Class of Array Types
 725 class TypeAry : public Type {
 726   TypeAry(const Type* elem, const TypeInt* size, bool stable, bool not_flat, bool not_null_free) : Type(Array),
 727       _elem(elem), _size(size), _stable(stable), _not_flat(not_flat), _not_null_free(not_null_free) {}
 728 public:
 729   virtual bool eq( const Type *t ) const;
 730   virtual int  hash() const;             // Type specific hashing
 731   virtual bool singleton(void) const;    // TRUE if type is a singleton
 732   virtual bool empty(void) const;        // TRUE if type is vacuous
 733 
 734 private:
 735   const Type *_elem;            // Element type of array
 736   const TypeInt *_size;         // Elements in array
 737   const bool _stable;           // Are elements @Stable?
 738 
 739   // Inline type array properties
 740   const bool _not_flat;         // Array is never flattened
 741   const bool _not_null_free;    // Array is never null-free
 742 
 743   friend class TypeAryPtr;
 744 
 745 public:
 746   static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false,
 747                              bool not_flat = false, bool not_null_free = false);
 748 
 749   virtual const Type *xmeet( const Type *t ) const;
 750   virtual const Type *xdual() const;    // Compute dual right now.
 751   bool ary_must_be_exact() const;  // true if arrays of such are never generic
 752   virtual const Type* remove_speculative() const;
 753   virtual const Type* cleanup_speculative() const;
 754 
 755 #ifdef ASSERT
 756   // One type is interface, the other is oop
 757   virtual bool interface_vs_oop(const Type *t) const;
 758 #endif
 759 #ifndef PRODUCT
 760   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 761 #endif
 762 };
 763 
 764 
 765 //------------------------------TypeValue---------------------------------------
 766 // Class of Inline Type Types
 767 class TypeInlineType : public Type {
 768 private:
 769   ciInlineKlass* _vk;
 770   bool _larval;
 771 
 772 protected:
 773   TypeInlineType(ciInlineKlass* vk, bool larval)
 774     : Type(InlineType),
 775       _vk(vk), _larval(larval) {
 776   }
 777 
 778 public:
 779   static const TypeInlineType* make(ciInlineKlass* vk, bool larval = false);
 780   virtual ciInlineKlass* inline_klass() const { return _vk; }
 781   bool larval() const { return _larval; }
 782 
 783   virtual bool eq(const Type* t) const;
 784   virtual int  hash() const;             // Type specific hashing
 785   virtual bool singleton(void) const;    // TRUE if type is a singleton
 786   virtual bool empty(void) const;        // TRUE if type is vacuous
 787 
 788   virtual const Type* xmeet(const Type* t) const;
 789   virtual const Type* xdual() const;     // Compute dual right now.
 790 
 791   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return false; }
 792   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return false; }
 793 
 794   static const TypeInlineType* BOTTOM;
 795 
 796 #ifndef PRODUCT
 797   virtual void dump2(Dict &amp;d, uint, outputStream* st) const; // Specialized per-Type dumping
 798 #endif
 799 };
 800 
 801 //------------------------------TypeVect---------------------------------------
 802 // Class of Vector Types
 803 class TypeVect : public Type {
 804   const Type*   _elem;  // Vector&#39;s element type
 805   const uint  _length;  // Elements in vector (power of 2)
 806 
 807 protected:
 808   TypeVect(TYPES t, const Type* elem, uint length) : Type(t),
 809     _elem(elem), _length(length) {}
 810 
 811 public:
 812   const Type* element_type() const { return _elem; }
 813   BasicType element_basic_type() const { return _elem-&gt;array_element_basic_type(); }
 814   uint length() const { return _length; }
 815   uint length_in_bytes() const {
 816    return _length * type2aelembytes(element_basic_type());
 817   }
 818 
 819   virtual bool eq(const Type *t) const;
 820   virtual int  hash() const;             // Type specific hashing
 821   virtual bool singleton(void) const;    // TRUE if type is a singleton
 822   virtual bool empty(void) const;        // TRUE if type is vacuous
 823 
 824   static const TypeVect *make(const BasicType elem_bt, uint length) {
 825     // Use bottom primitive type.
 826     return make(get_const_basic_type(elem_bt), length);
 827   }
 828   // Used directly by Replicate nodes to construct singleton vector.
 829   static const TypeVect *make(const Type* elem, uint length);
 830 
 831   virtual const Type *xmeet( const Type *t) const;
 832   virtual const Type *xdual() const;     // Compute dual right now.
 833 
 834   static const TypeVect *VECTS;
 835   static const TypeVect *VECTD;
 836   static const TypeVect *VECTX;
 837   static const TypeVect *VECTY;
 838   static const TypeVect *VECTZ;
 839 
 840 #ifndef PRODUCT
 841   virtual void dump2(Dict &amp;d, uint, outputStream *st) const; // Specialized per-Type dumping
 842 #endif
 843 };
 844 
 845 class TypeVectS : public TypeVect {
 846   friend class TypeVect;
 847   TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}
 848 };
 849 
 850 class TypeVectD : public TypeVect {
 851   friend class TypeVect;
 852   TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}
 853 };
 854 
 855 class TypeVectX : public TypeVect {
 856   friend class TypeVect;
 857   TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}
 858 };
 859 
 860 class TypeVectY : public TypeVect {
 861   friend class TypeVect;
 862   TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}
 863 };
 864 
 865 class TypeVectZ : public TypeVect {
 866   friend class TypeVect;
 867   TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}
 868 };
 869 
 870 //------------------------------TypePtr----------------------------------------
 871 // Class of machine Pointer Types: raw data, instances or arrays.
 872 // If the _base enum is AnyPtr, then this refers to all of the above.
 873 // Otherwise the _base will indicate which subset of pointers is affected,
 874 // and the class will be inherited from.
 875 class TypePtr : public Type {
 876   friend class TypeNarrowPtr;
 877 public:
 878   enum PTR { TopPTR, AnyNull, Constant, Null, NotNull, BotPTR, lastPTR };
 879 protected:
 880   TypePtr(TYPES t, PTR ptr, Offset offset,
 881           const TypePtr* speculative = NULL,
 882           int inline_depth = InlineDepthBottom) :
 883     Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset),
 884     _ptr(ptr) {}
 885   static const PTR ptr_meet[lastPTR][lastPTR];
 886   static const PTR ptr_dual[lastPTR];
 887   static const char * const ptr_msg[lastPTR];
 888 
 889   enum {
 890     InlineDepthBottom = INT_MAX,
 891     InlineDepthTop = -InlineDepthBottom
 892   };
 893 
 894   // Extra type information profiling gave us. We propagate it the
 895   // same way the rest of the type info is propagated. If we want to
 896   // use it, then we have to emit a guard: this part of the type is
 897   // not something we know but something we speculate about the type.
 898   const TypePtr*   _speculative;
 899   // For speculative types, we record at what inlining depth the
 900   // profiling point that provided the data is. We want to favor
 901   // profile data coming from outer scopes which are likely better for
 902   // the current compilation.
 903   int _inline_depth;
 904 
 905   // utility methods to work on the speculative part of the type
 906   const TypePtr* dual_speculative() const;
 907   const TypePtr* xmeet_speculative(const TypePtr* other) const;
 908   bool eq_speculative(const TypePtr* other) const;
 909   int hash_speculative() const;
 910   const TypePtr* add_offset_speculative(intptr_t offset) const;
 911 #ifndef PRODUCT
 912   void dump_speculative(outputStream *st) const;
 913 #endif
 914 
 915   // utility methods to work on the inline depth of the type
 916   int dual_inline_depth() const;
 917   int meet_inline_depth(int depth) const;
 918 #ifndef PRODUCT
 919   void dump_inline_depth(outputStream *st) const;
 920 #endif
 921 
 922 public:
 923   const Offset _offset;         // Offset into oop, with TOP &amp; BOT
 924   const PTR _ptr;               // Pointer equivalence class
 925 
 926   const int offset() const { return _offset.get(); }
 927   const PTR ptr()    const { return _ptr; }
 928 
 929   static const TypePtr* make(TYPES t, PTR ptr, Offset offset,
 930                              const TypePtr* speculative = NULL,
 931                              int inline_depth = InlineDepthBottom);
 932 
 933   // Return a &#39;ptr&#39; version of this type
 934   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 935 
 936   virtual intptr_t get_con() const;
 937 
 938   Offset xadd_offset(intptr_t offset) const;
 939   virtual const TypePtr *add_offset( intptr_t offset ) const;
 940   virtual const int flattened_offset() const { return offset(); }
 941 
 942   virtual bool eq(const Type *t) const;
 943   virtual int  hash() const;             // Type specific hashing
 944 
 945   virtual bool singleton(void) const;    // TRUE if type is a singleton
 946   virtual bool empty(void) const;        // TRUE if type is vacuous
 947   virtual const Type *xmeet( const Type *t ) const;
 948   virtual const Type *xmeet_helper( const Type *t ) const;
 949   Offset meet_offset(int offset) const;
 950   Offset dual_offset() const;
 951   virtual const Type *xdual() const;    // Compute dual right now.
 952 
 953   // meet, dual and join over pointer equivalence sets
 954   PTR meet_ptr( const PTR in_ptr ) const { return ptr_meet[in_ptr][ptr()]; }
 955   PTR dual_ptr()                   const { return ptr_dual[ptr()];      }
 956 
 957   // This is textually confusing unless one recalls that
 958   // join(t) == dual()-&gt;meet(t-&gt;dual())-&gt;dual().
 959   PTR join_ptr( const PTR in_ptr ) const {
 960     return ptr_dual[ ptr_meet[ ptr_dual[in_ptr] ] [ dual_ptr() ] ];
 961   }
 962 
 963   // Speculative type helper methods.
 964   virtual const TypePtr* speculative() const { return _speculative; }
 965   int inline_depth() const                   { return _inline_depth; }
 966   virtual ciKlass* speculative_type() const;
 967   virtual ciKlass* speculative_type_not_null() const;
 968   virtual bool speculative_maybe_null() const;
 969   virtual bool speculative_always_null() const;
 970   virtual const Type* remove_speculative() const;
 971   virtual const Type* cleanup_speculative() const;
 972   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
 973   virtual bool would_improve_ptr(ProfilePtrKind maybe_null) const;
 974   virtual const TypePtr* with_inline_depth(int depth) const;
 975 
 976   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 977 
 978   virtual bool can_be_inline_type() const { return false; }
<a name="1" id="anc1"></a><span class="line-modified"> 979   virtual bool flatten_array() const { return false; }</span>
 980 
 981   // Tests for relation to centerline of type lattice:
 982   static bool above_centerline(PTR ptr) { return (ptr &lt;= AnyNull); }
 983   static bool below_centerline(PTR ptr) { return (ptr &gt;= NotNull); }
 984   // Convenience common pre-built types.
 985   static const TypePtr *NULL_PTR;
 986   static const TypePtr *NOTNULL;
 987   static const TypePtr *BOTTOM;
 988 #ifndef PRODUCT
 989   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 990 #endif
 991 };
 992 
 993 //------------------------------TypeRawPtr-------------------------------------
 994 // Class of raw pointers, pointers to things other than Oops.  Examples
 995 // include the stack pointer, top of heap, card-marking area, handles, etc.
 996 class TypeRawPtr : public TypePtr {
 997 protected:
 998   TypeRawPtr(PTR ptr, address bits) : TypePtr(RawPtr,ptr,Offset(0)), _bits(bits){}
 999 public:
1000   virtual bool eq( const Type *t ) const;
1001   virtual int  hash() const;     // Type specific hashing
1002 
1003   const address _bits;          // Constant value, if applicable
1004 
1005   static const TypeRawPtr *make( PTR ptr );
1006   static const TypeRawPtr *make( address bits );
1007 
1008   // Return a &#39;ptr&#39; version of this type
1009   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1010 
1011   virtual intptr_t get_con() const;
1012 
1013   virtual const TypePtr *add_offset( intptr_t offset ) const;
1014 
1015   virtual const Type *xmeet( const Type *t ) const;
1016   virtual const Type *xdual() const;    // Compute dual right now.
1017   // Convenience common pre-built types.
1018   static const TypeRawPtr *BOTTOM;
1019   static const TypeRawPtr *NOTNULL;
1020 #ifndef PRODUCT
1021   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
1022 #endif
1023 };
1024 
1025 //------------------------------TypeOopPtr-------------------------------------
1026 // Some kind of oop (Java pointer), either instance or array.
1027 class TypeOopPtr : public TypePtr {
1028 protected:
1029   TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,
1030              int instance_id, const TypePtr* speculative, int inline_depth);
1031 public:
1032   virtual bool eq( const Type *t ) const;
1033   virtual int  hash() const;             // Type specific hashing
1034   virtual bool singleton(void) const;    // TRUE if type is a singleton
1035   enum {
1036    InstanceTop = -1,   // undefined instance
1037    InstanceBot = 0     // any possible instance
1038   };
1039 protected:
1040 
1041   // Oop is NULL, unless this is a constant oop.
1042   ciObject*     _const_oop;   // Constant oop
1043   // If _klass is NULL, then so is _sig.  This is an unloaded klass.
1044   ciKlass*      _klass;       // Klass object
1045   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1046   bool          _klass_is_exact;
1047   bool          _is_ptr_to_narrowoop;
1048   bool          _is_ptr_to_narrowklass;
1049   bool          _is_ptr_to_boxed_value;
1050 
1051   // If not InstanceTop or InstanceBot, indicates that this is
1052   // a particular instance of this type which is distinct.
1053   // This is the node index of the allocation node creating this instance.
1054   int           _instance_id;
1055 
1056   static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
1057 
1058   int dual_instance_id() const;
1059   int meet_instance_id(int uid) const;
1060 
1061   // Do not allow interface-vs.-noninterface joins to collapse to top.
1062   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1063 
1064 public:
1065   // Creates a type given a klass. Correctly handles multi-dimensional arrays
1066   // Respects UseUniqueSubclasses.
1067   // If the klass is final, the resulting type will be exact.
1068   static const TypeOopPtr* make_from_klass(ciKlass* klass) {
1069     return make_from_klass_common(klass, true, false);
1070   }
1071   // Same as before, but will produce an exact type, even if
1072   // the klass is not final, as long as it has exactly one implementation.
1073   static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {
1074     return make_from_klass_common(klass, true, true);
1075   }
1076   // Same as before, but does not respects UseUniqueSubclasses.
1077   // Use this only for creating array element types.
1078   static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {
1079     return make_from_klass_common(klass, false, false);
1080   }
1081   // Creates a singleton type given an object.
1082   // If the object cannot be rendered as a constant,
1083   // may return a non-singleton type.
1084   // If require_constant, produce a NULL if a singleton is not possible.
1085   static const TypeOopPtr* make_from_constant(ciObject* o,
1086                                               bool require_constant = false);
1087 
1088   // Make a generic (unclassed) pointer to an oop.
1089   static const TypeOopPtr* make(PTR ptr, Offset offset, int instance_id,
1090                                 const TypePtr* speculative = NULL,
1091                                 int inline_depth = InlineDepthBottom);
1092 
1093   ciObject* const_oop()    const { return _const_oop; }
1094   virtual ciKlass* klass() const { return _klass;     }
1095   bool klass_is_exact()    const { return _klass_is_exact; }
1096 
1097   // Returns true if this pointer points at memory which contains a
1098   // compressed oop references.
1099   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1100   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1101   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1102   bool is_known_instance()       const { return _instance_id &gt; 0; }
1103   int  instance_id()             const { return _instance_id; }
1104   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset.get() &gt;= 0; }
1105 
1106   virtual bool can_be_inline_type() const { return EnableValhalla &amp;&amp; (_klass == NULL || _klass-&gt;can_be_inline_klass(_klass_is_exact)); }
1107 
1108   virtual intptr_t get_con() const;
1109 
1110   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1111 
1112   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1113 
1114   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1115 
<a name="2" id="anc2"></a>


1116   virtual const TypePtr *add_offset( intptr_t offset ) const;
1117 
1118   // Speculative type helper methods.
1119   virtual const Type* remove_speculative() const;
1120   virtual const Type* cleanup_speculative() const;
1121   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1122   virtual const TypePtr* with_inline_depth(int depth) const;
1123 
1124   virtual const TypePtr* with_instance_id(int instance_id) const;
1125 
1126   virtual const Type *xdual() const;    // Compute dual right now.
1127   // the core of the computation of the meet for TypeOopPtr and for its subclasses
1128   virtual const Type *xmeet_helper(const Type *t) const;
1129 
1130   // Convenience common pre-built type.
1131   static const TypeOopPtr *BOTTOM;
1132 #ifndef PRODUCT
1133   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1134 #endif
1135 };
1136 
1137 //------------------------------TypeInstPtr------------------------------------
1138 // Class of Java object pointers, pointing either to non-array Java instances
1139 // or to a Klass* (including array klasses).
1140 class TypeInstPtr : public TypeOopPtr {
1141   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
<a name="3" id="anc3"></a><span class="line-modified">1142               bool flatten_array, int instance_id, const TypePtr* speculative,</span>
1143               int inline_depth);
1144   virtual bool eq( const Type *t ) const;
1145   virtual int  hash() const;             // Type specific hashing
1146 
1147   ciSymbol*  _name;        // class name
<a name="4" id="anc4"></a><span class="line-modified">1148   bool _flatten_array;     // Type is flat in arrays</span>
1149 
1150  public:
1151   ciSymbol* name()         const { return _name; }
1152 
1153   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1154 
1155   // Make a pointer to a constant oop.
1156   static const TypeInstPtr *make(ciObject* o) {
<a name="5" id="anc5"></a><span class="line-modified">1157     return make(TypePtr::Constant, o-&gt;klass(), true, o, Offset(0));</span>
1158   }
1159   // Make a pointer to a constant oop with offset.
1160   static const TypeInstPtr* make(ciObject* o, Offset offset) {
<a name="6" id="anc6"></a><span class="line-modified">1161     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset);</span>
1162   }
1163 
1164   // Make a pointer to some value of type klass.
1165   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
<a name="7" id="anc7"></a><span class="line-modified">1166     return make(ptr, klass, false, NULL, Offset(0));</span>
1167   }
1168 
1169   // Make a pointer to some non-polymorphic value of exactly type klass.
1170   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
<a name="8" id="anc8"></a><span class="line-modified">1171     return make(ptr, klass, true, NULL, Offset(0));</span>
1172   }
1173 
1174   // Make a pointer to some value of type klass with offset.
1175   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, Offset offset) {
<a name="9" id="anc9"></a><span class="line-modified">1176     return make(ptr, klass, false, NULL, offset);</span>
1177   }
1178 
1179   // Make a pointer to an oop.
1180   static const TypeInstPtr* make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
<a name="10" id="anc10"></a><span class="line-modified">1181                                  bool flatten_array = false,</span>
1182                                  int instance_id = InstanceBot,
1183                                  const TypePtr* speculative = NULL,
1184                                  int inline_depth = InlineDepthBottom);
1185 
1186   /** Create constant type for a constant boxed value */
1187   const Type* get_const_boxed_value() const;
1188 
1189   // If this is a java.lang.Class constant, return the type for it or NULL.
1190   // Pass to Type::get_const_type to turn it to a type, which will usually
1191   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1192   ciType* java_mirror_type() const;
1193 
1194   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1195 
1196   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1197 
1198   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1199 
1200   virtual const TypePtr *add_offset( intptr_t offset ) const;
1201 
1202   // Speculative type helper methods.
1203   virtual const Type* remove_speculative() const;
1204   virtual const TypePtr* with_inline_depth(int depth) const;
1205   virtual const TypePtr* with_instance_id(int instance_id) const;
1206 
<a name="11" id="anc11"></a><span class="line-modified">1207   virtual const TypeInstPtr* cast_to_flatten_array() const;</span>
<span class="line-modified">1208   virtual bool flatten_array() const { return _flatten_array; }</span>




1209 
1210   // the core of the computation of the meet of 2 types
1211   virtual const Type *xmeet_helper(const Type *t) const;
1212   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1213   virtual const Type *xdual() const;    // Compute dual right now.
1214 
1215   // Convenience common pre-built types.
1216   static const TypeInstPtr *NOTNULL;
1217   static const TypeInstPtr *BOTTOM;
1218   static const TypeInstPtr *MIRROR;
1219   static const TypeInstPtr *MARK;
1220   static const TypeInstPtr *KLASS;
1221 #ifndef PRODUCT
1222   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1223 #endif
1224 };
1225 
1226 //------------------------------TypeAryPtr-------------------------------------
1227 // Class of Java array pointers
1228 class TypeAryPtr : public TypeOopPtr {
1229   TypeAryPtr(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk,
1230              Offset offset, Offset field_offset, int instance_id, bool is_autobox_cache,
1231              const TypePtr* speculative, int inline_depth)
1232     : TypeOopPtr(AryPtr, ptr, k, xk, o, offset, field_offset, instance_id, speculative, inline_depth),
1233     _ary(ary),
1234     _is_autobox_cache(is_autobox_cache),
1235     _field_offset(field_offset)
1236  {
1237 #ifdef ASSERT
1238     if (k != NULL) {
1239       // Verify that specified klass and TypeAryPtr::klass() follow the same rules.
1240       ciKlass* ck = compute_klass(true);
1241       if (k != ck) {
1242         this-&gt;dump(); tty-&gt;cr();
1243         tty-&gt;print(&quot; k: &quot;);
1244         k-&gt;print(); tty-&gt;cr();
1245         tty-&gt;print(&quot;ck: &quot;);
1246         if (ck != NULL) ck-&gt;print();
1247         else tty-&gt;print(&quot;&lt;NULL&gt;&quot;);
1248         tty-&gt;cr();
1249         assert(false, &quot;unexpected TypeAryPtr::_klass&quot;);
1250       }
1251     }
1252 #endif
1253   }
1254   virtual bool eq( const Type *t ) const;
1255   virtual int hash() const;     // Type specific hashing
1256   const TypeAry *_ary;          // Array we point into
1257   const bool     _is_autobox_cache;
1258   // For flattened inline type arrays, each field of the inline type in
1259   // the array has its own memory slice so we need to keep track of
1260   // which field is accessed
1261   const Offset _field_offset;
1262   Offset meet_field_offset(const Type::Offset offset) const;
1263   Offset dual_field_offset() const;
1264 
1265   ciKlass* compute_klass(DEBUG_ONLY(bool verify = false)) const;
1266 
1267 public:
1268   // Accessors
1269   ciKlass* klass() const;
1270   const TypeAry* ary() const  { return _ary; }
1271   const Type*    elem() const { return _ary-&gt;_elem; }
1272   const TypeInt* size() const { return _ary-&gt;_size; }
1273   bool      is_stable() const { return _ary-&gt;_stable; }
1274 
1275   // Inline type array properties
<a name="12" id="anc12"></a><span class="line-added">1276   bool is_flat()          const { return _ary-&gt;_elem-&gt;isa_inlinetype() != NULL; }</span>
1277   bool is_not_flat()      const { return _ary-&gt;_not_flat; }
<a name="13" id="anc13"></a><span class="line-added">1278   bool is_null_free()     const { return is_flat() || (_ary-&gt;_elem-&gt;make_ptr() != NULL &amp;&amp; _ary-&gt;_elem-&gt;make_ptr()-&gt;is_inlinetypeptr()); }</span>
1279   bool is_not_null_free() const { return _ary-&gt;_not_null_free; }
1280 
1281   bool is_autobox_cache() const { return _is_autobox_cache; }
1282 
1283   static const TypeAryPtr* make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
1284                                 Offset field_offset = Offset::bottom,
1285                                 int instance_id = InstanceBot,
1286                                 const TypePtr* speculative = NULL,
1287                                 int inline_depth = InlineDepthBottom);
1288   // Constant pointer to array
1289   static const TypeAryPtr* make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
1290                                 Offset field_offset = Offset::bottom,
1291                                 int instance_id = InstanceBot,
1292                                 const TypePtr* speculative = NULL,
1293                                 int inline_depth = InlineDepthBottom,
1294                                 bool is_autobox_cache = false);
1295 
1296   // Return a &#39;ptr&#39; version of this type
1297   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1298 
1299   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1300 
1301   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1302 
1303   virtual const TypeAryPtr* cast_to_size(const TypeInt* size) const;
1304   virtual const TypeInt* narrow_size_type(const TypeInt* size) const;
1305 
1306   virtual bool empty(void) const;        // TRUE if type is vacuous
1307   virtual const TypePtr *add_offset( intptr_t offset ) const;
1308 
1309   // Speculative type helper methods.
1310   virtual const Type* remove_speculative() const;
1311   virtual const Type* cleanup_speculative() const;
1312   virtual const TypePtr* with_inline_depth(int depth) const;
1313   virtual const TypePtr* with_instance_id(int instance_id) const;
1314 
1315   // the core of the computation of the meet of 2 types
1316   virtual const Type *xmeet_helper(const Type *t) const;
1317   virtual const Type *xdual() const;    // Compute dual right now.
1318 
<a name="14" id="anc14"></a><span class="line-added">1319   // Inline type array properties</span>
1320   const TypeAryPtr* cast_to_not_flat(bool not_flat = true) const;
1321   const TypeAryPtr* cast_to_not_null_free(bool not_null_free = true) const;
<a name="15" id="anc15"></a><span class="line-added">1322   const TypeAryPtr* update_properties(const TypeAryPtr* new_type) const;</span>
1323 
1324   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1325   int stable_dimension() const;
1326 
1327   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1328 
1329   static jint max_array_length(BasicType etype);
1330 
1331   const int flattened_offset() const;
1332   const Offset field_offset() const { return _field_offset; }
1333   const TypeAryPtr* with_field_offset(int offset) const;
1334   const TypePtr* add_field_offset_and_offset(intptr_t offset) const;
1335 
1336   virtual bool can_be_inline_type() const { return false; }
1337 
1338   // Convenience common pre-built types.
1339   static const TypeAryPtr *RANGE;
1340   static const TypeAryPtr *OOPS;
1341   static const TypeAryPtr *NARROWOOPS;
1342   static const TypeAryPtr *BYTES;
1343   static const TypeAryPtr *SHORTS;
1344   static const TypeAryPtr *CHARS;
1345   static const TypeAryPtr *INTS;
1346   static const TypeAryPtr *LONGS;
1347   static const TypeAryPtr *FLOATS;
1348   static const TypeAryPtr *DOUBLES;
1349   static const TypeAryPtr *INLINES;
1350   // selects one of the above:
1351   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1352     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1353     return _array_body_type[elem];
1354   }
1355   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1356   // sharpen the type of an int which is used as an array size
1357 #ifdef ASSERT
1358   // One type is interface, the other is oop
1359   virtual bool interface_vs_oop(const Type *t) const;
1360 #endif
1361 #ifndef PRODUCT
1362   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1363 #endif
1364 };
1365 
1366 //------------------------------TypeMetadataPtr-------------------------------------
1367 // Some kind of metadata, either Method*, MethodData* or CPCacheOop
1368 class TypeMetadataPtr : public TypePtr {
1369 protected:
1370   TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset);
1371   // Do not allow interface-vs.-noninterface joins to collapse to top.
1372   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1373 public:
1374   virtual bool eq( const Type *t ) const;
1375   virtual int  hash() const;             // Type specific hashing
1376   virtual bool singleton(void) const;    // TRUE if type is a singleton
1377 
1378 private:
1379   ciMetadata*   _metadata;
1380 
1381 public:
1382   static const TypeMetadataPtr* make(PTR ptr, ciMetadata* m, Offset offset);
1383 
1384   static const TypeMetadataPtr* make(ciMethod* m);
1385   static const TypeMetadataPtr* make(ciMethodData* m);
1386 
1387   ciMetadata* metadata() const { return _metadata; }
1388 
1389   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1390 
1391   virtual const TypePtr *add_offset( intptr_t offset ) const;
1392 
1393   virtual const Type *xmeet( const Type *t ) const;
1394   virtual const Type *xdual() const;    // Compute dual right now.
1395 
1396   virtual intptr_t get_con() const;
1397 
1398   // Convenience common pre-built types.
1399   static const TypeMetadataPtr *BOTTOM;
1400 
1401 #ifndef PRODUCT
1402   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1403 #endif
1404 };
1405 
1406 //------------------------------TypeKlassPtr-----------------------------------
1407 // Class of Java Klass pointers
1408 class TypeKlassPtr : public TypePtr {
<a name="16" id="anc16"></a><span class="line-modified">1409   TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flatten_array);</span>
1410 
1411 protected:
1412   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1413  public:
1414   virtual bool eq( const Type *t ) const;
1415   virtual int hash() const;             // Type specific hashing
1416   virtual bool singleton(void) const;    // TRUE if type is a singleton
1417  private:
1418 
1419   ciKlass* _klass;
1420 
1421   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
<a name="17" id="anc17"></a><span class="line-modified">1422   bool _klass_is_exact;</span>
<span class="line-modified">1423   bool _flatten_array; // Type is flat in arrays</span>
1424 
1425 public:
1426   ciKlass* klass() const { return  _klass; }
1427   bool klass_is_exact()    const { return _klass_is_exact; }
1428 
1429   virtual bool can_be_inline_type() const { return EnableValhalla &amp;&amp; (_klass == NULL || _klass-&gt;can_be_inline_klass(_klass_is_exact)); }
<a name="18" id="anc18"></a><span class="line-modified">1430   virtual bool flatten_array() const { return _flatten_array; }</span>




1431 
1432   bool  is_loaded() const { return klass() != NULL &amp;&amp; klass()-&gt;is_loaded(); }
1433 
1434   // ptr to klass &#39;k&#39;
<a name="19" id="anc19"></a><span class="line-modified">1435   static const TypeKlassPtr* make(ciKlass* k) { return make( TypePtr::Constant, k, Offset(0)); }</span>
1436   // ptr to klass &#39;k&#39; with offset
<a name="20" id="anc20"></a><span class="line-modified">1437   static const TypeKlassPtr* make(ciKlass* k, Offset offset) { return make( TypePtr::Constant, k, offset); }</span>
1438   // ptr to klass &#39;k&#39; or sub-klass
<a name="21" id="anc21"></a><span class="line-modified">1439   static const TypeKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array = false);</span>
1440 
1441   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1442 
1443   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1444 
1445   // corresponding pointer to instance, for a given class
1446   const TypeOopPtr* as_instance_type() const;
1447 
1448   virtual const TypePtr *add_offset( intptr_t offset ) const;
1449   virtual const Type    *xmeet( const Type *t ) const;
1450   virtual const Type    *xdual() const;      // Compute dual right now.
1451 
1452   virtual intptr_t get_con() const;
1453 
1454   // Convenience common pre-built types.
1455   static const TypeKlassPtr* OBJECT; // Not-null object klass or below
1456   static const TypeKlassPtr* OBJECT_OR_NULL; // Maybe-null version of same
1457 #ifndef PRODUCT
1458   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1459 #endif
1460 };
1461 
1462 class TypeNarrowPtr : public Type {
1463 protected:
1464   const TypePtr* _ptrtype; // Could be TypePtr::NULL_PTR
1465 
1466   TypeNarrowPtr(TYPES t, const TypePtr* ptrtype): Type(t),
1467                                                   _ptrtype(ptrtype) {
1468     assert(ptrtype-&gt;offset() == 0 ||
1469            ptrtype-&gt;offset() == OffsetBot ||
1470            ptrtype-&gt;offset() == OffsetTop, &quot;no real offsets&quot;);
1471   }
1472 
1473   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const = 0;
1474   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const = 0;
1475   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const = 0;
1476   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const = 0;
1477   // Do not allow interface-vs.-noninterface joins to collapse to top.
1478   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1479 public:
1480   virtual bool eq( const Type *t ) const;
1481   virtual int  hash() const;             // Type specific hashing
1482   virtual bool singleton(void) const;    // TRUE if type is a singleton
1483 
1484   virtual const Type *xmeet( const Type *t ) const;
1485   virtual const Type *xdual() const;    // Compute dual right now.
1486 
1487   virtual intptr_t get_con() const;
1488 
1489   virtual bool empty(void) const;        // TRUE if type is vacuous
1490 
1491   // returns the equivalent ptr type for this compressed pointer
1492   const TypePtr *get_ptrtype() const {
1493     return _ptrtype;
1494   }
1495 
1496   bool is_known_instance() const {
1497     return _ptrtype-&gt;is_known_instance();
1498   }
1499 
1500 #ifndef PRODUCT
1501   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1502 #endif
1503 };
1504 
1505 //------------------------------TypeNarrowOop----------------------------------
1506 // A compressed reference to some kind of Oop.  This type wraps around
1507 // a preexisting TypeOopPtr and forwards most of it&#39;s operations to
1508 // the underlying type.  It&#39;s only real purpose is to track the
1509 // oopness of the compressed oop value when we expose the conversion
1510 // between the normal and the compressed form.
1511 class TypeNarrowOop : public TypeNarrowPtr {
1512 protected:
1513   TypeNarrowOop( const TypePtr* ptrtype): TypeNarrowPtr(NarrowOop, ptrtype) {
1514   }
1515 
1516   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1517     return t-&gt;isa_narrowoop();
1518   }
1519 
1520   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1521     return t-&gt;is_narrowoop();
1522   }
1523 
1524   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1525     return new TypeNarrowOop(t);
1526   }
1527 
1528   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1529     return (const TypeNarrowPtr*)((new TypeNarrowOop(t))-&gt;hashcons());
1530   }
1531 
1532 public:
1533 
1534   static const TypeNarrowOop *make( const TypePtr* type);
1535 
1536   static const TypeNarrowOop* make_from_constant(ciObject* con, bool require_constant = false) {
1537     return make(TypeOopPtr::make_from_constant(con, require_constant));
1538   }
1539 
1540   static const TypeNarrowOop *BOTTOM;
1541   static const TypeNarrowOop *NULL_PTR;
1542 
1543   virtual const Type* remove_speculative() const;
1544   virtual const Type* cleanup_speculative() const;
1545 
1546 #ifndef PRODUCT
1547   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1548 #endif
1549 };
1550 
1551 //------------------------------TypeNarrowKlass----------------------------------
1552 // A compressed reference to klass pointer.  This type wraps around a
1553 // preexisting TypeKlassPtr and forwards most of it&#39;s operations to
1554 // the underlying type.
1555 class TypeNarrowKlass : public TypeNarrowPtr {
1556 protected:
1557   TypeNarrowKlass( const TypePtr* ptrtype): TypeNarrowPtr(NarrowKlass, ptrtype) {
1558   }
1559 
1560   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1561     return t-&gt;isa_narrowklass();
1562   }
1563 
1564   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1565     return t-&gt;is_narrowklass();
1566   }
1567 
1568   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1569     return new TypeNarrowKlass(t);
1570   }
1571 
1572   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1573     return (const TypeNarrowPtr*)((new TypeNarrowKlass(t))-&gt;hashcons());
1574   }
1575 
1576 public:
1577   static const TypeNarrowKlass *make( const TypePtr* type);
1578 
1579   // static const TypeNarrowKlass *BOTTOM;
1580   static const TypeNarrowKlass *NULL_PTR;
1581 
1582 #ifndef PRODUCT
1583   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1584 #endif
1585 };
1586 
1587 //------------------------------TypeFunc---------------------------------------
1588 // Class of Array Types
1589 class TypeFunc : public Type {
1590   TypeFunc(const TypeTuple *domain_sig, const TypeTuple *domain_cc, const TypeTuple *range_sig, const TypeTuple *range_cc)
1591     : Type(Function), _domain_sig(domain_sig), _domain_cc(domain_cc), _range_sig(range_sig), _range_cc(range_cc) {}
1592   virtual bool eq( const Type *t ) const;
1593   virtual int  hash() const;             // Type specific hashing
1594   virtual bool singleton(void) const;    // TRUE if type is a singleton
1595   virtual bool empty(void) const;        // TRUE if type is vacuous
1596 
1597   // Domains of inputs: inline type arguments are not passed by
1598   // reference, instead each field of the inline type is passed as an
1599   // argument. We maintain 2 views of the argument list here: one
1600   // based on the signature (with an inline type argument as a single
1601   // slot), one based on the actual calling convention (with a value
1602   // type argument as a list of its fields).
1603   const TypeTuple* const _domain_sig;
1604   const TypeTuple* const _domain_cc;
1605   // Range of results. Similar to domains: an inline type result can be
1606   // returned in registers in which case range_cc lists all fields and
1607   // is the actual calling convention.
1608   const TypeTuple* const _range_sig;
1609   const TypeTuple* const _range_cc;
1610 
1611 public:
1612   // Constants are shared among ADLC and VM
1613   enum { Control    = AdlcVMDeps::Control,
1614          I_O        = AdlcVMDeps::I_O,
1615          Memory     = AdlcVMDeps::Memory,
1616          FramePtr   = AdlcVMDeps::FramePtr,
1617          ReturnAdr  = AdlcVMDeps::ReturnAdr,
1618          Parms      = AdlcVMDeps::Parms
1619   };
1620 
1621 
1622   // Accessors:
1623   const TypeTuple* domain_sig() const { return _domain_sig; }
1624   const TypeTuple* domain_cc()  const { return _domain_cc; }
1625   const TypeTuple* range_sig()  const { return _range_sig; }
1626   const TypeTuple* range_cc()   const { return _range_cc; }
1627 
1628   static const TypeFunc* make(ciMethod* method, bool is_osr_compilation = false);
1629   static const TypeFunc *make(const TypeTuple* domain_sig, const TypeTuple* domain_cc,
1630                               const TypeTuple* range_sig, const TypeTuple* range_cc);
1631   static const TypeFunc *make(const TypeTuple* domain, const TypeTuple* range);
1632 
1633   virtual const Type *xmeet( const Type *t ) const;
1634   virtual const Type *xdual() const;    // Compute dual right now.
1635 
1636   BasicType return_type() const;
1637 
1638   bool returns_inline_type_as_fields() const { return range_sig() != range_cc(); }
1639 
1640 #ifndef PRODUCT
1641   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1642 #endif
1643   // Convenience common pre-built types.
1644 };
1645 
1646 //------------------------------accessors--------------------------------------
1647 inline bool Type::is_ptr_to_narrowoop() const {
1648 #ifdef _LP64
1649   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowoop_nv());
1650 #else
1651   return false;
1652 #endif
1653 }
1654 
1655 inline bool Type::is_ptr_to_narrowklass() const {
1656 #ifdef _LP64
1657   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowklass_nv());
1658 #else
1659   return false;
1660 #endif
1661 }
1662 
1663 inline float Type::getf() const {
1664   assert( _base == FloatCon, &quot;Not a FloatCon&quot; );
1665   return ((TypeF*)this)-&gt;_f;
1666 }
1667 
1668 inline double Type::getd() const {
1669   assert( _base == DoubleCon, &quot;Not a DoubleCon&quot; );
1670   return ((TypeD*)this)-&gt;_d;
1671 }
1672 
1673 inline const TypeInt *Type::is_int() const {
1674   assert( _base == Int, &quot;Not an Int&quot; );
1675   return (TypeInt*)this;
1676 }
1677 
1678 inline const TypeInt *Type::isa_int() const {
1679   return ( _base == Int ? (TypeInt*)this : NULL);
1680 }
1681 
1682 inline const TypeLong *Type::is_long() const {
1683   assert( _base == Long, &quot;Not a Long&quot; );
1684   return (TypeLong*)this;
1685 }
1686 
1687 inline const TypeLong *Type::isa_long() const {
1688   return ( _base == Long ? (TypeLong*)this : NULL);
1689 }
1690 
1691 inline const TypeF *Type::isa_float() const {
1692   return ((_base == FloatTop ||
1693            _base == FloatCon ||
1694            _base == FloatBot) ? (TypeF*)this : NULL);
1695 }
1696 
1697 inline const TypeF *Type::is_float_constant() const {
1698   assert( _base == FloatCon, &quot;Not a Float&quot; );
1699   return (TypeF*)this;
1700 }
1701 
1702 inline const TypeF *Type::isa_float_constant() const {
1703   return ( _base == FloatCon ? (TypeF*)this : NULL);
1704 }
1705 
1706 inline const TypeD *Type::isa_double() const {
1707   return ((_base == DoubleTop ||
1708            _base == DoubleCon ||
1709            _base == DoubleBot) ? (TypeD*)this : NULL);
1710 }
1711 
1712 inline const TypeD *Type::is_double_constant() const {
1713   assert( _base == DoubleCon, &quot;Not a Double&quot; );
1714   return (TypeD*)this;
1715 }
1716 
1717 inline const TypeD *Type::isa_double_constant() const {
1718   return ( _base == DoubleCon ? (TypeD*)this : NULL);
1719 }
1720 
1721 inline const TypeTuple *Type::is_tuple() const {
1722   assert( _base == Tuple, &quot;Not a Tuple&quot; );
1723   return (TypeTuple*)this;
1724 }
1725 
1726 inline const TypeAry *Type::is_ary() const {
1727   assert( _base == Array , &quot;Not an Array&quot; );
1728   return (TypeAry*)this;
1729 }
1730 
1731 inline const TypeAry *Type::isa_ary() const {
1732   return ((_base == Array) ? (TypeAry*)this : NULL);
1733 }
1734 
1735 inline const TypeVect *Type::is_vect() const {
1736   assert( _base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ, &quot;Not a Vector&quot; );
1737   return (TypeVect*)this;
1738 }
1739 
1740 inline const TypeVect *Type::isa_vect() const {
1741   return (_base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ) ? (TypeVect*)this : NULL;
1742 }
1743 
1744 inline const TypePtr *Type::is_ptr() const {
1745   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1746   assert(_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr, &quot;Not a pointer&quot;);
1747   return (TypePtr*)this;
1748 }
1749 
1750 inline const TypePtr *Type::isa_ptr() const {
1751   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1752   return (_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr) ? (TypePtr*)this : NULL;
1753 }
1754 
1755 inline const TypeOopPtr *Type::is_oopptr() const {
1756   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1757   assert(_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr, &quot;Not a Java pointer&quot; ) ;
1758   return (TypeOopPtr*)this;
1759 }
1760 
1761 inline const TypeOopPtr *Type::isa_oopptr() const {
1762   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1763   return (_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr) ? (TypeOopPtr*)this : NULL;
1764 }
1765 
1766 inline const TypeRawPtr *Type::isa_rawptr() const {
1767   return (_base == RawPtr) ? (TypeRawPtr*)this : NULL;
1768 }
1769 
1770 inline const TypeRawPtr *Type::is_rawptr() const {
1771   assert( _base == RawPtr, &quot;Not a raw pointer&quot; );
1772   return (TypeRawPtr*)this;
1773 }
1774 
1775 inline const TypeInstPtr *Type::isa_instptr() const {
1776   return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;
1777 }
1778 
1779 inline const TypeInstPtr *Type::is_instptr() const {
1780   assert( _base == InstPtr, &quot;Not an object pointer&quot; );
1781   return (TypeInstPtr*)this;
1782 }
1783 
1784 inline const TypeAryPtr *Type::isa_aryptr() const {
1785   return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;
1786 }
1787 
1788 inline const TypeAryPtr *Type::is_aryptr() const {
1789   assert( _base == AryPtr, &quot;Not an array pointer&quot; );
1790   return (TypeAryPtr*)this;
1791 }
1792 
1793 inline const TypeInlineType* Type::isa_inlinetype() const {
1794   return (_base == InlineType) ? (TypeInlineType*)this : NULL;
1795 }
1796 
1797 inline const TypeInlineType* Type::is_inlinetype() const {
1798   assert(_base == InlineType, &quot;Not an inline type&quot;);
1799   return (TypeInlineType*)this;
1800 }
1801 
1802 inline const TypeNarrowOop *Type::is_narrowoop() const {
1803   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1804   assert(_base == NarrowOop, &quot;Not a narrow oop&quot; ) ;
1805   return (TypeNarrowOop*)this;
1806 }
1807 
1808 inline const TypeNarrowOop *Type::isa_narrowoop() const {
1809   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1810   return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;
1811 }
1812 
1813 inline const TypeNarrowKlass *Type::is_narrowklass() const {
1814   assert(_base == NarrowKlass, &quot;Not a narrow oop&quot; ) ;
1815   return (TypeNarrowKlass*)this;
1816 }
1817 
1818 inline const TypeNarrowKlass *Type::isa_narrowklass() const {
1819   return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;
1820 }
1821 
1822 inline const TypeMetadataPtr *Type::is_metadataptr() const {
1823   // MetadataPtr is the first and CPCachePtr the last
1824   assert(_base == MetadataPtr, &quot;Not a metadata pointer&quot; ) ;
1825   return (TypeMetadataPtr*)this;
1826 }
1827 
1828 inline const TypeMetadataPtr *Type::isa_metadataptr() const {
1829   return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : NULL;
1830 }
1831 
1832 inline const TypeKlassPtr *Type::isa_klassptr() const {
1833   return (_base == KlassPtr) ? (TypeKlassPtr*)this : NULL;
1834 }
1835 
1836 inline const TypeKlassPtr *Type::is_klassptr() const {
1837   assert( _base == KlassPtr, &quot;Not a klass pointer&quot; );
1838   return (TypeKlassPtr*)this;
1839 }
1840 
1841 inline const TypePtr* Type::make_ptr() const {
1842   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype() :
1843                               ((_base == NarrowKlass) ? is_narrowklass()-&gt;get_ptrtype() :
1844                                                        isa_ptr());
1845 }
1846 
1847 inline const TypeOopPtr* Type::make_oopptr() const {
1848   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype()-&gt;isa_oopptr() : isa_oopptr();
1849 }
1850 
1851 inline const TypeNarrowOop* Type::make_narrowoop() const {
1852   return (_base == NarrowOop) ? is_narrowoop() :
1853                                 (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);
1854 }
1855 
1856 inline const TypeNarrowKlass* Type::make_narrowklass() const {
1857   return (_base == NarrowKlass) ? is_narrowklass() :
1858                                   (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);
1859 }
1860 
1861 inline bool Type::is_floatingpoint() const {
1862   if( (_base == FloatCon)  || (_base == FloatBot) ||
1863       (_base == DoubleCon) || (_base == DoubleBot) )
1864     return true;
1865   return false;
1866 }
1867 
1868 inline bool Type::is_inlinetypeptr() const {
1869   return isa_instptr() != NULL &amp;&amp; is_instptr()-&gt;klass()-&gt;is_inlinetype();
1870 }
1871 
1872 
1873 inline ciInlineKlass* Type::inline_klass() const {
1874   assert(is_inlinetypeptr(), &quot;must be an inline type ptr&quot;);
1875   return is_instptr()-&gt;klass()-&gt;as_inline_klass();
1876 }
1877 
1878 
1879 // ===============================================================
1880 // Things that need to be 64-bits in the 64-bit build but
1881 // 32-bits in the 32-bit build.  Done this way to get full
1882 // optimization AND strong typing.
1883 #ifdef _LP64
1884 
1885 // For type queries and asserts
1886 #define is_intptr_t  is_long
1887 #define isa_intptr_t isa_long
1888 #define find_intptr_t_type find_long_type
1889 #define find_intptr_t_con  find_long_con
1890 #define TypeX        TypeLong
1891 #define Type_X       Type::Long
1892 #define TypeX_X      TypeLong::LONG
1893 #define TypeX_ZERO   TypeLong::ZERO
1894 // For &#39;ideal_reg&#39; machine registers
1895 #define Op_RegX      Op_RegL
1896 // For phase-&gt;intcon variants
1897 #define MakeConX     longcon
1898 #define ConXNode     ConLNode
1899 // For array index arithmetic
1900 #define MulXNode     MulLNode
1901 #define AndXNode     AndLNode
1902 #define OrXNode      OrLNode
1903 #define CmpXNode     CmpLNode
1904 #define CmpUXNode    CmpULNode
1905 #define SubXNode     SubLNode
1906 #define LShiftXNode  LShiftLNode
1907 // For object size computation:
1908 #define AddXNode     AddLNode
1909 #define RShiftXNode  RShiftLNode
1910 // For card marks and hashcodes
1911 #define URShiftXNode URShiftLNode
1912 // UseOptoBiasInlining
1913 #define XorXNode     XorLNode
1914 #define StoreXConditionalNode StoreLConditionalNode
1915 #define LoadXNode    LoadLNode
1916 #define StoreXNode   StoreLNode
1917 // Opcodes
1918 #define Op_LShiftX   Op_LShiftL
1919 #define Op_AndX      Op_AndL
1920 #define Op_AddX      Op_AddL
1921 #define Op_SubX      Op_SubL
1922 #define Op_XorX      Op_XorL
1923 #define Op_URShiftX  Op_URShiftL
1924 #define Op_LoadX     Op_LoadL
1925 #define Op_StoreX    Op_StoreL
1926 // conversions
1927 #define ConvI2X(x)   ConvI2L(x)
1928 #define ConvL2X(x)   (x)
1929 #define ConvX2I(x)   ConvL2I(x)
1930 #define ConvX2L(x)   (x)
1931 #define ConvX2UL(x)  (x)
1932 
1933 #else
1934 
1935 // For type queries and asserts
1936 #define is_intptr_t  is_int
1937 #define isa_intptr_t isa_int
1938 #define find_intptr_t_type find_int_type
1939 #define find_intptr_t_con  find_int_con
1940 #define TypeX        TypeInt
1941 #define Type_X       Type::Int
1942 #define TypeX_X      TypeInt::INT
1943 #define TypeX_ZERO   TypeInt::ZERO
1944 // For &#39;ideal_reg&#39; machine registers
1945 #define Op_RegX      Op_RegI
1946 // For phase-&gt;intcon variants
1947 #define MakeConX     intcon
1948 #define ConXNode     ConINode
1949 // For array index arithmetic
1950 #define MulXNode     MulINode
1951 #define AndXNode     AndINode
1952 #define OrXNode      OrINode
1953 #define CmpXNode     CmpINode
1954 #define CmpUXNode    CmpUNode
1955 #define SubXNode     SubINode
1956 #define LShiftXNode  LShiftINode
1957 // For object size computation:
1958 #define AddXNode     AddINode
1959 #define RShiftXNode  RShiftINode
1960 // For card marks and hashcodes
1961 #define URShiftXNode URShiftINode
1962 // UseOptoBiasInlining
1963 #define XorXNode     XorINode
1964 #define StoreXConditionalNode StoreIConditionalNode
1965 #define LoadXNode    LoadINode
1966 #define StoreXNode   StoreINode
1967 // Opcodes
1968 #define Op_LShiftX   Op_LShiftI
1969 #define Op_AndX      Op_AndI
1970 #define Op_AddX      Op_AddI
1971 #define Op_SubX      Op_SubI
1972 #define Op_XorX      Op_XorI
1973 #define Op_URShiftX  Op_URShiftI
1974 #define Op_LoadX     Op_LoadI
1975 #define Op_StoreX    Op_StoreI
1976 // conversions
1977 #define ConvI2X(x)   (x)
1978 #define ConvL2X(x)   ConvL2I(x)
1979 #define ConvX2I(x)   (x)
1980 #define ConvX2L(x)   ConvI2L(x)
1981 #define ConvX2UL(x)  ConvI2UL(x)
1982 
1983 #endif
1984 
1985 #endif // SHARE_OPTO_TYPE_HPP
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>