<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/assembler.hpp&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/accessDecorators.hpp&quot;
  37 #include &quot;oops/compressedOops.inline.hpp&quot;
  38 #include &quot;oops/klass.inline.hpp&quot;
  39 #include &quot;prims/methodHandles.hpp&quot;
  40 #include &quot;runtime/biasedLocking.hpp&quot;
  41 #include &quot;runtime/flags/flagSetting.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/signature_cc.hpp&quot;
  49 #include &quot;runtime/stubRoutines.hpp&quot;
  50 #include &quot;runtime/thread.hpp&quot;
  51 #include &quot;utilities/macros.hpp&quot;
  52 #include &quot;vmreg_x86.inline.hpp&quot;
  53 #include &quot;crc32c.h&quot;
  54 #ifdef COMPILER2
  55 #include &quot;opto/output.hpp&quot;
  56 #endif
  57 
  58 #ifdef PRODUCT
  59 #define BLOCK_COMMENT(str) /* nothing */
  60 #define STOP(error) stop(error)
  61 #else
  62 #define BLOCK_COMMENT(str) block_comment(str)
  63 #define STOP(error) block_comment(error); stop(error)
  64 #endif
  65 
  66 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  67 
  68 #ifdef ASSERT
  69 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
  70 #endif
  71 
  72 static Assembler::Condition reverse[] = {
  73     Assembler::noOverflow     /* overflow      = 0x0 */ ,
  74     Assembler::overflow       /* noOverflow    = 0x1 */ ,
  75     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
  76     Assembler::below          /* aboveEqual    = 0x3, carryClear    = 0x3 */ ,
  77     Assembler::notZero        /* zero          = 0x4, equal         = 0x4 */ ,
  78     Assembler::zero           /* notZero       = 0x5, notEqual      = 0x5 */ ,
  79     Assembler::above          /* belowEqual    = 0x6 */ ,
  80     Assembler::belowEqual     /* above         = 0x7 */ ,
  81     Assembler::positive       /* negative      = 0x8 */ ,
  82     Assembler::negative       /* positive      = 0x9 */ ,
  83     Assembler::noParity       /* parity        = 0xa */ ,
  84     Assembler::parity         /* noParity      = 0xb */ ,
  85     Assembler::greaterEqual   /* less          = 0xc */ ,
  86     Assembler::less           /* greaterEqual  = 0xd */ ,
  87     Assembler::greater        /* lessEqual     = 0xe */ ,
  88     Assembler::lessEqual      /* greater       = 0xf, */
  89 
  90 };
  91 
  92 
  93 // Implementation of MacroAssembler
  94 
  95 // First all the versions that have distinct versions depending on 32/64 bit
  96 // Unless the difference is trivial (1 line or so).
  97 
  98 #ifndef _LP64
  99 
 100 // 32bit versions
 101 
 102 Address MacroAssembler::as_Address(AddressLiteral adr) {
 103   return Address(adr.target(), adr.rspec());
 104 }
 105 
 106 Address MacroAssembler::as_Address(ArrayAddress adr) {
 107   return Address::make_array(adr);
 108 }
 109 
 110 void MacroAssembler::call_VM_leaf_base(address entry_point,
 111                                        int number_of_arguments) {
 112   call(RuntimeAddress(entry_point));
 113   increment(rsp, number_of_arguments * wordSize);
 114 }
 115 
 116 void MacroAssembler::cmpklass(Address src1, Metadata* obj) {
 117   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 118 }
 119 
 120 void MacroAssembler::cmpklass(Register src1, Metadata* obj) {
 121   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 122 }
 123 
 124 void MacroAssembler::cmpoop_raw(Address src1, jobject obj) {
 125   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 126 }
 127 
 128 void MacroAssembler::cmpoop_raw(Register src1, jobject obj) {
 129   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 130 }
 131 
 132 void MacroAssembler::cmpoop(Address src1, jobject obj) {
 133   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 134   bs-&gt;obj_equals(this, src1, obj);
 135 }
 136 
 137 void MacroAssembler::cmpoop(Register src1, jobject obj) {
 138   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 139   bs-&gt;obj_equals(this, src1, obj);
 140 }
 141 
 142 void MacroAssembler::extend_sign(Register hi, Register lo) {
 143   // According to Intel Doc. AP-526, &quot;Integer Divide&quot;, p.18.
 144   if (VM_Version::is_P6() &amp;&amp; hi == rdx &amp;&amp; lo == rax) {
 145     cdql();
 146   } else {
 147     movl(hi, lo);
 148     sarl(hi, 31);
 149   }
 150 }
 151 
 152 void MacroAssembler::jC2(Register tmp, Label&amp; L) {
 153   // set parity bit if FPU flag C2 is set (via rax)
 154   save_rax(tmp);
 155   fwait(); fnstsw_ax();
 156   sahf();
 157   restore_rax(tmp);
 158   // branch
 159   jcc(Assembler::parity, L);
 160 }
 161 
 162 void MacroAssembler::jnC2(Register tmp, Label&amp; L) {
 163   // set parity bit if FPU flag C2 is set (via rax)
 164   save_rax(tmp);
 165   fwait(); fnstsw_ax();
 166   sahf();
 167   restore_rax(tmp);
 168   // branch
 169   jcc(Assembler::noParity, L);
 170 }
 171 
 172 // 32bit can do a case table jump in one instruction but we no longer allow the base
 173 // to be installed in the Address class
 174 void MacroAssembler::jump(ArrayAddress entry) {
 175   jmp(as_Address(entry));
 176 }
 177 
 178 // Note: y_lo will be destroyed
 179 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 180   // Long compare for Java (semantics as described in JVM spec.)
 181   Label high, low, done;
 182 
 183   cmpl(x_hi, y_hi);
 184   jcc(Assembler::less, low);
 185   jcc(Assembler::greater, high);
 186   // x_hi is the return register
 187   xorl(x_hi, x_hi);
 188   cmpl(x_lo, y_lo);
 189   jcc(Assembler::below, low);
 190   jcc(Assembler::equal, done);
 191 
 192   bind(high);
 193   xorl(x_hi, x_hi);
 194   increment(x_hi);
 195   jmp(done);
 196 
 197   bind(low);
 198   xorl(x_hi, x_hi);
 199   decrementl(x_hi);
 200 
 201   bind(done);
 202 }
 203 
 204 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 205     mov_literal32(dst, (int32_t)src.target(), src.rspec());
 206 }
 207 
 208 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 209   // leal(dst, as_Address(adr));
 210   // see note in movl as to why we must use a move
 211   mov_literal32(dst, (int32_t) adr.target(), adr.rspec());
 212 }
 213 
 214 void MacroAssembler::leave() {
 215   mov(rsp, rbp);
 216   pop(rbp);
 217 }
 218 
 219 void MacroAssembler::lmul(int x_rsp_offset, int y_rsp_offset) {
 220   // Multiplication of two Java long values stored on the stack
 221   // as illustrated below. Result is in rdx:rax.
 222   //
 223   // rsp ---&gt; [  ??  ] \               \
 224   //            ....    | y_rsp_offset  |
 225   //          [ y_lo ] /  (in bytes)    | x_rsp_offset
 226   //          [ y_hi ]                  | (in bytes)
 227   //            ....                    |
 228   //          [ x_lo ]                 /
 229   //          [ x_hi ]
 230   //            ....
 231   //
 232   // Basic idea: lo(result) = lo(x_lo * y_lo)
 233   //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 234   Address x_hi(rsp, x_rsp_offset + wordSize); Address x_lo(rsp, x_rsp_offset);
 235   Address y_hi(rsp, y_rsp_offset + wordSize); Address y_lo(rsp, y_rsp_offset);
 236   Label quick;
 237   // load x_hi, y_hi and check if quick
 238   // multiplication is possible
 239   movl(rbx, x_hi);
 240   movl(rcx, y_hi);
 241   movl(rax, rbx);
 242   orl(rbx, rcx);                                 // rbx, = 0 &lt;=&gt; x_hi = 0 and y_hi = 0
 243   jcc(Assembler::zero, quick);                   // if rbx, = 0 do quick multiply
 244   // do full multiplication
 245   // 1st step
 246   mull(y_lo);                                    // x_hi * y_lo
 247   movl(rbx, rax);                                // save lo(x_hi * y_lo) in rbx,
 248   // 2nd step
 249   movl(rax, x_lo);
 250   mull(rcx);                                     // x_lo * y_hi
 251   addl(rbx, rax);                                // add lo(x_lo * y_hi) to rbx,
 252   // 3rd step
 253   bind(quick);                                   // note: rbx, = 0 if quick multiply!
 254   movl(rax, x_lo);
 255   mull(y_lo);                                    // x_lo * y_lo
 256   addl(rdx, rbx);                                // correct hi(x_lo * y_lo)
 257 }
 258 
 259 void MacroAssembler::lneg(Register hi, Register lo) {
 260   negl(lo);
 261   adcl(hi, 0);
 262   negl(hi);
 263 }
 264 
 265 void MacroAssembler::lshl(Register hi, Register lo) {
 266   // Java shift left long support (semantics as described in JVM spec., p.305)
 267   // (basic idea for shift counts s &gt;= n: x &lt;&lt; s == (x &lt;&lt; n) &lt;&lt; (s - n))
 268   // shift value is in rcx !
 269   assert(hi != rcx, &quot;must not use rcx&quot;);
 270   assert(lo != rcx, &quot;must not use rcx&quot;);
 271   const Register s = rcx;                        // shift count
 272   const int      n = BitsPerWord;
 273   Label L;
 274   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 275   cmpl(s, n);                                    // if (s &lt; n)
 276   jcc(Assembler::less, L);                       // else (s &gt;= n)
 277   movl(hi, lo);                                  // x := x &lt;&lt; n
 278   xorl(lo, lo);
 279   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 280   bind(L);                                       // s (mod n) &lt; n
 281   shldl(hi, lo);                                 // x := x &lt;&lt; s
 282   shll(lo);
 283 }
 284 
 285 
 286 void MacroAssembler::lshr(Register hi, Register lo, bool sign_extension) {
 287   // Java shift right long support (semantics as described in JVM spec., p.306 &amp; p.310)
 288   // (basic idea for shift counts s &gt;= n: x &gt;&gt; s == (x &gt;&gt; n) &gt;&gt; (s - n))
 289   assert(hi != rcx, &quot;must not use rcx&quot;);
 290   assert(lo != rcx, &quot;must not use rcx&quot;);
 291   const Register s = rcx;                        // shift count
 292   const int      n = BitsPerWord;
 293   Label L;
 294   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 295   cmpl(s, n);                                    // if (s &lt; n)
 296   jcc(Assembler::less, L);                       // else (s &gt;= n)
 297   movl(lo, hi);                                  // x := x &gt;&gt; n
 298   if (sign_extension) sarl(hi, 31);
 299   else                xorl(hi, hi);
 300   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 301   bind(L);                                       // s (mod n) &lt; n
 302   shrdl(lo, hi);                                 // x := x &gt;&gt; s
 303   if (sign_extension) sarl(hi);
 304   else                shrl(hi);
 305 }
 306 
 307 void MacroAssembler::movoop(Register dst, jobject obj) {
 308   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 309 }
 310 
 311 void MacroAssembler::movoop(Address dst, jobject obj) {
 312   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 313 }
 314 
 315 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 316   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 317 }
 318 
 319 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 320   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 321 }
 322 
 323 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 324   // scratch register is not used,
 325   // it is defined to match parameters of 64-bit version of this method.
 326   if (src.is_lval()) {
 327     mov_literal32(dst, (intptr_t)src.target(), src.rspec());
 328   } else {
 329     movl(dst, as_Address(src));
 330   }
 331 }
 332 
 333 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 334   movl(as_Address(dst), src);
 335 }
 336 
 337 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 338   movl(dst, as_Address(src));
 339 }
 340 
 341 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 342 void MacroAssembler::movptr(Address dst, intptr_t src) {
 343   movl(dst, src);
 344 }
 345 
 346 
 347 void MacroAssembler::pop_callee_saved_registers() {
 348   pop(rcx);
 349   pop(rdx);
 350   pop(rdi);
 351   pop(rsi);
 352 }
 353 
 354 void MacroAssembler::push_callee_saved_registers() {
 355   push(rsi);
 356   push(rdi);
 357   push(rdx);
 358   push(rcx);
 359 }
 360 
 361 void MacroAssembler::pushoop(jobject obj) {
 362   push_literal32((int32_t)obj, oop_Relocation::spec_for_immediate());
 363 }
 364 
 365 void MacroAssembler::pushklass(Metadata* obj) {
 366   push_literal32((int32_t)obj, metadata_Relocation::spec_for_immediate());
 367 }
 368 
 369 void MacroAssembler::pushptr(AddressLiteral src) {
 370   if (src.is_lval()) {
 371     push_literal32((int32_t)src.target(), src.rspec());
 372   } else {
 373     pushl(as_Address(src));
 374   }
 375 }
 376 
 377 void MacroAssembler::set_word_if_not_zero(Register dst) {
 378   xorl(dst, dst);
 379   set_byte_if_not_zero(dst);
 380 }
 381 
 382 static void pass_arg0(MacroAssembler* masm, Register arg) {
 383   masm-&gt;push(arg);
 384 }
 385 
 386 static void pass_arg1(MacroAssembler* masm, Register arg) {
 387   masm-&gt;push(arg);
 388 }
 389 
 390 static void pass_arg2(MacroAssembler* masm, Register arg) {
 391   masm-&gt;push(arg);
 392 }
 393 
 394 static void pass_arg3(MacroAssembler* masm, Register arg) {
 395   masm-&gt;push(arg);
 396 }
 397 
 398 #ifndef PRODUCT
 399 extern &quot;C&quot; void findpc(intptr_t x);
 400 #endif
 401 
 402 void MacroAssembler::debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg) {
 403   // In order to get locks to work, we need to fake a in_VM state
 404   JavaThread* thread = JavaThread::current();
 405   JavaThreadState saved_state = thread-&gt;thread_state();
 406   thread-&gt;set_thread_state(_thread_in_vm);
 407   if (ShowMessageBoxOnError) {
 408     JavaThread* thread = JavaThread::current();
 409     JavaThreadState saved_state = thread-&gt;thread_state();
 410     thread-&gt;set_thread_state(_thread_in_vm);
 411     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 412       ttyLocker ttyl;
 413       BytecodeCounter::print();
 414     }
 415     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 416     // This is the value of eip which points to where verify_oop will return.
 417     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 418       print_state32(rdi, rsi, rbp, rsp, rbx, rdx, rcx, rax, eip);
 419       BREAKPOINT;
 420     }
 421   }
 422   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 423 }
 424 
 425 void MacroAssembler::print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip) {
 426   ttyLocker ttyl;
 427   FlagSetting fs(Debugging, true);
 428   tty-&gt;print_cr(&quot;eip = 0x%08x&quot;, eip);
 429 #ifndef PRODUCT
 430   if ((WizardMode || Verbose) &amp;&amp; PrintMiscellaneous) {
 431     tty-&gt;cr();
 432     findpc(eip);
 433     tty-&gt;cr();
 434   }
 435 #endif
 436 #define PRINT_REG(rax) \
 437   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, rax); }
 438   PRINT_REG(rax);
 439   PRINT_REG(rbx);
 440   PRINT_REG(rcx);
 441   PRINT_REG(rdx);
 442   PRINT_REG(rdi);
 443   PRINT_REG(rsi);
 444   PRINT_REG(rbp);
 445   PRINT_REG(rsp);
 446 #undef PRINT_REG
 447   // Print some words near top of staack.
 448   int* dump_sp = (int*) rsp;
 449   for (int col1 = 0; col1 &lt; 8; col1++) {
 450     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 451     os::print_location(tty, *dump_sp++);
 452   }
 453   for (int row = 0; row &lt; 16; row++) {
 454     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 455     for (int col = 0; col &lt; 8; col++) {
 456       tty-&gt;print(&quot; 0x%08x&quot;, *dump_sp++);
 457     }
 458     tty-&gt;cr();
 459   }
 460   // Print some instructions around pc:
 461   Disassembler::decode((address)eip-64, (address)eip);
 462   tty-&gt;print_cr(&quot;--------&quot;);
 463   Disassembler::decode((address)eip, (address)eip+32);
 464 }
 465 
 466 void MacroAssembler::stop(const char* msg) {
 467   ExternalAddress message((address)msg);
 468   // push address of message
 469   pushptr(message.addr());
 470   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 471   pusha();                                            // push registers
 472   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug32)));
 473   hlt();
 474 }
 475 
 476 void MacroAssembler::warn(const char* msg) {
 477   push_CPU_state();
 478 
 479   ExternalAddress message((address) msg);
 480   // push address of message
 481   pushptr(message.addr());
 482 
 483   call(RuntimeAddress(CAST_FROM_FN_PTR(address, warning)));
 484   addl(rsp, wordSize);       // discard argument
 485   pop_CPU_state();
 486 }
 487 
 488 void MacroAssembler::print_state() {
 489   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 490   pusha();                                            // push registers
 491 
 492   push_CPU_state();
 493   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::print_state32)));
 494   pop_CPU_state();
 495 
 496   popa();
 497   addl(rsp, wordSize);
 498 }
 499 
 500 #else // _LP64
 501 
 502 // 64 bit versions
 503 
 504 Address MacroAssembler::as_Address(AddressLiteral adr) {
 505   // amd64 always does this as a pc-rel
 506   // we can be absolute or disp based on the instruction type
 507   // jmp/call are displacements others are absolute
 508   assert(!adr.is_lval(), &quot;must be rval&quot;);
 509   assert(reachable(adr), &quot;must be&quot;);
 510   return Address((int32_t)(intptr_t)(adr.target() - pc()), adr.target(), adr.reloc());
 511 
 512 }
 513 
 514 Address MacroAssembler::as_Address(ArrayAddress adr) {
 515   AddressLiteral base = adr.base();
 516   lea(rscratch1, base);
 517   Address index = adr.index();
 518   assert(index._disp == 0, &quot;must not have disp&quot;); // maybe it can?
 519   Address array(rscratch1, index._index, index._scale, index._disp);
 520   return array;
 521 }
 522 
 523 void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) {
 524   Label L, E;
 525 
 526 #ifdef _WIN64
 527   // Windows always allocates space for it&#39;s register args
 528   assert(num_args &lt;= 4, &quot;only register arguments supported&quot;);
 529   subq(rsp,  frame::arg_reg_save_area_bytes);
 530 #endif
 531 
 532   // Align stack if necessary
 533   testl(rsp, 15);
 534   jcc(Assembler::zero, L);
 535 
 536   subq(rsp, 8);
 537   {
 538     call(RuntimeAddress(entry_point));
 539   }
 540   addq(rsp, 8);
 541   jmp(E);
 542 
 543   bind(L);
 544   {
 545     call(RuntimeAddress(entry_point));
 546   }
 547 
 548   bind(E);
 549 
 550 #ifdef _WIN64
 551   // restore stack pointer
 552   addq(rsp, frame::arg_reg_save_area_bytes);
 553 #endif
 554 
 555 }
 556 
 557 void MacroAssembler::cmp64(Register src1, AddressLiteral src2) {
 558   assert(!src2.is_lval(), &quot;should use cmpptr&quot;);
 559 
 560   if (reachable(src2)) {
 561     cmpq(src1, as_Address(src2));
 562   } else {
 563     lea(rscratch1, src2);
 564     Assembler::cmpq(src1, Address(rscratch1, 0));
 565   }
 566 }
 567 
 568 int MacroAssembler::corrected_idivq(Register reg) {
 569   // Full implementation of Java ldiv and lrem; checks for special
 570   // case as described in JVM spec., p.243 &amp; p.271.  The function
 571   // returns the (pc) offset of the idivl instruction - may be needed
 572   // for implicit exceptions.
 573   //
 574   //         normal case                           special case
 575   //
 576   // input : rax: dividend                         min_long
 577   //         reg: divisor   (may not be eax/edx)   -1
 578   //
 579   // output: rax: quotient  (= rax idiv reg)       min_long
 580   //         rdx: remainder (= rax irem reg)       0
 581   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax or rdx register&quot;);
 582   static const int64_t min_long = 0x8000000000000000;
 583   Label normal_case, special_case;
 584 
 585   // check for special case
 586   cmp64(rax, ExternalAddress((address) &amp;min_long));
 587   jcc(Assembler::notEqual, normal_case);
 588   xorl(rdx, rdx); // prepare rdx for possible special case (where
 589                   // remainder = 0)
 590   cmpq(reg, -1);
 591   jcc(Assembler::equal, special_case);
 592 
 593   // handle normal case
 594   bind(normal_case);
 595   cdqq();
 596   int idivq_offset = offset();
 597   idivq(reg);
 598 
 599   // normal and special case exit
 600   bind(special_case);
 601 
 602   return idivq_offset;
 603 }
 604 
 605 void MacroAssembler::decrementq(Register reg, int value) {
 606   if (value == min_jint) { subq(reg, value); return; }
 607   if (value &lt;  0) { incrementq(reg, -value); return; }
 608   if (value == 0) {                        ; return; }
 609   if (value == 1 &amp;&amp; UseIncDec) { decq(reg) ; return; }
 610   /* else */      { subq(reg, value)       ; return; }
 611 }
 612 
 613 void MacroAssembler::decrementq(Address dst, int value) {
 614   if (value == min_jint) { subq(dst, value); return; }
 615   if (value &lt;  0) { incrementq(dst, -value); return; }
 616   if (value == 0) {                        ; return; }
 617   if (value == 1 &amp;&amp; UseIncDec) { decq(dst) ; return; }
 618   /* else */      { subq(dst, value)       ; return; }
 619 }
 620 
 621 void MacroAssembler::incrementq(AddressLiteral dst) {
 622   if (reachable(dst)) {
 623     incrementq(as_Address(dst));
 624   } else {
 625     lea(rscratch1, dst);
 626     incrementq(Address(rscratch1, 0));
 627   }
 628 }
 629 
 630 void MacroAssembler::incrementq(Register reg, int value) {
 631   if (value == min_jint) { addq(reg, value); return; }
 632   if (value &lt;  0) { decrementq(reg, -value); return; }
 633   if (value == 0) {                        ; return; }
 634   if (value == 1 &amp;&amp; UseIncDec) { incq(reg) ; return; }
 635   /* else */      { addq(reg, value)       ; return; }
 636 }
 637 
 638 void MacroAssembler::incrementq(Address dst, int value) {
 639   if (value == min_jint) { addq(dst, value); return; }
 640   if (value &lt;  0) { decrementq(dst, -value); return; }
 641   if (value == 0) {                        ; return; }
 642   if (value == 1 &amp;&amp; UseIncDec) { incq(dst) ; return; }
 643   /* else */      { addq(dst, value)       ; return; }
 644 }
 645 
 646 // 32bit can do a case table jump in one instruction but we no longer allow the base
 647 // to be installed in the Address class
 648 void MacroAssembler::jump(ArrayAddress entry) {
 649   lea(rscratch1, entry.base());
 650   Address dispatch = entry.index();
 651   assert(dispatch._base == noreg, &quot;must be&quot;);
 652   dispatch._base = rscratch1;
 653   jmp(dispatch);
 654 }
 655 
 656 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 657   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 658   cmpq(x_lo, y_lo);
 659 }
 660 
 661 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 662     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 663 }
 664 
 665 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 666   mov_literal64(rscratch1, (intptr_t)adr.target(), adr.rspec());
 667   movptr(dst, rscratch1);
 668 }
 669 
 670 void MacroAssembler::leave() {
 671   // %%% is this really better? Why not on 32bit too?
 672   emit_int8((unsigned char)0xC9); // LEAVE
 673 }
 674 
 675 void MacroAssembler::lneg(Register hi, Register lo) {
 676   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 677   negq(lo);
 678 }
 679 
 680 void MacroAssembler::movoop(Register dst, jobject obj) {
 681   mov_literal64(dst, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 682 }
 683 
 684 void MacroAssembler::movoop(Address dst, jobject obj) {
 685   mov_literal64(rscratch1, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 686   movq(dst, rscratch1);
 687 }
 688 
 689 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 690   mov_literal64(dst, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 691 }
 692 
 693 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 694   mov_literal64(rscratch1, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 695   movq(dst, rscratch1);
 696 }
 697 
 698 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 699   if (src.is_lval()) {
 700     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 701   } else {
 702     if (reachable(src)) {
 703       movq(dst, as_Address(src));
 704     } else {
 705       lea(scratch, src);
 706       movq(dst, Address(scratch, 0));
 707     }
 708   }
 709 }
 710 
 711 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 712   movq(as_Address(dst), src);
 713 }
 714 
 715 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 716   movq(dst, as_Address(src));
 717 }
 718 
 719 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 720 void MacroAssembler::movptr(Address dst, intptr_t src) {
 721   mov64(rscratch1, src);
 722   movq(dst, rscratch1);
 723 }
 724 
 725 // These are mostly for initializing NULL
 726 void MacroAssembler::movptr(Address dst, int32_t src) {
 727   movslq(dst, src);
 728 }
 729 
 730 void MacroAssembler::movptr(Register dst, int32_t src) {
 731   mov64(dst, (intptr_t)src);
 732 }
 733 
 734 void MacroAssembler::pushoop(jobject obj) {
 735   movoop(rscratch1, obj);
 736   push(rscratch1);
 737 }
 738 
 739 void MacroAssembler::pushklass(Metadata* obj) {
 740   mov_metadata(rscratch1, obj);
 741   push(rscratch1);
 742 }
 743 
 744 void MacroAssembler::pushptr(AddressLiteral src) {
 745   lea(rscratch1, src);
 746   if (src.is_lval()) {
 747     push(rscratch1);
 748   } else {
 749     pushq(Address(rscratch1, 0));
 750   }
 751 }
 752 
 753 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 754   // we must set sp to zero to clear frame
 755   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
 756   // must clear fp, so that compiled frames are not confused; it is
 757   // possible that we need it only for debugging
 758   if (clear_fp) {
 759     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
 760   }
 761 
 762   // Always clear the pc because it could have been set by make_walkable()
 763   movptr(Address(r15_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
 764   vzeroupper();
 765 }
 766 
 767 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 768                                          Register last_java_fp,
 769                                          address  last_java_pc) {
 770   vzeroupper();
 771   // determine last_java_sp register
 772   if (!last_java_sp-&gt;is_valid()) {
 773     last_java_sp = rsp;
 774   }
 775 
 776   // last_java_fp is optional
 777   if (last_java_fp-&gt;is_valid()) {
 778     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()),
 779            last_java_fp);
 780   }
 781 
 782   // last_java_pc is optional
 783   if (last_java_pc != NULL) {
 784     Address java_pc(r15_thread,
 785                     JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
 786     lea(rscratch1, InternalAddress(last_java_pc));
 787     movptr(java_pc, rscratch1);
 788   }
 789 
 790   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
 791 }
 792 
 793 static void pass_arg0(MacroAssembler* masm, Register arg) {
 794   if (c_rarg0 != arg ) {
 795     masm-&gt;mov(c_rarg0, arg);
 796   }
 797 }
 798 
 799 static void pass_arg1(MacroAssembler* masm, Register arg) {
 800   if (c_rarg1 != arg ) {
 801     masm-&gt;mov(c_rarg1, arg);
 802   }
 803 }
 804 
 805 static void pass_arg2(MacroAssembler* masm, Register arg) {
 806   if (c_rarg2 != arg ) {
 807     masm-&gt;mov(c_rarg2, arg);
 808   }
 809 }
 810 
 811 static void pass_arg3(MacroAssembler* masm, Register arg) {
 812   if (c_rarg3 != arg ) {
 813     masm-&gt;mov(c_rarg3, arg);
 814   }
 815 }
 816 
 817 void MacroAssembler::stop(const char* msg) {
 818   if (ShowMessageBoxOnError) {
 819     address rip = pc();
 820     pusha(); // get regs on stack
 821     lea(c_rarg1, InternalAddress(rip));
 822     movq(c_rarg2, rsp); // pass pointer to regs array
 823   }
 824   lea(c_rarg0, ExternalAddress((address) msg));
 825   andq(rsp, -16); // align stack as required by ABI
 826   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug64)));
 827   hlt();
 828 }
 829 
 830 void MacroAssembler::warn(const char* msg) {
 831   push(rbp);
 832   movq(rbp, rsp);
 833   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 834   push_CPU_state();   // keeps alignment at 16 bytes
 835   lea(c_rarg0, ExternalAddress((address) msg));
 836   lea(rax, ExternalAddress(CAST_FROM_FN_PTR(address, warning)));
 837   call(rax);
 838   pop_CPU_state();
 839   mov(rsp, rbp);
 840   pop(rbp);
 841 }
 842 
 843 void MacroAssembler::print_state() {
 844   address rip = pc();
 845   pusha();            // get regs on stack
 846   push(rbp);
 847   movq(rbp, rsp);
 848   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 849   push_CPU_state();   // keeps alignment at 16 bytes
 850 
 851   lea(c_rarg0, InternalAddress(rip));
 852   lea(c_rarg1, Address(rbp, wordSize)); // pass pointer to regs array
 853   call_VM_leaf(CAST_FROM_FN_PTR(address, MacroAssembler::print_state64), c_rarg0, c_rarg1);
 854 
 855   pop_CPU_state();
 856   mov(rsp, rbp);
 857   pop(rbp);
 858   popa();
 859 }
 860 
 861 #ifndef PRODUCT
 862 extern &quot;C&quot; void findpc(intptr_t x);
 863 #endif
 864 
 865 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[]) {
 866   // In order to get locks to work, we need to fake a in_VM state
 867   if (ShowMessageBoxOnError) {
 868     JavaThread* thread = JavaThread::current();
 869     JavaThreadState saved_state = thread-&gt;thread_state();
 870     thread-&gt;set_thread_state(_thread_in_vm);
 871 #ifndef PRODUCT
 872     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 873       ttyLocker ttyl;
 874       BytecodeCounter::print();
 875     }
 876 #endif
 877     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 878     // XXX correct this offset for amd64
 879     // This is the value of eip which points to where verify_oop will return.
 880     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 881       print_state64(pc, regs);
 882       BREAKPOINT;
 883     }
 884   }
 885   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 886 }
 887 
 888 void MacroAssembler::print_state64(int64_t pc, int64_t regs[]) {
 889   ttyLocker ttyl;
 890   FlagSetting fs(Debugging, true);
 891   tty-&gt;print_cr(&quot;rip = 0x%016lx&quot;, (intptr_t)pc);
 892 #ifndef PRODUCT
 893   tty-&gt;cr();
 894   findpc(pc);
 895   tty-&gt;cr();
 896 #endif
 897 #define PRINT_REG(rax, value) \
 898   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, value); }
 899   PRINT_REG(rax, regs[15]);
 900   PRINT_REG(rbx, regs[12]);
 901   PRINT_REG(rcx, regs[14]);
 902   PRINT_REG(rdx, regs[13]);
 903   PRINT_REG(rdi, regs[8]);
 904   PRINT_REG(rsi, regs[9]);
 905   PRINT_REG(rbp, regs[10]);
 906   // rsp is actually not stored by pusha(), compute the old rsp from regs (rsp after pusha): regs + 16 = old rsp
 907   PRINT_REG(rsp, (intptr_t)(&amp;regs[16]));
 908   PRINT_REG(r8 , regs[7]);
 909   PRINT_REG(r9 , regs[6]);
 910   PRINT_REG(r10, regs[5]);
 911   PRINT_REG(r11, regs[4]);
 912   PRINT_REG(r12, regs[3]);
 913   PRINT_REG(r13, regs[2]);
 914   PRINT_REG(r14, regs[1]);
 915   PRINT_REG(r15, regs[0]);
 916 #undef PRINT_REG
 917   // Print some words near the top of the stack.
 918   int64_t* rsp = &amp;regs[16];
 919   int64_t* dump_sp = rsp;
 920   for (int col1 = 0; col1 &lt; 8; col1++) {
 921     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 922     os::print_location(tty, *dump_sp++);
 923   }
 924   for (int row = 0; row &lt; 25; row++) {
 925     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 926     for (int col = 0; col &lt; 4; col++) {
 927       tty-&gt;print(&quot; 0x%016lx&quot;, (intptr_t)*dump_sp++);
 928     }
 929     tty-&gt;cr();
 930   }
 931   // Print some instructions around pc:
 932   Disassembler::decode((address)pc-64, (address)pc);
 933   tty-&gt;print_cr(&quot;--------&quot;);
 934   Disassembler::decode((address)pc, (address)pc+32);
 935 }
 936 
 937 #endif // _LP64
 938 
 939 // Now versions that are common to 32/64 bit
 940 
 941 void MacroAssembler::addptr(Register dst, int32_t imm32) {
 942   LP64_ONLY(addq(dst, imm32)) NOT_LP64(addl(dst, imm32));
 943 }
 944 
 945 void MacroAssembler::addptr(Register dst, Register src) {
 946   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 947 }
 948 
 949 void MacroAssembler::addptr(Address dst, Register src) {
 950   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 951 }
 952 
 953 void MacroAssembler::addsd(XMMRegister dst, AddressLiteral src) {
 954   if (reachable(src)) {
 955     Assembler::addsd(dst, as_Address(src));
 956   } else {
 957     lea(rscratch1, src);
 958     Assembler::addsd(dst, Address(rscratch1, 0));
 959   }
 960 }
 961 
 962 void MacroAssembler::addss(XMMRegister dst, AddressLiteral src) {
 963   if (reachable(src)) {
 964     addss(dst, as_Address(src));
 965   } else {
 966     lea(rscratch1, src);
 967     addss(dst, Address(rscratch1, 0));
 968   }
 969 }
 970 
 971 void MacroAssembler::addpd(XMMRegister dst, AddressLiteral src) {
 972   if (reachable(src)) {
 973     Assembler::addpd(dst, as_Address(src));
 974   } else {
 975     lea(rscratch1, src);
 976     Assembler::addpd(dst, Address(rscratch1, 0));
 977   }
 978 }
 979 
 980 void MacroAssembler::align(int modulus) {
 981   align(modulus, offset());
 982 }
 983 
 984 void MacroAssembler::align(int modulus, int target) {
 985   if (target % modulus != 0) {
 986     nop(modulus - (target % modulus));
 987   }
 988 }
 989 
 990 void MacroAssembler::andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 991   // Used in sign-masking with aligned address.
 992   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 993   if (reachable(src)) {
 994     Assembler::andpd(dst, as_Address(src));
 995   } else {
 996     lea(scratch_reg, src);
 997     Assembler::andpd(dst, Address(scratch_reg, 0));
 998   }
 999 }
1000 
1001 void MacroAssembler::andps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
1002   // Used in sign-masking with aligned address.
1003   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
1004   if (reachable(src)) {
1005     Assembler::andps(dst, as_Address(src));
1006   } else {
1007     lea(scratch_reg, src);
1008     Assembler::andps(dst, Address(scratch_reg, 0));
1009   }
1010 }
1011 
1012 void MacroAssembler::andptr(Register dst, int32_t imm32) {
1013   LP64_ONLY(andq(dst, imm32)) NOT_LP64(andl(dst, imm32));
1014 }
1015 
1016 void MacroAssembler::atomic_incl(Address counter_addr) {
1017   lock();
1018   incrementl(counter_addr);
1019 }
1020 
1021 void MacroAssembler::atomic_incl(AddressLiteral counter_addr, Register scr) {
1022   if (reachable(counter_addr)) {
1023     atomic_incl(as_Address(counter_addr));
1024   } else {
1025     lea(scr, counter_addr);
1026     atomic_incl(Address(scr, 0));
1027   }
1028 }
1029 
1030 #ifdef _LP64
1031 void MacroAssembler::atomic_incq(Address counter_addr) {
1032   lock();
1033   incrementq(counter_addr);
1034 }
1035 
1036 void MacroAssembler::atomic_incq(AddressLiteral counter_addr, Register scr) {
1037   if (reachable(counter_addr)) {
1038     atomic_incq(as_Address(counter_addr));
1039   } else {
1040     lea(scr, counter_addr);
1041     atomic_incq(Address(scr, 0));
1042   }
1043 }
1044 #endif
1045 
1046 // Writes to stack successive pages until offset reached to check for
1047 // stack overflow + shadow pages.  This clobbers tmp.
1048 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
1049   movptr(tmp, rsp);
1050   // Bang stack for total size given plus shadow page size.
1051   // Bang one page at a time because large size can bang beyond yellow and
1052   // red zones.
1053   Label loop;
1054   bind(loop);
1055   movl(Address(tmp, (-os::vm_page_size())), size );
1056   subptr(tmp, os::vm_page_size());
1057   subl(size, os::vm_page_size());
1058   jcc(Assembler::greater, loop);
1059 
1060   // Bang down shadow pages too.
1061   // At this point, (tmp-0) is the last address touched, so don&#39;t
1062   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
1063   // was post-decremented.)  Skip this address by starting at i=1, and
1064   // touch a few more pages below.  N.B.  It is important to touch all
1065   // the way down including all pages in the shadow zone.
1066   for (int i = 1; i &lt; ((int)JavaThread::stack_shadow_zone_size() / os::vm_page_size()); i++) {
1067     // this could be any sized move but this is can be a debugging crumb
1068     // so the bigger the better.
1069     movptr(Address(tmp, (-i*os::vm_page_size())), size );
1070   }
1071 }
1072 
1073 void MacroAssembler::reserved_stack_check() {
1074     // testing if reserved zone needs to be enabled
1075     Label no_reserved_zone_enabling;
1076     Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
1077     NOT_LP64(get_thread(rsi);)
1078 
1079     cmpptr(rsp, Address(thread, JavaThread::reserved_stack_activation_offset()));
1080     jcc(Assembler::below, no_reserved_zone_enabling);
1081 
1082     call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), thread);
1083     jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
1084     should_not_reach_here();
1085 
1086     bind(no_reserved_zone_enabling);
1087 }
1088 
1089 int MacroAssembler::biased_locking_enter(Register lock_reg,
1090                                          Register obj_reg,
1091                                          Register swap_reg,
1092                                          Register tmp_reg,
1093                                          Register tmp_reg2,
1094                                          bool swap_reg_contains_mark,
1095                                          Label&amp; done,
1096                                          Label* slow_case,
1097                                          BiasedLockingCounters* counters) {
1098   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1099   assert(swap_reg == rax, &quot;swap_reg must be rax for cmpxchgq&quot;);
1100   assert(tmp_reg != noreg, &quot;tmp_reg must be supplied&quot;);
1101   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);
1102   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
1103   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
1104   NOT_LP64( Address saved_mark_addr(lock_reg, 0); )
1105 
1106   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL) {
1107     counters = BiasedLocking::counters();
1108   }
1109   // Biased locking
1110   // See whether the lock is currently biased toward our thread and
1111   // whether the epoch is still valid
1112   // Note that the runtime guarantees sufficient alignment of JavaThread
1113   // pointers to allow age to be placed into low bits
1114   // First check to see whether biasing is even enabled for this object
1115   Label cas_label;
1116   int null_check_offset = -1;
1117   if (!swap_reg_contains_mark) {
1118     null_check_offset = offset();
1119     movptr(swap_reg, mark_addr);
1120   }
1121   movptr(tmp_reg, swap_reg);
1122   andptr(tmp_reg, markWord::biased_lock_mask_in_place);
1123   cmpptr(tmp_reg, markWord::biased_lock_pattern);
1124   jcc(Assembler::notEqual, cas_label);
1125   // The bias pattern is present in the object&#39;s header. Need to check
1126   // whether the bias owner and the epoch are both still current.
1127 #ifndef _LP64
1128   // Note that because there is no current thread register on x86_32 we
1129   // need to store off the mark word we read out of the object to
1130   // avoid reloading it and needing to recheck invariants below. This
1131   // store is unfortunate but it makes the overall code shorter and
1132   // simpler.
1133   movptr(saved_mark_addr, swap_reg);
1134 #endif
1135   if (swap_reg_contains_mark) {
1136     null_check_offset = offset();
1137   }
1138   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1139 #ifdef _LP64
1140   orptr(tmp_reg, r15_thread);
1141   xorptr(tmp_reg, swap_reg);
1142   Register header_reg = tmp_reg;
1143 #else
1144   xorptr(tmp_reg, swap_reg);
1145   get_thread(swap_reg);
1146   xorptr(swap_reg, tmp_reg);
1147   Register header_reg = swap_reg;
1148 #endif
1149   andptr(header_reg, ~((int) markWord::age_mask_in_place));
1150   if (counters != NULL) {
1151     cond_inc32(Assembler::zero,
1152                ExternalAddress((address) counters-&gt;biased_lock_entry_count_addr()));
1153   }
1154   jcc(Assembler::equal, done);
1155 
1156   Label try_revoke_bias;
1157   Label try_rebias;
1158 
1159   // At this point we know that the header has the bias pattern and
1160   // that we are not the bias owner in the current epoch. We need to
1161   // figure out more details about the state of the header in order to
1162   // know what operations can be legally performed on the object&#39;s
1163   // header.
1164 
1165   // If the low three bits in the xor result aren&#39;t clear, that means
1166   // the prototype header is no longer biased and we have to revoke
1167   // the bias on this object.
1168   testptr(header_reg, markWord::biased_lock_mask_in_place);
1169   jccb(Assembler::notZero, try_revoke_bias);
1170 
1171   // Biasing is still enabled for this data type. See whether the
1172   // epoch of the current bias is still valid, meaning that the epoch
1173   // bits of the mark word are equal to the epoch bits of the
1174   // prototype header. (Note that the prototype header&#39;s epoch bits
1175   // only change at a safepoint.) If not, attempt to rebias the object
1176   // toward the current thread. Note that we must be absolutely sure
1177   // that the current epoch is invalid in order to do this because
1178   // otherwise the manipulations it performs on the mark word are
1179   // illegal.
1180   testptr(header_reg, markWord::epoch_mask_in_place);
1181   jccb(Assembler::notZero, try_rebias);
1182 
1183   // The epoch of the current bias is still valid but we know nothing
1184   // about the owner; it might be set or it might be clear. Try to
1185   // acquire the bias of the object using an atomic operation. If this
1186   // fails we will go in to the runtime to revoke the object&#39;s bias.
1187   // Note that we first construct the presumed unbiased header so we
1188   // don&#39;t accidentally blow away another thread&#39;s valid bias.
1189   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1190   andptr(swap_reg,
1191          markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
1192 #ifdef _LP64
1193   movptr(tmp_reg, swap_reg);
1194   orptr(tmp_reg, r15_thread);
1195 #else
1196   get_thread(tmp_reg);
1197   orptr(tmp_reg, swap_reg);
1198 #endif
1199   lock();
1200   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1201   // If the biasing toward our thread failed, this means that
1202   // another thread succeeded in biasing it toward itself and we
1203   // need to revoke that bias. The revocation will occur in the
1204   // interpreter runtime in the slow case.
1205   if (counters != NULL) {
1206     cond_inc32(Assembler::zero,
1207                ExternalAddress((address) counters-&gt;anonymously_biased_lock_entry_count_addr()));
1208   }
1209   if (slow_case != NULL) {
1210     jcc(Assembler::notZero, *slow_case);
1211   }
1212   jmp(done);
1213 
1214   bind(try_rebias);
1215   // At this point we know the epoch has expired, meaning that the
1216   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
1217   // circumstances _only_, we are allowed to use the current header&#39;s
1218   // value as the comparison value when doing the cas to acquire the
1219   // bias in the current epoch. In other words, we allow transfer of
1220   // the bias from one thread to another directly in this situation.
1221   //
1222   // FIXME: due to a lack of registers we currently blow away the age
1223   // bits in this situation. Should attempt to preserve them.
1224   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1225 #ifdef _LP64
1226   orptr(tmp_reg, r15_thread);
1227 #else
1228   get_thread(swap_reg);
1229   orptr(tmp_reg, swap_reg);
1230   movptr(swap_reg, saved_mark_addr);
1231 #endif
1232   lock();
1233   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1234   // If the biasing toward our thread failed, then another thread
1235   // succeeded in biasing it toward itself and we need to revoke that
1236   // bias. The revocation will occur in the runtime in the slow case.
1237   if (counters != NULL) {
1238     cond_inc32(Assembler::zero,
1239                ExternalAddress((address) counters-&gt;rebiased_lock_entry_count_addr()));
1240   }
1241   if (slow_case != NULL) {
1242     jcc(Assembler::notZero, *slow_case);
1243   }
1244   jmp(done);
1245 
1246   bind(try_revoke_bias);
1247   // The prototype mark in the klass doesn&#39;t have the bias bit set any
1248   // more, indicating that objects of this data type are not supposed
1249   // to be biased any more. We are going to try to reset the mark of
1250   // this object to the prototype value and fall through to the
1251   // CAS-based locking scheme. Note that if our CAS fails, it means
1252   // that another thread raced us for the privilege of revoking the
1253   // bias of this particular object, so it&#39;s okay to continue in the
1254   // normal locking code.
1255   //
1256   // FIXME: due to a lack of registers we currently blow away the age
1257   // bits in this situation. Should attempt to preserve them.
1258   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1259   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1260   lock();
1261   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1262   // Fall through to the normal CAS-based lock, because no matter what
1263   // the result of the above CAS, some thread must have succeeded in
1264   // removing the bias bit from the object&#39;s header.
1265   if (counters != NULL) {
1266     cond_inc32(Assembler::zero,
1267                ExternalAddress((address) counters-&gt;revoked_lock_entry_count_addr()));
1268   }
1269 
1270   bind(cas_label);
1271 
1272   return null_check_offset;
1273 }
1274 
1275 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
1276   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1277 
1278   // Check for biased locking unlock case, which is a no-op
1279   // Note: we do not have to check the thread ID for two reasons.
1280   // First, the interpreter checks for IllegalMonitorStateException at
1281   // a higher level. Second, if the bias was revoked while we held the
1282   // lock, the object could not be rebiased toward another thread, so
1283   // the bias bit would be clear.
1284   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1285   andptr(temp_reg, markWord::biased_lock_mask_in_place);
1286   cmpptr(temp_reg, markWord::biased_lock_pattern);
1287   jcc(Assembler::equal, done);
1288 }
1289 
1290 void MacroAssembler::c2bool(Register x) {
1291   // implements x == 0 ? 0 : 1
1292   // note: must only look at least-significant byte of x
1293   //       since C-style booleans are stored in one byte
1294   //       only! (was bug)
1295   andl(x, 0xFF);
1296   setb(Assembler::notZero, x);
1297 }
1298 
1299 // Wouldn&#39;t need if AddressLiteral version had new name
1300 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
1301   Assembler::call(L, rtype);
1302 }
1303 
1304 void MacroAssembler::call(Register entry) {
1305   Assembler::call(entry);
1306 }
1307 
1308 void MacroAssembler::call(AddressLiteral entry) {
1309   if (reachable(entry)) {
1310     Assembler::call_literal(entry.target(), entry.rspec());
1311   } else {
1312     lea(rscratch1, entry);
1313     Assembler::call(rscratch1);
1314   }
1315 }
1316 
1317 void MacroAssembler::ic_call(address entry, jint method_index) {
1318   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
1319   movptr(rax, (intptr_t)Universe::non_oop_word());
1320   call(AddressLiteral(entry, rh));
1321 }
1322 
1323 // Implementation of call_VM versions
1324 
1325 void MacroAssembler::call_VM(Register oop_result,
1326                              address entry_point,
1327                              bool check_exceptions) {
1328   Label C, E;
1329   call(C, relocInfo::none);
1330   jmp(E);
1331 
1332   bind(C);
1333   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
1334   ret(0);
1335 
1336   bind(E);
1337 }
1338 
1339 void MacroAssembler::call_VM(Register oop_result,
1340                              address entry_point,
1341                              Register arg_1,
1342                              bool check_exceptions) {
1343   Label C, E;
1344   call(C, relocInfo::none);
1345   jmp(E);
1346 
1347   bind(C);
1348   pass_arg1(this, arg_1);
1349   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
1350   ret(0);
1351 
1352   bind(E);
1353 }
1354 
1355 void MacroAssembler::call_VM(Register oop_result,
1356                              address entry_point,
1357                              Register arg_1,
1358                              Register arg_2,
1359                              bool check_exceptions) {
1360   Label C, E;
1361   call(C, relocInfo::none);
1362   jmp(E);
1363 
1364   bind(C);
1365 
1366   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1367 
1368   pass_arg2(this, arg_2);
1369   pass_arg1(this, arg_1);
1370   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
1371   ret(0);
1372 
1373   bind(E);
1374 }
1375 
1376 void MacroAssembler::call_VM(Register oop_result,
1377                              address entry_point,
1378                              Register arg_1,
1379                              Register arg_2,
1380                              Register arg_3,
1381                              bool check_exceptions) {
1382   Label C, E;
1383   call(C, relocInfo::none);
1384   jmp(E);
1385 
1386   bind(C);
1387 
1388   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1389   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1390   pass_arg3(this, arg_3);
1391 
1392   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1393   pass_arg2(this, arg_2);
1394 
1395   pass_arg1(this, arg_1);
1396   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
1397   ret(0);
1398 
1399   bind(E);
1400 }
1401 
1402 void MacroAssembler::call_VM(Register oop_result,
1403                              Register last_java_sp,
1404                              address entry_point,
1405                              int number_of_arguments,
1406                              bool check_exceptions) {
1407   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1408   call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1409 }
1410 
1411 void MacroAssembler::call_VM(Register oop_result,
1412                              Register last_java_sp,
1413                              address entry_point,
1414                              Register arg_1,
1415                              bool check_exceptions) {
1416   pass_arg1(this, arg_1);
1417   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1418 }
1419 
1420 void MacroAssembler::call_VM(Register oop_result,
1421                              Register last_java_sp,
1422                              address entry_point,
1423                              Register arg_1,
1424                              Register arg_2,
1425                              bool check_exceptions) {
1426 
1427   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1428   pass_arg2(this, arg_2);
1429   pass_arg1(this, arg_1);
1430   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1431 }
1432 
1433 void MacroAssembler::call_VM(Register oop_result,
1434                              Register last_java_sp,
1435                              address entry_point,
1436                              Register arg_1,
1437                              Register arg_2,
1438                              Register arg_3,
1439                              bool check_exceptions) {
1440   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1441   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1442   pass_arg3(this, arg_3);
1443   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1444   pass_arg2(this, arg_2);
1445   pass_arg1(this, arg_1);
1446   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1447 }
1448 
1449 void MacroAssembler::super_call_VM(Register oop_result,
1450                                    Register last_java_sp,
1451                                    address entry_point,
1452                                    int number_of_arguments,
1453                                    bool check_exceptions) {
1454   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1455   MacroAssembler::call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1456 }
1457 
1458 void MacroAssembler::super_call_VM(Register oop_result,
1459                                    Register last_java_sp,
1460                                    address entry_point,
1461                                    Register arg_1,
1462                                    bool check_exceptions) {
1463   pass_arg1(this, arg_1);
1464   super_call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1465 }
1466 
1467 void MacroAssembler::super_call_VM(Register oop_result,
1468                                    Register last_java_sp,
1469                                    address entry_point,
1470                                    Register arg_1,
1471                                    Register arg_2,
1472                                    bool check_exceptions) {
1473 
1474   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1475   pass_arg2(this, arg_2);
1476   pass_arg1(this, arg_1);
1477   super_call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1478 }
1479 
1480 void MacroAssembler::super_call_VM(Register oop_result,
1481                                    Register last_java_sp,
1482                                    address entry_point,
1483                                    Register arg_1,
1484                                    Register arg_2,
1485                                    Register arg_3,
1486                                    bool check_exceptions) {
1487   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1488   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1489   pass_arg3(this, arg_3);
1490   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1491   pass_arg2(this, arg_2);
1492   pass_arg1(this, arg_1);
1493   super_call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1494 }
1495 
1496 void MacroAssembler::call_VM_base(Register oop_result,
1497                                   Register java_thread,
1498                                   Register last_java_sp,
1499                                   address  entry_point,
1500                                   int      number_of_arguments,
1501                                   bool     check_exceptions) {
1502   // determine java_thread register
1503   if (!java_thread-&gt;is_valid()) {
1504 #ifdef _LP64
1505     java_thread = r15_thread;
1506 #else
1507     java_thread = rdi;
1508     get_thread(java_thread);
1509 #endif // LP64
1510   }
1511   // determine last_java_sp register
1512   if (!last_java_sp-&gt;is_valid()) {
1513     last_java_sp = rsp;
1514   }
1515   // debugging support
1516   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
1517   LP64_ONLY(assert(java_thread == r15_thread, &quot;unexpected register&quot;));
1518 #ifdef ASSERT
1519   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
1520   // r12 is the heapbase.
1521   LP64_ONLY(if (UseCompressedOops &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);)
1522 #endif // ASSERT
1523 
1524   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
1525   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
1526 
1527   // push java thread (becomes first argument of C function)
1528 
1529   NOT_LP64(push(java_thread); number_of_arguments++);
1530   LP64_ONLY(mov(c_rarg0, r15_thread));
1531 
1532   // set last Java frame before call
1533   assert(last_java_sp != rbp, &quot;can&#39;t use ebp/rbp&quot;);
1534 
1535   // Only interpreter should have to set fp
1536   set_last_Java_frame(java_thread, last_java_sp, rbp, NULL);
1537 
1538   // do the call, remove parameters
1539   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments);
1540 
1541   // restore the thread (cannot use the pushed argument since arguments
1542   // may be overwritten by C code generated by an optimizing compiler);
1543   // however can use the register value directly if it is callee saved.
1544   if (LP64_ONLY(true ||) java_thread == rdi || java_thread == rsi) {
1545     // rdi &amp; rsi (also r15) are callee saved -&gt; nothing to do
1546 #ifdef ASSERT
1547     guarantee(java_thread != rax, &quot;change this code&quot;);
1548     push(rax);
1549     { Label L;
1550       get_thread(rax);
1551       cmpptr(java_thread, rax);
1552       jcc(Assembler::equal, L);
1553       STOP(&quot;MacroAssembler::call_VM_base: rdi not callee saved?&quot;);
1554       bind(L);
1555     }
1556     pop(rax);
1557 #endif
1558   } else {
1559     get_thread(java_thread);
1560   }
1561   // reset last Java frame
1562   // Only interpreter should have to clear fp
1563   reset_last_Java_frame(java_thread, true);
1564 
1565    // C++ interp handles this in the interpreter
1566   check_and_handle_popframe(java_thread);
1567   check_and_handle_earlyret(java_thread);
1568 
1569   if (check_exceptions) {
1570     // check for pending exceptions (java_thread is set upon return)
1571     cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);
1572 #ifndef _LP64
1573     jump_cc(Assembler::notEqual,
1574             RuntimeAddress(StubRoutines::forward_exception_entry()));
1575 #else
1576     // This used to conditionally jump to forward_exception however it is
1577     // possible if we relocate that the branch will not reach. So we must jump
1578     // around so we can always reach
1579 
1580     Label ok;
1581     jcc(Assembler::equal, ok);
1582     jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
1583     bind(ok);
1584 #endif // LP64
1585   }
1586 
1587   // get oop result if there is one and reset the value in the thread
1588   if (oop_result-&gt;is_valid()) {
1589     get_vm_result(oop_result, java_thread);
1590   }
1591 }
1592 
1593 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
1594 
1595   // Calculate the value for last_Java_sp
1596   // somewhat subtle. call_VM does an intermediate call
1597   // which places a return address on the stack just under the
1598   // stack pointer as the user finsihed with it. This allows
1599   // use to retrieve last_Java_pc from last_Java_sp[-1].
1600   // On 32bit we then have to push additional args on the stack to accomplish
1601   // the actual requested call. On 64bit call_VM only can use register args
1602   // so the only extra space is the return address that call_VM created.
1603   // This hopefully explains the calculations here.
1604 
1605 #ifdef _LP64
1606   // We&#39;ve pushed one address, correct last_Java_sp
1607   lea(rax, Address(rsp, wordSize));
1608 #else
1609   lea(rax, Address(rsp, (1 + number_of_arguments) * wordSize));
1610 #endif // LP64
1611 
1612   call_VM_base(oop_result, noreg, rax, entry_point, number_of_arguments, check_exceptions);
1613 
1614 }
1615 
1616 // Use this method when MacroAssembler version of call_VM_leaf_base() should be called from Interpreter.
1617 void MacroAssembler::call_VM_leaf0(address entry_point) {
1618   MacroAssembler::call_VM_leaf_base(entry_point, 0);
1619 }
1620 
1621 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
1622   call_VM_leaf_base(entry_point, number_of_arguments);
1623 }
1624 
1625 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
1626   pass_arg0(this, arg_0);
1627   call_VM_leaf(entry_point, 1);
1628 }
1629 
1630 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1631 
1632   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1633   pass_arg1(this, arg_1);
1634   pass_arg0(this, arg_0);
1635   call_VM_leaf(entry_point, 2);
1636 }
1637 
1638 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1639   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1640   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1641   pass_arg2(this, arg_2);
1642   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1643   pass_arg1(this, arg_1);
1644   pass_arg0(this, arg_0);
1645   call_VM_leaf(entry_point, 3);
1646 }
1647 
1648 void MacroAssembler::super_call_VM_leaf(address entry_point) {
1649   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1650 }
1651 
1652 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
1653   pass_arg0(this, arg_0);
1654   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1655 }
1656 
1657 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1658 
1659   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1660   pass_arg1(this, arg_1);
1661   pass_arg0(this, arg_0);
1662   MacroAssembler::call_VM_leaf_base(entry_point, 2);
1663 }
1664 
1665 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1666   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1667   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1668   pass_arg2(this, arg_2);
1669   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1670   pass_arg1(this, arg_1);
1671   pass_arg0(this, arg_0);
1672   MacroAssembler::call_VM_leaf_base(entry_point, 3);
1673 }
1674 
1675 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
1676   LP64_ONLY(assert(arg_0 != c_rarg3, &quot;smashed arg&quot;));
1677   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1678   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1679   pass_arg3(this, arg_3);
1680   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1681   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1682   pass_arg2(this, arg_2);
1683   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1684   pass_arg1(this, arg_1);
1685   pass_arg0(this, arg_0);
1686   MacroAssembler::call_VM_leaf_base(entry_point, 4);
1687 }
1688 
1689 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
1690   movptr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
1691   movptr(Address(java_thread, JavaThread::vm_result_offset()), NULL_WORD);
1692   verify_oop_msg(oop_result, &quot;broken oop in call_VM_base&quot;);
1693 }
1694 
1695 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
1696   movptr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
1697   movptr(Address(java_thread, JavaThread::vm_result_2_offset()), NULL_WORD);
1698 }
1699 
1700 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
1701 }
1702 
1703 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
1704 }
1705 
1706 void MacroAssembler::cmp32(AddressLiteral src1, int32_t imm) {
1707   if (reachable(src1)) {
1708     cmpl(as_Address(src1), imm);
1709   } else {
1710     lea(rscratch1, src1);
1711     cmpl(Address(rscratch1, 0), imm);
1712   }
1713 }
1714 
1715 void MacroAssembler::cmp32(Register src1, AddressLiteral src2) {
1716   assert(!src2.is_lval(), &quot;use cmpptr&quot;);
1717   if (reachable(src2)) {
1718     cmpl(src1, as_Address(src2));
1719   } else {
1720     lea(rscratch1, src2);
1721     cmpl(src1, Address(rscratch1, 0));
1722   }
1723 }
1724 
1725 void MacroAssembler::cmp32(Register src1, int32_t imm) {
1726   Assembler::cmpl(src1, imm);
1727 }
1728 
1729 void MacroAssembler::cmp32(Register src1, Address src2) {
1730   Assembler::cmpl(src1, src2);
1731 }
1732 
1733 void MacroAssembler::cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1734   ucomisd(opr1, opr2);
1735 
1736   Label L;
1737   if (unordered_is_less) {
1738     movl(dst, -1);
1739     jcc(Assembler::parity, L);
1740     jcc(Assembler::below , L);
1741     movl(dst, 0);
1742     jcc(Assembler::equal , L);
1743     increment(dst);
1744   } else { // unordered is greater
1745     movl(dst, 1);
1746     jcc(Assembler::parity, L);
1747     jcc(Assembler::above , L);
1748     movl(dst, 0);
1749     jcc(Assembler::equal , L);
1750     decrementl(dst);
1751   }
1752   bind(L);
1753 }
1754 
1755 void MacroAssembler::cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1756   ucomiss(opr1, opr2);
1757 
1758   Label L;
1759   if (unordered_is_less) {
1760     movl(dst, -1);
1761     jcc(Assembler::parity, L);
1762     jcc(Assembler::below , L);
1763     movl(dst, 0);
1764     jcc(Assembler::equal , L);
1765     increment(dst);
1766   } else { // unordered is greater
1767     movl(dst, 1);
1768     jcc(Assembler::parity, L);
1769     jcc(Assembler::above , L);
1770     movl(dst, 0);
1771     jcc(Assembler::equal , L);
1772     decrementl(dst);
1773   }
1774   bind(L);
1775 }
1776 
1777 
1778 void MacroAssembler::cmp8(AddressLiteral src1, int imm) {
1779   if (reachable(src1)) {
1780     cmpb(as_Address(src1), imm);
1781   } else {
1782     lea(rscratch1, src1);
1783     cmpb(Address(rscratch1, 0), imm);
1784   }
1785 }
1786 
1787 void MacroAssembler::cmpptr(Register src1, AddressLiteral src2) {
1788 #ifdef _LP64
1789   if (src2.is_lval()) {
1790     movptr(rscratch1, src2);
1791     Assembler::cmpq(src1, rscratch1);
1792   } else if (reachable(src2)) {
1793     cmpq(src1, as_Address(src2));
1794   } else {
1795     lea(rscratch1, src2);
1796     Assembler::cmpq(src1, Address(rscratch1, 0));
1797   }
1798 #else
1799   if (src2.is_lval()) {
1800     cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1801   } else {
1802     cmpl(src1, as_Address(src2));
1803   }
1804 #endif // _LP64
1805 }
1806 
1807 void MacroAssembler::cmpptr(Address src1, AddressLiteral src2) {
1808   assert(src2.is_lval(), &quot;not a mem-mem compare&quot;);
1809 #ifdef _LP64
1810   // moves src2&#39;s literal address
1811   movptr(rscratch1, src2);
1812   Assembler::cmpq(src1, rscratch1);
1813 #else
1814   cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1815 #endif // _LP64
1816 }
1817 
1818 void MacroAssembler::cmpoop(Register src1, Register src2) {
1819   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1820   bs-&gt;obj_equals(this, src1, src2);
1821 }
1822 
1823 void MacroAssembler::cmpoop(Register src1, Address src2) {
1824   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1825   bs-&gt;obj_equals(this, src1, src2);
1826 }
1827 
1828 #ifdef _LP64
1829 void MacroAssembler::cmpoop(Register src1, jobject src2) {
1830   movoop(rscratch1, src2);
1831   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1832   bs-&gt;obj_equals(this, src1, rscratch1);
1833 }
1834 #endif
1835 
1836 void MacroAssembler::locked_cmpxchgptr(Register reg, AddressLiteral adr) {
1837   if (reachable(adr)) {
1838     lock();
1839     cmpxchgptr(reg, as_Address(adr));
1840   } else {
1841     lea(rscratch1, adr);
1842     lock();
1843     cmpxchgptr(reg, Address(rscratch1, 0));
1844   }
1845 }
1846 
1847 void MacroAssembler::cmpxchgptr(Register reg, Address adr) {
1848   LP64_ONLY(cmpxchgq(reg, adr)) NOT_LP64(cmpxchgl(reg, adr));
1849 }
1850 
1851 void MacroAssembler::comisd(XMMRegister dst, AddressLiteral src) {
1852   if (reachable(src)) {
1853     Assembler::comisd(dst, as_Address(src));
1854   } else {
1855     lea(rscratch1, src);
1856     Assembler::comisd(dst, Address(rscratch1, 0));
1857   }
1858 }
1859 
1860 void MacroAssembler::comiss(XMMRegister dst, AddressLiteral src) {
1861   if (reachable(src)) {
1862     Assembler::comiss(dst, as_Address(src));
1863   } else {
1864     lea(rscratch1, src);
1865     Assembler::comiss(dst, Address(rscratch1, 0));
1866   }
1867 }
1868 
1869 
1870 void MacroAssembler::cond_inc32(Condition cond, AddressLiteral counter_addr) {
1871   Condition negated_cond = negate_condition(cond);
1872   Label L;
1873   jcc(negated_cond, L);
1874   pushf(); // Preserve flags
1875   atomic_incl(counter_addr);
1876   popf();
1877   bind(L);
1878 }
1879 
1880 int MacroAssembler::corrected_idivl(Register reg) {
1881   // Full implementation of Java idiv and irem; checks for
1882   // special case as described in JVM spec., p.243 &amp; p.271.
1883   // The function returns the (pc) offset of the idivl
1884   // instruction - may be needed for implicit exceptions.
1885   //
1886   //         normal case                           special case
1887   //
1888   // input : rax,: dividend                         min_int
1889   //         reg: divisor   (may not be rax,/rdx)   -1
1890   //
1891   // output: rax,: quotient  (= rax, idiv reg)       min_int
1892   //         rdx: remainder (= rax, irem reg)       0
1893   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax, or rdx register&quot;);
1894   const int min_int = 0x80000000;
1895   Label normal_case, special_case;
1896 
1897   // check for special case
1898   cmpl(rax, min_int);
1899   jcc(Assembler::notEqual, normal_case);
1900   xorl(rdx, rdx); // prepare rdx for possible special case (where remainder = 0)
1901   cmpl(reg, -1);
1902   jcc(Assembler::equal, special_case);
1903 
1904   // handle normal case
1905   bind(normal_case);
1906   cdql();
1907   int idivl_offset = offset();
1908   idivl(reg);
1909 
1910   // normal and special case exit
1911   bind(special_case);
1912 
1913   return idivl_offset;
1914 }
1915 
1916 
1917 
1918 void MacroAssembler::decrementl(Register reg, int value) {
1919   if (value == min_jint) {subl(reg, value) ; return; }
1920   if (value &lt;  0) { incrementl(reg, -value); return; }
1921   if (value == 0) {                        ; return; }
1922   if (value == 1 &amp;&amp; UseIncDec) { decl(reg) ; return; }
1923   /* else */      { subl(reg, value)       ; return; }
1924 }
1925 
1926 void MacroAssembler::decrementl(Address dst, int value) {
1927   if (value == min_jint) {subl(dst, value) ; return; }
1928   if (value &lt;  0) { incrementl(dst, -value); return; }
1929   if (value == 0) {                        ; return; }
1930   if (value == 1 &amp;&amp; UseIncDec) { decl(dst) ; return; }
1931   /* else */      { subl(dst, value)       ; return; }
1932 }
1933 
1934 void MacroAssembler::division_with_shift (Register reg, int shift_value) {
1935   assert (shift_value &gt; 0, &quot;illegal shift value&quot;);
1936   Label _is_positive;
1937   testl (reg, reg);
1938   jcc (Assembler::positive, _is_positive);
1939   int offset = (1 &lt;&lt; shift_value) - 1 ;
1940 
1941   if (offset == 1) {
1942     incrementl(reg);
1943   } else {
1944     addl(reg, offset);
1945   }
1946 
1947   bind (_is_positive);
1948   sarl(reg, shift_value);
1949 }
1950 
1951 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
1952   if (reachable(src)) {
1953     Assembler::divsd(dst, as_Address(src));
1954   } else {
1955     lea(rscratch1, src);
1956     Assembler::divsd(dst, Address(rscratch1, 0));
1957   }
1958 }
1959 
1960 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
1961   if (reachable(src)) {
1962     Assembler::divss(dst, as_Address(src));
1963   } else {
1964     lea(rscratch1, src);
1965     Assembler::divss(dst, Address(rscratch1, 0));
1966   }
1967 }
1968 
1969 void MacroAssembler::enter() {
1970   push(rbp);
1971   mov(rbp, rsp);
1972 }
1973 
1974 // A 5 byte nop that is safe for patching (see patch_verified_entry)
1975 void MacroAssembler::fat_nop() {
1976   if (UseAddressNop) {
1977     addr_nop_5();
1978   } else {
1979     emit_int8(0x26); // es:
1980     emit_int8(0x2e); // cs:
1981     emit_int8(0x64); // fs:
1982     emit_int8(0x65); // gs:
1983     emit_int8((unsigned char)0x90);
1984   }
1985 }
1986 
1987 #ifndef _LP64
1988 void MacroAssembler::fcmp(Register tmp) {
1989   fcmp(tmp, 1, true, true);
1990 }
1991 
1992 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
1993   assert(!pop_right || pop_left, &quot;usage error&quot;);
1994   if (VM_Version::supports_cmov()) {
1995     assert(tmp == noreg, &quot;unneeded temp&quot;);
1996     if (pop_left) {
1997       fucomip(index);
1998     } else {
1999       fucomi(index);
2000     }
2001     if (pop_right) {
2002       fpop();
2003     }
2004   } else {
2005     assert(tmp != noreg, &quot;need temp&quot;);
2006     if (pop_left) {
2007       if (pop_right) {
2008         fcompp();
2009       } else {
2010         fcomp(index);
2011       }
2012     } else {
2013       fcom(index);
2014     }
2015     // convert FPU condition into eflags condition via rax,
2016     save_rax(tmp);
2017     fwait(); fnstsw_ax();
2018     sahf();
2019     restore_rax(tmp);
2020   }
2021   // condition codes set as follows:
2022   //
2023   // CF (corresponds to C0) if x &lt; y
2024   // PF (corresponds to C2) if unordered
2025   // ZF (corresponds to C3) if x = y
2026 }
2027 
2028 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less) {
2029   fcmp2int(dst, unordered_is_less, 1, true, true);
2030 }
2031 
2032 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right) {
2033   fcmp(VM_Version::supports_cmov() ? noreg : dst, index, pop_left, pop_right);
2034   Label L;
2035   if (unordered_is_less) {
2036     movl(dst, -1);
2037     jcc(Assembler::parity, L);
2038     jcc(Assembler::below , L);
2039     movl(dst, 0);
2040     jcc(Assembler::equal , L);
2041     increment(dst);
2042   } else { // unordered is greater
2043     movl(dst, 1);
2044     jcc(Assembler::parity, L);
2045     jcc(Assembler::above , L);
2046     movl(dst, 0);
2047     jcc(Assembler::equal , L);
2048     decrementl(dst);
2049   }
2050   bind(L);
2051 }
2052 
2053 void MacroAssembler::fld_d(AddressLiteral src) {
2054   fld_d(as_Address(src));
2055 }
2056 
2057 void MacroAssembler::fld_s(AddressLiteral src) {
2058   fld_s(as_Address(src));
2059 }
2060 
2061 void MacroAssembler::fld_x(AddressLiteral src) {
2062   Assembler::fld_x(as_Address(src));
2063 }
2064 
2065 void MacroAssembler::fldcw(AddressLiteral src) {
2066   Assembler::fldcw(as_Address(src));
2067 }
2068 
2069 void MacroAssembler::fpop() {
2070   ffree();
2071   fincstp();
2072 }
2073 
2074 void MacroAssembler::fremr(Register tmp) {
2075   save_rax(tmp);
2076   { Label L;
2077     bind(L);
2078     fprem();
2079     fwait(); fnstsw_ax();
2080     sahf();
2081     jcc(Assembler::parity, L);
2082   }
2083   restore_rax(tmp);
2084   // Result is in ST0.
2085   // Note: fxch &amp; fpop to get rid of ST1
2086   // (otherwise FPU stack could overflow eventually)
2087   fxch(1);
2088   fpop();
2089 }
2090 
2091 void MacroAssembler::empty_FPU_stack() {
2092   if (VM_Version::supports_mmx()) {
2093     emms();
2094   } else {
2095     for (int i = 8; i-- &gt; 0; ) ffree(i);
2096   }
2097 }
2098 #endif // !LP64
2099 
2100 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
2101   if (reachable(src)) {
2102     Assembler::mulpd(dst, as_Address(src));
2103   } else {
2104     lea(rscratch1, src);
2105     Assembler::mulpd(dst, Address(rscratch1, 0));
2106   }
2107 }
2108 
2109 void MacroAssembler::load_float(Address src) {
2110 #ifdef _LP64
2111   movflt(xmm0, src);
2112 #else
2113   if (UseSSE &gt;= 1) {
2114     movflt(xmm0, src);
2115   } else {
2116     fld_s(src);
2117   }
2118 #endif // LP64
2119 }
2120 
2121 void MacroAssembler::store_float(Address dst) {
2122 #ifdef _LP64
2123   movflt(dst, xmm0);
2124 #else
2125   if (UseSSE &gt;= 1) {
2126     movflt(dst, xmm0);
2127   } else {
2128     fstp_s(dst);
2129   }
2130 #endif // LP64
2131 }
2132 
2133 void MacroAssembler::load_double(Address src) {
2134 #ifdef _LP64
2135   movdbl(xmm0, src);
2136 #else
2137   if (UseSSE &gt;= 2) {
2138     movdbl(xmm0, src);
2139   } else {
2140     fld_d(src);
2141   }
2142 #endif // LP64
2143 }
2144 
2145 void MacroAssembler::store_double(Address dst) {
2146 #ifdef _LP64
2147   movdbl(dst, xmm0);
2148 #else
2149   if (UseSSE &gt;= 2) {
2150     movdbl(dst, xmm0);
2151   } else {
2152     fstp_d(dst);
2153   }
2154 #endif // LP64
2155 }
2156 
2157 // dst = c = a * b + c
2158 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2159   Assembler::vfmadd231sd(c, a, b);
2160   if (dst != c) {
2161     movdbl(dst, c);
2162   }
2163 }
2164 
2165 // dst = c = a * b + c
2166 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2167   Assembler::vfmadd231ss(c, a, b);
2168   if (dst != c) {
2169     movflt(dst, c);
2170   }
2171 }
2172 
2173 // dst = c = a * b + c
2174 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2175   Assembler::vfmadd231pd(c, a, b, vector_len);
2176   if (dst != c) {
2177     vmovdqu(dst, c);
2178   }
2179 }
2180 
2181 // dst = c = a * b + c
2182 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2183   Assembler::vfmadd231ps(c, a, b, vector_len);
2184   if (dst != c) {
2185     vmovdqu(dst, c);
2186   }
2187 }
2188 
2189 // dst = c = a * b + c
2190 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2191   Assembler::vfmadd231pd(c, a, b, vector_len);
2192   if (dst != c) {
2193     vmovdqu(dst, c);
2194   }
2195 }
2196 
2197 // dst = c = a * b + c
2198 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2199   Assembler::vfmadd231ps(c, a, b, vector_len);
2200   if (dst != c) {
2201     vmovdqu(dst, c);
2202   }
2203 }
2204 
2205 void MacroAssembler::incrementl(AddressLiteral dst) {
2206   if (reachable(dst)) {
2207     incrementl(as_Address(dst));
2208   } else {
2209     lea(rscratch1, dst);
2210     incrementl(Address(rscratch1, 0));
2211   }
2212 }
2213 
2214 void MacroAssembler::incrementl(ArrayAddress dst) {
2215   incrementl(as_Address(dst));
2216 }
2217 
2218 void MacroAssembler::incrementl(Register reg, int value) {
2219   if (value == min_jint) {addl(reg, value) ; return; }
2220   if (value &lt;  0) { decrementl(reg, -value); return; }
2221   if (value == 0) {                        ; return; }
2222   if (value == 1 &amp;&amp; UseIncDec) { incl(reg) ; return; }
2223   /* else */      { addl(reg, value)       ; return; }
2224 }
2225 
2226 void MacroAssembler::incrementl(Address dst, int value) {
2227   if (value == min_jint) {addl(dst, value) ; return; }
2228   if (value &lt;  0) { decrementl(dst, -value); return; }
2229   if (value == 0) {                        ; return; }
2230   if (value == 1 &amp;&amp; UseIncDec) { incl(dst) ; return; }
2231   /* else */      { addl(dst, value)       ; return; }
2232 }
2233 
2234 void MacroAssembler::jump(AddressLiteral dst) {
2235   if (reachable(dst)) {
2236     jmp_literal(dst.target(), dst.rspec());
2237   } else {
2238     lea(rscratch1, dst);
2239     jmp(rscratch1);
2240   }
2241 }
2242 
2243 void MacroAssembler::jump_cc(Condition cc, AddressLiteral dst) {
2244   if (reachable(dst)) {
2245     InstructionMark im(this);
2246     relocate(dst.reloc());
2247     const int short_size = 2;
2248     const int long_size = 6;
2249     int offs = (intptr_t)dst.target() - ((intptr_t)pc());
2250     if (dst.reloc() == relocInfo::none &amp;&amp; is8bit(offs - short_size)) {
2251       // 0111 tttn #8-bit disp
2252       emit_int8(0x70 | cc);
2253       emit_int8((offs - short_size) &amp; 0xFF);
2254     } else {
2255       // 0000 1111 1000 tttn #32-bit disp
2256       emit_int8(0x0F);
2257       emit_int8((unsigned char)(0x80 | cc));
2258       emit_int32(offs - long_size);
2259     }
2260   } else {
2261 #ifdef ASSERT
2262     warning(&quot;reversing conditional branch&quot;);
2263 #endif /* ASSERT */
2264     Label skip;
2265     jccb(reverse[cc], skip);
2266     lea(rscratch1, dst);
2267     Assembler::jmp(rscratch1);
2268     bind(skip);
2269   }
2270 }
2271 
2272 void MacroAssembler::ldmxcsr(AddressLiteral src) {
2273   if (reachable(src)) {
2274     Assembler::ldmxcsr(as_Address(src));
2275   } else {
2276     lea(rscratch1, src);
2277     Assembler::ldmxcsr(Address(rscratch1, 0));
2278   }
2279 }
2280 
2281 int MacroAssembler::load_signed_byte(Register dst, Address src) {
2282   int off;
2283   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2284     off = offset();
2285     movsbl(dst, src); // movsxb
2286   } else {
2287     off = load_unsigned_byte(dst, src);
2288     shll(dst, 24);
2289     sarl(dst, 24);
2290   }
2291   return off;
2292 }
2293 
2294 // Note: load_signed_short used to be called load_signed_word.
2295 // Although the &#39;w&#39; in x86 opcodes refers to the term &quot;word&quot; in the assembler
2296 // manual, which means 16 bits, that usage is found nowhere in HotSpot code.
2297 // The term &quot;word&quot; in HotSpot means a 32- or 64-bit machine word.
2298 int MacroAssembler::load_signed_short(Register dst, Address src) {
2299   int off;
2300   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2301     // This is dubious to me since it seems safe to do a signed 16 =&gt; 64 bit
2302     // version but this is what 64bit has always done. This seems to imply
2303     // that users are only using 32bits worth.
2304     off = offset();
2305     movswl(dst, src); // movsxw
2306   } else {
2307     off = load_unsigned_short(dst, src);
2308     shll(dst, 16);
2309     sarl(dst, 16);
2310   }
2311   return off;
2312 }
2313 
2314 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
2315   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2316   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2317   int off;
2318   if (LP64_ONLY(true || ) VM_Version::is_P6() || src.uses(dst)) {
2319     off = offset();
2320     movzbl(dst, src); // movzxb
2321   } else {
2322     xorl(dst, dst);
2323     off = offset();
2324     movb(dst, src);
2325   }
2326   return off;
2327 }
2328 
2329 // Note: load_unsigned_short used to be called load_unsigned_word.
2330 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
2331   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2332   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2333   int off;
2334   if (LP64_ONLY(true ||) VM_Version::is_P6() || src.uses(dst)) {
2335     off = offset();
2336     movzwl(dst, src); // movzxw
2337   } else {
2338     xorl(dst, dst);
2339     off = offset();
2340     movw(dst, src);
2341   }
2342   return off;
2343 }
2344 
2345 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
2346   switch (size_in_bytes) {
2347 #ifndef _LP64
2348   case  8:
2349     assert(dst2 != noreg, &quot;second dest register required&quot;);
2350     movl(dst,  src);
2351     movl(dst2, src.plus_disp(BytesPerInt));
2352     break;
2353 #else
2354   case  8:  movq(dst, src); break;
2355 #endif
2356   case  4:  movl(dst, src); break;
2357   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
2358   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
2359   default:  ShouldNotReachHere();
2360   }
2361 }
2362 
2363 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
2364   switch (size_in_bytes) {
2365 #ifndef _LP64
2366   case  8:
2367     assert(src2 != noreg, &quot;second source register required&quot;);
2368     movl(dst,                        src);
2369     movl(dst.plus_disp(BytesPerInt), src2);
2370     break;
2371 #else
2372   case  8:  movq(dst, src); break;
2373 #endif
2374   case  4:  movl(dst, src); break;
2375   case  2:  movw(dst, src); break;
2376   case  1:  movb(dst, src); break;
2377   default:  ShouldNotReachHere();
2378   }
2379 }
2380 
2381 void MacroAssembler::mov32(AddressLiteral dst, Register src) {
2382   if (reachable(dst)) {
2383     movl(as_Address(dst), src);
2384   } else {
2385     lea(rscratch1, dst);
2386     movl(Address(rscratch1, 0), src);
2387   }
2388 }
2389 
2390 void MacroAssembler::mov32(Register dst, AddressLiteral src) {
2391   if (reachable(src)) {
2392     movl(dst, as_Address(src));
2393   } else {
2394     lea(rscratch1, src);
2395     movl(dst, Address(rscratch1, 0));
2396   }
2397 }
2398 
2399 // C++ bool manipulation
2400 
2401 void MacroAssembler::movbool(Register dst, Address src) {
2402   if(sizeof(bool) == 1)
2403     movb(dst, src);
2404   else if(sizeof(bool) == 2)
2405     movw(dst, src);
2406   else if(sizeof(bool) == 4)
2407     movl(dst, src);
2408   else
2409     // unsupported
2410     ShouldNotReachHere();
2411 }
2412 
2413 void MacroAssembler::movbool(Address dst, bool boolconst) {
2414   if(sizeof(bool) == 1)
2415     movb(dst, (int) boolconst);
2416   else if(sizeof(bool) == 2)
2417     movw(dst, (int) boolconst);
2418   else if(sizeof(bool) == 4)
2419     movl(dst, (int) boolconst);
2420   else
2421     // unsupported
2422     ShouldNotReachHere();
2423 }
2424 
2425 void MacroAssembler::movbool(Address dst, Register src) {
2426   if(sizeof(bool) == 1)
2427     movb(dst, src);
2428   else if(sizeof(bool) == 2)
2429     movw(dst, src);
2430   else if(sizeof(bool) == 4)
2431     movl(dst, src);
2432   else
2433     // unsupported
2434     ShouldNotReachHere();
2435 }
2436 
2437 void MacroAssembler::movbyte(ArrayAddress dst, int src) {
2438   movb(as_Address(dst), src);
2439 }
2440 
2441 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
2442   if (reachable(src)) {
2443     movdl(dst, as_Address(src));
2444   } else {
2445     lea(rscratch1, src);
2446     movdl(dst, Address(rscratch1, 0));
2447   }
2448 }
2449 
2450 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
2451   if (reachable(src)) {
2452     movq(dst, as_Address(src));
2453   } else {
2454     lea(rscratch1, src);
2455     movq(dst, Address(rscratch1, 0));
2456   }
2457 }
2458 
2459 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
2460   if (reachable(src)) {
2461     if (UseXmmLoadAndClearUpper) {
2462       movsd (dst, as_Address(src));
2463     } else {
2464       movlpd(dst, as_Address(src));
2465     }
2466   } else {
2467     lea(rscratch1, src);
2468     if (UseXmmLoadAndClearUpper) {
2469       movsd (dst, Address(rscratch1, 0));
2470     } else {
2471       movlpd(dst, Address(rscratch1, 0));
2472     }
2473   }
2474 }
2475 
2476 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
2477   if (reachable(src)) {
2478     movss(dst, as_Address(src));
2479   } else {
2480     lea(rscratch1, src);
2481     movss(dst, Address(rscratch1, 0));
2482   }
2483 }
2484 
2485 void MacroAssembler::movptr(Register dst, Register src) {
2486   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2487 }
2488 
2489 void MacroAssembler::movptr(Register dst, Address src) {
2490   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2491 }
2492 
2493 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
2494 void MacroAssembler::movptr(Register dst, intptr_t src) {
2495   LP64_ONLY(mov64(dst, src)) NOT_LP64(movl(dst, src));
2496 }
2497 
2498 void MacroAssembler::movptr(Address dst, Register src) {
2499   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2500 }
2501 
2502 void MacroAssembler::movdqu(Address dst, XMMRegister src) {
2503     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2504     Assembler::movdqu(dst, src);
2505 }
2506 
2507 void MacroAssembler::movdqu(XMMRegister dst, Address src) {
2508     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2509     Assembler::movdqu(dst, src);
2510 }
2511 
2512 void MacroAssembler::movdqu(XMMRegister dst, XMMRegister src) {
2513     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2514     Assembler::movdqu(dst, src);
2515 }
2516 
2517 void MacroAssembler::movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg) {
2518   if (reachable(src)) {
2519     movdqu(dst, as_Address(src));
2520   } else {
2521     lea(scratchReg, src);
2522     movdqu(dst, Address(scratchReg, 0));
2523   }
2524 }
2525 
2526 void MacroAssembler::vmovdqu(Address dst, XMMRegister src) {
2527     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2528     Assembler::vmovdqu(dst, src);
2529 }
2530 
2531 void MacroAssembler::vmovdqu(XMMRegister dst, Address src) {
2532     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2533     Assembler::vmovdqu(dst, src);
2534 }
2535 
2536 void MacroAssembler::vmovdqu(XMMRegister dst, XMMRegister src) {
2537     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2538     Assembler::vmovdqu(dst, src);
2539 }
2540 
2541 void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2542   if (reachable(src)) {
2543     vmovdqu(dst, as_Address(src));
2544   }
2545   else {
2546     lea(scratch_reg, src);
2547     vmovdqu(dst, Address(scratch_reg, 0));
2548   }
2549 }
2550 
2551 void MacroAssembler::evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {
2552   if (reachable(src)) {
2553     Assembler::evmovdquq(dst, as_Address(src), vector_len);
2554   } else {
2555     lea(rscratch, src);
2556     Assembler::evmovdquq(dst, Address(rscratch, 0), vector_len);
2557   }
2558 }
2559 
2560 void MacroAssembler::movdqa(XMMRegister dst, AddressLiteral src) {
2561   if (reachable(src)) {
2562     Assembler::movdqa(dst, as_Address(src));
2563   } else {
2564     lea(rscratch1, src);
2565     Assembler::movdqa(dst, Address(rscratch1, 0));
2566   }
2567 }
2568 
2569 void MacroAssembler::movsd(XMMRegister dst, AddressLiteral src) {
2570   if (reachable(src)) {
2571     Assembler::movsd(dst, as_Address(src));
2572   } else {
2573     lea(rscratch1, src);
2574     Assembler::movsd(dst, Address(rscratch1, 0));
2575   }
2576 }
2577 
2578 void MacroAssembler::movss(XMMRegister dst, AddressLiteral src) {
2579   if (reachable(src)) {
2580     Assembler::movss(dst, as_Address(src));
2581   } else {
2582     lea(rscratch1, src);
2583     Assembler::movss(dst, Address(rscratch1, 0));
2584   }
2585 }
2586 
2587 void MacroAssembler::mulsd(XMMRegister dst, AddressLiteral src) {
2588   if (reachable(src)) {
2589     Assembler::mulsd(dst, as_Address(src));
2590   } else {
2591     lea(rscratch1, src);
2592     Assembler::mulsd(dst, Address(rscratch1, 0));
2593   }
2594 }
2595 
2596 void MacroAssembler::mulss(XMMRegister dst, AddressLiteral src) {
2597   if (reachable(src)) {
2598     Assembler::mulss(dst, as_Address(src));
2599   } else {
2600     lea(rscratch1, src);
2601     Assembler::mulss(dst, Address(rscratch1, 0));
2602   }
2603 }
2604 
2605 void MacroAssembler::null_check(Register reg, int offset) {
2606   if (needs_explicit_null_check(offset)) {
2607     // provoke OS NULL exception if reg = NULL by
2608     // accessing M[reg] w/o changing any (non-CC) registers
2609     // NOTE: cmpl is plenty here to provoke a segv
2610     cmpptr(rax, Address(reg, 0));
2611     // Note: should probably use testl(rax, Address(reg, 0));
2612     //       may be shorter code (however, this version of
2613     //       testl needs to be implemented first)
2614   } else {
2615     // nothing to do, (later) access of M[reg + offset]
2616     // will provoke OS NULL exception if reg = NULL
2617   }
2618 }
2619 
2620 void MacroAssembler::test_klass_is_inline_type(Register klass, Register temp_reg, Label&amp; is_inline_type) {
2621   movl(temp_reg, Address(klass, Klass::access_flags_offset()));
2622   testl(temp_reg, JVM_ACC_VALUE);
2623   jcc(Assembler::notZero, is_inline_type);
2624 }
2625 
2626 void MacroAssembler::test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label&amp; is_empty_inline_type) {
2627 #ifdef ASSERT
2628   {
2629     Label done_check;
2630     test_klass_is_inline_type(klass, temp_reg, done_check);
2631     stop(&quot;test_klass_is_empty_inline_type with non inline type klass&quot;);
2632     bind(done_check);
2633   }
2634 #endif
2635   movl(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));
2636   testl(temp_reg, InstanceKlass::misc_flags_is_empty_inline_type());
2637   jcc(Assembler::notZero, is_empty_inline_type);
2638 }
2639 
2640 void MacroAssembler::test_field_is_inline_type(Register flags, Register temp_reg, Label&amp; is_inline_type) {
2641   movl(temp_reg, flags);
2642   shrl(temp_reg, ConstantPoolCacheEntry::is_inline_type_shift);
2643   andl(temp_reg, 0x1);
2644   testl(temp_reg, temp_reg);
2645   jcc(Assembler::notZero, is_inline_type);
2646 }
2647 
2648 void MacroAssembler::test_field_is_not_inline_type(Register flags, Register temp_reg, Label&amp; not_inline_type) {
2649   movl(temp_reg, flags);
2650   shrl(temp_reg, ConstantPoolCacheEntry::is_inline_type_shift);
2651   andl(temp_reg, 0x1);
2652   testl(temp_reg, temp_reg);
2653   jcc(Assembler::zero, not_inline_type);
2654 }
2655 
2656 void MacroAssembler::test_field_is_inlined(Register flags, Register temp_reg, Label&amp; is_inlined) {
2657   movl(temp_reg, flags);
2658   shrl(temp_reg, ConstantPoolCacheEntry::is_inlined_shift);
2659   andl(temp_reg, 0x1);
2660   testl(temp_reg, temp_reg);
2661   jcc(Assembler::notZero, is_inlined);
2662 }
2663 
2664 void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg,
2665                                               Label&amp;is_flattened_array) {
2666   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
2667   load_klass(temp_reg, oop, tmp_load_klass);
2668   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));
2669   test_flattened_array_layout(temp_reg, is_flattened_array);
2670 }
2671 
2672 void MacroAssembler::test_non_flattened_array_oop(Register oop, Register temp_reg,
2673                                                   Label&amp;is_non_flattened_array) {
2674   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
2675   load_klass(temp_reg, oop, tmp_load_klass);
2676   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));
2677   test_non_flattened_array_layout(temp_reg, is_non_flattened_array);
2678 }
2679 
2680 void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_null_free_array) {
2681   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
2682   load_klass(temp_reg, oop, tmp_load_klass);
2683   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));
2684   test_null_free_array_layout(temp_reg, is_null_free_array);
2685 }
2686 
2687 void MacroAssembler::test_non_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_non_null_free_array) {
2688   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
2689   load_klass(temp_reg, oop, tmp_load_klass);
2690   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));
2691   test_non_null_free_array_layout(temp_reg, is_non_null_free_array);
2692 }
2693 
2694 void MacroAssembler::test_flattened_array_layout(Register lh, Label&amp; is_flattened_array) {
2695   testl(lh, Klass::_lh_array_tag_vt_value_bit_inplace);
2696   jcc(Assembler::notZero, is_flattened_array);
2697 }
2698 void MacroAssembler::test_non_flattened_array_layout(Register lh, Label&amp; is_non_flattened_array) {
2699   testl(lh, Klass::_lh_array_tag_vt_value_bit_inplace);
2700   jcc(Assembler::zero, is_non_flattened_array);
2701 }
2702 
2703 void MacroAssembler::test_null_free_array_layout(Register lh, Label&amp; is_null_free_array) {
2704   testl(lh, Klass::_lh_null_free_bit_inplace);
2705   jcc(Assembler::notZero, is_null_free_array);
2706 }
2707 
2708 void MacroAssembler::test_non_null_free_array_layout(Register lh, Label&amp; is_non_null_free_array) {
2709   testl(lh, Klass::_lh_null_free_bit_inplace);
2710   jcc(Assembler::zero, is_non_null_free_array);
2711 }
2712 
2713 
2714 void MacroAssembler::os_breakpoint() {
2715   // instead of directly emitting a breakpoint, call os:breakpoint for better debugability
2716   // (e.g., MSVC can&#39;t call ps() otherwise)
2717   call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
2718 }
2719 
2720 void MacroAssembler::unimplemented(const char* what) {
2721   const char* buf = NULL;
2722   {
2723     ResourceMark rm;
2724     stringStream ss;
2725     ss.print(&quot;unimplemented: %s&quot;, what);
2726     buf = code_string(ss.as_string());
2727   }
2728   stop(buf);
2729 }
2730 
2731 #ifdef _LP64
2732 #define XSTATE_BV 0x200
2733 #endif
2734 
2735 void MacroAssembler::pop_CPU_state() {
2736   pop_FPU_state();
2737   pop_IU_state();
2738 }
2739 
2740 void MacroAssembler::pop_FPU_state() {
2741 #ifndef _LP64
2742   frstor(Address(rsp, 0));
2743 #else
2744   fxrstor(Address(rsp, 0));
2745 #endif
2746   addptr(rsp, FPUStateSizeInWords * wordSize);
2747 }
2748 
2749 void MacroAssembler::pop_IU_state() {
2750   popa();
2751   LP64_ONLY(addq(rsp, 8));
2752   popf();
2753 }
2754 
2755 // Save Integer and Float state
2756 // Warning: Stack must be 16 byte aligned (64bit)
2757 void MacroAssembler::push_CPU_state() {
2758   push_IU_state();
2759   push_FPU_state();
2760 }
2761 
2762 void MacroAssembler::push_FPU_state() {
2763   subptr(rsp, FPUStateSizeInWords * wordSize);
2764 #ifndef _LP64
2765   fnsave(Address(rsp, 0));
2766   fwait();
2767 #else
2768   fxsave(Address(rsp, 0));
2769 #endif // LP64
2770 }
2771 
2772 void MacroAssembler::push_IU_state() {
2773   // Push flags first because pusha kills them
2774   pushf();
2775   // Make sure rsp stays 16-byte aligned
2776   LP64_ONLY(subq(rsp, 8));
2777   pusha();
2778 }
2779 
2780 void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { // determine java_thread register
2781   if (!java_thread-&gt;is_valid()) {
2782     java_thread = rdi;
2783     get_thread(java_thread);
2784   }
2785   // we must set sp to zero to clear frame
2786   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
2787   if (clear_fp) {
2788     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
2789   }
2790 
2791   // Always clear the pc because it could have been set by make_walkable()
2792   movptr(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
2793 
2794   vzeroupper();
2795 }
2796 
2797 void MacroAssembler::restore_rax(Register tmp) {
2798   if (tmp == noreg) pop(rax);
2799   else if (tmp != rax) mov(rax, tmp);
2800 }
2801 
2802 void MacroAssembler::round_to(Register reg, int modulus) {
2803   addptr(reg, modulus - 1);
2804   andptr(reg, -modulus);
2805 }
2806 
2807 void MacroAssembler::save_rax(Register tmp) {
2808   if (tmp == noreg) push(rax);
2809   else if (tmp != rax) mov(tmp, rax);
2810 }
2811 
2812 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
2813 #ifdef _LP64
2814   assert(thread_reg == r15_thread, &quot;should be&quot;);
2815 #else
2816   if (thread_reg == noreg) {
2817     thread_reg = temp_reg;
2818     get_thread(thread_reg);
2819   }
2820 #endif
2821   testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2822   jcc(Assembler::notZero, slow_path); // handshake bit set implies poll
2823 }
2824 
2825 // Calls to C land
2826 //
2827 // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
2828 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
2829 // has to be reset to 0. This is required to allow proper stack traversal.
2830 void MacroAssembler::set_last_Java_frame(Register java_thread,
2831                                          Register last_java_sp,
2832                                          Register last_java_fp,
2833                                          address  last_java_pc) {
2834   vzeroupper();
2835   // determine java_thread register
2836   if (!java_thread-&gt;is_valid()) {
2837     java_thread = rdi;
2838     get_thread(java_thread);
2839   }
2840   // determine last_java_sp register
2841   if (!last_java_sp-&gt;is_valid()) {
2842     last_java_sp = rsp;
2843   }
2844 
2845   // last_java_fp is optional
2846 
2847   if (last_java_fp-&gt;is_valid()) {
2848     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), last_java_fp);
2849   }
2850 
2851   // last_java_pc is optional
2852 
2853   if (last_java_pc != NULL) {
2854     lea(Address(java_thread,
2855                  JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset()),
2856         InternalAddress(last_java_pc));
2857 
2858   }
2859   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
2860 }
2861 
2862 void MacroAssembler::shlptr(Register dst, int imm8) {
2863   LP64_ONLY(shlq(dst, imm8)) NOT_LP64(shll(dst, imm8));
2864 }
2865 
2866 void MacroAssembler::shrptr(Register dst, int imm8) {
2867   LP64_ONLY(shrq(dst, imm8)) NOT_LP64(shrl(dst, imm8));
2868 }
2869 
2870 void MacroAssembler::sign_extend_byte(Register reg) {
2871   if (LP64_ONLY(true ||) (VM_Version::is_P6() &amp;&amp; reg-&gt;has_byte_register())) {
2872     movsbl(reg, reg); // movsxb
2873   } else {
2874     shll(reg, 24);
2875     sarl(reg, 24);
2876   }
2877 }
2878 
2879 void MacroAssembler::sign_extend_short(Register reg) {
2880   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2881     movswl(reg, reg); // movsxw
2882   } else {
2883     shll(reg, 16);
2884     sarl(reg, 16);
2885   }
2886 }
2887 
2888 void MacroAssembler::testl(Register dst, AddressLiteral src) {
2889   assert(reachable(src), &quot;Address should be reachable&quot;);
2890   testl(dst, as_Address(src));
2891 }
2892 
2893 void MacroAssembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
2894   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2895   Assembler::pcmpeqb(dst, src);
2896 }
2897 
2898 void MacroAssembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
2899   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2900   Assembler::pcmpeqw(dst, src);
2901 }
2902 
2903 void MacroAssembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
2904   assert((dst-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2905   Assembler::pcmpestri(dst, src, imm8);
2906 }
2907 
2908 void MacroAssembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
2909   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2910   Assembler::pcmpestri(dst, src, imm8);
2911 }
2912 
2913 void MacroAssembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
2914   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2915   Assembler::pmovzxbw(dst, src);
2916 }
2917 
2918 void MacroAssembler::pmovzxbw(XMMRegister dst, Address src) {
2919   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2920   Assembler::pmovzxbw(dst, src);
2921 }
2922 
2923 void MacroAssembler::pmovmskb(Register dst, XMMRegister src) {
2924   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2925   Assembler::pmovmskb(dst, src);
2926 }
2927 
2928 void MacroAssembler::ptest(XMMRegister dst, XMMRegister src) {
2929   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2930   Assembler::ptest(dst, src);
2931 }
2932 
2933 void MacroAssembler::sqrtsd(XMMRegister dst, AddressLiteral src) {
2934   if (reachable(src)) {
2935     Assembler::sqrtsd(dst, as_Address(src));
2936   } else {
2937     lea(rscratch1, src);
2938     Assembler::sqrtsd(dst, Address(rscratch1, 0));
2939   }
2940 }
2941 
2942 void MacroAssembler::sqrtss(XMMRegister dst, AddressLiteral src) {
2943   if (reachable(src)) {
2944     Assembler::sqrtss(dst, as_Address(src));
2945   } else {
2946     lea(rscratch1, src);
2947     Assembler::sqrtss(dst, Address(rscratch1, 0));
2948   }
2949 }
2950 
2951 void MacroAssembler::subsd(XMMRegister dst, AddressLiteral src) {
2952   if (reachable(src)) {
2953     Assembler::subsd(dst, as_Address(src));
2954   } else {
2955     lea(rscratch1, src);
2956     Assembler::subsd(dst, Address(rscratch1, 0));
2957   }
2958 }
2959 
2960 void MacroAssembler::roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg) {
2961   if (reachable(src)) {
2962     Assembler::roundsd(dst, as_Address(src), rmode);
2963   } else {
2964     lea(scratch_reg, src);
2965     Assembler::roundsd(dst, Address(scratch_reg, 0), rmode);
2966   }
2967 }
2968 
2969 void MacroAssembler::subss(XMMRegister dst, AddressLiteral src) {
2970   if (reachable(src)) {
2971     Assembler::subss(dst, as_Address(src));
2972   } else {
2973     lea(rscratch1, src);
2974     Assembler::subss(dst, Address(rscratch1, 0));
2975   }
2976 }
2977 
2978 void MacroAssembler::ucomisd(XMMRegister dst, AddressLiteral src) {
2979   if (reachable(src)) {
2980     Assembler::ucomisd(dst, as_Address(src));
2981   } else {
2982     lea(rscratch1, src);
2983     Assembler::ucomisd(dst, Address(rscratch1, 0));
2984   }
2985 }
2986 
2987 void MacroAssembler::ucomiss(XMMRegister dst, AddressLiteral src) {
2988   if (reachable(src)) {
2989     Assembler::ucomiss(dst, as_Address(src));
2990   } else {
2991     lea(rscratch1, src);
2992     Assembler::ucomiss(dst, Address(rscratch1, 0));
2993   }
2994 }
2995 
2996 void MacroAssembler::xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2997   // Used in sign-bit flipping with aligned address.
2998   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
2999   if (reachable(src)) {
3000     Assembler::xorpd(dst, as_Address(src));
3001   } else {
3002     lea(scratch_reg, src);
3003     Assembler::xorpd(dst, Address(scratch_reg, 0));
3004   }
3005 }
3006 
3007 void MacroAssembler::xorpd(XMMRegister dst, XMMRegister src) {
3008   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
3009     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
3010   }
3011   else {
3012     Assembler::xorpd(dst, src);
3013   }
3014 }
3015 
3016 void MacroAssembler::xorps(XMMRegister dst, XMMRegister src) {
3017   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
3018     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
3019   } else {
3020     Assembler::xorps(dst, src);
3021   }
3022 }
3023 
3024 void MacroAssembler::xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
3025   // Used in sign-bit flipping with aligned address.
3026   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
3027   if (reachable(src)) {
3028     Assembler::xorps(dst, as_Address(src));
3029   } else {
3030     lea(scratch_reg, src);
3031     Assembler::xorps(dst, Address(scratch_reg, 0));
3032   }
3033 }
3034 
3035 void MacroAssembler::pshufb(XMMRegister dst, AddressLiteral src) {
3036   // Used in sign-bit flipping with aligned address.
3037   bool aligned_adr = (((intptr_t)src.target() &amp; 15) == 0);
3038   assert((UseAVX &gt; 0) || aligned_adr, &quot;SSE mode requires address alignment 16 bytes&quot;);
3039   if (reachable(src)) {
3040     Assembler::pshufb(dst, as_Address(src));
3041   } else {
3042     lea(rscratch1, src);
3043     Assembler::pshufb(dst, Address(rscratch1, 0));
3044   }
3045 }
3046 
3047 // AVX 3-operands instructions
3048 
3049 void MacroAssembler::vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3050   if (reachable(src)) {
3051     vaddsd(dst, nds, as_Address(src));
3052   } else {
3053     lea(rscratch1, src);
3054     vaddsd(dst, nds, Address(rscratch1, 0));
3055   }
3056 }
3057 
3058 void MacroAssembler::vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3059   if (reachable(src)) {
3060     vaddss(dst, nds, as_Address(src));
3061   } else {
3062     lea(rscratch1, src);
3063     vaddss(dst, nds, Address(rscratch1, 0));
3064   }
3065 }
3066 
3067 void MacroAssembler::vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {
3068   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
3069   if (reachable(src)) {
3070     Assembler::vpaddd(dst, nds, as_Address(src), vector_len);
3071   } else {
3072     lea(rscratch, src);
3073     Assembler::vpaddd(dst, nds, Address(rscratch, 0), vector_len);
3074   }
3075 }
3076 
3077 void MacroAssembler::vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
3078   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3079   vandps(dst, nds, negate_field, vector_len);
3080 }
3081 
3082 void MacroAssembler::vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
3083   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3084   vandpd(dst, nds, negate_field, vector_len);
3085 }
3086 
3087 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3088   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3089   Assembler::vpaddb(dst, nds, src, vector_len);
3090 }
3091 
3092 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3093   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3094   Assembler::vpaddb(dst, nds, src, vector_len);
3095 }
3096 
3097 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3098   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3099   Assembler::vpaddw(dst, nds, src, vector_len);
3100 }
3101 
3102 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3103   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3104   Assembler::vpaddw(dst, nds, src, vector_len);
3105 }
3106 
3107 void MacroAssembler::vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3108   if (reachable(src)) {
3109     Assembler::vpand(dst, nds, as_Address(src), vector_len);
3110   } else {
3111     lea(scratch_reg, src);
3112     Assembler::vpand(dst, nds, Address(scratch_reg, 0), vector_len);
3113   }
3114 }
3115 
3116 void MacroAssembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
3117   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3118   Assembler::vpbroadcastw(dst, src, vector_len);
3119 }
3120 
3121 void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3122   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3123   Assembler::vpcmpeqb(dst, nds, src, vector_len);
3124 }
3125 
3126 void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3127   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3128   Assembler::vpcmpeqw(dst, nds, src, vector_len);
3129 }
3130 
3131 void MacroAssembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
3132   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3133   Assembler::vpmovzxbw(dst, src, vector_len);
3134 }
3135 
3136 void MacroAssembler::vpmovmskb(Register dst, XMMRegister src) {
3137   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3138   Assembler::vpmovmskb(dst, src);
3139 }
3140 
3141 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3142   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3143   Assembler::vpmullw(dst, nds, src, vector_len);
3144 }
3145 
3146 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3147   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3148   Assembler::vpmullw(dst, nds, src, vector_len);
3149 }
3150 
3151 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3152   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3153   Assembler::vpsubb(dst, nds, src, vector_len);
3154 }
3155 
3156 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3157   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3158   Assembler::vpsubb(dst, nds, src, vector_len);
3159 }
3160 
3161 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3162   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3163   Assembler::vpsubw(dst, nds, src, vector_len);
3164 }
3165 
3166 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3167   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3168   Assembler::vpsubw(dst, nds, src, vector_len);
3169 }
3170 
3171 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3172   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3173   Assembler::vpsraw(dst, nds, shift, vector_len);
3174 }
3175 
3176 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3177   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3178   Assembler::vpsraw(dst, nds, shift, vector_len);
3179 }
3180 
3181 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3182   assert(UseAVX &gt; 2,&quot;&quot;);
3183   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3184      vector_len = 2;
3185   }
3186   Assembler::evpsraq(dst, nds, shift, vector_len);
3187 }
3188 
3189 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3190   assert(UseAVX &gt; 2,&quot;&quot;);
3191   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3192      vector_len = 2;
3193   }
3194   Assembler::evpsraq(dst, nds, shift, vector_len);
3195 }
3196 
3197 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3198   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3199   Assembler::vpsrlw(dst, nds, shift, vector_len);
3200 }
3201 
3202 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3203   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3204   Assembler::vpsrlw(dst, nds, shift, vector_len);
3205 }
3206 
3207 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3208   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3209   Assembler::vpsllw(dst, nds, shift, vector_len);
3210 }
3211 
3212 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3213   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3214   Assembler::vpsllw(dst, nds, shift, vector_len);
3215 }
3216 
3217 void MacroAssembler::vptest(XMMRegister dst, XMMRegister src) {
3218   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3219   Assembler::vptest(dst, src);
3220 }
3221 
3222 void MacroAssembler::punpcklbw(XMMRegister dst, XMMRegister src) {
3223   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3224   Assembler::punpcklbw(dst, src);
3225 }
3226 
3227 void MacroAssembler::pshufd(XMMRegister dst, Address src, int mode) {
3228   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
3229   Assembler::pshufd(dst, src, mode);
3230 }
3231 
3232 void MacroAssembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
3233   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3234   Assembler::pshuflw(dst, src, mode);
3235 }
3236 
3237 void MacroAssembler::vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3238   if (reachable(src)) {
3239     vandpd(dst, nds, as_Address(src), vector_len);
3240   } else {
3241     lea(scratch_reg, src);
3242     vandpd(dst, nds, Address(scratch_reg, 0), vector_len);
3243   }
3244 }
3245 
3246 void MacroAssembler::vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3247   if (reachable(src)) {
3248     vandps(dst, nds, as_Address(src), vector_len);
3249   } else {
3250     lea(scratch_reg, src);
3251     vandps(dst, nds, Address(scratch_reg, 0), vector_len);
3252   }
3253 }
3254 
3255 void MacroAssembler::vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3256   if (reachable(src)) {
3257     vdivsd(dst, nds, as_Address(src));
3258   } else {
3259     lea(rscratch1, src);
3260     vdivsd(dst, nds, Address(rscratch1, 0));
3261   }
3262 }
3263 
3264 void MacroAssembler::vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3265   if (reachable(src)) {
3266     vdivss(dst, nds, as_Address(src));
3267   } else {
3268     lea(rscratch1, src);
3269     vdivss(dst, nds, Address(rscratch1, 0));
3270   }
3271 }
3272 
3273 void MacroAssembler::vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3274   if (reachable(src)) {
3275     vmulsd(dst, nds, as_Address(src));
3276   } else {
3277     lea(rscratch1, src);
3278     vmulsd(dst, nds, Address(rscratch1, 0));
3279   }
3280 }
3281 
3282 void MacroAssembler::vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3283   if (reachable(src)) {
3284     vmulss(dst, nds, as_Address(src));
3285   } else {
3286     lea(rscratch1, src);
3287     vmulss(dst, nds, Address(rscratch1, 0));
3288   }
3289 }
3290 
3291 void MacroAssembler::vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3292   if (reachable(src)) {
3293     vsubsd(dst, nds, as_Address(src));
3294   } else {
3295     lea(rscratch1, src);
3296     vsubsd(dst, nds, Address(rscratch1, 0));
3297   }
3298 }
3299 
3300 void MacroAssembler::vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3301   if (reachable(src)) {
3302     vsubss(dst, nds, as_Address(src));
3303   } else {
3304     lea(rscratch1, src);
3305     vsubss(dst, nds, Address(rscratch1, 0));
3306   }
3307 }
3308 
3309 void MacroAssembler::vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3310   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3311   vxorps(dst, nds, src, Assembler::AVX_128bit);
3312 }
3313 
3314 void MacroAssembler::vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3315   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3316   vxorpd(dst, nds, src, Assembler::AVX_128bit);
3317 }
3318 
3319 void MacroAssembler::vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3320   if (reachable(src)) {
3321     vxorpd(dst, nds, as_Address(src), vector_len);
3322   } else {
3323     lea(scratch_reg, src);
3324     vxorpd(dst, nds, Address(scratch_reg, 0), vector_len);
3325   }
3326 }
3327 
3328 void MacroAssembler::vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3329   if (reachable(src)) {
3330     vxorps(dst, nds, as_Address(src), vector_len);
3331   } else {
3332     lea(scratch_reg, src);
3333     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
3334   }
3335 }
3336 
3337 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3338   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
3339     if (reachable(src)) {
3340       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
3341     } else {
3342       lea(scratch_reg, src);
3343       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
3344     }
3345   }
3346   else {
3347     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
3348   }
3349 }
3350 
3351 //-------------------------------------------------------------------------------------------
3352 
3353 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
3354   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
3355   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
3356   // The inverted mask is sign-extended
3357   andptr(possibly_jweak, inverted_jweak_mask);
3358 }
3359 
3360 void MacroAssembler::resolve_jobject(Register value,
3361                                      Register thread,
3362                                      Register tmp) {
3363   assert_different_registers(value, thread, tmp);
3364   Label done, not_weak;
3365   testptr(value, value);
3366   jcc(Assembler::zero, done);                // Use NULL as-is.
3367   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
3368   jcc(Assembler::zero, not_weak);
3369   // Resolve jweak.
3370   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
3371                  value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);
3372   verify_oop(value);
3373   jmp(done);
3374   bind(not_weak);
3375   // Resolve (untagged) jobject.
3376   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
3377   verify_oop(value);
3378   bind(done);
3379 }
3380 
3381 void MacroAssembler::subptr(Register dst, int32_t imm32) {
3382   LP64_ONLY(subq(dst, imm32)) NOT_LP64(subl(dst, imm32));
3383 }
3384 
3385 // Force generation of a 4 byte immediate value even if it fits into 8bit
3386 void MacroAssembler::subptr_imm32(Register dst, int32_t imm32) {
3387   LP64_ONLY(subq_imm32(dst, imm32)) NOT_LP64(subl_imm32(dst, imm32));
3388 }
3389 
3390 void MacroAssembler::subptr(Register dst, Register src) {
3391   LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src));
3392 }
3393 
3394 // C++ bool manipulation
3395 void MacroAssembler::testbool(Register dst) {
3396   if(sizeof(bool) == 1)
3397     testb(dst, 0xff);
3398   else if(sizeof(bool) == 2) {
3399     // testw implementation needed for two byte bools
3400     ShouldNotReachHere();
3401   } else if(sizeof(bool) == 4)
3402     testl(dst, dst);
3403   else
3404     // unsupported
3405     ShouldNotReachHere();
3406 }
3407 
3408 void MacroAssembler::testptr(Register dst, Register src) {
3409   LP64_ONLY(testq(dst, src)) NOT_LP64(testl(dst, src));
3410 }
3411 
3412 // Object / value buffer allocation...
3413 //
3414 // Kills klass and rsi on LP64
3415 void MacroAssembler::allocate_instance(Register klass, Register new_obj,
3416                                        Register t1, Register t2,
3417                                        bool clear_fields, Label&amp; alloc_failed)
3418 {
3419   Label done, initialize_header, initialize_object, slow_case, slow_case_no_pop;
3420   Register layout_size = t1;
3421   assert(new_obj == rax, &quot;needs to be rax, according to barrier asm eden_allocate&quot;);
3422   assert_different_registers(klass, new_obj, t1, t2);
3423 
3424 #ifdef ASSERT
3425   {
3426     Label L;
3427     cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3428     jcc(Assembler::equal, L);
3429     stop(&quot;klass not initialized&quot;);
3430     bind(L);
3431   }
3432 #endif
3433 
3434   // get instance_size in InstanceKlass (scaled to a count of bytes)
3435   movl(layout_size, Address(klass, Klass::layout_helper_offset()));
3436   // test to see if it has a finalizer or is malformed in some way
3437   testl(layout_size, Klass::_lh_instance_slow_path_bit);
3438   jcc(Assembler::notZero, slow_case_no_pop);
3439 
3440   // Allocate the instance:
3441   //  If TLAB is enabled:
3442   //    Try to allocate in the TLAB.
3443   //    If fails, go to the slow path.
3444   //  Else If inline contiguous allocations are enabled:
3445   //    Try to allocate in eden.
3446   //    If fails due to heap end, go to slow path.
3447   //
3448   //  If TLAB is enabled OR inline contiguous is enabled:
3449   //    Initialize the allocation.
3450   //    Exit.
3451   //
3452   //  Go to slow path.
3453   const bool allow_shared_alloc =
3454     Universe::heap()-&gt;supports_inline_contig_alloc();
3455 
3456   push(klass);
3457   const Register thread = LP64_ONLY(r15_thread) NOT_LP64(klass);
3458 #ifndef _LP64
3459   if (UseTLAB || allow_shared_alloc) {
3460     get_thread(thread);
3461   }
3462 #endif // _LP64
3463 
3464   if (UseTLAB) {
3465     tlab_allocate(thread, new_obj, layout_size, 0, klass, t2, slow_case);
3466     if (ZeroTLAB || (!clear_fields)) {
3467       // the fields have been already cleared
3468       jmp(initialize_header);
3469     } else {
3470       // initialize both the header and fields
3471       jmp(initialize_object);
3472     }
3473   } else {
3474     // Allocation in the shared Eden, if allowed.
3475     //
3476     eden_allocate(thread, new_obj, layout_size, 0, t2, slow_case);
3477   }
3478 
3479   // If UseTLAB or allow_shared_alloc are true, the object is created above and
3480   // there is an initialize need. Otherwise, skip and go to the slow path.
3481   if (UseTLAB || allow_shared_alloc) {
3482     if (clear_fields) {
3483       // The object is initialized before the header.  If the object size is
3484       // zero, go directly to the header initialization.
3485       bind(initialize_object);
3486       decrement(layout_size, sizeof(oopDesc));
3487       jcc(Assembler::zero, initialize_header);
3488 
3489       // Initialize topmost object field, divide size by 8, check if odd and
3490       // test if zero.
3491       Register zero = klass;
3492       xorl(zero, zero);    // use zero reg to clear memory (shorter code)
3493       shrl(layout_size, LogBytesPerLong); // divide by 2*oopSize and set carry flag if odd
3494 
3495   #ifdef ASSERT
3496       // make sure instance_size was multiple of 8
3497       Label L;
3498       // Ignore partial flag stall after shrl() since it is debug VM
3499       jcc(Assembler::carryClear, L);
3500       stop(&quot;object size is not multiple of 2 - adjust this code&quot;);
3501       bind(L);
3502       // must be &gt; 0, no extra check needed here
3503   #endif
3504 
3505       // initialize remaining object fields: instance_size was a multiple of 8
3506       {
3507         Label loop;
3508         bind(loop);
3509         movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 1*oopSize), zero);
3510         NOT_LP64(movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 2*oopSize), zero));
3511         decrement(layout_size);
3512         jcc(Assembler::notZero, loop);
3513       }
3514     } // clear_fields
3515 
3516     // initialize object header only.
3517     bind(initialize_header);
3518     pop(klass);
3519     Register mark_word = t2;
3520     movptr(mark_word, Address(klass, Klass::prototype_header_offset()));
3521     movptr(Address(new_obj, oopDesc::mark_offset_in_bytes ()), mark_word);
3522 #ifdef _LP64
3523     xorl(rsi, rsi);                 // use zero reg to clear memory (shorter code)
3524     store_klass_gap(new_obj, rsi);  // zero klass gap for compressed oops
3525 #endif
3526     movptr(t2, klass);         // preserve klass
3527     Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
3528     store_klass(new_obj, t2, tmp_store_klass);  // src klass reg is potentially compressed
3529 
3530     jmp(done);
3531   }
3532 
3533   bind(slow_case);
3534   pop(klass);
3535   bind(slow_case_no_pop);
3536   jmp(alloc_failed);
3537 
3538   bind(done);
3539 }
3540 
3541 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
3542 void MacroAssembler::tlab_allocate(Register thread, Register obj,
3543                                    Register var_size_in_bytes,
3544                                    int con_size_in_bytes,
3545                                    Register t1,
3546                                    Register t2,
3547                                    Label&amp; slow_case) {
3548   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3549   bs-&gt;tlab_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
3550 }
3551 
3552 // Defines obj, preserves var_size_in_bytes
3553 void MacroAssembler::eden_allocate(Register thread, Register obj,
3554                                    Register var_size_in_bytes,
3555                                    int con_size_in_bytes,
3556                                    Register t1,
3557                                    Label&amp; slow_case) {
3558   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3559   bs-&gt;eden_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
3560 }
3561 
3562 // Preserves the contents of address, destroys the contents length_in_bytes and temp.
3563 void MacroAssembler::zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp) {
3564   assert(address != length_in_bytes &amp;&amp; address != temp &amp;&amp; temp != length_in_bytes, &quot;registers must be different&quot;);
3565   assert((offset_in_bytes &amp; (BytesPerWord - 1)) == 0, &quot;offset must be a multiple of BytesPerWord&quot;);
3566   Label done;
3567 
3568   testptr(length_in_bytes, length_in_bytes);
3569   jcc(Assembler::zero, done);
3570 
3571   // initialize topmost word, divide index by 2, check if odd and test if zero
3572   // note: for the remaining code to work, index must be a multiple of BytesPerWord
3573 #ifdef ASSERT
3574   {
3575     Label L;
3576     testptr(length_in_bytes, BytesPerWord - 1);
3577     jcc(Assembler::zero, L);
3578     stop(&quot;length must be a multiple of BytesPerWord&quot;);
3579     bind(L);
3580   }
3581 #endif
3582   Register index = length_in_bytes;
3583   xorptr(temp, temp);    // use _zero reg to clear memory (shorter code)
3584   if (UseIncDec) {
3585     shrptr(index, 3);  // divide by 8/16 and set carry flag if bit 2 was set
3586   } else {
3587     shrptr(index, 2);  // use 2 instructions to avoid partial flag stall
3588     shrptr(index, 1);
3589   }
3590 #ifndef _LP64
3591   // index could have not been a multiple of 8 (i.e., bit 2 was set)
3592   {
3593     Label even;
3594     // note: if index was a multiple of 8, then it cannot
3595     //       be 0 now otherwise it must have been 0 before
3596     //       =&gt; if it is even, we don&#39;t need to check for 0 again
3597     jcc(Assembler::carryClear, even);
3598     // clear topmost word (no jump would be needed if conditional assignment worked here)
3599     movptr(Address(address, index, Address::times_8, offset_in_bytes - 0*BytesPerWord), temp);
3600     // index could be 0 now, must check again
3601     jcc(Assembler::zero, done);
3602     bind(even);
3603   }
3604 #endif // !_LP64
3605   // initialize remaining object fields: index is a multiple of 2 now
3606   {
3607     Label loop;
3608     bind(loop);
3609     movptr(Address(address, index, Address::times_8, offset_in_bytes - 1*BytesPerWord), temp);
3610     NOT_LP64(movptr(Address(address, index, Address::times_8, offset_in_bytes - 2*BytesPerWord), temp);)
3611     decrement(index);
3612     jcc(Assembler::notZero, loop);
3613   }
3614 
3615   bind(done);
3616 }
3617 
3618 void MacroAssembler::get_inline_type_field_klass(Register klass, Register index, Register inline_klass) {
3619   movptr(inline_klass, Address(klass, InstanceKlass::inline_type_field_klasses_offset()));
3620 #ifdef ASSERT
3621   {
3622     Label done;
3623     cmpptr(inline_klass, 0);
3624     jcc(Assembler::notEqual, done);
3625     stop(&quot;get_inline_type_field_klass contains no inline klass&quot;);
3626     bind(done);
3627   }
3628 #endif
3629   movptr(inline_klass, Address(inline_klass, index, Address::times_ptr));
3630 }
3631 
3632 void MacroAssembler::get_default_value_oop(Register inline_klass, Register temp_reg, Register obj) {
3633 #ifdef ASSERT
3634   {
3635     Label done_check;
3636     test_klass_is_inline_type(inline_klass, temp_reg, done_check);
3637     stop(&quot;get_default_value_oop from non inline type klass&quot;);
3638     bind(done_check);
3639   }
3640 #endif
3641   Register offset = temp_reg;
3642   // Getting the offset of the pre-allocated default value
3643   movptr(offset, Address(inline_klass, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset())));
3644   movl(offset, Address(offset, in_bytes(InlineKlass::default_value_offset_offset())));
3645 
3646   // Getting the mirror
3647   movptr(obj, Address(inline_klass, in_bytes(Klass::java_mirror_offset())));
3648   resolve_oop_handle(obj, inline_klass);
3649 
3650   // Getting the pre-allocated default value from the mirror
3651   Address field(obj, offset, Address::times_1);
3652   load_heap_oop(obj, field);
3653 }
3654 
3655 void MacroAssembler::get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj) {
3656 #ifdef ASSERT
3657   {
3658     Label done_check;
3659     test_klass_is_empty_inline_type(inline_klass, temp_reg, done_check);
3660     stop(&quot;get_empty_value from non-empty inline klass&quot;);
3661     bind(done_check);
3662   }
3663 #endif
3664   get_default_value_oop(inline_klass, temp_reg, obj);
3665 }
3666 
3667 
3668 // Look up the method for a megamorphic invokeinterface call.
3669 // The target method is determined by &lt;intf_klass, itable_index&gt;.
3670 // The receiver klass is in recv_klass.
3671 // On success, the result will be in method_result, and execution falls through.
3672 // On failure, execution transfers to the given label.
3673 void MacroAssembler::lookup_interface_method(Register recv_klass,
3674                                              Register intf_klass,
3675                                              RegisterOrConstant itable_index,
3676                                              Register method_result,
3677                                              Register scan_temp,
3678                                              Label&amp; L_no_such_interface,
3679                                              bool return_method) {
3680   assert_different_registers(recv_klass, intf_klass, scan_temp);
3681   assert_different_registers(method_result, intf_klass, scan_temp);
3682   assert(recv_klass != method_result || !return_method,
3683          &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
3684 
3685   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
3686          &quot;caller must use same register for non-constant itable index as for method&quot;);
3687 
3688   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
3689   int vtable_base = in_bytes(Klass::vtable_start_offset());
3690   int itentry_off = itableMethodEntry::method_offset_in_bytes();
3691   int scan_step   = itableOffsetEntry::size() * wordSize;
3692   int vte_size    = vtableEntry::size_in_bytes();
3693   Address::ScaleFactor times_vte_scale = Address::times_ptr;
3694   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
3695 
3696   movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
3697 
3698   // %%% Could store the aligned, prescaled offset in the klassoop.
3699   lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
3700 
3701   if (return_method) {
3702     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
3703     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
3704     lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
3705   }
3706 
3707   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
3708   //   if (scan-&gt;interface() == intf) {
3709   //     result = (klass + scan-&gt;offset() + itable_index);
3710   //   }
3711   // }
3712   Label search, found_method;
3713 
3714   for (int peel = 1; peel &gt;= 0; peel--) {
3715     movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
3716     cmpptr(intf_klass, method_result);
3717 
3718     if (peel) {
3719       jccb(Assembler::equal, found_method);
3720     } else {
3721       jccb(Assembler::notEqual, search);
3722       // (invert the test to fall through to found_method...)
3723     }
3724 
3725     if (!peel)  break;
3726 
3727     bind(search);
3728 
3729     // Check that the previous entry is non-null.  A null entry means that
3730     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
3731     // same as when the caller was compiled.
3732     testptr(method_result, method_result);
3733     jcc(Assembler::zero, L_no_such_interface);
3734     addptr(scan_temp, scan_step);
3735   }
3736 
3737   bind(found_method);
3738 
3739   if (return_method) {
3740     // Got a hit.
3741     movl(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
3742     movptr(method_result, Address(recv_klass, scan_temp, Address::times_1));
3743   }
3744 }
3745 
3746 
3747 // virtual method calling
3748 void MacroAssembler::lookup_virtual_method(Register recv_klass,
3749                                            RegisterOrConstant vtable_index,
3750                                            Register method_result) {
3751   const int base = in_bytes(Klass::vtable_start_offset());
3752   assert(vtableEntry::size() * wordSize == wordSize, &quot;else adjust the scaling in the code below&quot;);
3753   Address vtable_entry_addr(recv_klass,
3754                             vtable_index, Address::times_ptr,
3755                             base + vtableEntry::method_offset_in_bytes());
3756   movptr(method_result, vtable_entry_addr);
3757 }
3758 
3759 
3760 void MacroAssembler::check_klass_subtype(Register sub_klass,
3761                            Register super_klass,
3762                            Register temp_reg,
3763                            Label&amp; L_success) {
3764   Label L_failure;
3765   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
3766   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
3767   bind(L_failure);
3768 }
3769 
3770 
3771 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
3772                                                    Register super_klass,
3773                                                    Register temp_reg,
3774                                                    Label* L_success,
3775                                                    Label* L_failure,
3776                                                    Label* L_slow_path,
3777                                         RegisterOrConstant super_check_offset) {
3778   assert_different_registers(sub_klass, super_klass, temp_reg);
3779   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
3780   if (super_check_offset.is_register()) {
3781     assert_different_registers(sub_klass, super_klass,
3782                                super_check_offset.as_register());
3783   } else if (must_load_sco) {
3784     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
3785   }
3786 
3787   Label L_fallthrough;
3788   int label_nulls = 0;
3789   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3790   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3791   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
3792   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3793 
3794   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3795   int sco_offset = in_bytes(Klass::super_check_offset_offset());
3796   Address super_check_offset_addr(super_klass, sco_offset);
3797 
3798   // Hacked jcc, which &quot;knows&quot; that L_fallthrough, at least, is in
3799   // range of a jccb.  If this routine grows larger, reconsider at
3800   // least some of these.
3801 #define local_jcc(assembler_cond, label)                                \
3802   if (&amp;(label) == &amp;L_fallthrough)  jccb(assembler_cond, label);         \
3803   else                             jcc( assembler_cond, label) /*omit semi*/
3804 
3805   // Hacked jmp, which may only be used just before L_fallthrough.
3806 #define final_jmp(label)                                                \
3807   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3808   else                            jmp(label)                /*omit semi*/
3809 
3810   // If the pointers are equal, we are done (e.g., String[] elements).
3811   // This self-check enables sharing of secondary supertype arrays among
3812   // non-primary types such as array-of-interface.  Otherwise, each such
3813   // type would need its own customized SSA.
3814   // We move this check to the front of the fast path because many
3815   // type checks are in fact trivially successful in this manner,
3816   // so we get a nicely predicted branch right at the start of the check.
3817   cmpptr(sub_klass, super_klass);
3818   local_jcc(Assembler::equal, *L_success);
3819 
3820   // Check the supertype display:
3821   if (must_load_sco) {
3822     // Positive movl does right thing on LP64.
3823     movl(temp_reg, super_check_offset_addr);
3824     super_check_offset = RegisterOrConstant(temp_reg);
3825   }
3826   Address super_check_addr(sub_klass, super_check_offset, Address::times_1, 0);
3827   cmpptr(super_klass, super_check_addr); // load displayed supertype
3828 
3829   // This check has worked decisively for primary supers.
3830   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
3831   // (Secondary supers are interfaces and very deeply nested subtypes.)
3832   // This works in the same check above because of a tricky aliasing
3833   // between the super_cache and the primary super display elements.
3834   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
3835   // Note that the cache is updated below if it does not help us find
3836   // what we need immediately.
3837   // So if it was a primary super, we can just fail immediately.
3838   // Otherwise, it&#39;s the slow path for us (no success at this point).
3839 
3840   if (super_check_offset.is_register()) {
3841     local_jcc(Assembler::equal, *L_success);
3842     cmpl(super_check_offset.as_register(), sc_offset);
3843     if (L_failure == &amp;L_fallthrough) {
3844       local_jcc(Assembler::equal, *L_slow_path);
3845     } else {
3846       local_jcc(Assembler::notEqual, *L_failure);
3847       final_jmp(*L_slow_path);
3848     }
3849   } else if (super_check_offset.as_constant() == sc_offset) {
3850     // Need a slow path; fast failure is impossible.
3851     if (L_slow_path == &amp;L_fallthrough) {
3852       local_jcc(Assembler::equal, *L_success);
3853     } else {
3854       local_jcc(Assembler::notEqual, *L_slow_path);
3855       final_jmp(*L_success);
3856     }
3857   } else {
3858     // No slow path; it&#39;s a fast decision.
3859     if (L_failure == &amp;L_fallthrough) {
3860       local_jcc(Assembler::equal, *L_success);
3861     } else {
3862       local_jcc(Assembler::notEqual, *L_failure);
3863       final_jmp(*L_success);
3864     }
3865   }
3866 
3867   bind(L_fallthrough);
3868 
3869 #undef local_jcc
3870 #undef final_jmp
3871 }
3872 
3873 
3874 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
3875                                                    Register super_klass,
3876                                                    Register temp_reg,
3877                                                    Register temp2_reg,
3878                                                    Label* L_success,
3879                                                    Label* L_failure,
3880                                                    bool set_cond_codes) {
3881   assert_different_registers(sub_klass, super_klass, temp_reg);
3882   if (temp2_reg != noreg)
3883     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg);
3884 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
3885 
3886   Label L_fallthrough;
3887   int label_nulls = 0;
3888   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3889   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3890   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3891 
3892   // a couple of useful fields in sub_klass:
3893   int ss_offset = in_bytes(Klass::secondary_supers_offset());
3894   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3895   Address secondary_supers_addr(sub_klass, ss_offset);
3896   Address super_cache_addr(     sub_klass, sc_offset);
3897 
3898   // Do a linear scan of the secondary super-klass chain.
3899   // This code is rarely used, so simplicity is a virtue here.
3900   // The repne_scan instruction uses fixed registers, which we must spill.
3901   // Don&#39;t worry too much about pre-existing connections with the input regs.
3902 
3903   assert(sub_klass != rax, &quot;killed reg&quot;); // killed by mov(rax, super)
3904   assert(sub_klass != rcx, &quot;killed reg&quot;); // killed by lea(rcx, &amp;pst_counter)
3905 
3906   // Get super_klass value into rax (even if it was in rdi or rcx).
3907   bool pushed_rax = false, pushed_rcx = false, pushed_rdi = false;
3908   if (super_klass != rax || UseCompressedOops) {
3909     if (!IS_A_TEMP(rax)) { push(rax); pushed_rax = true; }
3910     mov(rax, super_klass);
3911   }
3912   if (!IS_A_TEMP(rcx)) { push(rcx); pushed_rcx = true; }
3913   if (!IS_A_TEMP(rdi)) { push(rdi); pushed_rdi = true; }
3914 
3915 #ifndef PRODUCT
3916   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
3917   ExternalAddress pst_counter_addr((address) pst_counter);
3918   NOT_LP64(  incrementl(pst_counter_addr) );
3919   LP64_ONLY( lea(rcx, pst_counter_addr) );
3920   LP64_ONLY( incrementl(Address(rcx, 0)) );
3921 #endif //PRODUCT
3922 
3923   // We will consult the secondary-super array.
3924   movptr(rdi, secondary_supers_addr);
3925   // Load the array length.  (Positive movl does right thing on LP64.)
3926   movl(rcx, Address(rdi, Array&lt;Klass*&gt;::length_offset_in_bytes()));
3927   // Skip to start of data.
3928   addptr(rdi, Array&lt;Klass*&gt;::base_offset_in_bytes());
3929 
3930   // Scan RCX words at [RDI] for an occurrence of RAX.
3931   // Set NZ/Z based on last compare.
3932   // Z flag value will not be set by &#39;repne&#39; if RCX == 0 since &#39;repne&#39; does
3933   // not change flags (only scas instruction which is repeated sets flags).
3934   // Set Z = 0 (not equal) before &#39;repne&#39; to indicate that class was not found.
3935 
3936     testptr(rax,rax); // Set Z = 0
3937     repne_scan();
3938 
3939   // Unspill the temp. registers:
3940   if (pushed_rdi)  pop(rdi);
3941   if (pushed_rcx)  pop(rcx);
3942   if (pushed_rax)  pop(rax);
3943 
3944   if (set_cond_codes) {
3945     // Special hack for the AD files:  rdi is guaranteed non-zero.
3946     assert(!pushed_rdi, &quot;rdi must be left non-NULL&quot;);
3947     // Also, the condition codes are properly set Z/NZ on succeed/failure.
3948   }
3949 
3950   if (L_failure == &amp;L_fallthrough)
3951         jccb(Assembler::notEqual, *L_failure);
3952   else  jcc(Assembler::notEqual, *L_failure);
3953 
3954   // Success.  Cache the super we found and proceed in triumph.
3955   movptr(super_cache_addr, super_klass);
3956 
3957   if (L_success != &amp;L_fallthrough) {
3958     jmp(*L_success);
3959   }
3960 
3961 #undef IS_A_TEMP
3962 
3963   bind(L_fallthrough);
3964 }
3965 
3966 void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {
3967   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
3968 
3969   Label L_fallthrough;
3970   if (L_fast_path == NULL) {
3971     L_fast_path = &amp;L_fallthrough;
3972   } else if (L_slow_path == NULL) {
3973     L_slow_path = &amp;L_fallthrough;
3974   }
3975 
3976   // Fast path check: class is fully initialized
3977   cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3978   jcc(Assembler::equal, *L_fast_path);
3979 
3980   // Fast path check: current thread is initializer thread
3981   cmpptr(thread, Address(klass, InstanceKlass::init_thread_offset()));
3982   if (L_slow_path == &amp;L_fallthrough) {
3983     jcc(Assembler::equal, *L_fast_path);
3984     bind(*L_slow_path);
3985   } else if (L_fast_path == &amp;L_fallthrough) {
3986     jcc(Assembler::notEqual, *L_slow_path);
3987     bind(*L_fast_path);
3988   } else {
3989     Unimplemented();
3990   }
3991 }
3992 
3993 void MacroAssembler::cmov32(Condition cc, Register dst, Address src) {
3994   if (VM_Version::supports_cmov()) {
3995     cmovl(cc, dst, src);
3996   } else {
3997     Label L;
3998     jccb(negate_condition(cc), L);
3999     movl(dst, src);
4000     bind(L);
4001   }
4002 }
4003 
4004 void MacroAssembler::cmov32(Condition cc, Register dst, Register src) {
4005   if (VM_Version::supports_cmov()) {
4006     cmovl(cc, dst, src);
4007   } else {
4008     Label L;
4009     jccb(negate_condition(cc), L);
4010     movl(dst, src);
4011     bind(L);
4012   }
4013 }
4014 
4015 void MacroAssembler::_verify_oop(Register reg, const char* s, const char* file, int line) {
4016   if (!VerifyOops || VerifyAdapterSharing) {
4017     // Below address of the code string confuses VerifyAdapterSharing
4018     // because it may differ between otherwise equivalent adapters.
4019     return;
4020   }
4021 
4022   // Pass register number to verify_oop_subroutine
4023   const char* b = NULL;
4024   {
4025     ResourceMark rm;
4026     stringStream ss;
4027     ss.print(&quot;verify_oop: %s: %s (%s:%d)&quot;, reg-&gt;name(), s, file, line);
4028     b = code_string(ss.as_string());
4029   }
4030   BLOCK_COMMENT(&quot;verify_oop {&quot;);
4031 #ifdef _LP64
4032   push(rscratch1);                    // save r10, trashed by movptr()
4033 #endif
4034   push(rax);                          // save rax,
4035   push(reg);                          // pass register argument
4036   ExternalAddress buffer((address) b);
4037   // avoid using pushptr, as it modifies scratch registers
4038   // and our contract is not to modify anything
4039   movptr(rax, buffer.addr());
4040   push(rax);
4041   // call indirectly to solve generation ordering problem
4042   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
4043   call(rax);
4044   // Caller pops the arguments (oop, message) and restores rax, r10
4045   BLOCK_COMMENT(&quot;} verify_oop&quot;);
4046 }
4047 
4048 void MacroAssembler::vallones(XMMRegister dst, int vector_len) {
4049   if (UseAVX &gt; 2 &amp;&amp; (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl())) {
4050     vpternlogd(dst, 0xFF, dst, dst, vector_len);
4051   } else {
4052     assert(UseAVX &gt; 0, &quot;&quot;);
4053     vpcmpeqb(dst, dst, dst, vector_len);
4054   }
4055 }
4056 
4057 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
4058                                                       Register tmp,
4059                                                       int offset) {
4060   intptr_t value = *delayed_value_addr;
4061   if (value != 0)
4062     return RegisterOrConstant(value + offset);
4063 
4064   // load indirectly to solve generation ordering problem
4065   movptr(tmp, ExternalAddress((address) delayed_value_addr));
4066 
4067 #ifdef ASSERT
4068   { Label L;
4069     testptr(tmp, tmp);
4070     if (WizardMode) {
4071       const char* buf = NULL;
4072       {
4073         ResourceMark rm;
4074         stringStream ss;
4075         ss.print(&quot;DelayedValue=&quot; INTPTR_FORMAT, delayed_value_addr[1]);
4076         buf = code_string(ss.as_string());
4077       }
4078       jcc(Assembler::notZero, L);
4079       STOP(buf);
4080     } else {
4081       jccb(Assembler::notZero, L);
4082       hlt();
4083     }
4084     bind(L);
4085   }
4086 #endif
4087 
4088   if (offset != 0)
4089     addptr(tmp, offset);
4090 
4091   return RegisterOrConstant(tmp);
4092 }
4093 
4094 
4095 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
4096                                          int extra_slot_offset) {
4097   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
4098   int stackElementSize = Interpreter::stackElementSize;
4099   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
4100 #ifdef ASSERT
4101   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
4102   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
4103 #endif
4104   Register             scale_reg    = noreg;
4105   Address::ScaleFactor scale_factor = Address::no_scale;
4106   if (arg_slot.is_constant()) {
4107     offset += arg_slot.as_constant() * stackElementSize;
4108   } else {
4109     scale_reg    = arg_slot.as_register();
4110     scale_factor = Address::times(stackElementSize);
4111   }
4112   offset += wordSize;           // return PC is on stack
4113   return Address(rsp, scale_reg, scale_factor, offset);
4114 }
4115 
4116 
4117 void MacroAssembler::_verify_oop_addr(Address addr, const char* s, const char* file, int line) {
4118   if (!VerifyOops || VerifyAdapterSharing) {
4119     // Below address of the code string confuses VerifyAdapterSharing
4120     // because it may differ between otherwise equivalent adapters.
4121     return;
4122   }
4123 
4124   // Address adjust(addr.base(), addr.index(), addr.scale(), addr.disp() + BytesPerWord);
4125   // Pass register number to verify_oop_subroutine
4126   const char* b = NULL;
4127   {
4128     ResourceMark rm;
4129     stringStream ss;
4130     ss.print(&quot;verify_oop_addr: %s (%s:%d)&quot;, s, file, line);
4131     b = code_string(ss.as_string());
4132   }
4133 #ifdef _LP64
4134   push(rscratch1);                    // save r10, trashed by movptr()
4135 #endif
4136   push(rax);                          // save rax,
4137   // addr may contain rsp so we will have to adjust it based on the push
4138   // we just did (and on 64 bit we do two pushes)
4139   // NOTE: 64bit seemed to have had a bug in that it did movq(addr, rax); which
4140   // stores rax into addr which is backwards of what was intended.
4141   if (addr.uses(rsp)) {
4142     lea(rax, addr);
4143     pushptr(Address(rax, LP64_ONLY(2 *) BytesPerWord));
4144   } else {
4145     pushptr(addr);
4146   }
4147 
4148   ExternalAddress buffer((address) b);
4149   // pass msg argument
4150   // avoid using pushptr, as it modifies scratch registers
4151   // and our contract is not to modify anything
4152   movptr(rax, buffer.addr());
4153   push(rax);
4154 
4155   // call indirectly to solve generation ordering problem
4156   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
4157   call(rax);
4158   // Caller pops the arguments (addr, message) and restores rax, r10.
4159 }
4160 
4161 void MacroAssembler::verify_tlab() {
4162 #ifdef ASSERT
4163   if (UseTLAB &amp;&amp; VerifyOops) {
4164     Label next, ok;
4165     Register t1 = rsi;
4166     Register thread_reg = NOT_LP64(rbx) LP64_ONLY(r15_thread);
4167 
4168     push(t1);
4169     NOT_LP64(push(thread_reg));
4170     NOT_LP64(get_thread(thread_reg));
4171 
4172     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
4173     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_start_offset())));
4174     jcc(Assembler::aboveEqual, next);
4175     STOP(&quot;assert(top &gt;= start)&quot;);
4176     should_not_reach_here();
4177 
4178     bind(next);
4179     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_end_offset())));
4180     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
4181     jcc(Assembler::aboveEqual, ok);
4182     STOP(&quot;assert(top &lt;= end)&quot;);
4183     should_not_reach_here();
4184 
4185     bind(ok);
4186     NOT_LP64(pop(thread_reg));
4187     pop(t1);
4188   }
4189 #endif
4190 }
4191 
4192 class ControlWord {
4193  public:
4194   int32_t _value;
4195 
4196   int  rounding_control() const        { return  (_value &gt;&gt; 10) &amp; 3      ; }
4197   int  precision_control() const       { return  (_value &gt;&gt;  8) &amp; 3      ; }
4198   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
4199   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4200   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
4201   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4202   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
4203   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4204 
4205   void print() const {
4206     // rounding control
4207     const char* rc;
4208     switch (rounding_control()) {
4209       case 0: rc = &quot;round near&quot;; break;
4210       case 1: rc = &quot;round down&quot;; break;
4211       case 2: rc = &quot;round up  &quot;; break;
4212       case 3: rc = &quot;chop      &quot;; break;
4213     };
4214     // precision control
4215     const char* pc;
4216     switch (precision_control()) {
4217       case 0: pc = &quot;24 bits &quot;; break;
4218       case 1: pc = &quot;reserved&quot;; break;
4219       case 2: pc = &quot;53 bits &quot;; break;
4220       case 3: pc = &quot;64 bits &quot;; break;
4221     };
4222     // flags
4223     char f[9];
4224     f[0] = &#39; &#39;;
4225     f[1] = &#39; &#39;;
4226     f[2] = (precision   ()) ? &#39;P&#39; : &#39;p&#39;;
4227     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;u&#39;;
4228     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;o&#39;;
4229     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;z&#39;;
4230     f[6] = (denormalized()) ? &#39;D&#39; : &#39;d&#39;;
4231     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;i&#39;;
4232     f[8] = &#39;\x0&#39;;
4233     // output
4234     printf(&quot;%04x  masks = %s, %s, %s&quot;, _value &amp; 0xFFFF, f, rc, pc);
4235   }
4236 
4237 };
4238 
4239 class StatusWord {
4240  public:
4241   int32_t _value;
4242 
4243   bool busy() const                    { return ((_value &gt;&gt; 15) &amp; 1) != 0; }
4244   bool C3() const                      { return ((_value &gt;&gt; 14) &amp; 1) != 0; }
4245   bool C2() const                      { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
4246   bool C1() const                      { return ((_value &gt;&gt;  9) &amp; 1) != 0; }
4247   bool C0() const                      { return ((_value &gt;&gt;  8) &amp; 1) != 0; }
4248   int  top() const                     { return  (_value &gt;&gt; 11) &amp; 7      ; }
4249   bool error_status() const            { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
4250   bool stack_fault() const             { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
4251   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
4252   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4253   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
4254   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4255   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
4256   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4257 
4258   void print() const {
4259     // condition codes
4260     char c[5];
4261     c[0] = (C3()) ? &#39;3&#39; : &#39;-&#39;;
4262     c[1] = (C2()) ? &#39;2&#39; : &#39;-&#39;;
4263     c[2] = (C1()) ? &#39;1&#39; : &#39;-&#39;;
4264     c[3] = (C0()) ? &#39;0&#39; : &#39;-&#39;;
4265     c[4] = &#39;\x0&#39;;
4266     // flags
4267     char f[9];
4268     f[0] = (error_status()) ? &#39;E&#39; : &#39;-&#39;;
4269     f[1] = (stack_fault ()) ? &#39;S&#39; : &#39;-&#39;;
4270     f[2] = (precision   ()) ? &#39;P&#39; : &#39;-&#39;;
4271     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;-&#39;;
4272     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;-&#39;;
4273     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;-&#39;;
4274     f[6] = (denormalized()) ? &#39;D&#39; : &#39;-&#39;;
4275     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;-&#39;;
4276     f[8] = &#39;\x0&#39;;
4277     // output
4278     printf(&quot;%04x  flags = %s, cc =  %s, top = %d&quot;, _value &amp; 0xFFFF, f, c, top());
4279   }
4280 
4281 };
4282 
4283 class TagWord {
4284  public:
4285   int32_t _value;
4286 
4287   int tag_at(int i) const              { return (_value &gt;&gt; (i*2)) &amp; 3; }
4288 
4289   void print() const {
4290     printf(&quot;%04x&quot;, _value &amp; 0xFFFF);
4291   }
4292 
4293 };
4294 
4295 class FPU_Register {
4296  public:
4297   int32_t _m0;
4298   int32_t _m1;
4299   int16_t _ex;
4300 
4301   bool is_indefinite() const           {
4302     return _ex == -1 &amp;&amp; _m1 == (int32_t)0xC0000000 &amp;&amp; _m0 == 0;
4303   }
4304 
4305   void print() const {
4306     char  sign = (_ex &lt; 0) ? &#39;-&#39; : &#39;+&#39;;
4307     const char* kind = (_ex == 0x7FFF || _ex == (int16_t)-1) ? &quot;NaN&quot; : &quot;   &quot;;
4308     printf(&quot;%c%04hx.%08x%08x  %s&quot;, sign, _ex, _m1, _m0, kind);
4309   };
4310 
4311 };
4312 
4313 class FPU_State {
4314  public:
4315   enum {
4316     register_size       = 10,
4317     number_of_registers =  8,
4318     register_mask       =  7
4319   };
4320 
4321   ControlWord  _control_word;
4322   StatusWord   _status_word;
4323   TagWord      _tag_word;
4324   int32_t      _error_offset;
4325   int32_t      _error_selector;
4326   int32_t      _data_offset;
4327   int32_t      _data_selector;
4328   int8_t       _register[register_size * number_of_registers];
4329 
4330   int tag_for_st(int i) const          { return _tag_word.tag_at((_status_word.top() + i) &amp; register_mask); }
4331   FPU_Register* st(int i) const        { return (FPU_Register*)&amp;_register[register_size * i]; }
4332 
4333   const char* tag_as_string(int tag) const {
4334     switch (tag) {
4335       case 0: return &quot;valid&quot;;
4336       case 1: return &quot;zero&quot;;
4337       case 2: return &quot;special&quot;;
4338       case 3: return &quot;empty&quot;;
4339     }
4340     ShouldNotReachHere();
4341     return NULL;
4342   }
4343 
4344   void print() const {
4345     // print computation registers
4346     { int t = _status_word.top();
4347       for (int i = 0; i &lt; number_of_registers; i++) {
4348         int j = (i - t) &amp; register_mask;
4349         printf(&quot;%c r%d = ST%d = &quot;, (j == 0 ? &#39;*&#39; : &#39; &#39;), i, j);
4350         st(j)-&gt;print();
4351         printf(&quot; %s\n&quot;, tag_as_string(_tag_word.tag_at(i)));
4352       }
4353     }
4354     printf(&quot;\n&quot;);
4355     // print control registers
4356     printf(&quot;ctrl = &quot;); _control_word.print(); printf(&quot;\n&quot;);
4357     printf(&quot;stat = &quot;); _status_word .print(); printf(&quot;\n&quot;);
4358     printf(&quot;tags = &quot;); _tag_word    .print(); printf(&quot;\n&quot;);
4359   }
4360 
4361 };
4362 
4363 class Flag_Register {
4364  public:
4365   int32_t _value;
4366 
4367   bool overflow() const                { return ((_value &gt;&gt; 11) &amp; 1) != 0; }
4368   bool direction() const               { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
4369   bool sign() const                    { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
4370   bool zero() const                    { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
4371   bool auxiliary_carry() const         { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4372   bool parity() const                  { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4373   bool carry() const                   { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4374 
4375   void print() const {
4376     // flags
4377     char f[8];
4378     f[0] = (overflow       ()) ? &#39;O&#39; : &#39;-&#39;;
4379     f[1] = (direction      ()) ? &#39;D&#39; : &#39;-&#39;;
4380     f[2] = (sign           ()) ? &#39;S&#39; : &#39;-&#39;;
4381     f[3] = (zero           ()) ? &#39;Z&#39; : &#39;-&#39;;
4382     f[4] = (auxiliary_carry()) ? &#39;A&#39; : &#39;-&#39;;
4383     f[5] = (parity         ()) ? &#39;P&#39; : &#39;-&#39;;
4384     f[6] = (carry          ()) ? &#39;C&#39; : &#39;-&#39;;
4385     f[7] = &#39;\x0&#39;;
4386     // output
4387     printf(&quot;%08x  flags = %s&quot;, _value, f);
4388   }
4389 
4390 };
4391 
4392 class IU_Register {
4393  public:
4394   int32_t _value;
4395 
4396   void print() const {
4397     printf(&quot;%08x  %11d&quot;, _value, _value);
4398   }
4399 
4400 };
4401 
4402 class IU_State {
4403  public:
4404   Flag_Register _eflags;
4405   IU_Register   _rdi;
4406   IU_Register   _rsi;
4407   IU_Register   _rbp;
4408   IU_Register   _rsp;
4409   IU_Register   _rbx;
4410   IU_Register   _rdx;
4411   IU_Register   _rcx;
4412   IU_Register   _rax;
4413 
4414   void print() const {
4415     // computation registers
4416     printf(&quot;rax,  = &quot;); _rax.print(); printf(&quot;\n&quot;);
4417     printf(&quot;rbx,  = &quot;); _rbx.print(); printf(&quot;\n&quot;);
4418     printf(&quot;rcx  = &quot;); _rcx.print(); printf(&quot;\n&quot;);
4419     printf(&quot;rdx  = &quot;); _rdx.print(); printf(&quot;\n&quot;);
4420     printf(&quot;rdi  = &quot;); _rdi.print(); printf(&quot;\n&quot;);
4421     printf(&quot;rsi  = &quot;); _rsi.print(); printf(&quot;\n&quot;);
4422     printf(&quot;rbp,  = &quot;); _rbp.print(); printf(&quot;\n&quot;);
4423     printf(&quot;rsp  = &quot;); _rsp.print(); printf(&quot;\n&quot;);
4424     printf(&quot;\n&quot;);
4425     // control registers
4426     printf(&quot;flgs = &quot;); _eflags.print(); printf(&quot;\n&quot;);
4427   }
4428 };
4429 
4430 
4431 class CPU_State {
4432  public:
4433   FPU_State _fpu_state;
4434   IU_State  _iu_state;
4435 
4436   void print() const {
4437     printf(&quot;--------------------------------------------------\n&quot;);
4438     _iu_state .print();
4439     printf(&quot;\n&quot;);
4440     _fpu_state.print();
4441     printf(&quot;--------------------------------------------------\n&quot;);
4442   }
4443 
4444 };
4445 
4446 
4447 static void _print_CPU_state(CPU_State* state) {
4448   state-&gt;print();
4449 };
4450 
4451 
4452 void MacroAssembler::print_CPU_state() {
4453   push_CPU_state();
4454   push(rsp);                // pass CPU state
4455   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _print_CPU_state)));
4456   addptr(rsp, wordSize);       // discard argument
4457   pop_CPU_state();
4458 }
4459 
4460 
4461 #ifndef _LP64
4462 static bool _verify_FPU(int stack_depth, char* s, CPU_State* state) {
4463   static int counter = 0;
4464   FPU_State* fs = &amp;state-&gt;_fpu_state;
4465   counter++;
4466   // For leaf calls, only verify that the top few elements remain empty.
4467   // We only need 1 empty at the top for C2 code.
4468   if( stack_depth &lt; 0 ) {
4469     if( fs-&gt;tag_for_st(7) != 3 ) {
4470       printf(&quot;FPR7 not empty\n&quot;);
4471       state-&gt;print();
4472       assert(false, &quot;error&quot;);
4473       return false;
4474     }
4475     return true;                // All other stack states do not matter
4476   }
4477 
4478   assert((fs-&gt;_control_word._value &amp; 0xffff) == StubRoutines::_fpu_cntrl_wrd_std,
4479          &quot;bad FPU control word&quot;);
4480 
4481   // compute stack depth
4482   int i = 0;
4483   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i)  &lt; 3) i++;
4484   int d = i;
4485   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i) == 3) i++;
4486   // verify findings
4487   if (i != FPU_State::number_of_registers) {
4488     // stack not contiguous
4489     printf(&quot;%s: stack not contiguous at ST%d\n&quot;, s, i);
4490     state-&gt;print();
4491     assert(false, &quot;error&quot;);
4492     return false;
4493   }
4494   // check if computed stack depth corresponds to expected stack depth
4495   if (stack_depth &lt; 0) {
4496     // expected stack depth is -stack_depth or less
4497     if (d &gt; -stack_depth) {
4498       // too many elements on the stack
4499       printf(&quot;%s: &lt;= %d stack elements expected but found %d\n&quot;, s, -stack_depth, d);
4500       state-&gt;print();
4501       assert(false, &quot;error&quot;);
4502       return false;
4503     }
4504   } else {
4505     // expected stack depth is stack_depth
4506     if (d != stack_depth) {
4507       // wrong stack depth
4508       printf(&quot;%s: %d stack elements expected but found %d\n&quot;, s, stack_depth, d);
4509       state-&gt;print();
4510       assert(false, &quot;error&quot;);
4511       return false;
4512     }
4513   }
4514   // everything is cool
4515   return true;
4516 }
4517 
4518 void MacroAssembler::verify_FPU(int stack_depth, const char* s) {
4519   if (!VerifyFPU) return;
4520   push_CPU_state();
4521   push(rsp);                // pass CPU state
4522   ExternalAddress msg((address) s);
4523   // pass message string s
4524   pushptr(msg.addr());
4525   push(stack_depth);        // pass stack depth
4526   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _verify_FPU)));
4527   addptr(rsp, 3 * wordSize);   // discard arguments
4528   // check for error
4529   { Label L;
4530     testl(rax, rax);
4531     jcc(Assembler::notZero, L);
4532     int3();                  // break if error condition
4533     bind(L);
4534   }
4535   pop_CPU_state();
4536 }
4537 #endif // _LP64
4538 
4539 void MacroAssembler::restore_cpu_control_state_after_jni() {
4540   // Either restore the MXCSR register after returning from the JNI Call
4541   // or verify that it wasn&#39;t changed (with -Xcheck:jni flag).
4542   if (VM_Version::supports_sse()) {
4543     if (RestoreMXCSROnJNICalls) {
4544       ldmxcsr(ExternalAddress(StubRoutines::addr_mxcsr_std()));
4545     } else if (CheckJNICalls) {
4546       call(RuntimeAddress(StubRoutines::x86::verify_mxcsr_entry()));
4547     }
4548   }
4549   // Clear upper bits of YMM registers to avoid SSE &lt;-&gt; AVX transition penalty.
4550   vzeroupper();
4551   // Reset k1 to 0xffff.
4552 
4553 #ifdef COMPILER2
4554   if (PostLoopMultiversioning &amp;&amp; VM_Version::supports_evex()) {
4555     push(rcx);
4556     movl(rcx, 0xffff);
4557     kmovwl(k1, rcx);
4558     pop(rcx);
4559   }
4560 #endif // COMPILER2
4561 
4562 #ifndef _LP64
4563   // Either restore the x87 floating pointer control word after returning
4564   // from the JNI call or verify that it wasn&#39;t changed.
4565   if (CheckJNICalls) {
4566     call(RuntimeAddress(StubRoutines::x86::verify_fpu_cntrl_wrd_entry()));
4567   }
4568 #endif // _LP64
4569 }
4570 
4571 // ((OopHandle)result).resolve();
4572 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
4573   assert_different_registers(result, tmp);
4574 
4575   // Only 64 bit platforms support GCs that require a tmp register
4576   // Only IN_HEAP loads require a thread_tmp register
4577   // OopHandle::resolve is an indirection like jobject.
4578   access_load_at(T_OBJECT, IN_NATIVE,
4579                  result, Address(result, 0), tmp, /*tmp_thread*/noreg);
4580 }
4581 
4582 // ((WeakHandle)result).resolve();
4583 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
4584   assert_different_registers(rresult, rtmp);
4585   Label resolved;
4586 
4587   // A null weak handle resolves to null.
4588   cmpptr(rresult, 0);
4589   jcc(Assembler::equal, resolved);
4590 
4591   // Only 64 bit platforms support GCs that require a tmp register
4592   // Only IN_HEAP loads require a thread_tmp register
4593   // WeakHandle::resolve is an indirection like jweak.
4594   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
4595                  rresult, Address(rresult, 0), rtmp, /*tmp_thread*/noreg);
4596   bind(resolved);
4597 }
4598 
4599 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
4600   // get mirror
4601   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
4602   load_method_holder(mirror, method);
4603   movptr(mirror, Address(mirror, mirror_offset));
4604   resolve_oop_handle(mirror, tmp);
4605 }
4606 
4607 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
4608   load_method_holder(rresult, rmethod);
4609   movptr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
4610 }
4611 
4612 void MacroAssembler::load_method_holder(Register holder, Register method) {
4613   movptr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
4614   movptr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
4615   movptr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
4616 }
4617 
4618 void MacroAssembler::load_metadata(Register dst, Register src) {
4619   if (UseCompressedClassPointers) {
4620     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4621   } else {
4622     movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4623   }
4624 }
4625 
4626 void MacroAssembler::load_klass(Register dst, Register src, Register tmp) {
4627   assert_different_registers(src, tmp);
4628   assert_different_registers(dst, tmp);
4629 #ifdef _LP64
4630   if (UseCompressedClassPointers) {
4631     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4632     decode_klass_not_null(dst, tmp);
4633   } else
4634 #endif
4635   movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4636 }
4637 
4638 void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {
4639   load_klass(dst, src, tmp);
4640   movptr(dst, Address(dst, Klass::prototype_header_offset()));
4641 }
4642 
4643 void MacroAssembler::store_klass(Register dst, Register src, Register tmp) {
4644   assert_different_registers(src, tmp);
4645   assert_different_registers(dst, tmp);
4646 #ifdef _LP64
4647   if (UseCompressedClassPointers) {
4648     encode_klass_not_null(src, tmp);
4649     movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4650   } else
4651 #endif
4652     movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4653 }
4654 
4655 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
4656                                     Register tmp1, Register thread_tmp) {
4657   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4658   decorators = AccessInternal::decorator_fixup(decorators);
4659   bool as_raw = (decorators &amp; AS_RAW) != 0;
4660   if (as_raw) {
4661     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4662   } else {
4663     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4664   }
4665 }
4666 
4667 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
4668                                      Register tmp1, Register tmp2, Register tmp3) {
4669   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4670   decorators = AccessInternal::decorator_fixup(decorators);
4671   bool as_raw = (decorators &amp; AS_RAW) != 0;
4672   if (as_raw) {
4673     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);
4674   } else {
4675     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);
4676   }
4677 }
4678 
4679 void MacroAssembler::access_value_copy(DecoratorSet decorators, Register src, Register dst,
4680                                        Register inline_klass) {
4681   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4682   bs-&gt;value_copy(this, decorators, src, dst, inline_klass);
4683 }
4684 
4685 void MacroAssembler::first_field_offset(Register inline_klass, Register offset) {
4686   movptr(offset, Address(inline_klass, InstanceKlass::adr_inlineklass_fixed_block_offset()));
4687   movl(offset, Address(offset, InlineKlass::first_field_offset_offset()));
4688 }
4689 
4690 void MacroAssembler::data_for_oop(Register oop, Register data, Register inline_klass) {
4691   // ((address) (void*) o) + vk-&gt;first_field_offset();
4692   Register offset = (data == oop) ? rscratch1 : data;
4693   first_field_offset(inline_klass, offset);
4694   if (data == oop) {
4695     addptr(data, offset);
4696   } else {
4697     lea(data, Address(oop, offset));
4698   }
4699 }
4700 
4701 void MacroAssembler::data_for_value_array_index(Register array, Register array_klass,
4702                                                 Register index, Register data) {
4703   assert(index != rcx, &quot;index needs to shift by rcx&quot;);
4704   assert_different_registers(array, array_klass, index);
4705   assert_different_registers(rcx, array, index);
4706 
4707   // array-&gt;base() + (index &lt;&lt; Klass::layout_helper_log2_element_size(lh));
4708   movl(rcx, Address(array_klass, Klass::layout_helper_offset()));
4709 
4710   // Klass::layout_helper_log2_element_size(lh)
4711   // (lh &gt;&gt; _lh_log2_element_size_shift) &amp; _lh_log2_element_size_mask;
4712   shrl(rcx, Klass::_lh_log2_element_size_shift);
4713   andl(rcx, Klass::_lh_log2_element_size_mask);
4714   shlptr(index); // index &lt;&lt; rcx
4715 
4716   lea(data, Address(array, index, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_INLINE_TYPE)));
4717 }
4718 
4719 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
4720   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
4721   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
4722     decorators |= ACCESS_READ | ACCESS_WRITE;
4723   }
4724   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4725   return bs-&gt;resolve(this, decorators, obj);
4726 }
4727 
4728 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
4729                                    Register thread_tmp, DecoratorSet decorators) {
4730   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4731 }
4732 
4733 // Doesn&#39;t do verfication, generates fixed size code
4734 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
4735                                             Register thread_tmp, DecoratorSet decorators) {
4736   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
4737 }
4738 
4739 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4740                                     Register tmp2, Register tmp3, DecoratorSet decorators) {
4741   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);
4742 }
4743 
4744 // Used for storing NULLs.
4745 void MacroAssembler::store_heap_oop_null(Address dst) {
4746   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg, noreg);
4747 }
4748 
4749 #ifdef _LP64
4750 void MacroAssembler::store_klass_gap(Register dst, Register src) {
4751   if (UseCompressedClassPointers) {
4752     // Store to klass gap in destination
4753     movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);
4754   }
4755 }
4756 
4757 #ifdef ASSERT
4758 void MacroAssembler::verify_heapbase(const char* msg) {
4759   assert (UseCompressedOops, &quot;should be compressed&quot;);
4760   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4761   if (CheckCompressedOops) {
4762     Label ok;
4763     push(rscratch1); // cmpptr trashes rscratch1
4764     cmpptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
4765     jcc(Assembler::equal, ok);
4766     STOP(msg);
4767     bind(ok);
4768     pop(rscratch1);
4769   }
4770 }
4771 #endif
4772 
4773 // Algorithm must match oop.inline.hpp encode_heap_oop.
4774 void MacroAssembler::encode_heap_oop(Register r) {
4775 #ifdef ASSERT
4776   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
4777 #endif
4778   verify_oop_msg(r, &quot;broken oop in encode_heap_oop&quot;);
4779   if (CompressedOops::base() == NULL) {
4780     if (CompressedOops::shift() != 0) {
4781       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4782       shrq(r, LogMinObjAlignmentInBytes);
4783     }
4784     return;
4785   }
4786   testq(r, r);
4787   cmovq(Assembler::equal, r, r12_heapbase);
4788   subq(r, r12_heapbase);
4789   shrq(r, LogMinObjAlignmentInBytes);
4790 }
4791 
4792 void MacroAssembler::encode_heap_oop_not_null(Register r) {
4793 #ifdef ASSERT
4794   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
4795   if (CheckCompressedOops) {
4796     Label ok;
4797     testq(r, r);
4798     jcc(Assembler::notEqual, ok);
4799     STOP(&quot;null oop passed to encode_heap_oop_not_null&quot;);
4800     bind(ok);
4801   }
4802 #endif
4803   verify_oop_msg(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
4804   if (CompressedOops::base() != NULL) {
4805     subq(r, r12_heapbase);
4806   }
4807   if (CompressedOops::shift() != 0) {
4808     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4809     shrq(r, LogMinObjAlignmentInBytes);
4810   }
4811 }
4812 
4813 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
4814 #ifdef ASSERT
4815   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
4816   if (CheckCompressedOops) {
4817     Label ok;
4818     testq(src, src);
4819     jcc(Assembler::notEqual, ok);
4820     STOP(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
4821     bind(ok);
4822   }
4823 #endif
4824   verify_oop_msg(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
4825   if (dst != src) {
4826     movq(dst, src);
4827   }
4828   if (CompressedOops::base() != NULL) {
4829     subq(dst, r12_heapbase);
4830   }
4831   if (CompressedOops::shift() != 0) {
4832     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4833     shrq(dst, LogMinObjAlignmentInBytes);
4834   }
4835 }
4836 
4837 void  MacroAssembler::decode_heap_oop(Register r) {
4838 #ifdef ASSERT
4839   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
4840 #endif
4841   if (CompressedOops::base() == NULL) {
4842     if (CompressedOops::shift() != 0) {
4843       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4844       shlq(r, LogMinObjAlignmentInBytes);
4845     }
4846   } else {
4847     Label done;
4848     shlq(r, LogMinObjAlignmentInBytes);
4849     jccb(Assembler::equal, done);
4850     addq(r, r12_heapbase);
4851     bind(done);
4852   }
4853   verify_oop_msg(r, &quot;broken oop in decode_heap_oop&quot;);
4854 }
4855 
4856 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
4857   // Note: it will change flags
4858   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4859   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4860   // Cannot assert, unverified entry point counts instructions (see .ad file)
4861   // vtableStubs also counts instructions in pd_code_size_limit.
4862   // Also do not verify_oop as this is called by verify_oop.
4863   if (CompressedOops::shift() != 0) {
4864     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4865     shlq(r, LogMinObjAlignmentInBytes);
4866     if (CompressedOops::base() != NULL) {
4867       addq(r, r12_heapbase);
4868     }
4869   } else {
4870     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4871   }
4872 }
4873 
4874 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
4875   // Note: it will change flags
4876   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4877   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4878   // Cannot assert, unverified entry point counts instructions (see .ad file)
4879   // vtableStubs also counts instructions in pd_code_size_limit.
4880   // Also do not verify_oop as this is called by verify_oop.
4881   if (CompressedOops::shift() != 0) {
4882     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4883     if (LogMinObjAlignmentInBytes == Address::times_8) {
4884       leaq(dst, Address(r12_heapbase, src, Address::times_8, 0));
4885     } else {
4886       if (dst != src) {
4887         movq(dst, src);
4888       }
4889       shlq(dst, LogMinObjAlignmentInBytes);
4890       if (CompressedOops::base() != NULL) {
4891         addq(dst, r12_heapbase);
4892       }
4893     }
4894   } else {
4895     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4896     if (dst != src) {
4897       movq(dst, src);
4898     }
4899   }
4900 }
4901 
4902 void MacroAssembler::encode_klass_not_null(Register r, Register tmp) {
4903   assert_different_registers(r, tmp);
4904   if (CompressedKlassPointers::base() != NULL) {
4905     mov64(tmp, (int64_t)CompressedKlassPointers::base());
4906     subq(r, tmp);
4907   }
4908   if (CompressedKlassPointers::shift() != 0) {
4909     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4910     shrq(r, LogKlassAlignmentInBytes);
4911   }
4912 }
4913 
4914 void MacroAssembler::encode_and_move_klass_not_null(Register dst, Register src) {
4915   assert_different_registers(src, dst);
4916   if (CompressedKlassPointers::base() != NULL) {
4917     mov64(dst, -(int64_t)CompressedKlassPointers::base());
4918     addq(dst, src);
4919   } else {
4920     movptr(dst, src);
4921   }
4922   if (CompressedKlassPointers::shift() != 0) {
4923     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4924     shrq(dst, LogKlassAlignmentInBytes);
4925   }
4926 }
4927 
4928 // !!! If the instructions that get generated here change then function
4929 // instr_size_for_decode_klass_not_null() needs to get updated.
4930 void  MacroAssembler::decode_klass_not_null(Register r, Register tmp) {
4931   assert_different_registers(r, tmp);
4932   // Note: it will change flags
4933   assert(UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4934   // Cannot assert, unverified entry point counts instructions (see .ad file)
4935   // vtableStubs also counts instructions in pd_code_size_limit.
4936   // Also do not verify_oop as this is called by verify_oop.
4937   if (CompressedKlassPointers::shift() != 0) {
4938     assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4939     shlq(r, LogKlassAlignmentInBytes);
4940   }
4941   if (CompressedKlassPointers::base() != NULL) {
4942     mov64(tmp, (int64_t)CompressedKlassPointers::base());
4943     addq(r, tmp);
4944   }
4945 }
4946 
4947 void  MacroAssembler::decode_and_move_klass_not_null(Register dst, Register src) {
4948   assert_different_registers(src, dst);
4949   // Note: it will change flags
4950   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4951   // Cannot assert, unverified entry point counts instructions (see .ad file)
4952   // vtableStubs also counts instructions in pd_code_size_limit.
4953   // Also do not verify_oop as this is called by verify_oop.
4954 
4955   if (CompressedKlassPointers::base() == NULL &amp;&amp;
4956       CompressedKlassPointers::shift() == 0) {
4957     // The best case scenario is that there is no base or shift. Then it is already
4958     // a pointer that needs nothing but a register rename.
4959     movl(dst, src);
4960   } else {
4961     if (CompressedKlassPointers::base() != NULL) {
4962       mov64(dst, (int64_t)CompressedKlassPointers::base());
4963     } else {
4964       xorq(dst, dst);
4965     }
4966     if (CompressedKlassPointers::shift() != 0) {
4967       assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4968       assert(LogKlassAlignmentInBytes == Address::times_8, &quot;klass not aligned on 64bits?&quot;);
4969       leaq(dst, Address(dst, src, Address::times_8, 0));
4970     } else {
4971       addq(dst, src);
4972     }
4973   }
4974 }
4975 
4976 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
4977   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4978   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4979   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4980   int oop_index = oop_recorder()-&gt;find_index(obj);
4981   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4982   mov_narrow_oop(dst, oop_index, rspec);
4983 }
4984 
4985 void  MacroAssembler::set_narrow_oop(Address dst, jobject obj) {
4986   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4987   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4988   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4989   int oop_index = oop_recorder()-&gt;find_index(obj);
4990   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4991   mov_narrow_oop(dst, oop_index, rspec);
4992 }
4993 
4994 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
4995   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4996   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4997   int klass_index = oop_recorder()-&gt;find_index(k);
4998   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4999   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5000 }
5001 
5002 void  MacroAssembler::set_narrow_klass(Address dst, Klass* k) {
5003   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5004   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5005   int klass_index = oop_recorder()-&gt;find_index(k);
5006   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5007   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5008 }
5009 
5010 void  MacroAssembler::cmp_narrow_oop(Register dst, jobject obj) {
5011   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
5012   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
5013   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5014   int oop_index = oop_recorder()-&gt;find_index(obj);
5015   RelocationHolder rspec = oop_Relocation::spec(oop_index);
5016   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
5017 }
5018 
5019 void  MacroAssembler::cmp_narrow_oop(Address dst, jobject obj) {
5020   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
5021   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
5022   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5023   int oop_index = oop_recorder()-&gt;find_index(obj);
5024   RelocationHolder rspec = oop_Relocation::spec(oop_index);
5025   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
5026 }
5027 
5028 void  MacroAssembler::cmp_narrow_klass(Register dst, Klass* k) {
5029   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5030   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5031   int klass_index = oop_recorder()-&gt;find_index(k);
5032   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5033   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5034 }
5035 
5036 void  MacroAssembler::cmp_narrow_klass(Address dst, Klass* k) {
5037   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5038   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5039   int klass_index = oop_recorder()-&gt;find_index(k);
5040   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5041   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5042 }
5043 
5044 void MacroAssembler::reinit_heapbase() {
5045   if (UseCompressedOops) {
5046     if (Universe::heap() != NULL) {
5047       if (CompressedOops::base() == NULL) {
5048         MacroAssembler::xorptr(r12_heapbase, r12_heapbase);
5049       } else {
5050         mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());
5051       }
5052     } else {
5053       movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
5054     }
5055   }
5056 }
5057 
5058 #endif // _LP64
5059 
5060 // C2 compiled method&#39;s prolog code.
5061 void MacroAssembler::verified_entry(Compile* C, int sp_inc) {
5062   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
5063   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
5064   bool fp_mode_24b = false;
5065   int stack_bang_size = C-&gt;output()-&gt;need_stack_bang(bangsize) ? bangsize : 0;
5066 
5067   // WARNING: Initial instruction MUST be 5 bytes or longer so that
5068   // NativeJump::patch_verified_entry will be able to patch out the entry
5069   // code safely. The push to verify stack depth is ok at 5 bytes,
5070   // the frame allocation can be either 3 or 6 bytes. So if we don&#39;t do
5071   // stack bang then we must use the 6 byte frame allocation even if
5072   // we have no frame. :-(
5073   assert(stack_bang_size &gt;= framesize || stack_bang_size &lt;= 0, &quot;stack bang size incorrect&quot;);
5074 
5075   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
5076   // Remove word for return addr
5077   framesize -= wordSize;
5078   stack_bang_size -= wordSize;
5079 
5080   // Calls to C2R adapters often do not accept exceptional returns.
5081   // We require that their callers must bang for them.  But be careful, because
5082   // some VM calls (such as call site linkage) can use several kilobytes of
5083   // stack.  But the stack safety zone should account for that.
5084   // See bugs 4446381, 4468289, 4497237.
5085   if (stack_bang_size &gt; 0) {
5086     generate_stack_overflow_check(stack_bang_size);
5087 
5088     // We always push rbp, so that on return to interpreter rbp, will be
5089     // restored correctly and we can correct the stack.
5090     push(rbp);
5091     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
5092     if (PreserveFramePointer) {
5093       mov(rbp, rsp);
5094     }
5095     // Remove word for ebp
5096     framesize -= wordSize;
5097 
5098     // Create frame
5099     if (framesize) {
5100       subptr(rsp, framesize);
5101     }
5102   } else {
5103     // Create frame (force generation of a 4 byte immediate value)
5104     subptr_imm32(rsp, framesize);
5105 
5106     // Save RBP register now.
5107     framesize -= wordSize;
5108     movptr(Address(rsp, framesize), rbp);
5109     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
5110     if (PreserveFramePointer) {
5111       movptr(rbp, rsp);
5112       if (framesize &gt; 0) {
5113         addptr(rbp, framesize);
5114       }
5115     }
5116   }
5117 
5118   if (C-&gt;needs_stack_repair()) {
5119     // Save stack increment (also account for fixed framesize and rbp)
5120     assert((sp_inc &amp; (StackAlignmentInBytes-1)) == 0, &quot;stack increment not aligned&quot;);
5121     movptr(Address(rsp, C-&gt;output()-&gt;sp_inc_offset()), sp_inc + framesize + wordSize);
5122   }
5123 
5124   if (VerifyStackAtCalls) { // Majik cookie to verify stack depth
5125     framesize -= wordSize;
5126     movptr(Address(rsp, framesize), (int32_t)0xbadb100d);
5127   }
5128 
5129 #ifndef _LP64
5130   // If method sets FPU control word do it now
5131   if (fp_mode_24b) {
5132     fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
5133   }
5134   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
5135     verify_FPU(0, &quot;FPU stack must be clean on entry&quot;);
5136   }
5137 #endif
5138 
5139 #ifdef ASSERT
5140   if (VerifyStackAtCalls) {
5141     Label L;
5142     push(rax);
5143     mov(rax, rsp);
5144     andptr(rax, StackAlignmentInBytes-1);
5145     cmpptr(rax, StackAlignmentInBytes-wordSize);
5146     pop(rax);
5147     jcc(Assembler::equal, L);
5148     STOP(&quot;Stack is not properly aligned!&quot;);
5149     bind(L);
5150   }
5151 #endif
5152 }
5153 
5154 // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
5155 void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp) {
5156   // cnt - number of qwords (8-byte words).
5157   // base - start address, qword aligned.
5158   Label L_zero_64_bytes, L_loop, L_sloop, L_tail, L_end;
5159   movdq(xtmp, val);
5160   if (UseAVX &gt;= 2) {
5161     punpcklqdq(xtmp, xtmp);
5162     vinserti128_high(xtmp, xtmp);
5163   } else {
5164     punpcklqdq(xtmp, xtmp);
5165   }
5166   jmp(L_zero_64_bytes);
5167 
5168   BIND(L_loop);
5169   if (UseAVX &gt;= 2) {
5170     vmovdqu(Address(base,  0), xtmp);
5171     vmovdqu(Address(base, 32), xtmp);
5172   } else {
5173     movdqu(Address(base,  0), xtmp);
5174     movdqu(Address(base, 16), xtmp);
5175     movdqu(Address(base, 32), xtmp);
5176     movdqu(Address(base, 48), xtmp);
5177   }
5178   addptr(base, 64);
5179 
5180   BIND(L_zero_64_bytes);
5181   subptr(cnt, 8);
5182   jccb(Assembler::greaterEqual, L_loop);
5183   addptr(cnt, 4);
5184   jccb(Assembler::less, L_tail);
5185   // Copy trailing 32 bytes
5186   if (UseAVX &gt;= 2) {
5187     vmovdqu(Address(base, 0), xtmp);
5188   } else {
5189     movdqu(Address(base,  0), xtmp);
5190     movdqu(Address(base, 16), xtmp);
5191   }
5192   addptr(base, 32);
5193   subptr(cnt, 4);
5194 
5195   BIND(L_tail);
5196   addptr(cnt, 4);
5197   jccb(Assembler::lessEqual, L_end);
5198   decrement(cnt);
5199 
5200   BIND(L_sloop);
5201   movq(Address(base, 0), xtmp);
5202   addptr(base, 8);
5203   decrement(cnt);
5204   jccb(Assembler::greaterEqual, L_sloop);
5205   BIND(L_end);
5206 }
5207 
5208 int MacroAssembler::store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter) {
5209   // An inline type might be returned. If fields are in registers we
5210   // need to allocate an inline type instance and initialize it with
5211   // the value of the fields.
5212   Label skip;
5213   // We only need a new buffered inline type if a new one is not returned
5214   testptr(rax, 1);
5215   jcc(Assembler::zero, skip);
5216   int call_offset = -1;
5217 
5218 #ifdef _LP64
5219   Label slow_case;
5220 
5221   // Try to allocate a new buffered inline type (from the heap)
5222   if (UseTLAB) {
5223     // FIXME -- for smaller code, the inline allocation (and the slow case) should be moved inside the pack handler.
5224     if (vk != NULL) {
5225       // Called from C1, where the return type is statically known.
5226       movptr(rbx, (intptr_t)vk-&gt;get_InlineKlass());
5227       jint lh = vk-&gt;layout_helper();
5228       assert(lh != Klass::_lh_neutral_value, &quot;inline class in return type must have been resolved&quot;);
5229       movl(r14, lh);
5230     } else {
5231       // Call from interpreter. RAX contains ((the InlineKlass* of the return type) | 0x01)
5232       mov(rbx, rax);
5233       andptr(rbx, -2);
5234       movl(r14, Address(rbx, Klass::layout_helper_offset()));
5235     }
5236 
5237     movptr(r13, Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())));
5238     lea(r14, Address(r13, r14, Address::times_1));
5239     cmpptr(r14, Address(r15_thread, in_bytes(JavaThread::tlab_end_offset())));
5240     jcc(Assembler::above, slow_case);
5241     movptr(Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())), r14);
5242     movptr(Address(r13, oopDesc::mark_offset_in_bytes()), (intptr_t)markWord::always_locked_prototype().value());
5243 
5244     xorl(rax, rax); // use zero reg to clear memory (shorter code)
5245     store_klass_gap(r13, rax);  // zero klass gap for compressed oops
5246 
5247     if (vk == NULL) {
5248       // store_klass corrupts rbx, so save it in rax for later use (interpreter case only).
5249       mov(rax, rbx);
5250     }
5251     Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);
5252     store_klass(r13, rbx, tmp_store_klass);  // klass
5253 
5254     // We have our new buffered inline type, initialize its fields with an inline class specific handler
5255     if (vk != NULL) {
5256       // FIXME -- do the packing in-line to avoid the runtime call
5257       mov(rax, r13);
5258       call(RuntimeAddress(vk-&gt;pack_handler())); // no need for call info as this will not safepoint.
5259     } else {
5260       movptr(rbx, Address(rax, InstanceKlass::adr_inlineklass_fixed_block_offset()));
5261       movptr(rbx, Address(rbx, InlineKlass::pack_handler_offset()));
5262       mov(rax, r13);
5263       call(rbx);
5264     }
5265     jmp(skip);
5266   }
5267 
5268   bind(slow_case);
5269   // We failed to allocate a new inline type, fall back to a runtime
5270   // call. Some oop field may be live in some registers but we can&#39;t
5271   // tell. That runtime call will take care of preserving them
5272   // across a GC if there&#39;s one.
5273 #endif
5274 
5275   if (from_interpreter) {
5276     super_call_VM_leaf(StubRoutines::store_inline_type_fields_to_buf());
5277   } else {
5278     call(RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));
5279     call_offset = offset();
5280   }
5281 
5282   bind(skip);
5283   return call_offset;
5284 }
5285 
5286 
5287 // Move a value between registers/stack slots and update the reg_state
5288 bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset) {
5289   if (reg_state[to-&gt;value()] == reg_written) {
5290     return true; // Already written
5291   }
5292   if (from != to &amp;&amp; bt != T_VOID) {
5293     if (reg_state[to-&gt;value()] == reg_readonly) {
5294       return false; // Not yet writable
5295     }
5296     if (from-&gt;is_reg()) {
5297       if (to-&gt;is_reg()) {
5298         if (from-&gt;is_XMMRegister()) {
5299           if (bt == T_DOUBLE) {
5300             movdbl(to-&gt;as_XMMRegister(), from-&gt;as_XMMRegister());
5301           } else {
5302             assert(bt == T_FLOAT, &quot;must be float&quot;);
5303             movflt(to-&gt;as_XMMRegister(), from-&gt;as_XMMRegister());
5304           }
5305         } else {
5306           movq(to-&gt;as_Register(), from-&gt;as_Register());
5307         }
5308       } else {
5309         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5310         assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);
5311         Address to_addr = Address(rsp, st_off);
5312         if (from-&gt;is_XMMRegister()) {
5313           if (bt == T_DOUBLE) {
5314             movdbl(to_addr, from-&gt;as_XMMRegister());
5315           } else {
5316             assert(bt == T_FLOAT, &quot;must be float&quot;);
5317             movflt(to_addr, from-&gt;as_XMMRegister());
5318           }
5319         } else {
5320           movq(to_addr, from-&gt;as_Register());
5321         }
5322       }
5323     } else {
5324       Address from_addr = Address(rsp, from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset);
5325       if (to-&gt;is_reg()) {
5326         if (to-&gt;is_XMMRegister()) {
5327           if (bt == T_DOUBLE) {
5328             movdbl(to-&gt;as_XMMRegister(), from_addr);
5329           } else {
5330             assert(bt == T_FLOAT, &quot;must be float&quot;);
5331             movflt(to-&gt;as_XMMRegister(), from_addr);
5332           }
5333         } else {
5334           movq(to-&gt;as_Register(), from_addr);
5335         }
5336       } else {
5337         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5338         assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);
5339         movq(r13, from_addr);
5340         movq(Address(rsp, st_off), r13);
5341       }
5342     }
5343   }
5344   // Update register states
5345   reg_state[from-&gt;value()] = reg_writable;
5346   reg_state[to-&gt;value()] = reg_written;
5347   return true;
5348 }
5349 
5350 // Read all fields from an inline type oop and store the values in registers/stack slots
5351 bool MacroAssembler::unpack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to,
5352                                           int&amp; to_index, RegState reg_state[], int ret_off, int extra_stack_offset) {
5353   Register fromReg = from-&gt;is_reg() ? from-&gt;as_Register() : noreg;
5354   assert(sig-&gt;at(sig_index)._bt == T_VOID, &quot;should be at end delimiter&quot;);
5355 
5356   int vt = 1;
5357   bool done = true;
5358   bool mark_done = true;
5359   do {
5360     sig_index--;
5361     BasicType bt = sig-&gt;at(sig_index)._bt;
5362     if (bt == T_INLINE_TYPE) {
5363       vt--;
5364     } else if (bt == T_VOID &amp;&amp;
5365                sig-&gt;at(sig_index-1)._bt != T_LONG &amp;&amp;
5366                sig-&gt;at(sig_index-1)._bt != T_DOUBLE) {
5367       vt++;
5368     } else if (SigEntry::is_reserved_entry(sig, sig_index)) {
5369       to_index--; // Ignore this
5370     } else {
5371       assert(to_index &gt;= 0, &quot;invalid to_index&quot;);
5372       VMRegPair pair_to = regs_to[to_index--];
5373       VMReg to = pair_to.first();
5374 
5375       if (bt == T_VOID) continue;
5376 
5377       int idx = (int)to-&gt;value();
5378       if (reg_state[idx] == reg_readonly) {
5379          if (idx != from-&gt;value()) {
5380            mark_done = false;
5381          }
5382          done = false;
5383          continue;
5384       } else if (reg_state[idx] == reg_written) {
5385         continue;
5386       } else {
5387         assert(reg_state[idx] == reg_writable, &quot;must be writable&quot;);
5388         reg_state[idx] = reg_written;
5389        }
5390 
5391       if (fromReg == noreg) {
5392         int st_off = from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5393         movq(r10, Address(rsp, st_off));
5394         fromReg = r10;
5395       }
5396 
5397       int off = sig-&gt;at(sig_index)._offset;
5398       assert(off &gt; 0, &quot;offset in object should be positive&quot;);
5399       bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
5400 
5401       Address fromAddr = Address(fromReg, off);
5402       bool is_signed = (bt != T_CHAR) &amp;&amp; (bt != T_BOOLEAN);
5403       if (!to-&gt;is_XMMRegister()) {
5404         Register dst = to-&gt;is_stack() ? r13 : to-&gt;as_Register();
5405         if (is_oop) {
5406           load_heap_oop(dst, fromAddr);
5407         } else {
5408           load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);
5409         }
5410         if (to-&gt;is_stack()) {
5411           int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5412           assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);
5413           movq(Address(rsp, st_off), dst);
5414         }
5415       } else {
5416         if (bt == T_DOUBLE) {
5417           movdbl(to-&gt;as_XMMRegister(), fromAddr);
5418         } else {
5419           assert(bt == T_FLOAT, &quot;must be float&quot;);
5420           movflt(to-&gt;as_XMMRegister(), fromAddr);
5421         }
5422       }
5423     }
5424   } while (vt != 0);
5425   if (mark_done &amp;&amp; reg_state[from-&gt;value()] != reg_written) {
5426     // This is okay because no one else will write to that slot
5427     reg_state[from-&gt;value()] = reg_writable;
5428   }
5429   return done;
5430 }
5431 
5432 // Pack fields back into an inline type oop
5433 bool MacroAssembler::pack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,
5434                                         VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],
5435                                         int ret_off, int extra_stack_offset) {
5436   assert(sig-&gt;at(sig_index)._bt == T_INLINE_TYPE, &quot;should be at end delimiter&quot;);
5437   assert(to-&gt;is_valid(), &quot;must be&quot;);
5438 
5439   if (reg_state[to-&gt;value()] == reg_written) {
5440     skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
5441     return true; // Already written
5442   }
5443 
5444   Register val_array = rax;
5445   Register val_obj_tmp = r11;
5446   Register from_reg_tmp = r14; // Be careful with r14 because it&#39;s used for spilling
5447   Register tmp1 = r10;
5448   Register tmp2 = r13;
5449   Register tmp3 = rbx;
5450   Register val_obj = to-&gt;is_stack() ? val_obj_tmp : to-&gt;as_Register();
5451 
5452   if (reg_state[to-&gt;value()] == reg_readonly) {
5453     if (!is_reg_in_unpacked_fields(sig, sig_index, to, regs_from, regs_from_count, from_index)) {
5454       skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);
5455       return false; // Not yet writable
5456     }
5457     val_obj = val_obj_tmp;
5458   }
5459 
5460   int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_INLINE_TYPE);
5461   load_heap_oop(val_obj, Address(val_array, index));
5462 
5463   ScalarizedValueArgsStream stream(sig, sig_index, regs_from, regs_from_count, from_index);
5464   VMRegPair from_pair;
5465   BasicType bt;
5466   while (stream.next(from_pair, bt)) {
5467     int off = sig-&gt;at(stream.sig_cc_index())._offset;
5468     assert(off &gt; 0, &quot;offset in object should be positive&quot;);
5469     bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
5470     size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;
5471 
5472     VMReg from_r1 = from_pair.first();
5473     VMReg from_r2 = from_pair.second();
5474 
5475     // Pack the scalarized field into the value object.
5476     Address dst(val_obj, off);
5477     if (!from_r1-&gt;is_XMMRegister()) {
5478       Register from_reg;
5479       if (from_r1-&gt;is_stack()) {
5480         from_reg = from_reg_tmp;
5481         int ld_off = from_r1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;
5482         load_sized_value(from_reg, Address(rsp, ld_off), size_in_bytes, /* is_signed */ false);
5483       } else {
5484         from_reg = from_r1-&gt;as_Register();
5485       }
5486       assert_different_registers(dst.base(), from_reg, tmp1, tmp2, tmp3, val_array);
5487       if (is_oop) {
5488         store_heap_oop(dst, from_reg, tmp1, tmp2, tmp3, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);
5489       } else {
5490         store_sized_value(dst, from_reg, size_in_bytes);
5491       }
5492     } else {
5493       if (from_r2-&gt;is_valid()) {
5494         movdbl(dst, from_r1-&gt;as_XMMRegister());
5495       } else {
5496         movflt(dst, from_r1-&gt;as_XMMRegister());
5497       }
5498     }
5499     reg_state[from_r1-&gt;value()] = reg_writable;
5500   }
5501   sig_index = stream.sig_cc_index();
5502   from_index = stream.regs_cc_index();
5503 
5504   assert(reg_state[to-&gt;value()] == reg_writable, &quot;must have already been read&quot;);
5505   bool success = move_helper(val_obj-&gt;as_VMReg(), to, T_OBJECT, reg_state, ret_off, extra_stack_offset);
5506   assert(success, &quot;to register must be writeable&quot;);
5507 
5508   return true;
5509 }
5510 
5511 // Unpack all inline type arguments passed as oops
5512 void MacroAssembler::unpack_inline_args(Compile* C, bool receiver_only) {
5513   int sp_inc = unpack_inline_args_common(C, receiver_only);
5514   // Emit code for verified entry and save increment for stack repair on return
5515   verified_entry(C, sp_inc);
5516 }
5517 
5518 void MacroAssembler::shuffle_inline_args(bool is_packing, bool receiver_only, int extra_stack_offset,
5519                                          BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,
5520                                          int args_passed, int args_on_stack, VMRegPair* regs,
5521                                          int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc) {
5522   // Check if we need to extend the stack for packing/unpacking
5523   if (sp_inc &gt; 0 &amp;&amp; !is_packing) {
5524     // Save the return address, adjust the stack (make sure it is properly
5525     // 16-byte aligned) and copy the return address to the new top of the stack.
5526     // (Note: C1 does this in C1_MacroAssembler::scalarized_entry).
5527     pop(r13);
5528     subptr(rsp, sp_inc);
5529     push(r13);
5530   }
5531 
5532   int ret_off; // make sure we don&#39;t overwrite the return address
5533   if (is_packing) {
5534     // For C1 code, the VIEP doesn&#39;t have reserved slots, so we store the returned address at
5535     // rsp[0] during shuffling.
5536     ret_off = 0;
5537   } else {
5538     // C2 code ensures that sp_inc is a reserved slot.
5539     ret_off = sp_inc;
5540   }
5541 
5542   shuffle_inline_args_common(is_packing, receiver_only, extra_stack_offset,
5543                              sig_bt, sig_cc,
5544                              args_passed, args_on_stack, regs,
5545                              args_passed_to, args_on_stack_to, regs_to,
5546                              sp_inc, ret_off);
5547 }
5548 
5549 VMReg MacroAssembler::spill_reg_for(VMReg reg) {
5550   return reg-&gt;is_XMMRegister() ? xmm8-&gt;as_VMReg() : r14-&gt;as_VMReg();
5551 }
5552 
5553 void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset) {
5554   assert((initial_framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
5555   if (needs_stack_repair) {
5556     movq(rbp, Address(rsp, initial_framesize));
5557     addq(rsp, Address(rsp, sp_inc_offset));
5558   } else {
5559     if (initial_framesize &gt; 0) {
5560       addq(rsp, initial_framesize);
5561     }
5562     pop(rbp);
5563   }
5564 }
5565 
5566 void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only) {
5567   // cnt - number of qwords (8-byte words).
5568   // base - start address, qword aligned.
5569   // is_large - if optimizers know cnt is larger than InitArrayShortSize
5570   assert(base==rdi, &quot;base register must be edi for rep stos&quot;);
5571   assert(val==rax,   &quot;tmp register must be eax for rep stos&quot;);
5572   assert(cnt==rcx,   &quot;cnt register must be ecx for rep stos&quot;);
5573   assert(InitArrayShortSize % BytesPerLong == 0,
5574     &quot;InitArrayShortSize should be the multiple of BytesPerLong&quot;);
5575 
5576   Label DONE;
5577 
5578   if (!is_large) {
5579     Label LOOP, LONG;
5580     cmpptr(cnt, InitArrayShortSize/BytesPerLong);
5581     jccb(Assembler::greater, LONG);
5582 
5583     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
5584 
5585     decrement(cnt);
5586     jccb(Assembler::negative, DONE); // Zero length
5587 
5588     // Use individual pointer-sized stores for small counts:
5589     BIND(LOOP);
5590     movptr(Address(base, cnt, Address::times_ptr), val);
5591     decrement(cnt);
5592     jccb(Assembler::greaterEqual, LOOP);
5593     jmpb(DONE);
5594 
5595     BIND(LONG);
5596   }
5597 
5598   // Use longer rep-prefixed ops for non-small counts:
5599   if (UseFastStosb &amp;&amp; !word_copy_only) {
5600     shlptr(cnt, 3); // convert to number of bytes
5601     rep_stosb();
5602   } else if (UseXMMForObjInit) {
5603     xmm_clear_mem(base, cnt, val, xtmp);
5604   } else {
5605     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
5606     rep_stos();
5607   }
5608 
5609   BIND(DONE);
5610 }
5611 
5612 void MacroAssembler::generate_fill(BasicType t, bool aligned,
5613                                    Register to, Register value, Register count,
5614                                    Register rtmp, XMMRegister xtmp) {
5615   ShortBranchVerifier sbv(this);
5616   assert_different_registers(to, value, count, rtmp);
5617   Label L_exit;
5618   Label L_fill_2_bytes, L_fill_4_bytes;
5619 
5620   int shift = -1;
5621   switch (t) {
5622     case T_BYTE:
5623       shift = 2;
5624       break;
5625     case T_SHORT:
5626       shift = 1;
5627       break;
5628     case T_INT:
5629       shift = 0;
5630       break;
5631     default: ShouldNotReachHere();
5632   }
5633 
5634   if (t == T_BYTE) {
5635     andl(value, 0xff);
5636     movl(rtmp, value);
5637     shll(rtmp, 8);
5638     orl(value, rtmp);
5639   }
5640   if (t == T_SHORT) {
5641     andl(value, 0xffff);
5642   }
5643   if (t == T_BYTE || t == T_SHORT) {
5644     movl(rtmp, value);
5645     shll(rtmp, 16);
5646     orl(value, rtmp);
5647   }
5648 
5649   cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) fill by element
5650   jcc(Assembler::below, L_fill_4_bytes); // use unsigned cmp
5651   if (!UseUnalignedLoadStores &amp;&amp; !aligned &amp;&amp; (t == T_BYTE || t == T_SHORT)) {
5652     Label L_skip_align2;
5653     // align source address at 4 bytes address boundary
5654     if (t == T_BYTE) {
5655       Label L_skip_align1;
5656       // One byte misalignment happens only for byte arrays
5657       testptr(to, 1);
5658       jccb(Assembler::zero, L_skip_align1);
5659       movb(Address(to, 0), value);
5660       increment(to);
5661       decrement(count);
5662       BIND(L_skip_align1);
5663     }
5664     // Two bytes misalignment happens only for byte and short (char) arrays
5665     testptr(to, 2);
5666     jccb(Assembler::zero, L_skip_align2);
5667     movw(Address(to, 0), value);
5668     addptr(to, 2);
5669     subl(count, 1&lt;&lt;(shift-1));
5670     BIND(L_skip_align2);
5671   }
5672   if (UseSSE &lt; 2) {
5673     Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
5674     // Fill 32-byte chunks
5675     subl(count, 8 &lt;&lt; shift);
5676     jcc(Assembler::less, L_check_fill_8_bytes);
5677     align(16);
5678 
5679     BIND(L_fill_32_bytes_loop);
5680 
5681     for (int i = 0; i &lt; 32; i += 4) {
5682       movl(Address(to, i), value);
5683     }
5684 
5685     addptr(to, 32);
5686     subl(count, 8 &lt;&lt; shift);
5687     jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5688     BIND(L_check_fill_8_bytes);
5689     addl(count, 8 &lt;&lt; shift);
5690     jccb(Assembler::zero, L_exit);
5691     jmpb(L_fill_8_bytes);
5692 
5693     //
5694     // length is too short, just fill qwords
5695     //
5696     BIND(L_fill_8_bytes_loop);
5697     movl(Address(to, 0), value);
5698     movl(Address(to, 4), value);
5699     addptr(to, 8);
5700     BIND(L_fill_8_bytes);
5701     subl(count, 1 &lt;&lt; (shift + 1));
5702     jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5703     // fall through to fill 4 bytes
5704   } else {
5705     Label L_fill_32_bytes;
5706     if (!UseUnalignedLoadStores) {
5707       // align to 8 bytes, we know we are 4 byte aligned to start
5708       testptr(to, 4);
5709       jccb(Assembler::zero, L_fill_32_bytes);
5710       movl(Address(to, 0), value);
5711       addptr(to, 4);
5712       subl(count, 1&lt;&lt;shift);
5713     }
5714     BIND(L_fill_32_bytes);
5715     {
5716       assert( UseSSE &gt;= 2, &quot;supported cpu only&quot; );
5717       Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
5718       movdl(xtmp, value);
5719       if (UseAVX &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
5720         Label L_check_fill_32_bytes;
5721         if (UseAVX &gt; 2) {
5722           // Fill 64-byte chunks
5723           Label L_fill_64_bytes_loop_avx3, L_check_fill_64_bytes_avx2;
5724 
5725           // If number of bytes to fill &lt; AVX3Threshold, perform fill using AVX2
5726           cmpl(count, AVX3Threshold);
5727           jccb(Assembler::below, L_check_fill_64_bytes_avx2);
5728 
5729           vpbroadcastd(xtmp, xtmp, Assembler::AVX_512bit);
5730 
5731           subl(count, 16 &lt;&lt; shift);
5732           jccb(Assembler::less, L_check_fill_32_bytes);
5733           align(16);
5734 
5735           BIND(L_fill_64_bytes_loop_avx3);
5736           evmovdqul(Address(to, 0), xtmp, Assembler::AVX_512bit);
5737           addptr(to, 64);
5738           subl(count, 16 &lt;&lt; shift);
5739           jcc(Assembler::greaterEqual, L_fill_64_bytes_loop_avx3);
5740           jmpb(L_check_fill_32_bytes);
5741 
5742           BIND(L_check_fill_64_bytes_avx2);
5743         }
5744         // Fill 64-byte chunks
5745         Label L_fill_64_bytes_loop;
5746         vpbroadcastd(xtmp, xtmp, Assembler::AVX_256bit);
5747 
5748         subl(count, 16 &lt;&lt; shift);
5749         jcc(Assembler::less, L_check_fill_32_bytes);
5750         align(16);
5751 
5752         BIND(L_fill_64_bytes_loop);
5753         vmovdqu(Address(to, 0), xtmp);
5754         vmovdqu(Address(to, 32), xtmp);
5755         addptr(to, 64);
5756         subl(count, 16 &lt;&lt; shift);
5757         jcc(Assembler::greaterEqual, L_fill_64_bytes_loop);
5758 
5759         BIND(L_check_fill_32_bytes);
5760         addl(count, 8 &lt;&lt; shift);
5761         jccb(Assembler::less, L_check_fill_8_bytes);
5762         vmovdqu(Address(to, 0), xtmp);
5763         addptr(to, 32);
5764         subl(count, 8 &lt;&lt; shift);
5765 
5766         BIND(L_check_fill_8_bytes);
5767         // clean upper bits of YMM registers
5768         movdl(xtmp, value);
5769         pshufd(xtmp, xtmp, 0);
5770       } else {
5771         // Fill 32-byte chunks
5772         pshufd(xtmp, xtmp, 0);
5773 
5774         subl(count, 8 &lt;&lt; shift);
5775         jcc(Assembler::less, L_check_fill_8_bytes);
5776         align(16);
5777 
5778         BIND(L_fill_32_bytes_loop);
5779 
5780         if (UseUnalignedLoadStores) {
5781           movdqu(Address(to, 0), xtmp);
5782           movdqu(Address(to, 16), xtmp);
5783         } else {
5784           movq(Address(to, 0), xtmp);
5785           movq(Address(to, 8), xtmp);
5786           movq(Address(to, 16), xtmp);
5787           movq(Address(to, 24), xtmp);
5788         }
5789 
5790         addptr(to, 32);
5791         subl(count, 8 &lt;&lt; shift);
5792         jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5793 
5794         BIND(L_check_fill_8_bytes);
5795       }
5796       addl(count, 8 &lt;&lt; shift);
5797       jccb(Assembler::zero, L_exit);
5798       jmpb(L_fill_8_bytes);
5799 
5800       //
5801       // length is too short, just fill qwords
5802       //
5803       BIND(L_fill_8_bytes_loop);
5804       movq(Address(to, 0), xtmp);
5805       addptr(to, 8);
5806       BIND(L_fill_8_bytes);
5807       subl(count, 1 &lt;&lt; (shift + 1));
5808       jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5809     }
5810   }
5811   // fill trailing 4 bytes
5812   BIND(L_fill_4_bytes);
5813   testl(count, 1&lt;&lt;shift);
5814   jccb(Assembler::zero, L_fill_2_bytes);
5815   movl(Address(to, 0), value);
5816   if (t == T_BYTE || t == T_SHORT) {
5817     Label L_fill_byte;
5818     addptr(to, 4);
5819     BIND(L_fill_2_bytes);
5820     // fill trailing 2 bytes
5821     testl(count, 1&lt;&lt;(shift-1));
5822     jccb(Assembler::zero, L_fill_byte);
5823     movw(Address(to, 0), value);
5824     if (t == T_BYTE) {
5825       addptr(to, 2);
5826       BIND(L_fill_byte);
5827       // fill trailing byte
5828       testl(count, 1);
5829       jccb(Assembler::zero, L_exit);
5830       movb(Address(to, 0), value);
5831     } else {
5832       BIND(L_fill_byte);
5833     }
5834   } else {
5835     BIND(L_fill_2_bytes);
5836   }
5837   BIND(L_exit);
5838 }
5839 
5840 // encode char[] to byte[] in ISO_8859_1
5841    //@HotSpotIntrinsicCandidate
5842    //private static int implEncodeISOArray(byte[] sa, int sp,
5843    //byte[] da, int dp, int len) {
5844    //  int i = 0;
5845    //  for (; i &lt; len; i++) {
5846    //    char c = StringUTF16.getChar(sa, sp++);
5847    //    if (c &gt; &#39;\u00FF&#39;)
5848    //      break;
5849    //    da[dp++] = (byte)c;
5850    //  }
5851    //  return i;
5852    //}
5853 void MacroAssembler::encode_iso_array(Register src, Register dst, Register len,
5854   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
5855   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
5856   Register tmp5, Register result) {
5857 
5858   // rsi: src
5859   // rdi: dst
5860   // rdx: len
5861   // rcx: tmp5
5862   // rax: result
5863   ShortBranchVerifier sbv(this);
5864   assert_different_registers(src, dst, len, tmp5, result);
5865   Label L_done, L_copy_1_char, L_copy_1_char_exit;
5866 
5867   // set result
5868   xorl(result, result);
5869   // check for zero length
5870   testl(len, len);
5871   jcc(Assembler::zero, L_done);
5872 
5873   movl(result, len);
5874 
5875   // Setup pointers
5876   lea(src, Address(src, len, Address::times_2)); // char[]
5877   lea(dst, Address(dst, len, Address::times_1)); // byte[]
5878   negptr(len);
5879 
5880   if (UseSSE42Intrinsics || UseAVX &gt;= 2) {
5881     Label L_copy_8_chars, L_copy_8_chars_exit;
5882     Label L_chars_16_check, L_copy_16_chars, L_copy_16_chars_exit;
5883 
5884     if (UseAVX &gt;= 2) {
5885       Label L_chars_32_check, L_copy_32_chars, L_copy_32_chars_exit;
5886       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5887       movdl(tmp1Reg, tmp5);
5888       vpbroadcastd(tmp1Reg, tmp1Reg, Assembler::AVX_256bit);
5889       jmp(L_chars_32_check);
5890 
5891       bind(L_copy_32_chars);
5892       vmovdqu(tmp3Reg, Address(src, len, Address::times_2, -64));
5893       vmovdqu(tmp4Reg, Address(src, len, Address::times_2, -32));
5894       vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5895       vptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5896       jccb(Assembler::notZero, L_copy_32_chars_exit);
5897       vpackuswb(tmp3Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5898       vpermq(tmp4Reg, tmp3Reg, 0xD8, /* vector_len */ 1);
5899       vmovdqu(Address(dst, len, Address::times_1, -32), tmp4Reg);
5900 
5901       bind(L_chars_32_check);
5902       addptr(len, 32);
5903       jcc(Assembler::lessEqual, L_copy_32_chars);
5904 
5905       bind(L_copy_32_chars_exit);
5906       subptr(len, 16);
5907       jccb(Assembler::greater, L_copy_16_chars_exit);
5908 
5909     } else if (UseSSE42Intrinsics) {
5910       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5911       movdl(tmp1Reg, tmp5);
5912       pshufd(tmp1Reg, tmp1Reg, 0);
5913       jmpb(L_chars_16_check);
5914     }
5915 
5916     bind(L_copy_16_chars);
5917     if (UseAVX &gt;= 2) {
5918       vmovdqu(tmp2Reg, Address(src, len, Address::times_2, -32));
5919       vptest(tmp2Reg, tmp1Reg);
5920       jcc(Assembler::notZero, L_copy_16_chars_exit);
5921       vpackuswb(tmp2Reg, tmp2Reg, tmp1Reg, /* vector_len */ 1);
5922       vpermq(tmp3Reg, tmp2Reg, 0xD8, /* vector_len */ 1);
5923     } else {
5924       if (UseAVX &gt; 0) {
5925         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5926         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5927         vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 0);
5928       } else {
5929         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5930         por(tmp2Reg, tmp3Reg);
5931         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5932         por(tmp2Reg, tmp4Reg);
5933       }
5934       ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5935       jccb(Assembler::notZero, L_copy_16_chars_exit);
5936       packuswb(tmp3Reg, tmp4Reg);
5937     }
5938     movdqu(Address(dst, len, Address::times_1, -16), tmp3Reg);
5939 
5940     bind(L_chars_16_check);
5941     addptr(len, 16);
5942     jcc(Assembler::lessEqual, L_copy_16_chars);
5943 
5944     bind(L_copy_16_chars_exit);
5945     if (UseAVX &gt;= 2) {
5946       // clean upper bits of YMM registers
5947       vpxor(tmp2Reg, tmp2Reg);
5948       vpxor(tmp3Reg, tmp3Reg);
5949       vpxor(tmp4Reg, tmp4Reg);
5950       movdl(tmp1Reg, tmp5);
5951       pshufd(tmp1Reg, tmp1Reg, 0);
5952     }
5953     subptr(len, 8);
5954     jccb(Assembler::greater, L_copy_8_chars_exit);
5955 
5956     bind(L_copy_8_chars);
5957     movdqu(tmp3Reg, Address(src, len, Address::times_2, -16));
5958     ptest(tmp3Reg, tmp1Reg);
5959     jccb(Assembler::notZero, L_copy_8_chars_exit);
5960     packuswb(tmp3Reg, tmp1Reg);
5961     movq(Address(dst, len, Address::times_1, -8), tmp3Reg);
5962     addptr(len, 8);
5963     jccb(Assembler::lessEqual, L_copy_8_chars);
5964 
5965     bind(L_copy_8_chars_exit);
5966     subptr(len, 8);
5967     jccb(Assembler::zero, L_done);
5968   }
5969 
5970   bind(L_copy_1_char);
5971   load_unsigned_short(tmp5, Address(src, len, Address::times_2, 0));
5972   testl(tmp5, 0xff00);      // check if Unicode char
5973   jccb(Assembler::notZero, L_copy_1_char_exit);
5974   movb(Address(dst, len, Address::times_1, 0), tmp5);
5975   addptr(len, 1);
5976   jccb(Assembler::less, L_copy_1_char);
5977 
5978   bind(L_copy_1_char_exit);
5979   addptr(result, len); // len is negative count of not processed elements
5980 
5981   bind(L_done);
5982 }
5983 
5984 #ifdef _LP64
5985 /**
5986  * Helper for multiply_to_len().
5987  */
5988 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
5989   addq(dest_lo, src1);
5990   adcq(dest_hi, 0);
5991   addq(dest_lo, src2);
5992   adcq(dest_hi, 0);
5993 }
5994 
5995 /**
5996  * Multiply 64 bit by 64 bit first loop.
5997  */
5998 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
5999                                            Register y, Register y_idx, Register z,
6000                                            Register carry, Register product,
6001                                            Register idx, Register kdx) {
6002   //
6003   //  jlong carry, x[], y[], z[];
6004   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
6005   //    huge_128 product = y[idx] * x[xstart] + carry;
6006   //    z[kdx] = (jlong)product;
6007   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
6008   //  }
6009   //  z[xstart] = carry;
6010   //
6011 
6012   Label L_first_loop, L_first_loop_exit;
6013   Label L_one_x, L_one_y, L_multiply;
6014 
6015   decrementl(xstart);
6016   jcc(Assembler::negative, L_one_x);
6017 
6018   movq(x_xstart, Address(x, xstart, Address::times_4,  0));
6019   rorq(x_xstart, 32); // convert big-endian to little-endian
6020 
6021   bind(L_first_loop);
6022   decrementl(idx);
6023   jcc(Assembler::negative, L_first_loop_exit);
6024   decrementl(idx);
6025   jcc(Assembler::negative, L_one_y);
6026   movq(y_idx, Address(y, idx, Address::times_4,  0));
6027   rorq(y_idx, 32); // convert big-endian to little-endian
6028   bind(L_multiply);
6029   movq(product, x_xstart);
6030   mulq(y_idx); // product(rax) * y_idx -&gt; rdx:rax
6031   addq(product, carry);
6032   adcq(rdx, 0);
6033   subl(kdx, 2);
6034   movl(Address(z, kdx, Address::times_4,  4), product);
6035   shrq(product, 32);
6036   movl(Address(z, kdx, Address::times_4,  0), product);
6037   movq(carry, rdx);
6038   jmp(L_first_loop);
6039 
6040   bind(L_one_y);
6041   movl(y_idx, Address(y,  0));
6042   jmp(L_multiply);
6043 
6044   bind(L_one_x);
6045   movl(x_xstart, Address(x,  0));
6046   jmp(L_first_loop);
6047 
6048   bind(L_first_loop_exit);
6049 }
6050 
6051 /**
6052  * Multiply 64 bit by 64 bit and add 128 bit.
6053  */
6054 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y, Register z,
6055                                             Register yz_idx, Register idx,
6056                                             Register carry, Register product, int offset) {
6057   //     huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
6058   //     z[kdx] = (jlong)product;
6059 
6060   movq(yz_idx, Address(y, idx, Address::times_4,  offset));
6061   rorq(yz_idx, 32); // convert big-endian to little-endian
6062   movq(product, x_xstart);
6063   mulq(yz_idx);     // product(rax) * yz_idx -&gt; rdx:product(rax)
6064   movq(yz_idx, Address(z, idx, Address::times_4,  offset));
6065   rorq(yz_idx, 32); // convert big-endian to little-endian
6066 
6067   add2_with_carry(rdx, product, carry, yz_idx);
6068 
6069   movl(Address(z, idx, Address::times_4,  offset+4), product);
6070   shrq(product, 32);
6071   movl(Address(z, idx, Address::times_4,  offset), product);
6072 
6073 }
6074 
6075 /**
6076  * Multiply 128 bit by 128 bit. Unrolled inner loop.
6077  */
6078 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
6079                                              Register yz_idx, Register idx, Register jdx,
6080                                              Register carry, Register product,
6081                                              Register carry2) {
6082   //   jlong carry, x[], y[], z[];
6083   //   int kdx = ystart+1;
6084   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
6085   //     huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
6086   //     z[kdx+idx+1] = (jlong)product;
6087   //     jlong carry2  = (jlong)(product &gt;&gt;&gt; 64);
6088   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
6089   //     z[kdx+idx] = (jlong)product;
6090   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
6091   //   }
6092   //   idx += 2;
6093   //   if (idx &gt; 0) {
6094   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
6095   //     z[kdx+idx] = (jlong)product;
6096   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
6097   //   }
6098   //
6099 
6100   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
6101 
6102   movl(jdx, idx);
6103   andl(jdx, 0xFFFFFFFC);
6104   shrl(jdx, 2);
6105 
6106   bind(L_third_loop);
6107   subl(jdx, 1);
6108   jcc(Assembler::negative, L_third_loop_exit);
6109   subl(idx, 4);
6110 
6111   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
6112   movq(carry2, rdx);
6113 
6114   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
6115   movq(carry, rdx);
6116   jmp(L_third_loop);
6117 
6118   bind (L_third_loop_exit);
6119 
6120   andl (idx, 0x3);
6121   jcc(Assembler::zero, L_post_third_loop_done);
6122 
6123   Label L_check_1;
6124   subl(idx, 2);
6125   jcc(Assembler::negative, L_check_1);
6126 
6127   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
6128   movq(carry, rdx);
6129 
6130   bind (L_check_1);
6131   addl (idx, 0x2);
6132   andl (idx, 0x1);
6133   subl(idx, 1);
6134   jcc(Assembler::negative, L_post_third_loop_done);
6135 
6136   movl(yz_idx, Address(y, idx, Address::times_4,  0));
6137   movq(product, x_xstart);
6138   mulq(yz_idx); // product(rax) * yz_idx -&gt; rdx:product(rax)
6139   movl(yz_idx, Address(z, idx, Address::times_4,  0));
6140 
6141   add2_with_carry(rdx, product, yz_idx, carry);
6142 
6143   movl(Address(z, idx, Address::times_4,  0), product);
6144   shrq(product, 32);
6145 
6146   shlq(rdx, 32);
6147   orq(product, rdx);
6148   movq(carry, product);
6149 
6150   bind(L_post_third_loop_done);
6151 }
6152 
6153 /**
6154  * Multiply 128 bit by 128 bit using BMI2. Unrolled inner loop.
6155  *
6156  */
6157 void MacroAssembler::multiply_128_x_128_bmi2_loop(Register y, Register z,
6158                                                   Register carry, Register carry2,
6159                                                   Register idx, Register jdx,
6160                                                   Register yz_idx1, Register yz_idx2,
6161                                                   Register tmp, Register tmp3, Register tmp4) {
6162   assert(UseBMI2Instructions, &quot;should be used only when BMI2 is available&quot;);
6163 
6164   //   jlong carry, x[], y[], z[];
6165   //   int kdx = ystart+1;
6166   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
6167   //     huge_128 tmp3 = (y[idx+1] * rdx) + z[kdx+idx+1] + carry;
6168   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
6169   //     huge_128 tmp4 = (y[idx]   * rdx) + z[kdx+idx] + carry2;
6170   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
6171   //     z[kdx+idx+1] = (jlong)tmp3;
6172   //     z[kdx+idx] = (jlong)tmp4;
6173   //   }
6174   //   idx += 2;
6175   //   if (idx &gt; 0) {
6176   //     yz_idx1 = (y[idx] * rdx) + z[kdx+idx] + carry;
6177   //     z[kdx+idx] = (jlong)yz_idx1;
6178   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
6179   //   }
6180   //
6181 
6182   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
6183 
6184   movl(jdx, idx);
6185   andl(jdx, 0xFFFFFFFC);
6186   shrl(jdx, 2);
6187 
6188   bind(L_third_loop);
6189   subl(jdx, 1);
6190   jcc(Assembler::negative, L_third_loop_exit);
6191   subl(idx, 4);
6192 
6193   movq(yz_idx1,  Address(y, idx, Address::times_4,  8));
6194   rorxq(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
6195   movq(yz_idx2, Address(y, idx, Address::times_4,  0));
6196   rorxq(yz_idx2, yz_idx2, 32);
6197 
6198   mulxq(tmp4, tmp3, yz_idx1);  //  yz_idx1 * rdx -&gt; tmp4:tmp3
6199   mulxq(carry2, tmp, yz_idx2); //  yz_idx2 * rdx -&gt; carry2:tmp
6200 
6201   movq(yz_idx1,  Address(z, idx, Address::times_4,  8));
6202   rorxq(yz_idx1, yz_idx1, 32);
6203   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
6204   rorxq(yz_idx2, yz_idx2, 32);
6205 
6206   if (VM_Version::supports_adx()) {
6207     adcxq(tmp3, carry);
6208     adoxq(tmp3, yz_idx1);
6209 
6210     adcxq(tmp4, tmp);
6211     adoxq(tmp4, yz_idx2);
6212 
6213     movl(carry, 0); // does not affect flags
6214     adcxq(carry2, carry);
6215     adoxq(carry2, carry);
6216   } else {
6217     add2_with_carry(tmp4, tmp3, carry, yz_idx1);
6218     add2_with_carry(carry2, tmp4, tmp, yz_idx2);
6219   }
6220   movq(carry, carry2);
6221 
6222   movl(Address(z, idx, Address::times_4, 12), tmp3);
6223   shrq(tmp3, 32);
6224   movl(Address(z, idx, Address::times_4,  8), tmp3);
6225 
6226   movl(Address(z, idx, Address::times_4,  4), tmp4);
6227   shrq(tmp4, 32);
6228   movl(Address(z, idx, Address::times_4,  0), tmp4);
6229 
6230   jmp(L_third_loop);
6231 
6232   bind (L_third_loop_exit);
6233 
6234   andl (idx, 0x3);
6235   jcc(Assembler::zero, L_post_third_loop_done);
6236 
6237   Label L_check_1;
6238   subl(idx, 2);
6239   jcc(Assembler::negative, L_check_1);
6240 
6241   movq(yz_idx1, Address(y, idx, Address::times_4,  0));
6242   rorxq(yz_idx1, yz_idx1, 32);
6243   mulxq(tmp4, tmp3, yz_idx1); //  yz_idx1 * rdx -&gt; tmp4:tmp3
6244   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
6245   rorxq(yz_idx2, yz_idx2, 32);
6246 
6247   add2_with_carry(tmp4, tmp3, carry, yz_idx2);
6248 
6249   movl(Address(z, idx, Address::times_4,  4), tmp3);
6250   shrq(tmp3, 32);
6251   movl(Address(z, idx, Address::times_4,  0), tmp3);
6252   movq(carry, tmp4);
6253 
6254   bind (L_check_1);
6255   addl (idx, 0x2);
6256   andl (idx, 0x1);
6257   subl(idx, 1);
6258   jcc(Assembler::negative, L_post_third_loop_done);
6259   movl(tmp4, Address(y, idx, Address::times_4,  0));
6260   mulxq(carry2, tmp3, tmp4);  //  tmp4 * rdx -&gt; carry2:tmp3
6261   movl(tmp4, Address(z, idx, Address::times_4,  0));
6262 
6263   add2_with_carry(carry2, tmp3, tmp4, carry);
6264 
6265   movl(Address(z, idx, Address::times_4,  0), tmp3);
6266   shrq(tmp3, 32);
6267 
6268   shlq(carry2, 32);
6269   orq(tmp3, carry2);
6270   movq(carry, tmp3);
6271 
6272   bind(L_post_third_loop_done);
6273 }
6274 
6275 /**
6276  * Code for BigInteger::multiplyToLen() instrinsic.
6277  *
6278  * rdi: x
6279  * rax: xlen
6280  * rsi: y
6281  * rcx: ylen
6282  * r8:  z
6283  * r11: zlen
6284  * r12: tmp1
6285  * r13: tmp2
6286  * r14: tmp3
6287  * r15: tmp4
6288  * rbx: tmp5
6289  *
6290  */
6291 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
6292                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {
6293   ShortBranchVerifier sbv(this);
6294   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);
6295 
6296   push(tmp1);
6297   push(tmp2);
6298   push(tmp3);
6299   push(tmp4);
6300   push(tmp5);
6301 
6302   push(xlen);
6303   push(zlen);
6304 
6305   const Register idx = tmp1;
6306   const Register kdx = tmp2;
6307   const Register xstart = tmp3;
6308 
6309   const Register y_idx = tmp4;
6310   const Register carry = tmp5;
6311   const Register product  = xlen;
6312   const Register x_xstart = zlen;  // reuse register
6313 
6314   // First Loop.
6315   //
6316   //  final static long LONG_MASK = 0xffffffffL;
6317   //  int xstart = xlen - 1;
6318   //  int ystart = ylen - 1;
6319   //  long carry = 0;
6320   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
6321   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
6322   //    z[kdx] = (int)product;
6323   //    carry = product &gt;&gt;&gt; 32;
6324   //  }
6325   //  z[xstart] = (int)carry;
6326   //
6327 
6328   movl(idx, ylen);      // idx = ylen;
6329   movl(kdx, zlen);      // kdx = xlen+ylen;
6330   xorq(carry, carry);   // carry = 0;
6331 
6332   Label L_done;
6333 
6334   movl(xstart, xlen);
6335   decrementl(xstart);
6336   jcc(Assembler::negative, L_done);
6337 
6338   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
6339 
6340   Label L_second_loop;
6341   testl(kdx, kdx);
6342   jcc(Assembler::zero, L_second_loop);
6343 
6344   Label L_carry;
6345   subl(kdx, 1);
6346   jcc(Assembler::zero, L_carry);
6347 
6348   movl(Address(z, kdx, Address::times_4,  0), carry);
6349   shrq(carry, 32);
6350   subl(kdx, 1);
6351 
6352   bind(L_carry);
6353   movl(Address(z, kdx, Address::times_4,  0), carry);
6354 
6355   // Second and third (nested) loops.
6356   //
6357   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
6358   //   carry = 0;
6359   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
6360   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
6361   //                    (z[k] &amp; LONG_MASK) + carry;
6362   //     z[k] = (int)product;
6363   //     carry = product &gt;&gt;&gt; 32;
6364   //   }
6365   //   z[i] = (int)carry;
6366   // }
6367   //
6368   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
6369 
6370   const Register jdx = tmp1;
6371 
6372   bind(L_second_loop);
6373   xorl(carry, carry);    // carry = 0;
6374   movl(jdx, ylen);       // j = ystart+1
6375 
6376   subl(xstart, 1);       // i = xstart-1;
6377   jcc(Assembler::negative, L_done);
6378 
6379   push (z);
6380 
6381   Label L_last_x;
6382   lea(z, Address(z, xstart, Address::times_4, 4)); // z = z + k - j
6383   subl(xstart, 1);       // i = xstart-1;
6384   jcc(Assembler::negative, L_last_x);
6385 
6386   if (UseBMI2Instructions) {
6387     movq(rdx,  Address(x, xstart, Address::times_4,  0));
6388     rorxq(rdx, rdx, 32); // convert big-endian to little-endian
6389   } else {
6390     movq(x_xstart, Address(x, xstart, Address::times_4,  0));
6391     rorq(x_xstart, 32);  // convert big-endian to little-endian
6392   }
6393 
6394   Label L_third_loop_prologue;
6395   bind(L_third_loop_prologue);
6396 
6397   push (x);
6398   push (xstart);
6399   push (ylen);
6400 
6401 
6402   if (UseBMI2Instructions) {
6403     multiply_128_x_128_bmi2_loop(y, z, carry, x, jdx, ylen, product, tmp2, x_xstart, tmp3, tmp4);
6404   } else { // !UseBMI2Instructions
6405     multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
6406   }
6407 
6408   pop(ylen);
6409   pop(xlen);
6410   pop(x);
6411   pop(z);
6412 
6413   movl(tmp3, xlen);
6414   addl(tmp3, 1);
6415   movl(Address(z, tmp3, Address::times_4,  0), carry);
6416   subl(tmp3, 1);
6417   jccb(Assembler::negative, L_done);
6418 
6419   shrq(carry, 32);
6420   movl(Address(z, tmp3, Address::times_4,  0), carry);
6421   jmp(L_second_loop);
6422 
6423   // Next infrequent code is moved outside loops.
6424   bind(L_last_x);
6425   if (UseBMI2Instructions) {
6426     movl(rdx, Address(x,  0));
6427   } else {
6428     movl(x_xstart, Address(x,  0));
6429   }
6430   jmp(L_third_loop_prologue);
6431 
6432   bind(L_done);
6433 
6434   pop(zlen);
6435   pop(xlen);
6436 
6437   pop(tmp5);
6438   pop(tmp4);
6439   pop(tmp3);
6440   pop(tmp2);
6441   pop(tmp1);
6442 }
6443 
6444 void MacroAssembler::vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
6445   Register result, Register tmp1, Register tmp2, XMMRegister rymm0, XMMRegister rymm1, XMMRegister rymm2){
6446   assert(UseSSE42Intrinsics, &quot;SSE4.2 must be enabled.&quot;);
6447   Label VECTOR16_LOOP, VECTOR8_LOOP, VECTOR4_LOOP;
6448   Label VECTOR8_TAIL, VECTOR4_TAIL;
6449   Label VECTOR32_NOT_EQUAL, VECTOR16_NOT_EQUAL, VECTOR8_NOT_EQUAL, VECTOR4_NOT_EQUAL;
6450   Label SAME_TILL_END, DONE;
6451   Label BYTES_LOOP, BYTES_TAIL, BYTES_NOT_EQUAL;
6452 
6453   //scale is in rcx in both Win64 and Unix
6454   ShortBranchVerifier sbv(this);
6455 
6456   shlq(length);
6457   xorq(result, result);
6458 
6459   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp;
6460       VM_Version::supports_avx512vlbw()) {
6461     Label VECTOR64_LOOP, VECTOR64_NOT_EQUAL, VECTOR32_TAIL;
6462 
6463     cmpq(length, 64);
6464     jcc(Assembler::less, VECTOR32_TAIL);
6465 
6466     movq(tmp1, length);
6467     andq(tmp1, 0x3F);      // tail count
6468     andq(length, ~(0x3F)); //vector count
6469 
6470     bind(VECTOR64_LOOP);
6471     // AVX512 code to compare 64 byte vectors.
6472     evmovdqub(rymm0, Address(obja, result), Assembler::AVX_512bit);
6473     evpcmpeqb(k7, rymm0, Address(objb, result), Assembler::AVX_512bit);
6474     kortestql(k7, k7);
6475     jcc(Assembler::aboveEqual, VECTOR64_NOT_EQUAL);     // mismatch
6476     addq(result, 64);
6477     subq(length, 64);
6478     jccb(Assembler::notZero, VECTOR64_LOOP);
6479 
6480     //bind(VECTOR64_TAIL);
6481     testq(tmp1, tmp1);
6482     jcc(Assembler::zero, SAME_TILL_END);
6483 
6484     //bind(VECTOR64_TAIL);
6485     // AVX512 code to compare upto 63 byte vectors.
6486     mov64(tmp2, 0xFFFFFFFFFFFFFFFF);
6487     shlxq(tmp2, tmp2, tmp1);
6488     notq(tmp2);
6489     kmovql(k3, tmp2);
6490 
6491     evmovdqub(rymm0, k3, Address(obja, result), Assembler::AVX_512bit);
6492     evpcmpeqb(k7, k3, rymm0, Address(objb, result), Assembler::AVX_512bit);
6493 
6494     ktestql(k7, k3);
6495     jcc(Assembler::below, SAME_TILL_END);     // not mismatch
6496 
6497     bind(VECTOR64_NOT_EQUAL);
6498     kmovql(tmp1, k7);
6499     notq(tmp1);
6500     tzcntq(tmp1, tmp1);
6501     addq(result, tmp1);
6502     shrq(result);
6503     jmp(DONE);
6504     bind(VECTOR32_TAIL);
6505   }
6506 
6507   cmpq(length, 8);
6508   jcc(Assembler::equal, VECTOR8_LOOP);
6509   jcc(Assembler::less, VECTOR4_TAIL);
6510 
6511   if (UseAVX &gt;= 2) {
6512     Label VECTOR16_TAIL, VECTOR32_LOOP;
6513 
6514     cmpq(length, 16);
6515     jcc(Assembler::equal, VECTOR16_LOOP);
6516     jcc(Assembler::less, VECTOR8_LOOP);
6517 
6518     cmpq(length, 32);
6519     jccb(Assembler::less, VECTOR16_TAIL);
6520 
6521     subq(length, 32);
6522     bind(VECTOR32_LOOP);
6523     vmovdqu(rymm0, Address(obja, result));
6524     vmovdqu(rymm1, Address(objb, result));
6525     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_256bit);
6526     vptest(rymm2, rymm2);
6527     jcc(Assembler::notZero, VECTOR32_NOT_EQUAL);//mismatch found
6528     addq(result, 32);
6529     subq(length, 32);
6530     jcc(Assembler::greaterEqual, VECTOR32_LOOP);
6531     addq(length, 32);
6532     jcc(Assembler::equal, SAME_TILL_END);
6533     //falling through if less than 32 bytes left //close the branch here.
6534 
6535     bind(VECTOR16_TAIL);
6536     cmpq(length, 16);
6537     jccb(Assembler::less, VECTOR8_TAIL);
6538     bind(VECTOR16_LOOP);
6539     movdqu(rymm0, Address(obja, result));
6540     movdqu(rymm1, Address(objb, result));
6541     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_128bit);
6542     ptest(rymm2, rymm2);
6543     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
6544     addq(result, 16);
6545     subq(length, 16);
6546     jcc(Assembler::equal, SAME_TILL_END);
6547     //falling through if less than 16 bytes left
6548   } else {//regular intrinsics
6549 
6550     cmpq(length, 16);
6551     jccb(Assembler::less, VECTOR8_TAIL);
6552 
6553     subq(length, 16);
6554     bind(VECTOR16_LOOP);
6555     movdqu(rymm0, Address(obja, result));
6556     movdqu(rymm1, Address(objb, result));
6557     pxor(rymm0, rymm1);
6558     ptest(rymm0, rymm0);
6559     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
6560     addq(result, 16);
6561     subq(length, 16);
6562     jccb(Assembler::greaterEqual, VECTOR16_LOOP);
6563     addq(length, 16);
6564     jcc(Assembler::equal, SAME_TILL_END);
6565     //falling through if less than 16 bytes left
6566   }
6567 
6568   bind(VECTOR8_TAIL);
6569   cmpq(length, 8);
6570   jccb(Assembler::less, VECTOR4_TAIL);
6571   bind(VECTOR8_LOOP);
6572   movq(tmp1, Address(obja, result));
6573   movq(tmp2, Address(objb, result));
6574   xorq(tmp1, tmp2);
6575   testq(tmp1, tmp1);
6576   jcc(Assembler::notZero, VECTOR8_NOT_EQUAL);//mismatch found
6577   addq(result, 8);
6578   subq(length, 8);
6579   jcc(Assembler::equal, SAME_TILL_END);
6580   //falling through if less than 8 bytes left
6581 
6582   bind(VECTOR4_TAIL);
6583   cmpq(length, 4);
6584   jccb(Assembler::less, BYTES_TAIL);
6585   bind(VECTOR4_LOOP);
6586   movl(tmp1, Address(obja, result));
6587   xorl(tmp1, Address(objb, result));
6588   testl(tmp1, tmp1);
6589   jcc(Assembler::notZero, VECTOR4_NOT_EQUAL);//mismatch found
6590   addq(result, 4);
6591   subq(length, 4);
6592   jcc(Assembler::equal, SAME_TILL_END);
6593   //falling through if less than 4 bytes left
6594 
6595   bind(BYTES_TAIL);
6596   bind(BYTES_LOOP);
6597   load_unsigned_byte(tmp1, Address(obja, result));
6598   load_unsigned_byte(tmp2, Address(objb, result));
6599   xorl(tmp1, tmp2);
6600   testl(tmp1, tmp1);
6601   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
6602   decq(length);
6603   jcc(Assembler::zero, SAME_TILL_END);
6604   incq(result);
6605   load_unsigned_byte(tmp1, Address(obja, result));
6606   load_unsigned_byte(tmp2, Address(objb, result));
6607   xorl(tmp1, tmp2);
6608   testl(tmp1, tmp1);
6609   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
6610   decq(length);
6611   jcc(Assembler::zero, SAME_TILL_END);
6612   incq(result);
6613   load_unsigned_byte(tmp1, Address(obja, result));
6614   load_unsigned_byte(tmp2, Address(objb, result));
6615   xorl(tmp1, tmp2);
6616   testl(tmp1, tmp1);
6617   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
6618   jmp(SAME_TILL_END);
6619 
6620   if (UseAVX &gt;= 2) {
6621     bind(VECTOR32_NOT_EQUAL);
6622     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_256bit);
6623     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_256bit);
6624     vpxor(rymm0, rymm0, rymm2, Assembler::AVX_256bit);
6625     vpmovmskb(tmp1, rymm0);
6626     bsfq(tmp1, tmp1);
6627     addq(result, tmp1);
6628     shrq(result);
6629     jmp(DONE);
6630   }
6631 
6632   bind(VECTOR16_NOT_EQUAL);
6633   if (UseAVX &gt;= 2) {
6634     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_128bit);
6635     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_128bit);
6636     pxor(rymm0, rymm2);
6637   } else {
6638     pcmpeqb(rymm2, rymm2);
6639     pxor(rymm0, rymm1);
6640     pcmpeqb(rymm0, rymm1);
6641     pxor(rymm0, rymm2);
6642   }
6643   pmovmskb(tmp1, rymm0);
6644   bsfq(tmp1, tmp1);
6645   addq(result, tmp1);
6646   shrq(result);
6647   jmpb(DONE);
6648 
6649   bind(VECTOR8_NOT_EQUAL);
6650   bind(VECTOR4_NOT_EQUAL);
6651   bsfq(tmp1, tmp1);
6652   shrq(tmp1, 3);
6653   addq(result, tmp1);
6654   bind(BYTES_NOT_EQUAL);
6655   shrq(result);
6656   jmpb(DONE);
6657 
6658   bind(SAME_TILL_END);
6659   mov64(result, -1);
6660 
6661   bind(DONE);
6662 }
6663 
6664 //Helper functions for square_to_len()
6665 
6666 /**
6667  * Store the squares of x[], right shifted one bit (divided by 2) into z[]
6668  * Preserves x and z and modifies rest of the registers.
6669  */
6670 void MacroAssembler::square_rshift(Register x, Register xlen, Register z, Register tmp1, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6671   // Perform square and right shift by 1
6672   // Handle odd xlen case first, then for even xlen do the following
6673   // jlong carry = 0;
6674   // for (int j=0, i=0; j &lt; xlen; j+=2, i+=4) {
6675   //     huge_128 product = x[j:j+1] * x[j:j+1];
6676   //     z[i:i+1] = (carry &lt;&lt; 63) | (jlong)(product &gt;&gt;&gt; 65);
6677   //     z[i+2:i+3] = (jlong)(product &gt;&gt;&gt; 1);
6678   //     carry = (jlong)product;
6679   // }
6680 
6681   xorq(tmp5, tmp5);     // carry
6682   xorq(rdxReg, rdxReg);
6683   xorl(tmp1, tmp1);     // index for x
6684   xorl(tmp4, tmp4);     // index for z
6685 
6686   Label L_first_loop, L_first_loop_exit;
6687 
6688   testl(xlen, 1);
6689   jccb(Assembler::zero, L_first_loop); //jump if xlen is even
6690 
6691   // Square and right shift by 1 the odd element using 32 bit multiply
6692   movl(raxReg, Address(x, tmp1, Address::times_4, 0));
6693   imulq(raxReg, raxReg);
6694   shrq(raxReg, 1);
6695   adcq(tmp5, 0);
6696   movq(Address(z, tmp4, Address::times_4, 0), raxReg);
6697   incrementl(tmp1);
6698   addl(tmp4, 2);
6699 
6700   // Square and  right shift by 1 the rest using 64 bit multiply
6701   bind(L_first_loop);
6702   cmpptr(tmp1, xlen);
6703   jccb(Assembler::equal, L_first_loop_exit);
6704 
6705   // Square
6706   movq(raxReg, Address(x, tmp1, Address::times_4,  0));
6707   rorq(raxReg, 32);    // convert big-endian to little-endian
6708   mulq(raxReg);        // 64-bit multiply rax * rax -&gt; rdx:rax
6709 
6710   // Right shift by 1 and save carry
6711   shrq(tmp5, 1);       // rdx:rax:tmp5 = (tmp5:rdx:rax) &gt;&gt;&gt; 1
6712   rcrq(rdxReg, 1);
6713   rcrq(raxReg, 1);
6714   adcq(tmp5, 0);
6715 
6716   // Store result in z
6717   movq(Address(z, tmp4, Address::times_4, 0), rdxReg);
6718   movq(Address(z, tmp4, Address::times_4, 8), raxReg);
6719 
6720   // Update indices for x and z
6721   addl(tmp1, 2);
6722   addl(tmp4, 4);
6723   jmp(L_first_loop);
6724 
6725   bind(L_first_loop_exit);
6726 }
6727 
6728 
6729 /**
6730  * Perform the following multiply add operation using BMI2 instructions
6731  * carry:sum = sum + op1*op2 + carry
6732  * op2 should be in rdx
6733  * op2 is preserved, all other registers are modified
6734  */
6735 void MacroAssembler::multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry, Register tmp2) {
6736   // assert op2 is rdx
6737   mulxq(tmp2, op1, op1);  //  op1 * op2 -&gt; tmp2:op1
6738   addq(sum, carry);
6739   adcq(tmp2, 0);
6740   addq(sum, op1);
6741   adcq(tmp2, 0);
6742   movq(carry, tmp2);
6743 }
6744 
6745 /**
6746  * Perform the following multiply add operation:
6747  * carry:sum = sum + op1*op2 + carry
6748  * Preserves op1, op2 and modifies rest of registers
6749  */
6750 void MacroAssembler::multiply_add_64(Register sum, Register op1, Register op2, Register carry, Register rdxReg, Register raxReg) {
6751   // rdx:rax = op1 * op2
6752   movq(raxReg, op2);
6753   mulq(op1);
6754 
6755   //  rdx:rax = sum + carry + rdx:rax
6756   addq(sum, carry);
6757   adcq(rdxReg, 0);
6758   addq(sum, raxReg);
6759   adcq(rdxReg, 0);
6760 
6761   // carry:sum = rdx:sum
6762   movq(carry, rdxReg);
6763 }
6764 
6765 /**
6766  * Add 64 bit long carry into z[] with carry propogation.
6767  * Preserves z and carry register values and modifies rest of registers.
6768  *
6769  */
6770 void MacroAssembler::add_one_64(Register z, Register zlen, Register carry, Register tmp1) {
6771   Label L_fourth_loop, L_fourth_loop_exit;
6772 
6773   movl(tmp1, 1);
6774   subl(zlen, 2);
6775   addq(Address(z, zlen, Address::times_4, 0), carry);
6776 
6777   bind(L_fourth_loop);
6778   jccb(Assembler::carryClear, L_fourth_loop_exit);
6779   subl(zlen, 2);
6780   jccb(Assembler::negative, L_fourth_loop_exit);
6781   addq(Address(z, zlen, Address::times_4, 0), tmp1);
6782   jmp(L_fourth_loop);
6783   bind(L_fourth_loop_exit);
6784 }
6785 
6786 /**
6787  * Shift z[] left by 1 bit.
6788  * Preserves x, len, z and zlen registers and modifies rest of the registers.
6789  *
6790  */
6791 void MacroAssembler::lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4) {
6792 
6793   Label L_fifth_loop, L_fifth_loop_exit;
6794 
6795   // Fifth loop
6796   // Perform primitiveLeftShift(z, zlen, 1)
6797 
6798   const Register prev_carry = tmp1;
6799   const Register new_carry = tmp4;
6800   const Register value = tmp2;
6801   const Register zidx = tmp3;
6802 
6803   // int zidx, carry;
6804   // long value;
6805   // carry = 0;
6806   // for (zidx = zlen-2; zidx &gt;=0; zidx -= 2) {
6807   //    (carry:value)  = (z[i] &lt;&lt; 1) | carry ;
6808   //    z[i] = value;
6809   // }
6810 
6811   movl(zidx, zlen);
6812   xorl(prev_carry, prev_carry); // clear carry flag and prev_carry register
6813 
6814   bind(L_fifth_loop);
6815   decl(zidx);  // Use decl to preserve carry flag
6816   decl(zidx);
6817   jccb(Assembler::negative, L_fifth_loop_exit);
6818 
6819   if (UseBMI2Instructions) {
6820      movq(value, Address(z, zidx, Address::times_4, 0));
6821      rclq(value, 1);
6822      rorxq(value, value, 32);
6823      movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6824   }
6825   else {
6826     // clear new_carry
6827     xorl(new_carry, new_carry);
6828 
6829     // Shift z[i] by 1, or in previous carry and save new carry
6830     movq(value, Address(z, zidx, Address::times_4, 0));
6831     shlq(value, 1);
6832     adcl(new_carry, 0);
6833 
6834     orq(value, prev_carry);
6835     rorq(value, 0x20);
6836     movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6837 
6838     // Set previous carry = new carry
6839     movl(prev_carry, new_carry);
6840   }
6841   jmp(L_fifth_loop);
6842 
6843   bind(L_fifth_loop_exit);
6844 }
6845 
6846 
6847 /**
6848  * Code for BigInteger::squareToLen() intrinsic
6849  *
6850  * rdi: x
6851  * rsi: len
6852  * r8:  z
6853  * rcx: zlen
6854  * r12: tmp1
6855  * r13: tmp2
6856  * r14: tmp3
6857  * r15: tmp4
6858  * rbx: tmp5
6859  *
6860  */
6861 void MacroAssembler::square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6862 
6863   Label L_second_loop, L_second_loop_exit, L_third_loop, L_third_loop_exit, L_last_x, L_multiply;
6864   push(tmp1);
6865   push(tmp2);
6866   push(tmp3);
6867   push(tmp4);
6868   push(tmp5);
6869 
6870   // First loop
6871   // Store the squares, right shifted one bit (i.e., divided by 2).
6872   square_rshift(x, len, z, tmp1, tmp3, tmp4, tmp5, rdxReg, raxReg);
6873 
6874   // Add in off-diagonal sums.
6875   //
6876   // Second, third (nested) and fourth loops.
6877   // zlen +=2;
6878   // for (int xidx=len-2,zidx=zlen-4; xidx &gt; 0; xidx-=2,zidx-=4) {
6879   //    carry = 0;
6880   //    long op2 = x[xidx:xidx+1];
6881   //    for (int j=xidx-2,k=zidx; j &gt;= 0; j-=2) {
6882   //       k -= 2;
6883   //       long op1 = x[j:j+1];
6884   //       long sum = z[k:k+1];
6885   //       carry:sum = multiply_add_64(sum, op1, op2, carry, tmp_regs);
6886   //       z[k:k+1] = sum;
6887   //    }
6888   //    add_one_64(z, k, carry, tmp_regs);
6889   // }
6890 
6891   const Register carry = tmp5;
6892   const Register sum = tmp3;
6893   const Register op1 = tmp4;
6894   Register op2 = tmp2;
6895 
6896   push(zlen);
6897   push(len);
6898   addl(zlen,2);
6899   bind(L_second_loop);
6900   xorq(carry, carry);
6901   subl(zlen, 4);
6902   subl(len, 2);
6903   push(zlen);
6904   push(len);
6905   cmpl(len, 0);
6906   jccb(Assembler::lessEqual, L_second_loop_exit);
6907 
6908   // Multiply an array by one 64 bit long.
6909   if (UseBMI2Instructions) {
6910     op2 = rdxReg;
6911     movq(op2, Address(x, len, Address::times_4,  0));
6912     rorxq(op2, op2, 32);
6913   }
6914   else {
6915     movq(op2, Address(x, len, Address::times_4,  0));
6916     rorq(op2, 32);
6917   }
6918 
6919   bind(L_third_loop);
6920   decrementl(len);
6921   jccb(Assembler::negative, L_third_loop_exit);
6922   decrementl(len);
6923   jccb(Assembler::negative, L_last_x);
6924 
6925   movq(op1, Address(x, len, Address::times_4,  0));
6926   rorq(op1, 32);
6927 
6928   bind(L_multiply);
6929   subl(zlen, 2);
6930   movq(sum, Address(z, zlen, Address::times_4,  0));
6931 
6932   // Multiply 64 bit by 64 bit and add 64 bits lower half and upper 64 bits as carry.
6933   if (UseBMI2Instructions) {
6934     multiply_add_64_bmi2(sum, op1, op2, carry, tmp2);
6935   }
6936   else {
6937     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6938   }
6939 
6940   movq(Address(z, zlen, Address::times_4, 0), sum);
6941 
6942   jmp(L_third_loop);
6943   bind(L_third_loop_exit);
6944 
6945   // Fourth loop
6946   // Add 64 bit long carry into z with carry propogation.
6947   // Uses offsetted zlen.
6948   add_one_64(z, zlen, carry, tmp1);
6949 
6950   pop(len);
6951   pop(zlen);
6952   jmp(L_second_loop);
6953 
6954   // Next infrequent code is moved outside loops.
6955   bind(L_last_x);
6956   movl(op1, Address(x, 0));
6957   jmp(L_multiply);
6958 
6959   bind(L_second_loop_exit);
6960   pop(len);
6961   pop(zlen);
6962   pop(len);
6963   pop(zlen);
6964 
6965   // Fifth loop
6966   // Shift z left 1 bit.
6967   lshift_by_1(x, len, z, zlen, tmp1, tmp2, tmp3, tmp4);
6968 
6969   // z[zlen-1] |= x[len-1] &amp; 1;
6970   movl(tmp3, Address(x, len, Address::times_4, -4));
6971   andl(tmp3, 1);
6972   orl(Address(z, zlen, Address::times_4,  -4), tmp3);
6973 
6974   pop(tmp5);
6975   pop(tmp4);
6976   pop(tmp3);
6977   pop(tmp2);
6978   pop(tmp1);
6979 }
6980 
6981 /**
6982  * Helper function for mul_add()
6983  * Multiply the in[] by int k and add to out[] starting at offset offs using
6984  * 128 bit by 32 bit multiply and return the carry in tmp5.
6985  * Only quad int aligned length of in[] is operated on in this function.
6986  * k is in rdxReg for BMI2Instructions, for others it is in tmp2.
6987  * This function preserves out, in and k registers.
6988  * len and offset point to the appropriate index in &quot;in&quot; &amp; &quot;out&quot; correspondingly
6989  * tmp5 has the carry.
6990  * other registers are temporary and are modified.
6991  *
6992  */
6993 void MacroAssembler::mul_add_128_x_32_loop(Register out, Register in,
6994   Register offset, Register len, Register tmp1, Register tmp2, Register tmp3,
6995   Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6996 
6997   Label L_first_loop, L_first_loop_exit;
6998 
6999   movl(tmp1, len);
7000   shrl(tmp1, 2);
7001 
7002   bind(L_first_loop);
7003   subl(tmp1, 1);
7004   jccb(Assembler::negative, L_first_loop_exit);
7005 
7006   subl(len, 4);
7007   subl(offset, 4);
7008 
7009   Register op2 = tmp2;
7010   const Register sum = tmp3;
7011   const Register op1 = tmp4;
7012   const Register carry = tmp5;
7013 
7014   if (UseBMI2Instructions) {
7015     op2 = rdxReg;
7016   }
7017 
7018   movq(op1, Address(in, len, Address::times_4,  8));
7019   rorq(op1, 32);
7020   movq(sum, Address(out, offset, Address::times_4,  8));
7021   rorq(sum, 32);
7022   if (UseBMI2Instructions) {
7023     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
7024   }
7025   else {
7026     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
7027   }
7028   // Store back in big endian from little endian
7029   rorq(sum, 0x20);
7030   movq(Address(out, offset, Address::times_4,  8), sum);
7031 
7032   movq(op1, Address(in, len, Address::times_4,  0));
7033   rorq(op1, 32);
7034   movq(sum, Address(out, offset, Address::times_4,  0));
7035   rorq(sum, 32);
7036   if (UseBMI2Instructions) {
7037     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
7038   }
7039   else {
7040     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
7041   }
7042   // Store back in big endian from little endian
7043   rorq(sum, 0x20);
7044   movq(Address(out, offset, Address::times_4,  0), sum);
7045 
7046   jmp(L_first_loop);
7047   bind(L_first_loop_exit);
7048 }
7049 
7050 /**
7051  * Code for BigInteger::mulAdd() intrinsic
7052  *
7053  * rdi: out
7054  * rsi: in
7055  * r11: offs (out.length - offset)
7056  * rcx: len
7057  * r8:  k
7058  * r12: tmp1
7059  * r13: tmp2
7060  * r14: tmp3
7061  * r15: tmp4
7062  * rbx: tmp5
7063  * Multiply the in[] by word k and add to out[], return the carry in rax
7064  */
7065 void MacroAssembler::mul_add(Register out, Register in, Register offs,
7066    Register len, Register k, Register tmp1, Register tmp2, Register tmp3,
7067    Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
7068 
7069   Label L_carry, L_last_in, L_done;
7070 
7071 // carry = 0;
7072 // for (int j=len-1; j &gt;= 0; j--) {
7073 //    long product = (in[j] &amp; LONG_MASK) * kLong +
7074 //                   (out[offs] &amp; LONG_MASK) + carry;
7075 //    out[offs--] = (int)product;
7076 //    carry = product &gt;&gt;&gt; 32;
7077 // }
7078 //
7079   push(tmp1);
7080   push(tmp2);
7081   push(tmp3);
7082   push(tmp4);
7083   push(tmp5);
7084 
7085   Register op2 = tmp2;
7086   const Register sum = tmp3;
7087   const Register op1 = tmp4;
7088   const Register carry =  tmp5;
7089 
7090   if (UseBMI2Instructions) {
7091     op2 = rdxReg;
7092     movl(op2, k);
7093   }
7094   else {
7095     movl(op2, k);
7096   }
7097 
7098   xorq(carry, carry);
7099 
7100   //First loop
7101 
7102   //Multiply in[] by k in a 4 way unrolled loop using 128 bit by 32 bit multiply
7103   //The carry is in tmp5
7104   mul_add_128_x_32_loop(out, in, offs, len, tmp1, tmp2, tmp3, tmp4, tmp5, rdxReg, raxReg);
7105 
7106   //Multiply the trailing in[] entry using 64 bit by 32 bit, if any
7107   decrementl(len);
7108   jccb(Assembler::negative, L_carry);
7109   decrementl(len);
7110   jccb(Assembler::negative, L_last_in);
7111 
7112   movq(op1, Address(in, len, Address::times_4,  0));
7113   rorq(op1, 32);
7114 
7115   subl(offs, 2);
7116   movq(sum, Address(out, offs, Address::times_4,  0));
7117   rorq(sum, 32);
7118 
7119   if (UseBMI2Instructions) {
7120     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
7121   }
7122   else {
7123     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
7124   }
7125 
7126   // Store back in big endian from little endian
7127   rorq(sum, 0x20);
7128   movq(Address(out, offs, Address::times_4,  0), sum);
7129 
7130   testl(len, len);
7131   jccb(Assembler::zero, L_carry);
7132 
7133   //Multiply the last in[] entry, if any
7134   bind(L_last_in);
7135   movl(op1, Address(in, 0));
7136   movl(sum, Address(out, offs, Address::times_4,  -4));
7137 
7138   movl(raxReg, k);
7139   mull(op1); //tmp4 * eax -&gt; edx:eax
7140   addl(sum, carry);
7141   adcl(rdxReg, 0);
7142   addl(sum, raxReg);
7143   adcl(rdxReg, 0);
7144   movl(carry, rdxReg);
7145 
7146   movl(Address(out, offs, Address::times_4,  -4), sum);
7147 
7148   bind(L_carry);
7149   //return tmp5/carry as carry in rax
7150   movl(rax, carry);
7151 
7152   bind(L_done);
7153   pop(tmp5);
7154   pop(tmp4);
7155   pop(tmp3);
7156   pop(tmp2);
7157   pop(tmp1);
7158 }
7159 #endif
7160 
7161 /**
7162  * Emits code to update CRC-32 with a byte value according to constants in table
7163  *
7164  * @param [in,out]crc   Register containing the crc.
7165  * @param [in]val       Register containing the byte to fold into the CRC.
7166  * @param [in]table     Register containing the table of crc constants.
7167  *
7168  * uint32_t crc;
7169  * val = crc_table[(val ^ crc) &amp; 0xFF];
7170  * crc = val ^ (crc &gt;&gt; 8);
7171  *
7172  */
7173 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
7174   xorl(val, crc);
7175   andl(val, 0xFF);
7176   shrl(crc, 8); // unsigned shift
7177   xorl(crc, Address(table, val, Address::times_4, 0));
7178 }
7179 
7180 /**
7181  * Fold 128-bit data chunk
7182  */
7183 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
7184   if (UseAVX &gt; 0) {
7185     vpclmulhdq(xtmp, xK, xcrc); // [123:64]
7186     vpclmulldq(xcrc, xK, xcrc); // [63:0]
7187     vpxor(xcrc, xcrc, Address(buf, offset), 0 /* vector_len */);
7188     pxor(xcrc, xtmp);
7189   } else {
7190     movdqa(xtmp, xcrc);
7191     pclmulhdq(xtmp, xK);   // [123:64]
7192     pclmulldq(xcrc, xK);   // [63:0]
7193     pxor(xcrc, xtmp);
7194     movdqu(xtmp, Address(buf, offset));
7195     pxor(xcrc, xtmp);
7196   }
7197 }
7198 
7199 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf) {
7200   if (UseAVX &gt; 0) {
7201     vpclmulhdq(xtmp, xK, xcrc);
7202     vpclmulldq(xcrc, xK, xcrc);
7203     pxor(xcrc, xbuf);
7204     pxor(xcrc, xtmp);
7205   } else {
7206     movdqa(xtmp, xcrc);
7207     pclmulhdq(xtmp, xK);
7208     pclmulldq(xcrc, xK);
7209     pxor(xcrc, xbuf);
7210     pxor(xcrc, xtmp);
7211   }
7212 }
7213 
7214 /**
7215  * 8-bit folds to compute 32-bit CRC
7216  *
7217  * uint64_t xcrc;
7218  * timesXtoThe32[xcrc &amp; 0xFF] ^ (xcrc &gt;&gt; 8);
7219  */
7220 void MacroAssembler::fold_8bit_crc32(XMMRegister xcrc, Register table, XMMRegister xtmp, Register tmp) {
7221   movdl(tmp, xcrc);
7222   andl(tmp, 0xFF);
7223   movdl(xtmp, Address(table, tmp, Address::times_4, 0));
7224   psrldq(xcrc, 1); // unsigned shift one byte
7225   pxor(xcrc, xtmp);
7226 }
7227 
7228 /**
7229  * uint32_t crc;
7230  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
7231  */
7232 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
7233   movl(tmp, crc);
7234   andl(tmp, 0xFF);
7235   shrl(crc, 8);
7236   xorl(crc, Address(table, tmp, Address::times_4, 0));
7237 }
7238 
7239 /**
7240  * @param crc   register containing existing CRC (32-bit)
7241  * @param buf   register pointing to input byte buffer (byte*)
7242  * @param len   register containing number of bytes
7243  * @param table register that will contain address of CRC table
7244  * @param tmp   scratch register
7245  */
7246 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp) {
7247   assert_different_registers(crc, buf, len, table, tmp, rax);
7248 
7249   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
7250   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
7251 
7252   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
7253   // context for the registers used, where all instructions below are using 128-bit mode
7254   // On EVEX without VL and BW, these instructions will all be AVX.
7255   lea(table, ExternalAddress(StubRoutines::crc_table_addr()));
7256   notl(crc); // ~crc
7257   cmpl(len, 16);
7258   jcc(Assembler::less, L_tail);
7259 
7260   // Align buffer to 16 bytes
7261   movl(tmp, buf);
7262   andl(tmp, 0xF);
7263   jccb(Assembler::zero, L_aligned);
7264   subl(tmp,  16);
7265   addl(len, tmp);
7266 
7267   align(4);
7268   BIND(L_align_loop);
7269   movsbl(rax, Address(buf, 0)); // load byte with sign extension
7270   update_byte_crc32(crc, rax, table);
7271   increment(buf);
7272   incrementl(tmp);
7273   jccb(Assembler::less, L_align_loop);
7274 
7275   BIND(L_aligned);
7276   movl(tmp, len); // save
7277   shrl(len, 4);
7278   jcc(Assembler::zero, L_tail_restore);
7279 
7280   // Fold crc into first bytes of vector
7281   movdqa(xmm1, Address(buf, 0));
7282   movdl(rax, xmm1);
7283   xorl(crc, rax);
7284   if (VM_Version::supports_sse4_1()) {
7285     pinsrd(xmm1, crc, 0);
7286   } else {
7287     pinsrw(xmm1, crc, 0);
7288     shrl(crc, 16);
7289     pinsrw(xmm1, crc, 1);
7290   }
7291   addptr(buf, 16);
7292   subl(len, 4); // len &gt; 0
7293   jcc(Assembler::less, L_fold_tail);
7294 
7295   movdqa(xmm2, Address(buf,  0));
7296   movdqa(xmm3, Address(buf, 16));
7297   movdqa(xmm4, Address(buf, 32));
7298   addptr(buf, 48);
7299   subl(len, 3);
7300   jcc(Assembler::lessEqual, L_fold_512b);
7301 
7302   // Fold total 512 bits of polynomial on each iteration,
7303   // 128 bits per each of 4 parallel streams.
7304   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 32));
7305 
7306   align(32);
7307   BIND(L_fold_512b_loop);
7308   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
7309   fold_128bit_crc32(xmm2, xmm0, xmm5, buf, 16);
7310   fold_128bit_crc32(xmm3, xmm0, xmm5, buf, 32);
7311   fold_128bit_crc32(xmm4, xmm0, xmm5, buf, 48);
7312   addptr(buf, 64);
7313   subl(len, 4);
7314   jcc(Assembler::greater, L_fold_512b_loop);
7315 
7316   // Fold 512 bits to 128 bits.
7317   BIND(L_fold_512b);
7318   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
7319   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm2);
7320   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm3);
7321   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm4);
7322 
7323   // Fold the rest of 128 bits data chunks
7324   BIND(L_fold_tail);
7325   addl(len, 3);
7326   jccb(Assembler::lessEqual, L_fold_128b);
7327   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
7328 
7329   BIND(L_fold_tail_loop);
7330   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
7331   addptr(buf, 16);
7332   decrementl(len);
7333   jccb(Assembler::greater, L_fold_tail_loop);
7334 
7335   // Fold 128 bits in xmm1 down into 32 bits in crc register.
7336   BIND(L_fold_128b);
7337   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr()));
7338   if (UseAVX &gt; 0) {
7339     vpclmulqdq(xmm2, xmm0, xmm1, 0x1);
7340     vpand(xmm3, xmm0, xmm2, 0 /* vector_len */);
7341     vpclmulqdq(xmm0, xmm0, xmm3, 0x1);
7342   } else {
7343     movdqa(xmm2, xmm0);
7344     pclmulqdq(xmm2, xmm1, 0x1);
7345     movdqa(xmm3, xmm0);
7346     pand(xmm3, xmm2);
7347     pclmulqdq(xmm0, xmm3, 0x1);
7348   }
7349   psrldq(xmm1, 8);
7350   psrldq(xmm2, 4);
7351   pxor(xmm0, xmm1);
7352   pxor(xmm0, xmm2);
7353 
7354   // 8 8-bit folds to compute 32-bit CRC.
7355   for (int j = 0; j &lt; 4; j++) {
7356     fold_8bit_crc32(xmm0, table, xmm1, rax);
7357   }
7358   movdl(crc, xmm0); // mov 32 bits to general register
7359   for (int j = 0; j &lt; 4; j++) {
7360     fold_8bit_crc32(crc, table, rax);
7361   }
7362 
7363   BIND(L_tail_restore);
7364   movl(len, tmp); // restore
7365   BIND(L_tail);
7366   andl(len, 0xf);
7367   jccb(Assembler::zero, L_exit);
7368 
7369   // Fold the rest of bytes
7370   align(4);
7371   BIND(L_tail_loop);
7372   movsbl(rax, Address(buf, 0)); // load byte with sign extension
7373   update_byte_crc32(crc, rax, table);
7374   increment(buf);
7375   decrementl(len);
7376   jccb(Assembler::greater, L_tail_loop);
7377 
7378   BIND(L_exit);
7379   notl(crc); // ~c
7380 }
7381 
7382 #ifdef _LP64
7383 // Helper function for AVX 512 CRC32
7384 // Fold 512-bit data chunks
7385 void MacroAssembler::fold512bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf,
7386                                              Register pos, int offset) {
7387   evmovdquq(xmm3, Address(buf, pos, Address::times_1, offset), Assembler::AVX_512bit);
7388   evpclmulqdq(xtmp, xcrc, xK, 0x10, Assembler::AVX_512bit); // [123:64]
7389   evpclmulqdq(xmm2, xcrc, xK, 0x01, Assembler::AVX_512bit); // [63:0]
7390   evpxorq(xcrc, xtmp, xmm2, Assembler::AVX_512bit /* vector_len */);
7391   evpxorq(xcrc, xcrc, xmm3, Assembler::AVX_512bit /* vector_len */);
7392 }
7393 
7394 // Helper function for AVX 512 CRC32
7395 // Compute CRC32 for &lt; 256B buffers
7396 void MacroAssembler::kernel_crc32_avx512_256B(Register crc, Register buf, Register len, Register key, Register pos,
7397                                               Register tmp1, Register tmp2, Label&amp; L_barrett, Label&amp; L_16B_reduction_loop,
7398                                               Label&amp; L_get_last_two_xmms, Label&amp; L_128_done, Label&amp; L_cleanup) {
7399 
7400   Label L_less_than_32, L_exact_16_left, L_less_than_16_left;
7401   Label L_less_than_8_left, L_less_than_4_left, L_less_than_2_left, L_zero_left;
7402   Label L_only_less_than_4, L_only_less_than_3, L_only_less_than_2;
7403 
7404   // check if there is enough buffer to be able to fold 16B at a time
7405   cmpl(len, 32);
7406   jcc(Assembler::less, L_less_than_32);
7407 
7408   // if there is, load the constants
7409   movdqu(xmm10, Address(key, 1 * 16));    //rk1 and rk2 in xmm10
7410   movdl(xmm0, crc);                        // get the initial crc value
7411   movdqu(xmm7, Address(buf, pos, Address::times_1, 0 * 16)); //load the plaintext
7412   pxor(xmm7, xmm0);
7413 
7414   // update the buffer pointer
7415   addl(pos, 16);
7416   //update the counter.subtract 32 instead of 16 to save one instruction from the loop
7417   subl(len, 32);
7418   jmp(L_16B_reduction_loop);
7419 
7420   bind(L_less_than_32);
7421   //mov initial crc to the return value. this is necessary for zero - length buffers.
7422   movl(rax, crc);
7423   testl(len, len);
7424   jcc(Assembler::equal, L_cleanup);
7425 
7426   movdl(xmm0, crc);                        //get the initial crc value
7427 
7428   cmpl(len, 16);
7429   jcc(Assembler::equal, L_exact_16_left);
7430   jcc(Assembler::less, L_less_than_16_left);
7431 
7432   movdqu(xmm7, Address(buf, pos, Address::times_1, 0 * 16)); //load the plaintext
7433   pxor(xmm7, xmm0);                       //xor the initial crc value
7434   addl(pos, 16);
7435   subl(len, 16);
7436   movdqu(xmm10, Address(key, 1 * 16));    // rk1 and rk2 in xmm10
7437   jmp(L_get_last_two_xmms);
7438 
7439   bind(L_less_than_16_left);
7440   //use stack space to load data less than 16 bytes, zero - out the 16B in memory first.
7441   pxor(xmm1, xmm1);
7442   movptr(tmp1, rsp);
7443   movdqu(Address(tmp1, 0 * 16), xmm1);
7444 
7445   cmpl(len, 4);
7446   jcc(Assembler::less, L_only_less_than_4);
7447 
7448   //backup the counter value
7449   movl(tmp2, len);
7450   cmpl(len, 8);
7451   jcc(Assembler::less, L_less_than_8_left);
7452 
7453   //load 8 Bytes
7454   movq(rax, Address(buf, pos, Address::times_1, 0 * 16));
7455   movq(Address(tmp1, 0 * 16), rax);
7456   addptr(tmp1, 8);
7457   subl(len, 8);
7458   addl(pos, 8);
7459 
7460   bind(L_less_than_8_left);
7461   cmpl(len, 4);
7462   jcc(Assembler::less, L_less_than_4_left);
7463 
7464   //load 4 Bytes
7465   movl(rax, Address(buf, pos, Address::times_1, 0));
7466   movl(Address(tmp1, 0 * 16), rax);
7467   addptr(tmp1, 4);
7468   subl(len, 4);
7469   addl(pos, 4);
7470 
7471   bind(L_less_than_4_left);
7472   cmpl(len, 2);
7473   jcc(Assembler::less, L_less_than_2_left);
7474 
7475   // load 2 Bytes
7476   movw(rax, Address(buf, pos, Address::times_1, 0));
7477   movl(Address(tmp1, 0 * 16), rax);
7478   addptr(tmp1, 2);
7479   subl(len, 2);
7480   addl(pos, 2);
7481 
7482   bind(L_less_than_2_left);
7483   cmpl(len, 1);
7484   jcc(Assembler::less, L_zero_left);
7485 
7486   // load 1 Byte
7487   movb(rax, Address(buf, pos, Address::times_1, 0));
7488   movb(Address(tmp1, 0 * 16), rax);
7489 
7490   bind(L_zero_left);
7491   movdqu(xmm7, Address(rsp, 0));
7492   pxor(xmm7, xmm0);                       //xor the initial crc value
7493 
7494   lea(rax, ExternalAddress(StubRoutines::x86::shuf_table_crc32_avx512_addr()));
7495   movdqu(xmm0, Address(rax, tmp2));
7496   pshufb(xmm7, xmm0);
7497   jmp(L_128_done);
7498 
7499   bind(L_exact_16_left);
7500   movdqu(xmm7, Address(buf, pos, Address::times_1, 0));
7501   pxor(xmm7, xmm0);                       //xor the initial crc value
7502   jmp(L_128_done);
7503 
7504   bind(L_only_less_than_4);
7505   cmpl(len, 3);
7506   jcc(Assembler::less, L_only_less_than_3);
7507 
7508   // load 3 Bytes
7509   movb(rax, Address(buf, pos, Address::times_1, 0));
7510   movb(Address(tmp1, 0), rax);
7511 
7512   movb(rax, Address(buf, pos, Address::times_1, 1));
7513   movb(Address(tmp1, 1), rax);
7514 
7515   movb(rax, Address(buf, pos, Address::times_1, 2));
7516   movb(Address(tmp1, 2), rax);
7517 
7518   movdqu(xmm7, Address(rsp, 0));
7519   pxor(xmm7, xmm0);                     //xor the initial crc value
7520 
7521   pslldq(xmm7, 0x5);
7522   jmp(L_barrett);
7523   bind(L_only_less_than_3);
7524   cmpl(len, 2);
7525   jcc(Assembler::less, L_only_less_than_2);
7526 
7527   // load 2 Bytes
7528   movb(rax, Address(buf, pos, Address::times_1, 0));
7529   movb(Address(tmp1, 0), rax);
7530 
7531   movb(rax, Address(buf, pos, Address::times_1, 1));
7532   movb(Address(tmp1, 1), rax);
7533 
7534   movdqu(xmm7, Address(rsp, 0));
7535   pxor(xmm7, xmm0);                     //xor the initial crc value
7536 
7537   pslldq(xmm7, 0x6);
7538   jmp(L_barrett);
7539 
7540   bind(L_only_less_than_2);
7541   //load 1 Byte
7542   movb(rax, Address(buf, pos, Address::times_1, 0));
7543   movb(Address(tmp1, 0), rax);
7544 
7545   movdqu(xmm7, Address(rsp, 0));
7546   pxor(xmm7, xmm0);                     //xor the initial crc value
7547 
7548   pslldq(xmm7, 0x7);
7549 }
7550 
7551 /**
7552 * Compute CRC32 using AVX512 instructions
7553 * param crc   register containing existing CRC (32-bit)
7554 * param buf   register pointing to input byte buffer (byte*)
7555 * param len   register containing number of bytes
7556 * param tmp1  scratch register
7557 * param tmp2  scratch register
7558 * return rax  result register
7559 */
7560 void MacroAssembler::kernel_crc32_avx512(Register crc, Register buf, Register len, Register key, Register tmp1, Register tmp2) {
7561   assert_different_registers(crc, buf, len, key, tmp1, tmp2, rax);
7562 
7563   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
7564   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
7565   Label L_less_than_256, L_fold_128_B_loop, L_fold_256_B_loop;
7566   Label L_fold_128_B_register, L_final_reduction_for_128, L_16B_reduction_loop;
7567   Label L_128_done, L_get_last_two_xmms, L_barrett, L_cleanup;
7568 
7569   const Register pos = r12;
7570   push(r12);
7571   subptr(rsp, 16 * 2 + 8);
7572 
7573   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
7574   // context for the registers used, where all instructions below are using 128-bit mode
7575   // On EVEX without VL and BW, these instructions will all be AVX.
7576   lea(key, ExternalAddress(StubRoutines::x86::crc_table_avx512_addr()));
7577   notl(crc);
7578   movl(pos, 0);
7579 
7580   // check if smaller than 256B
7581   cmpl(len, 256);
7582   jcc(Assembler::less, L_less_than_256);
7583 
7584   // load the initial crc value
7585   movdl(xmm10, crc);
7586 
7587   // receive the initial 64B data, xor the initial crc value
7588   evmovdquq(xmm0, Address(buf, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);
7589   evmovdquq(xmm4, Address(buf, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);
7590   evpxorq(xmm0, xmm0, xmm10, Assembler::AVX_512bit);
7591   evbroadcasti32x4(xmm10, Address(key, 2 * 16), Assembler::AVX_512bit); //zmm10 has rk3 and rk4
7592 
7593   subl(len, 256);
7594   cmpl(len, 256);
7595   jcc(Assembler::less, L_fold_128_B_loop);
7596 
7597   evmovdquq(xmm7, Address(buf, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);
7598   evmovdquq(xmm8, Address(buf, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);
7599   evbroadcasti32x4(xmm16, Address(key, 0 * 16), Assembler::AVX_512bit); //zmm16 has rk-1 and rk-2
7600   subl(len, 256);
7601 
7602   bind(L_fold_256_B_loop);
7603   addl(pos, 256);
7604   fold512bit_crc32_avx512(xmm0, xmm16, xmm1, buf, pos, 0 * 64);
7605   fold512bit_crc32_avx512(xmm4, xmm16, xmm1, buf, pos, 1 * 64);
7606   fold512bit_crc32_avx512(xmm7, xmm16, xmm1, buf, pos, 2 * 64);
7607   fold512bit_crc32_avx512(xmm8, xmm16, xmm1, buf, pos, 3 * 64);
7608 
7609   subl(len, 256);
7610   jcc(Assembler::greaterEqual, L_fold_256_B_loop);
7611 
7612   // Fold 256 into 128
7613   addl(pos, 256);
7614   evpclmulqdq(xmm1, xmm0, xmm10, 0x01, Assembler::AVX_512bit);
7615   evpclmulqdq(xmm2, xmm0, xmm10, 0x10, Assembler::AVX_512bit);
7616   vpternlogq(xmm7, 0x96, xmm1, xmm2, Assembler::AVX_512bit); // xor ABC
7617 
7618   evpclmulqdq(xmm5, xmm4, xmm10, 0x01, Assembler::AVX_512bit);
7619   evpclmulqdq(xmm6, xmm4, xmm10, 0x10, Assembler::AVX_512bit);
7620   vpternlogq(xmm8, 0x96, xmm5, xmm6, Assembler::AVX_512bit); // xor ABC
7621 
7622   evmovdquq(xmm0, xmm7, Assembler::AVX_512bit);
7623   evmovdquq(xmm4, xmm8, Assembler::AVX_512bit);
7624 
7625   addl(len, 128);
7626   jmp(L_fold_128_B_register);
7627 
7628   // at this section of the code, there is 128 * x + y(0 &lt;= y&lt;128) bytes of buffer.The fold_128_B_loop
7629   // loop will fold 128B at a time until we have 128 + y Bytes of buffer
7630 
7631   // fold 128B at a time.This section of the code folds 8 xmm registers in parallel
7632   bind(L_fold_128_B_loop);
7633   addl(pos, 128);
7634   fold512bit_crc32_avx512(xmm0, xmm10, xmm1, buf, pos, 0 * 64);
7635   fold512bit_crc32_avx512(xmm4, xmm10, xmm1, buf, pos, 1 * 64);
7636 
7637   subl(len, 128);
7638   jcc(Assembler::greaterEqual, L_fold_128_B_loop);
7639 
7640   addl(pos, 128);
7641 
7642   // at this point, the buffer pointer is pointing at the last y Bytes of the buffer, where 0 &lt;= y &lt; 128
7643   // the 128B of folded data is in 8 of the xmm registers : xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7
7644   bind(L_fold_128_B_register);
7645   evmovdquq(xmm16, Address(key, 5 * 16), Assembler::AVX_512bit); // multiply by rk9-rk16
7646   evmovdquq(xmm11, Address(key, 9 * 16), Assembler::AVX_512bit); // multiply by rk17-rk20, rk1,rk2, 0,0
7647   evpclmulqdq(xmm1, xmm0, xmm16, 0x01, Assembler::AVX_512bit);
7648   evpclmulqdq(xmm2, xmm0, xmm16, 0x10, Assembler::AVX_512bit);
7649   // save last that has no multiplicand
7650   vextracti64x2(xmm7, xmm4, 3);
7651 
7652   evpclmulqdq(xmm5, xmm4, xmm11, 0x01, Assembler::AVX_512bit);
7653   evpclmulqdq(xmm6, xmm4, xmm11, 0x10, Assembler::AVX_512bit);
7654   // Needed later in reduction loop
7655   movdqu(xmm10, Address(key, 1 * 16));
7656   vpternlogq(xmm1, 0x96, xmm2, xmm5, Assembler::AVX_512bit); // xor ABC
7657   vpternlogq(xmm1, 0x96, xmm6, xmm7, Assembler::AVX_512bit); // xor ABC
7658 
7659   // Swap 1,0,3,2 - 01 00 11 10
7660   evshufi64x2(xmm8, xmm1, xmm1, 0x4e, Assembler::AVX_512bit);
7661   evpxorq(xmm8, xmm8, xmm1, Assembler::AVX_256bit);
7662   vextracti128(xmm5, xmm8, 1);
7663   evpxorq(xmm7, xmm5, xmm8, Assembler::AVX_128bit);
7664 
7665   // instead of 128, we add 128 - 16 to the loop counter to save 1 instruction from the loop
7666   // instead of a cmp instruction, we use the negative flag with the jl instruction
7667   addl(len, 128 - 16);
7668   jcc(Assembler::less, L_final_reduction_for_128);
7669 
7670   bind(L_16B_reduction_loop);
7671   vpclmulqdq(xmm8, xmm7, xmm10, 0x1);
7672   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);
7673   vpxor(xmm7, xmm7, xmm8, Assembler::AVX_128bit);
7674   movdqu(xmm0, Address(buf, pos, Address::times_1, 0 * 16));
7675   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
7676   addl(pos, 16);
7677   subl(len, 16);
7678   jcc(Assembler::greaterEqual, L_16B_reduction_loop);
7679 
7680   bind(L_final_reduction_for_128);
7681   addl(len, 16);
7682   jcc(Assembler::equal, L_128_done);
7683 
7684   bind(L_get_last_two_xmms);
7685   movdqu(xmm2, xmm7);
7686   addl(pos, len);
7687   movdqu(xmm1, Address(buf, pos, Address::times_1, -16));
7688   subl(pos, len);
7689 
7690   // get rid of the extra data that was loaded before
7691   // load the shift constant
7692   lea(rax, ExternalAddress(StubRoutines::x86::shuf_table_crc32_avx512_addr()));
7693   movdqu(xmm0, Address(rax, len));
7694   addl(rax, len);
7695 
7696   vpshufb(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
7697   //Change mask to 512
7698   vpxor(xmm0, xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr() + 2 * 16), Assembler::AVX_128bit, tmp2);
7699   vpshufb(xmm2, xmm2, xmm0, Assembler::AVX_128bit);
7700 
7701   blendvpb(xmm2, xmm2, xmm1, xmm0, Assembler::AVX_128bit);
7702   vpclmulqdq(xmm8, xmm7, xmm10, 0x1);
7703   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);
7704   vpxor(xmm7, xmm7, xmm8, Assembler::AVX_128bit);
7705   vpxor(xmm7, xmm7, xmm2, Assembler::AVX_128bit);
7706 
7707   bind(L_128_done);
7708   // compute crc of a 128-bit value
7709   movdqu(xmm10, Address(key, 3 * 16));
7710   movdqu(xmm0, xmm7);
7711 
7712   // 64b fold
7713   vpclmulqdq(xmm7, xmm7, xmm10, 0x0);
7714   vpsrldq(xmm0, xmm0, 0x8, Assembler::AVX_128bit);
7715   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
7716 
7717   // 32b fold
7718   movdqu(xmm0, xmm7);
7719   vpslldq(xmm7, xmm7, 0x4, Assembler::AVX_128bit);
7720   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);
7721   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
7722   jmp(L_barrett);
7723 
7724   bind(L_less_than_256);
7725   kernel_crc32_avx512_256B(crc, buf, len, key, pos, tmp1, tmp2, L_barrett, L_16B_reduction_loop, L_get_last_two_xmms, L_128_done, L_cleanup);
7726 
7727   //barrett reduction
7728   bind(L_barrett);
7729   vpand(xmm7, xmm7, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr() + 1 * 16), Assembler::AVX_128bit, tmp2);
7730   movdqu(xmm1, xmm7);
7731   movdqu(xmm2, xmm7);
7732   movdqu(xmm10, Address(key, 4 * 16));
7733 
7734   pclmulqdq(xmm7, xmm10, 0x0);
7735   pxor(xmm7, xmm2);
7736   vpand(xmm7, xmm7, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr()), Assembler::AVX_128bit, tmp2);
7737   movdqu(xmm2, xmm7);
7738   pclmulqdq(xmm7, xmm10, 0x10);
7739   pxor(xmm7, xmm2);
7740   pxor(xmm7, xmm1);
7741   pextrd(crc, xmm7, 2);
7742 
7743   bind(L_cleanup);
7744   notl(crc); // ~c
7745   addptr(rsp, 16 * 2 + 8);
7746   pop(r12);
7747 }
7748 
7749 // S. Gueron / Information Processing Letters 112 (2012) 184
7750 // Algorithm 4: Computing carry-less multiplication using a precomputed lookup table.
7751 // Input: A 32 bit value B = [byte3, byte2, byte1, byte0].
7752 // Output: the 64-bit carry-less product of B * CONST
7753 void MacroAssembler::crc32c_ipl_alg4(Register in, uint32_t n,
7754                                      Register tmp1, Register tmp2, Register tmp3) {
7755   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7756   if (n &gt; 0) {
7757     addq(tmp3, n * 256 * 8);
7758   }
7759   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7760   movl(tmp1, in);
7761   andl(tmp1, 0x000000FF);
7762   shll(tmp1, 3);
7763   addq(tmp1, tmp3);
7764   movq(tmp1, Address(tmp1, 0));
7765 
7766   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7767   movl(tmp2, in);
7768   shrl(tmp2, 8);
7769   andl(tmp2, 0x000000FF);
7770   shll(tmp2, 3);
7771   addq(tmp2, tmp3);
7772   movq(tmp2, Address(tmp2, 0));
7773 
7774   shlq(tmp2, 8);
7775   xorq(tmp1, tmp2);
7776 
7777   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
7778   movl(tmp2, in);
7779   shrl(tmp2, 16);
7780   andl(tmp2, 0x000000FF);
7781   shll(tmp2, 3);
7782   addq(tmp2, tmp3);
7783   movq(tmp2, Address(tmp2, 0));
7784 
7785   shlq(tmp2, 16);
7786   xorq(tmp1, tmp2);
7787 
7788   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
7789   shrl(in, 24);
7790   andl(in, 0x000000FF);
7791   shll(in, 3);
7792   addq(in, tmp3);
7793   movq(in, Address(in, 0));
7794 
7795   shlq(in, 24);
7796   xorq(in, tmp1);
7797   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
7798 }
7799 
7800 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
7801                                       Register in_out,
7802                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
7803                                       XMMRegister w_xtmp2,
7804                                       Register tmp1,
7805                                       Register n_tmp2, Register n_tmp3) {
7806   if (is_pclmulqdq_supported) {
7807     movdl(w_xtmp1, in_out); // modified blindly
7808 
7809     movl(tmp1, const_or_pre_comp_const_index);
7810     movdl(w_xtmp2, tmp1);
7811     pclmulqdq(w_xtmp1, w_xtmp2, 0);
7812 
7813     movdq(in_out, w_xtmp1);
7814   } else {
7815     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3);
7816   }
7817 }
7818 
7819 // Recombination Alternative 2: No bit-reflections
7820 // T1 = (CRC_A * U1) &lt;&lt; 1
7821 // T2 = (CRC_B * U2) &lt;&lt; 1
7822 // C1 = T1 &gt;&gt; 32
7823 // C2 = T2 &gt;&gt; 32
7824 // T1 = T1 &amp; 0xFFFFFFFF
7825 // T2 = T2 &amp; 0xFFFFFFFF
7826 // T1 = CRC32(0, T1)
7827 // T2 = CRC32(0, T2)
7828 // C1 = C1 ^ T1
7829 // C2 = C2 ^ T2
7830 // CRC = C1 ^ C2 ^ CRC_C
7831 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
7832                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7833                                      Register tmp1, Register tmp2,
7834                                      Register n_tmp3) {
7835   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7836   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7837   shlq(in_out, 1);
7838   movl(tmp1, in_out);
7839   shrq(in_out, 32);
7840   xorl(tmp2, tmp2);
7841   crc32(tmp2, tmp1, 4);
7842   xorl(in_out, tmp2); // we don&#39;t care about upper 32 bit contents here
7843   shlq(in1, 1);
7844   movl(tmp1, in1);
7845   shrq(in1, 32);
7846   xorl(tmp2, tmp2);
7847   crc32(tmp2, tmp1, 4);
7848   xorl(in1, tmp2);
7849   xorl(in_out, in1);
7850   xorl(in_out, in2);
7851 }
7852 
7853 // Set N to predefined value
7854 // Subtract from a lenght of a buffer
7855 // execute in a loop:
7856 // CRC_A = 0xFFFFFFFF, CRC_B = 0, CRC_C = 0
7857 // for i = 1 to N do
7858 //  CRC_A = CRC32(CRC_A, A[i])
7859 //  CRC_B = CRC32(CRC_B, B[i])
7860 //  CRC_C = CRC32(CRC_C, C[i])
7861 // end for
7862 // Recombine
7863 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
7864                                        Register in_out1, Register in_out2, Register in_out3,
7865                                        Register tmp1, Register tmp2, Register tmp3,
7866                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7867                                        Register tmp4, Register tmp5,
7868                                        Register n_tmp6) {
7869   Label L_processPartitions;
7870   Label L_processPartition;
7871   Label L_exit;
7872 
7873   bind(L_processPartitions);
7874   cmpl(in_out1, 3 * size);
7875   jcc(Assembler::less, L_exit);
7876     xorl(tmp1, tmp1);
7877     xorl(tmp2, tmp2);
7878     movq(tmp3, in_out2);
7879     addq(tmp3, size);
7880 
7881     bind(L_processPartition);
7882       crc32(in_out3, Address(in_out2, 0), 8);
7883       crc32(tmp1, Address(in_out2, size), 8);
7884       crc32(tmp2, Address(in_out2, size * 2), 8);
7885       addq(in_out2, 8);
7886       cmpq(in_out2, tmp3);
7887       jcc(Assembler::less, L_processPartition);
7888     crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
7889             w_xtmp1, w_xtmp2, w_xtmp3,
7890             tmp4, tmp5,
7891             n_tmp6);
7892     addq(in_out2, 2 * size);
7893     subl(in_out1, 3 * size);
7894     jmp(L_processPartitions);
7895 
7896   bind(L_exit);
7897 }
7898 #else
7899 void MacroAssembler::crc32c_ipl_alg4(Register in_out, uint32_t n,
7900                                      Register tmp1, Register tmp2, Register tmp3,
7901                                      XMMRegister xtmp1, XMMRegister xtmp2) {
7902   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7903   if (n &gt; 0) {
7904     addl(tmp3, n * 256 * 8);
7905   }
7906   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7907   movl(tmp1, in_out);
7908   andl(tmp1, 0x000000FF);
7909   shll(tmp1, 3);
7910   addl(tmp1, tmp3);
7911   movq(xtmp1, Address(tmp1, 0));
7912 
7913   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7914   movl(tmp2, in_out);
7915   shrl(tmp2, 8);
7916   andl(tmp2, 0x000000FF);
7917   shll(tmp2, 3);
7918   addl(tmp2, tmp3);
7919   movq(xtmp2, Address(tmp2, 0));
7920 
7921   psllq(xtmp2, 8);
7922   pxor(xtmp1, xtmp2);
7923 
7924   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
7925   movl(tmp2, in_out);
7926   shrl(tmp2, 16);
7927   andl(tmp2, 0x000000FF);
7928   shll(tmp2, 3);
7929   addl(tmp2, tmp3);
7930   movq(xtmp2, Address(tmp2, 0));
7931 
7932   psllq(xtmp2, 16);
7933   pxor(xtmp1, xtmp2);
7934 
7935   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
7936   shrl(in_out, 24);
7937   andl(in_out, 0x000000FF);
7938   shll(in_out, 3);
7939   addl(in_out, tmp3);
7940   movq(xtmp2, Address(in_out, 0));
7941 
7942   psllq(xtmp2, 24);
7943   pxor(xtmp1, xtmp2); // Result in CXMM
7944   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
7945 }
7946 
7947 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
7948                                       Register in_out,
7949                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
7950                                       XMMRegister w_xtmp2,
7951                                       Register tmp1,
7952                                       Register n_tmp2, Register n_tmp3) {
7953   if (is_pclmulqdq_supported) {
7954     movdl(w_xtmp1, in_out);
7955 
7956     movl(tmp1, const_or_pre_comp_const_index);
7957     movdl(w_xtmp2, tmp1);
7958     pclmulqdq(w_xtmp1, w_xtmp2, 0);
7959     // Keep result in XMM since GPR is 32 bit in length
7960   } else {
7961     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3, w_xtmp1, w_xtmp2);
7962   }
7963 }
7964 
7965 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
7966                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7967                                      Register tmp1, Register tmp2,
7968                                      Register n_tmp3) {
7969   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7970   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7971 
7972   psllq(w_xtmp1, 1);
7973   movdl(tmp1, w_xtmp1);
7974   psrlq(w_xtmp1, 32);
7975   movdl(in_out, w_xtmp1);
7976 
7977   xorl(tmp2, tmp2);
7978   crc32(tmp2, tmp1, 4);
7979   xorl(in_out, tmp2);
7980 
7981   psllq(w_xtmp2, 1);
7982   movdl(tmp1, w_xtmp2);
7983   psrlq(w_xtmp2, 32);
7984   movdl(in1, w_xtmp2);
7985 
7986   xorl(tmp2, tmp2);
7987   crc32(tmp2, tmp1, 4);
7988   xorl(in1, tmp2);
7989   xorl(in_out, in1);
7990   xorl(in_out, in2);
7991 }
7992 
7993 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
7994                                        Register in_out1, Register in_out2, Register in_out3,
7995                                        Register tmp1, Register tmp2, Register tmp3,
7996                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7997                                        Register tmp4, Register tmp5,
7998                                        Register n_tmp6) {
7999   Label L_processPartitions;
8000   Label L_processPartition;
8001   Label L_exit;
8002 
8003   bind(L_processPartitions);
8004   cmpl(in_out1, 3 * size);
8005   jcc(Assembler::less, L_exit);
8006     xorl(tmp1, tmp1);
8007     xorl(tmp2, tmp2);
8008     movl(tmp3, in_out2);
8009     addl(tmp3, size);
8010 
8011     bind(L_processPartition);
8012       crc32(in_out3, Address(in_out2, 0), 4);
8013       crc32(tmp1, Address(in_out2, size), 4);
8014       crc32(tmp2, Address(in_out2, size*2), 4);
8015       crc32(in_out3, Address(in_out2, 0+4), 4);
8016       crc32(tmp1, Address(in_out2, size+4), 4);
8017       crc32(tmp2, Address(in_out2, size*2+4), 4);
8018       addl(in_out2, 8);
8019       cmpl(in_out2, tmp3);
8020       jcc(Assembler::less, L_processPartition);
8021 
8022         push(tmp3);
8023         push(in_out1);
8024         push(in_out2);
8025         tmp4 = tmp3;
8026         tmp5 = in_out1;
8027         n_tmp6 = in_out2;
8028 
8029       crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
8030             w_xtmp1, w_xtmp2, w_xtmp3,
8031             tmp4, tmp5,
8032             n_tmp6);
8033 
8034         pop(in_out2);
8035         pop(in_out1);
8036         pop(tmp3);
8037 
8038     addl(in_out2, 2 * size);
8039     subl(in_out1, 3 * size);
8040     jmp(L_processPartitions);
8041 
8042   bind(L_exit);
8043 }
8044 #endif //LP64
8045 
8046 #ifdef _LP64
8047 // Algorithm 2: Pipelined usage of the CRC32 instruction.
8048 // Input: A buffer I of L bytes.
8049 // Output: the CRC32C value of the buffer.
8050 // Notations:
8051 // Write L = 24N + r, with N = floor (L/24).
8052 // r = L mod 24 (0 &lt;= r &lt; 24).
8053 // Consider I as the concatenation of A|B|C|R, where A, B, C, each,
8054 // N quadwords, and R consists of r bytes.
8055 // A[j] = I [8j+7:8j], j= 0, 1, ..., N-1
8056 // B[j] = I [N + 8j+7:N + 8j], j= 0, 1, ..., N-1
8057 // C[j] = I [2N + 8j+7:2N + 8j], j= 0, 1, ..., N-1
8058 // if r &gt; 0 R[j] = I [3N +j], j= 0, 1, ...,r-1
8059 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
8060                                           Register tmp1, Register tmp2, Register tmp3,
8061                                           Register tmp4, Register tmp5, Register tmp6,
8062                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
8063                                           bool is_pclmulqdq_supported) {
8064   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
8065   Label L_wordByWord;
8066   Label L_byteByByteProlog;
8067   Label L_byteByByte;
8068   Label L_exit;
8069 
8070   if (is_pclmulqdq_supported ) {
8071     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
8072     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr+1);
8073 
8074     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
8075     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
8076 
8077     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
8078     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
8079     assert((CRC32C_NUM_PRECOMPUTED_CONSTANTS - 1 ) == 5, &quot;Checking whether you declared all of the constants based on the number of \&quot;chunks\&quot;&quot;);
8080   } else {
8081     const_or_pre_comp_const_index[0] = 1;
8082     const_or_pre_comp_const_index[1] = 0;
8083 
8084     const_or_pre_comp_const_index[2] = 3;
8085     const_or_pre_comp_const_index[3] = 2;
8086 
8087     const_or_pre_comp_const_index[4] = 5;
8088     const_or_pre_comp_const_index[5] = 4;
8089    }
8090   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
8091                     in2, in1, in_out,
8092                     tmp1, tmp2, tmp3,
8093                     w_xtmp1, w_xtmp2, w_xtmp3,
8094                     tmp4, tmp5,
8095                     tmp6);
8096   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
8097                     in2, in1, in_out,
8098                     tmp1, tmp2, tmp3,
8099                     w_xtmp1, w_xtmp2, w_xtmp3,
8100                     tmp4, tmp5,
8101                     tmp6);
8102   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
8103                     in2, in1, in_out,
8104                     tmp1, tmp2, tmp3,
8105                     w_xtmp1, w_xtmp2, w_xtmp3,
8106                     tmp4, tmp5,
8107                     tmp6);
8108   movl(tmp1, in2);
8109   andl(tmp1, 0x00000007);
8110   negl(tmp1);
8111   addl(tmp1, in2);
8112   addq(tmp1, in1);
8113 
8114   BIND(L_wordByWord);
8115   cmpq(in1, tmp1);
8116   jcc(Assembler::greaterEqual, L_byteByByteProlog);
8117     crc32(in_out, Address(in1, 0), 4);
8118     addq(in1, 4);
8119     jmp(L_wordByWord);
8120 
8121   BIND(L_byteByByteProlog);
8122   andl(in2, 0x00000007);
8123   movl(tmp2, 1);
8124 
8125   BIND(L_byteByByte);
8126   cmpl(tmp2, in2);
8127   jccb(Assembler::greater, L_exit);
8128     crc32(in_out, Address(in1, 0), 1);
8129     incq(in1);
8130     incl(tmp2);
8131     jmp(L_byteByByte);
8132 
8133   BIND(L_exit);
8134 }
8135 #else
8136 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
8137                                           Register tmp1, Register  tmp2, Register tmp3,
8138                                           Register tmp4, Register  tmp5, Register tmp6,
8139                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
8140                                           bool is_pclmulqdq_supported) {
8141   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
8142   Label L_wordByWord;
8143   Label L_byteByByteProlog;
8144   Label L_byteByByte;
8145   Label L_exit;
8146 
8147   if (is_pclmulqdq_supported) {
8148     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
8149     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 1);
8150 
8151     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
8152     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
8153 
8154     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
8155     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
8156   } else {
8157     const_or_pre_comp_const_index[0] = 1;
8158     const_or_pre_comp_const_index[1] = 0;
8159 
8160     const_or_pre_comp_const_index[2] = 3;
8161     const_or_pre_comp_const_index[3] = 2;
8162 
8163     const_or_pre_comp_const_index[4] = 5;
8164     const_or_pre_comp_const_index[5] = 4;
8165   }
8166   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
8167                     in2, in1, in_out,
8168                     tmp1, tmp2, tmp3,
8169                     w_xtmp1, w_xtmp2, w_xtmp3,
8170                     tmp4, tmp5,
8171                     tmp6);
8172   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
8173                     in2, in1, in_out,
8174                     tmp1, tmp2, tmp3,
8175                     w_xtmp1, w_xtmp2, w_xtmp3,
8176                     tmp4, tmp5,
8177                     tmp6);
8178   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
8179                     in2, in1, in_out,
8180                     tmp1, tmp2, tmp3,
8181                     w_xtmp1, w_xtmp2, w_xtmp3,
8182                     tmp4, tmp5,
8183                     tmp6);
8184   movl(tmp1, in2);
8185   andl(tmp1, 0x00000007);
8186   negl(tmp1);
8187   addl(tmp1, in2);
8188   addl(tmp1, in1);
8189 
8190   BIND(L_wordByWord);
8191   cmpl(in1, tmp1);
8192   jcc(Assembler::greaterEqual, L_byteByByteProlog);
8193     crc32(in_out, Address(in1,0), 4);
8194     addl(in1, 4);
8195     jmp(L_wordByWord);
8196 
8197   BIND(L_byteByByteProlog);
8198   andl(in2, 0x00000007);
8199   movl(tmp2, 1);
8200 
8201   BIND(L_byteByByte);
8202   cmpl(tmp2, in2);
8203   jccb(Assembler::greater, L_exit);
8204     movb(tmp1, Address(in1, 0));
8205     crc32(in_out, tmp1, 1);
8206     incl(in1);
8207     incl(tmp2);
8208     jmp(L_byteByByte);
8209 
8210   BIND(L_exit);
8211 }
8212 #endif // LP64
8213 #undef BIND
8214 #undef BLOCK_COMMENT
8215 
8216 // Compress char[] array to byte[].
8217 //   ..\jdk\src\java.base\share\classes\java\lang\StringUTF16.java
8218 //   @HotSpotIntrinsicCandidate
8219 //   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {
8220 //     for (int i = 0; i &lt; len; i++) {
8221 //       int c = src[srcOff++];
8222 //       if (c &gt;&gt;&gt; 8 != 0) {
8223 //         return 0;
8224 //       }
8225 //       dst[dstOff++] = (byte)c;
8226 //     }
8227 //     return len;
8228 //   }
8229 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
8230   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
8231   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
8232   Register tmp5, Register result) {
8233   Label copy_chars_loop, return_length, return_zero, done;
8234 
8235   // rsi: src
8236   // rdi: dst
8237   // rdx: len
8238   // rcx: tmp5
8239   // rax: result
8240 
8241   // rsi holds start addr of source char[] to be compressed
8242   // rdi holds start addr of destination byte[]
8243   // rdx holds length
8244 
8245   assert(len != result, &quot;&quot;);
8246 
8247   // save length for return
8248   push(len);
8249 
8250   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512
8251     VM_Version::supports_avx512vlbw() &amp;&amp;
8252     VM_Version::supports_bmi2()) {
8253 
8254     Label copy_32_loop, copy_loop_tail, below_threshold;
8255 
8256     // alignment
8257     Label post_alignment;
8258 
8259     // if length of the string is less than 16, handle it in an old fashioned way
8260     testl(len, -32);
8261     jcc(Assembler::zero, below_threshold);
8262 
8263     // First check whether a character is compressable ( &lt;= 0xFF).
8264     // Create mask to test for Unicode chars inside zmm vector
8265     movl(result, 0x00FF);
8266     evpbroadcastw(tmp2Reg, result, Assembler::AVX_512bit);
8267 
8268     testl(len, -64);
8269     jcc(Assembler::zero, post_alignment);
8270 
8271     movl(tmp5, dst);
8272     andl(tmp5, (32 - 1));
8273     negl(tmp5);
8274     andl(tmp5, (32 - 1));
8275 
8276     // bail out when there is nothing to be done
8277     testl(tmp5, 0xFFFFFFFF);
8278     jcc(Assembler::zero, post_alignment);
8279 
8280     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
8281     movl(result, 0xFFFFFFFF);
8282     shlxl(result, result, tmp5);
8283     notl(result);
8284     kmovdl(k3, result);
8285 
8286     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
8287     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
8288     ktestd(k2, k3);
8289     jcc(Assembler::carryClear, return_zero);
8290 
8291     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
8292 
8293     addptr(src, tmp5);
8294     addptr(src, tmp5);
8295     addptr(dst, tmp5);
8296     subl(len, tmp5);
8297 
8298     bind(post_alignment);
8299     // end of alignment
8300 
8301     movl(tmp5, len);
8302     andl(tmp5, (32 - 1));    // tail count (in chars)
8303     andl(len, ~(32 - 1));    // vector count (in chars)
8304     jcc(Assembler::zero, copy_loop_tail);
8305 
8306     lea(src, Address(src, len, Address::times_2));
8307     lea(dst, Address(dst, len, Address::times_1));
8308     negptr(len);
8309 
8310     bind(copy_32_loop);
8311     evmovdquw(tmp1Reg, Address(src, len, Address::times_2), Assembler::AVX_512bit);
8312     evpcmpuw(k2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
8313     kortestdl(k2, k2);
8314     jcc(Assembler::carryClear, return_zero);
8315 
8316     // All elements in current processed chunk are valid candidates for
8317     // compression. Write a truncated byte elements to the memory.
8318     evpmovwb(Address(dst, len, Address::times_1), tmp1Reg, Assembler::AVX_512bit);
8319     addptr(len, 32);
8320     jcc(Assembler::notZero, copy_32_loop);
8321 
8322     bind(copy_loop_tail);
8323     // bail out when there is nothing to be done
8324     testl(tmp5, 0xFFFFFFFF);
8325     jcc(Assembler::zero, return_length);
8326 
8327     movl(len, tmp5);
8328 
8329     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
8330     movl(result, 0xFFFFFFFF);
8331     shlxl(result, result, len);
8332     notl(result);
8333 
8334     kmovdl(k3, result);
8335 
8336     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
8337     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
8338     ktestd(k2, k3);
8339     jcc(Assembler::carryClear, return_zero);
8340 
8341     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
8342     jmp(return_length);
8343 
8344     bind(below_threshold);
8345   }
8346 
8347   if (UseSSE42Intrinsics) {
8348     Label copy_32_loop, copy_16, copy_tail;
8349 
8350     movl(result, len);
8351 
8352     movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vectors
8353 
8354     // vectored compression
8355     andl(len, 0xfffffff0);    // vector count (in chars)
8356     andl(result, 0x0000000f);    // tail count (in chars)
8357     testl(len, len);
8358     jcc(Assembler::zero, copy_16);
8359 
8360     // compress 16 chars per iter
8361     movdl(tmp1Reg, tmp5);
8362     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
8363     pxor(tmp4Reg, tmp4Reg);
8364 
8365     lea(src, Address(src, len, Address::times_2));
8366     lea(dst, Address(dst, len, Address::times_1));
8367     negptr(len);
8368 
8369     bind(copy_32_loop);
8370     movdqu(tmp2Reg, Address(src, len, Address::times_2));     // load 1st 8 characters
8371     por(tmp4Reg, tmp2Reg);
8372     movdqu(tmp3Reg, Address(src, len, Address::times_2, 16)); // load next 8 characters
8373     por(tmp4Reg, tmp3Reg);
8374     ptest(tmp4Reg, tmp1Reg);       // check for Unicode chars in next vector
8375     jcc(Assembler::notZero, return_zero);
8376     packuswb(tmp2Reg, tmp3Reg);    // only ASCII chars; compress each to 1 byte
8377     movdqu(Address(dst, len, Address::times_1), tmp2Reg);
8378     addptr(len, 16);
8379     jcc(Assembler::notZero, copy_32_loop);
8380 
8381     // compress next vector of 8 chars (if any)
8382     bind(copy_16);
8383     movl(len, result);
8384     andl(len, 0xfffffff8);    // vector count (in chars)
8385     andl(result, 0x00000007);    // tail count (in chars)
8386     testl(len, len);
8387     jccb(Assembler::zero, copy_tail);
8388 
8389     movdl(tmp1Reg, tmp5);
8390     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
8391     pxor(tmp3Reg, tmp3Reg);
8392 
8393     movdqu(tmp2Reg, Address(src, 0));
8394     ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in vector
8395     jccb(Assembler::notZero, return_zero);
8396     packuswb(tmp2Reg, tmp3Reg);    // only LATIN1 chars; compress each to 1 byte
8397     movq(Address(dst, 0), tmp2Reg);
8398     addptr(src, 16);
8399     addptr(dst, 8);
8400 
8401     bind(copy_tail);
8402     movl(len, result);
8403   }
8404   // compress 1 char per iter
8405   testl(len, len);
8406   jccb(Assembler::zero, return_length);
8407   lea(src, Address(src, len, Address::times_2));
8408   lea(dst, Address(dst, len, Address::times_1));
8409   negptr(len);
8410 
8411   bind(copy_chars_loop);
8412   load_unsigned_short(result, Address(src, len, Address::times_2));
8413   testl(result, 0xff00);      // check if Unicode char
8414   jccb(Assembler::notZero, return_zero);
8415   movb(Address(dst, len, Address::times_1), result);  // ASCII char; compress to 1 byte
8416   increment(len);
8417   jcc(Assembler::notZero, copy_chars_loop);
8418 
8419   // if compression succeeded, return length
8420   bind(return_length);
8421   pop(result);
8422   jmpb(done);
8423 
8424   // if compression failed, return 0
8425   bind(return_zero);
8426   xorl(result, result);
8427   addptr(rsp, wordSize);
8428 
8429   bind(done);
8430 }
8431 
8432 // Inflate byte[] array to char[].
8433 //   ..\jdk\src\java.base\share\classes\java\lang\StringLatin1.java
8434 //   @HotSpotIntrinsicCandidate
8435 //   private static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {
8436 //     for (int i = 0; i &lt; len; i++) {
8437 //       dst[dstOff++] = (char)(src[srcOff++] &amp; 0xff);
8438 //     }
8439 //   }
8440 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
8441   XMMRegister tmp1, Register tmp2) {
8442   Label copy_chars_loop, done, below_threshold, avx3_threshold;
8443   // rsi: src
8444   // rdi: dst
8445   // rdx: len
8446   // rcx: tmp2
8447 
8448   // rsi holds start addr of source byte[] to be inflated
8449   // rdi holds start addr of destination char[]
8450   // rdx holds length
8451   assert_different_registers(src, dst, len, tmp2);
8452   movl(tmp2, len);
8453   if ((UseAVX &gt; 2) &amp;&amp; // AVX512
8454     VM_Version::supports_avx512vlbw() &amp;&amp;
8455     VM_Version::supports_bmi2()) {
8456 
8457     Label copy_32_loop, copy_tail;
8458     Register tmp3_aliased = len;
8459 
8460     // if length of the string is less than 16, handle it in an old fashioned way
8461     testl(len, -16);
8462     jcc(Assembler::zero, below_threshold);
8463 
8464     testl(len, -1 * AVX3Threshold);
8465     jcc(Assembler::zero, avx3_threshold);
8466 
8467     // In order to use only one arithmetic operation for the main loop we use
8468     // this pre-calculation
8469     andl(tmp2, (32 - 1)); // tail count (in chars), 32 element wide loop
8470     andl(len, -32);     // vector count
8471     jccb(Assembler::zero, copy_tail);
8472 
8473     lea(src, Address(src, len, Address::times_1));
8474     lea(dst, Address(dst, len, Address::times_2));
8475     negptr(len);
8476 
8477 
8478     // inflate 32 chars per iter
8479     bind(copy_32_loop);
8480     vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_512bit);
8481     evmovdquw(Address(dst, len, Address::times_2), tmp1, Assembler::AVX_512bit);
8482     addptr(len, 32);
8483     jcc(Assembler::notZero, copy_32_loop);
8484 
8485     bind(copy_tail);
8486     // bail out when there is nothing to be done
8487     testl(tmp2, -1); // we don&#39;t destroy the contents of tmp2 here
8488     jcc(Assembler::zero, done);
8489 
8490     // ~(~0 &lt;&lt; length), where length is the # of remaining elements to process
8491     movl(tmp3_aliased, -1);
8492     shlxl(tmp3_aliased, tmp3_aliased, tmp2);
8493     notl(tmp3_aliased);
8494     kmovdl(k2, tmp3_aliased);
8495     evpmovzxbw(tmp1, k2, Address(src, 0), Assembler::AVX_512bit);
8496     evmovdquw(Address(dst, 0), k2, tmp1, Assembler::AVX_512bit);
8497 
8498     jmp(done);
8499     bind(avx3_threshold);
8500   }
8501   if (UseSSE42Intrinsics) {
8502     Label copy_16_loop, copy_8_loop, copy_bytes, copy_new_tail, copy_tail;
8503 
8504     if (UseAVX &gt; 1) {
8505       andl(tmp2, (16 - 1));
8506       andl(len, -16);
8507       jccb(Assembler::zero, copy_new_tail);
8508     } else {
8509       andl(tmp2, 0x00000007);   // tail count (in chars)
8510       andl(len, 0xfffffff8);    // vector count (in chars)
8511       jccb(Assembler::zero, copy_tail);
8512     }
8513 
8514     // vectored inflation
8515     lea(src, Address(src, len, Address::times_1));
8516     lea(dst, Address(dst, len, Address::times_2));
8517     negptr(len);
8518 
8519     if (UseAVX &gt; 1) {
8520       bind(copy_16_loop);
8521       vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_256bit);
8522       vmovdqu(Address(dst, len, Address::times_2), tmp1);
8523       addptr(len, 16);
8524       jcc(Assembler::notZero, copy_16_loop);
8525 
8526       bind(below_threshold);
8527       bind(copy_new_tail);
8528       movl(len, tmp2);
8529       andl(tmp2, 0x00000007);
8530       andl(len, 0xFFFFFFF8);
8531       jccb(Assembler::zero, copy_tail);
8532 
8533       pmovzxbw(tmp1, Address(src, 0));
8534       movdqu(Address(dst, 0), tmp1);
8535       addptr(src, 8);
8536       addptr(dst, 2 * 8);
8537 
8538       jmp(copy_tail, true);
8539     }
8540 
8541     // inflate 8 chars per iter
8542     bind(copy_8_loop);
8543     pmovzxbw(tmp1, Address(src, len, Address::times_1));  // unpack to 8 words
8544     movdqu(Address(dst, len, Address::times_2), tmp1);
8545     addptr(len, 8);
8546     jcc(Assembler::notZero, copy_8_loop);
8547 
8548     bind(copy_tail);
8549     movl(len, tmp2);
8550 
8551     cmpl(len, 4);
8552     jccb(Assembler::less, copy_bytes);
8553 
8554     movdl(tmp1, Address(src, 0));  // load 4 byte chars
8555     pmovzxbw(tmp1, tmp1);
8556     movq(Address(dst, 0), tmp1);
8557     subptr(len, 4);
8558     addptr(src, 4);
8559     addptr(dst, 8);
8560 
8561     bind(copy_bytes);
8562   } else {
8563     bind(below_threshold);
8564   }
8565 
8566   testl(len, len);
8567   jccb(Assembler::zero, done);
8568   lea(src, Address(src, len, Address::times_1));
8569   lea(dst, Address(dst, len, Address::times_2));
8570   negptr(len);
8571 
8572   // inflate 1 char per iter
8573   bind(copy_chars_loop);
8574   load_unsigned_byte(tmp2, Address(src, len, Address::times_1));  // load byte char
8575   movw(Address(dst, len, Address::times_2), tmp2);  // inflate byte char to word
8576   increment(len);
8577   jcc(Assembler::notZero, copy_chars_loop);
8578 
8579   bind(done);
8580 }
8581 
8582 #ifdef _LP64
8583 void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {
8584   Label done;
8585   cvttss2sil(dst, src);
8586   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
8587   cmpl(dst, 0x80000000); // float_sign_flip
8588   jccb(Assembler::notEqual, done);
8589   subptr(rsp, 8);
8590   movflt(Address(rsp, 0), src);
8591   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
8592   pop(dst);
8593   bind(done);
8594 }
8595 
8596 void MacroAssembler::convert_d2i(Register dst, XMMRegister src) {
8597   Label done;
8598   cvttsd2sil(dst, src);
8599   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
8600   cmpl(dst, 0x80000000); // float_sign_flip
8601   jccb(Assembler::notEqual, done);
8602   subptr(rsp, 8);
8603   movdbl(Address(rsp, 0), src);
8604   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
8605   pop(dst);
8606   bind(done);
8607 }
8608 
8609 void MacroAssembler::convert_f2l(Register dst, XMMRegister src) {
8610   Label done;
8611   cvttss2siq(dst, src);
8612   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
8613   jccb(Assembler::notEqual, done);
8614   subptr(rsp, 8);
8615   movflt(Address(rsp, 0), src);
8616   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
8617   pop(dst);
8618   bind(done);
8619 }
8620 
8621 void MacroAssembler::convert_d2l(Register dst, XMMRegister src) {
8622   Label done;
8623   cvttsd2siq(dst, src);
8624   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
8625   jccb(Assembler::notEqual, done);
8626   subptr(rsp, 8);
8627   movdbl(Address(rsp, 0), src);
8628   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
8629   pop(dst);
8630   bind(done);
8631 }
8632 
8633 void MacroAssembler::cache_wb(Address line)
8634 {
8635   // 64 bit cpus always support clflush
8636   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
8637   bool optimized = VM_Version::supports_clflushopt();
8638   bool no_evict = VM_Version::supports_clwb();
8639 
8640   // prefer clwb (writeback without evict) otherwise
8641   // prefer clflushopt (potentially parallel writeback with evict)
8642   // otherwise fallback on clflush (serial writeback with evict)
8643 
8644   if (optimized) {
8645     if (no_evict) {
8646       clwb(line);
8647     } else {
8648       clflushopt(line);
8649     }
8650   } else {
8651     // no need for fence when using CLFLUSH
8652     clflush(line);
8653   }
8654 }
8655 
8656 void MacroAssembler::cache_wbsync(bool is_pre)
8657 {
8658   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
8659   bool optimized = VM_Version::supports_clflushopt();
8660   bool no_evict = VM_Version::supports_clwb();
8661 
8662   // pick the correct implementation
8663 
8664   if (!is_pre &amp;&amp; (optimized || no_evict)) {
8665     // need an sfence for post flush when using clflushopt or clwb
8666     // otherwise no no need for any synchroniaztion
8667 
8668     sfence();
8669   }
8670 }
8671 #endif // _LP64
8672 
8673 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
8674   switch (cond) {
8675     // Note some conditions are synonyms for others
8676     case Assembler::zero:         return Assembler::notZero;
8677     case Assembler::notZero:      return Assembler::zero;
8678     case Assembler::less:         return Assembler::greaterEqual;
8679     case Assembler::lessEqual:    return Assembler::greater;
8680     case Assembler::greater:      return Assembler::lessEqual;
8681     case Assembler::greaterEqual: return Assembler::less;
8682     case Assembler::below:        return Assembler::aboveEqual;
8683     case Assembler::belowEqual:   return Assembler::above;
8684     case Assembler::above:        return Assembler::belowEqual;
8685     case Assembler::aboveEqual:   return Assembler::below;
8686     case Assembler::overflow:     return Assembler::noOverflow;
8687     case Assembler::noOverflow:   return Assembler::overflow;
8688     case Assembler::negative:     return Assembler::positive;
8689     case Assembler::positive:     return Assembler::negative;
8690     case Assembler::parity:       return Assembler::noParity;
8691     case Assembler::noParity:     return Assembler::parity;
8692   }
8693   ShouldNotReachHere(); return Assembler::overflow;
8694 }
8695 
8696 SkipIfEqual::SkipIfEqual(
8697     MacroAssembler* masm, const bool* flag_addr, bool value) {
8698   _masm = masm;
8699   _masm-&gt;cmp8(ExternalAddress((address)flag_addr), value);
8700   _masm-&gt;jcc(Assembler::equal, _label);
8701 }
8702 
8703 SkipIfEqual::~SkipIfEqual() {
8704   _masm-&gt;bind(_label);
8705 }
8706 
8707 // 32-bit Windows has its own fast-path implementation
8708 // of get_thread
8709 #if !defined(WIN32) || defined(_LP64)
8710 
8711 // This is simply a call to Thread::current()
8712 void MacroAssembler::get_thread(Register thread) {
8713   if (thread != rax) {
8714     push(rax);
8715   }
8716   LP64_ONLY(push(rdi);)
8717   LP64_ONLY(push(rsi);)
8718   push(rdx);
8719   push(rcx);
8720 #ifdef _LP64
8721   push(r8);
8722   push(r9);
8723   push(r10);
8724   push(r11);
8725 #endif
8726 
8727   MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, Thread::current), 0);
8728 
8729 #ifdef _LP64
8730   pop(r11);
8731   pop(r10);
8732   pop(r9);
8733   pop(r8);
8734 #endif
8735   pop(rcx);
8736   pop(rdx);
8737   LP64_ONLY(pop(rsi);)
8738   LP64_ONLY(pop(rdi);)
8739   if (thread != rax) {
8740     mov(thread, rax);
8741     pop(rax);
8742   }
8743 }
8744 
8745 #endif // !WIN32 || _LP64
    </pre>
  </body>
</html>