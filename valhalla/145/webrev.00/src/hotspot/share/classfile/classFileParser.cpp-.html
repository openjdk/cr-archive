<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/defaultMethods.hpp&quot;
  33 #include &quot;classfile/dictionary.hpp&quot;
  34 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/moduleEntry.hpp&quot;
  37 #include &quot;classfile/packageEntry.hpp&quot;
  38 #include &quot;classfile/symbolTable.hpp&quot;
  39 #include &quot;classfile/systemDictionary.hpp&quot;
  40 #include &quot;classfile/verificationType.hpp&quot;
  41 #include &quot;classfile/verifier.hpp&quot;
  42 #include &quot;classfile/vmSymbols.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;logging/logStream.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/annotations.hpp&quot;
  51 #include &quot;oops/constantPool.inline.hpp&quot;
  52 #include &quot;oops/fieldStreams.inline.hpp&quot;
  53 #include &quot;oops/inlineKlass.inline.hpp&quot;
  54 #include &quot;oops/instanceKlass.hpp&quot;
  55 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  56 #include &quot;oops/klass.inline.hpp&quot;
  57 #include &quot;oops/klassVtable.hpp&quot;
  58 #include &quot;oops/metadata.hpp&quot;
  59 #include &quot;oops/method.inline.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/recordComponent.hpp&quot;
  62 #include &quot;oops/symbol.hpp&quot;
  63 #include &quot;prims/jvmtiExport.hpp&quot;
  64 #include &quot;prims/jvmtiThreadState.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/javaCalls.hpp&quot;
  69 #include &quot;runtime/os.hpp&quot;
  70 #include &quot;runtime/perfData.hpp&quot;
  71 #include &quot;runtime/reflection.hpp&quot;
  72 #include &quot;runtime/safepointVerifiers.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/timer.hpp&quot;
  75 #include &quot;services/classLoadingService.hpp&quot;
  76 #include &quot;services/threadService.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/bitMap.inline.hpp&quot;
  79 #include &quot;utilities/copy.hpp&quot;
  80 #include &quot;utilities/exceptions.hpp&quot;
  81 #include &quot;utilities/globalDefinitions.hpp&quot;
  82 #include &quot;utilities/growableArray.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/ostream.hpp&quot;
  85 #include &quot;utilities/resourceHash.hpp&quot;
  86 #include &quot;utilities/stringUtils.hpp&quot;
  87 #include &quot;utilities/utf8.hpp&quot;
  88 
  89 #if INCLUDE_CDS
  90 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  91 #endif
  92 #if INCLUDE_JFR
  93 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  94 #endif
  95 
  96 // We generally try to create the oops directly when parsing, rather than
  97 // allocating temporary data structures and copying the bytes twice. A
  98 // temporary area is only needed when parsing utf8 entries in the constant
  99 // pool and when parsing line number tables.
 100 
 101 // We add assert in debug mode when class format is not checked.
 102 
 103 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 104 #define JAVA_MIN_SUPPORTED_VERSION        45
 105 #define JAVA_PREVIEW_MINOR_VERSION        65535
 106 
 107 // Used for two backward compatibility reasons:
 108 // - to check for new additions to the class file format in JDK1.5
 109 // - to check for bug fixes in the format checker in JDK1.5
 110 #define JAVA_1_5_VERSION                  49
 111 
 112 // Used for backward compatibility reasons:
 113 // - to check for javac bug fixes that happened after 1.5
 114 // - also used as the max version when running in jdk6
 115 #define JAVA_6_VERSION                    50
 116 
 117 // Used for backward compatibility reasons:
 118 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 119 #define JAVA_7_VERSION                    51
 120 
 121 // Extension method support.
 122 #define JAVA_8_VERSION                    52
 123 
 124 #define JAVA_9_VERSION                    53
 125 
 126 #define JAVA_10_VERSION                   54
 127 
 128 #define JAVA_11_VERSION                   55
 129 
 130 #define JAVA_12_VERSION                   56
 131 
 132 #define JAVA_13_VERSION                   57
 133 
 134 #define JAVA_14_VERSION                   58
 135 
 136 #define JAVA_15_VERSION                   59
 137 
 138 #define JAVA_16_VERSION                   60
 139 
 140 #define CONSTANT_CLASS_DESCRIPTORS        60
 141 
 142 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 143   assert((bad_constant == JVM_CONSTANT_Module ||
 144           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 145          &quot;Unexpected bad constant pool entry&quot;);
 146   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 147 }
 148 
 149 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 150                                                   ConstantPool* cp,
 151                                                   const int length,
 152                                                   TRAPS) {
 153   assert(stream != NULL, &quot;invariant&quot;);
 154   assert(cp != NULL, &quot;invariant&quot;);
 155 
 156   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 157   // this function (_current can be allocated in a register, with scalar
 158   // replacement of aggregates). The _current pointer is copied back to
 159   // stream() when this function returns. DON&#39;T call another method within
 160   // this method that uses stream().
 161   const ClassFileStream cfs1 = *stream;
 162   const ClassFileStream* const cfs = &amp;cfs1;
 163 
 164   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 165   debug_only(const u1* const old_current = stream-&gt;current();)
 166 
 167   // Used for batching symbol allocations.
 168   const char* names[SymbolTable::symbol_alloc_batch_size];
 169   int lengths[SymbolTable::symbol_alloc_batch_size];
 170   int indices[SymbolTable::symbol_alloc_batch_size];
 171   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 172   int names_count = 0;
 173 
 174   // parsing  Index 0 is unused
 175   for (int index = 1; index &lt; length; index++) {
 176     // Each of the following case guarantees one more byte in the stream
 177     // for the following tag or the access_flags following constant pool,
 178     // so we don&#39;t need bounds-check for reading tag.
 179     const u1 tag = cfs-&gt;get_u1_fast();
 180     switch (tag) {
 181       case JVM_CONSTANT_Class: {
 182         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 183         const u2 name_index = cfs-&gt;get_u2_fast();
 184         cp-&gt;klass_index_at_put(index, name_index);
 185         break;
 186       }
 187       case JVM_CONSTANT_Fieldref: {
 188         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 189         const u2 class_index = cfs-&gt;get_u2_fast();
 190         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 191         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 192         break;
 193       }
 194       case JVM_CONSTANT_Methodref: {
 195         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 196         const u2 class_index = cfs-&gt;get_u2_fast();
 197         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 198         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 199         break;
 200       }
 201       case JVM_CONSTANT_InterfaceMethodref: {
 202         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 203         const u2 class_index = cfs-&gt;get_u2_fast();
 204         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 205         cp-&gt;interface_method_at_put(index, class_index, name_and_type_index);
 206         break;
 207       }
 208       case JVM_CONSTANT_String : {
 209         cfs-&gt;guarantee_more(3, CHECK);  // string_index, tag/access_flags
 210         const u2 string_index = cfs-&gt;get_u2_fast();
 211         cp-&gt;string_index_at_put(index, string_index);
 212         break;
 213       }
 214       case JVM_CONSTANT_MethodHandle :
 215       case JVM_CONSTANT_MethodType: {
 216         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 217           classfile_parse_error(
 218             &quot;Class file version does not support constant tag %u in class file %s&quot;,
 219             tag, CHECK);
 220         }
 221         if (tag == JVM_CONSTANT_MethodHandle) {
 222           cfs-&gt;guarantee_more(4, CHECK);  // ref_kind, method_index, tag/access_flags
 223           const u1 ref_kind = cfs-&gt;get_u1_fast();
 224           const u2 method_index = cfs-&gt;get_u2_fast();
 225           cp-&gt;method_handle_index_at_put(index, ref_kind, method_index);
 226         }
 227         else if (tag == JVM_CONSTANT_MethodType) {
 228           cfs-&gt;guarantee_more(3, CHECK);  // signature_index, tag/access_flags
 229           const u2 signature_index = cfs-&gt;get_u2_fast();
 230           cp-&gt;method_type_index_at_put(index, signature_index);
 231         }
 232         else {
 233           ShouldNotReachHere();
 234         }
 235         break;
 236       }
 237       case JVM_CONSTANT_Dynamic : {
 238         if (_major_version &lt; Verifier::DYNAMICCONSTANT_MAJOR_VERSION) {
 239           classfile_parse_error(
 240               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 241               tag, CHECK);
 242         }
 243         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 244         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 245         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 246         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 247           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 248         }
 249         cp-&gt;dynamic_constant_at_put(index, bootstrap_specifier_index, name_and_type_index);
 250         break;
 251       }
 252       case JVM_CONSTANT_InvokeDynamic : {
 253         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 254           classfile_parse_error(
 255               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 256               tag, CHECK);
 257         }
 258         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 259         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 260         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 261         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 262           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 263         }
 264         cp-&gt;invoke_dynamic_at_put(index, bootstrap_specifier_index, name_and_type_index);
 265         break;
 266       }
 267       case JVM_CONSTANT_Integer: {
 268         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 269         const u4 bytes = cfs-&gt;get_u4_fast();
 270         cp-&gt;int_at_put(index, (jint)bytes);
 271         break;
 272       }
 273       case JVM_CONSTANT_Float: {
 274         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 275         const u4 bytes = cfs-&gt;get_u4_fast();
 276         cp-&gt;float_at_put(index, *(jfloat*)&amp;bytes);
 277         break;
 278       }
 279       case JVM_CONSTANT_Long: {
 280         // A mangled type might cause you to overrun allocated memory
 281         guarantee_property(index + 1 &lt; length,
 282                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 283                            index,
 284                            CHECK);
 285         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 286         const u8 bytes = cfs-&gt;get_u8_fast();
 287         cp-&gt;long_at_put(index, bytes);
 288         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 289         break;
 290       }
 291       case JVM_CONSTANT_Double: {
 292         // A mangled type might cause you to overrun allocated memory
 293         guarantee_property(index+1 &lt; length,
 294                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 295                            index,
 296                            CHECK);
 297         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 298         const u8 bytes = cfs-&gt;get_u8_fast();
 299         cp-&gt;double_at_put(index, *(jdouble*)&amp;bytes);
 300         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 301         break;
 302       }
 303       case JVM_CONSTANT_NameAndType: {
 304         cfs-&gt;guarantee_more(5, CHECK);  // name_index, signature_index, tag/access_flags
 305         const u2 name_index = cfs-&gt;get_u2_fast();
 306         const u2 signature_index = cfs-&gt;get_u2_fast();
 307         cp-&gt;name_and_type_at_put(index, name_index, signature_index);
 308         break;
 309       }
 310       case JVM_CONSTANT_Utf8 : {
 311         cfs-&gt;guarantee_more(2, CHECK);  // utf8_length
 312         u2  utf8_length = cfs-&gt;get_u2_fast();
 313         const u1* utf8_buffer = cfs-&gt;current();
 314         assert(utf8_buffer != NULL, &quot;null utf8 buffer&quot;);
 315         // Got utf8 string, guarantee utf8_length+1 bytes, set stream position forward.
 316         cfs-&gt;guarantee_more(utf8_length+1, CHECK);  // utf8 string, tag/access_flags
 317         cfs-&gt;skip_u1_fast(utf8_length);
 318 
 319         // Before storing the symbol, make sure it&#39;s legal
 320         if (_need_verify) {
 321           verify_legal_utf8(utf8_buffer, utf8_length, CHECK);
 322         }
 323 
 324         if (has_cp_patch_at(index)) {
 325           Handle patch = clear_cp_patch_at(index);
 326           guarantee_property(java_lang_String::is_instance(patch()),
 327                              &quot;Illegal utf8 patch at %d in class file %s&quot;,
 328                              index,
 329                              CHECK);
 330           const char* const str = java_lang_String::as_utf8_string(patch());
 331           // (could use java_lang_String::as_symbol instead, but might as well batch them)
 332           utf8_buffer = (const u1*) str;
 333           utf8_length = (u2) strlen(str);
 334         }
 335 
 336         unsigned int hash;
 337         Symbol* const result = SymbolTable::lookup_only((const char*)utf8_buffer,
 338                                                         utf8_length,
 339                                                         hash);
 340         if (result == NULL) {
 341           names[names_count] = (const char*)utf8_buffer;
 342           lengths[names_count] = utf8_length;
 343           indices[names_count] = index;
 344           hashValues[names_count++] = hash;
 345           if (names_count == SymbolTable::symbol_alloc_batch_size) {
 346             SymbolTable::new_symbols(_loader_data,
 347                                      constantPoolHandle(THREAD, cp),
 348                                      names_count,
 349                                      names,
 350                                      lengths,
 351                                      indices,
 352                                      hashValues);
 353             names_count = 0;
 354           }
 355         } else {
 356           cp-&gt;symbol_at_put(index, result);
 357         }
 358         break;
 359       }
 360       case JVM_CONSTANT_Module:
 361       case JVM_CONSTANT_Package: {
 362         // Record that an error occurred in these two cases but keep parsing so
 363         // that ACC_Module can be checked for in the access_flags.  Need to
 364         // throw NoClassDefFoundError in that case.
 365         if (_major_version &gt;= JAVA_9_VERSION) {
 366           cfs-&gt;guarantee_more(3, CHECK);
 367           cfs-&gt;get_u2_fast();
 368           set_class_bad_constant_seen(tag);
 369           break;
 370         }
 371       }
 372       default: {
 373         classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;,
 374                               tag,
 375                               CHECK);
 376         break;
 377       }
 378     } // end of switch(tag)
 379   } // end of for
 380 
 381   // Allocate the remaining symbols
 382   if (names_count &gt; 0) {
 383     SymbolTable::new_symbols(_loader_data,
 384                              constantPoolHandle(THREAD, cp),
 385                              names_count,
 386                              names,
 387                              lengths,
 388                              indices,
 389                              hashValues);
 390   }
 391 
 392   // Copy _current pointer of local copy back to stream.
 393   assert(stream-&gt;current() == old_current, &quot;non-exclusive use of stream&quot;);
 394   stream-&gt;set_current(cfs1.current());
 395 
 396 }
 397 
 398 static inline bool valid_cp_range(int index, int length) {
 399   return (index &gt; 0 &amp;&amp; index &lt; length);
 400 }
 401 
 402 static inline Symbol* check_symbol_at(const ConstantPool* cp, int index) {
 403   assert(cp != NULL, &quot;invariant&quot;);
 404   if (valid_cp_range(index, cp-&gt;length()) &amp;&amp; cp-&gt;tag_at(index).is_utf8()) {
 405     return cp-&gt;symbol_at(index);
 406   }
 407   return NULL;
 408 }
 409 
 410 #ifdef ASSERT
 411 PRAGMA_DIAG_PUSH
 412 PRAGMA_FORMAT_NONLITERAL_IGNORED
 413 void ClassFileParser::report_assert_property_failure(const char* msg, TRAPS) const {
 414   ResourceMark rm(THREAD);
 415   fatal(msg, _class_name-&gt;as_C_string());
 416 }
 417 
 418 void ClassFileParser::report_assert_property_failure(const char* msg,
 419                                                      int index,
 420                                                      TRAPS) const {
 421   ResourceMark rm(THREAD);
 422   fatal(msg, index, _class_name-&gt;as_C_string());
 423 }
 424 PRAGMA_DIAG_POP
 425 #endif
 426 
 427 void ClassFileParser::parse_constant_pool(const ClassFileStream* const stream,
 428                                          ConstantPool* const cp,
 429                                          const int length,
 430                                          TRAPS) {
 431   assert(cp != NULL, &quot;invariant&quot;);
 432   assert(stream != NULL, &quot;invariant&quot;);
 433 
 434   // parsing constant pool entries
 435   parse_constant_pool_entries(stream, cp, length, CHECK);
 436   if (class_bad_constant_seen() != 0) {
 437     // a bad CP entry has been detected previously so stop parsing and just return.
 438     return;
 439   }
 440 
 441   int index = 1;  // declared outside of loops for portability
 442   int num_klasses = 0;
 443 
 444   // first verification pass - validate cross references
 445   // and fixup class and string constants
 446   for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 447     const jbyte tag = cp-&gt;tag_at(index).value();
 448     switch (tag) {
 449       case JVM_CONSTANT_Class: {
 450         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 451         break;
 452       }
 453       case JVM_CONSTANT_Fieldref:
 454         // fall through
 455       case JVM_CONSTANT_Methodref:
 456         // fall through
 457       case JVM_CONSTANT_InterfaceMethodref: {
 458         if (!_need_verify) break;
 459         const int klass_ref_index = cp-&gt;klass_ref_index_at(index);
 460         const int name_and_type_ref_index = cp-&gt;name_and_type_ref_index_at(index);
 461         check_property(valid_klass_reference_at(klass_ref_index),
 462                        &quot;Invalid constant pool index %u in class file %s&quot;,
 463                        klass_ref_index, CHECK);
 464         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 465           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 466           &quot;Invalid constant pool index %u in class file %s&quot;,
 467           name_and_type_ref_index, CHECK);
 468         break;
 469       }
 470       case JVM_CONSTANT_String: {
 471         ShouldNotReachHere();     // Only JVM_CONSTANT_StringIndex should be present
 472         break;
 473       }
 474       case JVM_CONSTANT_Integer:
 475         break;
 476       case JVM_CONSTANT_Float:
 477         break;
 478       case JVM_CONSTANT_Long:
 479       case JVM_CONSTANT_Double: {
 480         index++;
 481         check_property(
 482           (index &lt; length &amp;&amp; cp-&gt;tag_at(index).is_invalid()),
 483           &quot;Improper constant pool long/double index %u in class file %s&quot;,
 484           index, CHECK);
 485         break;
 486       }
 487       case JVM_CONSTANT_NameAndType: {
 488         if (!_need_verify) break;
 489         const int name_ref_index = cp-&gt;name_ref_index_at(index);
 490         const int signature_ref_index = cp-&gt;signature_ref_index_at(index);
 491         check_property(valid_symbol_at(name_ref_index),
 492           &quot;Invalid constant pool index %u in class file %s&quot;,
 493           name_ref_index, CHECK);
 494         check_property(valid_symbol_at(signature_ref_index),
 495           &quot;Invalid constant pool index %u in class file %s&quot;,
 496           signature_ref_index, CHECK);
 497         break;
 498       }
 499       case JVM_CONSTANT_Utf8:
 500         break;
 501       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 502       case JVM_CONSTANT_UnresolvedClassInError: {
 503         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 504         break;
 505       }
 506       case JVM_CONSTANT_ClassIndex: {
 507         const int class_index = cp-&gt;klass_index_at(index);
 508         check_property(valid_symbol_at(class_index),
 509           &quot;Invalid constant pool index %u in class file %s&quot;,
 510           class_index, CHECK);
 511 
 512         Symbol* const name = cp-&gt;symbol_at(class_index);
 513         const unsigned int name_len = name-&gt;utf8_length();
 514         if (name-&gt;is_Q_signature()) {
 515           cp-&gt;unresolved_qdescriptor_at_put(index, class_index, num_klasses++);
 516         } else {
 517           cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);
 518         }
 519         break;
 520       }
 521       case JVM_CONSTANT_StringIndex: {
 522         const int string_index = cp-&gt;string_index_at(index);
 523         check_property(valid_symbol_at(string_index),
 524           &quot;Invalid constant pool index %u in class file %s&quot;,
 525           string_index, CHECK);
 526         Symbol* const sym = cp-&gt;symbol_at(string_index);
 527         cp-&gt;unresolved_string_at_put(index, sym);
 528         break;
 529       }
 530       case JVM_CONSTANT_MethodHandle: {
 531         const int ref_index = cp-&gt;method_handle_index_at(index);
 532         check_property(valid_cp_range(ref_index, length),
 533           &quot;Invalid constant pool index %u in class file %s&quot;,
 534           ref_index, CHECK);
 535         const constantTag tag = cp-&gt;tag_at(ref_index);
 536         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 537 
 538         switch (ref_kind) {
 539           case JVM_REF_getField:
 540           case JVM_REF_getStatic:
 541           case JVM_REF_putField:
 542           case JVM_REF_putStatic: {
 543             check_property(
 544               tag.is_field(),
 545               &quot;Invalid constant pool index %u in class file %s (not a field)&quot;,
 546               ref_index, CHECK);
 547             break;
 548           }
 549           case JVM_REF_invokeVirtual:
 550           case JVM_REF_newInvokeSpecial: {
 551             check_property(
 552               tag.is_method(),
 553               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 554               ref_index, CHECK);
 555             break;
 556           }
 557           case JVM_REF_invokeStatic:
 558           case JVM_REF_invokeSpecial: {
 559             check_property(
 560               tag.is_method() ||
 561               ((_major_version &gt;= JAVA_8_VERSION) &amp;&amp; tag.is_interface_method()),
 562               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 563               ref_index, CHECK);
 564             break;
 565           }
 566           case JVM_REF_invokeInterface: {
 567             check_property(
 568               tag.is_interface_method(),
 569               &quot;Invalid constant pool index %u in class file %s (not an interface method)&quot;,
 570               ref_index, CHECK);
 571             break;
 572           }
 573           default: {
 574             classfile_parse_error(
 575               &quot;Bad method handle kind at constant pool index %u in class file %s&quot;,
 576               index, CHECK);
 577           }
 578         } // switch(refkind)
 579         // Keep the ref_index unchanged.  It will be indirected at link-time.
 580         break;
 581       } // case MethodHandle
 582       case JVM_CONSTANT_MethodType: {
 583         const int ref_index = cp-&gt;method_type_index_at(index);
 584         check_property(valid_symbol_at(ref_index),
 585           &quot;Invalid constant pool index %u in class file %s&quot;,
 586           ref_index, CHECK);
 587         break;
 588       }
 589       case JVM_CONSTANT_Dynamic: {
 590         const int name_and_type_ref_index =
 591           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 592 
 593         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 594           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 595           &quot;Invalid constant pool index %u in class file %s&quot;,
 596           name_and_type_ref_index, CHECK);
 597         // bootstrap specifier index must be checked later,
 598         // when BootstrapMethods attr is available
 599 
 600         // Mark the constant pool as having a CONSTANT_Dynamic_info structure
 601         cp-&gt;set_has_dynamic_constant();
 602         break;
 603       }
 604       case JVM_CONSTANT_InvokeDynamic: {
 605         const int name_and_type_ref_index =
 606           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 607 
 608         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 609           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 610           &quot;Invalid constant pool index %u in class file %s&quot;,
 611           name_and_type_ref_index, CHECK);
 612         // bootstrap specifier index must be checked later,
 613         // when BootstrapMethods attr is available
 614         break;
 615       }
 616       default: {
 617         fatal(&quot;bad constant pool tag value %u&quot;, cp-&gt;tag_at(index).value());
 618         ShouldNotReachHere();
 619         break;
 620       }
 621     } // switch(tag)
 622   } // end of for
 623 
 624   _first_patched_klass_resolved_index = num_klasses;
 625   cp-&gt;allocate_resolved_klasses(_loader_data, num_klasses + _max_num_patched_klasses, CHECK);
 626 
 627   if (_cp_patches != NULL) {
 628     // need to treat this_class specially...
 629 
 630     // Add dummy utf8 entries in the space reserved for names of patched classes. We&#39;ll use &quot;*&quot;
 631     // for now. These will be replaced with actual names of the patched classes in patch_class().
 632     Symbol* s = vmSymbols::star_name();
 633     for (int n=_orig_cp_size; n&lt;cp-&gt;length(); n++) {
 634       cp-&gt;symbol_at_put(n, s);
 635     }
 636 
 637     int this_class_index;
 638     {
 639       stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
 640       const u1* const mark = stream-&gt;current();
 641       stream-&gt;skip_u2_fast(1); // skip flags
 642       this_class_index = stream-&gt;get_u2_fast();
 643       stream-&gt;set_current(mark);  // revert to mark
 644     }
 645 
 646     for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 647       if (has_cp_patch_at(index)) {
 648         guarantee_property(index != this_class_index,
 649           &quot;Illegal constant pool patch to self at %d in class file %s&quot;,
 650           index, CHECK);
 651         patch_constant_pool(cp, index, cp_patch_at(index), CHECK);
 652       }
 653     }
 654   }
 655 
 656   if (!_need_verify) {
 657     return;
 658   }
 659 
 660   // second verification pass - checks the strings are of the right format.
 661   // but not yet to the other entries
 662   for (index = 1; index &lt; length; index++) {
 663     const jbyte tag = cp-&gt;tag_at(index).value();
 664     switch (tag) {
 665       case JVM_CONSTANT_UnresolvedClass: {
 666         const Symbol* const class_name = cp-&gt;klass_name_at(index);
 667         // check the name, even if _cp_patches will overwrite it
 668         verify_legal_class_name(class_name, CHECK);
 669         break;
 670       }
 671       case JVM_CONSTANT_NameAndType: {
 672         if (_need_verify) {
 673           const int sig_index = cp-&gt;signature_ref_index_at(index);
 674           const int name_index = cp-&gt;name_ref_index_at(index);
 675           const Symbol* const name = cp-&gt;symbol_at(name_index);
 676           const Symbol* const sig = cp-&gt;symbol_at(sig_index);
 677           guarantee_property(sig-&gt;utf8_length() != 0,
 678             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 679             sig_index, CHECK);
 680           guarantee_property(name-&gt;utf8_length() != 0,
 681             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 682             name_index, CHECK);
 683 
 684           if (Signature::is_method(sig)) {
 685             // Format check method name and signature
 686             verify_legal_method_name(name, CHECK);
 687             verify_legal_method_signature(name, sig, CHECK);
 688           } else {
 689             // Format check field name and signature
 690             verify_legal_field_name(name, CHECK);
 691             verify_legal_field_signature(name, sig, CHECK);
 692           }
 693         }
 694         break;
 695       }
 696       case JVM_CONSTANT_Dynamic: {
 697         const int name_and_type_ref_index =
 698           cp-&gt;name_and_type_ref_index_at(index);
 699         // already verified to be utf8
 700         const int name_ref_index =
 701           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 702         // already verified to be utf8
 703         const int signature_ref_index =
 704           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 705         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 706         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 707         if (_need_verify) {
 708           // CONSTANT_Dynamic&#39;s name and signature are verified above, when iterating NameAndType_info.
 709           // Need only to be sure signature is the right type.
 710           if (Signature::is_method(signature)) {
 711             throwIllegalSignature(&quot;CONSTANT_Dynamic&quot;, name, signature, CHECK);
 712           }
 713         }
 714         break;
 715       }
 716       case JVM_CONSTANT_InvokeDynamic:
 717       case JVM_CONSTANT_Fieldref:
 718       case JVM_CONSTANT_Methodref:
 719       case JVM_CONSTANT_InterfaceMethodref: {
 720         const int name_and_type_ref_index =
 721           cp-&gt;name_and_type_ref_index_at(index);
 722         // already verified to be utf8
 723         const int name_ref_index =
 724           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 725         // already verified to be utf8
 726         const int signature_ref_index =
 727           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 728         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 729         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 730         if (tag == JVM_CONSTANT_Fieldref) {
 731           if (_need_verify) {
 732             // Field name and signature are verified above, when iterating NameAndType_info.
 733             // Need only to be sure signature is non-zero length and the right type.
 734             if (Signature::is_method(signature)) {
 735               throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
 736             }
 737           }
 738         } else {
 739           if (_need_verify) {
 740             // Method name and signature are verified above, when iterating NameAndType_info.
 741             // Need only to be sure signature is non-zero length and the right type.
 742             if (!Signature::is_method(signature)) {
 743               throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK);
 744             }
 745           }
 746           // 4509014: If a class method name begins with &#39;&lt;&#39;, it must be &quot;&lt;init&gt;&quot;
 747           const unsigned int name_len = name-&gt;utf8_length();
 748           if (tag == JVM_CONSTANT_Methodref &amp;&amp;
 749               name_len != 0 &amp;&amp;
 750               name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL &amp;&amp;
 751               name != vmSymbols::object_initializer_name()) {
 752             classfile_parse_error(
 753               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 754               name_ref_index, CHECK);
 755           }
 756         }
 757         break;
 758       }
 759       case JVM_CONSTANT_MethodHandle: {
 760         const int ref_index = cp-&gt;method_handle_index_at(index);
 761         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 762         switch (ref_kind) {
 763           case JVM_REF_invokeVirtual:
 764           case JVM_REF_invokeStatic:
 765           case JVM_REF_invokeSpecial:
 766           case JVM_REF_newInvokeSpecial: {
 767             const int name_and_type_ref_index =
 768               cp-&gt;name_and_type_ref_index_at(ref_index);
 769             const int name_ref_index =
 770               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 771             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 772             if (name != vmSymbols::object_initializer_name()) {
 773               if (ref_kind == JVM_REF_newInvokeSpecial) {
 774                 classfile_parse_error(
 775                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 776                     name_ref_index, CHECK);
 777               }
 778             } else {
 779               // The allowed invocation mode of &lt;init&gt; depends on its signature.
 780               // This test corresponds to verify_invoke_instructions in the verifier.
 781               const int signature_ref_index =
 782                 cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 783               const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 784               if (signature-&gt;is_void_method_signature()
 785                   &amp;&amp; ref_kind == JVM_REF_newInvokeSpecial) {
 786                 // OK, could be a constructor call
 787               } else if (!signature-&gt;is_void_method_signature()
 788                          &amp;&amp; ref_kind == JVM_REF_invokeStatic) {
 789                 // also OK, could be a static factory call
 790               } else {
 791                 classfile_parse_error(
 792                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 793                   name_ref_index, CHECK);
 794               }
 795             }
 796             break;
 797           }
 798           // Other ref_kinds are already fully checked in previous pass.
 799         } // switch(ref_kind)
 800         break;
 801       }
 802       case JVM_CONSTANT_MethodType: {
 803         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 804         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 805         verify_legal_method_signature(no_name, signature, CHECK);
 806         break;
 807       }
 808       case JVM_CONSTANT_Utf8: {
 809         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 810       }
 811     }  // switch(tag)
 812   }  // end of for
 813 }
 814 
 815 Handle ClassFileParser::clear_cp_patch_at(int index) {
 816   Handle patch = cp_patch_at(index);
 817   _cp_patches-&gt;at_put(index, Handle());
 818   assert(!has_cp_patch_at(index), &quot;&quot;);
 819   return patch;
 820 }
 821 
 822 void ClassFileParser::patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name) {
 823   int name_index = _orig_cp_size + _num_patched_klasses;
 824   int resolved_klass_index = _first_patched_klass_resolved_index + _num_patched_klasses;
 825 
 826   cp-&gt;klass_at_put(class_index, name_index, resolved_klass_index, k, name);
 827   _num_patched_klasses ++;
 828 }
 829 
 830 void ClassFileParser::patch_constant_pool(ConstantPool* cp,
 831                                           int index,
 832                                           Handle patch,
 833                                           TRAPS) {
 834   assert(cp != NULL, &quot;invariant&quot;);
 835 
 836   BasicType patch_type = T_VOID;
 837 
 838   switch (cp-&gt;tag_at(index).value()) {
 839 
 840     case JVM_CONSTANT_UnresolvedClass: {
 841       // Patching a class means pre-resolving it.
 842       // The name in the constant pool is ignored.
 843       if (java_lang_Class::is_instance(patch())) {
 844         guarantee_property(!java_lang_Class::is_primitive(patch()),
 845                            &quot;Illegal class patch at %d in class file %s&quot;,
 846                            index, CHECK);
 847         Klass* k = java_lang_Class::as_Klass(patch());
 848         patch_class(cp, index, k, k-&gt;name());
 849       } else {
 850         guarantee_property(java_lang_String::is_instance(patch()),
 851                            &quot;Illegal class patch at %d in class file %s&quot;,
 852                            index, CHECK);
 853         Symbol* const name = java_lang_String::as_symbol(patch());
 854         patch_class(cp, index, NULL, name);
 855       }
 856       break;
 857     }
 858 
 859     case JVM_CONSTANT_String: {
 860       // skip this patch and don&#39;t clear it.  Needs the oop array for resolved
 861       // references to be created first.
 862       return;
 863     }
 864     case JVM_CONSTANT_Integer: patch_type = T_INT;    goto patch_prim;
 865     case JVM_CONSTANT_Float:   patch_type = T_FLOAT;  goto patch_prim;
 866     case JVM_CONSTANT_Long:    patch_type = T_LONG;   goto patch_prim;
 867     case JVM_CONSTANT_Double:  patch_type = T_DOUBLE; goto patch_prim;
 868     patch_prim:
 869     {
 870       jvalue value;
 871       BasicType value_type = java_lang_boxing_object::get_value(patch(), &amp;value);
 872       guarantee_property(value_type == patch_type,
 873                          &quot;Illegal primitive patch at %d in class file %s&quot;,
 874                          index, CHECK);
 875       switch (value_type) {
 876         case T_INT:    cp-&gt;int_at_put(index,   value.i); break;
 877         case T_FLOAT:  cp-&gt;float_at_put(index, value.f); break;
 878         case T_LONG:   cp-&gt;long_at_put(index,  value.j); break;
 879         case T_DOUBLE: cp-&gt;double_at_put(index, value.d); break;
 880         default:       assert(false, &quot;&quot;);
 881       }
 882     } // end patch_prim label
 883     break;
 884 
 885     default: {
 886       // %%% TODO: put method handles into CONSTANT_InterfaceMethodref, etc.
 887       guarantee_property(!has_cp_patch_at(index),
 888                          &quot;Illegal unexpected patch at %d in class file %s&quot;,
 889                          index, CHECK);
 890       return;
 891     }
 892   } // end of switch(tag)
 893 
 894   // On fall-through, mark the patch as used.
 895   clear_cp_patch_at(index);
 896 }
 897 class NameSigHash: public ResourceObj {
 898  public:
 899   const Symbol*       _name;       // name
 900   const Symbol*       _sig;        // signature
 901   NameSigHash*  _next;             // Next entry in hash table
 902 };
 903 
 904 static const int HASH_ROW_SIZE = 256;
 905 
 906 static unsigned int hash(const Symbol* name, const Symbol* sig) {
 907   unsigned int raw_hash = 0;
 908   raw_hash += ((unsigned int)(uintptr_t)name) &gt;&gt; (LogHeapWordSize + 2);
 909   raw_hash += ((unsigned int)(uintptr_t)sig) &gt;&gt; LogHeapWordSize;
 910 
 911   return (raw_hash + (unsigned int)(uintptr_t)name) % HASH_ROW_SIZE;
 912 }
 913 
 914 
 915 static void initialize_hashtable(NameSigHash** table) {
 916   memset((void*)table, 0, sizeof(NameSigHash*) * HASH_ROW_SIZE);
 917 }
 918 // Return false if the name/sig combination is found in table.
 919 // Return true if no duplicate is found. And name/sig is added as a new entry in table.
 920 // The old format checker uses heap sort to find duplicates.
 921 // NOTE: caller should guarantee that GC doesn&#39;t happen during the life cycle
 922 // of table since we don&#39;t expect Symbol*&#39;s to move.
 923 static bool put_after_lookup(const Symbol* name, const Symbol* sig, NameSigHash** table) {
 924   assert(name != NULL, &quot;name in constant pool is NULL&quot;);
 925 
 926   // First lookup for duplicates
 927   int index = hash(name, sig);
 928   NameSigHash* entry = table[index];
 929   while (entry != NULL) {
 930     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 931       return false;
 932     }
 933     entry = entry-&gt;_next;
 934   }
 935 
 936   // No duplicate is found, allocate a new entry and fill it.
 937   entry = new NameSigHash();
 938   entry-&gt;_name = name;
 939   entry-&gt;_sig = sig;
 940 
 941   // Insert into hash table
 942   entry-&gt;_next = table[index];
 943   table[index] = entry;
 944 
 945   return true;
 946 }
 947 
 948 // Side-effects: populates the _local_interfaces field
 949 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,
 950                                        int itfs_len,
 951                                        ConstantPool* cp,
 952                                        bool is_inline_type,
 953                                        bool* const has_nonstatic_concrete_methods,
 954                                        // FIXME: lots of these functions
 955                                        // declare their parameters as const,
 956                                        // which adds only noise to the code.
 957                                        // Remove the spurious const modifiers.
 958                                        // Many are of the form &quot;const int x&quot;
 959                                        // or &quot;T* const x&quot;.
 960                                        bool* const is_declared_atomic,
 961                                        TRAPS) {
 962   assert(stream != NULL, &quot;invariant&quot;);
 963   assert(cp != NULL, &quot;invariant&quot;);
 964   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 965 
 966   if (itfs_len == 0) {
 967     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(0);
 968   } else {
 969     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
 970     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(itfs_len);
 971     int index = 0;
 972     for (index = 0; index &lt; itfs_len; index++) {
 973       const u2 interface_index = stream-&gt;get_u2(CHECK);
 974       Klass* interf;
 975       check_property(
 976         valid_klass_reference_at(interface_index),
 977         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 978         interface_index, CHECK);
 979       if (cp-&gt;tag_at(interface_index).is_klass()) {
 980         interf = cp-&gt;resolved_klass_at(interface_index);
 981       } else {
 982         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 983 
 984         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 985         // But need to make sure it&#39;s not an array type.
 986         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 987                            &quot;Bad interface name in class file %s&quot;, CHECK);
 988 
 989         // Call resolve_super so class circularity is checked
 990         interf = SystemDictionary::resolve_super_or_fail(
 991                                                   _class_name,
 992                                                   unresolved_klass,
 993                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 994                                                   _protection_domain,
 995                                                   false,
 996                                                   CHECK);
 997       }
 998 
 999       if (!interf-&gt;is_interface()) {
1000         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
1001                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1002                           _class_name-&gt;as_klass_external_name(),
1003                           interf-&gt;external_name(),
1004                           interf-&gt;class_in_module_of_loader()));
1005       }
1006 
1007       InstanceKlass* ik = InstanceKlass::cast(interf);
1008       if (is_inline_type &amp;&amp; ik-&gt;invalid_inline_super()) {
1009         ResourceMark rm(THREAD);
1010         Exceptions::fthrow(
1011           THREAD_AND_LOCATION,
1012           vmSymbols::java_lang_IncompatibleClassChangeError(),
1013           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,
1014           _class_name-&gt;as_klass_external_name());
1015         return;
1016       }
1017       if (ik-&gt;invalid_inline_super()) {
1018         set_invalid_inline_super();
1019       }
1020       if (ik-&gt;has_nonstatic_concrete_methods()) {
1021         *has_nonstatic_concrete_methods = true;
1022       }
1023       if (ik-&gt;is_declared_atomic()) {
1024         *is_declared_atomic = true;
1025       }
1026       if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {
1027         _implements_identityObject = true;
1028       }
1029       _temp_local_interfaces-&gt;append(ik);
1030     }
1031 
1032     if (!_need_verify || itfs_len &lt;= 1) {
1033       return;
1034     }
1035 
1036     // Check if there&#39;s any duplicates in interfaces
1037     ResourceMark rm(THREAD);
1038     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1039                                                                  NameSigHash*,
1040                                                                  HASH_ROW_SIZE);
1041     initialize_hashtable(interface_names);
1042     bool dup = false;
1043     const Symbol* name = NULL;
1044     {
1045       debug_only(NoSafepointVerifier nsv;)
1046       for (index = 0; index &lt; itfs_len; index++) {
1047         const InstanceKlass* const k = _temp_local_interfaces-&gt;at(index);
1048         name = k-&gt;name();
1049         // If no duplicates, add (name, NULL) in hashtable interface_names.
1050         if (!put_after_lookup(name, NULL, interface_names)) {
1051           dup = true;
1052           break;
1053         }
1054       }
1055     }
1056     if (dup) {
1057       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1058                              name-&gt;as_C_string(), CHECK);
1059     }
1060   }
1061 }
1062 
1063 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1064                                            int constantvalue_index,
1065                                            int signature_index,
1066                                            TRAPS) const {
1067   // Make sure the constant pool entry is of a type appropriate to this field
1068   guarantee_property(
1069     (constantvalue_index &gt; 0 &amp;&amp;
1070       constantvalue_index &lt; cp-&gt;length()),
1071     &quot;Bad initial value index %u in ConstantValue attribute in class file %s&quot;,
1072     constantvalue_index, CHECK);
1073 
1074   const constantTag value_type = cp-&gt;tag_at(constantvalue_index);
1075   switch(cp-&gt;basic_type_for_signature_at(signature_index)) {
1076     case T_LONG: {
1077       guarantee_property(value_type.is_long(),
1078                          &quot;Inconsistent constant value type in class file %s&quot;,
1079                          CHECK);
1080       break;
1081     }
1082     case T_FLOAT: {
1083       guarantee_property(value_type.is_float(),
1084                          &quot;Inconsistent constant value type in class file %s&quot;,
1085                          CHECK);
1086       break;
1087     }
1088     case T_DOUBLE: {
1089       guarantee_property(value_type.is_double(),
1090                          &quot;Inconsistent constant value type in class file %s&quot;,
1091                          CHECK);
1092       break;
1093     }
1094     case T_BYTE:
1095     case T_CHAR:
1096     case T_SHORT:
1097     case T_BOOLEAN:
1098     case T_INT: {
1099       guarantee_property(value_type.is_int(),
1100                          &quot;Inconsistent constant value type in class file %s&quot;,
1101                          CHECK);
1102       break;
1103     }
1104     case T_OBJECT: {
1105       guarantee_property((cp-&gt;symbol_at(signature_index)-&gt;equals(&quot;Ljava/lang/String;&quot;)
1106                          &amp;&amp; value_type.is_string()),
1107                          &quot;Bad string initial value in class file %s&quot;,
1108                          CHECK);
1109       break;
1110     }
1111     default: {
1112       classfile_parse_error(&quot;Unable to set initial value %u in class file %s&quot;,
1113                              constantvalue_index,
1114                              CHECK);
1115     }
1116   }
1117 }
1118 
1119 class AnnotationCollector : public ResourceObj{
1120 public:
1121   enum Location { _in_field, _in_method, _in_class };
1122   enum ID {
1123     _unknown = 0,
1124     _method_CallerSensitive,
1125     _method_ForceInline,
1126     _method_DontInline,
1127     _method_InjectedProfile,
1128     _method_LambdaForm_Compiled,
1129     _method_Hidden,
1130     _method_HotSpotIntrinsicCandidate,
1131     _jdk_internal_vm_annotation_Contended,
1132     _field_Stable,
1133     _jdk_internal_vm_annotation_ReservedStackAccess,
1134     _annotation_LIMIT
1135   };
1136   const Location _location;
1137   int _annotations_present;
1138   u2 _contended_group;
1139 
1140   AnnotationCollector(Location location)
1141     : _location(location), _annotations_present(0)
1142   {
1143     assert((int)_annotation_LIMIT &lt;= (int)sizeof(_annotations_present) * BitsPerByte, &quot;&quot;);
1144   }
1145   // If this annotation name has an ID, report it (or _none).
1146   ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name, bool can_access_vm_annotations);
1147   // Set the annotation name:
1148   void set_annotation(ID id) {
1149     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1150     _annotations_present |= nth_bit((int)id);
1151   }
1152 
1153   void remove_annotation(ID id) {
1154     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1155     _annotations_present &amp;= ~nth_bit((int)id);
1156   }
1157 
1158   // Report if the annotation is present.
1159   bool has_any_annotations() const { return _annotations_present != 0; }
1160   bool has_annotation(ID id) const { return (nth_bit((int)id) &amp; _annotations_present) != 0; }
1161 
1162   void set_contended_group(u2 group) { _contended_group = group; }
1163   u2 contended_group() const { return _contended_group; }
1164 
1165   bool is_contended() const { return has_annotation(_jdk_internal_vm_annotation_Contended); }
1166 
1167   void set_stable(bool stable) { set_annotation(_field_Stable); }
1168   bool is_stable() const { return has_annotation(_field_Stable); }
1169 };
1170 
1171 // This class also doubles as a holder for metadata cleanup.
1172 class ClassFileParser::FieldAnnotationCollector : public AnnotationCollector {
1173 private:
1174   ClassLoaderData* _loader_data;
1175   AnnotationArray* _field_annotations;
1176   AnnotationArray* _field_type_annotations;
1177 public:
1178   FieldAnnotationCollector(ClassLoaderData* loader_data) :
1179     AnnotationCollector(_in_field),
1180     _loader_data(loader_data),
1181     _field_annotations(NULL),
1182     _field_type_annotations(NULL) {}
1183   ~FieldAnnotationCollector();
1184   void apply_to(FieldInfo* f);
1185   AnnotationArray* field_annotations()      { return _field_annotations; }
1186   AnnotationArray* field_type_annotations() { return _field_type_annotations; }
1187 
1188   void set_field_annotations(AnnotationArray* a)      { _field_annotations = a; }
1189   void set_field_type_annotations(AnnotationArray* a) { _field_type_annotations = a; }
1190 };
1191 
1192 class MethodAnnotationCollector : public AnnotationCollector{
1193 public:
1194   MethodAnnotationCollector() : AnnotationCollector(_in_method) { }
1195   void apply_to(const methodHandle&amp; m);
1196 };
1197 
1198 class ClassFileParser::ClassAnnotationCollector : public AnnotationCollector{
1199 public:
1200   ClassAnnotationCollector() : AnnotationCollector(_in_class) { }
1201   void apply_to(InstanceKlass* ik);
1202 };
1203 
1204 
1205 static int skip_annotation_value(const u1*, int, int); // fwd decl
1206 
1207 // Safely increment index by val if does not pass limit
1208 #define SAFE_ADD(index, limit, val) \
1209 if (index &gt;= limit - val) return limit; \
1210 index += val;
1211 
1212 // Skip an annotation.  Return &gt;=limit if there is any problem.
1213 static int skip_annotation(const u1* buffer, int limit, int index) {
1214   assert(buffer != NULL, &quot;invariant&quot;);
1215   // annotation := atype:u2 do(nmem:u2) {member:u2 value}
1216   // value := switch (tag:u1) { ... }
1217   SAFE_ADD(index, limit, 4); // skip atype and read nmem
1218   int nmem = Bytes::get_Java_u2((address)buffer + index - 2);
1219   while (--nmem &gt;= 0 &amp;&amp; index &lt; limit) {
1220     SAFE_ADD(index, limit, 2); // skip member
1221     index = skip_annotation_value(buffer, limit, index);
1222   }
1223   return index;
1224 }
1225 
1226 // Skip an annotation value.  Return &gt;=limit if there is any problem.
1227 static int skip_annotation_value(const u1* buffer, int limit, int index) {
1228   assert(buffer != NULL, &quot;invariant&quot;);
1229 
1230   // value := switch (tag:u1) {
1231   //   case B, C, I, S, Z, D, F, J, c: con:u2;
1232   //   case e: e_class:u2 e_name:u2;
1233   //   case s: s_con:u2;
1234   //   case [: do(nval:u2) {value};
1235   //   case @: annotation;
1236   //   case s: s_con:u2;
1237   // }
1238   SAFE_ADD(index, limit, 1); // read tag
1239   const u1 tag = buffer[index - 1];
1240   switch (tag) {
1241     case &#39;B&#39;:
1242     case &#39;C&#39;:
1243     case &#39;I&#39;:
1244     case &#39;S&#39;:
1245     case &#39;Z&#39;:
1246     case &#39;D&#39;:
1247     case &#39;F&#39;:
1248     case &#39;J&#39;:
1249     case &#39;c&#39;:
1250     case &#39;s&#39;:
1251       SAFE_ADD(index, limit, 2);  // skip con or s_con
1252       break;
1253     case &#39;e&#39;:
1254       SAFE_ADD(index, limit, 4);  // skip e_class, e_name
1255       break;
1256     case &#39;[&#39;:
1257     {
1258       SAFE_ADD(index, limit, 2); // read nval
1259       int nval = Bytes::get_Java_u2((address)buffer + index - 2);
1260       while (--nval &gt;= 0 &amp;&amp; index &lt; limit) {
1261         index = skip_annotation_value(buffer, limit, index);
1262       }
1263     }
1264     break;
1265     case &#39;@&#39;:
1266       index = skip_annotation(buffer, limit, index);
1267       break;
1268     default:
1269       return limit;  //  bad tag byte
1270   }
1271   return index;
1272 }
1273 
1274 // Sift through annotations, looking for those significant to the VM:
1275 static void parse_annotations(const ConstantPool* const cp,
1276                               const u1* buffer, int limit,
1277                               AnnotationCollector* coll,
1278                               ClassLoaderData* loader_data,
1279                               const bool can_access_vm_annotations,
1280                               TRAPS) {
1281 
1282   assert(cp != NULL, &quot;invariant&quot;);
1283   assert(buffer != NULL, &quot;invariant&quot;);
1284   assert(coll != NULL, &quot;invariant&quot;);
1285   assert(loader_data != NULL, &quot;invariant&quot;);
1286 
1287   // annotations := do(nann:u2) {annotation}
1288   int index = 2; // read nann
1289   if (index &gt;= limit)  return;
1290   int nann = Bytes::get_Java_u2((address)buffer + index - 2);
1291   enum {  // initial annotation layout
1292     atype_off = 0,      // utf8 such as &#39;Ljava/lang/annotation/Retention;&#39;
1293     count_off = 2,      // u2   such as 1 (one value)
1294     member_off = 4,     // utf8 such as &#39;value&#39;
1295     tag_off = 6,        // u1   such as &#39;c&#39; (type) or &#39;e&#39; (enum)
1296     e_tag_val = &#39;e&#39;,
1297     e_type_off = 7,   // utf8 such as &#39;Ljava/lang/annotation/RetentionPolicy;&#39;
1298     e_con_off = 9,    // utf8 payload, such as &#39;SOURCE&#39;, &#39;CLASS&#39;, &#39;RUNTIME&#39;
1299     e_size = 11,     // end of &#39;e&#39; annotation
1300     c_tag_val = &#39;c&#39;,    // payload is type
1301     c_con_off = 7,    // utf8 payload, such as &#39;I&#39;
1302     c_size = 9,       // end of &#39;c&#39; annotation
1303     s_tag_val = &#39;s&#39;,    // payload is String
1304     s_con_off = 7,    // utf8 payload, such as &#39;Ljava/lang/String;&#39;
1305     s_size = 9,
1306     min_size = 6        // smallest possible size (zero members)
1307   };
1308   // Cannot add min_size to index in case of overflow MAX_INT
1309   while ((--nann) &gt;= 0 &amp;&amp; (index - 2 &lt;= limit - min_size)) {
1310     int index0 = index;
1311     index = skip_annotation(buffer, limit, index);
1312     const u1* const abase = buffer + index0;
1313     const int atype = Bytes::get_Java_u2((address)abase + atype_off);
1314     const int count = Bytes::get_Java_u2((address)abase + count_off);
1315     const Symbol* const aname = check_symbol_at(cp, atype);
1316     if (aname == NULL)  break;  // invalid annotation name
1317     const Symbol* member = NULL;
1318     if (count &gt;= 1) {
1319       const int member_index = Bytes::get_Java_u2((address)abase + member_off);
1320       member = check_symbol_at(cp, member_index);
1321       if (member == NULL)  break;  // invalid member name
1322     }
1323 
1324     // Here is where parsing particular annotations will take place.
1325     AnnotationCollector::ID id = coll-&gt;annotation_index(loader_data, aname, can_access_vm_annotations);
1326     if (AnnotationCollector::_unknown == id)  continue;
1327     coll-&gt;set_annotation(id);
1328 
1329     if (AnnotationCollector::_jdk_internal_vm_annotation_Contended == id) {
1330       // @Contended can optionally specify the contention group.
1331       //
1332       // Contended group defines the equivalence class over the fields:
1333       // the fields within the same contended group are not treated distinct.
1334       // The only exception is default group, which does not incur the
1335       // equivalence. Naturally, contention group for classes is meaningless.
1336       //
1337       // While the contention group is specified as String, annotation
1338       // values are already interned, and we might as well use the constant
1339       // pool index as the group tag.
1340       //
1341       u2 group_index = 0; // default contended group
1342       if (count == 1
1343         &amp;&amp; s_size == (index - index0)  // match size
1344         &amp;&amp; s_tag_val == *(abase + tag_off)
1345         &amp;&amp; member == vmSymbols::value_name()) {
1346         group_index = Bytes::get_Java_u2((address)abase + s_con_off);
1347         if (cp-&gt;symbol_at(group_index)-&gt;utf8_length() == 0) {
1348           group_index = 0; // default contended group
1349         }
1350       }
1351       coll-&gt;set_contended_group(group_index);
1352     }
1353   }
1354 }
1355 
1356 
1357 // Parse attributes for a field.
1358 void ClassFileParser::parse_field_attributes(const ClassFileStream* const cfs,
1359                                              u2 attributes_count,
1360                                              bool is_static, u2 signature_index,
1361                                              u2* const constantvalue_index_addr,
1362                                              bool* const is_synthetic_addr,
1363                                              u2* const generic_signature_index_addr,
1364                                              ClassFileParser::FieldAnnotationCollector* parsed_annotations,
1365                                              TRAPS) {
1366   assert(cfs != NULL, &quot;invariant&quot;);
1367   assert(constantvalue_index_addr != NULL, &quot;invariant&quot;);
1368   assert(is_synthetic_addr != NULL, &quot;invariant&quot;);
1369   assert(generic_signature_index_addr != NULL, &quot;invariant&quot;);
1370   assert(parsed_annotations != NULL, &quot;invariant&quot;);
1371   assert(attributes_count &gt; 0, &quot;attributes_count should be greater than 0&quot;);
1372 
1373   u2 constantvalue_index = 0;
1374   u2 generic_signature_index = 0;
1375   bool is_synthetic = false;
1376   const u1* runtime_visible_annotations = NULL;
1377   int runtime_visible_annotations_length = 0;
1378   const u1* runtime_invisible_annotations = NULL;
1379   int runtime_invisible_annotations_length = 0;
1380   const u1* runtime_visible_type_annotations = NULL;
1381   int runtime_visible_type_annotations_length = 0;
1382   const u1* runtime_invisible_type_annotations = NULL;
1383   int runtime_invisible_type_annotations_length = 0;
1384   bool runtime_invisible_annotations_exists = false;
1385   bool runtime_invisible_type_annotations_exists = false;
1386   const ConstantPool* const cp = _cp;
1387 
1388   while (attributes_count--) {
1389     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
1390     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
1391     const u4 attribute_length = cfs-&gt;get_u4_fast();
1392     check_property(valid_symbol_at(attribute_name_index),
1393                    &quot;Invalid field attribute index %u in class file %s&quot;,
1394                    attribute_name_index,
1395                    CHECK);
1396 
1397     const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
1398     if (is_static &amp;&amp; attribute_name == vmSymbols::tag_constant_value()) {
1399       // ignore if non-static
1400       if (constantvalue_index != 0) {
1401         classfile_parse_error(&quot;Duplicate ConstantValue attribute in class file %s&quot;, CHECK);
1402       }
1403       check_property(
1404         attribute_length == 2,
1405         &quot;Invalid ConstantValue field attribute length %u in class file %s&quot;,
1406         attribute_length, CHECK);
1407 
1408       constantvalue_index = cfs-&gt;get_u2(CHECK);
1409       if (_need_verify) {
1410         verify_constantvalue(cp, constantvalue_index, signature_index, CHECK);
1411       }
1412     } else if (attribute_name == vmSymbols::tag_synthetic()) {
1413       if (attribute_length != 0) {
1414         classfile_parse_error(
1415           &quot;Invalid Synthetic field attribute length %u in class file %s&quot;,
1416           attribute_length, CHECK);
1417       }
1418       is_synthetic = true;
1419     } else if (attribute_name == vmSymbols::tag_deprecated()) { // 4276120
1420       if (attribute_length != 0) {
1421         classfile_parse_error(
1422           &quot;Invalid Deprecated field attribute length %u in class file %s&quot;,
1423           attribute_length, CHECK);
1424       }
1425     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
1426       if (attribute_name == vmSymbols::tag_signature()) {
1427         if (generic_signature_index != 0) {
1428           classfile_parse_error(
1429             &quot;Multiple Signature attributes for field in class file %s&quot;, CHECK);
1430         }
1431         if (attribute_length != 2) {
1432           classfile_parse_error(
1433             &quot;Wrong size %u for field&#39;s Signature attribute in class file %s&quot;,
1434             attribute_length, CHECK);
1435         }
1436         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK);
1437       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
1438         if (runtime_visible_annotations != NULL) {
1439           classfile_parse_error(
1440             &quot;Multiple RuntimeVisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1441         }
1442         runtime_visible_annotations_length = attribute_length;
1443         runtime_visible_annotations = cfs-&gt;current();
1444         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
1445         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
1446         parse_annotations(cp,
1447                           runtime_visible_annotations,
1448                           runtime_visible_annotations_length,
1449                           parsed_annotations,
1450                           _loader_data,
1451                           _can_access_vm_annotations,
1452                           CHECK);
1453         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
1454       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
1455         if (runtime_invisible_annotations_exists) {
1456           classfile_parse_error(
1457             &quot;Multiple RuntimeInvisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1458         }
1459         runtime_invisible_annotations_exists = true;
1460         if (PreserveAllAnnotations) {
1461           runtime_invisible_annotations_length = attribute_length;
1462           runtime_invisible_annotations = cfs-&gt;current();
1463           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
1464         }
1465         cfs-&gt;skip_u1(attribute_length, CHECK);
1466       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
1467         if (runtime_visible_type_annotations != NULL) {
1468           classfile_parse_error(
1469             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1470         }
1471         runtime_visible_type_annotations_length = attribute_length;
1472         runtime_visible_type_annotations = cfs-&gt;current();
1473         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
1474         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
1475       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
1476         if (runtime_invisible_type_annotations_exists) {
1477           classfile_parse_error(
1478             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1479         } else {
1480           runtime_invisible_type_annotations_exists = true;
1481         }
1482         if (PreserveAllAnnotations) {
1483           runtime_invisible_type_annotations_length = attribute_length;
1484           runtime_invisible_type_annotations = cfs-&gt;current();
1485           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
1486         }
1487         cfs-&gt;skip_u1(attribute_length, CHECK);
1488       } else {
1489         cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1490       }
1491     } else {
1492       cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1493     }
1494   }
1495 
1496   *constantvalue_index_addr = constantvalue_index;
1497   *is_synthetic_addr = is_synthetic;
1498   *generic_signature_index_addr = generic_signature_index;
1499   AnnotationArray* a = assemble_annotations(runtime_visible_annotations,
1500                                             runtime_visible_annotations_length,
1501                                             runtime_invisible_annotations,
1502                                             runtime_invisible_annotations_length,
1503                                             CHECK);
1504   parsed_annotations-&gt;set_field_annotations(a);
1505   a = assemble_annotations(runtime_visible_type_annotations,
1506                            runtime_visible_type_annotations_length,
1507                            runtime_invisible_type_annotations,
1508                            runtime_invisible_type_annotations_length,
1509                            CHECK);
1510   parsed_annotations-&gt;set_field_type_annotations(a);
1511   return;
1512 }
1513 
1514 
1515 // Field allocation types. Used for computing field offsets.
1516 
1517 enum FieldAllocationType {
1518   STATIC_OOP,           // Oops
1519   STATIC_BYTE,          // Boolean, Byte, char
1520   STATIC_SHORT,         // shorts
1521   STATIC_WORD,          // ints
1522   STATIC_DOUBLE,        // aligned long or double
1523   STATIC_INLINE,        // inline type field
1524   NONSTATIC_OOP,
1525   NONSTATIC_BYTE,
1526   NONSTATIC_SHORT,
1527   NONSTATIC_WORD,
1528   NONSTATIC_DOUBLE,
1529   NONSTATIC_INLINE,
1530   MAX_FIELD_ALLOCATION_TYPE,
1531   BAD_ALLOCATION_TYPE = -1
1532 };
1533 
1534 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1535   BAD_ALLOCATION_TYPE, // 0
1536   BAD_ALLOCATION_TYPE, // 1
1537   BAD_ALLOCATION_TYPE, // 2
1538   BAD_ALLOCATION_TYPE, // 3
1539   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1540   NONSTATIC_SHORT,     // T_CHAR        =  5,
1541   NONSTATIC_WORD,      // T_FLOAT       =  6,
1542   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1543   NONSTATIC_BYTE,      // T_BYTE        =  8,
1544   NONSTATIC_SHORT,     // T_SHORT       =  9,
1545   NONSTATIC_WORD,      // T_INT         = 10,
1546   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1547   NONSTATIC_OOP,       // T_OBJECT      = 12,
1548   NONSTATIC_OOP,       // T_ARRAY       = 13,
1549   NONSTATIC_OOP,       // T_INLINE_TYPE = 14,
1550   BAD_ALLOCATION_TYPE, // T_VOID        = 15,
1551   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,
1552   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,
1553   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,
1554   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,
1555   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20,
1556   BAD_ALLOCATION_TYPE, // 0
1557   BAD_ALLOCATION_TYPE, // 1
1558   BAD_ALLOCATION_TYPE, // 2
1559   BAD_ALLOCATION_TYPE, // 3
1560   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1561   STATIC_SHORT,        // T_CHAR        =  5,
1562   STATIC_WORD,         // T_FLOAT       =  6,
1563   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1564   STATIC_BYTE,         // T_BYTE        =  8,
1565   STATIC_SHORT,        // T_SHORT       =  9,
1566   STATIC_WORD,         // T_INT         = 10,
1567   STATIC_DOUBLE,       // T_LONG        = 11,
1568   STATIC_OOP,          // T_OBJECT      = 12,
1569   STATIC_OOP,          // T_ARRAY       = 13,
1570   STATIC_OOP,          // T_INLINE_TYPE = 14,
1571   BAD_ALLOCATION_TYPE, // T_VOID        = 15,
1572   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,
1573   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,
1574   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,
1575   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,
1576   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20
1577 };
1578 
1579 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_inline_type) {
1580   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1581   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1582   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
1583   if (is_inline_type) {
1584     result = is_static ? STATIC_INLINE : NONSTATIC_INLINE;
1585   }
1586   return result;
1587 }
1588 
1589 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1590  public:
1591   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1592 
1593   FieldAllocationCount() {
1594     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1595       count[i] = 0;
1596     }
1597   }
1598 
1599   FieldAllocationType update(bool is_static, BasicType type, bool is_inline_type) {
1600     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_inline_type);
1601     if (atype != BAD_ALLOCATION_TYPE) {
1602       // Make sure there is no overflow with injected fields.
1603       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1604       count[atype]++;
1605     }
1606     return atype;
1607   }
1608 };
1609 
1610 // Side-effects: populates the _fields, _fields_annotations,
1611 // _fields_type_annotations fields
1612 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1613                                    bool is_interface,
1614                                    bool is_inline_type,
1615                                    FieldAllocationCount* const fac,
1616                                    ConstantPool* cp,
1617                                    const int cp_size,
1618                                    u2* const java_fields_count_ptr,
1619                                    TRAPS) {
1620 
1621   assert(cfs != NULL, &quot;invariant&quot;);
1622   assert(fac != NULL, &quot;invariant&quot;);
1623   assert(cp != NULL, &quot;invariant&quot;);
1624   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1625 
1626   assert(NULL == _fields, &quot;invariant&quot;);
1627   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1628   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1629 
1630   cfs-&gt;guarantee_more(2, CHECK);  // length
1631   const u2 length = cfs-&gt;get_u2_fast();
1632   *java_fields_count_ptr = length;
1633 
1634   int num_injected = 0;
1635   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1636                                                                   &amp;num_injected);
1637 
1638   // two more slots are required for inline classes:
1639   // one for the static field with a reference to the pre-allocated default value
1640   // one for the field the JVM injects when detecting an empty inline class
1641   const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);
1642 
1643   // The field array starts with tuples of shorts
1644   // [access, name index, sig index, initial value index, byte offset].
1645   // A generic signature slot only exists for field with generic
1646   // signature attribute. And the access flag is set with
1647   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1648   // signature slots are at the end of the field array and after all
1649   // other fields data.
1650   //
1651   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1652   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1653   //       ...
1654   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1655   //       [generic signature index]
1656   //       [generic signature index]
1657   //       ...
1658   //
1659   // Allocate a temporary resource array for field data. For each field,
1660   // a slot is reserved in the temporary array for the generic signature
1661   // index. After parsing all fields, the data are copied to a permanent
1662   // array and any unused slots will be discarded.
1663   ResourceMark rm(THREAD);
1664   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1665                                               u2,
1666                                               total_fields * (FieldInfo::field_slots + 1));
1667 
1668   // The generic signature slots start after all other fields&#39; data.
1669   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1670   int num_generic_signature = 0;
1671   int instance_fields_count = 0;
1672   for (int n = 0; n &lt; length; n++) {
1673     // access_flags, name_index, descriptor_index, attributes_count
1674     cfs-&gt;guarantee_more(8, CHECK);
1675 
1676     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;
1677 
1678     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
1679     verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);
1680     AccessFlags access_flags;
1681     access_flags.set_flags(flags);
1682 
1683     const u2 name_index = cfs-&gt;get_u2_fast();
1684     check_property(valid_symbol_at(name_index),
1685       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1686       name_index, CHECK);
1687     const Symbol* const name = cp-&gt;symbol_at(name_index);
1688     verify_legal_field_name(name, CHECK);
1689 
1690     const u2 signature_index = cfs-&gt;get_u2_fast();
1691     check_property(valid_symbol_at(signature_index),
1692       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1693       signature_index, CHECK);
1694     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1695     verify_legal_field_signature(name, sig, CHECK);
1696     if (!access_flags.is_static()) instance_fields_count++;
1697 
1698     u2 constantvalue_index = 0;
1699     bool is_synthetic = false;
1700     u2 generic_signature_index = 0;
1701     const bool is_static = access_flags.is_static();
1702     FieldAnnotationCollector parsed_annotations(_loader_data);
1703 
1704     const u2 attributes_count = cfs-&gt;get_u2_fast();
1705     if (attributes_count &gt; 0) {
1706       parse_field_attributes(cfs,
1707                              attributes_count,
1708                              is_static,
1709                              signature_index,
1710                              &amp;constantvalue_index,
1711                              &amp;is_synthetic,
1712                              &amp;generic_signature_index,
1713                              &amp;parsed_annotations,
1714                              CHECK);
1715 
1716       if (parsed_annotations.field_annotations() != NULL) {
1717         if (_fields_annotations == NULL) {
1718           _fields_annotations = MetadataFactory::new_array&lt;AnnotationArray*&gt;(
1719                                              _loader_data, length, NULL,
1720                                              CHECK);
1721         }
1722         _fields_annotations-&gt;at_put(n, parsed_annotations.field_annotations());
1723         parsed_annotations.set_field_annotations(NULL);
1724       }
1725       if (parsed_annotations.field_type_annotations() != NULL) {
1726         if (_fields_type_annotations == NULL) {
1727           _fields_type_annotations =
1728             MetadataFactory::new_array&lt;AnnotationArray*&gt;(_loader_data,
1729                                                          length,
1730                                                          NULL,
1731                                                          CHECK);
1732         }
1733         _fields_type_annotations-&gt;at_put(n, parsed_annotations.field_type_annotations());
1734         parsed_annotations.set_field_type_annotations(NULL);
1735       }
1736 
1737       if (is_synthetic) {
1738         access_flags.set_is_synthetic();
1739       }
1740       if (generic_signature_index != 0) {
1741         access_flags.set_field_has_generic_signature();
1742         fa[generic_signature_slot] = generic_signature_index;
1743         generic_signature_slot ++;
1744         num_generic_signature ++;
1745       }
1746     }
1747 
1748     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1749     field-&gt;initialize(access_flags.as_short(),
1750                       name_index,
1751                       signature_index,
1752                       constantvalue_index);
1753     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1754 
1755     // Remember how many oops we encountered and compute allocation type
1756     const FieldAllocationType atype = fac-&gt;update(is_static, type, type == T_INLINE_TYPE);
1757     field-&gt;set_allocation_type(atype);
1758 
1759     // After field is initialized with type, we can augment it with aux info
1760     if (parsed_annotations.has_any_annotations()) {
1761       parsed_annotations.apply_to(field);
1762       if (field-&gt;is_contended()) {
1763         _has_contended_fields = true;
1764       }
1765     }
1766   }
1767 
1768   int index = length;
1769   if (num_injected != 0) {
1770     for (int n = 0; n &lt; num_injected; n++) {
1771       // Check for duplicates
1772       if (injected[n].may_be_java) {
1773         const Symbol* const name      = injected[n].name();
1774         const Symbol* const signature = injected[n].signature();
1775         bool duplicate = false;
1776         for (int i = 0; i &lt; length; i++) {
1777           const FieldInfo* const f = FieldInfo::from_field_array(fa, i);
1778           if (name      == cp-&gt;symbol_at(f-&gt;name_index()) &amp;&amp;
1779               signature == cp-&gt;symbol_at(f-&gt;signature_index())) {
1780             // Symbol is desclared in Java so skip this one
1781             duplicate = true;
1782             break;
1783           }
1784         }
1785         if (duplicate) {
1786           // These will be removed from the field array at the end
1787           continue;
1788         }
1789       }
1790 
1791       // Injected field
1792       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1793       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1794                         injected[n].name_index,
1795                         injected[n].signature_index,
1796                         0);
1797 
1798       const BasicType type = Signature::basic_type(injected[n].signature());
1799 
1800       // Remember how many oops we encountered and compute allocation type
1801       const FieldAllocationType atype = fac-&gt;update(false, type, false);
1802       field-&gt;set_allocation_type(atype);
1803       index++;
1804     }
1805   }
1806 
1807   if (is_inline_type) {
1808     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1809     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,
1810                       vmSymbols::default_value_name_enum,
1811                       vmSymbols::object_signature_enum,
1812                       0);
1813     const BasicType type = Signature::basic_type(vmSymbols::object_signature());
1814     const FieldAllocationType atype = fac-&gt;update(true, type, false);
1815     field-&gt;set_allocation_type(atype);
1816     index++;
1817   }
1818 
1819   if (is_inline_type &amp;&amp; instance_fields_count == 0) {
1820     _is_empty_inline_type = true;
1821     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1822     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1823         vmSymbols::empty_marker_name_enum,
1824         vmSymbols::byte_signature_enum,
1825         0);
1826     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());
1827     const FieldAllocationType atype = fac-&gt;update(false, type, false);
1828     field-&gt;set_allocation_type(atype);
1829     index++;
1830   }
1831 
1832   if (instance_fields_count &gt; 0) {
1833     _has_nonstatic_fields = true;
1834   }
1835 
1836   assert(NULL == _fields, &quot;invariant&quot;);
1837 
1838   _fields =
1839     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1840                                    index * FieldInfo::field_slots + num_generic_signature,
1841                                    CHECK);
1842   // Sometimes injected fields already exist in the Java source so
1843   // the fields array could be too long.  In that case the
1844   // fields array is trimed. Also unused slots that were reserved
1845   // for generic signature indexes are discarded.
1846   {
1847     int i = 0;
1848     for (; i &lt; index * FieldInfo::field_slots; i++) {
1849       _fields-&gt;at_put(i, fa[i]);
1850     }
1851     for (int j = total_fields * FieldInfo::field_slots;
1852          j &lt; generic_signature_slot; j++) {
1853       _fields-&gt;at_put(i++, fa[j]);
1854     }
1855     assert(_fields-&gt;length() == i, &quot;&quot;);
1856   }
1857 
1858   if (_need_verify &amp;&amp; length &gt; 1) {
1859     // Check duplicated fields
1860     ResourceMark rm(THREAD);
1861     NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
1862       THREAD, NameSigHash*, HASH_ROW_SIZE);
1863     initialize_hashtable(names_and_sigs);
1864     bool dup = false;
1865     const Symbol* name = NULL;
1866     const Symbol* sig = NULL;
1867     {
1868       debug_only(NoSafepointVerifier nsv;)
1869       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
1870         name = fs.name();
1871         sig = fs.signature();
1872         // If no duplicates, add name/signature in hashtable names_and_sigs.
1873         if (!put_after_lookup(name, sig, names_and_sigs)) {
1874           dup = true;
1875           break;
1876         }
1877       }
1878     }
1879     if (dup) {
1880       classfile_parse_error(&quot;Duplicate field name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
1881                              name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
1882     }
1883   }
1884 }
1885 
1886 
1887 const ClassFileParser::unsafe_u2* ClassFileParser::parse_exception_table(const ClassFileStream* const cfs,
1888                                                                          u4 code_length,
1889                                                                          u4 exception_table_length,
1890                                                                          TRAPS) {
1891   assert(cfs != NULL, &quot;invariant&quot;);
1892 
1893   const unsafe_u2* const exception_table_start = cfs-&gt;current();
1894   assert(exception_table_start != NULL, &quot;null exception table&quot;);
1895 
1896   cfs-&gt;guarantee_more(8 * exception_table_length, CHECK_NULL); // start_pc,
1897                                                                // end_pc,
1898                                                                // handler_pc,
1899                                                                // catch_type_index
1900 
1901   // Will check legal target after parsing code array in verifier.
1902   if (_need_verify) {
1903     for (unsigned int i = 0; i &lt; exception_table_length; i++) {
1904       const u2 start_pc = cfs-&gt;get_u2_fast();
1905       const u2 end_pc = cfs-&gt;get_u2_fast();
1906       const u2 handler_pc = cfs-&gt;get_u2_fast();
1907       const u2 catch_type_index = cfs-&gt;get_u2_fast();
1908       guarantee_property((start_pc &lt; end_pc) &amp;&amp; (end_pc &lt;= code_length),
1909                          &quot;Illegal exception table range in class file %s&quot;,
1910                          CHECK_NULL);
1911       guarantee_property(handler_pc &lt; code_length,
1912                          &quot;Illegal exception table handler in class file %s&quot;,
1913                          CHECK_NULL);
1914       if (catch_type_index != 0) {
1915         guarantee_property(valid_klass_reference_at(catch_type_index),
1916                            &quot;Catch type in exception table has bad constant type in class file %s&quot;, CHECK_NULL);
1917       }
1918     }
1919   } else {
1920     cfs-&gt;skip_u2_fast(exception_table_length * 4);
1921   }
1922   return exception_table_start;
1923 }
1924 
1925 void ClassFileParser::parse_linenumber_table(u4 code_attribute_length,
1926                                              u4 code_length,
1927                                              CompressedLineNumberWriteStream**const write_stream,
1928                                              TRAPS) {
1929 
1930   const ClassFileStream* const cfs = _stream;
1931   unsigned int num_entries = cfs-&gt;get_u2(CHECK);
1932 
1933   // Each entry is a u2 start_pc, and a u2 line_number
1934   const unsigned int length_in_bytes = num_entries * (sizeof(u2) * 2);
1935 
1936   // Verify line number attribute and table length
1937   check_property(
1938     code_attribute_length == sizeof(u2) + length_in_bytes,
1939     &quot;LineNumberTable attribute has wrong length in class file %s&quot;, CHECK);
1940 
1941   cfs-&gt;guarantee_more(length_in_bytes, CHECK);
1942 
1943   if ((*write_stream) == NULL) {
1944     if (length_in_bytes &gt; fixed_buffer_size) {
1945       (*write_stream) = new CompressedLineNumberWriteStream(length_in_bytes);
1946     } else {
1947       (*write_stream) = new CompressedLineNumberWriteStream(
1948         _linenumbertable_buffer, fixed_buffer_size);
1949     }
1950   }
1951 
1952   while (num_entries-- &gt; 0) {
1953     const u2 bci  = cfs-&gt;get_u2_fast(); // start_pc
1954     const u2 line = cfs-&gt;get_u2_fast(); // line_number
1955     guarantee_property(bci &lt; code_length,
1956         &quot;Invalid pc in LineNumberTable in class file %s&quot;, CHECK);
1957     (*write_stream)-&gt;write_pair(bci, line);
1958   }
1959 }
1960 
1961 
1962 class LVT_Hash : public AllStatic {
1963  public:
1964 
1965   static bool equals(LocalVariableTableElement const&amp; e0, LocalVariableTableElement const&amp; e1) {
1966   /*
1967    * 3-tuple start_bci/length/slot has to be unique key,
1968    * so the following comparison seems to be redundant:
1969    *       &amp;&amp; elem-&gt;name_cp_index == entry-&gt;_elem-&gt;name_cp_index
1970    */
1971     return (e0.start_bci     == e1.start_bci &amp;&amp;
1972             e0.length        == e1.length &amp;&amp;
1973             e0.name_cp_index == e1.name_cp_index &amp;&amp;
1974             e0.slot          == e1.slot);
1975   }
1976 
1977   static unsigned int hash(LocalVariableTableElement const&amp; e0) {
1978     unsigned int raw_hash = e0.start_bci;
1979 
1980     raw_hash = e0.length        + raw_hash * 37;
1981     raw_hash = e0.name_cp_index + raw_hash * 37;
1982     raw_hash = e0.slot          + raw_hash * 37;
1983 
1984     return raw_hash;
1985   }
1986 };
1987 
1988 
1989 // Class file LocalVariableTable elements.
1990 class Classfile_LVT_Element {
1991  public:
1992   u2 start_bci;
1993   u2 length;
1994   u2 name_cp_index;
1995   u2 descriptor_cp_index;
1996   u2 slot;
1997 };
1998 
1999 static void copy_lvt_element(const Classfile_LVT_Element* const src,
2000                              LocalVariableTableElement* const lvt) {
2001   lvt-&gt;start_bci           = Bytes::get_Java_u2((u1*) &amp;src-&gt;start_bci);
2002   lvt-&gt;length              = Bytes::get_Java_u2((u1*) &amp;src-&gt;length);
2003   lvt-&gt;name_cp_index       = Bytes::get_Java_u2((u1*) &amp;src-&gt;name_cp_index);
2004   lvt-&gt;descriptor_cp_index = Bytes::get_Java_u2((u1*) &amp;src-&gt;descriptor_cp_index);
2005   lvt-&gt;signature_cp_index  = 0;
2006   lvt-&gt;slot                = Bytes::get_Java_u2((u1*) &amp;src-&gt;slot);
2007 }
2008 
2009 // Function is used to parse both attributes:
2010 // LocalVariableTable (LVT) and LocalVariableTypeTable (LVTT)
2011 const ClassFileParser::unsafe_u2* ClassFileParser::parse_localvariable_table(const ClassFileStream* cfs,
2012                                                                              u4 code_length,
2013                                                                              u2 max_locals,
2014                                                                              u4 code_attribute_length,
2015                                                                              u2* const localvariable_table_length,
2016                                                                              bool isLVTT,
2017                                                                              TRAPS) {
2018   const char* const tbl_name = (isLVTT) ? &quot;LocalVariableTypeTable&quot; : &quot;LocalVariableTable&quot;;
2019   *localvariable_table_length = cfs-&gt;get_u2(CHECK_NULL);
2020   const unsigned int size =
2021     (*localvariable_table_length) * sizeof(Classfile_LVT_Element) / sizeof(u2);
2022 
2023   const ConstantPool* const cp = _cp;
2024 
2025   // Verify local variable table attribute has right length
2026   if (_need_verify) {
2027     guarantee_property(code_attribute_length == (sizeof(*localvariable_table_length) + size * sizeof(u2)),
2028                        &quot;%s has wrong length in class file %s&quot;, tbl_name, CHECK_NULL);
2029   }
2030 
2031   const unsafe_u2* const localvariable_table_start = cfs-&gt;current();
2032   assert(localvariable_table_start != NULL, &quot;null local variable table&quot;);
2033   if (!_need_verify) {
2034     cfs-&gt;skip_u2_fast(size);
2035   } else {
2036     cfs-&gt;guarantee_more(size * 2, CHECK_NULL);
2037     for(int i = 0; i &lt; (*localvariable_table_length); i++) {
2038       const u2 start_pc = cfs-&gt;get_u2_fast();
2039       const u2 length = cfs-&gt;get_u2_fast();
2040       const u2 name_index = cfs-&gt;get_u2_fast();
2041       const u2 descriptor_index = cfs-&gt;get_u2_fast();
2042       const u2 index = cfs-&gt;get_u2_fast();
2043       // Assign to a u4 to avoid overflow
2044       const u4 end_pc = (u4)start_pc + (u4)length;
2045 
2046       if (start_pc &gt;= code_length) {
2047         classfile_parse_error(
2048           &quot;Invalid start_pc %u in %s in class file %s&quot;,
2049           start_pc, tbl_name, CHECK_NULL);
2050       }
2051       if (end_pc &gt; code_length) {
2052         classfile_parse_error(
2053           &quot;Invalid length %u in %s in class file %s&quot;,
2054           length, tbl_name, CHECK_NULL);
2055       }
2056       const int cp_size = cp-&gt;length();
2057       guarantee_property(valid_symbol_at(name_index),
2058         &quot;Name index %u in %s has bad constant type in class file %s&quot;,
2059         name_index, tbl_name, CHECK_NULL);
2060       guarantee_property(valid_symbol_at(descriptor_index),
2061         &quot;Signature index %u in %s has bad constant type in class file %s&quot;,
2062         descriptor_index, tbl_name, CHECK_NULL);
2063 
2064       const Symbol* const name = cp-&gt;symbol_at(name_index);
2065       const Symbol* const sig = cp-&gt;symbol_at(descriptor_index);
2066       verify_legal_field_name(name, CHECK_NULL);
2067       u2 extra_slot = 0;
2068       if (!isLVTT) {
2069         verify_legal_field_signature(name, sig, CHECK_NULL);
2070 
2071         // 4894874: check special cases for double and long local variables
2072         if (sig == vmSymbols::type_signature(T_DOUBLE) ||
2073             sig == vmSymbols::type_signature(T_LONG)) {
2074           extra_slot = 1;
2075         }
2076       }
2077       guarantee_property((index + extra_slot) &lt; max_locals,
2078                           &quot;Invalid index %u in %s in class file %s&quot;,
2079                           index, tbl_name, CHECK_NULL);
2080     }
2081   }
2082   return localvariable_table_start;
2083 }
2084 
2085 static const u1* parse_stackmap_table(const ClassFileStream* const cfs,
2086                                       u4 code_attribute_length,
2087                                       bool need_verify,
2088                                       TRAPS) {
2089   assert(cfs != NULL, &quot;invariant&quot;);
2090 
2091   if (0 == code_attribute_length) {
2092     return NULL;
2093   }
2094 
2095   const u1* const stackmap_table_start = cfs-&gt;current();
2096   assert(stackmap_table_start != NULL, &quot;null stackmap table&quot;);
2097 
2098   // check code_attribute_length first
2099   cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
2100 
2101   if (!need_verify &amp;&amp; !DumpSharedSpaces) {
2102     return NULL;
2103   }
2104   return stackmap_table_start;
2105 }
2106 
2107 const ClassFileParser::unsafe_u2* ClassFileParser::parse_checked_exceptions(const ClassFileStream* const cfs,
2108                                                                             u2* const checked_exceptions_length,
2109                                                                             u4 method_attribute_length,
2110                                                                             TRAPS) {
2111   assert(cfs != NULL, &quot;invariant&quot;);
2112   assert(checked_exceptions_length != NULL, &quot;invariant&quot;);
2113 
2114   cfs-&gt;guarantee_more(2, CHECK_NULL);  // checked_exceptions_length
2115   *checked_exceptions_length = cfs-&gt;get_u2_fast();
2116   const unsigned int size =
2117     (*checked_exceptions_length) * sizeof(CheckedExceptionElement) / sizeof(u2);
2118   const unsafe_u2* const checked_exceptions_start = cfs-&gt;current();
2119   assert(checked_exceptions_start != NULL, &quot;null checked exceptions&quot;);
2120   if (!_need_verify) {
2121     cfs-&gt;skip_u2_fast(size);
2122   } else {
2123     // Verify each value in the checked exception table
2124     u2 checked_exception;
2125     const u2 len = *checked_exceptions_length;
2126     cfs-&gt;guarantee_more(2 * len, CHECK_NULL);
2127     for (int i = 0; i &lt; len; i++) {
2128       checked_exception = cfs-&gt;get_u2_fast();
2129       check_property(
2130         valid_klass_reference_at(checked_exception),
2131         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2132         checked_exception, CHECK_NULL);
2133     }
2134   }
2135   // check exceptions attribute length
2136   if (_need_verify) {
2137     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2138                                                    sizeof(u2) * size),
2139                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2140   }
2141   return checked_exceptions_start;
2142 }
2143 
2144 void ClassFileParser::throwIllegalSignature(const char* type,
2145                                             const Symbol* name,
2146                                             const Symbol* sig,
2147                                             TRAPS) const {
2148   assert(name != NULL, &quot;invariant&quot;);
2149   assert(sig != NULL, &quot;invariant&quot;);
2150 
2151   const char* class_note = &quot;&quot;;
2152   if (is_inline_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {
2153     class_note = &quot; (an inline class)&quot;;
2154   }
2155 
2156   ResourceMark rm(THREAD);
2157   Exceptions::fthrow(THREAD_AND_LOCATION,
2158       vmSymbols::java_lang_ClassFormatError(),
2159       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,
2160       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());
2161 }
2162 
2163 AnnotationCollector::ID
2164 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2165                                       const Symbol* name,
2166                                       const bool can_access_vm_annotations) {
2167   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2168   // Privileged code can use all annotations.  Other code silently drops some.
2169   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2170                           loader_data-&gt;is_platform_class_loader_data() ||
2171                           can_access_vm_annotations;
2172   switch (sid) {
2173     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2174       if (_location != _in_method)  break;  // only allow for methods
2175       if (!privileged)              break;  // only allow in privileged code
2176       return _method_CallerSensitive;
2177     }
2178     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2179       if (_location != _in_method)  break;  // only allow for methods
2180       if (!privileged)              break;  // only allow in privileged code
2181       return _method_ForceInline;
2182     }
2183     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {
2184       if (_location != _in_method)  break;  // only allow for methods
2185       if (!privileged)              break;  // only allow in privileged code
2186       return _method_DontInline;
2187     }
2188     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {
2189       if (_location != _in_method)  break;  // only allow for methods
2190       if (!privileged)              break;  // only allow in privileged code
2191       return _method_InjectedProfile;
2192     }
2193     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_LambdaForm_Compiled_signature): {
2194       if (_location != _in_method)  break;  // only allow for methods
2195       if (!privileged)              break;  // only allow in privileged code
2196       return _method_LambdaForm_Compiled;
2197     }
2198     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Hidden_signature): {
2199       if (_location != _in_method)  break;  // only allow for methods
2200       if (!privileged)              break;  // only allow in privileged code
2201       return _method_Hidden;
2202     }
2203     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_HotSpotIntrinsicCandidate_signature): {
2204       if (_location != _in_method)  break;  // only allow for methods
2205       if (!privileged)              break;  // only allow in privileged code
2206       return _method_HotSpotIntrinsicCandidate;
2207     }
2208     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Stable_signature): {
2209       if (_location != _in_field)   break;  // only allow for fields
2210       if (!privileged)              break;  // only allow in privileged code
2211       return _field_Stable;
2212     }
2213     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Contended_signature): {
2214       if (_location != _in_field &amp;&amp; _location != _in_class) {
2215         break;  // only allow for fields and classes
2216       }
2217       if (!EnableContended || (RestrictContended &amp;&amp; !privileged)) {
2218         break;  // honor privileges
2219       }
2220       return _jdk_internal_vm_annotation_Contended;
2221     }
2222     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ReservedStackAccess_signature): {
2223       if (_location != _in_method)  break;  // only allow for methods
2224       if (RestrictReservedStack &amp;&amp; !privileged) break; // honor privileges
2225       return _jdk_internal_vm_annotation_ReservedStackAccess;
2226     }
2227     default: {
2228       break;
2229     }
2230   }
2231   return AnnotationCollector::_unknown;
2232 }
2233 
2234 void ClassFileParser::FieldAnnotationCollector::apply_to(FieldInfo* f) {
2235   if (is_contended())
2236     f-&gt;set_contended_group(contended_group());
2237   if (is_stable())
2238     f-&gt;set_stable(true);
2239 }
2240 
2241 ClassFileParser::FieldAnnotationCollector::~FieldAnnotationCollector() {
2242   // If there&#39;s an error deallocate metadata for field annotations
2243   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_annotations);
2244   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_type_annotations);
2245 }
2246 
2247 void MethodAnnotationCollector::apply_to(const methodHandle&amp; m) {
2248   if (has_annotation(_method_CallerSensitive))
2249     m-&gt;set_caller_sensitive(true);
2250   if (has_annotation(_method_ForceInline))
2251     m-&gt;set_force_inline(true);
2252   if (has_annotation(_method_DontInline))
2253     m-&gt;set_dont_inline(true);
2254   if (has_annotation(_method_InjectedProfile))
2255     m-&gt;set_has_injected_profile(true);
2256   if (has_annotation(_method_LambdaForm_Compiled) &amp;&amp; m-&gt;intrinsic_id() == vmIntrinsics::_none)
2257     m-&gt;set_intrinsic_id(vmIntrinsics::_compiledLambdaForm);
2258   if (has_annotation(_method_Hidden))
2259     m-&gt;set_hidden(true);
2260   if (has_annotation(_method_HotSpotIntrinsicCandidate) &amp;&amp; !m-&gt;is_synthetic())
2261     m-&gt;set_intrinsic_candidate(true);
2262   if (has_annotation(_jdk_internal_vm_annotation_ReservedStackAccess))
2263     m-&gt;set_has_reserved_stack_access(true);
2264 }
2265 
2266 void ClassFileParser::ClassAnnotationCollector::apply_to(InstanceKlass* ik) {
2267   assert(ik != NULL, &quot;invariant&quot;);
2268   ik-&gt;set_is_contended(is_contended());
2269 }
2270 
2271 #define MAX_ARGS_SIZE 255
2272 #define MAX_CODE_SIZE 65535
2273 #define INITIAL_MAX_LVT_NUMBER 256
2274 
2275 /* Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2276  *
2277  * Rules for LVT&#39;s and LVTT&#39;s are:
2278  *   - There can be any number of LVT&#39;s and LVTT&#39;s.
2279  *   - If there are n LVT&#39;s, it is the same as if there was just
2280  *     one LVT containing all the entries from the n LVT&#39;s.
2281  *   - There may be no more than one LVT entry per local variable.
2282  *     Two LVT entries are &#39;equal&#39; if these fields are the same:
2283  *        start_pc, length, name, slot
2284  *   - There may be no more than one LVTT entry per each LVT entry.
2285  *     Each LVTT entry has to match some LVT entry.
2286  *   - HotSpot internal LVT keeps natural ordering of class file LVT entries.
2287  */
2288 void ClassFileParser::copy_localvariable_table(const ConstMethod* cm,
2289                                                int lvt_cnt,
2290                                                u2* const localvariable_table_length,
2291                                                const unsafe_u2** const localvariable_table_start,
2292                                                int lvtt_cnt,
2293                                                u2* const localvariable_type_table_length,
2294                                                const unsafe_u2** const localvariable_type_table_start,
2295                                                TRAPS) {
2296 
2297   ResourceMark rm(THREAD);
2298 
2299   typedef ResourceHashtable&lt;LocalVariableTableElement, LocalVariableTableElement*,
2300                             &amp;LVT_Hash::hash, &amp;LVT_Hash::equals&gt; LVT_HashTable;
2301 
2302   LVT_HashTable* const table = new LVT_HashTable();
2303 
2304   // To fill LocalVariableTable in
2305   const Classfile_LVT_Element* cf_lvt;
2306   LocalVariableTableElement* lvt = cm-&gt;localvariable_table_start();
2307 
2308   for (int tbl_no = 0; tbl_no &lt; lvt_cnt; tbl_no++) {
2309     cf_lvt = (Classfile_LVT_Element *) localvariable_table_start[tbl_no];
2310     for (int idx = 0; idx &lt; localvariable_table_length[tbl_no]; idx++, lvt++) {
2311       copy_lvt_element(&amp;cf_lvt[idx], lvt);
2312       // If no duplicates, add LVT elem in hashtable.
2313       if (table-&gt;put(*lvt, lvt) == false
2314           &amp;&amp; _need_verify
2315           &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
2316         classfile_parse_error(&quot;Duplicated LocalVariableTable attribute &quot;
2317                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2318                                _cp-&gt;symbol_at(lvt-&gt;name_cp_index)-&gt;as_utf8(),
2319                                CHECK);
2320       }
2321     }
2322   }
2323 
2324   // To merge LocalVariableTable and LocalVariableTypeTable
2325   const Classfile_LVT_Element* cf_lvtt;
2326   LocalVariableTableElement lvtt_elem;
2327 
2328   for (int tbl_no = 0; tbl_no &lt; lvtt_cnt; tbl_no++) {
2329     cf_lvtt = (Classfile_LVT_Element *) localvariable_type_table_start[tbl_no];
2330     for (int idx = 0; idx &lt; localvariable_type_table_length[tbl_no]; idx++) {
2331       copy_lvt_element(&amp;cf_lvtt[idx], &amp;lvtt_elem);
2332       LocalVariableTableElement** entry = table-&gt;get(lvtt_elem);
2333       if (entry == NULL) {
2334         if (_need_verify) {
2335           classfile_parse_error(&quot;LVTT entry for &#39;%s&#39; in class file %s &quot;
2336                                 &quot;does not match any LVT entry&quot;,
2337                                  _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2338                                  CHECK);
2339         }
2340       } else if ((*entry)-&gt;signature_cp_index != 0 &amp;&amp; _need_verify) {
2341         classfile_parse_error(&quot;Duplicated LocalVariableTypeTable attribute &quot;
2342                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2343                                _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2344                                CHECK);
2345       } else {
2346         // to add generic signatures into LocalVariableTable
2347         (*entry)-&gt;signature_cp_index = lvtt_elem.descriptor_cp_index;
2348       }
2349     }
2350   }
2351 }
2352 
2353 
2354 void ClassFileParser::copy_method_annotations(ConstMethod* cm,
2355                                        const u1* runtime_visible_annotations,
2356                                        int runtime_visible_annotations_length,
2357                                        const u1* runtime_invisible_annotations,
2358                                        int runtime_invisible_annotations_length,
2359                                        const u1* runtime_visible_parameter_annotations,
2360                                        int runtime_visible_parameter_annotations_length,
2361                                        const u1* runtime_invisible_parameter_annotations,
2362                                        int runtime_invisible_parameter_annotations_length,
2363                                        const u1* runtime_visible_type_annotations,
2364                                        int runtime_visible_type_annotations_length,
2365                                        const u1* runtime_invisible_type_annotations,
2366                                        int runtime_invisible_type_annotations_length,
2367                                        const u1* annotation_default,
2368                                        int annotation_default_length,
2369                                        TRAPS) {
2370 
2371   AnnotationArray* a;
2372 
2373   if (runtime_visible_annotations_length +
2374       runtime_invisible_annotations_length &gt; 0) {
2375      a = assemble_annotations(runtime_visible_annotations,
2376                               runtime_visible_annotations_length,
2377                               runtime_invisible_annotations,
2378                               runtime_invisible_annotations_length,
2379                               CHECK);
2380      cm-&gt;set_method_annotations(a);
2381   }
2382 
2383   if (runtime_visible_parameter_annotations_length +
2384       runtime_invisible_parameter_annotations_length &gt; 0) {
2385     a = assemble_annotations(runtime_visible_parameter_annotations,
2386                              runtime_visible_parameter_annotations_length,
2387                              runtime_invisible_parameter_annotations,
2388                              runtime_invisible_parameter_annotations_length,
2389                              CHECK);
2390     cm-&gt;set_parameter_annotations(a);
2391   }
2392 
2393   if (annotation_default_length &gt; 0) {
2394     a = assemble_annotations(annotation_default,
2395                              annotation_default_length,
2396                              NULL,
2397                              0,
2398                              CHECK);
2399     cm-&gt;set_default_annotations(a);
2400   }
2401 
2402   if (runtime_visible_type_annotations_length +
2403       runtime_invisible_type_annotations_length &gt; 0) {
2404     a = assemble_annotations(runtime_visible_type_annotations,
2405                              runtime_visible_type_annotations_length,
2406                              runtime_invisible_type_annotations,
2407                              runtime_invisible_type_annotations_length,
2408                              CHECK);
2409     cm-&gt;set_type_annotations(a);
2410   }
2411 }
2412 
2413 
2414 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2415 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2416 // Method* to save footprint, so we only know the size of the resulting Method* when the
2417 // entire method attribute is parsed.
2418 //
2419 // The promoted_flags parameter is used to pass relevant access_flags
2420 // from the method back up to the containing klass. These flag values
2421 // are added to klass&#39;s access_flags.
2422 
2423 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2424                                       bool is_interface,
2425                                       bool is_inline_type,
2426                                       const ConstantPool* cp,
2427                                       AccessFlags* const promoted_flags,
2428                                       TRAPS) {
2429   assert(cfs != NULL, &quot;invariant&quot;);
2430   assert(cp != NULL, &quot;invariant&quot;);
2431   assert(promoted_flags != NULL, &quot;invariant&quot;);
2432 
2433   ResourceMark rm(THREAD);
2434   // Parse fixed parts:
2435   // access_flags, name_index, descriptor_index, attributes_count
2436   cfs-&gt;guarantee_more(8, CHECK_NULL);
2437 
2438   int flags = cfs-&gt;get_u2_fast();
2439   const u2 name_index = cfs-&gt;get_u2_fast();
2440   const int cp_size = cp-&gt;length();
2441   check_property(
2442     valid_symbol_at(name_index),
2443     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2444     name_index, CHECK_NULL);
2445   const Symbol* const name = cp-&gt;symbol_at(name_index);
2446   verify_legal_method_name(name, CHECK_NULL);
2447 
2448   const u2 signature_index = cfs-&gt;get_u2_fast();
2449   guarantee_property(
2450     valid_symbol_at(signature_index),
2451     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2452     signature_index, CHECK_NULL);
2453   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2454 
2455   if (name == vmSymbols::class_initializer_name()) {
2456     // We ignore the other access flags for a valid class initializer.
2457     // (JVM Spec 2nd ed., chapter 4.6)
2458     if (_major_version &lt; 51) { // backward compatibility
2459       flags = JVM_ACC_STATIC;
2460     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2461       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2462     } else {
2463       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2464     }
2465   } else {
2466     verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);
2467   }
2468 
2469   if (name == vmSymbols::object_initializer_name()) {
2470     if (is_interface) {
2471       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);
2472     } else if (!is_inline_type &amp;&amp; signature-&gt;is_void_method_signature()) {
2473       // OK, a constructor
2474     } else if (is_inline_type &amp;&amp; !signature-&gt;is_void_method_signature()) {
2475       // also OK, a static factory, as long as the return value is good
2476       bool ok = false;
2477       SignatureStream ss((Symbol*) signature, true);
2478       while (!ss.at_return_type())  ss.next();
2479       if (ss.is_reference()) {
2480         Symbol* ret = ss.as_symbol();
2481         const Symbol* required = class_name();
2482         if (is_hidden()) {
2483           // The original class name in hidden classes gets changed.  So using
2484           // the original name in the return type is no longer valid.
2485           // Note that expecting the return type for inline hidden class factory
2486           // methods to be java.lang.Object works around a JVM Spec issue for
2487           // hidden classes.
2488           required = vmSymbols::java_lang_Object();
2489         }
2490         ok = (ret == required);
2491       }
2492       if (!ok) {
2493         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
2494       }
2495     } else {
2496       // not OK, so throw the same error as in verify_legal_method_signature.
2497       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
2498     }
2499     // A declared &lt;init&gt; method must always be either a non-static
2500     // object constructor, with a void return, or else it must be a
2501     // static factory method, with a non-void return.  No other
2502     // definition of &lt;init&gt; is possible.
2503     //
2504     // The verifier (in verify_invoke_instructions) will inspect the
2505     // signature of any attempt to invoke &lt;init&gt;, and ensures that it
2506     // returns non-void if and only if it is being invoked by
2507     // invokestatic, and void if and only if it is being invoked by
2508     // invokespecial.
2509     //
2510     // When a symbolic reference to &lt;init&gt; is resolved for a
2511     // particular invocation mode (special or static), the mode is
2512     // matched to the JVM_ACC_STATIC modifier of the &lt;init&gt; method.
2513     // Thus, it is impossible to statically invoke a constructor, and
2514     // impossible to &quot;new + invokespecial&quot; a static factory, either
2515     // through bytecode or through reflection.
2516   }
2517 
2518   int args_size = -1;  // only used when _need_verify is true
2519   if (_need_verify) {
2520     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2521                  verify_legal_method_signature(name, signature, CHECK_NULL);
2522     if (args_size &gt; MAX_ARGS_SIZE) {
2523       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2524     }
2525   }
2526 
2527   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2528 
2529   // Default values for code and exceptions attribute elements
2530   u2 max_stack = 0;
2531   u2 max_locals = 0;
2532   u4 code_length = 0;
2533   const u1* code_start = 0;
2534   u2 exception_table_length = 0;
2535   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2536   Array&lt;int&gt;* exception_handlers = Universe::the_empty_int_array();
2537   u2 checked_exceptions_length = 0;
2538   const unsafe_u2* checked_exceptions_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2539   CompressedLineNumberWriteStream* linenumber_table = NULL;
2540   int linenumber_table_length = 0;
2541   int total_lvt_length = 0;
2542   u2 lvt_cnt = 0;
2543   u2 lvtt_cnt = 0;
2544   bool lvt_allocated = false;
2545   u2 max_lvt_cnt = INITIAL_MAX_LVT_NUMBER;
2546   u2 max_lvtt_cnt = INITIAL_MAX_LVT_NUMBER;
2547   u2* localvariable_table_length = NULL;
2548   const unsafe_u2** localvariable_table_start = NULL; // (potentially unaligned) pointer to array of LVT attributes
2549   u2* localvariable_type_table_length = NULL;
2550   const unsafe_u2** localvariable_type_table_start = NULL; // (potentially unaligned) pointer to LVTT attributes
2551   int method_parameters_length = -1;
2552   const u1* method_parameters_data = NULL;
2553   bool method_parameters_seen = false;
2554   bool parsed_code_attribute = false;
2555   bool parsed_checked_exceptions_attribute = false;
2556   bool parsed_stackmap_attribute = false;
2557   // stackmap attribute - JDK1.5
2558   const u1* stackmap_data = NULL;
2559   int stackmap_data_length = 0;
2560   u2 generic_signature_index = 0;
2561   MethodAnnotationCollector parsed_annotations;
2562   const u1* runtime_visible_annotations = NULL;
2563   int runtime_visible_annotations_length = 0;
2564   const u1* runtime_invisible_annotations = NULL;
2565   int runtime_invisible_annotations_length = 0;
2566   const u1* runtime_visible_parameter_annotations = NULL;
2567   int runtime_visible_parameter_annotations_length = 0;
2568   const u1* runtime_invisible_parameter_annotations = NULL;
2569   int runtime_invisible_parameter_annotations_length = 0;
2570   const u1* runtime_visible_type_annotations = NULL;
2571   int runtime_visible_type_annotations_length = 0;
2572   const u1* runtime_invisible_type_annotations = NULL;
2573   int runtime_invisible_type_annotations_length = 0;
2574   bool runtime_invisible_annotations_exists = false;
2575   bool runtime_invisible_type_annotations_exists = false;
2576   bool runtime_invisible_parameter_annotations_exists = false;
2577   const u1* annotation_default = NULL;
2578   int annotation_default_length = 0;
2579 
2580   // Parse code and exceptions attribute
2581   u2 method_attributes_count = cfs-&gt;get_u2_fast();
2582   while (method_attributes_count--) {
2583     cfs-&gt;guarantee_more(6, CHECK_NULL);  // method_attribute_name_index, method_attribute_length
2584     const u2 method_attribute_name_index = cfs-&gt;get_u2_fast();
2585     const u4 method_attribute_length = cfs-&gt;get_u4_fast();
2586     check_property(
2587       valid_symbol_at(method_attribute_name_index),
2588       &quot;Invalid method attribute name index %u in class file %s&quot;,
2589       method_attribute_name_index, CHECK_NULL);
2590 
2591     const Symbol* const method_attribute_name = cp-&gt;symbol_at(method_attribute_name_index);
2592     if (method_attribute_name == vmSymbols::tag_code()) {
2593       // Parse Code attribute
2594       if (_need_verify) {
2595         guarantee_property(
2596             !access_flags.is_native() &amp;&amp; !access_flags.is_abstract(),
2597                         &quot;Code attribute in native or abstract methods in class file %s&quot;,
2598                          CHECK_NULL);
2599       }
2600       if (parsed_code_attribute) {
2601         classfile_parse_error(&quot;Multiple Code attributes in class file %s&quot;,
2602                               CHECK_NULL);
2603       }
2604       parsed_code_attribute = true;
2605 
2606       // Stack size, locals size, and code size
2607       cfs-&gt;guarantee_more(8, CHECK_NULL);
2608       max_stack = cfs-&gt;get_u2_fast();
2609       max_locals = cfs-&gt;get_u2_fast();
2610       code_length = cfs-&gt;get_u4_fast();
2611       if (_need_verify) {
2612         guarantee_property(args_size &lt;= max_locals,
2613                            &quot;Arguments can&#39;t fit into locals in class file %s&quot;,
2614                            CHECK_NULL);
2615         guarantee_property(code_length &gt; 0 &amp;&amp; code_length &lt;= MAX_CODE_SIZE,
2616                            &quot;Invalid method Code length %u in class file %s&quot;,
2617                            code_length, CHECK_NULL);
2618       }
2619       // Code pointer
2620       code_start = cfs-&gt;current();
2621       assert(code_start != NULL, &quot;null code start&quot;);
2622       cfs-&gt;guarantee_more(code_length, CHECK_NULL);
2623       cfs-&gt;skip_u1_fast(code_length);
2624 
2625       // Exception handler table
2626       cfs-&gt;guarantee_more(2, CHECK_NULL);  // exception_table_length
2627       exception_table_length = cfs-&gt;get_u2_fast();
2628       if (exception_table_length &gt; 0) {
2629         exception_table_start = parse_exception_table(cfs,
2630                                                       code_length,
2631                                                       exception_table_length,
2632                                                       CHECK_NULL);
2633       }
2634 
2635       // Parse additional attributes in code attribute
2636       cfs-&gt;guarantee_more(2, CHECK_NULL);  // code_attributes_count
2637       u2 code_attributes_count = cfs-&gt;get_u2_fast();
2638 
2639       unsigned int calculated_attribute_length = 0;
2640 
2641       calculated_attribute_length =
2642           sizeof(max_stack) + sizeof(max_locals) + sizeof(code_length);
2643       calculated_attribute_length +=
2644         code_length +
2645         sizeof(exception_table_length) +
2646         sizeof(code_attributes_count) +
2647         exception_table_length *
2648             ( sizeof(u2) +   // start_pc
2649               sizeof(u2) +   // end_pc
2650               sizeof(u2) +   // handler_pc
2651               sizeof(u2) );  // catch_type_index
2652 
2653       while (code_attributes_count--) {
2654         cfs-&gt;guarantee_more(6, CHECK_NULL);  // code_attribute_name_index, code_attribute_length
2655         const u2 code_attribute_name_index = cfs-&gt;get_u2_fast();
2656         const u4 code_attribute_length = cfs-&gt;get_u4_fast();
2657         calculated_attribute_length += code_attribute_length +
2658                                        sizeof(code_attribute_name_index) +
2659                                        sizeof(code_attribute_length);
2660         check_property(valid_symbol_at(code_attribute_name_index),
2661                        &quot;Invalid code attribute name index %u in class file %s&quot;,
2662                        code_attribute_name_index,
2663                        CHECK_NULL);
2664         if (LoadLineNumberTables &amp;&amp;
2665             cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_line_number_table()) {
2666           // Parse and compress line number table
2667           parse_linenumber_table(code_attribute_length,
2668                                  code_length,
2669                                  &amp;linenumber_table,
2670                                  CHECK_NULL);
2671 
2672         } else if (LoadLocalVariableTables &amp;&amp;
2673                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_table()) {
2674           // Parse local variable table
2675           if (!lvt_allocated) {
2676             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2677               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2678             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2679               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2680             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2681               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2682             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2683               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2684             lvt_allocated = true;
2685           }
2686           if (lvt_cnt == max_lvt_cnt) {
2687             max_lvt_cnt &lt;&lt;= 1;
2688             localvariable_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_table_length, lvt_cnt, max_lvt_cnt);
2689             localvariable_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_table_start, lvt_cnt, max_lvt_cnt);
2690           }
2691           localvariable_table_start[lvt_cnt] =
2692             parse_localvariable_table(cfs,
2693                                       code_length,
2694                                       max_locals,
2695                                       code_attribute_length,
2696                                       &amp;localvariable_table_length[lvt_cnt],
2697                                       false,    // is not LVTT
2698                                       CHECK_NULL);
2699           total_lvt_length += localvariable_table_length[lvt_cnt];
2700           lvt_cnt++;
2701         } else if (LoadLocalVariableTypeTables &amp;&amp;
2702                    _major_version &gt;= JAVA_1_5_VERSION &amp;&amp;
2703                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_type_table()) {
2704           if (!lvt_allocated) {
2705             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2706               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2707             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2708               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2709             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2710               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2711             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2712               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2713             lvt_allocated = true;
2714           }
2715           // Parse local variable type table
2716           if (lvtt_cnt == max_lvtt_cnt) {
2717             max_lvtt_cnt &lt;&lt;= 1;
2718             localvariable_type_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_type_table_length, lvtt_cnt, max_lvtt_cnt);
2719             localvariable_type_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_type_table_start, lvtt_cnt, max_lvtt_cnt);
2720           }
2721           localvariable_type_table_start[lvtt_cnt] =
2722             parse_localvariable_table(cfs,
2723                                       code_length,
2724                                       max_locals,
2725                                       code_attribute_length,
2726                                       &amp;localvariable_type_table_length[lvtt_cnt],
2727                                       true,     // is LVTT
2728                                       CHECK_NULL);
2729           lvtt_cnt++;
2730         } else if (_major_version &gt;= Verifier::STACKMAP_ATTRIBUTE_MAJOR_VERSION &amp;&amp;
2731                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_stack_map_table()) {
2732           // Stack map is only needed by the new verifier in JDK1.5.
2733           if (parsed_stackmap_attribute) {
2734             classfile_parse_error(&quot;Multiple StackMapTable attributes in class file %s&quot;, CHECK_NULL);
2735           }
2736           stackmap_data = parse_stackmap_table(cfs, code_attribute_length, _need_verify, CHECK_NULL);
2737           stackmap_data_length = code_attribute_length;
2738           parsed_stackmap_attribute = true;
2739         } else {
2740           // Skip unknown attributes
2741           cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
2742         }
2743       }
2744       // check method attribute length
2745       if (_need_verify) {
2746         guarantee_property(method_attribute_length == calculated_attribute_length,
2747                            &quot;Code segment has wrong length in class file %s&quot;,
2748                            CHECK_NULL);
2749       }
2750     } else if (method_attribute_name == vmSymbols::tag_exceptions()) {
2751       // Parse Exceptions attribute
2752       if (parsed_checked_exceptions_attribute) {
2753         classfile_parse_error(&quot;Multiple Exceptions attributes in class file %s&quot;,
2754                               CHECK_NULL);
2755       }
2756       parsed_checked_exceptions_attribute = true;
2757       checked_exceptions_start =
2758             parse_checked_exceptions(cfs,
2759                                      &amp;checked_exceptions_length,
2760                                      method_attribute_length,
2761                                      CHECK_NULL);
2762     } else if (method_attribute_name == vmSymbols::tag_method_parameters()) {
2763       // reject multiple method parameters
2764       if (method_parameters_seen) {
2765         classfile_parse_error(&quot;Multiple MethodParameters attributes in class file %s&quot;,
2766                               CHECK_NULL);
2767       }
2768       method_parameters_seen = true;
2769       method_parameters_length = cfs-&gt;get_u1_fast();
2770       const u2 real_length = (method_parameters_length * 4u) + 1u;
2771       if (method_attribute_length != real_length) {
2772         classfile_parse_error(
2773           &quot;Invalid MethodParameters method attribute length %u in class file&quot;,
2774           method_attribute_length, CHECK_NULL);
2775       }
2776       method_parameters_data = cfs-&gt;current();
2777       cfs-&gt;skip_u2_fast(method_parameters_length);
2778       cfs-&gt;skip_u2_fast(method_parameters_length);
2779       // ignore this attribute if it cannot be reflected
2780       if (!SystemDictionary::Parameter_klass_loaded())
2781         method_parameters_length = -1;
2782     } else if (method_attribute_name == vmSymbols::tag_synthetic()) {
2783       if (method_attribute_length != 0) {
2784         classfile_parse_error(
2785           &quot;Invalid Synthetic method attribute length %u in class file %s&quot;,
2786           method_attribute_length, CHECK_NULL);
2787       }
2788       // Should we check that there hasn&#39;t already been a synthetic attribute?
2789       access_flags.set_is_synthetic();
2790     } else if (method_attribute_name == vmSymbols::tag_deprecated()) { // 4276120
2791       if (method_attribute_length != 0) {
2792         classfile_parse_error(
2793           &quot;Invalid Deprecated method attribute length %u in class file %s&quot;,
2794           method_attribute_length, CHECK_NULL);
2795       }
2796     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
2797       if (method_attribute_name == vmSymbols::tag_signature()) {
2798         if (generic_signature_index != 0) {
2799           classfile_parse_error(
2800             &quot;Multiple Signature attributes for method in class file %s&quot;,
2801             CHECK_NULL);
2802         }
2803         if (method_attribute_length != 2) {
2804           classfile_parse_error(
2805             &quot;Invalid Signature attribute length %u in class file %s&quot;,
2806             method_attribute_length, CHECK_NULL);
2807         }
2808         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK_NULL);
2809       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
2810         if (runtime_visible_annotations != NULL) {
2811           classfile_parse_error(
2812             &quot;Multiple RuntimeVisibleAnnotations attributes for method in class file %s&quot;,
2813             CHECK_NULL);
2814         }
2815         runtime_visible_annotations_length = method_attribute_length;
2816         runtime_visible_annotations = cfs-&gt;current();
2817         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
2818         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_NULL);
2819         parse_annotations(cp,
2820                           runtime_visible_annotations,
2821                           runtime_visible_annotations_length,
2822                           &amp;parsed_annotations,
2823                           _loader_data,
2824                           _can_access_vm_annotations,
2825                           CHECK_NULL);
2826         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
2827       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
2828         if (runtime_invisible_annotations_exists) {
2829           classfile_parse_error(
2830             &quot;Multiple RuntimeInvisibleAnnotations attributes for method in class file %s&quot;,
2831             CHECK_NULL);
2832         }
2833         runtime_invisible_annotations_exists = true;
2834         if (PreserveAllAnnotations) {
2835           runtime_invisible_annotations_length = method_attribute_length;
2836           runtime_invisible_annotations = cfs-&gt;current();
2837           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
2838         }
2839         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2840       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_parameter_annotations()) {
2841         if (runtime_visible_parameter_annotations != NULL) {
2842           classfile_parse_error(
2843             &quot;Multiple RuntimeVisibleParameterAnnotations attributes for method in class file %s&quot;,
2844             CHECK_NULL);
2845         }
2846         runtime_visible_parameter_annotations_length = method_attribute_length;
2847         runtime_visible_parameter_annotations = cfs-&gt;current();
2848         assert(runtime_visible_parameter_annotations != NULL, &quot;null visible parameter annotations&quot;);
2849         cfs-&gt;skip_u1(runtime_visible_parameter_annotations_length, CHECK_NULL);
2850       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_parameter_annotations()) {
2851         if (runtime_invisible_parameter_annotations_exists) {
2852           classfile_parse_error(
2853             &quot;Multiple RuntimeInvisibleParameterAnnotations attributes for method in class file %s&quot;,
2854             CHECK_NULL);
2855         }
2856         runtime_invisible_parameter_annotations_exists = true;
2857         if (PreserveAllAnnotations) {
2858           runtime_invisible_parameter_annotations_length = method_attribute_length;
2859           runtime_invisible_parameter_annotations = cfs-&gt;current();
2860           assert(runtime_invisible_parameter_annotations != NULL,
2861             &quot;null invisible parameter annotations&quot;);
2862         }
2863         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2864       } else if (method_attribute_name == vmSymbols::tag_annotation_default()) {
2865         if (annotation_default != NULL) {
2866           classfile_parse_error(
2867             &quot;Multiple AnnotationDefault attributes for method in class file %s&quot;,
2868             CHECK_NULL);
2869         }
2870         annotation_default_length = method_attribute_length;
2871         annotation_default = cfs-&gt;current();
2872         assert(annotation_default != NULL, &quot;null annotation default&quot;);
2873         cfs-&gt;skip_u1(annotation_default_length, CHECK_NULL);
2874       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
2875         if (runtime_visible_type_annotations != NULL) {
2876           classfile_parse_error(
2877             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for method in class file %s&quot;,
2878             CHECK_NULL);
2879         }
2880         runtime_visible_type_annotations_length = method_attribute_length;
2881         runtime_visible_type_annotations = cfs-&gt;current();
2882         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
2883         // No need for the VM to parse Type annotations
2884         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK_NULL);
2885       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
2886         if (runtime_invisible_type_annotations_exists) {
2887           classfile_parse_error(
2888             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for method in class file %s&quot;,
2889             CHECK_NULL);
2890         } else {
2891           runtime_invisible_type_annotations_exists = true;
2892         }
2893         if (PreserveAllAnnotations) {
2894           runtime_invisible_type_annotations_length = method_attribute_length;
2895           runtime_invisible_type_annotations = cfs-&gt;current();
2896           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
2897         }
2898         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2899       } else {
2900         // Skip unknown attributes
2901         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2902       }
2903     } else {
2904       // Skip unknown attributes
2905       cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2906     }
2907   }
2908 
2909   if (linenumber_table != NULL) {
2910     linenumber_table-&gt;write_terminator();
2911     linenumber_table_length = linenumber_table-&gt;position();
2912   }
2913 
2914   // Make sure there&#39;s at least one Code attribute in non-native/non-abstract method
2915   if (_need_verify) {
2916     guarantee_property(access_flags.is_native() ||
2917                        access_flags.is_abstract() ||
2918                        parsed_code_attribute,
2919                        &quot;Absent Code attribute in method that is not native or abstract in class file %s&quot;,
2920                        CHECK_NULL);
2921   }
2922 
2923   // All sizing information for a Method* is finally available, now create it
2924   InlineTableSizes sizes(
2925       total_lvt_length,
2926       linenumber_table_length,
2927       exception_table_length,
2928       checked_exceptions_length,
2929       method_parameters_length,
2930       generic_signature_index,
2931       runtime_visible_annotations_length +
2932            runtime_invisible_annotations_length,
2933       runtime_visible_parameter_annotations_length +
2934            runtime_invisible_parameter_annotations_length,
2935       runtime_visible_type_annotations_length +
2936            runtime_invisible_type_annotations_length,
2937       annotation_default_length,
2938       0);
2939 
2940   Method* const m = Method::allocate(_loader_data,
2941                                      code_length,
2942                                      access_flags,
2943                                      &amp;sizes,
2944                                      ConstMethod::NORMAL,
2945                                      CHECK_NULL);
2946 
2947   ClassLoadingService::add_class_method_size(m-&gt;size()*wordSize);
2948 
2949   // Fill in information from fixed part (access_flags already set)
2950   m-&gt;set_constants(_cp);
2951   m-&gt;set_name_index(name_index);
2952   m-&gt;set_signature_index(signature_index);
2953   m-&gt;compute_from_signature(cp-&gt;symbol_at(signature_index));
2954   assert(args_size &lt; 0 || args_size == m-&gt;size_of_parameters(), &quot;&quot;);
2955 
2956   // Fill in code attribute information
2957   m-&gt;set_max_stack(max_stack);
2958   m-&gt;set_max_locals(max_locals);
2959   if (stackmap_data != NULL) {
2960     m-&gt;constMethod()-&gt;copy_stackmap_data(_loader_data,
2961                                          (u1*)stackmap_data,
2962                                          stackmap_data_length,
2963                                          CHECK_NULL);
2964   }
2965 
2966   // Copy byte codes
2967   m-&gt;set_code((u1*)code_start);
2968 
2969   // Copy line number table
2970   if (linenumber_table != NULL) {
2971     memcpy(m-&gt;compressed_linenumber_table(),
2972            linenumber_table-&gt;buffer(),
2973            linenumber_table_length);
2974   }
2975 
2976   // Copy exception table
2977   if (exception_table_length &gt; 0) {
2978     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(exception_table_start,
2979                                                 m-&gt;exception_table_start(),
2980                                                 exception_table_length * sizeof(ExceptionTableElement),
2981                                                 sizeof(u2));
2982   }
2983 
2984   // Copy method parameters
2985   if (method_parameters_length &gt; 0) {
2986     MethodParametersElement* elem = m-&gt;constMethod()-&gt;method_parameters_start();
2987     for (int i = 0; i &lt; method_parameters_length; i++) {
2988       elem[i].name_cp_index = Bytes::get_Java_u2((address)method_parameters_data);
2989       method_parameters_data += 2;
2990       elem[i].flags = Bytes::get_Java_u2((address)method_parameters_data);
2991       method_parameters_data += 2;
2992     }
2993   }
2994 
2995   // Copy checked exceptions
2996   if (checked_exceptions_length &gt; 0) {
2997     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(checked_exceptions_start,
2998                                                 m-&gt;checked_exceptions_start(),
2999                                                 checked_exceptions_length * sizeof(CheckedExceptionElement),
3000                                                 sizeof(u2));
3001   }
3002 
3003   // Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
3004   if (total_lvt_length &gt; 0) {
3005     promoted_flags-&gt;set_has_localvariable_table();
3006     copy_localvariable_table(m-&gt;constMethod(),
3007                              lvt_cnt,
3008                              localvariable_table_length,
3009                              localvariable_table_start,
3010                              lvtt_cnt,
3011                              localvariable_type_table_length,
3012                              localvariable_type_table_start,
3013                              CHECK_NULL);
3014   }
3015 
3016   if (parsed_annotations.has_any_annotations())
3017     parsed_annotations.apply_to(methodHandle(THREAD, m));
3018 
3019   if (is_hidden()) { // Mark methods in hidden classes as &#39;hidden&#39;.
3020     m-&gt;set_hidden(true);
3021   }
3022 
3023   // Copy annotations
3024   copy_method_annotations(m-&gt;constMethod(),
3025                           runtime_visible_annotations,
3026                           runtime_visible_annotations_length,
3027                           runtime_invisible_annotations,
3028                           runtime_invisible_annotations_length,
3029                           runtime_visible_parameter_annotations,
3030                           runtime_visible_parameter_annotations_length,
3031                           runtime_invisible_parameter_annotations,
3032                           runtime_invisible_parameter_annotations_length,
3033                           runtime_visible_type_annotations,
3034                           runtime_visible_type_annotations_length,
3035                           runtime_invisible_type_annotations,
3036                           runtime_invisible_type_annotations_length,
3037                           annotation_default,
3038                           annotation_default_length,
3039                           CHECK_NULL);
3040 
3041   if (name == vmSymbols::finalize_method_name() &amp;&amp;
3042       signature == vmSymbols::void_method_signature()) {
3043     if (m-&gt;is_empty_method()) {
3044       _has_empty_finalizer = true;
3045     } else {
3046       _has_finalizer = true;
3047     }
3048   }
3049   if (name == vmSymbols::object_initializer_name() &amp;&amp;
3050       signature == vmSymbols::void_method_signature() &amp;&amp;
3051       m-&gt;is_vanilla_constructor()) {
3052     _has_vanilla_constructor = true;
3053   }
3054 
3055   NOT_PRODUCT(m-&gt;verify());
3056   return m;
3057 }
3058 
3059 
3060 // The promoted_flags parameter is used to pass relevant access_flags
3061 // from the methods back up to the containing klass. These flag values
3062 // are added to klass&#39;s access_flags.
3063 // Side-effects: populates the _methods field in the parser
3064 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
3065                                     bool is_interface,
3066                                     bool is_inline_type,
3067                                     AccessFlags* promoted_flags,
3068                                     bool* has_final_method,
3069                                     bool* declares_nonstatic_concrete_methods,
3070                                     TRAPS) {
3071   assert(cfs != NULL, &quot;invariant&quot;);
3072   assert(promoted_flags != NULL, &quot;invariant&quot;);
3073   assert(has_final_method != NULL, &quot;invariant&quot;);
3074   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
3075 
3076   assert(NULL == _methods, &quot;invariant&quot;);
3077 
3078   cfs-&gt;guarantee_more(2, CHECK);  // length
3079   const u2 length = cfs-&gt;get_u2_fast();
3080   if (length == 0) {
3081     _methods = Universe::the_empty_method_array();
3082   } else {
3083     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
3084                                                    length,
3085                                                    NULL,
3086                                                    CHECK);
3087 
3088     for (int index = 0; index &lt; length; index++) {
3089       Method* method = parse_method(cfs,
3090                                     is_interface,
3091                                     is_inline_type,
3092                                     _cp,
3093                                     promoted_flags,
3094                                     CHECK);
3095 
3096       if (method-&gt;is_final()) {
3097         *has_final_method = true;
3098       }
3099       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
3100       // used for interface initialization, and default method inheritance analysis
3101       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
3102         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
3103         *declares_nonstatic_concrete_methods = true;
3104       }
3105       _methods-&gt;at_put(index, method);
3106     }
3107 
3108     if (_need_verify &amp;&amp; length &gt; 1) {
3109       // Check duplicated methods
3110       ResourceMark rm(THREAD);
3111       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
3112         THREAD, NameSigHash*, HASH_ROW_SIZE);
3113       initialize_hashtable(names_and_sigs);
3114       bool dup = false;
3115       const Symbol* name = NULL;
3116       const Symbol* sig = NULL;
3117       {
3118         debug_only(NoSafepointVerifier nsv;)
3119         for (int i = 0; i &lt; length; i++) {
3120           const Method* const m = _methods-&gt;at(i);
3121           name = m-&gt;name();
3122           sig = m-&gt;signature();
3123           // If no duplicates, add name/signature in hashtable names_and_sigs.
3124           if (!put_after_lookup(name, sig, names_and_sigs)) {
3125             dup = true;
3126             break;
3127           }
3128         }
3129       }
3130       if (dup) {
3131         classfile_parse_error(&quot;Duplicate method name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
3132                                name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
3133       }
3134     }
3135   }
3136 }
3137 
3138 static const intArray* sort_methods(Array&lt;Method*&gt;* methods) {
3139   const int length = methods-&gt;length();
3140   // If JVMTI original method ordering or sharing is enabled we have to
3141   // remember the original class file ordering.
3142   // We temporarily use the vtable_index field in the Method* to store the
3143   // class file index, so we can read in after calling qsort.
3144   // Put the method ordering in the shared archive.
3145   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
3146     for (int index = 0; index &lt; length; index++) {
3147       Method* const m = methods-&gt;at(index);
3148       assert(!m-&gt;valid_vtable_index(), &quot;vtable index should not be set&quot;);
3149       m-&gt;set_vtable_index(index);
3150     }
3151   }
3152   // Sort method array by ascending method name (for faster lookups &amp; vtable construction)
3153   // Note that the ordering is not alphabetical, see Symbol::fast_compare
3154   Method::sort_methods(methods);
3155 
3156   intArray* method_ordering = NULL;
3157   // If JVMTI original method ordering or sharing is enabled construct int
3158   // array remembering the original ordering
3159   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
3160     method_ordering = new intArray(length, length, -1);
3161     for (int index = 0; index &lt; length; index++) {
3162       Method* const m = methods-&gt;at(index);
3163       const int old_index = m-&gt;vtable_index();
3164       assert(old_index &gt;= 0 &amp;&amp; old_index &lt; length, &quot;invalid method index&quot;);
3165       method_ordering-&gt;at_put(index, old_index);
3166       m-&gt;set_vtable_index(Method::invalid_vtable_index);
3167     }
3168   }
3169   return method_ordering;
3170 }
3171 
3172 // Parse generic_signature attribute for methods and fields
3173 u2 ClassFileParser::parse_generic_signature_attribute(const ClassFileStream* const cfs,
3174                                                       TRAPS) {
3175   assert(cfs != NULL, &quot;invariant&quot;);
3176 
3177   cfs-&gt;guarantee_more(2, CHECK_0);  // generic_signature_index
3178   const u2 generic_signature_index = cfs-&gt;get_u2_fast();
3179   check_property(
3180     valid_symbol_at(generic_signature_index),
3181     &quot;Invalid Signature attribute at constant pool index %u in class file %s&quot;,
3182     generic_signature_index, CHECK_0);
3183   return generic_signature_index;
3184 }
3185 
3186 void ClassFileParser::parse_classfile_sourcefile_attribute(const ClassFileStream* const cfs,
3187                                                            TRAPS) {
3188 
3189   assert(cfs != NULL, &quot;invariant&quot;);
3190 
3191   cfs-&gt;guarantee_more(2, CHECK);  // sourcefile_index
3192   const u2 sourcefile_index = cfs-&gt;get_u2_fast();
3193   check_property(
3194     valid_symbol_at(sourcefile_index),
3195     &quot;Invalid SourceFile attribute at constant pool index %u in class file %s&quot;,
3196     sourcefile_index, CHECK);
3197   set_class_sourcefile_index(sourcefile_index);
3198 }
3199 
3200 void ClassFileParser::parse_classfile_source_debug_extension_attribute(const ClassFileStream* const cfs,
3201                                                                        int length,
3202                                                                        TRAPS) {
3203   assert(cfs != NULL, &quot;invariant&quot;);
3204 
3205   const u1* const sde_buffer = cfs-&gt;current();
3206   assert(sde_buffer != NULL, &quot;null sde buffer&quot;);
3207 
3208   // Don&#39;t bother storing it if there is no way to retrieve it
3209   if (JvmtiExport::can_get_source_debug_extension()) {
3210     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
3211     u1* const sde = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, u1, length+1);
3212     for (int i = 0; i &lt; length; i++) {
3213       sde[i] = sde_buffer[i];
3214     }
3215     sde[length] = &#39;\0&#39;;
3216     set_class_sde_buffer((const char*)sde, length);
3217   }
3218   // Got utf8 string, set stream position forward
3219   cfs-&gt;skip_u1(length, CHECK);
3220 }
3221 
3222 
3223 // Inner classes can be static, private or protected (classic VM does this)
3224 #define RECOGNIZED_INNER_CLASS_MODIFIERS ( JVM_RECOGNIZED_CLASS_MODIFIERS | \
3225                                            JVM_ACC_PRIVATE |                \
3226                                            JVM_ACC_PROTECTED |              \
3227                                            JVM_ACC_STATIC                   \
3228                                          )
3229 
3230 // Return number of classes in the inner classes attribute table
3231 u2 ClassFileParser::parse_classfile_inner_classes_attribute(const ClassFileStream* const cfs,
3232                                                             const u1* const inner_classes_attribute_start,
3233                                                             bool parsed_enclosingmethod_attribute,
3234                                                             u2 enclosing_method_class_index,
3235                                                             u2 enclosing_method_method_index,
3236                                                             TRAPS) {
3237   const u1* const current_mark = cfs-&gt;current();
3238   u2 length = 0;
3239   if (inner_classes_attribute_start != NULL) {
3240     cfs-&gt;set_current(inner_classes_attribute_start);
3241     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3242     length = cfs-&gt;get_u2_fast();
3243   }
3244 
3245   // 4-tuples of shorts of inner classes data and 2 shorts of enclosing
3246   // method data:
3247   //   [inner_class_info_index,
3248   //    outer_class_info_index,
3249   //    inner_name_index,
3250   //    inner_class_access_flags,
3251   //    ...
3252   //    enclosing_method_class_index,
3253   //    enclosing_method_method_index]
3254   const int size = length * 4 + (parsed_enclosingmethod_attribute ? 2 : 0);
3255   Array&lt;u2&gt;* const inner_classes = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3256   _inner_classes = inner_classes;
3257 
3258   int index = 0;
3259   cfs-&gt;guarantee_more(8 * length, CHECK_0);  // 4-tuples of u2
3260   for (int n = 0; n &lt; length; n++) {
3261     // Inner class index
3262     const u2 inner_class_info_index = cfs-&gt;get_u2_fast();
3263     check_property(
3264       valid_klass_reference_at(inner_class_info_index),
3265       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3266       inner_class_info_index, CHECK_0);
3267     // Outer class index
3268     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3269     check_property(
3270       outer_class_info_index == 0 ||
3271         valid_klass_reference_at(outer_class_info_index),
3272       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3273       outer_class_info_index, CHECK_0);
3274     // Inner class name
3275     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3276     check_property(
3277       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3278       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3279       inner_name_index, CHECK_0);
3280     if (_need_verify) {
3281       guarantee_property(inner_class_info_index != outer_class_info_index,
3282                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3283     }
3284 
3285     jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;
3286     // JVM_ACC_MODULE is defined in JDK-9 and later.
3287     if (_major_version &gt;= JAVA_9_VERSION) {
3288       recognized_modifiers |= JVM_ACC_MODULE;
3289     }
3290     // JVM_ACC_VALUE is defined for class file version 55 and later
3291     if (supports_inline_types()) {
3292       recognized_modifiers |= JVM_ACC_VALUE;
3293     }
3294 
3295     // Access flags
3296     jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
3297 
3298     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3299       // Set abstract bit for old class files for backward compatibility
3300       flags |= JVM_ACC_ABSTRACT;
3301     }
3302     verify_legal_class_modifiers(flags, CHECK_0);
3303     AccessFlags inner_access_flags(flags);
3304 
3305     inner_classes-&gt;at_put(index++, inner_class_info_index);
3306     inner_classes-&gt;at_put(index++, outer_class_info_index);
3307     inner_classes-&gt;at_put(index++, inner_name_index);
3308     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3309   }
3310 
3311   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3312   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3313     for(int i = 0; i &lt; length * 4; i += 4) {
3314       for(int j = i + 4; j &lt; length * 4; j += 4) {
3315         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3316                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3317                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
3318                             inner_classes-&gt;at(i+3) != inner_classes-&gt;at(j+3)),
3319                             &quot;Duplicate entry in InnerClasses in class file %s&quot;,
3320                             CHECK_0);
3321       }
3322     }
3323   }
3324 
3325   // Set EnclosingMethod class and method indexes.
3326   if (parsed_enclosingmethod_attribute) {
3327     inner_classes-&gt;at_put(index++, enclosing_method_class_index);
3328     inner_classes-&gt;at_put(index++, enclosing_method_method_index);
3329   }
3330   assert(index == size, &quot;wrong size&quot;);
3331 
3332   // Restore buffer&#39;s current position.
3333   cfs-&gt;set_current(current_mark);
3334 
3335   return length;
3336 }
3337 
3338 u2 ClassFileParser::parse_classfile_nest_members_attribute(const ClassFileStream* const cfs,
3339                                                            const u1* const nest_members_attribute_start,
3340                                                            TRAPS) {
3341   const u1* const current_mark = cfs-&gt;current();
3342   u2 length = 0;
3343   if (nest_members_attribute_start != NULL) {
3344     cfs-&gt;set_current(nest_members_attribute_start);
3345     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3346     length = cfs-&gt;get_u2_fast();
3347   }
3348   const int size = length;
3349   Array&lt;u2&gt;* const nest_members = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3350   _nest_members = nest_members;
3351 
3352   int index = 0;
3353   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3354   for (int n = 0; n &lt; length; n++) {
3355     const u2 class_info_index = cfs-&gt;get_u2_fast();
3356     check_property(
3357       valid_klass_reference_at(class_info_index),
3358       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3359       class_info_index, CHECK_0);
3360     nest_members-&gt;at_put(index++, class_info_index);
3361   }
3362   assert(index == size, &quot;wrong size&quot;);
3363 
3364   // Restore buffer&#39;s current position.
3365   cfs-&gt;set_current(current_mark);
3366 
3367   return length;
3368 }
3369 
3370 u2 ClassFileParser::parse_classfile_permitted_subclasses_attribute(const ClassFileStream* const cfs,
3371                                                                    const u1* const permitted_subclasses_attribute_start,
3372                                                                    TRAPS) {
3373   const u1* const current_mark = cfs-&gt;current();
3374   u2 length = 0;
3375   if (permitted_subclasses_attribute_start != NULL) {
3376     cfs-&gt;set_current(permitted_subclasses_attribute_start);
3377     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3378     length = cfs-&gt;get_u2_fast();
3379   }
3380   if (length &lt; 1) {
3381     classfile_parse_error(&quot;PermittedSubclasses attribute is empty in class file %s&quot;, CHECK_0);
3382   }
3383   const int size = length;
3384   Array&lt;u2&gt;* const permitted_subclasses = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3385   _permitted_subclasses = permitted_subclasses;
3386 
3387   int index = 0;
3388   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3389   for (int n = 0; n &lt; length; n++) {
3390     const u2 class_info_index = cfs-&gt;get_u2_fast();
3391     check_property(
3392       valid_klass_reference_at(class_info_index),
3393       &quot;Permitted subclass class_info_index %u has bad constant type in class file %s&quot;,
3394       class_info_index, CHECK_0);
3395     permitted_subclasses-&gt;at_put(index++, class_info_index);
3396   }
3397   assert(index == size, &quot;wrong size&quot;);
3398 
3399   // Restore buffer&#39;s current position.
3400   cfs-&gt;set_current(current_mark);
3401 
3402   return length;
3403 }
3404 
3405 //  Record {
3406 //    u2 attribute_name_index;
3407 //    u4 attribute_length;
3408 //    u2 components_count;
3409 //    component_info components[components_count];
3410 //  }
3411 //  component_info {
3412 //    u2 name_index;
3413 //    u2 descriptor_index
3414 //    u2 attributes_count;
3415 //    attribute_info_attributes[attributes_count];
3416 //  }
3417 u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,
3418                                                      const ConstantPool* cp,
3419                                                      const u1* const record_attribute_start,
3420                                                      TRAPS) {
3421   const u1* const current_mark = cfs-&gt;current();
3422   int components_count = 0;
3423   unsigned int calculate_attr_size = 0;
3424   if (record_attribute_start != NULL) {
3425     cfs-&gt;set_current(record_attribute_start);
3426     cfs-&gt;guarantee_more(2, CHECK_0);  // num of components
3427     components_count = (int)cfs-&gt;get_u2_fast();
3428     calculate_attr_size = 2;
3429   }
3430 
3431   Array&lt;RecordComponent*&gt;* const record_components =
3432     MetadataFactory::new_array&lt;RecordComponent*&gt;(_loader_data, components_count, NULL, CHECK_0);
3433   _record_components = record_components;
3434 
3435   for (int x = 0; x &lt; components_count; x++) {
3436     cfs-&gt;guarantee_more(6, CHECK_0); // name_index, descriptor_index, attributes_count
3437 
3438     const u2 name_index = cfs-&gt;get_u2_fast();
3439     check_property(valid_symbol_at(name_index),
3440       &quot;Invalid constant pool index %u for name in Record attribute in class file %s&quot;,
3441       name_index, CHECK_0);
3442     const Symbol* const name = cp-&gt;symbol_at(name_index);
3443     verify_legal_field_name(name, CHECK_0);
3444 
3445     const u2 descriptor_index = cfs-&gt;get_u2_fast();
3446     check_property(valid_symbol_at(descriptor_index),
3447       &quot;Invalid constant pool index %u for descriptor in Record attribute in class file %s&quot;,
3448       descriptor_index, CHECK_0);
3449     const Symbol* const descr = cp-&gt;symbol_at(descriptor_index);
3450     verify_legal_field_signature(name, descr, CHECK_0);
3451 
3452     const u2 attributes_count = cfs-&gt;get_u2_fast();
3453     calculate_attr_size += 6;
3454     u2 generic_sig_index = 0;
3455     const u1* runtime_visible_annotations = NULL;
3456     int runtime_visible_annotations_length = 0;
3457     const u1* runtime_invisible_annotations = NULL;
3458     int runtime_invisible_annotations_length = 0;
3459     bool runtime_invisible_annotations_exists = false;
3460     const u1* runtime_visible_type_annotations = NULL;
3461     int runtime_visible_type_annotations_length = 0;
3462     const u1* runtime_invisible_type_annotations = NULL;
3463     int runtime_invisible_type_annotations_length = 0;
3464     bool runtime_invisible_type_annotations_exists = false;
3465 
3466     // Expected attributes for record components are Signature, Runtime(In)VisibleAnnotations,
3467     // and Runtime(In)VisibleTypeAnnotations.  Other attributes are ignored.
3468     for (int y = 0; y &lt; attributes_count; y++) {
3469       cfs-&gt;guarantee_more(6, CHECK_0);  // attribute_name_index, attribute_length
3470       const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3471       const u4 attribute_length = cfs-&gt;get_u4_fast();
3472       calculate_attr_size += 6;
3473       check_property(
3474         valid_symbol_at(attribute_name_index),
3475         &quot;Invalid Record attribute name index %u in class file %s&quot;,
3476         attribute_name_index, CHECK_0);
3477 
3478       const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
3479       if (attribute_name == vmSymbols::tag_signature()) {
3480         if (generic_sig_index != 0) {
3481           classfile_parse_error(
3482             &quot;Multiple Signature attributes for Record component in class file %s&quot;,
3483             CHECK_0);
3484         }
3485         if (attribute_length != 2) {
3486           classfile_parse_error(
3487             &quot;Invalid Signature attribute length %u in Record component in class file %s&quot;,
3488             attribute_length, CHECK_0);
3489         }
3490         generic_sig_index = parse_generic_signature_attribute(cfs, CHECK_0);
3491 
3492       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
3493         if (runtime_visible_annotations != NULL) {
3494           classfile_parse_error(
3495             &quot;Multiple RuntimeVisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3496         }
3497         runtime_visible_annotations_length = attribute_length;
3498         runtime_visible_annotations = cfs-&gt;current();
3499 
3500         assert(runtime_visible_annotations != NULL, &quot;null record component visible annotation&quot;);
3501         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_0);
3502         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3503 
3504       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
3505         if (runtime_invisible_annotations_exists) {
3506           classfile_parse_error(
3507             &quot;Multiple RuntimeInvisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3508         }
3509         runtime_invisible_annotations_exists = true;
3510         if (PreserveAllAnnotations) {
3511           runtime_invisible_annotations_length = attribute_length;
3512           runtime_invisible_annotations = cfs-&gt;current();
3513           assert(runtime_invisible_annotations != NULL, &quot;null record component invisible annotation&quot;);
3514         }
3515         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3516 
3517       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
3518         if (runtime_visible_type_annotations != NULL) {
3519           classfile_parse_error(
3520             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3521         }
3522         runtime_visible_type_annotations_length = attribute_length;
3523         runtime_visible_type_annotations = cfs-&gt;current();
3524 
3525         assert(runtime_visible_type_annotations != NULL, &quot;null record component visible type annotation&quot;);
3526         cfs-&gt;guarantee_more(runtime_visible_type_annotations_length, CHECK_0);
3527         cfs-&gt;skip_u1_fast(runtime_visible_type_annotations_length);
3528 
3529       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
3530         if (runtime_invisible_type_annotations_exists) {
3531           classfile_parse_error(
3532             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3533         }
3534         runtime_invisible_type_annotations_exists = true;
3535         if (PreserveAllAnnotations) {
3536           runtime_invisible_type_annotations_length = attribute_length;
3537           runtime_invisible_type_annotations = cfs-&gt;current();
3538           assert(runtime_invisible_type_annotations != NULL, &quot;null record component invisible type annotation&quot;);
3539         }
3540         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3541 
3542       } else {
3543         // Skip unknown attributes
3544         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3545       }
3546       calculate_attr_size += attribute_length;
3547     } // End of attributes For loop
3548 
3549     AnnotationArray* annotations = assemble_annotations(runtime_visible_annotations,
3550                                                         runtime_visible_annotations_length,
3551                                                         runtime_invisible_annotations,
3552                                                         runtime_invisible_annotations_length,
3553                                                         CHECK_0);
3554     AnnotationArray* type_annotations = assemble_annotations(runtime_visible_type_annotations,
3555                                                              runtime_visible_type_annotations_length,
3556                                                              runtime_invisible_type_annotations,
3557                                                              runtime_invisible_type_annotations_length,
3558                                                              CHECK_0);
3559 
3560     RecordComponent* record_component =
3561       RecordComponent::allocate(_loader_data, name_index, descriptor_index,
3562                                 attributes_count, generic_sig_index,
3563                                 annotations, type_annotations, CHECK_0);
3564     record_components-&gt;at_put(x, record_component);
3565   }  // End of component processing loop
3566 
3567   // Restore buffer&#39;s current position.
3568   cfs-&gt;set_current(current_mark);
3569   return calculate_attr_size;
3570 }
3571 
3572 void ClassFileParser::parse_classfile_synthetic_attribute(TRAPS) {
3573   set_class_synthetic_flag(true);
3574 }
3575 
3576 void ClassFileParser::parse_classfile_signature_attribute(const ClassFileStream* const cfs, TRAPS) {
3577   assert(cfs != NULL, &quot;invariant&quot;);
3578 
3579   const u2 signature_index = cfs-&gt;get_u2(CHECK);
3580   check_property(
3581     valid_symbol_at(signature_index),
3582     &quot;Invalid constant pool index %u in Signature attribute in class file %s&quot;,
3583     signature_index, CHECK);
3584   set_class_generic_signature_index(signature_index);
3585 }
3586 
3587 void ClassFileParser::parse_classfile_bootstrap_methods_attribute(const ClassFileStream* const cfs,
3588                                                                   ConstantPool* cp,
3589                                                                   u4 attribute_byte_length,
3590                                                                   TRAPS) {
3591   assert(cfs != NULL, &quot;invariant&quot;);
3592   assert(cp != NULL, &quot;invariant&quot;);
3593 
3594   const u1* const current_start = cfs-&gt;current();
3595 
3596   guarantee_property(attribute_byte_length &gt;= sizeof(u2),
3597                      &quot;Invalid BootstrapMethods attribute length %u in class file %s&quot;,
3598                      attribute_byte_length,
3599                      CHECK);
3600 
3601   cfs-&gt;guarantee_more(attribute_byte_length, CHECK);
3602 
3603   const int attribute_array_length = cfs-&gt;get_u2_fast();
3604 
3605   guarantee_property(_max_bootstrap_specifier_index &lt; attribute_array_length,
3606                      &quot;Short length on BootstrapMethods in class file %s&quot;,
3607                      CHECK);
3608 
3609 
3610   // The attribute contains a counted array of counted tuples of shorts,
3611   // represending bootstrap specifiers:
3612   //    length*{bootstrap_method_index, argument_count*{argument_index}}
3613   const int operand_count = (attribute_byte_length - sizeof(u2)) / sizeof(u2);
3614   // operand_count = number of shorts in attr, except for leading length
3615 
3616   // The attribute is copied into a short[] array.
3617   // The array begins with a series of short[2] pairs, one for each tuple.
3618   const int index_size = (attribute_array_length * 2);
3619 
3620   Array&lt;u2&gt;* const operands =
3621     MetadataFactory::new_array&lt;u2&gt;(_loader_data, index_size + operand_count, CHECK);
3622 
3623   // Eagerly assign operands so they will be deallocated with the constant
3624   // pool if there is an error.
3625   cp-&gt;set_operands(operands);
3626 
3627   int operand_fill_index = index_size;
3628   const int cp_size = cp-&gt;length();
3629 
3630   for (int n = 0; n &lt; attribute_array_length; n++) {
3631     // Store a 32-bit offset into the header of the operand array.
3632     ConstantPool::operand_offset_at_put(operands, n, operand_fill_index);
3633 
3634     // Read a bootstrap specifier.
3635     cfs-&gt;guarantee_more(sizeof(u2) * 2, CHECK);  // bsm, argc
3636     const u2 bootstrap_method_index = cfs-&gt;get_u2_fast();
3637     const u2 argument_count = cfs-&gt;get_u2_fast();
3638     check_property(
3639       valid_cp_range(bootstrap_method_index, cp_size) &amp;&amp;
3640       cp-&gt;tag_at(bootstrap_method_index).is_method_handle(),
3641       &quot;bootstrap_method_index %u has bad constant type in class file %s&quot;,
3642       bootstrap_method_index,
3643       CHECK);
3644 
3645     guarantee_property((operand_fill_index + 1 + argument_count) &lt; operands-&gt;length(),
3646       &quot;Invalid BootstrapMethods num_bootstrap_methods or num_bootstrap_arguments value in class file %s&quot;,
3647       CHECK);
3648 
3649     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3650     operands-&gt;at_put(operand_fill_index++, argument_count);
3651 
3652     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3653     for (int j = 0; j &lt; argument_count; j++) {
3654       const u2 argument_index = cfs-&gt;get_u2_fast();
3655       check_property(
3656         valid_cp_range(argument_index, cp_size) &amp;&amp;
3657         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3658         &quot;argument_index %u has bad constant type in class file %s&quot;,
3659         argument_index,
3660         CHECK);
3661       operands-&gt;at_put(operand_fill_index++, argument_index);
3662     }
3663   }
3664   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3665                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3666                      CHECK);
3667 }
3668 
3669 bool ClassFileParser::supports_sealed_types() {
3670   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
3671          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
3672          Arguments::enable_preview();
3673 }
3674 
3675 bool ClassFileParser::supports_records() {
3676   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
3677          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
3678          Arguments::enable_preview();
3679 }
3680 
3681 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3682                                                  ConstantPool* cp,
3683                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3684                                                  TRAPS) {
3685   assert(cfs != NULL, &quot;invariant&quot;);
3686   assert(cp != NULL, &quot;invariant&quot;);
3687   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3688 
3689   // Set inner classes attribute to default sentinel
3690   _inner_classes = Universe::the_empty_short_array();
3691   // Set nest members attribute to default sentinel
3692   _nest_members = Universe::the_empty_short_array();
3693   // Set _permitted_subclasses attribute to default sentinel
3694   _permitted_subclasses = Universe::the_empty_short_array();
3695   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3696   u2 attributes_count = cfs-&gt;get_u2_fast();
3697   bool parsed_sourcefile_attribute = false;
3698   bool parsed_innerclasses_attribute = false;
3699   bool parsed_nest_members_attribute = false;
3700   bool parsed_permitted_subclasses_attribute = false;
3701   bool parsed_nest_host_attribute = false;
3702   bool parsed_record_attribute = false;
3703   bool parsed_enclosingmethod_attribute = false;
3704   bool parsed_bootstrap_methods_attribute = false;
3705   const u1* runtime_visible_annotations = NULL;
3706   int runtime_visible_annotations_length = 0;
3707   const u1* runtime_invisible_annotations = NULL;
3708   int runtime_invisible_annotations_length = 0;
3709   const u1* runtime_visible_type_annotations = NULL;
3710   int runtime_visible_type_annotations_length = 0;
3711   const u1* runtime_invisible_type_annotations = NULL;
3712   int runtime_invisible_type_annotations_length = 0;
3713   bool runtime_invisible_type_annotations_exists = false;
3714   bool runtime_invisible_annotations_exists = false;
3715   bool parsed_source_debug_ext_annotations_exist = false;
3716   const u1* inner_classes_attribute_start = NULL;
3717   u4  inner_classes_attribute_length = 0;
3718   u2  enclosing_method_class_index = 0;
3719   u2  enclosing_method_method_index = 0;
3720   const u1* nest_members_attribute_start = NULL;
3721   u4  nest_members_attribute_length = 0;
3722   const u1* record_attribute_start = NULL;
3723   u4  record_attribute_length = 0;
3724   const u1* permitted_subclasses_attribute_start = NULL;
3725   u4  permitted_subclasses_attribute_length = 0;
3726 
3727   // Iterate over attributes
3728   while (attributes_count--) {
3729     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3730     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3731     const u4 attribute_length = cfs-&gt;get_u4_fast();
3732     check_property(
3733       valid_symbol_at(attribute_name_index),
3734       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3735       attribute_name_index, CHECK);
3736     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3737     if (tag == vmSymbols::tag_source_file()) {
3738       // Check for SourceFile tag
3739       if (_need_verify) {
3740         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3741       }
3742       if (parsed_sourcefile_attribute) {
3743         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3744       } else {
3745         parsed_sourcefile_attribute = true;
3746       }
3747       parse_classfile_sourcefile_attribute(cfs, CHECK);
3748     } else if (tag == vmSymbols::tag_source_debug_extension()) {
3749       // Check for SourceDebugExtension tag
3750       if (parsed_source_debug_ext_annotations_exist) {
3751           classfile_parse_error(
3752             &quot;Multiple SourceDebugExtension attributes in class file %s&quot;, CHECK);
3753       }
3754       parsed_source_debug_ext_annotations_exist = true;
3755       parse_classfile_source_debug_extension_attribute(cfs, (int)attribute_length, CHECK);
3756     } else if (tag == vmSymbols::tag_inner_classes()) {
3757       // Check for InnerClasses tag
3758       if (parsed_innerclasses_attribute) {
3759         classfile_parse_error(&quot;Multiple InnerClasses attributes in class file %s&quot;, CHECK);
3760       } else {
3761         parsed_innerclasses_attribute = true;
3762       }
3763       inner_classes_attribute_start = cfs-&gt;current();
3764       inner_classes_attribute_length = attribute_length;
3765       cfs-&gt;skip_u1(inner_classes_attribute_length, CHECK);
3766     } else if (tag == vmSymbols::tag_synthetic()) {
3767       // Check for Synthetic tag
3768       // Shouldn&#39;t we check that the synthetic flags wasn&#39;t already set? - not required in spec
3769       if (attribute_length != 0) {
3770         classfile_parse_error(
3771           &quot;Invalid Synthetic classfile attribute length %u in class file %s&quot;,
3772           attribute_length, CHECK);
3773       }
3774       parse_classfile_synthetic_attribute(CHECK);
3775     } else if (tag == vmSymbols::tag_deprecated()) {
3776       // Check for Deprecatd tag - 4276120
3777       if (attribute_length != 0) {
3778         classfile_parse_error(
3779           &quot;Invalid Deprecated classfile attribute length %u in class file %s&quot;,
3780           attribute_length, CHECK);
3781       }
3782     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
3783       if (tag == vmSymbols::tag_signature()) {
3784         if (_generic_signature_index != 0) {
3785           classfile_parse_error(
3786             &quot;Multiple Signature attributes in class file %s&quot;, CHECK);
3787         }
3788         if (attribute_length != 2) {
3789           classfile_parse_error(
3790             &quot;Wrong Signature attribute length %u in class file %s&quot;,
3791             attribute_length, CHECK);
3792         }
3793         parse_classfile_signature_attribute(cfs, CHECK);
3794       } else if (tag == vmSymbols::tag_runtime_visible_annotations()) {
3795         if (runtime_visible_annotations != NULL) {
3796           classfile_parse_error(
3797             &quot;Multiple RuntimeVisibleAnnotations attributes in class file %s&quot;, CHECK);
3798         }
3799         runtime_visible_annotations_length = attribute_length;
3800         runtime_visible_annotations = cfs-&gt;current();
3801         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
3802         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
3803         parse_annotations(cp,
3804                           runtime_visible_annotations,
3805                           runtime_visible_annotations_length,
3806                           parsed_annotations,
3807                           _loader_data,
3808                           _can_access_vm_annotations,
3809                           CHECK);
3810         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3811       } else if (tag == vmSymbols::tag_runtime_invisible_annotations()) {
3812         if (runtime_invisible_annotations_exists) {
3813           classfile_parse_error(
3814             &quot;Multiple RuntimeInvisibleAnnotations attributes in class file %s&quot;, CHECK);
3815         }
3816         runtime_invisible_annotations_exists = true;
3817         if (PreserveAllAnnotations) {
3818           runtime_invisible_annotations_length = attribute_length;
3819           runtime_invisible_annotations = cfs-&gt;current();
3820           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
3821         }
3822         cfs-&gt;skip_u1(attribute_length, CHECK);
3823       } else if (tag == vmSymbols::tag_enclosing_method()) {
3824         if (parsed_enclosingmethod_attribute) {
3825           classfile_parse_error(&quot;Multiple EnclosingMethod attributes in class file %s&quot;, CHECK);
3826         } else {
3827           parsed_enclosingmethod_attribute = true;
3828         }
3829         guarantee_property(attribute_length == 4,
3830           &quot;Wrong EnclosingMethod attribute length %u in class file %s&quot;,
3831           attribute_length, CHECK);
3832         cfs-&gt;guarantee_more(4, CHECK);  // class_index, method_index
3833         enclosing_method_class_index  = cfs-&gt;get_u2_fast();
3834         enclosing_method_method_index = cfs-&gt;get_u2_fast();
3835         if (enclosing_method_class_index == 0) {
3836           classfile_parse_error(&quot;Invalid class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3837         }
3838         // Validate the constant pool indices and types
3839         check_property(valid_klass_reference_at(enclosing_method_class_index),
3840           &quot;Invalid or out-of-bounds class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3841         if (enclosing_method_method_index != 0 &amp;&amp;
3842             (!cp-&gt;is_within_bounds(enclosing_method_method_index) ||
3843              !cp-&gt;tag_at(enclosing_method_method_index).is_name_and_type())) {
3844           classfile_parse_error(&quot;Invalid or out-of-bounds method index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3845         }
3846       } else if (tag == vmSymbols::tag_bootstrap_methods() &amp;&amp;
3847                  _major_version &gt;= Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
3848         if (parsed_bootstrap_methods_attribute) {
3849           classfile_parse_error(&quot;Multiple BootstrapMethods attributes in class file %s&quot;, CHECK);
3850         }
3851         parsed_bootstrap_methods_attribute = true;
3852         parse_classfile_bootstrap_methods_attribute(cfs, cp, attribute_length, CHECK);
3853       } else if (tag == vmSymbols::tag_runtime_visible_type_annotations()) {
3854         if (runtime_visible_type_annotations != NULL) {
3855           classfile_parse_error(
3856             &quot;Multiple RuntimeVisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3857         }
3858         runtime_visible_type_annotations_length = attribute_length;
3859         runtime_visible_type_annotations = cfs-&gt;current();
3860         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
3861         // No need for the VM to parse Type annotations
3862         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
3863       } else if (tag == vmSymbols::tag_runtime_invisible_type_annotations()) {
3864         if (runtime_invisible_type_annotations_exists) {
3865           classfile_parse_error(
3866             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3867         } else {
3868           runtime_invisible_type_annotations_exists = true;
3869         }
3870         if (PreserveAllAnnotations) {
3871           runtime_invisible_type_annotations_length = attribute_length;
3872           runtime_invisible_type_annotations = cfs-&gt;current();
3873           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
3874         }
3875         cfs-&gt;skip_u1(attribute_length, CHECK);
3876       } else if (_major_version &gt;= JAVA_11_VERSION) {
3877         if (tag == vmSymbols::tag_nest_members()) {
3878           // Check for NestMembers tag
3879           if (parsed_nest_members_attribute) {
3880             classfile_parse_error(&quot;Multiple NestMembers attributes in class file %s&quot;, CHECK);
3881           } else {
3882             parsed_nest_members_attribute = true;
3883           }
3884           if (parsed_nest_host_attribute) {
3885             classfile_parse_error(&quot;Conflicting NestHost and NestMembers attributes in class file %s&quot;, CHECK);
3886           }
3887           nest_members_attribute_start = cfs-&gt;current();
3888           nest_members_attribute_length = attribute_length;
3889           cfs-&gt;skip_u1(nest_members_attribute_length, CHECK);
3890         } else if (tag == vmSymbols::tag_nest_host()) {
3891           if (parsed_nest_host_attribute) {
3892             classfile_parse_error(&quot;Multiple NestHost attributes in class file %s&quot;, CHECK);
3893           } else {
3894             parsed_nest_host_attribute = true;
3895           }
3896           if (parsed_nest_members_attribute) {
3897             classfile_parse_error(&quot;Conflicting NestMembers and NestHost attributes in class file %s&quot;, CHECK);
3898           }
3899           if (_need_verify) {
3900             guarantee_property(attribute_length == 2, &quot;Wrong NestHost attribute length in class file %s&quot;, CHECK);
3901           }
3902           cfs-&gt;guarantee_more(2, CHECK);
3903           u2 class_info_index = cfs-&gt;get_u2_fast();
3904           check_property(
3905                          valid_klass_reference_at(class_info_index),
3906                          &quot;Nest-host class_info_index %u has bad constant type in class file %s&quot;,
3907                          class_info_index, CHECK);
3908           _nest_host = class_info_index;
3909         } else if (_major_version &gt;= JAVA_14_VERSION) {
3910           if (tag == vmSymbols::tag_record()) {
3911             // Skip over Record attribute if not supported or if super class is
3912             // not java.lang.Record.
3913             if (supports_records() &amp;&amp;
3914                 cp-&gt;klass_name_at(_super_class_index) == vmSymbols::java_lang_Record()) {
3915               if (parsed_record_attribute) {
3916                 classfile_parse_error(&quot;Multiple Record attributes in class file %s&quot;, CHECK);
3917               }
3918               // Check that class is final and not abstract.
3919               if (!_access_flags.is_final() || _access_flags.is_abstract()) {
3920                 classfile_parse_error(&quot;Record attribute in non-final or abstract class file %s&quot;, CHECK);
3921               }
3922               parsed_record_attribute = true;
3923               record_attribute_start = cfs-&gt;current();
3924               record_attribute_length = attribute_length;
3925             } else if (log_is_enabled(Info, class, record)) {
3926               // Log why the Record attribute was ignored.  Note that if the
3927               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and
3928               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3929               // exception would have been thrown.
3930               ResourceMark rm(THREAD);
3931               if (supports_records()) {
3932                 log_info(class, record)(
3933                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3934                   _class_name-&gt;as_C_string());
3935               } else {
3936                 log_info(class, record)(
3937                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3938                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3939               }
3940             }
3941             cfs-&gt;skip_u1(attribute_length, CHECK);
3942           } else if (_major_version &gt;= JAVA_15_VERSION) {
3943             // Check for PermittedSubclasses tag
3944             if (tag == vmSymbols::tag_permitted_subclasses()) {
3945               if (supports_sealed_types()) {
3946                 if (parsed_permitted_subclasses_attribute) {
3947                   classfile_parse_error(&quot;Multiple PermittedSubclasses attributes in class file %s&quot;, CHECK);
3948                 }
3949                 // Classes marked ACC_FINAL cannot have a PermittedSubclasses attribute.
3950                 if (_access_flags.is_final()) {
3951                   classfile_parse_error(&quot;PermittedSubclasses attribute in final class file %s&quot;, CHECK);
3952                 }
3953                 parsed_permitted_subclasses_attribute = true;
3954                 permitted_subclasses_attribute_start = cfs-&gt;current();
3955                 permitted_subclasses_attribute_length = attribute_length;
3956               }
3957               cfs-&gt;skip_u1(attribute_length, CHECK);
3958             } else {
3959               // Unknown attribute
3960               cfs-&gt;skip_u1(attribute_length, CHECK);
3961             }
3962           } else {
3963             // Unknown attribute
3964             cfs-&gt;skip_u1(attribute_length, CHECK);
3965           }
3966         } else {
3967           // Unknown attribute
3968           cfs-&gt;skip_u1(attribute_length, CHECK);
3969         }
3970       } else {
3971         // Unknown attribute
3972         cfs-&gt;skip_u1(attribute_length, CHECK);
3973       }
3974     } else {
3975       // Unknown attribute
3976       cfs-&gt;skip_u1(attribute_length, CHECK);
3977     }
3978   }
3979   _class_annotations = assemble_annotations(runtime_visible_annotations,
3980                                             runtime_visible_annotations_length,
3981                                             runtime_invisible_annotations,
3982                                             runtime_invisible_annotations_length,
3983                                             CHECK);
3984   _class_type_annotations = assemble_annotations(runtime_visible_type_annotations,
3985                                                  runtime_visible_type_annotations_length,
3986                                                  runtime_invisible_type_annotations,
3987                                                  runtime_invisible_type_annotations_length,
3988                                                  CHECK);
3989 
3990   if (parsed_innerclasses_attribute || parsed_enclosingmethod_attribute) {
3991     const u2 num_of_classes = parse_classfile_inner_classes_attribute(
3992                             cfs,
3993                             inner_classes_attribute_start,
3994                             parsed_innerclasses_attribute,
3995                             enclosing_method_class_index,
3996                             enclosing_method_method_index,
3997                             CHECK);
3998     if (parsed_innerclasses_attribute &amp;&amp; _need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3999       guarantee_property(
4000         inner_classes_attribute_length == sizeof(num_of_classes) + 4 * sizeof(u2) * num_of_classes,
4001         &quot;Wrong InnerClasses attribute length in class file %s&quot;, CHECK);
4002     }
4003   }
4004 
4005   if (parsed_nest_members_attribute) {
4006     const u2 num_of_classes = parse_classfile_nest_members_attribute(
4007                             cfs,
4008                             nest_members_attribute_start,
4009                             CHECK);
4010     if (_need_verify) {
4011       guarantee_property(
4012         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
4013         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
4014     }
4015   }
4016 
4017   if (parsed_record_attribute) {
4018     const unsigned int calculated_attr_length = parse_classfile_record_attribute(
4019                             cfs,
4020                             cp,
4021                             record_attribute_start,
4022                             CHECK);
4023     if (_need_verify) {
4024       guarantee_property(record_attribute_length == calculated_attr_length,
4025                          &quot;Record attribute has wrong length in class file %s&quot;,
4026                          CHECK);
4027     }
4028   }
4029 
4030   if (parsed_permitted_subclasses_attribute) {
4031     const u2 num_subclasses = parse_classfile_permitted_subclasses_attribute(
4032                             cfs,
4033                             permitted_subclasses_attribute_start,
4034                             CHECK);
4035     if (_need_verify) {
4036       guarantee_property(
4037         permitted_subclasses_attribute_length == sizeof(num_subclasses) + sizeof(u2) * num_subclasses,
4038         &quot;Wrong PermittedSubclasses attribute length in class file %s&quot;, CHECK);
4039     }
4040   }
4041 
4042   if (_max_bootstrap_specifier_index &gt;= 0) {
4043     guarantee_property(parsed_bootstrap_methods_attribute,
4044                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
4045   }
4046 }
4047 
4048 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
4049   assert(k != NULL, &quot;invariant&quot;);
4050 
4051   if (_synthetic_flag)
4052     k-&gt;set_is_synthetic();
4053   if (_sourcefile_index != 0) {
4054     k-&gt;set_source_file_name_index(_sourcefile_index);
4055   }
4056   if (_generic_signature_index != 0) {
4057     k-&gt;set_generic_signature_index(_generic_signature_index);
4058   }
4059   if (_sde_buffer != NULL) {
4060     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
4061   }
4062 }
4063 
4064 // Create the Annotations object that will
4065 // hold the annotations array for the Klass.
4066 void ClassFileParser::create_combined_annotations(TRAPS) {
4067     if (_class_annotations == NULL &amp;&amp;
4068         _class_type_annotations == NULL &amp;&amp;
4069         _fields_annotations == NULL &amp;&amp;
4070         _fields_type_annotations == NULL) {
4071       // Don&#39;t create the Annotations object unnecessarily.
4072       return;
4073     }
4074 
4075     Annotations* const annotations = Annotations::allocate(_loader_data, CHECK);
4076     annotations-&gt;set_class_annotations(_class_annotations);
4077     annotations-&gt;set_class_type_annotations(_class_type_annotations);
4078     annotations-&gt;set_fields_annotations(_fields_annotations);
4079     annotations-&gt;set_fields_type_annotations(_fields_type_annotations);
4080 
4081     // This is the Annotations object that will be
4082     // assigned to InstanceKlass being constructed.
4083     _combined_annotations = annotations;
4084 
4085     // The annotations arrays below has been transfered the
4086     // _combined_annotations so these fields can now be cleared.
4087     _class_annotations       = NULL;
4088     _class_type_annotations  = NULL;
4089     _fields_annotations      = NULL;
4090     _fields_type_annotations = NULL;
4091 }
4092 
4093 // Transfer ownership of metadata allocated to the InstanceKlass.
4094 void ClassFileParser::apply_parsed_class_metadata(
4095                                             InstanceKlass* this_klass,
4096                                             int java_fields_count,
4097                                             TRAPS) {
4098   assert(this_klass != NULL, &quot;invariant&quot;);
4099 
4100   _cp-&gt;set_pool_holder(this_klass);
4101   this_klass-&gt;set_constants(_cp);
4102   this_klass-&gt;set_fields(_fields, java_fields_count);
4103   this_klass-&gt;set_methods(_methods);
4104   this_klass-&gt;set_inner_classes(_inner_classes);
4105   this_klass-&gt;set_nest_members(_nest_members);
4106   this_klass-&gt;set_nest_host_index(_nest_host);
4107   this_klass-&gt;set_annotations(_combined_annotations);
4108   this_klass-&gt;set_permitted_subclasses(_permitted_subclasses);
4109   this_klass-&gt;set_record_components(_record_components);
4110   // Delay the setting of _local_interfaces and _transitive_interfaces until after
4111   // initialize_supers() in fill_instance_klass(). It is because the _local_interfaces could
4112   // be shared with _transitive_interfaces and _transitive_interfaces may be shared with
4113   // its _super. If an OOM occurs while loading the current klass, its _super field
4114   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
4115   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
4116   // dereferences to the deallocated _transitive_interfaces will result in a crash.
4117 
4118   // Clear out these fields so they don&#39;t get deallocated by the destructor
4119   clear_class_metadata();
4120 }
4121 
4122 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
4123                                                        int runtime_visible_annotations_length,
4124                                                        const u1* const runtime_invisible_annotations,
4125                                                        int runtime_invisible_annotations_length,
4126                                                        TRAPS) {
4127   AnnotationArray* annotations = NULL;
4128   if (runtime_visible_annotations != NULL ||
4129       runtime_invisible_annotations != NULL) {
4130     annotations = MetadataFactory::new_array&lt;u1&gt;(_loader_data,
4131                                           runtime_visible_annotations_length +
4132                                           runtime_invisible_annotations_length,
4133                                           CHECK_(annotations));
4134     if (runtime_visible_annotations != NULL) {
4135       for (int i = 0; i &lt; runtime_visible_annotations_length; i++) {
4136         annotations-&gt;at_put(i, runtime_visible_annotations[i]);
4137       }
4138     }
4139     if (runtime_invisible_annotations != NULL) {
4140       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
4141         int append = runtime_visible_annotations_length+i;
4142         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
4143       }
4144     }
4145   }
4146   return annotations;
4147 }
4148 
4149 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
4150                                                         const int super_class_index,
4151                                                         const bool need_verify,
4152                                                         TRAPS) {
4153   assert(cp != NULL, &quot;invariant&quot;);
4154   const InstanceKlass* super_klass = NULL;
4155 
4156   if (super_class_index == 0) {
4157     check_property(_class_name == vmSymbols::java_lang_Object()
4158                    || (_access_flags.get_flags() &amp; JVM_ACC_VALUE),
4159                    &quot;Invalid superclass index %u in class file %s&quot;,
4160                    super_class_index,
4161                    CHECK_NULL);
4162   } else {
4163     check_property(valid_klass_reference_at(super_class_index),
4164                    &quot;Invalid superclass index %u in class file %s&quot;,
4165                    super_class_index,
4166                    CHECK_NULL);
4167     // The class name should be legal because it is checked when parsing constant pool.
4168     // However, make sure it is not an array type.
4169     bool is_array = false;
4170     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4171       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4172       if (need_verify)
4173         is_array = super_klass-&gt;is_array_klass();
4174     } else if (need_verify) {
4175       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4176     }
4177     if (need_verify) {
4178       guarantee_property(!is_array,
4179                         &quot;Bad superclass name in class file %s&quot;, CHECK_NULL);
4180     }
4181   }
4182   return super_klass;
4183 }
4184 
4185 #ifndef PRODUCT
4186 static void print_field_layout(const Symbol* name,
4187                                Array&lt;u2&gt;* fields,
4188                                ConstantPool* cp,
4189                                int instance_size,
4190                                int instance_fields_start,
4191                                int instance_fields_end,
4192                                int static_fields_end) {
4193 
4194   assert(name != NULL, &quot;invariant&quot;);
4195 
4196   tty-&gt;print(&quot;%s: field layout\n&quot;, name-&gt;as_klass_external_name());
4197   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_start, &quot;--- instance fields start ---&quot;);
4198   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
4199     if (!fs.access_flags().is_static()) {
4200       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
4201         fs.offset(),
4202         fs.name()-&gt;as_klass_external_name(),
4203         fs.signature()-&gt;as_klass_external_name());
4204     }
4205   }
4206   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_end, &quot;--- instance fields end ---&quot;);
4207   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_size * wordSize, &quot;--- instance ends ---&quot;);
4208   tty-&gt;print(&quot;  @%3d %s\n&quot;, InstanceMirrorKlass::offset_of_static_fields(), &quot;--- static fields start ---&quot;);
4209   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
4210     if (fs.access_flags().is_static()) {
4211       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
4212         fs.offset(),
4213         fs.name()-&gt;as_klass_external_name(),
4214         fs.signature()-&gt;as_klass_external_name());
4215     }
4216   }
4217   tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);
4218   tty-&gt;print(&quot;\n&quot;);
4219 }
4220 #endif
4221 
4222 OopMapBlocksBuilder::OopMapBlocksBuilder(unsigned int max_blocks) {
4223   _max_nonstatic_oop_maps = max_blocks;
4224   _nonstatic_oop_map_count = 0;
4225   if (max_blocks == 0) {
4226     _nonstatic_oop_maps = NULL;
4227   } else {
4228     _nonstatic_oop_maps =
4229         NEW_RESOURCE_ARRAY(OopMapBlock, _max_nonstatic_oop_maps);
4230     memset(_nonstatic_oop_maps, 0, sizeof(OopMapBlock) * max_blocks);
4231   }
4232 }
4233 
4234 OopMapBlock* OopMapBlocksBuilder::last_oop_map() const {
4235   assert(_nonstatic_oop_map_count &gt; 0, &quot;Has no oop maps&quot;);
4236   return _nonstatic_oop_maps + (_nonstatic_oop_map_count - 1);
4237 }
4238 
4239 // addition of super oop maps
4240 void OopMapBlocksBuilder::initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks) {
4241   assert(nof_blocks &amp;&amp; _nonstatic_oop_map_count == 0 &amp;&amp;
4242          nof_blocks &lt;= _max_nonstatic_oop_maps, &quot;invariant&quot;);
4243 
4244   memcpy(_nonstatic_oop_maps, blocks, sizeof(OopMapBlock) * nof_blocks);
4245   _nonstatic_oop_map_count += nof_blocks;
4246 }
4247 
4248 // collection of oops
4249 void OopMapBlocksBuilder::add(int offset, int count) {
4250   if (_nonstatic_oop_map_count == 0) {
4251     _nonstatic_oop_map_count++;
4252   }
4253   OopMapBlock* nonstatic_oop_map = last_oop_map();
4254   if (nonstatic_oop_map-&gt;count() == 0) {  // Unused map, set it up
4255     nonstatic_oop_map-&gt;set_offset(offset);
4256     nonstatic_oop_map-&gt;set_count(count);
4257   } else if (nonstatic_oop_map-&gt;is_contiguous(offset)) { // contiguous, add
4258     nonstatic_oop_map-&gt;increment_count(count);
4259   } else { // Need a new one...
4260     _nonstatic_oop_map_count++;
4261     assert(_nonstatic_oop_map_count &lt;= _max_nonstatic_oop_maps, &quot;range check&quot;);
4262     nonstatic_oop_map = last_oop_map();
4263     nonstatic_oop_map-&gt;set_offset(offset);
4264     nonstatic_oop_map-&gt;set_count(count);
4265   }
4266 }
4267 
4268 // general purpose copy, e.g. into allocated instanceKlass
4269 void OopMapBlocksBuilder::copy(OopMapBlock* dst) {
4270   if (_nonstatic_oop_map_count != 0) {
4271     memcpy(dst, _nonstatic_oop_maps, sizeof(OopMapBlock) * _nonstatic_oop_map_count);
4272   }
4273 }
4274 
4275 // Sort and compact adjacent blocks
4276 void OopMapBlocksBuilder::compact() {
4277   if (_nonstatic_oop_map_count &lt;= 1) {
4278     return;
4279   }
4280   /*
4281    * Since field layout sneeks in oops before values, we will be able to condense
4282    * blocks. There is potential to compact between super, own refs and values
4283    * containing refs.
4284    *
4285    * Currently compaction is slightly limited due to values being 8 byte aligned.
4286    * This may well change: FixMe if it doesn&#39;t, the code below is fairly general purpose
4287    * and maybe it doesn&#39;t need to be.
4288    */
4289   qsort(_nonstatic_oop_maps, _nonstatic_oop_map_count, sizeof(OopMapBlock),
4290         (_sort_Fn)OopMapBlock::compare_offset);
4291   if (_nonstatic_oop_map_count &lt; 2) {
4292     return;
4293   }
4294 
4295   // Make a temp copy, and iterate through and copy back into the original
4296   ResourceMark rm;
4297   OopMapBlock* oop_maps_copy =
4298       NEW_RESOURCE_ARRAY(OopMapBlock, _nonstatic_oop_map_count);
4299   OopMapBlock* oop_maps_copy_end = oop_maps_copy + _nonstatic_oop_map_count;
4300   copy(oop_maps_copy);
4301   OopMapBlock* nonstatic_oop_map = _nonstatic_oop_maps;
4302   unsigned int new_count = 1;
4303   oop_maps_copy++;
4304   while(oop_maps_copy &lt; oop_maps_copy_end) {
4305     assert(nonstatic_oop_map-&gt;offset() &lt; oop_maps_copy-&gt;offset(), &quot;invariant&quot;);
4306     if (nonstatic_oop_map-&gt;is_contiguous(oop_maps_copy-&gt;offset())) {
4307       nonstatic_oop_map-&gt;increment_count(oop_maps_copy-&gt;count());
4308     } else {
4309       nonstatic_oop_map++;
4310       new_count++;
4311       nonstatic_oop_map-&gt;set_offset(oop_maps_copy-&gt;offset());
4312       nonstatic_oop_map-&gt;set_count(oop_maps_copy-&gt;count());
4313     }
4314     oop_maps_copy++;
4315   }
4316   assert(new_count &lt;= _nonstatic_oop_map_count, &quot;end up with more maps after compact() ?&quot;);
4317   _nonstatic_oop_map_count = new_count;
4318 }
4319 
4320 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4321   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4322   if (_nonstatic_oop_map_count &gt; 0) {
4323     OopMapBlock* map = _nonstatic_oop_maps;
4324     OopMapBlock* last_map = last_oop_map();
4325     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4326     while (map &lt;= last_map) {
4327       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4328                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4329       map++;
4330     }
4331   }
4332 }
4333 
4334 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4335   print_on(st);
4336 }
4337 
4338 void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,
4339                                                 const char* msg,
4340                                                 const Symbol* name,
4341                                                 const Symbol* sig) const {
4342 
4343   ResourceMark rm(THREAD);
4344   if (name == NULL || sig == NULL) {
4345     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4346         vmSymbols::java_lang_ClassFormatError(),
4347         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);
4348   }
4349   else {
4350     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4351         vmSymbols::java_lang_ClassFormatError(),
4352         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),
4353         _class_name-&gt;as_C_string(), msg);
4354   }
4355 }
4356 
4357 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4358 void ClassFileParser::layout_fields(ConstantPool* cp,
4359                                     const FieldAllocationCount* fac,
4360                                     const ClassAnnotationCollector* parsed_annotations,
4361                                     FieldLayoutInfo* info,
4362                                     TRAPS) {
4363 
4364   assert(cp != NULL, &quot;invariant&quot;);
4365 
4366   // Field size and offset computation
4367   int nonstatic_field_size = _super_klass == NULL ? 0 :
4368                                _super_klass-&gt;nonstatic_field_size();
4369   int next_nonstatic_inline_type_offset = 0;
4370   int first_nonstatic_inline_type_offset = 0;
4371 
4372   // Fields that are inline types are handled differently depending if they are static or not:
4373   // - static fields are oops
4374   // - non-static fields are embedded
4375 
4376   // Count the contended fields by type.
4377   //
4378   // We ignore static fields, because @Contended is not supported for them.
4379   // The layout code below will also ignore the static fields.
4380   int nonstatic_contended_count = 0;
4381   FieldAllocationCount fac_contended;
4382   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4383     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4384     if (fs.is_contended()) {
4385       fac_contended.count[atype]++;
4386       if (!fs.access_flags().is_static()) {
4387         nonstatic_contended_count++;
4388       }
4389     }
4390   }
4391 
4392 
4393   // Calculate the starting byte offsets
4394   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
4395   // Inline types in static fields are not embedded, they are handled with oops
4396   int next_static_double_offset = next_static_oop_offset +
4397                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_INLINE]) * heapOopSize);
4398   if (fac-&gt;count[STATIC_DOUBLE]) {
4399     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4400   }
4401 
4402   int next_static_word_offset   = next_static_double_offset +
4403                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4404   int next_static_short_offset  = next_static_word_offset +
4405                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4406   int next_static_byte_offset   = next_static_short_offset +
4407                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4408 
4409   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4410                                 nonstatic_field_size * heapOopSize;
4411 
4412   // First field of inline types is aligned on a long boundary in order to ease
4413   // in-lining of inline types (with header removal) in packed arrays and
4414   // inlined fields
4415   int initial_inline_type_padding = 0;
4416   if (is_inline_type()) {
4417     int old = nonstatic_fields_start;
4418     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);
4419     initial_inline_type_padding = nonstatic_fields_start - old;
4420   }
4421 
4422   int next_nonstatic_field_offset = nonstatic_fields_start;
4423 
4424   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4425 
4426   // Class is contended, pad before all the fields
4427   if (is_contended_class) {
4428     next_nonstatic_field_offset += ContendedPaddingWidth;
4429   }
4430 
4431   // Temporary inline types restrictions
4432   if (is_inline_type()) {
4433     if (is_contended_class) {
4434       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);
4435       return;
4436     }
4437   }
4438 
4439   // Compute the non-contended fields count.
4440   // The packing code below relies on these counts to determine if some field
4441   // can be squeezed into the alignment gap. Contended fields are obviously
4442   // exempt from that.
4443   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4444   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4445   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4446   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4447   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4448 
4449   int static_inline_type_count = 0;
4450   int nonstatic_inline_type_count = 0;
4451   int* nonstatic_inline_type_indexes = NULL;
4452   Klass** nonstatic_inline_type_klasses = NULL;
4453   unsigned int inline_type_oop_map_count = 0;
4454   int inline_types_not_inlined = 0;
4455   int not_atomic_inline_types = 0;
4456 
4457   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_INLINE] + 1;
4458 
4459   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,
4460                                                                max_nonstatic_inline_type);
4461   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {
4462     nonstatic_inline_type_indexes[i] = -1;
4463   }
4464   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,
4465                                                                max_nonstatic_inline_type);
4466 
4467   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
4468     if (fs.allocation_type() == STATIC_INLINE) {
4469       ResourceMark rm;
4470       if (!fs.signature()-&gt;is_Q_signature()) {
4471         THROW(vmSymbols::java_lang_ClassFormatError());
4472       }
4473       static_inline_type_count++;
4474     } else if (fs.allocation_type() == NONSTATIC_INLINE) {
4475       // Pre-resolve the inline field and check for inline type circularity issues.
4476       ResourceMark rm;
4477       if (!fs.signature()-&gt;is_Q_signature()) {
4478         THROW(vmSymbols::java_lang_ClassFormatError());
4479       }
4480       Klass* klass =
4481         SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,
4482                                                             Handle(THREAD, _loader_data-&gt;class_loader()),
4483                                                             _protection_domain, true, CHECK);
4484       assert(klass != NULL, &quot;Sanity check&quot;);
4485       if (!klass-&gt;access_flags().is_inline_type()) {
4486         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
4487       }
4488       InlineKlass* vk = InlineKlass::cast(klass);
4489       // Conditions to apply flattening or not should be defined in a single place
4490       bool too_big_to_allocate_inline = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;
4491                                  (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);
4492       bool too_atomic_to_allocate_inline = vk-&gt;is_declared_atomic();
4493       bool too_volatile_to_allocate_inline = fs.access_flags().is_volatile();
4494       if (vk-&gt;is_naturally_atomic()) {
4495         too_atomic_to_allocate_inline = false;
4496         // too_volatile_to_allocate_inline = false; //FIXME
4497         // volatile fields are currently never inlined, this could change in the future
4498       }
4499       if (!(too_big_to_allocate_inline | too_atomic_to_allocate_inline | too_volatile_to_allocate_inline)) {
4500         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();
4501         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;
4502         nonstatic_inline_type_count++;
4503 
4504         InlineKlass* vklass = InlineKlass::cast(klass);
4505         if (vklass-&gt;contains_oops()) {
4506           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();
4507         }
4508         fs.set_inlined(true);
4509         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
4510           not_atomic_inline_types++;
4511         }
4512       } else {
4513         inline_types_not_inlined++;
4514         fs.set_inlined(false);
4515       }
4516     }
4517   }
4518 
4519   // Adjusting non_static_oop_count to take into account inline types fields not inlined;
4520   nonstatic_oop_count += inline_types_not_inlined;
4521 
4522   // Total non-static fields count, including every contended field
4523   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4524                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
4525                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_INLINE];
4526 
4527   const bool super_has_nonstatic_fields =
4528           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4529   const bool has_nonstatic_fields =
4530     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
4531   const bool has_nonstatic_inline_fields = nonstatic_inline_type_count &gt; 0;
4532 
4533   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {
4534     // There are a number of fixes required throughout the type system and JIT
4535     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);
4536     return;
4537   }
4538 
4539   // Prepare list of oops for oop map generation.
4540   //
4541   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4542   // regions. offset[i] is the start of the i-th region, which then has
4543   // count[i] oops following. Before we know how many regions are required,
4544   // we pessimistically allocate the maps to fit all the oops into the
4545   // distinct regions.
4546   //
4547   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
4548   int max_oop_map_count =
4549       super_oop_map_count +
4550       fac-&gt;count[NONSTATIC_OOP] +
4551       inline_type_oop_map_count +
4552       inline_types_not_inlined;
4553 
4554   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4555   if (super_oop_map_count &gt; 0) {
4556     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4557                                                     _super_klass-&gt;nonstatic_oop_map_count());
4558   }
4559 
4560   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4561 
4562   bool compact_fields  = true;
4563   bool allocate_oops_first = false;
4564 
4565   int next_nonstatic_oop_offset = 0;
4566   int next_nonstatic_double_offset = 0;
4567 
4568   // Rearrange fields for a given allocation style
4569   if (allocate_oops_first) {
4570     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4571     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4572     next_nonstatic_double_offset = next_nonstatic_oop_offset +
4573                                     (nonstatic_oop_count * heapOopSize);
4574   } else {
4575     // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
4576     next_nonstatic_double_offset = next_nonstatic_field_offset;
4577   }
4578 
4579   int nonstatic_oop_space_count   = 0;
4580   int nonstatic_word_space_count  = 0;
4581   int nonstatic_short_space_count = 0;
4582   int nonstatic_byte_space_count  = 0;
4583   int nonstatic_oop_space_offset = 0;
4584   int nonstatic_word_space_offset = 0;
4585   int nonstatic_short_space_offset = 0;
4586   int nonstatic_byte_space_offset = 0;
4587 
4588   // Try to squeeze some of the fields into the gaps due to
4589   // long/double alignment.
4590   if (nonstatic_double_count &gt; 0) {
4591     int offset = next_nonstatic_double_offset;
4592     next_nonstatic_double_offset = align_up(offset, BytesPerLong);
4593     if (compact_fields &amp;&amp; offset != next_nonstatic_double_offset) {
4594       // Allocate available fields into the gap before double field.
4595       int length = next_nonstatic_double_offset - offset;
4596       assert(length == BytesPerInt, &quot;&quot;);
4597       nonstatic_word_space_offset = offset;
4598       if (nonstatic_word_count &gt; 0) {
4599         nonstatic_word_count      -= 1;
4600         nonstatic_word_space_count = 1; // Only one will fit
4601         length -= BytesPerInt;
4602         offset += BytesPerInt;
4603       }
4604       nonstatic_short_space_offset = offset;
4605       while (length &gt;= BytesPerShort &amp;&amp; nonstatic_short_count &gt; 0) {
4606         nonstatic_short_count       -= 1;
4607         nonstatic_short_space_count += 1;
4608         length -= BytesPerShort;
4609         offset += BytesPerShort;
4610       }
4611       nonstatic_byte_space_offset = offset;
4612       while (length &gt; 0 &amp;&amp; nonstatic_byte_count &gt; 0) {
4613         nonstatic_byte_count       -= 1;
4614         nonstatic_byte_space_count += 1;
4615         length -= 1;
4616       }
4617       // Allocate oop field in the gap if there are no other fields for that.
4618       nonstatic_oop_space_offset = offset;
4619       if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;
4620           !allocate_oops_first) { // when oop fields not first
4621         nonstatic_oop_count      -= 1;
4622         nonstatic_oop_space_count = 1; // Only one will fit
4623         length -= heapOopSize;
4624         offset += heapOopSize;
4625       }
4626     }
4627   }
4628 
4629   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4630                                      (nonstatic_double_count * BytesPerLong);
4631   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4632                                       (nonstatic_word_count * BytesPerInt);
4633   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4634                                      (nonstatic_short_count * BytesPerShort);
4635   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4636                                        nonstatic_byte_count;
4637 
4638   // let oops jump before padding with this allocation style
4639   if (!allocate_oops_first) {
4640     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4641     if( nonstatic_oop_count &gt; 0 ) {
4642       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4643     }
4644     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4645   }
4646 
4647   // Aligning embedded inline types
4648   // bug below, the current algorithm to layout embedded inline types always put them at the
4649   // end of the layout, which doesn&#39;t match the different allocation policies the VM is
4650   // supposed to provide =&gt; FixMe
4651   // Note also that the current alignment policy is to make each inline type starting on a
4652   // 64 bits boundary. This could be optimized later. For instance, it could be nice to
4653   // align inline types according to their most constrained internal type.
4654   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4655   int next_inline_type_index = 0;
4656 
4657   // Iterate over fields again and compute correct offsets.
4658   // The field allocation type was temporarily stored in the offset slot.
4659   // oop fields are located before non-oop fields (static and non-static).
4660   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4661 
4662     // skip already laid out fields
4663     if (fs.is_offset_set()) continue;
4664 
4665     // contended instance fields are handled below
4666     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4667 
4668     int real_offset = 0;
4669     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4670 
4671     // pack the rest of the fields
4672     switch (atype) {
4673       // Inline types in static fields are handled with oops
4674       case STATIC_INLINE:   // Fallthrough
4675       case STATIC_OOP:
4676         real_offset = next_static_oop_offset;
4677         next_static_oop_offset += heapOopSize;
4678         break;
4679       case STATIC_BYTE:
4680         real_offset = next_static_byte_offset;
4681         next_static_byte_offset += 1;
4682         break;
4683       case STATIC_SHORT:
4684         real_offset = next_static_short_offset;
4685         next_static_short_offset += BytesPerShort;
4686         break;
4687       case STATIC_WORD:
4688         real_offset = next_static_word_offset;
4689         next_static_word_offset += BytesPerInt;
4690         break;
4691       case STATIC_DOUBLE:
4692         real_offset = next_static_double_offset;
4693         next_static_double_offset += BytesPerLong;
4694         break;
4695       case NONSTATIC_INLINE:
4696         if (fs.is_inlined()) {
4697           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];
4698           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);
4699           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);
4700           InlineKlass* vklass = InlineKlass::cast(klass);
4701           real_offset = next_nonstatic_inline_type_offset;
4702           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();
4703           // aligning next inline type on a 64 bits boundary
4704           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);
4705           next_inline_type_index += 1;
4706 
4707           if (vklass-&gt;contains_oops()) { // add flatten oop maps
4708             int diff = real_offset - vklass-&gt;first_field_offset();
4709             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();
4710             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();
4711             while (map &lt; last_map) {
4712               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());
4713               map++;
4714             }
4715           }
4716           break;
4717         } else {
4718           // Fall through
4719         }
4720       case NONSTATIC_OOP:
4721         if( nonstatic_oop_space_count &gt; 0 ) {
4722           real_offset = nonstatic_oop_space_offset;
4723           nonstatic_oop_space_offset += heapOopSize;
4724           nonstatic_oop_space_count  -= 1;
4725         } else {
4726           real_offset = next_nonstatic_oop_offset;
4727           next_nonstatic_oop_offset += heapOopSize;
4728         }
4729         nonstatic_oop_maps-&gt;add(real_offset, 1);
4730         break;
4731       case NONSTATIC_BYTE:
4732         if( nonstatic_byte_space_count &gt; 0 ) {
4733           real_offset = nonstatic_byte_space_offset;
4734           nonstatic_byte_space_offset += 1;
4735           nonstatic_byte_space_count  -= 1;
4736         } else {
4737           real_offset = next_nonstatic_byte_offset;
4738           next_nonstatic_byte_offset += 1;
4739         }
4740         break;
4741       case NONSTATIC_SHORT:
4742         if( nonstatic_short_space_count &gt; 0 ) {
4743           real_offset = nonstatic_short_space_offset;
4744           nonstatic_short_space_offset += BytesPerShort;
4745           nonstatic_short_space_count  -= 1;
4746         } else {
4747           real_offset = next_nonstatic_short_offset;
4748           next_nonstatic_short_offset += BytesPerShort;
4749         }
4750         break;
4751       case NONSTATIC_WORD:
4752         if( nonstatic_word_space_count &gt; 0 ) {
4753           real_offset = nonstatic_word_space_offset;
4754           nonstatic_word_space_offset += BytesPerInt;
4755           nonstatic_word_space_count  -= 1;
4756         } else {
4757           real_offset = next_nonstatic_word_offset;
4758           next_nonstatic_word_offset += BytesPerInt;
4759         }
4760         break;
4761       case NONSTATIC_DOUBLE:
4762         real_offset = next_nonstatic_double_offset;
4763         next_nonstatic_double_offset += BytesPerLong;
4764         break;
4765       default:
4766         ShouldNotReachHere();
4767     }
4768     fs.set_offset(real_offset);
4769   }
4770 
4771 
4772   // Handle the contended cases.
4773   //
4774   // Each contended field should not intersect the cache line with another contended field.
4775   // In the absence of alignment information, we end up with pessimistically separating
4776   // the fields with full-width padding.
4777   //
4778   // Additionally, this should not break alignment for the fields, so we round the alignment up
4779   // for each field.
4780   if (nonstatic_contended_count &gt; 0) {
4781 
4782     // if there is at least one contended field, we need to have pre-padding for them
4783     next_nonstatic_padded_offset += ContendedPaddingWidth;
4784 
4785     // collect all contended groups
4786     ResourceBitMap bm(cp-&gt;size());
4787     for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4788       // skip already laid out fields
4789       if (fs.is_offset_set()) continue;
4790 
4791       if (fs.is_contended()) {
4792         bm.set_bit(fs.contended_group());
4793       }
4794     }
4795 
4796     int current_group = -1;
4797     while ((current_group = (int)bm.get_next_one_offset(current_group + 1)) != (int)bm.size()) {
4798 
4799       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4800 
4801         // skip already laid out fields
4802         if (fs.is_offset_set()) continue;
4803 
4804         // skip non-contended fields and fields from different group
4805         if (!fs.is_contended() || (fs.contended_group() != current_group)) continue;
4806 
4807         // handle statics below
4808         if (fs.access_flags().is_static()) continue;
4809 
4810         int real_offset = 0;
4811         FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4812 
4813         switch (atype) {
4814           case NONSTATIC_BYTE:
4815             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, 1);
4816             real_offset = next_nonstatic_padded_offset;
4817             next_nonstatic_padded_offset += 1;
4818             break;
4819 
4820           case NONSTATIC_SHORT:
4821             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4822             real_offset = next_nonstatic_padded_offset;
4823             next_nonstatic_padded_offset += BytesPerShort;
4824             break;
4825 
4826           case NONSTATIC_WORD:
4827             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4828             real_offset = next_nonstatic_padded_offset;
4829             next_nonstatic_padded_offset += BytesPerInt;
4830             break;
4831 
4832           case NONSTATIC_DOUBLE:
4833             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4834             real_offset = next_nonstatic_padded_offset;
4835             next_nonstatic_padded_offset += BytesPerLong;
4836             break;
4837 
4838             // Inline types in static fields are handled with oops
4839           case NONSTATIC_INLINE:
4840             throwInlineTypeLimitation(THREAD_AND_LOCATION,
4841                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());
4842             return;
4843 
4844           case NONSTATIC_OOP:
4845             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4846             real_offset = next_nonstatic_padded_offset;
4847             next_nonstatic_padded_offset += heapOopSize;
4848             nonstatic_oop_maps-&gt;add(real_offset, 1);
4849             break;
4850 
4851           default:
4852             ShouldNotReachHere();
4853         }
4854 
4855         if (fs.contended_group() == 0) {
4856           // Contended group defines the equivalence class over the fields:
4857           // the fields within the same contended group are not inter-padded.
4858           // The only exception is default group, which does not incur the
4859           // equivalence, and so requires intra-padding.
4860           next_nonstatic_padded_offset += ContendedPaddingWidth;
4861         }
4862 
4863         fs.set_offset(real_offset);
4864       } // for
4865 
4866       // Start laying out the next group.
4867       // Note that this will effectively pad the last group in the back;
4868       // this is expected to alleviate memory contention effects for
4869       // subclass fields and/or adjacent object.
4870       // If this was the default group, the padding is already in place.
4871       if (current_group != 0) {
4872         next_nonstatic_padded_offset += ContendedPaddingWidth;
4873       }
4874     }
4875 
4876     // handle static fields
4877   }
4878 
4879   // Entire class is contended, pad in the back.
4880   // This helps to alleviate memory contention effects for subclass fields
4881   // and/or adjacent object.
4882   if (is_contended_class) {
4883     assert(!is_inline_type(), &quot;@Contended not supported for inline types yet&quot;);
4884     next_nonstatic_padded_offset += ContendedPaddingWidth;
4885   }
4886 
4887   int notaligned_nonstatic_fields_end;
4888   if (nonstatic_inline_type_count != 0) {
4889     notaligned_nonstatic_fields_end = next_nonstatic_inline_type_offset;
4890   } else {
4891     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;
4892   }
4893 
4894   int nonstatic_field_sz_align = heapOopSize;
4895   if (is_inline_type()) {
4896     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {
4897       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy
4898     }
4899   }
4900   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);
4901   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4902   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4903 
4904   int static_field_size         = (static_fields_end -
4905                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4906   nonstatic_field_size          = nonstatic_field_size +
4907                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4908 
4909   int instance_size             = align_object_size(instance_end / wordSize);
4910 
4911   assert(instance_size == align_object_size(align_up(
4912          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)
4913          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);
4914 
4915 
4916   // Invariant: nonstatic_field end/start should only change if there are
4917   // nonstatic fields in the class, or if the class is contended. We compare
4918   // against the non-aligned value, so that end alignment will not fail the
4919   // assert without actually having the fields.
4920   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4921          is_contended_class ||
4922          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4923 
4924   // Number of non-static oop map blocks allocated at end of klass.
4925   nonstatic_oop_maps-&gt;compact();
4926 
4927 #ifndef PRODUCT
4928   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||
4929       (PrintInlineLayout &amp;&amp; (is_inline_type() || has_nonstatic_inline_fields))) {
4930     print_field_layout(_class_name,
4931           _fields,
4932           cp,
4933           instance_size,
4934           nonstatic_fields_start,
4935           nonstatic_fields_end,
4936           static_fields_end);
4937     nonstatic_oop_maps-&gt;print_on(tty);
4938     tty-&gt;print(&quot;\n&quot;);
4939     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4940     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4941     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4942     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4943     tty-&gt;print_cr(&quot;---&quot;);
4944   }
4945 
4946 #endif
4947   // Pass back information needed for InstanceKlass creation
4948   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4949   info-&gt;_instance_size = instance_size;
4950   info-&gt;_static_field_size = static_field_size;
4951   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4952   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
4953   info-&gt;_has_inline_fields = nonstatic_inline_type_count &gt; 0;
4954 
4955   // An inline type is naturally atomic if it has just one field, and
4956   // that field is simple enough.
4957   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;
4958                                 !super_has_nonstatic_fields &amp;&amp;
4959                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;
4960                                 (not_atomic_inline_types == 0) &amp;&amp;
4961                                 (nonstatic_contended_count == 0));
4962   // This may be too restrictive, since if all the fields fit in 64
4963   // bits we could make the decision to align instances of this class
4964   // to 64-bit boundaries, and load and store them as single words.
4965   // And on machines which supported larger atomics we could similarly
4966   // allow larger values to be atomic, if properly aligned.
4967 }
4968 
4969 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4970   assert(ik != NULL, &quot;invariant&quot;);
4971 
4972   const Klass* const super = ik-&gt;super();
4973 
4974   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4975   // in which case we don&#39;t have to register objects as finalizable
4976   if (!_has_empty_finalizer) {
4977     if (_has_finalizer ||
4978         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4979       ik-&gt;set_has_finalizer();
4980     }
4981   }
4982 
4983 #ifdef ASSERT
4984   bool f = false;
4985   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4986                                            vmSymbols::void_method_signature());
4987   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4988       f = true;
4989   }
4990 
4991   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4992   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4993   // will not work as expected we shouldn&#39;t abort vm in this case
4994   if (!ik-&gt;has_redefined_this_or_super()) {
4995     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4996   }
4997 #endif
4998 
4999   // Check if this klass supports the java.lang.Cloneable interface
5000   if (SystemDictionary::Cloneable_klass_loaded()) {
5001     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
5002       if (ik-&gt;is_inline_klass()) {
5003         Thread *THREAD = Thread::current();
5004         throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);
5005         return;
5006       }
5007       ik-&gt;set_is_cloneable();
5008     }
5009   }
5010 
5011   // Check if this klass has a vanilla default constructor
5012   if (super == NULL) {
5013     // java.lang.Object has empty default constructor
5014     ik-&gt;set_has_vanilla_constructor();
5015   } else {
5016     if (super-&gt;has_vanilla_constructor() &amp;&amp;
5017         _has_vanilla_constructor) {
5018       ik-&gt;set_has_vanilla_constructor();
5019     }
5020 #ifdef ASSERT
5021     bool v = false;
5022     if (super-&gt;has_vanilla_constructor()) {
5023       const Method* const constructor =
5024         ik-&gt;find_method(vmSymbols::object_initializer_name(),
5025                        vmSymbols::void_method_signature());
5026       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
5027         v = true;
5028       }
5029     }
5030     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
5031 #endif
5032   }
5033 
5034   // If it cannot be fast-path allocated, set a bit in the layout helper.
5035   // See documentation of InstanceKlass::can_be_fastpath_allocated().
5036   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
5037   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
5038       || ik-&gt;is_abstract() || ik-&gt;is_interface()
5039       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
5040       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
5041     // Forbid fast-path allocation.
5042     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
5043     ik-&gt;set_layout_helper(lh);
5044   }
5045 }
5046 
5047 bool ClassFileParser::supports_inline_types() const {
5048   // Inline types are only supported by class file version 55 and later
5049   return _major_version &gt;= JAVA_11_VERSION;
5050 }
5051 
5052 // utility methods for appending an array with check for duplicates
5053 
5054 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
5055                               const Array&lt;InstanceKlass*&gt;* const ifs) {
5056   // iterate over new interfaces
5057   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
5058     InstanceKlass* const e = ifs-&gt;at(i);
5059     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
5060     // add new interface
5061     result-&gt;append_if_missing(e);
5062   }
5063 }
5064 
5065 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
5066                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
5067                                                             ClassLoaderData* loader_data,
5068                                                             TRAPS) {
5069   assert(local_ifs != NULL, &quot;invariant&quot;);
5070   assert(loader_data != NULL, &quot;invariant&quot;);
5071 
5072   // Compute maximum size for transitive interfaces
5073   int max_transitive_size = 0;
5074   int super_size = 0;
5075   // Add superclass transitive interfaces size
5076   if (super != NULL) {
5077     super_size = super-&gt;transitive_interfaces()-&gt;length();
5078     max_transitive_size += super_size;
5079   }
5080   // Add local interfaces&#39; super interfaces
5081   const int local_size = local_ifs-&gt;length();
5082   for (int i = 0; i &lt; local_size; i++) {
5083     InstanceKlass* const l = local_ifs-&gt;at(i);
5084     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
5085   }
5086   // Finally add local interfaces
5087   max_transitive_size += local_size;
5088   // Construct array
5089   if (max_transitive_size == 0) {
5090     // no interfaces, use canonicalized array
5091     return Universe::the_empty_instance_klass_array();
5092   } else if (max_transitive_size == super_size) {
5093     // no new local interfaces added, share superklass&#39; transitive interface array
5094     return super-&gt;transitive_interfaces();
5095     // The three lines below are commented to work around bug JDK-8245487
5096 //  } else if (max_transitive_size == local_size) {
5097 //    // only local interfaces added, share local interface array
5098 //    return local_ifs;
5099   } else {
5100     ResourceMark rm;
5101     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
5102 
5103     // Copy down from superclass
5104     if (super != NULL) {
5105       append_interfaces(result, super-&gt;transitive_interfaces());
5106     }
5107 
5108     // Copy down from local interfaces&#39; superinterfaces
5109     for (int i = 0; i &lt; local_size; i++) {
5110       InstanceKlass* const l = local_ifs-&gt;at(i);
5111       append_interfaces(result, l-&gt;transitive_interfaces());
5112     }
5113     // Finally add local interfaces
5114     append_interfaces(result, local_ifs);
5115 
5116     // length will be less than the max_transitive_size if duplicates were removed
5117     const int length = result-&gt;length();
5118     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
5119 
5120     if (length == 1 &amp;&amp; result-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {
5121       return Universe::the_single_IdentityObject_klass_array();
5122     }
5123 
5124     Array&lt;InstanceKlass*&gt;* const new_result =
5125       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
5126     for (int i = 0; i &lt; length; i++) {
5127       InstanceKlass* const e = result-&gt;at(i);
5128       assert(e != NULL, &quot;just checking&quot;);
5129       new_result-&gt;at_put(i, e);
5130     }
5131     return new_result;
5132   }
5133 }
5134 
5135 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
5136   assert(this_klass != NULL, &quot;invariant&quot;);
5137   const Klass* const super = this_klass-&gt;super();
5138 
5139   if (super != NULL) {
5140     const InstanceKlass* super_ik = InstanceKlass::cast(super);
5141 
5142     if (super-&gt;is_final()) {
5143       ResourceMark rm(THREAD);
5144       Exceptions::fthrow(
5145         THREAD_AND_LOCATION,
5146         vmSymbols::java_lang_VerifyError(),
5147         &quot;class %s cannot inherit from final class %s&quot;,
5148         this_klass-&gt;external_name(),
5149         super_ik-&gt;external_name());
5150       return;
5151     }
5152 
5153     if (super_ik-&gt;is_sealed() &amp;&amp; !super_ik-&gt;has_as_permitted_subclass(this_klass)) {
5154       ResourceMark rm(THREAD);
5155       Exceptions::fthrow(
5156         THREAD_AND_LOCATION,
5157         vmSymbols::java_lang_IncompatibleClassChangeError(),
5158         &quot;class %s cannot inherit from sealed class %s&quot;,
5159         this_klass-&gt;external_name(),
5160         super_ik-&gt;external_name());
5161       return;
5162     }
5163 
5164     // If the loader is not the boot loader then throw an exception if its
5165     // superclass is in package jdk.internal.reflect and its loader is not a
5166     // special reflection class loader
5167     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
5168       PackageEntry* super_package = super-&gt;package();
5169       if (super_package != NULL &amp;&amp;
5170           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
5171           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
5172         ResourceMark rm(THREAD);
5173         Exceptions::fthrow(
5174           THREAD_AND_LOCATION,
5175           vmSymbols::java_lang_IllegalAccessError(),
5176           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
5177           this_klass-&gt;external_name(),
5178           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
5179           super-&gt;external_name());
5180         return;
5181       }
5182     }
5183 
5184     Reflection::VerifyClassAccessResults vca_result =
5185       Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);
5186     if (vca_result != Reflection::ACCESS_OK) {
5187       ResourceMark rm(THREAD);
5188       char* msg = Reflection::verify_class_access_msg(this_klass,
5189                                                       InstanceKlass::cast(super),
5190                                                       vca_result);
5191       if (msg == NULL) {
5192         bool same_module = (this_klass-&gt;module() == super-&gt;module());
5193         Exceptions::fthrow(
5194           THREAD_AND_LOCATION,
5195           vmSymbols::java_lang_IllegalAccessError(),
5196           &quot;class %s cannot access its %ssuperclass %s (%s%s%s)&quot;,
5197           this_klass-&gt;external_name(),
5198           super-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
5199           super-&gt;external_name(),
5200           (same_module) ? this_klass-&gt;joint_in_module_of_loader(super) : this_klass-&gt;class_in_module_of_loader(),
5201           (same_module) ? &quot;&quot; : &quot;; &quot;,
5202           (same_module) ? &quot;&quot; : super-&gt;class_in_module_of_loader());
5203       } else {
5204         // Add additional message content.
5205         Exceptions::fthrow(
5206           THREAD_AND_LOCATION,
5207           vmSymbols::java_lang_IllegalAccessError(),
5208           &quot;superclass access check failed: %s&quot;,
5209           msg);
5210       }
5211     }
5212   }
5213 }
5214 
5215 
5216 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
5217   assert(this_klass != NULL, &quot;invariant&quot;);
5218   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
5219   const int lng = local_interfaces-&gt;length();
5220   for (int i = lng - 1; i &gt;= 0; i--) {
5221     InstanceKlass* const k = local_interfaces-&gt;at(i);
5222     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
5223 
5224     if (k-&gt;is_sealed() &amp;&amp; !k-&gt;has_as_permitted_subclass(this_klass)) {
5225       ResourceMark rm(THREAD);
5226       Exceptions::fthrow(
5227         THREAD_AND_LOCATION,
5228         vmSymbols::java_lang_IncompatibleClassChangeError(),
5229         &quot;class %s cannot %s sealed interface %s&quot;,
5230         this_klass-&gt;external_name(),
5231         this_klass-&gt;is_interface() ? &quot;extend&quot; : &quot;implement&quot;,
5232         k-&gt;external_name());
5233       return;
5234     }
5235 
5236     Reflection::VerifyClassAccessResults vca_result =
5237       Reflection::verify_class_access(this_klass, k, false);
5238     if (vca_result != Reflection::ACCESS_OK) {
5239       ResourceMark rm(THREAD);
5240       char* msg = Reflection::verify_class_access_msg(this_klass,
5241                                                       k,
5242                                                       vca_result);
5243       if (msg == NULL) {
5244         bool same_module = (this_klass-&gt;module() == k-&gt;module());
5245         Exceptions::fthrow(
5246           THREAD_AND_LOCATION,
5247           vmSymbols::java_lang_IllegalAccessError(),
5248           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
5249           this_klass-&gt;external_name(),
5250           k-&gt;external_name(),
5251           (same_module) ? this_klass-&gt;joint_in_module_of_loader(k) : this_klass-&gt;class_in_module_of_loader(),
5252           (same_module) ? &quot;&quot; : &quot;; &quot;,
5253           (same_module) ? &quot;&quot; : k-&gt;class_in_module_of_loader());
5254       } else {
5255         // Add additional message content.
5256         Exceptions::fthrow(
5257           THREAD_AND_LOCATION,
5258           vmSymbols::java_lang_IllegalAccessError(),
5259           &quot;superinterface check failed: %s&quot;,
5260           msg);
5261       }
5262     }
5263   }
5264 }
5265 
5266 
5267 static void check_final_method_override(const InstanceKlass* this_klass, TRAPS) {
5268   assert(this_klass != NULL, &quot;invariant&quot;);
5269   const Array&lt;Method*&gt;* const methods = this_klass-&gt;methods();
5270   const int num_methods = methods-&gt;length();
5271 
5272   // go thru each method and check if it overrides a final method
5273   for (int index = 0; index &lt; num_methods; index++) {
5274     const Method* const m = methods-&gt;at(index);
5275 
5276     // skip private, static, and &lt;init&gt; methods
5277     if ((!m-&gt;is_private() &amp;&amp; !m-&gt;is_static()) &amp;&amp;
5278         (m-&gt;name() != vmSymbols::object_initializer_name())) {
5279 
5280       const Symbol* const name = m-&gt;name();
5281       const Symbol* const signature = m-&gt;signature();
5282       const Klass* k = this_klass-&gt;super();
5283       const Method* super_m = NULL;
5284       while (k != NULL) {
5285         // skip supers that don&#39;t have final methods.
5286         if (k-&gt;has_final_method()) {
5287           // lookup a matching method in the super class hierarchy
5288           super_m = InstanceKlass::cast(k)-&gt;lookup_method(name, signature);
5289           if (super_m == NULL) {
5290             break; // didn&#39;t find any match; get out
5291           }
5292 
5293           if (super_m-&gt;is_final() &amp;&amp; !super_m-&gt;is_static() &amp;&amp;
5294               !super_m-&gt;access_flags().is_private()) {
5295             // matching method in super is final, and not static or private
5296             bool can_access = Reflection::verify_member_access(this_klass,
5297                                                                super_m-&gt;method_holder(),
5298                                                                super_m-&gt;method_holder(),
5299                                                                super_m-&gt;access_flags(),
5300                                                               false, false, CHECK);
5301             if (can_access) {
5302               // this class can access super final method and therefore override
5303               ResourceMark rm(THREAD);
5304               Exceptions::fthrow(THREAD_AND_LOCATION,
5305                                  vmSymbols::java_lang_VerifyError(),
5306                                  &quot;class %s overrides final method %s.%s%s&quot;,
5307                                  this_klass-&gt;external_name(),
5308                                  super_m-&gt;method_holder()-&gt;external_name(),
5309                                  name-&gt;as_C_string(),
5310                                  signature-&gt;as_C_string()
5311                                  );
5312               return;
5313             }
5314           }
5315 
5316           // continue to look from super_m&#39;s holder&#39;s super.
5317           k = super_m-&gt;method_holder()-&gt;super();
5318           continue;
5319         }
5320 
5321         k = k-&gt;super();
5322       }
5323     }
5324   }
5325 }
5326 
5327 
5328 // assumes that this_klass is an interface
5329 static void check_illegal_static_method(const InstanceKlass* this_klass, TRAPS) {
5330   assert(this_klass != NULL, &quot;invariant&quot;);
5331   assert(this_klass-&gt;is_interface(), &quot;not an interface&quot;);
5332   const Array&lt;Method*&gt;* methods = this_klass-&gt;methods();
5333   const int num_methods = methods-&gt;length();
5334 
5335   for (int index = 0; index &lt; num_methods; index++) {
5336     const Method* const m = methods-&gt;at(index);
5337     // if m is static and not the init method, throw a verify error
5338     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
5339       ResourceMark rm(THREAD);
5340       Exceptions::fthrow(
5341         THREAD_AND_LOCATION,
5342         vmSymbols::java_lang_VerifyError(),
5343         &quot;Illegal static method %s in interface %s&quot;,
5344         m-&gt;name()-&gt;as_C_string(),
5345         this_klass-&gt;external_name()
5346       );
5347       return;
5348     }
5349   }
5350 }
5351 
5352 // utility methods for format checking
5353 
5354 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
5355   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
5356   const bool is_inline_type = (flags &amp; JVM_ACC_VALUE) != 0;
5357   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
5358   assert(supports_inline_types() || !is_inline_type, &quot;JVM_ACC_VALUE should not be set&quot;);
5359   if (is_module) {
5360     ResourceMark rm(THREAD);
5361     Exceptions::fthrow(
5362       THREAD_AND_LOCATION,
5363       vmSymbols::java_lang_NoClassDefFoundError(),
5364       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
5365       _class_name-&gt;as_C_string());
5366     return;
5367   }
5368 
5369   if (is_inline_type &amp;&amp; !EnableValhalla) {
5370     ResourceMark rm(THREAD);
5371     Exceptions::fthrow(
5372       THREAD_AND_LOCATION,
5373       vmSymbols::java_lang_ClassFormatError(),
5374       &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,
5375       _class_name-&gt;as_C_string()
5376     );
5377   }
5378 
5379   if (!_need_verify) { return; }
5380 
5381   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
5382   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
5383   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
5384   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
5385   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
5386   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
5387   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5388   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5389 
5390   if ((is_abstract &amp;&amp; is_final) ||
5391       (is_interface &amp;&amp; !is_abstract) ||
5392       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
5393       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||
5394       (is_inline_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {
5395     ResourceMark rm(THREAD);
5396     const char* class_note = &quot;&quot;;
5397     if (is_inline_type)  class_note = &quot; (an inline class)&quot;;
5398     Exceptions::fthrow(
5399       THREAD_AND_LOCATION,
5400       vmSymbols::java_lang_ClassFormatError(),
5401       &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,
5402       _class_name-&gt;as_C_string(), class_note, flags
5403     );
5404     return;
5405   }
5406 }
5407 
5408 static bool has_illegal_visibility(jint flags) {
5409   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5410   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5411   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5412 
5413   return ((is_public &amp;&amp; is_protected) ||
5414           (is_public &amp;&amp; is_private) ||
5415           (is_protected &amp;&amp; is_private));
5416 }
5417 
5418 // A legal major_version.minor_version must be one of the following:
5419 //
5420 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
5421 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
5422 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
5423 //
5424 static void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){
5425   ResourceMark rm(THREAD);
5426   const u2 max_version = JVM_CLASSFILE_MAJOR_VERSION;
5427   if (major &lt; JAVA_MIN_SUPPORTED_VERSION) {
5428     Exceptions::fthrow(
5429       THREAD_AND_LOCATION,
5430       vmSymbols::java_lang_UnsupportedClassVersionError(),
5431       &quot;%s (class file version %u.%u) was compiled with an invalid major version&quot;,
5432       class_name-&gt;as_C_string(), major, minor);
5433     return;
5434   }
5435 
5436   if (major &gt; max_version) {
5437     Exceptions::fthrow(
5438       THREAD_AND_LOCATION,
5439       vmSymbols::java_lang_UnsupportedClassVersionError(),
5440       &quot;%s has been compiled by a more recent version of the Java Runtime (class file version %u.%u), &quot;
5441       &quot;this version of the Java Runtime only recognizes class file versions up to %u.0&quot;,
5442       class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION);
5443     return;
5444   }
5445 
5446   if (major &lt; JAVA_12_VERSION || minor == 0) {
5447     return;
5448   }
5449 
5450   if (minor == JAVA_PREVIEW_MINOR_VERSION) {
5451     if (major != max_version) {
5452       Exceptions::fthrow(
5453         THREAD_AND_LOCATION,
5454         vmSymbols::java_lang_UnsupportedClassVersionError(),
5455         &quot;%s (class file version %u.%u) was compiled with preview features that are unsupported. &quot;
5456         &quot;This version of the Java Runtime only recognizes preview features for class file version %u.%u&quot;,
5457         class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION, JAVA_PREVIEW_MINOR_VERSION);
5458       return;
5459     }
5460 
5461     if (!Arguments::enable_preview()) {
5462       Exceptions::fthrow(
5463         THREAD_AND_LOCATION,
5464         vmSymbols::java_lang_UnsupportedClassVersionError(),
5465         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5466         class_name-&gt;as_C_string(), major, minor);
5467       return;
5468     }
5469 
5470   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5471     Exceptions::fthrow(
5472         THREAD_AND_LOCATION,
5473         vmSymbols::java_lang_UnsupportedClassVersionError(),
5474         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5475         class_name-&gt;as_C_string(), major, minor);
5476   }
5477 }
5478 
5479 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5480                                                    bool is_interface,
5481                                                    bool is_inline_type,
5482                                                    TRAPS) const {
5483   if (!_need_verify) { return; }
5484 
5485   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5486   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5487   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5488   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5489   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5490   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5491   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5492   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5493   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5494 
5495   bool is_illegal = false;
5496 
5497   if (is_interface) {
5498     if (!is_public || !is_static || !is_final || is_private ||
5499         is_protected || is_volatile || is_transient ||
5500         (major_gte_1_5 &amp;&amp; is_enum)) {
5501       is_illegal = true;
5502     }
5503   } else { // not interface
5504     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5505       is_illegal = true;
5506     } else {
5507       if (is_inline_type &amp;&amp; !is_static &amp;&amp; !is_final) {
5508         is_illegal = true;
5509       }
5510     }
5511   }
5512 
5513   if (is_illegal) {
5514     ResourceMark rm(THREAD);
5515     Exceptions::fthrow(
5516       THREAD_AND_LOCATION,
5517       vmSymbols::java_lang_ClassFormatError(),
5518       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5519       _class_name-&gt;as_C_string(), flags);
5520     return;
5521   }
5522 }
5523 
5524 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5525                                                     bool is_interface,
5526                                                     bool is_inline_type,
5527                                                     const Symbol* name,
5528                                                     TRAPS) const {
5529   if (!_need_verify) { return; }
5530 
5531   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5532   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5533   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5534   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5535   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5536   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5537   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5538   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5539   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5540   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5541   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5542   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5543   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5544 
5545   bool is_illegal = false;
5546 
5547   const char* class_note = &quot;&quot;;
5548 
5549   if (is_interface) {
5550     if (major_gte_8) {
5551       // Class file version is JAVA_8_VERSION or later Methods of
5552       // interfaces may set any of the flags except ACC_PROTECTED,
5553       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5554       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5555       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5556           (is_native || is_protected || is_final || is_synchronized) ||
5557           // If a specific method of a class or interface has its
5558           // ACC_ABSTRACT flag set, it must not have any of its
5559           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5560           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5561           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5562           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5563           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5564         is_illegal = true;
5565       }
5566     } else if (major_gte_1_5) {
5567       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5568       if (!is_public || is_private || is_protected || is_static || is_final ||
5569           is_synchronized || is_native || !is_abstract || is_strict) {
5570         is_illegal = true;
5571       }
5572     } else {
5573       // Class file version is pre-JAVA_1_5_VERSION
5574       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5575         is_illegal = true;
5576       }
5577     }
5578   } else { // not interface
5579     if (has_illegal_visibility(flags)) {
5580       is_illegal = true;
5581     } else {
5582       if (is_initializer) {
5583         if (is_final || is_synchronized || is_native ||
5584             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5585           is_illegal = true;
5586         }
5587         if (!is_static &amp;&amp; !is_inline_type) {
5588           // OK, an object constructor in a regular class
5589         } else if (is_static &amp;&amp; is_inline_type) {
5590           // OK, a static init factory in an inline class
5591         } else {
5592           // but no other combinations are allowed
5593           is_illegal = true;
5594           class_note = (is_inline_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);
5595         }
5596       } else { // not initializer
5597         if (is_inline_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {
5598           is_illegal = true;
5599           class_note = &quot; (an inline class)&quot;;
5600         } else {
5601           if (is_abstract) {
5602             if ((is_final || is_native || is_private || is_static ||
5603                 (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {
5604               is_illegal = true;
5605             }
5606           }
5607         }
5608       }
5609     }
5610   }
5611 
5612   if (is_illegal) {
5613     ResourceMark rm(THREAD);
5614     Exceptions::fthrow(
5615       THREAD_AND_LOCATION,
5616       vmSymbols::java_lang_ClassFormatError(),
5617       &quot;Method %s in class %s%s has illegal modifiers: 0x%X&quot;,
5618       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, flags);
5619     return;
5620   }
5621 }
5622 
5623 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5624                                         int length,
5625                                         TRAPS) const {
5626   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5627   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5628     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5629   }
5630 }
5631 
5632 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5633 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5634 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5635 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5636 // method.  Because these names have been checked as special cases before
5637 // calling this method in verify_legal_method_name.
5638 //
5639 // This method is also called from the modular system APIs in modules.cpp
5640 // to verify the validity of module and package names.
5641 bool ClassFileParser::verify_unqualified_name(const char* name,
5642                                               unsigned int length,
5643                                               int type) {
5644   if (length == 0) return false;  // Must have at least one char.
5645   for (const char* p = name; p != name + length; p++) {
5646     switch(*p) {
5647       case JVM_SIGNATURE_DOT:
5648       case JVM_SIGNATURE_ENDCLASS:
5649       case JVM_SIGNATURE_ARRAY:
5650         // do not permit &#39;.&#39;, &#39;;&#39;, or &#39;[&#39;
5651         return false;
5652       case JVM_SIGNATURE_SLASH:
5653         // check for &#39;//&#39; or leading or trailing &#39;/&#39; which are not legal
5654         // unqualified name must not be empty
5655         if (type == ClassFileParser::LegalClass) {
5656           if (p == name || p+1 &gt;= name+length ||
5657               *(p+1) == JVM_SIGNATURE_SLASH) {
5658             return false;
5659           }
5660         } else {
5661           return false;   // do not permit &#39;/&#39; unless it&#39;s class name
5662         }
5663         break;
5664       case JVM_SIGNATURE_SPECIAL:
5665       case JVM_SIGNATURE_ENDSPECIAL:
5666         // do not permit &#39;&lt;&#39; or &#39;&gt;&#39; in method names
5667         if (type == ClassFileParser::LegalMethod) {
5668           return false;
5669         }
5670     }
5671   }
5672   return true;
5673 }
5674 
5675 // Take pointer to a UTF8 byte string (not NUL-terminated).
5676 // Skip over the longest part of the string that could
5677 // be taken as a fieldname. Allow &#39;/&#39; if slash_ok is true.
5678 // Return a pointer to just past the fieldname.
5679 // Return NULL if no fieldname at all was found, or in the case of slash_ok
5680 // being true, we saw consecutive slashes (meaning we were looking for a
5681 // qualified path but found something that was badly-formed).
5682 static const char* skip_over_field_name(const char* const name,
5683                                         bool slash_ok,
5684                                         unsigned int length) {
5685   const char* p;
5686   jboolean last_is_slash = false;
5687   jboolean not_first_ch = false;
5688 
5689   for (p = name; p != name + length; not_first_ch = true) {
5690     const char* old_p = p;
5691     jchar ch = *p;
5692     if (ch &lt; 128) {
5693       p++;
5694       // quick check for ascii
5695       if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) ||
5696         (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
5697         (ch == &#39;_&#39; || ch == &#39;$&#39;) ||
5698         (not_first_ch &amp;&amp; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
5699         last_is_slash = false;
5700         continue;
5701       }
5702       if (slash_ok &amp;&amp; ch == JVM_SIGNATURE_SLASH) {
5703         if (last_is_slash) {
5704           return NULL;  // Don&#39;t permit consecutive slashes
5705         }
5706         last_is_slash = true;
5707         continue;
5708       }
5709     }
5710     else {
5711       jint unicode_ch;
5712       char* tmp_p = UTF8::next_character(p, &amp;unicode_ch);
5713       p = tmp_p;
5714       last_is_slash = false;
5715       // Check if ch is Java identifier start or is Java identifier part
5716       // 4672820: call java.lang.Character methods directly without generating separate tables.
5717       EXCEPTION_MARK;
5718       // return value
5719       JavaValue result(T_BOOLEAN);
5720       // Set up the arguments to isJavaIdentifierStart or isJavaIdentifierPart
5721       JavaCallArguments args;
5722       args.push_int(unicode_ch);
5723 
5724       if (not_first_ch) {
5725         // public static boolean isJavaIdentifierPart(char ch);
5726         JavaCalls::call_static(&amp;result,
5727           SystemDictionary::Character_klass(),
5728           vmSymbols::isJavaIdentifierPart_name(),
5729           vmSymbols::int_bool_signature(),
5730           &amp;args,
5731           THREAD);
5732       } else {
5733         // public static boolean isJavaIdentifierStart(char ch);
5734         JavaCalls::call_static(&amp;result,
5735           SystemDictionary::Character_klass(),
5736           vmSymbols::isJavaIdentifierStart_name(),
5737           vmSymbols::int_bool_signature(),
5738           &amp;args,
5739           THREAD);
5740       }
5741       if (HAS_PENDING_EXCEPTION) {
5742         CLEAR_PENDING_EXCEPTION;
5743         return NULL;
5744       }
5745       if(result.get_jboolean()) {
5746         continue;
5747       }
5748     }
5749     return (not_first_ch) ? old_p : NULL;
5750   }
5751   return (not_first_ch) ? p : NULL;
5752 }
5753 
5754 // Take pointer to a UTF8 byte string (not NUL-terminated).
5755 // Skip over the longest part of the string that could
5756 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5757 // Return a pointer to just past the signature.
5758 // Return NULL if no legal signature is found.
5759 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5760                                                        bool void_ok,
5761                                                        unsigned int length,
5762                                                        TRAPS) const {
5763   unsigned int array_dim = 0;
5764   while (length &gt; 0) {
5765     switch (signature[0]) {
5766     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5767     case JVM_SIGNATURE_BOOLEAN:
5768     case JVM_SIGNATURE_BYTE:
5769     case JVM_SIGNATURE_CHAR:
5770     case JVM_SIGNATURE_SHORT:
5771     case JVM_SIGNATURE_INT:
5772     case JVM_SIGNATURE_FLOAT:
5773     case JVM_SIGNATURE_LONG:
5774     case JVM_SIGNATURE_DOUBLE:
5775       return signature + 1;
5776     case JVM_SIGNATURE_INLINE_TYPE:
5777       // Can&#39;t enable this check until JDK upgrades the bytecode generators
5778       // if (_major_version &lt; CONSTANT_CLASS_DESCRIPTORS ) {
5779       //   classfile_parse_error(&quot;Class name contains illegal Q-signature &quot;
5780       //                                    &quot;in descriptor in class file %s&quot;,
5781       //                                    CHECK_0);
5782       // }
5783       // fall through
5784     case JVM_SIGNATURE_CLASS:
5785     {
5786       if (_major_version &lt; JAVA_1_5_VERSION) {
5787         // Skip over the class name if one is there
5788         const char* const p = skip_over_field_name(signature + 1, true, --length);
5789 
5790         // The next character better be a semicolon
5791         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5792           return p + 1;
5793         }
5794       }
5795       else {
5796         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;
5797         signature++;
5798         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5799         // Format check signature
5800         if (c != NULL) {
5801           int newlen = c - (char*) signature;
5802           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5803           if (!legal) {
5804             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5805                                   &quot;in descriptor in class file %s&quot;,
5806                                   CHECK_NULL);
5807             return NULL;
5808           }
5809           return signature + newlen + 1;
5810         }
5811       }
5812       return NULL;
5813     }
5814     case JVM_SIGNATURE_ARRAY:
5815       array_dim++;
5816       if (array_dim &gt; 255) {
5817         // 4277370: array descriptor is valid only if it represents 255 or fewer dimensions.
5818         classfile_parse_error(&quot;Array type descriptor has more than 255 dimensions in class file %s&quot;, CHECK_NULL);
5819       }
5820       // The rest of what&#39;s there better be a legal signature
5821       signature++;
5822       length--;
5823       void_ok = false;
5824       break;
5825     default:
5826       return NULL;
5827     }
5828   }
5829   return NULL;
5830 }
5831 
5832 // Checks if name is a legal class name.
5833 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5834   if (!_need_verify || _relax_verify) { return; }
5835 
5836   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5837   char* bytes = (char*)name-&gt;bytes();
5838   unsigned int length = name-&gt;utf8_length();
5839   bool legal = false;
5840 
5841   if (length &gt; 0) {
5842     const char* p;
5843     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5844       p = skip_over_field_signature(bytes, false, length, CHECK);
5845       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5846     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5847       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5848         p = skip_over_field_name(bytes, true, length);
5849         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5850       }
5851     } else if (_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS &amp;&amp; bytes[length - 1] == &#39;;&#39; ) {
5852       // Support for L...; and Q...; descriptors
5853       legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);
5854     } else {
5855       // 4900761: relax the constraints based on JSR202 spec
5856       // Class names may be drawn from the entire Unicode character set.
5857       // Identifiers between &#39;/&#39; must be unqualified names.
5858       // The utf8 string has been verified when parsing cpool entries.
5859       legal = verify_unqualified_name(bytes, length, LegalClass);
5860     }
5861   }
5862   if (!legal) {
5863     ResourceMark rm(THREAD);
5864     assert(_class_name != NULL, &quot;invariant&quot;);
5865     Exceptions::fthrow(
5866       THREAD_AND_LOCATION,
5867       vmSymbols::java_lang_ClassFormatError(),
5868       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5869       _class_name-&gt;as_C_string()
5870     );
5871     return;
5872   }
5873 }
5874 
5875 // Checks if name is a legal field name.
5876 void ClassFileParser::verify_legal_field_name(const Symbol* name, TRAPS) const {
5877   if (!_need_verify || _relax_verify) { return; }
5878 
5879   char* bytes = (char*)name-&gt;bytes();
5880   unsigned int length = name-&gt;utf8_length();
5881   bool legal = false;
5882 
5883   if (length &gt; 0) {
5884     if (_major_version &lt; JAVA_1_5_VERSION) {
5885       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5886         const char* p = skip_over_field_name(bytes, false, length);
5887         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5888       }
5889     } else {
5890       // 4881221: relax the constraints based on JSR202 spec
5891       legal = verify_unqualified_name(bytes, length, LegalField);
5892     }
5893   }
5894 
5895   if (!legal) {
5896     ResourceMark rm(THREAD);
5897     assert(_class_name != NULL, &quot;invariant&quot;);
5898     Exceptions::fthrow(
5899       THREAD_AND_LOCATION,
5900       vmSymbols::java_lang_ClassFormatError(),
5901       &quot;Illegal field name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5902       _class_name-&gt;as_C_string()
5903     );
5904     return;
5905   }
5906 }
5907 
5908 // Checks if name is a legal method name.
5909 void ClassFileParser::verify_legal_method_name(const Symbol* name, TRAPS) const {
5910   if (!_need_verify || _relax_verify) { return; }
5911 
5912   assert(name != NULL, &quot;method name is null&quot;);
5913   char* bytes = (char*)name-&gt;bytes();
5914   unsigned int length = name-&gt;utf8_length();
5915   bool legal = false;
5916 
5917   if (length &gt; 0) {
5918     if (bytes[0] == JVM_SIGNATURE_SPECIAL) {
5919       if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {
5920         legal = true;
5921       }
5922     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5923       const char* p;
5924       p = skip_over_field_name(bytes, false, length);
5925       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5926     } else {
5927       // 4881221: relax the constraints based on JSR202 spec
5928       legal = verify_unqualified_name(bytes, length, LegalMethod);
5929     }
5930   }
5931 
5932   if (!legal) {
5933     ResourceMark rm(THREAD);
5934     assert(_class_name != NULL, &quot;invariant&quot;);
5935     Exceptions::fthrow(
5936       THREAD_AND_LOCATION,
5937       vmSymbols::java_lang_ClassFormatError(),
5938       &quot;Illegal method name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5939       _class_name-&gt;as_C_string()
5940     );
5941     return;
5942   }
5943 }
5944 
5945 
5946 // Checks if signature is a legal field signature.
5947 void ClassFileParser::verify_legal_field_signature(const Symbol* name,
5948                                                    const Symbol* signature,
5949                                                    TRAPS) const {
5950   if (!_need_verify) { return; }
5951 
5952   const char* const bytes = (const char* const)signature-&gt;bytes();
5953   const unsigned int length = signature-&gt;utf8_length();
5954   const char* const p = skip_over_field_signature(bytes, false, length, CHECK);
5955 
5956   if (p == NULL || (p - bytes) != (int)length) {
5957     throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
5958   }
5959 }
5960 
5961 // Checks if signature is a legal method signature.
5962 // Returns number of parameters
5963 int ClassFileParser::verify_legal_method_signature(const Symbol* name,
5964                                                    const Symbol* signature,
5965                                                    TRAPS) const {
5966   if (!_need_verify) {
5967     // make sure caller&#39;s args_size will be less than 0 even for non-static
5968     // method so it will be recomputed in compute_size_of_parameters().
5969     return -2;
5970   }
5971 
5972   // Class initializers cannot have args for class format version &gt;= 51.
5973   if (name == vmSymbols::class_initializer_name() &amp;&amp;
5974       signature != vmSymbols::void_method_signature() &amp;&amp;
5975       _major_version &gt;= JAVA_7_VERSION) {
5976     throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5977     return 0;
5978   }
5979 
5980   unsigned int args_size = 0;
5981   const char* p = (const char*)signature-&gt;bytes();
5982   unsigned int length = signature-&gt;utf8_length();
5983   const char* nextp;
5984 
5985   // The first character must be a &#39;(&#39;
5986   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5987     length--;
5988     // Skip over legal field signatures
5989     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5990     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5991       args_size++;
5992       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5993         args_size++;
5994       }
5995       length -= nextp - p;
5996       p = nextp;
5997       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5998     }
5999     // The first non-signature thing better be a &#39;)&#39;
6000     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
6001       length--;
6002       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
6003         // All constructor methods must return void
6004         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
6005           return args_size;
6006         }
6007         // All static init methods must return the current class
6008         if ((length &gt;= 3) &amp;&amp; (p[length-1] == JVM_SIGNATURE_ENDCLASS)
6009             &amp;&amp; name == vmSymbols::object_initializer_name()) {
6010           nextp = skip_over_field_signature(p, true, length, CHECK_0);
6011           if (nextp &amp;&amp; ((int)length == (nextp - p))) {
6012             // The actual class will be checked against current class
6013             // when the method is defined (see parse_method).
6014             // A reference to a static init with a bad return type
6015             // will load and verify OK, but will fail to link.
6016             return args_size;
6017           }
6018         }
6019         // The distinction between static factory methods and
6020         // constructors depends on the JVM_ACC_STATIC modifier.
6021         // This distinction must be reflected in a void or non-void
6022         // return. For declared methods, the check is in parse_method.
6023       } else {
6024         // Now we better just have a return value
6025         nextp = skip_over_field_signature(p, true, length, CHECK_0);
6026         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
6027           return args_size;
6028         }
6029       }
6030     }
6031   }
6032   // Report error
6033   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
6034   return 0;
6035 }
6036 
6037 int ClassFileParser::static_field_size() const {
6038   assert(_field_info != NULL, &quot;invariant&quot;);
6039   return _field_info-&gt;_static_field_size;
6040 }
6041 
6042 int ClassFileParser::total_oop_map_count() const {
6043   assert(_field_info != NULL, &quot;invariant&quot;);
6044   return _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count;
6045 }
6046 
6047 jint ClassFileParser::layout_size() const {
6048   assert(_field_info != NULL, &quot;invariant&quot;);
6049   return _field_info-&gt;_instance_size;
6050 }
6051 
6052 static void check_methods_for_intrinsics(const InstanceKlass* ik,
6053                                          const Array&lt;Method*&gt;* methods) {
6054   assert(ik != NULL, &quot;invariant&quot;);
6055   assert(methods != NULL, &quot;invariant&quot;);
6056 
6057   // Set up Method*::intrinsic_id as soon as we know the names of methods.
6058   // (We used to do this lazily, but now we query it in Rewriter,
6059   // which is eagerly done for every method, so we might as well do it now,
6060   // when everything is fresh in memory.)
6061   const vmSymbols::SID klass_id = Method::klass_id_for_intrinsics(ik);
6062 
6063   if (klass_id != vmSymbols::NO_SID) {
6064     for (int j = 0; j &lt; methods-&gt;length(); ++j) {
6065       Method* method = methods-&gt;at(j);
6066       method-&gt;init_intrinsic_id();
6067 
6068       if (CheckIntrinsics) {
6069         // Check if an intrinsic is defined for method &#39;method&#39;,
6070         // but the method is not annotated with @HotSpotIntrinsicCandidate.
6071         if (method-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
6072             !method-&gt;intrinsic_candidate()) {
6073               tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
6074               &quot;but the method is not annotated with @HotSpotIntrinsicCandidate.%s&quot;,
6075               method-&gt;name_and_sig_as_C_string(),
6076               NOT_DEBUG(&quot; Method will not be inlined.&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
6077             );
6078           tty-&gt;cr();
6079           DEBUG_ONLY(vm_exit(1));
6080         }
6081         // Check is the method &#39;method&#39; is annotated with @HotSpotIntrinsicCandidate,
6082         // but there is no intrinsic available for it.
6083         if (method-&gt;intrinsic_candidate() &amp;&amp;
6084           method-&gt;intrinsic_id() == vmIntrinsics::_none) {
6085             tty-&gt;print(&quot;Method [%s] is annotated with @HotSpotIntrinsicCandidate, &quot;
6086               &quot;but no compiler intrinsic is defined for the method.%s&quot;,
6087               method-&gt;name_and_sig_as_C_string(),
6088               NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
6089             );
6090           tty-&gt;cr();
6091           DEBUG_ONLY(vm_exit(1));
6092         }
6093       }
6094     } // end for
6095 
6096 #ifdef ASSERT
6097     if (CheckIntrinsics) {
6098       // Check for orphan methods in the current class. A method m
6099       // of a class C is orphan if an intrinsic is defined for method m,
6100       // but class C does not declare m.
6101       // The check is potentially expensive, therefore it is available
6102       // only in debug builds.
6103 
6104       for (int id = vmIntrinsics::FIRST_ID; id &lt; (int)vmIntrinsics::ID_LIMIT; ++id) {
6105         if (vmIntrinsics::_compiledLambdaForm == id) {
6106           // The _compiledLamdbdaForm intrinsic is a special marker for bytecode
6107           // generated for the JVM from a LambdaForm and therefore no method
6108           // is defined for it.
6109           continue;
6110         }
6111 
6112         if (vmIntrinsics::class_for(vmIntrinsics::ID_from(id)) == klass_id) {
6113           // Check if the current class contains a method with the same
6114           // name, flags, signature.
6115           bool match = false;
6116           for (int j = 0; j &lt; methods-&gt;length(); ++j) {
6117             const Method* method = methods-&gt;at(j);
6118             if (method-&gt;intrinsic_id() == id) {
6119               match = true;
6120               break;
6121             }
6122           }
6123 
6124           if (!match) {
6125             char buf[1000];
6126             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
6127                        &quot;but the method is not available in class [%s].%s&quot;,
6128                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
6129                                                              buf, sizeof(buf)),
6130                         ik-&gt;name()-&gt;as_C_string(),
6131                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
6132             );
6133             tty-&gt;cr();
6134             DEBUG_ONLY(vm_exit(1));
6135           }
6136         }
6137       } // end for
6138     } // CheckIntrinsics
6139 #endif // ASSERT
6140   }
6141 }
6142 
6143 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook,
6144                                                       const ClassInstanceInfo&amp; cl_inst_info,
6145                                                       TRAPS) {
6146   if (_klass != NULL) {
6147     return _klass;
6148   }
6149 
6150   InstanceKlass* const ik =
6151     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
6152 
6153   if (is_hidden()) {
6154     mangle_hidden_class_name(ik);
6155   }
6156 
6157   fill_instance_klass(ik, changed_by_loadhook, cl_inst_info, CHECK_NULL);
6158 
6159   assert(_klass == ik, &quot;invariant&quot;);
6160 
6161 
6162   if (ik-&gt;should_store_fingerprint()) {
6163     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
6164   }
6165 
6166   ik-&gt;set_has_passed_fingerprint_check(false);
6167   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
6168     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
6169     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
6170     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
6171       // This class matches with a class saved in an AOT library
6172       ik-&gt;set_has_passed_fingerprint_check(true);
6173     } else {
6174       ResourceMark rm;
6175       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
6176                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6177     }
6178   }
6179 
6180   if (ik-&gt;is_inline_klass()) {
6181     InlineKlass* vk = InlineKlass::cast(ik);
6182     oop val = ik-&gt;allocate_instance(CHECK_NULL);
6183     vk-&gt;set_default_value(val);
6184   }
6185 
6186   return ik;
6187 }
6188 
6189 // Return true if the specified class is not a valid super class for an inline type.
6190 // A valid super class for an inline type is abstract, has no instance fields,
6191 // does not implement interface java.lang.IdentityObject (checked elsewhere), has
6192 // an empty body-less no-arg constructor, and no synchronized instance methods.
6193 // This function doesn&#39;t check if the class&#39;s super types are invalid.  Those checks
6194 // are done elsewhere.  The final determination of whether or not a class is an
6195 // invalid super type for an inline class is done in fill_instance_klass().
6196 bool ClassFileParser::is_invalid_super_for_inline_type() {
6197   if (class_name() == vmSymbols::java_lang_IdentityObject()) {
6198     return true;
6199   }
6200   if (is_interface() || class_name() == vmSymbols::java_lang_Object()) {
6201     return false;
6202   }
6203   if (!access_flags().is_abstract() || _has_nonstatic_fields) {
6204     return true;
6205   } else {
6206     // Look at each method
6207     for (int x = 0; x &lt; _methods-&gt;length(); x++) {
6208       const Method* const method = _methods-&gt;at(x);
6209       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {
6210         return true;
6211 
6212       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {
6213         if (method-&gt;signature() != vmSymbols::void_method_signature() ||
6214             !method-&gt;is_vanilla_constructor()) {
6215           return true;
6216         }
6217       }
6218     }
6219   }
6220   return false;
6221 }
6222 
6223 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
6224                                           bool changed_by_loadhook,
6225                                           const ClassInstanceInfo&amp; cl_inst_info,
6226                                           TRAPS) {
6227   assert(ik != NULL, &quot;invariant&quot;);
6228 
6229   // Set name and CLD before adding to CLD
6230   ik-&gt;set_class_loader_data(_loader_data);
6231   ik-&gt;set_name(_class_name);
6232 
6233   // Add all classes to our internal class loader list here,
6234   // including classes in the bootstrap (NULL) class loader.
6235   const bool publicize = !is_internal();
6236 
6237   _loader_data-&gt;add_class(ik, publicize);
6238 
6239   set_klass_to_deallocate(ik);
6240 
6241   assert(_field_info != NULL, &quot;invariant&quot;);
6242   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6243   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6244          &quot;sanity&quot;);
6245 
6246   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6247   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6248 
6249   // Fill in information already parsed
6250   ik-&gt;set_should_verify_class(_need_verify);
6251 
6252   // Not yet: supers are done below to support the new subtype-checking fields
6253   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6254   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
6255   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_inline_klass()) {
6256     ik-&gt;set_is_naturally_atomic();
6257   }
6258   if (_is_empty_inline_type) {
6259     ik-&gt;set_is_empty_inline_type();
6260   }
6261 
6262   if (this-&gt;_invalid_inline_super) {
6263     ik-&gt;set_invalid_inline_super();
6264   }
6265 
6266   if (_has_injected_identityObject) {
6267     ik-&gt;set_has_injected_identityObject();
6268   }
6269 
6270   assert(_fac != NULL, &quot;invariant&quot;);
6271   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_INLINE]);
6272 
6273   // this transfers ownership of a lot of arrays from
6274   // the parser onto the InstanceKlass*
6275   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6276 
6277   // can only set dynamic nest-host after static nest information is set
6278   if (cl_inst_info.dynamic_nest_host() != NULL) {
6279     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
6280   }
6281 
6282   // note that is not safe to use the fields in the parser from this point on
6283   assert(NULL == _cp, &quot;invariant&quot;);
6284   assert(NULL == _fields, &quot;invariant&quot;);
6285   assert(NULL == _methods, &quot;invariant&quot;);
6286   assert(NULL == _inner_classes, &quot;invariant&quot;);
6287   assert(NULL == _nest_members, &quot;invariant&quot;);
6288   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6289   assert(NULL == _record_components, &quot;invariant&quot;);
6290   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);
6291 
6292   if (_has_final_method) {
6293     ik-&gt;set_has_final_method();
6294   }
6295 
6296   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
6297   // The InstanceKlass::_methods_jmethod_ids cache
6298   // is managed on the assumption that the initial cache
6299   // size is equal to the number of methods in the class. If
6300   // that changes, then InstanceKlass::idnum_can_increment()
6301   // has to be changed accordingly.
6302   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6303 
6304   ik-&gt;set_this_class_index(_this_class_index);
6305 
6306   if (_is_hidden || is_unsafe_anonymous()) {
6307     // _this_class_index is a CONSTANT_Class entry that refers to this
6308     // hidden or anonymous class itself. If this class needs to refer to its own
6309     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
6310     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
6311     // not stored in SystemDictionary), _this_class_index cannot be resolved
6312     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
6313     // Therefore, we must eagerly resolve _this_class_index now.
6314     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
6315   }
6316 
6317   ik-&gt;set_minor_version(_minor_version);
6318   ik-&gt;set_major_version(_major_version);
6319   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
6320   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
6321   if (_is_declared_atomic) {
6322     ik-&gt;set_is_declared_atomic();
6323   }
6324 
6325   if (_unsafe_anonymous_host != NULL) {
6326     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
6327     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
6328   }
6329   if (_is_hidden) {
6330     ik-&gt;set_is_hidden();
6331   }
6332 
6333   // Set PackageEntry for this_klass
6334   oop cl = ik-&gt;class_loader();
6335   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
6336   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
6337   ik-&gt;set_package(cld, NULL, CHECK);
6338 
6339   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
6340   assert(methods != NULL, &quot;invariant&quot;);
6341   const int methods_len = methods-&gt;length();
6342 
6343   check_methods_for_intrinsics(ik, methods);
6344 
6345   // Fill in field values obtained by parse_classfile_attributes
6346   if (_parsed_annotations-&gt;has_any_annotations()) {
6347     _parsed_annotations-&gt;apply_to(ik);
6348   }
6349 
6350   apply_parsed_class_attributes(ik);
6351 
6352   // Miranda methods
6353   if ((_num_miranda_methods &gt; 0) ||
6354       // if this class introduced new miranda methods or
6355       (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_miranda_methods())
6356         // super class exists and this class inherited miranda methods
6357      ) {
6358        ik-&gt;set_has_miranda_methods(); // then set a flag
6359   }
6360 
6361   // Fill in information needed to compute superclasses.
6362   ik-&gt;initialize_supers(const_cast&lt;InstanceKlass*&gt;(_super_klass), _transitive_interfaces, CHECK);
6363   ik-&gt;set_transitive_interfaces(_transitive_interfaces);
6364   ik-&gt;set_local_interfaces(_local_interfaces);
6365   _transitive_interfaces = NULL;
6366   _local_interfaces = NULL;
6367 
6368   // Initialize itable offset tables
6369   klassItable::setup_itable_offset_table(ik);
6370 
6371   // Compute transitive closure of interfaces this class implements
6372   // Do final class setup
6373   OopMapBlocksBuilder* oop_map_blocks = _field_info-&gt;oop_map_blocks;
6374   if (oop_map_blocks-&gt;_nonstatic_oop_map_count &gt; 0) {
6375     oop_map_blocks-&gt;copy(ik-&gt;start_of_nonstatic_oop_maps());
6376   }
6377 
6378   if (_has_contended_fields || _parsed_annotations-&gt;is_contended() ||
6379       ( _super_klass != NULL &amp;&amp; _super_klass-&gt;has_contended_annotations())) {
6380     ik-&gt;set_has_contended_annotations(true);
6381   }
6382 
6383   // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
6384   set_precomputed_flags(ik);
6385 
6386   // check if this class can access its super class
6387   check_super_class_access(ik, CHECK);
6388 
6389   // check if this class can access its superinterfaces
6390   check_super_interface_access(ik, CHECK);
6391 
6392   // check if this class overrides any final method
6393   check_final_method_override(ik, CHECK);
6394 
6395   // reject static interface methods prior to Java 8
6396   if (ik-&gt;is_interface() &amp;&amp; _major_version &lt; JAVA_8_VERSION) {
6397     check_illegal_static_method(ik, CHECK);
6398   }
6399 
6400   // Obtain this_klass&#39; module entry
6401   ModuleEntry* module_entry = ik-&gt;module();
6402   assert(module_entry != NULL, &quot;module_entry should always be set&quot;);
6403 
6404   // Obtain java.lang.Module
6405   Handle module_handle(THREAD, module_entry-&gt;module());
6406 
6407   // Allocate mirror and initialize static fields
6408   // The create_mirror() call will also call compute_modifiers()
6409   java_lang_Class::create_mirror(ik,
6410                                  Handle(THREAD, _loader_data-&gt;class_loader()),
6411                                  module_handle,
6412                                  _protection_domain,
6413                                  cl_inst_info.class_data(),
6414                                  CHECK);
6415 
6416   assert(_all_mirandas != NULL, &quot;invariant&quot;);
6417 
6418   // Generate any default methods - default methods are public interface methods
6419   // that have a default implementation.  This is new with Java 8.
6420   if (_has_nonstatic_concrete_methods) {
6421     DefaultMethods::generate_default_methods(ik,
6422                                              _all_mirandas,
6423                                              CHECK);
6424   }
6425 
6426   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6427   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6428       !module_entry-&gt;has_default_read_edges()) {
6429     if (!module_entry-&gt;set_has_default_read_edges()) {
6430       // We won a potential race
6431       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6432     }
6433   }
6434 
6435   int nfields = ik-&gt;java_fields_count();
6436   if (ik-&gt;is_inline_klass()) nfields++;
6437   for (int i = 0; i &lt; nfields; i++) {
6438     if (ik-&gt;field_is_inline_type(i) &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) == 0)) {
6439       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);
6440       // Inline classes for instance fields must have been pre-loaded
6441       // Inline classes for static fields might not have been loaded yet
6442       Klass* klass = SystemDictionary::find(klass_name,
6443           Handle(THREAD, ik-&gt;class_loader()),
6444           Handle(THREAD, ik-&gt;protection_domain()), CHECK);
6445       if (klass != NULL) {
6446         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);
6447         ik-&gt;set_inline_type_field_klass(i, klass);
6448       }
6449       klass_name-&gt;decrement_refcount();
6450     } else
6451       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)
6452         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {
6453       InlineKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));
6454     }
6455   }
6456 
6457   if (is_inline_type()) {
6458     InlineKlass* vk = InlineKlass::cast(ik);
6459     if (UseNewFieldLayout) {
6460       vk-&gt;set_alignment(_alignment);
6461       vk-&gt;set_first_field_offset(_first_field_offset);
6462       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);
6463     } else {
6464       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());
6465     }
6466     InlineKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);
6467   }
6468 
6469   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
6470 
6471   if (!is_internal()) {
6472     if (log_is_enabled(Info, class, load)) {
6473       ResourceMark rm;
6474       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
6475       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
6476     }
6477 
6478     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
6479         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
6480         log_is_enabled(Info, class, preview)) {
6481       ResourceMark rm;
6482       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
6483                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
6484     }
6485 
6486     if (log_is_enabled(Debug, class, resolve))  {
6487       ResourceMark rm;
6488       // print out the superclass.
6489       const char * from = ik-&gt;external_name();
6490       if (ik-&gt;java_super() != NULL) {
6491         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
6492                    from,
6493                    ik-&gt;java_super()-&gt;external_name());
6494       }
6495       // print out each of the interface classes referred to by this class.
6496       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
6497       if (local_interfaces != NULL) {
6498         const int length = local_interfaces-&gt;length();
6499         for (int i = 0; i &lt; length; i++) {
6500           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6501           const char * to = k-&gt;external_name();
6502           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6503         }
6504       }
6505     }
6506   }
6507 
6508   JFR_ONLY(INIT_ID(ik);)
6509 
6510   // If we reach here, all is well.
6511   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6512   // in order for it to not be destroyed in the ClassFileParser destructor.
6513   set_klass_to_deallocate(NULL);
6514 
6515   // it&#39;s official
6516   set_klass(ik);
6517 
6518   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {
6519     Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);
6520   }
6521 
6522   debug_only(ik-&gt;verify();)
6523 }
6524 
6525 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6526   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6527   _class_name-&gt;decrement_refcount();
6528 
6529   _class_name = new_class_name;
6530   // Increment the refcount of the new name.
6531   // Now the ClassFileParser owns this name and will decrement in
6532   // the destructor.
6533   _class_name-&gt;increment_refcount();
6534 }
6535 
6536 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6537 // package by prepending its host class&#39;s package name to its class name and setting
6538 // its _class_name field.
6539 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6540   ResourceMark rm(THREAD);
6541   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
6542          &quot;Unsafe anonymous class should not be in a package&quot;);
6543   TempNewSymbol host_pkg_name =
6544     ClassLoader::package_from_class_name(unsafe_anonymous_host-&gt;name());
6545 
6546   if (host_pkg_name != NULL) {
6547     int host_pkg_len = host_pkg_name-&gt;utf8_length();
6548     int class_name_len = _class_name-&gt;utf8_length();
6549     int symbol_len = host_pkg_len + 1 + class_name_len;
6550     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
6551     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%.*s/%.*s&quot;,
6552                          host_pkg_len, host_pkg_name-&gt;base(), class_name_len, _class_name-&gt;base());
6553     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
6554 
6555     // Decrement old _class_name to avoid leaking.
6556     _class_name-&gt;decrement_refcount();
6557 
6558     // Create a symbol and update the anonymous class name.
6559     // The new class name is created with a refcount of one. When installed into the InstanceKlass,
6560     // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
6561     // when the class is unloaded.
6562     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);
6563   }
6564 }
6565 
6566 // If the host class and the anonymous class are in the same package then do
6567 // nothing.  If the anonymous class is in the unnamed package then move it to its
6568 // host&#39;s package.  If the classes are in different packages then throw an IAE
6569 // exception.
6570 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
6571   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
6572 
6573   const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
6574                                                _class_name-&gt;utf8_length(), JVM_SIGNATURE_SLASH);
6575   if (anon_last_slash == NULL) {  // Unnamed package
6576     prepend_host_package_name(_unsafe_anonymous_host, CHECK);
6577   } else {
6578     if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
6579       ResourceMark rm(THREAD);
6580       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
6581         err_msg(&quot;Host class %s and anonymous class %s are in different packages&quot;,
6582         _unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), _class_name-&gt;as_C_string()));
6583     }
6584   }
6585 }
6586 
6587 static bool relax_format_check_for(ClassLoaderData* loader_data) {
6588   bool trusted = loader_data-&gt;is_boot_class_loader_data() ||
6589                  loader_data-&gt;is_platform_class_loader_data();
6590   bool need_verify =
6591     // verifyAll
6592     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
6593     // verifyRemote
6594     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
6595   return !need_verify;
6596 }
6597 
6598 ClassFileParser::ClassFileParser(ClassFileStream* stream,
6599                                  Symbol* name,
6600                                  ClassLoaderData* loader_data,
6601                                  const ClassLoadInfo* cl_info,
6602                                  Publicity pub_level,
6603                                  TRAPS) :
6604   _stream(stream),
6605   _class_name(NULL),
6606   _loader_data(loader_data),
6607   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
6608   _cp_patches(cl_info-&gt;cp_patches()),
6609   _is_hidden(cl_info-&gt;is_hidden()),
6610   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
6611   _num_patched_klasses(0),
6612   _max_num_patched_klasses(0),
6613   _orig_cp_size(0),
6614   _first_patched_klass_resolved_index(0),
6615   _super_klass(),
6616   _cp(NULL),
6617   _fields(NULL),
6618   _methods(NULL),
6619   _inner_classes(NULL),
6620   _nest_members(NULL),
6621   _nest_host(0),
6622   _permitted_subclasses(NULL),
6623   _record_components(NULL),
6624   _temp_local_interfaces(NULL),
6625   _local_interfaces(NULL),
6626   _transitive_interfaces(NULL),
6627   _combined_annotations(NULL),
6628   _class_annotations(NULL),
6629   _class_type_annotations(NULL),
6630   _fields_annotations(NULL),
6631   _fields_type_annotations(NULL),
6632   _klass(NULL),
6633   _klass_to_deallocate(NULL),
6634   _parsed_annotations(NULL),
6635   _fac(NULL),
6636   _field_info(NULL),
6637   _method_ordering(NULL),
6638   _all_mirandas(NULL),
6639   _vtable_size(0),
6640   _itable_size(0),
6641   _num_miranda_methods(0),
6642   _rt(REF_NONE),
6643   _protection_domain(cl_info-&gt;protection_domain()),
6644   _access_flags(),
6645   _pub_level(pub_level),
6646   _bad_constant_seen(0),
6647   _synthetic_flag(false),
6648   _sde_length(false),
6649   _sde_buffer(NULL),
6650   _sourcefile_index(0),
6651   _generic_signature_index(0),
6652   _major_version(0),
6653   _minor_version(0),
6654   _this_class_index(0),
6655   _super_class_index(0),
6656   _itfs_len(0),
6657   _java_fields_count(0),
6658   _need_verify(false),
6659   _relax_verify(false),
6660   _has_nonstatic_concrete_methods(false),
6661   _declares_nonstatic_concrete_methods(false),
6662   _has_final_method(false),
6663   _has_contended_fields(false),
6664   _has_inline_type_fields(false),
6665   _has_nonstatic_fields(false),
6666   _is_empty_inline_type(false),
6667   _is_naturally_atomic(false),
6668   _is_declared_atomic(false),
6669   _invalid_inline_super(false),
6670   _invalid_identity_super(false),
6671   _implements_identityObject(false),
6672   _has_injected_identityObject(false),
6673   _has_finalizer(false),
6674   _has_empty_finalizer(false),
6675   _has_vanilla_constructor(false),
6676   _max_bootstrap_specifier_index(-1) {
6677 
6678   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6679   _class_name-&gt;increment_refcount();
6680 
6681   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6682   assert(_loader_data != NULL, &quot;invariant&quot;);
6683   assert(stream != NULL, &quot;invariant&quot;);
6684   assert(_stream != NULL, &quot;invariant&quot;);
6685   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6686   assert(_class_name != NULL, &quot;invariant&quot;);
6687   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6688 
6689   // Figure out whether we can skip format checking (matching classic VM behavior)
6690   if (DumpSharedSpaces) {
6691     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6692     // Verification decision is based on BytecodeVerificationRemote flag
6693     // for those classes.
6694     _need_verify = (stream-&gt;need_verify()) ? BytecodeVerificationRemote :
6695                                               BytecodeVerificationLocal;
6696   }
6697   else {
6698     _need_verify = Verifier::should_verify_for(_loader_data-&gt;class_loader(),
6699                                                stream-&gt;need_verify());
6700   }
6701   if (_cp_patches != NULL) {
6702     int len = _cp_patches-&gt;length();
6703     for (int i=0; i&lt;len; i++) {
6704       if (has_cp_patch_at(i)) {
6705         Handle patch = cp_patch_at(i);
6706         if (java_lang_String::is_instance(patch()) || java_lang_Class::is_instance(patch())) {
6707           // We need to append the names of the patched classes to the end of the constant pool,
6708           // because a patched class may have a Utf8 name that&#39;s not already included in the
6709           // original constant pool. These class names are used when patch_constant_pool()
6710           // calls patch_class().
6711           //
6712           // Note that a String in cp_patch_at(i) may be used to patch a Utf8, a String, or a Class.
6713           // At this point, we don&#39;t know the tag for index i yet, because we haven&#39;t parsed the
6714           // constant pool. So we can only assume the worst -- every String is used to patch a Class.
6715           _max_num_patched_klasses++;
6716         }
6717       }
6718     }
6719   }
6720 
6721   // synch back verification state to stream
6722   stream-&gt;set_verify(_need_verify);
6723 
6724   // Check if verification needs to be relaxed for this class file
6725   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6726   _relax_verify = relax_format_check_for(_loader_data);
6727 
6728   parse_stream(stream, CHECK);
6729 
6730   post_process_parsed_stream(stream, _cp, CHECK);
6731 }
6732 
6733 void ClassFileParser::clear_class_metadata() {
6734   // metadata created before the instance klass is created.  Must be
6735   // deallocated if classfile parsing returns an error.
6736   _cp = NULL;
6737   _fields = NULL;
6738   _methods = NULL;
6739   _inner_classes = NULL;
6740   _nest_members = NULL;
6741   _permitted_subclasses = NULL;
6742   _combined_annotations = NULL;
6743   _class_annotations = _class_type_annotations = NULL;
6744   _fields_annotations = _fields_type_annotations = NULL;
6745   _record_components = NULL;
6746 }
6747 
6748 // Destructor to clean up
6749 ClassFileParser::~ClassFileParser() {
6750   _class_name-&gt;decrement_refcount();
6751 
6752   if (_cp != NULL) {
6753     MetadataFactory::free_metadata(_loader_data, _cp);
6754   }
6755   if (_fields != NULL) {
6756     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6757   }
6758 
6759   if (_methods != NULL) {
6760     // Free methods
6761     InstanceKlass::deallocate_methods(_loader_data, _methods);
6762   }
6763 
6764   // beware of the Universe::empty_blah_array!!
6765   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
6766     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
6767   }
6768 
6769   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
6770     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
6771   }
6772 
6773   if (_record_components != NULL) {
6774     InstanceKlass::deallocate_record_components(_loader_data, _record_components);
6775   }
6776 
6777   if (_permitted_subclasses != NULL &amp;&amp; _permitted_subclasses != Universe::the_empty_short_array()) {
6778     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _permitted_subclasses);
6779   }
6780 
6781   // Free interfaces
6782   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
6783                                        _local_interfaces, _transitive_interfaces);
6784 
6785   if (_combined_annotations != NULL) {
6786     // After all annotations arrays have been created, they are installed into the
6787     // Annotations object that will be assigned to the InstanceKlass being created.
6788 
6789     // Deallocate the Annotations object and the installed annotations arrays.
6790     _combined_annotations-&gt;deallocate_contents(_loader_data);
6791 
6792     // If the _combined_annotations pointer is non-NULL,
6793     // then the other annotations fields should have been cleared.
6794     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6795     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6796     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6797     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6798   } else {
6799     // If the annotations arrays were not installed into the Annotations object,
6800     // then they have to be deallocated explicitly.
6801     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_annotations);
6802     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_type_annotations);
6803     Annotations::free_contents(_loader_data, _fields_annotations);
6804     Annotations::free_contents(_loader_data, _fields_type_annotations);
6805   }
6806 
6807   clear_class_metadata();
6808   _transitive_interfaces = NULL;
6809   _local_interfaces = NULL;
6810 
6811   // deallocate the klass if already created.  Don&#39;t directly deallocate, but add
6812   // to the deallocate list so that the klass is removed from the CLD::_klasses list
6813   // at a safepoint.
6814   if (_klass_to_deallocate != NULL) {
6815     _loader_data-&gt;add_to_deallocate_list(_klass_to_deallocate);
6816   }
6817 }
6818 
6819 void ClassFileParser::parse_stream(const ClassFileStream* const stream,
6820                                    TRAPS) {
6821 
6822   assert(stream != NULL, &quot;invariant&quot;);
6823   assert(_class_name != NULL, &quot;invariant&quot;);
6824 
6825   // BEGIN STREAM PARSING
6826   stream-&gt;guarantee_more(8, CHECK);  // magic, major, minor
6827   // Magic value
6828   const u4 magic = stream-&gt;get_u4_fast();
6829   guarantee_property(magic == JAVA_CLASSFILE_MAGIC,
6830                      &quot;Incompatible magic value %u in class file %s&quot;,
6831                      magic, CHECK);
6832 
6833   // Version numbers
6834   _minor_version = stream-&gt;get_u2_fast();
6835   _major_version = stream-&gt;get_u2_fast();
6836 
6837   if (DumpSharedSpaces &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6838     ResourceMark rm;
6839     warning(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
6840             _major_version,  _minor_version, _class_name-&gt;as_C_string());
6841     Exceptions::fthrow(
6842       THREAD_AND_LOCATION,
6843       vmSymbols::java_lang_UnsupportedClassVersionError(),
6844       &quot;Unsupported major.minor version for dump time %u.%u&quot;,
6845       _major_version,
6846       _minor_version);
6847   }
6848 
6849   // Check version numbers - we check this even with verifier off
6850   verify_class_version(_major_version, _minor_version, _class_name, CHECK);
6851 
6852   stream-&gt;guarantee_more(3, CHECK); // length, first cp tag
6853   u2 cp_size = stream-&gt;get_u2_fast();
6854 
6855   guarantee_property(
6856     cp_size &gt;= 1, &quot;Illegal constant pool size %u in class file %s&quot;,
6857     cp_size, CHECK);
6858 
6859   _orig_cp_size = cp_size;
6860   if (is_hidden()) { // Add a slot for hidden class name.
6861     assert(_max_num_patched_klasses == 0, &quot;Sanity check&quot;);
6862     cp_size++;
6863   } else {
6864     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6865       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6866     }
6867     cp_size += _max_num_patched_klasses;
6868   }
6869 
6870   _cp = ConstantPool::allocate(_loader_data,
6871                                cp_size,
6872                                CHECK);
6873 
6874   ConstantPool* const cp = _cp;
6875 
6876   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6877 
6878   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6879 
6880   // ACCESS FLAGS
6881   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6882 
6883   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;
6884   // JVM_ACC_MODULE is defined in JDK-9 and later.
6885   if (_major_version &gt;= JAVA_9_VERSION) {
6886     recognized_modifiers |= JVM_ACC_MODULE;
6887   }
6888   // JVM_ACC_VALUE is defined for class file version 55 and later
6889   if (supports_inline_types()) {
6890     recognized_modifiers |= JVM_ACC_VALUE;
6891   }
6892 
6893   // Access flags
6894   jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;
6895 
6896   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6897     // Set abstract bit for old class files for backward compatibility
6898     flags |= JVM_ACC_ABSTRACT;
6899   }
6900 
6901   verify_legal_class_modifiers(flags, CHECK);
6902 
6903   short bad_constant = class_bad_constant_seen();
6904   if (bad_constant != 0) {
6905     // Do not throw CFE until after the access_flags are checked because if
6906     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6907     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6908   }
6909 
6910   _access_flags.set_flags(flags);
6911 
6912   // This class and superclass
6913   _this_class_index = stream-&gt;get_u2_fast();
6914   check_property(
6915     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
6916       cp-&gt;tag_at(_this_class_index).is_unresolved_klass(),
6917     &quot;Invalid this class index %u in constant pool in class file %s&quot;,
6918     _this_class_index, CHECK);
6919 
6920   Symbol* const class_name_in_cp = cp-&gt;klass_name_at(_this_class_index);
6921   assert(class_name_in_cp != NULL, &quot;class_name can&#39;t be null&quot;);
6922 
6923   // Don&#39;t need to check whether this class name is legal or not.
6924   // It has been checked when constant pool is parsed.
6925   // However, make sure it is not an array type.
6926   if (_need_verify) {
6927     guarantee_property(class_name_in_cp-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
6928                        &quot;Bad class name in class file %s&quot;,
6929                        CHECK);
6930   }
6931 
6932 #ifdef ASSERT
6933   // Basic sanity checks
6934   assert(!(_is_hidden &amp;&amp; (_unsafe_anonymous_host != NULL)), &quot;mutually exclusive variants&quot;);
6935 
6936   if (_unsafe_anonymous_host != NULL) {
6937     assert(_class_name == vmSymbols::unknown_class_name(), &quot;A named anonymous class???&quot;);
6938   }
6939   if (_is_hidden) {
6940     assert(_class_name != vmSymbols::unknown_class_name(), &quot;hidden classes should have a special name&quot;);
6941   }
6942 #endif
6943 
6944   // Update the _class_name as needed depending on whether this is a named,
6945   // un-named, hidden or unsafe-anonymous class.
6946 
6947   if (_is_hidden) {
6948     assert(_class_name != NULL, &quot;Unexpected null _class_name&quot;);
6949 #ifdef ASSERT
6950     if (_need_verify) {
6951       verify_legal_class_name(_class_name, CHECK);
6952     }
6953 #endif
6954 
6955   // NOTE: !_is_hidden does not imply &quot;findable&quot; as it could be an old-style
6956   //       &quot;hidden&quot; unsafe-anonymous class
6957 
6958   // If this is an anonymous class fix up its name if it is in the unnamed
6959   // package.  Otherwise, throw IAE if it is in a different package than
6960   // its host class.
6961   } else if (_unsafe_anonymous_host != NULL) {
6962     update_class_name(class_name_in_cp);
6963     fix_unsafe_anonymous_class_name(CHECK);
6964 
6965   } else {
6966     // Check if name in class file matches given name
6967     if (_class_name != class_name_in_cp) {
6968       if (_class_name != vmSymbols::unknown_class_name()) {
6969         ResourceMark rm(THREAD);
6970         Exceptions::fthrow(THREAD_AND_LOCATION,
6971                            vmSymbols::java_lang_NoClassDefFoundError(),
6972                            &quot;%s (wrong name: %s)&quot;,
6973                            class_name_in_cp-&gt;as_C_string(),
6974                            _class_name-&gt;as_C_string()
6975                            );
6976         return;
6977       } else {
6978         // The class name was not known by the caller so we set it from
6979         // the value in the CP.
6980         update_class_name(class_name_in_cp);
6981       }
6982       // else nothing to do: the expected class name matches what is in the CP
6983     }
6984   }
6985 
6986   // Verification prevents us from creating names with dots in them, this
6987   // asserts that that&#39;s the case.
6988   assert(is_internal_format(_class_name), &quot;external class name format used internally&quot;);
6989 
6990   if (!is_internal()) {
6991     LogTarget(Debug, class, preorder) lt;
6992     if (lt.is_enabled()){
6993       ResourceMark rm(THREAD);
6994       LogStream ls(lt);
6995       ls.print(&quot;%s&quot;, _class_name-&gt;as_klass_external_name());
6996       if (stream-&gt;source() != NULL) {
6997         ls.print(&quot; source: %s&quot;, stream-&gt;source());
6998       }
6999       ls.cr();
7000     }
7001 
7002 #if INCLUDE_CDS
7003     if (DumpLoadedClassList != NULL &amp;&amp; stream-&gt;source() != NULL &amp;&amp; classlist_file-&gt;is_open()) {
7004       if (!ClassLoader::has_jrt_entry()) {
7005         warning(&quot;DumpLoadedClassList and CDS are not supported in exploded build&quot;);
7006         DumpLoadedClassList = NULL;
7007       } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &amp;&amp;
7008                  !_is_hidden &amp;&amp;
7009                  _unsafe_anonymous_host == NULL) {
7010         // Only dump the classes that can be stored into CDS archive.
7011         // Hidden and unsafe anonymous classes such as generated LambdaForm classes are also not included.
7012         oop class_loader = _loader_data-&gt;class_loader();
7013         ResourceMark rm(THREAD);
7014         bool skip = false;
7015         if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
7016           // For the boot and platform class loaders, skip classes that are not found in the
7017           // java runtime image, such as those found in the --patch-module entries.
7018           // These classes can&#39;t be loaded from the archive during runtime.
7019           if (!stream-&gt;from_boot_loader_modules_image() &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {
7020             skip = true;
7021           }
7022 
7023           if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
7024             // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
7025             // as they can be loaded from the archive during runtime.
7026             skip = false;
7027           }
7028         }
7029         if (skip) {
7030           tty-&gt;print_cr(&quot;skip writing class %s from source %s to classlist file&quot;,
7031             _class_name-&gt;as_C_string(), stream-&gt;source());
7032         } else {
7033           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
7034           classlist_file-&gt;flush();
7035         }
7036       }
7037     }
7038 #endif
7039   }
7040 
7041   // SUPERKLASS
7042   _super_class_index = stream-&gt;get_u2_fast();
7043   _super_klass = parse_super_class(cp,
7044                                    _super_class_index,
7045                                    _need_verify,
7046                                    CHECK);
7047 
7048   // Interfaces
7049   _itfs_len = stream-&gt;get_u2_fast();
7050   parse_interfaces(stream,
7051                    _itfs_len,
7052                    cp,
7053                    is_inline_type(),
7054                    &amp;_has_nonstatic_concrete_methods,
7055                    &amp;_is_declared_atomic,
7056                    CHECK);
7057 
7058   assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);
7059 
7060   // Fields (offsets are filled in later)
7061   _fac = new FieldAllocationCount();
7062   parse_fields(stream,
7063                is_interface(),
7064                is_inline_type(),
7065                _fac,
7066                cp,
7067                cp_size,
7068                &amp;_java_fields_count,
7069                CHECK);
7070 
7071   assert(_fields != NULL, &quot;invariant&quot;);
7072 
7073   // Methods
7074   AccessFlags promoted_flags;
7075   parse_methods(stream,
7076                 is_interface(),
7077                 is_inline_type(),
7078                 &amp;promoted_flags,
7079                 &amp;_has_final_method,
7080                 &amp;_declares_nonstatic_concrete_methods,
7081                 CHECK);
7082 
7083   assert(_methods != NULL, &quot;invariant&quot;);
7084 
7085   // promote flags from parse_methods() to the klass&#39; flags
7086   _access_flags.add_promoted_flags(promoted_flags.as_int());
7087 
7088   if (_declares_nonstatic_concrete_methods) {
7089     _has_nonstatic_concrete_methods = true;
7090   }
7091 
7092   // Additional attributes/annotations
7093   _parsed_annotations = new ClassAnnotationCollector();
7094   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
7095 
7096   assert(_inner_classes != NULL, &quot;invariant&quot;);
7097 
7098   // Finalize the Annotations metadata object,
7099   // now that all annotation arrays have been created.
7100   create_combined_annotations(CHECK);
7101 
7102   // Make sure this is the end of class file stream
7103   guarantee_property(stream-&gt;at_eos(),
7104                      &quot;Extra bytes at the end of class file %s&quot;,
7105                      CHECK);
7106 
7107   // all bytes in stream read and parsed
7108 }
7109 
7110 void ClassFileParser::mangle_hidden_class_name(InstanceKlass* const ik) {
7111   ResourceMark rm;
7112   // Construct hidden name from _class_name, &quot;+&quot;, and &amp;ik. Note that we can&#39;t
7113   // use a &#39;/&#39; because that confuses finding the class&#39;s package.  Also, can&#39;t
7114   // use an illegal char such as &#39;;&#39; because that causes serialization issues
7115   // and issues with hidden classes that create their own hidden classes.
7116   char addr_buf[20];
7117   jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));
7118   size_t new_name_len = _class_name-&gt;utf8_length() + 2 + strlen(addr_buf);
7119   char* new_name = NEW_RESOURCE_ARRAY(char, new_name_len);
7120   jio_snprintf(new_name, new_name_len, &quot;%s+%s&quot;,
7121                _class_name-&gt;as_C_string(), addr_buf);
7122   update_class_name(SymbolTable::new_symbol(new_name));
7123 
7124   // Add a Utf8 entry containing the hidden name.
7125   assert(_class_name != NULL, &quot;Unexpected null _class_name&quot;);
7126   int hidden_index = _orig_cp_size; // this is an extra slot we added
7127   _cp-&gt;symbol_at_put(hidden_index, _class_name);
7128 
7129   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
7130   // We have to update the resolved_klass_index and the name_index together
7131   // so extract the existing resolved_klass_index first.
7132   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
7133   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
7134   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
7135   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
7136          &quot;Bad name_index&quot;);
7137 }
7138 
7139 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
7140                                                  ConstantPool* cp,
7141                                                  TRAPS) {
7142   assert(stream != NULL, &quot;invariant&quot;);
7143   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
7144   assert(cp != NULL, &quot;invariant&quot;);
7145   assert(_loader_data != NULL, &quot;invariant&quot;);
7146 
7147   if (_class_name == vmSymbols::java_lang_Object()) {
7148     check_property(_temp_local_interfaces-&gt;length() == 0,
7149         &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
7150         CHECK);
7151   }
7152   // We check super class after class file is parsed and format is checked
7153   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
7154     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
7155     if (is_interface()) {
7156       // Before attempting to resolve the superclass, check for class format
7157       // errors not checked yet.
7158       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
7159         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
7160         CHECK);
7161     }
7162     Handle loader(THREAD, _loader_data-&gt;class_loader());
7163     _super_klass = (const InstanceKlass*)
7164                        SystemDictionary::resolve_super_or_fail(_class_name,
7165                                                                super_class_name,
7166                                                                loader,
7167                                                                _protection_domain,
7168                                                                true,
7169                                                                CHECK);
7170   }
7171 
7172   if (_super_klass != NULL) {
7173     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
7174       _has_nonstatic_concrete_methods = true;
7175     }
7176     if (_super_klass-&gt;is_declared_atomic()) {
7177       _is_declared_atomic = true;
7178     }
7179 
7180     if (_super_klass-&gt;is_interface()) {
7181       ResourceMark rm(THREAD);
7182       Exceptions::fthrow(
7183         THREAD_AND_LOCATION,
7184         vmSymbols::java_lang_IncompatibleClassChangeError(),
7185         &quot;class %s has interface %s as super class&quot;,
7186         _class_name-&gt;as_klass_external_name(),
7187         _super_klass-&gt;external_name()
7188       );
7189       return;
7190     }
7191 
7192     // For an inline class, only java/lang/Object or special abstract classes
7193     // are acceptable super classes.
7194     if (is_inline_type()) {
7195       const InstanceKlass* super_ik = _super_klass;
7196       if (super_ik-&gt;invalid_inline_super()) {
7197         ResourceMark rm(THREAD);
7198         Exceptions::fthrow(
7199           THREAD_AND_LOCATION,
7200           vmSymbols::java_lang_IncompatibleClassChangeError(),
7201           &quot;inline class %s has an invalid super class %s&quot;,
7202           _class_name-&gt;as_klass_external_name(),
7203           _super_klass-&gt;external_name());
7204         return;
7205       }
7206     }
7207   }
7208 
7209   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {
7210     // This is the original source of this condition.
7211     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.
7212     _is_declared_atomic = true;
7213   } else if (*ForceNonTearable != &#39;\0&#39;) {
7214     // Allow a command line switch to force the same atomicity property:
7215     const char* class_name_str = _class_name-&gt;as_C_string();
7216     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
7217       _is_declared_atomic = true;
7218     }
7219   }
7220 
7221   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,
7222   // if super is marked invalid, or if is_invalid_super_for_inline_type()
7223   // returns true
7224   if (invalid_inline_super() ||
7225       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||
7226       is_invalid_super_for_inline_type()) {
7227     set_invalid_inline_super();
7228   }
7229 
7230   if (!is_inline_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())
7231       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {
7232     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());
7233     _has_injected_identityObject = true;
7234   }
7235   int itfs_len = _temp_local_interfaces-&gt;length();
7236   if (itfs_len == 0) {
7237     _local_interfaces = Universe::the_empty_instance_klass_array();
7238   } else if (itfs_len == 1 &amp;&amp; _temp_local_interfaces-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {
7239     _local_interfaces = Universe::the_single_IdentityObject_klass_array();
7240   } else {
7241     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
7242     for (int i = 0; i &lt; itfs_len; i++) {
7243       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));
7244     }
7245   }
7246   _temp_local_interfaces = NULL;
7247   assert(_local_interfaces != NULL, &quot;invariant&quot;);
7248 
7249   // Compute the transitive list of all unique interfaces implemented by this class
7250   _transitive_interfaces =
7251     compute_transitive_interfaces(_super_klass,
7252                                   _local_interfaces,
7253                                   _loader_data,
7254                                   CHECK);
7255 
7256   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7257 
7258   // sort methods
7259   _method_ordering = sort_methods(_methods);
7260 
7261   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
7262 
7263   Handle loader(THREAD, _loader_data-&gt;class_loader());
7264   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
7265                                                     &amp;_num_miranda_methods,
7266                                                     _all_mirandas,
7267                                                     _super_klass,
7268                                                     _methods,
7269                                                     _access_flags,
7270                                                     _major_version,
7271                                                     loader,
7272                                                     _class_name,
7273                                                     _local_interfaces,
7274                                                     CHECK);
7275 
7276   // Size of Java itable (in words)
7277   _itable_size = is_interface() ? 0 :
7278     klassItable::compute_itable_size(_transitive_interfaces);
7279 
7280   assert(_fac != NULL, &quot;invariant&quot;);
7281   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7282 
7283 
7284   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
7285     if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE  &amp;&amp; !fs.access_flags().is_static()) {
7286       // Pre-load inline class
7287       Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,
7288           Handle(THREAD, _loader_data-&gt;class_loader()),
7289           _protection_domain, true, CHECK);
7290       assert(klass != NULL, &quot;Sanity check&quot;);
7291       assert(klass-&gt;access_flags().is_inline_type(), &quot;Value type expected&quot;);
7292     }
7293   }
7294 
7295   _field_info = new FieldLayoutInfo();
7296   if (UseNewFieldLayout) {
7297     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
7298         _parsed_annotations-&gt;is_contended(), is_inline_type(),
7299         loader_data(), _protection_domain, _field_info);
7300     lb.build_layout(CHECK);
7301     if (is_inline_type()) {
7302       _alignment = lb.get_alignment();
7303       _first_field_offset = lb.get_first_field_offset();
7304       _exact_size_in_bytes = lb.get_exact_size_in_byte();
7305     }
7306   } else {
7307     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
7308   }
7309   _has_inline_type_fields = _field_info-&gt;_has_inline_fields;
7310 
7311   // Compute reference type
7312   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
7313 }
7314 
7315 void ClassFileParser::set_klass(InstanceKlass* klass) {
7316 
7317 #ifdef ASSERT
7318   if (klass != NULL) {
7319     assert(NULL == _klass, &quot;leaking?&quot;);
7320   }
7321 #endif
7322 
7323   _klass = klass;
7324 }
7325 
7326 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
7327 
7328 #ifdef ASSERT
7329   if (klass != NULL) {
7330     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
7331   }
7332 #endif
7333 
7334   _klass_to_deallocate = klass;
7335 }
7336 
7337 // Caller responsible for ResourceMark
7338 // clone stream with rewound position
7339 const ClassFileStream* ClassFileParser::clone_stream() const {
7340   assert(_stream != NULL, &quot;invariant&quot;);
7341 
7342   return _stream-&gt;clone();
7343 }
7344 
7345 // ----------------------------------------------------------------------------
7346 // debugging
7347 
7348 #ifdef ASSERT
7349 
7350 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
7351 bool ClassFileParser::is_internal_format(Symbol* class_name) {
7352   if (class_name != NULL) {
7353     ResourceMark rm;
7354     char* name = class_name-&gt;as_C_string();
7355     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
7356   } else {
7357     return true;
7358   }
7359 }
7360 
7361 #endif
    </pre>
  </body>
</html>