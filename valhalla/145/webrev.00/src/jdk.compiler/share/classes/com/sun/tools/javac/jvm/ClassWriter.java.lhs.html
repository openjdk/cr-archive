<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.util.LinkedHashMap;
  30 import java.util.Map;
  31 import java.util.Set;
  32 import java.util.LinkedHashSet;
  33 import java.util.function.ToIntFunction;
  34 
  35 import javax.tools.JavaFileManager;
  36 import javax.tools.FileObject;
  37 import javax.tools.JavaFileManager.Location;
  38 import javax.tools.JavaFileObject;
  39 
  40 import com.sun.tools.javac.code.*;
  41 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  42 import com.sun.tools.javac.code.Directive.*;
  43 import com.sun.tools.javac.code.Symbol.*;
  44 import com.sun.tools.javac.code.Type.*;
  45 import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;
  46 import com.sun.tools.javac.comp.Check;
  47 import com.sun.tools.javac.file.PathFileObject;
  48 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
  49 import com.sun.tools.javac.jvm.PoolConstant.Dynamic.BsmKey;
  50 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  51 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  52 import com.sun.tools.javac.util.*;
  53 import com.sun.tools.javac.util.List;
  54 
  55 import static com.sun.tools.javac.code.Flags.*;
  56 import static com.sun.tools.javac.code.Kinds.Kind.*;
  57 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  58 import static com.sun.tools.javac.code.TypeTag.*;
  59 import static com.sun.tools.javac.main.Option.*;
  60 
  61 import static javax.tools.StandardLocation.CLASS_OUTPUT;
  62 
  63 /** This class provides operations to map an internal symbol table graph
  64  *  rooted in a ClassSymbol into a classfile.
  65  *
  66  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  67  *  If you write code that depends on this, you do so at your own risk.
  68  *  This code and its internal interfaces are subject to change or
  69  *  deletion without notice.&lt;/b&gt;
  70  */
  71 public class ClassWriter extends ClassFile {
  72     protected static final Context.Key&lt;ClassWriter&gt; classWriterKey = new Context.Key&lt;&gt;();
  73 
  74     private final Options options;
  75 
  76     /** Switch: verbose output.
  77      */
  78     private boolean verbose;
  79 
  80     /** Switch: emit source file attribute.
  81      */
  82     private boolean emitSourceFile;
  83 
  84     /** Switch: generate CharacterRangeTable attribute.
  85      */
  86     private boolean genCrt;
  87 
  88     /** Switch: describe the generated stackmap.
  89      */
  90     private boolean debugstackmap;
  91 
  92     /** Preview language level.
  93      */
  94     private Preview preview;
  95 
  96     /**
  97      * Target class version.
  98      */
  99     private Target target;
 100 
 101     /**
 102      * Source language version.
 103      */
 104     private Source source;
 105 
 106     /** Type utilities. */
 107     private Types types;
 108 
 109     private Check check;
 110 
 111     /**
 112      * If true, class files will be written in module-specific subdirectories
 113      * of the CLASS_OUTPUT location.
 114      */
 115     public boolean multiModuleMode;
 116 
 117     private List&lt;ToIntFunction&lt;Symbol&gt;&gt; extraAttributeHooks = List.nil();
 118 
 119     /** The initial sizes of the data and constant pool buffers.
 120      *  Sizes are increased when buffers get full.
 121      */
 122     static final int DATA_BUF_SIZE = 0x0fff0;
 123     static final int CLASS_BUF_SIZE = 0x1fff0;
 124 
 125     /** An output buffer for member info.
 126      */
 127     public ByteBuffer databuf = new ByteBuffer(DATA_BUF_SIZE);
 128 
 129     /** An output buffer for the constant pool.
 130      */
 131     ByteBuffer poolbuf = new ByteBuffer(CLASS_BUF_SIZE);
 132 
 133     /** The constant pool writer.
 134      */
 135     final PoolWriter poolWriter;
 136 
 137     /** The log to use for verbose output.
 138      */
 139     private final Log log;
 140 
 141     /** The name table. */
 142     private final Names names;
 143 
 144     private final Symtab syms;
 145 
 146     /** Access to files. */
 147     private final JavaFileManager fileManager;
 148 
 149     /** The tags and constants used in compressed stackmap. */
 150     static final int SAME_FRAME_SIZE = 64;
 151     static final int SAME_LOCALS_1_STACK_ITEM_EXTENDED = 247;
 152     static final int SAME_FRAME_EXTENDED = 251;
 153     static final int FULL_FRAME = 255;
 154     static final int MAX_LOCAL_LENGTH_DIFF = 4;
 155 
 156     /** Get the ClassWriter instance for this context. */
 157     public static ClassWriter instance(Context context) {
 158         ClassWriter instance = context.get(classWriterKey);
 159         if (instance == null)
 160             instance = new ClassWriter(context);
 161         return instance;
 162     }
 163 
 164     /** Construct a class writer, given an options table.
 165      */
 166     protected ClassWriter(Context context) {
 167         context.put(classWriterKey, this);
 168 
 169         log = Log.instance(context);
 170         names = Names.instance(context);
 171         options = Options.instance(context);
 172         preview = Preview.instance(context);
 173         target = Target.instance(context);
 174         source = Source.instance(context);
 175         types = Types.instance(context);
 176         check = Check.instance(context);
 177         fileManager = context.get(JavaFileManager.class);
 178         poolWriter = Gen.instance(context).poolWriter;
 179         syms = Symtab.instance(context);
 180 
 181         verbose        = options.isSet(VERBOSE);
 182         genCrt         = options.isSet(XJCOV);
 183         debugstackmap = options.isSet(&quot;debug.stackmap&quot;);
 184 
 185         emitSourceFile = options.isUnset(G_CUSTOM) ||
 186                             options.isSet(G_CUSTOM, &quot;source&quot;);
 187 
 188         String modifierFlags = options.get(&quot;debug.dumpmodifiers&quot;);
 189         if (modifierFlags != null) {
 190             dumpClassModifiers = modifierFlags.indexOf(&#39;c&#39;) != -1;
 191             dumpFieldModifiers = modifierFlags.indexOf(&#39;f&#39;) != -1;
 192             dumpInnerClassModifiers = modifierFlags.indexOf(&#39;i&#39;) != -1;
 193             dumpMethodModifiers = modifierFlags.indexOf(&#39;m&#39;) != -1;
 194         }
 195     }
 196 
 197     public void addExtraAttributes(ToIntFunction&lt;Symbol&gt; addExtraAttributes) {
 198         extraAttributeHooks = extraAttributeHooks.prepend(addExtraAttributes);
 199     }
 200 
 201 /******************************************************************
 202  * Diagnostics: dump generated class names and modifiers
 203  ******************************************************************/
 204 
 205     /** Value of option &#39;dumpmodifiers&#39; is a string
 206      *  indicating which modifiers should be dumped for debugging:
 207      *    &#39;c&#39; -- classes
 208      *    &#39;f&#39; -- fields
 209      *    &#39;i&#39; -- innerclass attributes
 210      *    &#39;m&#39; -- methods
 211      *  For example, to dump everything:
 212      *    javac -XDdumpmodifiers=cifm MyProg.java
 213      */
 214     private boolean dumpClassModifiers; // -XDdumpmodifiers=c
 215     private boolean dumpFieldModifiers; // -XDdumpmodifiers=f
 216     private boolean dumpInnerClassModifiers; // -XDdumpmodifiers=i
 217     private boolean dumpMethodModifiers; // -XDdumpmodifiers=m
 218 
 219 
 220     /** Return flags as a string, separated by &quot; &quot;.
 221      */
 222     public static String flagNames(long flags) {
 223         StringBuilder sbuf = new StringBuilder();
 224         int i = 0;
 225         long f = flags &amp; StandardFlags;
 226         while (f != 0) {
 227             if ((f &amp; 1) != 0) {
 228                 sbuf.append(&quot; &quot;);
 229                 sbuf.append(flagName[i]);
 230             }
 231             f = f &gt;&gt; 1;
 232             i++;
 233         }
 234         return sbuf.toString();
 235     }
 236     //where
 237         private final static String[] flagName = {
 238             &quot;PUBLIC&quot;, &quot;PRIVATE&quot;, &quot;PROTECTED&quot;, &quot;STATIC&quot;, &quot;FINAL&quot;,
 239             &quot;SUPER&quot;, &quot;VOLATILE&quot;, &quot;TRANSIENT&quot;, &quot;NATIVE&quot;, &quot;INTERFACE&quot;,
 240             &quot;ABSTRACT&quot;, &quot;STRICTFP&quot;};
 241 
 242 /******************************************************************
 243  * Output routines
 244  ******************************************************************/
 245 
 246     /** Write a character into given byte buffer;
 247      *  byte buffer will not be grown.
 248      */
 249     void putChar(ByteBuffer buf, int op, int x) {
 250         buf.elems[op  ] = (byte)((x &gt;&gt;  8) &amp; 0xFF);
 251         buf.elems[op+1] = (byte)((x      ) &amp; 0xFF);
 252     }
 253 
 254     /** Write an integer into given byte buffer;
 255      *  byte buffer will not be grown.
 256      */
 257     void putInt(ByteBuffer buf, int adr, int x) {
 258         buf.elems[adr  ] = (byte)((x &gt;&gt; 24) &amp; 0xFF);
 259         buf.elems[adr+1] = (byte)((x &gt;&gt; 16) &amp; 0xFF);
 260         buf.elems[adr+2] = (byte)((x &gt;&gt;  8) &amp; 0xFF);
 261         buf.elems[adr+3] = (byte)((x      ) &amp; 0xFF);
 262     }
 263 
 264 /******************************************************************
 265  * Writing the Constant Pool
 266  ******************************************************************/
 267 
 268     /** Thrown when the constant pool is over full.
 269      */
 270     public static class PoolOverflow extends RuntimeException {
 271         private static final long serialVersionUID = 0;
 272         public PoolOverflow() {}
 273     }
 274     public static class StringOverflow extends RuntimeException {
 275         private static final long serialVersionUID = 0;
 276         public final String value;
 277         public StringOverflow(String s) {
 278             value = s;
 279         }
 280     }
 281 
 282 /******************************************************************
 283  * Writing Attributes
 284  ******************************************************************/
 285 
 286     /** Write header for an attribute to data buffer and return
 287      *  position past attribute length index.
 288      */
 289     public int writeAttr(Name attrName) {
 290         int index = poolWriter.putName(attrName);
 291         databuf.appendChar(index);
 292         databuf.appendInt(0);
 293         return databuf.length;
 294     }
 295 
 296     /** Fill in attribute length.
 297      */
 298     public void endAttr(int index) {
 299         putInt(databuf, index - 4, databuf.length - index);
 300     }
 301 
 302     /** Leave space for attribute count and return index for
 303      *  number of attributes field.
 304      */
 305     int beginAttrs() {
 306         databuf.appendChar(0);
 307         return databuf.length;
 308     }
 309 
 310     /** Fill in number of attributes.
 311      */
 312     void endAttrs(int index, int count) {
 313         putChar(databuf, index - 2, count);
 314     }
 315 
 316     /** Write the EnclosingMethod attribute if needed.
 317      *  Returns the number of attributes written (0 or 1).
 318      */
 319     int writeEnclosingMethodAttribute(ClassSymbol c) {
 320         return writeEnclosingMethodAttribute(names.EnclosingMethod, c);
 321     }
 322 
 323     /** Write the EnclosingMethod attribute with a specified name.
 324      *  Returns the number of attributes written (0 or 1).
 325      */
 326     protected int writeEnclosingMethodAttribute(Name attributeName, ClassSymbol c) {
 327         if (c.owner.kind != MTH &amp;&amp; // neither a local class
 328             c.name != names.empty) // nor anonymous
 329             return 0;
 330 
 331         int alenIdx = writeAttr(attributeName);
 332         ClassSymbol enclClass = c.owner.enclClass();
 333         MethodSymbol enclMethod =
 334             (c.owner.type == null // local to init block
 335              || c.owner.kind != MTH) // or member init
 336             ? null
 337             : ((MethodSymbol)c.owner).originalEnclosingMethod();
 338         databuf.appendChar(poolWriter.putClass(enclClass));
 339         databuf.appendChar(enclMethod == null ? 0 : poolWriter.putNameAndType(enclMethod));
 340         endAttr(alenIdx);
 341         return 1;
 342     }
 343 
 344     /** Write flag attributes; return number of attributes written.
 345      */
 346     int writeFlagAttrs(long flags) {
 347         int acount = 0;
 348         if ((flags &amp; DEPRECATED) != 0) {
 349             int alenIdx = writeAttr(names.Deprecated);
 350             endAttr(alenIdx);
 351             acount++;
 352         }
 353         return acount;
 354     }
 355 
 356     /** Write member (field or method) attributes;
 357      *  return number of attributes written.
 358      */
 359     int writeMemberAttrs(Symbol sym, boolean isRecordComponent) {
 360         int acount = 0;
 361         if (!isRecordComponent) {
 362             acount = writeFlagAttrs(sym.flags());
 363         }
 364         long flags = sym.flags();
 365         if ((flags &amp; (SYNTHETIC | BRIDGE)) != SYNTHETIC &amp;&amp;
 366             (flags &amp; ANONCONSTR) == 0 &amp;&amp;
 367             (!types.isSameType(sym.type, sym.erasure(types)) ||
 368              poolWriter.signatureGen.hasTypeVar(sym.type.getThrownTypes()))) {
 369             // note that a local class with captured variables
 370             // will get a signature attribute
 371             int alenIdx = writeAttr(names.Signature);
 372             databuf.appendChar(poolWriter.putSignature(sym));
 373             endAttr(alenIdx);
 374             acount++;
 375         }
 376         acount += writeJavaAnnotations(sym.getRawAttributes());
 377         acount += writeTypeAnnotations(sym.getRawTypeAttributes(), false);
 378         return acount;
 379     }
 380 
 381     /**
 382      * Write method parameter names attribute.
 383      */
 384     int writeMethodParametersAttr(MethodSymbol m) {
 385         MethodType ty = m.externalType(types).asMethodType();
 386         final int allparams = ty.argtypes.size();
 387         if (m.params != null &amp;&amp; allparams != 0) {
 388             final int attrIndex = writeAttr(names.MethodParameters);
 389             databuf.appendByte(allparams);
 390             // Write extra parameters first
 391             for (VarSymbol s : m.extraParams) {
 392                 final int flags =
 393                     ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
 394                     ((int) m.flags() &amp; SYNTHETIC);
 395                 databuf.appendChar(poolWriter.putName(s.name));
 396                 databuf.appendChar(flags);
 397             }
 398             // Now write the real parameters
 399             for (VarSymbol s : m.params) {
 400                 final int flags =
 401                     ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
 402                     ((int) m.flags() &amp; SYNTHETIC);
 403                 databuf.appendChar(poolWriter.putName(s.name));
 404                 databuf.appendChar(flags);
 405             }
 406             // Now write the captured locals
 407             for (VarSymbol s : m.capturedLocals) {
 408                 final int flags =
 409                     ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
 410                     ((int) m.flags() &amp; SYNTHETIC);
 411                 databuf.appendChar(poolWriter.putName(s.name));
 412                 databuf.appendChar(flags);
 413             }
 414             endAttr(attrIndex);
 415             return 1;
 416         } else
 417             return 0;
 418     }
 419 
 420     private void writeParamAnnotations(List&lt;VarSymbol&gt; params,
 421                                        RetentionPolicy retention) {
 422         databuf.appendByte(params.length());
 423         for (VarSymbol s : params) {
 424             ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
 425             for (Attribute.Compound a : s.getRawAttributes())
 426                 if (types.getRetention(a) == retention)
 427                     buf.append(a);
 428             databuf.appendChar(buf.length());
 429             for (Attribute.Compound a : buf)
 430                 writeCompoundAttribute(a);
 431         }
 432 
 433     }
 434 
 435     private void writeParamAnnotations(MethodSymbol m,
 436                                        RetentionPolicy retention) {
 437         databuf.appendByte(m.params.length());
 438         writeParamAnnotations(m.params, retention);
 439     }
 440 
 441     /** Write method parameter annotations;
 442      *  return number of attributes written.
 443      */
 444     int writeParameterAttrs(List&lt;VarSymbol&gt; vars) {
 445         boolean hasVisible = false;
 446         boolean hasInvisible = false;
 447         if (vars != null) {
 448             for (VarSymbol s : vars) {
 449                 for (Attribute.Compound a : s.getRawAttributes()) {
 450                     switch (types.getRetention(a)) {
 451                     case SOURCE: break;
 452                     case CLASS: hasInvisible = true; break;
 453                     case RUNTIME: hasVisible = true; break;
 454                     default: // /* fail soft */ throw new AssertionError(vis);
 455                     }
 456                 }
 457             }
 458         }
 459 
 460         int attrCount = 0;
 461         if (hasVisible) {
 462             int attrIndex = writeAttr(names.RuntimeVisibleParameterAnnotations);
 463             writeParamAnnotations(vars, RetentionPolicy.RUNTIME);
 464             endAttr(attrIndex);
 465             attrCount++;
 466         }
 467         if (hasInvisible) {
 468             int attrIndex = writeAttr(names.RuntimeInvisibleParameterAnnotations);
 469             writeParamAnnotations(vars, RetentionPolicy.CLASS);
 470             endAttr(attrIndex);
 471             attrCount++;
 472         }
 473         return attrCount;
 474     }
 475 
 476 /**********************************************************************
 477  * Writing Java-language annotations (aka metadata, attributes)
 478  **********************************************************************/
 479 
 480     /** Write Java-language annotations; return number of JVM
 481      *  attributes written (zero or one).
 482      */
 483     int writeJavaAnnotations(List&lt;Attribute.Compound&gt; attrs) {
 484         if (attrs.isEmpty()) return 0;
 485         ListBuffer&lt;Attribute.Compound&gt; visibles = new ListBuffer&lt;&gt;();
 486         ListBuffer&lt;Attribute.Compound&gt; invisibles = new ListBuffer&lt;&gt;();
 487         for (Attribute.Compound a : attrs) {
 488             switch (types.getRetention(a)) {
 489             case SOURCE: break;
 490             case CLASS: invisibles.append(a); break;
 491             case RUNTIME: visibles.append(a); break;
 492             default: // /* fail soft */ throw new AssertionError(vis);
 493             }
 494         }
 495 
 496         int attrCount = 0;
 497         if (visibles.length() != 0) {
 498             int attrIndex = writeAttr(names.RuntimeVisibleAnnotations);
 499             databuf.appendChar(visibles.length());
 500             for (Attribute.Compound a : visibles)
 501                 writeCompoundAttribute(a);
 502             endAttr(attrIndex);
 503             attrCount++;
 504         }
 505         if (invisibles.length() != 0) {
 506             int attrIndex = writeAttr(names.RuntimeInvisibleAnnotations);
 507             databuf.appendChar(invisibles.length());
 508             for (Attribute.Compound a : invisibles)
 509                 writeCompoundAttribute(a);
 510             endAttr(attrIndex);
 511             attrCount++;
 512         }
 513         return attrCount;
 514     }
 515 
 516     int writeTypeAnnotations(List&lt;Attribute.TypeCompound&gt; typeAnnos, boolean inCode) {
 517         if (typeAnnos.isEmpty()) return 0;
 518 
 519         ListBuffer&lt;Attribute.TypeCompound&gt; visibles = new ListBuffer&lt;&gt;();
 520         ListBuffer&lt;Attribute.TypeCompound&gt; invisibles = new ListBuffer&lt;&gt;();
 521 
 522         for (Attribute.TypeCompound tc : typeAnnos) {
 523             if (tc.hasUnknownPosition()) {
 524                 boolean fixed = tc.tryFixPosition();
 525 
 526                 // Could we fix it?
 527                 if (!fixed) {
 528                     // This happens for nested types like @A Outer. @B Inner.
 529                     // For method parameters we get the annotation twice! Once with
 530                     // a valid position, once unknown.
 531                     // TODO: find a cleaner solution.
 532                     PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
 533                     pw.println(&quot;ClassWriter: Position UNKNOWN in type annotation: &quot; + tc);
 534                     continue;
 535                 }
 536             }
 537 
 538             if (tc.position.type.isLocal() != inCode)
 539                 continue;
 540             if (!tc.position.emitToClassfile())
 541                 continue;
 542             switch (types.getRetention(tc)) {
 543             case SOURCE: break;
 544             case CLASS: invisibles.append(tc); break;
 545             case RUNTIME: visibles.append(tc); break;
 546             default: // /* fail soft */ throw new AssertionError(vis);
 547             }
 548         }
 549 
 550         int attrCount = 0;
 551         if (visibles.length() != 0) {
 552             int attrIndex = writeAttr(names.RuntimeVisibleTypeAnnotations);
 553             databuf.appendChar(visibles.length());
 554             for (Attribute.TypeCompound p : visibles)
 555                 writeTypeAnnotation(p);
 556             endAttr(attrIndex);
 557             attrCount++;
 558         }
 559 
 560         if (invisibles.length() != 0) {
 561             int attrIndex = writeAttr(names.RuntimeInvisibleTypeAnnotations);
 562             databuf.appendChar(invisibles.length());
 563             for (Attribute.TypeCompound p : invisibles)
 564                 writeTypeAnnotation(p);
 565             endAttr(attrIndex);
 566             attrCount++;
 567         }
 568 
 569         return attrCount;
 570     }
 571 
 572     /** A visitor to write an attribute including its leading
 573      *  single-character marker.
 574      */
 575     class AttributeWriter implements Attribute.Visitor {
 576         public void visitConstant(Attribute.Constant _value) {
 577             if (_value.type.getTag() == CLASS) {
 578                 Assert.check(_value.value instanceof String);
 579                 String s = (String)_value.value;
 580                 databuf.appendByte(&#39;s&#39;);
 581                 databuf.appendChar(poolWriter.putName(names.fromString(s)));
 582             } else {
 583                 switch (_value.type.getTag()) {
 584                     case BYTE:
 585                         databuf.appendByte(&#39;B&#39;);
 586                         break;
 587                     case CHAR:
 588                         databuf.appendByte(&#39;C&#39;);
 589                         break;
 590                     case SHORT:
 591                         databuf.appendByte(&#39;S&#39;);
 592                         break;
 593                     case INT:
 594                         databuf.appendByte(&#39;I&#39;);
 595                         break;
 596                     case LONG:
 597                         databuf.appendByte(&#39;J&#39;);
 598                         break;
 599                     case FLOAT:
 600                         databuf.appendByte(&#39;F&#39;);
 601                         break;
 602                     case DOUBLE:
 603                         databuf.appendByte(&#39;D&#39;);
 604                         break;
 605                     case BOOLEAN:
 606                         databuf.appendByte(&#39;Z&#39;);
 607                         break;
 608                     default:
 609                         throw new AssertionError(_value.type);
 610                 }
 611                 databuf.appendChar(poolWriter.putConstant(_value.value));
 612             }
 613         }
 614         public void visitEnum(Attribute.Enum e) {
 615             databuf.appendByte(&#39;e&#39;);
 616             databuf.appendChar(poolWriter.putDescriptor(e.value.type));
 617             databuf.appendChar(poolWriter.putName(e.value.name));
 618         }
 619         public void visitClass(Attribute.Class clazz) {
 620             databuf.appendByte(&#39;c&#39;);
 621             databuf.appendChar(poolWriter.putDescriptor(clazz.classType));
 622         }
 623         public void visitCompound(Attribute.Compound compound) {
 624             databuf.appendByte(&#39;@&#39;);
 625             writeCompoundAttribute(compound);
 626         }
 627         public void visitError(Attribute.Error x) {
 628             throw new AssertionError(x);
 629         }
 630         public void visitArray(Attribute.Array array) {
 631             databuf.appendByte(&#39;[&#39;);
 632             databuf.appendChar(array.values.length);
 633             for (Attribute a : array.values) {
 634                 a.accept(this);
 635             }
 636         }
 637     }
 638     AttributeWriter awriter = new AttributeWriter();
 639 
 640     /** Write a compound attribute excluding the &#39;@&#39; marker. */
 641     void writeCompoundAttribute(Attribute.Compound c) {
 642         databuf.appendChar(poolWriter.putDescriptor(c.type));
 643         databuf.appendChar(c.values.length());
 644         for (Pair&lt;Symbol.MethodSymbol,Attribute&gt; p : c.values) {
 645             databuf.appendChar(poolWriter.putName(p.fst.name));
 646             p.snd.accept(awriter);
 647         }
 648     }
 649 
 650     void writeTypeAnnotation(Attribute.TypeCompound c) {
 651         writePosition(c.position);
 652         writeCompoundAttribute(c);
 653     }
 654 
 655     void writePosition(TypeAnnotationPosition p) {
 656         databuf.appendByte(p.type.targetTypeValue()); // TargetType tag is a byte
 657         switch (p.type) {
 658         // instanceof
 659         case INSTANCEOF:
 660         // new expression
 661         case NEW:
 662         // constructor/method reference receiver
 663         case CONSTRUCTOR_REFERENCE:
 664         case METHOD_REFERENCE:
 665             databuf.appendChar(p.offset);
 666             break;
 667         // local variable
 668         case LOCAL_VARIABLE:
 669         // resource variable
 670         case RESOURCE_VARIABLE:
 671             databuf.appendChar(p.lvarOffset.length);  // for table length
 672             for (int i = 0; i &lt; p.lvarOffset.length; ++i) {
 673                 databuf.appendChar(p.lvarOffset[i]);
 674                 databuf.appendChar(p.lvarLength[i]);
 675                 databuf.appendChar(p.lvarIndex[i]);
 676             }
 677             break;
 678         // exception parameter
 679         case EXCEPTION_PARAMETER:
 680             databuf.appendChar(p.getExceptionIndex());
 681             break;
 682         // method receiver
 683         case METHOD_RECEIVER:
 684             // Do nothing
 685             break;
 686         // type parameter
 687         case CLASS_TYPE_PARAMETER:
 688         case METHOD_TYPE_PARAMETER:
 689             databuf.appendByte(p.parameter_index);
 690             break;
 691         // type parameter bound
 692         case CLASS_TYPE_PARAMETER_BOUND:
 693         case METHOD_TYPE_PARAMETER_BOUND:
 694             databuf.appendByte(p.parameter_index);
 695             databuf.appendByte(p.bound_index);
 696             break;
 697         // class extends or implements clause
 698         case CLASS_EXTENDS:
 699             databuf.appendChar(p.type_index);
 700             break;
 701         // throws
 702         case THROWS:
 703             databuf.appendChar(p.type_index);
 704             break;
 705         // method parameter
 706         case METHOD_FORMAL_PARAMETER:
 707             databuf.appendByte(p.parameter_index);
 708             break;
 709         // type cast
 710         case CAST:
 711         // method/constructor/reference type argument
 712         case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
 713         case METHOD_INVOCATION_TYPE_ARGUMENT:
 714         case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
 715         case METHOD_REFERENCE_TYPE_ARGUMENT:
 716             databuf.appendChar(p.offset);
 717             databuf.appendByte(p.type_index);
 718             break;
 719         // We don&#39;t need to worry about these
 720         case METHOD_RETURN:
 721         case FIELD:
 722             break;
 723         case UNKNOWN:
 724             throw new AssertionError(&quot;jvm.ClassWriter: UNKNOWN target type should never occur!&quot;);
 725         default:
 726             throw new AssertionError(&quot;jvm.ClassWriter: Unknown target type for position: &quot; + p);
 727         }
 728 
 729         { // Append location data for generics/arrays.
 730             databuf.appendByte(p.location.size());
 731             java.util.List&lt;Integer&gt; loc = TypeAnnotationPosition.getBinaryFromTypePath(p.location);
 732             for (int i : loc)
 733                 databuf.appendByte((byte)i);
 734         }
 735     }
 736 
 737 /**********************************************************************
 738  * Writing module attributes
 739  **********************************************************************/
 740 
 741     /** Write the Module attribute if needed.
 742      *  Returns the number of attributes written (0 or 1).
 743      */
 744     int writeModuleAttribute(ClassSymbol c) {
 745         ModuleSymbol m = (ModuleSymbol) c.owner;
 746 
 747         int alenIdx = writeAttr(names.Module);
 748 
 749         databuf.appendChar(poolWriter.putModule(m));
 750         databuf.appendChar(ModuleFlags.value(m.flags)); // module_flags
 751         databuf.appendChar(m.version != null ? poolWriter.putName(m.version) : 0);
 752 
 753         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
 754         for (RequiresDirective r: m.requires) {
 755             if (!r.flags.contains(RequiresFlag.EXTRA))
 756                 requires.add(r);
 757         }
 758         databuf.appendChar(requires.size());
 759         for (RequiresDirective r: requires) {
 760             databuf.appendChar(poolWriter.putModule(r.module));
 761             databuf.appendChar(RequiresFlag.value(r.flags));
 762             databuf.appendChar(r.module.version != null ? poolWriter.putName(r.module.version) : 0);
 763         }
 764 
 765         List&lt;ExportsDirective&gt; exports = m.exports;
 766         databuf.appendChar(exports.size());
 767         for (ExportsDirective e: exports) {
 768             databuf.appendChar(poolWriter.putPackage(e.packge));
 769             databuf.appendChar(ExportsFlag.value(e.flags));
 770             if (e.modules == null) {
 771                 databuf.appendChar(0);
 772             } else {
 773                 databuf.appendChar(e.modules.size());
 774                 for (ModuleSymbol msym: e.modules) {
 775                     databuf.appendChar(poolWriter.putModule(msym));
 776                 }
 777             }
 778         }
 779 
 780         List&lt;OpensDirective&gt; opens = m.opens;
 781         databuf.appendChar(opens.size());
 782         for (OpensDirective o: opens) {
 783             databuf.appendChar(poolWriter.putPackage(o.packge));
 784             databuf.appendChar(OpensFlag.value(o.flags));
 785             if (o.modules == null) {
 786                 databuf.appendChar(0);
 787             } else {
 788                 databuf.appendChar(o.modules.size());
 789                 for (ModuleSymbol msym: o.modules) {
 790                     databuf.appendChar(poolWriter.putModule(msym));
 791                 }
 792             }
 793         }
 794 
 795         List&lt;UsesDirective&gt; uses = m.uses;
 796         databuf.appendChar(uses.size());
 797         for (UsesDirective s: uses) {
 798             databuf.appendChar(poolWriter.putClass(s.service));
 799         }
 800 
 801         // temporary fix to merge repeated provides clause for same service;
 802         // eventually this should be disallowed when analyzing the module,
 803         // so that each service type only appears once.
 804         Map&lt;ClassSymbol, Set&lt;ClassSymbol&gt;&gt; mergedProvides = new LinkedHashMap&lt;&gt;();
 805         for (ProvidesDirective p : m.provides) {
 806             mergedProvides.computeIfAbsent(p.service, s -&gt; new LinkedHashSet&lt;&gt;()).addAll(p.impls);
 807         }
 808         databuf.appendChar(mergedProvides.size());
 809         mergedProvides.forEach((srvc, impls) -&gt; {
 810             databuf.appendChar(poolWriter.putClass(srvc));
 811             databuf.appendChar(impls.size());
 812             impls.forEach(impl -&gt; databuf.appendChar(poolWriter.putClass(impl)));
 813         });
 814 
 815         endAttr(alenIdx);
 816         return 1;
 817     }
 818 
 819 /**********************************************************************
 820  * Writing Objects
 821  **********************************************************************/
 822 
 823     /** Write &quot;inner classes&quot; attribute.
 824      */
 825     void writeInnerClasses() {
 826         int alenIdx = writeAttr(names.InnerClasses);
 827         databuf.appendChar(poolWriter.innerClasses.size());
 828         for (ClassSymbol inner : poolWriter.innerClasses) {
 829             inner.markAbstractIfNeeded(types);
 830             char flags = (char) adjustFlags(inner.flags_field);
 831             if ((flags &amp; INTERFACE) != 0) flags |= ABSTRACT; // Interfaces are always ABSTRACT
 832             flags &amp;= ~STRICTFP; //inner classes should not have the strictfp flag set.
 833             if (dumpInnerClassModifiers) {
 834                 PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
 835                 pw.println(&quot;INNERCLASS  &quot; + inner.name);
 836                 pw.println(&quot;---&quot; + flagNames(flags));
 837             }
 838             databuf.appendChar(poolWriter.putClass(inner));
 839             databuf.appendChar(
 840                 inner.owner.kind == TYP &amp;&amp; !inner.name.isEmpty() ? poolWriter.putClass((ClassSymbol)inner.owner) : 0);
 841             databuf.appendChar(
 842                 !inner.name.isEmpty() ? poolWriter.putName(inner.name) : 0);
 843             databuf.appendChar(flags);
 844         }
 845         endAttr(alenIdx);
 846     }
 847 
 848     int writeRecordAttribute(ClassSymbol csym) {
 849         int alenIdx = writeAttr(names.Record);
 850         Scope s = csym.members();
 851         databuf.appendChar(csym.getRecordComponents().size());
 852         for (VarSymbol v: csym.getRecordComponents()) {
 853             //databuf.appendChar(poolWriter.putMember(v.accessor.head.snd));
 854             databuf.appendChar(poolWriter.putName(v.name));
 855             databuf.appendChar(poolWriter.putDescriptor(v));
 856             int acountIdx = beginAttrs();
 857             int acount = 0;
 858             acount += writeMemberAttrs(v, true);
 859             endAttrs(acountIdx, acount);
 860         }
 861         endAttr(alenIdx);
 862         return 1;
 863     }
 864 
 865     /**
 866      * Write NestMembers attribute (if needed)
 867      */
 868     int writeNestMembersIfNeeded(ClassSymbol csym) {
 869         Set&lt;ClassSymbol&gt; nestedUnique = new LinkedHashSet&lt;&gt;();
 870         if (csym.owner.kind == PCK) {
 871             if (csym.isValue()) {
 872                 // reference projection is the host
 873             } else if (csym.isReferenceProjection()) {
 874                 ClassSymbol valueProjection = csym.valueProjection();
 875                 nestedUnique.add(valueProjection);
 876                 listNested(valueProjection, nestedUnique);
 877             } else {
 878                 listNested(csym, nestedUnique);
 879             }
 880             if (!nestedUnique.isEmpty()) {
 881                 int alenIdx = writeAttr(names.NestMembers);
 882                 databuf.appendChar(nestedUnique.size());
 883                 for (ClassSymbol s : nestedUnique) {
 884                     databuf.appendChar(poolWriter.putClass(s));
 885                 }
 886                 endAttr(alenIdx);
 887                 return 1;
 888             }
 889         }
 890         return 0;
 891     }
 892 
 893     /**
 894      * Write NestHost attribute (if needed)
 895      */
 896     int writeNestHostIfNeeded(ClassSymbol csym) {
 897         if (csym.owner.kind != PCK || csym.isValue()) {
 898             int alenIdx = writeAttr(names.NestHost);
 899             ClassSymbol outerMost = csym.outermostClass();
 900             if (outerMost.isValue()) {
 901                 outerMost = outerMost.referenceProjection();
 902             }
 903             databuf.appendChar(poolWriter.putClass(outerMost));
 904             endAttr(alenIdx);
 905             return 1;
 906         }
 907         return 0;
 908     }
 909 
 910     private void listNested(Symbol sym, Set&lt;ClassSymbol&gt; seen) {
 911         if (sym.kind != TYP) return;
 912         ClassSymbol csym = (ClassSymbol)sym;
 913         if (csym.owner.kind != PCK) {
 914             seen.add(csym);
 915             if (csym.isValue()) {
 916                 seen.add(csym.referenceProjection());
 917             }
 918         }
 919         if (csym.members() != null) {
 920             for (Symbol s : sym.members().getSymbols()) {
 921                 listNested(s, seen);
 922             }
 923         }
 924         if (csym.trans_local != null) {
 925             for (Symbol s : csym.trans_local) {
 926                 listNested(s, seen);
 927             }
 928         }
 929     }
 930 
 931     /** Write &quot;PermittedSubclasses&quot; attribute.
 932      */
 933     int writePermittedSubclassesIfNeeded(ClassSymbol csym) {
 934         if (csym.permitted.nonEmpty()) {
 935             int alenIdx = writeAttr(names.PermittedSubclasses);
 936             databuf.appendChar(csym.permitted.size());
 937             for (Symbol c : csym.permitted) {
 938                 databuf.appendChar(poolWriter.putClass((ClassSymbol) c));
 939             }
 940             endAttr(alenIdx);
 941             return 1;
 942         }
 943         return 0;
 944     }
 945 
 946     /** Write &quot;bootstrapMethods&quot; attribute.
 947      */
 948     void writeBootstrapMethods() {
 949         int alenIdx = writeAttr(names.BootstrapMethods);
 950         databuf.appendChar(poolWriter.bootstrapMethods.size());
 951         for (BsmKey bsmKey : poolWriter.bootstrapMethods.keySet()) {
 952             //write BSM handle
 953             databuf.appendChar(poolWriter.putConstant(bsmKey.bsm));
 954             LoadableConstant[] uniqueArgs = bsmKey.staticArgs;
 955             //write static args length
 956             databuf.appendChar(uniqueArgs.length);
 957             //write static args array
 958             for (LoadableConstant arg : uniqueArgs) {
 959                 databuf.appendChar(poolWriter.putConstant(arg));
 960             }
 961         }
 962         endAttr(alenIdx);
 963     }
 964 
 965     /** Write field symbol, entering all references into constant pool.
 966      */
 967     void writeField(VarSymbol v) {
 968         int flags = adjustFlags(v.flags());
 969         databuf.appendChar(flags);
 970         if (dumpFieldModifiers) {
 971             PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
 972             pw.println(&quot;FIELD  &quot; + v.name);
 973             pw.println(&quot;---&quot; + flagNames(v.flags()));
 974         }
 975         databuf.appendChar(poolWriter.putName(v.name));
 976         databuf.appendChar(poolWriter.putDescriptor(v));
 977         int acountIdx = beginAttrs();
 978         int acount = 0;
 979         if (v.getConstValue() != null) {
 980             int alenIdx = writeAttr(names.ConstantValue);
 981             databuf.appendChar(poolWriter.putConstant(v.getConstValue()));
 982             endAttr(alenIdx);
 983             acount++;
 984         }
 985         acount += writeMemberAttrs(v, false);
 986         acount += writeExtraAttributes(v);
 987         endAttrs(acountIdx, acount);
 988     }
 989 
 990     /** Write method symbol, entering all references into constant pool.
 991      */
 992     void writeMethod(MethodSymbol m) {
 993         int flags = adjustFlags(m.flags());
 994         databuf.appendChar(flags);
 995         if (dumpMethodModifiers) {
 996             PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
 997             pw.println(&quot;METHOD  &quot; + m.name);
 998             pw.println(&quot;---&quot; + flagNames(m.flags()));
 999         }
1000         databuf.appendChar(poolWriter.putName(m.name));
1001         databuf.appendChar(poolWriter.putDescriptor(m));
1002         int acountIdx = beginAttrs();
1003         int acount = 0;
1004         if (m.code != null) {
1005             int alenIdx = writeAttr(names.Code);
1006             writeCode(m.code);
1007             m.code = null; // to conserve space
1008             endAttr(alenIdx);
1009             acount++;
1010         }
1011         List&lt;Type&gt; thrown = m.erasure(types).getThrownTypes();
1012         if (thrown.nonEmpty()) {
1013             int alenIdx = writeAttr(names.Exceptions);
1014             databuf.appendChar(thrown.length());
1015             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1016                 databuf.appendChar(poolWriter.putClass(l.head));
1017             endAttr(alenIdx);
1018             acount++;
1019         }
1020         if (m.defaultValue != null) {
1021             int alenIdx = writeAttr(names.AnnotationDefault);
1022             m.defaultValue.accept(awriter);
1023             endAttr(alenIdx);
1024             acount++;
1025         }
1026         if (target.hasMethodParameters() &amp;&amp; (options.isSet(PARAMETERS) || m.isConstructor() &amp;&amp; (m.flags_field &amp; RECORD) != 0)) {
1027             if (!m.isLambdaMethod()) // Per JDK-8138729, do not emit parameters table for lambda bodies.
1028                 acount += writeMethodParametersAttr(m);
1029         }
1030         acount += writeMemberAttrs(m, false);
1031         if (!m.isLambdaMethod())
1032             acount += writeParameterAttrs(m.params);
1033         acount += writeExtraAttributes(m);
1034         endAttrs(acountIdx, acount);
1035     }
1036 
1037     /** Write code attribute of method.
1038      */
1039     void writeCode(Code code) {
1040         databuf.appendChar(code.max_stack);
1041         databuf.appendChar(code.max_locals);
1042         databuf.appendInt(code.cp);
1043         databuf.appendBytes(code.code, 0, code.cp);
1044         databuf.appendChar(code.catchInfo.length());
1045         for (List&lt;char[]&gt; l = code.catchInfo.toList();
1046              l.nonEmpty();
1047              l = l.tail) {
1048             for (int i = 0; i &lt; l.head.length; i++)
1049                 databuf.appendChar(l.head[i]);
1050         }
1051         int acountIdx = beginAttrs();
1052         int acount = 0;
1053 
1054         if (code.lineInfo.nonEmpty()) {
1055             int alenIdx = writeAttr(names.LineNumberTable);
1056             databuf.appendChar(code.lineInfo.length());
1057             for (List&lt;char[]&gt; l = code.lineInfo.reverse();
1058                  l.nonEmpty();
1059                  l = l.tail)
1060                 for (int i = 0; i &lt; l.head.length; i++)
1061                     databuf.appendChar(l.head[i]);
1062             endAttr(alenIdx);
1063             acount++;
1064         }
1065 
1066         if (genCrt &amp;&amp; (code.crt != null)) {
1067             CRTable crt = code.crt;
1068             int alenIdx = writeAttr(names.CharacterRangeTable);
1069             int crtIdx = beginAttrs();
1070             int crtEntries = crt.writeCRT(databuf, code.lineMap, log);
1071             endAttrs(crtIdx, crtEntries);
1072             endAttr(alenIdx);
1073             acount++;
1074         }
1075 
1076         // counter for number of generic local variables
1077         if (code.varDebugInfo &amp;&amp; code.varBufferSize &gt; 0) {
1078             int nGenericVars = 0;
1079             int alenIdx = writeAttr(names.LocalVariableTable);
1080             databuf.appendChar(code.getLVTSize());
1081             for (int i=0; i&lt;code.varBufferSize; i++) {
1082                 Code.LocalVar var = code.varBuffer[i];
1083 
1084                 for (Code.LocalVar.Range r: var.aliveRanges) {
1085                     // write variable info
1086                     Assert.check(r.start_pc &gt;= 0
1087                             &amp;&amp; r.start_pc &lt;= code.cp);
1088                     databuf.appendChar(r.start_pc);
1089                     Assert.check(r.length &gt; 0
1090                             &amp;&amp; (r.start_pc + r.length) &lt;= code.cp);
1091                     databuf.appendChar(r.length);
1092                     VarSymbol sym = var.sym;
1093                     databuf.appendChar(poolWriter.putName(sym.name));
1094                     databuf.appendChar(poolWriter.putDescriptor(sym));
1095                     databuf.appendChar(var.reg);
1096                     if (needsLocalVariableTypeEntry(var.sym.type)) {
1097                         nGenericVars++;
1098                     }
1099                 }
1100             }
1101             endAttr(alenIdx);
1102             acount++;
1103 
1104             if (nGenericVars &gt; 0) {
1105                 alenIdx = writeAttr(names.LocalVariableTypeTable);
1106                 databuf.appendChar(nGenericVars);
1107                 int count = 0;
1108 
1109                 for (int i=0; i&lt;code.varBufferSize; i++) {
1110                     Code.LocalVar var = code.varBuffer[i];
1111                     VarSymbol sym = var.sym;
1112                     if (!needsLocalVariableTypeEntry(sym.type))
1113                         continue;
1114                     for (Code.LocalVar.Range r : var.aliveRanges) {
1115                         // write variable info
1116                         databuf.appendChar(r.start_pc);
1117                         databuf.appendChar(r.length);
1118                         databuf.appendChar(poolWriter.putName(sym.name));
1119                         databuf.appendChar(poolWriter.putSignature(sym));
1120                         databuf.appendChar(var.reg);
1121                         count++;
1122                     }
1123                 }
1124                 Assert.check(count == nGenericVars);
1125                 endAttr(alenIdx);
1126                 acount++;
1127             }
1128         }
1129 
1130         if (code.stackMapBufferSize &gt; 0) {
1131             if (debugstackmap) System.out.println(&quot;Stack map for &quot; + code.meth);
1132             int alenIdx = writeAttr(code.stackMap.getAttributeName(names));
1133             writeStackMap(code);
1134             endAttr(alenIdx);
1135             acount++;
1136         }
1137 
1138         acount += writeTypeAnnotations(code.meth.getRawTypeAttributes(), true);
1139 
1140         endAttrs(acountIdx, acount);
1141     }
1142     //where
1143     private boolean needsLocalVariableTypeEntry(Type t) {
1144         //a local variable needs a type-entry if its type T is generic
1145         //(i.e. |T| != T) and if it&#39;s not an non-denotable type (non-denotable
1146         // types are not supported in signature attribute grammar!)
1147         return !types.isSameType(t, types.erasure(t)) &amp;&amp;
1148                 check.checkDenotable(t);
1149     }
1150 
1151     void writeStackMap(Code code) {
1152         int nframes = code.stackMapBufferSize;
1153         if (debugstackmap) System.out.println(&quot; nframes = &quot; + nframes);
1154         databuf.appendChar(nframes);
1155 
1156         switch (code.stackMap) {
1157         case CLDC:
1158             for (int i=0; i&lt;nframes; i++) {
1159                 if (debugstackmap) System.out.print(&quot;  &quot; + i + &quot;:&quot;);
1160                 Code.StackMapFrame frame = code.stackMapBuffer[i];
1161 
1162                 // output PC
1163                 if (debugstackmap) System.out.print(&quot; pc=&quot; + frame.pc);
1164                 databuf.appendChar(frame.pc);
1165 
1166                 // output locals
1167                 int localCount = 0;
1168                 for (int j=0; j&lt;frame.locals.length;
1169                      j += Code.width(frame.locals[j])) {
1170                     localCount++;
1171                 }
1172                 if (debugstackmap) System.out.print(&quot; nlocals=&quot; +
1173                                                     localCount);
1174                 databuf.appendChar(localCount);
1175                 for (int j=0; j&lt;frame.locals.length;
1176                      j += Code.width(frame.locals[j])) {
1177                     if (debugstackmap) System.out.print(&quot; local[&quot; + j + &quot;]=&quot;);
1178                     writeStackMapType(frame.locals[j]);
1179                 }
1180 
1181                 // output stack
1182                 int stackCount = 0;
1183                 for (int j=0; j&lt;frame.stack.length;
1184                      j += Code.width(frame.stack[j])) {
1185                     stackCount++;
1186                 }
1187                 if (debugstackmap) System.out.print(&quot; nstack=&quot; +
1188                                                     stackCount);
1189                 databuf.appendChar(stackCount);
1190                 for (int j=0; j&lt;frame.stack.length;
1191                      j += Code.width(frame.stack[j])) {
1192                     if (debugstackmap) System.out.print(&quot; stack[&quot; + j + &quot;]=&quot;);
1193                     writeStackMapType(frame.stack[j]);
1194                 }
1195                 if (debugstackmap) System.out.println();
1196             }
1197             break;
1198         case JSR202: {
1199             Assert.checkNull(code.stackMapBuffer);
1200             for (int i=0; i&lt;nframes; i++) {
1201                 if (debugstackmap) System.out.print(&quot;  &quot; + i + &quot;:&quot;);
1202                 StackMapTableFrame frame = code.stackMapTableBuffer[i];
1203                 frame.write(this);
1204                 if (debugstackmap) System.out.println();
1205             }
1206             break;
1207         }
1208         default:
1209             throw new AssertionError(&quot;Unexpected stackmap format value&quot;);
1210         }
1211     }
1212 
1213         //where
1214         void writeStackMapType(Type t) {
1215             if (t == null) {
1216                 if (debugstackmap) System.out.print(&quot;empty&quot;);
1217                 databuf.appendByte(0);
1218             }
1219             else switch(t.getTag()) {
1220             case BYTE:
1221             case CHAR:
1222             case SHORT:
1223             case INT:
1224             case BOOLEAN:
1225                 if (debugstackmap) System.out.print(&quot;int&quot;);
1226                 databuf.appendByte(1);
1227                 break;
1228             case FLOAT:
1229                 if (debugstackmap) System.out.print(&quot;float&quot;);
1230                 databuf.appendByte(2);
1231                 break;
1232             case DOUBLE:
1233                 if (debugstackmap) System.out.print(&quot;double&quot;);
1234                 databuf.appendByte(3);
1235                 break;
1236             case LONG:
1237                 if (debugstackmap) System.out.print(&quot;long&quot;);
1238                 databuf.appendByte(4);
1239                 break;
1240             case BOT: // null
1241                 if (debugstackmap) System.out.print(&quot;null&quot;);
1242                 databuf.appendByte(5);
1243                 break;
1244             case CLASS:
1245             case ARRAY:
1246                 if (debugstackmap) System.out.print(&quot;object(&quot; + types.erasure(t).tsym + &quot;)&quot;);
1247                 databuf.appendByte(7);
1248                 databuf.appendChar(types.isValue(t) ? poolWriter.putClass(new ConstantPoolQType(types.erasure(t), types)) : poolWriter.putClass(types.erasure(t)));
1249                 break;
1250             case TYPEVAR:
1251                 if (debugstackmap) System.out.print(&quot;object(&quot; + types.erasure(t).tsym + &quot;)&quot;);
1252                 databuf.appendByte(7);
1253                 databuf.appendChar(poolWriter.putClass(types.erasure(t)));
1254                 break;
1255             case UNINITIALIZED_THIS:
1256                 if (debugstackmap) System.out.print(&quot;uninit_this&quot;);
1257                 databuf.appendByte(6);
1258                 break;
1259             case UNINITIALIZED_OBJECT:
1260                 { UninitializedType uninitType = (UninitializedType)t;
1261                 databuf.appendByte(8);
1262                 if (debugstackmap) System.out.print(&quot;uninit_object@&quot; + uninitType.offset);
1263                 databuf.appendChar(uninitType.offset);
1264                 }
1265                 break;
1266             default:
1267                 throw new AssertionError();
1268             }
1269         }
1270 
1271     /** An entry in the JSR202 StackMapTable */
1272     abstract static class StackMapTableFrame {
1273         abstract int getFrameType();
1274 
1275         void write(ClassWriter writer) {
1276             int frameType = getFrameType();
1277             writer.databuf.appendByte(frameType);
1278             if (writer.debugstackmap) System.out.print(&quot; frame_type=&quot; + frameType);
1279         }
1280 
1281         static class SameFrame extends StackMapTableFrame {
1282             final int offsetDelta;
1283             SameFrame(int offsetDelta) {
1284                 this.offsetDelta = offsetDelta;
1285             }
1286             int getFrameType() {
1287                 return (offsetDelta &lt; SAME_FRAME_SIZE) ? offsetDelta : SAME_FRAME_EXTENDED;
1288             }
1289             @Override
1290             void write(ClassWriter writer) {
1291                 super.write(writer);
1292                 if (getFrameType() == SAME_FRAME_EXTENDED) {
1293                     writer.databuf.appendChar(offsetDelta);
1294                     if (writer.debugstackmap){
1295                         System.out.print(&quot; offset_delta=&quot; + offsetDelta);
1296                     }
1297                 }
1298             }
1299         }
1300 
1301         static class SameLocals1StackItemFrame extends StackMapTableFrame {
1302             final int offsetDelta;
1303             final Type stack;
1304             SameLocals1StackItemFrame(int offsetDelta, Type stack) {
1305                 this.offsetDelta = offsetDelta;
1306                 this.stack = stack;
1307             }
1308             int getFrameType() {
1309                 return (offsetDelta &lt; SAME_FRAME_SIZE) ?
1310                        (SAME_FRAME_SIZE + offsetDelta) :
1311                        SAME_LOCALS_1_STACK_ITEM_EXTENDED;
1312             }
1313             @Override
1314             void write(ClassWriter writer) {
1315                 super.write(writer);
1316                 if (getFrameType() == SAME_LOCALS_1_STACK_ITEM_EXTENDED) {
1317                     writer.databuf.appendChar(offsetDelta);
1318                     if (writer.debugstackmap) {
1319                         System.out.print(&quot; offset_delta=&quot; + offsetDelta);
1320                     }
1321                 }
1322                 if (writer.debugstackmap) {
1323                     System.out.print(&quot; stack[&quot; + 0 + &quot;]=&quot;);
1324                 }
1325                 writer.writeStackMapType(stack);
1326             }
1327         }
1328 
1329         static class ChopFrame extends StackMapTableFrame {
1330             final int frameType;
1331             final int offsetDelta;
1332             ChopFrame(int frameType, int offsetDelta) {
1333                 this.frameType = frameType;
1334                 this.offsetDelta = offsetDelta;
1335             }
1336             int getFrameType() { return frameType; }
1337             @Override
1338             void write(ClassWriter writer) {
1339                 super.write(writer);
1340                 writer.databuf.appendChar(offsetDelta);
1341                 if (writer.debugstackmap) {
1342                     System.out.print(&quot; offset_delta=&quot; + offsetDelta);
1343                 }
1344             }
1345         }
1346 
1347         static class AppendFrame extends StackMapTableFrame {
1348             final int frameType;
1349             final int offsetDelta;
1350             final Type[] locals;
1351             AppendFrame(int frameType, int offsetDelta, Type[] locals) {
1352                 this.frameType = frameType;
1353                 this.offsetDelta = offsetDelta;
1354                 this.locals = locals;
1355             }
1356             int getFrameType() { return frameType; }
1357             @Override
1358             void write(ClassWriter writer) {
1359                 super.write(writer);
1360                 writer.databuf.appendChar(offsetDelta);
1361                 if (writer.debugstackmap) {
1362                     System.out.print(&quot; offset_delta=&quot; + offsetDelta);
1363                 }
1364                 for (int i=0; i&lt;locals.length; i++) {
1365                      if (writer.debugstackmap) System.out.print(&quot; locals[&quot; + i + &quot;]=&quot;);
1366                      writer.writeStackMapType(locals[i]);
1367                 }
1368             }
1369         }
1370 
1371         static class FullFrame extends StackMapTableFrame {
1372             final int offsetDelta;
1373             final Type[] locals;
1374             final Type[] stack;
1375             FullFrame(int offsetDelta, Type[] locals, Type[] stack) {
1376                 this.offsetDelta = offsetDelta;
1377                 this.locals = locals;
1378                 this.stack = stack;
1379             }
1380             int getFrameType() { return FULL_FRAME; }
1381             @Override
1382             void write(ClassWriter writer) {
1383                 super.write(writer);
1384                 writer.databuf.appendChar(offsetDelta);
1385                 writer.databuf.appendChar(locals.length);
1386                 if (writer.debugstackmap) {
1387                     System.out.print(&quot; offset_delta=&quot; + offsetDelta);
1388                     System.out.print(&quot; nlocals=&quot; + locals.length);
1389                 }
1390                 for (int i=0; i&lt;locals.length; i++) {
1391                     if (writer.debugstackmap) System.out.print(&quot; locals[&quot; + i + &quot;]=&quot;);
1392                     writer.writeStackMapType(locals[i]);
1393                 }
1394 
1395                 writer.databuf.appendChar(stack.length);
1396                 if (writer.debugstackmap) { System.out.print(&quot; nstack=&quot; + stack.length); }
1397                 for (int i=0; i&lt;stack.length; i++) {
1398                     if (writer.debugstackmap) System.out.print(&quot; stack[&quot; + i + &quot;]=&quot;);
1399                     writer.writeStackMapType(stack[i]);
1400                 }
1401             }
1402         }
1403 
1404        /** Compare this frame with the previous frame and produce
1405         *  an entry of compressed stack map frame. */
1406         static StackMapTableFrame getInstance(Code.StackMapFrame this_frame,
1407                                               int prev_pc,
1408                                               Type[] prev_locals,
1409                                               Types types) {
1410             Type[] locals = this_frame.locals;
1411             Type[] stack = this_frame.stack;
1412             int offset_delta = this_frame.pc - prev_pc - 1;
1413             if (stack.length == 1) {
1414                 if (locals.length == prev_locals.length
1415                     &amp;&amp; compare(prev_locals, locals, types) == 0) {
1416                     return new SameLocals1StackItemFrame(offset_delta, stack[0]);
1417                 }
1418             } else if (stack.length == 0) {
1419                 int diff_length = compare(prev_locals, locals, types);
1420                 if (diff_length == 0) {
1421                     return new SameFrame(offset_delta);
1422                 } else if (-MAX_LOCAL_LENGTH_DIFF &lt; diff_length &amp;&amp; diff_length &lt; 0) {
1423                     // APPEND
1424                     Type[] local_diff = new Type[-diff_length];
1425                     for (int i=prev_locals.length, j=0; i&lt;locals.length; i++,j++) {
1426                         local_diff[j] = locals[i];
1427                     }
1428                     return new AppendFrame(SAME_FRAME_EXTENDED - diff_length,
1429                                            offset_delta,
1430                                            local_diff);
1431                 } else if (0 &lt; diff_length &amp;&amp; diff_length &lt; MAX_LOCAL_LENGTH_DIFF) {
1432                     // CHOP
1433                     return new ChopFrame(SAME_FRAME_EXTENDED - diff_length,
1434                                          offset_delta);
1435                 }
1436             }
1437             // FULL_FRAME
1438             return new FullFrame(offset_delta, locals, stack);
1439         }
1440 
1441         static boolean isInt(Type t) {
1442             return (t.getTag().isStrictSubRangeOf(INT)  || t.hasTag(BOOLEAN));
1443         }
1444 
1445         static boolean isSameType(Type t1, Type t2, Types types) {
1446             if (t1 == null) { return t2 == null; }
1447             if (t2 == null) { return false; }
1448 
1449             if (isInt(t1) &amp;&amp; isInt(t2)) { return true; }
1450 
1451             if (t1.hasTag(UNINITIALIZED_THIS)) {
1452                 return t2.hasTag(UNINITIALIZED_THIS);
1453             } else if (t1.hasTag(UNINITIALIZED_OBJECT)) {
1454                 if (t2.hasTag(UNINITIALIZED_OBJECT)) {
1455                     return ((UninitializedType)t1).offset == ((UninitializedType)t2).offset;
1456                 } else {
1457                     return false;
1458                 }
1459             } else if (t2.hasTag(UNINITIALIZED_THIS) || t2.hasTag(UNINITIALIZED_OBJECT)) {
1460                 return false;
1461             }
1462 
1463             return types.isSameType(t1, t2);
1464         }
1465 
1466         static int compare(Type[] arr1, Type[] arr2, Types types) {
1467             int diff_length = arr1.length - arr2.length;
1468             if (diff_length &gt; MAX_LOCAL_LENGTH_DIFF || diff_length &lt; -MAX_LOCAL_LENGTH_DIFF) {
1469                 return Integer.MAX_VALUE;
1470             }
1471             int len = (diff_length &gt; 0) ? arr2.length : arr1.length;
1472             for (int i=0; i&lt;len; i++) {
1473                 if (!isSameType(arr1[i], arr2[i], types)) {
1474                     return Integer.MAX_VALUE;
1475                 }
1476             }
1477             return diff_length;
1478         }
1479     }
1480 
1481     void writeFields(Scope s) {
1482         // process them in reverse sibling order;
1483         // i.e., process them in declaration order.
1484         List&lt;VarSymbol&gt; vars = List.nil();
1485         for (Symbol sym : s.getSymbols(NON_RECURSIVE)) {
1486             if (sym.kind == VAR) vars = vars.prepend((VarSymbol)sym);
1487         }
1488         while (vars.nonEmpty()) {
1489             writeField(vars.head);
1490             vars = vars.tail;
1491         }
1492     }
1493 
1494     void writeMethods(Scope s) {
1495         List&lt;MethodSymbol&gt; methods = List.nil();
1496         for (Symbol sym : s.getSymbols(NON_RECURSIVE)) {
1497             if (sym.kind == MTH &amp;&amp; (sym.flags() &amp; HYPOTHETICAL) == 0)
1498                 methods = methods.prepend((MethodSymbol)sym);
1499         }
1500         while (methods.nonEmpty()) {
1501             writeMethod(methods.head);
1502             methods = methods.tail;
1503         }
1504     }
1505 
1506     /** Emit a class file for a given class.
1507      *  @param c      The class from which a class file is generated.
1508      */
1509     public JavaFileObject writeClass(ClassSymbol c)
1510         throws IOException, PoolOverflow, StringOverflow
1511     {
1512         JavaFileObject javaFileObject = writeClassInternal(c);
1513         if (c.isValue()) {
1514             ClassSymbol refProjection = c.referenceProjection();
1515             refProjection.flags_field = (refProjection.flags_field &amp; ~FINAL) | ABSTRACT;
1516             writeClassInternal(refProjection);
1517         }
1518         return javaFileObject;
1519     }
1520 
1521     private JavaFileObject writeClassInternal(ClassSymbol c)
1522         throws IOException, PoolOverflow, StringOverflow
1523     {
1524         String name = (c.owner.kind == MDL ? c.name : c.flatname).toString();
1525         Location outLocn;
1526         if (multiModuleMode) {
1527             ModuleSymbol msym = c.owner.kind == MDL ? (ModuleSymbol) c.owner : c.packge().modle;
1528             outLocn = fileManager.getLocationForModule(CLASS_OUTPUT, msym.name.toString());
1529         } else {
1530             outLocn = CLASS_OUTPUT;
1531         }
1532         JavaFileObject outFile
1533             = fileManager.getJavaFileForOutput(outLocn,
1534                                                name,
1535                                                JavaFileObject.Kind.CLASS,
1536                                                c.sourcefile);
1537         OutputStream out = outFile.openOutputStream();
1538         try {
1539             writeClassFile(out, c);
1540             if (verbose)
1541                 log.printVerbose(&quot;wrote.file&quot;, outFile.getName());
1542             out.close();
1543             out = null;
1544         } catch (InvalidSignatureException ex) {
1545             log.error(Errors.CannotGenerateClass(c, Fragments.IllegalSignature(c, ex.type())));
1546         } finally {
1547             if (out != null) {
1548                 // if we are propagating an exception, delete the file
1549                 out.close();
1550                 outFile.delete();
1551                 outFile = null;
1552             }
1553         }
1554         return outFile; // may be null if write failed
1555     }
1556 
1557     /** Write class `c&#39; to outstream `out&#39;.
1558      */
1559     public void writeClassFile(OutputStream out, ClassSymbol c)
1560         throws IOException, PoolOverflow, StringOverflow {
1561         Assert.check((c.flags() &amp; COMPOUND) == 0);
1562         databuf.reset();
1563         poolbuf.reset();
1564 
1565         Type supertype = c.isValue() ? c.type.referenceProjection() : types.supertype(c.type);
1566         List&lt;Type&gt; interfaces = c.isValue() ? List.nil() : types.interfaces(c.type);
1567         List&lt;Type&gt; typarams = c.type.getTypeArguments();
1568 
1569         int flags;
1570         if (c.owner.kind == MDL) {
1571             flags = ACC_MODULE;
1572         } else {
1573             flags = adjustFlags(c.flags() &amp; ~DEFAULT);
1574             if ((flags &amp; PROTECTED) != 0) flags |= PUBLIC;
<a name="1" id="anc1"></a><span class="line-modified">1575             flags = flags &amp; (ClassFlags | ACC_VALUE) &amp; ~STRICTFP;</span>
1576             if ((flags &amp; INTERFACE) == 0) flags |= ACC_SUPER;
1577         }
1578 
1579         if (dumpClassModifiers) {
1580             PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
1581             pw.println();
1582             pw.println(&quot;CLASSFILE  &quot; + c.getQualifiedName());
1583             pw.println(&quot;---&quot; + flagNames(flags));
1584         }
1585         databuf.appendChar(flags);
1586 
1587         if (c.owner.kind == MDL) {
1588             PackageSymbol unnamed = ((ModuleSymbol) c.owner).unnamedPackage;
1589             databuf.appendChar(poolWriter.putClass(new ClassSymbol(0, names.module_info, unnamed)));
1590         } else {
1591             databuf.appendChar(poolWriter.putClass(c));
1592         }
1593         databuf.appendChar(supertype.hasTag(CLASS) ? poolWriter.putClass((ClassSymbol)supertype.tsym) : 0);
1594         databuf.appendChar(interfaces.length());
1595         for (List&lt;Type&gt; l = interfaces; l.nonEmpty(); l = l.tail)
1596             databuf.appendChar(poolWriter.putClass((ClassSymbol)l.head.tsym));
1597         int fieldsCount = 0;
1598         int methodsCount = 0;
1599         boolean referenceProjection = c.isReferenceProjection();
1600         if (!referenceProjection) {
1601             for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {
1602                 switch (sym.kind) {
1603                     case VAR:
1604                         fieldsCount++;
1605                         break;
1606                     case MTH:
1607                         if ((sym.flags() &amp; HYPOTHETICAL) == 0) methodsCount++;
1608                         break;
1609                     case TYP:
1610                         poolWriter.enterInner((ClassSymbol)sym);
1611                         break;
1612                     default:
1613                         Assert.error();
1614                 }
1615             }
1616 
1617             if (c.trans_local != null) {
1618                 for (ClassSymbol local : c.trans_local) {
1619                     poolWriter.enterInner(local);
1620                 }
1621             }
1622         }
1623 
1624         databuf.appendChar(fieldsCount);
1625         if (!referenceProjection)
1626             writeFields(c.members());
1627         databuf.appendChar(methodsCount);
1628         if (!referenceProjection)
1629             writeMethods(c.members());
1630 
1631         int acountIdx = beginAttrs();
1632         int acount = 0;
1633 
1634         boolean sigReq =
1635             typarams.length() != 0 || supertype.allparams().length() != 0;
1636         for (List&lt;Type&gt; l = interfaces; !sigReq &amp;&amp; l.nonEmpty(); l = l.tail)
1637             sigReq = l.head.allparams().length() != 0;
1638         if (sigReq) {
1639             int alenIdx = writeAttr(names.Signature);
1640             databuf.appendChar(poolWriter.putSignature(c));
1641             endAttr(alenIdx);
1642             acount++;
1643         }
1644 
1645         if (c.sourcefile != null &amp;&amp; emitSourceFile) {
1646             int alenIdx = writeAttr(names.SourceFile);
1647             // WHM 6/29/1999: Strip file path prefix.  We do it here at
1648             // the last possible moment because the sourcefile may be used
1649             // elsewhere in error diagnostics. Fixes 4241573.
1650             String simpleName = PathFileObject.getSimpleName(c.sourcefile);
1651             databuf.appendChar(poolWriter.putName(names.fromString(simpleName)));
1652             endAttr(alenIdx);
1653             acount++;
1654         }
1655 
1656         if (genCrt) {
1657             // Append SourceID attribute
1658             int alenIdx = writeAttr(names.SourceID);
1659             databuf.appendChar(poolWriter.putName(names.fromString(Long.toString(getLastModified(c.sourcefile)))));
1660             endAttr(alenIdx);
1661             acount++;
1662             // Append CompilationID attribute
1663             alenIdx = writeAttr(names.CompilationID);
1664             databuf.appendChar(poolWriter.putName(names.fromString(Long.toString(System.currentTimeMillis()))));
1665             endAttr(alenIdx);
1666             acount++;
1667         }
1668 
1669         acount += writeFlagAttrs(c.flags());
1670         acount += writeJavaAnnotations(c.getRawAttributes());
1671         acount += writeTypeAnnotations(c.getRawTypeAttributes(), false);
1672         acount += writeEnclosingMethodAttribute(c);
1673         if (c.owner.kind == MDL) {
1674             acount += writeModuleAttribute(c);
1675             acount += writeFlagAttrs(c.owner.flags() &amp; ~DEPRECATED);
1676         }
1677         acount += writeExtraClassAttributes(c);
1678         acount += writeExtraAttributes(c);
1679 
1680         poolbuf.appendInt(JAVA_MAGIC);
1681         if (preview.isEnabled()) {
1682             poolbuf.appendChar(ClassFile.PREVIEW_MINOR_VERSION);
1683         } else {
1684             poolbuf.appendChar(target.minorVersion);
1685         }
1686         poolbuf.appendChar(target.majorVersion);
1687 
1688         if (c.owner.kind != MDL) {
1689             if (target.hasNestmateAccess()) {
1690                 acount += writeNestMembersIfNeeded(c);
1691                 acount += writeNestHostIfNeeded(c);
1692             }
1693         }
1694 
1695         if (c.isRecord()) {
1696             acount += writeRecordAttribute(c);
1697         }
1698 
1699         if (target.hasSealedClasses()) {
1700             acount += writePermittedSubclassesIfNeeded(c);
1701         }
1702 
1703         if (!poolWriter.bootstrapMethods.isEmpty()) {
1704             writeBootstrapMethods();
1705             acount++;
1706         }
1707 
1708         if (!poolWriter.innerClasses.isEmpty()) {
1709             writeInnerClasses();
1710             acount++;
1711         }
1712 
1713         endAttrs(acountIdx, acount);
1714 
1715         out.write(poolbuf.elems, 0, poolbuf.length);
1716 
1717         poolWriter.writePool(out);
1718         poolWriter.reset(); // to save space
1719 
1720         out.write(databuf.elems, 0, databuf.length);
1721     }
1722 
1723      /**Allows subclasses to write additional class attributes
1724       *
1725       * @return the number of attributes written
1726       */
1727     protected int writeExtraClassAttributes(ClassSymbol c) {
1728         return 0;
1729     }
1730 
1731     /**Allows friends to write additional attributes
1732      *
1733      * @return the number of attributes written
1734      */
1735     protected int writeExtraAttributes(Symbol sym) {
1736         int i = 0;
1737         for (ToIntFunction&lt;Symbol&gt; hook : extraAttributeHooks) {
1738             i += hook.applyAsInt(sym);
1739         }
1740         return i;
1741     }
1742 
1743     int adjustFlags(final long flags) {
1744         int result = (int)flags;
1745 
1746         if ((flags &amp; BRIDGE) != 0)
1747             result |= ACC_BRIDGE;
1748         if ((flags &amp; VARARGS) != 0)
1749             result |= ACC_VARARGS;
1750         if ((flags &amp; DEFAULT) != 0)
1751             result &amp;= ~ABSTRACT;
1752         if ((flags &amp; VALUE) != 0)
<a name="2" id="anc2"></a><span class="line-modified">1753             result |= ACC_VALUE;</span>
1754         return result;
1755     }
1756 
1757     long getLastModified(FileObject filename) {
1758         long mod = 0;
1759         try {
1760             mod = filename.getLastModified();
1761         } catch (SecurityException e) {
1762             throw new AssertionError(&quot;CRT: couldn&#39;t get source file modification date: &quot; + e.getMessage());
1763         }
1764         return mod;
1765     }
1766 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>