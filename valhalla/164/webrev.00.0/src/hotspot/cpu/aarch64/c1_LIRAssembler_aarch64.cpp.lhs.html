<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;c1/c1_CodeStubs.hpp&quot;
  30 #include &quot;c1/c1_Compilation.hpp&quot;
  31 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  32 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  33 #include &quot;c1/c1_Runtime1.hpp&quot;
  34 #include &quot;c1/c1_ValueStack.hpp&quot;
  35 #include &quot;ci/ciArrayKlass.hpp&quot;
  36 #include &quot;ci/ciInlineKlass.hpp&quot;
  37 #include &quot;ci/ciInstance.hpp&quot;
  38 #include &quot;code/compiledIC.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.hpp&quot;
  40 #include &quot;nativeInst_aarch64.hpp&quot;
  41 #include &quot;oops/objArrayKlass.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;runtime/frame.inline.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;utilities/powerOfTwo.hpp&quot;
  46 #include &quot;vmreg_aarch64.inline.hpp&quot;
  47 
  48 
  49 #ifndef PRODUCT
  50 #define COMMENT(x)   do { __ block_comment(x); } while (0)
  51 #else
  52 #define COMMENT(x)
  53 #endif
  54 
  55 NEEDS_CLEANUP // remove this definitions ?
  56 const Register IC_Klass    = rscratch2;   // where the IC klass is cached
  57 const Register SYNC_header = r0;   // synchronization header
  58 const Register SHIFT_count = r0;   // where count for shift operations must be
  59 
  60 #define __ _masm-&gt;
  61 
  62 
  63 static void select_different_registers(Register preserve,
  64                                        Register extra,
  65                                        Register &amp;tmp1,
  66                                        Register &amp;tmp2) {
  67   if (tmp1 == preserve) {
  68     assert_different_registers(tmp1, tmp2, extra);
  69     tmp1 = extra;
  70   } else if (tmp2 == preserve) {
  71     assert_different_registers(tmp1, tmp2, extra);
  72     tmp2 = extra;
  73   }
  74   assert_different_registers(preserve, tmp1, tmp2);
  75 }
  76 
  77 
  78 
  79 static void select_different_registers(Register preserve,
  80                                        Register extra,
  81                                        Register &amp;tmp1,
  82                                        Register &amp;tmp2,
  83                                        Register &amp;tmp3) {
  84   if (tmp1 == preserve) {
  85     assert_different_registers(tmp1, tmp2, tmp3, extra);
  86     tmp1 = extra;
  87   } else if (tmp2 == preserve) {
  88     assert_different_registers(tmp1, tmp2, tmp3, extra);
  89     tmp2 = extra;
  90   } else if (tmp3 == preserve) {
  91     assert_different_registers(tmp1, tmp2, tmp3, extra);
  92     tmp3 = extra;
  93   }
  94   assert_different_registers(preserve, tmp1, tmp2, tmp3);
  95 }
  96 
  97 
  98 bool LIR_Assembler::is_small_constant(LIR_Opr opr) { Unimplemented(); return false; }
  99 
 100 
 101 LIR_Opr LIR_Assembler::receiverOpr() {
 102   return FrameMap::receiver_opr;
 103 }
 104 
 105 LIR_Opr LIR_Assembler::osrBufferPointer() {
 106   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 107 }
 108 
 109 //--------------fpu register translations-----------------------
 110 
 111 
 112 address LIR_Assembler::float_constant(float f) {
 113   address const_addr = __ float_constant(f);
 114   if (const_addr == NULL) {
 115     bailout(&quot;const section overflow&quot;);
 116     return __ code()-&gt;consts()-&gt;start();
 117   } else {
 118     return const_addr;
 119   }
 120 }
 121 
 122 
 123 address LIR_Assembler::double_constant(double d) {
 124   address const_addr = __ double_constant(d);
 125   if (const_addr == NULL) {
 126     bailout(&quot;const section overflow&quot;);
 127     return __ code()-&gt;consts()-&gt;start();
 128   } else {
 129     return const_addr;
 130   }
 131 }
 132 
 133 address LIR_Assembler::int_constant(jlong n) {
 134   address const_addr = __ long_constant(n);
 135   if (const_addr == NULL) {
 136     bailout(&quot;const section overflow&quot;);
 137     return __ code()-&gt;consts()-&gt;start();
 138   } else {
 139     return const_addr;
 140   }
 141 }
 142 
 143 void LIR_Assembler::breakpoint() { Unimplemented(); }
 144 
 145 void LIR_Assembler::push(LIR_Opr opr) { Unimplemented(); }
 146 
 147 void LIR_Assembler::pop(LIR_Opr opr) { Unimplemented(); }
 148 
 149 bool LIR_Assembler::is_literal_address(LIR_Address* addr) { Unimplemented(); return false; }
 150 //-------------------------------------------
 151 
 152 static Register as_reg(LIR_Opr op) {
 153   return op-&gt;is_double_cpu() ? op-&gt;as_register_lo() : op-&gt;as_register();
 154 }
 155 
 156 static jlong as_long(LIR_Opr data) {
 157   jlong result;
 158   switch (data-&gt;type()) {
 159   case T_INT:
 160     result = (data-&gt;as_jint());
 161     break;
 162   case T_LONG:
 163     result = (data-&gt;as_jlong());
 164     break;
 165   default:
 166     ShouldNotReachHere();
 167     result = 0;  // unreachable
 168   }
 169   return result;
 170 }
 171 
 172 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 173   Register base = addr-&gt;base()-&gt;as_pointer_register();
 174   LIR_Opr opr = addr-&gt;index();
 175   if (opr-&gt;is_cpu_register()) {
 176     Register index;
 177     if (opr-&gt;is_single_cpu())
 178       index = opr-&gt;as_register();
 179     else
 180       index = opr-&gt;as_register_lo();
 181     assert(addr-&gt;disp() == 0, &quot;must be&quot;);
 182     switch(opr-&gt;type()) {
 183       case T_INT:
 184         return Address(base, index, Address::sxtw(addr-&gt;scale()));
 185       case T_LONG:
 186         return Address(base, index, Address::lsl(addr-&gt;scale()));
 187       default:
 188         ShouldNotReachHere();
 189       }
 190   } else  {
 191     intptr_t addr_offset = intptr_t(addr-&gt;disp());
 192     if (Address::offset_ok_for_immed(addr_offset, addr-&gt;scale()))
 193       return Address(base, addr_offset, Address::lsl(addr-&gt;scale()));
 194     else {
 195       __ mov(tmp, addr_offset);
 196       return Address(base, tmp, Address::lsl(addr-&gt;scale()));
 197     }
 198   }
 199   return Address();
 200 }
 201 
 202 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 203   ShouldNotReachHere();
 204   return Address();
 205 }
 206 
 207 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 208   return as_Address(addr, rscratch1);
 209 }
 210 
 211 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 212   return as_Address(addr, rscratch1);  // Ouch
 213   // FIXME: This needs to be much more clever.  See x86.
 214 }
 215 
 216 
 217 void LIR_Assembler::osr_entry() {
 218   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 219   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 220   ValueStack* entry_state = osr_entry-&gt;state();
 221   int number_of_locks = entry_state-&gt;locks_size();
 222 
 223   // we jump here if osr happens with the interpreter
 224   // state set up to continue at the beginning of the
 225   // loop that triggered osr - in particular, we have
 226   // the following registers setup:
 227   //
 228   // r2: osr buffer
 229   //
 230 
 231   // build frame
 232   ciMethod* m = compilation()-&gt;method();
 233   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes(), needs_stack_repair(), NULL);
 234 
 235   // OSR buffer is
 236   //
 237   // locals[nlocals-1..0]
 238   // monitors[0..number_of_locks]
 239   //
 240   // locals is a direct copy of the interpreter frame so in the osr buffer
 241   // so first slot in the local array is the last local from the interpreter
 242   // and last slot is local[0] (receiver) from the interpreter
 243   //
 244   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 245   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 246   // in the interpreter frame (the method lock if a sync method)
 247 
 248   // Initialize monitors in the compiled activation.
 249   //   r2: pointer to osr buffer
 250   //
 251   // All other registers are dead at this point and the locals will be
 252   // copied into place by code emitted in the IR.
 253 
 254   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 255   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 256     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 257       (2 * BytesPerWord) * (number_of_locks - 1);
 258     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 259     // the OSR buffer using 2 word entries: first the lock and then
 260     // the oop.
 261     for (int i = 0; i &lt; number_of_locks; i++) {
 262       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 263 #ifdef ASSERT
 264       // verify the interpreter&#39;s monitor has a non-null object
 265       {
 266         Label L;
 267         __ ldr(rscratch1, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 268         __ cbnz(rscratch1, L);
 269         __ stop(&quot;locked object is NULL&quot;);
 270         __ bind(L);
 271       }
 272 #endif
 273       __ ldr(r19, Address(OSR_buf, slot_offset + 0));
 274       __ str(r19, frame_map()-&gt;address_for_monitor_lock(i));
 275       __ ldr(r19, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 276       __ str(r19, frame_map()-&gt;address_for_monitor_object(i));
 277     }
 278   }
 279 }
 280 
 281 
 282 // inline cache check; done before the frame is built.
 283 int LIR_Assembler::check_icache() {
 284   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 285   Register ic_klass = IC_Klass;
 286   int start_offset = __ offset();
 287   __ inline_cache_check(receiver, ic_klass);
 288 
 289   // if icache check fails, then jump to runtime routine
 290   // Note: RECEIVER must still contain the receiver!
 291   Label dont;
 292   __ br(Assembler::EQ, dont);
 293   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 294 
 295   // We align the verified entry point unless the method body
 296   // (including its inline cache check) will fit in a single 64-byte
 297   // icache line.
 298   if (! method()-&gt;is_accessor() || __ offset() - start_offset &gt; 4 * 4) {
 299     // force alignment after the cache check.
 300     __ align(CodeEntryAlignment);
 301   }
 302 
 303   __ bind(dont);
 304   return start_offset;
 305 }
 306 
 307 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 308   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 309   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 310 
 311   Label L_skip_barrier;
 312 
 313   __ mov_metadata(rscratch2, method-&gt;holder()-&gt;constant_encoding());
 314   __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier /*L_fast_path*/);
 315   __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 316   __ bind(L_skip_barrier);
 317 }
 318 
 319 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 320   if (o == NULL) {
 321     __ mov(reg, zr);
 322   } else {
 323     __ movoop(reg, o, /*immediate*/true);
 324   }
 325 }
 326 
 327 void LIR_Assembler::deoptimize_trap(CodeEmitInfo *info) {
 328   address target = NULL;
 329   relocInfo::relocType reloc_type = relocInfo::none;
 330 
 331   switch (patching_id(info)) {
 332   case PatchingStub::access_field_id:
 333     target = Runtime1::entry_for(Runtime1::access_field_patching_id);
 334     reloc_type = relocInfo::section_word_type;
 335     break;
 336   case PatchingStub::load_klass_id:
 337     target = Runtime1::entry_for(Runtime1::load_klass_patching_id);
 338     reloc_type = relocInfo::metadata_type;
 339     break;
 340   case PatchingStub::load_mirror_id:
 341     target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);
 342     reloc_type = relocInfo::oop_type;
 343     break;
 344   case PatchingStub::load_appendix_id:
 345     target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);
 346     reloc_type = relocInfo::oop_type;
 347     break;
 348   default: ShouldNotReachHere();
 349   }
 350 
 351   __ far_call(RuntimeAddress(target));
 352   add_call_info_here(info);
 353 }
 354 
 355 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 356   deoptimize_trap(info);
 357 }
 358 
 359 
 360 // This specifies the rsp decrement needed to build the frame
 361 int LIR_Assembler::initial_frame_size_in_bytes() const {
 362   // if rounding, must let FrameMap know!
 363 
 364   // The frame_map records size in slots (32bit word)
 365 
 366   // subtract two words to account for return address and link
 367   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 368 }
 369 
 370 
 371 int LIR_Assembler::emit_exception_handler() {
 372   // if the last instruction is a call (typically to do a throw which
 373   // is coming at the end after block reordering) the return address
 374   // must still point into the code area in order to avoid assertion
 375   // failures when searching for the corresponding bci =&gt; add a nop
 376   // (was bug 5/14/1999 - gri)
 377   __ nop();
 378 
 379   // generate code for exception handler
 380   address handler_base = __ start_a_stub(exception_handler_size());
 381   if (handler_base == NULL) {
 382     // not enough space left for the handler
 383     bailout(&quot;exception handler overflow&quot;);
 384     return -1;
 385   }
 386 
 387   int offset = code_offset();
 388 
 389   // the exception oop and pc are in r0, and r3
 390   // no other registers need to be preserved, so invalidate them
 391   __ invalidate_registers(false, true, true, false, true, true);
 392 
 393   // check that there is really an exception
 394   __ verify_not_null_oop(r0);
 395 
 396   // search an exception handler (r0: exception oop, r3: throwing pc)
 397   __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));  __ should_not_reach_here();
 398   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 399   __ end_a_stub();
 400 
 401   return offset;
 402 }
 403 
 404 
 405 // Emit the code to remove the frame from the stack in the exception
 406 // unwind path.
 407 int LIR_Assembler::emit_unwind_handler() {
 408 #ifndef PRODUCT
 409   if (CommentedAssembly) {
 410     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 411   }
 412 #endif
 413 
 414   int offset = code_offset();
 415 
 416   // Fetch the exception from TLS and clear out exception related thread state
 417   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
 418   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
 419   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
 420 
 421   __ bind(_unwind_handler_entry);
 422   __ verify_not_null_oop(r0);
 423   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 424     __ mov(r19, r0);  // Preserve the exception
 425   }
 426 
 427   // Preform needed unlocking
 428   MonitorExitStub* stub = NULL;
 429   if (method()-&gt;is_synchronized()) {
 430     monitor_address(0, FrameMap::r0_opr);
 431     stub = new MonitorExitStub(FrameMap::r0_opr, true, 0);
 432     __ unlock_object(r5, r4, r0, *stub-&gt;entry());
 433     __ bind(*stub-&gt;continuation());
 434   }
 435 
 436   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 437     __ mov(c_rarg0, rthread);
 438     __ mov_metadata(c_rarg1, method()-&gt;constant_encoding());
 439     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), c_rarg0, c_rarg1);
 440   }
 441 
 442   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 443     __ mov(r0, r19);  // Restore the exception
 444   }
 445 
 446   // remove the activation and dispatch to the unwind handler
 447   __ block_comment(&quot;remove_frame and dispatch to the unwind handler&quot;);
 448   __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());
 449   __ far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 450 
 451   // Emit the slow path assembly
 452   if (stub != NULL) {
 453     stub-&gt;emit_code(this);
 454   }
 455 
 456   return offset;
 457 }
 458 
 459 
 460 int LIR_Assembler::emit_deopt_handler() {
 461   // if the last instruction is a call (typically to do a throw which
 462   // is coming at the end after block reordering) the return address
 463   // must still point into the code area in order to avoid assertion
 464   // failures when searching for the corresponding bci =&gt; add a nop
 465   // (was bug 5/14/1999 - gri)
 466   __ nop();
 467 
 468   // generate code for exception handler
 469   address handler_base = __ start_a_stub(deopt_handler_size());
 470   if (handler_base == NULL) {
 471     // not enough space left for the handler
 472     bailout(&quot;deopt handler overflow&quot;);
 473     return -1;
 474   }
 475 
 476   int offset = code_offset();
 477 
 478   __ adr(lr, pc());
 479   __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 480   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 481   __ end_a_stub();
 482 
 483   return offset;
 484 }
 485 
 486 void LIR_Assembler::add_debug_info_for_branch(address adr, CodeEmitInfo* info) {
 487   _masm-&gt;code_section()-&gt;relocate(adr, relocInfo::poll_type);
 488   int pc_offset = code_offset();
 489   flush_debug_info(pc_offset);
 490   info-&gt;record_debug_info(compilation()-&gt;debug_info_recorder(), pc_offset);
 491   if (info-&gt;exception_handlers() != NULL) {
 492     compilation()-&gt;add_exception_handlers_for_pco(pc_offset, info-&gt;exception_handlers());
 493   }
 494 }
 495 
 496 void LIR_Assembler::return_op(LIR_Opr result) {
 497   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == r0, &quot;word returns are in r0,&quot;);
 498 
 499   ciMethod* method = compilation()-&gt;method();
 500 
 501   ciType* return_type = method-&gt;return_type();
 502   if (InlineTypeReturnedAsFields &amp;&amp; return_type-&gt;is_inlinetype()) {
 503     ciInlineKlass* vk = return_type-&gt;as_inline_klass();
 504     if (vk-&gt;can_be_returned_as_fields()) {
 505       address unpack_handler = vk-&gt;unpack_handler();
 506       assert(unpack_handler != NULL, &quot;must be&quot;);
 507       __ far_call(RuntimeAddress(unpack_handler));
 508       // At this point, rax points to the value object (for interpreter or C1 caller).
 509       // The fields of the object are copied into registers (for C2 caller).
 510     }
 511   }
 512 
 513 
 514   // Pop the stack before the safepoint code
 515   __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());
 516 
 517   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 518     __ reserved_stack_check();
 519   }
 520 
 521   __ fetch_and_read_polling_page(rscratch1, relocInfo::poll_return_type);
 522   __ ret(lr);
 523 }
 524 
 525 int LIR_Assembler::store_inline_type_fields_to_buf(ciInlineKlass* vk) {
 526   return (__ store_inline_type_fields_to_buf(vk, false));
 527 }
 528 
 529 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 530   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 531   __ get_polling_page(rscratch1, relocInfo::poll_type);
 532   add_debug_info_for_branch(info);  // This isn&#39;t just debug info:
 533                                     // it&#39;s the oop map
 534   __ read_polling_page(rscratch1, relocInfo::poll_type);
 535   return __ offset();
 536 }
 537 
 538 
 539 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 540   if (from_reg == r31_sp)
 541     from_reg = sp;
 542   if (to_reg == r31_sp)
 543     to_reg = sp;
 544   __ mov(to_reg, from_reg);
 545 }
 546 
 547 void LIR_Assembler::swap_reg(Register a, Register b) { Unimplemented(); }
 548 
 549 
 550 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 551   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 552   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 553   LIR_Const* c = src-&gt;as_constant_ptr();
 554 
 555   switch (c-&gt;type()) {
 556     case T_INT: {
 557       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 558       __ movw(dest-&gt;as_register(), c-&gt;as_jint());
 559       break;
 560     }
 561 
 562     case T_ADDRESS: {
 563       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 564       __ mov(dest-&gt;as_register(), c-&gt;as_jint());
 565       break;
 566     }
 567 
 568     case T_LONG: {
 569       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 570       __ mov(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 571       break;
 572     }
 573 
 574     case T_INLINE_TYPE:
 575     case T_OBJECT: {
 576         if (patch_code != lir_patch_none) {
 577           jobject2reg_with_patching(dest-&gt;as_register(), info);
 578         } else {
 579           jobject2reg(c-&gt;as_jobject(), dest-&gt;as_register());
 580         }
 581       break;
 582     }
 583 
 584     case T_METADATA: {
 585       if (patch_code != lir_patch_none) {
 586         klass2reg_with_patching(dest-&gt;as_register(), info);
 587       } else {
 588         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 589       }
 590       break;
 591     }
 592 
 593     case T_FLOAT: {
 594       if (__ operand_valid_for_float_immediate(c-&gt;as_jfloat())) {
 595         __ fmovs(dest-&gt;as_float_reg(), (c-&gt;as_jfloat()));
 596       } else {
 597         __ adr(rscratch1, InternalAddress(float_constant(c-&gt;as_jfloat())));
 598         __ ldrs(dest-&gt;as_float_reg(), Address(rscratch1));
 599       }
 600       break;
 601     }
 602 
 603     case T_DOUBLE: {
 604       if (__ operand_valid_for_float_immediate(c-&gt;as_jdouble())) {
 605         __ fmovd(dest-&gt;as_double_reg(), (c-&gt;as_jdouble()));
 606       } else {
 607         __ adr(rscratch1, InternalAddress(double_constant(c-&gt;as_jdouble())));
 608         __ ldrd(dest-&gt;as_double_reg(), Address(rscratch1));
 609       }
 610       break;
 611     }
 612 
 613     default:
 614       ShouldNotReachHere();
 615   }
 616 }
 617 
 618 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 619   LIR_Const* c = src-&gt;as_constant_ptr();
 620   switch (c-&gt;type()) {
 621   case T_INLINE_TYPE:
 622   case T_OBJECT:
 623     {
 624       if (! c-&gt;as_jobject())
 625         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 626       else {
 627         const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 628         reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 629       }
 630     }
 631     break;
 632   case T_ADDRESS:
 633     {
 634       const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 635       reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 636     }
 637   case T_INT:
 638   case T_FLOAT:
 639     {
 640       Register reg = zr;
 641       if (c-&gt;as_jint_bits() == 0)
 642         __ strw(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 643       else {
 644         __ movw(rscratch1, c-&gt;as_jint_bits());
 645         __ strw(rscratch1, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 646       }
 647     }
 648     break;
 649   case T_LONG:
 650   case T_DOUBLE:
 651     {
 652       Register reg = zr;
 653       if (c-&gt;as_jlong_bits() == 0)
 654         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 655                                                  lo_word_offset_in_bytes));
 656       else {
 657         __ mov(rscratch1, (intptr_t)c-&gt;as_jlong_bits());
 658         __ str(rscratch1, frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 659                                                         lo_word_offset_in_bytes));
 660       }
 661     }
 662     break;
 663   default:
 664     ShouldNotReachHere();
 665   }
 666 }
 667 
 668 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 669   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 670   LIR_Const* c = src-&gt;as_constant_ptr();
 671   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 672 
 673   void (Assembler::* insn)(Register Rt, const Address &amp;adr);
 674 
 675   switch (type) {
 676   case T_ADDRESS:
 677     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 678     insn = &amp;Assembler::str;
 679     break;
 680   case T_LONG:
 681     assert(c-&gt;as_jlong() == 0, &quot;should be&quot;);
 682     insn = &amp;Assembler::str;
 683     break;
 684   case T_INT:
 685     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 686     insn = &amp;Assembler::strw;
 687     break;
 688   case T_INLINE_TYPE:
 689   case T_OBJECT:
 690   case T_ARRAY:
 691     // Non-null case is not handled on aarch64 but handled on x86
 692     // FIXME: do we need to add it here?
 693     assert(c-&gt;as_jobject() == 0, &quot;should be&quot;);
 694     if (UseCompressedOops &amp;&amp; !wide) {
 695       insn = &amp;Assembler::strw;
 696     } else {
 697       insn = &amp;Assembler::str;
 698     }
 699     break;
 700   case T_CHAR:
 701   case T_SHORT:
 702     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 703     insn = &amp;Assembler::strh;
 704     break;
 705   case T_BOOLEAN:
 706   case T_BYTE:
 707     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 708     insn = &amp;Assembler::strb;
 709     break;
 710   default:
 711     ShouldNotReachHere();
 712     insn = &amp;Assembler::str;  // unreachable
 713   }
 714 
 715   if (info) add_debug_info_for_null_check_here(info);
 716   (_masm-&gt;*insn)(zr, as_Address(to_addr, rscratch1));
 717 }
 718 
 719 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 720   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 721   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 722 
 723   // move between cpu-registers
 724   if (dest-&gt;is_single_cpu()) {
 725     if (src-&gt;type() == T_LONG) {
 726       // Can do LONG -&gt; OBJECT
 727       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 728       return;
 729     }
 730     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 731     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_INLINE_TYPE) {
 732       __ verify_oop(src-&gt;as_register());
 733     }
 734     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 735 
 736   } else if (dest-&gt;is_double_cpu()) {
 737     if (is_reference_type(src-&gt;type())) {
 738       // Surprising to me but we can see move of a long to t_object
 739       __ verify_oop(src-&gt;as_register());
 740       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 741       return;
 742     }
 743     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 744     Register f_lo = src-&gt;as_register_lo();
 745     Register f_hi = src-&gt;as_register_hi();
 746     Register t_lo = dest-&gt;as_register_lo();
 747     Register t_hi = dest-&gt;as_register_hi();
 748     assert(f_hi == f_lo, &quot;must be same&quot;);
 749     assert(t_hi == t_lo, &quot;must be same&quot;);
 750     move_regs(f_lo, t_lo);
 751 
 752   } else if (dest-&gt;is_single_fpu()) {
 753     __ fmovs(dest-&gt;as_float_reg(), src-&gt;as_float_reg());
 754 
 755   } else if (dest-&gt;is_double_fpu()) {
 756     __ fmovd(dest-&gt;as_double_reg(), src-&gt;as_double_reg());
 757 
 758   } else {
 759     ShouldNotReachHere();
 760   }
 761 }
 762 
 763 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 764   if (src-&gt;is_single_cpu()) {
 765     if (is_reference_type(type)) {
 766       __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 767       __ verify_oop(src-&gt;as_register());
 768     } else if (type == T_METADATA || type == T_DOUBLE || type == T_ADDRESS) {
 769       __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 770     } else {
 771       __ strw(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 772     }
 773 
 774   } else if (src-&gt;is_double_cpu()) {
 775     Address dest_addr_LO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 776     __ str(src-&gt;as_register_lo(), dest_addr_LO);
 777 
 778   } else if (src-&gt;is_single_fpu()) {
 779     Address dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 780     __ strs(src-&gt;as_float_reg(), dest_addr);
 781 
 782   } else if (src-&gt;is_double_fpu()) {
 783     Address dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 784     __ strd(src-&gt;as_double_reg(), dest_addr);
 785 
 786   } else {
 787     ShouldNotReachHere();
 788   }
 789 
 790 }
 791 
 792 
 793 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 794   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 795   PatchingStub* patch = NULL;
 796   Register compressed_src = rscratch1;
 797 
 798   if (patch_code != lir_patch_none) {
 799     deoptimize_trap(info);
 800     return;
 801   }
 802 
 803   if (is_reference_type(type)) {
 804     __ verify_oop(src-&gt;as_register());
 805 
 806     if (UseCompressedOops &amp;&amp; !wide) {
 807       __ encode_heap_oop(compressed_src, src-&gt;as_register());
 808     } else {
 809       compressed_src = src-&gt;as_register();
 810     }
 811   }
 812 
 813   int null_check_here = code_offset();
 814   switch (type) {
 815     case T_FLOAT: {
 816       __ strs(src-&gt;as_float_reg(), as_Address(to_addr));
 817       break;
 818     }
 819 
 820     case T_DOUBLE: {
 821       __ strd(src-&gt;as_double_reg(), as_Address(to_addr));
 822       break;
 823     }
 824 
 825     case T_INLINE_TYPE: // fall through
 826     case T_ARRAY:   // fall through
 827     case T_OBJECT:  // fall through
 828       if (UseCompressedOops &amp;&amp; !wide) {
 829         __ strw(compressed_src, as_Address(to_addr, rscratch2));
 830       } else {
 831          __ str(compressed_src, as_Address(to_addr));
 832       }
 833       break;
 834     case T_METADATA:
 835       // We get here to store a method pointer to the stack to pass to
 836       // a dtrace runtime call. This can&#39;t work on 64 bit with
 837       // compressed klass ptrs: T_METADATA can be a compressed klass
 838       // ptr or a 64 bit method pointer.
 839       ShouldNotReachHere();
 840       __ str(src-&gt;as_register(), as_Address(to_addr));
 841       break;
 842     case T_ADDRESS:
 843       __ str(src-&gt;as_register(), as_Address(to_addr));
 844       break;
 845     case T_INT:
 846       __ strw(src-&gt;as_register(), as_Address(to_addr));
 847       break;
 848 
 849     case T_LONG: {
 850       __ str(src-&gt;as_register_lo(), as_Address_lo(to_addr));
 851       break;
 852     }
 853 
 854     case T_BYTE:    // fall through
 855     case T_BOOLEAN: {
 856       __ strb(src-&gt;as_register(), as_Address(to_addr));
 857       break;
 858     }
 859 
 860     case T_CHAR:    // fall through
 861     case T_SHORT:
 862       __ strh(src-&gt;as_register(), as_Address(to_addr));
 863       break;
 864 
 865     default:
 866       ShouldNotReachHere();
 867   }
 868   if (info != NULL) {
 869     add_debug_info_for_null_check(null_check_here, info);
 870   }
 871 }
 872 
 873 
 874 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
 875   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
 876   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 877 
 878   if (dest-&gt;is_single_cpu()) {
 879     if (is_reference_type(type)) {
 880       __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
 881       __ verify_oop(dest-&gt;as_register());
 882     } else if (type == T_METADATA || type == T_ADDRESS) {
 883       __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
 884     } else {
 885       __ ldrw(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
 886     }
 887 
 888   } else if (dest-&gt;is_double_cpu()) {
 889     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 890     __ ldr(dest-&gt;as_register_lo(), src_addr_LO);
 891 
 892   } else if (dest-&gt;is_single_fpu()) {
 893     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
 894     __ ldrs(dest-&gt;as_float_reg(), src_addr);
 895 
 896   } else if (dest-&gt;is_double_fpu()) {
 897     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
 898     __ ldrd(dest-&gt;as_double_reg(), src_addr);
 899 
 900   } else {
 901     ShouldNotReachHere();
 902   }
 903 }
 904 
 905 
 906 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 907   address target = NULL;
 908   relocInfo::relocType reloc_type = relocInfo::none;
 909 
 910   switch (patching_id(info)) {
 911   case PatchingStub::access_field_id:
 912     target = Runtime1::entry_for(Runtime1::access_field_patching_id);
 913     reloc_type = relocInfo::section_word_type;
 914     break;
 915   case PatchingStub::load_klass_id:
 916     target = Runtime1::entry_for(Runtime1::load_klass_patching_id);
 917     reloc_type = relocInfo::metadata_type;
 918     break;
 919   case PatchingStub::load_mirror_id:
 920     target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);
 921     reloc_type = relocInfo::oop_type;
 922     break;
 923   case PatchingStub::load_appendix_id:
 924     target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);
 925     reloc_type = relocInfo::oop_type;
 926     break;
 927   default: ShouldNotReachHere();
 928   }
 929 
 930   __ far_call(RuntimeAddress(target));
 931   add_call_info_here(info);
 932 }
 933 
 934 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
 935 
 936   LIR_Opr temp;
 937   if (type == T_LONG || type == T_DOUBLE)
 938     temp = FrameMap::rscratch1_long_opr;
 939   else
 940     temp = FrameMap::rscratch1_opr;
 941 
 942   stack2reg(src, temp, src-&gt;type());
 943   reg2stack(temp, dest, dest-&gt;type(), false);
 944 }
 945 
 946 
 947 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
 948   LIR_Address* addr = src-&gt;as_address_ptr();
 949   LIR_Address* from_addr = src-&gt;as_address_ptr();
 950 
 951   if (addr-&gt;base()-&gt;type() == T_OBJECT || addr-&gt;base()-&gt;type() == T_INLINE_TYPE) {
 952     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
 953   }
 954 
 955   if (patch_code != lir_patch_none) {
 956     deoptimize_trap(info);
 957     return;
 958   }
 959 
 960   if (info != NULL) {
 961     add_debug_info_for_null_check_here(info);
 962   }
 963   int null_check_here = code_offset();
 964   switch (type) {
 965     case T_FLOAT: {
 966       __ ldrs(dest-&gt;as_float_reg(), as_Address(from_addr));
 967       break;
 968     }
 969 
 970     case T_DOUBLE: {
 971       __ ldrd(dest-&gt;as_double_reg(), as_Address(from_addr));
 972       break;
 973     }
 974 
 975     case T_INLINE_TYPE: // fall through
 976     case T_ARRAY:   // fall through
 977     case T_OBJECT:  // fall through
 978       if (UseCompressedOops &amp;&amp; !wide) {
 979         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 980       } else {
 981          __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 982       }
 983       break;
 984     case T_METADATA:
 985       // We get here to store a method pointer to the stack to pass to
 986       // a dtrace runtime call. This can&#39;t work on 64 bit with
 987       // compressed klass ptrs: T_METADATA can be a compressed klass
 988       // ptr or a 64 bit method pointer.
 989       ShouldNotReachHere();
 990       __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 991       break;
 992     case T_ADDRESS:
 993       // FIXME: OMG this is a horrible kludge.  Any offset from an
 994       // address that matches klass_offset_in_bytes() will be loaded
 995       // as a word, not a long.
 996       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
 997         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 998       } else {
 999         __ ldr(dest-&gt;as_register(), as_Address(from_addr));
1000       }
1001       break;
1002     case T_INT:
1003       __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
1004       break;
1005 
1006     case T_LONG: {
1007       __ ldr(dest-&gt;as_register_lo(), as_Address_lo(from_addr));
1008       break;
1009     }
1010 
1011     case T_BYTE:
1012       __ ldrsb(dest-&gt;as_register(), as_Address(from_addr));
1013       break;
1014     case T_BOOLEAN: {
1015       __ ldrb(dest-&gt;as_register(), as_Address(from_addr));
1016       break;
1017     }
1018 
1019     case T_CHAR:
1020       __ ldrh(dest-&gt;as_register(), as_Address(from_addr));
1021       break;
1022     case T_SHORT:
1023       __ ldrsh(dest-&gt;as_register(), as_Address(from_addr));
1024       break;
1025 
1026     default:
1027       ShouldNotReachHere();
1028   }
1029 
1030   if (is_reference_type(type)) {
1031     if (UseCompressedOops &amp;&amp; !wide) {
1032       __ decode_heap_oop(dest-&gt;as_register());
1033     }
1034 
1035     if (!UseZGC) {
1036       // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1037       __ verify_oop(dest-&gt;as_register());
1038     }
1039   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1040     if (UseCompressedClassPointers) {
1041       __ andr(dest-&gt;as_register(), dest-&gt;as_register(), oopDesc::compressed_klass_mask());
1042       __ decode_klass_not_null(dest-&gt;as_register());
1043     } else {
1044       __   ubfm(dest-&gt;as_register(), dest-&gt;as_register(), 0, 63 - oopDesc::storage_props_nof_bits);
1045     }
1046   }
1047 }
1048 
1049 void LIR_Assembler::move(LIR_Opr src, LIR_Opr dst) {
1050   assert(dst-&gt;is_cpu_register(), &quot;must be&quot;);
1051   assert(dst-&gt;type() == src-&gt;type(), &quot;must be&quot;);
1052 
1053   if (src-&gt;is_cpu_register()) {
1054     reg2reg(src, dst);
1055   } else if (src-&gt;is_stack()) {
1056     stack2reg(src, dst, dst-&gt;type());
1057   } else if (src-&gt;is_constant()) {
1058     const2reg(src, dst, lir_patch_none, NULL);
1059   } else {
1060     ShouldNotReachHere();
1061   }
1062 }
1063 
1064 int LIR_Assembler::array_element_size(BasicType type) const {
1065   int elem_size = type2aelembytes(type);
1066   return exact_log2(elem_size);
1067 }
1068 
1069 
1070 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1071   switch (op-&gt;code()) {
1072   case lir_idiv:
1073   case lir_irem:
1074     arithmetic_idiv(op-&gt;code(),
1075                     op-&gt;in_opr1(),
1076                     op-&gt;in_opr2(),
1077                     op-&gt;in_opr3(),
1078                     op-&gt;result_opr(),
1079                     op-&gt;info());
1080     break;
1081   case lir_fmad:
1082     __ fmaddd(op-&gt;result_opr()-&gt;as_double_reg(),
1083               op-&gt;in_opr1()-&gt;as_double_reg(),
1084               op-&gt;in_opr2()-&gt;as_double_reg(),
1085               op-&gt;in_opr3()-&gt;as_double_reg());
1086     break;
1087   case lir_fmaf:
1088     __ fmadds(op-&gt;result_opr()-&gt;as_float_reg(),
1089               op-&gt;in_opr1()-&gt;as_float_reg(),
1090               op-&gt;in_opr2()-&gt;as_float_reg(),
1091               op-&gt;in_opr3()-&gt;as_float_reg());
1092     break;
1093   default:      ShouldNotReachHere(); break;
1094   }
1095 }
1096 
1097 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1098 #ifdef ASSERT
1099   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1100   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1101   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1102 #endif
1103 
1104   if (op-&gt;cond() == lir_cond_always) {
1105     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1106     __ b(*(op-&gt;label()));
1107   } else {
1108     Assembler::Condition acond;
1109     if (op-&gt;code() == lir_cond_float_branch) {
1110       bool is_unordered = (op-&gt;ublock() == op-&gt;block());
1111       // Assembler::EQ does not permit unordered branches, so we add
1112       // another branch here.  Likewise, Assembler::NE does not permit
1113       // ordered branches.
1114       if ((is_unordered &amp;&amp; op-&gt;cond() == lir_cond_equal)
1115           || (!is_unordered &amp;&amp; op-&gt;cond() == lir_cond_notEqual))
1116         __ br(Assembler::VS, *(op-&gt;ublock()-&gt;label()));
1117       switch(op-&gt;cond()) {
1118       case lir_cond_equal:        acond = Assembler::EQ; break;
1119       case lir_cond_notEqual:     acond = Assembler::NE; break;
1120       case lir_cond_less:         acond = (is_unordered ? Assembler::LT : Assembler::LO); break;
1121       case lir_cond_lessEqual:    acond = (is_unordered ? Assembler::LE : Assembler::LS); break;
1122       case lir_cond_greaterEqual: acond = (is_unordered ? Assembler::HS : Assembler::GE); break;
1123       case lir_cond_greater:      acond = (is_unordered ? Assembler::HI : Assembler::GT); break;
1124       default:                    ShouldNotReachHere();
1125         acond = Assembler::EQ;  // unreachable
1126       }
1127     } else {
1128       switch (op-&gt;cond()) {
1129         case lir_cond_equal:        acond = Assembler::EQ; break;
1130         case lir_cond_notEqual:     acond = Assembler::NE; break;
1131         case lir_cond_less:         acond = Assembler::LT; break;
1132         case lir_cond_lessEqual:    acond = Assembler::LE; break;
1133         case lir_cond_greaterEqual: acond = Assembler::GE; break;
1134         case lir_cond_greater:      acond = Assembler::GT; break;
1135         case lir_cond_belowEqual:   acond = Assembler::LS; break;
1136         case lir_cond_aboveEqual:   acond = Assembler::HS; break;
1137         default:                    ShouldNotReachHere();
1138           acond = Assembler::EQ;  // unreachable
1139       }
1140     }
1141     __ br(acond,*(op-&gt;label()));
1142   }
1143 }
1144 
1145 
1146 
1147 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1148   LIR_Opr src  = op-&gt;in_opr();
1149   LIR_Opr dest = op-&gt;result_opr();
1150 
1151   switch (op-&gt;bytecode()) {
1152     case Bytecodes::_i2f:
1153       {
1154         __ scvtfws(dest-&gt;as_float_reg(), src-&gt;as_register());
1155         break;
1156       }
1157     case Bytecodes::_i2d:
1158       {
1159         __ scvtfwd(dest-&gt;as_double_reg(), src-&gt;as_register());
1160         break;
1161       }
1162     case Bytecodes::_l2d:
1163       {
1164         __ scvtfd(dest-&gt;as_double_reg(), src-&gt;as_register_lo());
1165         break;
1166       }
1167     case Bytecodes::_l2f:
1168       {
1169         __ scvtfs(dest-&gt;as_float_reg(), src-&gt;as_register_lo());
1170         break;
1171       }
1172     case Bytecodes::_f2d:
1173       {
1174         __ fcvts(dest-&gt;as_double_reg(), src-&gt;as_float_reg());
1175         break;
1176       }
1177     case Bytecodes::_d2f:
1178       {
1179         __ fcvtd(dest-&gt;as_float_reg(), src-&gt;as_double_reg());
1180         break;
1181       }
1182     case Bytecodes::_i2c:
1183       {
1184         __ ubfx(dest-&gt;as_register(), src-&gt;as_register(), 0, 16);
1185         break;
1186       }
1187     case Bytecodes::_i2l:
1188       {
1189         __ sxtw(dest-&gt;as_register_lo(), src-&gt;as_register());
1190         break;
1191       }
1192     case Bytecodes::_i2s:
1193       {
1194         __ sxth(dest-&gt;as_register(), src-&gt;as_register());
1195         break;
1196       }
1197     case Bytecodes::_i2b:
1198       {
1199         __ sxtb(dest-&gt;as_register(), src-&gt;as_register());
1200         break;
1201       }
1202     case Bytecodes::_l2i:
1203       {
1204         _masm-&gt;block_comment(&quot;FIXME: This could be a no-op&quot;);
1205         __ uxtw(dest-&gt;as_register(), src-&gt;as_register_lo());
1206         break;
1207       }
1208     case Bytecodes::_d2l:
1209       {
1210         __ fcvtzd(dest-&gt;as_register_lo(), src-&gt;as_double_reg());
1211         break;
1212       }
1213     case Bytecodes::_f2i:
1214       {
1215         __ fcvtzsw(dest-&gt;as_register(), src-&gt;as_float_reg());
1216         break;
1217       }
1218     case Bytecodes::_f2l:
1219       {
1220         __ fcvtzs(dest-&gt;as_register_lo(), src-&gt;as_float_reg());
1221         break;
1222       }
1223     case Bytecodes::_d2i:
1224       {
1225         __ fcvtzdw(dest-&gt;as_register(), src-&gt;as_double_reg());
1226         break;
1227       }
1228     default: ShouldNotReachHere();
1229   }
1230 }
1231 
1232 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1233   if (op-&gt;init_check()) {
1234     __ ldrb(rscratch1, Address(op-&gt;klass()-&gt;as_register(),
1235                                InstanceKlass::init_state_offset()));
1236     __ cmpw(rscratch1, InstanceKlass::fully_initialized);
1237     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1238     __ br(Assembler::NE, *op-&gt;stub()-&gt;entry());
1239   }
1240   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1241                      op-&gt;tmp1()-&gt;as_register(),
1242                      op-&gt;tmp2()-&gt;as_register(),
1243                      op-&gt;header_size(),
1244                      op-&gt;object_size(),
1245                      op-&gt;klass()-&gt;as_register(),
1246                      *op-&gt;stub()-&gt;entry());
1247   __ bind(*op-&gt;stub()-&gt;continuation());
1248 }
1249 
1250 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1251   Register len =  op-&gt;len()-&gt;as_register();
1252   __ uxtw(len, len);
1253 
1254   if (UseSlowPath || op-&gt;type() == T_INLINE_TYPE ||
1255       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1256       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1257     __ b(*op-&gt;stub()-&gt;entry());
1258   } else {
1259     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1260     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1261     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1262     if (len == tmp1) {
1263       tmp1 = tmp3;
1264     } else if (len == tmp2) {
1265       tmp2 = tmp3;
1266     } else if (len == tmp3) {
1267       // everything is ok
1268     } else {
1269       __ mov(tmp3, len);
1270     }
1271     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1272                       len,
1273                       tmp1,
1274                       tmp2,
1275                       arrayOopDesc::header_size(op-&gt;type()),
1276                       array_element_size(op-&gt;type()),
1277                       op-&gt;klass()-&gt;as_register(),
1278                       *op-&gt;stub()-&gt;entry());
1279   }
1280   __ bind(*op-&gt;stub()-&gt;continuation());
1281 }
1282 
1283 void LIR_Assembler::type_profile_helper(Register mdo,
1284                                         ciMethodData *md, ciProfileData *data,
1285                                         Register recv, Label* update_done) {
1286   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1287     Label next_test;
1288     // See if the receiver is receiver[n].
1289     __ lea(rscratch2, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1290     __ ldr(rscratch1, Address(rscratch2));
1291     __ cmp(recv, rscratch1);
1292     __ br(Assembler::NE, next_test);
1293     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1294     __ addptr(data_addr, DataLayout::counter_increment);
1295     __ b(*update_done);
1296     __ bind(next_test);
1297   }
1298 
1299   // Didn&#39;t find receiver; find next empty slot and fill it in
1300   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1301     Label next_test;
1302     __ lea(rscratch2,
1303            Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1304     Address recv_addr(rscratch2);
1305     __ ldr(rscratch1, recv_addr);
1306     __ cbnz(rscratch1, next_test);
1307     __ str(recv, recv_addr);
1308     __ mov(rscratch1, DataLayout::counter_increment);
1309     __ lea(rscratch2, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))));
1310     __ str(rscratch1, Address(rscratch2));
1311     __ b(*update_done);
1312     __ bind(next_test);
1313   }
1314 }
1315 
1316 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1317   // we always need a stub for the failure case.
1318   CodeStub* stub = op-&gt;stub();
1319   Register obj = op-&gt;object()-&gt;as_register();
1320   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1321   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1322   Register dst = op-&gt;result_opr()-&gt;as_register();
1323   ciKlass* k = op-&gt;klass();
1324   Register Rtmp1 = noreg;
1325 
1326   // check if it needs to be profiled
1327   ciMethodData* md;
1328   ciProfileData* data;
1329 
1330   const bool should_profile = op-&gt;should_profile();
1331 
1332   if (should_profile) {
1333     ciMethod* method = op-&gt;profiled_method();
1334     assert(method != NULL, &quot;Should have method&quot;);
1335     int bci = op-&gt;profiled_bci();
1336     md = method-&gt;method_data_or_null();
1337     assert(md != NULL, &quot;Sanity&quot;);
1338     data = md-&gt;bci_to_data(bci);
1339     assert(data != NULL,                &quot;need data for type check&quot;);
1340     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1341   }
1342   Label profile_cast_success, profile_cast_failure;
1343   Label *success_target = should_profile ? &amp;profile_cast_success : success;
1344   Label *failure_target = should_profile ? &amp;profile_cast_failure : failure;
1345 
1346   if (obj == k_RInfo) {
1347     k_RInfo = dst;
1348   } else if (obj == klass_RInfo) {
1349     klass_RInfo = dst;
1350   }
1351   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1352     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1353   } else {
1354     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1355     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1356   }
1357 
1358   assert_different_registers(obj, k_RInfo, klass_RInfo);
1359 
1360     if (should_profile) {
1361       Label not_null;
1362       __ cbnz(obj, not_null);
1363       // Object is null; update MDO and exit
1364       Register mdo  = klass_RInfo;
1365       __ mov_metadata(mdo, md-&gt;constant_encoding());
1366       Address data_addr
1367         = __ form_address(rscratch2, mdo,
1368                           md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()),
1369                           0);
1370       __ ldrb(rscratch1, data_addr);
1371       __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());
1372       __ strb(rscratch1, data_addr);
1373       __ b(*obj_is_null);
1374       __ bind(not_null);
1375     } else {
1376       __ cbz(obj, *obj_is_null);
1377     }
1378 
1379   if (!k-&gt;is_loaded()) {
1380     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1381   } else {
1382     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1383   }
1384   __ verify_oop(obj);
1385 
1386   if (op-&gt;fast_check()) {
1387     // get object class
1388     // not a safepoint as obj null check happens earlier
1389     __ load_klass(rscratch1, obj);
1390     __ cmp( rscratch1, k_RInfo);
1391 
1392     __ br(Assembler::NE, *failure_target);
1393     // successful cast, fall through to profile or jump
1394   } else {
1395     // get object class
1396     // not a safepoint as obj null check happens earlier
1397     __ load_klass(klass_RInfo, obj);
1398     if (k-&gt;is_loaded()) {
1399       // See if we get an immediate positive hit
1400       __ ldr(rscratch1, Address(klass_RInfo, long(k-&gt;super_check_offset())));
1401       __ cmp(k_RInfo, rscratch1);
1402       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1403         __ br(Assembler::NE, *failure_target);
1404         // successful cast, fall through to profile or jump
1405       } else {
1406         // See if we get an immediate positive hit
1407         __ br(Assembler::EQ, *success_target);
1408         // check for self
1409         __ cmp(klass_RInfo, k_RInfo);
1410         __ br(Assembler::EQ, *success_target);
1411 
1412         __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1413         __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1414         __ ldr(klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1415         // result is a boolean
1416         __ cbzw(klass_RInfo, *failure_target);
1417         // successful cast, fall through to profile or jump
1418       }
1419     } else {
1420       // perform the fast part of the checking logic
1421       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1422       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1423       __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1424       __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1425       __ ldp(k_RInfo, klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1426       // result is a boolean
1427       __ cbz(k_RInfo, *failure_target);
1428       // successful cast, fall through to profile or jump
1429     }
1430   }
1431   if (should_profile) {
1432     Register mdo  = klass_RInfo, recv = k_RInfo;
1433     __ bind(profile_cast_success);
1434     __ mov_metadata(mdo, md-&gt;constant_encoding());
1435     __ load_klass(recv, obj);
1436     Label update_done;
1437     type_profile_helper(mdo, md, data, recv, success);
1438     __ b(*success);
1439 
1440     __ bind(profile_cast_failure);
1441     __ mov_metadata(mdo, md-&gt;constant_encoding());
1442     Address counter_addr
1443       = __ form_address(rscratch2, mdo,
1444                         md-&gt;byte_offset_of_slot(data, CounterData::count_offset()),
1445                         0);
1446     __ ldr(rscratch1, counter_addr);
1447     __ sub(rscratch1, rscratch1, DataLayout::counter_increment);
1448     __ str(rscratch1, counter_addr);
1449     __ b(*failure);
1450   }
1451   __ b(*success);
1452 }
1453 
1454 
1455 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1456   const bool should_profile = op-&gt;should_profile();
1457 
1458   LIR_Code code = op-&gt;code();
1459   if (code == lir_store_check) {
1460     Register value = op-&gt;object()-&gt;as_register();
1461     Register array = op-&gt;array()-&gt;as_register();
1462     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1463     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1464     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1465 
1466     CodeStub* stub = op-&gt;stub();
1467 
1468     // check if it needs to be profiled
1469     ciMethodData* md;
1470     ciProfileData* data;
1471 
1472     if (should_profile) {
1473       ciMethod* method = op-&gt;profiled_method();
1474       assert(method != NULL, &quot;Should have method&quot;);
1475       int bci = op-&gt;profiled_bci();
1476       md = method-&gt;method_data_or_null();
1477       assert(md != NULL, &quot;Sanity&quot;);
1478       data = md-&gt;bci_to_data(bci);
1479       assert(data != NULL,                &quot;need data for type check&quot;);
1480       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1481     }
1482     Label profile_cast_success, profile_cast_failure, done;
1483     Label *success_target = should_profile ? &amp;profile_cast_success : &amp;done;
1484     Label *failure_target = should_profile ? &amp;profile_cast_failure : stub-&gt;entry();
1485 
1486     if (should_profile) {
1487       Label not_null;
1488       __ cbnz(value, not_null);
1489       // Object is null; update MDO and exit
1490       Register mdo  = klass_RInfo;
1491       __ mov_metadata(mdo, md-&gt;constant_encoding());
1492       Address data_addr
1493         = __ form_address(rscratch2, mdo,
1494                           md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()),
1495                           0);
1496       __ ldrb(rscratch1, data_addr);
1497       __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());
1498       __ strb(rscratch1, data_addr);
1499       __ b(done);
1500       __ bind(not_null);
1501     } else {
1502       __ cbz(value, done);
1503     }
1504 
1505     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1506     __ load_klass(k_RInfo, array);
1507     __ load_klass(klass_RInfo, value);
1508 
1509     // get instance klass (it&#39;s already uncompressed)
1510     __ ldr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1511     // perform the fast part of the checking logic
1512     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1513     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1514     __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1515     __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1516     __ ldp(k_RInfo, klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1517     // result is a boolean
1518     __ cbzw(k_RInfo, *failure_target);
1519     // fall through to the success case
1520 
1521     if (should_profile) {
1522       Register mdo  = klass_RInfo, recv = k_RInfo;
1523       __ bind(profile_cast_success);
1524       __ mov_metadata(mdo, md-&gt;constant_encoding());
1525       __ load_klass(recv, value);
1526       Label update_done;
1527       type_profile_helper(mdo, md, data, recv, &amp;done);
1528       __ b(done);
1529 
1530       __ bind(profile_cast_failure);
1531       __ mov_metadata(mdo, md-&gt;constant_encoding());
1532       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1533       __ lea(rscratch2, counter_addr);
1534       __ ldr(rscratch1, Address(rscratch2));
1535       __ sub(rscratch1, rscratch1, DataLayout::counter_increment);
1536       __ str(rscratch1, Address(rscratch2));
1537       __ b(*stub-&gt;entry());
1538     }
1539 
1540     __ bind(done);
1541   } else if (code == lir_checkcast) {
1542     Register obj = op-&gt;object()-&gt;as_register();
1543     Register dst = op-&gt;result_opr()-&gt;as_register();
1544     Label success;
1545     emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1546     __ bind(success);
1547     if (dst != obj) {
1548       __ mov(dst, obj);
1549     }
1550   } else if (code == lir_instanceof) {
1551     Register obj = op-&gt;object()-&gt;as_register();
1552     Register dst = op-&gt;result_opr()-&gt;as_register();
1553     Label success, failure, done;
1554     emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1555     __ bind(failure);
1556     __ mov(dst, zr);
1557     __ b(done);
1558     __ bind(success);
1559     __ mov(dst, 1);
1560     __ bind(done);
1561   } else {
1562     ShouldNotReachHere();
1563   }
1564 }
1565 
1566 void LIR_Assembler::emit_opFlattenedArrayCheck(LIR_OpFlattenedArrayCheck* op) {
1567   // We are loading/storing an array that *may* be a flattened array (the declared type
1568   // Object[], interface[], or VT?[]). If this array is flattened, take slow path.
1569 
1570   __ load_storage_props(op-&gt;tmp()-&gt;as_register(), op-&gt;array()-&gt;as_register());
1571   __ tst(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::flattened_value);
1572   __ br(Assembler::NE, *op-&gt;stub()-&gt;entry());
1573   if (!op-&gt;value()-&gt;is_illegal()) {
1574     // We are storing into the array.
1575     Label skip;
1576     __ tst(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::null_free_value);
1577     __ br(Assembler::EQ, skip);
1578     // The array is not flattened, but it is null_free. If we are storing
1579     // a null, take the slow path (which will throw NPE).
1580     __ cbz(op-&gt;value()-&gt;as_register(), *op-&gt;stub()-&gt;entry());
1581     __ bind(skip);
1582   }
1583 
1584 }
1585 
1586 void LIR_Assembler::emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op) {
1587   // This is called when we use aastore into a an array declared as &quot;[LVT;&quot;,
1588   // where we know VT is not flattened (due to FlatArrayElementMaxSize, etc).
1589   // However, we need to do a NULL check if the actual array is a &quot;[QVT;&quot;.
1590 
1591   __ load_storage_props(op-&gt;tmp()-&gt;as_register(), op-&gt;array()-&gt;as_register());
1592   __ mov(rscratch1, (uint64_t) ArrayStorageProperties::null_free_value);
1593   __ cmp(op-&gt;tmp()-&gt;as_register(), rscratch1);
1594 }
1595 
1596 void LIR_Assembler::emit_opSubstitutabilityCheck(LIR_OpSubstitutabilityCheck* op) {
1597   Label L_oops_equal;
1598   Label L_oops_not_equal;
1599   Label L_end;
1600 
1601   Register left  = op-&gt;left()-&gt;as_register();
1602   Register right = op-&gt;right()-&gt;as_register();
1603 
1604   __ cmp(left, right);
1605   __ br(Assembler::EQ, L_oops_equal);
1606 
1607   // (1) Null check -- if one of the operands is null, the other must not be null (because
1608   //     the two references are not equal), so they are not substitutable,
1609   //     FIXME: do null check only if the operand is nullable
1610   {
1611     __ cbz(left, L_oops_not_equal);
1612     __ cbz(right, L_oops_not_equal);
1613   }
1614 
1615 
1616   ciKlass* left_klass = op-&gt;left_klass();
1617   ciKlass* right_klass = op-&gt;right_klass();
1618 
1619   // (2) Value object check -- if either of the operands is not a value object,
1620   //     they are not substitutable. We do this only if we are not sure that the
1621   //     operands are value objects
1622   if ((left_klass == NULL || right_klass == NULL) ||// The klass is still unloaded, or came from a Phi node.
1623       !left_klass-&gt;is_inlinetype() || !right_klass-&gt;is_inlinetype()) {
1624     Register tmp1  = rscratch1; /* op-&gt;tmp1()-&gt;as_register(); */
1625     Register tmp2  = rscratch2; /* op-&gt;tmp2()-&gt;as_register(); */
1626 
1627     __ mov(tmp1, (intptr_t)markWord::always_locked_pattern);
1628 
1629     __ ldr(tmp2, Address(left, oopDesc::mark_offset_in_bytes()));
1630     __ andr(tmp1, tmp1, tmp2);
1631 
1632     __ ldr(tmp2, Address(right, oopDesc::mark_offset_in_bytes()));
1633     __ andr(tmp1, tmp1, tmp2);
1634 
1635     __ mov(tmp2, (intptr_t)markWord::always_locked_pattern);
1636     __ cmp(tmp1, tmp2);
1637     __ br(Assembler::NE, L_oops_not_equal);
1638   }
1639 
1640   // (3) Same klass check: if the operands are of different klasses, they are not substitutable.
1641   if (left_klass != NULL &amp;&amp; left_klass-&gt;is_inlinetype() &amp;&amp; left_klass == right_klass) {
1642     // No need to load klass -- the operands are statically known to be the same inline klass.
1643     __ b(*op-&gt;stub()-&gt;entry());
1644   } else {
1645     Register left_klass_op = op-&gt;left_klass_op()-&gt;as_register();
1646     Register right_klass_op = op-&gt;right_klass_op()-&gt;as_register();
1647 
1648     if (UseCompressedOops) {
1649       __ ldrw(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));
1650       __ ldrw(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));
1651       __ cmpw(left_klass_op, right_klass_op);
1652     } else {
1653       __ ldr(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));
1654       __ ldr(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));
1655       __ cmp(left_klass_op, right_klass_op);
1656     }
1657 
1658     __ br(Assembler::EQ, *op-&gt;stub()-&gt;entry()); // same klass -&gt; do slow check
1659     // fall through to L_oops_not_equal
1660   }
1661 
1662   __ bind(L_oops_not_equal);
1663   move(op-&gt;not_equal_result(), op-&gt;result_opr());
1664   __ b(L_end);
1665 
1666   __ bind(L_oops_equal);
1667   move(op-&gt;equal_result(), op-&gt;result_opr());
1668   __ b(L_end);
1669 
1670   // We&#39;ve returned from the stub. op-&gt;result_opr() contains 0x0 IFF the two
1671   // operands are not substitutable. (Don&#39;t compare against 0x1 in case the
1672   // C compiler is naughty)
1673   __ bind(*op-&gt;stub()-&gt;continuation());
1674 
1675   if (op-&gt;result_opr()-&gt;type() == T_LONG) {
1676     __ cbzw(op-&gt;result_opr()-&gt;as_register(), L_oops_not_equal); // (call_stub() == 0x0) -&gt; not_equal
1677   } else {
1678     __ cbz(op-&gt;result_opr()-&gt;as_register(), L_oops_not_equal); // (call_stub() == 0x0) -&gt; not_equal
1679   }
1680 
1681   move(op-&gt;equal_result(), op-&gt;result_opr()); // (call_stub() != 0x0) -&gt; equal
1682   // fall-through
1683   __ bind(L_end);
1684 
1685 }
1686 
1687 
1688 void LIR_Assembler::casw(Register addr, Register newval, Register cmpval) {
1689   __ cmpxchg(addr, cmpval, newval, Assembler::word, /* acquire*/ true, /* release*/ true, /* weak*/ false, rscratch1);
1690   __ cset(rscratch1, Assembler::NE);
1691   __ membar(__ AnyAny);
1692 }
1693 
1694 void LIR_Assembler::casl(Register addr, Register newval, Register cmpval) {
1695   __ cmpxchg(addr, cmpval, newval, Assembler::xword, /* acquire*/ true, /* release*/ true, /* weak*/ false, rscratch1);
1696   __ cset(rscratch1, Assembler::NE);
1697   __ membar(__ AnyAny);
1698 }
1699 
1700 
1701 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
1702   assert(VM_Version::supports_cx8(), &quot;wrong machine&quot;);
1703   Register addr;
1704   if (op-&gt;addr()-&gt;is_register()) {
1705     addr = as_reg(op-&gt;addr());
1706   } else {
1707     assert(op-&gt;addr()-&gt;is_address(), &quot;what else?&quot;);
1708     LIR_Address* addr_ptr = op-&gt;addr()-&gt;as_address_ptr();
1709     assert(addr_ptr-&gt;disp() == 0, &quot;need 0 disp&quot;);
1710     assert(addr_ptr-&gt;index() == LIR_OprDesc::illegalOpr(), &quot;need 0 index&quot;);
1711     addr = as_reg(addr_ptr-&gt;base());
1712   }
1713   Register newval = as_reg(op-&gt;new_value());
1714   Register cmpval = as_reg(op-&gt;cmp_value());
1715 
1716   if (op-&gt;code() == lir_cas_obj) {
1717     if (UseCompressedOops) {
1718       Register t1 = op-&gt;tmp1()-&gt;as_register();
1719       assert(op-&gt;tmp1()-&gt;is_valid(), &quot;must be&quot;);
1720       __ encode_heap_oop(t1, cmpval);
1721       cmpval = t1;
1722       __ encode_heap_oop(rscratch2, newval);
1723       newval = rscratch2;
1724       casw(addr, newval, cmpval);
1725     } else {
1726       casl(addr, newval, cmpval);
1727     }
1728   } else if (op-&gt;code() == lir_cas_int) {
1729     casw(addr, newval, cmpval);
1730   } else {
1731     casl(addr, newval, cmpval);
1732   }
1733 }
1734 
1735 
1736 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1737 
1738   Assembler::Condition acond, ncond;
1739   switch (condition) {
1740   case lir_cond_equal:        acond = Assembler::EQ; ncond = Assembler::NE; break;
1741   case lir_cond_notEqual:     acond = Assembler::NE; ncond = Assembler::EQ; break;
1742   case lir_cond_less:         acond = Assembler::LT; ncond = Assembler::GE; break;
1743   case lir_cond_lessEqual:    acond = Assembler::LE; ncond = Assembler::GT; break;
1744   case lir_cond_greaterEqual: acond = Assembler::GE; ncond = Assembler::LT; break;
1745   case lir_cond_greater:      acond = Assembler::GT; ncond = Assembler::LE; break;
1746   case lir_cond_belowEqual:
1747   case lir_cond_aboveEqual:
1748   default:                    ShouldNotReachHere();
1749     acond = Assembler::EQ; ncond = Assembler::NE;  // unreachable
1750   }
1751 
1752   assert(result-&gt;is_single_cpu() || result-&gt;is_double_cpu(),
1753          &quot;expect single register for result&quot;);
1754   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_constant()
1755       &amp;&amp; opr1-&gt;type() == T_INT &amp;&amp; opr2-&gt;type() == T_INT) {
1756     jint val1 = opr1-&gt;as_jint();
1757     jint val2 = opr2-&gt;as_jint();
1758     if (val1 == 0 &amp;&amp; val2 == 1) {
1759       __ cset(result-&gt;as_register(), ncond);
1760       return;
1761     } else if (val1 == 1 &amp;&amp; val2 == 0) {
1762       __ cset(result-&gt;as_register(), acond);
1763       return;
1764     }
1765   }
1766 
1767   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_constant()
1768       &amp;&amp; opr1-&gt;type() == T_LONG &amp;&amp; opr2-&gt;type() == T_LONG) {
1769     jlong val1 = opr1-&gt;as_jlong();
1770     jlong val2 = opr2-&gt;as_jlong();
1771     if (val1 == 0 &amp;&amp; val2 == 1) {
1772       __ cset(result-&gt;as_register_lo(), ncond);
1773       return;
1774     } else if (val1 == 1 &amp;&amp; val2 == 0) {
1775       __ cset(result-&gt;as_register_lo(), acond);
1776       return;
1777     }
1778   }
1779 
1780   if (opr1-&gt;is_stack()) {
1781     stack2reg(opr1, FrameMap::rscratch1_opr, result-&gt;type());
1782     opr1 = FrameMap::rscratch1_opr;
1783   } else if (opr1-&gt;is_constant()) {
1784     LIR_Opr tmp
1785       = opr1-&gt;type() == T_LONG ? FrameMap::rscratch1_long_opr : FrameMap::rscratch1_opr;
1786     const2reg(opr1, tmp, lir_patch_none, NULL);
1787     opr1 = tmp;
1788   }
1789 
1790   if (opr2-&gt;is_stack()) {
1791     stack2reg(opr2, FrameMap::rscratch2_opr, result-&gt;type());
1792     opr2 = FrameMap::rscratch2_opr;
1793   } else if (opr2-&gt;is_constant()) {
1794     LIR_Opr tmp
1795       = opr2-&gt;type() == T_LONG ? FrameMap::rscratch2_long_opr : FrameMap::rscratch2_opr;
1796     const2reg(opr2, tmp, lir_patch_none, NULL);
1797     opr2 = tmp;
1798   }
1799 
1800   if (result-&gt;type() == T_LONG)
1801     __ csel(result-&gt;as_register_lo(), opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo(), acond);
1802   else
1803     __ csel(result-&gt;as_register(), opr1-&gt;as_register(), opr2-&gt;as_register(), acond);
1804 }
1805 
1806 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
1807   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
1808 
1809   if (left-&gt;is_single_cpu()) {
1810     Register lreg = left-&gt;as_register();
1811     Register dreg = as_reg(dest);
1812 
1813     if (right-&gt;is_single_cpu()) {
1814       // cpu register - cpu register
1815 
1816       assert(left-&gt;type() == T_INT &amp;&amp; right-&gt;type() == T_INT &amp;&amp; dest-&gt;type() == T_INT,
1817              &quot;should be&quot;);
1818       Register rreg = right-&gt;as_register();
1819       switch (code) {
1820       case lir_add: __ addw (dest-&gt;as_register(), lreg, rreg); break;
1821       case lir_sub: __ subw (dest-&gt;as_register(), lreg, rreg); break;
1822       case lir_mul: __ mulw (dest-&gt;as_register(), lreg, rreg); break;
1823       default:      ShouldNotReachHere();
1824       }
1825 
1826     } else if (right-&gt;is_double_cpu()) {
1827       Register rreg = right-&gt;as_register_lo();
1828       // single_cpu + double_cpu: can happen with obj+long
1829       assert(code == lir_add || code == lir_sub, &quot;mismatched arithmetic op&quot;);
1830       switch (code) {
1831       case lir_add: __ add(dreg, lreg, rreg); break;
1832       case lir_sub: __ sub(dreg, lreg, rreg); break;
1833       default: ShouldNotReachHere();
1834       }
1835     } else if (right-&gt;is_constant()) {
1836       // cpu register - constant
1837       jlong c;
1838 
1839       // FIXME.  This is fugly: we really need to factor all this logic.
1840       switch(right-&gt;type()) {
1841       case T_LONG:
1842         c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1843         break;
1844       case T_INT:
1845       case T_ADDRESS:
1846         c = right-&gt;as_constant_ptr()-&gt;as_jint();
1847         break;
1848       default:
1849         ShouldNotReachHere();
1850         c = 0;  // unreachable
1851         break;
1852       }
1853 
1854       assert(code == lir_add || code == lir_sub, &quot;mismatched arithmetic op&quot;);
1855       if (c == 0 &amp;&amp; dreg == lreg) {
1856         COMMENT(&quot;effective nop elided&quot;);
1857         return;
1858       }
1859       switch(left-&gt;type()) {
1860       case T_INT:
1861         switch (code) {
1862         case lir_add: __ addw(dreg, lreg, c); break;
1863         case lir_sub: __ subw(dreg, lreg, c); break;
1864         default: ShouldNotReachHere();
1865         }
1866         break;
1867       case T_OBJECT:
1868       case T_ADDRESS:
1869         switch (code) {
1870         case lir_add: __ add(dreg, lreg, c); break;
1871         case lir_sub: __ sub(dreg, lreg, c); break;
1872         default: ShouldNotReachHere();
1873         }
1874         break;
1875       default:
1876         ShouldNotReachHere();
1877       }
1878     } else {
1879       ShouldNotReachHere();
1880     }
1881 
1882   } else if (left-&gt;is_double_cpu()) {
1883     Register lreg_lo = left-&gt;as_register_lo();
1884 
1885     if (right-&gt;is_double_cpu()) {
1886       // cpu register - cpu register
1887       Register rreg_lo = right-&gt;as_register_lo();
1888       switch (code) {
1889       case lir_add: __ add (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1890       case lir_sub: __ sub (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1891       case lir_mul: __ mul (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1892       case lir_div: __ corrected_idivq(dest-&gt;as_register_lo(), lreg_lo, rreg_lo, false, rscratch1); break;
1893       case lir_rem: __ corrected_idivq(dest-&gt;as_register_lo(), lreg_lo, rreg_lo, true, rscratch1); break;
1894       default:
1895         ShouldNotReachHere();
1896       }
1897 
1898     } else if (right-&gt;is_constant()) {
1899       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1900       Register dreg = as_reg(dest);
1901       switch (code) {
1902         case lir_add:
1903         case lir_sub:
1904           if (c == 0 &amp;&amp; dreg == lreg_lo) {
1905             COMMENT(&quot;effective nop elided&quot;);
1906             return;
1907           }
1908           code == lir_add ? __ add(dreg, lreg_lo, c) : __ sub(dreg, lreg_lo, c);
1909           break;
1910         case lir_div:
1911           assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
1912           if (c == 1) {
1913             // move lreg_lo to dreg if divisor is 1
1914             __ mov(dreg, lreg_lo);
1915           } else {
1916             unsigned int shift = exact_log2_long(c);
1917             // use rscratch1 as intermediate result register
1918             __ asr(rscratch1, lreg_lo, 63);
1919             __ add(rscratch1, lreg_lo, rscratch1, Assembler::LSR, 64 - shift);
1920             __ asr(dreg, rscratch1, shift);
1921           }
1922           break;
1923         case lir_rem:
1924           assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
1925           if (c == 1) {
1926             // move 0 to dreg if divisor is 1
1927             __ mov(dreg, zr);
1928           } else {
1929             // use rscratch1 as intermediate result register
1930             __ negs(rscratch1, lreg_lo);
1931             __ andr(dreg, lreg_lo, c - 1);
1932             __ andr(rscratch1, rscratch1, c - 1);
1933             __ csneg(dreg, dreg, rscratch1, Assembler::MI);
1934           }
1935           break;
1936         default:
1937           ShouldNotReachHere();
1938       }
1939     } else {
1940       ShouldNotReachHere();
1941     }
1942   } else if (left-&gt;is_single_fpu()) {
1943     assert(right-&gt;is_single_fpu(), &quot;right hand side of float arithmetics needs to be float register&quot;);
1944     switch (code) {
1945     case lir_add: __ fadds (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1946     case lir_sub: __ fsubs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1947     case lir_mul_strictfp: // fall through
1948     case lir_mul: __ fmuls (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1949     case lir_div_strictfp: // fall through
1950     case lir_div: __ fdivs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1951     default:
1952       ShouldNotReachHere();
1953     }
1954   } else if (left-&gt;is_double_fpu()) {
1955     if (right-&gt;is_double_fpu()) {
1956       // fpu register - fpu register
1957       switch (code) {
1958       case lir_add: __ faddd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1959       case lir_sub: __ fsubd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1960       case lir_mul_strictfp: // fall through
1961       case lir_mul: __ fmuld (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1962       case lir_div_strictfp: // fall through
1963       case lir_div: __ fdivd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1964       default:
1965         ShouldNotReachHere();
1966       }
1967     } else {
1968       if (right-&gt;is_constant()) {
1969         ShouldNotReachHere();
1970       }
1971       ShouldNotReachHere();
1972     }
1973   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
1974     assert(left == dest, &quot;left and dest must be equal&quot;);
1975     ShouldNotReachHere();
1976   } else {
1977     ShouldNotReachHere();
1978   }
1979 }
1980 
1981 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) { Unimplemented(); }
1982 
1983 
1984 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op) {
1985   switch(code) {
1986   case lir_abs : __ fabsd(dest-&gt;as_double_reg(), value-&gt;as_double_reg()); break;
1987   case lir_sqrt: __ fsqrtd(dest-&gt;as_double_reg(), value-&gt;as_double_reg()); break;
1988   default      : ShouldNotReachHere();
1989   }
1990 }
1991 
1992 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
1993 
1994   assert(left-&gt;is_single_cpu() || left-&gt;is_double_cpu(), &quot;expect single or double register&quot;);
1995   Register Rleft = left-&gt;is_single_cpu() ? left-&gt;as_register() :
1996                                            left-&gt;as_register_lo();
1997    if (dst-&gt;is_single_cpu()) {
1998      Register Rdst = dst-&gt;as_register();
1999      if (right-&gt;is_constant()) {
2000        switch (code) {
2001          case lir_logic_and: __ andw (Rdst, Rleft, right-&gt;as_jint()); break;
2002          case lir_logic_or:  __ orrw (Rdst, Rleft, right-&gt;as_jint()); break;
2003          case lir_logic_xor: __ eorw (Rdst, Rleft, right-&gt;as_jint()); break;
2004          default: ShouldNotReachHere(); break;
2005        }
2006      } else {
2007        Register Rright = right-&gt;is_single_cpu() ? right-&gt;as_register() :
2008                                                   right-&gt;as_register_lo();
2009        switch (code) {
2010          case lir_logic_and: __ andw (Rdst, Rleft, Rright); break;
2011          case lir_logic_or:  __ orrw (Rdst, Rleft, Rright); break;
2012          case lir_logic_xor: __ eorw (Rdst, Rleft, Rright); break;
2013          default: ShouldNotReachHere(); break;
2014        }
2015      }
2016    } else {
2017      Register Rdst = dst-&gt;as_register_lo();
2018      if (right-&gt;is_constant()) {
2019        switch (code) {
2020          case lir_logic_and: __ andr (Rdst, Rleft, right-&gt;as_jlong()); break;
2021          case lir_logic_or:  __ orr (Rdst, Rleft, right-&gt;as_jlong()); break;
2022          case lir_logic_xor: __ eor (Rdst, Rleft, right-&gt;as_jlong()); break;
2023          default: ShouldNotReachHere(); break;
2024        }
2025      } else {
2026        Register Rright = right-&gt;is_single_cpu() ? right-&gt;as_register() :
2027                                                   right-&gt;as_register_lo();
2028        switch (code) {
2029          case lir_logic_and: __ andr (Rdst, Rleft, Rright); break;
2030          case lir_logic_or:  __ orr (Rdst, Rleft, Rright); break;
2031          case lir_logic_xor: __ eor (Rdst, Rleft, Rright); break;
2032          default: ShouldNotReachHere(); break;
2033        }
2034      }
2035    }
2036 }
2037 
2038 
2039 
2040 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr illegal, LIR_Opr result, CodeEmitInfo* info) {
2041 
2042   // opcode check
2043   assert((code == lir_idiv) || (code == lir_irem), &quot;opcode must be idiv or irem&quot;);
2044   bool is_irem = (code == lir_irem);
2045 
2046   // operand check
2047   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
2048   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
2049   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
2050   Register lreg = left-&gt;as_register();
2051   Register dreg = result-&gt;as_register();
2052 
2053   // power-of-2 constant check and codegen
2054   if (right-&gt;is_constant()) {
2055     int c = right-&gt;as_constant_ptr()-&gt;as_jint();
2056     assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
2057     if (is_irem) {
2058       if (c == 1) {
2059         // move 0 to dreg if divisor is 1
2060         __ movw(dreg, zr);
2061       } else {
2062         // use rscratch1 as intermediate result register
2063         __ negsw(rscratch1, lreg);
2064         __ andw(dreg, lreg, c - 1);
2065         __ andw(rscratch1, rscratch1, c - 1);
2066         __ csnegw(dreg, dreg, rscratch1, Assembler::MI);
2067       }
2068     } else {
2069       if (c == 1) {
2070         // move lreg to dreg if divisor is 1
2071         __ movw(dreg, lreg);
2072       } else {
2073         unsigned int shift = exact_log2(c);
2074         // use rscratch1 as intermediate result register
2075         __ asrw(rscratch1, lreg, 31);
2076         __ addw(rscratch1, lreg, rscratch1, Assembler::LSR, 32 - shift);
2077         __ asrw(dreg, rscratch1, shift);
2078       }
2079     }
2080   } else {
2081     Register rreg = right-&gt;as_register();
2082     __ corrected_idivl(dreg, lreg, rreg, is_irem, rscratch1);
2083   }
2084 }
2085 
2086 
2087 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
2088   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_single_cpu()) {
2089     // tableswitch
2090     Register reg = as_reg(opr2);
2091     struct tableswitch &amp;table = switches[opr1-&gt;as_constant_ptr()-&gt;as_jint()];
2092     __ tableswitch(reg, table._first_key, table._last_key, table._branches, table._after);
2093   } else if (opr1-&gt;is_single_cpu() || opr1-&gt;is_double_cpu()) {
2094     Register reg1 = as_reg(opr1);
2095     if (opr2-&gt;is_single_cpu()) {
2096       // cpu register - cpu register
2097       Register reg2 = opr2-&gt;as_register();
2098       if (is_reference_type(opr1-&gt;type())) {
2099         __ cmpoop(reg1, reg2);
2100       } else {
2101         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
2102         __ cmpw(reg1, reg2);
2103       }
2104       return;
2105     }
2106     if (opr2-&gt;is_double_cpu()) {
2107       // cpu register - cpu register
2108       Register reg2 = opr2-&gt;as_register_lo();
2109       __ cmp(reg1, reg2);
2110       return;
2111     }
2112 
2113     if (opr2-&gt;is_constant()) {
2114       bool is_32bit = false; // width of register operand
2115       jlong imm;
2116 
2117       switch(opr2-&gt;type()) {
2118       case T_INT:
2119         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
2120         is_32bit = true;
2121         break;
2122       case T_LONG:
2123         imm = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
2124         break;
2125       case T_ADDRESS:
2126         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
2127         break;
2128       case T_METADATA:
2129         imm = (intptr_t)(opr2-&gt;as_constant_ptr()-&gt;as_metadata());
2130         break;
2131       case T_INLINE_TYPE:
2132       case T_OBJECT:
2133       case T_ARRAY:
2134         jobject2reg(opr2-&gt;as_constant_ptr()-&gt;as_jobject(), rscratch1);
2135         __ cmpoop(reg1, rscratch1);
2136         return;
2137       default:
2138         ShouldNotReachHere();
2139         imm = 0;  // unreachable
2140         break;
2141       }
2142 
2143       if (Assembler::operand_valid_for_add_sub_immediate(imm)) {
2144         if (is_32bit)
2145           __ cmpw(reg1, imm);
2146         else
2147           __ subs(zr, reg1, imm);
2148         return;
2149       } else {
2150         __ mov(rscratch1, imm);
2151         if (is_32bit)
2152           __ cmpw(reg1, rscratch1);
2153         else
2154           __ cmp(reg1, rscratch1);
2155         return;
2156       }
2157     } else
2158       ShouldNotReachHere();
2159   } else if (opr1-&gt;is_single_fpu()) {
2160     FloatRegister reg1 = opr1-&gt;as_float_reg();
2161     assert(opr2-&gt;is_single_fpu(), &quot;expect single float register&quot;);
2162     FloatRegister reg2 = opr2-&gt;as_float_reg();
2163     __ fcmps(reg1, reg2);
2164   } else if (opr1-&gt;is_double_fpu()) {
2165     FloatRegister reg1 = opr1-&gt;as_double_reg();
2166     assert(opr2-&gt;is_double_fpu(), &quot;expect double float register&quot;);
2167     FloatRegister reg2 = opr2-&gt;as_double_reg();
2168     __ fcmpd(reg1, reg2);
2169   } else {
2170     ShouldNotReachHere();
2171   }
2172 }
2173 
2174 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
2175   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2176     bool is_unordered_less = (code == lir_ucmp_fd2i);
2177     if (left-&gt;is_single_fpu()) {
2178       __ float_cmp(true, is_unordered_less ? -1 : 1, left-&gt;as_float_reg(), right-&gt;as_float_reg(), dst-&gt;as_register());
2179     } else if (left-&gt;is_double_fpu()) {
2180       __ float_cmp(false, is_unordered_less ? -1 : 1, left-&gt;as_double_reg(), right-&gt;as_double_reg(), dst-&gt;as_register());
2181     } else {
2182       ShouldNotReachHere();
2183     }
2184   } else if (code == lir_cmp_l2i) {
2185     Label done;
2186     __ cmp(left-&gt;as_register_lo(), right-&gt;as_register_lo());
<a name="1" id="anc1"></a><span class="line-modified">2187     __ mov(dst-&gt;as_register(), (u_int64_t)-1L);</span>
2188     __ br(Assembler::LT, done);
2189     __ csinc(dst-&gt;as_register(), zr, zr, Assembler::EQ);
2190     __ bind(done);
2191   } else {
2192     ShouldNotReachHere();
2193   }
2194 }
2195 
2196 
2197 void LIR_Assembler::align_call(LIR_Code code) {  }
2198 
2199 
2200 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
2201   address call = __ trampoline_call(Address(op-&gt;addr(), rtype));
2202   if (call == NULL) {
2203     bailout(&quot;trampoline stub overflow&quot;);
2204     return;
2205   }
2206   add_call_info(code_offset(), op-&gt;info());
2207 }
2208 
2209 
2210 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
2211   address call = __ ic_call(op-&gt;addr());
2212   if (call == NULL) {
2213     bailout(&quot;trampoline stub overflow&quot;);
2214     return;
2215   }
2216   add_call_info(code_offset(), op-&gt;info());
2217 }
2218 
2219 
2220 /* Currently, vtable-dispatch is only enabled for sparc platforms */
2221 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
2222   ShouldNotReachHere();
2223 }
2224 
2225 
2226 void LIR_Assembler::emit_static_call_stub() {
2227   address call_pc = __ pc();
2228   address stub = __ start_a_stub(call_stub_size());
2229   if (stub == NULL) {
2230     bailout(&quot;static call stub overflow&quot;);
2231     return;
2232   }
2233 
2234   int start = __ offset();
2235 
2236   __ relocate(static_stub_Relocation::spec(call_pc));
2237   __ emit_static_call_stub();
2238 
2239   assert(__ offset() - start + CompiledStaticCall::to_trampoline_stub_size()
2240         &lt;= call_stub_size(), &quot;stub too big&quot;);
2241   __ end_a_stub();
2242 }
2243 
2244 
2245 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2246   assert(exceptionOop-&gt;as_register() == r0, &quot;must match&quot;);
2247   assert(exceptionPC-&gt;as_register() == r3, &quot;must match&quot;);
2248 
2249   // exception object is not added to oop map by LinearScan
2250   // (LinearScan assumes that no oops are in fixed registers)
2251   info-&gt;add_register_oop(exceptionOop);
2252   Runtime1::StubID unwind_id;
2253 
2254   // get current pc information
2255   // pc is only needed if the method has an exception handler, the unwind code does not need it.
2256   int pc_for_athrow_offset = __ offset();
2257   InternalAddress pc_for_athrow(__ pc());
2258   __ adr(exceptionPC-&gt;as_register(), pc_for_athrow);
2259   add_call_info(pc_for_athrow_offset, info); // for exception handler
2260 
2261   __ verify_not_null_oop(r0);
2262   // search an exception handler (r0: exception oop, r3: throwing pc)
2263   if (compilation()-&gt;has_fpu_code()) {
2264     unwind_id = Runtime1::handle_exception_id;
2265   } else {
2266     unwind_id = Runtime1::handle_exception_nofpu_id;
2267   }
2268   __ far_call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
2269 
2270   // FIXME: enough room for two byte trap   ????
2271   __ nop();
2272 }
2273 
2274 
2275 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
2276   assert(exceptionOop-&gt;as_register() == r0, &quot;must match&quot;);
2277 
2278   __ b(_unwind_handler_entry);
2279 }
2280 
2281 
2282 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2283   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2284   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2285 
2286   switch (left-&gt;type()) {
2287     case T_INT: {
2288       switch (code) {
2289       case lir_shl:  __ lslvw (dreg, lreg, count-&gt;as_register()); break;
2290       case lir_shr:  __ asrvw (dreg, lreg, count-&gt;as_register()); break;
2291       case lir_ushr: __ lsrvw (dreg, lreg, count-&gt;as_register()); break;
2292       default:
2293         ShouldNotReachHere();
2294         break;
2295       }
2296       break;
2297     case T_LONG:
2298     case T_INLINE_TYPE:
2299     case T_ADDRESS:
2300     case T_OBJECT:
2301       switch (code) {
2302       case lir_shl:  __ lslv (dreg, lreg, count-&gt;as_register()); break;
2303       case lir_shr:  __ asrv (dreg, lreg, count-&gt;as_register()); break;
2304       case lir_ushr: __ lsrv (dreg, lreg, count-&gt;as_register()); break;
2305       default:
2306         ShouldNotReachHere();
2307         break;
2308       }
2309       break;
2310     default:
2311       ShouldNotReachHere();
2312       break;
2313     }
2314   }
2315 }
2316 
2317 
2318 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2319   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2320   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2321 
2322   switch (left-&gt;type()) {
2323     case T_INT: {
2324       switch (code) {
2325       case lir_shl:  __ lslw (dreg, lreg, count); break;
2326       case lir_shr:  __ asrw (dreg, lreg, count); break;
2327       case lir_ushr: __ lsrw (dreg, lreg, count); break;
2328       default:
2329         ShouldNotReachHere();
2330         break;
2331       }
2332       break;
2333     case T_LONG:
2334     case T_ADDRESS:
2335     case T_INLINE_TYPE:
2336     case T_OBJECT:
2337       switch (code) {
2338       case lir_shl:  __ lsl (dreg, lreg, count); break;
2339       case lir_shr:  __ asr (dreg, lreg, count); break;
2340       case lir_ushr: __ lsr (dreg, lreg, count); break;
2341       default:
2342         ShouldNotReachHere();
2343         break;
2344       }
2345       break;
2346     default:
2347       ShouldNotReachHere();
2348       break;
2349     }
2350   }
2351 }
2352 
2353 
2354 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
2355   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2356   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2357   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2358   __ str (r, Address(sp, offset_from_rsp_in_bytes));
2359 }
2360 
2361 
2362 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
2363   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2364   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2365   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2366   __ mov (rscratch1, c);
2367   __ str (rscratch1, Address(sp, offset_from_rsp_in_bytes));
2368 }
2369 
2370 
2371 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
2372   ShouldNotReachHere();
2373   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2374   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2375   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2376   __ lea(rscratch1, __ constant_oop_address(o));
2377   __ str(rscratch1, Address(sp, offset_from_rsp_in_bytes));
2378 }
2379 
2380 void LIR_Assembler::arraycopy_inlinetype_check(Register obj, Register tmp, CodeStub* slow_path, bool is_dest) {
2381   __ load_storage_props(tmp, obj);
2382   if (is_dest) {
2383     // We also take slow path if it&#39;s a null_free destination array, just in case the source array
2384     // contains NULLs.
2385     __ tst(tmp, ArrayStorageProperties::flattened_value | ArrayStorageProperties::null_free_value);
2386   } else {
2387     __ tst(tmp, ArrayStorageProperties::flattened_value);
2388   }
2389   __ br(Assembler::NE, *slow_path-&gt;entry());
2390 }
2391 
2392 
2393 
2394 // This code replaces a call to arraycopy; no exception may
2395 // be thrown in this code, they must be thrown in the System.arraycopy
2396 // activation frame; we could save some checks if this would not be the case
2397 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
2398   ciArrayKlass* default_type = op-&gt;expected_type();
2399   Register src = op-&gt;src()-&gt;as_register();
2400   Register dst = op-&gt;dst()-&gt;as_register();
2401   Register src_pos = op-&gt;src_pos()-&gt;as_register();
2402   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
2403   Register length  = op-&gt;length()-&gt;as_register();
2404   Register tmp = op-&gt;tmp()-&gt;as_register();
2405 
2406   __ resolve(ACCESS_READ, src);
2407   __ resolve(ACCESS_WRITE, dst);
2408 
2409   CodeStub* stub = op-&gt;stub();
2410   int flags = op-&gt;flags();
2411   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
2412   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
2413 
2414   if (flags &amp; LIR_OpArrayCopy::always_slow_path) {
2415     __ b(*stub-&gt;entry());
2416     __ bind(*stub-&gt;continuation());
2417     return;
2418   }
2419 
2420   if (flags &amp; LIR_OpArrayCopy::src_inlinetype_check) {
2421     arraycopy_inlinetype_check(src, tmp, stub, false);
2422   }
2423 
2424   if (flags &amp; LIR_OpArrayCopy::dst_inlinetype_check) {
2425     arraycopy_inlinetype_check(dst, tmp, stub, true);
2426   }
2427 
2428 
2429 
2430   // if we don&#39;t know anything, just go through the generic arraycopy
2431   if (default_type == NULL // || basic_type == T_OBJECT
2432       ) {
2433     Label done;
2434     assert(src == r1 &amp;&amp; src_pos == r2, &quot;mismatch in calling convention&quot;);
2435 
2436     // Save the arguments in case the generic arraycopy fails and we
2437     // have to fall back to the JNI stub
2438     __ stp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2439     __ stp(length,  src_pos, Address(sp, 2*BytesPerWord));
2440     __ str(src,              Address(sp, 4*BytesPerWord));
2441 
2442     address copyfunc_addr = StubRoutines::generic_arraycopy();
2443     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
2444 
2445     // The arguments are in java calling convention so we shift them
2446     // to C convention
2447     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
2448     __ mov(c_rarg0, j_rarg0);
2449     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
2450     __ mov(c_rarg1, j_rarg1);
2451     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
2452     __ mov(c_rarg2, j_rarg2);
2453     assert_different_registers(c_rarg3, j_rarg4);
2454     __ mov(c_rarg3, j_rarg3);
2455     __ mov(c_rarg4, j_rarg4);
2456 #ifndef PRODUCT
2457     if (PrintC1Statistics) {
2458       __ incrementw(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
2459     }
2460 #endif
2461     __ far_call(RuntimeAddress(copyfunc_addr));
2462 
2463     __ cbz(r0, *stub-&gt;continuation());
2464 
2465     // Reload values from the stack so they are where the stub
2466     // expects them.
2467     __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2468     __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
2469     __ ldr(src,              Address(sp, 4*BytesPerWord));
2470 
2471     // r0 is -1^K where K == partial copied count
2472     __ eonw(rscratch1, r0, zr);
2473     // adjust length down and src/end pos up by partial copied count
2474     __ subw(length, length, rscratch1);
2475     __ addw(src_pos, src_pos, rscratch1);
2476     __ addw(dst_pos, dst_pos, rscratch1);
2477     __ b(*stub-&gt;entry());
2478 
2479     __ bind(*stub-&gt;continuation());
2480     return;
2481   }
2482 
2483   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
2484 
2485   int elem_size = type2aelembytes(basic_type);
2486   int shift_amount;
2487   int scale = exact_log2(elem_size);
2488 
2489   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
2490   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
2491   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
2492   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
2493 
2494   // test for NULL
2495   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
2496     __ cbz(src, *stub-&gt;entry());
2497   }
2498   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
2499     __ cbz(dst, *stub-&gt;entry());
2500   }
2501 
2502   // If the compiler was not able to prove that exact type of the source or the destination
2503   // of the arraycopy is an array type, check at runtime if the source or the destination is
2504   // an instance type.
2505   if (flags &amp; LIR_OpArrayCopy::type_check) {
2506     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::dst_objarray)) {
2507       __ load_klass(tmp, dst);
2508       __ ldrw(rscratch1, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2509       __ cmpw(rscratch1, Klass::_lh_neutral_value);
2510       __ br(Assembler::GE, *stub-&gt;entry());
2511     }
2512 
2513     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::src_objarray)) {
2514       __ load_klass(tmp, src);
2515       __ ldrw(rscratch1, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2516       __ cmpw(rscratch1, Klass::_lh_neutral_value);
2517       __ br(Assembler::GE, *stub-&gt;entry());
2518     }
2519   }
2520 
2521   // check if negative
2522   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
2523     __ cmpw(src_pos, 0);
2524     __ br(Assembler::LT, *stub-&gt;entry());
2525   }
2526   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
2527     __ cmpw(dst_pos, 0);
2528     __ br(Assembler::LT, *stub-&gt;entry());
2529   }
2530 
2531   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
2532     __ cmpw(length, 0);
2533     __ br(Assembler::LT, *stub-&gt;entry());
2534   }
2535 
2536   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
2537     __ addw(tmp, src_pos, length);
2538     __ ldrw(rscratch1, src_length_addr);
2539     __ cmpw(tmp, rscratch1);
2540     __ br(Assembler::HI, *stub-&gt;entry());
2541   }
2542   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
2543     __ addw(tmp, dst_pos, length);
2544     __ ldrw(rscratch1, dst_length_addr);
2545     __ cmpw(tmp, rscratch1);
2546     __ br(Assembler::HI, *stub-&gt;entry());
2547   }
2548 
2549   if (flags &amp; LIR_OpArrayCopy::type_check) {
2550     // We don&#39;t know the array types are compatible
2551     if (basic_type != T_OBJECT) {
2552       // Simple test for basic type arrays
2553       if (UseCompressedClassPointers) {
2554         __ ldrw(tmp, src_klass_addr);
2555         __ ldrw(rscratch1, dst_klass_addr);
2556         __ cmpw(tmp, rscratch1);
2557       } else {
2558         __ ldr(tmp, src_klass_addr);
2559         __ ldr(rscratch1, dst_klass_addr);
2560         __ cmp(tmp, rscratch1);
2561       }
2562       __ br(Assembler::NE, *stub-&gt;entry());
2563     } else {
2564       // For object arrays, if src is a sub class of dst then we can
2565       // safely do the copy.
2566       Label cont, slow;
2567 
2568 #define PUSH(r1, r2)                                    \
2569       stp(r1, r2, __ pre(sp, -2 * wordSize));
2570 
2571 #define POP(r1, r2)                                     \
2572       ldp(r1, r2, __ post(sp, 2 * wordSize));
2573 
2574       __ PUSH(src, dst);
2575 
2576       __ load_klass(src, src);
2577       __ load_klass(dst, dst);
2578 
2579       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
2580 
2581       __ PUSH(src, dst);
2582       __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
2583       __ POP(src, dst);
2584 
2585       __ cbnz(src, cont);
2586 
2587       __ bind(slow);
2588       __ POP(src, dst);
2589 
2590       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2591       if (copyfunc_addr != NULL) { // use stub if available
2592         // src is not a sub class of dst so we have to do a
2593         // per-element check.
2594 
2595         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2596         if ((flags &amp; mask) != mask) {
2597           // Check that at least both of them object arrays.
2598           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2599 
2600           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2601             __ load_klass(tmp, src);
2602           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2603             __ load_klass(tmp, dst);
2604           }
2605           int lh_offset = in_bytes(Klass::layout_helper_offset());
2606           Address klass_lh_addr(tmp, lh_offset);
2607           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2608           __ ldrw(rscratch1, klass_lh_addr);
2609           __ mov(rscratch2, objArray_lh);
2610           __ eorw(rscratch1, rscratch1, rscratch2);
2611           __ cbnzw(rscratch1, *stub-&gt;entry());
2612         }
2613 
2614        // Spill because stubs can use any register they like and it&#39;s
2615        // easier to restore just those that we care about.
2616         __ stp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2617         __ stp(length,  src_pos, Address(sp, 2*BytesPerWord));
2618         __ str(src,              Address(sp, 4*BytesPerWord));
2619 
2620         __ lea(c_rarg0, Address(src, src_pos, Address::uxtw(scale)));
2621         __ add(c_rarg0, c_rarg0, arrayOopDesc::base_offset_in_bytes(basic_type));
2622         assert_different_registers(c_rarg0, dst, dst_pos, length);
2623         __ lea(c_rarg1, Address(dst, dst_pos, Address::uxtw(scale)));
2624         __ add(c_rarg1, c_rarg1, arrayOopDesc::base_offset_in_bytes(basic_type));
2625         assert_different_registers(c_rarg1, dst, length);
2626         __ uxtw(c_rarg2, length);
2627         assert_different_registers(c_rarg2, dst);
2628 
2629         __ load_klass(c_rarg4, dst);
2630         __ ldr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
2631         __ ldrw(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
2632         __ far_call(RuntimeAddress(copyfunc_addr));
2633 
2634 #ifndef PRODUCT
2635         if (PrintC1Statistics) {
2636           Label failed;
2637           __ cbnz(r0, failed);
2638           __ incrementw(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
2639           __ bind(failed);
2640         }
2641 #endif
2642 
2643         __ cbz(r0, *stub-&gt;continuation());
2644 
2645 #ifndef PRODUCT
2646         if (PrintC1Statistics) {
2647           __ incrementw(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
2648         }
2649 #endif
2650         assert_different_registers(dst, dst_pos, length, src_pos, src, r0, rscratch1);
2651 
2652         // Restore previously spilled arguments
2653         __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2654         __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
2655         __ ldr(src,              Address(sp, 4*BytesPerWord));
2656 
2657         // return value is -1^K where K is partial copied count
2658         __ eonw(rscratch1, r0, zr);
2659         // adjust length down and src/end pos up by partial copied count
2660         __ subw(length, length, rscratch1);
2661         __ addw(src_pos, src_pos, rscratch1);
2662         __ addw(dst_pos, dst_pos, rscratch1);
2663       }
2664 
2665       __ b(*stub-&gt;entry());
2666 
2667       __ bind(cont);
2668       __ POP(src, dst);
2669     }
2670   }
2671 
2672 #ifdef ASSERT
2673   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2674     // Sanity check the known type with the incoming class.  For the
2675     // primitive case the types must match exactly with src.klass and
2676     // dst.klass each exactly matching the default type.  For the
2677     // object array case, if no type check is needed then either the
2678     // dst type is exactly the expected type and the src type is a
2679     // subtype which we can&#39;t check or src is the same array as dst
2680     // but not necessarily exactly of type default_type.
2681     Label known_ok, halt;
2682     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
2683     if (UseCompressedClassPointers) {
2684       __ encode_klass_not_null(tmp);
2685     }
2686 
2687     if (basic_type != T_OBJECT) {
2688 
2689       if (UseCompressedClassPointers) {
2690         __ ldrw(rscratch1, dst_klass_addr);
2691         __ cmpw(tmp, rscratch1);
2692       } else {
2693         __ ldr(rscratch1, dst_klass_addr);
2694         __ cmp(tmp, rscratch1);
2695       }
2696       __ br(Assembler::NE, halt);
2697       if (UseCompressedClassPointers) {
2698         __ ldrw(rscratch1, src_klass_addr);
2699         __ cmpw(tmp, rscratch1);
2700       } else {
2701         __ ldr(rscratch1, src_klass_addr);
2702         __ cmp(tmp, rscratch1);
2703       }
2704       __ br(Assembler::EQ, known_ok);
2705     } else {
2706       if (UseCompressedClassPointers) {
2707         __ ldrw(rscratch1, dst_klass_addr);
2708         __ cmpw(tmp, rscratch1);
2709       } else {
2710         __ ldr(rscratch1, dst_klass_addr);
2711         __ cmp(tmp, rscratch1);
2712       }
2713       __ br(Assembler::EQ, known_ok);
2714       __ cmp(src, dst);
2715       __ br(Assembler::EQ, known_ok);
2716     }
2717     __ bind(halt);
2718     __ stop(&quot;incorrect type information in arraycopy&quot;);
2719     __ bind(known_ok);
2720   }
2721 #endif
2722 
2723 #ifndef PRODUCT
2724   if (PrintC1Statistics) {
2725     __ incrementw(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
2726   }
2727 #endif
2728 
2729   __ lea(c_rarg0, Address(src, src_pos, Address::uxtw(scale)));
2730   __ add(c_rarg0, c_rarg0, arrayOopDesc::base_offset_in_bytes(basic_type));
2731   assert_different_registers(c_rarg0, dst, dst_pos, length);
2732   __ lea(c_rarg1, Address(dst, dst_pos, Address::uxtw(scale)));
2733   __ add(c_rarg1, c_rarg1, arrayOopDesc::base_offset_in_bytes(basic_type));
2734   assert_different_registers(c_rarg1, dst, length);
2735   __ uxtw(c_rarg2, length);
2736   assert_different_registers(c_rarg2, dst);
2737 
2738   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2739   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2740   const char *name;
2741   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2742 
2743  CodeBlob *cb = CodeCache::find_blob(entry);
2744  if (cb) {
2745    __ far_call(RuntimeAddress(entry));
2746  } else {
2747    __ call_VM_leaf(entry, 3);
2748  }
2749 
2750   __ bind(*stub-&gt;continuation());
2751 }
2752 
2753 
2754 
2755 
2756 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2757   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
2758   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2759   Register lock = op-&gt;lock_opr()-&gt;as_register();
2760   if (!UseFastLocking) {
2761     __ b(*op-&gt;stub()-&gt;entry());
2762   } else if (op-&gt;code() == lir_lock) {
2763     Register scratch = noreg;
2764     if (UseBiasedLocking) {
2765       scratch = op-&gt;scratch_opr()-&gt;as_register();
2766     }
2767     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2768     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
2769     // add debug info for NullPointerException only if one is possible
2770     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
2771     if (op-&gt;info() != NULL) {
2772       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
2773     }
2774     // done
2775   } else if (op-&gt;code() == lir_unlock) {
2776     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2777     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2778   } else {
2779     Unimplemented();
2780   }
2781   __ bind(*op-&gt;stub()-&gt;continuation());
2782 }
2783 
2784 
2785 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2786   ciMethod* method = op-&gt;profiled_method();
2787   int bci          = op-&gt;profiled_bci();
2788   ciMethod* callee = op-&gt;profiled_callee();
2789 
2790   // Update counter for all call types
2791   ciMethodData* md = method-&gt;method_data_or_null();
2792   assert(md != NULL, &quot;Sanity&quot;);
2793   ciProfileData* data = md-&gt;bci_to_data(bci);
2794   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2795   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2796   Register mdo  = op-&gt;mdo()-&gt;as_register();
2797   __ mov_metadata(mdo, md-&gt;constant_encoding());
2798   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
2799   // Perform additional virtual call profiling for invokevirtual and
2800   // invokeinterface bytecodes
2801   if (op-&gt;should_profile_receiver_type()) {
2802     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2803     Register recv = op-&gt;recv()-&gt;as_register();
2804     assert_different_registers(mdo, recv);
2805     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2806     ciKlass* known_klass = op-&gt;known_holder();
2807     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2808       // We know the type that will be seen at this call site; we can
2809       // statically update the MethodData* rather than needing to do
2810       // dynamic tests on the receiver type
2811 
2812       // NOTE: we should probably put a lock around this search to
2813       // avoid collisions by concurrent compilations
2814       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2815       uint i;
2816       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2817         ciKlass* receiver = vc_data-&gt;receiver(i);
2818         if (known_klass-&gt;equals(receiver)) {
2819           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2820           __ addptr(data_addr, DataLayout::counter_increment);
2821           return;
2822         }
2823       }
2824 
2825       // Receiver type not found in profile data; select an empty slot
2826 
2827       // Note that this is less efficient than it should be because it
2828       // always does a write to the receiver part of the
2829       // VirtualCallData rather than just the first time
2830       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2831         ciKlass* receiver = vc_data-&gt;receiver(i);
2832         if (receiver == NULL) {
2833           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
2834           __ mov_metadata(rscratch1, known_klass-&gt;constant_encoding());
2835           __ lea(rscratch2, recv_addr);
2836           __ str(rscratch1, Address(rscratch2));
2837           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2838           __ addptr(data_addr, DataLayout::counter_increment);
2839           return;
2840         }
2841       }
2842     } else {
2843       __ load_klass(recv, recv);
2844       Label update_done;
2845       type_profile_helper(mdo, md, data, recv, &amp;update_done);
2846       // Receiver did not match any saved receiver and there is no empty row for it.
2847       // Increment total counter to indicate polymorphic case.
2848       __ addptr(counter_addr, DataLayout::counter_increment);
2849 
2850       __ bind(update_done);
2851     }
2852   } else {
2853     // Static call
2854     __ addptr(counter_addr, DataLayout::counter_increment);
2855   }
2856 }
2857 
2858 
2859 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
2860   Unimplemented();
2861 }
2862 
2863 
2864 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
2865   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
2866 }
2867 
2868 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
2869   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
2870   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
2871   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
2872   Register crc = op-&gt;crc()-&gt;as_register();
2873   Register val = op-&gt;val()-&gt;as_register();
2874   Register res = op-&gt;result_opr()-&gt;as_register();
2875 
2876   assert_different_registers(val, crc, res);
2877   unsigned long offset;
2878   __ adrp(res, ExternalAddress(StubRoutines::crc_table_addr()), offset);
2879   if (offset) __ add(res, res, offset);
2880 
2881   __ mvnw(crc, crc); // ~crc
2882   __ update_byte_crc32(crc, val, res);
2883   __ mvnw(res, crc); // ~crc
2884 }
2885 
2886 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2887   COMMENT(&quot;emit_profile_type {&quot;);
2888   Register obj = op-&gt;obj()-&gt;as_register();
2889   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
2890   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2891   ciKlass* exact_klass = op-&gt;exact_klass();
2892   intptr_t current_klass = op-&gt;current_klass();
2893   bool not_null = op-&gt;not_null();
2894   bool no_conflict = op-&gt;no_conflict();
2895 
2896   Label update, next, none;
2897 
2898   bool do_null = !not_null;
2899   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2900   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2901 
2902   assert(do_null || do_update, &quot;why are we here?&quot;);
2903   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2904   assert(mdo_addr.base() != rscratch1, &quot;wrong register&quot;);
2905 
2906   __ verify_oop(obj);
2907 
2908   if (tmp != obj) {
2909     __ mov(tmp, obj);
2910   }
2911   if (do_null) {
2912     __ cbnz(tmp, update);
2913     if (!TypeEntries::was_null_seen(current_klass)) {
2914       __ ldr(rscratch2, mdo_addr);
2915       __ orr(rscratch2, rscratch2, TypeEntries::null_seen);
2916       __ str(rscratch2, mdo_addr);
2917     }
2918     if (do_update) {
2919 #ifndef ASSERT
2920       __ b(next);
2921     }
2922 #else
2923       __ b(next);
2924     }
2925   } else {
2926     __ cbnz(tmp, update);
2927     __ stop(&quot;unexpected null obj&quot;);
2928 #endif
2929   }
2930 
2931   __ bind(update);
2932 
2933   if (do_update) {
2934 #ifdef ASSERT
2935     if (exact_klass != NULL) {
2936       Label ok;
2937       __ load_klass(tmp, tmp);
2938       __ mov_metadata(rscratch1, exact_klass-&gt;constant_encoding());
2939       __ eor(rscratch1, tmp, rscratch1);
2940       __ cbz(rscratch1, ok);
2941       __ stop(&quot;exact klass and actual klass differ&quot;);
2942       __ bind(ok);
2943     }
2944 #endif
2945     if (!no_conflict) {
2946       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
2947         if (exact_klass != NULL) {
2948           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
2949         } else {
2950           __ load_klass(tmp, tmp);
2951         }
2952 
2953         __ ldr(rscratch2, mdo_addr);
2954         __ eor(tmp, tmp, rscratch2);
2955         __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2956         // klass seen before, nothing to do. The unknown bit may have been
2957         // set already but no need to check.
2958         __ cbz(rscratch1, next);
2959 
2960         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2961 
2962         if (TypeEntries::is_type_none(current_klass)) {
2963           __ cbz(rscratch2, none);
2964           __ cmp(rscratch2, (u1)TypeEntries::null_seen);
2965           __ br(Assembler::EQ, none);
2966           // There is a chance that the checks above (re-reading profiling
2967           // data from memory) fail if another thread has just set the
2968           // profiling to this obj&#39;s klass
2969           __ dmb(Assembler::ISHLD);
2970           __ ldr(rscratch2, mdo_addr);
2971           __ eor(tmp, tmp, rscratch2);
2972           __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2973           __ cbz(rscratch1, next);
2974         }
2975       } else {
2976         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2977                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
2978 
2979         __ ldr(tmp, mdo_addr);
2980         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2981       }
2982 
2983       // different than before. Cannot keep accurate profile.
2984       __ ldr(rscratch2, mdo_addr);
2985       __ orr(rscratch2, rscratch2, TypeEntries::type_unknown);
2986       __ str(rscratch2, mdo_addr);
2987 
2988       if (TypeEntries::is_type_none(current_klass)) {
2989         __ b(next);
2990 
2991         __ bind(none);
2992         // first time here. Set profile type.
2993         __ str(tmp, mdo_addr);
2994       }
2995     } else {
2996       // There&#39;s a single possible klass at this profile point
2997       assert(exact_klass != NULL, &quot;should be&quot;);
2998       if (TypeEntries::is_type_none(current_klass)) {
2999         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3000         __ ldr(rscratch2, mdo_addr);
3001         __ eor(tmp, tmp, rscratch2);
3002         __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
3003         __ cbz(rscratch1, next);
3004 #ifdef ASSERT
3005         {
3006           Label ok;
3007           __ ldr(rscratch1, mdo_addr);
3008           __ cbz(rscratch1, ok);
3009           __ cmp(rscratch1, (u1)TypeEntries::null_seen);
3010           __ br(Assembler::EQ, ok);
3011           // may have been set by another thread
3012           __ dmb(Assembler::ISHLD);
3013           __ mov_metadata(rscratch1, exact_klass-&gt;constant_encoding());
3014           __ ldr(rscratch2, mdo_addr);
3015           __ eor(rscratch2, rscratch1, rscratch2);
3016           __ andr(rscratch2, rscratch2, TypeEntries::type_mask);
3017           __ cbz(rscratch2, ok);
3018 
3019           __ stop(&quot;unexpected profiling mismatch&quot;);
3020           __ bind(ok);
3021         }
3022 #endif
3023         // first time here. Set profile type.
3024         __ ldr(tmp, mdo_addr);
3025       } else {
3026         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3027                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3028 
3029         __ ldr(tmp, mdo_addr);
3030         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
3031 
3032         __ orr(tmp, tmp, TypeEntries::type_unknown);
3033         __ str(tmp, mdo_addr);
3034         // FIXME: Write barrier needed here?
3035       }
3036     }
3037 
3038     __ bind(next);
3039   }
3040   COMMENT(&quot;} emit_profile_type&quot;);
3041 }
3042 
3043 
3044 void LIR_Assembler::align_backward_branch_target() {
3045 }
3046 
3047 
3048 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
3049   // tmp must be unused
3050   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
3051 
3052   if (left-&gt;is_single_cpu()) {
3053     assert(dest-&gt;is_single_cpu(), &quot;expect single result reg&quot;);
3054     __ negw(dest-&gt;as_register(), left-&gt;as_register());
3055   } else if (left-&gt;is_double_cpu()) {
3056     assert(dest-&gt;is_double_cpu(), &quot;expect double result reg&quot;);
3057     __ neg(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
3058   } else if (left-&gt;is_single_fpu()) {
3059     assert(dest-&gt;is_single_fpu(), &quot;expect single float result reg&quot;);
3060     __ fnegs(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
3061   } else {
3062     assert(left-&gt;is_double_fpu(), &quot;expect double float operand reg&quot;);
3063     assert(dest-&gt;is_double_fpu(), &quot;expect double float result reg&quot;);
3064     __ fnegd(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
3065   }
3066 }
3067 
3068 
3069 void LIR_Assembler::leal(LIR_Opr addr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
3070   if (patch_code != lir_patch_none) {
3071     deoptimize_trap(info);
3072     return;
3073   }
3074 
3075   __ lea(dest-&gt;as_register_lo(), as_Address(addr-&gt;as_address_ptr()));
3076 }
3077 
3078 
3079 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
3080   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
3081 
3082   CodeBlob *cb = CodeCache::find_blob(dest);
3083   if (cb) {
3084     __ far_call(RuntimeAddress(dest));
3085   } else {
3086     __ mov(rscratch1, RuntimeAddress(dest));
3087     __ blr(rscratch1);
3088   }
3089 
3090   if (info != NULL) {
3091     add_call_info_here(info);
3092   }
3093   __ maybe_isb();
3094 }
3095 
3096 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
3097   if (dest-&gt;is_address() || src-&gt;is_address()) {
3098     move_op(src, dest, type, lir_patch_none, info,
3099             /*pop_fpu_stack*/false, /*unaligned*/false, /*wide*/false);
3100   } else {
3101     ShouldNotReachHere();
3102   }
3103 }
3104 
3105 #ifdef ASSERT
3106 // emit run-time assertion
3107 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
3108   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
3109 
3110   if (op-&gt;in_opr1()-&gt;is_valid()) {
3111     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
3112     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
3113   } else {
3114     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
3115     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
3116   }
3117 
3118   Label ok;
3119   if (op-&gt;condition() != lir_cond_always) {
3120     Assembler::Condition acond = Assembler::AL;
3121     switch (op-&gt;condition()) {
3122       case lir_cond_equal:        acond = Assembler::EQ;  break;
3123       case lir_cond_notEqual:     acond = Assembler::NE;  break;
3124       case lir_cond_less:         acond = Assembler::LT;  break;
3125       case lir_cond_lessEqual:    acond = Assembler::LE;  break;
3126       case lir_cond_greaterEqual: acond = Assembler::GE;  break;
3127       case lir_cond_greater:      acond = Assembler::GT;  break;
3128       case lir_cond_belowEqual:   acond = Assembler::LS;  break;
3129       case lir_cond_aboveEqual:   acond = Assembler::HS;  break;
3130       default:                    ShouldNotReachHere();
3131     }
3132     __ br(acond, ok);
3133   }
3134   if (op-&gt;halt()) {
3135     const char* str = __ code_string(op-&gt;msg());
3136     __ stop(str);
3137   } else {
3138     breakpoint();
3139   }
3140   __ bind(ok);
3141 }
3142 #endif
3143 
3144 #ifndef PRODUCT
3145 #define COMMENT(x)   do { __ block_comment(x); } while (0)
3146 #else
3147 #define COMMENT(x)
3148 #endif
3149 
3150 void LIR_Assembler::membar() {
3151   COMMENT(&quot;membar&quot;);
3152   __ membar(MacroAssembler::AnyAny);
3153 }
3154 
3155 void LIR_Assembler::membar_acquire() {
3156   __ membar(Assembler::LoadLoad|Assembler::LoadStore);
3157 }
3158 
3159 void LIR_Assembler::membar_release() {
3160   __ membar(Assembler::LoadStore|Assembler::StoreStore);
3161 }
3162 
3163 void LIR_Assembler::membar_loadload() {
3164   __ membar(Assembler::LoadLoad);
3165 }
3166 
3167 void LIR_Assembler::membar_storestore() {
3168   __ membar(MacroAssembler::StoreStore);
3169 }
3170 
3171 void LIR_Assembler::membar_loadstore() { __ membar(MacroAssembler::LoadStore); }
3172 
3173 void LIR_Assembler::membar_storeload() { __ membar(MacroAssembler::StoreLoad); }
3174 
3175 void LIR_Assembler::on_spin_wait() {
3176   Unimplemented();
3177 }
3178 
3179 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
3180   __ mov(result_reg-&gt;as_register(), rthread);
3181 }
3182 
3183 
3184 void LIR_Assembler::peephole(LIR_List *lir) {
3185 #if 0
3186   if (tableswitch_count &gt;= max_tableswitches)
3187     return;
3188 
3189   /*
3190     This finite-state automaton recognizes sequences of compare-and-
3191     branch instructions.  We will turn them into a tableswitch.  You
3192     could argue that C1 really shouldn&#39;t be doing this sort of
3193     optimization, but without it the code is really horrible.
3194   */
3195 
3196   enum { start_s, cmp1_s, beq_s, cmp_s } state;
3197   int first_key, last_key = -2147483648;
3198   int next_key = 0;
3199   int start_insn = -1;
3200   int last_insn = -1;
3201   Register reg = noreg;
3202   LIR_Opr reg_opr;
3203   state = start_s;
3204 
3205   LIR_OpList* inst = lir-&gt;instructions_list();
3206   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3207     LIR_Op* op = inst-&gt;at(i);
3208     switch (state) {
3209     case start_s:
3210       first_key = -1;
3211       start_insn = i;
3212       switch (op-&gt;code()) {
3213       case lir_cmp:
3214         LIR_Opr opr1 = op-&gt;as_Op2()-&gt;in_opr1();
3215         LIR_Opr opr2 = op-&gt;as_Op2()-&gt;in_opr2();
3216         if (opr1-&gt;is_cpu_register() &amp;&amp; opr1-&gt;is_single_cpu()
3217             &amp;&amp; opr2-&gt;is_constant()
3218             &amp;&amp; opr2-&gt;type() == T_INT) {
3219           reg_opr = opr1;
3220           reg = opr1-&gt;as_register();
3221           first_key = opr2-&gt;as_constant_ptr()-&gt;as_jint();
3222           next_key = first_key + 1;
3223           state = cmp_s;
3224           goto next_state;
3225         }
3226         break;
3227       }
3228       break;
3229     case cmp_s:
3230       switch (op-&gt;code()) {
3231       case lir_branch:
3232         if (op-&gt;as_OpBranch()-&gt;cond() == lir_cond_equal) {
3233           state = beq_s;
3234           last_insn = i;
3235           goto next_state;
3236         }
3237       }
3238       state = start_s;
3239       break;
3240     case beq_s:
3241       switch (op-&gt;code()) {
3242       case lir_cmp: {
3243         LIR_Opr opr1 = op-&gt;as_Op2()-&gt;in_opr1();
3244         LIR_Opr opr2 = op-&gt;as_Op2()-&gt;in_opr2();
3245         if (opr1-&gt;is_cpu_register() &amp;&amp; opr1-&gt;is_single_cpu()
3246             &amp;&amp; opr1-&gt;as_register() == reg
3247             &amp;&amp; opr2-&gt;is_constant()
3248             &amp;&amp; opr2-&gt;type() == T_INT
3249             &amp;&amp; opr2-&gt;as_constant_ptr()-&gt;as_jint() == next_key) {
3250           last_key = next_key;
3251           next_key++;
3252           state = cmp_s;
3253           goto next_state;
3254         }
3255       }
3256       }
3257       last_key = next_key;
3258       state = start_s;
3259       break;
3260     default:
3261       assert(false, &quot;impossible state&quot;);
3262     }
3263     if (state == start_s) {
3264       if (first_key &lt; last_key - 5L &amp;&amp; reg != noreg) {
3265         {
3266           // printf(&quot;found run register %d starting at insn %d low value %d high value %d\n&quot;,
3267           //        reg-&gt;encoding(),
3268           //        start_insn, first_key, last_key);
3269           //   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3270           //     inst-&gt;at(i)-&gt;print();
3271           //     tty-&gt;print(&quot;\n&quot;);
3272           //   }
3273           //   tty-&gt;print(&quot;\n&quot;);
3274         }
3275 
3276         struct tableswitch *sw = &amp;switches[tableswitch_count];
3277         sw-&gt;_insn_index = start_insn, sw-&gt;_first_key = first_key,
3278           sw-&gt;_last_key = last_key, sw-&gt;_reg = reg;
3279         inst-&gt;insert_before(last_insn + 1, new LIR_OpLabel(&amp;sw-&gt;_after));
3280         {
3281           // Insert the new table of branches
3282           int offset = last_insn;
3283           for (int n = first_key; n &lt; last_key; n++) {
3284             inst-&gt;insert_before
3285               (last_insn + 1,
3286                new LIR_OpBranch(lir_cond_always, T_ILLEGAL,
3287                                 inst-&gt;at(offset)-&gt;as_OpBranch()-&gt;label()));
3288             offset -= 2, i++;
3289           }
3290         }
3291         // Delete all the old compare-and-branch instructions
3292         for (int n = first_key; n &lt; last_key; n++) {
3293           inst-&gt;remove_at(start_insn);
3294           inst-&gt;remove_at(start_insn);
3295         }
3296         // Insert the tableswitch instruction
3297         inst-&gt;insert_before(start_insn,
3298                             new LIR_Op2(lir_cmp, lir_cond_always,
3299                                         LIR_OprFact::intConst(tableswitch_count),
3300                                         reg_opr));
3301         inst-&gt;insert_before(start_insn + 1, new LIR_OpLabel(&amp;sw-&gt;_branches));
3302         tableswitch_count++;
3303       }
3304       reg = noreg;
3305       last_key = -2147483648;
3306     }
3307   next_state:
3308     ;
3309   }
3310 #endif
3311 }
3312 
3313 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp_op) {
3314   Address addr = as_Address(src-&gt;as_address_ptr());
3315   BasicType type = src-&gt;type();
3316   bool is_oop = is_reference_type(type);
3317 
3318   void (MacroAssembler::* add)(Register prev, RegisterOrConstant incr, Register addr);
3319   void (MacroAssembler::* xchg)(Register prev, Register newv, Register addr);
3320 
3321   switch(type) {
3322   case T_INT:
3323     xchg = &amp;MacroAssembler::atomic_xchgalw;
3324     add = &amp;MacroAssembler::atomic_addalw;
3325     break;
3326   case T_LONG:
3327     xchg = &amp;MacroAssembler::atomic_xchgal;
3328     add = &amp;MacroAssembler::atomic_addal;
3329     break;
3330   case T_INLINE_TYPE:
3331   case T_OBJECT:
3332   case T_ARRAY:
3333     if (UseCompressedOops) {
3334       xchg = &amp;MacroAssembler::atomic_xchgalw;
3335       add = &amp;MacroAssembler::atomic_addalw;
3336     } else {
3337       xchg = &amp;MacroAssembler::atomic_xchgal;
3338       add = &amp;MacroAssembler::atomic_addal;
3339     }
3340     break;
3341   default:
3342     ShouldNotReachHere();
3343     xchg = &amp;MacroAssembler::atomic_xchgal;
3344     add = &amp;MacroAssembler::atomic_addal; // unreachable
3345   }
3346 
3347   switch (code) {
3348   case lir_xadd:
3349     {
3350       RegisterOrConstant inc;
3351       Register tmp = as_reg(tmp_op);
3352       Register dst = as_reg(dest);
3353       if (data-&gt;is_constant()) {
3354         inc = RegisterOrConstant(as_long(data));
3355         assert_different_registers(dst, addr.base(), tmp,
3356                                    rscratch1, rscratch2);
3357       } else {
3358         inc = RegisterOrConstant(as_reg(data));
3359         assert_different_registers(inc.as_register(), dst, addr.base(), tmp,
3360                                    rscratch1, rscratch2);
3361       }
3362       __ lea(tmp, addr);
3363       (_masm-&gt;*add)(dst, inc, tmp);
3364       break;
3365     }
3366   case lir_xchg:
3367     {
3368       Register tmp = tmp_op-&gt;as_register();
3369       Register obj = as_reg(data);
3370       Register dst = as_reg(dest);
3371       if (is_oop &amp;&amp; UseCompressedOops) {
3372         __ encode_heap_oop(rscratch2, obj);
3373         obj = rscratch2;
3374       }
3375       assert_different_registers(obj, addr.base(), tmp, rscratch1, dst);
3376       __ lea(tmp, addr);
3377       (_masm-&gt;*xchg)(dst, obj, tmp);
3378       if (is_oop &amp;&amp; UseCompressedOops) {
3379         __ decode_heap_oop(dst);
3380       }
3381     }
3382     break;
3383   default:
3384     ShouldNotReachHere();
3385   }
3386   __ membar(__ AnyAny);
3387 }
3388 
3389 #undef __
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>