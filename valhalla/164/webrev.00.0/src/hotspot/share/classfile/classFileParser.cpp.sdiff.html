<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/aarch64/templateTable_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4164                    super_class_index,
4165                    CHECK_NULL);
4166     // The class name should be legal because it is checked when parsing constant pool.
4167     // However, make sure it is not an array type.
4168     bool is_array = false;
4169     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4170       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4171       if (need_verify)
4172         is_array = super_klass-&gt;is_array_klass();
4173     } else if (need_verify) {
4174       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4175     }
4176     if (need_verify) {
4177       guarantee_property(!is_array,
4178                         &quot;Bad superclass name in class file %s&quot;, CHECK_NULL);
4179     }
4180   }
4181   return super_klass;
4182 }
4183 
<span class="line-removed">4184 #ifndef PRODUCT</span>
<span class="line-removed">4185 static void print_field_layout(const Symbol* name,</span>
<span class="line-removed">4186                                Array&lt;u2&gt;* fields,</span>
<span class="line-removed">4187                                ConstantPool* cp,</span>
<span class="line-removed">4188                                int instance_size,</span>
<span class="line-removed">4189                                int instance_fields_start,</span>
<span class="line-removed">4190                                int instance_fields_end,</span>
<span class="line-removed">4191                                int static_fields_end) {</span>
<span class="line-removed">4192 </span>
<span class="line-removed">4193   assert(name != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">4194 </span>
<span class="line-removed">4195   tty-&gt;print(&quot;%s: field layout\n&quot;, name-&gt;as_klass_external_name());</span>
<span class="line-removed">4196   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_start, &quot;--- instance fields start ---&quot;);</span>
<span class="line-removed">4197   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-removed">4198     if (!fs.access_flags().is_static()) {</span>
<span class="line-removed">4199       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,</span>
<span class="line-removed">4200         fs.offset(),</span>
<span class="line-removed">4201         fs.name()-&gt;as_klass_external_name(),</span>
<span class="line-removed">4202         fs.signature()-&gt;as_klass_external_name());</span>
<span class="line-removed">4203     }</span>
<span class="line-removed">4204   }</span>
<span class="line-removed">4205   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_end, &quot;--- instance fields end ---&quot;);</span>
<span class="line-removed">4206   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_size * wordSize, &quot;--- instance ends ---&quot;);</span>
<span class="line-removed">4207   tty-&gt;print(&quot;  @%3d %s\n&quot;, InstanceMirrorKlass::offset_of_static_fields(), &quot;--- static fields start ---&quot;);</span>
<span class="line-removed">4208   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-removed">4209     if (fs.access_flags().is_static()) {</span>
<span class="line-removed">4210       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,</span>
<span class="line-removed">4211         fs.offset(),</span>
<span class="line-removed">4212         fs.name()-&gt;as_klass_external_name(),</span>
<span class="line-removed">4213         fs.signature()-&gt;as_klass_external_name());</span>
<span class="line-removed">4214     }</span>
<span class="line-removed">4215   }</span>
<span class="line-removed">4216   tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);</span>
<span class="line-removed">4217   tty-&gt;print(&quot;\n&quot;);</span>
<span class="line-removed">4218 }</span>
<span class="line-removed">4219 #endif</span>
<span class="line-removed">4220 </span>
4221 OopMapBlocksBuilder::OopMapBlocksBuilder(unsigned int max_blocks) {
4222   _max_nonstatic_oop_maps = max_blocks;
4223   _nonstatic_oop_map_count = 0;
4224   if (max_blocks == 0) {
4225     _nonstatic_oop_maps = NULL;
4226   } else {
4227     _nonstatic_oop_maps =
4228         NEW_RESOURCE_ARRAY(OopMapBlock, _max_nonstatic_oop_maps);
4229     memset(_nonstatic_oop_maps, 0, sizeof(OopMapBlock) * max_blocks);
4230   }
4231 }
4232 
4233 OopMapBlock* OopMapBlocksBuilder::last_oop_map() const {
4234   assert(_nonstatic_oop_map_count &gt; 0, &quot;Has no oop maps&quot;);
4235   return _nonstatic_oop_maps + (_nonstatic_oop_map_count - 1);
4236 }
4237 
4238 // addition of super oop maps
4239 void OopMapBlocksBuilder::initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks) {
4240   assert(nof_blocks &amp;&amp; _nonstatic_oop_map_count == 0 &amp;&amp;
</pre>
<hr />
<pre>
4336 
4337 void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,
4338                                                 const char* msg,
4339                                                 const Symbol* name,
4340                                                 const Symbol* sig) const {
4341 
4342   ResourceMark rm(THREAD);
4343   if (name == NULL || sig == NULL) {
4344     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4345         vmSymbols::java_lang_ClassFormatError(),
4346         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);
4347   }
4348   else {
4349     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4350         vmSymbols::java_lang_ClassFormatError(),
4351         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),
4352         _class_name-&gt;as_C_string(), msg);
4353   }
4354 }
4355 
<span class="line-removed">4356 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!</span>
<span class="line-removed">4357 void ClassFileParser::layout_fields(ConstantPool* cp,</span>
<span class="line-removed">4358                                     const FieldAllocationCount* fac,</span>
<span class="line-removed">4359                                     const ClassAnnotationCollector* parsed_annotations,</span>
<span class="line-removed">4360                                     FieldLayoutInfo* info,</span>
<span class="line-removed">4361                                     TRAPS) {</span>
<span class="line-removed">4362 </span>
<span class="line-removed">4363   assert(cp != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">4364 </span>
<span class="line-removed">4365   // Field size and offset computation</span>
<span class="line-removed">4366   int nonstatic_field_size = _super_klass == NULL ? 0 :</span>
<span class="line-removed">4367                                _super_klass-&gt;nonstatic_field_size();</span>
<span class="line-removed">4368   int next_nonstatic_inline_type_offset = 0;</span>
<span class="line-removed">4369   int first_nonstatic_inline_type_offset = 0;</span>
<span class="line-removed">4370 </span>
<span class="line-removed">4371   // Fields that are inline types are handled differently depending if they are static or not:</span>
<span class="line-removed">4372   // - static fields are oops</span>
<span class="line-removed">4373   // - non-static fields are embedded</span>
<span class="line-removed">4374 </span>
<span class="line-removed">4375   // Count the contended fields by type.</span>
<span class="line-removed">4376   //</span>
<span class="line-removed">4377   // We ignore static fields, because @Contended is not supported for them.</span>
<span class="line-removed">4378   // The layout code below will also ignore the static fields.</span>
<span class="line-removed">4379   int nonstatic_contended_count = 0;</span>
<span class="line-removed">4380   FieldAllocationCount fac_contended;</span>
<span class="line-removed">4381   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-removed">4382     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();</span>
<span class="line-removed">4383     if (fs.is_contended()) {</span>
<span class="line-removed">4384       fac_contended.count[atype]++;</span>
<span class="line-removed">4385       if (!fs.access_flags().is_static()) {</span>
<span class="line-removed">4386         nonstatic_contended_count++;</span>
<span class="line-removed">4387       }</span>
<span class="line-removed">4388     }</span>
<span class="line-removed">4389   }</span>
<span class="line-removed">4390 </span>
<span class="line-removed">4391 </span>
<span class="line-removed">4392   // Calculate the starting byte offsets</span>
<span class="line-removed">4393   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();</span>
<span class="line-removed">4394   // Inline types in static fields are not embedded, they are handled with oops</span>
<span class="line-removed">4395   int next_static_double_offset = next_static_oop_offset +</span>
<span class="line-removed">4396                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_INLINE]) * heapOopSize);</span>
<span class="line-removed">4397   if (fac-&gt;count[STATIC_DOUBLE]) {</span>
<span class="line-removed">4398     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);</span>
<span class="line-removed">4399   }</span>
<span class="line-removed">4400 </span>
<span class="line-removed">4401   int next_static_word_offset   = next_static_double_offset +</span>
<span class="line-removed">4402                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);</span>
<span class="line-removed">4403   int next_static_short_offset  = next_static_word_offset +</span>
<span class="line-removed">4404                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);</span>
<span class="line-removed">4405   int next_static_byte_offset   = next_static_short_offset +</span>
<span class="line-removed">4406                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);</span>
<span class="line-removed">4407 </span>
<span class="line-removed">4408   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +</span>
<span class="line-removed">4409                                 nonstatic_field_size * heapOopSize;</span>
<span class="line-removed">4410 </span>
<span class="line-removed">4411   // First field of inline types is aligned on a long boundary in order to ease</span>
<span class="line-removed">4412   // in-lining of inline types (with header removal) in packed arrays and</span>
<span class="line-removed">4413   // inlined fields</span>
<span class="line-removed">4414   int initial_inline_type_padding = 0;</span>
<span class="line-removed">4415   if (is_inline_type()) {</span>
<span class="line-removed">4416     int old = nonstatic_fields_start;</span>
<span class="line-removed">4417     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);</span>
<span class="line-removed">4418     initial_inline_type_padding = nonstatic_fields_start - old;</span>
<span class="line-removed">4419   }</span>
<span class="line-removed">4420 </span>
<span class="line-removed">4421   int next_nonstatic_field_offset = nonstatic_fields_start;</span>
<span class="line-removed">4422 </span>
<span class="line-removed">4423   const bool is_contended_class     = parsed_annotations-&gt;is_contended();</span>
<span class="line-removed">4424 </span>
<span class="line-removed">4425   // Class is contended, pad before all the fields</span>
<span class="line-removed">4426   if (is_contended_class) {</span>
<span class="line-removed">4427     next_nonstatic_field_offset += ContendedPaddingWidth;</span>
<span class="line-removed">4428   }</span>
<span class="line-removed">4429 </span>
<span class="line-removed">4430   // Temporary inline types restrictions</span>
<span class="line-removed">4431   if (is_inline_type()) {</span>
<span class="line-removed">4432     if (is_contended_class) {</span>
<span class="line-removed">4433       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);</span>
<span class="line-removed">4434       return;</span>
<span class="line-removed">4435     }</span>
<span class="line-removed">4436   }</span>
<span class="line-removed">4437 </span>
<span class="line-removed">4438   // Compute the non-contended fields count.</span>
<span class="line-removed">4439   // The packing code below relies on these counts to determine if some field</span>
<span class="line-removed">4440   // can be squeezed into the alignment gap. Contended fields are obviously</span>
<span class="line-removed">4441   // exempt from that.</span>
<span class="line-removed">4442   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];</span>
<span class="line-removed">4443   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];</span>
<span class="line-removed">4444   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];</span>
<span class="line-removed">4445   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];</span>
<span class="line-removed">4446   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];</span>
<span class="line-removed">4447 </span>
<span class="line-removed">4448   int static_inline_type_count = 0;</span>
<span class="line-removed">4449   int nonstatic_inline_type_count = 0;</span>
<span class="line-removed">4450   int* nonstatic_inline_type_indexes = NULL;</span>
<span class="line-removed">4451   Klass** nonstatic_inline_type_klasses = NULL;</span>
<span class="line-removed">4452   unsigned int inline_type_oop_map_count = 0;</span>
<span class="line-removed">4453   int inline_types_not_inlined = 0;</span>
<span class="line-removed">4454   int not_atomic_inline_types = 0;</span>
<span class="line-removed">4455 </span>
<span class="line-removed">4456   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_INLINE] + 1;</span>
<span class="line-removed">4457 </span>
<span class="line-removed">4458   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,</span>
<span class="line-removed">4459                                                                max_nonstatic_inline_type);</span>
<span class="line-removed">4460   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {</span>
<span class="line-removed">4461     nonstatic_inline_type_indexes[i] = -1;</span>
<span class="line-removed">4462   }</span>
<span class="line-removed">4463   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,</span>
<span class="line-removed">4464                                                                max_nonstatic_inline_type);</span>
<span class="line-removed">4465 </span>
<span class="line-removed">4466   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {</span>
<span class="line-removed">4467     if (fs.allocation_type() == STATIC_INLINE) {</span>
<span class="line-removed">4468       ResourceMark rm;</span>
<span class="line-removed">4469       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-removed">4470         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-removed">4471       }</span>
<span class="line-removed">4472       static_inline_type_count++;</span>
<span class="line-removed">4473     } else if (fs.allocation_type() == NONSTATIC_INLINE) {</span>
<span class="line-removed">4474       // Pre-resolve the inline field and check for inline type circularity issues.</span>
<span class="line-removed">4475       ResourceMark rm;</span>
<span class="line-removed">4476       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-removed">4477         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-removed">4478       }</span>
<span class="line-removed">4479       Klass* klass =</span>
<span class="line-removed">4480         SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,</span>
<span class="line-removed">4481                                                             Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-removed">4482                                                             _protection_domain, true, CHECK);</span>
<span class="line-removed">4483       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-removed">4484       if (!klass-&gt;access_flags().is_inline_type()) {</span>
<span class="line-removed">4485         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-removed">4486       }</span>
<span class="line-removed">4487       InlineKlass* vk = InlineKlass::cast(klass);</span>
<span class="line-removed">4488       // Conditions to apply flattening or not should be defined in a single place</span>
<span class="line-removed">4489       bool too_big_to_allocate_inline = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-removed">4490                                  (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);</span>
<span class="line-removed">4491       bool too_atomic_to_allocate_inline = vk-&gt;is_declared_atomic();</span>
<span class="line-removed">4492       bool too_volatile_to_allocate_inline = fs.access_flags().is_volatile();</span>
<span class="line-removed">4493       if (vk-&gt;is_naturally_atomic()) {</span>
<span class="line-removed">4494         too_atomic_to_allocate_inline = false;</span>
<span class="line-removed">4495         // too_volatile_to_allocate_inline = false; //FIXME</span>
<span class="line-removed">4496         // volatile fields are currently never inlined, this could change in the future</span>
<span class="line-removed">4497       }</span>
<span class="line-removed">4498       if (!(too_big_to_allocate_inline | too_atomic_to_allocate_inline | too_volatile_to_allocate_inline)) {</span>
<span class="line-removed">4499         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();</span>
<span class="line-removed">4500         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;</span>
<span class="line-removed">4501         nonstatic_inline_type_count++;</span>
<span class="line-removed">4502 </span>
<span class="line-removed">4503         InlineKlass* vklass = InlineKlass::cast(klass);</span>
<span class="line-removed">4504         if (vklass-&gt;contains_oops()) {</span>
<span class="line-removed">4505           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-removed">4506         }</span>
<span class="line-removed">4507         fs.set_inlined(true);</span>
<span class="line-removed">4508         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note</span>
<span class="line-removed">4509           not_atomic_inline_types++;</span>
<span class="line-removed">4510         }</span>
<span class="line-removed">4511       } else {</span>
<span class="line-removed">4512         inline_types_not_inlined++;</span>
<span class="line-removed">4513         fs.set_inlined(false);</span>
<span class="line-removed">4514       }</span>
<span class="line-removed">4515     }</span>
<span class="line-removed">4516   }</span>
<span class="line-removed">4517 </span>
<span class="line-removed">4518   // Adjusting non_static_oop_count to take into account inline types fields not inlined;</span>
<span class="line-removed">4519   nonstatic_oop_count += inline_types_not_inlined;</span>
<span class="line-removed">4520 </span>
<span class="line-removed">4521   // Total non-static fields count, including every contended field</span>
<span class="line-removed">4522   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +</span>
<span class="line-removed">4523                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +</span>
<span class="line-removed">4524                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_INLINE];</span>
<span class="line-removed">4525 </span>
<span class="line-removed">4526   const bool super_has_nonstatic_fields =</span>
<span class="line-removed">4527           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());</span>
<span class="line-removed">4528   const bool has_nonstatic_fields =</span>
<span class="line-removed">4529     super_has_nonstatic_fields || (nonstatic_fields_count != 0);</span>
<span class="line-removed">4530   const bool has_nonstatic_inline_fields = nonstatic_inline_type_count &gt; 0;</span>
<span class="line-removed">4531 </span>
<span class="line-removed">4532   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {</span>
<span class="line-removed">4533     // There are a number of fixes required throughout the type system and JIT</span>
<span class="line-removed">4534     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);</span>
<span class="line-removed">4535     return;</span>
<span class="line-removed">4536   }</span>
<span class="line-removed">4537 </span>
<span class="line-removed">4538   // Prepare list of oops for oop map generation.</span>
<span class="line-removed">4539   //</span>
<span class="line-removed">4540   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop</span>
<span class="line-removed">4541   // regions. offset[i] is the start of the i-th region, which then has</span>
<span class="line-removed">4542   // count[i] oops following. Before we know how many regions are required,</span>
<span class="line-removed">4543   // we pessimistically allocate the maps to fit all the oops into the</span>
<span class="line-removed">4544   // distinct regions.</span>
<span class="line-removed">4545   //</span>
<span class="line-removed">4546   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();</span>
<span class="line-removed">4547   int max_oop_map_count =</span>
<span class="line-removed">4548       super_oop_map_count +</span>
<span class="line-removed">4549       fac-&gt;count[NONSTATIC_OOP] +</span>
<span class="line-removed">4550       inline_type_oop_map_count +</span>
<span class="line-removed">4551       inline_types_not_inlined;</span>
<span class="line-removed">4552 </span>
<span class="line-removed">4553   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);</span>
<span class="line-removed">4554   if (super_oop_map_count &gt; 0) {</span>
<span class="line-removed">4555     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),</span>
<span class="line-removed">4556                                                     _super_klass-&gt;nonstatic_oop_map_count());</span>
<span class="line-removed">4557   }</span>
<span class="line-removed">4558 </span>
<span class="line-removed">4559   int first_nonstatic_oop_offset = 0; // will be set for first oop field</span>
<span class="line-removed">4560 </span>
<span class="line-removed">4561   bool compact_fields  = true;</span>
<span class="line-removed">4562   bool allocate_oops_first = false;</span>
<span class="line-removed">4563 </span>
<span class="line-removed">4564   int next_nonstatic_oop_offset = 0;</span>
<span class="line-removed">4565   int next_nonstatic_double_offset = 0;</span>
<span class="line-removed">4566 </span>
<span class="line-removed">4567   // Rearrange fields for a given allocation style</span>
<span class="line-removed">4568   if (allocate_oops_first) {</span>
<span class="line-removed">4569     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields</span>
<span class="line-removed">4570     next_nonstatic_oop_offset    = next_nonstatic_field_offset;</span>
<span class="line-removed">4571     next_nonstatic_double_offset = next_nonstatic_oop_offset +</span>
<span class="line-removed">4572                                     (nonstatic_oop_count * heapOopSize);</span>
<span class="line-removed">4573   } else {</span>
<span class="line-removed">4574     // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields</span>
<span class="line-removed">4575     next_nonstatic_double_offset = next_nonstatic_field_offset;</span>
<span class="line-removed">4576   }</span>
<span class="line-removed">4577 </span>
<span class="line-removed">4578   int nonstatic_oop_space_count   = 0;</span>
<span class="line-removed">4579   int nonstatic_word_space_count  = 0;</span>
<span class="line-removed">4580   int nonstatic_short_space_count = 0;</span>
<span class="line-removed">4581   int nonstatic_byte_space_count  = 0;</span>
<span class="line-removed">4582   int nonstatic_oop_space_offset = 0;</span>
<span class="line-removed">4583   int nonstatic_word_space_offset = 0;</span>
<span class="line-removed">4584   int nonstatic_short_space_offset = 0;</span>
<span class="line-removed">4585   int nonstatic_byte_space_offset = 0;</span>
<span class="line-removed">4586 </span>
<span class="line-removed">4587   // Try to squeeze some of the fields into the gaps due to</span>
<span class="line-removed">4588   // long/double alignment.</span>
<span class="line-removed">4589   if (nonstatic_double_count &gt; 0) {</span>
<span class="line-removed">4590     int offset = next_nonstatic_double_offset;</span>
<span class="line-removed">4591     next_nonstatic_double_offset = align_up(offset, BytesPerLong);</span>
<span class="line-removed">4592     if (compact_fields &amp;&amp; offset != next_nonstatic_double_offset) {</span>
<span class="line-removed">4593       // Allocate available fields into the gap before double field.</span>
<span class="line-removed">4594       int length = next_nonstatic_double_offset - offset;</span>
<span class="line-removed">4595       assert(length == BytesPerInt, &quot;&quot;);</span>
<span class="line-removed">4596       nonstatic_word_space_offset = offset;</span>
<span class="line-removed">4597       if (nonstatic_word_count &gt; 0) {</span>
<span class="line-removed">4598         nonstatic_word_count      -= 1;</span>
<span class="line-removed">4599         nonstatic_word_space_count = 1; // Only one will fit</span>
<span class="line-removed">4600         length -= BytesPerInt;</span>
<span class="line-removed">4601         offset += BytesPerInt;</span>
<span class="line-removed">4602       }</span>
<span class="line-removed">4603       nonstatic_short_space_offset = offset;</span>
<span class="line-removed">4604       while (length &gt;= BytesPerShort &amp;&amp; nonstatic_short_count &gt; 0) {</span>
<span class="line-removed">4605         nonstatic_short_count       -= 1;</span>
<span class="line-removed">4606         nonstatic_short_space_count += 1;</span>
<span class="line-removed">4607         length -= BytesPerShort;</span>
<span class="line-removed">4608         offset += BytesPerShort;</span>
<span class="line-removed">4609       }</span>
<span class="line-removed">4610       nonstatic_byte_space_offset = offset;</span>
<span class="line-removed">4611       while (length &gt; 0 &amp;&amp; nonstatic_byte_count &gt; 0) {</span>
<span class="line-removed">4612         nonstatic_byte_count       -= 1;</span>
<span class="line-removed">4613         nonstatic_byte_space_count += 1;</span>
<span class="line-removed">4614         length -= 1;</span>
<span class="line-removed">4615       }</span>
<span class="line-removed">4616       // Allocate oop field in the gap if there are no other fields for that.</span>
<span class="line-removed">4617       nonstatic_oop_space_offset = offset;</span>
<span class="line-removed">4618       if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;</span>
<span class="line-removed">4619           !allocate_oops_first) { // when oop fields not first</span>
<span class="line-removed">4620         nonstatic_oop_count      -= 1;</span>
<span class="line-removed">4621         nonstatic_oop_space_count = 1; // Only one will fit</span>
<span class="line-removed">4622         length -= heapOopSize;</span>
<span class="line-removed">4623         offset += heapOopSize;</span>
<span class="line-removed">4624       }</span>
<span class="line-removed">4625     }</span>
<span class="line-removed">4626   }</span>
<span class="line-removed">4627 </span>
<span class="line-removed">4628   int next_nonstatic_word_offset = next_nonstatic_double_offset +</span>
<span class="line-removed">4629                                      (nonstatic_double_count * BytesPerLong);</span>
<span class="line-removed">4630   int next_nonstatic_short_offset = next_nonstatic_word_offset +</span>
<span class="line-removed">4631                                       (nonstatic_word_count * BytesPerInt);</span>
<span class="line-removed">4632   int next_nonstatic_byte_offset = next_nonstatic_short_offset +</span>
<span class="line-removed">4633                                      (nonstatic_short_count * BytesPerShort);</span>
<span class="line-removed">4634   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +</span>
<span class="line-removed">4635                                        nonstatic_byte_count;</span>
<span class="line-removed">4636 </span>
<span class="line-removed">4637   // let oops jump before padding with this allocation style</span>
<span class="line-removed">4638   if (!allocate_oops_first) {</span>
<span class="line-removed">4639     next_nonstatic_oop_offset = next_nonstatic_padded_offset;</span>
<span class="line-removed">4640     if( nonstatic_oop_count &gt; 0 ) {</span>
<span class="line-removed">4641       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);</span>
<span class="line-removed">4642     }</span>
<span class="line-removed">4643     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);</span>
<span class="line-removed">4644   }</span>
<span class="line-removed">4645 </span>
<span class="line-removed">4646   // Aligning embedded inline types</span>
<span class="line-removed">4647   // bug below, the current algorithm to layout embedded inline types always put them at the</span>
<span class="line-removed">4648   // end of the layout, which doesn&#39;t match the different allocation policies the VM is</span>
<span class="line-removed">4649   // supposed to provide =&gt; FixMe</span>
<span class="line-removed">4650   // Note also that the current alignment policy is to make each inline type starting on a</span>
<span class="line-removed">4651   // 64 bits boundary. This could be optimized later. For instance, it could be nice to</span>
<span class="line-removed">4652   // align inline types according to their most constrained internal type.</span>
<span class="line-removed">4653   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="line-removed">4654   int next_inline_type_index = 0;</span>
<span class="line-removed">4655 </span>
<span class="line-removed">4656   // Iterate over fields again and compute correct offsets.</span>
<span class="line-removed">4657   // The field allocation type was temporarily stored in the offset slot.</span>
<span class="line-removed">4658   // oop fields are located before non-oop fields (static and non-static).</span>
<span class="line-removed">4659   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-removed">4660 </span>
<span class="line-removed">4661     // skip already laid out fields</span>
<span class="line-removed">4662     if (fs.is_offset_set()) continue;</span>
<span class="line-removed">4663 </span>
<span class="line-removed">4664     // contended instance fields are handled below</span>
<span class="line-removed">4665     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;</span>
<span class="line-removed">4666 </span>
<span class="line-removed">4667     int real_offset = 0;</span>
<span class="line-removed">4668     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();</span>
<span class="line-removed">4669 </span>
<span class="line-removed">4670     // pack the rest of the fields</span>
<span class="line-removed">4671     switch (atype) {</span>
<span class="line-removed">4672       // Inline types in static fields are handled with oops</span>
<span class="line-removed">4673       case STATIC_INLINE:   // Fallthrough</span>
<span class="line-removed">4674       case STATIC_OOP:</span>
<span class="line-removed">4675         real_offset = next_static_oop_offset;</span>
<span class="line-removed">4676         next_static_oop_offset += heapOopSize;</span>
<span class="line-removed">4677         break;</span>
<span class="line-removed">4678       case STATIC_BYTE:</span>
<span class="line-removed">4679         real_offset = next_static_byte_offset;</span>
<span class="line-removed">4680         next_static_byte_offset += 1;</span>
<span class="line-removed">4681         break;</span>
<span class="line-removed">4682       case STATIC_SHORT:</span>
<span class="line-removed">4683         real_offset = next_static_short_offset;</span>
<span class="line-removed">4684         next_static_short_offset += BytesPerShort;</span>
<span class="line-removed">4685         break;</span>
<span class="line-removed">4686       case STATIC_WORD:</span>
<span class="line-removed">4687         real_offset = next_static_word_offset;</span>
<span class="line-removed">4688         next_static_word_offset += BytesPerInt;</span>
<span class="line-removed">4689         break;</span>
<span class="line-removed">4690       case STATIC_DOUBLE:</span>
<span class="line-removed">4691         real_offset = next_static_double_offset;</span>
<span class="line-removed">4692         next_static_double_offset += BytesPerLong;</span>
<span class="line-removed">4693         break;</span>
<span class="line-removed">4694       case NONSTATIC_INLINE:</span>
<span class="line-removed">4695         if (fs.is_inlined()) {</span>
<span class="line-removed">4696           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];</span>
<span class="line-removed">4697           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);</span>
<span class="line-removed">4698           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);</span>
<span class="line-removed">4699           InlineKlass* vklass = InlineKlass::cast(klass);</span>
<span class="line-removed">4700           real_offset = next_nonstatic_inline_type_offset;</span>
<span class="line-removed">4701           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();</span>
<span class="line-removed">4702           // aligning next inline type on a 64 bits boundary</span>
<span class="line-removed">4703           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);</span>
<span class="line-removed">4704           next_inline_type_index += 1;</span>
<span class="line-removed">4705 </span>
<span class="line-removed">4706           if (vklass-&gt;contains_oops()) { // add flatten oop maps</span>
<span class="line-removed">4707             int diff = real_offset - vklass-&gt;first_field_offset();</span>
<span class="line-removed">4708             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-removed">4709             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-removed">4710             while (map &lt; last_map) {</span>
<span class="line-removed">4711               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());</span>
<span class="line-removed">4712               map++;</span>
<span class="line-removed">4713             }</span>
<span class="line-removed">4714           }</span>
<span class="line-removed">4715           break;</span>
<span class="line-removed">4716         } else {</span>
<span class="line-removed">4717           // Fall through</span>
<span class="line-removed">4718         }</span>
<span class="line-removed">4719       case NONSTATIC_OOP:</span>
<span class="line-removed">4720         if( nonstatic_oop_space_count &gt; 0 ) {</span>
<span class="line-removed">4721           real_offset = nonstatic_oop_space_offset;</span>
<span class="line-removed">4722           nonstatic_oop_space_offset += heapOopSize;</span>
<span class="line-removed">4723           nonstatic_oop_space_count  -= 1;</span>
<span class="line-removed">4724         } else {</span>
<span class="line-removed">4725           real_offset = next_nonstatic_oop_offset;</span>
<span class="line-removed">4726           next_nonstatic_oop_offset += heapOopSize;</span>
<span class="line-removed">4727         }</span>
<span class="line-removed">4728         nonstatic_oop_maps-&gt;add(real_offset, 1);</span>
<span class="line-removed">4729         break;</span>
<span class="line-removed">4730       case NONSTATIC_BYTE:</span>
<span class="line-removed">4731         if( nonstatic_byte_space_count &gt; 0 ) {</span>
<span class="line-removed">4732           real_offset = nonstatic_byte_space_offset;</span>
<span class="line-removed">4733           nonstatic_byte_space_offset += 1;</span>
<span class="line-removed">4734           nonstatic_byte_space_count  -= 1;</span>
<span class="line-removed">4735         } else {</span>
<span class="line-removed">4736           real_offset = next_nonstatic_byte_offset;</span>
<span class="line-removed">4737           next_nonstatic_byte_offset += 1;</span>
<span class="line-removed">4738         }</span>
<span class="line-removed">4739         break;</span>
<span class="line-removed">4740       case NONSTATIC_SHORT:</span>
<span class="line-removed">4741         if( nonstatic_short_space_count &gt; 0 ) {</span>
<span class="line-removed">4742           real_offset = nonstatic_short_space_offset;</span>
<span class="line-removed">4743           nonstatic_short_space_offset += BytesPerShort;</span>
<span class="line-removed">4744           nonstatic_short_space_count  -= 1;</span>
<span class="line-removed">4745         } else {</span>
<span class="line-removed">4746           real_offset = next_nonstatic_short_offset;</span>
<span class="line-removed">4747           next_nonstatic_short_offset += BytesPerShort;</span>
<span class="line-removed">4748         }</span>
<span class="line-removed">4749         break;</span>
<span class="line-removed">4750       case NONSTATIC_WORD:</span>
<span class="line-removed">4751         if( nonstatic_word_space_count &gt; 0 ) {</span>
<span class="line-removed">4752           real_offset = nonstatic_word_space_offset;</span>
<span class="line-removed">4753           nonstatic_word_space_offset += BytesPerInt;</span>
<span class="line-removed">4754           nonstatic_word_space_count  -= 1;</span>
<span class="line-removed">4755         } else {</span>
<span class="line-removed">4756           real_offset = next_nonstatic_word_offset;</span>
<span class="line-removed">4757           next_nonstatic_word_offset += BytesPerInt;</span>
<span class="line-removed">4758         }</span>
<span class="line-removed">4759         break;</span>
<span class="line-removed">4760       case NONSTATIC_DOUBLE:</span>
<span class="line-removed">4761         real_offset = next_nonstatic_double_offset;</span>
<span class="line-removed">4762         next_nonstatic_double_offset += BytesPerLong;</span>
<span class="line-removed">4763         break;</span>
<span class="line-removed">4764       default:</span>
<span class="line-removed">4765         ShouldNotReachHere();</span>
<span class="line-removed">4766     }</span>
<span class="line-removed">4767     fs.set_offset(real_offset);</span>
<span class="line-removed">4768   }</span>
<span class="line-removed">4769 </span>
<span class="line-removed">4770 </span>
<span class="line-removed">4771   // Handle the contended cases.</span>
<span class="line-removed">4772   //</span>
<span class="line-removed">4773   // Each contended field should not intersect the cache line with another contended field.</span>
<span class="line-removed">4774   // In the absence of alignment information, we end up with pessimistically separating</span>
<span class="line-removed">4775   // the fields with full-width padding.</span>
<span class="line-removed">4776   //</span>
<span class="line-removed">4777   // Additionally, this should not break alignment for the fields, so we round the alignment up</span>
<span class="line-removed">4778   // for each field.</span>
<span class="line-removed">4779   if (nonstatic_contended_count &gt; 0) {</span>
<span class="line-removed">4780 </span>
<span class="line-removed">4781     // if there is at least one contended field, we need to have pre-padding for them</span>
<span class="line-removed">4782     next_nonstatic_padded_offset += ContendedPaddingWidth;</span>
<span class="line-removed">4783 </span>
<span class="line-removed">4784     // collect all contended groups</span>
<span class="line-removed">4785     ResourceBitMap bm(cp-&gt;size());</span>
<span class="line-removed">4786     for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-removed">4787       // skip already laid out fields</span>
<span class="line-removed">4788       if (fs.is_offset_set()) continue;</span>
<span class="line-removed">4789 </span>
<span class="line-removed">4790       if (fs.is_contended()) {</span>
<span class="line-removed">4791         bm.set_bit(fs.contended_group());</span>
<span class="line-removed">4792       }</span>
<span class="line-removed">4793     }</span>
<span class="line-removed">4794 </span>
<span class="line-removed">4795     int current_group = -1;</span>
<span class="line-removed">4796     while ((current_group = (int)bm.get_next_one_offset(current_group + 1)) != (int)bm.size()) {</span>
<span class="line-removed">4797 </span>
<span class="line-removed">4798       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-removed">4799 </span>
<span class="line-removed">4800         // skip already laid out fields</span>
<span class="line-removed">4801         if (fs.is_offset_set()) continue;</span>
<span class="line-removed">4802 </span>
<span class="line-removed">4803         // skip non-contended fields and fields from different group</span>
<span class="line-removed">4804         if (!fs.is_contended() || (fs.contended_group() != current_group)) continue;</span>
<span class="line-removed">4805 </span>
<span class="line-removed">4806         // handle statics below</span>
<span class="line-removed">4807         if (fs.access_flags().is_static()) continue;</span>
<span class="line-removed">4808 </span>
<span class="line-removed">4809         int real_offset = 0;</span>
<span class="line-removed">4810         FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();</span>
<span class="line-removed">4811 </span>
<span class="line-removed">4812         switch (atype) {</span>
<span class="line-removed">4813           case NONSTATIC_BYTE:</span>
<span class="line-removed">4814             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, 1);</span>
<span class="line-removed">4815             real_offset = next_nonstatic_padded_offset;</span>
<span class="line-removed">4816             next_nonstatic_padded_offset += 1;</span>
<span class="line-removed">4817             break;</span>
<span class="line-removed">4818 </span>
<span class="line-removed">4819           case NONSTATIC_SHORT:</span>
<span class="line-removed">4820             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);</span>
<span class="line-removed">4821             real_offset = next_nonstatic_padded_offset;</span>
<span class="line-removed">4822             next_nonstatic_padded_offset += BytesPerShort;</span>
<span class="line-removed">4823             break;</span>
<span class="line-removed">4824 </span>
<span class="line-removed">4825           case NONSTATIC_WORD:</span>
<span class="line-removed">4826             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);</span>
<span class="line-removed">4827             real_offset = next_nonstatic_padded_offset;</span>
<span class="line-removed">4828             next_nonstatic_padded_offset += BytesPerInt;</span>
<span class="line-removed">4829             break;</span>
<span class="line-removed">4830 </span>
<span class="line-removed">4831           case NONSTATIC_DOUBLE:</span>
<span class="line-removed">4832             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="line-removed">4833             real_offset = next_nonstatic_padded_offset;</span>
<span class="line-removed">4834             next_nonstatic_padded_offset += BytesPerLong;</span>
<span class="line-removed">4835             break;</span>
<span class="line-removed">4836 </span>
<span class="line-removed">4837             // Inline types in static fields are handled with oops</span>
<span class="line-removed">4838           case NONSTATIC_INLINE:</span>
<span class="line-removed">4839             throwInlineTypeLimitation(THREAD_AND_LOCATION,</span>
<span class="line-removed">4840                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());</span>
<span class="line-removed">4841             return;</span>
<span class="line-removed">4842 </span>
<span class="line-removed">4843           case NONSTATIC_OOP:</span>
<span class="line-removed">4844             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);</span>
<span class="line-removed">4845             real_offset = next_nonstatic_padded_offset;</span>
<span class="line-removed">4846             next_nonstatic_padded_offset += heapOopSize;</span>
<span class="line-removed">4847             nonstatic_oop_maps-&gt;add(real_offset, 1);</span>
<span class="line-removed">4848             break;</span>
<span class="line-removed">4849 </span>
<span class="line-removed">4850           default:</span>
<span class="line-removed">4851             ShouldNotReachHere();</span>
<span class="line-removed">4852         }</span>
<span class="line-removed">4853 </span>
<span class="line-removed">4854         if (fs.contended_group() == 0) {</span>
<span class="line-removed">4855           // Contended group defines the equivalence class over the fields:</span>
<span class="line-removed">4856           // the fields within the same contended group are not inter-padded.</span>
<span class="line-removed">4857           // The only exception is default group, which does not incur the</span>
<span class="line-removed">4858           // equivalence, and so requires intra-padding.</span>
<span class="line-removed">4859           next_nonstatic_padded_offset += ContendedPaddingWidth;</span>
<span class="line-removed">4860         }</span>
<span class="line-removed">4861 </span>
<span class="line-removed">4862         fs.set_offset(real_offset);</span>
<span class="line-removed">4863       } // for</span>
<span class="line-removed">4864 </span>
<span class="line-removed">4865       // Start laying out the next group.</span>
<span class="line-removed">4866       // Note that this will effectively pad the last group in the back;</span>
<span class="line-removed">4867       // this is expected to alleviate memory contention effects for</span>
<span class="line-removed">4868       // subclass fields and/or adjacent object.</span>
<span class="line-removed">4869       // If this was the default group, the padding is already in place.</span>
<span class="line-removed">4870       if (current_group != 0) {</span>
<span class="line-removed">4871         next_nonstatic_padded_offset += ContendedPaddingWidth;</span>
<span class="line-removed">4872       }</span>
<span class="line-removed">4873     }</span>
<span class="line-removed">4874 </span>
<span class="line-removed">4875     // handle static fields</span>
<span class="line-removed">4876   }</span>
<span class="line-removed">4877 </span>
<span class="line-removed">4878   // Entire class is contended, pad in the back.</span>
<span class="line-removed">4879   // This helps to alleviate memory contention effects for subclass fields</span>
<span class="line-removed">4880   // and/or adjacent object.</span>
<span class="line-removed">4881   if (is_contended_class) {</span>
<span class="line-removed">4882     assert(!is_inline_type(), &quot;@Contended not supported for inline types yet&quot;);</span>
<span class="line-removed">4883     next_nonstatic_padded_offset += ContendedPaddingWidth;</span>
<span class="line-removed">4884   }</span>
<span class="line-removed">4885 </span>
<span class="line-removed">4886   int notaligned_nonstatic_fields_end;</span>
<span class="line-removed">4887   if (nonstatic_inline_type_count != 0) {</span>
<span class="line-removed">4888     notaligned_nonstatic_fields_end = next_nonstatic_inline_type_offset;</span>
<span class="line-removed">4889   } else {</span>
<span class="line-removed">4890     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>
<span class="line-removed">4891   }</span>
<span class="line-removed">4892 </span>
<span class="line-removed">4893   int nonstatic_field_sz_align = heapOopSize;</span>
<span class="line-removed">4894   if (is_inline_type()) {</span>
<span class="line-removed">4895     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {</span>
<span class="line-removed">4896       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy</span>
<span class="line-removed">4897     }</span>
<span class="line-removed">4898   }</span>
<span class="line-removed">4899   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);</span>
<span class="line-removed">4900   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);</span>
<span class="line-removed">4901   int static_fields_end         = align_up(next_static_byte_offset, wordSize);</span>
<span class="line-removed">4902 </span>
<span class="line-removed">4903   int static_field_size         = (static_fields_end -</span>
<span class="line-removed">4904                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;</span>
<span class="line-removed">4905   nonstatic_field_size          = nonstatic_field_size +</span>
<span class="line-removed">4906                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;</span>
<span class="line-removed">4907 </span>
<span class="line-removed">4908   int instance_size             = align_object_size(instance_end / wordSize);</span>
<span class="line-removed">4909 </span>
<span class="line-removed">4910   assert(instance_size == align_object_size(align_up(</span>
<span class="line-removed">4911          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)</span>
<span class="line-removed">4912          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
<span class="line-removed">4913 </span>
<span class="line-removed">4914 </span>
<span class="line-removed">4915   // Invariant: nonstatic_field end/start should only change if there are</span>
<span class="line-removed">4916   // nonstatic fields in the class, or if the class is contended. We compare</span>
<span class="line-removed">4917   // against the non-aligned value, so that end alignment will not fail the</span>
<span class="line-removed">4918   // assert without actually having the fields.</span>
<span class="line-removed">4919   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||</span>
<span class="line-removed">4920          is_contended_class ||</span>
<span class="line-removed">4921          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);</span>
<span class="line-removed">4922 </span>
<span class="line-removed">4923   // Number of non-static oop map blocks allocated at end of klass.</span>
<span class="line-removed">4924   nonstatic_oop_maps-&gt;compact();</span>
<span class="line-removed">4925 </span>
<span class="line-removed">4926 #ifndef PRODUCT</span>
<span class="line-removed">4927   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||</span>
<span class="line-removed">4928       (PrintInlineLayout &amp;&amp; (is_inline_type() || has_nonstatic_inline_fields))) {</span>
<span class="line-removed">4929     print_field_layout(_class_name,</span>
<span class="line-removed">4930           _fields,</span>
<span class="line-removed">4931           cp,</span>
<span class="line-removed">4932           instance_size,</span>
<span class="line-removed">4933           nonstatic_fields_start,</span>
<span class="line-removed">4934           nonstatic_fields_end,</span>
<span class="line-removed">4935           static_fields_end);</span>
<span class="line-removed">4936     nonstatic_oop_maps-&gt;print_on(tty);</span>
<span class="line-removed">4937     tty-&gt;print(&quot;\n&quot;);</span>
<span class="line-removed">4938     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);</span>
<span class="line-removed">4939     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);</span>
<span class="line-removed">4940     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);</span>
<span class="line-removed">4941     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);</span>
<span class="line-removed">4942     tty-&gt;print_cr(&quot;---&quot;);</span>
<span class="line-removed">4943   }</span>
<span class="line-removed">4944 </span>
<span class="line-removed">4945 #endif</span>
<span class="line-removed">4946   // Pass back information needed for InstanceKlass creation</span>
<span class="line-removed">4947   info-&gt;oop_map_blocks = nonstatic_oop_maps;</span>
<span class="line-removed">4948   info-&gt;_instance_size = instance_size;</span>
<span class="line-removed">4949   info-&gt;_static_field_size = static_field_size;</span>
<span class="line-removed">4950   info-&gt;_nonstatic_field_size = nonstatic_field_size;</span>
<span class="line-removed">4951   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;</span>
<span class="line-removed">4952   info-&gt;_has_inline_fields = nonstatic_inline_type_count &gt; 0;</span>
<span class="line-removed">4953 </span>
<span class="line-removed">4954   // An inline type is naturally atomic if it has just one field, and</span>
<span class="line-removed">4955   // that field is simple enough.</span>
<span class="line-removed">4956   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;</span>
<span class="line-removed">4957                                 !super_has_nonstatic_fields &amp;&amp;</span>
<span class="line-removed">4958                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;</span>
<span class="line-removed">4959                                 (not_atomic_inline_types == 0) &amp;&amp;</span>
<span class="line-removed">4960                                 (nonstatic_contended_count == 0));</span>
<span class="line-removed">4961   // This may be too restrictive, since if all the fields fit in 64</span>
<span class="line-removed">4962   // bits we could make the decision to align instances of this class</span>
<span class="line-removed">4963   // to 64-bit boundaries, and load and store them as single words.</span>
<span class="line-removed">4964   // And on machines which supported larger atomics we could similarly</span>
<span class="line-removed">4965   // allow larger values to be atomic, if properly aligned.</span>
<span class="line-removed">4966 }</span>
<span class="line-removed">4967 </span>
4968 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4969   assert(ik != NULL, &quot;invariant&quot;);
4970 
4971   const Klass* const super = ik-&gt;super();
4972 
4973   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4974   // in which case we don&#39;t have to register objects as finalizable
4975   if (!_has_empty_finalizer) {
4976     if (_has_finalizer ||
4977         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4978       ik-&gt;set_has_finalizer();
4979     }
4980   }
4981 
4982 #ifdef ASSERT
4983   bool f = false;
4984   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4985                                            vmSymbols::void_method_signature());
4986   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4987       f = true;
</pre>
<hr />
<pre>
6438       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);
6439       // Inline classes for instance fields must have been pre-loaded
6440       // Inline classes for static fields might not have been loaded yet
6441       Klass* klass = SystemDictionary::find(klass_name,
6442           Handle(THREAD, ik-&gt;class_loader()),
6443           Handle(THREAD, ik-&gt;protection_domain()), CHECK);
6444       if (klass != NULL) {
6445         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);
6446         ik-&gt;set_inline_type_field_klass(i, klass);
6447       }
6448       klass_name-&gt;decrement_refcount();
6449     } else
6450       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)
6451         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {
6452       InlineKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));
6453     }
6454   }
6455 
6456   if (is_inline_type()) {
6457     InlineKlass* vk = InlineKlass::cast(ik);
<span class="line-modified">6458     if (UseNewFieldLayout) {</span>
<span class="line-modified">6459       vk-&gt;set_alignment(_alignment);</span>
<span class="line-modified">6460       vk-&gt;set_first_field_offset(_first_field_offset);</span>
<span class="line-removed">6461       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);</span>
<span class="line-removed">6462     } else {</span>
<span class="line-removed">6463       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());</span>
<span class="line-removed">6464     }</span>
6465     InlineKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);
6466   }
6467 
6468   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
6469 
6470   if (!is_internal()) {
6471     if (log_is_enabled(Info, class, load)) {
6472       ResourceMark rm;
6473       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
6474       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
6475     }
6476 
6477     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
6478         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
6479         log_is_enabled(Info, class, preview)) {
6480       ResourceMark rm;
6481       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
6482                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
6483     }
6484 
</pre>
<hr />
<pre>
7275   // Size of Java itable (in words)
7276   _itable_size = is_interface() ? 0 :
7277     klassItable::compute_itable_size(_transitive_interfaces);
7278 
7279   assert(_fac != NULL, &quot;invariant&quot;);
7280   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7281 
7282 
7283   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
7284     if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE  &amp;&amp; !fs.access_flags().is_static()) {
7285       // Pre-load inline class
7286       Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,
7287           Handle(THREAD, _loader_data-&gt;class_loader()),
7288           _protection_domain, true, CHECK);
7289       assert(klass != NULL, &quot;Sanity check&quot;);
7290       assert(klass-&gt;access_flags().is_inline_type(), &quot;Value type expected&quot;);
7291     }
7292   }
7293 
7294   _field_info = new FieldLayoutInfo();
<span class="line-modified">7295   if (UseNewFieldLayout) {</span>
<span class="line-modified">7296     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,</span>
<span class="line-modified">7297         _parsed_annotations-&gt;is_contended(), is_inline_type(),</span>
<span class="line-modified">7298         loader_data(), _protection_domain, _field_info);</span>
<span class="line-modified">7299     lb.build_layout(CHECK);</span>
<span class="line-modified">7300     if (is_inline_type()) {</span>
<span class="line-modified">7301       _alignment = lb.get_alignment();</span>
<span class="line-modified">7302       _first_field_offset = lb.get_first_field_offset();</span>
<span class="line-removed">7303       _exact_size_in_bytes = lb.get_exact_size_in_byte();</span>
<span class="line-removed">7304     }</span>
<span class="line-removed">7305   } else {</span>
<span class="line-removed">7306     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);</span>
7307   }
7308   _has_inline_type_fields = _field_info-&gt;_has_inline_fields;
7309 
7310   // Compute reference type
7311   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
7312 }
7313 
7314 void ClassFileParser::set_klass(InstanceKlass* klass) {
7315 
7316 #ifdef ASSERT
7317   if (klass != NULL) {
7318     assert(NULL == _klass, &quot;leaking?&quot;);
7319   }
7320 #endif
7321 
7322   _klass = klass;
7323 }
7324 
7325 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
7326 
</pre>
</td>
<td>
<hr />
<pre>
4164                    super_class_index,
4165                    CHECK_NULL);
4166     // The class name should be legal because it is checked when parsing constant pool.
4167     // However, make sure it is not an array type.
4168     bool is_array = false;
4169     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4170       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4171       if (need_verify)
4172         is_array = super_klass-&gt;is_array_klass();
4173     } else if (need_verify) {
4174       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4175     }
4176     if (need_verify) {
4177       guarantee_property(!is_array,
4178                         &quot;Bad superclass name in class file %s&quot;, CHECK_NULL);
4179     }
4180   }
4181   return super_klass;
4182 }
4183 





































4184 OopMapBlocksBuilder::OopMapBlocksBuilder(unsigned int max_blocks) {
4185   _max_nonstatic_oop_maps = max_blocks;
4186   _nonstatic_oop_map_count = 0;
4187   if (max_blocks == 0) {
4188     _nonstatic_oop_maps = NULL;
4189   } else {
4190     _nonstatic_oop_maps =
4191         NEW_RESOURCE_ARRAY(OopMapBlock, _max_nonstatic_oop_maps);
4192     memset(_nonstatic_oop_maps, 0, sizeof(OopMapBlock) * max_blocks);
4193   }
4194 }
4195 
4196 OopMapBlock* OopMapBlocksBuilder::last_oop_map() const {
4197   assert(_nonstatic_oop_map_count &gt; 0, &quot;Has no oop maps&quot;);
4198   return _nonstatic_oop_maps + (_nonstatic_oop_map_count - 1);
4199 }
4200 
4201 // addition of super oop maps
4202 void OopMapBlocksBuilder::initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks) {
4203   assert(nof_blocks &amp;&amp; _nonstatic_oop_map_count == 0 &amp;&amp;
</pre>
<hr />
<pre>
4299 
4300 void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,
4301                                                 const char* msg,
4302                                                 const Symbol* name,
4303                                                 const Symbol* sig) const {
4304 
4305   ResourceMark rm(THREAD);
4306   if (name == NULL || sig == NULL) {
4307     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4308         vmSymbols::java_lang_ClassFormatError(),
4309         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);
4310   }
4311   else {
4312     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4313         vmSymbols::java_lang_ClassFormatError(),
4314         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),
4315         _class_name-&gt;as_C_string(), msg);
4316   }
4317 }
4318 




































































































































































































































































































































































































































































































































































































































4319 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4320   assert(ik != NULL, &quot;invariant&quot;);
4321 
4322   const Klass* const super = ik-&gt;super();
4323 
4324   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4325   // in which case we don&#39;t have to register objects as finalizable
4326   if (!_has_empty_finalizer) {
4327     if (_has_finalizer ||
4328         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4329       ik-&gt;set_has_finalizer();
4330     }
4331   }
4332 
4333 #ifdef ASSERT
4334   bool f = false;
4335   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4336                                            vmSymbols::void_method_signature());
4337   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4338       f = true;
</pre>
<hr />
<pre>
5789       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);
5790       // Inline classes for instance fields must have been pre-loaded
5791       // Inline classes for static fields might not have been loaded yet
5792       Klass* klass = SystemDictionary::find(klass_name,
5793           Handle(THREAD, ik-&gt;class_loader()),
5794           Handle(THREAD, ik-&gt;protection_domain()), CHECK);
5795       if (klass != NULL) {
5796         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);
5797         ik-&gt;set_inline_type_field_klass(i, klass);
5798       }
5799       klass_name-&gt;decrement_refcount();
5800     } else
5801       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)
5802         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {
5803       InlineKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));
5804     }
5805   }
5806 
5807   if (is_inline_type()) {
5808     InlineKlass* vk = InlineKlass::cast(ik);
<span class="line-modified">5809     vk-&gt;set_alignment(_alignment);</span>
<span class="line-modified">5810     vk-&gt;set_first_field_offset(_first_field_offset);</span>
<span class="line-modified">5811     vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);</span>




5812     InlineKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);
5813   }
5814 
5815   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
5816 
5817   if (!is_internal()) {
5818     if (log_is_enabled(Info, class, load)) {
5819       ResourceMark rm;
5820       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5821       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5822     }
5823 
5824     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
5825         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
5826         log_is_enabled(Info, class, preview)) {
5827       ResourceMark rm;
5828       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
5829                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
5830     }
5831 
</pre>
<hr />
<pre>
6622   // Size of Java itable (in words)
6623   _itable_size = is_interface() ? 0 :
6624     klassItable::compute_itable_size(_transitive_interfaces);
6625 
6626   assert(_fac != NULL, &quot;invariant&quot;);
6627   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6628 
6629 
6630   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
6631     if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE  &amp;&amp; !fs.access_flags().is_static()) {
6632       // Pre-load inline class
6633       Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,
6634           Handle(THREAD, _loader_data-&gt;class_loader()),
6635           _protection_domain, true, CHECK);
6636       assert(klass != NULL, &quot;Sanity check&quot;);
6637       assert(klass-&gt;access_flags().is_inline_type(), &quot;Value type expected&quot;);
6638     }
6639   }
6640 
6641   _field_info = new FieldLayoutInfo();
<span class="line-modified">6642   FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,</span>
<span class="line-modified">6643       _parsed_annotations-&gt;is_contended(), is_inline_type(),</span>
<span class="line-modified">6644       loader_data(), _protection_domain, _field_info);</span>
<span class="line-modified">6645   lb.build_layout(CHECK);</span>
<span class="line-modified">6646   if (is_inline_type()) {</span>
<span class="line-modified">6647     _alignment = lb.get_alignment();</span>
<span class="line-modified">6648     _first_field_offset = lb.get_first_field_offset();</span>
<span class="line-modified">6649     _exact_size_in_bytes = lb.get_exact_size_in_byte();</span>




6650   }
6651   _has_inline_type_fields = _field_info-&gt;_has_inline_fields;
6652 
6653   // Compute reference type
6654   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
6655 }
6656 
6657 void ClassFileParser::set_klass(InstanceKlass* klass) {
6658 
6659 #ifdef ASSERT
6660   if (klass != NULL) {
6661     assert(NULL == _klass, &quot;leaking?&quot;);
6662   }
6663 #endif
6664 
6665   _klass = klass;
6666 }
6667 
6668 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6669 
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/aarch64/templateTable_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>