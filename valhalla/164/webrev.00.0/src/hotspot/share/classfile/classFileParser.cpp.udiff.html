<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/aarch64/templateTable_aarch64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -4179,47 +4179,10 @@</span>
      }
    }
    return super_klass;
  }
  
<span class="udiff-line-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-removed">- static void print_field_layout(const Symbol* name,</span>
<span class="udiff-line-removed">-                                Array&lt;u2&gt;* fields,</span>
<span class="udiff-line-removed">-                                ConstantPool* cp,</span>
<span class="udiff-line-removed">-                                int instance_size,</span>
<span class="udiff-line-removed">-                                int instance_fields_start,</span>
<span class="udiff-line-removed">-                                int instance_fields_end,</span>
<span class="udiff-line-removed">-                                int static_fields_end) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert(name != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   tty-&gt;print(&quot;%s: field layout\n&quot;, name-&gt;as_klass_external_name());</span>
<span class="udiff-line-removed">-   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_start, &quot;--- instance fields start ---&quot;);</span>
<span class="udiff-line-removed">-   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {</span>
<span class="udiff-line-removed">-     if (!fs.access_flags().is_static()) {</span>
<span class="udiff-line-removed">-       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,</span>
<span class="udiff-line-removed">-         fs.offset(),</span>
<span class="udiff-line-removed">-         fs.name()-&gt;as_klass_external_name(),</span>
<span class="udiff-line-removed">-         fs.signature()-&gt;as_klass_external_name());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_end, &quot;--- instance fields end ---&quot;);</span>
<span class="udiff-line-removed">-   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_size * wordSize, &quot;--- instance ends ---&quot;);</span>
<span class="udiff-line-removed">-   tty-&gt;print(&quot;  @%3d %s\n&quot;, InstanceMirrorKlass::offset_of_static_fields(), &quot;--- static fields start ---&quot;);</span>
<span class="udiff-line-removed">-   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {</span>
<span class="udiff-line-removed">-     if (fs.access_flags().is_static()) {</span>
<span class="udiff-line-removed">-       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,</span>
<span class="udiff-line-removed">-         fs.offset(),</span>
<span class="udiff-line-removed">-         fs.name()-&gt;as_klass_external_name(),</span>
<span class="udiff-line-removed">-         fs.signature()-&gt;as_klass_external_name());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);</span>
<span class="udiff-line-removed">-   tty-&gt;print(&quot;\n&quot;);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  OopMapBlocksBuilder::OopMapBlocksBuilder(unsigned int max_blocks) {
    _max_nonstatic_oop_maps = max_blocks;
    _nonstatic_oop_map_count = 0;
    if (max_blocks == 0) {
      _nonstatic_oop_maps = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4351,622 +4314,10 @@</span>
          &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),
          _class_name-&gt;as_C_string(), msg);
    }
  }
  
<span class="udiff-line-removed">- // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!</span>
<span class="udiff-line-removed">- void ClassFileParser::layout_fields(ConstantPool* cp,</span>
<span class="udiff-line-removed">-                                     const FieldAllocationCount* fac,</span>
<span class="udiff-line-removed">-                                     const ClassAnnotationCollector* parsed_annotations,</span>
<span class="udiff-line-removed">-                                     FieldLayoutInfo* info,</span>
<span class="udiff-line-removed">-                                     TRAPS) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert(cp != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Field size and offset computation</span>
<span class="udiff-line-removed">-   int nonstatic_field_size = _super_klass == NULL ? 0 :</span>
<span class="udiff-line-removed">-                                _super_klass-&gt;nonstatic_field_size();</span>
<span class="udiff-line-removed">-   int next_nonstatic_inline_type_offset = 0;</span>
<span class="udiff-line-removed">-   int first_nonstatic_inline_type_offset = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Fields that are inline types are handled differently depending if they are static or not:</span>
<span class="udiff-line-removed">-   // - static fields are oops</span>
<span class="udiff-line-removed">-   // - non-static fields are embedded</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Count the contended fields by type.</span>
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   // We ignore static fields, because @Contended is not supported for them.</span>
<span class="udiff-line-removed">-   // The layout code below will also ignore the static fields.</span>
<span class="udiff-line-removed">-   int nonstatic_contended_count = 0;</span>
<span class="udiff-line-removed">-   FieldAllocationCount fac_contended;</span>
<span class="udiff-line-removed">-   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="udiff-line-removed">-     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();</span>
<span class="udiff-line-removed">-     if (fs.is_contended()) {</span>
<span class="udiff-line-removed">-       fac_contended.count[atype]++;</span>
<span class="udiff-line-removed">-       if (!fs.access_flags().is_static()) {</span>
<span class="udiff-line-removed">-         nonstatic_contended_count++;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Calculate the starting byte offsets</span>
<span class="udiff-line-removed">-   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();</span>
<span class="udiff-line-removed">-   // Inline types in static fields are not embedded, they are handled with oops</span>
<span class="udiff-line-removed">-   int next_static_double_offset = next_static_oop_offset +</span>
<span class="udiff-line-removed">-                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_INLINE]) * heapOopSize);</span>
<span class="udiff-line-removed">-   if (fac-&gt;count[STATIC_DOUBLE]) {</span>
<span class="udiff-line-removed">-     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int next_static_word_offset   = next_static_double_offset +</span>
<span class="udiff-line-removed">-                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);</span>
<span class="udiff-line-removed">-   int next_static_short_offset  = next_static_word_offset +</span>
<span class="udiff-line-removed">-                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);</span>
<span class="udiff-line-removed">-   int next_static_byte_offset   = next_static_short_offset +</span>
<span class="udiff-line-removed">-                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +</span>
<span class="udiff-line-removed">-                                 nonstatic_field_size * heapOopSize;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // First field of inline types is aligned on a long boundary in order to ease</span>
<span class="udiff-line-removed">-   // in-lining of inline types (with header removal) in packed arrays and</span>
<span class="udiff-line-removed">-   // inlined fields</span>
<span class="udiff-line-removed">-   int initial_inline_type_padding = 0;</span>
<span class="udiff-line-removed">-   if (is_inline_type()) {</span>
<span class="udiff-line-removed">-     int old = nonstatic_fields_start;</span>
<span class="udiff-line-removed">-     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);</span>
<span class="udiff-line-removed">-     initial_inline_type_padding = nonstatic_fields_start - old;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int next_nonstatic_field_offset = nonstatic_fields_start;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   const bool is_contended_class     = parsed_annotations-&gt;is_contended();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Class is contended, pad before all the fields</span>
<span class="udiff-line-removed">-   if (is_contended_class) {</span>
<span class="udiff-line-removed">-     next_nonstatic_field_offset += ContendedPaddingWidth;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Temporary inline types restrictions</span>
<span class="udiff-line-removed">-   if (is_inline_type()) {</span>
<span class="udiff-line-removed">-     if (is_contended_class) {</span>
<span class="udiff-line-removed">-       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Compute the non-contended fields count.</span>
<span class="udiff-line-removed">-   // The packing code below relies on these counts to determine if some field</span>
<span class="udiff-line-removed">-   // can be squeezed into the alignment gap. Contended fields are obviously</span>
<span class="udiff-line-removed">-   // exempt from that.</span>
<span class="udiff-line-removed">-   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];</span>
<span class="udiff-line-removed">-   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];</span>
<span class="udiff-line-removed">-   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];</span>
<span class="udiff-line-removed">-   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];</span>
<span class="udiff-line-removed">-   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int static_inline_type_count = 0;</span>
<span class="udiff-line-removed">-   int nonstatic_inline_type_count = 0;</span>
<span class="udiff-line-removed">-   int* nonstatic_inline_type_indexes = NULL;</span>
<span class="udiff-line-removed">-   Klass** nonstatic_inline_type_klasses = NULL;</span>
<span class="udiff-line-removed">-   unsigned int inline_type_oop_map_count = 0;</span>
<span class="udiff-line-removed">-   int inline_types_not_inlined = 0;</span>
<span class="udiff-line-removed">-   int not_atomic_inline_types = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_INLINE] + 1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,</span>
<span class="udiff-line-removed">-                                                                max_nonstatic_inline_type);</span>
<span class="udiff-line-removed">-   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {</span>
<span class="udiff-line-removed">-     nonstatic_inline_type_indexes[i] = -1;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,</span>
<span class="udiff-line-removed">-                                                                max_nonstatic_inline_type);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {</span>
<span class="udiff-line-removed">-     if (fs.allocation_type() == STATIC_INLINE) {</span>
<span class="udiff-line-removed">-       ResourceMark rm;</span>
<span class="udiff-line-removed">-       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="udiff-line-removed">-         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       static_inline_type_count++;</span>
<span class="udiff-line-removed">-     } else if (fs.allocation_type() == NONSTATIC_INLINE) {</span>
<span class="udiff-line-removed">-       // Pre-resolve the inline field and check for inline type circularity issues.</span>
<span class="udiff-line-removed">-       ResourceMark rm;</span>
<span class="udiff-line-removed">-       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="udiff-line-removed">-         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       Klass* klass =</span>
<span class="udiff-line-removed">-         SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,</span>
<span class="udiff-line-removed">-                                                             Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="udiff-line-removed">-                                                             _protection_domain, true, CHECK);</span>
<span class="udiff-line-removed">-       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="udiff-line-removed">-       if (!klass-&gt;access_flags().is_inline_type()) {</span>
<span class="udiff-line-removed">-         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       InlineKlass* vk = InlineKlass::cast(klass);</span>
<span class="udiff-line-removed">-       // Conditions to apply flattening or not should be defined in a single place</span>
<span class="udiff-line-removed">-       bool too_big_to_allocate_inline = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="udiff-line-removed">-                                  (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);</span>
<span class="udiff-line-removed">-       bool too_atomic_to_allocate_inline = vk-&gt;is_declared_atomic();</span>
<span class="udiff-line-removed">-       bool too_volatile_to_allocate_inline = fs.access_flags().is_volatile();</span>
<span class="udiff-line-removed">-       if (vk-&gt;is_naturally_atomic()) {</span>
<span class="udiff-line-removed">-         too_atomic_to_allocate_inline = false;</span>
<span class="udiff-line-removed">-         // too_volatile_to_allocate_inline = false; //FIXME</span>
<span class="udiff-line-removed">-         // volatile fields are currently never inlined, this could change in the future</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (!(too_big_to_allocate_inline | too_atomic_to_allocate_inline | too_volatile_to_allocate_inline)) {</span>
<span class="udiff-line-removed">-         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();</span>
<span class="udiff-line-removed">-         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;</span>
<span class="udiff-line-removed">-         nonstatic_inline_type_count++;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         InlineKlass* vklass = InlineKlass::cast(klass);</span>
<span class="udiff-line-removed">-         if (vklass-&gt;contains_oops()) {</span>
<span class="udiff-line-removed">-           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         fs.set_inlined(true);</span>
<span class="udiff-line-removed">-         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note</span>
<span class="udiff-line-removed">-           not_atomic_inline_types++;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         inline_types_not_inlined++;</span>
<span class="udiff-line-removed">-         fs.set_inlined(false);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Adjusting non_static_oop_count to take into account inline types fields not inlined;</span>
<span class="udiff-line-removed">-   nonstatic_oop_count += inline_types_not_inlined;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Total non-static fields count, including every contended field</span>
<span class="udiff-line-removed">-   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +</span>
<span class="udiff-line-removed">-                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +</span>
<span class="udiff-line-removed">-                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_INLINE];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   const bool super_has_nonstatic_fields =</span>
<span class="udiff-line-removed">-           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());</span>
<span class="udiff-line-removed">-   const bool has_nonstatic_fields =</span>
<span class="udiff-line-removed">-     super_has_nonstatic_fields || (nonstatic_fields_count != 0);</span>
<span class="udiff-line-removed">-   const bool has_nonstatic_inline_fields = nonstatic_inline_type_count &gt; 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {</span>
<span class="udiff-line-removed">-     // There are a number of fixes required throughout the type system and JIT</span>
<span class="udiff-line-removed">-     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Prepare list of oops for oop map generation.</span>
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop</span>
<span class="udiff-line-removed">-   // regions. offset[i] is the start of the i-th region, which then has</span>
<span class="udiff-line-removed">-   // count[i] oops following. Before we know how many regions are required,</span>
<span class="udiff-line-removed">-   // we pessimistically allocate the maps to fit all the oops into the</span>
<span class="udiff-line-removed">-   // distinct regions.</span>
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();</span>
<span class="udiff-line-removed">-   int max_oop_map_count =</span>
<span class="udiff-line-removed">-       super_oop_map_count +</span>
<span class="udiff-line-removed">-       fac-&gt;count[NONSTATIC_OOP] +</span>
<span class="udiff-line-removed">-       inline_type_oop_map_count +</span>
<span class="udiff-line-removed">-       inline_types_not_inlined;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);</span>
<span class="udiff-line-removed">-   if (super_oop_map_count &gt; 0) {</span>
<span class="udiff-line-removed">-     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),</span>
<span class="udiff-line-removed">-                                                     _super_klass-&gt;nonstatic_oop_map_count());</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int first_nonstatic_oop_offset = 0; // will be set for first oop field</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bool compact_fields  = true;</span>
<span class="udiff-line-removed">-   bool allocate_oops_first = false;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int next_nonstatic_oop_offset = 0;</span>
<span class="udiff-line-removed">-   int next_nonstatic_double_offset = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Rearrange fields for a given allocation style</span>
<span class="udiff-line-removed">-   if (allocate_oops_first) {</span>
<span class="udiff-line-removed">-     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields</span>
<span class="udiff-line-removed">-     next_nonstatic_oop_offset    = next_nonstatic_field_offset;</span>
<span class="udiff-line-removed">-     next_nonstatic_double_offset = next_nonstatic_oop_offset +</span>
<span class="udiff-line-removed">-                                     (nonstatic_oop_count * heapOopSize);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields</span>
<span class="udiff-line-removed">-     next_nonstatic_double_offset = next_nonstatic_field_offset;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int nonstatic_oop_space_count   = 0;</span>
<span class="udiff-line-removed">-   int nonstatic_word_space_count  = 0;</span>
<span class="udiff-line-removed">-   int nonstatic_short_space_count = 0;</span>
<span class="udiff-line-removed">-   int nonstatic_byte_space_count  = 0;</span>
<span class="udiff-line-removed">-   int nonstatic_oop_space_offset = 0;</span>
<span class="udiff-line-removed">-   int nonstatic_word_space_offset = 0;</span>
<span class="udiff-line-removed">-   int nonstatic_short_space_offset = 0;</span>
<span class="udiff-line-removed">-   int nonstatic_byte_space_offset = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Try to squeeze some of the fields into the gaps due to</span>
<span class="udiff-line-removed">-   // long/double alignment.</span>
<span class="udiff-line-removed">-   if (nonstatic_double_count &gt; 0) {</span>
<span class="udiff-line-removed">-     int offset = next_nonstatic_double_offset;</span>
<span class="udiff-line-removed">-     next_nonstatic_double_offset = align_up(offset, BytesPerLong);</span>
<span class="udiff-line-removed">-     if (compact_fields &amp;&amp; offset != next_nonstatic_double_offset) {</span>
<span class="udiff-line-removed">-       // Allocate available fields into the gap before double field.</span>
<span class="udiff-line-removed">-       int length = next_nonstatic_double_offset - offset;</span>
<span class="udiff-line-removed">-       assert(length == BytesPerInt, &quot;&quot;);</span>
<span class="udiff-line-removed">-       nonstatic_word_space_offset = offset;</span>
<span class="udiff-line-removed">-       if (nonstatic_word_count &gt; 0) {</span>
<span class="udiff-line-removed">-         nonstatic_word_count      -= 1;</span>
<span class="udiff-line-removed">-         nonstatic_word_space_count = 1; // Only one will fit</span>
<span class="udiff-line-removed">-         length -= BytesPerInt;</span>
<span class="udiff-line-removed">-         offset += BytesPerInt;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       nonstatic_short_space_offset = offset;</span>
<span class="udiff-line-removed">-       while (length &gt;= BytesPerShort &amp;&amp; nonstatic_short_count &gt; 0) {</span>
<span class="udiff-line-removed">-         nonstatic_short_count       -= 1;</span>
<span class="udiff-line-removed">-         nonstatic_short_space_count += 1;</span>
<span class="udiff-line-removed">-         length -= BytesPerShort;</span>
<span class="udiff-line-removed">-         offset += BytesPerShort;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       nonstatic_byte_space_offset = offset;</span>
<span class="udiff-line-removed">-       while (length &gt; 0 &amp;&amp; nonstatic_byte_count &gt; 0) {</span>
<span class="udiff-line-removed">-         nonstatic_byte_count       -= 1;</span>
<span class="udiff-line-removed">-         nonstatic_byte_space_count += 1;</span>
<span class="udiff-line-removed">-         length -= 1;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       // Allocate oop field in the gap if there are no other fields for that.</span>
<span class="udiff-line-removed">-       nonstatic_oop_space_offset = offset;</span>
<span class="udiff-line-removed">-       if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;</span>
<span class="udiff-line-removed">-           !allocate_oops_first) { // when oop fields not first</span>
<span class="udiff-line-removed">-         nonstatic_oop_count      -= 1;</span>
<span class="udiff-line-removed">-         nonstatic_oop_space_count = 1; // Only one will fit</span>
<span class="udiff-line-removed">-         length -= heapOopSize;</span>
<span class="udiff-line-removed">-         offset += heapOopSize;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int next_nonstatic_word_offset = next_nonstatic_double_offset +</span>
<span class="udiff-line-removed">-                                      (nonstatic_double_count * BytesPerLong);</span>
<span class="udiff-line-removed">-   int next_nonstatic_short_offset = next_nonstatic_word_offset +</span>
<span class="udiff-line-removed">-                                       (nonstatic_word_count * BytesPerInt);</span>
<span class="udiff-line-removed">-   int next_nonstatic_byte_offset = next_nonstatic_short_offset +</span>
<span class="udiff-line-removed">-                                      (nonstatic_short_count * BytesPerShort);</span>
<span class="udiff-line-removed">-   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +</span>
<span class="udiff-line-removed">-                                        nonstatic_byte_count;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // let oops jump before padding with this allocation style</span>
<span class="udiff-line-removed">-   if (!allocate_oops_first) {</span>
<span class="udiff-line-removed">-     next_nonstatic_oop_offset = next_nonstatic_padded_offset;</span>
<span class="udiff-line-removed">-     if( nonstatic_oop_count &gt; 0 ) {</span>
<span class="udiff-line-removed">-       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Aligning embedded inline types</span>
<span class="udiff-line-removed">-   // bug below, the current algorithm to layout embedded inline types always put them at the</span>
<span class="udiff-line-removed">-   // end of the layout, which doesn&#39;t match the different allocation policies the VM is</span>
<span class="udiff-line-removed">-   // supposed to provide =&gt; FixMe</span>
<span class="udiff-line-removed">-   // Note also that the current alignment policy is to make each inline type starting on a</span>
<span class="udiff-line-removed">-   // 64 bits boundary. This could be optimized later. For instance, it could be nice to</span>
<span class="udiff-line-removed">-   // align inline types according to their most constrained internal type.</span>
<span class="udiff-line-removed">-   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="udiff-line-removed">-   int next_inline_type_index = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Iterate over fields again and compute correct offsets.</span>
<span class="udiff-line-removed">-   // The field allocation type was temporarily stored in the offset slot.</span>
<span class="udiff-line-removed">-   // oop fields are located before non-oop fields (static and non-static).</span>
<span class="udiff-line-removed">-   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // skip already laid out fields</span>
<span class="udiff-line-removed">-     if (fs.is_offset_set()) continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // contended instance fields are handled below</span>
<span class="udiff-line-removed">-     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     int real_offset = 0;</span>
<span class="udiff-line-removed">-     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // pack the rest of the fields</span>
<span class="udiff-line-removed">-     switch (atype) {</span>
<span class="udiff-line-removed">-       // Inline types in static fields are handled with oops</span>
<span class="udiff-line-removed">-       case STATIC_INLINE:   // Fallthrough</span>
<span class="udiff-line-removed">-       case STATIC_OOP:</span>
<span class="udiff-line-removed">-         real_offset = next_static_oop_offset;</span>
<span class="udiff-line-removed">-         next_static_oop_offset += heapOopSize;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case STATIC_BYTE:</span>
<span class="udiff-line-removed">-         real_offset = next_static_byte_offset;</span>
<span class="udiff-line-removed">-         next_static_byte_offset += 1;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case STATIC_SHORT:</span>
<span class="udiff-line-removed">-         real_offset = next_static_short_offset;</span>
<span class="udiff-line-removed">-         next_static_short_offset += BytesPerShort;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case STATIC_WORD:</span>
<span class="udiff-line-removed">-         real_offset = next_static_word_offset;</span>
<span class="udiff-line-removed">-         next_static_word_offset += BytesPerInt;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case STATIC_DOUBLE:</span>
<span class="udiff-line-removed">-         real_offset = next_static_double_offset;</span>
<span class="udiff-line-removed">-         next_static_double_offset += BytesPerLong;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case NONSTATIC_INLINE:</span>
<span class="udiff-line-removed">-         if (fs.is_inlined()) {</span>
<span class="udiff-line-removed">-           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];</span>
<span class="udiff-line-removed">-           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);</span>
<span class="udiff-line-removed">-           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);</span>
<span class="udiff-line-removed">-           InlineKlass* vklass = InlineKlass::cast(klass);</span>
<span class="udiff-line-removed">-           real_offset = next_nonstatic_inline_type_offset;</span>
<span class="udiff-line-removed">-           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();</span>
<span class="udiff-line-removed">-           // aligning next inline type on a 64 bits boundary</span>
<span class="udiff-line-removed">-           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);</span>
<span class="udiff-line-removed">-           next_inline_type_index += 1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           if (vklass-&gt;contains_oops()) { // add flatten oop maps</span>
<span class="udiff-line-removed">-             int diff = real_offset - vklass-&gt;first_field_offset();</span>
<span class="udiff-line-removed">-             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="udiff-line-removed">-             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();</span>
<span class="udiff-line-removed">-             while (map &lt; last_map) {</span>
<span class="udiff-line-removed">-               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());</span>
<span class="udiff-line-removed">-               map++;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-           break;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           // Fall through</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       case NONSTATIC_OOP:</span>
<span class="udiff-line-removed">-         if( nonstatic_oop_space_count &gt; 0 ) {</span>
<span class="udiff-line-removed">-           real_offset = nonstatic_oop_space_offset;</span>
<span class="udiff-line-removed">-           nonstatic_oop_space_offset += heapOopSize;</span>
<span class="udiff-line-removed">-           nonstatic_oop_space_count  -= 1;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           real_offset = next_nonstatic_oop_offset;</span>
<span class="udiff-line-removed">-           next_nonstatic_oop_offset += heapOopSize;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         nonstatic_oop_maps-&gt;add(real_offset, 1);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case NONSTATIC_BYTE:</span>
<span class="udiff-line-removed">-         if( nonstatic_byte_space_count &gt; 0 ) {</span>
<span class="udiff-line-removed">-           real_offset = nonstatic_byte_space_offset;</span>
<span class="udiff-line-removed">-           nonstatic_byte_space_offset += 1;</span>
<span class="udiff-line-removed">-           nonstatic_byte_space_count  -= 1;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           real_offset = next_nonstatic_byte_offset;</span>
<span class="udiff-line-removed">-           next_nonstatic_byte_offset += 1;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case NONSTATIC_SHORT:</span>
<span class="udiff-line-removed">-         if( nonstatic_short_space_count &gt; 0 ) {</span>
<span class="udiff-line-removed">-           real_offset = nonstatic_short_space_offset;</span>
<span class="udiff-line-removed">-           nonstatic_short_space_offset += BytesPerShort;</span>
<span class="udiff-line-removed">-           nonstatic_short_space_count  -= 1;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           real_offset = next_nonstatic_short_offset;</span>
<span class="udiff-line-removed">-           next_nonstatic_short_offset += BytesPerShort;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case NONSTATIC_WORD:</span>
<span class="udiff-line-removed">-         if( nonstatic_word_space_count &gt; 0 ) {</span>
<span class="udiff-line-removed">-           real_offset = nonstatic_word_space_offset;</span>
<span class="udiff-line-removed">-           nonstatic_word_space_offset += BytesPerInt;</span>
<span class="udiff-line-removed">-           nonstatic_word_space_count  -= 1;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           real_offset = next_nonstatic_word_offset;</span>
<span class="udiff-line-removed">-           next_nonstatic_word_offset += BytesPerInt;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case NONSTATIC_DOUBLE:</span>
<span class="udiff-line-removed">-         real_offset = next_nonstatic_double_offset;</span>
<span class="udiff-line-removed">-         next_nonstatic_double_offset += BytesPerLong;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       default:</span>
<span class="udiff-line-removed">-         ShouldNotReachHere();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     fs.set_offset(real_offset);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Handle the contended cases.</span>
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   // Each contended field should not intersect the cache line with another contended field.</span>
<span class="udiff-line-removed">-   // In the absence of alignment information, we end up with pessimistically separating</span>
<span class="udiff-line-removed">-   // the fields with full-width padding.</span>
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   // Additionally, this should not break alignment for the fields, so we round the alignment up</span>
<span class="udiff-line-removed">-   // for each field.</span>
<span class="udiff-line-removed">-   if (nonstatic_contended_count &gt; 0) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // if there is at least one contended field, we need to have pre-padding for them</span>
<span class="udiff-line-removed">-     next_nonstatic_padded_offset += ContendedPaddingWidth;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // collect all contended groups</span>
<span class="udiff-line-removed">-     ResourceBitMap bm(cp-&gt;size());</span>
<span class="udiff-line-removed">-     for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="udiff-line-removed">-       // skip already laid out fields</span>
<span class="udiff-line-removed">-       if (fs.is_offset_set()) continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (fs.is_contended()) {</span>
<span class="udiff-line-removed">-         bm.set_bit(fs.contended_group());</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     int current_group = -1;</span>
<span class="udiff-line-removed">-     while ((current_group = (int)bm.get_next_one_offset(current_group + 1)) != (int)bm.size()) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // skip already laid out fields</span>
<span class="udiff-line-removed">-         if (fs.is_offset_set()) continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // skip non-contended fields and fields from different group</span>
<span class="udiff-line-removed">-         if (!fs.is_contended() || (fs.contended_group() != current_group)) continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // handle statics below</span>
<span class="udiff-line-removed">-         if (fs.access_flags().is_static()) continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         int real_offset = 0;</span>
<span class="udiff-line-removed">-         FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         switch (atype) {</span>
<span class="udiff-line-removed">-           case NONSTATIC_BYTE:</span>
<span class="udiff-line-removed">-             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, 1);</span>
<span class="udiff-line-removed">-             real_offset = next_nonstatic_padded_offset;</span>
<span class="udiff-line-removed">-             next_nonstatic_padded_offset += 1;</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           case NONSTATIC_SHORT:</span>
<span class="udiff-line-removed">-             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);</span>
<span class="udiff-line-removed">-             real_offset = next_nonstatic_padded_offset;</span>
<span class="udiff-line-removed">-             next_nonstatic_padded_offset += BytesPerShort;</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           case NONSTATIC_WORD:</span>
<span class="udiff-line-removed">-             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);</span>
<span class="udiff-line-removed">-             real_offset = next_nonstatic_padded_offset;</span>
<span class="udiff-line-removed">-             next_nonstatic_padded_offset += BytesPerInt;</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           case NONSTATIC_DOUBLE:</span>
<span class="udiff-line-removed">-             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="udiff-line-removed">-             real_offset = next_nonstatic_padded_offset;</span>
<span class="udiff-line-removed">-             next_nonstatic_padded_offset += BytesPerLong;</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Inline types in static fields are handled with oops</span>
<span class="udiff-line-removed">-           case NONSTATIC_INLINE:</span>
<span class="udiff-line-removed">-             throwInlineTypeLimitation(THREAD_AND_LOCATION,</span>
<span class="udiff-line-removed">-                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           case NONSTATIC_OOP:</span>
<span class="udiff-line-removed">-             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);</span>
<span class="udiff-line-removed">-             real_offset = next_nonstatic_padded_offset;</span>
<span class="udiff-line-removed">-             next_nonstatic_padded_offset += heapOopSize;</span>
<span class="udiff-line-removed">-             nonstatic_oop_maps-&gt;add(real_offset, 1);</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           default:</span>
<span class="udiff-line-removed">-             ShouldNotReachHere();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (fs.contended_group() == 0) {</span>
<span class="udiff-line-removed">-           // Contended group defines the equivalence class over the fields:</span>
<span class="udiff-line-removed">-           // the fields within the same contended group are not inter-padded.</span>
<span class="udiff-line-removed">-           // The only exception is default group, which does not incur the</span>
<span class="udiff-line-removed">-           // equivalence, and so requires intra-padding.</span>
<span class="udiff-line-removed">-           next_nonstatic_padded_offset += ContendedPaddingWidth;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         fs.set_offset(real_offset);</span>
<span class="udiff-line-removed">-       } // for</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Start laying out the next group.</span>
<span class="udiff-line-removed">-       // Note that this will effectively pad the last group in the back;</span>
<span class="udiff-line-removed">-       // this is expected to alleviate memory contention effects for</span>
<span class="udiff-line-removed">-       // subclass fields and/or adjacent object.</span>
<span class="udiff-line-removed">-       // If this was the default group, the padding is already in place.</span>
<span class="udiff-line-removed">-       if (current_group != 0) {</span>
<span class="udiff-line-removed">-         next_nonstatic_padded_offset += ContendedPaddingWidth;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // handle static fields</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Entire class is contended, pad in the back.</span>
<span class="udiff-line-removed">-   // This helps to alleviate memory contention effects for subclass fields</span>
<span class="udiff-line-removed">-   // and/or adjacent object.</span>
<span class="udiff-line-removed">-   if (is_contended_class) {</span>
<span class="udiff-line-removed">-     assert(!is_inline_type(), &quot;@Contended not supported for inline types yet&quot;);</span>
<span class="udiff-line-removed">-     next_nonstatic_padded_offset += ContendedPaddingWidth;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int notaligned_nonstatic_fields_end;</span>
<span class="udiff-line-removed">-   if (nonstatic_inline_type_count != 0) {</span>
<span class="udiff-line-removed">-     notaligned_nonstatic_fields_end = next_nonstatic_inline_type_offset;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int nonstatic_field_sz_align = heapOopSize;</span>
<span class="udiff-line-removed">-   if (is_inline_type()) {</span>
<span class="udiff-line-removed">-     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {</span>
<span class="udiff-line-removed">-       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);</span>
<span class="udiff-line-removed">-   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);</span>
<span class="udiff-line-removed">-   int static_fields_end         = align_up(next_static_byte_offset, wordSize);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int static_field_size         = (static_fields_end -</span>
<span class="udiff-line-removed">-                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;</span>
<span class="udiff-line-removed">-   nonstatic_field_size          = nonstatic_field_size +</span>
<span class="udiff-line-removed">-                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int instance_size             = align_object_size(instance_end / wordSize);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert(instance_size == align_object_size(align_up(</span>
<span class="udiff-line-removed">-          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)</span>
<span class="udiff-line-removed">-          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Invariant: nonstatic_field end/start should only change if there are</span>
<span class="udiff-line-removed">-   // nonstatic fields in the class, or if the class is contended. We compare</span>
<span class="udiff-line-removed">-   // against the non-aligned value, so that end alignment will not fail the</span>
<span class="udiff-line-removed">-   // assert without actually having the fields.</span>
<span class="udiff-line-removed">-   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||</span>
<span class="udiff-line-removed">-          is_contended_class ||</span>
<span class="udiff-line-removed">-          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Number of non-static oop map blocks allocated at end of klass.</span>
<span class="udiff-line-removed">-   nonstatic_oop_maps-&gt;compact();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-removed">-   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||</span>
<span class="udiff-line-removed">-       (PrintInlineLayout &amp;&amp; (is_inline_type() || has_nonstatic_inline_fields))) {</span>
<span class="udiff-line-removed">-     print_field_layout(_class_name,</span>
<span class="udiff-line-removed">-           _fields,</span>
<span class="udiff-line-removed">-           cp,</span>
<span class="udiff-line-removed">-           instance_size,</span>
<span class="udiff-line-removed">-           nonstatic_fields_start,</span>
<span class="udiff-line-removed">-           nonstatic_fields_end,</span>
<span class="udiff-line-removed">-           static_fields_end);</span>
<span class="udiff-line-removed">-     nonstatic_oop_maps-&gt;print_on(tty);</span>
<span class="udiff-line-removed">-     tty-&gt;print(&quot;\n&quot;);</span>
<span class="udiff-line-removed">-     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);</span>
<span class="udiff-line-removed">-     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);</span>
<span class="udiff-line-removed">-     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);</span>
<span class="udiff-line-removed">-     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);</span>
<span class="udiff-line-removed">-     tty-&gt;print_cr(&quot;---&quot;);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   // Pass back information needed for InstanceKlass creation</span>
<span class="udiff-line-removed">-   info-&gt;oop_map_blocks = nonstatic_oop_maps;</span>
<span class="udiff-line-removed">-   info-&gt;_instance_size = instance_size;</span>
<span class="udiff-line-removed">-   info-&gt;_static_field_size = static_field_size;</span>
<span class="udiff-line-removed">-   info-&gt;_nonstatic_field_size = nonstatic_field_size;</span>
<span class="udiff-line-removed">-   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;</span>
<span class="udiff-line-removed">-   info-&gt;_has_inline_fields = nonstatic_inline_type_count &gt; 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // An inline type is naturally atomic if it has just one field, and</span>
<span class="udiff-line-removed">-   // that field is simple enough.</span>
<span class="udiff-line-removed">-   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;</span>
<span class="udiff-line-removed">-                                 !super_has_nonstatic_fields &amp;&amp;</span>
<span class="udiff-line-removed">-                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;</span>
<span class="udiff-line-removed">-                                 (not_atomic_inline_types == 0) &amp;&amp;</span>
<span class="udiff-line-removed">-                                 (nonstatic_contended_count == 0));</span>
<span class="udiff-line-removed">-   // This may be too restrictive, since if all the fields fit in 64</span>
<span class="udiff-line-removed">-   // bits we could make the decision to align instances of this class</span>
<span class="udiff-line-removed">-   // to 64-bit boundaries, and load and store them as single words.</span>
<span class="udiff-line-removed">-   // And on machines which supported larger atomics we could similarly</span>
<span class="udiff-line-removed">-   // allow larger values to be atomic, if properly aligned.</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
    assert(ik != NULL, &quot;invariant&quot;);
  
    const Klass* const super = ik-&gt;super();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6453,17 +5804,13 @@</span>
      }
    }
  
    if (is_inline_type()) {
      InlineKlass* vk = InlineKlass::cast(ik);
<span class="udiff-line-modified-removed">-     if (UseNewFieldLayout) {</span>
<span class="udiff-line-modified-removed">-       vk-&gt;set_alignment(_alignment);</span>
<span class="udiff-line-modified-removed">-       vk-&gt;set_first_field_offset(_first_field_offset);</span>
<span class="udiff-line-removed">-       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     vk-&gt;set_alignment(_alignment);</span>
<span class="udiff-line-modified-added">+     vk-&gt;set_first_field_offset(_first_field_offset);</span>
<span class="udiff-line-modified-added">+     vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);</span>
      InlineKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);
    }
  
    ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7290,22 +6637,18 @@</span>
        assert(klass-&gt;access_flags().is_inline_type(), &quot;Value type expected&quot;);
      }
    }
  
    _field_info = new FieldLayoutInfo();
<span class="udiff-line-modified-removed">-   if (UseNewFieldLayout) {</span>
<span class="udiff-line-modified-removed">-     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,</span>
<span class="udiff-line-modified-removed">-         _parsed_annotations-&gt;is_contended(), is_inline_type(),</span>
<span class="udiff-line-modified-removed">-         loader_data(), _protection_domain, _field_info);</span>
<span class="udiff-line-modified-removed">-     lb.build_layout(CHECK);</span>
<span class="udiff-line-modified-removed">-     if (is_inline_type()) {</span>
<span class="udiff-line-modified-removed">-       _alignment = lb.get_alignment();</span>
<span class="udiff-line-modified-removed">-       _first_field_offset = lb.get_first_field_offset();</span>
<span class="udiff-line-removed">-       _exact_size_in_bytes = lb.get_exact_size_in_byte();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);</span>
<span class="udiff-line-modified-added">+   FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,</span>
<span class="udiff-line-modified-added">+       _parsed_annotations-&gt;is_contended(), is_inline_type(),</span>
<span class="udiff-line-modified-added">+       loader_data(), _protection_domain, _field_info);</span>
<span class="udiff-line-modified-added">+   lb.build_layout(CHECK);</span>
<span class="udiff-line-modified-added">+   if (is_inline_type()) {</span>
<span class="udiff-line-modified-added">+     _alignment = lb.get_alignment();</span>
<span class="udiff-line-modified-added">+     _first_field_offset = lb.get_first_field_offset();</span>
<span class="udiff-line-modified-added">+     _exact_size_in_bytes = lb.get_exact_size_in_byte();</span>
    }
    _has_inline_type_fields = _field_info-&gt;_has_inline_fields;
  
    // Compute reference type
    _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
</pre>
<center><a href="../../cpu/aarch64/templateTable_aarch64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>