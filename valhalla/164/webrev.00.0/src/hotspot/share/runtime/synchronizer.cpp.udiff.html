<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/synchronizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="safepoint.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/synchronizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -503,19 +503,15 @@</span>
    assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_inline_klass(), &quot;monitor op on inline type&quot;);
    const markWord mark = obj-&gt;mark();
  
    if (mark.has_monitor()) {
      ObjectMonitor* const m = mark.monitor();
<span class="udiff-line-modified-removed">-     if (AsyncDeflateIdleMonitors) {</span>
<span class="udiff-line-modified-removed">-       // An async deflation can race us before we manage to make the</span>
<span class="udiff-line-modified-removed">-       // ObjectMonitor busy by setting the owner below. If we detect</span>
<span class="udiff-line-modified-removed">-       // that race we just bail out to the slow-path here.</span>
<span class="udiff-line-modified-removed">-       if (m-&gt;object() == NULL) {</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       assert(m-&gt;object() == obj, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+     // An async deflation can race us before we manage to make the</span>
<span class="udiff-line-modified-added">+     // ObjectMonitor busy by setting the owner below. If we detect</span>
<span class="udiff-line-modified-added">+     // that race we just bail out to the slow-path here.</span>
<span class="udiff-line-modified-added">+     if (m-&gt;object() == NULL) {</span>
<span class="udiff-line-modified-added">+       return false;</span>
      }
      Thread* const owner = (Thread *) m-&gt;_owner;
  
      // Lock contention and Transactional Lock Elision (TLE) diagnostics
      // and observability
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1015,13 +1011,12 @@</span>
      // VM should be calling bootstrap method
      ShouldNotReachHere();
    }
    if (UseBiasedLocking) {
      // NOTE: many places throughout the JVM do not expect a safepoint
<span class="udiff-line-modified-removed">-     // to be taken here, in particular most operations on perm gen</span>
<span class="udiff-line-modified-removed">-     // objects. However, we only ever bias Java instances and all of</span>
<span class="udiff-line-removed">-     // the call sites of identity_hash that might revoke biases have</span>
<span class="udiff-line-modified-added">+     // to be taken here. However, we only ever bias Java instances and all</span>
<span class="udiff-line-modified-added">+     // of the call sites of identity_hash that might revoke biases have</span>
      // been checked to make sure they can handle a safepoint. The
      // added check of the bias pattern is to avoid useless calls to
      // thread-local storage.
      if (obj-&gt;mark().has_bias_pattern()) {
        // Handle for oop obj in case of STW safepoint
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1219,12 +1214,10 @@</span>
      return self-&gt;is_lock_owned((address)mark.locker()) ?
        owner_self : owner_other;
    }
  
    // CASE: inflated. Mark (tagged pointer) points to an ObjectMonitor.
<span class="udiff-line-removed">-   // The Object:ObjectMonitor relationship is stable as long as we&#39;re</span>
<span class="udiff-line-removed">-   // not at a safepoint and AsyncDeflateIdleMonitors is false.</span>
    if (mark.has_monitor()) {
      // The first stage of async deflation does not affect any field
      // used by this comparison so the ObjectMonitor* is usable here.
      ObjectMonitor* monitor = mark.monitor();
      void* owner = monitor-&gt;owner();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1320,13 +1313,10 @@</span>
    }
    return false;
  }
  
  bool ObjectSynchronizer::is_async_deflation_needed() {
<span class="udiff-line-removed">-   if (!AsyncDeflateIdleMonitors) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
    if (is_async_deflation_requested()) {
      // Async deflation request.
      return true;
    }
    if (AsyncDeflationInterval &gt; 0 &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1339,52 +1329,37 @@</span>
      return true;
    }
    return false;
  }
  
<span class="udiff-line-removed">- bool ObjectSynchronizer::is_safepoint_deflation_needed() {</span>
<span class="udiff-line-removed">-   return !AsyncDeflateIdleMonitors &amp;&amp;</span>
<span class="udiff-line-removed">-          monitors_used_above_threshold();  // Too many monitors in use.</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool ObjectSynchronizer::request_deflate_idle_monitors() {
    bool is_JavaThread = Thread::current()-&gt;is_Java_thread();
    bool ret_code = false;
  
<span class="udiff-line-modified-removed">-   if (AsyncDeflateIdleMonitors) {</span>
<span class="udiff-line-modified-removed">-     jlong last_time = last_async_deflation_time_ns();</span>
<span class="udiff-line-modified-removed">-     set_is_async_deflation_requested(true);</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       MonitorLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-removed">-       ml.notify_all();</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     const int N_CHECKS = 5;</span>
<span class="udiff-line-modified-removed">-     for (int i = 0; i &lt; N_CHECKS; i++) {  // sleep for at most 5 seconds</span>
<span class="udiff-line-modified-removed">-       if (last_async_deflation_time_ns() &gt; last_time) {</span>
<span class="udiff-line-modified-removed">-         log_info(monitorinflation)(&quot;Async Deflation happened after %d check(s).&quot;, i);</span>
<span class="udiff-line-modified-removed">-         ret_code = true;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (is_JavaThread) {</span>
<span class="udiff-line-removed">-         // JavaThread has to honor the blocking protocol.</span>
<span class="udiff-line-removed">-         ThreadBlockInVM tbivm(JavaThread::current());</span>
<span class="udiff-line-removed">-         os::naked_short_sleep(999);  // sleep for almost 1 second</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         os::naked_short_sleep(999);  // sleep for almost 1 second</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+   jlong last_time = last_async_deflation_time_ns();</span>
<span class="udiff-line-modified-added">+   set_is_async_deflation_requested(true);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     MonitorLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     ml.notify_all();</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   const int N_CHECKS = 5;</span>
<span class="udiff-line-modified-added">+   for (int i = 0; i &lt; N_CHECKS; i++) {  // sleep for at most 5 seconds</span>
<span class="udiff-line-modified-added">+     if (last_async_deflation_time_ns() &gt; last_time) {</span>
<span class="udiff-line-modified-added">+       log_info(monitorinflation)(&quot;Async Deflation happened after %d check(s).&quot;, i);</span>
<span class="udiff-line-modified-added">+       ret_code = true;</span>
<span class="udiff-line-modified-added">+       break;</span>
      }
<span class="udiff-line-modified-removed">-     if (!ret_code) {</span>
<span class="udiff-line-modified-removed">-       log_info(monitorinflation)(&quot;Async Deflation DID NOT happen after %d checks.&quot;, N_CHECKS);</span>
<span class="udiff-line-modified-added">+     if (is_JavaThread) {</span>
<span class="udiff-line-modified-added">+       // JavaThread has to honor the blocking protocol.</span>
<span class="udiff-line-added">+       ThreadBlockInVM tbivm(JavaThread::current());</span>
<span class="udiff-line-added">+       os::naked_short_sleep(999);  // sleep for almost 1 second</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       os::naked_short_sleep(999);  // sleep for almost 1 second</span>
      }
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-removed">-     // Only need to force this safepoint if we are not using async</span>
<span class="udiff-line-modified-removed">-     // deflation. The VMThread won&#39;t call this function before the</span>
<span class="udiff-line-removed">-     // final safepoint if we are not using async deflation so we</span>
<span class="udiff-line-removed">-     // don&#39;t have to reason about the VMThread executing a VM-op here.</span>
<span class="udiff-line-removed">-     VM_ForceSafepoint force_safepoint_op;</span>
<span class="udiff-line-removed">-     VMThread::execute(&amp;force_safepoint_op);</span>
<span class="udiff-line-removed">-     ret_code = true;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   if (!ret_code) {</span>
<span class="udiff-line-modified-added">+     log_info(monitorinflation)(&quot;Async Deflation DID NOT happen after %d checks.&quot;, N_CHECKS);</span>
    }
  
    return ret_code;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1422,13 +1397,13 @@</span>
  
  // -----------------------------------------------------------------------------
  // ObjectMonitor Lifecycle
  // -----------------------
  // Inflation unlinks monitors from om_list_globals._free_list or a per-thread
<span class="udiff-line-modified-removed">- // free list and associates them with objects. Deflation -- which occurs at</span>
<span class="udiff-line-modified-removed">- // STW-time or asynchronously -- disassociates idle monitors from objects.</span>
<span class="udiff-line-modified-removed">- // Such scavenged monitors are returned to the om_list_globals._free_list.</span>
<span class="udiff-line-modified-added">+ // free list and associates them with objects. Async deflation disassociates</span>
<span class="udiff-line-modified-added">+ // idle monitors from objects. Such scavenged monitors are returned to the</span>
<span class="udiff-line-modified-added">+ // om_list_globals._free_list.</span>
  //
  // ObjectMonitors reside in type-stable memory (TSM) and are immortal.
  //
  // Lifecycle:
  // --   unassigned and on the om_list_globals._free_list
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1437,11 +1412,11 @@</span>
  //      to the ObjectMonitor.
  
  ObjectMonitor* ObjectSynchronizer::om_alloc(Thread* self) {
    // A large MAXPRIVATE value reduces both list lock contention
    // and list coherency traffic, but also tends to increase the
<span class="udiff-line-modified-removed">-   // number of ObjectMonitors in circulation as well as the STW</span>
<span class="udiff-line-modified-added">+   // number of ObjectMonitors in circulation as well as the</span>
    // scavenge costs.  As usual, we lean toward time in space-time
    // tradeoffs.
    const int MAXPRIVATE = 1024;
    NoSafepointVerifier nsv;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1473,27 +1448,25 @@</span>
          ObjectMonitor* take = take_from_start_of_global_free_list();
          if (take == NULL) {
            break;  // No more are available.
          }
          guarantee(take-&gt;object() == NULL, &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-         if (AsyncDeflateIdleMonitors) {</span>
<span class="udiff-line-modified-removed">-           // We allowed 3 field values to linger during async deflation.</span>
<span class="udiff-line-modified-removed">-           // Clear or restore them as appropriate.</span>
<span class="udiff-line-modified-removed">-           take-&gt;set_header(markWord::zero());</span>
<span class="udiff-line-modified-removed">-           // DEFLATER_MARKER is the only non-NULL value we should see here.</span>
<span class="udiff-line-modified-removed">-           take-&gt;try_set_owner_from(DEFLATER_MARKER, NULL);</span>
<span class="udiff-line-modified-removed">-           if (take-&gt;contentions() &lt; 0) {</span>
<span class="udiff-line-modified-removed">-             // Add back max_jint to restore the contentions field to its</span>
<span class="udiff-line-modified-removed">-             // proper value.</span>
<span class="udiff-line-removed">-             take-&gt;add_to_contentions(max_jint);</span>
<span class="udiff-line-modified-added">+         // We allowed 3 field values to linger during async deflation.</span>
<span class="udiff-line-modified-added">+         // Clear or restore them as appropriate.</span>
<span class="udiff-line-modified-added">+         take-&gt;set_header(markWord::zero());</span>
<span class="udiff-line-modified-added">+         // DEFLATER_MARKER is the only non-NULL value we should see here.</span>
<span class="udiff-line-modified-added">+         take-&gt;try_set_owner_from(DEFLATER_MARKER, NULL);</span>
<span class="udiff-line-modified-added">+         if (take-&gt;contentions() &lt; 0) {</span>
<span class="udiff-line-modified-added">+           // Add back max_jint to restore the contentions field to its</span>
<span class="udiff-line-modified-added">+           // proper value.</span>
<span class="udiff-line-modified-added">+           take-&gt;add_to_contentions(max_jint);</span>
  
  #ifdef ASSERT
<span class="udiff-line-modified-removed">-             jint l_contentions = take-&gt;contentions();</span>
<span class="udiff-line-modified-added">+           jint l_contentions = take-&gt;contentions();</span>
<span class="udiff-line-added">+           assert(l_contentions &gt;= 0, &quot;must not be negative: l_contentions=%d, contentions=%d&quot;,</span>
<span class="udiff-line-added">+                  l_contentions, take-&gt;contentions());</span>
  #endif
<span class="udiff-line-removed">-             assert(l_contentions &gt;= 0, &quot;must not be negative: l_contentions=%d, contentions=%d&quot;,</span>
<span class="udiff-line-removed">-                    l_contentions, take-&gt;contentions());</span>
<span class="udiff-line-removed">-           }</span>
          }
          take-&gt;Recycle();
          // Since we&#39;re taking from the global free-list, take must be Free.
          // om_release() also sets the allocation state to Free because it
          // is called from other code paths.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1555,12 +1528,12 @@</span>
  // a CAS attempt failed. This doesn&#39;t allow unbounded #s of monitors to
  // accumulate on a thread&#39;s free list.
  //
  // Key constraint: all ObjectMonitors on a thread&#39;s free list and the global
  // free list must have their object field set to null. This prevents the
<span class="udiff-line-modified-removed">- // scavenger -- deflate_monitor_list() or deflate_monitor_list_using_JT()</span>
<span class="udiff-line-modified-removed">- // -- from reclaiming them while we are trying to release them.</span>
<span class="udiff-line-modified-added">+ // scavenger -- deflate_monitor_list_using_JT() -- from reclaiming them</span>
<span class="udiff-line-modified-added">+ // while we are trying to release them.</span>
  
  void ObjectSynchronizer::om_release(Thread* self, ObjectMonitor* m,
                                      bool from_per_thread_alloc) {
    guarantee(m-&gt;header().value() == 0, &quot;invariant&quot;);
    guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1665,19 +1638,17 @@</span>
  // lists to the appropriate global lists. The ObjectMonitors on the
  // per-thread in-use list may still be in use by other threads.
  //
  // We currently call om_flush() from Threads::remove() before the
  // thread has been excised from the thread list and is no longer a
<span class="udiff-line-modified-removed">- // mutator. This means that om_flush() cannot run concurrently with</span>
<span class="udiff-line-modified-removed">- // a safepoint and interleave with deflate_idle_monitors(). In</span>
<span class="udiff-line-modified-removed">- // particular, this ensures that the thread&#39;s in-use monitors are</span>
<span class="udiff-line-modified-removed">- // scanned by a GC safepoint, either via Thread::oops_do() (before</span>
<span class="udiff-line-removed">- // om_flush() is called) or via ObjectSynchronizer::oops_do() (after</span>
<span class="udiff-line-removed">- // om_flush() is called).</span>
<span class="udiff-line-modified-added">+ // mutator. In particular, this ensures that the thread&#39;s in-use</span>
<span class="udiff-line-modified-added">+ // monitors are scanned by a GC safepoint, either via Thread::oops_do()</span>
<span class="udiff-line-modified-added">+ // (before om_flush() is called) or via ObjectSynchronizer::oops_do()</span>
<span class="udiff-line-modified-added">+ // (after om_flush() is called).</span>
  //
<span class="udiff-line-modified-removed">- // With AsyncDeflateIdleMonitors, deflate_global_idle_monitors_using_JT()</span>
<span class="udiff-line-modified-removed">- // and deflate_per_thread_idle_monitors_using_JT() (in another thread) can</span>
<span class="udiff-line-modified-added">+ // deflate_global_idle_monitors_using_JT() and</span>
<span class="udiff-line-modified-added">+ // deflate_per_thread_idle_monitors_using_JT() (in another thread) can</span>
  // run at the same time as om_flush() so we have to follow a careful
  // protocol to prevent list corruption.
  
  void ObjectSynchronizer::om_flush(Thread* self) {
    // Process the per-thread in-use list first to be consistent.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1727,13 +1698,15 @@</span>
        in_use_tail = cur_om;
        in_use_count++;
        cur_om = unmarked_next(cur_om);
      }
      guarantee(in_use_tail != NULL, &quot;invariant&quot;);
<span class="udiff-line-added">+ #ifdef ASSERT</span>
      int l_om_in_use_count = Atomic::load(&amp;self-&gt;om_in_use_count);
<span class="udiff-line-modified-removed">-     ADIM_guarantee(l_om_in_use_count == in_use_count, &quot;in-use counts don&#39;t match: &quot;</span>
<span class="udiff-line-modified-removed">-                    &quot;l_om_in_use_count=%d, in_use_count=%d&quot;, l_om_in_use_count, in_use_count);</span>
<span class="udiff-line-modified-added">+     assert(l_om_in_use_count == in_use_count, &quot;in-use counts don&#39;t match: &quot;</span>
<span class="udiff-line-modified-added">+            &quot;l_om_in_use_count=%d, in_use_count=%d&quot;, l_om_in_use_count, in_use_count);</span>
<span class="udiff-line-added">+ #endif</span>
      Atomic::store(&amp;self-&gt;om_in_use_count, 0);
      // Clear the in-use list head (which also unlocks it):
      Atomic::store(&amp;self-&gt;om_in_use_list, (ObjectMonitor*)NULL);
      om_unlock(in_use_list);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1770,13 +1743,15 @@</span>
          stringStream ss;
          fatal(&quot;must be !is_busy: %s&quot;, s-&gt;is_busy_to_string(&amp;ss));
        }
      }
      guarantee(free_tail != NULL, &quot;invariant&quot;);
<span class="udiff-line-added">+ #ifdef ASSERT</span>
      int l_om_free_count = Atomic::load(&amp;self-&gt;om_free_count);
<span class="udiff-line-modified-removed">-     ADIM_guarantee(l_om_free_count == free_count, &quot;free counts don&#39;t match: &quot;</span>
<span class="udiff-line-modified-removed">-                    &quot;l_om_free_count=%d, free_count=%d&quot;, l_om_free_count, free_count);</span>
<span class="udiff-line-modified-added">+     assert(l_om_free_count == free_count, &quot;free counts don&#39;t match: &quot;</span>
<span class="udiff-line-modified-added">+            &quot;l_om_free_count=%d, free_count=%d&quot;, l_om_free_count, free_count);</span>
<span class="udiff-line-added">+ #endif</span>
      Atomic::store(&amp;self-&gt;om_free_count, 0);
      Atomic::store(&amp;self-&gt;om_free_list, (ObjectMonitor*)NULL);
      om_unlock(free_list);
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1855,11 +1830,10 @@</span>
      // CASE: inflated
      if (mark.has_monitor()) {
        ObjectMonitor* inf = mark.monitor();
        markWord dmw = inf-&gt;header();
        assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());
<span class="udiff-line-removed">-       assert(AsyncDeflateIdleMonitors || inf-&gt;object() == object, &quot;invariant&quot;);</span>
        assert(ObjectSynchronizer::verify_objmon_isinpool(inf), &quot;monitor is invalid&quot;);
        return inf;
      }
  
      // CASE: inflation in progress - inflating over a stack-lock.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1941,25 +1915,21 @@</span>
        // object is in the mark.  Furthermore the owner can&#39;t complete
        // an unlock on the object, either.
        markWord dmw = mark.displaced_mark_helper();
        // Catch if the object&#39;s header is not neutral (not locked and
        // not marked is what we care about here).
<span class="udiff-line-modified-removed">-       ADIM_guarantee(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());</span>
<span class="udiff-line-modified-added">+       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());</span>
  
        // Setup monitor fields to proper values -- prepare the monitor
        m-&gt;set_header(dmw);
  
        // Optimization: if the mark.locker stack address is associated
        // with this thread we could simply set m-&gt;_owner = self.
        // Note that a thread can inflate an object
        // that it has stack-locked -- as might happen in wait() -- directly
        // with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.
<span class="udiff-line-modified-removed">-       if (AsyncDeflateIdleMonitors) {</span>
<span class="udiff-line-removed">-         m-&gt;set_owner_from(NULL, DEFLATER_MARKER, mark.locker());</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         m-&gt;set_owner_from(NULL, mark.locker());</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+       m-&gt;set_owner_from(NULL, DEFLATER_MARKER, mark.locker());</span>
        m-&gt;set_object(object);
        // TODO-FIXME: assert BasicLock-&gt;dhw != 0.
  
        // Must preserve store ordering. The monitor state must
        // be stable at the time of publishing the monitor address.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1995,19 +1965,17 @@</span>
      // to inflate and then CAS() again to try to swing _owner from NULL to self.
      // An inflateTry() method that we could call from enter() would be useful.
  
      // Catch if the object&#39;s header is not neutral (not locked and
      // not marked is what we care about here).
<span class="udiff-line-modified-removed">-     ADIM_guarantee(mark.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, mark.value());</span>
<span class="udiff-line-modified-added">+     assert(mark.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, mark.value());</span>
      ObjectMonitor* m = om_alloc(self);
      // prepare m for installation - set monitor to initial state
      m-&gt;Recycle();
      m-&gt;set_header(mark);
<span class="udiff-line-modified-removed">-     if (AsyncDeflateIdleMonitors) {</span>
<span class="udiff-line-modified-removed">-       // DEFLATER_MARKER is the only non-NULL value we should see here.</span>
<span class="udiff-line-removed">-       m-&gt;try_set_owner_from(DEFLATER_MARKER, NULL);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     // DEFLATER_MARKER is the only non-NULL value we should see here.</span>
<span class="udiff-line-modified-added">+     m-&gt;try_set_owner_from(DEFLATER_MARKER, NULL);</span>
      m-&gt;set_object(object);
      m-&gt;_Responsible  = NULL;
      m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;       // consider: keep metastats by type/class
  
      if (object-&gt;cas_set_mark(markWord::encode(m), mark) != mark) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2043,137 +2011,28 @@</span>
      return m;
    }
  }
  
  
<span class="udiff-line-modified-removed">- // We maintain a list of in-use monitors for each thread.</span>
<span class="udiff-line-modified-removed">- //</span>
<span class="udiff-line-modified-removed">- // For safepoint based deflation:</span>
<span class="udiff-line-removed">- // deflate_thread_local_monitors() scans a single thread&#39;s in-use list, while</span>
<span class="udiff-line-removed">- // deflate_idle_monitors() scans only a global list of in-use monitors which</span>
<span class="udiff-line-removed">- // is populated only as a thread dies (see om_flush()).</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // These operations are called at all safepoints, immediately after mutators</span>
<span class="udiff-line-removed">- // are stopped, but before any objects have moved. Collectively they traverse</span>
<span class="udiff-line-removed">- // the population of in-use monitors, deflating where possible. The scavenged</span>
<span class="udiff-line-removed">- // monitors are returned to the global monitor free list.</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // Beware that we scavenge at *every* stop-the-world point. Having a large</span>
<span class="udiff-line-removed">- // number of monitors in-use could negatively impact performance. We also want</span>
<span class="udiff-line-removed">- // to minimize the total # of monitors in circulation, as they incur a small</span>
<span class="udiff-line-removed">- // footprint penalty.</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // Perversely, the heap size -- and thus the STW safepoint rate --</span>
<span class="udiff-line-removed">- // typically drives the scavenge rate.  Large heaps can mean infrequent GC,</span>
<span class="udiff-line-removed">- // which in turn can mean large(r) numbers of ObjectMonitors in circulation.</span>
<span class="udiff-line-removed">- // This is an unfortunate aspect of this design.</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // For async deflation:</span>
<span class="udiff-line-removed">- // If a special deflation request is made, then the safepoint based</span>
<span class="udiff-line-removed">- // deflation mechanism is used. Otherwise, an async deflation request</span>
<span class="udiff-line-removed">- // is registered with the ServiceThread and it is notified.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ObjectSynchronizer::do_safepoint_work(DeflateMonitorCounters* counters) {</span>
<span class="udiff-line-modified-added">+ // An async deflation request is registered with the ServiceThread</span>
<span class="udiff-line-modified-added">+ // and it is notified.</span>
<span class="udiff-line-modified-added">+ void ObjectSynchronizer::do_safepoint_work() {</span>
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
  
<span class="udiff-line-removed">-   // The per-thread in-use lists are handled in</span>
<span class="udiff-line-removed">-   // ParallelSPCleanupThreadClosure::do_thread().</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (!AsyncDeflateIdleMonitors) {</span>
<span class="udiff-line-removed">-     // Use the older mechanism for the global in-use list.</span>
<span class="udiff-line-removed">-     ObjectSynchronizer::deflate_idle_monitors(counters);</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    log_debug(monitorinflation)(&quot;requesting async deflation of idle monitors.&quot;);
    // Request deflation of idle monitors by the ServiceThread:
    set_is_async_deflation_requested(true);
    MonitorLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);
    ml.notify_all();
  
    if (log_is_enabled(Debug, monitorinflation)) {
      // exit_globals()&#39;s call to audit_and_print_stats() is done
      // at the Info level and not at a safepoint.
<span class="udiff-line-removed">-     // For safepoint based deflation, audit_and_print_stats() is called</span>
<span class="udiff-line-removed">-     // in ObjectSynchronizer::finish_deflate_idle_monitors() at the</span>
<span class="udiff-line-removed">-     // Debug level at a safepoint.</span>
      ObjectSynchronizer::audit_and_print_stats(false /* on_exit */);
    }
  }
  
<span class="udiff-line-removed">- // Deflate a single monitor if not in-use</span>
<span class="udiff-line-removed">- // Return true if deflated, false if in-use</span>
<span class="udiff-line-removed">- bool ObjectSynchronizer::deflate_monitor(ObjectMonitor* mid, oop obj,</span>
<span class="udiff-line-removed">-                                          ObjectMonitor** free_head_p,</span>
<span class="udiff-line-removed">-                                          ObjectMonitor** free_tail_p) {</span>
<span class="udiff-line-removed">-   bool deflated;</span>
<span class="udiff-line-removed">-   // Normal case ... The monitor is associated with obj.</span>
<span class="udiff-line-removed">-   const markWord mark = obj-&gt;mark();</span>
<span class="udiff-line-removed">-   guarantee(mark == markWord::encode(mid), &quot;should match: mark=&quot;</span>
<span class="udiff-line-removed">-             INTPTR_FORMAT &quot;, encoded mid=&quot; INTPTR_FORMAT, mark.value(),</span>
<span class="udiff-line-removed">-             markWord::encode(mid).value());</span>
<span class="udiff-line-removed">-   // Make sure that mark.monitor() and markWord::encode() agree:</span>
<span class="udiff-line-removed">-   guarantee(mark.monitor() == mid, &quot;should match: monitor()=&quot; INTPTR_FORMAT</span>
<span class="udiff-line-removed">-             &quot;, mid=&quot; INTPTR_FORMAT, p2i(mark.monitor()), p2i(mid));</span>
<span class="udiff-line-removed">-   const markWord dmw = mid-&gt;header();</span>
<span class="udiff-line-removed">-   guarantee(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (mid-&gt;is_busy()) {</span>
<span class="udiff-line-removed">-     // Easy checks are first - the ObjectMonitor is busy so no deflation.</span>
<span class="udiff-line-removed">-     deflated = false;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // Deflate the monitor if it is no longer being used</span>
<span class="udiff-line-removed">-     // It&#39;s idle - scavenge and return to the global free list</span>
<span class="udiff-line-removed">-     // plain old deflation ...</span>
<span class="udiff-line-removed">-     if (log_is_enabled(Trace, monitorinflation)) {</span>
<span class="udiff-line-removed">-       ResourceMark rm;</span>
<span class="udiff-line-removed">-       log_trace(monitorinflation)(&quot;deflate_monitor: &quot;</span>
<span class="udiff-line-removed">-                                   &quot;object=&quot; INTPTR_FORMAT &quot;, mark=&quot;</span>
<span class="udiff-line-removed">-                                   INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(obj),</span>
<span class="udiff-line-removed">-                                   mark.value(), obj-&gt;klass()-&gt;external_name());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Restore the header back to obj</span>
<span class="udiff-line-removed">-     obj-&gt;release_set_mark(dmw);</span>
<span class="udiff-line-removed">-     if (AsyncDeflateIdleMonitors) {</span>
<span class="udiff-line-removed">-       // clear() expects the owner field to be NULL.</span>
<span class="udiff-line-removed">-       // DEFLATER_MARKER is the only non-NULL value we should see here.</span>
<span class="udiff-line-removed">-       mid-&gt;try_set_owner_from(DEFLATER_MARKER, NULL);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     mid-&gt;clear();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     assert(mid-&gt;object() == NULL, &quot;invariant: object=&quot; INTPTR_FORMAT,</span>
<span class="udiff-line-removed">-            p2i(mid-&gt;object()));</span>
<span class="udiff-line-removed">-     assert(mid-&gt;is_free(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Move the deflated ObjectMonitor to the working free list</span>
<span class="udiff-line-removed">-     // defined by free_head_p and free_tail_p.</span>
<span class="udiff-line-removed">-     if (*free_head_p == NULL) *free_head_p = mid;</span>
<span class="udiff-line-removed">-     if (*free_tail_p != NULL) {</span>
<span class="udiff-line-removed">-       // We append to the list so the caller can use mid-&gt;_next_om</span>
<span class="udiff-line-removed">-       // to fix the linkages in its context.</span>
<span class="udiff-line-removed">-       ObjectMonitor* prevtail = *free_tail_p;</span>
<span class="udiff-line-removed">-       // Should have been cleaned up by the caller:</span>
<span class="udiff-line-removed">-       // Note: Should not have to lock prevtail here since we&#39;re at a</span>
<span class="udiff-line-removed">-       // safepoint and ObjectMonitors on the local free list should</span>
<span class="udiff-line-removed">-       // not be accessed in parallel.</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-       ObjectMonitor* l_next_om = prevtail-&gt;next_om();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-       assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
<span class="udiff-line-removed">-       prevtail-&gt;set_next_om(mid);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     *free_tail_p = mid;</span>
<span class="udiff-line-removed">-     // At this point, mid-&gt;_next_om still refers to its current</span>
<span class="udiff-line-removed">-     // value and another ObjectMonitor&#39;s _next_om field still</span>
<span class="udiff-line-removed">-     // refers to this ObjectMonitor. Those linkages have to be</span>
<span class="udiff-line-removed">-     // cleaned up by the caller who has the complete context.</span>
<span class="udiff-line-removed">-     deflated = true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return deflated;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  // Deflate the specified ObjectMonitor if not in-use using a JavaThread.
  // Returns true if it was deflated and false otherwise.
  //
  // The async deflation protocol sets owner to DEFLATER_MARKER and
  // makes contentions negative as signals to contending threads that
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2186,11 +2045,10 @@</span>
  // Contending threads that see that condition know to retry their operation.
  //
  bool ObjectSynchronizer::deflate_monitor_using_JT(ObjectMonitor* mid,
                                                    ObjectMonitor** free_head_p,
                                                    ObjectMonitor** free_tail_p) {
<span class="udiff-line-removed">-   assert(AsyncDeflateIdleMonitors, &quot;sanity check&quot;);</span>
    assert(Thread::current()-&gt;is_Java_thread(), &quot;precondition&quot;);
    // A newly allocated ObjectMonitor should not be seen here so we
    // avoid an endless inflate/deflate cycle.
    assert(mid-&gt;is_old(), &quot;must be old: allocation_state=%d&quot;,
           (int) mid-&gt;allocation_state());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2275,11 +2133,11 @@</span>
      // to fix the linkages in its context.
      ObjectMonitor* prevtail = *free_tail_p;
      // prevtail should have been cleaned up by the caller:
  #ifdef ASSERT
      ObjectMonitor* l_next_om = unmarked_next(prevtail);
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+     assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
  #endif
      om_lock(prevtail);
      prevtail-&gt;set_next_om(mid);  // prevtail now points to mid (and is unlocked)
    }
    *free_tail_p = mid;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2292,60 +2150,10 @@</span>
    // We leave owner == DEFLATER_MARKER and contentions &lt; 0
    // to force any racing threads to retry.
    return true;  // Success, ObjectMonitor has been deflated.
  }
  
<span class="udiff-line-removed">- // Walk a given monitor list, and deflate idle monitors.</span>
<span class="udiff-line-removed">- // The given list could be a per-thread list or a global list.</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // In the case of parallel processing of thread local monitor lists,</span>
<span class="udiff-line-removed">- // work is done by Threads::parallel_threads_do() which ensures that</span>
<span class="udiff-line-removed">- // each Java thread is processed by exactly one worker thread, and</span>
<span class="udiff-line-removed">- // thus avoid conflicts that would arise when worker threads would</span>
<span class="udiff-line-removed">- // process the same monitor lists concurrently.</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // See also ParallelSPCleanupTask and</span>
<span class="udiff-line-removed">- // SafepointSynchronize::do_cleanup_tasks() in safepoint.cpp and</span>
<span class="udiff-line-removed">- // Threads::parallel_java_threads_do() in thread.cpp.</span>
<span class="udiff-line-removed">- int ObjectSynchronizer::deflate_monitor_list(ObjectMonitor** list_p,</span>
<span class="udiff-line-removed">-                                              int* count_p,</span>
<span class="udiff-line-removed">-                                              ObjectMonitor** free_head_p,</span>
<span class="udiff-line-removed">-                                              ObjectMonitor** free_tail_p) {</span>
<span class="udiff-line-removed">-   ObjectMonitor* cur_mid_in_use = NULL;</span>
<span class="udiff-line-removed">-   ObjectMonitor* mid = NULL;</span>
<span class="udiff-line-removed">-   ObjectMonitor* next = NULL;</span>
<span class="udiff-line-removed">-   int deflated_count = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // This list walk executes at a safepoint and does not race with any</span>
<span class="udiff-line-removed">-   // other list walkers.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   for (mid = Atomic::load(list_p); mid != NULL; mid = next) {</span>
<span class="udiff-line-removed">-     next = unmarked_next(mid);</span>
<span class="udiff-line-removed">-     oop obj = (oop) mid-&gt;object();</span>
<span class="udiff-line-removed">-     if (obj != NULL &amp;&amp; deflate_monitor(mid, obj, free_head_p, free_tail_p)) {</span>
<span class="udiff-line-removed">-       // Deflation succeeded and already updated free_head_p and</span>
<span class="udiff-line-removed">-       // free_tail_p as needed. Finish the move to the local free list</span>
<span class="udiff-line-removed">-       // by unlinking mid from the global or per-thread in-use list.</span>
<span class="udiff-line-removed">-       if (cur_mid_in_use == NULL) {</span>
<span class="udiff-line-removed">-         // mid is the list head so switch the list head to next:</span>
<span class="udiff-line-removed">-         Atomic::store(list_p, next);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         // Switch cur_mid_in_use&#39;s next field to next:</span>
<span class="udiff-line-removed">-         cur_mid_in_use-&gt;set_next_om(next);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       // At this point mid is disconnected from the in-use list.</span>
<span class="udiff-line-removed">-       deflated_count++;</span>
<span class="udiff-line-removed">-       Atomic::dec(count_p);</span>
<span class="udiff-line-removed">-       // mid is current tail in the free_head_p list so NULL terminate it:</span>
<span class="udiff-line-removed">-       mid-&gt;set_next_om(NULL);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       cur_mid_in_use = mid;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return deflated_count;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  // Walk a given ObjectMonitor list and deflate idle ObjectMonitors using
  // a JavaThread. Returns the number of deflated ObjectMonitors. The given
  // list could be a per-thread in-use list or the global in-use list.
  // If a safepoint has started, then we save state via saved_mid_in_use_p
  // and return to the caller to honor the safepoint.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2353,11 +2161,10 @@</span>
  int ObjectSynchronizer::deflate_monitor_list_using_JT(ObjectMonitor** list_p,
                                                        int* count_p,
                                                        ObjectMonitor** free_head_p,
                                                        ObjectMonitor** free_tail_p,
                                                        ObjectMonitor** saved_mid_in_use_p) {
<span class="udiff-line-removed">-   assert(AsyncDeflateIdleMonitors, &quot;sanity check&quot;);</span>
    JavaThread* self = JavaThread::current();
  
    ObjectMonitor* cur_mid_in_use = NULL;
    ObjectMonitor* mid = NULL;
    ObjectMonitor* next = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2483,79 +2290,10 @@</span>
    // no need to save state.
    *saved_mid_in_use_p = NULL;
    return deflated_count;
  }
  
<span class="udiff-line-removed">- void ObjectSynchronizer::prepare_deflate_idle_monitors(DeflateMonitorCounters* counters) {</span>
<span class="udiff-line-removed">-   counters-&gt;n_in_use = 0;              // currently associated with objects</span>
<span class="udiff-line-removed">-   counters-&gt;n_in_circulation = 0;      // extant</span>
<span class="udiff-line-removed">-   counters-&gt;n_scavenged = 0;           // reclaimed (global and per-thread)</span>
<span class="udiff-line-removed">-   counters-&gt;per_thread_scavenged = 0;  // per-thread scavenge total</span>
<span class="udiff-line-removed">-   counters-&gt;per_thread_times = 0.0;    // per-thread scavenge times</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ObjectSynchronizer::deflate_idle_monitors(DeflateMonitorCounters* counters) {</span>
<span class="udiff-line-removed">-   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (AsyncDeflateIdleMonitors) {</span>
<span class="udiff-line-removed">-     // Nothing to do when global idle ObjectMonitors are deflated using</span>
<span class="udiff-line-removed">-     // a JavaThread.</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bool deflated = false;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ObjectMonitor* free_head_p = NULL;  // Local SLL of scavenged monitors</span>
<span class="udiff-line-removed">-   ObjectMonitor* free_tail_p = NULL;</span>
<span class="udiff-line-removed">-   elapsedTimer timer;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (log_is_enabled(Info, monitorinflation)) {</span>
<span class="udiff-line-removed">-     timer.start();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Note: the thread-local monitors lists get deflated in</span>
<span class="udiff-line-removed">-   // a separate pass. See deflate_thread_local_monitors().</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // For moribund threads, scan om_list_globals._in_use_list</span>
<span class="udiff-line-removed">-   int deflated_count = 0;</span>
<span class="udiff-line-removed">-   if (Atomic::load(&amp;om_list_globals._in_use_list) != NULL) {</span>
<span class="udiff-line-removed">-     // Update n_in_circulation before om_list_globals._in_use_count is</span>
<span class="udiff-line-removed">-     // updated by deflation.</span>
<span class="udiff-line-removed">-     Atomic::add(&amp;counters-&gt;n_in_circulation,</span>
<span class="udiff-line-removed">-                 Atomic::load(&amp;om_list_globals._in_use_count));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     deflated_count = deflate_monitor_list(&amp;om_list_globals._in_use_list,</span>
<span class="udiff-line-removed">-                                           &amp;om_list_globals._in_use_count,</span>
<span class="udiff-line-removed">-                                           &amp;free_head_p, &amp;free_tail_p);</span>
<span class="udiff-line-removed">-     Atomic::add(&amp;counters-&gt;n_in_use, Atomic::load(&amp;om_list_globals._in_use_count));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (free_head_p != NULL) {</span>
<span class="udiff-line-removed">-     // Move the deflated ObjectMonitors back to the global free list.</span>
<span class="udiff-line-removed">-     guarantee(free_tail_p != NULL &amp;&amp; deflated_count &gt; 0, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-     ObjectMonitor* l_next_om = free_tail_p-&gt;next_om();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
<span class="udiff-line-removed">-     prepend_list_to_global_free_list(free_head_p, free_tail_p, deflated_count);</span>
<span class="udiff-line-removed">-     Atomic::add(&amp;counters-&gt;n_scavenged, deflated_count);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   timer.stop();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   LogStreamHandle(Debug, monitorinflation) lsh_debug;</span>
<span class="udiff-line-removed">-   LogStreamHandle(Info, monitorinflation) lsh_info;</span>
<span class="udiff-line-removed">-   LogStream* ls = NULL;</span>
<span class="udiff-line-removed">-   if (log_is_enabled(Debug, monitorinflation)) {</span>
<span class="udiff-line-removed">-     ls = &amp;lsh_debug;</span>
<span class="udiff-line-removed">-   } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {</span>
<span class="udiff-line-removed">-     ls = &amp;lsh_info;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (ls != NULL) {</span>
<span class="udiff-line-removed">-     ls-&gt;print_cr(&quot;deflating global idle monitors, %3.7f secs, %d monitors&quot;, timer.seconds(), deflated_count);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  class HandshakeForDeflation : public HandshakeClosure {
   public:
    HandshakeForDeflation() : HandshakeClosure(&quot;HandshakeForDeflation&quot;) {}
  
    void do_thread(Thread* thread) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2563,12 +2301,10 @@</span>
                                  INTPTR_FORMAT, p2i(thread));
    }
  };
  
  void ObjectSynchronizer::deflate_idle_monitors_using_JT() {
<span class="udiff-line-removed">-   assert(AsyncDeflateIdleMonitors, &quot;sanity check&quot;);</span>
<span class="udiff-line-removed">- </span>
    // Deflate any global idle monitors.
    deflate_global_idle_monitors_using_JT();
  
    int count = 0;
    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2598,25 +2334,29 @@</span>
    if (Atomic::load(&amp;om_list_globals._wait_count) &gt; 0) {
      // There are deflated ObjectMonitors waiting for a handshake
      // (or a safepoint) for safety.
  
      ObjectMonitor* list = Atomic::load(&amp;om_list_globals._wait_list);
<span class="udiff-line-modified-removed">-     ADIM_guarantee(list != NULL, &quot;om_list_globals._wait_list must not be NULL&quot;);</span>
<span class="udiff-line-modified-added">+     assert(list != NULL, &quot;om_list_globals._wait_list must not be NULL&quot;);</span>
      int count = Atomic::load(&amp;om_list_globals._wait_count);
      Atomic::store(&amp;om_list_globals._wait_count, 0);
      Atomic::store(&amp;om_list_globals._wait_list, (ObjectMonitor*)NULL);
  
      // Find the tail for prepend_list_to_common(). No need to mark
      // ObjectMonitors for this list walk since only the deflater
      // thread manages the wait list.
<span class="udiff-line-added">+ #ifdef ASSERT</span>
      int l_count = 0;
<span class="udiff-line-added">+ #endif</span>
      ObjectMonitor* tail = NULL;
      for (ObjectMonitor* n = list; n != NULL; n = unmarked_next(n)) {
        tail = n;
<span class="udiff-line-added">+ #ifdef ASSERT</span>
        l_count++;
<span class="udiff-line-added">+ #endif</span>
      }
<span class="udiff-line-modified-removed">-     ADIM_guarantee(count == l_count, &quot;count=%d != l_count=%d&quot;, count, l_count);</span>
<span class="udiff-line-modified-added">+     assert(count == l_count, &quot;count=%d != l_count=%d&quot;, count, l_count);</span>
  
      // Will execute a safepoint if !ThreadLocalHandshakes:
      HandshakeForDeflation hfd_hc;
      Handshake::execute(&amp;hfd_hc);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2628,21 +2368,19 @@</span>
  }
  
  // Deflate global idle ObjectMonitors using a JavaThread.
  //
  void ObjectSynchronizer::deflate_global_idle_monitors_using_JT() {
<span class="udiff-line-removed">-   assert(AsyncDeflateIdleMonitors, &quot;sanity check&quot;);</span>
    assert(Thread::current()-&gt;is_Java_thread(), &quot;precondition&quot;);
    JavaThread* self = JavaThread::current();
  
    deflate_common_idle_monitors_using_JT(true /* is_global */, self);
  }
  
  // Deflate the specified JavaThread&#39;s idle ObjectMonitors using a JavaThread.
  //
  void ObjectSynchronizer::deflate_per_thread_idle_monitors_using_JT(JavaThread* target) {
<span class="udiff-line-removed">-   assert(AsyncDeflateIdleMonitors, &quot;sanity check&quot;);</span>
    assert(Thread::current()-&gt;is_Java_thread(), &quot;precondition&quot;);
  
    deflate_common_idle_monitors_using_JT(false /* !is_global */, target);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2694,11 +2432,11 @@</span>
        // but the next field in free_tail_p can flicker to marked
        // and then unmarked while prepend_to_common() is sorting it
        // all out.
  #ifdef ASSERT
        ObjectMonitor* l_next_om = unmarked_next(free_tail_p);
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+       assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
  #endif
  
        prepend_list_to_global_wait_list(free_head_p, free_tail_p, local_deflated_count);
  
        OM_PERFDATA_OP(Deflations, inc(local_deflated_count));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2741,98 +2479,10 @@</span>
        ls-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: async-deflating per-thread idle monitors, %3.7f secs, %d monitors&quot;, p2i(target), timer.seconds(), deflated_count);
      }
    }
  }
  
<span class="udiff-line-removed">- void ObjectSynchronizer::finish_deflate_idle_monitors(DeflateMonitorCounters* counters) {</span>
<span class="udiff-line-removed">-   // Report the cumulative time for deflating each thread&#39;s idle</span>
<span class="udiff-line-removed">-   // monitors. Note: if the work is split among more than one</span>
<span class="udiff-line-removed">-   // worker thread, then the reported time will likely be more</span>
<span class="udiff-line-removed">-   // than a beginning to end measurement of the phase.</span>
<span class="udiff-line-removed">-   log_info(safepoint, cleanup)(&quot;deflating per-thread idle monitors, %3.7f secs, monitors=%d&quot;, counters-&gt;per_thread_times, counters-&gt;per_thread_scavenged);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (AsyncDeflateIdleMonitors) {</span>
<span class="udiff-line-removed">-     // Nothing to do when idle ObjectMonitors are deflated using</span>
<span class="udiff-line-removed">-     // a JavaThread.</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (log_is_enabled(Debug, monitorinflation)) {</span>
<span class="udiff-line-removed">-     // exit_globals()&#39;s call to audit_and_print_stats() is done</span>
<span class="udiff-line-removed">-     // at the Info level and not at a safepoint.</span>
<span class="udiff-line-removed">-     // For async deflation, audit_and_print_stats() is called in</span>
<span class="udiff-line-removed">-     // ObjectSynchronizer::do_safepoint_work() at the Debug level</span>
<span class="udiff-line-removed">-     // at a safepoint.</span>
<span class="udiff-line-removed">-     ObjectSynchronizer::audit_and_print_stats(false /* on_exit */);</span>
<span class="udiff-line-removed">-   } else if (log_is_enabled(Info, monitorinflation)) {</span>
<span class="udiff-line-removed">-     log_info(monitorinflation)(&quot;global_population=%d, global_in_use_count=%d, &quot;</span>
<span class="udiff-line-removed">-                                &quot;global_free_count=%d, global_wait_count=%d&quot;,</span>
<span class="udiff-line-removed">-                                Atomic::load(&amp;om_list_globals._population),</span>
<span class="udiff-line-removed">-                                Atomic::load(&amp;om_list_globals._in_use_count),</span>
<span class="udiff-line-removed">-                                Atomic::load(&amp;om_list_globals._free_count),</span>
<span class="udiff-line-removed">-                                Atomic::load(&amp;om_list_globals._wait_count));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   OM_PERFDATA_OP(Deflations, inc(counters-&gt;n_scavenged));</span>
<span class="udiff-line-removed">-   OM_PERFDATA_OP(MonExtant, set_value(counters-&gt;n_in_circulation));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   GVars.stw_random = os::random();</span>
<span class="udiff-line-removed">-   GVars.stw_cycle++;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ObjectSynchronizer::deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters) {</span>
<span class="udiff-line-removed">-   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (AsyncDeflateIdleMonitors) {</span>
<span class="udiff-line-removed">-     // Nothing to do when per-thread idle ObjectMonitors are deflated</span>
<span class="udiff-line-removed">-     // using a JavaThread.</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ObjectMonitor* free_head_p = NULL;  // Local SLL of scavenged monitors</span>
<span class="udiff-line-removed">-   ObjectMonitor* free_tail_p = NULL;</span>
<span class="udiff-line-removed">-   elapsedTimer timer;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (log_is_enabled(Info, safepoint, cleanup) ||</span>
<span class="udiff-line-removed">-       log_is_enabled(Info, monitorinflation)) {</span>
<span class="udiff-line-removed">-     timer.start();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Update n_in_circulation before om_in_use_count is updated by deflation.</span>
<span class="udiff-line-removed">-   Atomic::add(&amp;counters-&gt;n_in_circulation, Atomic::load(&amp;thread-&gt;om_in_use_count));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int deflated_count = deflate_monitor_list(&amp;thread-&gt;om_in_use_list, &amp;thread-&gt;om_in_use_count, &amp;free_head_p, &amp;free_tail_p);</span>
<span class="udiff-line-removed">-   Atomic::add(&amp;counters-&gt;n_in_use, Atomic::load(&amp;thread-&gt;om_in_use_count));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (free_head_p != NULL) {</span>
<span class="udiff-line-removed">-     // Move the deflated ObjectMonitors back to the global free list.</span>
<span class="udiff-line-removed">-     guarantee(free_tail_p != NULL &amp;&amp; deflated_count &gt; 0, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-     ObjectMonitor* l_next_om = free_tail_p-&gt;next_om();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
<span class="udiff-line-removed">-     prepend_list_to_global_free_list(free_head_p, free_tail_p, deflated_count);</span>
<span class="udiff-line-removed">-     Atomic::add(&amp;counters-&gt;n_scavenged, deflated_count);</span>
<span class="udiff-line-removed">-     Atomic::add(&amp;counters-&gt;per_thread_scavenged, deflated_count);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   timer.stop();</span>
<span class="udiff-line-removed">-   counters-&gt;per_thread_times += timer.seconds();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   LogStreamHandle(Debug, monitorinflation) lsh_debug;</span>
<span class="udiff-line-removed">-   LogStreamHandle(Info, monitorinflation) lsh_info;</span>
<span class="udiff-line-removed">-   LogStream* ls = NULL;</span>
<span class="udiff-line-removed">-   if (log_is_enabled(Debug, monitorinflation)) {</span>
<span class="udiff-line-removed">-     ls = &amp;lsh_debug;</span>
<span class="udiff-line-removed">-   } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {</span>
<span class="udiff-line-removed">-     ls = &amp;lsh_info;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (ls != NULL) {</span>
<span class="udiff-line-removed">-     ls-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: deflating per-thread idle monitors, %3.7f secs, %d monitors&quot;, p2i(thread), timer.seconds(), deflated_count);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  // Monitor cleanup on JavaThread::exit
  
  // Iterate through monitor cache and attempt to release thread&#39;s monitors
  // Gives up on a particular monitor if an exception occurs, but continues
  // the overall iteration, swallowing the exception.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2854,11 +2504,11 @@</span>
  // all remaining monitors are heavyweight.  All exceptions are swallowed.
  // Scanning the extant monitor list can be time consuming.
  // A simple optimization is to add a per-thread flag that indicates a thread
  // called jni_monitorenter() during its lifetime.
  //
<span class="udiff-line-modified-removed">- // Instead of No_Savepoint_Verifier it might be cheaper to</span>
<span class="udiff-line-modified-added">+ // Instead of NoSafepointVerifier it might be cheaper to</span>
  // use an idiom of the form:
  //   auto int tmp = SafepointSynchronize::_safepoint_counter ;
  //   &lt;code that must not run at safepoint&gt;
  //   guarantee (((tmp ^ _safepoint_counter) | (tmp &amp; 1)) == 0) ;
  // Since the tests are extremely cheap we could leave them enabled
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2913,12 +2563,10 @@</span>
  //
  // Calls to this function can be added in various places as a debugging
  // aid; pass &#39;true&#39; for the &#39;on_exit&#39; parameter to have in-use monitor
  // details logged at the Info level and &#39;false&#39; for the &#39;on_exit&#39;
  // parameter to have in-use monitor details logged at the Trace level.
<span class="udiff-line-removed">- // deflate_monitor_list() no longer uses spin-locking so be careful</span>
<span class="udiff-line-removed">- // when adding audit_and_print_stats() calls at a safepoint.</span>
  //
  void ObjectSynchronizer::audit_and_print_stats(bool on_exit) {
    assert(on_exit || SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
  
    LogStreamHandle(Debug, monitorinflation) lsh_debug;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3012,15 +2660,10 @@</span>
      if (jt != NULL) {
        out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
                      &quot;: free per-thread monitor must have NULL _header &quot;
                      &quot;field: _header=&quot; INTPTR_FORMAT, p2i(jt), p2i(n),
                      n-&gt;header().value());
<span class="udiff-line-removed">-       *error_cnt_p = *error_cnt_p + 1;</span>
<span class="udiff-line-removed">-     } else if (!AsyncDeflateIdleMonitors) {</span>
<span class="udiff-line-removed">-       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;</span>
<span class="udiff-line-removed">-                     &quot;must have NULL _header field: _header=&quot; INTPTR_FORMAT,</span>
<span class="udiff-line-removed">-                     p2i(n), n-&gt;header().value());</span>
        *error_cnt_p = *error_cnt_p + 1;
      }
    }
    if (n-&gt;object() != NULL) {
      if (jt != NULL) {
</pre>
<center><a href="safepoint.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>