<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;
  30 import jdk.internal.misc.Unsafe;
  31 import jdk.internal.misc.VM;
  32 import jdk.internal.module.IllegalAccessLogger;
  33 import jdk.internal.org.objectweb.asm.ClassReader;
  34 import jdk.internal.org.objectweb.asm.Opcodes;
  35 import jdk.internal.org.objectweb.asm.Type;
  36 import jdk.internal.reflect.CallerSensitive;
  37 import jdk.internal.reflect.Reflection;
  38 import jdk.internal.vm.annotation.ForceInline;
  39 import sun.invoke.util.ValueConversions;
  40 import sun.invoke.util.VerifyAccess;
  41 import sun.invoke.util.Wrapper;
  42 import sun.reflect.misc.ReflectUtil;
  43 import sun.security.util.SecurityConstants;
  44 
  45 import java.lang.invoke.LambdaForm.BasicType;
  46 import java.lang.reflect.Constructor;
  47 import java.lang.reflect.Field;
  48 import java.lang.reflect.Member;
  49 import java.lang.reflect.Method;
  50 import java.lang.reflect.Modifier;
  51 import java.lang.reflect.ReflectPermission;
  52 import java.nio.ByteOrder;
  53 import java.security.ProtectionDomain;
  54 import java.util.ArrayList;
  55 import java.util.Arrays;
  56 import java.util.BitSet;
  57 import java.util.Iterator;
  58 import java.util.List;
  59 import java.util.Objects;
  60 import java.util.Set;
  61 import java.util.concurrent.ConcurrentHashMap;
  62 import java.util.stream.Collectors;
  63 import java.util.stream.Stream;
  64 
  65 import static java.lang.invoke.MethodHandleImpl.Intrinsic;
  66 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  67 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;
  68 import static java.lang.invoke.MethodType.methodType;
  69 
  70 /**
  71  * This class consists exclusively of static methods that operate on or return
  72  * method handles. They fall into several categories:
  73  * &lt;ul&gt;
  74  * &lt;li&gt;Lookup methods which help create method handles for methods and fields.
  75  * &lt;li&gt;Combinator methods, which combine or transform pre-existing method handles into new ones.
  76  * &lt;li&gt;Other factory methods to create method handles that emulate other common JVM operations or control flow patterns.
  77  * &lt;/ul&gt;
  78  * A lookup, combinator, or factory method will fail and throw an
  79  * {@code IllegalArgumentException} if the created method handle&#39;s type
  80  * would have &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;.
  81  *
  82  * @author John Rose, JSR 292 EG
  83  * @since 1.7
  84  */
  85 public class MethodHandles {
  86 
  87     private MethodHandles() { }  // do not instantiate
  88 
  89     static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
  90 
  91     // See IMPL_LOOKUP below.
  92 
  93     //// Method handle creation from ordinary methods.
  94 
  95     /**
  96      * Returns a {@link Lookup lookup object} with
  97      * full capabilities to emulate all supported bytecode behaviors of the caller.
  98      * These capabilities include {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access} to the caller.
  99      * Factory methods on the lookup object can create
 100      * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handles&lt;/a&gt;
 101      * for any member that the caller has access to via bytecodes,
 102      * including protected and private fields and methods.
 103      * This lookup object is a &lt;em&gt;capability&lt;/em&gt; which may be delegated to trusted agents.
 104      * Do not store it in place where untrusted code can access it.
 105      * &lt;p&gt;
 106      * This method is caller sensitive, which means that it may return different
 107      * values to different callers.
 108      * @return a lookup object for the caller of this method, with
 109      * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access}
 110      */
 111     @CallerSensitive
 112     @ForceInline // to ensure Reflection.getCallerClass optimization
 113     public static Lookup lookup() {
 114         return new Lookup(Reflection.getCallerClass());
 115     }
 116 
 117     /**
 118      * This reflected$lookup method is the alternate implementation of
 119      * the lookup method when being invoked by reflection.
 120      */
 121     @CallerSensitive
 122     private static Lookup reflected$lookup() {
 123         Class&lt;?&gt; caller = Reflection.getCallerClass();
 124         if (caller.getClassLoader() == null) {
 125             throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+caller);
 126         }
 127         return new Lookup(caller);
 128     }
 129 
 130     /**
 131      * Returns a {@link Lookup lookup object} which is trusted minimally.
 132      * The lookup has the {@code UNCONDITIONAL} mode.
 133      * It can only be used to create method handles to public members of
 134      * public classes in packages that are exported unconditionally.
 135      * &lt;p&gt;
 136      * As a matter of pure convention, the {@linkplain Lookup#lookupClass() lookup class}
 137      * of this lookup object will be {@link java.lang.Object}.
 138      *
 139      * @apiNote The use of Object is conventional, and because the lookup modes are
 140      * limited, there is no special access provided to the internals of Object, its package
 141      * or its module.  This public lookup object or other lookup object with
 142      * {@code UNCONDITIONAL} mode assumes readability. Consequently, the lookup class
 143      * is not used to determine the lookup context.
 144      *
 145      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 146      * &lt;em&gt;Discussion:&lt;/em&gt;
 147      * The lookup class can be changed to any other class {@code C} using an expression of the form
 148      * {@link Lookup#in publicLookup().in(C.class)}.
 149      * A public lookup object is always subject to
 150      * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;security manager checks&lt;/a&gt;.
 151      * Also, it cannot access
 152      * &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive methods&lt;/a&gt;.
 153      * @return a lookup object which is trusted minimally
 154      *
 155      * @revised 9
 156      * @spec JPMS
 157      */
 158     public static Lookup publicLookup() {
 159         return Lookup.PUBLIC_LOOKUP;
 160     }
 161 
 162     /**
 163      * Returns a {@link Lookup lookup} object on a target class to emulate all supported
 164      * bytecode behaviors, including &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;.
 165      * The returned lookup object can provide access to classes in modules and packages,
 166      * and members of those classes, outside the normal rules of Java access control,
 167      * instead conforming to the more permissive rules for modular &lt;em&gt;deep reflection&lt;/em&gt;.
 168      * &lt;p&gt;
 169      * A caller, specified as a {@code Lookup} object, in module {@code M1} is
 170      * allowed to do deep reflection on module {@code M2} and package of the target class
 171      * if and only if all of the following conditions are {@code true}:
 172      * &lt;ul&gt;
 173      * &lt;li&gt;If there is a security manager, its {@code checkPermission} method is
 174      * called to check {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} and
 175      * that must return normally.
 176      * &lt;li&gt;The caller lookup object must have {@linkplain Lookup#hasFullPrivilegeAccess()
 177      * full privilege access}.  Specifically:
 178      *   &lt;ul&gt;
 179      *     &lt;li&gt;The caller lookup object must have the {@link Lookup#MODULE MODULE} lookup mode.
 180      *         (This is because otherwise there would be no way to ensure the original lookup
 181      *         creator was a member of any particular module, and so any subsequent checks
 182      *         for readability and qualified exports would become ineffective.)
 183      *     &lt;li&gt;The caller lookup object must have {@link Lookup#PRIVATE PRIVATE} access.
 184      *         (This is because an application intending to share intra-module access
 185      *         using {@link Lookup#MODULE MODULE} alone will inadvertently also share
 186      *         deep reflection to its own module.)
 187      *   &lt;/ul&gt;
 188      * &lt;li&gt;The target class must be a proper class, not a primitive or array class.
 189      * (Thus, {@code M2} is well-defined.)
 190      * &lt;li&gt;If the caller module {@code M1} differs from
 191      * the target module {@code M2} then both of the following must be true:
 192      *   &lt;ul&gt;
 193      *     &lt;li&gt;{@code M1} {@link Module#canRead reads} {@code M2}.&lt;/li&gt;
 194      *     &lt;li&gt;{@code M2} {@link Module#isOpen(String,Module) opens} the package
 195      *         containing the target class to at least {@code M1}.&lt;/li&gt;
 196      *   &lt;/ul&gt;
 197      * &lt;/ul&gt;
 198      * &lt;p&gt;
 199      * If any of the above checks is violated, this method fails with an
 200      * exception.
 201      * &lt;p&gt;
 202      * Otherwise, if {@code M1} and {@code M2} are the same module, this method
 203      * returns a {@code Lookup} on {@code targetClass} with
 204      * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access} and
 205      * {@code null} previous lookup class.
 206      * &lt;p&gt;
 207      * Otherwise, {@code M1} and {@code M2} are two different modules.  This method
 208      * returns a {@code Lookup} on {@code targetClass} that records
 209      * the lookup class of the caller as the new previous lookup class and
 210      * drops {@code MODULE} access from the full privilege access.
 211      *
 212      * @param targetClass the target class
 213      * @param caller the caller lookup object
 214      * @return a lookup object for the target class, with private access
 215      * @throws IllegalArgumentException if {@code targetClass} is a primitive type or void or array class
 216      * @throws NullPointerException if {@code targetClass} or {@code caller} is {@code null}
 217      * @throws SecurityException if denied by the security manager
 218      * @throws IllegalAccessException if any of the other access checks specified above fails
 219      * @since 9
 220      * @spec JPMS
 221      * @see Lookup#dropLookupMode
 222      * @see &lt;a href=&quot;MethodHandles.Lookup.html#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
 223      */
 224     public static Lookup privateLookupIn(Class&lt;?&gt; targetClass, Lookup caller) throws IllegalAccessException {
 225         if (caller.allowedModes == Lookup.TRUSTED) {
 226             return new Lookup(targetClass);
 227         }
 228 
 229         SecurityManager sm = System.getSecurityManager();
 230         if (sm != null) sm.checkPermission(ACCESS_PERMISSION);
 231         if (targetClass.isPrimitive())
 232             throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);
 233         if (targetClass.isArray())
 234             throw new IllegalArgumentException(targetClass + &quot; is an array class&quot;);
 235         // Ensure that we can reason accurately about private and module access.
 236         if (!caller.hasFullPrivilegeAccess())
 237             throw new IllegalAccessException(&quot;caller does not have PRIVATE and MODULE lookup mode&quot;);
 238 
 239         // previous lookup class is never set if it has MODULE access
 240         assert caller.previousLookupClass() == null;
 241 
 242         Class&lt;?&gt; callerClass = caller.lookupClass();
 243         Module callerModule = callerClass.getModule();  // M1
 244         Module targetModule = targetClass.getModule();  // M2
 245         Class&lt;?&gt; newPreviousClass = null;
 246         int newModes = Lookup.FULL_POWER_MODES;
 247 
 248         if (targetModule != callerModule) {
 249             if (!callerModule.canRead(targetModule))
 250                 throw new IllegalAccessException(callerModule + &quot; does not read &quot; + targetModule);
 251             if (targetModule.isNamed()) {
 252                 String pn = targetClass.getPackageName();
 253                 assert !pn.isEmpty() : &quot;unnamed package cannot be in named module&quot;;
 254                 if (!targetModule.isOpen(pn, callerModule))
 255                     throw new IllegalAccessException(targetModule + &quot; does not open &quot; + pn + &quot; to &quot; + callerModule);
 256             }
 257 
 258             // M2 != M1, set previous lookup class to M1 and drop MODULE access
 259             newPreviousClass = callerClass;
 260             newModes &amp;= ~Lookup.MODULE;
 261 
 262             if (!callerModule.isNamed() &amp;&amp; targetModule.isNamed()) {
 263                 IllegalAccessLogger logger = IllegalAccessLogger.illegalAccessLogger();
 264                 if (logger != null) {
 265                     logger.logIfOpenedForIllegalAccess(caller, targetClass);
 266                 }
 267             }
 268         }
 269         return Lookup.newLookup(targetClass, newPreviousClass, newModes);
 270     }
 271 
 272     /**
 273      * Returns the &lt;em&gt;class data&lt;/em&gt; associated with the lookup class
 274      * of the specified {@code Lookup} object, or {@code null}.
 275      *
 276      * &lt;p&gt; Classes can be created with class data by calling
 277      * {@link Lookup#defineHiddenClassWithClassData(byte[], Object, Lookup.ClassOption...)
 278      * Lookup::defineHiddenClassWithClassData}.
 279      * A hidden class with a class data behaves as if the hidden class
 280      * has a private static final unnamed field pre-initialized with
 281      * the class data and this method is equivalent as if calling
 282      * {@link ConstantBootstraps#getStaticFinal(Lookup, String, Class)} to
 283      * obtain the value of such field corresponding to the class data.
 284      *
 285      * &lt;p&gt; The {@linkplain Lookup#lookupModes() lookup modes} for this lookup
 286      * must have {@link Lookup#ORIGINAL ORIGINAL} access in order to retrieve
 287      * the class data.
 288      *
 289      * @apiNote
 290      * This method can be called as a bootstrap method for a dynamically computed
 291      * constant.  A framework can create a hidden class with class data, for
 292      * example that can be {@code List.of(o1, o2, o3....)} containing more than
 293      * one live object.  The class data is accessible only to the lookup object
 294      * created by the original caller but inaccessible to other members
 295      * in the same nest.  If a framework passes security sensitive live objects
 296      * to a hidden class via class data, it is recommended to load the value
 297      * of class data as a dynamically computed constant instead of storing
 298      * the live objects in private fields which are accessible to other
 299      * nestmates.
 300      *
 301      * @param &lt;T&gt; the type to cast the class data object to
 302      * @param caller the lookup context describing the class performing the
 303      * operation (normally stacked by the JVM)
 304      * @param name ignored
 305      * @param type the type of the class data
 306      * @return the value of the class data if present in the lookup class;
 307      * otherwise {@code null}
 308      * @throws IllegalAccessException if the lookup context does not have
 309      * original caller access
 310      * @throws ClassCastException if the class data cannot be converted to
 311      * the specified {@code type}
 312      * @see Lookup#defineHiddenClassWithClassData(byte[], Object, Lookup.ClassOption...)
 313      * @since 15
 314      */
 315     static &lt;T&gt; T classData(Lookup caller, String name, Class&lt;T&gt; type) throws IllegalAccessException {
 316         if (!caller.hasFullPrivilegeAccess()) {
 317             throw new IllegalAccessException(caller + &quot; does not have full privilege access&quot;);
 318         }
 319         Object classData = MethodHandleNatives.classData(caller.lookupClass);
 320         return type.cast(classData);
 321     }
 322 
 323     /**
 324      * Performs an unchecked &quot;crack&quot; of a
 325      * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;.
 326      * The result is as if the user had obtained a lookup object capable enough
 327      * to crack the target method handle, called
 328      * {@link java.lang.invoke.MethodHandles.Lookup#revealDirect Lookup.revealDirect}
 329      * on the target to obtain its symbolic reference, and then called
 330      * {@link java.lang.invoke.MethodHandleInfo#reflectAs MethodHandleInfo.reflectAs}
 331      * to resolve the symbolic reference to a member.
 332      * &lt;p&gt;
 333      * If there is a security manager, its {@code checkPermission} method
 334      * is called with a {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} permission.
 335      * @param &lt;T&gt; the desired type of the result, either {@link Member} or a subtype
 336      * @param target a direct method handle to crack into symbolic reference components
 337      * @param expected a class object representing the desired result type {@code T}
 338      * @return a reference to the method, constructor, or field object
 339      * @throws    SecurityException if the caller is not privileged to call {@code setAccessible}
 340      * @throws    NullPointerException if either argument is {@code null}
 341      * @throws    IllegalArgumentException if the target is not a direct method handle
 342      * @throws    ClassCastException if the member is not of the expected type
 343      * @since 1.8
 344      */
 345     public static &lt;T extends Member&gt; T reflectAs(Class&lt;T&gt; expected, MethodHandle target) {
 346         SecurityManager smgr = System.getSecurityManager();
 347         if (smgr != null)  smgr.checkPermission(ACCESS_PERMISSION);
 348         Lookup lookup = Lookup.IMPL_LOOKUP;  // use maximally privileged lookup
 349         return lookup.revealDirect(target).reflectAs(expected, lookup);
 350     }
 351     // Copied from AccessibleObject, as used by Method.setAccessible, etc.:
 352     private static final java.security.Permission ACCESS_PERMISSION =
 353         new ReflectPermission(&quot;suppressAccessChecks&quot;);
 354 
 355     /**
 356      * A &lt;em&gt;lookup object&lt;/em&gt; is a factory for creating method handles,
 357      * when the creation requires access checking.
 358      * Method handles do not perform
 359      * access checks when they are called, but rather when they are created.
 360      * Therefore, method handle access
 361      * restrictions must be enforced when a method handle is created.
 362      * The caller class against which those restrictions are enforced
 363      * is known as the {@linkplain #lookupClass() lookup class}.
 364      * &lt;p&gt;
 365      * A lookup class which needs to create method handles will call
 366      * {@link MethodHandles#lookup() MethodHandles.lookup} to create a factory for itself.
 367      * When the {@code Lookup} factory object is created, the identity of the lookup class is
 368      * determined, and securely stored in the {@code Lookup} object.
 369      * The lookup class (or its delegates) may then use factory methods
 370      * on the {@code Lookup} object to create method handles for access-checked members.
 371      * This includes all methods, constructors, and fields which are allowed to the lookup class,
 372      * even private ones.
 373      *
 374      * &lt;h2&gt;&lt;a id=&quot;lookups&quot;&gt;&lt;/a&gt;Lookup Factory Methods&lt;/h2&gt;
 375      * The factory methods on a {@code Lookup} object correspond to all major
 376      * use cases for methods, constructors, and fields.
 377      * Each method handle created by a factory method is the functional
 378      * equivalent of a particular &lt;em&gt;bytecode behavior&lt;/em&gt;.
 379      * (Bytecode behaviors are described in section {@jvms 5.4.3.5} of
 380      * the Java Virtual Machine Specification.)
 381      * Here is a summary of the correspondence between these factory methods and
 382      * the behavior of the resulting method handles:
 383      * &lt;table class=&quot;striped&quot;&gt;
 384      * &lt;caption style=&quot;display:none&quot;&gt;lookup method behaviors&lt;/caption&gt;
 385      * &lt;thead&gt;
 386      * &lt;tr&gt;
 387      *     &lt;th scope=&quot;col&quot;&gt;&lt;a id=&quot;equiv&quot;&gt;&lt;/a&gt;lookup expression&lt;/th&gt;
 388      *     &lt;th scope=&quot;col&quot;&gt;member&lt;/th&gt;
 389      *     &lt;th scope=&quot;col&quot;&gt;bytecode behavior&lt;/th&gt;
 390      * &lt;/tr&gt;
 391      * &lt;/thead&gt;
 392      * &lt;tbody&gt;
 393      * &lt;tr&gt;
 394      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findGetter lookup.findGetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 395      *     &lt;td&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (T) this.f;}&lt;/td&gt;
 396      * &lt;/tr&gt;
 397      * &lt;tr&gt;
 398      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStaticGetter lookup.findStaticGetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 399      *     &lt;td&gt;{@code static}&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (FT) C.f;}&lt;/td&gt;
 400      * &lt;/tr&gt;
 401      * &lt;tr&gt;
 402      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findSetter lookup.findSetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 403      *     &lt;td&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code this.f = x;}&lt;/td&gt;
 404      * &lt;/tr&gt;
 405      * &lt;tr&gt;
 406      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStaticSetter lookup.findStaticSetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 407      *     &lt;td&gt;{@code static}&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code C.f = arg;}&lt;/td&gt;
 408      * &lt;/tr&gt;
 409      * &lt;tr&gt;
 410      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findVirtual lookup.findVirtual(C.class,&quot;m&quot;,MT)}&lt;/th&gt;
 411      *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) this.m(arg*);}&lt;/td&gt;
 412      * &lt;/tr&gt;
 413      * &lt;tr&gt;
 414      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStatic lookup.findStatic(C.class,&quot;m&quot;,MT)}&lt;/th&gt;
 415      *     &lt;td&gt;{@code static}&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) C.m(arg*);}&lt;/td&gt;
 416      * &lt;/tr&gt;
 417      * &lt;tr&gt;
 418      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findSpecial lookup.findSpecial(C.class,&quot;m&quot;,MT,this.class)}&lt;/th&gt;
 419      *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) super.m(arg*);}&lt;/td&gt;
 420      * &lt;/tr&gt;
 421      * &lt;tr&gt;
 422      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findConstructor lookup.findConstructor(C.class,MT)}&lt;/th&gt;
 423      *     &lt;td&gt;{@code C(A*);}&lt;/td&gt;&lt;td&gt;{@code new C(arg*);}&lt;/td&gt;
 424      * &lt;/tr&gt;
 425      * &lt;tr&gt;
 426      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectGetter lookup.unreflectGetter(aField)}&lt;/th&gt;
 427      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (FT) aField.get(thisOrNull);}&lt;/td&gt;
 428      * &lt;/tr&gt;
 429      * &lt;tr&gt;
 430      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectSetter lookup.unreflectSetter(aField)}&lt;/th&gt;
 431      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code aField.set(thisOrNull, arg);}&lt;/td&gt;
 432      * &lt;/tr&gt;
 433      * &lt;tr&gt;
 434      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)}&lt;/th&gt;
 435      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) aMethod.invoke(thisOrNull, arg*);}&lt;/td&gt;
 436      * &lt;/tr&gt;
 437      * &lt;tr&gt;
 438      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectConstructor lookup.unreflectConstructor(aConstructor)}&lt;/th&gt;
 439      *     &lt;td&gt;{@code C(A*);}&lt;/td&gt;&lt;td&gt;{@code (C) aConstructor.newInstance(arg*);}&lt;/td&gt;
 440      * &lt;/tr&gt;
 441      * &lt;tr&gt;
 442      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectSpecial lookup.unreflectSpecial(aMethod,this.class)}&lt;/th&gt;
 443      *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) super.m(arg*);}&lt;/td&gt;
 444      * &lt;/tr&gt;
 445      * &lt;tr&gt;
 446      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findClass lookup.findClass(&quot;C&quot;)}&lt;/th&gt;
 447      *     &lt;td&gt;{@code class C { ... }}&lt;/td&gt;&lt;td&gt;{@code C.class;}&lt;/td&gt;
 448      * &lt;/tr&gt;
 449      * &lt;/tbody&gt;
 450      * &lt;/table&gt;
 451      *
 452      * Here, the type {@code C} is the class or interface being searched for a member,
 453      * documented as a parameter named {@code refc} in the lookup methods.
 454      * The method type {@code MT} is composed from the return type {@code T}
 455      * and the sequence of argument types {@code A*}.
 456      * The constructor also has a sequence of argument types {@code A*} and
 457      * is deemed to return the newly-created object of type {@code C}.
 458      * Both {@code MT} and the field type {@code FT} are documented as a parameter named {@code type}.
 459      * The formal parameter {@code this} stands for the self-reference of type {@code C};
 460      * if it is present, it is always the leading argument to the method handle invocation.
 461      * (In the case of some {@code protected} members, {@code this} may be
 462      * restricted in type to the lookup class; see below.)
 463      * The name {@code arg} stands for all the other method handle arguments.
 464      * In the code examples for the Core Reflection API, the name {@code thisOrNull}
 465      * stands for a null reference if the accessed method or field is static,
 466      * and {@code this} otherwise.
 467      * The names {@code aMethod}, {@code aField}, and {@code aConstructor} stand
 468      * for reflective objects corresponding to the given members declared in type {@code C}.
 469      * &lt;p&gt;
 470      * The bytecode behavior for a {@code findClass} operation is a load of a constant class,
 471      * as if by {@code ldc CONSTANT_Class}.
 472      * The behavior is represented, not as a method handle, but directly as a {@code Class} constant.
 473      * &lt;p&gt;
 474      * In cases where the given member is of variable arity (i.e., a method or constructor)
 475      * the returned method handle will also be of {@linkplain MethodHandle#asVarargsCollector variable arity}.
 476      * In all other cases, the returned method handle will be of fixed arity.
 477      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 478      * &lt;em&gt;Discussion:&lt;/em&gt;
 479      * The equivalence between looked-up method handles and underlying
 480      * class members and bytecode behaviors
 481      * can break down in a few ways:
 482      * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
 483      * &lt;li&gt;If {@code C} is not symbolically accessible from the lookup class&#39;s loader,
 484      * the lookup can still succeed, even when there is no equivalent
 485      * Java expression or bytecoded constant.
 486      * &lt;li&gt;Likewise, if {@code T} or {@code MT}
 487      * is not symbolically accessible from the lookup class&#39;s loader,
 488      * the lookup can still succeed.
 489      * For example, lookups for {@code MethodHandle.invokeExact} and
 490      * {@code MethodHandle.invoke} will always succeed, regardless of requested type.
 491      * &lt;li&gt;If there is a security manager installed, it can forbid the lookup
 492      * on various grounds (&lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;see below&lt;/a&gt;).
 493      * By contrast, the {@code ldc} instruction on a {@code CONSTANT_MethodHandle}
 494      * constant is not subject to security manager checks.
 495      * &lt;li&gt;If the looked-up method has a
 496      * &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;very large arity&lt;/a&gt;,
 497      * the method handle creation may fail with an
 498      * {@code IllegalArgumentException}, due to the method handle type having
 499      * &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters.&lt;/a&gt;
 500      * &lt;/ul&gt;
 501      *
 502      * &lt;h2&gt;&lt;a id=&quot;access&quot;&gt;&lt;/a&gt;Access checking&lt;/h2&gt;
 503      * Access checks are applied in the factory methods of {@code Lookup},
 504      * when a method handle is created.
 505      * This is a key difference from the Core Reflection API, since
 506      * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
 507      * performs access checking against every caller, on every call.
 508      * &lt;p&gt;
 509      * All access checks start from a {@code Lookup} object, which
 510      * compares its recorded lookup class against all requests to
 511      * create method handles.
 512      * A single {@code Lookup} object can be used to create any number
 513      * of access-checked method handles, all checked against a single
 514      * lookup class.
 515      * &lt;p&gt;
 516      * A {@code Lookup} object can be shared with other trusted code,
 517      * such as a metaobject protocol.
 518      * A shared {@code Lookup} object delegates the capability
 519      * to create method handles on private members of the lookup class.
 520      * Even if privileged code uses the {@code Lookup} object,
 521      * the access checking is confined to the privileges of the
 522      * original lookup class.
 523      * &lt;p&gt;
 524      * A lookup can fail, because
 525      * the containing class is not accessible to the lookup class, or
 526      * because the desired class member is missing, or because the
 527      * desired class member is not accessible to the lookup class, or
 528      * because the lookup object is not trusted enough to access the member.
 529      * In the case of a field setter function on a {@code final} field,
 530      * finality enforcement is treated as a kind of access control,
 531      * and the lookup will fail, except in special cases of
 532      * {@link Lookup#unreflectSetter Lookup.unreflectSetter}.
 533      * In any of these cases, a {@code ReflectiveOperationException} will be
 534      * thrown from the attempted lookup.  The exact class will be one of
 535      * the following:
 536      * &lt;ul&gt;
 537      * &lt;li&gt;NoSuchMethodException &amp;mdash; if a method is requested but does not exist
 538      * &lt;li&gt;NoSuchFieldException &amp;mdash; if a field is requested but does not exist
 539      * &lt;li&gt;IllegalAccessException &amp;mdash; if the member exists but an access check fails
 540      * &lt;/ul&gt;
 541      * &lt;p&gt;
 542      * In general, the conditions under which a method handle may be
 543      * looked up for a method {@code M} are no more restrictive than the conditions
 544      * under which the lookup class could have compiled, verified, and resolved a call to {@code M}.
 545      * Where the JVM would raise exceptions like {@code NoSuchMethodError},
 546      * a method handle lookup will generally raise a corresponding
 547      * checked exception, such as {@code NoSuchMethodException}.
 548      * And the effect of invoking the method handle resulting from the lookup
 549      * is &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;exactly equivalent&lt;/a&gt;
 550      * to executing the compiled, verified, and resolved call to {@code M}.
 551      * The same point is true of fields and constructors.
 552      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 553      * &lt;em&gt;Discussion:&lt;/em&gt;
 554      * Access checks only apply to named and reflected methods,
 555      * constructors, and fields.
 556      * Other method handle creation methods, such as
 557      * {@link MethodHandle#asType MethodHandle.asType},
 558      * do not require any access checks, and are used
 559      * independently of any {@code Lookup} object.
 560      * &lt;p&gt;
 561      * If the desired member is {@code protected}, the usual JVM rules apply,
 562      * including the requirement that the lookup class must either be in the
 563      * same package as the desired member, or must inherit that member.
 564      * (See the Java Virtual Machine Specification, sections {@jvms
 565      * 4.9.2}, {@jvms 5.4.3.5}, and {@jvms 6.4}.)
 566      * In addition, if the desired member is a non-static field or method
 567      * in a different package, the resulting method handle may only be applied
 568      * to objects of the lookup class or one of its subclasses.
 569      * This requirement is enforced by narrowing the type of the leading
 570      * {@code this} parameter from {@code C}
 571      * (which will necessarily be a superclass of the lookup class)
 572      * to the lookup class itself.
 573      * &lt;p&gt;
 574      * The JVM imposes a similar requirement on {@code invokespecial} instruction,
 575      * that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt;
 576      * the current class.  Again, this requirement is enforced by narrowing the
 577      * type of the leading parameter to the resulting method handle.
 578      * (See the Java Virtual Machine Specification, section {@jvms 4.10.1.9}.)
 579      * &lt;p&gt;
 580      * The JVM represents constructors and static initializer blocks as internal methods
 581      * with special names ({@code &quot;&lt;init&gt;&quot;} and {@code &quot;&lt;clinit&gt;&quot;}).
 582      * The internal syntax of invocation instructions allows them to refer to such internal
 583      * methods as if they were normal methods, but the JVM bytecode verifier rejects them.
 584      * A lookup of such an internal method will produce a {@code NoSuchMethodException}.
 585      * &lt;p&gt;
 586      * If the relationship between nested types is expressed directly through the
 587      * {@code NestHost} and {@code NestMembers} attributes
 588      * (see the Java Virtual Machine Specification, sections {@jvms
 589      * 4.7.28} and {@jvms 4.7.29}),
 590      * then the associated {@code Lookup} object provides direct access to
 591      * the lookup class and all of its nestmates
 592      * (see {@link java.lang.Class#getNestHost Class.getNestHost}).
 593      * Otherwise, access between nested classes is obtained by the Java compiler creating
 594      * a wrapper method to access a private method of another class in the same nest.
 595      * For example, a nested class {@code C.D}
 596      * can access private members within other related classes such as
 597      * {@code C}, {@code C.D.E}, or {@code C.B},
 598      * but the Java compiler may need to generate wrapper methods in
 599      * those related classes.  In such cases, a {@code Lookup} object on
 600      * {@code C.E} would be unable to access those private members.
 601      * A workaround for this limitation is the {@link Lookup#in Lookup.in} method,
 602      * which can transform a lookup on {@code C.E} into one on any of those other
 603      * classes, without special elevation of privilege.
 604      * &lt;p&gt;
 605      * The accesses permitted to a given lookup object may be limited,
 606      * according to its set of {@link #lookupModes lookupModes},
 607      * to a subset of members normally accessible to the lookup class.
 608      * For example, the {@link MethodHandles#publicLookup publicLookup}
 609      * method produces a lookup object which is only allowed to access
 610      * public members in public classes of exported packages.
 611      * The caller sensitive method {@link MethodHandles#lookup lookup}
 612      * produces a lookup object with full capabilities relative to
 613      * its caller class, to emulate all supported bytecode behaviors.
 614      * Also, the {@link Lookup#in Lookup.in} method may produce a lookup object
 615      * with fewer access modes than the original lookup object.
 616      *
 617      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 618      * &lt;a id=&quot;privacc&quot;&gt;&lt;/a&gt;
 619      * &lt;em&gt;Discussion of private and module access:&lt;/em&gt;
 620      * We say that a lookup has &lt;em&gt;private access&lt;/em&gt;
 621      * if its {@linkplain #lookupModes lookup modes}
 622      * include the possibility of accessing {@code private} members
 623      * (which includes the private members of nestmates).
 624      * As documented in the relevant methods elsewhere,
 625      * only lookups with private access possess the following capabilities:
 626      * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
 627      * &lt;li&gt;access private fields, methods, and constructors of the lookup class and its nestmates
 628      * &lt;li&gt;create method handles which {@link Lookup#findSpecial emulate invokespecial} instructions
 629      * &lt;li&gt;avoid &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;package access checks&lt;/a&gt;
 630      *     for classes accessible to the lookup class
 631      * &lt;li&gt;create {@link Lookup#in delegated lookup objects} which have private access to other classes
 632      *     within the same package member
 633      * &lt;/ul&gt;
 634      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 635      * Similarly, a lookup with module access ensures that the original lookup creator was
 636      * a member in the same module as the lookup class.
 637      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 638      * Private and module access are independently determined modes; a lookup may have
 639      * either or both or neither.  A lookup which possesses both access modes is said to
 640      * possess {@linkplain #hasFullPrivilegeAccess() full privilege access}.  Such a lookup has
 641      * the following additional capability:
 642      * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
 643      * &lt;li&gt;create method handles which invoke &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt; methods,
 644      *     such as {@code Class.forName}
 645      * &lt;/ul&gt;
 646      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 647      * Each of these permissions is a consequence of the fact that a lookup object
 648      * with private access can be securely traced back to an originating class,
 649      * whose &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; and Java language access permissions
 650      * can be reliably determined and emulated by method handles.
 651      *
 652      * &lt;h2&gt;&lt;a id=&quot;cross-module-lookup&quot;&gt;&lt;/a&gt;Cross-module lookups&lt;/h2&gt;
 653      * When a lookup class in one module {@code M1} accesses a class in another module
 654      * {@code M2}, extra access checking is performed beyond the access mode bits.
 655      * A {@code Lookup} with {@link #PUBLIC} mode and a lookup class in {@code M1}
 656      * can access public types in {@code M2} when {@code M2} is readable to {@code M1}
 657      * and when the type is in a package of {@code M2} that is exported to
 658      * at least {@code M1}.
 659      * &lt;p&gt;
 660      * A {@code Lookup} on {@code C} can also &lt;em&gt;teleport&lt;/em&gt; to a target class
 661      * via {@link #in(Class) Lookup.in} and {@link MethodHandles#privateLookupIn(Class, Lookup)
 662      * MethodHandles.privateLookupIn} methods.
 663      * Teleporting across modules will always record the original lookup class as
 664      * the &lt;em&gt;{@linkplain #previousLookupClass() previous lookup class}&lt;/em&gt;
 665      * and drops {@link Lookup#MODULE MODULE} access.
 666      * If the target class is in the same module as the lookup class {@code C},
 667      * then the target class becomes the new lookup class
 668      * and there is no change to the previous lookup class.
 669      * If the target class is in a different module from {@code M1} ({@code C}&#39;s module),
 670      * {@code C} becomes the new previous lookup class
 671      * and the target class becomes the new lookup class.
 672      * In that case, if there was already a previous lookup class in {@code M0},
 673      * and it differs from {@code M1} and {@code M2}, then the resulting lookup
 674      * drops all privileges.
 675      * For example,
 676      * &lt;blockquote&gt;&lt;pre&gt;
 677      * {@code
 678      * Lookup lookup = MethodHandles.lookup();   // in class C
 679      * Lookup lookup2 = lookup.in(D.class);
 680      * MethodHandle mh = lookup2.findStatic(E.class, &quot;m&quot;, MT);
 681      * }&lt;/pre&gt;&lt;/blockquote&gt;
 682      * &lt;p&gt;
 683      * The {@link #lookup()} factory method produces a {@code Lookup} object
 684      * with {@code null} previous lookup class.
 685      * {@link Lookup#in lookup.in(D.class)} transforms the {@code lookup} on class {@code C}
 686      * to class {@code D} without elevation of privileges.
 687      * If {@code C} and {@code D} are in the same module,
 688      * {@code lookup2} records {@code D} as the new lookup class and keeps the
 689      * same previous lookup class as the original {@code lookup}, or
 690      * {@code null} if not present.
 691      * &lt;p&gt;
 692      * When a {@code Lookup} teleports from a class
 693      * in one nest to another nest, {@code PRIVATE} access is dropped.
 694      * When a {@code Lookup} teleports from a class in one package to
 695      * another package, {@code PACKAGE} access is dropped.
 696      * When a {@code Lookup} teleports from a class in one module to another module,
 697      * {@code MODULE} access is dropped.
 698      * Teleporting across modules drops the ability to access non-exported classes
 699      * in both the module of the new lookup class and the module of the old lookup class
 700      * and the resulting {@code Lookup} remains only {@code PUBLIC} access.
 701      * A {@code Lookup} can teleport back and forth to a class in the module of
 702      * the lookup class and the module of the previous class lookup.
 703      * Teleporting across modules can only decrease access but cannot increase it.
 704      * Teleporting to some third module drops all accesses.
 705      * &lt;p&gt;
 706      * In the above example, if {@code C} and {@code D} are in different modules,
 707      * {@code lookup2} records {@code D} as its lookup class and
 708      * {@code C} as its previous lookup class and {@code lookup2} has only
 709      * {@code PUBLIC} access. {@code lookup2} can teleport to other class in
 710      * {@code C}&#39;s module and {@code D}&#39;s module.
 711      * If class {@code E} is in a third module, {@code lookup2.in(E.class)} creates
 712      * a {@code Lookup} on {@code E} with no access and {@code lookup2}&#39;s lookup
 713      * class {@code D} is recorded as its previous lookup class.
 714      * &lt;p&gt;
 715      * Teleporting across modules restricts access to the public types that
 716      * both the lookup class and the previous lookup class can equally access
 717      * (see below).
 718      * &lt;p&gt;
 719      * {@link MethodHandles#privateLookupIn(Class, Lookup) MethodHandles.privateLookupIn(T.class, lookup)}
 720      * can be used to teleport a {@code lookup} from class {@code C} to class {@code T}
 721      * and create a new {@code Lookup} with &lt;a href=&quot;#privacc&quot;&gt;private access&lt;/a&gt;
 722      * if the lookup class is allowed to do &lt;em&gt;deep reflection&lt;/em&gt; on {@code T}.
 723      * The {@code lookup} must have {@link #MODULE} and {@link #PRIVATE} access
 724      * to call {@code privateLookupIn}.
 725      * A {@code lookup} on {@code C} in module {@code M1} is allowed to do deep reflection
 726      * on all classes in {@code M1}.  If {@code T} is in {@code M1}, {@code privateLookupIn}
 727      * produces a new {@code Lookup} on {@code T} with full capabilities.
 728      * A {@code lookup} on {@code C} is also allowed
 729      * to do deep reflection on {@code T} in another module {@code M2} if
 730      * {@code M1} reads {@code M2} and {@code M2} {@link Module#isOpen(String,Module) opens}
 731      * the package containing {@code T} to at least {@code M1}.
 732      * {@code T} becomes the new lookup class and {@code C} becomes the new previous
 733      * lookup class and {@code MODULE} access is dropped from the resulting {@code Lookup}.
 734      * The resulting {@code Lookup} can be used to do member lookup or teleport
 735      * to another lookup class by calling {@link #in Lookup::in}.  But
 736      * it cannot be used to obtain another private {@code Lookup} by calling
 737      * {@link MethodHandles#privateLookupIn(Class, Lookup) privateLookupIn}
 738      * because it has no {@code MODULE} access.
 739      *
 740      * &lt;h2&gt;&lt;a id=&quot;module-access-check&quot;&gt;&lt;/a&gt;Cross-module access checks&lt;/h2&gt;
 741      *
 742      * A {@code Lookup} with {@link #PUBLIC} or with {@link #UNCONDITIONAL} mode
 743      * allows cross-module access. The access checking is performed with respect
 744      * to both the lookup class and the previous lookup class if present.
 745      * &lt;p&gt;
 746      * A {@code Lookup} with {@link #UNCONDITIONAL} mode can access public type
 747      * in all modules when the type is in a package that is {@linkplain Module#isExported(String)
 748      * exported unconditionally}.
 749      * &lt;p&gt;
 750      * If a {@code Lookup} on {@code LC} in {@code M1} has no previous lookup class,
 751      * the lookup with {@link #PUBLIC} mode can access all public types in modules
 752      * that are readable to {@code M1} and the type is in a package that is exported
 753      * at least to {@code M1}.
 754      * &lt;p&gt;
 755      * If a {@code Lookup} on {@code LC} in {@code M1} has a previous lookup class
 756      * {@code PLC} on {@code M0}, the lookup with {@link #PUBLIC} mode can access
 757      * the intersection of all public types that are accessible to {@code M1}
 758      * with all public types that are accessible to {@code M0}. {@code M0}
 759      * reads {@code M1} and hence the set of accessible types includes:
 760      *
 761      * &lt;table class=&quot;striped&quot;&gt;
 762      * &lt;caption style=&quot;display:none&quot;&gt;
 763      * Public types in the following packages are accessible to the
 764      * lookup class and the previous lookup class.
 765      * &lt;/caption&gt;
 766      * &lt;thead&gt;
 767      * &lt;tr&gt;
 768      * &lt;th scope=&quot;col&quot;&gt;Equally accessible types to {@code M0} and {@code M1}&lt;/th&gt;
 769      * &lt;/tr&gt;
 770      * &lt;/thead&gt;
 771      * &lt;tbody&gt;
 772      * &lt;tr&gt;
 773      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;unconditional-exported packages from {@code M1}&lt;/th&gt;
 774      * &lt;/tr&gt;
 775      * &lt;tr&gt;
 776      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;unconditional-exported packages from {@code M0} if {@code M1} reads {@code M0}&lt;/th&gt;
 777      * &lt;/tr&gt;
 778      * &lt;tr&gt;
 779      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;unconditional-exported packages from a third module {@code M2}
 780      * if both {@code M0} and {@code M1} read {@code M2}&lt;/th&gt;
 781      * &lt;/tr&gt;
 782      * &lt;tr&gt;
 783      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;qualified-exported packages from {@code M1} to {@code M0}&lt;/th&gt;
 784      * &lt;/tr&gt;
 785      * &lt;tr&gt;
 786      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;qualified-exported packages from {@code M0} to {@code M1}
 787      * if {@code M1} reads {@code M0}&lt;/th&gt;
 788      * &lt;/tr&gt;
 789      * &lt;tr&gt;
 790      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;qualified-exported packages from a third module {@code M2} to
 791      * both {@code M0} and {@code M1} if both {@code M0} and {@code M1} read {@code M2}&lt;/th&gt;
 792      * &lt;/tr&gt;
 793      * &lt;/tbody&gt;
 794      * &lt;/table&gt;
 795      *
 796      * &lt;h2&gt;&lt;a id=&quot;access-modes&quot;&gt;&lt;/a&gt;Access modes&lt;/h2&gt;
 797      *
 798      * The table below shows the access modes of a {@code Lookup} produced by
 799      * any of the following factory or transformation methods:
 800      * &lt;ul&gt;
 801      * &lt;li&gt;{@link #lookup() MethodHandles::lookup}&lt;/li&gt;
 802      * &lt;li&gt;{@link #publicLookup() MethodHandles::publicLookup}&lt;/li&gt;
 803      * &lt;li&gt;{@link #privateLookupIn(Class, Lookup) MethodHandles::privateLookupIn}&lt;/li&gt;
 804      * &lt;li&gt;{@link Lookup#in Lookup::in}&lt;/li&gt;
 805      * &lt;li&gt;{@link Lookup#dropLookupMode(int) Lookup::dropLookupMode}&lt;/li&gt;
 806      * &lt;/ul&gt;
 807      *
 808      * &lt;table class=&quot;striped&quot;&gt;
 809      * &lt;caption style=&quot;display:none&quot;&gt;
 810      * Access mode summary
 811      * &lt;/caption&gt;
 812      * &lt;thead&gt;
 813      * &lt;tr&gt;
 814      * &lt;th scope=&quot;col&quot;&gt;Lookup object&lt;/th&gt;
 815      * &lt;th style=&quot;text-align:center&quot;&gt;protected&lt;/th&gt;
 816      * &lt;th style=&quot;text-align:center&quot;&gt;private&lt;/th&gt;
 817      * &lt;th style=&quot;text-align:center&quot;&gt;package&lt;/th&gt;
 818      * &lt;th style=&quot;text-align:center&quot;&gt;module&lt;/th&gt;
 819      * &lt;th style=&quot;text-align:center&quot;&gt;public&lt;/th&gt;
 820      * &lt;/tr&gt;
 821      * &lt;/thead&gt;
 822      * &lt;tbody&gt;
 823      * &lt;tr&gt;
 824      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL = MethodHandles.lookup()} in {@code C}&lt;/th&gt;
 825      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;
 826      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 827      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 828      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 829      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 830      * &lt;/tr&gt;
 831      * &lt;tr&gt;
 832      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL.in(C1)} same package&lt;/th&gt;
 833      * &lt;td&gt;&lt;/td&gt;
 834      * &lt;td&gt;&lt;/td&gt;
 835      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 836      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 837      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 838      * &lt;/tr&gt;
 839      * &lt;tr&gt;
 840      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL.in(C1)} same module&lt;/th&gt;
 841      * &lt;td&gt;&lt;/td&gt;
 842      * &lt;td&gt;&lt;/td&gt;
 843      * &lt;td&gt;&lt;/td&gt;
 844      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 845      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 846      * &lt;/tr&gt;
 847      * &lt;tr&gt;
 848      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL.in(D)} different module&lt;/th&gt;
 849      * &lt;td&gt;&lt;/td&gt;
 850      * &lt;td&gt;&lt;/td&gt;
 851      * &lt;td&gt;&lt;/td&gt;
 852      * &lt;td&gt;&lt;/td&gt;
 853      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 854      * &lt;/tr&gt;
 855      * &lt;tr&gt;
 856      * &lt;td&gt;{@code CL.in(D).in(C)} hop back to module&lt;/td&gt;
 857      * &lt;td&gt;&lt;/td&gt;
 858      * &lt;td&gt;&lt;/td&gt;
 859      * &lt;td&gt;&lt;/td&gt;
 860      * &lt;td&gt;&lt;/td&gt;
 861      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 862      * &lt;/tr&gt;
 863      * &lt;tr&gt;
 864      * &lt;td&gt;{@code PRI1 = privateLookupIn(C1,CL)}&lt;/td&gt;
 865      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;
 866      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 867      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 868      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 869      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 870      * &lt;/tr&gt;
 871      * &lt;tr&gt;
 872      * &lt;td&gt;{@code PRI1a = privateLookupIn(C,PRI1)}&lt;/td&gt;
 873      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;
 874      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 875      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 876      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 877      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 878      * &lt;/tr&gt;
 879      * &lt;tr&gt;
 880      * &lt;td&gt;{@code PRI1.in(C1)} same package&lt;/td&gt;
 881      * &lt;td&gt;&lt;/td&gt;
 882      * &lt;td&gt;&lt;/td&gt;
 883      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 884      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 885      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 886      * &lt;/tr&gt;
 887      * &lt;tr&gt;
 888      * &lt;td&gt;{@code PRI1.in(C1)} different package&lt;/td&gt;
 889      * &lt;td&gt;&lt;/td&gt;
 890      * &lt;td&gt;&lt;/td&gt;
 891      * &lt;td&gt;&lt;/td&gt;
 892      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 893      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 894      * &lt;/tr&gt;
 895      * &lt;tr&gt;
 896      * &lt;td&gt;{@code PRI1.in(D)} different module&lt;/td&gt;
 897      * &lt;td&gt;&lt;/td&gt;
 898      * &lt;td&gt;&lt;/td&gt;
 899      * &lt;td&gt;&lt;/td&gt;
 900      * &lt;td&gt;&lt;/td&gt;
 901      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 902      * &lt;/tr&gt;
 903      * &lt;tr&gt;
 904      * &lt;td&gt;{@code PRI1.dropLookupMode(PROTECTED)}&lt;/td&gt;
 905      * &lt;td&gt;&lt;/td&gt;
 906      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 907      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 908      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 909      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 910      * &lt;/tr&gt;
 911      * &lt;tr&gt;
 912      * &lt;td&gt;{@code PRI1.dropLookupMode(PRIVATE)}&lt;/td&gt;
 913      * &lt;td&gt;&lt;/td&gt;
 914      * &lt;td&gt;&lt;/td&gt;
 915      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 916      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 917      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 918      * &lt;/tr&gt;
 919      * &lt;tr&gt;
 920      * &lt;td&gt;{@code PRI1.dropLookupMode(PACKAGE)}&lt;/td&gt;
 921      * &lt;td&gt;&lt;/td&gt;
 922      * &lt;td&gt;&lt;/td&gt;
 923      * &lt;td&gt;&lt;/td&gt;
 924      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
 925      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 926      * &lt;/tr&gt;
 927      * &lt;tr&gt;
 928      * &lt;td&gt;{@code PRI1.dropLookupMode(MODULE)}&lt;/td&gt;
 929      * &lt;td&gt;&lt;/td&gt;
 930      * &lt;td&gt;&lt;/td&gt;
 931      * &lt;td&gt;&lt;/td&gt;
 932      * &lt;td&gt;&lt;/td&gt;
 933      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
 934      * &lt;/tr&gt;
 935      * &lt;tr&gt;
 936      * &lt;td&gt;{@code PRI1.dropLookupMode(PUBLIC)}&lt;/td&gt;
 937      * &lt;td&gt;&lt;/td&gt;
 938      * &lt;td&gt;&lt;/td&gt;
 939      * &lt;td&gt;&lt;/td&gt;
 940      * &lt;td&gt;&lt;/td&gt;
 941      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;
 942      * &lt;tr&gt;
 943      * &lt;td&gt;{@code PRI2 = privateLookupIn(D,CL)}&lt;/td&gt;
 944      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;
 945      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 946      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 947      * &lt;td&gt;&lt;/td&gt;
 948      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 949      * &lt;/tr&gt;
 950      * &lt;tr&gt;
 951      * &lt;td&gt;{@code privateLookupIn(D,PRI1)}&lt;/td&gt;
 952      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;
 953      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
 954      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 955      * &lt;td&gt;&lt;/td&gt;
 956      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 957      * &lt;/tr&gt;
 958      * &lt;tr&gt;
 959      * &lt;td&gt;{@code privateLookupIn(C,PRI2)} fails&lt;/td&gt;
 960      * &lt;td&gt;&lt;/td&gt;
 961      * &lt;td&gt;&lt;/td&gt;
 962      * &lt;td&gt;&lt;/td&gt;
 963      * &lt;td&gt;&lt;/td&gt;
 964      * &lt;td style=&quot;text-align:center&quot;&gt;IAE&lt;/td&gt;
 965      * &lt;/tr&gt;
 966      * &lt;tr&gt;
 967      * &lt;td&gt;{@code PRI2.in(D2)} same package&lt;/td&gt;
 968      * &lt;td&gt;&lt;/td&gt;
 969      * &lt;td&gt;&lt;/td&gt;
 970      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
 971      * &lt;td&gt;&lt;/td&gt;
 972      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 973      * &lt;/tr&gt;
 974      * &lt;tr&gt;
 975      * &lt;td&gt;{@code PRI2.in(D2)} different package&lt;/td&gt;
 976      * &lt;td&gt;&lt;/td&gt;
 977      * &lt;td&gt;&lt;/td&gt;
 978      * &lt;td&gt;&lt;/td&gt;
 979      * &lt;td&gt;&lt;/td&gt;
 980      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 981      * &lt;/tr&gt;
 982      * &lt;tr&gt;
 983      * &lt;td&gt;{@code PRI2.in(C1)} hop back to module&lt;/td&gt;
 984      * &lt;td&gt;&lt;/td&gt;
 985      * &lt;td&gt;&lt;/td&gt;
 986      * &lt;td&gt;&lt;/td&gt;
 987      * &lt;td&gt;&lt;/td&gt;
 988      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
 989      * &lt;/tr&gt;
 990      * &lt;tr&gt;
 991      * &lt;td&gt;{@code PRI2.in(E)} hop to third module&lt;/td&gt;
 992      * &lt;td&gt;&lt;/td&gt;
 993      * &lt;td&gt;&lt;/td&gt;
 994      * &lt;td&gt;&lt;/td&gt;
 995      * &lt;td&gt;&lt;/td&gt;
 996      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;
 997      * &lt;/tr&gt;
 998      * &lt;tr&gt;
 999      * &lt;td&gt;{@code PRI2.dropLookupMode(PROTECTED)}&lt;/td&gt;
1000      * &lt;td&gt;&lt;/td&gt;
1001      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
1002      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
1003      * &lt;td&gt;&lt;/td&gt;
1004      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
1005      * &lt;/tr&gt;
1006      * &lt;tr&gt;
1007      * &lt;td&gt;{@code PRI2.dropLookupMode(PRIVATE)}&lt;/td&gt;
1008      * &lt;td&gt;&lt;/td&gt;
1009      * &lt;td&gt;&lt;/td&gt;
1010      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
1011      * &lt;td&gt;&lt;/td&gt;
1012      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
1013      * &lt;/tr&gt;
1014      * &lt;tr&gt;
1015      * &lt;td&gt;{@code PRI2.dropLookupMode(PACKAGE)}&lt;/td&gt;
1016      * &lt;td&gt;&lt;/td&gt;
1017      * &lt;td&gt;&lt;/td&gt;
1018      * &lt;td&gt;&lt;/td&gt;
1019      * &lt;td&gt;&lt;/td&gt;
1020      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
1021      * &lt;/tr&gt;
1022      * &lt;tr&gt;
1023      * &lt;td&gt;{@code PRI2.dropLookupMode(MODULE)}&lt;/td&gt;
1024      * &lt;td&gt;&lt;/td&gt;
1025      * &lt;td&gt;&lt;/td&gt;
1026      * &lt;td&gt;&lt;/td&gt;
1027      * &lt;td&gt;&lt;/td&gt;
1028      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;
1029      * &lt;/tr&gt;
1030      * &lt;tr&gt;
1031      * &lt;td&gt;{@code PRI2.dropLookupMode(PUBLIC)}&lt;/td&gt;
1032      * &lt;td&gt;&lt;/td&gt;
1033      * &lt;td&gt;&lt;/td&gt;
1034      * &lt;td&gt;&lt;/td&gt;
1035      * &lt;td&gt;&lt;/td&gt;
1036      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;
1037      * &lt;/tr&gt;
1038      * &lt;tr&gt;
1039      * &lt;td&gt;{@code CL.dropLookupMode(PROTECTED)}&lt;/td&gt;
1040      * &lt;td&gt;&lt;/td&gt;
1041      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;
1042      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
1043      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
1044      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
1045      * &lt;/tr&gt;
1046      * &lt;tr&gt;
1047      * &lt;td&gt;{@code CL.dropLookupMode(PRIVATE)}&lt;/td&gt;
1048      * &lt;td&gt;&lt;/td&gt;
1049      * &lt;td&gt;&lt;/td&gt;
1050      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;
1051      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
1052      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
1053      * &lt;/tr&gt;
1054      * &lt;tr&gt;
1055      * &lt;td&gt;{@code CL.dropLookupMode(PACKAGE)}&lt;/td&gt;
1056      * &lt;td&gt;&lt;/td&gt;
1057      * &lt;td&gt;&lt;/td&gt;
1058      * &lt;td&gt;&lt;/td&gt;
1059      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;
1060      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
1061      * &lt;/tr&gt;
1062      * &lt;tr&gt;
1063      * &lt;td&gt;{@code CL.dropLookupMode(MODULE)}&lt;/td&gt;
1064      * &lt;td&gt;&lt;/td&gt;
1065      * &lt;td&gt;&lt;/td&gt;
1066      * &lt;td&gt;&lt;/td&gt;
1067      * &lt;td&gt;&lt;/td&gt;
1068      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;
1069      * &lt;/tr&gt;
1070      * &lt;tr&gt;
1071      * &lt;td&gt;{@code CL.dropLookupMode(PUBLIC)}&lt;/td&gt;
1072      * &lt;td&gt;&lt;/td&gt;
1073      * &lt;td&gt;&lt;/td&gt;
1074      * &lt;td&gt;&lt;/td&gt;
1075      * &lt;td&gt;&lt;/td&gt;
1076      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;
1077      * &lt;/tr&gt;
1078      * &lt;tr&gt;
1079      * &lt;td&gt;{@code PUB = publicLookup()}&lt;/td&gt;
1080      * &lt;td&gt;&lt;/td&gt;
1081      * &lt;td&gt;&lt;/td&gt;
1082      * &lt;td&gt;&lt;/td&gt;
1083      * &lt;td&gt;&lt;/td&gt;
1084      * &lt;td style=&quot;text-align:center&quot;&gt;U&lt;/td&gt;
1085      * &lt;/tr&gt;
1086      * &lt;tr&gt;
1087      * &lt;td&gt;{@code PUB.in(D)} different module&lt;/td&gt;
1088      * &lt;td&gt;&lt;/td&gt;
1089      * &lt;td&gt;&lt;/td&gt;
1090      * &lt;td&gt;&lt;/td&gt;
1091      * &lt;td&gt;&lt;/td&gt;
1092      * &lt;td style=&quot;text-align:center&quot;&gt;U&lt;/td&gt;
1093      * &lt;/tr&gt;
1094      * &lt;tr&gt;
1095      * &lt;td&gt;{@code PUB.in(D).in(E)} third module&lt;/td&gt;
1096      * &lt;td&gt;&lt;/td&gt;
1097      * &lt;td&gt;&lt;/td&gt;
1098      * &lt;td&gt;&lt;/td&gt;
1099      * &lt;td&gt;&lt;/td&gt;
1100      * &lt;td style=&quot;text-align:center&quot;&gt;U&lt;/td&gt;
1101      * &lt;/tr&gt;
1102      * &lt;tr&gt;
1103      * &lt;td&gt;{@code PUB.dropLookupMode(UNCONDITIONAL)}&lt;/td&gt;
1104      * &lt;td&gt;&lt;/td&gt;
1105      * &lt;td&gt;&lt;/td&gt;
1106      * &lt;td&gt;&lt;/td&gt;
1107      * &lt;td&gt;&lt;/td&gt;
1108      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;
1109      * &lt;/tr&gt;
1110      * &lt;tr&gt;
1111      * &lt;td&gt;{@code privateLookupIn(C1,PUB)} fails&lt;/td&gt;
1112      * &lt;td&gt;&lt;/td&gt;
1113      * &lt;td&gt;&lt;/td&gt;
1114      * &lt;td&gt;&lt;/td&gt;
1115      * &lt;td&gt;&lt;/td&gt;
1116      * &lt;td style=&quot;text-align:center&quot;&gt;IAE&lt;/td&gt;
1117      * &lt;/tr&gt;
1118      * &lt;tr&gt;
1119      * &lt;td&gt;{@code ANY.in(X)}, for inaccessible {@code X}&lt;/td&gt;
1120      * &lt;td&gt;&lt;/td&gt;
1121      * &lt;td&gt;&lt;/td&gt;
1122      * &lt;td&gt;&lt;/td&gt;
1123      * &lt;td&gt;&lt;/td&gt;
1124      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;
1125      * &lt;/tr&gt;
1126      * &lt;/tbody&gt;
1127      * &lt;/table&gt;
1128      *
1129      * &lt;p&gt;
1130      * Notes:
1131      * &lt;ul&gt;
1132      * &lt;li&gt;Class {@code C} and class {@code C1} are in module {@code M1},
1133      *     but {@code D} and {@code D2} are in module {@code M2}, and {@code E}
1134      *     is in module {@code M3}. {@code X} stands for class which is inaccessible
1135      *     to the lookup. {@code ANY} stands for any of the example lookups.&lt;/li&gt;
1136      * &lt;li&gt;{@code PRO} indicates {@link #PROTECTED} bit set,
1137      *     {@code PRI} indicates {@link #PRIVATE} bit set,
1138      *     {@code PAC} indicates {@link #PACKAGE} bit set,
1139      *     {@code MOD} indicates {@link #MODULE} bit set,
1140      *     {@code 1R} and {@code 2R} indicate {@link #PUBLIC} bit set,
1141      *     {@code U} indicates {@link #UNCONDITIONAL} bit set,
1142      *     {@code IAE} indicates {@code IllegalAccessException} thrown.&lt;/li&gt;
1143      * &lt;li&gt;Public access comes in three kinds:
1144      * &lt;ul&gt;
1145      * &lt;li&gt;unconditional ({@code U}): the lookup assumes readability.
1146      *     The lookup has {@code null} previous lookup class.
1147      * &lt;li&gt;one-module-reads ({@code 1R}): the module access checking is
1148      *     performed with respect to the lookup class.  The lookup has {@code null}
1149      *     previous lookup class.
1150      * &lt;li&gt;two-module-reads ({@code 2R}): the module access checking is
1151      *     performed with respect to the lookup class and the previous lookup class.
1152      *     The lookup has a non-null previous lookup class which is in a
1153      *     different module from the current lookup class.
1154      * &lt;/ul&gt;
1155      * &lt;li&gt;Any attempt to reach a third module loses all access.&lt;/li&gt;
1156      * &lt;li&gt;If a target class {@code X} is not accessible to {@code Lookup::in}
1157      * all access modes are dropped.&lt;/li&gt;
1158      * &lt;/ul&gt;
1159      *
1160      * &lt;h2&gt;&lt;a id=&quot;secmgr&quot;&gt;&lt;/a&gt;Security manager interactions&lt;/h2&gt;
1161      * Although bytecode instructions can only refer to classes in
1162      * a related class loader, this API can search for methods in any
1163      * class, as long as a reference to its {@code Class} object is
1164      * available.  Such cross-loader references are also possible with the
1165      * Core Reflection API, and are impossible to bytecode instructions
1166      * such as {@code invokestatic} or {@code getfield}.
1167      * There is a {@linkplain java.lang.SecurityManager security manager API}
1168      * to allow applications to check such cross-loader references.
1169      * These checks apply to both the {@code MethodHandles.Lookup} API
1170      * and the Core Reflection API
1171      * (as found on {@link java.lang.Class Class}).
1172      * &lt;p&gt;
1173      * If a security manager is present, member and class lookups are subject to
1174      * additional checks.
1175      * From one to three calls are made to the security manager.
1176      * Any of these calls can refuse access by throwing a
1177      * {@link java.lang.SecurityException SecurityException}.
1178      * Define {@code smgr} as the security manager,
1179      * {@code lookc} as the lookup class of the current lookup object,
1180      * {@code refc} as the containing class in which the member
1181      * is being sought, and {@code defc} as the class in which the
1182      * member is actually defined.
1183      * (If a class or other type is being accessed,
1184      * the {@code refc} and {@code defc} values are the class itself.)
1185      * The value {@code lookc} is defined as &lt;em&gt;not present&lt;/em&gt;
1186      * if the current lookup object does not have
1187      * {@linkplain #hasFullPrivilegeAccess() full privilege access}.
1188      * The calls are made according to the following rules:
1189      * &lt;ul&gt;
1190      * &lt;li&gt;&lt;b&gt;Step 1:&lt;/b&gt;
1191      *     If {@code lookc} is not present, or if its class loader is not
1192      *     the same as or an ancestor of the class loader of {@code refc},
1193      *     then {@link SecurityManager#checkPackageAccess
1194      *     smgr.checkPackageAccess(refcPkg)} is called,
1195      *     where {@code refcPkg} is the package of {@code refc}.
1196      * &lt;li&gt;&lt;b&gt;Step 2a:&lt;/b&gt;
1197      *     If the retrieved member is not public and
1198      *     {@code lookc} is not present, then
1199      *     {@link SecurityManager#checkPermission smgr.checkPermission}
1200      *     with {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)} is called.
1201      * &lt;li&gt;&lt;b&gt;Step 2b:&lt;/b&gt;
1202      *     If the retrieved class has a {@code null} class loader,
1203      *     and {@code lookc} is not present, then
1204      *     {@link SecurityManager#checkPermission smgr.checkPermission}
1205      *     with {@code RuntimePermission(&quot;getClassLoader&quot;)} is called.
1206      * &lt;li&gt;&lt;b&gt;Step 3:&lt;/b&gt;
1207      *     If the retrieved member is not public,
1208      *     and if {@code lookc} is not present,
1209      *     and if {@code defc} and {@code refc} are different,
1210      *     then {@link SecurityManager#checkPackageAccess
1211      *     smgr.checkPackageAccess(defcPkg)} is called,
1212      *     where {@code defcPkg} is the package of {@code defc}.
1213      * &lt;/ul&gt;
1214      * Security checks are performed after other access checks have passed.
1215      * Therefore, the above rules presuppose a member or class that is public,
1216      * or else that is being accessed from a lookup class that has
1217      * rights to access the member or class.
1218      * &lt;p&gt;
1219      * If a security manager is present and the current lookup object does not have
1220      * {@linkplain #hasFullPrivilegeAccess() full privilege access}, then
1221      * {@link #defineClass(byte[]) defineClass}
1222      * calls {@link SecurityManager#checkPermission smgr.checkPermission}
1223      * with {@code RuntimePermission(&quot;defineClass&quot;)}.
1224      *
1225      * &lt;h2&gt;&lt;a id=&quot;callsens&quot;&gt;&lt;/a&gt;Caller sensitive methods&lt;/h2&gt;
1226      * A small number of Java methods have a special property called caller sensitivity.
1227      * A &lt;em&gt;caller-sensitive&lt;/em&gt; method can behave differently depending on the
1228      * identity of its immediate caller.
1229      * &lt;p&gt;
1230      * If a method handle for a caller-sensitive method is requested,
1231      * the general rules for &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; apply,
1232      * but they take account of the lookup class in a special way.
1233      * The resulting method handle behaves as if it were called
1234      * from an instruction contained in the lookup class,
1235      * so that the caller-sensitive method detects the lookup class.
1236      * (By contrast, the invoker of the method handle is disregarded.)
1237      * Thus, in the case of caller-sensitive methods,
1238      * different lookup classes may give rise to
1239      * differently behaving method handles.
1240      * &lt;p&gt;
1241      * In cases where the lookup object is
1242      * {@link MethodHandles#publicLookup() publicLookup()},
1243      * or some other lookup object without the
1244      * {@linkplain #hasFullPrivilegeAccess() full privilege access},
1245      * the lookup class is disregarded.
1246      * In such cases, no caller-sensitive method handle can be created,
1247      * access is forbidden, and the lookup fails with an
1248      * {@code IllegalAccessException}.
1249      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
1250      * &lt;em&gt;Discussion:&lt;/em&gt;
1251      * For example, the caller-sensitive method
1252      * {@link java.lang.Class#forName(String) Class.forName(x)}
1253      * can return varying classes or throw varying exceptions,
1254      * depending on the class loader of the class that calls it.
1255      * A public lookup of {@code Class.forName} will fail, because
1256      * there is no reasonable way to determine its bytecode behavior.
1257      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
1258      * If an application caches method handles for broad sharing,
1259      * it should use {@code publicLookup()} to create them.
1260      * If there is a lookup of {@code Class.forName}, it will fail,
1261      * and the application must take appropriate action in that case.
1262      * It may be that a later lookup, perhaps during the invocation of a
1263      * bootstrap method, can incorporate the specific identity
1264      * of the caller, making the method accessible.
1265      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
1266      * The function {@code MethodHandles.lookup} is caller sensitive
1267      * so that there can be a secure foundation for lookups.
1268      * Nearly all other methods in the JSR 292 API rely on lookup
1269      * objects to check access requests.
1270      *
1271      * @revised 9
1272      */
1273     public static final
1274     class Lookup {
1275         /** The class on behalf of whom the lookup is being performed. */
1276         private final Class&lt;?&gt; lookupClass;
1277 
1278         /** previous lookup class */
1279         private final Class&lt;?&gt; prevLookupClass;
1280 
1281         /** The allowed sorts of members which may be looked up (PUBLIC, etc.). */
1282         private final int allowedModes;
1283 
1284         static {
1285             Reflection.registerFieldsToFilter(Lookup.class, Set.of(&quot;lookupClass&quot;, &quot;allowedModes&quot;));
1286         }
1287 
1288         /** A single-bit mask representing {@code public} access,
1289          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1290          *  The value, {@code 0x01}, happens to be the same as the value of the
1291          *  {@code public} {@linkplain java.lang.reflect.Modifier#PUBLIC modifier bit}.
1292          *  &lt;p&gt;
1293          *  A {@code Lookup} with this lookup mode performs cross-module access check
1294          *  with respect to the {@linkplain #lookupClass() lookup class} and
1295          *  {@linkplain #previousLookupClass() previous lookup class} if present.
1296          */
1297         public static final int PUBLIC = Modifier.PUBLIC;
1298 
1299         /** A single-bit mask representing {@code private} access,
1300          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1301          *  The value, {@code 0x02}, happens to be the same as the value of the
1302          *  {@code private} {@linkplain java.lang.reflect.Modifier#PRIVATE modifier bit}.
1303          */
1304         public static final int PRIVATE = Modifier.PRIVATE;
1305 
1306         /** A single-bit mask representing {@code protected} access,
1307          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1308          *  The value, {@code 0x04}, happens to be the same as the value of the
1309          *  {@code protected} {@linkplain java.lang.reflect.Modifier#PROTECTED modifier bit}.
1310          */
1311         public static final int PROTECTED = Modifier.PROTECTED;
1312 
1313         /** A single-bit mask representing {@code package} access (default access),
1314          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1315          *  The value is {@code 0x08}, which does not correspond meaningfully to
1316          *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
1317          */
1318         public static final int PACKAGE = Modifier.STATIC;
1319 
1320         /** A single-bit mask representing {@code module} access,
1321          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1322          *  The value is {@code 0x10}, which does not correspond meaningfully to
1323          *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
1324          *  In conjunction with the {@code PUBLIC} modifier bit, a {@code Lookup}
1325          *  with this lookup mode can access all public types in the module of the
1326          *  lookup class and public types in packages exported by other modules
1327          *  to the module of the lookup class.
1328          *  &lt;p&gt;
1329          *  If this lookup mode is set, the {@linkplain #previousLookupClass()
1330          *  previous lookup class} is always {@code null}.
1331          *
1332          *  @since 9
1333          *  @spec JPMS
1334          */
1335         public static final int MODULE = PACKAGE &lt;&lt; 1;
1336 
1337         /** A single-bit mask representing {@code unconditional} access
1338          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1339          *  The value is {@code 0x20}, which does not correspond meaningfully to
1340          *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
1341          *  A {@code Lookup} with this lookup mode assumes {@linkplain
1342          *  java.lang.Module#canRead(java.lang.Module) readability}.
1343          *  This lookup mode can access all public members of public types
1344          *  of all modules when the type is in a package that is {@link
1345          *  java.lang.Module#isExported(String) exported unconditionally}.
1346          *
1347          *  &lt;p&gt;
1348          *  If this lookup mode is set, the {@linkplain #previousLookupClass()
1349          *  previous lookup class} is always {@code null}.
1350          *
1351          *  @since 9
1352          *  @spec JPMS
1353          *  @see #publicLookup()
1354          */
1355         public static final int UNCONDITIONAL = PACKAGE &lt;&lt; 2;
1356 
1357         private static final int ALL_MODES = (PUBLIC | PRIVATE | PROTECTED | PACKAGE | MODULE | UNCONDITIONAL);
1358         private static final int FULL_POWER_MODES = (ALL_MODES &amp; ~UNCONDITIONAL);
1359         private static final int TRUSTED   = -1;
1360 
1361         /*
1362          * Adjust PUBLIC =&gt; PUBLIC|MODULE|UNCONDITIONAL
1363          * Adjust 0 =&gt; PACKAGE
1364          */
1365         private static int fixmods(int mods) {
1366             mods &amp;= (ALL_MODES - PACKAGE - MODULE - UNCONDITIONAL);
1367             if (Modifier.isPublic(mods))
1368                 mods |= UNCONDITIONAL;
1369             return (mods != 0) ? mods : PACKAGE;
1370         }
1371 
1372         /** Tells which class is performing the lookup.  It is this class against
1373          *  which checks are performed for visibility and access permissions.
1374          *  &lt;p&gt;
1375          *  If this lookup object has a {@linkplain #previousLookupClass() previous lookup class},
1376          *  access checks are performed against both the lookup class and the previous lookup class.
1377          *  &lt;p&gt;
1378          *  The class implies a maximum level of access permission,
1379          *  but the permissions may be additionally limited by the bitmask
1380          *  {@link #lookupModes lookupModes}, which controls whether non-public members
1381          *  can be accessed.
1382          *  @return the lookup class, on behalf of which this lookup object finds members
1383          *  @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
1384          */
1385         public Class&lt;?&gt; lookupClass() {
1386             return lookupClass;
1387         }
1388 
1389         /** Reports a lookup class in another module that this lookup object
1390          * was previously teleported from, or {@code null}.
1391          * &lt;p&gt;
1392          * A {@code Lookup} object produced by the factory methods, such as the
1393          * {@link #lookup() lookup()} and {@link #publicLookup() publicLookup()} method,
1394          * has {@code null} previous lookup class.
1395          * A {@code Lookup} object has a non-null previous lookup class
1396          * when this lookup was teleported from an old lookup class
1397          * in one module to a new lookup class in another module.
1398          *
1399          * @return the lookup class in another module that this lookup object was
1400          *         previously teleported from, or {@code null}
1401          * @since 14
1402          * @see #in(Class)
1403          * @see MethodHandles#privateLookupIn(Class, Lookup)
1404          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
1405          */
1406         public Class&lt;?&gt; previousLookupClass() {
1407             return prevLookupClass;
1408         }
1409 
1410         // This is just for calling out to MethodHandleImpl.
1411         private Class&lt;?&gt; lookupClassOrNull() {
1412             if (allowedModes == TRUSTED) {
1413                 return null;
1414             }
1415             if (allowedModes == UNCONDITIONAL) {
1416                 // use Object as the caller to pass to VM doing resolution
1417                 return Object.class;
1418             }
1419             return lookupClass;
1420         }
1421 
1422         /** Tells which access-protection classes of members this lookup object can produce.
1423          *  The result is a bit-mask of the bits
1424          *  {@linkplain #PUBLIC PUBLIC (0x01)},
1425          *  {@linkplain #PRIVATE PRIVATE (0x02)},
1426          *  {@linkplain #PROTECTED PROTECTED (0x04)},
1427          *  {@linkplain #PACKAGE PACKAGE (0x08)},
1428          *  {@linkplain #MODULE MODULE (0x10)},
1429          *  and {@linkplain #UNCONDITIONAL UNCONDITIONAL (0x20)}.
1430          *  &lt;p&gt;
1431          *  A freshly-created lookup object
1432          *  on the {@linkplain java.lang.invoke.MethodHandles#lookup() caller&#39;s class} has
1433          *  all possible bits set, except {@code UNCONDITIONAL}.
1434          *  A lookup object on a new lookup class
1435          *  {@linkplain java.lang.invoke.MethodHandles.Lookup#in created from a previous lookup object}
1436          *  may have some mode bits set to zero.
1437          *  Mode bits can also be
1438          *  {@linkplain java.lang.invoke.MethodHandles.Lookup#dropLookupMode directly cleared}.
1439          *  Once cleared, mode bits cannot be restored from the downgraded lookup object.
1440          *  The purpose of this is to restrict access via the new lookup object,
1441          *  so that it can access only names which can be reached by the original
1442          *  lookup object, and also by the new lookup class.
1443          *  @return the lookup modes, which limit the kinds of access performed by this lookup object
1444          *  @see #in
1445          *  @see #dropLookupMode
1446          *
1447          *  @revised 9
1448          *  @spec JPMS
1449          */
1450         public int lookupModes() {
1451             return allowedModes &amp; ALL_MODES;
1452         }
1453 
1454         /** Embody the current class (the lookupClass) as a lookup class
1455          * for method handle creation.
1456          * Must be called by from a method in this package,
1457          * which in turn is called by a method not in this package.
1458          */
1459         Lookup(Class&lt;?&gt; lookupClass) {
1460             this(lookupClass, null, FULL_POWER_MODES);
1461         }
1462 
1463         private Lookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {
1464             assert prevLookupClass == null || ((allowedModes &amp; MODULE) == 0
1465                     &amp;&amp; prevLookupClass.getModule() != lookupClass.getModule());
1466             assert !lookupClass.isArray() &amp;&amp; !lookupClass.isPrimitive();
1467             this.lookupClass = lookupClass;
1468             this.prevLookupClass = prevLookupClass;
1469             this.allowedModes = allowedModes;
1470         }
1471 
1472         private static Lookup newLookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {
1473             // make sure we haven&#39;t accidentally picked up a privileged class:
1474             checkUnprivilegedlookupClass(lookupClass);
1475             return new Lookup(lookupClass, prevLookupClass, allowedModes);
1476         }
1477 
1478         /**
1479          * Creates a lookup on the specified new lookup class.
1480          * The resulting object will report the specified
1481          * class as its own {@link #lookupClass() lookupClass}.
1482          *
1483          * &lt;p&gt;
1484          * However, the resulting {@code Lookup} object is guaranteed
1485          * to have no more access capabilities than the original.
1486          * In particular, access capabilities can be lost as follows:&lt;ul&gt;
1487          * &lt;li&gt;If the new lookup class is in a different module from the old one,
1488          * i.e. {@link #MODULE MODULE} access is lost.
1489          * &lt;li&gt;If the new lookup class is in a different package
1490          * than the old one, protected and default (package) members will not be accessible,
1491          * i.e. {@link #PROTECTED PROTECTED} and {@link #PACKAGE PACKAGE} access are lost.
1492          * &lt;li&gt;If the new lookup class is not within the same package member
1493          * as the old one, private members will not be accessible, and protected members
1494          * will not be accessible by virtue of inheritance,
1495          * i.e. {@link #PRIVATE PRIVATE} access is lost.
1496          * (Protected members may continue to be accessible because of package sharing.)
1497          * &lt;li&gt;If the new lookup class is not
1498          * {@linkplain #accessClass(Class) accessible} to this lookup,
1499          * then no members, not even public members, will be accessible
1500          * i.e. all access modes are lost.
1501          * &lt;li&gt;If the new lookup class, the old lookup class and the previous lookup class
1502          * are all in different modules i.e. teleporting to a third module,
1503          * all access modes are lost.
1504          * &lt;/ul&gt;
1505          * &lt;p&gt;
1506          * The new previous lookup class is chosen as follows:
1507          * &lt;ul&gt;
1508          * &lt;li&gt;If the new lookup object has {@link #UNCONDITIONAL UNCONDITIONAL} bit,
1509          * the new previous lookup class is {@code null}.
1510          * &lt;li&gt;If the new lookup class is in the same module as the old lookup class,
1511          * the new previous lookup class is the old previous lookup class.
1512          * &lt;li&gt;If the new lookup class is in a different module from the old lookup class,
1513          * the new previous lookup class is the old lookup class.
1514          *&lt;/ul&gt;
1515          * &lt;p&gt;
1516          * The resulting lookup&#39;s capabilities for loading classes
1517          * (used during {@link #findClass} invocations)
1518          * are determined by the lookup class&#39; loader,
1519          * which may change due to this operation.
1520          * &lt;p&gt;
1521          * @param requestedLookupClass the desired lookup class for the new lookup object
1522          * @return a lookup object which reports the desired lookup class, or the same object
1523          * if there is no change
1524          * @throws IllegalArgumentException if {@code requestedLookupClass} is a primitive type or void or array class
1525          * @throws NullPointerException if the argument is null
1526          *
1527          * @revised 9
1528          * @spec JPMS
1529          * @see #accessClass(Class)
1530          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
1531          */
1532         public Lookup in(Class&lt;?&gt; requestedLookupClass) {
1533             Objects.requireNonNull(requestedLookupClass);
1534             if (requestedLookupClass.isPrimitive())
1535                 throw new IllegalArgumentException(requestedLookupClass + &quot; is a primitive class&quot;);
1536             if (requestedLookupClass.isArray())
1537                 throw new IllegalArgumentException(requestedLookupClass + &quot; is an array class&quot;);
1538 
1539             if (allowedModes == TRUSTED)  // IMPL_LOOKUP can make any lookup at all
1540                 return new Lookup(requestedLookupClass, null, FULL_POWER_MODES);
1541             if (requestedLookupClass == this.lookupClass)
1542                 return this;  // keep same capabilities
1543             int newModes = (allowedModes &amp; FULL_POWER_MODES);
1544             Module fromModule = this.lookupClass.getModule();
1545             Module targetModule = requestedLookupClass.getModule();
1546             Class&lt;?&gt; plc = this.previousLookupClass();
1547             if ((this.allowedModes &amp; UNCONDITIONAL) != 0) {
1548                 assert plc == null;
1549                 newModes = UNCONDITIONAL;
1550             } else if (fromModule != targetModule) {
1551                 if (plc != null &amp;&amp; !VerifyAccess.isSameModule(plc, requestedLookupClass)) {
1552                     // allow hopping back and forth between fromModule and plc&#39;s module
1553                     // but not the third module
1554                     newModes = 0;
1555                 }
1556                 // drop MODULE access
1557                 newModes &amp;= ~(MODULE|PACKAGE|PRIVATE|PROTECTED);
1558                 // teleport from this lookup class
1559                 plc = this.lookupClass;
1560             }
1561             if ((newModes &amp; PACKAGE) != 0
1562                 &amp;&amp; !VerifyAccess.isSamePackage(this.lookupClass, requestedLookupClass)) {
1563                 newModes &amp;= ~(PACKAGE|PRIVATE|PROTECTED);
1564             }
1565             // Allow nestmate lookups to be created without special privilege:
1566             if ((newModes &amp; PRIVATE) != 0
1567                     &amp;&amp; !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {
1568                 newModes &amp;= ~(PRIVATE|PROTECTED);
1569             }
1570             if ((newModes &amp; (PUBLIC|UNCONDITIONAL)) != 0
1571                 &amp;&amp; !VerifyAccess.isClassAccessible(requestedLookupClass, this.lookupClass, this.prevLookupClass, allowedModes)) {
1572                 // The requested class it not accessible from the lookup class.
1573                 // No permissions.
1574                 newModes = 0;
1575             }
1576             return newLookup(requestedLookupClass, plc, newModes);
1577         }
1578 
1579         /**
1580          * Creates a lookup on the same lookup class which this lookup object
1581          * finds members, but with a lookup mode that has lost the given lookup mode.
1582          * The lookup mode to drop is one of {@link #PUBLIC PUBLIC}, {@link #MODULE
1583          * MODULE}, {@link #PACKAGE PACKAGE}, {@link #PROTECTED PROTECTED},
1584          * {@link #PRIVATE PRIVATE}, or {@link #UNCONDITIONAL UNCONDITIONAL}.
1585          *
1586          * &lt;p&gt; If this lookup is a {@linkplain MethodHandles#publicLookup() public lookup},
1587          * this lookup has {@code UNCONDITIONAL} mode set and it has no other mode set.
1588          * When dropping {@code UNCONDITIONAL} on a public lookup then the resulting
1589          * lookup has no access.
1590          *
1591          * &lt;p&gt; If this lookup is not a public lookup, then the following applies
1592          * regardless of its {@linkplain #lookupModes() lookup modes}.
1593          * {@link #PROTECTED PROTECTED} is always dropped and so the resulting lookup
1594          * mode will never have this access capability. When dropping {@code PACKAGE}
1595          * then the resulting lookup will not have {@code PACKAGE} or {@code PRIVATE}
1596          * access. When dropping {@code MODULE} then the resulting lookup will not
1597          * have {@code MODULE}, {@code PACKAGE}, or {@code PRIVATE} access.
1598          * When dropping {@code PUBLIC} then the resulting lookup has no access.
1599          *
1600          * @apiNote
1601          * A lookup with {@code PACKAGE} but not {@code PRIVATE} mode can safely
1602          * delegate non-public access within the package of the lookup class without
1603          * conferring  &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;.
1604          * A lookup with {@code MODULE} but not
1605          * {@code PACKAGE} mode can safely delegate {@code PUBLIC} access within
1606          * the module of the lookup class without conferring package access.
1607          * A lookup with a {@linkplain #previousLookupClass() previous lookup class}
1608          * (and {@code PUBLIC} but not {@code MODULE} mode) can safely delegate access
1609          * to public classes accessible to both the module of the lookup class
1610          * and the module of the previous lookup class.
1611          *
1612          * @param modeToDrop the lookup mode to drop
1613          * @return a lookup object which lacks the indicated mode, or the same object if there is no change
1614          * @throws IllegalArgumentException if {@code modeToDrop} is not one of {@code PUBLIC},
1615          * {@code MODULE}, {@code PACKAGE}, {@code PROTECTED}, {@code PRIVATE} or {@code UNCONDITIONAL}
1616          * @see MethodHandles#privateLookupIn
1617          * @since 9
1618          */
1619         public Lookup dropLookupMode(int modeToDrop) {
1620             int oldModes = lookupModes();
1621             int newModes = oldModes &amp; ~(modeToDrop | PROTECTED);
1622             switch (modeToDrop) {
1623                 case PUBLIC: newModes &amp;= ~(FULL_POWER_MODES); break;
1624                 case MODULE: newModes &amp;= ~(PACKAGE | PRIVATE); break;
1625                 case PACKAGE: newModes &amp;= ~(PRIVATE); break;
1626                 case PROTECTED:
1627                 case PRIVATE:
1628                 case UNCONDITIONAL: break;
1629                 default: throw new IllegalArgumentException(modeToDrop + &quot; is not a valid mode to drop&quot;);
1630             }
1631             if (newModes == oldModes) return this;  // return self if no change
1632             return newLookup(lookupClass(), previousLookupClass(), newModes);
1633         }
1634 
1635         /**
1636          * Creates and links a class or interface from {@code bytes}
1637          * with the same class loader and in the same runtime package and
1638          * {@linkplain java.security.ProtectionDomain protection domain} as this lookup&#39;s
1639          * {@linkplain #lookupClass() lookup class} as if calling
1640          * {@link ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
1641          * ClassLoader::defineClass}.
1642          *
1643          * &lt;p&gt; The {@linkplain #lookupModes() lookup modes} for this lookup must include
1644          * {@link #PACKAGE PACKAGE} access as default (package) members will be
1645          * accessible to the class. The {@code PACKAGE} lookup mode serves to authenticate
1646          * that the lookup object was created by a caller in the runtime package (or derived
1647          * from a lookup originally created by suitably privileged code to a target class in
1648          * the runtime package). &lt;/p&gt;
1649          *
1650          * &lt;p&gt; The {@code bytes} parameter is the class bytes of a valid class file (as defined
1651          * by the &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;) with a class name in the
1652          * same package as the lookup class. &lt;/p&gt;
1653          *
1654          * &lt;p&gt; This method does not run the class initializer. The class initializer may
1655          * run at a later time, as detailed in section 12.4 of the &lt;em&gt;The Java Language
1656          * Specification&lt;/em&gt;. &lt;/p&gt;
1657          *
1658          * &lt;p&gt; If there is a security manager and this lookup does not have {@linkplain
1659          * #hasFullPrivilegeAccess() full privilege access}, its {@code checkPermission} method
1660          * is first called to check {@code RuntimePermission(&quot;defineClass&quot;)}. &lt;/p&gt;
1661          *
1662          * @param bytes the class bytes
1663          * @return the {@code Class} object for the class
1664          * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access
1665          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure
1666          * @throws IllegalArgumentException if {@code bytes} denotes a class in a different package
1667          * than the lookup class or {@code bytes} is not a class or interface
1668          * ({@code ACC_MODULE} flag is set in the value of the {@code access_flags} item)
1669          * @throws VerifyError if the newly created class cannot be verified
1670          * @throws LinkageError if the newly created class cannot be linked for any other reason
1671          * @throws SecurityException if a security manager is present and it
1672          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1673          * @throws NullPointerException if {@code bytes} is {@code null}
1674          * @since 9
1675          * @spec JPMS
1676          * @see Lookup#privateLookupIn
1677          * @see Lookup#dropLookupMode
1678          * @see ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
1679          */
1680         public Class&lt;?&gt; defineClass(byte[] bytes) throws IllegalAccessException {
1681             ensureDefineClassPermission();
1682             if ((lookupModes() &amp; PACKAGE) == 0)
1683                 throw new IllegalAccessException(&quot;Lookup does not have PACKAGE access&quot;);
1684             return makeClassDefiner(bytes.clone()).defineClass(false);
1685         }
1686 
1687         private void ensureDefineClassPermission() {
1688             if (allowedModes == TRUSTED)  return;
1689 
1690             if (!hasFullPrivilegeAccess()) {
1691                 SecurityManager sm = System.getSecurityManager();
1692                 if (sm != null)
1693                     sm.checkPermission(new RuntimePermission(&quot;defineClass&quot;));
1694             }
1695         }
1696 
1697         /**
1698          * The set of class options that specify whether a hidden class created by
1699          * {@link Lookup#defineHiddenClass(byte[], boolean, ClassOption...)
1700          * Lookup::defineHiddenClass} method is dynamically added as a new member
1701          * to the nest of a lookup class and/or whether a hidden class has
1702          * a strong relationship with the class loader marked as its defining loader.
1703          *
1704          * @since 15
1705          */
1706         public enum ClassOption {
1707             /**
1708              * Specifies that a hidden class be added to {@linkplain Class#getNestHost nest}
1709              * of a lookup class as a nestmate.
1710              *
1711              * &lt;p&gt; A hidden nestmate class has access to the private members of all
1712              * classes and interfaces in the same nest.
1713              *
1714              * @see Class#getNestHost()
1715              */
1716             NESTMATE(NESTMATE_CLASS),
1717 
1718             /**
1719              * Specifies that a hidden class has a &lt;em&gt;strong&lt;/em&gt;
1720              * relationship with the class loader marked as its defining loader,
1721              * as a normal class or interface has with its own defining loader.
1722              * This means that the hidden class may be unloaded if and only if
1723              * its defining loader is not reachable and thus may be reclaimed
1724              * by a garbage collector (JLS 12.7).
1725              *
1726              * &lt;p&gt; By default, a hidden class or interface may be unloaded
1727              * even if the class loader that is marked as its defining loader is
1728              * &lt;a href=&quot;../ref/package.html#reachability&quot;&gt;reachable&lt;/a&gt;.
1729 
1730              *
1731              * @jls 12.7 Unloading of Classes and Interfaces
1732              */
1733             STRONG(STRONG_LOADER_LINK);
1734 
1735             /* the flag value is used by VM at define class time */
1736             private final int flag;
1737             ClassOption(int flag) {
1738                 this.flag = flag;
1739             }
1740 
1741             static int optionsToFlag(Set&lt;ClassOption&gt; options) {
1742                 int flags = 0;
1743                 for (ClassOption cp : options) {
1744                     flags |= cp.flag;
1745                 }
1746                 return flags;
1747             }
1748         }
1749 
1750         /**
1751          * Creates a &lt;em&gt;hidden&lt;/em&gt; class or interface from {@code bytes},
1752          * returning a {@code Lookup} on the newly created class or interface.
1753          *
1754          * &lt;p&gt; Ordinarily, a class or interface {@code C} is created by a class loader,
1755          * which either defines {@code C} directly or delegates to another class loader.
1756          * A class loader defines {@code C} directly by invoking
1757          * {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)
1758          * ClassLoader::defineClass}, which causes the Java Virtual Machine
1759          * to derive {@code C} from a purported representation in {@code class} file format.
1760          * In situations where use of a class loader is undesirable, a class or interface
1761          * {@code C} can be created by this method instead. This method is capable of
1762          * defining {@code C}, and thereby creating it, without invoking
1763          * {@code ClassLoader::defineClass}.
1764          * Instead, this method defines {@code C} as if by arranging for
1765          * the Java Virtual Machine to derive a nonarray class or interface {@code C}
1766          * from a purported representation in {@code class} file format
1767          * using the following rules:
1768          *
1769          * &lt;ol&gt;
1770          * &lt;li&gt; The {@linkplain #lookupModes() lookup modes} for this {@code Lookup}
1771          * must include {@linkplain #hasFullPrivilegeAccess() full privilege} access.
1772          * This level of access is needed to create {@code C} in the module
1773          * of the lookup class of this {@code Lookup}.&lt;/li&gt;
1774          *
1775          * &lt;li&gt; The purported representation in {@code bytes} must be a {@code ClassFile}
1776          * structure of a supported major and minor version. The major and minor version
1777          * may differ from the {@code class} file version of the lookup class of this
1778          * {@code Lookup}.&lt;/li&gt;
1779          *
1780          * &lt;li&gt; The value of {@code this_class} must be a valid index in the
1781          * {@code constant_pool} table, and the entry at that index must be a valid
1782          * {@code CONSTANT_Class_info} structure. Let {@code N} be the binary name
1783          * encoded in internal form that is specified by this structure. {@code N} must
1784          * denote a class or interface in the same package as the lookup class.&lt;/li&gt;
1785          *
1786          * &lt;li&gt; Let {@code CN} be the string {@code N + &quot;.&quot; + &lt;suffix&gt;},
1787          * where {@code &lt;suffix&gt;} is an unqualified name.
1788          *
1789          * &lt;p&gt; Let {@code newBytes} be the {@code ClassFile} structure given by
1790          * {@code bytes} with an additional entry in the {@code constant_pool} table,
1791          * indicating a {@code CONSTANT_Utf8_info} structure for {@code CN}, and
1792          * where the {@code CONSTANT_Class_info} structure indicated by {@code this_class}
1793          * refers to the new {@code CONSTANT_Utf8_info} structure.
1794          *
1795          * &lt;p&gt; Let {@code L} be the defining class loader of the lookup class of this {@code Lookup}.
1796          *
1797          * &lt;p&gt; {@code C} is derived with name {@code CN}, class loader {@code L}, and
1798          * purported representation {@code newBytes} as if by the rules of JVMS {@jvms 5.3.5},
1799          * with the following adjustments:
1800          * &lt;ul&gt;
1801          * &lt;li&gt; The constant indicated by {@code this_class} is permitted to specify a name
1802          * that includes a single {@code &quot;.&quot;} character, even though this is not a valid
1803          * binary class or interface name in internal form.&lt;/li&gt;
1804          *
1805          * &lt;li&gt; The Java Virtual Machine marks {@code L} as the defining class loader of {@code C},
1806          * but no class loader is recorded as an initiating class loader of {@code C}.&lt;/li&gt;
1807          *
1808          * &lt;li&gt; {@code C} is considered to have the same runtime
1809          * {@linkplain Class#getPackage() package}, {@linkplain Class#getModule() module}
1810          * and {@linkplain java.security.ProtectionDomain protection domain}
1811          * as the lookup class of this {@code Lookup}.
1812          * &lt;li&gt; Let {@code GN} be the binary name obtained by taking {@code N}
1813          * (a binary name encoded in internal form) and replacing ASCII forward slashes with
1814          * ASCII periods. For the instance of {@link java.lang.Class} representing {@code C}:
1815          * &lt;ul&gt;
1816          * &lt;li&gt; {@link Class#getName()} returns the string {@code GN + &quot;/&quot; + &lt;suffix&gt;},
1817          *      even though this is not a valid binary class or interface name.&lt;/li&gt;
1818          * &lt;li&gt; {@link Class#descriptorString()} returns the string
1819          *      {@code &quot;L&quot; + N + &quot;.&quot; + &lt;suffix&gt; + &quot;;&quot;},
1820          *      even though this is not a valid type descriptor name.&lt;/li&gt;
1821          * &lt;li&gt; {@link Class#describeConstable()} returns an empty optional as {@code C}
1822          *      cannot be described in {@linkplain java.lang.constant.ClassDesc nominal form}.&lt;/li&gt;
1823          * &lt;/ul&gt;
1824          * &lt;/ul&gt;
1825          * &lt;/li&gt;
1826          * &lt;/ol&gt;
1827          *
1828          * &lt;p&gt; After {@code C} is derived, it is linked by the Java Virtual Machine.
1829          * Linkage occurs as specified in JVMS {@jvms 5.4.3}, with the following adjustments:
1830          * &lt;ul&gt;
1831          * &lt;li&gt; During verification, whenever it is necessary to load the class named
1832          * {@code CN}, the attempt succeeds, producing class {@code C}. No request is
1833          * made of any class loader.&lt;/li&gt;
1834          *
1835          * &lt;li&gt; On any attempt to resolve the entry in the run-time constant pool indicated
1836          * by {@code this_class}, the symbolic reference is considered to be resolved to
1837          * {@code C} and resolution always succeeds immediately.&lt;/li&gt;
1838          * &lt;/ul&gt;
1839          *
1840          * &lt;p&gt; If the {@code initialize} parameter is {@code true},
1841          * then {@code C} is initialized by the Java Virtual Machine.
1842          *
1843          * &lt;p&gt; The newly created class or interface {@code C} serves as the
1844          * {@linkplain #lookupClass() lookup class} of the {@code Lookup} object
1845          * returned by this method. {@code C} is &lt;em&gt;hidden&lt;/em&gt; in the sense that
1846          * no other class or interface can refer to {@code C} via a constant pool entry.
1847          * That is, a hidden class or interface cannot be named as a supertype, a field type,
1848          * a method parameter type, or a method return type by any other class.
1849          * This is because a hidden class or interface does not have a binary name, so
1850          * there is no internal form available to record in any class&#39;s constant pool.
1851          * A hidden class or interface is not discoverable by {@link Class#forName(String, boolean, ClassLoader)},
1852          * {@link ClassLoader#loadClass(String, boolean)}, or {@link #findClass(String)}, and
1853          * is not {@linkplain java.lang.instrument.Instrumentation#isModifiableClass(Class)
1854          * modifiable} by Java agents or tool agents using the &lt;a href=&quot;{@docRoot}/../specs/jvmti.html&quot;&gt;
1855          * JVM Tool Interface&lt;/a&gt;.
1856          *
1857          * &lt;p&gt; A class or interface created by
1858          * {@linkplain ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)
1859          * a class loader} has a strong relationship with that class loader.
1860          * That is, every {@code Class} object contains a reference to the {@code ClassLoader}
1861          * that {@linkplain Class#getClassLoader() defined it}.
1862          * This means that a class created by a class loader may be unloaded if and
1863          * only if its defining loader is not reachable and thus may be reclaimed
1864          * by a garbage collector (JLS 12.7).
1865          *
1866          * By default, however, a hidden class or interface may be unloaded even if
1867          * the class loader that is marked as its defining loader is
1868          * &lt;a href=&quot;../ref/package.html#reachability&quot;&gt;reachable&lt;/a&gt;.
1869          * This behavior is useful when a hidden class or interface serves multiple
1870          * classes defined by arbitrary class loaders.  In other cases, a hidden
1871          * class or interface may be linked to a single class (or a small number of classes)
1872          * with the same defining loader as the hidden class or interface.
1873          * In such cases, where the hidden class or interface must be coterminous
1874          * with a normal class or interface, the {@link ClassOption#STRONG STRONG}
1875          * option may be passed in {@code options}.
1876          * This arranges for a hidden class to have the same strong relationship
1877          * with the class loader marked as its defining loader,
1878          * as a normal class or interface has with its own defining loader.
1879          *
1880          * If {@code STRONG} is not used, then the invoker of {@code defineHiddenClass}
1881          * may still prevent a hidden class or interface from being
1882          * unloaded by ensuring that the {@code Class} object is reachable.
1883          *
1884          * &lt;p&gt; The unloading characteristics are set for each hidden class when it is
1885          * defined, and cannot be changed later.  An advantage of allowing hidden classes
1886          * to be unloaded independently of the class loader marked as their defining loader
1887          * is that a very large number of hidden classes may be created by an application.
1888          * In contrast, if {@code STRONG} is used, then the JVM may run out of memory,
1889          * just as if normal classes were created by class loaders.
1890          *
1891          * &lt;p&gt; Classes and interfaces in a nest are allowed to have mutual access to
1892          * their private members.  The nest relationship is determined by
1893          * the {@code NestHost} attribute (JVMS {@jvms 4.7.28}) and
1894          * the {@code NestMembers} attribute (JVMS {@jvms 4.7.29}) in a {@code class} file.
1895          * By default, a hidden class belongs to a nest consisting only of itself
1896          * because a hidden class has no binary name.
1897          * The {@link ClassOption#NESTMATE NESTMATE} option can be passed in {@code options}
1898          * to create a hidden class or interface {@code C} as a member of a nest.
1899          * The nest to which {@code C} belongs is not based on any {@code NestHost} attribute
1900          * in the {@code ClassFile} structure from which {@code C} was derived.
1901          * Instead, the following rules determine the nest host of {@code C}:
1902          * &lt;ul&gt;
1903          * &lt;li&gt;If the nest host of the lookup class of this {@code Lookup} has previously
1904          *     been determined, then let {@code H} be the nest host of the lookup class.
1905          *     Otherwise, the nest host of the lookup class is determined using the
1906          *     algorithm in JVMS {@jvms 5.4.4}, yielding {@code H}.&lt;/li&gt;
1907          * &lt;li&gt;The nest host of {@code C} is determined to be {@code H},
1908          *     the nest host of the lookup class.&lt;/li&gt;
1909          * &lt;/ul&gt;
1910          *
1911          * &lt;p&gt; A hidden class or interface may be serializable, but this requires a custom
1912          * serialization mechanism in order to ensure that instances are properly serialized
1913          * and deserialized. The default serialization mechanism supports only classes and
1914          * interfaces that are discoverable by their class name.
1915          *
1916          * @param bytes the bytes that make up the class data,
1917          * in the format of a valid {@code class} file as defined by
1918          * &lt;cite&gt;The Java Virtual Machine Specification&lt;/cite&gt;.
1919          * @param initialize if {@code true} the class will be initialized.
1920          * @param options {@linkplain ClassOption class options}
1921          * @return the {@code Lookup} object on the hidden class
1922          *
1923          * @throws IllegalAccessException if this {@code Lookup} does not have
1924          * {@linkplain #hasFullPrivilegeAccess() full privilege} access
1925          * @throws SecurityException if a security manager is present and it
1926          * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1927          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure
1928          * @throws UnsupportedClassVersionError if {@code bytes} is not of a supported major or minor version
1929          * @throws IllegalArgumentException if {@code bytes} denotes a class in a different package
1930          * than the lookup class or {@code bytes} is not a class or interface
1931          * ({@code ACC_MODULE} flag is set in the value of the {@code access_flags} item)
1932          * @throws IncompatibleClassChangeError if the class or interface named as
1933          * the direct superclass of {@code C} is in fact an interface, or if any of the classes
1934          * or interfaces named as direct superinterfaces of {@code C} are not in fact interfaces
1935          * @throws ClassCircularityError if any of the superclasses or superinterfaces of
1936          * {@code C} is {@code C} itself
1937          * @throws VerifyError if the newly created class cannot be verified
1938          * @throws LinkageError if the newly created class cannot be linked for any other reason
1939          * @throws NullPointerException if any parameter is {@code null}
1940          *
1941          * @since 15
1942          * @see Class#isHidden()
1943          * @jvms 4.2.1 Binary Class and Interface Names
1944          * @jvms 4.2.2 Unqualified Names
1945          * @jvms 4.7.28 The {@code NestHost} Attribute
1946          * @jvms 4.7.29 The {@code NestMembers} Attribute
1947          * @jvms 5.4.3.1 Class and Interface Resolution
1948          * @jvms 5.4.4 Access Control
1949          * @jvms 5.3.5 Deriving a {@code Class} from a {@code class} File Representation
1950          * @jvms 5.4 Linking
1951          * @jvms 5.5 Initialization
1952          * @jls 12.7 Unloading of Classes and Interfaces
1953          */
1954         public Lookup defineHiddenClass(byte[] bytes, boolean initialize, ClassOption... options)
1955                 throws IllegalAccessException
1956         {
1957             Objects.requireNonNull(bytes);
1958             Objects.requireNonNull(options);
1959 
1960             ensureDefineClassPermission();
1961             if (!hasFullPrivilegeAccess()) {
1962                 throw new IllegalAccessException(this + &quot; does not have full privilege access&quot;);
1963             }
1964 
1965             return makeHiddenClassDefiner(bytes.clone(), Set.of(options), false).defineClassAsLookup(initialize);
1966         }
1967 
1968         /**
1969          * Creates a &lt;em&gt;hidden&lt;/em&gt; class or interface from {@code bytes} with associated
1970          * {@linkplain MethodHandles#classData(Lookup, String, Class) class data},
1971          * returning a {@code Lookup} on the newly created class or interface.
1972          *
1973          * &lt;p&gt; This method is equivalent to calling
1974          * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass(bytes, true, options)}
1975          * as if the hidden class has a private static final unnamed field whose value
1976          * is initialized to {@code classData} right before the class initializer is
1977          * executed.  The newly created class is linked and initialized by the Java
1978          * Virtual Machine.
1979          *
1980          * &lt;p&gt; The {@link MethodHandles#classData(Lookup, String, Class) MethodHandles::classData}
1981          * method can be used to retrieve the {@code classData}.
1982          *
1983          * @param bytes     the class bytes
1984          * @param classData pre-initialized class data
1985          * @param options   {@linkplain ClassOption class options}
1986          * @return the {@code Lookup} object on the hidden class
1987          *
1988          * @throws IllegalAccessException if this {@code Lookup} does not have
1989          * {@linkplain #hasFullPrivilegeAccess() full privilege} access
1990          * @throws SecurityException if a security manager is present and it
1991          * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1992          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure
1993          * @throws UnsupportedClassVersionError if {@code bytes} is not of a supported major or minor version
1994          * @throws IllegalArgumentException if {@code bytes} denotes a class in a different package
1995          * than the lookup class or {@code bytes} is not a class or interface
1996          * ({@code ACC_MODULE} flag is set in the value of the {@code access_flags} item)
1997          * @throws IncompatibleClassChangeError if the class or interface named as
1998          * the direct superclass of {@code C} is in fact an interface, or if any of the classes
1999          * or interfaces named as direct superinterfaces of {@code C} are not in fact interfaces
2000          * @throws ClassCircularityError if any of the superclasses or superinterfaces of
2001          * {@code C} is {@code C} itself
2002          * @throws VerifyError if the newly created class cannot be verified
2003          * @throws LinkageError if the newly created class cannot be linked for any other reason
2004          * @throws NullPointerException if any parameter is {@code null}
2005          *
2006          * @since 15
2007          * @see Lookup#defineHiddenClass(byte[], boolean, ClassOption...)
2008          * @see Class#isHidden()
2009          */
2010         /* package-private */ Lookup defineHiddenClassWithClassData(byte[] bytes, Object classData, ClassOption... options)
2011                 throws IllegalAccessException
2012         {
2013             Objects.requireNonNull(bytes);
2014             Objects.requireNonNull(classData);
2015             Objects.requireNonNull(options);
2016 
2017             ensureDefineClassPermission();
2018             if (!hasFullPrivilegeAccess()) {
2019                 throw new IllegalAccessException(this + &quot; does not have full privilege access&quot;);
2020             }
2021 
2022             return makeHiddenClassDefiner(bytes.clone(), Set.of(options), false)
2023                        .defineClassAsLookup(true, classData);
2024         }
2025 
2026         static class ClassFile {
2027             final String name;
2028             final int accessFlags;
2029             final byte[] bytes;
2030             ClassFile(String name, int accessFlags, byte[] bytes) {
2031                 this.name = name;
2032                 this.accessFlags = accessFlags;
2033                 this.bytes = bytes;
2034             }
2035 
2036             static ClassFile newInstanceNoCheck(String name, byte[] bytes) {
2037                 return new ClassFile(name, 0, bytes);
2038             }
2039 
2040             /**
2041              * This method checks the class file version and the structure of `this_class`.
2042              * and checks if the bytes is a class or interface (ACC_MODULE flag not set)
2043              * that is in the named package.
2044              *
2045              * @throws IllegalArgumentException if ACC_MODULE flag is set in access flags
2046              * or the class is not in the given package name.
2047              */
2048             static ClassFile newInstance(byte[] bytes, String pkgName) {
2049                 int magic = readInt(bytes, 0);
2050                 if (magic != 0xCAFEBABE) {
2051                     throw new ClassFormatError(&quot;Incompatible magic value: &quot; + magic);
2052                 }
2053                 int minor = readUnsignedShort(bytes, 4);
2054                 int major = readUnsignedShort(bytes, 6);
2055                 if (!VM.isSupportedClassFileVersion(major, minor)) {
2056                     throw new UnsupportedClassVersionError(&quot;Unsupported class file version &quot; + major + &quot;.&quot; + minor);
2057                 }
2058 
2059                 String name;
2060                 int accessFlags;
2061                 try {
2062                     ClassReader reader = new ClassReader(bytes);
2063                     // ClassReader::getClassName does not check if `this_class` is CONSTANT_Class_info
2064                     // workaround to read `this_class` using readConst and validate the value
2065                     int thisClass = reader.readUnsignedShort(reader.header + 2);
2066                     Object constant = reader.readConst(thisClass, new char[reader.getMaxStringLength()]);
2067                     if (!(constant instanceof Type)) {
2068                         throw new ClassFormatError(&quot;this_class item: #&quot; + thisClass + &quot; not a CONSTANT_Class_info&quot;);
2069                     }
2070                     Type type = ((Type) constant);
2071                     if (!type.getDescriptor().startsWith(&quot;L&quot;)) {
2072                         throw new ClassFormatError(&quot;this_class item: #&quot; + thisClass + &quot; not a CONSTANT_Class_info&quot;);
2073                     }
2074                     name = type.getClassName();
2075                     accessFlags = reader.readUnsignedShort(reader.header);
2076                 } catch (RuntimeException e) {
2077                     // ASM exceptions are poorly specified
2078                     ClassFormatError cfe = new ClassFormatError();
2079                     cfe.initCause(e);
2080                     throw cfe;
2081                 }
2082 
2083                 // must be a class or interface
2084                 if ((accessFlags &amp; Opcodes.ACC_MODULE) != 0) {
2085                     throw newIllegalArgumentException(&quot;Not a class or interface: ACC_MODULE flag is set&quot;);
2086                 }
2087 
2088                 // check if it&#39;s in the named package
2089                 int index = name.lastIndexOf(&#39;.&#39;);
2090                 String pn = (index == -1) ? &quot;&quot; : name.substring(0, index);
2091                 if (!pn.equals(pkgName)) {
2092                     throw newIllegalArgumentException(name + &quot; not in same package as lookup class&quot;);
2093                 }
2094 
2095                 return new ClassFile(name, accessFlags, bytes);
2096             }
2097 
2098             private static int readInt(byte[] bytes, int offset) {
2099                 if ((offset+4) &gt; bytes.length) {
2100                     throw new ClassFormatError(&quot;Invalid ClassFile structure&quot;);
2101                 }
2102                 return ((bytes[offset] &amp; 0xFF) &lt;&lt; 24)
2103                         | ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16)
2104                         | ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8)
2105                         | (bytes[offset + 3] &amp; 0xFF);
2106             }
2107 
2108             private static int readUnsignedShort(byte[] bytes, int offset) {
2109                 if ((offset+2) &gt; bytes.length) {
2110                     throw new ClassFormatError(&quot;Invalid ClassFile structure&quot;);
2111                 }
2112                 return ((bytes[offset] &amp; 0xFF) &lt;&lt; 8) | (bytes[offset + 1] &amp; 0xFF);
2113             }
2114         }
2115 
2116         /*
2117          * Returns a ClassDefiner that creates a {@code Class} object of a normal class
2118          * from the given bytes.
2119          *
2120          * Caller should make a defensive copy of the arguments if needed
2121          * before calling this factory method.
2122          *
2123          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
2124          * {@bytes} denotes a class in a different package than the lookup class
2125          */
2126         private ClassDefiner makeClassDefiner(byte[] bytes) {
2127             ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());
2128             return new ClassDefiner(this, cf, STRONG_LOADER_LINK);
2129         }
2130 
2131         /**
2132          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
2133          * from the given bytes.  The name must be in the same package as the lookup class.
2134          *
2135          * Caller should make a defensive copy of the arguments if needed
2136          * before calling this factory method.
2137          *
2138          * @param bytes   class bytes
2139          * @return ClassDefiner that defines a hidden class of the given bytes.
2140          *
2141          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
2142          * {@bytes} denotes a class in a different package than the lookup class
2143          */
2144         ClassDefiner makeHiddenClassDefiner(byte[] bytes) {
2145             ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());
2146             return makeHiddenClassDefiner(cf, Set.of(), false);
2147         }
2148 
2149         /**
2150          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
2151          * from the given bytes and options.
2152          * The name must be in the same package as the lookup class.
2153          *
2154          * Caller should make a defensive copy of the arguments if needed
2155          * before calling this factory method.
2156          *
2157          * @param bytes   class bytes
2158          * @param options class options
2159          * @param accessVmAnnotations true to give the hidden class access to VM annotations
2160          * @return ClassDefiner that defines a hidden class of the given bytes and options
2161          *
2162          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
2163          * {@bytes} denotes a class in a different package than the lookup class
2164          */
2165         ClassDefiner makeHiddenClassDefiner(byte[] bytes,
2166                                             Set&lt;ClassOption&gt; options,
2167                                             boolean accessVmAnnotations) {
2168             ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());
2169             return makeHiddenClassDefiner(cf, options, accessVmAnnotations);
2170         }
2171 
2172         /**
2173          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
2174          * from the given bytes.  No package name check on the given name.
2175          *
2176          * @param name    fully-qualified name that specifies the prefix of the hidden class
2177          * @param bytes   class bytes
2178          * @return ClassDefiner that defines a hidden class of the given bytes.
2179          */
2180         ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes) {
2181             // skip name and access flags validation
2182             return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), Set.of(), false);
2183         }
2184 
2185         /**
2186          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
2187          * from the given class file and options.
2188          *
2189          * @param cf ClassFile
2190          * @param options class options
2191          * @param accessVmAnnotations true to give the hidden class access to VM annotations
2192          */
2193         private ClassDefiner makeHiddenClassDefiner(ClassFile cf,
2194                                                     Set&lt;ClassOption&gt; options,
2195                                                     boolean accessVmAnnotations) {
2196             int flags = HIDDEN_CLASS | ClassOption.optionsToFlag(options);
2197             if (accessVmAnnotations | VM.isSystemDomainLoader(lookupClass.getClassLoader())) {
2198                 // jdk.internal.vm.annotations are permitted for classes
2199                 // defined to boot loader and platform loader
2200                 flags |= ACCESS_VM_ANNOTATIONS;
2201             }
2202 
2203             return new ClassDefiner(this, cf, flags);
2204         }
2205 
2206         static class ClassDefiner {
2207             private final Lookup lookup;
2208             private final String name;
2209             private final byte[] bytes;
2210             private final int classFlags;
2211 
2212             private ClassDefiner(Lookup lookup, ClassFile cf, int flags) {
2213                 assert ((flags &amp; HIDDEN_CLASS) != 0 || (flags &amp; STRONG_LOADER_LINK) == STRONG_LOADER_LINK);
2214                 this.lookup = lookup;
2215                 this.bytes = cf.bytes;
2216                 this.name = cf.name;
2217                 this.classFlags = flags;
2218             }
2219 
2220             String className() {
2221                 return name;
2222             }
2223 
2224             Class&lt;?&gt; defineClass(boolean initialize) {
2225                 return defineClass(initialize, null);
2226             }
2227 
2228             Lookup defineClassAsLookup(boolean initialize) {
2229                 Class&lt;?&gt; c = defineClass(initialize, null);
2230                 return new Lookup(c, null, FULL_POWER_MODES);
2231             }
2232 
2233             /**
2234              * Defines the class of the given bytes and the given classData.
2235              * If {@code initialize} parameter is true, then the class will be initialized.
2236              *
2237              * @param initialize true if the class to be initialized
2238              * @param classData classData or null
2239              * @return the class
2240              *
2241              * @throws LinkageError linkage error
2242              */
2243             Class&lt;?&gt; defineClass(boolean initialize, Object classData) {
2244                 Class&lt;?&gt; lookupClass = lookup.lookupClass();
2245                 ClassLoader loader = lookupClass.getClassLoader();
2246                 ProtectionDomain pd = (loader != null) ? lookup.lookupClassProtectionDomain() : null;
2247                 Class&lt;?&gt; c = SharedSecrets.getJavaLangAccess()
2248                         .defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);
2249                 assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();
2250                 return c;
2251             }
2252 
2253             Lookup defineClassAsLookup(boolean initialize, Object classData) {
2254                 // initialize must be true if classData is non-null
2255                 assert classData == null || initialize == true;
2256                 Class&lt;?&gt; c = defineClass(initialize, classData);
2257                 return new Lookup(c, null, FULL_POWER_MODES);
2258             }
2259 
2260             private boolean isNestmate() {
2261                 return (classFlags &amp; NESTMATE_CLASS) != 0;
2262             }
2263         }
2264 
2265         private ProtectionDomain lookupClassProtectionDomain() {
2266             ProtectionDomain pd = cachedProtectionDomain;
2267             if (pd == null) {
2268                 cachedProtectionDomain = pd = SharedSecrets.getJavaLangAccess().protectionDomain(lookupClass);
2269             }
2270             return pd;
2271         }
2272 
2273         // cached protection domain
2274         private volatile ProtectionDomain cachedProtectionDomain;
2275 
2276         // Make sure outer class is initialized first.
2277         static { IMPL_NAMES.getClass(); }
2278 
2279         /** Package-private version of lookup which is trusted. */
2280         static final Lookup IMPL_LOOKUP = new Lookup(Object.class, null, TRUSTED);
2281 
2282         /** Version of lookup which is trusted minimally.
2283          *  It can only be used to create method handles to publicly accessible
2284          *  members in packages that are exported unconditionally.
2285          */
2286         static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, null, UNCONDITIONAL);
2287 
2288         private static void checkUnprivilegedlookupClass(Class&lt;?&gt; lookupClass) {
2289             String name = lookupClass.getName();
2290             if (name.startsWith(&quot;java.lang.invoke.&quot;))
2291                 throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+lookupClass);
2292         }
2293 
2294         /**
2295          * Displays the name of the class from which lookups are to be made,
2296          * followed by &quot;/&quot; and the name of the {@linkplain #previousLookupClass()
2297          * previous lookup class} if present.
2298          * (The name is the one reported by {@link java.lang.Class#getName() Class.getName}.)
2299          * If there are restrictions on the access permitted to this lookup,
2300          * this is indicated by adding a suffix to the class name, consisting
2301          * of a slash and a keyword.  The keyword represents the strongest
2302          * allowed access, and is chosen as follows:
2303          * &lt;ul&gt;
2304          * &lt;li&gt;If no access is allowed, the suffix is &quot;/noaccess&quot;.
2305          * &lt;li&gt;If only unconditional access is allowed, the suffix is &quot;/publicLookup&quot;.
2306          * &lt;li&gt;If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.
2307          * &lt;li&gt;If only public and module access are allowed, the suffix is &quot;/module&quot;.
2308          * &lt;li&gt;If public and package access are allowed, the suffix is &quot;/package&quot;.
2309          * &lt;li&gt;If public, package, and private access are allowed, the suffix is &quot;/private&quot;.
2310          * &lt;/ul&gt;
2311          * If none of the above cases apply, it is the case that full access
2312          * (public, module, package, private, and protected) is allowed.
2313          * In this case, no suffix is added.
2314          * This is true only of an object obtained originally from
2315          * {@link java.lang.invoke.MethodHandles#lookup MethodHandles.lookup}.
2316          * Objects created by {@link java.lang.invoke.MethodHandles.Lookup#in Lookup.in}
2317          * always have restricted access, and will display a suffix.
2318          * &lt;p&gt;
2319          * (It may seem strange that protected access should be
2320          * stronger than private access.  Viewed independently from
2321          * package access, protected access is the first to be lost,
2322          * because it requires a direct subclass relationship between
2323          * caller and callee.)
2324          * @see #in
2325          *
2326          * @revised 9
2327          * @spec JPMS
2328          */
2329         @Override
2330         public String toString() {
2331             String cname = lookupClass.getName();
2332             if (prevLookupClass != null)
2333                 cname += &quot;/&quot; + prevLookupClass.getName();
2334             switch (allowedModes) {
2335             case 0:  // no privileges
2336                 return cname + &quot;/noaccess&quot;;
2337             case UNCONDITIONAL:
2338                 return cname + &quot;/publicLookup&quot;;
2339             case PUBLIC:
2340                 return cname + &quot;/public&quot;;
2341             case PUBLIC|MODULE:
2342                 return cname + &quot;/module&quot;;
2343             case PUBLIC|PACKAGE:
2344             case PUBLIC|MODULE|PACKAGE:
2345                 return cname + &quot;/package&quot;;
2346             case FULL_POWER_MODES &amp; (~PROTECTED):
2347             case FULL_POWER_MODES &amp; ~(PROTECTED|MODULE):
2348                 return cname + &quot;/private&quot;;
2349             case FULL_POWER_MODES:
2350             case FULL_POWER_MODES &amp; (~MODULE):
2351                 return cname;
2352             case TRUSTED:
2353                 return &quot;/trusted&quot;;  // internal only; not exported
2354             default:  // Should not happen, but it&#39;s a bitfield...
2355                 cname = cname + &quot;/&quot; + Integer.toHexString(allowedModes);
2356                 assert(false) : cname;
2357                 return cname;
2358             }
2359         }
2360 
2361         /**
2362          * Produces a method handle for a static method.
2363          * The type of the method handle will be that of the method.
2364          * (Since static methods do not take receivers, there is no
2365          * additional receiver argument inserted into the method handle type,
2366          * as there would be with {@link #findVirtual findVirtual} or {@link #findSpecial findSpecial}.)
2367          * The method and all its argument types must be accessible to the lookup object.
2368          * &lt;p&gt;
2369          * The returned method handle will have
2370          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
2371          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
2372          * &lt;p&gt;
2373          * If the returned method handle is invoked, the method&#39;s class will
2374          * be initialized, if it has not already been initialized.
2375          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2376          * &lt;blockquote&gt;&lt;pre&gt;{@code
2377 import static java.lang.invoke.MethodHandles.*;
2378 import static java.lang.invoke.MethodType.*;
2379 ...
2380 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
2381   &quot;asList&quot;, methodType(List.class, Object[].class));
2382 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
2383          * }&lt;/pre&gt;&lt;/blockquote&gt;
2384          * @param refc the class from which the method is accessed
2385          * @param name the name of the method
2386          * @param type the type of the method
2387          * @return the desired method handle
2388          * @throws NoSuchMethodException if the method does not exist
2389          * @throws IllegalAccessException if access checking fails,
2390          *                                or if the method is not {@code static},
2391          *                                or if the method&#39;s variable arity modifier bit
2392          *                                is set and {@code asVarargsCollector} fails
2393          * @throws    SecurityException if a security manager is present and it
2394          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2395          * @throws NullPointerException if any argument is null
2396          */
2397         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2398             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);
<a name="1" id="anc1"></a><span class="line-added">2399             // resolveOrFail could return a non-static &lt;init&gt; method if present</span>
<span class="line-added">2400             // detect and throw NSME before producing a MethodHandle</span>
<span class="line-added">2401             if (!method.isStatic() &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;)) {</span>
<span class="line-added">2402                 throw new NoSuchMethodException(&quot;illegal method name: &quot; + name);</span>
<span class="line-added">2403             }</span>
<span class="line-added">2404 </span>
2405             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));
2406         }
2407 
2408         /**
2409          * Produces a method handle for a virtual method.
2410          * The type of the method handle will be that of the method,
2411          * with the receiver type (usually {@code refc}) prepended.
2412          * The method and all its argument types must be accessible to the lookup object.
2413          * &lt;p&gt;
2414          * When called, the handle will treat the first argument as a receiver
2415          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
2416          * implementation to enter.
2417          * For private methods the named method in {@code refc} will be invoked on the receiver.
2418          * (The dispatching action is identical with that performed by an
2419          * {@code invokevirtual} or {@code invokeinterface} instruction.)
2420          * &lt;p&gt;
2421          * The first argument will be of type {@code refc} if the lookup
2422          * class has full privileges to access the member.  Otherwise
2423          * the member must be {@code protected} and the first argument
2424          * will be restricted in type to the lookup class.
2425          * &lt;p&gt;
2426          * The returned method handle will have
2427          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
2428          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
2429          * &lt;p&gt;
2430          * Because of the general &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;equivalence&lt;/a&gt; between {@code invokevirtual}
2431          * instructions and method handles produced by {@code findVirtual},
2432          * if the class is {@code MethodHandle} and the name string is
2433          * {@code invokeExact} or {@code invoke}, the resulting
2434          * method handle is equivalent to one produced by
2435          * {@link java.lang.invoke.MethodHandles#exactInvoker MethodHandles.exactInvoker} or
2436          * {@link java.lang.invoke.MethodHandles#invoker MethodHandles.invoker}
2437          * with the same {@code type} argument.
2438          * &lt;p&gt;
2439          * If the class is {@code VarHandle} and the name string corresponds to
2440          * the name of a signature-polymorphic access mode method, the resulting
2441          * method handle is equivalent to one produced by
2442          * {@link java.lang.invoke.MethodHandles#varHandleInvoker} with
2443          * the access mode corresponding to the name string and with the same
2444          * {@code type} arguments.
2445          * &lt;p&gt;
2446          * &lt;b&gt;Example:&lt;/b&gt;
2447          * &lt;blockquote&gt;&lt;pre&gt;{@code
2448 import static java.lang.invoke.MethodHandles.*;
2449 import static java.lang.invoke.MethodType.*;
2450 ...
2451 MethodHandle MH_concat = publicLookup().findVirtual(String.class,
2452   &quot;concat&quot;, methodType(String.class, String.class));
2453 MethodHandle MH_hashCode = publicLookup().findVirtual(Object.class,
2454   &quot;hashCode&quot;, methodType(int.class));
2455 MethodHandle MH_hashCode_String = publicLookup().findVirtual(String.class,
2456   &quot;hashCode&quot;, methodType(int.class));
2457 assertEquals(&quot;xy&quot;, (String) MH_concat.invokeExact(&quot;x&quot;, &quot;y&quot;));
2458 assertEquals(&quot;xy&quot;.hashCode(), (int) MH_hashCode.invokeExact((Object)&quot;xy&quot;));
2459 assertEquals(&quot;xy&quot;.hashCode(), (int) MH_hashCode_String.invokeExact(&quot;xy&quot;));
2460 // interface method:
2461 MethodHandle MH_subSequence = publicLookup().findVirtual(CharSequence.class,
2462   &quot;subSequence&quot;, methodType(CharSequence.class, int.class, int.class));
2463 assertEquals(&quot;def&quot;, MH_subSequence.invoke(&quot;abcdefghi&quot;, 3, 6).toString());
2464 // constructor &quot;internal method&quot; must be accessed differently:
2465 MethodType MT_newString = methodType(void.class); //()V for new String()
2466 try { assertEquals(&quot;impossible&quot;, lookup()
2467         .findVirtual(String.class, &quot;&lt;init&gt;&quot;, MT_newString));
2468  } catch (NoSuchMethodException ex) { } // OK
2469 MethodHandle MH_newString = publicLookup()
2470   .findConstructor(String.class, MT_newString);
2471 assertEquals(&quot;&quot;, (String) MH_newString.invokeExact());
2472          * }&lt;/pre&gt;&lt;/blockquote&gt;
2473          *
2474          * @param refc the class or interface from which the method is accessed
2475          * @param name the name of the method
2476          * @param type the type of the method, with the receiver argument omitted
2477          * @return the desired method handle
2478          * @throws NoSuchMethodException if the method does not exist
2479          * @throws IllegalAccessException if access checking fails,
2480          *                                or if the method is {@code static},
2481          *                                or if the method&#39;s variable arity modifier bit
2482          *                                is set and {@code asVarargsCollector} fails
2483          * @throws    SecurityException if a security manager is present and it
2484          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2485          * @throws NullPointerException if any argument is null
2486          */
2487         public MethodHandle findVirtual(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2488             if (refc == MethodHandle.class) {
2489                 MethodHandle mh = findVirtualForMH(name, type);
2490                 if (mh != null)  return mh;
2491             } else if (refc == VarHandle.class) {
2492                 MethodHandle mh = findVirtualForVH(name, type);
2493                 if (mh != null)  return mh;
2494             }
2495             byte refKind = (refc.isInterface() ? REF_invokeInterface : REF_invokeVirtual);
2496             MemberName method = resolveOrFail(refKind, refc, name, type);
2497             return getDirectMethod(refKind, refc, method, findBoundCallerLookup(method));
2498         }
2499         private MethodHandle findVirtualForMH(String name, MethodType type) {
2500             // these names require special lookups because of the implicit MethodType argument
2501             if (&quot;invoke&quot;.equals(name))
2502                 return invoker(type);
2503             if (&quot;invokeExact&quot;.equals(name))
2504                 return exactInvoker(type);
2505             assert(!MemberName.isMethodHandleInvokeName(name));
2506             return null;
2507         }
2508         private MethodHandle findVirtualForVH(String name, MethodType type) {
2509             try {
2510                 return varHandleInvoker(VarHandle.AccessMode.valueFromMethodName(name), type);
2511             } catch (IllegalArgumentException e) {
2512                 return null;
2513             }
2514         }
2515 
2516         /**
2517          * Produces a method handle which creates an object and initializes it, using
2518          * the constructor of the specified type.
2519          * The parameter types of the method handle will be those of the constructor,
2520          * while the return type will be a reference to the constructor&#39;s class.
2521          * The constructor and all its argument types must be accessible to the lookup object.
2522          * &lt;p&gt;
2523          * The requested type must have a return type of {@code void}.
2524          * (This is consistent with the JVM&#39;s treatment of constructor type descriptors.)
2525          * &lt;p&gt;
2526          * The returned method handle will have
2527          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
2528          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
2529          * &lt;p&gt;
2530          * If the returned method handle is invoked, the constructor&#39;s class will
2531          * be initialized, if it has not already been initialized.
2532          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2533          * &lt;blockquote&gt;&lt;pre&gt;{@code
2534 import static java.lang.invoke.MethodHandles.*;
2535 import static java.lang.invoke.MethodType.*;
2536 ...
2537 MethodHandle MH_newArrayList = publicLookup().findConstructor(
2538   ArrayList.class, methodType(void.class, Collection.class));
2539 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
2540 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
2541 assert(orig != copy);
2542 assertEquals(orig, copy);
2543 // a variable-arity constructor:
2544 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
2545   ProcessBuilder.class, methodType(void.class, String[].class));
2546 ProcessBuilder pb = (ProcessBuilder)
2547   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
2548 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
2549          * }&lt;/pre&gt;&lt;/blockquote&gt;
<a name="2" id="anc2"></a><span class="line-added">2550          *</span>
<span class="line-added">2551          * @apiNote</span>
<span class="line-added">2552          * This method does not find a static {@code &lt;init&gt;} factory method as it is invoked</span>
<span class="line-added">2553          * via {@code invokestatic} bytecode as opposed to {@code invokespecial} for an</span>
<span class="line-added">2554          * object constructor.  To look up static {@code &lt;init&gt;} factory method, use</span>
<span class="line-added">2555          * the {@link #findStatic(Class, String, MethodType) findStatic} method.</span>
<span class="line-added">2556          *</span>
2557          * @param refc the class or interface from which the method is accessed
2558          * @param type the type of the method, with the receiver argument omitted, and a void return type
2559          * @return the desired method handle
2560          * @throws NoSuchMethodException if the constructor does not exist
2561          * @throws IllegalAccessException if access checking fails
2562          *                                or if the method&#39;s variable arity modifier bit
2563          *                                is set and {@code asVarargsCollector} fails
2564          * @throws    SecurityException if a security manager is present and it
2565          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2566          * @throws NullPointerException if any argument is null
2567          */
2568         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2569             if (refc.isArray()) {
2570                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
2571             }
<a name="3" id="anc3"></a><span class="line-added">2572             if (type.returnType() != void.class) {</span>
<span class="line-added">2573                 throw new NoSuchMethodException(&quot;Constructors must have void return type: &quot; + refc.getName());</span>
<span class="line-added">2574             }</span>
2575             String name = &quot;&lt;init&gt;&quot;;
2576             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
2577             return getDirectConstructor(refc, ctor);
2578         }
2579 
2580         /**
2581          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,
2582          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.
2583          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,
2584          * and then determines whether the class is accessible to this lookup object.
2585          * &lt;p&gt;
2586          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2587          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2588          *
2589          * @param targetName the fully qualified name of the class to be looked up.
2590          * @return the requested class.
2591          * @throws SecurityException if a security manager is present and it
2592          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2593          * @throws LinkageError if the linkage fails
2594          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
2595          * @throws IllegalAccessException if the class is not accessible, using the allowed access
2596          * modes.
2597          * @since 9
2598          * @jvms 5.4.3.1 Class and Interface Resolution
2599          */
2600         public Class&lt;?&gt; findClass(String targetName) throws ClassNotFoundException, IllegalAccessException {
2601             Class&lt;?&gt; targetClass = Class.forName(targetName, false, lookupClass.getClassLoader());
2602             return accessClass(targetClass);
2603         }
2604 
2605         /**
2606          * Ensures that {@code targetClass} has been initialized. The class
2607          * to be initialized must be {@linkplain #accessClass accessible}
2608          * to this {@code Lookup} object.  This method causes {@code targetClass}
2609          * to be initialized if it has not been already initialized,
2610          * as specified in JVMS {@jvms 5.5}.
2611          *
2612          * @param targetClass the class to be initialized
2613          * @return {@code targetClass} that has been initialized
2614          *
2615          * @throws  IllegalArgumentException if {@code targetClass} is a primitive type or {@code void}
2616          *          or array class
2617          * @throws  IllegalAccessException if {@code targetClass} is not
2618          *          {@linkplain #accessClass accessible} to this lookup
2619          * @throws  ExceptionInInitializerError if the class initialization provoked
2620          *          by this method fails
2621          * @throws  SecurityException if a security manager is present and it
2622          *          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2623          * @since 15
2624          * @jvms 5.5 Initialization
2625          */
2626         public Class&lt;?&gt; ensureInitialized(Class&lt;?&gt; targetClass) throws IllegalAccessException {
2627             if (targetClass.isPrimitive())
2628                 throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);
2629             if (targetClass.isArray())
2630                 throw new IllegalArgumentException(targetClass + &quot; is an array class&quot;);
2631 
2632             if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, prevLookupClass, allowedModes)) {
2633                 throw makeAccessException(targetClass);
2634             }
2635             checkSecurityManager(targetClass);
2636 
2637             // ensure class initialization
2638             Unsafe.getUnsafe().ensureClassInitialized(targetClass);
2639             return targetClass;
2640         }
2641 
2642         /*
2643          * Returns IllegalAccessException due to access violation to the given targetClass.
2644          *
2645          * This method is called by {@link Lookup#accessClass} and {@link Lookup#ensureInitialized}
2646          * which verifies access to a class rather a member.
2647          */
2648         private IllegalAccessException makeAccessException(Class&lt;?&gt; targetClass) {
2649             String message = &quot;access violation: &quot;+ targetClass;
2650             if (this == MethodHandles.publicLookup()) {
2651                 message += &quot;, from public Lookup&quot;;
2652             } else {
2653                 Module m = lookupClass().getModule();
2654                 message += &quot;, from &quot; + lookupClass() + &quot; (&quot; + m + &quot;)&quot;;
2655                 if (prevLookupClass != null) {
2656                     message += &quot;, previous lookup &quot; +
2657                             prevLookupClass.getName() + &quot; (&quot; + prevLookupClass.getModule() + &quot;)&quot;;
2658                 }
2659             }
2660             return new IllegalAccessException(message);
2661         }
2662 
2663         /**
2664          * Determines if a class can be accessed from the lookup context defined by
2665          * this {@code Lookup} object. The static initializer of the class is not run.
2666          * &lt;p&gt;
2667          * If the {@code targetClass} is in the same module as the lookup class,
2668          * the lookup class is {@code LC} in module {@code M1} and
2669          * the previous lookup class is in module {@code M0} or
2670          * {@code null} if not present,
2671          * {@code targetClass} is accessible if and only if one of the following is true:
2672          * &lt;ul&gt;
2673          * &lt;li&gt;If this lookup has {@link #PRIVATE} access, {@code targetClass} is
2674          *     {@code LC} or other class in the same nest of {@code LC}.&lt;/li&gt;
2675          * &lt;li&gt;If this lookup has {@link #PACKAGE} access, {@code targetClass} is
2676          *     in the same runtime package of {@code LC}.&lt;/li&gt;
2677          * &lt;li&gt;If this lookup has {@link #MODULE} access, {@code targetClass} is
2678          *     a public type in {@code M1}.&lt;/li&gt;
2679          * &lt;li&gt;If this lookup has {@link #PUBLIC} access, {@code targetClass} is
2680          *     a public type in a package exported by {@code M1} to at least  {@code M0}
2681          *     if the previous lookup class is present; otherwise, {@code targetClass}
2682          *     is a public type in a package exported by {@code M1} unconditionally.&lt;/li&gt;
2683          * &lt;/ul&gt;
2684          *
2685          * &lt;p&gt;
2686          * Otherwise, if this lookup has {@link #UNCONDITIONAL} access, this lookup
2687          * can access public types in all modules when the type is in a package
2688          * that is exported unconditionally.
2689          * &lt;p&gt;
2690          * Otherwise, the target class is in a different module from {@code lookupClass},
2691          * and if this lookup does not have {@code PUBLIC} access, {@code lookupClass}
2692          * is inaccessible.
2693          * &lt;p&gt;
2694          * Otherwise, if this lookup has no {@linkplain #previousLookupClass() previous lookup class},
2695          * {@code M1} is the module containing {@code lookupClass} and
2696          * {@code M2} is the module containing {@code targetClass},
2697          * then {@code targetClass} is accessible if and only if
2698          * &lt;ul&gt;
2699          * &lt;li&gt;{@code M1} reads {@code M2}, and
2700          * &lt;li&gt;{@code targetClass} is public and in a package exported by
2701          *     {@code M2} at least to {@code M1}.
2702          * &lt;/ul&gt;
2703          * &lt;p&gt;
2704          * Otherwise, if this lookup has a {@linkplain #previousLookupClass() previous lookup class},
2705          * {@code M1} and {@code M2} are as before, and {@code M0} is the module
2706          * containing the previous lookup class, then {@code targetClass} is accessible
2707          * if and only if one of the following is true:
2708          * &lt;ul&gt;
2709          * &lt;li&gt;{@code targetClass} is in {@code M0} and {@code M1}
2710          *     {@linkplain Module#reads reads} {@code M0} and the type is
2711          *     in a package that is exported to at least {@code M1}.
2712          * &lt;li&gt;{@code targetClass} is in {@code M1} and {@code M0}
2713          *     {@linkplain Module#reads reads} {@code M1} and the type is
2714          *     in a package that is exported to at least {@code M0}.
2715          * &lt;li&gt;{@code targetClass} is in a third module {@code M2} and both {@code M0}
2716          *     and {@code M1} reads {@code M2} and the type is in a package
2717          *     that is exported to at least both {@code M0} and {@code M2}.
2718          * &lt;/ul&gt;
2719          * &lt;p&gt;
2720          * Otherwise, {@code targetClass} is not accessible.
2721          *
2722          * @param targetClass the class to be access-checked
2723          * @return the class that has been access-checked
2724          * @throws IllegalAccessException if the class is not accessible from the lookup class
2725          * and previous lookup class, if present, using the allowed access modes.
2726          * @throws    SecurityException if a security manager is present and it
2727          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2728          * @since 9
2729          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
2730          */
2731         public Class&lt;?&gt; accessClass(Class&lt;?&gt; targetClass) throws IllegalAccessException {
2732             if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, prevLookupClass, allowedModes)) {
2733                 throw makeAccessException(targetClass);
2734             }
2735             checkSecurityManager(targetClass);
2736             return targetClass;
2737         }
2738 
2739         /**
2740          * Produces an early-bound method handle for a virtual method.
2741          * It will bypass checks for overriding methods on the receiver,
2742          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if called&lt;/a&gt; from an {@code invokespecial}
2743          * instruction from within the explicitly specified {@code specialCaller}.
2744          * The type of the method handle will be that of the method,
2745          * with a suitably restricted receiver type prepended.
2746          * (The receiver type will be {@code specialCaller} or a subtype.)
2747          * The method and all its argument types must be accessible
2748          * to the lookup object.
2749          * &lt;p&gt;
2750          * Before method resolution,
2751          * if the explicitly specified caller class is not identical with the
2752          * lookup class, or if this lookup object does not have
2753          * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;
2754          * privileges, the access fails.
2755          * &lt;p&gt;
2756          * The returned method handle will have
2757          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
2758          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
2759          * &lt;p style=&quot;font-size:smaller;&quot;&gt;
2760          * &lt;em&gt;(Note:  JVM internal methods named {@code &quot;&lt;init&gt;&quot;} are not visible to this API,
2761          * even though the {@code invokespecial} instruction can refer to them
2762          * in special circumstances.  Use {@link #findConstructor findConstructor}
2763          * to access instance initialization methods in a safe manner.)&lt;/em&gt;
2764          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2765          * &lt;blockquote&gt;&lt;pre&gt;{@code
2766 import static java.lang.invoke.MethodHandles.*;
2767 import static java.lang.invoke.MethodType.*;
2768 ...
2769 static class Listie extends ArrayList {
2770   public String toString() { return &quot;[wee Listie]&quot;; }
2771   static Lookup lookup() { return MethodHandles.lookup(); }
2772 }
2773 ...
2774 // no access to constructor via invokeSpecial:
2775 MethodHandle MH_newListie = Listie.lookup()
2776   .findConstructor(Listie.class, methodType(void.class));
2777 Listie l = (Listie) MH_newListie.invokeExact();
2778 try { assertEquals(&quot;impossible&quot;, Listie.lookup().findSpecial(
2779         Listie.class, &quot;&lt;init&gt;&quot;, methodType(void.class), Listie.class));
2780  } catch (NoSuchMethodException ex) { } // OK
2781 // access to super and self methods via invokeSpecial:
2782 MethodHandle MH_super = Listie.lookup().findSpecial(
2783   ArrayList.class, &quot;toString&quot; , methodType(String.class), Listie.class);
2784 MethodHandle MH_this = Listie.lookup().findSpecial(
2785   Listie.class, &quot;toString&quot; , methodType(String.class), Listie.class);
2786 MethodHandle MH_duper = Listie.lookup().findSpecial(
2787   Object.class, &quot;toString&quot; , methodType(String.class), Listie.class);
2788 assertEquals(&quot;[]&quot;, (String) MH_super.invokeExact(l));
2789 assertEquals(&quot;&quot;+l, (String) MH_this.invokeExact(l));
2790 assertEquals(&quot;[]&quot;, (String) MH_duper.invokeExact(l)); // ArrayList method
2791 try { assertEquals(&quot;inaccessible&quot;, Listie.lookup().findSpecial(
2792         String.class, &quot;toString&quot;, methodType(String.class), Listie.class));
2793  } catch (IllegalAccessException ex) { } // OK
2794 Listie subl = new Listie() { public String toString() { return &quot;[subclass]&quot;; } };
2795 assertEquals(&quot;&quot;+l, (String) MH_this.invokeExact(subl)); // Listie method
2796          * }&lt;/pre&gt;&lt;/blockquote&gt;
2797          *
2798          * @param refc the class or interface from which the method is accessed
2799          * @param name the name of the method (which must not be &quot;&amp;lt;init&amp;gt;&quot;)
2800          * @param type the type of the method, with the receiver argument omitted
2801          * @param specialCaller the proposed calling class to perform the {@code invokespecial}
2802          * @return the desired method handle
2803          * @throws NoSuchMethodException if the method does not exist
2804          * @throws IllegalAccessException if access checking fails,
2805          *                                or if the method is {@code static},
2806          *                                or if the method&#39;s variable arity modifier bit
2807          *                                is set and {@code asVarargsCollector} fails
2808          * @throws    SecurityException if a security manager is present and it
2809          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2810          * @throws NullPointerException if any argument is null
2811          */
2812         public MethodHandle findSpecial(Class&lt;?&gt; refc, String name, MethodType type,
2813                                         Class&lt;?&gt; specialCaller) throws NoSuchMethodException, IllegalAccessException {
2814             checkSpecialCaller(specialCaller, refc);
2815             Lookup specialLookup = this.in(specialCaller);
2816             MemberName method = specialLookup.resolveOrFail(REF_invokeSpecial, refc, name, type);
2817             return specialLookup.getDirectMethod(REF_invokeSpecial, refc, method, findBoundCallerLookup(method));
2818         }
2819 
2820         /**
2821          * Produces a method handle giving read access to a non-static field.
2822          * The type of the method handle will have a return type of the field&#39;s
2823          * value type.
2824          * The method handle&#39;s single argument will be the instance containing
2825          * the field.
2826          * Access checking is performed immediately on behalf of the lookup class.
2827          * @param refc the class or interface from which the method is accessed
2828          * @param name the field&#39;s name
2829          * @param type the field&#39;s type
2830          * @return a method handle which can load values from the field
2831          * @throws NoSuchFieldException if the field does not exist
2832          * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
2833          * @throws    SecurityException if a security manager is present and it
2834          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2835          * @throws NullPointerException if any argument is null
2836          * @see #findVarHandle(Class, String, Class)
2837          */
2838         public MethodHandle findGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2839             MemberName field = resolveOrFail(REF_getField, refc, name, type);
2840             return getDirectField(REF_getField, refc, field);
2841         }
2842 
2843         /**
2844          * Produces a method handle giving write access to a non-static field.
2845          * The type of the method handle will have a void return type.
2846          * The method handle will take two arguments, the instance containing
2847          * the field, and the value to be stored.
2848          * The second argument will be of the field&#39;s value type.
2849          * Access checking is performed immediately on behalf of the lookup class.
2850          * @param refc the class or interface from which the method is accessed
2851          * @param name the field&#39;s name
2852          * @param type the field&#39;s type
2853          * @return a method handle which can store values into the field
2854          * @throws NoSuchFieldException if the field does not exist
2855          * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
2856          *                                or {@code final}
2857          * @throws    SecurityException if a security manager is present and it
2858          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2859          * @throws NullPointerException if any argument is null
2860          * @see #findVarHandle(Class, String, Class)
2861          */
2862         public MethodHandle findSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2863             MemberName field = resolveOrFail(REF_putField, refc, name, type);
2864             return getDirectField(REF_putField, refc, field);
2865         }
2866 
2867         /**
2868          * Produces a VarHandle giving access to a non-static field {@code name}
2869          * of type {@code type} declared in a class of type {@code recv}.
2870          * The VarHandle&#39;s variable type is {@code type} and it has one
2871          * coordinate type, {@code recv}.
2872          * &lt;p&gt;
2873          * Access checking is performed immediately on behalf of the lookup
2874          * class.
2875          * &lt;p&gt;
2876          * Certain access modes of the returned VarHandle are unsupported under
2877          * the following conditions:
2878          * &lt;ul&gt;
2879          * &lt;li&gt;if the field is declared {@code final}, then the write, atomic
2880          *     update, numeric atomic update, and bitwise atomic update access
2881          *     modes are unsupported.
2882          * &lt;li&gt;if the field type is anything other than {@code byte},
2883          *     {@code short}, {@code char}, {@code int}, {@code long},
2884          *     {@code float}, or {@code double} then numeric atomic update
2885          *     access modes are unsupported.
2886          * &lt;li&gt;if the field type is anything other than {@code boolean},
2887          *     {@code byte}, {@code short}, {@code char}, {@code int} or
2888          *     {@code long} then bitwise atomic update access modes are
2889          *     unsupported.
2890          * &lt;/ul&gt;
2891          * &lt;p&gt;
2892          * If the field is declared {@code volatile} then the returned VarHandle
2893          * will override access to the field (effectively ignore the
2894          * {@code volatile} declaration) in accordance to its specified
2895          * access modes.
2896          * &lt;p&gt;
2897          * If the field type is {@code float} or {@code double} then numeric
2898          * and atomic update access modes compare values using their bitwise
2899          * representation (see {@link Float#floatToRawIntBits} and
2900          * {@link Double#doubleToRawLongBits}, respectively).
2901          * @apiNote
2902          * Bitwise comparison of {@code float} values or {@code double} values,
2903          * as performed by the numeric and atomic update access modes, differ
2904          * from the primitive {@code ==} operator and the {@link Float#equals}
2905          * and {@link Double#equals} methods, specifically with respect to
2906          * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
2907          * Care should be taken when performing a compare and set or a compare
2908          * and exchange operation with such values since the operation may
2909          * unexpectedly fail.
2910          * There are many possible NaN values that are considered to be
2911          * {@code NaN} in Java, although no IEEE 754 floating-point operation
2912          * provided by Java can distinguish between them.  Operation failure can
2913          * occur if the expected or witness value is a NaN value and it is
2914          * transformed (perhaps in a platform specific manner) into another NaN
2915          * value, and thus has a different bitwise representation (see
2916          * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
2917          * details).
2918          * The values {@code -0.0} and {@code +0.0} have different bitwise
2919          * representations but are considered equal when using the primitive
2920          * {@code ==} operator.  Operation failure can occur if, for example, a
2921          * numeric algorithm computes an expected value to be say {@code -0.0}
2922          * and previously computed the witness value to be say {@code +0.0}.
2923          * @param recv the receiver class, of type {@code R}, that declares the
2924          * non-static field
2925          * @param name the field&#39;s name
2926          * @param type the field&#39;s type, of type {@code T}
2927          * @return a VarHandle giving access to non-static fields.
2928          * @throws NoSuchFieldException if the field does not exist
2929          * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
2930          * @throws    SecurityException if a security manager is present and it
2931          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2932          * @throws NullPointerException if any argument is null
2933          * @since 9
2934          */
2935         public VarHandle findVarHandle(Class&lt;?&gt; recv, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2936             MemberName getField = resolveOrFail(REF_getField, recv, name, type);
2937             MemberName putField = resolveOrFail(REF_putField, recv, name, type);
2938             return getFieldVarHandle(REF_getField, REF_putField, recv, getField, putField);
2939         }
2940 
2941         /**
2942          * Produces a method handle giving read access to a static field.
2943          * The type of the method handle will have a return type of the field&#39;s
2944          * value type.
2945          * The method handle will take no arguments.
2946          * Access checking is performed immediately on behalf of the lookup class.
2947          * &lt;p&gt;
2948          * If the returned method handle is invoked, the field&#39;s class will
2949          * be initialized, if it has not already been initialized.
2950          * @param refc the class or interface from which the method is accessed
2951          * @param name the field&#39;s name
2952          * @param type the field&#39;s type
2953          * @return a method handle which can load values from the field
2954          * @throws NoSuchFieldException if the field does not exist
2955          * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
2956          * @throws    SecurityException if a security manager is present and it
2957          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2958          * @throws NullPointerException if any argument is null
2959          */
2960         public MethodHandle findStaticGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2961             MemberName field = resolveOrFail(REF_getStatic, refc, name, type);
2962             return getDirectField(REF_getStatic, refc, field);
2963         }
2964 
2965         /**
2966          * Produces a method handle giving write access to a static field.
2967          * The type of the method handle will have a void return type.
2968          * The method handle will take a single
2969          * argument, of the field&#39;s value type, the value to be stored.
2970          * Access checking is performed immediately on behalf of the lookup class.
2971          * &lt;p&gt;
2972          * If the returned method handle is invoked, the field&#39;s class will
2973          * be initialized, if it has not already been initialized.
2974          * @param refc the class or interface from which the method is accessed
2975          * @param name the field&#39;s name
2976          * @param type the field&#39;s type
2977          * @return a method handle which can store values into the field
2978          * @throws NoSuchFieldException if the field does not exist
2979          * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
2980          *                                or is {@code final}
2981          * @throws    SecurityException if a security manager is present and it
2982          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2983          * @throws NullPointerException if any argument is null
2984          */
2985         public MethodHandle findStaticSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2986             MemberName field = resolveOrFail(REF_putStatic, refc, name, type);
2987             return getDirectField(REF_putStatic, refc, field);
2988         }
2989 
2990         /**
2991          * Produces a VarHandle giving access to a static field {@code name} of
2992          * type {@code type} declared in a class of type {@code decl}.
2993          * The VarHandle&#39;s variable type is {@code type} and it has no
2994          * coordinate types.
2995          * &lt;p&gt;
2996          * Access checking is performed immediately on behalf of the lookup
2997          * class.
2998          * &lt;p&gt;
2999          * If the returned VarHandle is operated on, the declaring class will be
3000          * initialized, if it has not already been initialized.
3001          * &lt;p&gt;
3002          * Certain access modes of the returned VarHandle are unsupported under
3003          * the following conditions:
3004          * &lt;ul&gt;
3005          * &lt;li&gt;if the field is declared {@code final}, then the write, atomic
3006          *     update, numeric atomic update, and bitwise atomic update access
3007          *     modes are unsupported.
3008          * &lt;li&gt;if the field type is anything other than {@code byte},
3009          *     {@code short}, {@code char}, {@code int}, {@code long},
3010          *     {@code float}, or {@code double}, then numeric atomic update
3011          *     access modes are unsupported.
3012          * &lt;li&gt;if the field type is anything other than {@code boolean},
3013          *     {@code byte}, {@code short}, {@code char}, {@code int} or
3014          *     {@code long} then bitwise atomic update access modes are
3015          *     unsupported.
3016          * &lt;/ul&gt;
3017          * &lt;p&gt;
3018          * If the field is declared {@code volatile} then the returned VarHandle
3019          * will override access to the field (effectively ignore the
3020          * {@code volatile} declaration) in accordance to its specified
3021          * access modes.
3022          * &lt;p&gt;
3023          * If the field type is {@code float} or {@code double} then numeric
3024          * and atomic update access modes compare values using their bitwise
3025          * representation (see {@link Float#floatToRawIntBits} and
3026          * {@link Double#doubleToRawLongBits}, respectively).
3027          * @apiNote
3028          * Bitwise comparison of {@code float} values or {@code double} values,
3029          * as performed by the numeric and atomic update access modes, differ
3030          * from the primitive {@code ==} operator and the {@link Float#equals}
3031          * and {@link Double#equals} methods, specifically with respect to
3032          * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
3033          * Care should be taken when performing a compare and set or a compare
3034          * and exchange operation with such values since the operation may
3035          * unexpectedly fail.
3036          * There are many possible NaN values that are considered to be
3037          * {@code NaN} in Java, although no IEEE 754 floating-point operation
3038          * provided by Java can distinguish between them.  Operation failure can
3039          * occur if the expected or witness value is a NaN value and it is
3040          * transformed (perhaps in a platform specific manner) into another NaN
3041          * value, and thus has a different bitwise representation (see
3042          * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
3043          * details).
3044          * The values {@code -0.0} and {@code +0.0} have different bitwise
3045          * representations but are considered equal when using the primitive
3046          * {@code ==} operator.  Operation failure can occur if, for example, a
3047          * numeric algorithm computes an expected value to be say {@code -0.0}
3048          * and previously computed the witness value to be say {@code +0.0}.
3049          * @param decl the class that declares the static field
3050          * @param name the field&#39;s name
3051          * @param type the field&#39;s type, of type {@code T}
3052          * @return a VarHandle giving access to a static field
3053          * @throws NoSuchFieldException if the field does not exist
3054          * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
3055          * @throws    SecurityException if a security manager is present and it
3056          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
3057          * @throws NullPointerException if any argument is null
3058          * @since 9
3059          */
3060         public VarHandle findStaticVarHandle(Class&lt;?&gt; decl, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
3061             MemberName getField = resolveOrFail(REF_getStatic, decl, name, type);
3062             MemberName putField = resolveOrFail(REF_putStatic, decl, name, type);
3063             return getFieldVarHandle(REF_getStatic, REF_putStatic, decl, getField, putField);
3064         }
3065 
3066         /**
3067          * Produces an early-bound method handle for a non-static method.
3068          * The receiver must have a supertype {@code defc} in which a method
3069          * of the given name and type is accessible to the lookup class.
3070          * The method and all its argument types must be accessible to the lookup object.
3071          * The type of the method handle will be that of the method,
3072          * without any insertion of an additional receiver parameter.
3073          * The given receiver will be bound into the method handle,
3074          * so that every call to the method handle will invoke the
3075          * requested method on the given receiver.
3076          * &lt;p&gt;
3077          * The returned method handle will have
3078          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3079          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set
3080          * &lt;em&gt;and&lt;/em&gt; the trailing array argument is not the only argument.
3081          * (If the trailing array argument is the only argument,
3082          * the given receiver value will be bound to it.)
3083          * &lt;p&gt;
3084          * This is almost equivalent to the following code, with some differences noted below:
3085          * &lt;blockquote&gt;&lt;pre&gt;{@code
3086 import static java.lang.invoke.MethodHandles.*;
3087 import static java.lang.invoke.MethodType.*;
3088 ...
3089 MethodHandle mh0 = lookup().findVirtual(defc, name, type);
3090 MethodHandle mh1 = mh0.bindTo(receiver);
3091 mh1 = mh1.withVarargs(mh0.isVarargsCollector());
3092 return mh1;
3093          * }&lt;/pre&gt;&lt;/blockquote&gt;
3094          * where {@code defc} is either {@code receiver.getClass()} or a super
3095          * type of that class, in which the requested method is accessible
3096          * to the lookup class.
3097          * (Unlike {@code bind}, {@code bindTo} does not preserve variable arity.
3098          * Also, {@code bindTo} may throw a {@code ClassCastException} in instances where {@code bind} would
3099          * throw an {@code IllegalAccessException}, as in the case where the member is {@code protected} and
3100          * the receiver is restricted by {@code findVirtual} to the lookup class.)
3101          * @param receiver the object from which the method is accessed
3102          * @param name the name of the method
3103          * @param type the type of the method, with the receiver argument omitted
3104          * @return the desired method handle
3105          * @throws NoSuchMethodException if the method does not exist
3106          * @throws IllegalAccessException if access checking fails
3107          *                                or if the method&#39;s variable arity modifier bit
3108          *                                is set and {@code asVarargsCollector} fails
3109          * @throws    SecurityException if a security manager is present and it
3110          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
3111          * @throws NullPointerException if any argument is null
3112          * @see MethodHandle#bindTo
3113          * @see #findVirtual
3114          */
3115         public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
3116             Class&lt;? extends Object&gt; refc = receiver.getClass(); // may get NPE
3117             MemberName method = resolveOrFail(REF_invokeSpecial, refc, name, type);
3118             MethodHandle mh = getDirectMethodNoRestrictInvokeSpecial(refc, method, findBoundCallerLookup(method));
3119             if (!mh.type().leadingReferenceParameter().isAssignableFrom(receiver.getClass())) {
3120                 throw new IllegalAccessException(&quot;The restricted defining class &quot; +
3121                                                  mh.type().leadingReferenceParameter().getName() +
3122                                                  &quot; is not assignable from receiver class &quot; +
3123                                                  receiver.getClass().getName());
3124             }
3125             return mh.bindArgumentL(0, receiver).setVarargs(method);
3126         }
3127 
3128         /**
3129          * Makes a &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;
3130          * to &lt;i&gt;m&lt;/i&gt;, if the lookup class has permission.
3131          * If &lt;i&gt;m&lt;/i&gt; is non-static, the receiver argument is treated as an initial argument.
3132          * If &lt;i&gt;m&lt;/i&gt; is virtual, overriding is respected on every call.
3133          * Unlike the Core Reflection API, exceptions are &lt;em&gt;not&lt;/em&gt; wrapped.
3134          * The type of the method handle will be that of the method,
3135          * with the receiver type prepended (but only if it is non-static).
3136          * If the method&#39;s {@code accessible} flag is not set,
3137          * access checking is performed immediately on behalf of the lookup class.
3138          * If &lt;i&gt;m&lt;/i&gt; is not public, do not share the resulting handle with untrusted parties.
3139          * &lt;p&gt;
3140          * The returned method handle will have
3141          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3142          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3143          * &lt;p&gt;
3144          * If &lt;i&gt;m&lt;/i&gt; is static, and
3145          * if the returned method handle is invoked, the method&#39;s class will
3146          * be initialized, if it has not already been initialized.
3147          * @param m the reflected method
3148          * @return a method handle which can invoke the reflected method
3149          * @throws IllegalAccessException if access checking fails
3150          *                                or if the method&#39;s variable arity modifier bit
3151          *                                is set and {@code asVarargsCollector} fails
3152          * @throws NullPointerException if the argument is null
3153          */
3154         public MethodHandle unreflect(Method m) throws IllegalAccessException {
3155             if (m.getDeclaringClass() == MethodHandle.class) {
3156                 MethodHandle mh = unreflectForMH(m);
3157                 if (mh != null)  return mh;
3158             }
3159             if (m.getDeclaringClass() == VarHandle.class) {
3160                 MethodHandle mh = unreflectForVH(m);
3161                 if (mh != null)  return mh;
3162             }
3163             MemberName method = new MemberName(m);
3164             byte refKind = method.getReferenceKind();
3165             if (refKind == REF_invokeSpecial)
3166                 refKind = REF_invokeVirtual;
3167             assert(method.isMethod());
3168             @SuppressWarnings(&quot;deprecation&quot;)
3169             Lookup lookup = m.isAccessible() ? IMPL_LOOKUP : this;
3170             return lookup.getDirectMethodNoSecurityManager(refKind, method.getDeclaringClass(), method, findBoundCallerLookup(method));
3171         }
3172         private MethodHandle unreflectForMH(Method m) {
3173             // these names require special lookups because they throw UnsupportedOperationException
3174             if (MemberName.isMethodHandleInvokeName(m.getName()))
3175                 return MethodHandleImpl.fakeMethodHandleInvoke(new MemberName(m));
3176             return null;
3177         }
3178         private MethodHandle unreflectForVH(Method m) {
3179             // these names require special lookups because they throw UnsupportedOperationException
3180             if (MemberName.isVarHandleMethodInvokeName(m.getName()))
3181                 return MethodHandleImpl.fakeVarHandleInvoke(new MemberName(m));
3182             return null;
3183         }
3184 
3185         /**
3186          * Produces a method handle for a reflected method.
3187          * It will bypass checks for overriding methods on the receiver,
3188          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if called&lt;/a&gt; from an {@code invokespecial}
3189          * instruction from within the explicitly specified {@code specialCaller}.
3190          * The type of the method handle will be that of the method,
3191          * with a suitably restricted receiver type prepended.
3192          * (The receiver type will be {@code specialCaller} or a subtype.)
3193          * If the method&#39;s {@code accessible} flag is not set,
3194          * access checking is performed immediately on behalf of the lookup class,
3195          * as if {@code invokespecial} instruction were being linked.
3196          * &lt;p&gt;
3197          * Before method resolution,
3198          * if the explicitly specified caller class is not identical with the
3199          * lookup class, or if this lookup object does not have
3200          * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;
3201          * privileges, the access fails.
3202          * &lt;p&gt;
3203          * The returned method handle will have
3204          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3205          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3206          * @param m the reflected method
3207          * @param specialCaller the class nominally calling the method
3208          * @return a method handle which can invoke the reflected method
3209          * @throws IllegalAccessException if access checking fails,
3210          *                                or if the method is {@code static},
3211          *                                or if the method&#39;s variable arity modifier bit
3212          *                                is set and {@code asVarargsCollector} fails
3213          * @throws NullPointerException if any argument is null
3214          */
3215         public MethodHandle unreflectSpecial(Method m, Class&lt;?&gt; specialCaller) throws IllegalAccessException {
3216             checkSpecialCaller(specialCaller, m.getDeclaringClass());
3217             Lookup specialLookup = this.in(specialCaller);
3218             MemberName method = new MemberName(m, true);
3219             assert(method.isMethod());
3220             // ignore m.isAccessible:  this is a new kind of access
3221             return specialLookup.getDirectMethodNoSecurityManager(REF_invokeSpecial, method.getDeclaringClass(), method, findBoundCallerLookup(method));
3222         }
3223 
3224         /**
3225          * Produces a method handle for a reflected constructor.
3226          * The type of the method handle will be that of the constructor,
3227          * with the return type changed to the declaring class.
3228          * The method handle will perform a {@code newInstance} operation,
3229          * creating a new instance of the constructor&#39;s class on the
3230          * arguments passed to the method handle.
3231          * &lt;p&gt;
3232          * If the constructor&#39;s {@code accessible} flag is not set,
3233          * access checking is performed immediately on behalf of the lookup class.
3234          * &lt;p&gt;
3235          * The returned method handle will have
3236          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3237          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3238          * &lt;p&gt;
3239          * If the returned method handle is invoked, the constructor&#39;s class will
3240          * be initialized, if it has not already been initialized.
3241          * @param c the reflected constructor
3242          * @return a method handle which can invoke the reflected constructor
3243          * @throws IllegalAccessException if access checking fails
3244          *                                or if the method&#39;s variable arity modifier bit
3245          *                                is set and {@code asVarargsCollector} fails
3246          * @throws NullPointerException if the argument is null
3247          */
3248         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
3249             MemberName ctor = new MemberName(c);
<a name="4" id="anc4"></a><span class="line-modified">3250             assert(ctor.isObjectConstructorOrStaticInitMethod());</span>
3251             @SuppressWarnings(&quot;deprecation&quot;)
3252             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
<a name="5" id="anc5"></a><span class="line-modified">3253             if (ctor.isObjectConstructor()) {</span>
<span class="line-added">3254                 assert(ctor.getReturnType() == void.class);</span>
<span class="line-added">3255                 return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);</span>
<span class="line-added">3256             } else {</span>
<span class="line-added">3257                 // static init factory is a static method</span>
<span class="line-added">3258                 assert(ctor.isMethod() &amp;&amp; ctor.getReturnType() == ctor.getDeclaringClass() &amp;&amp; ctor.getReferenceKind() == REF_invokeStatic);</span>
<span class="line-added">3259                 assert(!MethodHandleNatives.isCallerSensitive(ctor));  // must not be caller-sensitive</span>
<span class="line-added">3260                 return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), ctor.getDeclaringClass(), ctor, lookup);</span>
<span class="line-added">3261             }</span>
3262         }
3263 
3264         /**
3265          * Produces a method handle giving read access to a reflected field.
3266          * The type of the method handle will have a return type of the field&#39;s
3267          * value type.
3268          * If the field is {@code static}, the method handle will take no arguments.
3269          * Otherwise, its single argument will be the instance containing
3270          * the field.
3271          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
3272          * access checking is performed immediately on behalf of the lookup class.
3273          * &lt;p&gt;
3274          * If the field is static, and
3275          * if the returned method handle is invoked, the field&#39;s class will
3276          * be initialized, if it has not already been initialized.
3277          * @param f the reflected field
3278          * @return a method handle which can load values from the reflected field
3279          * @throws IllegalAccessException if access checking fails
3280          * @throws NullPointerException if the argument is null
3281          */
3282         public MethodHandle unreflectGetter(Field f) throws IllegalAccessException {
3283             return unreflectField(f, false);
3284         }
3285 
3286         /**
3287          * Produces a method handle giving write access to a reflected field.
3288          * The type of the method handle will have a void return type.
3289          * If the field is {@code static}, the method handle will take a single
3290          * argument, of the field&#39;s value type, the value to be stored.
3291          * Otherwise, the two arguments will be the instance containing
3292          * the field, and the value to be stored.
3293          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
3294          * access checking is performed immediately on behalf of the lookup class.
3295          * &lt;p&gt;
3296          * If the field is {@code final}, write access will not be
3297          * allowed and access checking will fail, except under certain
3298          * narrow circumstances documented for {@link Field#set Field.set}.
3299          * A method handle is returned only if a corresponding call to
3300          * the {@code Field} object&#39;s {@code set} method could return
3301          * normally.  In particular, fields which are both {@code static}
3302          * and {@code final} may never be set.
3303          * &lt;p&gt;
3304          * If the field is {@code static}, and
3305          * if the returned method handle is invoked, the field&#39;s class will
3306          * be initialized, if it has not already been initialized.
3307          * @param f the reflected field
3308          * @return a method handle which can store values into the reflected field
3309          * @throws IllegalAccessException if access checking fails,
3310          *         or if the field is {@code final} and write access
3311          *         is not enabled on the {@code Field} object
3312          * @throws NullPointerException if the argument is null
3313          */
3314         public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {
3315             return unreflectField(f, true);
3316         }
3317 
3318         private MethodHandle unreflectField(Field f, boolean isSetter) throws IllegalAccessException {
3319             MemberName field = new MemberName(f, isSetter);
3320             if (isSetter &amp;&amp; field.isFinal()) {
3321                 if (field.isTrustedFinalField()) {
3322                     String msg = field.isStatic() ? &quot;static final field has no write access&quot;
3323                                                   : &quot;final field has no write access&quot;;
3324                     throw field.makeAccessException(msg, this);
3325                 }
3326             }
3327             assert(isSetter
3328                     ? MethodHandleNatives.refKindIsSetter(field.getReferenceKind())
3329                     : MethodHandleNatives.refKindIsGetter(field.getReferenceKind()));
3330             @SuppressWarnings(&quot;deprecation&quot;)
3331             Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;
3332             return lookup.getDirectFieldNoSecurityManager(field.getReferenceKind(), f.getDeclaringClass(), field);
3333         }
3334 
3335         /**
3336          * Produces a VarHandle giving access to a reflected field {@code f}
3337          * of type {@code T} declared in a class of type {@code R}.
3338          * The VarHandle&#39;s variable type is {@code T}.
3339          * If the field is non-static the VarHandle has one coordinate type,
3340          * {@code R}.  Otherwise, the field is static, and the VarHandle has no
3341          * coordinate types.
3342          * &lt;p&gt;
3343          * Access checking is performed immediately on behalf of the lookup
3344          * class, regardless of the value of the field&#39;s {@code accessible}
3345          * flag.
3346          * &lt;p&gt;
3347          * If the field is static, and if the returned VarHandle is operated
3348          * on, the field&#39;s declaring class will be initialized, if it has not
3349          * already been initialized.
3350          * &lt;p&gt;
3351          * Certain access modes of the returned VarHandle are unsupported under
3352          * the following conditions:
3353          * &lt;ul&gt;
3354          * &lt;li&gt;if the field is declared {@code final}, then the write, atomic
3355          *     update, numeric atomic update, and bitwise atomic update access
3356          *     modes are unsupported.
3357          * &lt;li&gt;if the field type is anything other than {@code byte},
3358          *     {@code short}, {@code char}, {@code int}, {@code long},
3359          *     {@code float}, or {@code double} then numeric atomic update
3360          *     access modes are unsupported.
3361          * &lt;li&gt;if the field type is anything other than {@code boolean},
3362          *     {@code byte}, {@code short}, {@code char}, {@code int} or
3363          *     {@code long} then bitwise atomic update access modes are
3364          *     unsupported.
3365          * &lt;/ul&gt;
3366          * &lt;p&gt;
3367          * If the field is declared {@code volatile} then the returned VarHandle
3368          * will override access to the field (effectively ignore the
3369          * {@code volatile} declaration) in accordance to its specified
3370          * access modes.
3371          * &lt;p&gt;
3372          * If the field type is {@code float} or {@code double} then numeric
3373          * and atomic update access modes compare values using their bitwise
3374          * representation (see {@link Float#floatToRawIntBits} and
3375          * {@link Double#doubleToRawLongBits}, respectively).
3376          * @apiNote
3377          * Bitwise comparison of {@code float} values or {@code double} values,
3378          * as performed by the numeric and atomic update access modes, differ
3379          * from the primitive {@code ==} operator and the {@link Float#equals}
3380          * and {@link Double#equals} methods, specifically with respect to
3381          * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
3382          * Care should be taken when performing a compare and set or a compare
3383          * and exchange operation with such values since the operation may
3384          * unexpectedly fail.
3385          * There are many possible NaN values that are considered to be
3386          * {@code NaN} in Java, although no IEEE 754 floating-point operation
3387          * provided by Java can distinguish between them.  Operation failure can
3388          * occur if the expected or witness value is a NaN value and it is
3389          * transformed (perhaps in a platform specific manner) into another NaN
3390          * value, and thus has a different bitwise representation (see
3391          * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
3392          * details).
3393          * The values {@code -0.0} and {@code +0.0} have different bitwise
3394          * representations but are considered equal when using the primitive
3395          * {@code ==} operator.  Operation failure can occur if, for example, a
3396          * numeric algorithm computes an expected value to be say {@code -0.0}
3397          * and previously computed the witness value to be say {@code +0.0}.
3398          * @param f the reflected field, with a field of type {@code T}, and
3399          * a declaring class of type {@code R}
3400          * @return a VarHandle giving access to non-static fields or a static
3401          * field
3402          * @throws IllegalAccessException if access checking fails
3403          * @throws NullPointerException if the argument is null
3404          * @since 9
3405          */
3406         public VarHandle unreflectVarHandle(Field f) throws IllegalAccessException {
3407             MemberName getField = new MemberName(f, false);
3408             MemberName putField = new MemberName(f, true);
3409             return getFieldVarHandleNoSecurityManager(getField.getReferenceKind(), putField.getReferenceKind(),
3410                                                       f.getDeclaringClass(), getField, putField);
3411         }
3412 
3413         /**
3414          * Cracks a &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;
3415          * created by this lookup object or a similar one.
3416          * Security and access checks are performed to ensure that this lookup object
3417          * is capable of reproducing the target method handle.
3418          * This means that the cracking may fail if target is a direct method handle
3419          * but was created by an unrelated lookup object.
3420          * This can happen if the method handle is &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt;
3421          * and was created by a lookup object for a different class.
3422          * @param target a direct method handle to crack into symbolic reference components
3423          * @return a symbolic reference which can be used to reconstruct this method handle from this lookup object
3424          * @throws    SecurityException if a security manager is present and it
3425          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
3426          * @throws IllegalArgumentException if the target is not a direct method handle or if access checking fails
3427          * @throws    NullPointerException if the target is {@code null}
3428          * @see MethodHandleInfo
3429          * @since 1.8
3430          */
3431         public MethodHandleInfo revealDirect(MethodHandle target) {
3432             if (!target.isCrackable()) {
3433                 throw newIllegalArgumentException(&quot;not a direct method handle&quot;);
3434             }
3435             MemberName member = target.internalMemberName();
3436             Class&lt;?&gt; defc = member.getDeclaringClass();
3437             byte refKind = member.getReferenceKind();
3438             assert(MethodHandleNatives.refKindIsValid(refKind));
3439             if (refKind == REF_invokeSpecial &amp;&amp; !target.isInvokeSpecial())
3440                 // Devirtualized method invocation is usually formally virtual.
3441                 // To avoid creating extra MemberName objects for this common case,
3442                 // we encode this extra degree of freedom using MH.isInvokeSpecial.
3443                 refKind = REF_invokeVirtual;
3444             if (refKind == REF_invokeVirtual &amp;&amp; defc.isInterface())
3445                 // Symbolic reference is through interface but resolves to Object method (toString, etc.)
3446                 refKind = REF_invokeInterface;
3447             // Check SM permissions and member access before cracking.
3448             try {
3449                 checkAccess(refKind, defc, member);
3450                 checkSecurityManager(defc, member);
3451             } catch (IllegalAccessException ex) {
3452                 throw new IllegalArgumentException(ex);
3453             }
3454             if (allowedModes != TRUSTED &amp;&amp; member.isCallerSensitive()) {
3455                 Class&lt;?&gt; callerClass = target.internalCallerClass();
3456                 if (!hasFullPrivilegeAccess() || callerClass != lookupClass())
3457                     throw new IllegalArgumentException(&quot;method handle is caller sensitive: &quot;+callerClass);
3458             }
3459             // Produce the handle to the results.
3460             return new InfoFromMemberName(this, member, refKind);
3461         }
3462 
3463         /// Helper methods, all package-private.
3464 
3465         MemberName resolveOrFail(byte refKind, Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
3466             checkSymbolicClass(refc);  // do this before attempting to resolve
3467             Objects.requireNonNull(name);
3468             Objects.requireNonNull(type);
3469             return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(),
3470                                             NoSuchFieldException.class);
3471         }
3472 
3473         MemberName resolveOrFail(byte refKind, Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
3474             checkSymbolicClass(refc);  // do this before attempting to resolve
3475             Objects.requireNonNull(name);
3476             Objects.requireNonNull(type);
3477             checkMethodName(refKind, name);  // NPE check on name
3478             return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(),
3479                                             NoSuchMethodException.class);
3480         }
3481 
3482         MemberName resolveOrFail(byte refKind, MemberName member) throws ReflectiveOperationException {
3483             checkSymbolicClass(member.getDeclaringClass());  // do this before attempting to resolve
3484             Objects.requireNonNull(member.getName());
3485             Objects.requireNonNull(member.getType());
3486             return IMPL_NAMES.resolveOrFail(refKind, member, lookupClassOrNull(),
3487                                             ReflectiveOperationException.class);
3488         }
3489 
3490         MemberName resolveOrNull(byte refKind, MemberName member) {
3491             // do this before attempting to resolve
3492             if (!isClassAccessible(member.getDeclaringClass())) {
3493                 return null;
3494             }
3495             Objects.requireNonNull(member.getName());
3496             Objects.requireNonNull(member.getType());
3497             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
3498         }
3499 
3500         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
3501             if (!isClassAccessible(refc)) {
3502                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
3503             }
3504         }
3505 
3506         boolean isClassAccessible(Class&lt;?&gt; refc) {
3507             Objects.requireNonNull(refc);
3508             Class&lt;?&gt; caller = lookupClassOrNull();
3509             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);
3510         }
3511 
3512         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
3513         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
<a name="6" id="anc6"></a><span class="line-modified">3514             // &quot;&lt;init&gt;&quot; can only be invoked via invokespecial or it&#39;s a static init factory</span>
<span class="line-modified">3515             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial &amp;&amp;</span>
<span class="line-added">3516                     !(refKind == REF_invokeStatic &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;))) {</span>
<span class="line-added">3517                     throw new NoSuchMethodException(&quot;illegal method name: &quot; + name);</span>
<span class="line-added">3518             }</span>
3519         }
3520 
<a name="7" id="anc7"></a>
3521         /**
3522          * Find my trustable caller class if m is a caller sensitive method.
3523          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3524          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
3525          */
3526         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {
3527             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {
3528                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods
3529                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3530             }
3531             return this;
3532         }
3533 
3534         /**
3535          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3536          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3537          *
3538          * @deprecated This method was originally designed to test {@code PRIVATE} access
3539          * that implies full privilege access but {@code MODULE} access has since become
3540          * independent of {@code PRIVATE} access.  It is recommended to call
3541          * {@link #hasFullPrivilegeAccess()} instead.
3542          * @since 9
3543          */
3544         @Deprecated(since=&quot;14&quot;)
3545         public boolean hasPrivateAccess() {
3546             return hasFullPrivilegeAccess();
3547         }
3548 
3549         /**
3550          * Returns {@code true} if this lookup has &lt;em&gt;full privilege access&lt;/em&gt;,
3551          * i.e. {@code PRIVATE} and {@code MODULE} access.
3552          * A {@code Lookup} object must have full privilege access in order to
3553          * access all members that are allowed to the {@linkplain #lookupClass() lookup class}.
3554          *
3555          * @return {@code true} if this lookup has full privilege access.
3556          * @since 14
3557          * @see &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private and module access&lt;/a&gt;
3558          */
3559         public boolean hasFullPrivilegeAccess() {
3560             return (allowedModes &amp; (PRIVATE|MODULE)) == (PRIVATE|MODULE);
3561         }
3562 
3563         /**
3564          * Perform steps 1 and 2b &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;access checks&lt;/a&gt;
3565          * for ensureInitialzed, findClass or accessClass.
3566          */
3567         void checkSecurityManager(Class&lt;?&gt; refc) {
3568             if (allowedModes == TRUSTED)  return;
3569 
3570             SecurityManager smgr = System.getSecurityManager();
3571             if (smgr == null)  return;
3572 
3573             // Step 1:
3574             boolean fullPowerLookup = hasFullPrivilegeAccess();
3575             if (!fullPowerLookup ||
3576                 !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {
3577                 ReflectUtil.checkPackageAccess(refc);
3578             }
3579 
3580             // Step 2b:
3581             if (!fullPowerLookup) {
3582                 smgr.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
3583             }
3584         }
3585 
3586         /**
3587          * Perform steps 1, 2a and 3 &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;access checks&lt;/a&gt;.
3588          * Determines a trustable caller class to compare with refc, the symbolic reference class.
3589          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3590          */
3591         void checkSecurityManager(Class&lt;?&gt; refc, MemberName m) {
3592             Objects.requireNonNull(refc);
3593             Objects.requireNonNull(m);
3594 
3595             if (allowedModes == TRUSTED)  return;
3596 
3597             SecurityManager smgr = System.getSecurityManager();
3598             if (smgr == null)  return;
3599 
3600             // Step 1:
3601             boolean fullPowerLookup = hasFullPrivilegeAccess();
3602             if (!fullPowerLookup ||
3603                 !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {
3604                 ReflectUtil.checkPackageAccess(refc);
3605             }
3606 
3607             // Step 2a:
3608             if (m.isPublic()) return;
3609             if (!fullPowerLookup) {
3610                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3611             }
3612 
3613             // Step 3:
3614             Class&lt;?&gt; defc = m.getDeclaringClass();
3615             if (!fullPowerLookup &amp;&amp; defc != refc) {
3616                 ReflectUtil.checkPackageAccess(defc);
3617             }
3618         }
3619 
3620         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3621             boolean wantStatic = (refKind == REF_invokeStatic);
3622             String message;
<a name="8" id="anc8"></a><span class="line-modified">3623             if (m.isObjectConstructor())</span>
3624                 message = &quot;expected a method, not a constructor&quot;;
3625             else if (!m.isMethod())
3626                 message = &quot;expected a method&quot;;
3627             else if (wantStatic != m.isStatic())
3628                 message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;
3629             else
3630                 { checkAccess(refKind, refc, m); return; }
3631             throw m.makeAccessException(message, this);
3632         }
3633 
3634         void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3635             boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);
3636             String message;
3637             if (wantStatic != m.isStatic())
3638                 message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;
3639             else
3640                 { checkAccess(refKind, refc, m); return; }
3641             throw m.makeAccessException(message, this);
3642         }
3643 
3644         /** Check public/protected/private bits on the symbolic reference class and its member. */
3645         void checkAccess(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3646             assert(m.referenceKindIsConsistentWith(refKind) &amp;&amp;
3647                    MethodHandleNatives.refKindIsValid(refKind) &amp;&amp;
3648                    (MethodHandleNatives.refKindIsField(refKind) == m.isField()));
3649             int allowedModes = this.allowedModes;
3650             if (allowedModes == TRUSTED)  return;
3651             int mods = m.getModifiers();
3652             if (Modifier.isProtected(mods) &amp;&amp;
3653                     refKind == REF_invokeVirtual &amp;&amp;
3654                     m.getDeclaringClass() == Object.class &amp;&amp;
3655                     m.getName().equals(&quot;clone&quot;) &amp;&amp;
3656                     refc.isArray()) {
3657                 // The JVM does this hack also.
3658                 // (See ClassVerifier::verify_invoke_instructions
3659                 // and LinkResolver::check_method_accessability.)
3660                 // Because the JVM does not allow separate methods on array types,
3661                 // there is no separate method for int[].clone.
3662                 // All arrays simply inherit Object.clone.
3663                 // But for access checking logic, we make Object.clone
3664                 // (normally protected) appear to be public.
3665                 // Later on, when the DirectMethodHandle is created,
3666                 // its leading argument will be restricted to the
3667                 // requested array type.
3668                 // N.B. The return type is not adjusted, because
3669                 // that is *not* the bytecode behavior.
3670                 mods ^= Modifier.PROTECTED | Modifier.PUBLIC;
3671             }
3672             if (Modifier.isProtected(mods) &amp;&amp; refKind == REF_newInvokeSpecial) {
3673                 // cannot &quot;new&quot; a protected ctor in a different package
3674                 mods ^= Modifier.PROTECTED;
3675             }
3676             if (Modifier.isFinal(mods) &amp;&amp;
3677                     MethodHandleNatives.refKindIsSetter(refKind))
3678                 throw m.makeAccessException(&quot;unexpected set of a final field&quot;, this);
3679             int requestedModes = fixmods(mods);  // adjust 0 =&gt; PACKAGE
3680             if ((requestedModes &amp; allowedModes) != 0) {
3681                 if (VerifyAccess.isMemberAccessible(refc, m.getDeclaringClass(),
3682                                                     mods, lookupClass(), previousLookupClass(), allowedModes))
3683                     return;
3684             } else {
3685                 // Protected members can also be checked as if they were package-private.
3686                 if ((requestedModes &amp; PROTECTED) != 0 &amp;&amp; (allowedModes &amp; PACKAGE) != 0
3687                         &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), lookupClass()))
3688                     return;
3689             }
3690             throw m.makeAccessException(accessFailedMessage(refc, m), this);
3691         }
3692 
3693         String accessFailedMessage(Class&lt;?&gt; refc, MemberName m) {
3694             Class&lt;?&gt; defc = m.getDeclaringClass();
3695             int mods = m.getModifiers();
3696             // check the class first:
3697             boolean classOK = (Modifier.isPublic(defc.getModifiers()) &amp;&amp;
3698                                (defc == refc ||
3699                                 Modifier.isPublic(refc.getModifiers())));
3700             if (!classOK &amp;&amp; (allowedModes &amp; PACKAGE) != 0) {
3701                 // ignore previous lookup class to check if default package access
3702                 classOK = (VerifyAccess.isClassAccessible(defc, lookupClass(), null, FULL_POWER_MODES) &amp;&amp;
3703                            (defc == refc ||
3704                             VerifyAccess.isClassAccessible(refc, lookupClass(), null, FULL_POWER_MODES)));
3705             }
3706             if (!classOK)
3707                 return &quot;class is not public&quot;;
3708             if (Modifier.isPublic(mods))
3709                 return &quot;access to public member failed&quot;;  // (how?, module not readable?)
3710             if (Modifier.isPrivate(mods))
3711                 return &quot;member is private&quot;;
3712             if (Modifier.isProtected(mods))
3713                 return &quot;member is protected&quot;;
3714             return &quot;member is private to package&quot;;
3715         }
3716 
3717         private void checkSpecialCaller(Class&lt;?&gt; specialCaller, Class&lt;?&gt; refc) throws IllegalAccessException {
3718             int allowedModes = this.allowedModes;
3719             if (allowedModes == TRUSTED)  return;
3720             if ((lookupModes() &amp; PRIVATE) == 0
3721                 || (specialCaller != lookupClass()
3722                        // ensure non-abstract methods in superinterfaces can be special-invoked
3723                     &amp;&amp; !(refc != null &amp;&amp; refc.isInterface() &amp;&amp; refc.isAssignableFrom(specialCaller))))
3724                 throw new MemberName(specialCaller).
3725                     makeAccessException(&quot;no private access for invokespecial&quot;, this);
3726         }
3727 
3728         private boolean restrictProtectedReceiver(MemberName method) {
3729             // The accessing class only has the right to use a protected member
3730             // on itself or a subclass.  Enforce that restriction, from JVMS 5.4.4, etc.
3731             if (!method.isProtected() || method.isStatic()
3732                 || allowedModes == TRUSTED
3733                 || method.getDeclaringClass() == lookupClass()
3734                 || VerifyAccess.isSamePackage(method.getDeclaringClass(), lookupClass()))
3735                 return false;
3736             return true;
3737         }
3738         private MethodHandle restrictReceiver(MemberName method, DirectMethodHandle mh, Class&lt;?&gt; caller) throws IllegalAccessException {
3739             assert(!method.isStatic());
3740             // receiver type of mh is too wide; narrow to caller
3741             if (!method.getDeclaringClass().isAssignableFrom(caller)) {
3742                 throw method.makeAccessException(&quot;caller class must be a subclass below the method&quot;, caller);
3743             }
3744             MethodType rawType = mh.type();
3745             if (caller.isAssignableFrom(rawType.parameterType(0))) return mh; // no need to restrict; already narrow
3746             MethodType narrowType = rawType.changeParameterType(0, caller);
3747             assert(!mh.isVarargsCollector());  // viewAsType will lose varargs-ness
3748             assert(mh.viewAsTypeChecks(narrowType, true));
3749             return mh.copyWith(narrowType, mh.form);
3750         }
3751 
3752         /** Check access and get the requested method. */
3753         private MethodHandle getDirectMethod(byte refKind, Class&lt;?&gt; refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {
3754             final boolean doRestrict    = true;
3755             final boolean checkSecurity = true;
3756             return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, callerLookup);
3757         }
3758         /** Check access and get the requested method, for invokespecial with no restriction on the application of narrowing rules. */
3759         private MethodHandle getDirectMethodNoRestrictInvokeSpecial(Class&lt;?&gt; refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {
3760             final boolean doRestrict    = false;
3761             final boolean checkSecurity = true;
3762             return getDirectMethodCommon(REF_invokeSpecial, refc, method, checkSecurity, doRestrict, callerLookup);
3763         }
3764         /** Check access and get the requested method, eliding security manager checks. */
3765         private MethodHandle getDirectMethodNoSecurityManager(byte refKind, Class&lt;?&gt; refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {
3766             final boolean doRestrict    = true;
3767             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3768             return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, callerLookup);
3769         }
3770         /** Common code for all methods; do not call directly except from immediately above. */
3771         private MethodHandle getDirectMethodCommon(byte refKind, Class&lt;?&gt; refc, MemberName method,
3772                                                    boolean checkSecurity,
3773                                                    boolean doRestrict,
3774                                                    Lookup boundCaller) throws IllegalAccessException {
3775             checkMethod(refKind, refc, method);
3776             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3777             if (checkSecurity)
3778                 checkSecurityManager(refc, method);
3779             assert(!method.isMethodHandleInvoke());
3780 
3781             if (refKind == REF_invokeSpecial &amp;&amp;
3782                 refc != lookupClass() &amp;&amp;
3783                 !refc.isInterface() &amp;&amp;
3784                 refc != lookupClass().getSuperclass() &amp;&amp;
3785                 refc.isAssignableFrom(lookupClass())) {
3786                 assert(!method.getName().equals(&quot;&lt;init&gt;&quot;));  // not this code path
3787 
3788                 // Per JVMS 6.5, desc. of invokespecial instruction:
3789                 // If the method is in a superclass of the LC,
3790                 // and if our original search was above LC.super,
3791                 // repeat the search (symbolic lookup) from LC.super
3792                 // and continue with the direct superclass of that class,
3793                 // and so forth, until a match is found or no further superclasses exist.
3794                 // FIXME: MemberName.resolve should handle this instead.
3795                 Class&lt;?&gt; refcAsSuper = lookupClass();
3796                 MemberName m2;
3797                 do {
3798                     refcAsSuper = refcAsSuper.getSuperclass();
3799                     m2 = new MemberName(refcAsSuper,
3800                                         method.getName(),
3801                                         method.getMethodType(),
3802                                         REF_invokeSpecial);
3803                     m2 = IMPL_NAMES.resolveOrNull(refKind, m2, lookupClassOrNull());
3804                 } while (m2 == null &amp;&amp;         // no method is found yet
3805                          refc != refcAsSuper); // search up to refc
3806                 if (m2 == null)  throw new InternalError(method.toString());
3807                 method = m2;
3808                 refc = refcAsSuper;
3809                 // redo basic checks
3810                 checkMethod(refKind, refc, method);
3811             }
3812             DirectMethodHandle dmh = DirectMethodHandle.make(refKind, refc, method, lookupClass());
3813             MethodHandle mh = dmh;
3814             // Optionally narrow the receiver argument to lookupClass using restrictReceiver.
3815             if ((doRestrict &amp;&amp; refKind == REF_invokeSpecial) ||
3816                     (MethodHandleNatives.refKindHasReceiver(refKind) &amp;&amp; restrictProtectedReceiver(method))) {
3817                 mh = restrictReceiver(method, dmh, lookupClass());
3818             }
3819             mh = maybeBindCaller(method, mh, boundCaller);
3820             mh = mh.setVarargs(method);
3821             return mh;
3822         }
3823         private MethodHandle maybeBindCaller(MemberName method, MethodHandle mh, Lookup boundCaller)
3824                                              throws IllegalAccessException {
3825             if (boundCaller.allowedModes == TRUSTED || !MethodHandleNatives.isCallerSensitive(method))
3826                 return mh;
3827 
3828             // boundCaller must have full privilege access.
3829             // It should have been checked by findBoundCallerLookup. Safe to check this again.
3830             if (!boundCaller.hasFullPrivilegeAccess())
3831                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3832 
3833             MethodHandle cbmh = MethodHandleImpl.bindCaller(mh, boundCaller.lookupClass);
3834             // Note: caller will apply varargs after this step happens.
3835             return cbmh;
3836         }
3837 
3838         /** Check access and get the requested field. */
3839         private MethodHandle getDirectField(byte refKind, Class&lt;?&gt; refc, MemberName field) throws IllegalAccessException {
3840             final boolean checkSecurity = true;
3841             return getDirectFieldCommon(refKind, refc, field, checkSecurity);
3842         }
3843         /** Check access and get the requested field, eliding security manager checks. */
3844         private MethodHandle getDirectFieldNoSecurityManager(byte refKind, Class&lt;?&gt; refc, MemberName field) throws IllegalAccessException {
3845             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3846             return getDirectFieldCommon(refKind, refc, field, checkSecurity);
3847         }
3848         /** Common code for all fields; do not call directly except from immediately above. */
3849         private MethodHandle getDirectFieldCommon(byte refKind, Class&lt;?&gt; refc, MemberName field,
3850                                                   boolean checkSecurity) throws IllegalAccessException {
3851             checkField(refKind, refc, field);
3852             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3853             if (checkSecurity)
3854                 checkSecurityManager(refc, field);
3855             DirectMethodHandle dmh = DirectMethodHandle.make(refc, field);
3856             boolean doRestrict = (MethodHandleNatives.refKindHasReceiver(refKind) &amp;&amp;
3857                                     restrictProtectedReceiver(field));
3858             if (doRestrict)
3859                 return restrictReceiver(field, dmh, lookupClass());
3860             return dmh;
3861         }
3862         private VarHandle getFieldVarHandle(byte getRefKind, byte putRefKind,
3863                                             Class&lt;?&gt; refc, MemberName getField, MemberName putField)
3864                 throws IllegalAccessException {
3865             final boolean checkSecurity = true;
3866             return getFieldVarHandleCommon(getRefKind, putRefKind, refc, getField, putField, checkSecurity);
3867         }
3868         private VarHandle getFieldVarHandleNoSecurityManager(byte getRefKind, byte putRefKind,
3869                                                              Class&lt;?&gt; refc, MemberName getField, MemberName putField)
3870                 throws IllegalAccessException {
3871             final boolean checkSecurity = false;
3872             return getFieldVarHandleCommon(getRefKind, putRefKind, refc, getField, putField, checkSecurity);
3873         }
3874         private VarHandle getFieldVarHandleCommon(byte getRefKind, byte putRefKind,
3875                                                   Class&lt;?&gt; refc, MemberName getField, MemberName putField,
3876                                                   boolean checkSecurity) throws IllegalAccessException {
3877             assert getField.isStatic() == putField.isStatic();
3878             assert getField.isGetter() &amp;&amp; putField.isSetter();
3879             assert MethodHandleNatives.refKindIsStatic(getRefKind) == MethodHandleNatives.refKindIsStatic(putRefKind);
3880             assert MethodHandleNatives.refKindIsGetter(getRefKind) &amp;&amp; MethodHandleNatives.refKindIsSetter(putRefKind);
3881 
3882             checkField(getRefKind, refc, getField);
3883             if (checkSecurity)
3884                 checkSecurityManager(refc, getField);
3885 
3886             if (!putField.isFinal()) {
3887                 // A VarHandle does not support updates to final fields, any
3888                 // such VarHandle to a final field will be read-only and
3889                 // therefore the following write-based accessibility checks are
3890                 // only required for non-final fields
3891                 checkField(putRefKind, refc, putField);
3892                 if (checkSecurity)
3893                     checkSecurityManager(refc, putField);
3894             }
3895 
3896             boolean doRestrict = (MethodHandleNatives.refKindHasReceiver(getRefKind) &amp;&amp;
3897                                   restrictProtectedReceiver(getField));
3898             if (doRestrict) {
3899                 assert !getField.isStatic();
3900                 // receiver type of VarHandle is too wide; narrow to caller
3901                 if (!getField.getDeclaringClass().isAssignableFrom(lookupClass())) {
3902                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3903                 }
3904                 refc = lookupClass();
3905             }
3906             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),
3907                                               this.allowedModes == TRUSTED &amp;&amp; !getField.isTrustedFinalField());
3908         }
3909         /** Check access and get the requested constructor. */
3910         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3911             final boolean checkSecurity = true;
3912             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3913         }
3914         /** Check access and get the requested constructor, eliding security manager checks. */
3915         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3916             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3917             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3918         }
3919         /** Common code for all constructors; do not call directly except from immediately above. */
3920         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3921                                                   boolean checkSecurity) throws IllegalAccessException {
<a name="9" id="anc9"></a><span class="line-modified">3922             assert(ctor.isObjectConstructor());</span>
3923             checkAccess(REF_newInvokeSpecial, refc, ctor);
3924             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3925             if (checkSecurity)
3926                 checkSecurityManager(refc, ctor);
3927             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3928             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3929         }
3930 
3931         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3932          */
3933         /*non-public*/
3934         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)
3935                 throws ReflectiveOperationException {
3936             if (!(type instanceof Class || type instanceof MethodType))
3937                 throw new InternalError(&quot;unresolved MemberName&quot;);
3938             MemberName member = new MemberName(refKind, defc, name, type);
3939             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3940             if (mh != null) {
3941                 checkSymbolicClass(defc);
3942                 return mh;
3943             }
3944             if (defc == MethodHandle.class &amp;&amp; refKind == REF_invokeVirtual) {
3945                 // Treat MethodHandle.invoke and invokeExact specially.
3946                 mh = findVirtualForMH(member.getName(), member.getMethodType());
3947                 if (mh != null) {
3948                     return mh;
3949                 }
3950             } else if (defc == VarHandle.class &amp;&amp; refKind == REF_invokeVirtual) {
3951                 // Treat signature-polymorphic methods on VarHandle specially.
3952                 mh = findVirtualForVH(member.getName(), member.getMethodType());
3953                 if (mh != null) {
3954                     return mh;
3955                 }
3956             }
3957             MemberName resolved = resolveOrFail(refKind, member);
3958             mh = getDirectMethodForConstant(refKind, defc, resolved);
3959             if (mh instanceof DirectMethodHandle
3960                     &amp;&amp; canBeCached(refKind, defc, resolved)) {
3961                 MemberName key = mh.internalMemberName();
3962                 if (key != null) {
3963                     key = key.asNormalOriginal();
3964                 }
3965                 if (member.equals(key)) {  // better safe than sorry
3966                     LOOKASIDE_TABLE.put(key, (DirectMethodHandle) mh);
3967                 }
3968             }
3969             return mh;
3970         }
3971         private boolean canBeCached(byte refKind, Class&lt;?&gt; defc, MemberName member) {
3972             if (refKind == REF_invokeSpecial) {
3973                 return false;
3974             }
3975             if (!Modifier.isPublic(defc.getModifiers()) ||
3976                     !Modifier.isPublic(member.getDeclaringClass().getModifiers()) ||
3977                     !member.isPublic() ||
3978                     member.isCallerSensitive()) {
3979                 return false;
3980             }
3981             ClassLoader loader = defc.getClassLoader();
3982             if (loader != null) {
3983                 ClassLoader sysl = ClassLoader.getSystemClassLoader();
3984                 boolean found = false;
3985                 while (sysl != null) {
3986                     if (loader == sysl) { found = true; break; }
3987                     sysl = sysl.getParent();
3988                 }
3989                 if (!found) {
3990                     return false;
3991                 }
3992             }
3993             try {
3994                 MemberName resolved2 = publicLookup().resolveOrNull(refKind,
3995                     new MemberName(refKind, defc, member.getName(), member.getType()));
3996                 if (resolved2 == null) {
3997                     return false;
3998                 }
3999                 checkSecurityManager(defc, resolved2);
4000             } catch (SecurityException ex) {
4001                 return false;
4002             }
4003             return true;
4004         }
4005         private MethodHandle getDirectMethodForConstant(byte refKind, Class&lt;?&gt; defc, MemberName member)
4006                 throws ReflectiveOperationException {
4007             if (MethodHandleNatives.refKindIsField(refKind)) {
4008                 return getDirectFieldNoSecurityManager(refKind, defc, member);
4009             } else if (MethodHandleNatives.refKindIsMethod(refKind)) {
4010                 return getDirectMethodNoSecurityManager(refKind, defc, member, findBoundCallerLookup(member));
4011             } else if (refKind == REF_newInvokeSpecial) {
4012                 return getDirectConstructorNoSecurityManager(defc, member);
4013             }
4014             // oops
4015             throw newIllegalArgumentException(&quot;bad MethodHandle constant #&quot;+member);
4016         }
4017 
4018         static ConcurrentHashMap&lt;MemberName, DirectMethodHandle&gt; LOOKASIDE_TABLE = new ConcurrentHashMap&lt;&gt;();
4019     }
4020 
4021     /**
4022      * Produces a method handle constructing arrays of a desired type,
4023      * as if by the {@code anewarray} bytecode.
4024      * The return type of the method handle will be the array type.
4025      * The type of its sole argument will be {@code int}, which specifies the size of the array.
4026      *
4027      * &lt;p&gt; If the returned method handle is invoked with a negative
4028      * array size, a {@code NegativeArraySizeException} will be thrown.
4029      *
4030      * @param arrayClass an array type
4031      * @return a method handle which can create arrays of the given type
4032      * @throws NullPointerException if the argument is {@code null}
4033      * @throws IllegalArgumentException if {@code arrayClass} is not an array type
4034      * @see java.lang.reflect.Array#newInstance(Class, int)
4035      * @jvms 6.5 {@code anewarray} Instruction
4036      * @since 9
4037      */
4038     public static MethodHandle arrayConstructor(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
4039         if (!arrayClass.isArray()) {
4040             throw newIllegalArgumentException(&quot;not an array class: &quot; + arrayClass.getName());
4041         }
4042         MethodHandle ani = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_Array_newInstance).
4043                 bindTo(arrayClass.getComponentType());
4044         return ani.asType(ani.type().changeReturnType(arrayClass));
4045     }
4046 
4047     /**
4048      * Produces a method handle returning the length of an array,
4049      * as if by the {@code arraylength} bytecode.
4050      * The type of the method handle will have {@code int} as return type,
4051      * and its sole argument will be the array type.
4052      *
4053      * &lt;p&gt; If the returned method handle is invoked with a {@code null}
4054      * array reference, a {@code NullPointerException} will be thrown.
4055      *
4056      * @param arrayClass an array type
4057      * @return a method handle which can retrieve the length of an array of the given array type
4058      * @throws NullPointerException if the argument is {@code null}
4059      * @throws IllegalArgumentException if arrayClass is not an array type
4060      * @jvms 6.5 {@code arraylength} Instruction
4061      * @since 9
4062      */
4063     public static MethodHandle arrayLength(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
4064         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.LENGTH);
4065     }
4066 
4067     /**
4068      * Produces a method handle giving read access to elements of an array,
4069      * as if by the {@code aaload} bytecode.
4070      * The type of the method handle will have a return type of the array&#39;s
4071      * element type.  Its first argument will be the array type,
4072      * and the second will be {@code int}.
4073      *
4074      * &lt;p&gt; When the returned method handle is invoked,
4075      * the array reference and array index are checked.
4076      * A {@code NullPointerException} will be thrown if the array reference
4077      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
4078      * thrown if the index is negative or if it is greater than or equal to
4079      * the length of the array.
4080      *
4081      * @param arrayClass an array type
4082      * @return a method handle which can load values from the given array type
4083      * @throws NullPointerException if the argument is null
4084      * @throws  IllegalArgumentException if arrayClass is not an array type
4085      * @jvms 6.5 {@code aaload} Instruction
4086      */
4087     public static MethodHandle arrayElementGetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
4088         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.GET);
4089     }
4090 
4091     /**
4092      * Produces a method handle giving write access to elements of an array,
4093      * as if by the {@code astore} bytecode.
4094      * The type of the method handle will have a void return type.
4095      * Its last argument will be the array&#39;s element type.
4096      * The first and second arguments will be the array type and int.
4097      *
4098      * &lt;p&gt; When the returned method handle is invoked,
4099      * the array reference and array index are checked.
4100      * A {@code NullPointerException} will be thrown if the array reference
4101      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
4102      * thrown if the index is negative or if it is greater than or equal to
4103      * the length of the array.
4104      *
4105      * @param arrayClass the class of an array
4106      * @return a method handle which can store values into the array type
4107      * @throws NullPointerException if the argument is null
4108      * @throws IllegalArgumentException if arrayClass is not an array type
4109      * @jvms 6.5 {@code aastore} Instruction
4110      */
4111     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
<a name="10" id="anc10"></a><span class="line-added">4112         if (arrayClass.isInlineClass()) {</span>
<span class="line-added">4113             throw new UnsupportedOperationException();</span>
<span class="line-added">4114         }</span>
4115         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
4116     }
4117 
4118     /**
4119      * Produces a VarHandle giving access to elements of an array of type
4120      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
4121      * of {@code arrayClass} and the list of coordinate types is
4122      * {@code (arrayClass, int)}, where the {@code int} coordinate type
4123      * corresponds to an argument that is an index into an array.
4124      * &lt;p&gt;
4125      * Certain access modes of the returned VarHandle are unsupported under
4126      * the following conditions:
4127      * &lt;ul&gt;
4128      * &lt;li&gt;if the component type is anything other than {@code byte},
4129      *     {@code short}, {@code char}, {@code int}, {@code long},
4130      *     {@code float}, or {@code double} then numeric atomic update access
4131      *     modes are unsupported.
4132      * &lt;li&gt;if the component type is anything other than {@code boolean},
4133      *     {@code byte}, {@code short}, {@code char}, {@code int} or
4134      *     {@code long} then bitwise atomic update access modes are
4135      *     unsupported.
4136      * &lt;/ul&gt;
4137      * &lt;p&gt;
4138      * If the component type is {@code float} or {@code double} then numeric
4139      * and atomic update access modes compare values using their bitwise
4140      * representation (see {@link Float#floatToRawIntBits} and
4141      * {@link Double#doubleToRawLongBits}, respectively).
4142      *
4143      * &lt;p&gt; When the returned {@code VarHandle} is invoked,
4144      * the array reference and array index are checked.
4145      * A {@code NullPointerException} will be thrown if the array reference
4146      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
4147      * thrown if the index is negative or if it is greater than or equal to
4148      * the length of the array.
4149      *
4150      * @apiNote
4151      * Bitwise comparison of {@code float} values or {@code double} values,
4152      * as performed by the numeric and atomic update access modes, differ
4153      * from the primitive {@code ==} operator and the {@link Float#equals}
4154      * and {@link Double#equals} methods, specifically with respect to
4155      * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
4156      * Care should be taken when performing a compare and set or a compare
4157      * and exchange operation with such values since the operation may
4158      * unexpectedly fail.
4159      * There are many possible NaN values that are considered to be
4160      * {@code NaN} in Java, although no IEEE 754 floating-point operation
4161      * provided by Java can distinguish between them.  Operation failure can
4162      * occur if the expected or witness value is a NaN value and it is
4163      * transformed (perhaps in a platform specific manner) into another NaN
4164      * value, and thus has a different bitwise representation (see
4165      * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
4166      * details).
4167      * The values {@code -0.0} and {@code +0.0} have different bitwise
4168      * representations but are considered equal when using the primitive
4169      * {@code ==} operator.  Operation failure can occur if, for example, a
4170      * numeric algorithm computes an expected value to be say {@code -0.0}
4171      * and previously computed the witness value to be say {@code +0.0}.
4172      * @param arrayClass the class of an array, of type {@code T[]}
4173      * @return a VarHandle giving access to elements of an array
4174      * @throws NullPointerException if the arrayClass is null
4175      * @throws IllegalArgumentException if arrayClass is not an array type
4176      * @since 9
4177      */
4178     public static VarHandle arrayElementVarHandle(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
4179         return VarHandles.makeArrayElementHandle(arrayClass);
4180     }
4181 
4182     /**
4183      * Produces a VarHandle giving access to elements of a {@code byte[]} array
4184      * viewed as if it were a different primitive array type, such as
4185      * {@code int[]} or {@code long[]}.
4186      * The VarHandle&#39;s variable type is the component type of
4187      * {@code viewArrayClass} and the list of coordinate types is
4188      * {@code (byte[], int)}, where the {@code int} coordinate type
4189      * corresponds to an argument that is an index into a {@code byte[]} array.
4190      * The returned VarHandle accesses bytes at an index in a {@code byte[]}
4191      * array, composing bytes to or from a value of the component type of
4192      * {@code viewArrayClass} according to the given endianness.
4193      * &lt;p&gt;
4194      * The supported component types (variables types) are {@code short},
4195      * {@code char}, {@code int}, {@code long}, {@code float} and
4196      * {@code double}.
4197      * &lt;p&gt;
4198      * Access of bytes at a given index will result in an
4199      * {@code IndexOutOfBoundsException} if the index is less than {@code 0}
4200      * or greater than the {@code byte[]} array length minus the size (in bytes)
4201      * of {@code T}.
4202      * &lt;p&gt;
4203      * Access of bytes at an index may be aligned or misaligned for {@code T},
4204      * with respect to the underlying memory address, {@code A} say, associated
4205      * with the array and index.
4206      * If access is misaligned then access for anything other than the
4207      * {@code get} and {@code set} access modes will result in an
4208      * {@code IllegalStateException}.  In such cases atomic access is only
4209      * guaranteed with respect to the largest power of two that divides the GCD
4210      * of {@code A} and the size (in bytes) of {@code T}.
4211      * If access is aligned then following access modes are supported and are
4212      * guaranteed to support atomic access:
4213      * &lt;ul&gt;
4214      * &lt;li&gt;read write access modes for all {@code T}, with the exception of
4215      *     access modes {@code get} and {@code set} for {@code long} and
4216      *     {@code double} on 32-bit platforms.
4217      * &lt;li&gt;atomic update access modes for {@code int}, {@code long},
4218      *     {@code float} or {@code double}.
4219      *     (Future major platform releases of the JDK may support additional
4220      *     types for certain currently unsupported access modes.)
4221      * &lt;li&gt;numeric atomic update access modes for {@code int} and {@code long}.
4222      *     (Future major platform releases of the JDK may support additional
4223      *     numeric types for certain currently unsupported access modes.)
4224      * &lt;li&gt;bitwise atomic update access modes for {@code int} and {@code long}.
4225      *     (Future major platform releases of the JDK may support additional
4226      *     numeric types for certain currently unsupported access modes.)
4227      * &lt;/ul&gt;
4228      * &lt;p&gt;
4229      * Misaligned access, and therefore atomicity guarantees, may be determined
4230      * for {@code byte[]} arrays without operating on a specific array.  Given
4231      * an {@code index}, {@code T} and it&#39;s corresponding boxed type,
4232      * {@code T_BOX}, misalignment may be determined as follows:
4233      * &lt;pre&gt;{@code
4234      * int sizeOfT = T_BOX.BYTES;  // size in bytes of T
4235      * int misalignedAtZeroIndex = ByteBuffer.wrap(new byte[0]).
4236      *     alignmentOffset(0, sizeOfT);
4237      * int misalignedAtIndex = (misalignedAtZeroIndex + index) % sizeOfT;
4238      * boolean isMisaligned = misalignedAtIndex != 0;
4239      * }&lt;/pre&gt;
4240      * &lt;p&gt;
4241      * If the variable type is {@code float} or {@code double} then atomic
4242      * update access modes compare values using their bitwise representation
4243      * (see {@link Float#floatToRawIntBits} and
4244      * {@link Double#doubleToRawLongBits}, respectively).
4245      * @param viewArrayClass the view array class, with a component type of
4246      * type {@code T}
4247      * @param byteOrder the endianness of the view array elements, as
4248      * stored in the underlying {@code byte} array
4249      * @return a VarHandle giving access to elements of a {@code byte[]} array
4250      * viewed as if elements corresponding to the components type of the view
4251      * array class
4252      * @throws NullPointerException if viewArrayClass or byteOrder is null
4253      * @throws IllegalArgumentException if viewArrayClass is not an array type
4254      * @throws UnsupportedOperationException if the component type of
4255      * viewArrayClass is not supported as a variable type
4256      * @since 9
4257      */
4258     public static VarHandle byteArrayViewVarHandle(Class&lt;?&gt; viewArrayClass,
4259                                      ByteOrder byteOrder) throws IllegalArgumentException {
4260         Objects.requireNonNull(byteOrder);
4261         return VarHandles.byteArrayViewHandle(viewArrayClass,
4262                                               byteOrder == ByteOrder.BIG_ENDIAN);
4263     }
4264 
4265     /**
4266      * Produces a VarHandle giving access to elements of a {@code ByteBuffer}
4267      * viewed as if it were an array of elements of a different primitive
4268      * component type to that of {@code byte}, such as {@code int[]} or
4269      * {@code long[]}.
4270      * The VarHandle&#39;s variable type is the component type of
4271      * {@code viewArrayClass} and the list of coordinate types is
4272      * {@code (ByteBuffer, int)}, where the {@code int} coordinate type
4273      * corresponds to an argument that is an index into a {@code byte[]} array.
4274      * The returned VarHandle accesses bytes at an index in a
4275      * {@code ByteBuffer}, composing bytes to or from a value of the component
4276      * type of {@code viewArrayClass} according to the given endianness.
4277      * &lt;p&gt;
4278      * The supported component types (variables types) are {@code short},
4279      * {@code char}, {@code int}, {@code long}, {@code float} and
4280      * {@code double}.
4281      * &lt;p&gt;
4282      * Access will result in a {@code ReadOnlyBufferException} for anything
4283      * other than the read access modes if the {@code ByteBuffer} is read-only.
4284      * &lt;p&gt;
4285      * Access of bytes at a given index will result in an
4286      * {@code IndexOutOfBoundsException} if the index is less than {@code 0}
4287      * or greater than the {@code ByteBuffer} limit minus the size (in bytes) of
4288      * {@code T}.
4289      * &lt;p&gt;
4290      * Access of bytes at an index may be aligned or misaligned for {@code T},
4291      * with respect to the underlying memory address, {@code A} say, associated
4292      * with the {@code ByteBuffer} and index.
4293      * If access is misaligned then access for anything other than the
4294      * {@code get} and {@code set} access modes will result in an
4295      * {@code IllegalStateException}.  In such cases atomic access is only
4296      * guaranteed with respect to the largest power of two that divides the GCD
4297      * of {@code A} and the size (in bytes) of {@code T}.
4298      * If access is aligned then following access modes are supported and are
4299      * guaranteed to support atomic access:
4300      * &lt;ul&gt;
4301      * &lt;li&gt;read write access modes for all {@code T}, with the exception of
4302      *     access modes {@code get} and {@code set} for {@code long} and
4303      *     {@code double} on 32-bit platforms.
4304      * &lt;li&gt;atomic update access modes for {@code int}, {@code long},
4305      *     {@code float} or {@code double}.
4306      *     (Future major platform releases of the JDK may support additional
4307      *     types for certain currently unsupported access modes.)
4308      * &lt;li&gt;numeric atomic update access modes for {@code int} and {@code long}.
4309      *     (Future major platform releases of the JDK may support additional
4310      *     numeric types for certain currently unsupported access modes.)
4311      * &lt;li&gt;bitwise atomic update access modes for {@code int} and {@code long}.
4312      *     (Future major platform releases of the JDK may support additional
4313      *     numeric types for certain currently unsupported access modes.)
4314      * &lt;/ul&gt;
4315      * &lt;p&gt;
4316      * Misaligned access, and therefore atomicity guarantees, may be determined
4317      * for a {@code ByteBuffer}, {@code bb} (direct or otherwise), an
4318      * {@code index}, {@code T} and it&#39;s corresponding boxed type,
4319      * {@code T_BOX}, as follows:
4320      * &lt;pre&gt;{@code
4321      * int sizeOfT = T_BOX.BYTES;  // size in bytes of T
4322      * ByteBuffer bb = ...
4323      * int misalignedAtIndex = bb.alignmentOffset(index, sizeOfT);
4324      * boolean isMisaligned = misalignedAtIndex != 0;
4325      * }&lt;/pre&gt;
4326      * &lt;p&gt;
4327      * If the variable type is {@code float} or {@code double} then atomic
4328      * update access modes compare values using their bitwise representation
4329      * (see {@link Float#floatToRawIntBits} and
4330      * {@link Double#doubleToRawLongBits}, respectively).
4331      * @param viewArrayClass the view array class, with a component type of
4332      * type {@code T}
4333      * @param byteOrder the endianness of the view array elements, as
4334      * stored in the underlying {@code ByteBuffer} (Note this overrides the
4335      * endianness of a {@code ByteBuffer})
4336      * @return a VarHandle giving access to elements of a {@code ByteBuffer}
4337      * viewed as if elements corresponding to the components type of the view
4338      * array class
4339      * @throws NullPointerException if viewArrayClass or byteOrder is null
4340      * @throws IllegalArgumentException if viewArrayClass is not an array type
4341      * @throws UnsupportedOperationException if the component type of
4342      * viewArrayClass is not supported as a variable type
4343      * @since 9
4344      */
4345     public static VarHandle byteBufferViewVarHandle(Class&lt;?&gt; viewArrayClass,
4346                                       ByteOrder byteOrder) throws IllegalArgumentException {
4347         Objects.requireNonNull(byteOrder);
4348         return VarHandles.makeByteBufferViewHandle(viewArrayClass,
4349                                                    byteOrder == ByteOrder.BIG_ENDIAN);
4350     }
4351 
4352 
4353     /// method handle invocation (reflective style)
4354 
4355     /**
4356      * Produces a method handle which will invoke any method handle of the
4357      * given {@code type}, with a given number of trailing arguments replaced by
4358      * a single trailing {@code Object[]} array.
4359      * The resulting invoker will be a method handle with the following
4360      * arguments:
4361      * &lt;ul&gt;
4362      * &lt;li&gt;a single {@code MethodHandle} target
4363      * &lt;li&gt;zero or more leading values (counted by {@code leadingArgCount})
4364      * &lt;li&gt;an {@code Object[]} array containing trailing arguments
4365      * &lt;/ul&gt;
4366      * &lt;p&gt;
4367      * The invoker will invoke its target like a call to {@link MethodHandle#invoke invoke} with
4368      * the indicated {@code type}.
4369      * That is, if the target is exactly of the given {@code type}, it will behave
4370      * like {@code invokeExact}; otherwise it behave as if {@link MethodHandle#asType asType}
4371      * is used to convert the target to the required {@code type}.
4372      * &lt;p&gt;
4373      * The type of the returned invoker will not be the given {@code type}, but rather
4374      * will have all parameters except the first {@code leadingArgCount}
4375      * replaced by a single array of type {@code Object[]}, which will be
4376      * the final parameter.
4377      * &lt;p&gt;
4378      * Before invoking its target, the invoker will spread the final array, apply
4379      * reference casts as necessary, and unbox and widen primitive arguments.
4380      * If, when the invoker is called, the supplied array argument does
4381      * not have the correct number of elements, the invoker will throw
4382      * an {@link IllegalArgumentException} instead of invoking the target.
4383      * &lt;p&gt;
4384      * This method is equivalent to the following code (though it may be more efficient):
4385      * &lt;blockquote&gt;&lt;pre&gt;{@code
4386 MethodHandle invoker = MethodHandles.invoker(type);
4387 int spreadArgCount = type.parameterCount() - leadingArgCount;
4388 invoker = invoker.asSpreader(Object[].class, spreadArgCount);
4389 return invoker;
4390      * }&lt;/pre&gt;&lt;/blockquote&gt;
4391      * This method throws no reflective or security exceptions.
4392      * @param type the desired target type
4393      * @param leadingArgCount number of fixed arguments, to be passed unchanged to the target
4394      * @return a method handle suitable for invoking any method handle of the given type
4395      * @throws NullPointerException if {@code type} is null
4396      * @throws IllegalArgumentException if {@code leadingArgCount} is not in
4397      *                  the range from 0 to {@code type.parameterCount()} inclusive,
4398      *                  or if the resulting method handle&#39;s type would have
4399      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
4400      */
4401     public static MethodHandle spreadInvoker(MethodType type, int leadingArgCount) {
4402         if (leadingArgCount &lt; 0 || leadingArgCount &gt; type.parameterCount())
4403             throw newIllegalArgumentException(&quot;bad argument count&quot;, leadingArgCount);
4404         type = type.asSpreaderType(Object[].class, leadingArgCount, type.parameterCount() - leadingArgCount);
4405         return type.invokers().spreadInvoker(leadingArgCount);
4406     }
4407 
4408     /**
4409      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
4410      * invoke any method handle of the given type, as if by {@link MethodHandle#invokeExact invokeExact}.
4411      * The resulting invoker will have a type which is
4412      * exactly equal to the desired type, except that it will accept
4413      * an additional leading argument of type {@code MethodHandle}.
4414      * &lt;p&gt;
4415      * This method is equivalent to the following code (though it may be more efficient):
4416      * {@code publicLookup().findVirtual(MethodHandle.class, &quot;invokeExact&quot;, type)}
4417      *
4418      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
4419      * &lt;em&gt;Discussion:&lt;/em&gt;
4420      * Invoker method handles can be useful when working with variable method handles
4421      * of unknown types.
4422      * For example, to emulate an {@code invokeExact} call to a variable method
4423      * handle {@code M}, extract its type {@code T},
4424      * look up the invoker method {@code X} for {@code T},
4425      * and call the invoker method, as {@code X.invoke(T, A...)}.
4426      * (It would not work to call {@code X.invokeExact}, since the type {@code T}
4427      * is unknown.)
4428      * If spreading, collecting, or other argument transformations are required,
4429      * they can be applied once to the invoker {@code X} and reused on many {@code M}
4430      * method handle values, as long as they are compatible with the type of {@code X}.
4431      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
4432      * &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
4433      * An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
4434      * on the declared {@code invokeExact} or {@code invoke} method will raise an
4435      * {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;
4436      * &lt;p&gt;
4437      * This method throws no reflective or security exceptions.
4438      * @param type the desired target type
4439      * @return a method handle suitable for invoking any method handle of the given type
4440      * @throws IllegalArgumentException if the resulting method handle&#39;s type would have
4441      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
4442      */
4443     public static MethodHandle exactInvoker(MethodType type) {
4444         return type.invokers().exactInvoker();
4445     }
4446 
4447     /**
4448      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
4449      * invoke any method handle compatible with the given type, as if by {@link MethodHandle#invoke invoke}.
4450      * The resulting invoker will have a type which is
4451      * exactly equal to the desired type, except that it will accept
4452      * an additional leading argument of type {@code MethodHandle}.
4453      * &lt;p&gt;
4454      * Before invoking its target, if the target differs from the expected type,
4455      * the invoker will apply reference casts as
4456      * necessary and box, unbox, or widen primitive values, as if by {@link MethodHandle#asType asType}.
4457      * Similarly, the return value will be converted as necessary.
4458      * If the target is a {@linkplain MethodHandle#asVarargsCollector variable arity method handle},
4459      * the required arity conversion will be made, again as if by {@link MethodHandle#asType asType}.
4460      * &lt;p&gt;
4461      * This method is equivalent to the following code (though it may be more efficient):
4462      * {@code publicLookup().findVirtual(MethodHandle.class, &quot;invoke&quot;, type)}
4463      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
4464      * &lt;em&gt;Discussion:&lt;/em&gt;
4465      * A {@linkplain MethodType#genericMethodType general method type} is one which
4466      * mentions only {@code Object} arguments and return values.
4467      * An invoker for such a type is capable of calling any method handle
4468      * of the same arity as the general type.
4469      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
4470      * &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
4471      * An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
4472      * on the declared {@code invokeExact} or {@code invoke} method will raise an
4473      * {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;
4474      * &lt;p&gt;
4475      * This method throws no reflective or security exceptions.
4476      * @param type the desired target type
4477      * @return a method handle suitable for invoking any method handle convertible to the given type
4478      * @throws IllegalArgumentException if the resulting method handle&#39;s type would have
4479      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
4480      */
4481     public static MethodHandle invoker(MethodType type) {
4482         return type.invokers().genericInvoker();
4483     }
4484 
4485     /**
4486      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
4487      * invoke a signature-polymorphic access mode method on any VarHandle whose
4488      * associated access mode type is compatible with the given type.
4489      * The resulting invoker will have a type which is exactly equal to the
4490      * desired given type, except that it will accept an additional leading
4491      * argument of type {@code VarHandle}.
4492      *
4493      * @param accessMode the VarHandle access mode
4494      * @param type the desired target type
4495      * @return a method handle suitable for invoking an access mode method of
4496      *         any VarHandle whose access mode type is of the given type.
4497      * @since 9
4498      */
4499     public static MethodHandle varHandleExactInvoker(VarHandle.AccessMode accessMode, MethodType type) {
4500         return type.invokers().varHandleMethodExactInvoker(accessMode);
4501     }
4502 
4503     /**
4504      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
4505      * invoke a signature-polymorphic access mode method on any VarHandle whose
4506      * associated access mode type is compatible with the given type.
4507      * The resulting invoker will have a type which is exactly equal to the
4508      * desired given type, except that it will accept an additional leading
4509      * argument of type {@code VarHandle}.
4510      * &lt;p&gt;
4511      * Before invoking its target, if the access mode type differs from the
4512      * desired given type, the invoker will apply reference casts as necessary
4513      * and box, unbox, or widen primitive values, as if by
4514      * {@link MethodHandle#asType asType}.  Similarly, the return value will be
4515      * converted as necessary.
4516      * &lt;p&gt;
4517      * This method is equivalent to the following code (though it may be more
4518      * efficient): {@code publicLookup().findVirtual(VarHandle.class, accessMode.name(), type)}
4519      *
4520      * @param accessMode the VarHandle access mode
4521      * @param type the desired target type
4522      * @return a method handle suitable for invoking an access mode method of
4523      *         any VarHandle whose access mode type is convertible to the given
4524      *         type.
4525      * @since 9
4526      */
4527     public static MethodHandle varHandleInvoker(VarHandle.AccessMode accessMode, MethodType type) {
4528         return type.invokers().varHandleMethodInvoker(accessMode);
4529     }
4530 
4531     /*non-public*/
4532     static MethodHandle basicInvoker(MethodType type) {
4533         return type.invokers().basicInvoker();
4534     }
4535 
4536      /// method handle modification (creation from other method handles)
4537 
4538     /**
4539      * Produces a method handle which adapts the type of the
4540      * given method handle to a new type by pairwise argument and return type conversion.
4541      * The original type and new type must have the same number of arguments.
4542      * The resulting method handle is guaranteed to report a type
4543      * which is equal to the desired new type.
4544      * &lt;p&gt;
4545      * If the original type and new type are equal, returns target.
4546      * &lt;p&gt;
4547      * The same conversions are allowed as for {@link MethodHandle#asType MethodHandle.asType},
4548      * and some additional conversions are also applied if those conversions fail.
4549      * Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied
4550      * if possible, before or instead of any conversions done by {@code asType}:
4551      * &lt;ul&gt;
4552      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, and &lt;em&gt;T1&lt;/em&gt; is an interface type,
4553      *     then the value of type &lt;em&gt;T0&lt;/em&gt; is passed as a &lt;em&gt;T1&lt;/em&gt; without a cast.
4554      *     (This treatment of interfaces follows the usage of the bytecode verifier.)
4555      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is boolean and &lt;em&gt;T1&lt;/em&gt; is another primitive,
4556      *     the boolean is converted to a byte value, 1 for true, 0 for false.
4557      *     (This treatment follows the usage of the bytecode verifier.)
4558      * &lt;li&gt;If &lt;em&gt;T1&lt;/em&gt; is boolean and &lt;em&gt;T0&lt;/em&gt; is another primitive,
4559      *     &lt;em&gt;T0&lt;/em&gt; is converted to byte via Java casting conversion (JLS 5.5),
4560      *     and the low order bit of the result is tested, as if by {@code (x &amp; 1) != 0}.
4561      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives other than boolean,
4562      *     then a Java casting conversion (JLS 5.5) is applied.
4563      *     (Specifically, &lt;em&gt;T0&lt;/em&gt; will convert to &lt;em&gt;T1&lt;/em&gt; by
4564      *     widening and/or narrowing.)
4565      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing
4566      *     conversion will be applied at runtime, possibly followed
4567      *     by a Java casting conversion (JLS 5.5) on the primitive value,
4568      *     possibly followed by a conversion from byte to boolean by testing
4569      *     the low-order bit.
4570      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive,
4571      *     and if the reference is null at runtime, a zero value is introduced.
4572      * &lt;/ul&gt;
4573      * @param target the method handle to invoke after arguments are retyped
4574      * @param newType the expected type of the new method handle
4575      * @return a method handle which delegates to the target after performing
4576      *           any necessary argument conversions, and arranges for any
4577      *           necessary return value conversions
4578      * @throws NullPointerException if either argument is null
4579      * @throws WrongMethodTypeException if the conversion cannot be made
4580      * @see MethodHandle#asType
4581      */
4582     public static MethodHandle explicitCastArguments(MethodHandle target, MethodType newType) {
4583         explicitCastArgumentsChecks(target, newType);
4584         // use the asTypeCache when possible:
4585         MethodType oldType = target.type();
4586         if (oldType == newType)  return target;
4587         if (oldType.explicitCastEquivalentToAsType(newType)) {
4588             return target.asFixedArity().asType(newType);
4589         }
4590         return MethodHandleImpl.makePairwiseConvert(target, newType, false);
4591     }
4592 
4593     private static void explicitCastArgumentsChecks(MethodHandle target, MethodType newType) {
4594         if (target.type().parameterCount() != newType.parameterCount()) {
4595             throw new WrongMethodTypeException(&quot;cannot explicitly cast &quot; + target + &quot; to &quot; + newType);
4596         }
4597     }
4598 
4599     /**
4600      * Produces a method handle which adapts the calling sequence of the
4601      * given method handle to a new type, by reordering the arguments.
4602      * The resulting method handle is guaranteed to report a type
4603      * which is equal to the desired new type.
4604      * &lt;p&gt;
4605      * The given array controls the reordering.
4606      * Call {@code #I} the number of incoming parameters (the value
4607      * {@code newType.parameterCount()}, and call {@code #O} the number
4608      * of outgoing parameters (the value {@code target.type().parameterCount()}).
4609      * Then the length of the reordering array must be {@code #O},
4610      * and each element must be a non-negative number less than {@code #I}.
4611      * For every {@code N} less than {@code #O}, the {@code N}-th
4612      * outgoing argument will be taken from the {@code I}-th incoming
4613      * argument, where {@code I} is {@code reorder[N]}.
4614      * &lt;p&gt;
4615      * No argument or return value conversions are applied.
4616      * The type of each incoming argument, as determined by {@code newType},
4617      * must be identical to the type of the corresponding outgoing parameter
4618      * or parameters in the target method handle.
4619      * The return type of {@code newType} must be identical to the return
4620      * type of the original target.
4621      * &lt;p&gt;
4622      * The reordering array need not specify an actual permutation.
4623      * An incoming argument will be duplicated if its index appears
4624      * more than once in the array, and an incoming argument will be dropped
4625      * if its index does not appear in the array.
4626      * As in the case of {@link #dropArguments(MethodHandle,int,List) dropArguments},
4627      * incoming arguments which are not mentioned in the reordering array
4628      * may be of any type, as determined only by {@code newType}.
4629      * &lt;blockquote&gt;&lt;pre&gt;{@code
4630 import static java.lang.invoke.MethodHandles.*;
4631 import static java.lang.invoke.MethodType.*;
4632 ...
4633 MethodType intfn1 = methodType(int.class, int.class);
4634 MethodType intfn2 = methodType(int.class, int.class, int.class);
4635 MethodHandle sub = ... (int x, int y) -&gt; (x-y) ...;
4636 assert(sub.type().equals(intfn2));
4637 MethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);
4638 MethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);
4639 assert((int)rsub.invokeExact(1, 100) == 99);
4640 MethodHandle add = ... (int x, int y) -&gt; (x+y) ...;
4641 assert(add.type().equals(intfn2));
4642 MethodHandle twice = permuteArguments(add, intfn1, 0, 0);
4643 assert(twice.type().equals(intfn1));
4644 assert((int)twice.invokeExact(21) == 42);
4645      * }&lt;/pre&gt;&lt;/blockquote&gt;
4646      * &lt;p&gt;
4647      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4648      * variable-arity method handle}, even if the original target method handle was.
4649      * @param target the method handle to invoke after arguments are reordered
4650      * @param newType the expected type of the new method handle
4651      * @param reorder an index array which controls the reordering
4652      * @return a method handle which delegates to the target after it
4653      *           drops unused arguments and moves and/or duplicates the other arguments
4654      * @throws NullPointerException if any argument is null
4655      * @throws IllegalArgumentException if the index array length is not equal to
4656      *                  the arity of the target, or if any index array element
4657      *                  not a valid index for a parameter of {@code newType},
4658      *                  or if two corresponding parameter types in
4659      *                  {@code target.type()} and {@code newType} are not identical,
4660      */
4661     public static MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder) {
4662         reorder = reorder.clone();  // get a private copy
4663         MethodType oldType = target.type();
4664         permuteArgumentChecks(reorder, newType, oldType);
4665         // first detect dropped arguments and handle them separately
4666         int[] originalReorder = reorder;
4667         BoundMethodHandle result = target.rebind();
4668         LambdaForm form = result.form;
4669         int newArity = newType.parameterCount();
4670         // Normalize the reordering into a real permutation,
4671         // by removing duplicates and adding dropped elements.
4672         // This somewhat improves lambda form caching, as well
4673         // as simplifying the transform by breaking it up into steps.
4674         for (int ddIdx; (ddIdx = findFirstDupOrDrop(reorder, newArity)) != 0; ) {
4675             if (ddIdx &gt; 0) {
4676                 // We found a duplicated entry at reorder[ddIdx].
4677                 // Example:  (x,y,z)-&gt;asList(x,y,z)
4678                 // permuted by [1*,0,1] =&gt; (a0,a1)=&gt;asList(a1,a0,a1)
4679                 // permuted by [0,1,0*] =&gt; (a0,a1)=&gt;asList(a0,a1,a0)
4680                 // The starred element corresponds to the argument
4681                 // deleted by the dupArgumentForm transform.
4682                 int srcPos = ddIdx, dstPos = srcPos, dupVal = reorder[srcPos];
4683                 boolean killFirst = false;
4684                 for (int val; (val = reorder[--dstPos]) != dupVal; ) {
4685                     // Set killFirst if the dup is larger than an intervening position.
4686                     // This will remove at least one inversion from the permutation.
4687                     if (dupVal &gt; val) killFirst = true;
4688                 }
4689                 if (!killFirst) {
4690                     srcPos = dstPos;
4691                     dstPos = ddIdx;
4692                 }
4693                 form = form.editor().dupArgumentForm(1 + srcPos, 1 + dstPos);
4694                 assert (reorder[srcPos] == reorder[dstPos]);
4695                 oldType = oldType.dropParameterTypes(dstPos, dstPos + 1);
4696                 // contract the reordering by removing the element at dstPos
4697                 int tailPos = dstPos + 1;
4698                 System.arraycopy(reorder, tailPos, reorder, dstPos, reorder.length - tailPos);
4699                 reorder = Arrays.copyOf(reorder, reorder.length - 1);
4700             } else {
4701                 int dropVal = ~ddIdx, insPos = 0;
4702                 while (insPos &lt; reorder.length &amp;&amp; reorder[insPos] &lt; dropVal) {
4703                     // Find first element of reorder larger than dropVal.
4704                     // This is where we will insert the dropVal.
4705                     insPos += 1;
4706                 }
4707                 Class&lt;?&gt; ptype = newType.parameterType(dropVal);
4708                 form = form.editor().addArgumentForm(1 + insPos, BasicType.basicType(ptype));
4709                 oldType = oldType.insertParameterTypes(insPos, ptype);
4710                 // expand the reordering by inserting an element at insPos
4711                 int tailPos = insPos + 1;
4712                 reorder = Arrays.copyOf(reorder, reorder.length + 1);
4713                 System.arraycopy(reorder, insPos, reorder, tailPos, reorder.length - tailPos);
4714                 reorder[insPos] = dropVal;
4715             }
4716             assert (permuteArgumentChecks(reorder, newType, oldType));
4717         }
4718         assert (reorder.length == newArity);  // a perfect permutation
4719         // Note:  This may cache too many distinct LFs. Consider backing off to varargs code.
4720         form = form.editor().permuteArgumentsForm(1, reorder);
4721         if (newType == result.type() &amp;&amp; form == result.internalForm())
4722             return result;
4723         return result.copyWith(newType, form);
4724     }
4725 
4726     /**
4727      * Return an indication of any duplicate or omission in reorder.
4728      * If the reorder contains a duplicate entry, return the index of the second occurrence.
4729      * Otherwise, return ~(n), for the first n in [0..newArity-1] that is not present in reorder.
4730      * Otherwise, return zero.
4731      * If an element not in [0..newArity-1] is encountered, return reorder.length.
4732      */
4733     private static int findFirstDupOrDrop(int[] reorder, int newArity) {
4734         final int BIT_LIMIT = 63;  // max number of bits in bit mask
4735         if (newArity &lt; BIT_LIMIT) {
4736             long mask = 0;
4737             for (int i = 0; i &lt; reorder.length; i++) {
4738                 int arg = reorder[i];
4739                 if (arg &gt;= newArity) {
4740                     return reorder.length;
4741                 }
4742                 long bit = 1L &lt;&lt; arg;
4743                 if ((mask &amp; bit) != 0) {
4744                     return i;  // &gt;0 indicates a dup
4745                 }
4746                 mask |= bit;
4747             }
4748             if (mask == (1L &lt;&lt; newArity) - 1) {
4749                 assert(Long.numberOfTrailingZeros(Long.lowestOneBit(~mask)) == newArity);
4750                 return 0;
4751             }
4752             // find first zero
4753             long zeroBit = Long.lowestOneBit(~mask);
4754             int zeroPos = Long.numberOfTrailingZeros(zeroBit);
4755             assert(zeroPos &lt;= newArity);
4756             if (zeroPos == newArity) {
4757                 return 0;
4758             }
4759             return ~zeroPos;
4760         } else {
4761             // same algorithm, different bit set
4762             BitSet mask = new BitSet(newArity);
4763             for (int i = 0; i &lt; reorder.length; i++) {
4764                 int arg = reorder[i];
4765                 if (arg &gt;= newArity) {
4766                     return reorder.length;
4767                 }
4768                 if (mask.get(arg)) {
4769                     return i;  // &gt;0 indicates a dup
4770                 }
4771                 mask.set(arg);
4772             }
4773             int zeroPos = mask.nextClearBit(0);
4774             assert(zeroPos &lt;= newArity);
4775             if (zeroPos == newArity) {
4776                 return 0;
4777             }
4778             return ~zeroPos;
4779         }
4780     }
4781 
4782     static boolean permuteArgumentChecks(int[] reorder, MethodType newType, MethodType oldType) {
4783         if (newType.returnType() != oldType.returnType())
4784             throw newIllegalArgumentException(&quot;return types do not match&quot;,
4785                     oldType, newType);
4786         if (reorder.length == oldType.parameterCount()) {
4787             int limit = newType.parameterCount();
4788             boolean bad = false;
4789             for (int j = 0; j &lt; reorder.length; j++) {
4790                 int i = reorder[j];
4791                 if (i &lt; 0 || i &gt;= limit) {
4792                     bad = true; break;
4793                 }
4794                 Class&lt;?&gt; src = newType.parameterType(i);
4795                 Class&lt;?&gt; dst = oldType.parameterType(j);
4796                 if (src != dst)
4797                     throw newIllegalArgumentException(&quot;parameter types do not match after reorder&quot;,
4798                             oldType, newType);
4799             }
4800             if (!bad)  return true;
4801         }
4802         throw newIllegalArgumentException(&quot;bad reorder array: &quot;+Arrays.toString(reorder));
4803     }
4804 
4805     /**
4806      * Produces a method handle of the requested return type which returns the given
4807      * constant value every time it is invoked.
4808      * &lt;p&gt;
4809      * Before the method handle is returned, the passed-in value is converted to the requested type.
4810      * If the requested type is primitive, widening primitive conversions are attempted,
4811      * else reference conversions are attempted.
4812      * &lt;p&gt;The returned method handle is equivalent to {@code identity(type).bindTo(value)}.
4813      * @param type the return type of the desired method handle
4814      * @param value the value to return
4815      * @return a method handle of the given return type and no arguments, which always returns the given value
4816      * @throws NullPointerException if the {@code type} argument is null
4817      * @throws ClassCastException if the value cannot be converted to the required return type
4818      * @throws IllegalArgumentException if the given type is {@code void.class}
4819      */
4820     public static MethodHandle constant(Class&lt;?&gt; type, Object value) {
4821         if (type.isPrimitive()) {
4822             if (type == void.class)
4823                 throw newIllegalArgumentException(&quot;void type&quot;);
4824             Wrapper w = Wrapper.forPrimitiveType(type);
4825             value = w.convert(value, type);
4826             if (w.zero().equals(value))
4827                 return zero(w, type);
4828             return insertArguments(identity(type), 0, value);
4829         } else {
4830             if (value == null)
4831                 return zero(Wrapper.OBJECT, type);
4832             return identity(type).bindTo(value);
4833         }
4834     }
4835 
4836     /**
4837      * Produces a method handle which returns its sole argument when invoked.
4838      * @param type the type of the sole parameter and return value of the desired method handle
4839      * @return a unary method handle which accepts and returns the given type
4840      * @throws NullPointerException if the argument is null
4841      * @throws IllegalArgumentException if the given type is {@code void.class}
4842      */
4843     public static MethodHandle identity(Class&lt;?&gt; type) {
4844         Wrapper btw = (type.isPrimitive() ? Wrapper.forPrimitiveType(type) : Wrapper.OBJECT);
4845         int pos = btw.ordinal();
4846         MethodHandle ident = IDENTITY_MHS[pos];
4847         if (ident == null) {
4848             ident = setCachedMethodHandle(IDENTITY_MHS, pos, makeIdentity(btw.primitiveType()));
4849         }
4850         if (ident.type().returnType() == type)
4851             return ident;
4852         // something like identity(Foo.class); do not bother to intern these
4853         assert (btw == Wrapper.OBJECT);
4854         return makeIdentity(type);
4855     }
4856 
4857     /**
4858      * Produces a constant method handle of the requested return type which
4859      * returns the default value for that type every time it is invoked.
4860      * The resulting constant method handle will have no side effects.
4861      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4862      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4863      * since {@code explicitCastArguments} converts {@code null} to default values.
4864      * @param type the expected return type of the desired method handle
4865      * @return a constant method handle that takes no arguments
4866      *         and returns the default value of the given type (or void, if the type is void)
4867      * @throws NullPointerException if the argument is null
4868      * @see MethodHandles#constant
4869      * @see MethodHandles#empty
4870      * @see MethodHandles#explicitCastArguments
4871      * @since 9
4872      */
4873     public static MethodHandle zero(Class&lt;?&gt; type) {
4874         Objects.requireNonNull(type);
<a name="11" id="anc11"></a><span class="line-modified">4875         if (type.isPrimitive()) {</span>
<span class="line-added">4876             return zero(Wrapper.forPrimitiveType(type), type);</span>
<span class="line-added">4877         } else if (type.isInlineClass()) {</span>
<span class="line-added">4878             throw new UnsupportedOperationException();</span>
<span class="line-added">4879         } else {</span>
<span class="line-added">4880             return zero(Wrapper.OBJECT, type);</span>
<span class="line-added">4881         }</span>
4882     }
4883 
4884     private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
4885         return type == void.class ? zero(type) : identity(type);
4886     }
4887 
4888     /**
4889      * Produces a method handle of the requested type which ignores any arguments, does nothing,
4890      * and returns a suitable default depending on the return type.
4891      * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
4892      * &lt;p&gt;The returned method handle is equivalent to
4893      * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
4894      *
4895      * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
4896      * {@code guardWithTest(pred, target, empty(target.type())}.
4897      * @param type the type of the desired method handle
4898      * @return a constant method handle of the given type, which returns a default value of the given return type
4899      * @throws NullPointerException if the argument is null
4900      * @see MethodHandles#zero
4901      * @see MethodHandles#constant
4902      * @since 9
4903      */
4904     public static  MethodHandle empty(MethodType type) {
4905         Objects.requireNonNull(type);
4906         return dropArguments(zero(type.returnType()), 0, type.parameterList());
4907     }
4908 
4909     private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
4910     private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
<a name="12" id="anc12"></a><span class="line-modified">4911         MethodType mtype = MethodType.methodType(ptype, ptype);</span>
4912         LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
4913         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
4914     }
4915 
4916     private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
4917         int pos = btw.ordinal();
4918         MethodHandle zero = ZERO_MHS[pos];
4919         if (zero == null) {
4920             zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
4921         }
4922         if (zero.type().returnType() == rtype)
4923             return zero;
4924         assert(btw == Wrapper.OBJECT);
4925         return makeZero(rtype);
4926     }
4927     private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
4928     private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
4929         MethodType mtype = methodType(rtype);
4930         LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
4931         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
4932     }
4933 
4934     private static synchronized MethodHandle setCachedMethodHandle(MethodHandle[] cache, int pos, MethodHandle value) {
4935         // Simulate a CAS, to avoid racy duplication of results.
4936         MethodHandle prev = cache[pos];
4937         if (prev != null) return prev;
4938         return cache[pos] = value;
4939     }
4940 
4941     /**
4942      * Provides a target method handle with one or more &lt;em&gt;bound arguments&lt;/em&gt;
4943      * in advance of the method handle&#39;s invocation.
4944      * The formal parameters to the target corresponding to the bound
4945      * arguments are called &lt;em&gt;bound parameters&lt;/em&gt;.
4946      * Returns a new method handle which saves away the bound arguments.
4947      * When it is invoked, it receives arguments for any non-bound parameters,
4948      * binds the saved arguments to their corresponding parameters,
4949      * and calls the original target.
4950      * &lt;p&gt;
4951      * The type of the new method handle will drop the types for the bound
4952      * parameters from the original target type, since the new method handle
4953      * will no longer require those arguments to be supplied by its callers.
4954      * &lt;p&gt;
4955      * Each given argument object must match the corresponding bound parameter type.
4956      * If a bound parameter type is a primitive, the argument object
4957      * must be a wrapper, and will be unboxed to produce the primitive value.
4958      * &lt;p&gt;
4959      * The {@code pos} argument selects which parameters are to be bound.
4960      * It may range between zero and &lt;i&gt;N-L&lt;/i&gt; (inclusively),
4961      * where &lt;i&gt;N&lt;/i&gt; is the arity of the target method handle
4962      * and &lt;i&gt;L&lt;/i&gt; is the length of the values array.
4963      * &lt;p&gt;
4964      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4965      * variable-arity method handle}, even if the original target method handle was.
4966      * @param target the method handle to invoke after the argument is inserted
4967      * @param pos where to insert the argument (zero for the first)
4968      * @param values the series of arguments to insert
4969      * @return a method handle which inserts an additional argument,
4970      *         before calling the original method handle
4971      * @throws NullPointerException if the target or the {@code values} array is null
4972      * @throws IllegalArgumentException if (@code pos) is less than {@code 0} or greater than
4973      *         {@code N - L} where {@code N} is the arity of the target method handle and {@code L}
4974      *         is the length of the values array.
4975      * @throws ClassCastException if an argument does not match the corresponding bound parameter
4976      *         type.
4977      * @see MethodHandle#bindTo
4978      */
4979     public static MethodHandle insertArguments(MethodHandle target, int pos, Object... values) {
4980         int insCount = values.length;
4981         Class&lt;?&gt;[] ptypes = insertArgumentsChecks(target, insCount, pos);
4982         if (insCount == 0)  return target;
4983         BoundMethodHandle result = target.rebind();
4984         for (int i = 0; i &lt; insCount; i++) {
4985             Object value = values[i];
4986             Class&lt;?&gt; ptype = ptypes[pos+i];
4987             if (ptype.isPrimitive()) {
4988                 result = insertArgumentPrimitive(result, pos, ptype, value);
4989             } else {
4990                 value = ptype.cast(value);  // throw CCE if needed
4991                 result = result.bindArgumentL(pos, value);
4992             }
4993         }
4994         return result;
4995     }
4996 
4997     private static BoundMethodHandle insertArgumentPrimitive(BoundMethodHandle result, int pos,
4998                                                              Class&lt;?&gt; ptype, Object value) {
4999         Wrapper w = Wrapper.forPrimitiveType(ptype);
5000         // perform unboxing and/or primitive conversion
5001         value = w.convert(value, ptype);
5002         switch (w) {
5003         case INT:     return result.bindArgumentI(pos, (int)value);
5004         case LONG:    return result.bindArgumentJ(pos, (long)value);
5005         case FLOAT:   return result.bindArgumentF(pos, (float)value);
5006         case DOUBLE:  return result.bindArgumentD(pos, (double)value);
5007         default:      return result.bindArgumentI(pos, ValueConversions.widenSubword(value));
5008         }
5009     }
5010 
5011     private static Class&lt;?&gt;[] insertArgumentsChecks(MethodHandle target, int insCount, int pos) throws RuntimeException {
5012         MethodType oldType = target.type();
5013         int outargs = oldType.parameterCount();
5014         int inargs  = outargs - insCount;
5015         if (inargs &lt; 0)
5016             throw newIllegalArgumentException(&quot;too many values to insert&quot;);
5017         if (pos &lt; 0 || pos &gt; inargs)
5018             throw newIllegalArgumentException(&quot;no argument type to append&quot;);
5019         return oldType.ptypes();
5020     }
5021 
5022     /**
5023      * Produces a method handle which will discard some dummy arguments
5024      * before calling some other specified &lt;i&gt;target&lt;/i&gt; method handle.
5025      * The type of the new method handle will be the same as the target&#39;s type,
5026      * except it will also include the dummy argument types,
5027      * at some given position.
5028      * &lt;p&gt;
5029      * The {@code pos} argument may range between zero and &lt;i&gt;N&lt;/i&gt;,
5030      * where &lt;i&gt;N&lt;/i&gt; is the arity of the target.
5031      * If {@code pos} is zero, the dummy arguments will precede
5032      * the target&#39;s real arguments; if {@code pos} is &lt;i&gt;N&lt;/i&gt;
5033      * they will come after.
5034      * &lt;p&gt;
5035      * &lt;b&gt;Example:&lt;/b&gt;
5036      * &lt;blockquote&gt;&lt;pre&gt;{@code
5037 import static java.lang.invoke.MethodHandles.*;
5038 import static java.lang.invoke.MethodType.*;
5039 ...
5040 MethodHandle cat = lookup().findVirtual(String.class,
5041   &quot;concat&quot;, methodType(String.class, String.class));
5042 assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
5043 MethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);
5044 MethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));
5045 assertEquals(bigType, d0.type());
5046 assertEquals(&quot;yz&quot;, (String) d0.invokeExact(123, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
5047      * }&lt;/pre&gt;&lt;/blockquote&gt;
5048      * &lt;p&gt;
5049      * This method is also equivalent to the following code:
5050      * &lt;blockquote&gt;&lt;pre&gt;
5051      * {@link #dropArguments(MethodHandle,int,Class...) dropArguments}{@code (target, pos, valueTypes.toArray(new Class[0]))}
5052      * &lt;/pre&gt;&lt;/blockquote&gt;
5053      * @param target the method handle to invoke after the arguments are dropped
5054      * @param pos position of first argument to drop (zero for the leftmost)
5055      * @param valueTypes the type(s) of the argument(s) to drop
5056      * @return a method handle which drops arguments of the given types,
5057      *         before calling the original method handle
5058      * @throws NullPointerException if the target is null,
5059      *                              or if the {@code valueTypes} list or any of its elements is null
5060      * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
5061      *                  or if {@code pos} is negative or greater than the arity of the target,
5062      *                  or if the new method handle&#39;s type would have too many parameters
5063      */
5064     public static MethodHandle dropArguments(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {
5065         return dropArguments0(target, pos, copyTypes(valueTypes.toArray()));
5066     }
5067 
5068     private static List&lt;Class&lt;?&gt;&gt; copyTypes(Object[] array) {
5069         return Arrays.asList(Arrays.copyOf(array, array.length, Class[].class));
5070     }
5071 
5072     private static MethodHandle dropArguments0(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {
5073         MethodType oldType = target.type();  // get NPE
5074         int dropped = dropArgumentChecks(oldType, pos, valueTypes);
5075         MethodType newType = oldType.insertParameterTypes(pos, valueTypes);
5076         if (dropped == 0)  return target;
5077         BoundMethodHandle result = target.rebind();
5078         LambdaForm lform = result.form;
5079         int insertFormArg = 1 + pos;
5080         for (Class&lt;?&gt; ptype : valueTypes) {
5081             lform = lform.editor().addArgumentForm(insertFormArg++, BasicType.basicType(ptype));
5082         }
5083         result = result.copyWith(newType, lform);
5084         return result;
5085     }
5086 
5087     private static int dropArgumentChecks(MethodType oldType, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {
5088         int dropped = valueTypes.size();
5089         MethodType.checkSlotCount(dropped);
5090         int outargs = oldType.parameterCount();
5091         int inargs  = outargs + dropped;
5092         if (pos &lt; 0 || pos &gt; outargs)
5093             throw newIllegalArgumentException(&quot;no argument type to remove&quot;
5094                     + Arrays.asList(oldType, pos, valueTypes, inargs, outargs)
5095                     );
5096         return dropped;
5097     }
5098 
5099     /**
5100      * Produces a method handle which will discard some dummy arguments
5101      * before calling some other specified &lt;i&gt;target&lt;/i&gt; method handle.
5102      * The type of the new method handle will be the same as the target&#39;s type,
5103      * except it will also include the dummy argument types,
5104      * at some given position.
5105      * &lt;p&gt;
5106      * The {@code pos} argument may range between zero and &lt;i&gt;N&lt;/i&gt;,
5107      * where &lt;i&gt;N&lt;/i&gt; is the arity of the target.
5108      * If {@code pos} is zero, the dummy arguments will precede
5109      * the target&#39;s real arguments; if {@code pos} is &lt;i&gt;N&lt;/i&gt;
5110      * they will come after.
5111      * @apiNote
5112      * &lt;blockquote&gt;&lt;pre&gt;{@code
5113 import static java.lang.invoke.MethodHandles.*;
5114 import static java.lang.invoke.MethodType.*;
5115 ...
5116 MethodHandle cat = lookup().findVirtual(String.class,
5117   &quot;concat&quot;, methodType(String.class, String.class));
5118 assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
5119 MethodHandle d0 = dropArguments(cat, 0, String.class);
5120 assertEquals(&quot;yz&quot;, (String) d0.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
5121 MethodHandle d1 = dropArguments(cat, 1, String.class);
5122 assertEquals(&quot;xz&quot;, (String) d1.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
5123 MethodHandle d2 = dropArguments(cat, 2, String.class);
5124 assertEquals(&quot;xy&quot;, (String) d2.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
5125 MethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);
5126 assertEquals(&quot;xz&quot;, (String) d12.invokeExact(&quot;x&quot;, 12, true, &quot;z&quot;));
5127      * }&lt;/pre&gt;&lt;/blockquote&gt;
5128      * &lt;p&gt;
5129      * This method is also equivalent to the following code:
5130      * &lt;blockquote&gt;&lt;pre&gt;
5131      * {@link #dropArguments(MethodHandle,int,List) dropArguments}{@code (target, pos, Arrays.asList(valueTypes))}
5132      * &lt;/pre&gt;&lt;/blockquote&gt;
5133      * @param target the method handle to invoke after the arguments are dropped
5134      * @param pos position of first argument to drop (zero for the leftmost)
5135      * @param valueTypes the type(s) of the argument(s) to drop
5136      * @return a method handle which drops arguments of the given types,
5137      *         before calling the original method handle
5138      * @throws NullPointerException if the target is null,
5139      *                              or if the {@code valueTypes} array or any of its elements is null
5140      * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
5141      *                  or if {@code pos} is negative or greater than the arity of the target,
5142      *                  or if the new method handle&#39;s type would have
5143      *                  &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
5144      */
5145     public static MethodHandle dropArguments(MethodHandle target, int pos, Class&lt;?&gt;... valueTypes) {
5146         return dropArguments0(target, pos, copyTypes(valueTypes));
5147     }
5148 
5149     // private version which allows caller some freedom with error handling
5150     private static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos,
5151                                       boolean nullOnFailure) {
5152         newTypes = copyTypes(newTypes.toArray());
5153         List&lt;Class&lt;?&gt;&gt; oldTypes = target.type().parameterList();
5154         int match = oldTypes.size();
5155         if (skip != 0) {
5156             if (skip &lt; 0 || skip &gt; match) {
5157                 throw newIllegalArgumentException(&quot;illegal skip&quot;, skip, target);
5158             }
5159             oldTypes = oldTypes.subList(skip, match);
5160             match -= skip;
5161         }
5162         List&lt;Class&lt;?&gt;&gt; addTypes = newTypes;
5163         int add = addTypes.size();
5164         if (pos != 0) {
5165             if (pos &lt; 0 || pos &gt; add) {
5166                 throw newIllegalArgumentException(&quot;illegal pos&quot;, pos, newTypes);
5167             }
5168             addTypes = addTypes.subList(pos, add);
5169             add -= pos;
5170             assert(addTypes.size() == add);
5171         }
5172         // Do not add types which already match the existing arguments.
5173         if (match &gt; add || !oldTypes.equals(addTypes.subList(0, match))) {
5174             if (nullOnFailure) {
5175                 return null;
5176             }
5177             throw newIllegalArgumentException(&quot;argument lists do not match&quot;, oldTypes, newTypes);
5178         }
5179         addTypes = addTypes.subList(match, add);
5180         add -= match;
5181         assert(addTypes.size() == add);
5182         // newTypes:     (   P*[pos], M*[match], A*[add] )
5183         // target: ( S*[skip],        M*[match]  )
5184         MethodHandle adapter = target;
5185         if (add &gt; 0) {
5186             adapter = dropArguments0(adapter, skip+ match, addTypes);
5187         }
5188         // adapter: (S*[skip],        M*[match], A*[add] )
5189         if (pos &gt; 0) {
5190             adapter = dropArguments0(adapter, skip, newTypes.subList(0, pos));
5191         }
5192         // adapter: (S*[skip], P*[pos], M*[match], A*[add] )
5193         return adapter;
5194     }
5195 
5196     /**
5197      * Adapts a target method handle to match the given parameter type list. If necessary, adds dummy arguments. Some
5198      * leading parameters can be skipped before matching begins. The remaining types in the {@code target}&#39;s parameter
5199      * type list must be a sub-list of the {@code newTypes} type list at the starting position {@code pos}. The
5200      * resulting handle will have the target handle&#39;s parameter type list, with any non-matching parameter types (before
5201      * or after the matching sub-list) inserted in corresponding positions of the target&#39;s original parameters, as if by
5202      * {@link #dropArguments(MethodHandle, int, Class[])}.
5203      * &lt;p&gt;
5204      * The resulting handle will have the same return type as the target handle.
5205      * &lt;p&gt;
5206      * In more formal terms, assume these two type lists:&lt;ul&gt;
5207      * &lt;li&gt;The target handle has the parameter type list {@code S..., M...}, with as many types in {@code S} as
5208      * indicated by {@code skip}. The {@code M} types are those that are supposed to match part of the given type list,
5209      * {@code newTypes}.
5210      * &lt;li&gt;The {@code newTypes} list contains types {@code P..., M..., A...}, with as many types in {@code P} as
5211      * indicated by {@code pos}. The {@code M} types are precisely those that the {@code M} types in the target handle&#39;s
5212      * parameter type list are supposed to match. The types in {@code A} are additional types found after the matching
5213      * sub-list.
5214      * &lt;/ul&gt;
5215      * Given these assumptions, the result of an invocation of {@code dropArgumentsToMatch} will have the parameter type
5216      * list {@code S..., P..., M..., A...}, with the {@code P} and {@code A} types inserted as if by
5217      * {@link #dropArguments(MethodHandle, int, Class[])}.
5218      *
5219      * @apiNote
5220      * Two method handles whose argument lists are &quot;effectively identical&quot; (i.e., identical in a common prefix) may be
5221      * mutually converted to a common type by two calls to {@code dropArgumentsToMatch}, as follows:
5222      * &lt;blockquote&gt;&lt;pre&gt;{@code
5223 import static java.lang.invoke.MethodHandles.*;
5224 import static java.lang.invoke.MethodType.*;
5225 ...
5226 ...
5227 MethodHandle h0 = constant(boolean.class, true);
5228 MethodHandle h1 = lookup().findVirtual(String.class, &quot;concat&quot;, methodType(String.class, String.class));
5229 MethodType bigType = h1.type().insertParameterTypes(1, String.class, int.class);
5230 MethodHandle h2 = dropArguments(h1, 0, bigType.parameterList());
5231 if (h1.type().parameterCount() &lt; h2.type().parameterCount())
5232     h1 = dropArgumentsToMatch(h1, 0, h2.type().parameterList(), 0);  // lengthen h1
5233 else
5234     h2 = dropArgumentsToMatch(h2, 0, h1.type().parameterList(), 0);    // lengthen h2
5235 MethodHandle h3 = guardWithTest(h0, h1, h2);
5236 assertEquals(&quot;xy&quot;, h3.invoke(&quot;x&quot;, &quot;y&quot;, 1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
5237      * }&lt;/pre&gt;&lt;/blockquote&gt;
5238      * @param target the method handle to adapt
5239      * @param skip number of targets parameters to disregard (they will be unchanged)
5240      * @param newTypes the list of types to match {@code target}&#39;s parameter type list to
5241      * @param pos place in {@code newTypes} where the non-skipped target parameters must occur
5242      * @return a possibly adapted method handle
5243      * @throws NullPointerException if either argument is null
5244      * @throws IllegalArgumentException if any element of {@code newTypes} is {@code void.class},
5245      *         or if {@code skip} is negative or greater than the arity of the target,
5246      *         or if {@code pos} is negative or greater than the newTypes list size,
5247      *         or if {@code newTypes} does not contain the {@code target}&#39;s non-skipped parameter types at position
5248      *         {@code pos}.
5249      * @since 9
5250      */
5251     public static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos) {
5252         Objects.requireNonNull(target);
5253         Objects.requireNonNull(newTypes);
5254         return dropArgumentsToMatch(target, skip, newTypes, pos, false);
5255     }
5256 
5257     /**
5258      * Adapts a target method handle by pre-processing
5259      * one or more of its arguments, each with its own unary filter function,
5260      * and then calling the target with each pre-processed argument
5261      * replaced by the result of its corresponding filter function.
5262      * &lt;p&gt;
5263      * The pre-processing is performed by one or more method handles,
5264      * specified in the elements of the {@code filters} array.
5265      * The first element of the filter array corresponds to the {@code pos}
5266      * argument of the target, and so on in sequence.
5267      * The filter functions are invoked in left to right order.
5268      * &lt;p&gt;
5269      * Null arguments in the array are treated as identity functions,
5270      * and the corresponding arguments left unchanged.
5271      * (If there are no non-null elements in the array, the original target is returned.)
5272      * Each filter is applied to the corresponding argument of the adapter.
5273      * &lt;p&gt;
5274      * If a filter {@code F} applies to the {@code N}th argument of
5275      * the target, then {@code F} must be a method handle which
5276      * takes exactly one argument.  The type of {@code F}&#39;s sole argument
5277      * replaces the corresponding argument type of the target
5278      * in the resulting adapted method handle.
5279      * The return type of {@code F} must be identical to the corresponding
5280      * parameter type of the target.
5281      * &lt;p&gt;
5282      * It is an error if there are elements of {@code filters}
5283      * (null or not)
5284      * which do not correspond to argument positions in the target.
5285      * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
5286      * &lt;blockquote&gt;&lt;pre&gt;{@code
5287 import static java.lang.invoke.MethodHandles.*;
5288 import static java.lang.invoke.MethodType.*;
5289 ...
5290 MethodHandle cat = lookup().findVirtual(String.class,
5291   &quot;concat&quot;, methodType(String.class, String.class));
5292 MethodHandle upcase = lookup().findVirtual(String.class,
5293   &quot;toUpperCase&quot;, methodType(String.class));
5294 assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
5295 MethodHandle f0 = filterArguments(cat, 0, upcase);
5296 assertEquals(&quot;Xy&quot;, (String) f0.invokeExact(&quot;x&quot;, &quot;y&quot;)); // Xy
5297 MethodHandle f1 = filterArguments(cat, 1, upcase);
5298 assertEquals(&quot;xY&quot;, (String) f1.invokeExact(&quot;x&quot;, &quot;y&quot;)); // xY
5299 MethodHandle f2 = filterArguments(cat, 0, upcase, upcase);
5300 assertEquals(&quot;XY&quot;, (String) f2.invokeExact(&quot;x&quot;, &quot;y&quot;)); // XY
5301      * }&lt;/pre&gt;&lt;/blockquote&gt;
5302      * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code, {@code T}
5303      * denotes the return type of both the {@code target} and resulting adapter.
5304      * {@code P}/{@code p} and {@code B}/{@code b} represent the types and values
5305      * of the parameters and arguments that precede and follow the filter position
5306      * {@code pos}, respectively. {@code A[i]}/{@code a[i]} stand for the types and
5307      * values of the filtered parameters and arguments; they also represent the
5308      * return types of the {@code filter[i]} handles. The latter accept arguments
5309      * {@code v[i]} of type {@code V[i]}, which also appear in the signature of
5310      * the resulting adapter.
5311      * &lt;blockquote&gt;&lt;pre&gt;{@code
5312      * T target(P... p, A[i]... a[i], B... b);
5313      * A[i] filter[i](V[i]);
5314      * T adapter(P... p, V[i]... v[i], B... b) {
5315      *   return target(p..., filter[i](v[i])..., b...);
5316      * }
5317      * }&lt;/pre&gt;&lt;/blockquote&gt;
5318      * &lt;p&gt;
5319      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
5320      * variable-arity method handle}, even if the original target method handle was.
5321      *
5322      * @param target the method handle to invoke after arguments are filtered
5323      * @param pos the position of the first argument to filter
5324      * @param filters method handles to call initially on filtered arguments
5325      * @return method handle which incorporates the specified argument filtering logic
5326      * @throws NullPointerException if the target is null
5327      *                              or if the {@code filters} array is null
5328      * @throws IllegalArgumentException if a non-null element of {@code filters}
5329      *          does not match a corresponding argument type of target as described above,
5330      *          or if the {@code pos+filters.length} is greater than {@code target.type().parameterCount()},
5331      *          or if the resulting method handle&#39;s type would have
5332      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
5333      */
5334     public static MethodHandle filterArguments(MethodHandle target, int pos, MethodHandle... filters) {
5335         // In method types arguments start at index 0, while the LF
5336         // editor have the MH receiver at position 0 - adjust appropriately.
5337         final int MH_RECEIVER_OFFSET = 1;
5338         filterArgumentsCheckArity(target, pos, filters);
5339         MethodHandle adapter = target;
5340 
5341         // keep track of currently matched filters, as to optimize repeated filters
5342         int index = 0;
5343         int[] positions = new int[filters.length];
5344         MethodHandle filter = null;
5345 
5346         // process filters in reverse order so that the invocation of
5347         // the resulting adapter will invoke the filters in left-to-right order
5348         for (int i = filters.length - 1; i &gt;= 0; --i) {
5349             MethodHandle newFilter = filters[i];
5350             if (newFilter == null) continue;  // ignore null elements of filters
5351 
5352             // flush changes on update
5353             if (filter != newFilter) {
5354                 if (filter != null) {
5355                     if (index &gt; 1) {
5356                         adapter = filterRepeatedArgument(adapter, filter, Arrays.copyOf(positions, index));
5357                     } else {
5358                         adapter = filterArgument(adapter, positions[0] - 1, filter);
5359                     }
5360                 }
5361                 filter = newFilter;
5362                 index = 0;
5363             }
5364 
5365             filterArgumentChecks(target, pos + i, newFilter);
5366             positions[index++] = pos + i + MH_RECEIVER_OFFSET;
5367         }
5368         if (index &gt; 1) {
5369             adapter = filterRepeatedArgument(adapter, filter, Arrays.copyOf(positions, index));
5370         } else if (index == 1) {
5371             adapter = filterArgument(adapter, positions[0] - 1, filter);
5372         }
5373         return adapter;
5374     }
5375 
5376     private static MethodHandle filterRepeatedArgument(MethodHandle adapter, MethodHandle filter, int[] positions) {
5377         MethodType targetType = adapter.type();
5378         MethodType filterType = filter.type();
5379         BoundMethodHandle result = adapter.rebind();
5380         Class&lt;?&gt; newParamType = filterType.parameterType(0);
5381 
5382         Class&lt;?&gt;[] ptypes = targetType.ptypes().clone();
5383         for (int pos : positions) {
5384             ptypes[pos - 1] = newParamType;
5385         }
5386         MethodType newType = MethodType.makeImpl(targetType.rtype(), ptypes, true);
5387 
5388         LambdaForm lform = result.editor().filterRepeatedArgumentForm(BasicType.basicType(newParamType), positions);
5389         return result.copyWithExtendL(newType, lform, filter);
5390     }
5391 
5392     /*non-public*/
5393     static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle filter) {
5394         filterArgumentChecks(target, pos, filter);
5395         MethodType targetType = target.type();
5396         MethodType filterType = filter.type();
5397         BoundMethodHandle result = target.rebind();
5398         Class&lt;?&gt; newParamType = filterType.parameterType(0);
5399         LambdaForm lform = result.editor().filterArgumentForm(1 + pos, BasicType.basicType(newParamType));
5400         MethodType newType = targetType.changeParameterType(pos, newParamType);
5401         result = result.copyWithExtendL(newType, lform, filter);
5402         return result;
5403     }
5404 
5405     private static void filterArgumentsCheckArity(MethodHandle target, int pos, MethodHandle[] filters) {
5406         MethodType targetType = target.type();
5407         int maxPos = targetType.parameterCount();
5408         if (pos + filters.length &gt; maxPos)
5409             throw newIllegalArgumentException(&quot;too many filters&quot;);
5410     }
5411 
5412     private static void filterArgumentChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException {
5413         MethodType targetType = target.type();
5414         MethodType filterType = filter.type();
5415         if (filterType.parameterCount() != 1
5416             || filterType.returnType() != targetType.parameterType(pos))
5417             throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
5418     }
5419 
5420     /**
5421      * Adapts a target method handle by pre-processing
5422      * a sub-sequence of its arguments with a filter (another method handle).
5423      * The pre-processed arguments are replaced by the result (if any) of the
5424      * filter function.
5425      * The target is then called on the modified (usually shortened) argument list.
5426      * &lt;p&gt;
5427      * If the filter returns a value, the target must accept that value as
5428      * its argument in position {@code pos}, preceded and/or followed by
5429      * any arguments not passed to the filter.
5430      * If the filter returns void, the target must accept all arguments
5431      * not passed to the filter.
5432      * No arguments are reordered, and a result returned from the filter
5433      * replaces (in order) the whole subsequence of arguments originally
5434      * passed to the adapter.
5435      * &lt;p&gt;
5436      * The argument types (if any) of the filter
5437      * replace zero or one argument types of the target, at position {@code pos},
5438      * in the resulting adapted method handle.
5439      * The return type of the filter (if any) must be identical to the
5440      * argument type of the target at position {@code pos}, and that target argument
5441      * is supplied by the return value of the filter.
5442      * &lt;p&gt;
5443      * In all cases, {@code pos} must be greater than or equal to zero, and
5444      * {@code pos} must also be less than or equal to the target&#39;s arity.
5445      * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
5446      * &lt;blockquote&gt;&lt;pre&gt;{@code
5447 import static java.lang.invoke.MethodHandles.*;
5448 import static java.lang.invoke.MethodType.*;
5449 ...
5450 MethodHandle deepToString = publicLookup()
5451   .findStatic(Arrays.class, &quot;deepToString&quot;, methodType(String.class, Object[].class));
5452 
5453 MethodHandle ts1 = deepToString.asCollector(String[].class, 1);
5454 assertEquals(&quot;[strange]&quot;, (String) ts1.invokeExact(&quot;strange&quot;));
5455 
5456 MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
5457 assertEquals(&quot;[up, down]&quot;, (String) ts2.invokeExact(&quot;up&quot;, &quot;down&quot;));
5458 
5459 MethodHandle ts3 = deepToString.asCollector(String[].class, 3);
5460 MethodHandle ts3_ts2 = collectArguments(ts3, 1, ts2);
5461 assertEquals(&quot;[top, [up, down], strange]&quot;,
5462              (String) ts3_ts2.invokeExact(&quot;top&quot;, &quot;up&quot;, &quot;down&quot;, &quot;strange&quot;));
5463 
5464 MethodHandle ts3_ts2_ts1 = collectArguments(ts3_ts2, 3, ts1);
5465 assertEquals(&quot;[top, [up, down], [strange]]&quot;,
5466              (String) ts3_ts2_ts1.invokeExact(&quot;top&quot;, &quot;up&quot;, &quot;down&quot;, &quot;strange&quot;));
5467 
5468 MethodHandle ts3_ts2_ts3 = collectArguments(ts3_ts2, 1, ts3);
5469 assertEquals(&quot;[top, [[up, down, strange], charm], bottom]&quot;,
5470              (String) ts3_ts2_ts3.invokeExact(&quot;top&quot;, &quot;up&quot;, &quot;down&quot;, &quot;strange&quot;, &quot;charm&quot;, &quot;bottom&quot;));
5471      * }&lt;/pre&gt;&lt;/blockquote&gt;
5472      * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code, {@code T}
5473      * represents the return type of the {@code target} and resulting adapter.
5474      * {@code V}/{@code v} stand for the return type and value of the
5475      * {@code filter}, which are also found in the signature and arguments of
5476      * the {@code target}, respectively, unless {@code V} is {@code void}.
5477      * {@code A}/{@code a} and {@code C}/{@code c} represent the parameter types
5478      * and values preceding and following the collection position, {@code pos},
5479      * in the {@code target}&#39;s signature. They also turn up in the resulting
5480      * adapter&#39;s signature and arguments, where they surround
5481      * {@code B}/{@code b}, which represent the parameter types and arguments
5482      * to the {@code filter} (if any).
5483      * &lt;blockquote&gt;&lt;pre&gt;{@code
5484      * T target(A...,V,C...);
5485      * V filter(B...);
5486      * T adapter(A... a,B... b,C... c) {
5487      *   V v = filter(b...);
5488      *   return target(a...,v,c...);
5489      * }
5490      * // and if the filter has no arguments:
5491      * T target2(A...,V,C...);
5492      * V filter2();
5493      * T adapter2(A... a,C... c) {
5494      *   V v = filter2();
5495      *   return target2(a...,v,c...);
5496      * }
5497      * // and if the filter has a void return:
5498      * T target3(A...,C...);
5499      * void filter3(B...);
5500      * T adapter3(A... a,B... b,C... c) {
5501      *   filter3(b...);
5502      *   return target3(a...,c...);
5503      * }
5504      * }&lt;/pre&gt;&lt;/blockquote&gt;
5505      * &lt;p&gt;
5506      * A collection adapter {@code collectArguments(mh, 0, coll)} is equivalent to
5507      * one which first &quot;folds&quot; the affected arguments, and then drops them, in separate
5508      * steps as follows:
5509      * &lt;blockquote&gt;&lt;pre&gt;{@code
5510      * mh = MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2
5511      * mh = MethodHandles.foldArguments(mh, coll); //step 1
5512      * }&lt;/pre&gt;&lt;/blockquote&gt;
5513      * If the target method handle consumes no arguments besides than the result
5514      * (if any) of the filter {@code coll}, then {@code collectArguments(mh, 0, coll)}
5515      * is equivalent to {@code filterReturnValue(coll, mh)}.
5516      * If the filter method handle {@code coll} consumes one argument and produces
5517      * a non-void result, then {@code collectArguments(mh, N, coll)}
5518      * is equivalent to {@code filterArguments(mh, N, coll)}.
5519      * Other equivalences are possible but would require argument permutation.
5520      * &lt;p&gt;
5521      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
5522      * variable-arity method handle}, even if the original target method handle was.
5523      *
5524      * @param target the method handle to invoke after filtering the subsequence of arguments
5525      * @param pos the position of the first adapter argument to pass to the filter,
5526      *            and/or the target argument which receives the result of the filter
5527      * @param filter method handle to call on the subsequence of arguments
5528      * @return method handle which incorporates the specified argument subsequence filtering logic
5529      * @throws NullPointerException if either argument is null
5530      * @throws IllegalArgumentException if the return type of {@code filter}
5531      *          is non-void and is not the same as the {@code pos} argument of the target,
5532      *          or if {@code pos} is not between 0 and the target&#39;s arity, inclusive,
5533      *          or if the resulting method handle&#39;s type would have
5534      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
5535      * @see MethodHandles#foldArguments
5536      * @see MethodHandles#filterArguments
5537      * @see MethodHandles#filterReturnValue
5538      */
5539     public static MethodHandle collectArguments(MethodHandle target, int pos, MethodHandle filter) {
5540         MethodType newType = collectArgumentsChecks(target, pos, filter);
5541         MethodType collectorType = filter.type();
5542         BoundMethodHandle result = target.rebind();
5543         LambdaForm lform;
5544         if (collectorType.returnType().isArray() &amp;&amp; filter.intrinsicName() == Intrinsic.NEW_ARRAY) {
5545             lform = result.editor().collectArgumentArrayForm(1 + pos, filter);
5546             if (lform != null) {
5547                 return result.copyWith(newType, lform);
5548             }
5549         }
5550         lform = result.editor().collectArgumentsForm(1 + pos, collectorType.basicType());
5551         return result.copyWithExtendL(newType, lform, filter);
5552     }
5553 
5554     private static MethodType collectArgumentsChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException {
5555         MethodType targetType = target.type();
5556         MethodType filterType = filter.type();
5557         Class&lt;?&gt; rtype = filterType.returnType();
5558         List&lt;Class&lt;?&gt;&gt; filterArgs = filterType.parameterList();
5559         if (rtype == void.class) {
5560             return targetType.insertParameterTypes(pos, filterArgs);
5561         }
5562         if (rtype != targetType.parameterType(pos)) {
5563             throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
5564         }
5565         return targetType.dropParameterTypes(pos, pos+1).insertParameterTypes(pos, filterArgs);
5566     }
5567 
5568     /**
5569      * Adapts a target method handle by post-processing
5570      * its return value (if any) with a filter (another method handle).
5571      * The result of the filter is returned from the adapter.
5572      * &lt;p&gt;
5573      * If the target returns a value, the filter must accept that value as
5574      * its only argument.
5575      * If the target returns void, the filter must accept no arguments.
5576      * &lt;p&gt;
5577      * The return type of the filter
5578      * replaces the return type of the target
5579      * in the resulting adapted method handle.
5580      * The argument type of the filter (if any) must be identical to the
5581      * return type of the target.
5582      * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
5583      * &lt;blockquote&gt;&lt;pre&gt;{@code
5584 import static java.lang.invoke.MethodHandles.*;
5585 import static java.lang.invoke.MethodType.*;
5586 ...
5587 MethodHandle cat = lookup().findVirtual(String.class,
5588   &quot;concat&quot;, methodType(String.class, String.class));
5589 MethodHandle length = lookup().findVirtual(String.class,
5590   &quot;length&quot;, methodType(int.class));
5591 System.out.println((String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;)); // xy
5592 MethodHandle f0 = filterReturnValue(cat, length);
5593 System.out.println((int) f0.invokeExact(&quot;x&quot;, &quot;y&quot;)); // 2
5594      * }&lt;/pre&gt;&lt;/blockquote&gt;
5595      * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code,
5596      * {@code T}/{@code t} represent the result type and value of the
5597      * {@code target}; {@code V}, the result type of the {@code filter}; and
5598      * {@code A}/{@code a}, the types and values of the parameters and arguments
5599      * of the {@code target} as well as the resulting adapter.
5600      * &lt;blockquote&gt;&lt;pre&gt;{@code
5601      * T target(A...);
5602      * V filter(T);
5603      * V adapter(A... a) {
5604      *   T t = target(a...);
5605      *   return filter(t);
5606      * }
5607      * // and if the target has a void return:
5608      * void target2(A...);
5609      * V filter2();
5610      * V adapter2(A... a) {
5611      *   target2(a...);
5612      *   return filter2();
5613      * }
5614      * // and if the filter has a void return:
5615      * T target3(A...);
5616      * void filter3(V);
5617      * void adapter3(A... a) {
5618      *   T t = target3(a...);
5619      *   filter3(t);
5620      * }
5621      * }&lt;/pre&gt;&lt;/blockquote&gt;
5622      * &lt;p&gt;
5623      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
5624      * variable-arity method handle}, even if the original target method handle was.
5625      * @param target the method handle to invoke before filtering the return value
5626      * @param filter method handle to call on the return value
5627      * @return method handle which incorporates the specified return value filtering logic
5628      * @throws NullPointerException if either argument is null
5629      * @throws IllegalArgumentException if the argument list of {@code filter}
5630      *          does not match the return type of target as described above
5631      */
5632     public static MethodHandle filterReturnValue(MethodHandle target, MethodHandle filter) {
5633         MethodType targetType = target.type();
5634         MethodType filterType = filter.type();
5635         filterReturnValueChecks(targetType, filterType);
5636         BoundMethodHandle result = target.rebind();
5637         BasicType rtype = BasicType.basicType(filterType.returnType());
5638         LambdaForm lform = result.editor().filterReturnForm(rtype, false);
5639         MethodType newType = targetType.changeReturnType(filterType.returnType());
5640         result = result.copyWithExtendL(newType, lform, filter);
5641         return result;
5642     }
5643 
5644     private static void filterReturnValueChecks(MethodType targetType, MethodType filterType) throws RuntimeException {
5645         Class&lt;?&gt; rtype = targetType.returnType();
5646         int filterValues = filterType.parameterCount();
5647         if (filterValues == 0
5648                 ? (rtype != void.class)
5649                 : (rtype != filterType.parameterType(0) || filterValues != 1))
5650             throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
5651     }
5652 
5653     /**
5654      * Filter the return value of a target method handle with a filter function. The filter function is
5655      * applied to the return value of the original handle; if the filter specifies more than one parameters,
5656      * then any remaining parameter is appended to the adapter handle. In other words, the adaptation works
5657      * as follows:
5658      * &lt;blockquote&gt;&lt;pre&gt;{@code
5659      * T target(A...)
5660      * V filter(B... , T)
5661      * V adapter(A... a, B... b) {
5662      *     T t = target(a...);
5663      *     return filter(b..., t);
5664      * }&lt;/pre&gt;&lt;/blockquote&gt;
5665      * &lt;p&gt;
5666      * If the filter handle is a unary function, then this method behaves like {@link #filterReturnValue(MethodHandle, MethodHandle)}.
5667      *
5668      * @param target the target method handle
5669      * @param filter the filter method handle
5670      * @return the adapter method handle
5671      */
5672     /* package */ static MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter) {
5673         MethodType targetType = target.type();
5674         MethodType filterType = filter.type();
5675         BoundMethodHandle result = target.rebind();
5676         LambdaForm lform = result.editor().collectReturnValueForm(filterType.basicType());
5677         MethodType newType = targetType.changeReturnType(filterType.returnType());
5678         if (filterType.parameterList().size() &gt; 1) {
5679             for (int i = 0 ; i &lt; filterType.parameterList().size() - 1 ; i++) {
5680                 newType = newType.appendParameterTypes(filterType.parameterType(i));
5681             }
5682         }
5683         result = result.copyWithExtendL(newType, lform, filter);
5684         return result;
5685     }
5686 
5687     /**
5688      * Adapts a target method handle by pre-processing
5689      * some of its arguments, and then calling the target with
5690      * the result of the pre-processing, inserted into the original
5691      * sequence of arguments.
5692      * &lt;p&gt;
5693      * The pre-processing is performed by {@code combiner}, a second method handle.
5694      * Of the arguments passed to the adapter, the first {@code N} arguments
5695      * are copied to the combiner, which is then called.
5696      * (Here, {@code N} is defined as the parameter count of the combiner.)
5697      * After this, control passes to the target, with any result
5698      * from the combiner inserted before the original {@code N} incoming
5699      * arguments.
5700      * &lt;p&gt;
5701      * If the combiner returns a value, the first parameter type of the target
5702      * must be identical with the return type of the combiner, and the next
5703      * {@code N} parameter types of the target must exactly match the parameters
5704      * of the combiner.
5705      * &lt;p&gt;
5706      * If the combiner has a void return, no result will be inserted,
5707      * and the first {@code N} parameter types of the target
5708      * must exactly match the parameters of the combiner.
5709      * &lt;p&gt;
5710      * The resulting adapter is the same type as the target, except that the
5711      * first parameter type is dropped,
5712      * if it corresponds to the result of the combiner.
5713      * &lt;p&gt;
5714      * (Note that {@link #dropArguments(MethodHandle,int,List) dropArguments} can be used to remove any arguments
5715      * that either the combiner or the target does not wish to receive.
5716      * If some of the incoming arguments are destined only for the combiner,
5717      * consider using {@link MethodHandle#asCollector asCollector} instead, since those
5718      * arguments will not need to be live on the stack on entry to the
5719      * target.)
5720      * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
5721      * &lt;blockquote&gt;&lt;pre&gt;{@code
5722 import static java.lang.invoke.MethodHandles.*;
5723 import static java.lang.invoke.MethodType.*;
5724 ...
5725 MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
5726   &quot;println&quot;, methodType(void.class, String.class))
5727     .bindTo(System.out);
5728 MethodHandle cat = lookup().findVirtual(String.class,
5729   &quot;concat&quot;, methodType(String.class, String.class));
5730 assertEquals(&quot;boojum&quot;, (String) cat.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
5731 MethodHandle catTrace = foldArguments(cat, trace);
5732 // also prints &quot;boo&quot;:
5733 assertEquals(&quot;boojum&quot;, (String) catTrace.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
5734      * }&lt;/pre&gt;&lt;/blockquote&gt;
5735      * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code, {@code T}
5736      * represents the result type of the {@code target} and resulting adapter.
5737      * {@code V}/{@code v} represent the type and value of the parameter and argument
5738      * of {@code target} that precedes the folding position; {@code V} also is
5739      * the result type of the {@code combiner}. {@code A}/{@code a} denote the
5740      * types and values of the {@code N} parameters and arguments at the folding
5741      * position. {@code B}/{@code b} represent the types and values of the
5742      * {@code target} parameters and arguments that follow the folded parameters
5743      * and arguments.
5744      * &lt;blockquote&gt;&lt;pre&gt;{@code
5745      * // there are N arguments in A...
5746      * T target(V, A[N]..., B...);
5747      * V combiner(A...);
5748      * T adapter(A... a, B... b) {
5749      *   V v = combiner(a...);
5750      *   return target(v, a..., b...);
5751      * }
5752      * // and if the combiner has a void return:
5753      * T target2(A[N]..., B...);
5754      * void combiner2(A...);
5755      * T adapter2(A... a, B... b) {
5756      *   combiner2(a...);
5757      *   return target2(a..., b...);
5758      * }
5759      * }&lt;/pre&gt;&lt;/blockquote&gt;
5760      * &lt;p&gt;
5761      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
5762      * variable-arity method handle}, even if the original target method handle was.
5763      * @param target the method handle to invoke after arguments are combined
5764      * @param combiner method handle to call initially on the incoming arguments
5765      * @return method handle which incorporates the specified argument folding logic
5766      * @throws NullPointerException if either argument is null
5767      * @throws IllegalArgumentException if {@code combiner}&#39;s return type
5768      *          is non-void and not the same as the first argument type of
5769      *          the target, or if the initial {@code N} argument types
5770      *          of the target
5771      *          (skipping one matching the {@code combiner}&#39;s return type)
5772      *          are not identical with the argument types of {@code combiner}
5773      */
5774     public static MethodHandle foldArguments(MethodHandle target, MethodHandle combiner) {
5775         return foldArguments(target, 0, combiner);
5776     }
5777 
5778     /**
5779      * Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then
5780      * calling the target with the result of the pre-processing, inserted into the original sequence of arguments just
5781      * before the folded arguments.
5782      * &lt;p&gt;
5783      * This method is closely related to {@link #foldArguments(MethodHandle, MethodHandle)}, but allows to control the
5784      * position in the parameter list at which folding takes place. The argument controlling this, {@code pos}, is a
5785      * zero-based index. The aforementioned method {@link #foldArguments(MethodHandle, MethodHandle)} assumes position
5786      * 0.
5787      *
5788      * @apiNote Example:
5789      * &lt;blockquote&gt;&lt;pre&gt;{@code
5790     import static java.lang.invoke.MethodHandles.*;
5791     import static java.lang.invoke.MethodType.*;
5792     ...
5793     MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
5794     &quot;println&quot;, methodType(void.class, String.class))
5795     .bindTo(System.out);
5796     MethodHandle cat = lookup().findVirtual(String.class,
5797     &quot;concat&quot;, methodType(String.class, String.class));
5798     assertEquals(&quot;boojum&quot;, (String) cat.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
5799     MethodHandle catTrace = foldArguments(cat, 1, trace);
5800     // also prints &quot;jum&quot;:
5801     assertEquals(&quot;boojum&quot;, (String) catTrace.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
5802      * }&lt;/pre&gt;&lt;/blockquote&gt;
5803      * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code, {@code T}
5804      * represents the result type of the {@code target} and resulting adapter.
5805      * {@code V}/{@code v} represent the type and value of the parameter and argument
5806      * of {@code target} that precedes the folding position; {@code V} also is
5807      * the result type of the {@code combiner}. {@code A}/{@code a} denote the
5808      * types and values of the {@code N} parameters and arguments at the folding
5809      * position. {@code Z}/{@code z} and {@code B}/{@code b} represent the types
5810      * and values of the {@code target} parameters and arguments that precede and
5811      * follow the folded parameters and arguments starting at {@code pos},
5812      * respectively.
5813      * &lt;blockquote&gt;&lt;pre&gt;{@code
5814      * // there are N arguments in A...
5815      * T target(Z..., V, A[N]..., B...);
5816      * V combiner(A...);
5817      * T adapter(Z... z, A... a, B... b) {
5818      *   V v = combiner(a...);
5819      *   return target(z..., v, a..., b...);
5820      * }
5821      * // and if the combiner has a void return:
5822      * T target2(Z..., A[N]..., B...);
5823      * void combiner2(A...);
5824      * T adapter2(Z... z, A... a, B... b) {
5825      *   combiner2(a...);
5826      *   return target2(z..., a..., b...);
5827      * }
5828      * }&lt;/pre&gt;&lt;/blockquote&gt;
5829      * &lt;p&gt;
5830      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
5831      * variable-arity method handle}, even if the original target method handle was.
5832      *
5833      * @param target the method handle to invoke after arguments are combined
5834      * @param pos the position at which to start folding and at which to insert the folding result; if this is {@code
5835      *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.
5836      * @param combiner method handle to call initially on the incoming arguments
5837      * @return method handle which incorporates the specified argument folding logic
5838      * @throws NullPointerException if either argument is null
5839      * @throws IllegalArgumentException if either of the following two conditions holds:
5840      *          (1) {@code combiner}&#39;s return type is non-{@code void} and not the same as the argument type at position
5841      *              {@code pos} of the target signature;
5842      *          (2) the {@code N} argument types at position {@code pos} of the target signature (skipping one matching
5843      *              the {@code combiner}&#39;s return type) are not identical with the argument types of {@code combiner}.
5844      *
5845      * @see #foldArguments(MethodHandle, MethodHandle)
5846      * @since 9
5847      */
5848     public static MethodHandle foldArguments(MethodHandle target, int pos, MethodHandle combiner) {
5849         MethodType targetType = target.type();
5850         MethodType combinerType = combiner.type();
5851         Class&lt;?&gt; rtype = foldArgumentChecks(pos, targetType, combinerType);
5852         BoundMethodHandle result = target.rebind();
5853         boolean dropResult = rtype == void.class;
5854         LambdaForm lform = result.editor().foldArgumentsForm(1 + pos, dropResult, combinerType.basicType());
5855         MethodType newType = targetType;
5856         if (!dropResult) {
5857             newType = newType.dropParameterTypes(pos, pos + 1);
5858         }
5859         result = result.copyWithExtendL(newType, lform, combiner);
5860         return result;
5861     }
5862 
5863     private static Class&lt;?&gt; foldArgumentChecks(int foldPos, MethodType targetType, MethodType combinerType) {
5864         int foldArgs   = combinerType.parameterCount();
5865         Class&lt;?&gt; rtype = combinerType.returnType();
5866         int foldVals = rtype == void.class ? 0 : 1;
5867         int afterInsertPos = foldPos + foldVals;
5868         boolean ok = (targetType.parameterCount() &gt;= afterInsertPos + foldArgs);
5869         if (ok) {
5870             for (int i = 0; i &lt; foldArgs; i++) {
5871                 if (combinerType.parameterType(i) != targetType.parameterType(i + afterInsertPos)) {
5872                     ok = false;
5873                     break;
5874                 }
5875             }
5876         }
5877         if (ok &amp;&amp; foldVals != 0 &amp;&amp; combinerType.returnType() != targetType.parameterType(foldPos))
5878             ok = false;
5879         if (!ok)
5880             throw misMatchedTypes(&quot;target and combiner types&quot;, targetType, combinerType);
5881         return rtype;
5882     }
5883 
5884     /**
5885      * Adapts a target method handle by pre-processing some of its arguments, then calling the target with the result
5886      * of the pre-processing replacing the argument at the given position.
5887      *
5888      * @param target the method handle to invoke after arguments are combined
5889      * @param position the position at which to start folding and at which to insert the folding result; if this is {@code
5890      *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.
5891      * @param combiner method handle to call initially on the incoming arguments
5892      * @param argPositions indexes of the target to pick arguments sent to the combiner from
5893      * @return method handle which incorporates the specified argument folding logic
5894      * @throws NullPointerException if either argument is null
5895      * @throws IllegalArgumentException if either of the following two conditions holds:
5896      *          (1) {@code combiner}&#39;s return type is not the same as the argument type at position
5897      *              {@code pos} of the target signature;
5898      *          (2) the {@code N} argument types at positions {@code argPositions[1...N]} of the target signature are
5899      *              not identical with the argument types of {@code combiner}.
5900      */
5901     /*non-public*/
5902     static MethodHandle filterArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {
5903         return argumentsWithCombiner(true, target, position, combiner, argPositions);
5904     }
5905 
5906     /**
5907      * Adapts a target method handle by pre-processing some of its arguments, calling the target with the result of
5908      * the pre-processing inserted into the original sequence of arguments at the given position.
5909      *
5910      * @param target the method handle to invoke after arguments are combined
5911      * @param position the position at which to start folding and at which to insert the folding result; if this is {@code
5912      *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.
5913      * @param combiner method handle to call initially on the incoming arguments
5914      * @param argPositions indexes of the target to pick arguments sent to the combiner from
5915      * @return method handle which incorporates the specified argument folding logic
5916      * @throws NullPointerException if either argument is null
5917      * @throws IllegalArgumentException if either of the following two conditions holds:
5918      *          (1) {@code combiner}&#39;s return type is non-{@code void} and not the same as the argument type at position
5919      *              {@code pos} of the target signature;
5920      *          (2) the {@code N} argument types at positions {@code argPositions[1...N]} of the target signature
5921      *              (skipping {@code position} where the {@code combiner}&#39;s return will be folded in) are not identical
5922      *              with the argument types of {@code combiner}.
5923      */
5924     /*non-public*/
5925     static MethodHandle foldArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {
5926         return argumentsWithCombiner(false, target, position, combiner, argPositions);
5927     }
5928 
5929     private static MethodHandle argumentsWithCombiner(boolean filter, MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {
5930         MethodType targetType = target.type();
5931         MethodType combinerType = combiner.type();
5932         Class&lt;?&gt; rtype = argumentsWithCombinerChecks(position, filter, targetType, combinerType, argPositions);
5933         BoundMethodHandle result = target.rebind();
5934 
5935         MethodType newType = targetType;
5936         LambdaForm lform;
5937         if (filter) {
5938             lform = result.editor().filterArgumentsForm(1 + position, combinerType.basicType(), argPositions);
5939         } else {
5940             boolean dropResult = rtype == void.class;
5941             lform = result.editor().foldArgumentsForm(1 + position, dropResult, combinerType.basicType(), argPositions);
5942             if (!dropResult) {
5943                 newType = newType.dropParameterTypes(position, position + 1);
5944             }
5945         }
5946         result = result.copyWithExtendL(newType, lform, combiner);
5947         return result;
5948     }
5949 
5950     private static Class&lt;?&gt; argumentsWithCombinerChecks(int position, boolean filter, MethodType targetType, MethodType combinerType, int ... argPos) {
5951         int combinerArgs = combinerType.parameterCount();
5952         if (argPos.length != combinerArgs) {
5953             throw newIllegalArgumentException(&quot;combiner and argument map must be equal size&quot;, combinerType, argPos.length);
5954         }
5955         Class&lt;?&gt; rtype = combinerType.returnType();
5956 
5957         for (int i = 0; i &lt; combinerArgs; i++) {
5958             int arg = argPos[i];
5959             if (arg &lt; 0 || arg &gt; targetType.parameterCount()) {
5960                 throw newIllegalArgumentException(&quot;arg outside of target parameterRange&quot;, targetType, arg);
5961             }
5962             if (combinerType.parameterType(i) != targetType.parameterType(arg)) {
5963                 throw newIllegalArgumentException(&quot;target argument type at position &quot; + arg
5964                         + &quot; must match combiner argument type at index &quot; + i + &quot;: &quot; + targetType
5965                         + &quot; -&gt; &quot; + combinerType + &quot;, map: &quot; + Arrays.toString(argPos));
5966             }
5967         }
5968         if (filter &amp;&amp; combinerType.returnType() != targetType.parameterType(position)) {
5969             throw misMatchedTypes(&quot;target and combiner types&quot;, targetType, combinerType);
5970         }
5971         return rtype;
5972     }
5973 
5974     /**
5975      * Makes a method handle which adapts a target method handle,
5976      * by guarding it with a test, a boolean-valued method handle.
5977      * If the guard fails, a fallback handle is called instead.
5978      * All three method handles must have the same corresponding
5979      * argument and return types, except that the return type
5980      * of the test must be boolean, and the test is allowed
5981      * to have fewer arguments than the other two method handles.
5982      * &lt;p&gt;
5983      * Here is pseudocode for the resulting adapter. In the code, {@code T}
5984      * represents the uniform result type of the three involved handles;
5985      * {@code A}/{@code a}, the types and values of the {@code target}
5986      * parameters and arguments that are consumed by the {@code test}; and
5987      * {@code B}/{@code b}, those types and values of the {@code target}
5988      * parameters and arguments that are not consumed by the {@code test}.
5989      * &lt;blockquote&gt;&lt;pre&gt;{@code
5990      * boolean test(A...);
5991      * T target(A...,B...);
5992      * T fallback(A...,B...);
5993      * T adapter(A... a,B... b) {
5994      *   if (test(a...))
5995      *     return target(a..., b...);
5996      *   else
5997      *     return fallback(a..., b...);
5998      * }
5999      * }&lt;/pre&gt;&lt;/blockquote&gt;
6000      * Note that the test arguments ({@code a...} in the pseudocode) cannot
6001      * be modified by execution of the test, and so are passed unchanged
6002      * from the caller to the target or fallback as appropriate.
6003      * @param test method handle used for test, must return boolean
6004      * @param target method handle to call if test passes
6005      * @param fallback method handle to call if test fails
6006      * @return method handle which incorporates the specified if/then/else logic
6007      * @throws NullPointerException if any argument is null
6008      * @throws IllegalArgumentException if {@code test} does not return boolean,
6009      *          or if all three method types do not match (with the return
6010      *          type of {@code test} changed to match that of the target).
6011      */
6012     public static MethodHandle guardWithTest(MethodHandle test,
6013                                MethodHandle target,
6014                                MethodHandle fallback) {
6015         MethodType gtype = test.type();
6016         MethodType ttype = target.type();
6017         MethodType ftype = fallback.type();
6018         if (!ttype.equals(ftype))
6019             throw misMatchedTypes(&quot;target and fallback types&quot;, ttype, ftype);
6020         if (gtype.returnType() != boolean.class)
6021             throw newIllegalArgumentException(&quot;guard type is not a predicate &quot;+gtype);
6022         List&lt;Class&lt;?&gt;&gt; targs = ttype.parameterList();
6023         test = dropArgumentsToMatch(test, 0, targs, 0, true);
6024         if (test == null) {
6025             throw misMatchedTypes(&quot;target and test types&quot;, ttype, gtype);
6026         }
6027         return MethodHandleImpl.makeGuardWithTest(test, target, fallback);
6028     }
6029 
6030     static &lt;T&gt; RuntimeException misMatchedTypes(String what, T t1, T t2) {
6031         return newIllegalArgumentException(what + &quot; must match: &quot; + t1 + &quot; != &quot; + t2);
6032     }
6033 
6034     /**
6035      * Makes a method handle which adapts a target method handle,
6036      * by running it inside an exception handler.
6037      * If the target returns normally, the adapter returns that value.
6038      * If an exception matching the specified type is thrown, the fallback
6039      * handle is called instead on the exception, plus the original arguments.
6040      * &lt;p&gt;
6041      * The target and handler must have the same corresponding
6042      * argument and return types, except that handler may omit trailing arguments
6043      * (similarly to the predicate in {@link #guardWithTest guardWithTest}).
6044      * Also, the handler must have an extra leading parameter of {@code exType} or a supertype.
6045      * &lt;p&gt;
6046      * Here is pseudocode for the resulting adapter. In the code, {@code T}
6047      * represents the return type of the {@code target} and {@code handler},
6048      * and correspondingly that of the resulting adapter; {@code A}/{@code a},
6049      * the types and values of arguments to the resulting handle consumed by
6050      * {@code handler}; and {@code B}/{@code b}, those of arguments to the
6051      * resulting handle discarded by {@code handler}.
6052      * &lt;blockquote&gt;&lt;pre&gt;{@code
6053      * T target(A..., B...);
6054      * T handler(ExType, A...);
6055      * T adapter(A... a, B... b) {
6056      *   try {
6057      *     return target(a..., b...);
6058      *   } catch (ExType ex) {
6059      *     return handler(ex, a...);
6060      *   }
6061      * }
6062      * }&lt;/pre&gt;&lt;/blockquote&gt;
6063      * Note that the saved arguments ({@code a...} in the pseudocode) cannot
6064      * be modified by execution of the target, and so are passed unchanged
6065      * from the caller to the handler, if the handler is invoked.
6066      * &lt;p&gt;
6067      * The target and handler must return the same type, even if the handler
6068      * always throws.  (This might happen, for instance, because the handler
6069      * is simulating a {@code finally} clause).
6070      * To create such a throwing handler, compose the handler creation logic
6071      * with {@link #throwException throwException},
6072      * in order to create a method handle of the correct return type.
6073      * @param target method handle to call
6074      * @param exType the type of exception which the handler will catch
6075      * @param handler method handle to call if a matching exception is thrown
6076      * @return method handle which incorporates the specified try/catch logic
6077      * @throws NullPointerException if any argument is null
6078      * @throws IllegalArgumentException if {@code handler} does not accept
6079      *          the given exception type, or if the method handle types do
6080      *          not match in their return types and their
6081      *          corresponding parameters
6082      * @see MethodHandles#tryFinally(MethodHandle, MethodHandle)
6083      */
6084     public static MethodHandle catchException(MethodHandle target,
6085                                 Class&lt;? extends Throwable&gt; exType,
6086                                 MethodHandle handler) {
6087         MethodType ttype = target.type();
6088         MethodType htype = handler.type();
6089         if (!Throwable.class.isAssignableFrom(exType))
6090             throw new ClassCastException(exType.getName());
6091         if (htype.parameterCount() &lt; 1 ||
6092             !htype.parameterType(0).isAssignableFrom(exType))
6093             throw newIllegalArgumentException(&quot;handler does not accept exception type &quot;+exType);
6094         if (htype.returnType() != ttype.returnType())
6095             throw misMatchedTypes(&quot;target and handler return types&quot;, ttype, htype);
6096         handler = dropArgumentsToMatch(handler, 1, ttype.parameterList(), 0, true);
6097         if (handler == null) {
6098             throw misMatchedTypes(&quot;target and handler types&quot;, ttype, htype);
6099         }
6100         return MethodHandleImpl.makeGuardWithCatch(target, exType, handler);
6101     }
6102 
6103     /**
6104      * Produces a method handle which will throw exceptions of the given {@code exType}.
6105      * The method handle will accept a single argument of {@code exType},
6106      * and immediately throw it as an exception.
6107      * The method type will nominally specify a return of {@code returnType}.
6108      * The return type may be anything convenient:  It doesn&#39;t matter to the
6109      * method handle&#39;s behavior, since it will never return normally.
6110      * @param returnType the return type of the desired method handle
6111      * @param exType the parameter type of the desired method handle
6112      * @return method handle which can throw the given exceptions
6113      * @throws NullPointerException if either argument is null
6114      */
6115     public static MethodHandle throwException(Class&lt;?&gt; returnType, Class&lt;? extends Throwable&gt; exType) {
6116         if (!Throwable.class.isAssignableFrom(exType))
6117             throw new ClassCastException(exType.getName());
6118         return MethodHandleImpl.throwException(methodType(returnType, exType));
6119     }
6120 
6121     /**
6122      * Constructs a method handle representing a loop with several loop variables that are updated and checked upon each
6123      * iteration. Upon termination of the loop due to one of the predicates, a corresponding finalizer is run and
6124      * delivers the loop&#39;s result, which is the return value of the resulting handle.
6125      * &lt;p&gt;
6126      * Intuitively, every loop is formed by one or more &quot;clauses&quot;, each specifying a local &lt;em&gt;iteration variable&lt;/em&gt; and/or a loop
6127      * exit. Each iteration of the loop executes each clause in order. A clause can optionally update its iteration
6128      * variable; it can also optionally perform a test and conditional loop exit. In order to express this logic in
6129      * terms of method handles, each clause will specify up to four independent actions:&lt;ul&gt;
6130      * &lt;li&gt;&lt;em&gt;init:&lt;/em&gt; Before the loop executes, the initialization of an iteration variable {@code v} of type {@code V}.
6131      * &lt;li&gt;&lt;em&gt;step:&lt;/em&gt; When a clause executes, an update step for the iteration variable {@code v}.
6132      * &lt;li&gt;&lt;em&gt;pred:&lt;/em&gt; When a clause executes, a predicate execution to test for loop exit.
6133      * &lt;li&gt;&lt;em&gt;fini:&lt;/em&gt; If a clause causes a loop exit, a finalizer execution to compute the loop&#39;s return value.
6134      * &lt;/ul&gt;
6135      * The full sequence of all iteration variable types, in clause order, will be notated as {@code (V...)}.
6136      * The values themselves will be {@code (v...)}.  When we speak of &quot;parameter lists&quot;, we will usually
6137      * be referring to types, but in some contexts (describing execution) the lists will be of actual values.
6138      * &lt;p&gt;
6139      * Some of these clause parts may be omitted according to certain rules, and useful default behavior is provided in
6140      * this case. See below for a detailed description.
6141      * &lt;p&gt;
6142      * &lt;em&gt;Parameters optional everywhere:&lt;/em&gt;
6143      * Each clause function is allowed but not required to accept a parameter for each iteration variable {@code v}.
6144      * As an exception, the init functions cannot take any {@code v} parameters,
6145      * because those values are not yet computed when the init functions are executed.
6146      * Any clause function may neglect to take any trailing subsequence of parameters it is entitled to take.
6147      * In fact, any clause function may take no arguments at all.
6148      * &lt;p&gt;
6149      * &lt;em&gt;Loop parameters:&lt;/em&gt;
6150      * A clause function may take all the iteration variable values it is entitled to, in which case
6151      * it may also take more trailing parameters. Such extra values are called &lt;em&gt;loop parameters&lt;/em&gt;,
6152      * with their types and values notated as {@code (A...)} and {@code (a...)}.
6153      * These become the parameters of the resulting loop handle, to be supplied whenever the loop is executed.
6154      * (Since init functions do not accept iteration variables {@code v}, any parameter to an
6155      * init function is automatically a loop parameter {@code a}.)
6156      * As with iteration variables, clause functions are allowed but not required to accept loop parameters.
6157      * These loop parameters act as loop-invariant values visible across the whole loop.
6158      * &lt;p&gt;
6159      * &lt;em&gt;Parameters visible everywhere:&lt;/em&gt;
6160      * Each non-init clause function is permitted to observe the entire loop state, because it can be passed the full
6161      * list {@code (v... a...)} of current iteration variable values and incoming loop parameters.
6162      * The init functions can observe initial pre-loop state, in the form {@code (a...)}.
6163      * Most clause functions will not need all of this information, but they will be formally connected to it
6164      * as if by {@link #dropArguments}.
6165      * &lt;a id=&quot;astar&quot;&gt;&lt;/a&gt;
6166      * More specifically, we shall use the notation {@code (V*)} to express an arbitrary prefix of a full
6167      * sequence {@code (V...)} (and likewise for {@code (v*)}, {@code (A*)}, {@code (a*)}).
6168      * In that notation, the general form of an init function parameter list
6169      * is {@code (A*)}, and the general form of a non-init function parameter list is {@code (V*)} or {@code (V... A*)}.
6170      * &lt;p&gt;
6171      * &lt;em&gt;Checking clause structure:&lt;/em&gt;
6172      * Given a set of clauses, there is a number of checks and adjustments performed to connect all the parts of the
6173      * loop. They are spelled out in detail in the steps below. In these steps, every occurrence of the word &quot;must&quot;
6174      * corresponds to a place where {@link IllegalArgumentException} will be thrown if the required constraint is not
6175      * met by the inputs to the loop combinator.
6176      * &lt;p&gt;
6177      * &lt;em&gt;Effectively identical sequences:&lt;/em&gt;
6178      * &lt;a id=&quot;effid&quot;&gt;&lt;/a&gt;
6179      * A parameter list {@code A} is defined to be &lt;em&gt;effectively identical&lt;/em&gt; to another parameter list {@code B}
6180      * if {@code A} and {@code B} are identical, or if {@code A} is shorter and is identical with a proper prefix of {@code B}.
6181      * When speaking of an unordered set of parameter lists, we say they the set is &quot;effectively identical&quot;
6182      * as a whole if the set contains a longest list, and all members of the set are effectively identical to
6183      * that longest list.
6184      * For example, any set of type sequences of the form {@code (V*)} is effectively identical,
6185      * and the same is true if more sequences of the form {@code (V... A*)} are added.
6186      * &lt;p&gt;
6187      * &lt;em&gt;Step 0: Determine clause structure.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
6188      * &lt;li&gt;The clause array (of type {@code MethodHandle[][]}) must be non-{@code null} and contain at least one element.
6189      * &lt;li&gt;The clause array may not contain {@code null}s or sub-arrays longer than four elements.
6190      * &lt;li&gt;Clauses shorter than four elements are treated as if they were padded by {@code null} elements to length
6191      * four. Padding takes place by appending elements to the array.
6192      * &lt;li&gt;Clauses with all {@code null}s are disregarded.
6193      * &lt;li&gt;Each clause is treated as a four-tuple of functions, called &quot;init&quot;, &quot;step&quot;, &quot;pred&quot;, and &quot;fini&quot;.
6194      * &lt;/ol&gt;
6195      * &lt;p&gt;
6196      * &lt;em&gt;Step 1A: Determine iteration variable types {@code (V...)}.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
6197      * &lt;li&gt;The iteration variable type for each clause is determined using the clause&#39;s init and step return types.
6198      * &lt;li&gt;If both functions are omitted, there is no iteration variable for the corresponding clause ({@code void} is
6199      * used as the type to indicate that). If one of them is omitted, the other&#39;s return type defines the clause&#39;s
6200      * iteration variable type. If both are given, the common return type (they must be identical) defines the clause&#39;s
6201      * iteration variable type.
6202      * &lt;li&gt;Form the list of return types (in clause order), omitting all occurrences of {@code void}.
6203      * &lt;li&gt;This list of types is called the &quot;iteration variable types&quot; ({@code (V...)}).
6204      * &lt;/ol&gt;
6205      * &lt;p&gt;
6206      * &lt;em&gt;Step 1B: Determine loop parameters {@code (A...)}.&lt;/em&gt;&lt;ul&gt;
6207      * &lt;li&gt;Examine and collect init function parameter lists (which are of the form {@code (A*)}).
6208      * &lt;li&gt;Examine and collect the suffixes of the step, pred, and fini parameter lists, after removing the iteration variable types.
6209      * (They must have the form {@code (V... A*)}; collect the {@code (A*)} parts only.)
6210      * &lt;li&gt;Do not collect suffixes from step, pred, and fini parameter lists that do not begin with all the iteration variable types.
6211      * (These types will be checked in step 2, along with all the clause function types.)
6212      * &lt;li&gt;Omitted clause functions are ignored.  (Equivalently, they are deemed to have empty parameter lists.)
6213      * &lt;li&gt;All of the collected parameter lists must be effectively identical.
6214      * &lt;li&gt;The longest parameter list (which is necessarily unique) is called the &quot;external parameter list&quot; ({@code (A...)}).
6215      * &lt;li&gt;If there is no such parameter list, the external parameter list is taken to be the empty sequence.
6216      * &lt;li&gt;The combined list consisting of iteration variable types followed by the external parameter types is called
6217      * the &quot;internal parameter list&quot;.
6218      * &lt;/ul&gt;
6219      * &lt;p&gt;
6220      * &lt;em&gt;Step 1C: Determine loop return type.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
6221      * &lt;li&gt;Examine fini function return types, disregarding omitted fini functions.
6222      * &lt;li&gt;If there are no fini functions, the loop return type is {@code void}.
6223      * &lt;li&gt;Otherwise, the common return type {@code R} of the fini functions (their return types must be identical) defines the loop return
6224      * type.
6225      * &lt;/ol&gt;
6226      * &lt;p&gt;
6227      * &lt;em&gt;Step 1D: Check other types.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
6228      * &lt;li&gt;There must be at least one non-omitted pred function.
6229      * &lt;li&gt;Every non-omitted pred function must have a {@code boolean} return type.
6230      * &lt;/ol&gt;
6231      * &lt;p&gt;
6232      * &lt;em&gt;Step 2: Determine parameter lists.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
6233      * &lt;li&gt;The parameter list for the resulting loop handle will be the external parameter list {@code (A...)}.
6234      * &lt;li&gt;The parameter list for init functions will be adjusted to the external parameter list.
6235      * (Note that their parameter lists are already effectively identical to this list.)
6236      * &lt;li&gt;The parameter list for every non-omitted, non-init (step, pred, and fini) function must be
6237      * effectively identical to the internal parameter list {@code (V... A...)}.
6238      * &lt;/ol&gt;
6239      * &lt;p&gt;
6240      * &lt;em&gt;Step 3: Fill in omitted functions.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
6241      * &lt;li&gt;If an init function is omitted, use a {@linkplain #empty default value} for the clause&#39;s iteration variable
6242      * type.
6243      * &lt;li&gt;If a step function is omitted, use an {@linkplain #identity identity function} of the clause&#39;s iteration
6244      * variable type; insert dropped argument parameters before the identity function parameter for the non-{@code void}
6245      * iteration variables of preceding clauses. (This will turn the loop variable into a local loop invariant.)
6246      * &lt;li&gt;If a pred function is omitted, use a constant {@code true} function. (This will keep the loop going, as far
6247      * as this clause is concerned.  Note that in such cases the corresponding fini function is unreachable.)
6248      * &lt;li&gt;If a fini function is omitted, use a {@linkplain #empty default value} for the
6249      * loop return type.
6250      * &lt;/ol&gt;
6251      * &lt;p&gt;
6252      * &lt;em&gt;Step 4: Fill in missing parameter types.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
6253      * &lt;li&gt;At this point, every init function parameter list is effectively identical to the external parameter list {@code (A...)},
6254      * but some lists may be shorter. For every init function with a short parameter list, pad out the end of the list.
6255      * &lt;li&gt;At this point, every non-init function parameter list is effectively identical to the internal parameter
6256      * list {@code (V... A...)}, but some lists may be shorter. For every non-init function with a short parameter list,
6257      * pad out the end of the list.
6258      * &lt;li&gt;Argument lists are padded out by {@linkplain #dropArgumentsToMatch(MethodHandle, int, List, int) dropping unused trailing arguments}.
6259      * &lt;/ol&gt;
6260      * &lt;p&gt;
6261      * &lt;em&gt;Final observations.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
6262      * &lt;li&gt;After these steps, all clauses have been adjusted by supplying omitted functions and arguments.
6263      * &lt;li&gt;All init functions have a common parameter type list {@code (A...)}, which the final loop handle will also have.
6264      * &lt;li&gt;All fini functions have a common return type {@code R}, which the final loop handle will also have.
6265      * &lt;li&gt;All non-init functions have a common parameter type list {@code (V... A...)}, of
6266      * (non-{@code void}) iteration variables {@code V} followed by loop parameters.
6267      * &lt;li&gt;Each pair of init and step functions agrees in their return type {@code V}.
6268      * &lt;li&gt;Each non-init function will be able to observe the current values {@code (v...)} of all iteration variables.
6269      * &lt;li&gt;Every function will be able to observe the incoming values {@code (a...)} of all loop parameters.
6270      * &lt;/ol&gt;
6271      * &lt;p&gt;
6272      * &lt;em&gt;Example.&lt;/em&gt; As a consequence of step 1A above, the {@code loop} combinator has the following property:
6273      * &lt;ul&gt;
6274      * &lt;li&gt;Given {@code N} clauses {@code Cn = {null, Sn, Pn}} with {@code n = 1..N}.
6275      * &lt;li&gt;Suppose predicate handles {@code Pn} are either {@code null} or have no parameters.
6276      * (Only one {@code Pn} has to be non-{@code null}.)
6277      * &lt;li&gt;Suppose step handles {@code Sn} have signatures {@code (B1..BX)Rn}, for some constant {@code X&gt;=N}.
6278      * &lt;li&gt;Suppose {@code Q} is the count of non-void types {@code Rn}, and {@code (V1...VQ)} is the sequence of those types.
6279      * &lt;li&gt;It must be that {@code Vn == Bn} for {@code n = 1..min(X,Q)}.
6280      * &lt;li&gt;The parameter types {@code Vn} will be interpreted as loop-local state elements {@code (V...)}.
6281      * &lt;li&gt;Any remaining types {@code BQ+1..BX} (if {@code Q&lt;X}) will determine
6282      * the resulting loop handle&#39;s parameter types {@code (A...)}.
6283      * &lt;/ul&gt;
6284      * In this example, the loop handle parameters {@code (A...)} were derived from the step functions,
6285      * which is natural if most of the loop computation happens in the steps.  For some loops,
6286      * the burden of computation might be heaviest in the pred functions, and so the pred functions
6287      * might need to accept the loop parameter values.  For loops with complex exit logic, the fini
6288      * functions might need to accept loop parameters, and likewise for loops with complex entry logic,
6289      * where the init functions will need the extra parameters.  For such reasons, the rules for
6290      * determining these parameters are as symmetric as possible, across all clause parts.
6291      * In general, the loop parameters function as common invariant values across the whole
6292      * loop, while the iteration variables function as common variant values, or (if there is
6293      * no step function) as internal loop invariant temporaries.
6294      * &lt;p&gt;
6295      * &lt;em&gt;Loop execution.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
6296      * &lt;li&gt;When the loop is called, the loop input values are saved in locals, to be passed to
6297      * every clause function. These locals are loop invariant.
6298      * &lt;li&gt;Each init function is executed in clause order (passing the external arguments {@code (a...)})
6299      * and the non-{@code void} values are saved (as the iteration variables {@code (v...)}) into locals.
6300      * These locals will be loop varying (unless their steps behave as identity functions, as noted above).
6301      * &lt;li&gt;All function executions (except init functions) will be passed the internal parameter list, consisting of
6302      * the non-{@code void} iteration values {@code (v...)} (in clause order) and then the loop inputs {@code (a...)}
6303      * (in argument order).
6304      * &lt;li&gt;The step and pred functions are then executed, in clause order (step before pred), until a pred function
6305      * returns {@code false}.
6306      * &lt;li&gt;The non-{@code void} result from a step function call is used to update the corresponding value in the
6307      * sequence {@code (v...)} of loop variables.
6308      * The updated value is immediately visible to all subsequent function calls.
6309      * &lt;li&gt;If a pred function returns {@code false}, the corresponding fini function is called, and the resulting value
6310      * (of type {@code R}) is returned from the loop as a whole.
6311      * &lt;li&gt;If all the pred functions always return true, no fini function is ever invoked, and the loop cannot exit
6312      * except by throwing an exception.
6313      * &lt;/ol&gt;
6314      * &lt;p&gt;
6315      * &lt;em&gt;Usage tips.&lt;/em&gt;
6316      * &lt;ul&gt;
6317      * &lt;li&gt;Although each step function will receive the current values of &lt;em&gt;all&lt;/em&gt; the loop variables,
6318      * sometimes a step function only needs to observe the current value of its own variable.
6319      * In that case, the step function may need to explicitly {@linkplain #dropArguments drop all preceding loop variables}.
6320      * This will require mentioning their types, in an expression like {@code dropArguments(step, 0, V0.class, ...)}.
6321      * &lt;li&gt;Loop variables are not required to vary; they can be loop invariant.  A clause can create
6322      * a loop invariant by a suitable init function with no step, pred, or fini function.  This may be
6323      * useful to &quot;wire&quot; an incoming loop argument into the step or pred function of an adjacent loop variable.
6324      * &lt;li&gt;If some of the clause functions are virtual methods on an instance, the instance
6325      * itself can be conveniently placed in an initial invariant loop &quot;variable&quot;, using an initial clause
6326      * like {@code new MethodHandle[]{identity(ObjType.class)}}.  In that case, the instance reference
6327      * will be the first iteration variable value, and it will be easy to use virtual
6328      * methods as clause parts, since all of them will take a leading instance reference matching that value.
6329      * &lt;/ul&gt;
6330      * &lt;p&gt;
6331      * Here is pseudocode for the resulting loop handle. As above, {@code V} and {@code v} represent the types
6332      * and values of loop variables; {@code A} and {@code a} represent arguments passed to the whole loop;
6333      * and {@code R} is the common result type of all finalizers as well as of the resulting loop.
6334      * &lt;blockquote&gt;&lt;pre&gt;{@code
6335      * V... init...(A...);
6336      * boolean pred...(V..., A...);
6337      * V... step...(V..., A...);
6338      * R fini...(V..., A...);
6339      * R loop(A... a) {
6340      *   V... v... = init...(a...);
6341      *   for (;;) {
6342      *     for ((v, p, s, f) in (v..., pred..., step..., fini...)) {
6343      *       v = s(v..., a...);
6344      *       if (!p(v..., a...)) {
6345      *         return f(v..., a...);
6346      *       }
6347      *     }
6348      *   }
6349      * }
6350      * }&lt;/pre&gt;&lt;/blockquote&gt;
6351      * Note that the parameter type lists {@code (V...)} and {@code (A...)} have been expanded
6352      * to their full length, even though individual clause functions may neglect to take them all.
6353      * As noted above, missing parameters are filled in as if by {@link #dropArgumentsToMatch(MethodHandle, int, List, int)}.
6354      *
6355      * @apiNote Example:
6356      * &lt;blockquote&gt;&lt;pre&gt;{@code
6357      * // iterative implementation of the factorial function as a loop handle
6358      * static int one(int k) { return 1; }
6359      * static int inc(int i, int acc, int k) { return i + 1; }
6360      * static int mult(int i, int acc, int k) { return i * acc; }
6361      * static boolean pred(int i, int acc, int k) { return i &lt; k; }
6362      * static int fin(int i, int acc, int k) { return acc; }
6363      * // assume MH_one, MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods
6364      * // null initializer for counter, should initialize to 0
6365      * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
6366      * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
6367      * MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);
6368      * assertEquals(120, loop.invoke(5));
6369      * }&lt;/pre&gt;&lt;/blockquote&gt;
6370      * The same example, dropping arguments and using combinators:
6371      * &lt;blockquote&gt;&lt;pre&gt;{@code
6372      * // simplified implementation of the factorial function as a loop handle
6373      * static int inc(int i) { return i + 1; } // drop acc, k
6374      * static int mult(int i, int acc) { return i * acc; } //drop k
6375      * static boolean cmp(int i, int k) { return i &lt; k; }
6376      * // assume MH_inc, MH_mult, and MH_cmp are handles to the above methods
6377      * // null initializer for counter, should initialize to 0
6378      * MethodHandle MH_one = MethodHandles.constant(int.class, 1);
6379      * MethodHandle MH_pred = MethodHandles.dropArguments(MH_cmp, 1, int.class); // drop acc
6380      * MethodHandle MH_fin = MethodHandles.dropArguments(MethodHandles.identity(int.class), 0, int.class); // drop i
6381      * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
6382      * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
6383      * MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);
6384      * assertEquals(720, loop.invoke(6));
6385      * }&lt;/pre&gt;&lt;/blockquote&gt;
6386      * A similar example, using a helper object to hold a loop parameter:
6387      * &lt;blockquote&gt;&lt;pre&gt;{@code
6388      * // instance-based implementation of the factorial function as a loop handle
6389      * static class FacLoop {
6390      *   final int k;
6391      *   FacLoop(int k) { this.k = k; }
6392      *   int inc(int i) { return i + 1; }
6393      *   int mult(int i, int acc) { return i * acc; }
6394      *   boolean pred(int i) { return i &lt; k; }
6395      *   int fin(int i, int acc) { return acc; }
6396      * }
6397      * // assume MH_FacLoop is a handle to the constructor
6398      * // assume MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods
6399      * // null initializer for counter, should initialize to 0
6400      * MethodHandle MH_one = MethodHandles.constant(int.class, 1);
6401      * MethodHandle[] instanceClause = new MethodHandle[]{MH_FacLoop};
6402      * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
6403      * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
6404      * MethodHandle loop = MethodHandles.loop(instanceClause, counterClause, accumulatorClause);
6405      * assertEquals(5040, loop.invoke(7));
6406      * }&lt;/pre&gt;&lt;/blockquote&gt;
6407      *
6408      * @param clauses an array of arrays (4-tuples) of {@link MethodHandle}s adhering to the rules described above.
6409      *
6410      * @return a method handle embodying the looping behavior as defined by the arguments.
6411      *
6412      * @throws IllegalArgumentException in case any of the constraints described above is violated.
6413      *
6414      * @see MethodHandles#whileLoop(MethodHandle, MethodHandle, MethodHandle)
6415      * @see MethodHandles#doWhileLoop(MethodHandle, MethodHandle, MethodHandle)
6416      * @see MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle)
6417      * @see MethodHandles#iteratedLoop(MethodHandle, MethodHandle, MethodHandle)
6418      * @since 9
6419      */
6420     public static MethodHandle loop(MethodHandle[]... clauses) {
6421         // Step 0: determine clause structure.
6422         loopChecks0(clauses);
6423 
6424         List&lt;MethodHandle&gt; init = new ArrayList&lt;&gt;();
6425         List&lt;MethodHandle&gt; step = new ArrayList&lt;&gt;();
6426         List&lt;MethodHandle&gt; pred = new ArrayList&lt;&gt;();
6427         List&lt;MethodHandle&gt; fini = new ArrayList&lt;&gt;();
6428 
6429         Stream.of(clauses).filter(c -&gt; Stream.of(c).anyMatch(Objects::nonNull)).forEach(clause -&gt; {
6430             init.add(clause[0]); // all clauses have at least length 1
6431             step.add(clause.length &lt;= 1 ? null : clause[1]);
6432             pred.add(clause.length &lt;= 2 ? null : clause[2]);
6433             fini.add(clause.length &lt;= 3 ? null : clause[3]);
6434         });
6435 
6436         assert Stream.of(init, step, pred, fini).map(List::size).distinct().count() == 1;
6437         final int nclauses = init.size();
6438 
6439         // Step 1A: determine iteration variables (V...).
6440         final List&lt;Class&lt;?&gt;&gt; iterationVariableTypes = new ArrayList&lt;&gt;();
6441         for (int i = 0; i &lt; nclauses; ++i) {
6442             MethodHandle in = init.get(i);
6443             MethodHandle st = step.get(i);
6444             if (in == null &amp;&amp; st == null) {
6445                 iterationVariableTypes.add(void.class);
6446             } else if (in != null &amp;&amp; st != null) {
6447                 loopChecks1a(i, in, st);
6448                 iterationVariableTypes.add(in.type().returnType());
6449             } else {
6450                 iterationVariableTypes.add(in == null ? st.type().returnType() : in.type().returnType());
6451             }
6452         }
6453         final List&lt;Class&lt;?&gt;&gt; commonPrefix = iterationVariableTypes.stream().filter(t -&gt; t != void.class).
6454                 collect(Collectors.toList());
6455 
6456         // Step 1B: determine loop parameters (A...).
6457         final List&lt;Class&lt;?&gt;&gt; commonSuffix = buildCommonSuffix(init, step, pred, fini, commonPrefix.size());
6458         loopChecks1b(init, commonSuffix);
6459 
6460         // Step 1C: determine loop return type.
6461         // Step 1D: check other types.
6462         // local variable required here; see JDK-8223553
6463         Stream&lt;Class&lt;?&gt;&gt; cstream = fini.stream().filter(Objects::nonNull).map(MethodHandle::type)
6464                 .map(MethodType::returnType);
6465         final Class&lt;?&gt; loopReturnType = cstream.findFirst().orElse(void.class);
6466         loopChecks1cd(pred, fini, loopReturnType);
6467 
6468         // Step 2: determine parameter lists.
6469         final List&lt;Class&lt;?&gt;&gt; commonParameterSequence = new ArrayList&lt;&gt;(commonPrefix);
6470         commonParameterSequence.addAll(commonSuffix);
6471         loopChecks2(step, pred, fini, commonParameterSequence);
6472 
6473         // Step 3: fill in omitted functions.
6474         for (int i = 0; i &lt; nclauses; ++i) {
6475             Class&lt;?&gt; t = iterationVariableTypes.get(i);
6476             if (init.get(i) == null) {
6477                 init.set(i, empty(methodType(t, commonSuffix)));
6478             }
6479             if (step.get(i) == null) {
6480                 step.set(i, dropArgumentsToMatch(identityOrVoid(t), 0, commonParameterSequence, i));
6481             }
6482             if (pred.get(i) == null) {
6483                 pred.set(i, dropArguments0(constant(boolean.class, true), 0, commonParameterSequence));
6484             }
6485             if (fini.get(i) == null) {
6486                 fini.set(i, empty(methodType(t, commonParameterSequence)));
6487             }
6488         }
6489 
6490         // Step 4: fill in missing parameter types.
6491         // Also convert all handles to fixed-arity handles.
6492         List&lt;MethodHandle&gt; finit = fixArities(fillParameterTypes(init, commonSuffix));
6493         List&lt;MethodHandle&gt; fstep = fixArities(fillParameterTypes(step, commonParameterSequence));
6494         List&lt;MethodHandle&gt; fpred = fixArities(fillParameterTypes(pred, commonParameterSequence));
6495         List&lt;MethodHandle&gt; ffini = fixArities(fillParameterTypes(fini, commonParameterSequence));
6496 
6497         assert finit.stream().map(MethodHandle::type).map(MethodType::parameterList).
6498                 allMatch(pl -&gt; pl.equals(commonSuffix));
6499         assert Stream.of(fstep, fpred, ffini).flatMap(List::stream).map(MethodHandle::type).map(MethodType::parameterList).
6500                 allMatch(pl -&gt; pl.equals(commonParameterSequence));
6501 
6502         return MethodHandleImpl.makeLoop(loopReturnType, commonSuffix, finit, fstep, fpred, ffini);
6503     }
6504 
6505     private static void loopChecks0(MethodHandle[][] clauses) {
6506         if (clauses == null || clauses.length == 0) {
6507             throw newIllegalArgumentException(&quot;null or no clauses passed&quot;);
6508         }
6509         if (Stream.of(clauses).anyMatch(Objects::isNull)) {
6510             throw newIllegalArgumentException(&quot;null clauses are not allowed&quot;);
6511         }
6512         if (Stream.of(clauses).anyMatch(c -&gt; c.length &gt; 4)) {
6513             throw newIllegalArgumentException(&quot;All loop clauses must be represented as MethodHandle arrays with at most 4 elements.&quot;);
6514         }
6515     }
6516 
6517     private static void loopChecks1a(int i, MethodHandle in, MethodHandle st) {
6518         if (in.type().returnType() != st.type().returnType()) {
6519             throw misMatchedTypes(&quot;clause &quot; + i + &quot;: init and step return types&quot;, in.type().returnType(),
6520                     st.type().returnType());
6521         }
6522     }
6523 
6524     private static List&lt;Class&lt;?&gt;&gt; longestParameterList(Stream&lt;MethodHandle&gt; mhs, int skipSize) {
6525         final List&lt;Class&lt;?&gt;&gt; empty = List.of();
6526         final List&lt;Class&lt;?&gt;&gt; longest = mhs.filter(Objects::nonNull).
6527                 // take only those that can contribute to a common suffix because they are longer than the prefix
6528                         map(MethodHandle::type).
6529                         filter(t -&gt; t.parameterCount() &gt; skipSize).
6530                         map(MethodType::parameterList).
6531                         reduce((p, q) -&gt; p.size() &gt;= q.size() ? p : q).orElse(empty);
6532         return longest.size() == 0 ? empty : longest.subList(skipSize, longest.size());
6533     }
6534 
6535     private static List&lt;Class&lt;?&gt;&gt; longestParameterList(List&lt;List&lt;Class&lt;?&gt;&gt;&gt; lists) {
6536         final List&lt;Class&lt;?&gt;&gt; empty = List.of();
6537         return lists.stream().reduce((p, q) -&gt; p.size() &gt;= q.size() ? p : q).orElse(empty);
6538     }
6539 
6540     private static List&lt;Class&lt;?&gt;&gt; buildCommonSuffix(List&lt;MethodHandle&gt; init, List&lt;MethodHandle&gt; step, List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini, int cpSize) {
6541         final List&lt;Class&lt;?&gt;&gt; longest1 = longestParameterList(Stream.of(step, pred, fini).flatMap(List::stream), cpSize);
6542         final List&lt;Class&lt;?&gt;&gt; longest2 = longestParameterList(init.stream(), 0);
6543         return longestParameterList(Arrays.asList(longest1, longest2));
6544     }
6545 
6546     private static void loopChecks1b(List&lt;MethodHandle&gt; init, List&lt;Class&lt;?&gt;&gt; commonSuffix) {
6547         if (init.stream().filter(Objects::nonNull).map(MethodHandle::type).
6548                 anyMatch(t -&gt; !t.effectivelyIdenticalParameters(0, commonSuffix))) {
6549             throw newIllegalArgumentException(&quot;found non-effectively identical init parameter type lists: &quot; + init +
6550                     &quot; (common suffix: &quot; + commonSuffix + &quot;)&quot;);
6551         }
6552     }
6553 
6554     private static void loopChecks1cd(List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini, Class&lt;?&gt; loopReturnType) {
6555         if (fini.stream().filter(Objects::nonNull).map(MethodHandle::type).map(MethodType::returnType).
6556                 anyMatch(t -&gt; t != loopReturnType)) {
6557             throw newIllegalArgumentException(&quot;found non-identical finalizer return types: &quot; + fini + &quot; (return type: &quot; +
6558                     loopReturnType + &quot;)&quot;);
6559         }
6560 
6561         if (!pred.stream().filter(Objects::nonNull).findFirst().isPresent()) {
6562             throw newIllegalArgumentException(&quot;no predicate found&quot;, pred);
6563         }
6564         if (pred.stream().filter(Objects::nonNull).map(MethodHandle::type).map(MethodType::returnType).
6565                 anyMatch(t -&gt; t != boolean.class)) {
6566             throw newIllegalArgumentException(&quot;predicates must have boolean return type&quot;, pred);
6567         }
6568     }
6569 
6570     private static void loopChecks2(List&lt;MethodHandle&gt; step, List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini, List&lt;Class&lt;?&gt;&gt; commonParameterSequence) {
6571         if (Stream.of(step, pred, fini).flatMap(List::stream).filter(Objects::nonNull).map(MethodHandle::type).
6572                 anyMatch(t -&gt; !t.effectivelyIdenticalParameters(0, commonParameterSequence))) {
6573             throw newIllegalArgumentException(&quot;found non-effectively identical parameter type lists:\nstep: &quot; + step +
6574                     &quot;\npred: &quot; + pred + &quot;\nfini: &quot; + fini + &quot; (common parameter sequence: &quot; + commonParameterSequence + &quot;)&quot;);
6575         }
6576     }
6577 
6578     private static List&lt;MethodHandle&gt; fillParameterTypes(List&lt;MethodHandle&gt; hs, final List&lt;Class&lt;?&gt;&gt; targetParams) {
6579         return hs.stream().map(h -&gt; {
6580             int pc = h.type().parameterCount();
6581             int tpsize = targetParams.size();
6582             return pc &lt; tpsize ? dropArguments0(h, pc, targetParams.subList(pc, tpsize)) : h;
6583         }).collect(Collectors.toList());
6584     }
6585 
6586     private static List&lt;MethodHandle&gt; fixArities(List&lt;MethodHandle&gt; hs) {
6587         return hs.stream().map(MethodHandle::asFixedArity).collect(Collectors.toList());
6588     }
6589 
6590     /**
6591      * Constructs a {@code while} loop from an initializer, a body, and a predicate.
6592      * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
6593      * &lt;p&gt;
6594      * The {@code pred} handle describes the loop condition; and {@code body}, its body. The loop resulting from this
6595      * method will, in each iteration, first evaluate the predicate and then execute its body (if the predicate
6596      * evaluates to {@code true}).
6597      * The loop will terminate once the predicate evaluates to {@code false} (the body will not be executed in this case).
6598      * &lt;p&gt;
6599      * The {@code init} handle describes the initial value of an additional optional loop-local variable.
6600      * In each iteration, this loop-local variable, if present, will be passed to the {@code body}
6601      * and updated with the value returned from its invocation. The result of loop execution will be
6602      * the final value of the additional loop-local variable (if present).
6603      * &lt;p&gt;
6604      * The following rules hold for these argument handles:&lt;ul&gt;
6605      * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
6606      * {@code (V A...)V}, where {@code V} is non-{@code void}, or else {@code (A...)void}.
6607      * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
6608      * and we will write {@code (V A...)V} with the understanding that a {@code void} type {@code V}
6609      * is quietly dropped from the parameter list, leaving {@code (A...)V}.)
6610      * &lt;li&gt;The parameter list {@code (V A...)} of the body is called the &lt;em&gt;internal parameter list&lt;/em&gt;.
6611      * It will constrain the parameter lists of the other loop parts.
6612      * &lt;li&gt;If the iteration variable type {@code V} is dropped from the internal parameter list, the resulting shorter
6613      * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
6614      * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
6615      * additional state variable of the loop.
6616      * The body must both accept and return a value of this type {@code V}.
6617      * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
6618      * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
6619      * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
6620      * to the external parameter list {@code (A...)}.
6621      * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
6622      * {@linkplain #empty default value}.
6623      * &lt;li&gt;The {@code pred} handle must not be {@code null}.  It must have {@code boolean} as its return type.
6624      * Its parameter list (either empty or of the form {@code (V A*)}) must be
6625      * effectively identical to the internal parameter list.
6626      * &lt;/ul&gt;
6627      * &lt;p&gt;
6628      * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
6629      * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
6630      * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
6631      * from the external parameter list.
6632      * &lt;/ul&gt;
6633      * &lt;p&gt;
6634      * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
6635      * the sole loop variable as well as the result type of the loop; and {@code A}/{@code a}, that of the argument
6636      * passed to the loop.
6637      * &lt;blockquote&gt;&lt;pre&gt;{@code
6638      * V init(A...);
6639      * boolean pred(V, A...);
6640      * V body(V, A...);
6641      * V whileLoop(A... a...) {
6642      *   V v = init(a...);
6643      *   while (pred(v, a...)) {
6644      *     v = body(v, a...);
6645      *   }
6646      *   return v;
6647      * }
6648      * }&lt;/pre&gt;&lt;/blockquote&gt;
6649      *
6650      * @apiNote Example:
6651      * &lt;blockquote&gt;&lt;pre&gt;{@code
6652      * // implement the zip function for lists as a loop handle
6653      * static List&lt;String&gt; initZip(Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) { return new ArrayList&lt;&gt;(); }
6654      * static boolean zipPred(List&lt;String&gt; zip, Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) { return a.hasNext() &amp;&amp; b.hasNext(); }
6655      * static List&lt;String&gt; zipStep(List&lt;String&gt; zip, Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) {
6656      *   zip.add(a.next());
6657      *   zip.add(b.next());
6658      *   return zip;
6659      * }
6660      * // assume MH_initZip, MH_zipPred, and MH_zipStep are handles to the above methods
6661      * MethodHandle loop = MethodHandles.whileLoop(MH_initZip, MH_zipPred, MH_zipStep);
6662      * List&lt;String&gt; a = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
6663      * List&lt;String&gt; b = Arrays.asList(&quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;);
6664      * List&lt;String&gt; zipped = Arrays.asList(&quot;a&quot;, &quot;e&quot;, &quot;b&quot;, &quot;f&quot;, &quot;c&quot;, &quot;g&quot;, &quot;d&quot;, &quot;h&quot;);
6665      * assertEquals(zipped, (List&lt;String&gt;) loop.invoke(a.iterator(), b.iterator()));
6666      * }&lt;/pre&gt;&lt;/blockquote&gt;
6667      *
6668      *
6669      * @apiNote The implementation of this method can be expressed as follows:
6670      * &lt;blockquote&gt;&lt;pre&gt;{@code
6671      * MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body) {
6672      *     MethodHandle fini = (body.type().returnType() == void.class
6673      *                         ? null : identity(body.type().returnType()));
6674      *     MethodHandle[]
6675      *         checkExit = { null, null, pred, fini },
6676      *         varBody   = { init, body };
6677      *     return loop(checkExit, varBody);
6678      * }
6679      * }&lt;/pre&gt;&lt;/blockquote&gt;
6680      *
6681      * @param init optional initializer, providing the initial value of the loop variable.
6682      *             May be {@code null}, implying a default initial value.  See above for other constraints.
6683      * @param pred condition for the loop, which may not be {@code null}. Its result type must be {@code boolean}. See
6684      *             above for other constraints.
6685      * @param body body of the loop, which may not be {@code null}. It controls the loop parameters and result type.
6686      *             See above for other constraints.
6687      *
6688      * @return a method handle implementing the {@code while} loop as described by the arguments.
6689      * @throws IllegalArgumentException if the rules for the arguments are violated.
6690      * @throws NullPointerException if {@code pred} or {@code body} are {@code null}.
6691      *
6692      * @see #loop(MethodHandle[][])
6693      * @see #doWhileLoop(MethodHandle, MethodHandle, MethodHandle)
6694      * @since 9
6695      */
6696     public static MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body) {
6697         whileLoopChecks(init, pred, body);
6698         MethodHandle fini = identityOrVoid(body.type().returnType());
6699         MethodHandle[] checkExit = { null, null, pred, fini };
6700         MethodHandle[] varBody = { init, body };
6701         return loop(checkExit, varBody);
6702     }
6703 
6704     /**
6705      * Constructs a {@code do-while} loop from an initializer, a body, and a predicate.
6706      * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
6707      * &lt;p&gt;
6708      * The {@code pred} handle describes the loop condition; and {@code body}, its body. The loop resulting from this
6709      * method will, in each iteration, first execute its body and then evaluate the predicate.
6710      * The loop will terminate once the predicate evaluates to {@code false} after an execution of the body.
6711      * &lt;p&gt;
6712      * The {@code init} handle describes the initial value of an additional optional loop-local variable.
6713      * In each iteration, this loop-local variable, if present, will be passed to the {@code body}
6714      * and updated with the value returned from its invocation. The result of loop execution will be
6715      * the final value of the additional loop-local variable (if present).
6716      * &lt;p&gt;
6717      * The following rules hold for these argument handles:&lt;ul&gt;
6718      * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
6719      * {@code (V A...)V}, where {@code V} is non-{@code void}, or else {@code (A...)void}.
6720      * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
6721      * and we will write {@code (V A...)V} with the understanding that a {@code void} type {@code V}
6722      * is quietly dropped from the parameter list, leaving {@code (A...)V}.)
6723      * &lt;li&gt;The parameter list {@code (V A...)} of the body is called the &lt;em&gt;internal parameter list&lt;/em&gt;.
6724      * It will constrain the parameter lists of the other loop parts.
6725      * &lt;li&gt;If the iteration variable type {@code V} is dropped from the internal parameter list, the resulting shorter
6726      * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
6727      * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
6728      * additional state variable of the loop.
6729      * The body must both accept and return a value of this type {@code V}.
6730      * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
6731      * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
6732      * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
6733      * to the external parameter list {@code (A...)}.
6734      * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
6735      * {@linkplain #empty default value}.
6736      * &lt;li&gt;The {@code pred} handle must not be {@code null}.  It must have {@code boolean} as its return type.
6737      * Its parameter list (either empty or of the form {@code (V A*)}) must be
6738      * effectively identical to the internal parameter list.
6739      * &lt;/ul&gt;
6740      * &lt;p&gt;
6741      * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
6742      * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
6743      * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
6744      * from the external parameter list.
6745      * &lt;/ul&gt;
6746      * &lt;p&gt;
6747      * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
6748      * the sole loop variable as well as the result type of the loop; and {@code A}/{@code a}, that of the argument
6749      * passed to the loop.
6750      * &lt;blockquote&gt;&lt;pre&gt;{@code
6751      * V init(A...);
6752      * boolean pred(V, A...);
6753      * V body(V, A...);
6754      * V doWhileLoop(A... a...) {
6755      *   V v = init(a...);
6756      *   do {
6757      *     v = body(v, a...);
6758      *   } while (pred(v, a...));
6759      *   return v;
6760      * }
6761      * }&lt;/pre&gt;&lt;/blockquote&gt;
6762      *
6763      * @apiNote Example:
6764      * &lt;blockquote&gt;&lt;pre&gt;{@code
6765      * // int i = 0; while (i &lt; limit) { ++i; } return i; =&gt; limit
6766      * static int zero(int limit) { return 0; }
6767      * static int step(int i, int limit) { return i + 1; }
6768      * static boolean pred(int i, int limit) { return i &lt; limit; }
6769      * // assume MH_zero, MH_step, and MH_pred are handles to the above methods
6770      * MethodHandle loop = MethodHandles.doWhileLoop(MH_zero, MH_step, MH_pred);
6771      * assertEquals(23, loop.invoke(23));
6772      * }&lt;/pre&gt;&lt;/blockquote&gt;
6773      *
6774      *
6775      * @apiNote The implementation of this method can be expressed as follows:
6776      * &lt;blockquote&gt;&lt;pre&gt;{@code
6777      * MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred) {
6778      *     MethodHandle fini = (body.type().returnType() == void.class
6779      *                         ? null : identity(body.type().returnType()));
6780      *     MethodHandle[] clause = { init, body, pred, fini };
6781      *     return loop(clause);
6782      * }
6783      * }&lt;/pre&gt;&lt;/blockquote&gt;
6784      *
6785      * @param init optional initializer, providing the initial value of the loop variable.
6786      *             May be {@code null}, implying a default initial value.  See above for other constraints.
6787      * @param body body of the loop, which may not be {@code null}. It controls the loop parameters and result type.
6788      *             See above for other constraints.
6789      * @param pred condition for the loop, which may not be {@code null}. Its result type must be {@code boolean}. See
6790      *             above for other constraints.
6791      *
6792      * @return a method handle implementing the {@code while} loop as described by the arguments.
6793      * @throws IllegalArgumentException if the rules for the arguments are violated.
6794      * @throws NullPointerException if {@code pred} or {@code body} are {@code null}.
6795      *
6796      * @see #loop(MethodHandle[][])
6797      * @see #whileLoop(MethodHandle, MethodHandle, MethodHandle)
6798      * @since 9
6799      */
6800     public static MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred) {
6801         whileLoopChecks(init, pred, body);
6802         MethodHandle fini = identityOrVoid(body.type().returnType());
6803         MethodHandle[] clause = {init, body, pred, fini };
6804         return loop(clause);
6805     }
6806 
6807     private static void whileLoopChecks(MethodHandle init, MethodHandle pred, MethodHandle body) {
6808         Objects.requireNonNull(pred);
6809         Objects.requireNonNull(body);
6810         MethodType bodyType = body.type();
6811         Class&lt;?&gt; returnType = bodyType.returnType();
6812         List&lt;Class&lt;?&gt;&gt; innerList = bodyType.parameterList();
6813         List&lt;Class&lt;?&gt;&gt; outerList = innerList;
6814         if (returnType == void.class) {
6815             // OK
6816         } else if (innerList.size() == 0 || innerList.get(0) != returnType) {
6817             // leading V argument missing =&gt; error
6818             MethodType expected = bodyType.insertParameterTypes(0, returnType);
6819             throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
6820         } else {
6821             outerList = innerList.subList(1, innerList.size());
6822         }
6823         MethodType predType = pred.type();
6824         if (predType.returnType() != boolean.class ||
6825                 !predType.effectivelyIdenticalParameters(0, innerList)) {
6826             throw misMatchedTypes(&quot;loop predicate&quot;, predType, methodType(boolean.class, innerList));
6827         }
6828         if (init != null) {
6829             MethodType initType = init.type();
6830             if (initType.returnType() != returnType ||
6831                     !initType.effectivelyIdenticalParameters(0, outerList)) {
6832                 throw misMatchedTypes(&quot;loop initializer&quot;, initType, methodType(returnType, outerList));
6833             }
6834         }
6835     }
6836 
6837     /**
6838      * Constructs a loop that runs a given number of iterations.
6839      * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
6840      * &lt;p&gt;
6841      * The number of iterations is determined by the {@code iterations} handle evaluation result.
6842      * The loop counter {@code i} is an extra loop iteration variable of type {@code int}.
6843      * It will be initialized to 0 and incremented by 1 in each iteration.
6844      * &lt;p&gt;
6845      * If the {@code body} handle returns a non-{@code void} type {@code V}, a leading loop iteration variable
6846      * of that type is also present.  This variable is initialized using the optional {@code init} handle,
6847      * or to the {@linkplain #empty default value} of type {@code V} if that handle is {@code null}.
6848      * &lt;p&gt;
6849      * In each iteration, the iteration variables are passed to an invocation of the {@code body} handle.
6850      * A non-{@code void} value returned from the body (of type {@code V}) updates the leading
6851      * iteration variable.
6852      * The result of the loop handle execution will be the final {@code V} value of that variable
6853      * (or {@code void} if there is no {@code V} variable).
6854      * &lt;p&gt;
6855      * The following rules hold for the argument handles:&lt;ul&gt;
6856      * &lt;li&gt;The {@code iterations} handle must not be {@code null}, and must return
6857      * the type {@code int}, referred to here as {@code I} in parameter type lists.
6858      * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
6859      * {@code (V I A...)V}, where {@code V} is non-{@code void}, or else {@code (I A...)void}.
6860      * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
6861      * and we will write {@code (V I A...)V} with the understanding that a {@code void} type {@code V}
6862      * is quietly dropped from the parameter list, leaving {@code (I A...)V}.)
6863      * &lt;li&gt;The parameter list {@code (V I A...)} of the body contributes to a list
6864      * of types called the &lt;em&gt;internal parameter list&lt;/em&gt;.
6865      * It will constrain the parameter lists of the other loop parts.
6866      * &lt;li&gt;As a special case, if the body contributes only {@code V} and {@code I} types,
6867      * with no additional {@code A} types, then the internal parameter list is extended by
6868      * the argument types {@code A...} of the {@code iterations} handle.
6869      * &lt;li&gt;If the iteration variable types {@code (V I)} are dropped from the internal parameter list, the resulting shorter
6870      * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
6871      * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
6872      * additional state variable of the loop.
6873      * The body must both accept a leading parameter and return a value of this type {@code V}.
6874      * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
6875      * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
6876      * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
6877      * to the external parameter list {@code (A...)}.
6878      * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
6879      * {@linkplain #empty default value}.
6880      * &lt;li&gt;The parameter list of {@code iterations} (of some form {@code (A*)}) must be
6881      * effectively identical to the external parameter list {@code (A...)}.
6882      * &lt;/ul&gt;
6883      * &lt;p&gt;
6884      * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
6885      * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
6886      * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
6887      * from the external parameter list.
6888      * &lt;/ul&gt;
6889      * &lt;p&gt;
6890      * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
6891      * the second loop variable as well as the result type of the loop; and {@code A...}/{@code a...} represent
6892      * arguments passed to the loop.
6893      * &lt;blockquote&gt;&lt;pre&gt;{@code
6894      * int iterations(A...);
6895      * V init(A...);
6896      * V body(V, int, A...);
6897      * V countedLoop(A... a...) {
6898      *   int end = iterations(a...);
6899      *   V v = init(a...);
6900      *   for (int i = 0; i &lt; end; ++i) {
6901      *     v = body(v, i, a...);
6902      *   }
6903      *   return v;
6904      * }
6905      * }&lt;/pre&gt;&lt;/blockquote&gt;
6906      *
6907      * @apiNote Example with a fully conformant body method:
6908      * &lt;blockquote&gt;&lt;pre&gt;{@code
6909      * // String s = &quot;Lambdaman!&quot;; for (int i = 0; i &lt; 13; ++i) { s = &quot;na &quot; + s; } return s;
6910      * // =&gt; a variation on a well known theme
6911      * static String step(String v, int counter, String init) { return &quot;na &quot; + v; }
6912      * // assume MH_step is a handle to the method above
6913      * MethodHandle fit13 = MethodHandles.constant(int.class, 13);
6914      * MethodHandle start = MethodHandles.identity(String.class);
6915      * MethodHandle loop = MethodHandles.countedLoop(fit13, start, MH_step);
6916      * assertEquals(&quot;na na na na na na na na na na na na na Lambdaman!&quot;, loop.invoke(&quot;Lambdaman!&quot;));
6917      * }&lt;/pre&gt;&lt;/blockquote&gt;
6918      *
6919      * @apiNote Example with the simplest possible body method type,
6920      * and passing the number of iterations to the loop invocation:
6921      * &lt;blockquote&gt;&lt;pre&gt;{@code
6922      * // String s = &quot;Lambdaman!&quot;; for (int i = 0; i &lt; 13; ++i) { s = &quot;na &quot; + s; } return s;
6923      * // =&gt; a variation on a well known theme
6924      * static String step(String v, int counter ) { return &quot;na &quot; + v; }
6925      * // assume MH_step is a handle to the method above
6926      * MethodHandle count = MethodHandles.dropArguments(MethodHandles.identity(int.class), 1, String.class);
6927      * MethodHandle start = MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class);
6928      * MethodHandle loop = MethodHandles.countedLoop(count, start, MH_step);  // (v, i) -&gt; &quot;na &quot; + v
6929      * assertEquals(&quot;na na na na na na na na na na na na na Lambdaman!&quot;, loop.invoke(13, &quot;Lambdaman!&quot;));
6930      * }&lt;/pre&gt;&lt;/blockquote&gt;
6931      *
6932      * @apiNote Example that treats the number of iterations, string to append to, and string to append
6933      * as loop parameters:
6934      * &lt;blockquote&gt;&lt;pre&gt;{@code
6935      * // String s = &quot;Lambdaman!&quot;, t = &quot;na&quot;; for (int i = 0; i &lt; 13; ++i) { s = t + &quot; &quot; + s; } return s;
6936      * // =&gt; a variation on a well known theme
6937      * static String step(String v, int counter, int iterations_, String pre, String start_) { return pre + &quot; &quot; + v; }
6938      * // assume MH_step is a handle to the method above
6939      * MethodHandle count = MethodHandles.identity(int.class);
6940      * MethodHandle start = MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class, String.class);
6941      * MethodHandle loop = MethodHandles.countedLoop(count, start, MH_step);  // (v, i, _, pre, _) -&gt; pre + &quot; &quot; + v
6942      * assertEquals(&quot;na na na na na na na na na na na na na Lambdaman!&quot;, loop.invoke(13, &quot;na&quot;, &quot;Lambdaman!&quot;));
6943      * }&lt;/pre&gt;&lt;/blockquote&gt;
6944      *
6945      * @apiNote Example that illustrates the usage of {@link #dropArgumentsToMatch(MethodHandle, int, List, int)}
6946      * to enforce a loop type:
6947      * &lt;blockquote&gt;&lt;pre&gt;{@code
6948      * // String s = &quot;Lambdaman!&quot;, t = &quot;na&quot;; for (int i = 0; i &lt; 13; ++i) { s = t + &quot; &quot; + s; } return s;
6949      * // =&gt; a variation on a well known theme
6950      * static String step(String v, int counter, String pre) { return pre + &quot; &quot; + v; }
6951      * // assume MH_step is a handle to the method above
6952      * MethodType loopType = methodType(String.class, String.class, int.class, String.class);
6953      * MethodHandle count = MethodHandles.dropArgumentsToMatch(MethodHandles.identity(int.class),    0, loopType.parameterList(), 1);
6954      * MethodHandle start = MethodHandles.dropArgumentsToMatch(MethodHandles.identity(String.class), 0, loopType.parameterList(), 2);
6955      * MethodHandle body  = MethodHandles.dropArgumentsToMatch(MH_step,                              2, loopType.parameterList(), 0);
6956      * MethodHandle loop = MethodHandles.countedLoop(count, start, body);  // (v, i, pre, _, _) -&gt; pre + &quot; &quot; + v
6957      * assertEquals(&quot;na na na na na na na na na na na na na Lambdaman!&quot;, loop.invoke(&quot;na&quot;, 13, &quot;Lambdaman!&quot;));
6958      * }&lt;/pre&gt;&lt;/blockquote&gt;
6959      *
6960      * @apiNote The implementation of this method can be expressed as follows:
6961      * &lt;blockquote&gt;&lt;pre&gt;{@code
6962      * MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body) {
6963      *     return countedLoop(empty(iterations.type()), iterations, init, body);
6964      * }
6965      * }&lt;/pre&gt;&lt;/blockquote&gt;
6966      *
6967      * @param iterations a non-{@code null} handle to return the number of iterations this loop should run. The handle&#39;s
6968      *                   result type must be {@code int}. See above for other constraints.
6969      * @param init optional initializer, providing the initial value of the loop variable.
6970      *             May be {@code null}, implying a default initial value.  See above for other constraints.
6971      * @param body body of the loop, which may not be {@code null}.
6972      *             It controls the loop parameters and result type in the standard case (see above for details).
6973      *             It must accept its own return type (if non-void) plus an {@code int} parameter (for the counter),
6974      *             and may accept any number of additional types.
6975      *             See above for other constraints.
6976      *
6977      * @return a method handle representing the loop.
6978      * @throws NullPointerException if either of the {@code iterations} or {@code body} handles is {@code null}.
6979      * @throws IllegalArgumentException if any argument violates the rules formulated above.
6980      *
6981      * @see #countedLoop(MethodHandle, MethodHandle, MethodHandle, MethodHandle)
6982      * @since 9
6983      */
6984     public static MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body) {
6985         return countedLoop(empty(iterations.type()), iterations, init, body);
6986     }
6987 
6988     /**
6989      * Constructs a loop that counts over a range of numbers.
6990      * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
6991      * &lt;p&gt;
6992      * The loop counter {@code i} is a loop iteration variable of type {@code int}.
6993      * The {@code start} and {@code end} handles determine the start (inclusive) and end (exclusive)
6994      * values of the loop counter.
6995      * The loop counter will be initialized to the {@code int} value returned from the evaluation of the
6996      * {@code start} handle and run to the value returned from {@code end} (exclusively) with a step width of 1.
6997      * &lt;p&gt;
6998      * If the {@code body} handle returns a non-{@code void} type {@code V}, a leading loop iteration variable
6999      * of that type is also present.  This variable is initialized using the optional {@code init} handle,
7000      * or to the {@linkplain #empty default value} of type {@code V} if that handle is {@code null}.
7001      * &lt;p&gt;
7002      * In each iteration, the iteration variables are passed to an invocation of the {@code body} handle.
7003      * A non-{@code void} value returned from the body (of type {@code V}) updates the leading
7004      * iteration variable.
7005      * The result of the loop handle execution will be the final {@code V} value of that variable
7006      * (or {@code void} if there is no {@code V} variable).
7007      * &lt;p&gt;
7008      * The following rules hold for the argument handles:&lt;ul&gt;
7009      * &lt;li&gt;The {@code start} and {@code end} handles must not be {@code null}, and must both return
7010      * the common type {@code int}, referred to here as {@code I} in parameter type lists.
7011      * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
7012      * {@code (V I A...)V}, where {@code V} is non-{@code void}, or else {@code (I A...)void}.
7013      * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
7014      * and we will write {@code (V I A...)V} with the understanding that a {@code void} type {@code V}
7015      * is quietly dropped from the parameter list, leaving {@code (I A...)V}.)
7016      * &lt;li&gt;The parameter list {@code (V I A...)} of the body contributes to a list
7017      * of types called the &lt;em&gt;internal parameter list&lt;/em&gt;.
7018      * It will constrain the parameter lists of the other loop parts.
7019      * &lt;li&gt;As a special case, if the body contributes only {@code V} and {@code I} types,
7020      * with no additional {@code A} types, then the internal parameter list is extended by
7021      * the argument types {@code A...} of the {@code end} handle.
7022      * &lt;li&gt;If the iteration variable types {@code (V I)} are dropped from the internal parameter list, the resulting shorter
7023      * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
7024      * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
7025      * additional state variable of the loop.
7026      * The body must both accept a leading parameter and return a value of this type {@code V}.
7027      * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
7028      * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
7029      * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
7030      * to the external parameter list {@code (A...)}.
7031      * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
7032      * {@linkplain #empty default value}.
7033      * &lt;li&gt;The parameter list of {@code start} (of some form {@code (A*)}) must be
7034      * effectively identical to the external parameter list {@code (A...)}.
7035      * &lt;li&gt;Likewise, the parameter list of {@code end} must be effectively identical
7036      * to the external parameter list.
7037      * &lt;/ul&gt;
7038      * &lt;p&gt;
7039      * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
7040      * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
7041      * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
7042      * from the external parameter list.
7043      * &lt;/ul&gt;
7044      * &lt;p&gt;
7045      * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
7046      * the second loop variable as well as the result type of the loop; and {@code A...}/{@code a...} represent
7047      * arguments passed to the loop.
7048      * &lt;blockquote&gt;&lt;pre&gt;{@code
7049      * int start(A...);
7050      * int end(A...);
7051      * V init(A...);
7052      * V body(V, int, A...);
7053      * V countedLoop(A... a...) {
7054      *   int e = end(a...);
7055      *   int s = start(a...);
7056      *   V v = init(a...);
7057      *   for (int i = s; i &lt; e; ++i) {
7058      *     v = body(v, i, a...);
7059      *   }
7060      *   return v;
7061      * }
7062      * }&lt;/pre&gt;&lt;/blockquote&gt;
7063      *
7064      * @apiNote The implementation of this method can be expressed as follows:
7065      * &lt;blockquote&gt;&lt;pre&gt;{@code
7066      * MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {
7067      *     MethodHandle returnVar = dropArguments(identity(init.type().returnType()), 0, int.class, int.class);
7068      *     // assume MH_increment and MH_predicate are handles to implementation-internal methods with
7069      *     // the following semantics:
7070      *     // MH_increment: (int limit, int counter) -&gt; counter + 1
7071      *     // MH_predicate: (int limit, int counter) -&gt; counter &lt; limit
7072      *     Class&lt;?&gt; counterType = start.type().returnType();  // int
7073      *     Class&lt;?&gt; returnType = body.type().returnType();
7074      *     MethodHandle incr = MH_increment, pred = MH_predicate, retv = null;
7075      *     if (returnType != void.class) {  // ignore the V variable
7076      *         incr = dropArguments(incr, 1, returnType);  // (limit, v, i) =&gt; (limit, i)
7077      *         pred = dropArguments(pred, 1, returnType);  // ditto
7078      *         retv = dropArguments(identity(returnType), 0, counterType); // ignore limit
7079      *     }
7080      *     body = dropArguments(body, 0, counterType);  // ignore the limit variable
7081      *     MethodHandle[]
7082      *         loopLimit  = { end, null, pred, retv }, // limit = end(); i &lt; limit || return v
7083      *         bodyClause = { init, body },            // v = init(); v = body(v, i)
7084      *         indexVar   = { start, incr };           // i = start(); i = i + 1
7085      *     return loop(loopLimit, bodyClause, indexVar);
7086      * }
7087      * }&lt;/pre&gt;&lt;/blockquote&gt;
7088      *
7089      * @param start a non-{@code null} handle to return the start value of the loop counter, which must be {@code int}.
7090      *              See above for other constraints.
7091      * @param end a non-{@code null} handle to return the end value of the loop counter (the loop will run to
7092      *            {@code end-1}). The result type must be {@code int}. See above for other constraints.
7093      * @param init optional initializer, providing the initial value of the loop variable.
7094      *             May be {@code null}, implying a default initial value.  See above for other constraints.
7095      * @param body body of the loop, which may not be {@code null}.
7096      *             It controls the loop parameters and result type in the standard case (see above for details).
7097      *             It must accept its own return type (if non-void) plus an {@code int} parameter (for the counter),
7098      *             and may accept any number of additional types.
7099      *             See above for other constraints.
7100      *
7101      * @return a method handle representing the loop.
7102      * @throws NullPointerException if any of the {@code start}, {@code end}, or {@code body} handles is {@code null}.
7103      * @throws IllegalArgumentException if any argument violates the rules formulated above.
7104      *
7105      * @see #countedLoop(MethodHandle, MethodHandle, MethodHandle)
7106      * @since 9
7107      */
7108     public static MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {
7109         countedLoopChecks(start, end, init, body);
7110         Class&lt;?&gt; counterType = start.type().returnType();  // int, but who&#39;s counting?
7111         Class&lt;?&gt; limitType   = end.type().returnType();    // yes, int again
7112         Class&lt;?&gt; returnType  = body.type().returnType();
7113         MethodHandle incr = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_countedLoopStep);
7114         MethodHandle pred = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_countedLoopPred);
7115         MethodHandle retv = null;
7116         if (returnType != void.class) {
7117             incr = dropArguments(incr, 1, returnType);  // (limit, v, i) =&gt; (limit, i)
7118             pred = dropArguments(pred, 1, returnType);  // ditto
7119             retv = dropArguments(identity(returnType), 0, counterType);
7120         }
7121         body = dropArguments(body, 0, counterType);  // ignore the limit variable
7122         MethodHandle[]
7123             loopLimit  = { end, null, pred, retv }, // limit = end(); i &lt; limit || return v
7124             bodyClause = { init, body },            // v = init(); v = body(v, i)
7125             indexVar   = { start, incr };           // i = start(); i = i + 1
7126         return loop(loopLimit, bodyClause, indexVar);
7127     }
7128 
7129     private static void countedLoopChecks(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {
7130         Objects.requireNonNull(start);
7131         Objects.requireNonNull(end);
7132         Objects.requireNonNull(body);
7133         Class&lt;?&gt; counterType = start.type().returnType();
7134         if (counterType != int.class) {
7135             MethodType expected = start.type().changeReturnType(int.class);
7136             throw misMatchedTypes(&quot;start function&quot;, start.type(), expected);
7137         } else if (end.type().returnType() != counterType) {
7138             MethodType expected = end.type().changeReturnType(counterType);
7139             throw misMatchedTypes(&quot;end function&quot;, end.type(), expected);
7140         }
7141         MethodType bodyType = body.type();
7142         Class&lt;?&gt; returnType = bodyType.returnType();
7143         List&lt;Class&lt;?&gt;&gt; innerList = bodyType.parameterList();
7144         // strip leading V value if present
7145         int vsize = (returnType == void.class ? 0 : 1);
7146         if (vsize != 0 &amp;&amp; (innerList.size() == 0 || innerList.get(0) != returnType)) {
7147             // argument list has no &quot;V&quot; =&gt; error
7148             MethodType expected = bodyType.insertParameterTypes(0, returnType);
7149             throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
7150         } else if (innerList.size() &lt;= vsize || innerList.get(vsize) != counterType) {
7151             // missing I type =&gt; error
7152             MethodType expected = bodyType.insertParameterTypes(vsize, counterType);
7153             throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
7154         }
7155         List&lt;Class&lt;?&gt;&gt; outerList = innerList.subList(vsize + 1, innerList.size());
7156         if (outerList.isEmpty()) {
7157             // special case; take lists from end handle
7158             outerList = end.type().parameterList();
7159             innerList = bodyType.insertParameterTypes(vsize + 1, outerList).parameterList();
7160         }
7161         MethodType expected = methodType(counterType, outerList);
7162         if (!start.type().effectivelyIdenticalParameters(0, outerList)) {
7163             throw misMatchedTypes(&quot;start parameter types&quot;, start.type(), expected);
7164         }
7165         if (end.type() != start.type() &amp;&amp;
7166             !end.type().effectivelyIdenticalParameters(0, outerList)) {
7167             throw misMatchedTypes(&quot;end parameter types&quot;, end.type(), expected);
7168         }
7169         if (init != null) {
7170             MethodType initType = init.type();
7171             if (initType.returnType() != returnType ||
7172                 !initType.effectivelyIdenticalParameters(0, outerList)) {
7173                 throw misMatchedTypes(&quot;loop initializer&quot;, initType, methodType(returnType, outerList));
7174             }
7175         }
7176     }
7177 
7178     /**
7179      * Constructs a loop that ranges over the values produced by an {@code Iterator&lt;T&gt;}.
7180      * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
7181      * &lt;p&gt;
7182      * The iterator itself will be determined by the evaluation of the {@code iterator} handle.
7183      * Each value it produces will be stored in a loop iteration variable of type {@code T}.
7184      * &lt;p&gt;
7185      * If the {@code body} handle returns a non-{@code void} type {@code V}, a leading loop iteration variable
7186      * of that type is also present.  This variable is initialized using the optional {@code init} handle,
7187      * or to the {@linkplain #empty default value} of type {@code V} if that handle is {@code null}.
7188      * &lt;p&gt;
7189      * In each iteration, the iteration variables are passed to an invocation of the {@code body} handle.
7190      * A non-{@code void} value returned from the body (of type {@code V}) updates the leading
7191      * iteration variable.
7192      * The result of the loop handle execution will be the final {@code V} value of that variable
7193      * (or {@code void} if there is no {@code V} variable).
7194      * &lt;p&gt;
7195      * The following rules hold for the argument handles:&lt;ul&gt;
7196      * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
7197      * {@code (V T A...)V}, where {@code V} is non-{@code void}, or else {@code (T A...)void}.
7198      * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
7199      * and we will write {@code (V T A...)V} with the understanding that a {@code void} type {@code V}
7200      * is quietly dropped from the parameter list, leaving {@code (T A...)V}.)
7201      * &lt;li&gt;The parameter list {@code (V T A...)} of the body contributes to a list
7202      * of types called the &lt;em&gt;internal parameter list&lt;/em&gt;.
7203      * It will constrain the parameter lists of the other loop parts.
7204      * &lt;li&gt;As a special case, if the body contributes only {@code V} and {@code T} types,
7205      * with no additional {@code A} types, then the internal parameter list is extended by
7206      * the argument types {@code A...} of the {@code iterator} handle; if it is {@code null} the
7207      * single type {@code Iterable} is added and constitutes the {@code A...} list.
7208      * &lt;li&gt;If the iteration variable types {@code (V T)} are dropped from the internal parameter list, the resulting shorter
7209      * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
7210      * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
7211      * additional state variable of the loop.
7212      * The body must both accept a leading parameter and return a value of this type {@code V}.
7213      * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
7214      * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
7215      * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
7216      * to the external parameter list {@code (A...)}.
7217      * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
7218      * {@linkplain #empty default value}.
7219      * &lt;li&gt;If the {@code iterator} handle is non-{@code null}, it must have the return
7220      * type {@code java.util.Iterator} or a subtype thereof.
7221      * The iterator it produces when the loop is executed will be assumed
7222      * to yield values which can be converted to type {@code T}.
7223      * &lt;li&gt;The parameter list of an {@code iterator} that is non-{@code null} (of some form {@code (A*)}) must be
7224      * effectively identical to the external parameter list {@code (A...)}.
7225      * &lt;li&gt;If {@code iterator} is {@code null} it defaults to a method handle which behaves
7226      * like {@link java.lang.Iterable#iterator()}.  In that case, the internal parameter list
7227      * {@code (V T A...)} must have at least one {@code A} type, and the default iterator
7228      * handle parameter is adjusted to accept the leading {@code A} type, as if by
7229      * the {@link MethodHandle#asType asType} conversion method.
7230      * The leading {@code A} type must be {@code Iterable} or a subtype thereof.
7231      * This conversion step, done at loop construction time, must not throw a {@code WrongMethodTypeException}.
7232      * &lt;/ul&gt;
7233      * &lt;p&gt;
7234      * The type {@code T} may be either a primitive or reference.
7235      * Since type {@code Iterator&lt;T&gt;} is erased in the method handle representation to the raw type {@code Iterator},
7236      * the {@code iteratedLoop} combinator adjusts the leading argument type for {@code body} to {@code Object}
7237      * as if by the {@link MethodHandle#asType asType} conversion method.
7238      * Therefore, if an iterator of the wrong type appears as the loop is executed, runtime exceptions may occur
7239      * as the result of dynamic conversions performed by {@link MethodHandle#asType(MethodType)}.
7240      * &lt;p&gt;
7241      * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
7242      * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
7243      * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
7244      * from the external parameter list.
7245      * &lt;/ul&gt;
7246      * &lt;p&gt;
7247      * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
7248      * the loop variable as well as the result type of the loop; {@code T}/{@code t}, that of the elements of the
7249      * structure the loop iterates over, and {@code A...}/{@code a...} represent arguments passed to the loop.
7250      * &lt;blockquote&gt;&lt;pre&gt;{@code
7251      * Iterator&lt;T&gt; iterator(A...);  // defaults to Iterable::iterator
7252      * V init(A...);
7253      * V body(V,T,A...);
7254      * V iteratedLoop(A... a...) {
7255      *   Iterator&lt;T&gt; it = iterator(a...);
7256      *   V v = init(a...);
7257      *   while (it.hasNext()) {
7258      *     T t = it.next();
7259      *     v = body(v, t, a...);
7260      *   }
7261      *   return v;
7262      * }
7263      * }&lt;/pre&gt;&lt;/blockquote&gt;
7264      *
7265      * @apiNote Example:
7266      * &lt;blockquote&gt;&lt;pre&gt;{@code
7267      * // get an iterator from a list
7268      * static List&lt;String&gt; reverseStep(List&lt;String&gt; r, String e) {
7269      *   r.add(0, e);
7270      *   return r;
7271      * }
7272      * static List&lt;String&gt; newArrayList() { return new ArrayList&lt;&gt;(); }
7273      * // assume MH_reverseStep and MH_newArrayList are handles to the above methods
7274      * MethodHandle loop = MethodHandles.iteratedLoop(null, MH_newArrayList, MH_reverseStep);
7275      * List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);
7276      * List&lt;String&gt; reversedList = Arrays.asList(&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;);
7277      * assertEquals(reversedList, (List&lt;String&gt;) loop.invoke(list));
7278      * }&lt;/pre&gt;&lt;/blockquote&gt;
7279      *
7280      * @apiNote The implementation of this method can be expressed approximately as follows:
7281      * &lt;blockquote&gt;&lt;pre&gt;{@code
7282      * MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body) {
7283      *     // assume MH_next, MH_hasNext, MH_startIter are handles to methods of Iterator/Iterable
7284      *     Class&lt;?&gt; returnType = body.type().returnType();
7285      *     Class&lt;?&gt; ttype = body.type().parameterType(returnType == void.class ? 0 : 1);
7286      *     MethodHandle nextVal = MH_next.asType(MH_next.type().changeReturnType(ttype));
7287      *     MethodHandle retv = null, step = body, startIter = iterator;
7288      *     if (returnType != void.class) {
7289      *         // the simple thing first:  in (I V A...), drop the I to get V
7290      *         retv = dropArguments(identity(returnType), 0, Iterator.class);
7291      *         // body type signature (V T A...), internal loop types (I V A...)
7292      *         step = swapArguments(body, 0, 1);  // swap V &lt;-&gt; T
7293      *     }
7294      *     if (startIter == null)  startIter = MH_getIter;
7295      *     MethodHandle[]
7296      *         iterVar    = { startIter, null, MH_hasNext, retv }, // it = iterator; while (it.hasNext())
7297      *         bodyClause = { init, filterArguments(step, 0, nextVal) };  // v = body(v, t, a)
7298      *     return loop(iterVar, bodyClause);
7299      * }
7300      * }&lt;/pre&gt;&lt;/blockquote&gt;
7301      *
7302      * @param iterator an optional handle to return the iterator to start the loop.
7303      *                 If non-{@code null}, the handle must return {@link java.util.Iterator} or a subtype.
7304      *                 See above for other constraints.
7305      * @param init optional initializer, providing the initial value of the loop variable.
7306      *             May be {@code null}, implying a default initial value.  See above for other constraints.
7307      * @param body body of the loop, which may not be {@code null}.
7308      *             It controls the loop parameters and result type in the standard case (see above for details).
7309      *             It must accept its own return type (if non-void) plus a {@code T} parameter (for the iterated values),
7310      *             and may accept any number of additional types.
7311      *             See above for other constraints.
7312      *
7313      * @return a method handle embodying the iteration loop functionality.
7314      * @throws NullPointerException if the {@code body} handle is {@code null}.
7315      * @throws IllegalArgumentException if any argument violates the above requirements.
7316      *
7317      * @since 9
7318      */
7319     public static MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body) {
7320         Class&lt;?&gt; iterableType = iteratedLoopChecks(iterator, init, body);
7321         Class&lt;?&gt; returnType = body.type().returnType();
7322         MethodHandle hasNext = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_iteratePred);
7323         MethodHandle nextRaw = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_iterateNext);
7324         MethodHandle startIter;
7325         MethodHandle nextVal;
7326         {
7327             MethodType iteratorType;
7328             if (iterator == null) {
7329                 // derive argument type from body, if available, else use Iterable
7330                 startIter = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_initIterator);
7331                 iteratorType = startIter.type().changeParameterType(0, iterableType);
7332             } else {
7333                 // force return type to the internal iterator class
7334                 iteratorType = iterator.type().changeReturnType(Iterator.class);
7335                 startIter = iterator;
7336             }
7337             Class&lt;?&gt; ttype = body.type().parameterType(returnType == void.class ? 0 : 1);
7338             MethodType nextValType = nextRaw.type().changeReturnType(ttype);
7339 
7340             // perform the asType transforms under an exception transformer, as per spec.:
7341             try {
7342                 startIter = startIter.asType(iteratorType);
7343                 nextVal = nextRaw.asType(nextValType);
7344             } catch (WrongMethodTypeException ex) {
7345                 throw new IllegalArgumentException(ex);
7346             }
7347         }
7348 
7349         MethodHandle retv = null, step = body;
7350         if (returnType != void.class) {
7351             // the simple thing first:  in (I V A...), drop the I to get V
7352             retv = dropArguments(identity(returnType), 0, Iterator.class);
7353             // body type signature (V T A...), internal loop types (I V A...)
7354             step = swapArguments(body, 0, 1);  // swap V &lt;-&gt; T
7355         }
7356 
7357         MethodHandle[]
7358             iterVar    = { startIter, null, hasNext, retv },
7359             bodyClause = { init, filterArgument(step, 0, nextVal) };
7360         return loop(iterVar, bodyClause);
7361     }
7362 
7363     private static Class&lt;?&gt; iteratedLoopChecks(MethodHandle iterator, MethodHandle init, MethodHandle body) {
7364         Objects.requireNonNull(body);
7365         MethodType bodyType = body.type();
7366         Class&lt;?&gt; returnType = bodyType.returnType();
7367         List&lt;Class&lt;?&gt;&gt; internalParamList = bodyType.parameterList();
7368         // strip leading V value if present
7369         int vsize = (returnType == void.class ? 0 : 1);
7370         if (vsize != 0 &amp;&amp; (internalParamList.size() == 0 || internalParamList.get(0) != returnType)) {
7371             // argument list has no &quot;V&quot; =&gt; error
7372             MethodType expected = bodyType.insertParameterTypes(0, returnType);
7373             throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
7374         } else if (internalParamList.size() &lt;= vsize) {
7375             // missing T type =&gt; error
7376             MethodType expected = bodyType.insertParameterTypes(vsize, Object.class);
7377             throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
7378         }
7379         List&lt;Class&lt;?&gt;&gt; externalParamList = internalParamList.subList(vsize + 1, internalParamList.size());
7380         Class&lt;?&gt; iterableType = null;
7381         if (iterator != null) {
7382             // special case; if the body handle only declares V and T then
7383             // the external parameter list is obtained from iterator handle
7384             if (externalParamList.isEmpty()) {
7385                 externalParamList = iterator.type().parameterList();
7386             }
7387             MethodType itype = iterator.type();
7388             if (!Iterator.class.isAssignableFrom(itype.returnType())) {
7389                 throw newIllegalArgumentException(&quot;iteratedLoop first argument must have Iterator return type&quot;);
7390             }
7391             if (!itype.effectivelyIdenticalParameters(0, externalParamList)) {
7392                 MethodType expected = methodType(itype.returnType(), externalParamList);
7393                 throw misMatchedTypes(&quot;iterator parameters&quot;, itype, expected);
7394             }
7395         } else {
7396             if (externalParamList.isEmpty()) {
7397                 // special case; if the iterator handle is null and the body handle
7398                 // only declares V and T then the external parameter list consists
7399                 // of Iterable
7400                 externalParamList = Arrays.asList(Iterable.class);
7401                 iterableType = Iterable.class;
7402             } else {
7403                 // special case; if the iterator handle is null and the external
7404                 // parameter list is not empty then the first parameter must be
7405                 // assignable to Iterable
7406                 iterableType = externalParamList.get(0);
7407                 if (!Iterable.class.isAssignableFrom(iterableType)) {
7408                     throw newIllegalArgumentException(
7409                             &quot;inferred first loop argument must inherit from Iterable: &quot; + iterableType);
7410                 }
7411             }
7412         }
7413         if (init != null) {
7414             MethodType initType = init.type();
7415             if (initType.returnType() != returnType ||
7416                     !initType.effectivelyIdenticalParameters(0, externalParamList)) {
7417                 throw misMatchedTypes(&quot;loop initializer&quot;, initType, methodType(returnType, externalParamList));
7418             }
7419         }
7420         return iterableType;  // help the caller a bit
7421     }
7422 
7423     /*non-public*/
7424     static MethodHandle swapArguments(MethodHandle mh, int i, int j) {
7425         // there should be a better way to uncross my wires
7426         int arity = mh.type().parameterCount();
7427         int[] order = new int[arity];
7428         for (int k = 0; k &lt; arity; k++)  order[k] = k;
7429         order[i] = j; order[j] = i;
7430         Class&lt;?&gt;[] types = mh.type().parameterArray();
7431         Class&lt;?&gt; ti = types[i]; types[i] = types[j]; types[j] = ti;
7432         MethodType swapType = methodType(mh.type().returnType(), types);
7433         return permuteArguments(mh, swapType, order);
7434     }
7435 
7436     /**
7437      * Makes a method handle that adapts a {@code target} method handle by wrapping it in a {@code try-finally} block.
7438      * Another method handle, {@code cleanup}, represents the functionality of the {@code finally} block. Any exception
7439      * thrown during the execution of the {@code target} handle will be passed to the {@code cleanup} handle. The
7440      * exception will be rethrown, unless {@code cleanup} handle throws an exception first.  The
7441      * value returned from the {@code cleanup} handle&#39;s execution will be the result of the execution of the
7442      * {@code try-finally} handle.
7443      * &lt;p&gt;
7444      * The {@code cleanup} handle will be passed one or two additional leading arguments.
7445      * The first is the exception thrown during the
7446      * execution of the {@code target} handle, or {@code null} if no exception was thrown.
7447      * The second is the result of the execution of the {@code target} handle, or, if it throws an exception,
7448      * a {@code null}, zero, or {@code false} value of the required type is supplied as a placeholder.
7449      * The second argument is not present if the {@code target} handle has a {@code void} return type.
7450      * (Note that, except for argument type conversions, combinators represent {@code void} values in parameter lists
7451      * by omitting the corresponding paradoxical arguments, not by inserting {@code null} or zero values.)
7452      * &lt;p&gt;
7453      * The {@code target} and {@code cleanup} handles must have the same corresponding argument and return types, except
7454      * that the {@code cleanup} handle may omit trailing arguments. Also, the {@code cleanup} handle must have one or
7455      * two extra leading parameters:&lt;ul&gt;
7456      * &lt;li&gt;a {@code Throwable}, which will carry the exception thrown by the {@code target} handle (if any); and
7457      * &lt;li&gt;a parameter of the same type as the return type of both {@code target} and {@code cleanup}, which will carry
7458      * the result from the execution of the {@code target} handle.
7459      * This parameter is not present if the {@code target} returns {@code void}.
7460      * &lt;/ul&gt;
7461      * &lt;p&gt;
7462      * The pseudocode for the resulting adapter looks as follows. In the code, {@code V} represents the result type of
7463      * the {@code try/finally} construct; {@code A}/{@code a}, the types and values of arguments to the resulting
7464      * handle consumed by the cleanup; and {@code B}/{@code b}, those of arguments to the resulting handle discarded by
7465      * the cleanup.
7466      * &lt;blockquote&gt;&lt;pre&gt;{@code
7467      * V target(A..., B...);
7468      * V cleanup(Throwable, V, A...);
7469      * V adapter(A... a, B... b) {
7470      *   V result = (zero value for V);
7471      *   Throwable throwable = null;
7472      *   try {
7473      *     result = target(a..., b...);
7474      *   } catch (Throwable t) {
7475      *     throwable = t;
7476      *     throw t;
7477      *   } finally {
7478      *     result = cleanup(throwable, result, a...);
7479      *   }
7480      *   return result;
7481      * }
7482      * }&lt;/pre&gt;&lt;/blockquote&gt;
7483      * &lt;p&gt;
7484      * Note that the saved arguments ({@code a...} in the pseudocode) cannot
7485      * be modified by execution of the target, and so are passed unchanged
7486      * from the caller to the cleanup, if it is invoked.
7487      * &lt;p&gt;
7488      * The target and cleanup must return the same type, even if the cleanup
7489      * always throws.
7490      * To create such a throwing cleanup, compose the cleanup logic
7491      * with {@link #throwException throwException},
7492      * in order to create a method handle of the correct return type.
7493      * &lt;p&gt;
7494      * Note that {@code tryFinally} never converts exceptions into normal returns.
7495      * In rare cases where exceptions must be converted in that way, first wrap
7496      * the target with {@link #catchException(MethodHandle, Class, MethodHandle)}
7497      * to capture an outgoing exception, and then wrap with {@code tryFinally}.
7498      * &lt;p&gt;
7499      * It is recommended that the first parameter type of {@code cleanup} be
7500      * declared {@code Throwable} rather than a narrower subtype.  This ensures
7501      * {@code cleanup} will always be invoked with whatever exception that
7502      * {@code target} throws.  Declaring a narrower type may result in a
7503      * {@code ClassCastException} being thrown by the {@code try-finally}
7504      * handle if the type of the exception thrown by {@code target} is not
7505      * assignable to the first parameter type of {@code cleanup}.  Note that
7506      * various exception types of {@code VirtualMachineError},
7507      * {@code LinkageError}, and {@code RuntimeException} can in principle be
7508      * thrown by almost any kind of Java code, and a finally clause that
7509      * catches (say) only {@code IOException} would mask any of the others
7510      * behind a {@code ClassCastException}.
7511      *
7512      * @param target the handle whose execution is to be wrapped in a {@code try} block.
7513      * @param cleanup the handle that is invoked in the finally block.
7514      *
7515      * @return a method handle embodying the {@code try-finally} block composed of the two arguments.
7516      * @throws NullPointerException if any argument is null
7517      * @throws IllegalArgumentException if {@code cleanup} does not accept
7518      *          the required leading arguments, or if the method handle types do
7519      *          not match in their return types and their
7520      *          corresponding trailing parameters
7521      *
7522      * @see MethodHandles#catchException(MethodHandle, Class, MethodHandle)
7523      * @since 9
7524      */
7525     public static MethodHandle tryFinally(MethodHandle target, MethodHandle cleanup) {
7526         List&lt;Class&lt;?&gt;&gt; targetParamTypes = target.type().parameterList();
7527         Class&lt;?&gt; rtype = target.type().returnType();
7528 
7529         tryFinallyChecks(target, cleanup);
7530 
7531         // Match parameter lists: if the cleanup has a shorter parameter list than the target, add ignored arguments.
7532         // The cleanup parameter list (minus the leading Throwable and result parameters) must be a sublist of the
7533         // target parameter list.
7534         cleanup = dropArgumentsToMatch(cleanup, (rtype == void.class ? 1 : 2), targetParamTypes, 0);
7535 
7536         // Ensure that the intrinsic type checks the instance thrown by the
7537         // target against the first parameter of cleanup
7538         cleanup = cleanup.asType(cleanup.type().changeParameterType(0, Throwable.class));
7539 
7540         // Use asFixedArity() to avoid unnecessary boxing of last argument for VarargsCollector case.
7541         return MethodHandleImpl.makeTryFinally(target.asFixedArity(), cleanup.asFixedArity(), rtype, targetParamTypes);
7542     }
7543 
7544     private static void tryFinallyChecks(MethodHandle target, MethodHandle cleanup) {
7545         Class&lt;?&gt; rtype = target.type().returnType();
7546         if (rtype != cleanup.type().returnType()) {
7547             throw misMatchedTypes(&quot;target and return types&quot;, cleanup.type().returnType(), rtype);
7548         }
7549         MethodType cleanupType = cleanup.type();
7550         if (!Throwable.class.isAssignableFrom(cleanupType.parameterType(0))) {
7551             throw misMatchedTypes(&quot;cleanup first argument and Throwable&quot;, cleanup.type(), Throwable.class);
7552         }
7553         if (rtype != void.class &amp;&amp; cleanupType.parameterType(1) != rtype) {
7554             throw misMatchedTypes(&quot;cleanup second argument and target return type&quot;, cleanup.type(), rtype);
7555         }
7556         // The cleanup parameter list (minus the leading Throwable and result parameters) must be a sublist of the
7557         // target parameter list.
7558         int cleanupArgIndex = rtype == void.class ? 1 : 2;
7559         if (!cleanupType.effectivelyIdenticalParameters(cleanupArgIndex, target.type().parameterList())) {
7560             throw misMatchedTypes(&quot;cleanup parameters after (Throwable,result) and target parameter list prefix&quot;,
7561                     cleanup.type(), target.type());
7562         }
7563     }
7564 
7565 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>