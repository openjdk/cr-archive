<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../hotspot/share/runtime/vmOperations.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../module-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2379 ...
2380 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
2381   &quot;asList&quot;, methodType(List.class, Object[].class));
2382 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
2383          * }&lt;/pre&gt;&lt;/blockquote&gt;
2384          * @param refc the class from which the method is accessed
2385          * @param name the name of the method
2386          * @param type the type of the method
2387          * @return the desired method handle
2388          * @throws NoSuchMethodException if the method does not exist
2389          * @throws IllegalAccessException if access checking fails,
2390          *                                or if the method is not {@code static},
2391          *                                or if the method&#39;s variable arity modifier bit
2392          *                                is set and {@code asVarargsCollector} fails
2393          * @throws    SecurityException if a security manager is present and it
2394          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2395          * @throws NullPointerException if any argument is null
2396          */
2397         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2398             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);






2399             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));
2400         }
2401 
2402         /**
2403          * Produces a method handle for a virtual method.
2404          * The type of the method handle will be that of the method,
2405          * with the receiver type (usually {@code refc}) prepended.
2406          * The method and all its argument types must be accessible to the lookup object.
2407          * &lt;p&gt;
2408          * When called, the handle will treat the first argument as a receiver
2409          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
2410          * implementation to enter.
2411          * For private methods the named method in {@code refc} will be invoked on the receiver.
2412          * (The dispatching action is identical with that performed by an
2413          * {@code invokevirtual} or {@code invokeinterface} instruction.)
2414          * &lt;p&gt;
2415          * The first argument will be of type {@code refc} if the lookup
2416          * class has full privileges to access the member.  Otherwise
2417          * the member must be {@code protected} and the first argument
2418          * will be restricted in type to the lookup class.
</pre>
<hr />
<pre>
2524          * If the returned method handle is invoked, the constructor&#39;s class will
2525          * be initialized, if it has not already been initialized.
2526          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2527          * &lt;blockquote&gt;&lt;pre&gt;{@code
2528 import static java.lang.invoke.MethodHandles.*;
2529 import static java.lang.invoke.MethodType.*;
2530 ...
2531 MethodHandle MH_newArrayList = publicLookup().findConstructor(
2532   ArrayList.class, methodType(void.class, Collection.class));
2533 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
2534 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
2535 assert(orig != copy);
2536 assertEquals(orig, copy);
2537 // a variable-arity constructor:
2538 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
2539   ProcessBuilder.class, methodType(void.class, String[].class));
2540 ProcessBuilder pb = (ProcessBuilder)
2541   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
2542 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
2543          * }&lt;/pre&gt;&lt;/blockquote&gt;







2544          * @param refc the class or interface from which the method is accessed
2545          * @param type the type of the method, with the receiver argument omitted, and a void return type
2546          * @return the desired method handle
2547          * @throws NoSuchMethodException if the constructor does not exist
2548          * @throws IllegalAccessException if access checking fails
2549          *                                or if the method&#39;s variable arity modifier bit
2550          *                                is set and {@code asVarargsCollector} fails
2551          * @throws    SecurityException if a security manager is present and it
2552          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2553          * @throws NullPointerException if any argument is null
2554          */
2555         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2556             if (refc.isArray()) {
2557                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
2558             }



2559             String name = &quot;&lt;init&gt;&quot;;
2560             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
2561             return getDirectConstructor(refc, ctor);
2562         }
2563 
2564         /**
2565          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,
2566          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.
2567          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,
2568          * and then determines whether the class is accessible to this lookup object.
2569          * &lt;p&gt;
2570          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2571          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2572          *
2573          * @param targetName the fully qualified name of the class to be looked up.
2574          * @return the requested class.
2575          * @throws SecurityException if a security manager is present and it
2576          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2577          * @throws LinkageError if the linkage fails
2578          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
</pre>
<hr />
<pre>
3214          * arguments passed to the method handle.
3215          * &lt;p&gt;
3216          * If the constructor&#39;s {@code accessible} flag is not set,
3217          * access checking is performed immediately on behalf of the lookup class.
3218          * &lt;p&gt;
3219          * The returned method handle will have
3220          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3221          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3222          * &lt;p&gt;
3223          * If the returned method handle is invoked, the constructor&#39;s class will
3224          * be initialized, if it has not already been initialized.
3225          * @param c the reflected constructor
3226          * @return a method handle which can invoke the reflected constructor
3227          * @throws IllegalAccessException if access checking fails
3228          *                                or if the method&#39;s variable arity modifier bit
3229          *                                is set and {@code asVarargsCollector} fails
3230          * @throws NullPointerException if the argument is null
3231          */
3232         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
3233             MemberName ctor = new MemberName(c);
<span class="line-modified">3234             assert(ctor.isConstructor());</span>
3235             @SuppressWarnings(&quot;deprecation&quot;)
3236             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
<span class="line-modified">3237             return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);</span>








3238         }
3239 
3240         /**
3241          * Produces a method handle giving read access to a reflected field.
3242          * The type of the method handle will have a return type of the field&#39;s
3243          * value type.
3244          * If the field is {@code static}, the method handle will take no arguments.
3245          * Otherwise, its single argument will be the instance containing
3246          * the field.
3247          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
3248          * access checking is performed immediately on behalf of the lookup class.
3249          * &lt;p&gt;
3250          * If the field is static, and
3251          * if the returned method handle is invoked, the field&#39;s class will
3252          * be initialized, if it has not already been initialized.
3253          * @param f the reflected field
3254          * @return a method handle which can load values from the reflected field
3255          * @throws IllegalAccessException if access checking fails
3256          * @throws NullPointerException if the argument is null
3257          */
</pre>
<hr />
<pre>
3470             }
3471             Objects.requireNonNull(member.getName());
3472             Objects.requireNonNull(member.getType());
3473             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
3474         }
3475 
3476         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
3477             if (!isClassAccessible(refc)) {
3478                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
3479             }
3480         }
3481 
3482         boolean isClassAccessible(Class&lt;?&gt; refc) {
3483             Objects.requireNonNull(refc);
3484             Class&lt;?&gt; caller = lookupClassOrNull();
3485             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);
3486         }
3487 
3488         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
3489         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
<span class="line-modified">3490             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial)</span>
<span class="line-modified">3491                 throw new NoSuchMethodException(&quot;illegal method name: &quot;+name);</span>



3492         }
3493 
<span class="line-removed">3494 </span>
3495         /**
3496          * Find my trustable caller class if m is a caller sensitive method.
3497          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3498          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
3499          */
3500         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {
3501             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {
3502                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods
3503                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3504             }
3505             return this;
3506         }
3507 
3508         /**
3509          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3510          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3511          *
3512          * @deprecated This method was originally designed to test {@code PRIVATE} access
3513          * that implies full privilege access but {@code MODULE} access has since become
3514          * independent of {@code PRIVATE} access.  It is recommended to call
</pre>
<hr />
<pre>
3577                 !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {
3578                 ReflectUtil.checkPackageAccess(refc);
3579             }
3580 
3581             // Step 2a:
3582             if (m.isPublic()) return;
3583             if (!fullPowerLookup) {
3584                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3585             }
3586 
3587             // Step 3:
3588             Class&lt;?&gt; defc = m.getDeclaringClass();
3589             if (!fullPowerLookup &amp;&amp; defc != refc) {
3590                 ReflectUtil.checkPackageAccess(defc);
3591             }
3592         }
3593 
3594         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3595             boolean wantStatic = (refKind == REF_invokeStatic);
3596             String message;
<span class="line-modified">3597             if (m.isConstructor())</span>
3598                 message = &quot;expected a method, not a constructor&quot;;
3599             else if (!m.isMethod())
3600                 message = &quot;expected a method&quot;;
3601             else if (wantStatic != m.isStatic())
3602                 message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;
3603             else
3604                 { checkAccess(refKind, refc, m); return; }
3605             throw m.makeAccessException(message, this);
3606         }
3607 
3608         void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3609             boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);
3610             String message;
3611             if (wantStatic != m.isStatic())
3612                 message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;
3613             else
3614                 { checkAccess(refKind, refc, m); return; }
3615             throw m.makeAccessException(message, this);
3616         }
3617 
</pre>
<hr />
<pre>
3876                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3877                 }
3878                 refc = lookupClass();
3879             }
3880             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),
3881                                               this.allowedModes == TRUSTED &amp;&amp; !getField.isTrustedFinalField());
3882         }
3883         /** Check access and get the requested constructor. */
3884         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3885             final boolean checkSecurity = true;
3886             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3887         }
3888         /** Check access and get the requested constructor, eliding security manager checks. */
3889         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3890             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3891             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3892         }
3893         /** Common code for all constructors; do not call directly except from immediately above. */
3894         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3895                                                   boolean checkSecurity) throws IllegalAccessException {
<span class="line-modified">3896             assert(ctor.isConstructor());</span>
3897             checkAccess(REF_newInvokeSpecial, refc, ctor);
3898             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3899             if (checkSecurity)
3900                 checkSecurityManager(refc, ctor);
3901             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3902             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3903         }
3904 
3905         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3906          */
3907         /*non-public*/
3908         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)
3909                 throws ReflectiveOperationException {
3910             if (!(type instanceof Class || type instanceof MethodType))
3911                 throw new InternalError(&quot;unresolved MemberName&quot;);
3912             MemberName member = new MemberName(refKind, defc, name, type);
3913             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3914             if (mh != null) {
3915                 checkSymbolicClass(defc);
3916                 return mh;
</pre>
<hr />
<pre>
4066      * Produces a method handle giving write access to elements of an array,
4067      * as if by the {@code astore} bytecode.
4068      * The type of the method handle will have a void return type.
4069      * Its last argument will be the array&#39;s element type.
4070      * The first and second arguments will be the array type and int.
4071      *
4072      * &lt;p&gt; When the returned method handle is invoked,
4073      * the array reference and array index are checked.
4074      * A {@code NullPointerException} will be thrown if the array reference
4075      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
4076      * thrown if the index is negative or if it is greater than or equal to
4077      * the length of the array.
4078      *
4079      * @param arrayClass the class of an array
4080      * @return a method handle which can store values into the array type
4081      * @throws NullPointerException if the argument is null
4082      * @throws IllegalArgumentException if arrayClass is not an array type
4083      * @jvms 6.5 {@code aastore} Instruction
4084      */
4085     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {



4086         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
4087     }
4088 
4089     /**
4090      * Produces a VarHandle giving access to elements of an array of type
4091      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
4092      * of {@code arrayClass} and the list of coordinate types is
4093      * {@code (arrayClass, int)}, where the {@code int} coordinate type
4094      * corresponds to an argument that is an index into an array.
4095      * &lt;p&gt;
4096      * Certain access modes of the returned VarHandle are unsupported under
4097      * the following conditions:
4098      * &lt;ul&gt;
4099      * &lt;li&gt;if the component type is anything other than {@code byte},
4100      *     {@code short}, {@code char}, {@code int}, {@code long},
4101      *     {@code float}, or {@code double} then numeric atomic update access
4102      *     modes are unsupported.
4103      * &lt;li&gt;if the component type is anything other than {@code boolean},
4104      *     {@code byte}, {@code short}, {@code char}, {@code int} or
4105      *     {@code long} then bitwise atomic update access modes are
</pre>
<hr />
<pre>
4826     }
4827 
4828     /**
4829      * Produces a constant method handle of the requested return type which
4830      * returns the default value for that type every time it is invoked.
4831      * The resulting constant method handle will have no side effects.
4832      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4833      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4834      * since {@code explicitCastArguments} converts {@code null} to default values.
4835      * @param type the expected return type of the desired method handle
4836      * @return a constant method handle that takes no arguments
4837      *         and returns the default value of the given type (or void, if the type is void)
4838      * @throws NullPointerException if the argument is null
4839      * @see MethodHandles#constant
4840      * @see MethodHandles#empty
4841      * @see MethodHandles#explicitCastArguments
4842      * @since 9
4843      */
4844     public static MethodHandle zero(Class&lt;?&gt; type) {
4845         Objects.requireNonNull(type);
<span class="line-modified">4846         return type.isPrimitive() ?  zero(Wrapper.forPrimitiveType(type), type) : zero(Wrapper.OBJECT, type);</span>






4847     }
4848 
4849     private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
4850         return type == void.class ? zero(type) : identity(type);
4851     }
4852 
4853     /**
4854      * Produces a method handle of the requested type which ignores any arguments, does nothing,
4855      * and returns a suitable default depending on the return type.
4856      * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
4857      * &lt;p&gt;The returned method handle is equivalent to
4858      * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
4859      *
4860      * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
4861      * {@code guardWithTest(pred, target, empty(target.type())}.
4862      * @param type the type of the desired method handle
4863      * @return a constant method handle of the given type, which returns a default value of the given return type
4864      * @throws NullPointerException if the argument is null
4865      * @see MethodHandles#zero
4866      * @see MethodHandles#constant
4867      * @since 9
4868      */
4869     public static  MethodHandle empty(MethodType type) {
4870         Objects.requireNonNull(type);
4871         return dropArguments(zero(type.returnType()), 0, type.parameterList());
4872     }
4873 
4874     private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
4875     private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
<span class="line-modified">4876         MethodType mtype = methodType(ptype, ptype);</span>
4877         LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
4878         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
4879     }
4880 
4881     private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
4882         int pos = btw.ordinal();
4883         MethodHandle zero = ZERO_MHS[pos];
4884         if (zero == null) {
4885             zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
4886         }
4887         if (zero.type().returnType() == rtype)
4888             return zero;
4889         assert(btw == Wrapper.OBJECT);
4890         return makeZero(rtype);
4891     }
4892     private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
4893     private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
4894         MethodType mtype = methodType(rtype);
4895         LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
4896         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
</pre>
</td>
<td>
<hr />
<pre>
2379 ...
2380 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
2381   &quot;asList&quot;, methodType(List.class, Object[].class));
2382 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
2383          * }&lt;/pre&gt;&lt;/blockquote&gt;
2384          * @param refc the class from which the method is accessed
2385          * @param name the name of the method
2386          * @param type the type of the method
2387          * @return the desired method handle
2388          * @throws NoSuchMethodException if the method does not exist
2389          * @throws IllegalAccessException if access checking fails,
2390          *                                or if the method is not {@code static},
2391          *                                or if the method&#39;s variable arity modifier bit
2392          *                                is set and {@code asVarargsCollector} fails
2393          * @throws    SecurityException if a security manager is present and it
2394          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2395          * @throws NullPointerException if any argument is null
2396          */
2397         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2398             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);
<span class="line-added">2399             // resolveOrFail could return a non-static &lt;init&gt; method if present</span>
<span class="line-added">2400             // detect and throw NSME before producing a MethodHandle</span>
<span class="line-added">2401             if (!method.isStatic() &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;)) {</span>
<span class="line-added">2402                 throw new NoSuchMethodException(&quot;illegal method name: &quot; + name);</span>
<span class="line-added">2403             }</span>
<span class="line-added">2404 </span>
2405             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));
2406         }
2407 
2408         /**
2409          * Produces a method handle for a virtual method.
2410          * The type of the method handle will be that of the method,
2411          * with the receiver type (usually {@code refc}) prepended.
2412          * The method and all its argument types must be accessible to the lookup object.
2413          * &lt;p&gt;
2414          * When called, the handle will treat the first argument as a receiver
2415          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
2416          * implementation to enter.
2417          * For private methods the named method in {@code refc} will be invoked on the receiver.
2418          * (The dispatching action is identical with that performed by an
2419          * {@code invokevirtual} or {@code invokeinterface} instruction.)
2420          * &lt;p&gt;
2421          * The first argument will be of type {@code refc} if the lookup
2422          * class has full privileges to access the member.  Otherwise
2423          * the member must be {@code protected} and the first argument
2424          * will be restricted in type to the lookup class.
</pre>
<hr />
<pre>
2530          * If the returned method handle is invoked, the constructor&#39;s class will
2531          * be initialized, if it has not already been initialized.
2532          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2533          * &lt;blockquote&gt;&lt;pre&gt;{@code
2534 import static java.lang.invoke.MethodHandles.*;
2535 import static java.lang.invoke.MethodType.*;
2536 ...
2537 MethodHandle MH_newArrayList = publicLookup().findConstructor(
2538   ArrayList.class, methodType(void.class, Collection.class));
2539 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
2540 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
2541 assert(orig != copy);
2542 assertEquals(orig, copy);
2543 // a variable-arity constructor:
2544 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
2545   ProcessBuilder.class, methodType(void.class, String[].class));
2546 ProcessBuilder pb = (ProcessBuilder)
2547   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
2548 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
2549          * }&lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-added">2550          *</span>
<span class="line-added">2551          * @apiNote</span>
<span class="line-added">2552          * This method does not find a static {@code &lt;init&gt;} factory method as it is invoked</span>
<span class="line-added">2553          * via {@code invokestatic} bytecode as opposed to {@code invokespecial} for an</span>
<span class="line-added">2554          * object constructor.  To look up static {@code &lt;init&gt;} factory method, use</span>
<span class="line-added">2555          * the {@link #findStatic(Class, String, MethodType) findStatic} method.</span>
<span class="line-added">2556          *</span>
2557          * @param refc the class or interface from which the method is accessed
2558          * @param type the type of the method, with the receiver argument omitted, and a void return type
2559          * @return the desired method handle
2560          * @throws NoSuchMethodException if the constructor does not exist
2561          * @throws IllegalAccessException if access checking fails
2562          *                                or if the method&#39;s variable arity modifier bit
2563          *                                is set and {@code asVarargsCollector} fails
2564          * @throws    SecurityException if a security manager is present and it
2565          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2566          * @throws NullPointerException if any argument is null
2567          */
2568         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2569             if (refc.isArray()) {
2570                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
2571             }
<span class="line-added">2572             if (type.returnType() != void.class) {</span>
<span class="line-added">2573                 throw new NoSuchMethodException(&quot;Constructors must have void return type: &quot; + refc.getName());</span>
<span class="line-added">2574             }</span>
2575             String name = &quot;&lt;init&gt;&quot;;
2576             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
2577             return getDirectConstructor(refc, ctor);
2578         }
2579 
2580         /**
2581          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,
2582          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.
2583          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,
2584          * and then determines whether the class is accessible to this lookup object.
2585          * &lt;p&gt;
2586          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2587          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2588          *
2589          * @param targetName the fully qualified name of the class to be looked up.
2590          * @return the requested class.
2591          * @throws SecurityException if a security manager is present and it
2592          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2593          * @throws LinkageError if the linkage fails
2594          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
</pre>
<hr />
<pre>
3230          * arguments passed to the method handle.
3231          * &lt;p&gt;
3232          * If the constructor&#39;s {@code accessible} flag is not set,
3233          * access checking is performed immediately on behalf of the lookup class.
3234          * &lt;p&gt;
3235          * The returned method handle will have
3236          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3237          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3238          * &lt;p&gt;
3239          * If the returned method handle is invoked, the constructor&#39;s class will
3240          * be initialized, if it has not already been initialized.
3241          * @param c the reflected constructor
3242          * @return a method handle which can invoke the reflected constructor
3243          * @throws IllegalAccessException if access checking fails
3244          *                                or if the method&#39;s variable arity modifier bit
3245          *                                is set and {@code asVarargsCollector} fails
3246          * @throws NullPointerException if the argument is null
3247          */
3248         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
3249             MemberName ctor = new MemberName(c);
<span class="line-modified">3250             assert(ctor.isObjectConstructorOrStaticInitMethod());</span>
3251             @SuppressWarnings(&quot;deprecation&quot;)
3252             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
<span class="line-modified">3253             if (ctor.isObjectConstructor()) {</span>
<span class="line-added">3254                 assert(ctor.getReturnType() == void.class);</span>
<span class="line-added">3255                 return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);</span>
<span class="line-added">3256             } else {</span>
<span class="line-added">3257                 // static init factory is a static method</span>
<span class="line-added">3258                 assert(ctor.isMethod() &amp;&amp; ctor.getReturnType() == ctor.getDeclaringClass() &amp;&amp; ctor.getReferenceKind() == REF_invokeStatic);</span>
<span class="line-added">3259                 assert(!MethodHandleNatives.isCallerSensitive(ctor));  // must not be caller-sensitive</span>
<span class="line-added">3260                 return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), ctor.getDeclaringClass(), ctor, lookup);</span>
<span class="line-added">3261             }</span>
3262         }
3263 
3264         /**
3265          * Produces a method handle giving read access to a reflected field.
3266          * The type of the method handle will have a return type of the field&#39;s
3267          * value type.
3268          * If the field is {@code static}, the method handle will take no arguments.
3269          * Otherwise, its single argument will be the instance containing
3270          * the field.
3271          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
3272          * access checking is performed immediately on behalf of the lookup class.
3273          * &lt;p&gt;
3274          * If the field is static, and
3275          * if the returned method handle is invoked, the field&#39;s class will
3276          * be initialized, if it has not already been initialized.
3277          * @param f the reflected field
3278          * @return a method handle which can load values from the reflected field
3279          * @throws IllegalAccessException if access checking fails
3280          * @throws NullPointerException if the argument is null
3281          */
</pre>
<hr />
<pre>
3494             }
3495             Objects.requireNonNull(member.getName());
3496             Objects.requireNonNull(member.getType());
3497             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
3498         }
3499 
3500         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
3501             if (!isClassAccessible(refc)) {
3502                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
3503             }
3504         }
3505 
3506         boolean isClassAccessible(Class&lt;?&gt; refc) {
3507             Objects.requireNonNull(refc);
3508             Class&lt;?&gt; caller = lookupClassOrNull();
3509             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);
3510         }
3511 
3512         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
3513         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
<span class="line-modified">3514             // &quot;&lt;init&gt;&quot; can only be invoked via invokespecial or it&#39;s a static init factory</span>
<span class="line-modified">3515             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial &amp;&amp;</span>
<span class="line-added">3516                     !(refKind == REF_invokeStatic &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;))) {</span>
<span class="line-added">3517                     throw new NoSuchMethodException(&quot;illegal method name: &quot; + name);</span>
<span class="line-added">3518             }</span>
3519         }
3520 

3521         /**
3522          * Find my trustable caller class if m is a caller sensitive method.
3523          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3524          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
3525          */
3526         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {
3527             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {
3528                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods
3529                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3530             }
3531             return this;
3532         }
3533 
3534         /**
3535          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3536          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3537          *
3538          * @deprecated This method was originally designed to test {@code PRIVATE} access
3539          * that implies full privilege access but {@code MODULE} access has since become
3540          * independent of {@code PRIVATE} access.  It is recommended to call
</pre>
<hr />
<pre>
3603                 !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {
3604                 ReflectUtil.checkPackageAccess(refc);
3605             }
3606 
3607             // Step 2a:
3608             if (m.isPublic()) return;
3609             if (!fullPowerLookup) {
3610                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3611             }
3612 
3613             // Step 3:
3614             Class&lt;?&gt; defc = m.getDeclaringClass();
3615             if (!fullPowerLookup &amp;&amp; defc != refc) {
3616                 ReflectUtil.checkPackageAccess(defc);
3617             }
3618         }
3619 
3620         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3621             boolean wantStatic = (refKind == REF_invokeStatic);
3622             String message;
<span class="line-modified">3623             if (m.isObjectConstructor())</span>
3624                 message = &quot;expected a method, not a constructor&quot;;
3625             else if (!m.isMethod())
3626                 message = &quot;expected a method&quot;;
3627             else if (wantStatic != m.isStatic())
3628                 message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;
3629             else
3630                 { checkAccess(refKind, refc, m); return; }
3631             throw m.makeAccessException(message, this);
3632         }
3633 
3634         void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3635             boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);
3636             String message;
3637             if (wantStatic != m.isStatic())
3638                 message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;
3639             else
3640                 { checkAccess(refKind, refc, m); return; }
3641             throw m.makeAccessException(message, this);
3642         }
3643 
</pre>
<hr />
<pre>
3902                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3903                 }
3904                 refc = lookupClass();
3905             }
3906             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),
3907                                               this.allowedModes == TRUSTED &amp;&amp; !getField.isTrustedFinalField());
3908         }
3909         /** Check access and get the requested constructor. */
3910         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3911             final boolean checkSecurity = true;
3912             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3913         }
3914         /** Check access and get the requested constructor, eliding security manager checks. */
3915         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3916             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3917             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3918         }
3919         /** Common code for all constructors; do not call directly except from immediately above. */
3920         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3921                                                   boolean checkSecurity) throws IllegalAccessException {
<span class="line-modified">3922             assert(ctor.isObjectConstructor());</span>
3923             checkAccess(REF_newInvokeSpecial, refc, ctor);
3924             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3925             if (checkSecurity)
3926                 checkSecurityManager(refc, ctor);
3927             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3928             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3929         }
3930 
3931         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3932          */
3933         /*non-public*/
3934         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)
3935                 throws ReflectiveOperationException {
3936             if (!(type instanceof Class || type instanceof MethodType))
3937                 throw new InternalError(&quot;unresolved MemberName&quot;);
3938             MemberName member = new MemberName(refKind, defc, name, type);
3939             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3940             if (mh != null) {
3941                 checkSymbolicClass(defc);
3942                 return mh;
</pre>
<hr />
<pre>
4092      * Produces a method handle giving write access to elements of an array,
4093      * as if by the {@code astore} bytecode.
4094      * The type of the method handle will have a void return type.
4095      * Its last argument will be the array&#39;s element type.
4096      * The first and second arguments will be the array type and int.
4097      *
4098      * &lt;p&gt; When the returned method handle is invoked,
4099      * the array reference and array index are checked.
4100      * A {@code NullPointerException} will be thrown if the array reference
4101      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
4102      * thrown if the index is negative or if it is greater than or equal to
4103      * the length of the array.
4104      *
4105      * @param arrayClass the class of an array
4106      * @return a method handle which can store values into the array type
4107      * @throws NullPointerException if the argument is null
4108      * @throws IllegalArgumentException if arrayClass is not an array type
4109      * @jvms 6.5 {@code aastore} Instruction
4110      */
4111     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
<span class="line-added">4112         if (arrayClass.isInlineClass()) {</span>
<span class="line-added">4113             throw new UnsupportedOperationException();</span>
<span class="line-added">4114         }</span>
4115         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
4116     }
4117 
4118     /**
4119      * Produces a VarHandle giving access to elements of an array of type
4120      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
4121      * of {@code arrayClass} and the list of coordinate types is
4122      * {@code (arrayClass, int)}, where the {@code int} coordinate type
4123      * corresponds to an argument that is an index into an array.
4124      * &lt;p&gt;
4125      * Certain access modes of the returned VarHandle are unsupported under
4126      * the following conditions:
4127      * &lt;ul&gt;
4128      * &lt;li&gt;if the component type is anything other than {@code byte},
4129      *     {@code short}, {@code char}, {@code int}, {@code long},
4130      *     {@code float}, or {@code double} then numeric atomic update access
4131      *     modes are unsupported.
4132      * &lt;li&gt;if the component type is anything other than {@code boolean},
4133      *     {@code byte}, {@code short}, {@code char}, {@code int} or
4134      *     {@code long} then bitwise atomic update access modes are
</pre>
<hr />
<pre>
4855     }
4856 
4857     /**
4858      * Produces a constant method handle of the requested return type which
4859      * returns the default value for that type every time it is invoked.
4860      * The resulting constant method handle will have no side effects.
4861      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4862      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4863      * since {@code explicitCastArguments} converts {@code null} to default values.
4864      * @param type the expected return type of the desired method handle
4865      * @return a constant method handle that takes no arguments
4866      *         and returns the default value of the given type (or void, if the type is void)
4867      * @throws NullPointerException if the argument is null
4868      * @see MethodHandles#constant
4869      * @see MethodHandles#empty
4870      * @see MethodHandles#explicitCastArguments
4871      * @since 9
4872      */
4873     public static MethodHandle zero(Class&lt;?&gt; type) {
4874         Objects.requireNonNull(type);
<span class="line-modified">4875         if (type.isPrimitive()) {</span>
<span class="line-added">4876             return zero(Wrapper.forPrimitiveType(type), type);</span>
<span class="line-added">4877         } else if (type.isInlineClass()) {</span>
<span class="line-added">4878             throw new UnsupportedOperationException();</span>
<span class="line-added">4879         } else {</span>
<span class="line-added">4880             return zero(Wrapper.OBJECT, type);</span>
<span class="line-added">4881         }</span>
4882     }
4883 
4884     private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
4885         return type == void.class ? zero(type) : identity(type);
4886     }
4887 
4888     /**
4889      * Produces a method handle of the requested type which ignores any arguments, does nothing,
4890      * and returns a suitable default depending on the return type.
4891      * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
4892      * &lt;p&gt;The returned method handle is equivalent to
4893      * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
4894      *
4895      * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
4896      * {@code guardWithTest(pred, target, empty(target.type())}.
4897      * @param type the type of the desired method handle
4898      * @return a constant method handle of the given type, which returns a default value of the given return type
4899      * @throws NullPointerException if the argument is null
4900      * @see MethodHandles#zero
4901      * @see MethodHandles#constant
4902      * @since 9
4903      */
4904     public static  MethodHandle empty(MethodType type) {
4905         Objects.requireNonNull(type);
4906         return dropArguments(zero(type.returnType()), 0, type.parameterList());
4907     }
4908 
4909     private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
4910     private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
<span class="line-modified">4911         MethodType mtype = MethodType.methodType(ptype, ptype);</span>
4912         LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
4913         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
4914     }
4915 
4916     private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
4917         int pos = btw.ordinal();
4918         MethodHandle zero = ZERO_MHS[pos];
4919         if (zero == null) {
4920             zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
4921         }
4922         if (zero.type().returnType() == rtype)
4923             return zero;
4924         assert(btw == Wrapper.OBJECT);
4925         return makeZero(rtype);
4926     }
4927     private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
4928     private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
4929         MethodType mtype = methodType(rtype);
4930         LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
4931         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../hotspot/share/runtime/vmOperations.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../module-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>