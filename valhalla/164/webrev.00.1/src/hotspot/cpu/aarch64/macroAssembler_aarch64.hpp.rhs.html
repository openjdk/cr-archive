<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
  27 #define CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
  28 
  29 #include &quot;asm/assembler.hpp&quot;
  30 #include &quot;oops/compressedOops.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  31 #include &quot;utilities/macros.hpp&quot;</span>
  32 #include &quot;utilities/powerOfTwo.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  33 #include &quot;runtime/signature.hpp&quot;</span>
<span class="line-added">  34 </span>
<span class="line-added">  35 </span>
<span class="line-added">  36 class ciInlineKlass;</span>
  37 
  38 // MacroAssembler extends Assembler by frequently used macros.
  39 //
  40 // Instructions for which a &#39;better&#39; code sequence exists depending
  41 // on arguments should also go in here.
  42 
  43 class MacroAssembler: public Assembler {
  44   friend class LIR_Assembler;
  45 
  46  public:
  47   using Assembler::mov;
  48   using Assembler::movi;
  49 
  50  protected:
  51 
  52   // Support for VM calls
  53   //
  54   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  55   // may customize this version by overriding it for its purposes (e.g., to save/restore
  56   // additional registers when doing a VM call).
  57   virtual void call_VM_leaf_base(
  58     address entry_point,               // the entry point
  59     int     number_of_arguments,        // the number of arguments to pop after the call
  60     Label *retaddr = NULL
  61   );
  62 
  63   virtual void call_VM_leaf_base(
  64     address entry_point,               // the entry point
  65     int     number_of_arguments,        // the number of arguments to pop after the call
  66     Label &amp;retaddr) {
  67     call_VM_leaf_base(entry_point, number_of_arguments, &amp;retaddr);
  68   }
  69 
  70   // This is the base routine called by the different versions of call_VM. The interpreter
  71   // may customize this version by overriding it for its purposes (e.g., to save/restore
  72   // additional registers when doing a VM call).
  73   //
  74   // If no java_thread register is specified (noreg) than rthread will be used instead. call_VM_base
  75   // returns the register which contains the thread upon return. If a thread register has been
  76   // specified, the return value will correspond to that register. If no last_java_sp is specified
  77   // (noreg) than rsp will be used instead.
  78   virtual void call_VM_base(           // returns the register containing the thread upon return
  79     Register oop_result,               // where an oop-result ends up if any; use noreg otherwise
  80     Register java_thread,              // the thread if computed before     ; use noreg otherwise
  81     Register last_java_sp,             // to set up last_Java_frame in stubs; use noreg otherwise
  82     address  entry_point,              // the entry point
  83     int      number_of_arguments,      // the number of arguments (w/o thread) to pop after the call
  84     bool     check_exceptions          // whether to check for pending exceptions after return
  85   );
  86 
  87   void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions = true);
  88 
  89   enum KlassDecodeMode {
  90     KlassDecodeNone,
  91     KlassDecodeZero,
  92     KlassDecodeXor,
  93     KlassDecodeMovk
  94   };
  95 
  96   KlassDecodeMode klass_decode_mode();
  97 
  98  private:
  99   static KlassDecodeMode _klass_decode_mode;
 100 
 101  public:
 102   MacroAssembler(CodeBuffer* code) : Assembler(code) {}
 103 
 104  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
 105  // The implementation is only non-empty for the InterpreterMacroAssembler,
 106  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
 107  virtual void check_and_handle_popframe(Register java_thread);
 108  virtual void check_and_handle_earlyret(Register java_thread);
 109 
 110   void safepoint_poll(Label&amp; slow_path);
 111   void safepoint_poll_acquire(Label&amp; slow_path);
 112 
 113   // Biased locking support
 114   // lock_reg and obj_reg must be loaded up with the appropriate values.
 115   // swap_reg is killed.
 116   // tmp_reg must be supplied and must not be rscratch1 or rscratch2
 117   // Optional slow case is for implementations (interpreter and C1) which branch to
 118   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 119   // Returns offset of first potentially-faulting instruction for null
 120   // check info (currently consumed only by C1). If
 121   // swap_reg_contains_mark is true then returns -1 as it is assumed
 122   // the calling code has already passed any potential faults.
 123   int biased_locking_enter(Register lock_reg, Register obj_reg,
 124                            Register swap_reg, Register tmp_reg,
 125                            bool swap_reg_contains_mark,
 126                            Label&amp; done, Label* slow_case = NULL,
 127                            BiasedLockingCounters* counters = NULL);
 128   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 129 
 130 
 131   // Helper functions for statistics gathering.
 132   // Unconditional atomic increment.
 133   void atomic_incw(Register counter_addr, Register tmp, Register tmp2);
 134   void atomic_incw(Address counter_addr, Register tmp1, Register tmp2, Register tmp3) {
 135     lea(tmp1, counter_addr);
 136     atomic_incw(tmp1, tmp2, tmp3);
 137   }
 138   // Load Effective Address
 139   void lea(Register r, const Address &amp;a) {
 140     InstructionMark im(this);
 141     code_section()-&gt;relocate(inst_mark(), a.rspec());
 142     a.lea(this, r);
 143   }
 144 
 145   /* Sometimes we get misaligned loads and stores, usually from Unsafe
 146      accesses, and these can exceed the offset range. */
 147   Address legitimize_address(const Address &amp;a, int size, Register scratch) {
 148     if (a.getMode() == Address::base_plus_offset) {
 149       if (! Address::offset_ok_for_immed(a.offset(), exact_log2(size))) {
 150         block_comment(&quot;legitimize_address {&quot;);
 151         lea(scratch, a);
 152         block_comment(&quot;} legitimize_address&quot;);
 153         return Address(scratch);
 154       }
 155     }
 156     return a;
 157   }
 158 
 159   void addmw(Address a, Register incr, Register scratch) {
 160     ldrw(scratch, a);
 161     addw(scratch, scratch, incr);
 162     strw(scratch, a);
 163   }
 164 
 165   // Add constant to memory word
 166   void addmw(Address a, int imm, Register scratch) {
 167     ldrw(scratch, a);
 168     if (imm &gt; 0)
 169       addw(scratch, scratch, (unsigned)imm);
 170     else
 171       subw(scratch, scratch, (unsigned)-imm);
 172     strw(scratch, a);
 173   }
 174 
 175   void bind(Label&amp; L) {
 176     Assembler::bind(L);
 177     code()-&gt;clear_last_insn();
 178   }
 179 
 180   void membar(Membar_mask_bits order_constraint);
 181 
 182   using Assembler::ldr;
 183   using Assembler::str;
 184   using Assembler::ldrw;
 185   using Assembler::strw;
 186 
 187   void ldr(Register Rx, const Address &amp;adr);
 188   void ldrw(Register Rw, const Address &amp;adr);
 189   void str(Register Rx, const Address &amp;adr);
 190   void strw(Register Rx, const Address &amp;adr);
 191 
 192   // Frame creation and destruction shared between JITs.
 193   void build_frame(int framesize);
 194   void remove_frame(int framesize);
 195 
 196   virtual void _call_Unimplemented(address call_site) {
 197     mov(rscratch2, call_site);
 198   }
 199 
 200 #define call_Unimplemented() _call_Unimplemented((address)__PRETTY_FUNCTION__)
 201 
 202   // aliases defined in AARCH64 spec
 203 
 204   template&lt;class T&gt;
 205   inline void cmpw(Register Rd, T imm)  { subsw(zr, Rd, imm); }
 206 
 207   inline void cmp(Register Rd, unsigned char imm8)  { subs(zr, Rd, imm8); }
 208   inline void cmp(Register Rd, unsigned imm) __attribute__ ((deprecated));
 209 
 210   inline void cmnw(Register Rd, unsigned imm) { addsw(zr, Rd, imm); }
 211   inline void cmn(Register Rd, unsigned imm) { adds(zr, Rd, imm); }
 212 
 213   void cset(Register Rd, Assembler::Condition cond) {
 214     csinc(Rd, zr, zr, ~cond);
 215   }
 216   void csetw(Register Rd, Assembler::Condition cond) {
 217     csincw(Rd, zr, zr, ~cond);
 218   }
 219 
 220   void cneg(Register Rd, Register Rn, Assembler::Condition cond) {
 221     csneg(Rd, Rn, Rn, ~cond);
 222   }
 223   void cnegw(Register Rd, Register Rn, Assembler::Condition cond) {
 224     csnegw(Rd, Rn, Rn, ~cond);
 225   }
 226 
 227   inline void movw(Register Rd, Register Rn) {
 228     if (Rd == sp || Rn == sp) {
 229       addw(Rd, Rn, 0U);
 230     } else {
 231       orrw(Rd, zr, Rn);
 232     }
 233   }
 234   inline void mov(Register Rd, Register Rn) {
 235     assert(Rd != r31_sp &amp;&amp; Rn != r31_sp, &quot;should be&quot;);
 236     if (Rd == Rn) {
 237     } else if (Rd == sp || Rn == sp) {
 238       add(Rd, Rn, 0U);
 239     } else {
 240       orr(Rd, zr, Rn);
 241     }
 242   }
 243 
 244   inline void moviw(Register Rd, unsigned imm) { orrw(Rd, zr, imm); }
 245   inline void movi(Register Rd, unsigned imm) { orr(Rd, zr, imm); }
 246 
 247   inline void tstw(Register Rd, Register Rn) { andsw(zr, Rd, Rn); }
 248   inline void tst(Register Rd, Register Rn) { ands(zr, Rd, Rn); }
 249 
 250   inline void tstw(Register Rd, uint64_t imm) { andsw(zr, Rd, imm); }
 251   inline void tst(Register Rd, uint64_t imm) { ands(zr, Rd, imm); }
 252 
 253   inline void bfiw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 254     bfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 255   }
 256   inline void bfi(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 257     bfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 258   }
 259 
 260   inline void bfxilw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 261     bfmw(Rd, Rn, lsb, (lsb + width - 1));
 262   }
 263   inline void bfxil(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 264     bfm(Rd, Rn, lsb , (lsb + width - 1));
 265   }
 266 
 267   inline void sbfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 268     sbfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 269   }
 270   inline void sbfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 271     sbfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 272   }
 273 
 274   inline void sbfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 275     sbfmw(Rd, Rn, lsb, (lsb + width - 1));
 276   }
 277   inline void sbfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 278     sbfm(Rd, Rn, lsb , (lsb + width - 1));
 279   }
 280 
 281   inline void ubfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 282     ubfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 283   }
 284   inline void ubfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 285     ubfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 286   }
 287 
 288   inline void ubfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 289     ubfmw(Rd, Rn, lsb, (lsb + width - 1));
 290   }
 291   inline void ubfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 292     ubfm(Rd, Rn, lsb , (lsb + width - 1));
 293   }
 294 
 295   inline void asrw(Register Rd, Register Rn, unsigned imm) {
 296     sbfmw(Rd, Rn, imm, 31);
 297   }
 298 
 299   inline void asr(Register Rd, Register Rn, unsigned imm) {
 300     sbfm(Rd, Rn, imm, 63);
 301   }
 302 
 303   inline void lslw(Register Rd, Register Rn, unsigned imm) {
 304     ubfmw(Rd, Rn, ((32 - imm) &amp; 31), (31 - imm));
 305   }
 306 
 307   inline void lsl(Register Rd, Register Rn, unsigned imm) {
 308     ubfm(Rd, Rn, ((64 - imm) &amp; 63), (63 - imm));
 309   }
 310 
 311   inline void lsrw(Register Rd, Register Rn, unsigned imm) {
 312     ubfmw(Rd, Rn, imm, 31);
 313   }
 314 
 315   inline void lsr(Register Rd, Register Rn, unsigned imm) {
 316     ubfm(Rd, Rn, imm, 63);
 317   }
 318 
 319   inline void rorw(Register Rd, Register Rn, unsigned imm) {
 320     extrw(Rd, Rn, Rn, imm);
 321   }
 322 
 323   inline void ror(Register Rd, Register Rn, unsigned imm) {
 324     extr(Rd, Rn, Rn, imm);
 325   }
 326 
 327   inline void sxtbw(Register Rd, Register Rn) {
 328     sbfmw(Rd, Rn, 0, 7);
 329   }
 330   inline void sxthw(Register Rd, Register Rn) {
 331     sbfmw(Rd, Rn, 0, 15);
 332   }
 333   inline void sxtb(Register Rd, Register Rn) {
 334     sbfm(Rd, Rn, 0, 7);
 335   }
 336   inline void sxth(Register Rd, Register Rn) {
 337     sbfm(Rd, Rn, 0, 15);
 338   }
 339   inline void sxtw(Register Rd, Register Rn) {
 340     sbfm(Rd, Rn, 0, 31);
 341   }
 342 
 343   inline void uxtbw(Register Rd, Register Rn) {
 344     ubfmw(Rd, Rn, 0, 7);
 345   }
 346   inline void uxthw(Register Rd, Register Rn) {
 347     ubfmw(Rd, Rn, 0, 15);
 348   }
 349   inline void uxtb(Register Rd, Register Rn) {
 350     ubfm(Rd, Rn, 0, 7);
 351   }
 352   inline void uxth(Register Rd, Register Rn) {
 353     ubfm(Rd, Rn, 0, 15);
 354   }
 355   inline void uxtw(Register Rd, Register Rn) {
 356     ubfm(Rd, Rn, 0, 31);
 357   }
 358 
 359   inline void cmnw(Register Rn, Register Rm) {
 360     addsw(zr, Rn, Rm);
 361   }
 362   inline void cmn(Register Rn, Register Rm) {
 363     adds(zr, Rn, Rm);
 364   }
 365 
 366   inline void cmpw(Register Rn, Register Rm) {
 367     subsw(zr, Rn, Rm);
 368   }
 369   inline void cmp(Register Rn, Register Rm) {
 370     subs(zr, Rn, Rm);
 371   }
 372 
 373   inline void negw(Register Rd, Register Rn) {
 374     subw(Rd, zr, Rn);
 375   }
 376 
 377   inline void neg(Register Rd, Register Rn) {
 378     sub(Rd, zr, Rn);
 379   }
 380 
 381   inline void negsw(Register Rd, Register Rn) {
 382     subsw(Rd, zr, Rn);
 383   }
 384 
 385   inline void negs(Register Rd, Register Rn) {
 386     subs(Rd, zr, Rn);
 387   }
 388 
 389   inline void cmnw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 390     addsw(zr, Rn, Rm, kind, shift);
 391   }
 392   inline void cmn(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 393     adds(zr, Rn, Rm, kind, shift);
 394   }
 395 
 396   inline void cmpw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 397     subsw(zr, Rn, Rm, kind, shift);
 398   }
 399   inline void cmp(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 400     subs(zr, Rn, Rm, kind, shift);
 401   }
 402 
 403   inline void negw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 404     subw(Rd, zr, Rn, kind, shift);
 405   }
 406 
 407   inline void neg(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 408     sub(Rd, zr, Rn, kind, shift);
 409   }
 410 
 411   inline void negsw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 412     subsw(Rd, zr, Rn, kind, shift);
 413   }
 414 
 415   inline void negs(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 416     subs(Rd, zr, Rn, kind, shift);
 417   }
 418 
 419   inline void mnegw(Register Rd, Register Rn, Register Rm) {
 420     msubw(Rd, Rn, Rm, zr);
 421   }
 422   inline void mneg(Register Rd, Register Rn, Register Rm) {
 423     msub(Rd, Rn, Rm, zr);
 424   }
 425 
 426   inline void mulw(Register Rd, Register Rn, Register Rm) {
 427     maddw(Rd, Rn, Rm, zr);
 428   }
 429   inline void mul(Register Rd, Register Rn, Register Rm) {
 430     madd(Rd, Rn, Rm, zr);
 431   }
 432 
 433   inline void smnegl(Register Rd, Register Rn, Register Rm) {
 434     smsubl(Rd, Rn, Rm, zr);
 435   }
 436   inline void smull(Register Rd, Register Rn, Register Rm) {
 437     smaddl(Rd, Rn, Rm, zr);
 438   }
 439 
 440   inline void umnegl(Register Rd, Register Rn, Register Rm) {
 441     umsubl(Rd, Rn, Rm, zr);
 442   }
 443   inline void umull(Register Rd, Register Rn, Register Rm) {
 444     umaddl(Rd, Rn, Rm, zr);
 445   }
 446 
 447 #define WRAP(INSN)                                                            \
 448   void INSN(Register Rd, Register Rn, Register Rm, Register Ra) {             \
 449     if ((VM_Version::features() &amp; VM_Version::CPU_A53MAC) &amp;&amp; Ra != zr)        \
 450       nop();                                                                  \
 451     Assembler::INSN(Rd, Rn, Rm, Ra);                                          \
 452   }
 453 
 454   WRAP(madd) WRAP(msub) WRAP(maddw) WRAP(msubw)
 455   WRAP(smaddl) WRAP(smsubl) WRAP(umaddl) WRAP(umsubl)
 456 #undef WRAP
 457 
 458 
 459   // macro assembly operations needed for aarch64
 460 
 461   // first two private routines for loading 32 bit or 64 bit constants
 462 private:
 463 
 464   void mov_immediate64(Register dst, uint64_t imm64);
 465   void mov_immediate32(Register dst, uint32_t imm32);
 466 
 467   int push(unsigned int bitset, Register stack);
 468   int pop(unsigned int bitset, Register stack);
 469 
 470   int push_fp(unsigned int bitset, Register stack);
 471   int pop_fp(unsigned int bitset, Register stack);
 472 
 473   void mov(Register dst, Address a);
 474 
 475 public:
 476   void push(RegSet regs, Register stack) { if (regs.bits()) push(regs.bits(), stack); }
 477   void pop(RegSet regs, Register stack) { if (regs.bits()) pop(regs.bits(), stack); }
 478 
 479   void push_fp(RegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }
 480   void pop_fp(RegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }
 481 
 482   // Push and pop everything that might be clobbered by a native
 483   // runtime call except rscratch1 and rscratch2.  (They are always
 484   // scratch, so we don&#39;t have to protect them.)  Only save the lower
 485   // 64 bits of each vector register.
 486   void push_call_clobbered_registers();
 487   void pop_call_clobbered_registers();
 488 
 489   // now mov instructions for loading absolute addresses and 32 or
 490   // 64 bit integers
 491 
 492   inline void mov(Register dst, address addr)
 493   {
 494     mov_immediate64(dst, (uint64_t)addr);
 495   }
 496 
 497   inline void mov(Register dst, uint64_t imm64)
 498   {
 499     mov_immediate64(dst, imm64);
 500   }
 501 
 502   inline void movw(Register dst, uint32_t imm32)
 503   {
 504     mov_immediate32(dst, imm32);
 505   }
 506 
 507   inline void mov(Register dst, long l)
 508   {
 509     mov(dst, (uint64_t)l);
 510   }
 511 
 512   inline void mov(Register dst, int i)
 513   {
 514     mov(dst, (long)i);
 515   }
 516 
 517   void mov(Register dst, RegisterOrConstant src) {
 518     if (src.is_register())
 519       mov(dst, src.as_register());
 520     else
 521       mov(dst, src.as_constant());
 522   }
 523 
 524   void movptr(Register r, uintptr_t imm64);
 525 
 526   void mov(FloatRegister Vd, SIMD_Arrangement T, uint32_t imm32);
 527 
 528   void mov(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {
 529     orr(Vd, T, Vn, Vn);
 530   }
 531 
 532 public:
 533 
 534   // Generalized Test Bit And Branch, including a &quot;far&quot; variety which
 535   // spans more than 32KiB.
 536   void tbr(Condition cond, Register Rt, int bitpos, Label &amp;dest, bool far = false) {
 537     assert(cond == EQ || cond == NE, &quot;must be&quot;);
 538 
 539     if (far)
 540       cond = ~cond;
 541 
 542     void (Assembler::* branch)(Register Rt, int bitpos, Label &amp;L);
 543     if (cond == Assembler::EQ)
 544       branch = &amp;Assembler::tbz;
 545     else
 546       branch = &amp;Assembler::tbnz;
 547 
 548     if (far) {
 549       Label L;
 550       (this-&gt;*branch)(Rt, bitpos, L);
 551       b(dest);
 552       bind(L);
 553     } else {
 554       (this-&gt;*branch)(Rt, bitpos, dest);
 555     }
 556   }
 557 
 558   // macro instructions for accessing and updating floating point
 559   // status register
 560   //
 561   // FPSR : op1 == 011
 562   //        CRn == 0100
 563   //        CRm == 0100
 564   //        op2 == 001
 565 
 566   inline void get_fpsr(Register reg)
 567   {
 568     mrs(0b11, 0b0100, 0b0100, 0b001, reg);
 569   }
 570 
 571   inline void set_fpsr(Register reg)
 572   {
 573     msr(0b011, 0b0100, 0b0100, 0b001, reg);
 574   }
 575 
 576   inline void clear_fpsr()
 577   {
 578     msr(0b011, 0b0100, 0b0100, 0b001, zr);
 579   }
 580 
 581   // DCZID_EL0: op1 == 011
 582   //            CRn == 0000
 583   //            CRm == 0000
 584   //            op2 == 111
 585   inline void get_dczid_el0(Register reg)
 586   {
 587     mrs(0b011, 0b0000, 0b0000, 0b111, reg);
 588   }
 589 
 590   // CTR_EL0:   op1 == 011
 591   //            CRn == 0000
 592   //            CRm == 0000
 593   //            op2 == 001
 594   inline void get_ctr_el0(Register reg)
 595   {
 596     mrs(0b011, 0b0000, 0b0000, 0b001, reg);
 597   }
 598 
 599   // idiv variant which deals with MINLONG as dividend and -1 as divisor
 600   int corrected_idivl(Register result, Register ra, Register rb,
 601                       bool want_remainder, Register tmp = rscratch1);
 602   int corrected_idivq(Register result, Register ra, Register rb,
 603                       bool want_remainder, Register tmp = rscratch1);
 604 
 605   // Support for NULL-checks
 606   //
 607   // Generates code that causes a NULL OS exception if the content of reg is NULL.
 608   // If the accessed location is M[reg + offset] and the offset is known, provide the
 609   // offset. No explicit code generation is needed if the offset is within a certain
 610   // range (0 &lt;= offset &lt;= page_size).
 611 
 612   virtual void null_check(Register reg, int offset = -1);
 613   static bool needs_explicit_null_check(intptr_t offset);
 614   static bool uses_implicit_null_check(void* address);
 615 
<a name="3" id="anc3"></a><span class="line-added"> 616   void test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value);</span>
<span class="line-added"> 617 </span>
<span class="line-added"> 618   void test_field_is_inline_type(Register flags, Register temp_reg, Label&amp; is_inline);</span>
<span class="line-added"> 619   void test_field_is_not_inline_type(Register flags, Register temp_reg, Label&amp; not_inline);</span>
<span class="line-added"> 620   void test_field_is_inlined(Register flags, Register temp_reg, Label&amp; is_flattened);</span>
<span class="line-added"> 621 </span>
<span class="line-added"> 622   // Check klass/oops is flat inline type array (oop-&gt;_klass-&gt;_layout_helper &amp; vt_bit)</span>
<span class="line-added"> 623   void test_flattened_array_oop(Register klass, Register temp_reg, Label&amp; is_flattened_array);</span>
<span class="line-added"> 624   void test_null_free_array_oop(Register oop, Register temp_reg, Label&amp; is_null_free_array);</span>
<span class="line-added"> 625 </span>
 626   static address target_addr_for_insn(address insn_addr, unsigned insn);
 627   static address target_addr_for_insn(address insn_addr) {
 628     unsigned insn = *(unsigned*)insn_addr;
 629     return target_addr_for_insn(insn_addr, insn);
 630   }
 631 
 632   // Required platform-specific helpers for Label::patch_instructions.
 633   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 634   static int pd_patch_instruction_size(address branch, address target);
 635   static void pd_patch_instruction(address branch, address target, const char* file = NULL, int line = 0) {
 636     pd_patch_instruction_size(branch, target);
 637   }
 638   static address pd_call_destination(address branch) {
 639     return target_addr_for_insn(branch);
 640   }
 641 #ifndef PRODUCT
 642   static void pd_print_patched_instruction(address branch);
 643 #endif
 644 
 645   static int patch_oop(address insn_addr, address o);
 646   static int patch_narrow_klass(address insn_addr, narrowKlass n);
 647 
 648   address emit_trampoline_stub(int insts_call_instruction_offset, address target);
 649   void emit_static_call_stub();
 650 
 651   // The following 4 methods return the offset of the appropriate move instruction
 652 
 653   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 654   int load_unsigned_byte(Register dst, Address src);
 655   int load_unsigned_short(Register dst, Address src);
 656 
 657   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 658   int load_signed_byte(Register dst, Address src);
 659   int load_signed_short(Register dst, Address src);
 660 
 661   int load_signed_byte32(Register dst, Address src);
 662   int load_signed_short32(Register dst, Address src);
 663 
 664   // Support for sign-extension (hi:lo = extend_sign(lo))
 665   void extend_sign(Register hi, Register lo);
 666 
 667   // Load and store values by size and signed-ness
 668   void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);
 669   void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);
 670 
 671   // Support for inc/dec with optimal instruction selection depending on value
 672 
 673   // x86_64 aliases an unqualified register/address increment and
 674   // decrement to call incrementq and decrementq but also supports
 675   // explicitly sized calls to incrementq/decrementq or
 676   // incrementl/decrementl
 677 
 678   // for aarch64 the proper convention would be to use
 679   // increment/decrement for 64 bit operatons and
 680   // incrementw/decrementw for 32 bit operations. so when porting
 681   // x86_64 code we can leave calls to increment/decrement as is,
 682   // replace incrementq/decrementq with increment/decrement and
 683   // replace incrementl/decrementl with incrementw/decrementw.
 684 
 685   // n.b. increment/decrement calls with an Address destination will
 686   // need to use a scratch register to load the value to be
 687   // incremented. increment/decrement calls which add or subtract a
 688   // constant value greater than 2^12 will need to use a 2nd scratch
 689   // register to hold the constant. so, a register increment/decrement
 690   // may trash rscratch2 and an address increment/decrement trash
 691   // rscratch and rscratch2
 692 
 693   void decrementw(Address dst, int value = 1);
 694   void decrementw(Register reg, int value = 1);
 695 
 696   void decrement(Register reg, int value = 1);
 697   void decrement(Address dst, int value = 1);
 698 
 699   void incrementw(Address dst, int value = 1);
 700   void incrementw(Register reg, int value = 1);
 701 
 702   void increment(Register reg, int value = 1);
 703   void increment(Address dst, int value = 1);
 704 
 705 
 706   // Alignment
 707   void align(int modulus);
 708 
 709   // Stack frame creation/removal
 710   void enter()
 711   {
 712     stp(rfp, lr, Address(pre(sp, -2 * wordSize)));
 713     mov(rfp, sp);
 714   }
 715   void leave()
 716   {
 717     mov(sp, rfp);
 718     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
 719   }
 720 
 721   // Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)
 722   // The pointer will be loaded into the thread register.
 723   void get_thread(Register thread);
 724 
 725 
 726   // Support for VM calls
 727   //
 728   // It is imperative that all calls into the VM are handled via the call_VM macros.
 729   // They make sure that the stack linkage is setup correctly. call_VM&#39;s correspond
 730   // to ENTRY/ENTRY_X entry points while call_VM_leaf&#39;s correspond to LEAF entry points.
 731 
 732 
 733   void call_VM(Register oop_result,
 734                address entry_point,
 735                bool check_exceptions = true);
 736   void call_VM(Register oop_result,
 737                address entry_point,
 738                Register arg_1,
 739                bool check_exceptions = true);
 740   void call_VM(Register oop_result,
 741                address entry_point,
 742                Register arg_1, Register arg_2,
 743                bool check_exceptions = true);
 744   void call_VM(Register oop_result,
 745                address entry_point,
 746                Register arg_1, Register arg_2, Register arg_3,
 747                bool check_exceptions = true);
 748 
 749   // Overloadings with last_Java_sp
 750   void call_VM(Register oop_result,
 751                Register last_java_sp,
 752                address entry_point,
 753                int number_of_arguments = 0,
 754                bool check_exceptions = true);
 755   void call_VM(Register oop_result,
 756                Register last_java_sp,
 757                address entry_point,
 758                Register arg_1, bool
 759                check_exceptions = true);
 760   void call_VM(Register oop_result,
 761                Register last_java_sp,
 762                address entry_point,
 763                Register arg_1, Register arg_2,
 764                bool check_exceptions = true);
 765   void call_VM(Register oop_result,
 766                Register last_java_sp,
 767                address entry_point,
 768                Register arg_1, Register arg_2, Register arg_3,
 769                bool check_exceptions = true);
 770 
 771   void get_vm_result  (Register oop_result, Register thread);
 772   void get_vm_result_2(Register metadata_result, Register thread);
 773 
 774   // These always tightly bind to MacroAssembler::call_VM_base
 775   // bypassing the virtual implementation
 776   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments = 0, bool check_exceptions = true);
 777   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true);
 778   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
 779   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
 780   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4, bool check_exceptions = true);
 781 
 782   void call_VM_leaf(address entry_point,
 783                     int number_of_arguments = 0);
 784   void call_VM_leaf(address entry_point,
 785                     Register arg_1);
 786   void call_VM_leaf(address entry_point,
 787                     Register arg_1, Register arg_2);
 788   void call_VM_leaf(address entry_point,
 789                     Register arg_1, Register arg_2, Register arg_3);
 790 
 791   // These always tightly bind to MacroAssembler::call_VM_leaf_base
 792   // bypassing the virtual implementation
 793   void super_call_VM_leaf(address entry_point);
 794   void super_call_VM_leaf(address entry_point, Register arg_1);
 795   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
 796   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3);
 797   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4);
 798 
 799   // last Java Frame (fills frame anchor)
 800   void set_last_Java_frame(Register last_java_sp,
 801                            Register last_java_fp,
 802                            address last_java_pc,
 803                            Register scratch);
 804 
 805   void set_last_Java_frame(Register last_java_sp,
 806                            Register last_java_fp,
 807                            Label &amp;last_java_pc,
 808                            Register scratch);
 809 
 810   void set_last_Java_frame(Register last_java_sp,
 811                            Register last_java_fp,
 812                            Register last_java_pc,
 813                            Register scratch);
 814 
 815   void reset_last_Java_frame(Register thread);
 816 
 817   // thread in the default location (rthread)
 818   void reset_last_Java_frame(bool clear_fp);
 819 
 820   // Stores
 821   void store_check(Register obj);                // store check for obj - register is destroyed afterwards
 822   void store_check(Register obj, Address dst);   // same as above, dst is exact store location (reg. is destroyed)
 823 
 824   void resolve_jobject(Register value, Register thread, Register tmp);
 825 
 826   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 827   void c2bool(Register x);
 828 
 829   void load_method_holder_cld(Register rresult, Register rmethod);
 830   void load_method_holder(Register holder, Register method);
 831 
 832   // oop manipulations
<a name="4" id="anc4"></a><span class="line-added"> 833   void load_metadata(Register dst, Register src);</span>
<span class="line-added"> 834   void load_storage_props(Register dst, Register src);</span>
<span class="line-added"> 835 </span>
 836   void load_klass(Register dst, Register src);
 837   void store_klass(Register dst, Register src);
 838   void cmp_klass(Register oop, Register trial_klass, Register tmp);
 839 
 840   void resolve_weak_handle(Register result, Register tmp);
 841   void resolve_oop_handle(Register result, Register tmp = r5);
 842   void load_mirror(Register dst, Register method, Register tmp = r5);
 843 
 844   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 845                       Register tmp1, Register tmp_thread);
 846 
 847   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
<a name="5" id="anc5"></a><span class="line-modified"> 848                        Register tmp1, Register tmp_thread, Register tmp3 = noreg);</span>
 849 
 850   // Resolves obj for access. Result is placed in the same register.
 851   // All other registers are preserved.
 852   void resolve(DecoratorSet decorators, Register obj);
 853 
 854   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 855                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 856 
 857   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 858                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 859   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
<a name="6" id="anc6"></a><span class="line-modified"> 860                       Register tmp_thread = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);</span>
 861 
 862   // currently unimplemented
 863   // Used for storing NULL. All other oop constants should be
 864   // stored using routines that take a jobject.
 865   void store_heap_oop_null(Address dst);
 866 
 867   void load_prototype_header(Register dst, Register src);
 868 
 869   void store_klass_gap(Register dst, Register src);
 870 
 871   // This dummy is to prevent a call to store_heap_oop from
 872   // converting a zero (like NULL) into a Register by giving
 873   // the compiler two choices it can&#39;t resolve
 874 
 875   void store_heap_oop(Address dst, void* dummy);
 876 
 877   void encode_heap_oop(Register d, Register s);
 878   void encode_heap_oop(Register r) { encode_heap_oop(r, r); }
 879   void decode_heap_oop(Register d, Register s);
 880   void decode_heap_oop(Register r) { decode_heap_oop(r, r); }
 881   void encode_heap_oop_not_null(Register r);
 882   void decode_heap_oop_not_null(Register r);
 883   void encode_heap_oop_not_null(Register dst, Register src);
 884   void decode_heap_oop_not_null(Register dst, Register src);
 885 
 886   void set_narrow_oop(Register dst, jobject obj);
 887 
 888   void encode_klass_not_null(Register r);
 889   void decode_klass_not_null(Register r);
 890   void encode_klass_not_null(Register dst, Register src);
 891   void decode_klass_not_null(Register dst, Register src);
 892 
 893   void set_narrow_klass(Register dst, Klass* k);
 894 
 895   // if heap base register is used - reinit it with the correct value
 896   void reinit_heapbase();
 897 
 898   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 899 
 900   void push_CPU_state(bool save_vectors = false);
 901   void pop_CPU_state(bool restore_vectors = false) ;
 902 
 903   // Round up to a power of two
 904   void round_to(Register reg, int modulus);
 905 
 906   // allocation
 907   void eden_allocate(
 908     Register obj,                      // result: pointer to object after successful allocation
 909     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 910     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 911     Register t1,                       // temp register
 912     Label&amp;   slow_case                 // continuation point if fast allocation fails
 913   );
 914   void tlab_allocate(
 915     Register obj,                      // result: pointer to object after successful allocation
 916     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 917     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 918     Register t1,                       // temp register
 919     Register t2,                       // temp register
 920     Label&amp;   slow_case                 // continuation point if fast allocation fails
 921   );
 922   void zero_memory(Register addr, Register len, Register t1);
 923   void verify_tlab();
 924 
 925   // interface method calling
 926   void lookup_interface_method(Register recv_klass,
 927                                Register intf_klass,
 928                                RegisterOrConstant itable_index,
 929                                Register method_result,
 930                                Register scan_temp,
 931                                Label&amp; no_such_interface,
 932                    bool return_method = true);
 933 
 934   // virtual method calling
 935   // n.b. x86 allows RegisterOrConstant for vtable_index
 936   void lookup_virtual_method(Register recv_klass,
 937                              RegisterOrConstant vtable_index,
 938                              Register method_result);
 939 
 940   // Test sub_klass against super_klass, with fast and slow paths.
 941 
 942   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 943   // One of the three labels can be NULL, meaning take the fall-through.
 944   // If super_check_offset is -1, the value is loaded up from super_klass.
 945   // No registers are killed, except temp_reg.
 946   void check_klass_subtype_fast_path(Register sub_klass,
 947                                      Register super_klass,
 948                                      Register temp_reg,
 949                                      Label* L_success,
 950                                      Label* L_failure,
 951                                      Label* L_slow_path,
 952                 RegisterOrConstant super_check_offset = RegisterOrConstant(-1));
 953 
 954   // The rest of the type check; must be wired to a corresponding fast path.
 955   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 956   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 957   // Updates the sub&#39;s secondary super cache as necessary.
 958   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 959   void check_klass_subtype_slow_path(Register sub_klass,
 960                                      Register super_klass,
 961                                      Register temp_reg,
 962                                      Register temp2_reg,
 963                                      Label* L_success,
 964                                      Label* L_failure,
 965                                      bool set_cond_codes = false);
 966 
 967   // Simplified, combined version, good for typical uses.
 968   // Falls through on failure.
 969   void check_klass_subtype(Register sub_klass,
 970                            Register super_klass,
 971                            Register temp_reg,
 972                            Label&amp; L_success);
 973 
 974   void clinit_barrier(Register klass,
 975                       Register thread,
 976                       Label* L_fast_path = NULL,
 977                       Label* L_slow_path = NULL);
 978 
 979   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 980 
 981 
 982   // Debugging
 983 
 984   // only if +VerifyOops
 985   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
 986   void verify_oop_addr(Address addr, const char * s = &quot;broken oop addr&quot;);
 987 
 988 // TODO: verify method and klass metadata (compare against vptr?)
 989   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 990   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 991 
 992 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 993 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 994 
 995   // only if +VerifyFPU
 996   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 997 
 998   // prints msg, dumps registers and stops execution
 999   void stop(const char* msg);
1000 
1001   static void debug64(char* msg, int64_t pc, int64_t regs[]);
1002 
1003   void untested()                                { stop(&quot;untested&quot;); }
1004 
1005   void unimplemented(const char* what = &quot;&quot;);
1006 
1007   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
1008 
1009   // Stack overflow checking
1010   void bang_stack_with_offset(int offset) {
1011     // stack grows down, caller passes positive offset
1012     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
1013     sub(rscratch2, sp, offset);
1014     str(zr, Address(rscratch2));
1015   }
1016 
1017   // Writes to stack successive pages until offset reached to check for
1018   // stack overflow + shadow pages.  Also, clobbers tmp
1019   void bang_stack_size(Register size, Register tmp);
1020 
1021   // Check for reserved stack access in method being exited (for JIT)
1022   void reserved_stack_check();
1023 
1024   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
1025                                                 Register tmp,
1026                                                 int offset);
1027 
1028   // Arithmetics
1029 
1030   void addptr(const Address &amp;dst, int32_t src);
1031   void cmpptr(Register src1, Address src2);
1032 
1033   void cmpoop(Register obj1, Register obj2);
1034 
1035   // Various forms of CAS
1036 
1037   void cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,
1038                           Label &amp;suceed, Label *fail);
1039   void cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,
1040                   Label &amp;suceed, Label *fail);
1041 
1042   void cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,
1043                   Label &amp;suceed, Label *fail);
1044 
1045   void atomic_add(Register prev, RegisterOrConstant incr, Register addr);
1046   void atomic_addw(Register prev, RegisterOrConstant incr, Register addr);
1047   void atomic_addal(Register prev, RegisterOrConstant incr, Register addr);
1048   void atomic_addalw(Register prev, RegisterOrConstant incr, Register addr);
1049 
1050   void atomic_xchg(Register prev, Register newv, Register addr);
1051   void atomic_xchgw(Register prev, Register newv, Register addr);
1052   void atomic_xchgal(Register prev, Register newv, Register addr);
1053   void atomic_xchgalw(Register prev, Register newv, Register addr);
1054 
1055   void orptr(Address adr, RegisterOrConstant src) {
1056     ldr(rscratch1, adr);
1057     if (src.is_register())
1058       orr(rscratch1, rscratch1, src.as_register());
1059     else
1060       orr(rscratch1, rscratch1, src.as_constant());
1061     str(rscratch1, adr);
1062   }
1063 
1064   // A generic CAS; success or failure is in the EQ flag.
1065   // Clobbers rscratch1
1066   void cmpxchg(Register addr, Register expected, Register new_val,
1067                enum operand_size size,
1068                bool acquire, bool release, bool weak,
1069                Register result);
1070 private:
1071   void compare_eq(Register rn, Register rm, enum operand_size size);
1072 
1073 public:
1074   // Calls
1075 
1076   address trampoline_call(Address entry, CodeBuffer *cbuf = NULL);
1077 
1078   static bool far_branches() {
1079     return ReservedCodeCacheSize &gt; branch_range || UseAOT;
1080   }
1081 
1082   // Jumps that can reach anywhere in the code cache.
1083   // Trashes tmp.
1084   void far_call(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);
1085   void far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);
1086 
1087   static int far_branch_size() {
1088     if (far_branches()) {
1089       return 3 * 4;  // adrp, add, br
1090     } else {
1091       return 4;
1092     }
1093   }
1094 
1095   // Emit the CompiledIC call idiom
1096   address ic_call(address entry, jint method_index = 0);
1097 
1098 public:
1099 
1100   // Data
1101 
1102   void mov_metadata(Register dst, Metadata* obj);
1103   Address allocate_metadata_address(Metadata* obj);
1104   Address constant_oop_address(jobject obj);
1105 
1106   void movoop(Register dst, jobject obj, bool immediate = false);
1107 
1108   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1109   void kernel_crc32(Register crc, Register buf, Register len,
1110         Register table0, Register table1, Register table2, Register table3,
1111         Register tmp, Register tmp2, Register tmp3);
1112   // CRC32 code for java.util.zip.CRC32C::updateBytes() instrinsic.
1113   void kernel_crc32c(Register crc, Register buf, Register len,
1114         Register table0, Register table1, Register table2, Register table3,
1115         Register tmp, Register tmp2, Register tmp3);
1116 
1117   // Stack push and pop individual 64 bit registers
1118   void push(Register src);
1119   void pop(Register dst);
1120 
1121   // push all registers onto the stack
1122   void pusha();
1123   void popa();
1124 
1125   void repne_scan(Register addr, Register value, Register count,
1126                   Register scratch);
1127   void repne_scanw(Register addr, Register value, Register count,
1128                    Register scratch);
1129 
1130   typedef void (MacroAssembler::* add_sub_imm_insn)(Register Rd, Register Rn, unsigned imm);
1131   typedef void (MacroAssembler::* add_sub_reg_insn)(Register Rd, Register Rn, Register Rm, enum shift_kind kind, unsigned shift);
1132 
1133   // If a constant does not fit in an immediate field, generate some
1134   // number of MOV instructions and then perform the operation
1135   void wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
1136                              add_sub_imm_insn insn1,
1137                              add_sub_reg_insn insn2);
1138   // Seperate vsn which sets the flags
1139   void wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,
1140                              add_sub_imm_insn insn1,
1141                              add_sub_reg_insn insn2);
1142 
1143 #define WRAP(INSN)                                                      \
1144   void INSN(Register Rd, Register Rn, unsigned imm) {                   \
1145     wrap_add_sub_imm_insn(Rd, Rn, imm, &amp;Assembler::INSN, &amp;Assembler::INSN); \
1146   }                                                                     \
1147                                                                         \
1148   void INSN(Register Rd, Register Rn, Register Rm,                      \
1149              enum shift_kind kind, unsigned shift = 0) {                \
1150     Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \
1151   }                                                                     \
1152                                                                         \
1153   void INSN(Register Rd, Register Rn, Register Rm) {                    \
1154     Assembler::INSN(Rd, Rn, Rm);                                        \
1155   }                                                                     \
1156                                                                         \
1157   void INSN(Register Rd, Register Rn, Register Rm,                      \
1158            ext::operation option, int amount = 0) {                     \
1159     Assembler::INSN(Rd, Rn, Rm, option, amount);                        \
1160   }
1161 
1162   WRAP(add) WRAP(addw) WRAP(sub) WRAP(subw)
1163 
1164 #undef WRAP
1165 #define WRAP(INSN)                                                      \
1166   void INSN(Register Rd, Register Rn, unsigned imm) {                   \
1167     wrap_adds_subs_imm_insn(Rd, Rn, imm, &amp;Assembler::INSN, &amp;Assembler::INSN); \
1168   }                                                                     \
1169                                                                         \
1170   void INSN(Register Rd, Register Rn, Register Rm,                      \
1171              enum shift_kind kind, unsigned shift = 0) {                \
1172     Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \
1173   }                                                                     \
1174                                                                         \
1175   void INSN(Register Rd, Register Rn, Register Rm) {                    \
1176     Assembler::INSN(Rd, Rn, Rm);                                        \
1177   }                                                                     \
1178                                                                         \
1179   void INSN(Register Rd, Register Rn, Register Rm,                      \
1180            ext::operation option, int amount = 0) {                     \
1181     Assembler::INSN(Rd, Rn, Rm, option, amount);                        \
1182   }
1183 
1184   WRAP(adds) WRAP(addsw) WRAP(subs) WRAP(subsw)
1185 
1186   void add(Register Rd, Register Rn, RegisterOrConstant increment);
1187   void addw(Register Rd, Register Rn, RegisterOrConstant increment);
1188   void sub(Register Rd, Register Rn, RegisterOrConstant decrement);
1189   void subw(Register Rd, Register Rn, RegisterOrConstant decrement);
1190 
1191   void adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset);
1192 
<a name="7" id="anc7"></a><span class="line-added">1193 </span>
<span class="line-added">1194   enum RegState {</span>
<span class="line-added">1195      reg_readonly,</span>
<span class="line-added">1196      reg_writable,</span>
<span class="line-added">1197      reg_written</span>
<span class="line-added">1198   };</span>
<span class="line-added">1199 </span>
<span class="line-added">1200   void verified_entry(Compile* C, int sp_inc);</span>
<span class="line-added">1201 </span>
<span class="line-added">1202   int store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter = true);</span>
<span class="line-added">1203 </span>
<span class="line-added">1204 // Unpack all inline type arguments passed as oops</span>
<span class="line-added">1205   void unpack_inline_args(Compile* C, bool receiver_only);</span>
<span class="line-added">1206   bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset);</span>
<span class="line-added">1207   bool unpack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to, int&amp; to_index,</span>
<span class="line-added">1208                             RegState reg_state[], int ret_off, int extra_stack_offset);</span>
<span class="line-added">1209   bool pack_inline_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,</span>
<span class="line-added">1210                           VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],</span>
<span class="line-added">1211                           int ret_off, int extra_stack_offset);</span>
<span class="line-added">1212   void restore_stack(Compile* C);</span>
<span class="line-added">1213 </span>
<span class="line-added">1214   int shuffle_inline_args(bool is_packing, bool receiver_only, int extra_stack_offset,</span>
<span class="line-added">1215                           BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-added">1216                           int args_passed, int args_on_stack, VMRegPair* regs,</span>
<span class="line-added">1217                           int args_passed_to, int args_on_stack_to, VMRegPair* regs_to);</span>
<span class="line-added">1218   bool shuffle_inline_args_spill(bool is_packing,  const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,</span>
<span class="line-added">1219                                  VMRegPair* regs_from, int from_index, int regs_from_count,</span>
<span class="line-added">1220                                  RegState* reg_state, int sp_inc, int extra_stack_offset);</span>
<span class="line-added">1221   VMReg spill_reg_for(VMReg reg);</span>
<span class="line-added">1222 </span>
<span class="line-added">1223 </span>
1224   void tableswitch(Register index, jint lowbound, jint highbound,
1225                    Label &amp;jumptable, Label &amp;jumptable_end, int stride = 1) {
1226     adr(rscratch1, jumptable);
1227     subsw(rscratch2, index, lowbound);
1228     subsw(zr, rscratch2, highbound - lowbound);
1229     br(Assembler::HS, jumptable_end);
1230     add(rscratch1, rscratch1, rscratch2,
1231         ext::sxtw, exact_log2(stride * Assembler::instruction_size));
1232     br(rscratch1);
1233   }
1234 
1235   // Form an address from base + offset in Rd.  Rd may or may not
1236   // actually be used: you must use the Address that is returned.  It
1237   // is up to you to ensure that the shift provided matches the size
1238   // of your data.
1239   Address form_address(Register Rd, Register base, long byte_offset, int shift);
1240 
1241   // Return true iff an address is within the 48-bit AArch64 address
1242   // space.
1243   bool is_valid_AArch64_address(address a) {
1244     return ((uint64_t)a &gt;&gt; 48) == 0;
1245   }
1246 
1247   // Load the base of the cardtable byte map into reg.
1248   void load_byte_map_base(Register reg);
1249 
1250   // Prolog generator routines to support switch between x86 code and
1251   // generated ARM code
1252 
1253   // routine to generate an x86 prolog for a stub function which
1254   // bootstraps into the generated ARM code which directly follows the
1255   // stub
1256   //
1257 
1258   public:
1259 
1260   void ldr_constant(Register dest, const Address &amp;const_addr) {
1261     if (NearCpool) {
1262       ldr(dest, const_addr);
1263     } else {
1264       unsigned long offset;
1265       adrp(dest, InternalAddress(const_addr.target()), offset);
1266       ldr(dest, Address(dest, offset));
1267     }
1268   }
1269 
1270   address read_polling_page(Register r, relocInfo::relocType rtype);
1271   void get_polling_page(Register dest, relocInfo::relocType rtype);
1272   address fetch_and_read_polling_page(Register r, relocInfo::relocType rtype);
1273 
1274   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1275   void update_byte_crc32(Register crc, Register val, Register table);
1276   void update_word_crc32(Register crc, Register v, Register tmp,
1277         Register table0, Register table1, Register table2, Register table3,
1278         bool upper = false);
1279 
1280   void has_negatives(Register ary1, Register len, Register result);
1281 
1282   void arrays_equals(Register a1, Register a2, Register result, Register cnt1,
1283                      Register tmp1, Register tmp2, Register tmp3, int elem_size);
1284 
1285   void string_equals(Register a1, Register a2, Register result, Register cnt1,
1286                      int elem_size);
1287 
1288   void fill_words(Register base, Register cnt, Register value);
<a name="8" id="anc8"></a><span class="line-added">1289   void fill_words(Register base, uint64_t cnt, Register value);</span>
<span class="line-added">1290 </span>
1291   void zero_words(Register base, uint64_t cnt);
1292   void zero_words(Register ptr, Register cnt);
1293   void zero_dcache_blocks(Register base, Register cnt);
1294 
1295   static const int zero_words_block_size;
1296 
1297   void byte_array_inflate(Register src, Register dst, Register len,
1298                           FloatRegister vtmp1, FloatRegister vtmp2,
1299                           FloatRegister vtmp3, Register tmp4);
1300 
1301   void char_array_compress(Register src, Register dst, Register len,
1302                            FloatRegister tmp1Reg, FloatRegister tmp2Reg,
1303                            FloatRegister tmp3Reg, FloatRegister tmp4Reg,
1304                            Register result);
1305 
1306   void encode_iso_array(Register src, Register dst,
1307                         Register len, Register result,
1308                         FloatRegister Vtmp1, FloatRegister Vtmp2,
1309                         FloatRegister Vtmp3, FloatRegister Vtmp4);
1310   void fast_log(FloatRegister vtmp0, FloatRegister vtmp1, FloatRegister vtmp2,
1311                 FloatRegister vtmp3, FloatRegister vtmp4, FloatRegister vtmp5,
1312                 FloatRegister tmpC1, FloatRegister tmpC2, FloatRegister tmpC3,
1313                 FloatRegister tmpC4, Register tmp1, Register tmp2,
1314                 Register tmp3, Register tmp4, Register tmp5);
1315   void generate_dsin_dcos(bool isCos, address npio2_hw, address two_over_pi,
1316       address pio2, address dsin_coef, address dcos_coef);
1317  private:
1318   // begin trigonometric functions support block
1319   void generate__ieee754_rem_pio2(address npio2_hw, address two_over_pi, address pio2);
1320   void generate__kernel_rem_pio2(address two_over_pi, address pio2);
1321   void generate_kernel_sin(FloatRegister x, bool iyIsOne, address dsin_coef);
1322   void generate_kernel_cos(FloatRegister x, address dcos_coef);
1323   // end trigonometric functions support block
1324   void add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,
1325                        Register src1, Register src2);
1326   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
1327     add2_with_carry(dest_hi, dest_hi, dest_lo, src1, src2);
1328   }
1329   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1330                              Register y, Register y_idx, Register z,
1331                              Register carry, Register product,
1332                              Register idx, Register kdx);
1333   void multiply_128_x_128_loop(Register y, Register z,
1334                                Register carry, Register carry2,
1335                                Register idx, Register jdx,
1336                                Register yz_idx1, Register yz_idx2,
1337                                Register tmp, Register tmp3, Register tmp4,
1338                                Register tmp7, Register product_hi);
1339   void kernel_crc32_using_crc32(Register crc, Register buf,
1340         Register len, Register tmp0, Register tmp1, Register tmp2,
1341         Register tmp3);
1342   void kernel_crc32c_using_crc32c(Register crc, Register buf,
1343         Register len, Register tmp0, Register tmp1, Register tmp2,
1344         Register tmp3);
1345 public:
1346   void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z,
1347                        Register zlen, Register tmp1, Register tmp2, Register tmp3,
1348                        Register tmp4, Register tmp5, Register tmp6, Register tmp7);
1349   void mul_add(Register out, Register in, Register offs, Register len, Register k);
1350   // ISB may be needed because of a safepoint
1351   void maybe_isb() { isb(); }
1352 
1353 private:
1354   // Return the effective address r + (r1 &lt;&lt; ext) + offset.
1355   // Uses rscratch2.
1356   Address offsetted_address(Register r, Register r1, Address::extend ext,
1357                             int offset, int size);
1358 
1359 private:
1360   // Returns an address on the stack which is reachable with a ldr/str of size
1361   // Uses rscratch2 if the address is not directly reachable
1362   Address spill_address(int size, int offset, Register tmp=rscratch2);
1363 
1364   bool merge_alignment_check(Register base, size_t size, long cur_offset, long prev_offset) const;
1365 
1366   // Check whether two loads/stores can be merged into ldp/stp.
1367   bool ldst_can_merge(Register rx, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store) const;
1368 
1369   // Merge current load/store with previous load/store into ldp/stp.
1370   void merge_ldst(Register rx, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store);
1371 
1372   // Try to merge two loads/stores into ldp/stp. If success, returns true else false.
1373   bool try_merge_ldst(Register rt, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store);
1374 
1375 public:
1376   void spill(Register Rx, bool is64, int offset) {
1377     if (is64) {
1378       str(Rx, spill_address(8, offset));
1379     } else {
1380       strw(Rx, spill_address(4, offset));
1381     }
1382   }
1383   void spill(FloatRegister Vx, SIMD_RegVariant T, int offset) {
1384     str(Vx, T, spill_address(1 &lt;&lt; (int)T, offset));
1385   }
1386   void unspill(Register Rx, bool is64, int offset) {
1387     if (is64) {
1388       ldr(Rx, spill_address(8, offset));
1389     } else {
1390       ldrw(Rx, spill_address(4, offset));
1391     }
1392   }
1393   void unspill(FloatRegister Vx, SIMD_RegVariant T, int offset) {
1394     ldr(Vx, T, spill_address(1 &lt;&lt; (int)T, offset));
1395   }
1396   void spill_copy128(int src_offset, int dst_offset,
1397                      Register tmp1=rscratch1, Register tmp2=rscratch2) {
1398     if (src_offset &lt; 512 &amp;&amp; (src_offset &amp; 7) == 0 &amp;&amp;
1399         dst_offset &lt; 512 &amp;&amp; (dst_offset &amp; 7) == 0) {
1400       ldp(tmp1, tmp2, Address(sp, src_offset));
1401       stp(tmp1, tmp2, Address(sp, dst_offset));
1402     } else {
1403       unspill(tmp1, true, src_offset);
1404       spill(tmp1, true, dst_offset);
1405       unspill(tmp1, true, src_offset+8);
1406       spill(tmp1, true, dst_offset+8);
1407     }
1408   }
1409 
1410   void cache_wb(Address line);
1411   void cache_wbsync(bool is_pre);
<a name="9" id="anc9"></a><span class="line-added">1412 </span>
<span class="line-added">1413   #include &quot;asm/macroAssembler_common.hpp&quot;</span>
<span class="line-added">1414 </span>
1415 };
1416 
1417 #ifdef ASSERT
1418 inline bool AbstractAssembler::pd_check_instruction_mark() { return false; }
1419 #endif
1420 
1421 /**
1422  * class SkipIfEqual:
1423  *
1424  * Instantiating this class will result in assembly code being output that will
1425  * jump around any code emitted between the creation of the instance and it&#39;s
1426  * automatic destruction at the end of a scope block, depending on the value of
1427  * the flag passed to the constructor, which will be checked at run-time.
1428  */
1429 class SkipIfEqual {
1430  private:
1431   MacroAssembler* _masm;
1432   Label _label;
1433 
1434  public:
1435    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1436    ~SkipIfEqual();
1437 };
1438 
1439 struct tableswitch {
1440   Register _reg;
1441   int _insn_index; jint _first_key; jint _last_key;
1442   Label _after;
1443   Label _branches;
1444 };
1445 
1446 #endif // CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>