<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/stringopts.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;opto/addnode.hpp&quot;
  29 #include &quot;opto/callGenerator.hpp&quot;
  30 #include &quot;opto/callnode.hpp&quot;
  31 #include &quot;opto/divnode.hpp&quot;
  32 #include &quot;opto/graphKit.hpp&quot;
  33 #include &quot;opto/idealKit.hpp&quot;
  34 #include &quot;opto/rootnode.hpp&quot;
  35 #include &quot;opto/runtime.hpp&quot;
  36 #include &quot;opto/stringopts.hpp&quot;
  37 #include &quot;opto/subnode.hpp&quot;
  38 #include &quot;runtime/sharedRuntime.hpp&quot;
  39 
  40 #define __ kit.
  41 
  42 class StringConcat : public ResourceObj {
  43  private:
  44   PhaseStringOpts*    _stringopts;
  45   Node*               _string_alloc;
  46   AllocateNode*       _begin;          // The allocation the begins the pattern
  47   CallStaticJavaNode* _end;            // The final call of the pattern.  Will either be
  48                                        // SB.toString or or String.&lt;init&gt;(SB.toString)
  49   bool                _multiple;       // indicates this is a fusion of two or more
  50                                        // separate StringBuilders
  51 
  52   Node*               _arguments;      // The list of arguments to be concatenated
  53   GrowableArray&lt;int&gt;  _mode;           // into a String along with a mode flag
  54                                        // indicating how to treat the value.
  55   Node_List           _constructors;   // List of constructors (many in case of stacked concat)
  56   Node_List           _control;        // List of control nodes that will be deleted
  57   Node_List           _uncommon_traps; // Uncommon traps that needs to be rewritten
  58                                        // to restart at the initial JVMState.
  59 
  60  public:
  61   // Mode for converting arguments to Strings
  62   enum {
  63     StringMode,
  64     IntMode,
  65     CharMode,
  66     StringNullCheckMode
  67   };
  68 
  69   StringConcat(PhaseStringOpts* stringopts, CallStaticJavaNode* end):
  70     _stringopts(stringopts),
  71     _string_alloc(NULL),
  72     _begin(NULL),
  73     _end(end),
  74     _multiple(false) {
  75     _arguments = new Node(1);
  76     _arguments-&gt;del_req(0);
  77   }
  78 
  79   bool validate_mem_flow();
  80   bool validate_control_flow();
  81 
  82   void merge_add() {
  83 #if 0
  84     // XXX This is place holder code for reusing an existing String
  85     // allocation but the logic for checking the state safety is
  86     // probably inadequate at the moment.
  87     CallProjections endprojs;
  88     sc-&gt;end()-&gt;extract_projections(&amp;endprojs, false);
  89     if (endprojs.resproj != NULL) {
  90       for (SimpleDUIterator i(endprojs.resproj); i.has_next(); i.next()) {
  91         CallStaticJavaNode *use = i.get()-&gt;isa_CallStaticJava();
  92         if (use != NULL &amp;&amp; use-&gt;method() != NULL &amp;&amp;
  93             use-&gt;method()-&gt;intrinsic_id() == vmIntrinsics::_String_String &amp;&amp;
  94             use-&gt;in(TypeFunc::Parms + 1) == endprojs.resproj) {
  95           // Found useless new String(sb.toString()) so reuse the newly allocated String
  96           // when creating the result instead of allocating a new one.
  97           sc-&gt;set_string_alloc(use-&gt;in(TypeFunc::Parms));
  98           sc-&gt;set_end(use);
  99         }
 100       }
 101     }
 102 #endif
 103   }
 104 
 105   StringConcat* merge(StringConcat* other, Node* arg);
 106 
 107   void set_allocation(AllocateNode* alloc) {
 108     _begin = alloc;
 109   }
 110 
 111   void append(Node* value, int mode) {
 112     _arguments-&gt;add_req(value);
 113     _mode.append(mode);
 114   }
 115   void push(Node* value, int mode) {
 116     _arguments-&gt;ins_req(0, value);
 117     _mode.insert_before(0, mode);
 118   }
 119 
 120   void push_string(Node* value) {
 121     push(value, StringMode);
 122   }
 123   void push_string_null_check(Node* value) {
 124     push(value, StringNullCheckMode);
 125   }
 126   void push_int(Node* value) {
 127     push(value, IntMode);
 128   }
 129   void push_char(Node* value) {
 130     push(value, CharMode);
 131   }
 132 
 133   static bool is_SB_toString(Node* call) {
 134     if (call-&gt;is_CallStaticJava()) {
 135       CallStaticJavaNode* csj = call-&gt;as_CallStaticJava();
 136       ciMethod* m = csj-&gt;method();
 137       if (m != NULL &amp;&amp;
 138           (m-&gt;intrinsic_id() == vmIntrinsics::_StringBuilder_toString ||
 139            m-&gt;intrinsic_id() == vmIntrinsics::_StringBuffer_toString)) {
 140         return true;
 141       }
 142     }
 143     return false;
 144   }
 145 
 146   static Node* skip_string_null_check(Node* value) {
 147     // Look for a diamond shaped Null check of toString() result
 148     // (could be code from String.valueOf()):
 149     // (Proj == NULL) ? &quot;null&quot;:&quot;CastPP(Proj)#NotNULL
 150     if (value-&gt;is_Phi()) {
 151       int true_path = value-&gt;as_Phi()-&gt;is_diamond_phi();
 152       if (true_path != 0) {
 153         // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool
 154         BoolNode* b = value-&gt;in(0)-&gt;in(1)-&gt;in(0)-&gt;in(1)-&gt;as_Bool();
 155         Node* cmp = b-&gt;in(1);
 156         Node* v1 = cmp-&gt;in(1);
 157         Node* v2 = cmp-&gt;in(2);
 158         // Null check of the return of toString which can simply be skipped.
 159         if (b-&gt;_test._test == BoolTest::ne &amp;&amp;
 160             v2-&gt;bottom_type() == TypePtr::NULL_PTR &amp;&amp;
 161             value-&gt;in(true_path)-&gt;Opcode() == Op_CastPP &amp;&amp;
 162             value-&gt;in(true_path)-&gt;in(1) == v1 &amp;&amp;
 163             v1-&gt;is_Proj() &amp;&amp; is_SB_toString(v1-&gt;in(0))) {
 164           return v1;
 165         }
 166       }
 167     }
 168     return value;
 169   }
 170 
 171   Node* argument(int i) {
 172     return _arguments-&gt;in(i);
 173   }
 174   Node* argument_uncast(int i) {
 175     Node* arg = argument(i);
 176     int amode = mode(i);
 177     if (amode == StringConcat::StringMode ||
 178         amode == StringConcat::StringNullCheckMode) {
 179       arg = skip_string_null_check(arg);
 180     }
 181     return arg;
 182   }
 183   void set_argument(int i, Node* value) {
 184     _arguments-&gt;set_req(i, value);
 185   }
 186   int num_arguments() {
 187     return _mode.length();
 188   }
 189   int mode(int i) {
 190     return _mode.at(i);
 191   }
 192   void add_control(Node* ctrl) {
 193     assert(!_control.contains(ctrl), &quot;only push once&quot;);
 194     _control.push(ctrl);
 195   }
 196   void add_constructor(Node* init) {
 197     assert(!_constructors.contains(init), &quot;only push once&quot;);
 198     _constructors.push(init);
 199   }
 200   CallStaticJavaNode* end() { return _end; }
 201   AllocateNode* begin() { return _begin; }
 202   Node* string_alloc() { return _string_alloc; }
 203 
 204   void eliminate_unneeded_control();
 205   void eliminate_initialize(InitializeNode* init);
 206   void eliminate_call(CallNode* call);
 207 
 208   void maybe_log_transform() {
 209     CompileLog* log = _stringopts-&gt;C-&gt;log();
 210     if (log != NULL) {
 211       log-&gt;head(&quot;replace_string_concat arguments=&#39;%d&#39; string_alloc=&#39;%d&#39; multiple=&#39;%d&#39;&quot;,
 212                 num_arguments(),
 213                 _string_alloc != NULL,
 214                 _multiple);
 215       JVMState* p = _begin-&gt;jvms();
 216       while (p != NULL) {
 217         log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
 218         p = p-&gt;caller();
 219       }
 220       log-&gt;tail(&quot;replace_string_concat&quot;);
 221     }
 222   }
 223 
 224   void convert_uncommon_traps(GraphKit&amp; kit, const JVMState* jvms) {
 225     for (uint u = 0; u &lt; _uncommon_traps.size(); u++) {
 226       Node* uct = _uncommon_traps.at(u);
 227 
 228       // Build a new call using the jvms state of the allocate
 229       address call_addr = SharedRuntime::uncommon_trap_blob()-&gt;entry_point();
 230       const TypeFunc* call_type = OptoRuntime::uncommon_trap_Type();
 231       const TypePtr* no_memory_effects = NULL;
 232       Compile* C = _stringopts-&gt;C;
 233       CallStaticJavaNode* call = new CallStaticJavaNode(call_type, call_addr, &quot;uncommon_trap&quot;,
 234                                                         jvms-&gt;bci(), no_memory_effects);
 235       for (int e = 0; e &lt; TypeFunc::Parms; e++) {
 236         call-&gt;init_req(e, uct-&gt;in(e));
 237       }
 238       // Set the trap request to record intrinsic failure if this trap
 239       // is taken too many times.  Ideally we would handle then traps by
 240       // doing the original bookkeeping in the MDO so that if it caused
 241       // the code to be thrown out we could still recompile and use the
 242       // optimization.  Failing the uncommon traps doesn&#39;t really mean
 243       // that the optimization is a bad idea but there&#39;s no other way to
 244       // do the MDO updates currently.
 245       int trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_intrinsic,
 246                                                            Deoptimization::Action_make_not_entrant);
 247       call-&gt;init_req(TypeFunc::Parms, __ intcon(trap_request));
 248       kit.add_safepoint_edges(call);
 249 
 250       _stringopts-&gt;gvn()-&gt;transform(call);
 251       C-&gt;gvn_replace_by(uct, call);
 252       uct-&gt;disconnect_inputs(NULL, C);
 253     }
 254   }
 255 
 256   void cleanup() {
 257     // disconnect the hook node
 258     _arguments-&gt;disconnect_inputs(NULL, _stringopts-&gt;C);
 259   }
 260 };
 261 
 262 
 263 void StringConcat::eliminate_unneeded_control() {
 264   for (uint i = 0; i &lt; _control.size(); i++) {
 265     Node* n = _control.at(i);
 266     if (n-&gt;is_Allocate()) {
 267       eliminate_initialize(n-&gt;as_Allocate()-&gt;initialization());
 268     }
 269     if (n-&gt;is_Call()) {
 270       if (n != _end) {
 271         eliminate_call(n-&gt;as_Call());
 272       }
 273     } else if (n-&gt;is_IfTrue()) {
 274       Compile* C = _stringopts-&gt;C;
 275       C-&gt;gvn_replace_by(n, n-&gt;in(0)-&gt;in(0));
 276       // get rid of the other projection
 277       C-&gt;gvn_replace_by(n-&gt;in(0)-&gt;as_If()-&gt;proj_out(false), C-&gt;top());
 278     }
 279   }
 280 }
 281 
 282 
 283 StringConcat* StringConcat::merge(StringConcat* other, Node* arg) {
 284   StringConcat* result = new StringConcat(_stringopts, _end);
 285   for (uint x = 0; x &lt; _control.size(); x++) {
 286     Node* n = _control.at(x);
 287     if (n-&gt;is_Call()) {
 288       result-&gt;_control.push(n);
 289     }
 290   }
 291   for (uint x = 0; x &lt; other-&gt;_control.size(); x++) {
 292     Node* n = other-&gt;_control.at(x);
 293     if (n-&gt;is_Call()) {
 294       result-&gt;_control.push(n);
 295     }
 296   }
 297   assert(result-&gt;_control.contains(other-&gt;_end), &quot;what?&quot;);
 298   assert(result-&gt;_control.contains(_begin), &quot;what?&quot;);
 299   for (int x = 0; x &lt; num_arguments(); x++) {
 300     Node* argx = argument_uncast(x);
 301     if (argx == arg) {
 302       // replace the toString result with the all the arguments that
 303       // made up the other StringConcat
 304       for (int y = 0; y &lt; other-&gt;num_arguments(); y++) {
 305         result-&gt;append(other-&gt;argument(y), other-&gt;mode(y));
 306       }
 307     } else {
 308       result-&gt;append(argx, mode(x));
 309     }
 310   }
 311   result-&gt;set_allocation(other-&gt;_begin);
 312   for (uint i = 0; i &lt; _constructors.size(); i++) {
 313     result-&gt;add_constructor(_constructors.at(i));
 314   }
 315   for (uint i = 0; i &lt; other-&gt;_constructors.size(); i++) {
 316     result-&gt;add_constructor(other-&gt;_constructors.at(i));
 317   }
 318   result-&gt;_multiple = true;
 319   return result;
 320 }
 321 
 322 
 323 void StringConcat::eliminate_call(CallNode* call) {
 324   Compile* C = _stringopts-&gt;C;
 325   CallProjections* projs = call-&gt;extract_projections(false);
 326   if (projs-&gt;fallthrough_catchproj != NULL) {
 327     C-&gt;gvn_replace_by(projs-&gt;fallthrough_catchproj, call-&gt;in(TypeFunc::Control));
 328   }
 329   if (projs-&gt;fallthrough_memproj != NULL) {
 330     C-&gt;gvn_replace_by(projs-&gt;fallthrough_memproj, call-&gt;in(TypeFunc::Memory));
 331   }
 332   if (projs-&gt;catchall_memproj != NULL) {
 333     C-&gt;gvn_replace_by(projs-&gt;catchall_memproj, C-&gt;top());
 334   }
 335   if (projs-&gt;fallthrough_ioproj != NULL) {
 336     C-&gt;gvn_replace_by(projs-&gt;fallthrough_ioproj, call-&gt;in(TypeFunc::I_O));
 337   }
 338   if (projs-&gt;catchall_ioproj != NULL) {
 339     C-&gt;gvn_replace_by(projs-&gt;catchall_ioproj, C-&gt;top());
 340   }
 341   if (projs-&gt;catchall_catchproj != NULL) {
 342     // EA can&#39;t cope with the partially collapsed graph this
 343     // creates so put it on the worklist to be collapsed later.
 344     for (SimpleDUIterator i(projs-&gt;catchall_catchproj); i.has_next(); i.next()) {
 345       Node *use = i.get();
 346       int opc = use-&gt;Opcode();
 347       if (opc == Op_CreateEx || opc == Op_Region) {
 348         _stringopts-&gt;record_dead_node(use);
 349       }
 350     }
 351     C-&gt;gvn_replace_by(projs-&gt;catchall_catchproj, C-&gt;top());
 352   }
 353   if (projs-&gt;resproj[0] != NULL) {
 354     assert(projs-&gt;nb_resproj == 1, &quot;unexpected number of results&quot;);
 355     C-&gt;gvn_replace_by(projs-&gt;resproj[0], C-&gt;top());
 356   }
 357   C-&gt;gvn_replace_by(call, C-&gt;top());
 358 }
 359 
 360 void StringConcat::eliminate_initialize(InitializeNode* init) {
 361   Compile* C = _stringopts-&gt;C;
 362 
 363   // Eliminate Initialize node.
 364   assert(init-&gt;outcnt() &lt;= 2, &quot;only a control and memory projection expected&quot;);
 365   assert(init-&gt;req() &lt;= InitializeNode::RawStores, &quot;no pending inits&quot;);
 366   Node *ctrl_proj = init-&gt;proj_out_or_null(TypeFunc::Control);
 367   if (ctrl_proj != NULL) {
 368     C-&gt;gvn_replace_by(ctrl_proj, init-&gt;in(TypeFunc::Control));
 369   }
 370   Node *mem_proj = init-&gt;proj_out_or_null(TypeFunc::Memory);
 371   if (mem_proj != NULL) {
 372     Node *mem = init-&gt;in(TypeFunc::Memory);
 373     C-&gt;gvn_replace_by(mem_proj, mem);
 374   }
 375   C-&gt;gvn_replace_by(init, C-&gt;top());
 376   init-&gt;disconnect_inputs(NULL, C);
 377 }
 378 
 379 Node_List PhaseStringOpts::collect_toString_calls() {
 380   Node_List string_calls;
 381   Node_List worklist;
 382 
 383   _visited.clear();
 384 
 385   // Prime the worklist
 386   for (uint i = 1; i &lt; C-&gt;root()-&gt;len(); i++) {
 387     Node* n = C-&gt;root()-&gt;in(i);
 388     if (n != NULL &amp;&amp; !_visited.test_set(n-&gt;_idx)) {
 389       worklist.push(n);
 390     }
 391   }
 392 
 393   while (worklist.size() &gt; 0) {
 394     Node* ctrl = worklist.pop();
 395     if (StringConcat::is_SB_toString(ctrl)) {
 396       CallStaticJavaNode* csj = ctrl-&gt;as_CallStaticJava();
 397       string_calls.push(csj);
 398     }
 399     if (ctrl-&gt;in(0) != NULL &amp;&amp; !_visited.test_set(ctrl-&gt;in(0)-&gt;_idx)) {
 400       worklist.push(ctrl-&gt;in(0));
 401     }
 402     if (ctrl-&gt;is_Region()) {
 403       for (uint i = 1; i &lt; ctrl-&gt;len(); i++) {
 404         if (ctrl-&gt;in(i) != NULL &amp;&amp; !_visited.test_set(ctrl-&gt;in(i)-&gt;_idx)) {
 405           worklist.push(ctrl-&gt;in(i));
 406         }
 407       }
 408     }
 409   }
 410   return string_calls;
 411 }
 412 
 413 
 414 StringConcat* PhaseStringOpts::build_candidate(CallStaticJavaNode* call) {
 415   ciMethod* m = call-&gt;method();
 416   ciSymbol* string_sig;
 417   ciSymbol* int_sig;
 418   ciSymbol* char_sig;
 419   if (m-&gt;holder() == C-&gt;env()-&gt;StringBuilder_klass()) {
 420     string_sig = ciSymbol::String_StringBuilder_signature();
 421     int_sig = ciSymbol::int_StringBuilder_signature();
 422     char_sig = ciSymbol::char_StringBuilder_signature();
 423   } else if (m-&gt;holder() == C-&gt;env()-&gt;StringBuffer_klass()) {
 424     string_sig = ciSymbol::String_StringBuffer_signature();
 425     int_sig = ciSymbol::int_StringBuffer_signature();
 426     char_sig = ciSymbol::char_StringBuffer_signature();
 427   } else {
 428     return NULL;
 429   }
 430 #ifndef PRODUCT
 431   if (PrintOptimizeStringConcat) {
 432     tty-&gt;print(&quot;considering toString call in &quot;);
 433     call-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 434   }
 435 #endif
 436 
 437   StringConcat* sc = new StringConcat(this, call);
 438 
 439   AllocateNode* alloc = NULL;
 440   InitializeNode* init = NULL;
 441 
 442   // possible opportunity for StringBuilder fusion
 443   CallStaticJavaNode* cnode = call;
 444   while (cnode) {
 445     Node* recv = cnode-&gt;in(TypeFunc::Parms)-&gt;uncast();
 446     if (recv-&gt;is_Proj()) {
 447       recv = recv-&gt;in(0);
 448     }
 449     cnode = recv-&gt;isa_CallStaticJava();
 450     if (cnode == NULL) {
 451       alloc = recv-&gt;isa_Allocate();
 452       if (alloc == NULL) {
 453         break;
 454       }
 455       // Find the constructor call
 456       Node* result = alloc-&gt;result_cast();
 457       if (result == NULL || !result-&gt;is_CheckCastPP() || alloc-&gt;in(TypeFunc::Memory)-&gt;is_top()) {
 458         // strange looking allocation
 459 #ifndef PRODUCT
 460         if (PrintOptimizeStringConcat) {
 461           tty-&gt;print(&quot;giving up because allocation looks strange &quot;);
 462           alloc-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 463         }
 464 #endif
 465         break;
 466       }
 467       Node* constructor = NULL;
 468       for (SimpleDUIterator i(result); i.has_next(); i.next()) {
 469         CallStaticJavaNode *use = i.get()-&gt;isa_CallStaticJava();
 470         if (use != NULL &amp;&amp;
 471             use-&gt;method() != NULL &amp;&amp;
 472             !use-&gt;method()-&gt;is_static() &amp;&amp;
 473             use-&gt;method()-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
 474             use-&gt;method()-&gt;holder() == m-&gt;holder()) {
 475           // Matched the constructor.
 476           ciSymbol* sig = use-&gt;method()-&gt;signature()-&gt;as_symbol();
 477           if (sig == ciSymbol::void_method_signature() ||
 478               sig == ciSymbol::int_void_signature() ||
 479               sig == ciSymbol::string_void_signature()) {
 480             if (sig == ciSymbol::string_void_signature()) {
 481               // StringBuilder(String) so pick this up as the first argument
 482               assert(use-&gt;in(TypeFunc::Parms + 1) != NULL, &quot;what?&quot;);
 483               const Type* type = _gvn-&gt;type(use-&gt;in(TypeFunc::Parms + 1));
 484               if (type == TypePtr::NULL_PTR) {
 485                 // StringBuilder(null) throws exception.
 486 #ifndef PRODUCT
 487                 if (PrintOptimizeStringConcat) {
 488                   tty-&gt;print(&quot;giving up because StringBuilder(null) throws exception&quot;);
 489                   alloc-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 490                 }
 491 #endif
 492                 return NULL;
 493               }
 494               // StringBuilder(str) argument needs null check.
 495               sc-&gt;push_string_null_check(use-&gt;in(TypeFunc::Parms + 1));
 496             }
 497             // The int variant takes an initial size for the backing
 498             // array so just treat it like the void version.
 499             constructor = use;
 500           } else {
 501 #ifndef PRODUCT
 502             if (PrintOptimizeStringConcat) {
 503               tty-&gt;print(&quot;unexpected constructor signature: %s&quot;, sig-&gt;as_utf8());
 504             }
 505 #endif
 506           }
 507           break;
 508         }
 509       }
 510       if (constructor == NULL) {
 511         // couldn&#39;t find constructor
 512 #ifndef PRODUCT
 513         if (PrintOptimizeStringConcat) {
 514           tty-&gt;print(&quot;giving up because couldn&#39;t find constructor &quot;);
 515           alloc-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 516         }
 517 #endif
 518         break;
 519       }
 520 
 521       // Walked all the way back and found the constructor call so see
 522       // if this call converted into a direct string concatenation.
 523       sc-&gt;add_control(call);
 524       sc-&gt;add_control(constructor);
 525       sc-&gt;add_control(alloc);
 526       sc-&gt;set_allocation(alloc);
 527       sc-&gt;add_constructor(constructor);
 528       if (sc-&gt;validate_control_flow() &amp;&amp; sc-&gt;validate_mem_flow()) {
 529         return sc;
 530       } else {
 531         return NULL;
 532       }
 533     } else if (cnode-&gt;method() == NULL) {
 534       break;
 535     } else if (!cnode-&gt;method()-&gt;is_static() &amp;&amp;
 536                cnode-&gt;method()-&gt;holder() == m-&gt;holder() &amp;&amp;
 537                cnode-&gt;method()-&gt;name() == ciSymbol::append_name() &amp;&amp;
 538                (cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == string_sig ||
 539                 cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == char_sig ||
 540                 cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == int_sig)) {
 541       sc-&gt;add_control(cnode);
 542       Node* arg = cnode-&gt;in(TypeFunc::Parms + 1);
 543       if (arg == NULL || arg-&gt;is_top()) {
 544 #ifndef PRODUCT
 545         if (PrintOptimizeStringConcat) {
 546           tty-&gt;print(&quot;giving up because the call is effectively dead&quot;);
 547           cnode-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 548         }
 549 #endif
 550         break;
 551       }
 552       if (cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == int_sig) {
 553         sc-&gt;push_int(arg);
 554       } else if (cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == char_sig) {
 555         sc-&gt;push_char(arg);
 556       } else {
 557         if (arg-&gt;is_Proj() &amp;&amp; arg-&gt;in(0)-&gt;is_CallStaticJava()) {
 558           CallStaticJavaNode* csj = arg-&gt;in(0)-&gt;as_CallStaticJava();
 559           if (csj-&gt;method() != NULL &amp;&amp;
 560               csj-&gt;method()-&gt;intrinsic_id() == vmIntrinsics::_Integer_toString &amp;&amp;
 561               arg-&gt;outcnt() == 1) {
 562             // _control is the list of StringBuilder calls nodes which
 563             // will be replaced by new String code after this optimization.
 564             // Integer::toString() call is not part of StringBuilder calls
 565             // chain. It could be eliminated only if its result is used
 566             // only by this SB calls chain.
 567             // Another limitation: it should be used only once because
 568             // it is unknown that it is used only by this SB calls chain
 569             // until all related SB calls nodes are collected.
 570             assert(arg-&gt;unique_out() == cnode, &quot;sanity&quot;);
 571             sc-&gt;add_control(csj);
 572             sc-&gt;push_int(csj-&gt;in(TypeFunc::Parms));
 573             continue;
 574           }
 575         }
 576         sc-&gt;push_string(arg);
 577       }
 578       continue;
 579     } else {
 580       // some unhandled signature
 581 #ifndef PRODUCT
 582       if (PrintOptimizeStringConcat) {
 583         tty-&gt;print(&quot;giving up because encountered unexpected signature &quot;);
 584         cnode-&gt;tf()-&gt;dump(); tty-&gt;cr();
 585         cnode-&gt;in(TypeFunc::Parms + 1)-&gt;dump();
 586       }
 587 #endif
 588       break;
 589     }
 590   }
 591   return NULL;
 592 }
 593 
 594 
 595 PhaseStringOpts::PhaseStringOpts(PhaseGVN* gvn, Unique_Node_List*):
 596   Phase(StringOpts),
 597   _gvn(gvn) {
 598 
 599   assert(OptimizeStringConcat, &quot;shouldn&#39;t be here&quot;);
 600 
 601   size_table_field = C-&gt;env()-&gt;Integer_klass()-&gt;get_field_by_name(ciSymbol::make(&quot;sizeTable&quot;),
 602                                                                   ciSymbol::make(&quot;[I&quot;), true);
 603   if (size_table_field == NULL) {
 604     // Something wrong so give up.
 605     assert(false, &quot;why can&#39;t we find Integer.sizeTable?&quot;);
 606     return;
 607   }
 608 
 609   // Collect the types needed to talk about the various slices of memory
 610   byte_adr_idx = C-&gt;get_alias_index(TypeAryPtr::BYTES);
 611 
 612   // For each locally allocated StringBuffer see if the usages can be
 613   // collapsed into a single String construction.
 614 
 615   // Run through the list of allocation looking for SB.toString to see
 616   // if it&#39;s possible to fuse the usage of the SB into a single String
 617   // construction.
 618   GrowableArray&lt;StringConcat*&gt; concats;
 619   Node_List toStrings = collect_toString_calls();
 620   while (toStrings.size() &gt; 0) {
 621     StringConcat* sc = build_candidate(toStrings.pop()-&gt;as_CallStaticJava());
 622     if (sc != NULL) {
 623       concats.push(sc);
 624     }
 625   }
 626 
 627   // try to coalesce separate concats
 628  restart:
 629   for (int c = 0; c &lt; concats.length(); c++) {
 630     StringConcat* sc = concats.at(c);
 631     for (int i = 0; i &lt; sc-&gt;num_arguments(); i++) {
 632       Node* arg = sc-&gt;argument_uncast(i);
 633       if (arg-&gt;is_Proj() &amp;&amp; StringConcat::is_SB_toString(arg-&gt;in(0))) {
 634         CallStaticJavaNode* csj = arg-&gt;in(0)-&gt;as_CallStaticJava();
 635         for (int o = 0; o &lt; concats.length(); o++) {
 636           if (c == o) continue;
 637           StringConcat* other = concats.at(o);
 638           if (other-&gt;end() == csj) {
 639 #ifndef PRODUCT
 640             if (PrintOptimizeStringConcat) {
 641               tty-&gt;print_cr(&quot;considering stacked concats&quot;);
 642             }
 643 #endif
 644 
 645             StringConcat* merged = sc-&gt;merge(other, arg);
 646             if (merged-&gt;validate_control_flow() &amp;&amp; merged-&gt;validate_mem_flow()) {
 647 #ifndef PRODUCT
 648               if (PrintOptimizeStringConcat) {
 649                 tty-&gt;print_cr(&quot;stacking would succeed&quot;);
 650               }
 651 #endif
 652               if (c &lt; o) {
 653                 concats.remove_at(o);
 654                 concats.at_put(c, merged);
 655               } else {
 656                 concats.remove_at(c);
 657                 concats.at_put(o, merged);
 658               }
 659               goto restart;
 660             } else {
 661 #ifndef PRODUCT
 662               if (PrintOptimizeStringConcat) {
 663                 tty-&gt;print_cr(&quot;stacking would fail&quot;);
 664               }
 665 #endif
 666             }
 667           }
 668         }
 669       }
 670     }
 671   }
 672 
 673 
 674   for (int c = 0; c &lt; concats.length(); c++) {
 675     StringConcat* sc = concats.at(c);
 676     replace_string_concat(sc);
 677   }
 678 
 679   remove_dead_nodes();
 680 }
 681 
 682 void PhaseStringOpts::record_dead_node(Node* dead) {
 683   dead_worklist.push(dead);
 684 }
 685 
 686 void PhaseStringOpts::remove_dead_nodes() {
 687   // Delete any dead nodes to make things clean enough that escape
 688   // analysis doesn&#39;t get unhappy.
 689   while (dead_worklist.size() &gt; 0) {
 690     Node* use = dead_worklist.pop();
 691     int opc = use-&gt;Opcode();
 692     switch (opc) {
 693       case Op_Region: {
 694         uint i = 1;
 695         for (i = 1; i &lt; use-&gt;req(); i++) {
 696           if (use-&gt;in(i) != C-&gt;top()) {
 697             break;
 698           }
 699         }
 700         if (i &gt;= use-&gt;req()) {
 701           for (SimpleDUIterator i(use); i.has_next(); i.next()) {
 702             Node* m = i.get();
 703             if (m-&gt;is_Phi()) {
 704               dead_worklist.push(m);
 705             }
 706           }
 707           C-&gt;gvn_replace_by(use, C-&gt;top());
 708         }
 709         break;
 710       }
 711       case Op_AddP:
 712       case Op_CreateEx: {
 713         // Recurisvely clean up references to CreateEx so EA doesn&#39;t
 714         // get unhappy about the partially collapsed graph.
 715         for (SimpleDUIterator i(use); i.has_next(); i.next()) {
 716           Node* m = i.get();
 717           if (m-&gt;is_AddP()) {
 718             dead_worklist.push(m);
 719           }
 720         }
 721         C-&gt;gvn_replace_by(use, C-&gt;top());
 722         break;
 723       }
 724       case Op_Phi:
 725         if (use-&gt;in(0) == C-&gt;top()) {
 726           C-&gt;gvn_replace_by(use, C-&gt;top());
 727         }
 728         break;
 729     }
 730   }
 731 }
 732 
 733 
 734 bool StringConcat::validate_mem_flow() {
 735   Compile* C = _stringopts-&gt;C;
 736 
 737   for (uint i = 0; i &lt; _control.size(); i++) {
 738 #ifndef PRODUCT
 739     Node_List path;
 740 #endif
 741     Node* curr = _control.at(i);
 742     if (curr-&gt;is_Call() &amp;&amp; curr != _begin) { // For all calls except the first allocation
 743       // Now here&#39;s the main invariant in our case:
 744       // For memory between the constructor, and appends, and toString we should only see bottom memory,
 745       // produced by the previous call we know about.
 746       if (!_constructors.contains(curr)) {
 747         NOT_PRODUCT(path.push(curr);)
 748         Node* mem = curr-&gt;in(TypeFunc::Memory);
 749         assert(mem != NULL, &quot;calls should have memory edge&quot;);
 750         assert(!mem-&gt;is_Phi(), &quot;should be handled by control flow validation&quot;);
 751         NOT_PRODUCT(path.push(mem);)
 752         while (mem-&gt;is_MergeMem()) {
 753           for (uint i = 1; i &lt; mem-&gt;req(); i++) {
 754             if (i != Compile::AliasIdxBot &amp;&amp; mem-&gt;in(i) != C-&gt;top()) {
 755 #ifndef PRODUCT
 756               if (PrintOptimizeStringConcat) {
 757                 tty-&gt;print(&quot;fusion has incorrect memory flow (side effects) for &quot;);
 758                 _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 759                 path.dump();
 760               }
 761 #endif
 762               return false;
 763             }
 764           }
 765           // skip through a potential MergeMem chain, linked through Bot
 766           mem = mem-&gt;in(Compile::AliasIdxBot);
 767           NOT_PRODUCT(path.push(mem);)
 768         }
 769         // now let it fall through, and see if we have a projection
 770         if (mem-&gt;is_Proj()) {
 771           // Should point to a previous known call
 772           Node *prev = mem-&gt;in(0);
 773           NOT_PRODUCT(path.push(prev);)
 774           if (!prev-&gt;is_Call() || !_control.contains(prev)) {
 775 #ifndef PRODUCT
 776             if (PrintOptimizeStringConcat) {
 777               tty-&gt;print(&quot;fusion has incorrect memory flow (unknown call) for &quot;);
 778               _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 779               path.dump();
 780             }
 781 #endif
 782             return false;
 783           }
 784         } else {
 785           assert(mem-&gt;is_Store() || mem-&gt;is_LoadStore(), &quot;unexpected node type: %s&quot;, mem-&gt;Name());
 786 #ifndef PRODUCT
 787           if (PrintOptimizeStringConcat) {
 788             tty-&gt;print(&quot;fusion has incorrect memory flow (unexpected source) for &quot;);
 789             _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 790             path.dump();
 791           }
 792 #endif
 793           return false;
 794         }
 795       } else {
 796         // For memory that feeds into constructors it&#39;s more complicated.
 797         // However the advantage is that any side effect that happens between the Allocate/Initialize and
 798         // the constructor will have to be control-dependent on Initialize.
 799         // So we actually don&#39;t have to do anything, since it&#39;s going to be caught by the control flow
 800         // analysis.
 801 #ifdef ASSERT
 802         // Do a quick verification of the control pattern between the constructor and the initialize node
 803         assert(curr-&gt;is_Call(), &quot;constructor should be a call&quot;);
 804         // Go up the control starting from the constructor call
 805         Node* ctrl = curr-&gt;in(0);
 806         IfNode* iff = NULL;
 807         RegionNode* copy = NULL;
 808 
 809         while (true) {
 810           // skip known check patterns
 811           if (ctrl-&gt;is_Region()) {
 812             if (ctrl-&gt;as_Region()-&gt;is_copy()) {
 813               copy = ctrl-&gt;as_Region();
 814               ctrl = copy-&gt;is_copy();
 815             } else { // a cast
 816               assert(ctrl-&gt;req() == 3 &amp;&amp;
 817                      ctrl-&gt;in(1) != NULL &amp;&amp; ctrl-&gt;in(1)-&gt;is_Proj() &amp;&amp;
 818                      ctrl-&gt;in(2) != NULL &amp;&amp; ctrl-&gt;in(2)-&gt;is_Proj() &amp;&amp;
 819                      ctrl-&gt;in(1)-&gt;in(0) == ctrl-&gt;in(2)-&gt;in(0) &amp;&amp;
 820                      ctrl-&gt;in(1)-&gt;in(0) != NULL &amp;&amp; ctrl-&gt;in(1)-&gt;in(0)-&gt;is_If(),
 821                      &quot;must be a simple diamond&quot;);
 822               Node* true_proj = ctrl-&gt;in(1)-&gt;is_IfTrue() ? ctrl-&gt;in(1) : ctrl-&gt;in(2);
 823               for (SimpleDUIterator i(true_proj); i.has_next(); i.next()) {
 824                 Node* use = i.get();
 825                 assert(use == ctrl || use-&gt;is_ConstraintCast(),
 826                        &quot;unexpected user: %s&quot;, use-&gt;Name());
 827               }
 828 
 829               iff = ctrl-&gt;in(1)-&gt;in(0)-&gt;as_If();
 830               ctrl = iff-&gt;in(0);
 831             }
 832           } else if (ctrl-&gt;is_IfTrue()) { // null checks, class checks
 833             iff = ctrl-&gt;in(0)-&gt;as_If();
 834             // Verify that the other arm is an uncommon trap
 835             Node* otherproj = iff-&gt;proj_out(1 - ctrl-&gt;as_Proj()-&gt;_con);
 836             CallStaticJavaNode* call = otherproj-&gt;unique_out()-&gt;isa_CallStaticJava();
 837             assert(strcmp(call-&gt;_name, &quot;uncommon_trap&quot;) == 0, &quot;must be uncommon trap&quot;);
 838             ctrl = iff-&gt;in(0);
 839           } else {
 840             break;
 841           }
 842         }
 843 
 844         assert(ctrl-&gt;is_Proj(), &quot;must be a projection&quot;);
 845         assert(ctrl-&gt;in(0)-&gt;is_Initialize(), &quot;should be initialize&quot;);
 846         for (SimpleDUIterator i(ctrl); i.has_next(); i.next()) {
 847           Node* use = i.get();
 848           assert(use == copy || use == iff || use == curr || use-&gt;is_CheckCastPP() || use-&gt;is_Load(),
 849                  &quot;unexpected user: %s&quot;, use-&gt;Name());
 850         }
 851 #endif // ASSERT
 852       }
 853     }
 854   }
 855 
 856 #ifndef PRODUCT
 857   if (PrintOptimizeStringConcat) {
 858     tty-&gt;print(&quot;fusion has correct memory flow for &quot;);
 859     _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 860     tty-&gt;cr();
 861   }
 862 #endif
 863   return true;
 864 }
 865 
 866 bool StringConcat::validate_control_flow() {
 867   // We found all the calls and arguments now lets see if it&#39;s
 868   // safe to transform the graph as we would expect.
 869 
 870   // Check to see if this resulted in too many uncommon traps previously
 871   if (Compile::current()-&gt;too_many_traps(_begin-&gt;jvms()-&gt;method(), _begin-&gt;jvms()-&gt;bci(),
 872                         Deoptimization::Reason_intrinsic)) {
 873     return false;
 874   }
 875 
 876   // Walk backwards over the control flow from toString to the
 877   // allocation and make sure all the control flow is ok.  This
 878   // means it&#39;s either going to be eliminated once the calls are
 879   // removed or it can safely be transformed into an uncommon
 880   // trap.
 881 
 882   int null_check_count = 0;
 883   Unique_Node_List ctrl_path;
 884 
 885   assert(_control.contains(_begin), &quot;missing&quot;);
 886   assert(_control.contains(_end), &quot;missing&quot;);
 887 
 888   // Collect the nodes that we know about and will eliminate into ctrl_path
 889   for (uint i = 0; i &lt; _control.size(); i++) {
 890     // Push the call and it&#39;s control projection
 891     Node* n = _control.at(i);
 892     if (n-&gt;is_Allocate()) {
 893       AllocateNode* an = n-&gt;as_Allocate();
 894       InitializeNode* init = an-&gt;initialization();
 895       ctrl_path.push(init);
 896       ctrl_path.push(init-&gt;as_Multi()-&gt;proj_out(0));
 897     }
 898     if (n-&gt;is_Call()) {
 899       CallNode* cn = n-&gt;as_Call();
 900       ctrl_path.push(cn);
 901       ctrl_path.push(cn-&gt;proj_out(0));
 902       ctrl_path.push(cn-&gt;proj_out(0)-&gt;unique_out());
 903       Node* catchproj = cn-&gt;proj_out(0)-&gt;unique_out()-&gt;as_Catch()-&gt;proj_out_or_null(0);
 904       if (catchproj != NULL) {
 905         ctrl_path.push(catchproj);
 906       }
 907     } else {
 908       ShouldNotReachHere();
 909     }
 910   }
 911 
 912   // Skip backwards through the control checking for unexpected control flow
 913   Node* ptr = _end;
 914   bool fail = false;
 915   while (ptr != _begin) {
 916     if (ptr-&gt;is_Call() &amp;&amp; ctrl_path.member(ptr)) {
 917       ptr = ptr-&gt;in(0);
 918     } else if (ptr-&gt;is_CatchProj() &amp;&amp; ctrl_path.member(ptr)) {
 919       ptr = ptr-&gt;in(0)-&gt;in(0)-&gt;in(0);
 920       assert(ctrl_path.member(ptr), &quot;should be a known piece of control&quot;);
 921     } else if (ptr-&gt;is_IfTrue()) {
 922       IfNode* iff = ptr-&gt;in(0)-&gt;as_If();
 923       BoolNode* b = iff-&gt;in(1)-&gt;isa_Bool();
 924 
 925       if (b == NULL) {
 926 #ifndef PRODUCT
 927         if (PrintOptimizeStringConcat) {
 928           tty-&gt;print_cr(&quot;unexpected input to IfNode&quot;);
 929           iff-&gt;in(1)-&gt;dump();
 930           tty-&gt;cr();
 931         }
 932 #endif
 933         fail = true;
 934         break;
 935       }
 936 
 937       Node* cmp = b-&gt;in(1);
 938       Node* v1 = cmp-&gt;in(1);
 939       Node* v2 = cmp-&gt;in(2);
 940       Node* otherproj = iff-&gt;proj_out(1 - ptr-&gt;as_Proj()-&gt;_con);
 941 
 942       // Null check of the return of append which can simply be eliminated
 943       if (b-&gt;_test._test == BoolTest::ne &amp;&amp;
 944           v2-&gt;bottom_type() == TypePtr::NULL_PTR &amp;&amp;
 945           v1-&gt;is_Proj() &amp;&amp; ctrl_path.member(v1-&gt;in(0))) {
 946         // NULL check of the return value of the append
 947         null_check_count++;
 948         if (otherproj-&gt;outcnt() == 1) {
 949           CallStaticJavaNode* call = otherproj-&gt;unique_out()-&gt;isa_CallStaticJava();
 950           if (call != NULL &amp;&amp; call-&gt;_name != NULL &amp;&amp; strcmp(call-&gt;_name, &quot;uncommon_trap&quot;) == 0) {
 951             ctrl_path.push(call);
 952           }
 953         }
 954         _control.push(ptr);
 955         ptr = ptr-&gt;in(0)-&gt;in(0);
 956         continue;
 957       }
 958 
 959       // A test which leads to an uncommon trap which should be safe.
 960       // Later this trap will be converted into a trap that restarts
 961       // at the beginning.
 962       if (otherproj-&gt;outcnt() == 1) {
 963         CallStaticJavaNode* call = otherproj-&gt;unique_out()-&gt;isa_CallStaticJava();
 964         if (call != NULL &amp;&amp; call-&gt;_name != NULL &amp;&amp; strcmp(call-&gt;_name, &quot;uncommon_trap&quot;) == 0) {
 965           // control flow leads to uct so should be ok
 966           _uncommon_traps.push(call);
 967           ctrl_path.push(call);
 968           ptr = ptr-&gt;in(0)-&gt;in(0);
 969           continue;
 970         }
 971       }
 972 
 973 #ifndef PRODUCT
 974       // Some unexpected control flow we don&#39;t know how to handle.
 975       if (PrintOptimizeStringConcat) {
 976         tty-&gt;print_cr(&quot;failing with unknown test&quot;);
 977         b-&gt;dump();
 978         cmp-&gt;dump();
 979         v1-&gt;dump();
 980         v2-&gt;dump();
 981         tty-&gt;cr();
 982       }
 983 #endif
 984       fail = true;
 985       break;
 986     } else if (ptr-&gt;is_Proj() &amp;&amp; ptr-&gt;in(0)-&gt;is_Initialize()) {
 987       ptr = ptr-&gt;in(0)-&gt;in(0);
 988     } else if (ptr-&gt;is_Region()) {
 989       Node* copy = ptr-&gt;as_Region()-&gt;is_copy();
 990       if (copy != NULL) {
 991         ptr = copy;
 992         continue;
 993       }
 994       if (ptr-&gt;req() == 3 &amp;&amp;
 995           ptr-&gt;in(1) != NULL &amp;&amp; ptr-&gt;in(1)-&gt;is_Proj() &amp;&amp;
 996           ptr-&gt;in(2) != NULL &amp;&amp; ptr-&gt;in(2)-&gt;is_Proj() &amp;&amp;
 997           ptr-&gt;in(1)-&gt;in(0) == ptr-&gt;in(2)-&gt;in(0) &amp;&amp;
 998           ptr-&gt;in(1)-&gt;in(0) != NULL &amp;&amp; ptr-&gt;in(1)-&gt;in(0)-&gt;is_If()) {
 999         // Simple diamond.
1000         // XXX should check for possibly merging stores.  simple data merges are ok.
1001         // The IGVN will make this simple diamond go away when it
1002         // transforms the Region. Make sure it sees it.
1003         Compile::current()-&gt;record_for_igvn(ptr);
1004         ptr = ptr-&gt;in(1)-&gt;in(0)-&gt;in(0);
1005         continue;
1006       }
1007 #ifndef PRODUCT
1008       if (PrintOptimizeStringConcat) {
1009         tty-&gt;print_cr(&quot;fusion would fail for region&quot;);
1010         _begin-&gt;dump();
1011         ptr-&gt;dump(2);
1012       }
1013 #endif
1014       fail = true;
1015       break;
1016     } else {
1017       // other unknown control
1018       if (!fail) {
1019 #ifndef PRODUCT
1020         if (PrintOptimizeStringConcat) {
1021           tty-&gt;print_cr(&quot;fusion would fail for&quot;);
1022           _begin-&gt;dump();
1023         }
1024 #endif
1025         fail = true;
1026       }
1027 #ifndef PRODUCT
1028       if (PrintOptimizeStringConcat) {
1029         ptr-&gt;dump();
1030       }
1031 #endif
1032       ptr = ptr-&gt;in(0);
1033     }
1034   }
1035 #ifndef PRODUCT
1036   if (PrintOptimizeStringConcat &amp;&amp; fail) {
1037     tty-&gt;cr();
1038   }
1039 #endif
1040   if (fail) return !fail;
1041 
1042   // Validate that all these results produced are contained within
1043   // this cluster of objects.  First collect all the results produced
1044   // by calls in the region.
1045   _stringopts-&gt;_visited.clear();
1046   Node_List worklist;
1047   Node* final_result = _end-&gt;proj_out_or_null(TypeFunc::Parms);
1048   for (uint i = 0; i &lt; _control.size(); i++) {
1049     CallNode* cnode = _control.at(i)-&gt;isa_Call();
1050     if (cnode != NULL) {
1051       _stringopts-&gt;_visited.test_set(cnode-&gt;_idx);
1052     }
1053     Node* result = cnode != NULL ? cnode-&gt;proj_out_or_null(TypeFunc::Parms) : NULL;
1054     if (result != NULL &amp;&amp; result != final_result) {
1055       worklist.push(result);
1056     }
1057   }
1058 
1059   Node* last_result = NULL;
1060   while (worklist.size() &gt; 0) {
1061     Node* result = worklist.pop();
1062     if (_stringopts-&gt;_visited.test_set(result-&gt;_idx))
1063       continue;
1064     for (SimpleDUIterator i(result); i.has_next(); i.next()) {
1065       Node *use = i.get();
1066       if (ctrl_path.member(use)) {
1067         // already checked this
1068         continue;
1069       }
1070       int opc = use-&gt;Opcode();
1071       if (opc == Op_CmpP || opc == Op_Node) {
1072         ctrl_path.push(use);
1073         continue;
1074       }
1075       if (opc == Op_CastPP || opc == Op_CheckCastPP) {
1076         for (SimpleDUIterator j(use); j.has_next(); j.next()) {
1077           worklist.push(j.get());
1078         }
1079         worklist.push(use-&gt;in(1));
1080         ctrl_path.push(use);
1081         continue;
1082       }
1083 #ifndef PRODUCT
1084       if (PrintOptimizeStringConcat) {
1085         if (result != last_result) {
1086           last_result = result;
1087           tty-&gt;print_cr(&quot;extra uses for result:&quot;);
1088           last_result-&gt;dump();
1089         }
1090         use-&gt;dump();
1091       }
1092 #endif
1093       fail = true;
1094       break;
1095     }
1096   }
1097 
1098 #ifndef PRODUCT
1099   if (PrintOptimizeStringConcat &amp;&amp; !fail) {
1100     ttyLocker ttyl;
1101     tty-&gt;cr();
1102     tty-&gt;print(&quot;fusion has correct control flow (%d %d) for &quot;, null_check_count, _uncommon_traps.size());
1103     _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
1104     for (int i = 0; i &lt; num_arguments(); i++) {
1105       argument(i)-&gt;dump();
1106     }
1107     _control.dump();
1108     tty-&gt;cr();
1109   }
1110 #endif
1111 
1112   return !fail;
1113 }
1114 
1115 Node* PhaseStringOpts::fetch_static_field(GraphKit&amp; kit, ciField* field) {
1116   const TypeInstPtr* mirror_type = TypeInstPtr::make(field-&gt;holder()-&gt;java_mirror());
1117   Node* klass_node = __ makecon(mirror_type);
1118   BasicType bt = field-&gt;layout_type();
1119   ciType* field_klass = field-&gt;type();
1120 
1121   const Type *type;
1122   if( bt == T_OBJECT ) {
1123     if (!field-&gt;type()-&gt;is_loaded()) {
1124       type = TypeInstPtr::BOTTOM;
1125     } else if (field-&gt;is_static_constant()) {
1126       // This can happen if the constant oop is non-perm.
1127       ciObject* con = field-&gt;constant_value().as_object();
1128       // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
1129       // and may yield a vacuous result if the field is of interface type.
1130       type = TypeOopPtr::make_from_constant(con, true)-&gt;isa_oopptr();
1131       assert(type != NULL, &quot;field singleton type must be consistent&quot;);
1132       return __ makecon(type);
1133     } else {
1134       type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
1135     }
1136   } else {
1137     type = Type::get_const_basic_type(bt);
1138   }
1139 
1140   return kit.make_load(NULL, kit.basic_plus_adr(klass_node, field-&gt;offset_in_bytes()),
1141                        type, T_OBJECT,
1142                        C-&gt;get_alias_index(mirror_type-&gt;add_offset(field-&gt;offset_in_bytes())),
1143                        MemNode::unordered);
1144 }
1145 
1146 Node* PhaseStringOpts::int_stringSize(GraphKit&amp; kit, Node* arg) {
1147   if (arg-&gt;is_Con()) {
1148     // Constant integer. Compute constant length using Integer.sizeTable
1149     int arg_val = arg-&gt;get_int();
1150     int count = 1;
1151     if (arg_val &lt; 0) {
1152       arg_val = -arg_val;
1153       count++;
1154     }
1155 
1156     ciArray* size_table = (ciArray*)size_table_field-&gt;constant_value().as_object();
1157     for (int i = 0; i &lt; size_table-&gt;length(); i++) {
1158       if (arg_val &lt;= size_table-&gt;element_value(i).as_int()) {
1159         count += i;
1160         break;
1161       }
1162     }
1163     return __ intcon(count);
1164   }
1165 
1166   RegionNode *final_merge = new RegionNode(3);
1167   kit.gvn().set_type(final_merge, Type::CONTROL);
1168   Node* final_size = new PhiNode(final_merge, TypeInt::INT);
1169   kit.gvn().set_type(final_size, TypeInt::INT);
1170 
1171   IfNode* iff = kit.create_and_map_if(kit.control(),
1172                                       __ Bool(__ CmpI(arg, __ intcon(0x80000000)), BoolTest::ne),
1173                                       PROB_FAIR, COUNT_UNKNOWN);
1174   Node* is_min = __ IfFalse(iff);
1175   final_merge-&gt;init_req(1, is_min);
1176   final_size-&gt;init_req(1, __ intcon(11));
1177 
1178   kit.set_control(__ IfTrue(iff));
1179   if (kit.stopped()) {
1180     final_merge-&gt;init_req(2, C-&gt;top());
1181     final_size-&gt;init_req(2, C-&gt;top());
1182   } else {
1183 
1184     // int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i);
1185     RegionNode *r = new RegionNode(3);
1186     kit.gvn().set_type(r, Type::CONTROL);
1187     Node *phi = new PhiNode(r, TypeInt::INT);
1188     kit.gvn().set_type(phi, TypeInt::INT);
1189     Node *size = new PhiNode(r, TypeInt::INT);
1190     kit.gvn().set_type(size, TypeInt::INT);
1191     Node* chk = __ CmpI(arg, __ intcon(0));
1192     Node* p = __ Bool(chk, BoolTest::lt);
1193     IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_FAIR, COUNT_UNKNOWN);
1194     Node* lessthan = __ IfTrue(iff);
1195     Node* greaterequal = __ IfFalse(iff);
1196     r-&gt;init_req(1, lessthan);
1197     phi-&gt;init_req(1, __ SubI(__ intcon(0), arg));
1198     size-&gt;init_req(1, __ intcon(1));
1199     r-&gt;init_req(2, greaterequal);
1200     phi-&gt;init_req(2, arg);
1201     size-&gt;init_req(2, __ intcon(0));
1202     kit.set_control(r);
1203     C-&gt;record_for_igvn(r);
1204     C-&gt;record_for_igvn(phi);
1205     C-&gt;record_for_igvn(size);
1206 
1207     // for (int i=0; ; i++)
1208     //   if (x &lt;= sizeTable[i])
1209     //     return i+1;
1210 
1211     // Add loop predicate first.
1212     kit.add_empty_predicates();
1213 
1214     RegionNode *loop = new RegionNode(3);
1215     loop-&gt;init_req(1, kit.control());
1216     kit.gvn().set_type(loop, Type::CONTROL);
1217 
1218     Node *index = new PhiNode(loop, TypeInt::INT);
1219     index-&gt;init_req(1, __ intcon(0));
1220     kit.gvn().set_type(index, TypeInt::INT);
1221     kit.set_control(loop);
1222     Node* sizeTable = fetch_static_field(kit, size_table_field);
1223 
1224     Node* value = kit.load_array_element(NULL, sizeTable, index, TypeAryPtr::INTS);
1225     C-&gt;record_for_igvn(value);
1226     Node* limit = __ CmpI(phi, value);
1227     Node* limitb = __ Bool(limit, BoolTest::le);
1228     IfNode* iff2 = kit.create_and_map_if(kit.control(), limitb, PROB_MIN, COUNT_UNKNOWN);
1229     Node* lessEqual = __ IfTrue(iff2);
1230     Node* greater = __ IfFalse(iff2);
1231 
1232     loop-&gt;init_req(2, greater);
1233     index-&gt;init_req(2, __ AddI(index, __ intcon(1)));
1234 
1235     kit.set_control(lessEqual);
1236     C-&gt;record_for_igvn(loop);
1237     C-&gt;record_for_igvn(index);
1238 
1239     final_merge-&gt;init_req(2, kit.control());
1240     final_size-&gt;init_req(2, __ AddI(__ AddI(index, size), __ intcon(1)));
1241   }
1242 
1243   kit.set_control(final_merge);
1244   C-&gt;record_for_igvn(final_merge);
1245   C-&gt;record_for_igvn(final_size);
1246 
1247   return final_size;
1248 }
1249 
1250 // Simplified version of Integer.getChars
1251 void PhaseStringOpts::getChars(GraphKit&amp; kit, Node* arg, Node* dst_array, BasicType bt, Node* end, Node* final_merge, Node* final_mem, int merge_index) {
1252   // if (i &lt; 0) {
1253   //     sign = &#39;-&#39;;
1254   //     i = -i;
1255   // }
1256   IfNode* iff = kit.create_and_map_if(kit.control(), __ Bool(__ CmpI(arg, __ intcon(0)), BoolTest::lt),
1257                                       PROB_FAIR, COUNT_UNKNOWN);
1258 
1259   RegionNode* merge = new RegionNode(3);
1260   kit.gvn().set_type(merge, Type::CONTROL);
1261   Node* i = new PhiNode(merge, TypeInt::INT);
1262   kit.gvn().set_type(i, TypeInt::INT);
1263   Node* sign = new PhiNode(merge, TypeInt::INT);
1264   kit.gvn().set_type(sign, TypeInt::INT);
1265 
1266   merge-&gt;init_req(1, __ IfTrue(iff));
1267   i-&gt;init_req(1, __ SubI(__ intcon(0), arg));
1268   sign-&gt;init_req(1, __ intcon(&#39;-&#39;));
1269   merge-&gt;init_req(2, __ IfFalse(iff));
1270   i-&gt;init_req(2, arg);
1271   sign-&gt;init_req(2, __ intcon(0));
1272 
1273   kit.set_control(merge);
1274 
1275   C-&gt;record_for_igvn(merge);
1276   C-&gt;record_for_igvn(i);
1277   C-&gt;record_for_igvn(sign);
1278 
1279   // for (;;) {
1280   //     q = i / 10;
1281   //     r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1));  // r = i-(q*10) ...
1282   //     buf [--charPos] = digits [r];
1283   //     i = q;
1284   //     if (i == 0) break;
1285   // }
1286 
1287   // Add loop predicate first.
1288   kit.add_empty_predicates();
1289 
1290   RegionNode* head = new RegionNode(3);
1291   head-&gt;init_req(1, kit.control());
1292 
1293   kit.gvn().set_type(head, Type::CONTROL);
1294   Node* i_phi = new PhiNode(head, TypeInt::INT);
1295   i_phi-&gt;init_req(1, i);
1296   kit.gvn().set_type(i_phi, TypeInt::INT);
1297   Node* charPos = new PhiNode(head, TypeInt::INT);
1298   charPos-&gt;init_req(1, end);
1299   kit.gvn().set_type(charPos, TypeInt::INT);
1300   Node* mem = PhiNode::make(head, kit.memory(byte_adr_idx), Type::MEMORY, TypeAryPtr::BYTES);
1301   kit.gvn().set_type(mem, Type::MEMORY);
1302 
1303   kit.set_control(head);
1304   kit.set_memory(mem, byte_adr_idx);
1305 
1306   Node* q = __ DivI(kit.null(), i_phi, __ intcon(10));
1307   Node* r = __ SubI(i_phi, __ AddI(__ LShiftI(q, __ intcon(3)),
1308                                    __ LShiftI(q, __ intcon(1))));
1309   Node* index = __ SubI(charPos, __ intcon((bt == T_BYTE) ? 1 : 2));
1310   Node* ch = __ AddI(r, __ intcon(&#39;0&#39;));
1311   Node* st = __ store_to_memory(kit.control(), kit.array_element_address(dst_array, index, T_BYTE),
1312                                 ch, bt, byte_adr_idx, MemNode::unordered, (bt != T_BYTE) /* mismatched */);
1313 
1314   iff = kit.create_and_map_if(head, __ Bool(__ CmpI(q, __ intcon(0)), BoolTest::ne),
1315                               PROB_FAIR, COUNT_UNKNOWN);
1316   Node* ne = __ IfTrue(iff);
1317   Node* eq = __ IfFalse(iff);
1318 
1319   head-&gt;init_req(2, ne);
1320   mem-&gt;init_req(2, st);
1321 
1322   i_phi-&gt;init_req(2, q);
1323   charPos-&gt;init_req(2, index);
1324   charPos = index;
1325 
1326   kit.set_control(eq);
1327   kit.set_memory(st, byte_adr_idx);
1328 
1329   C-&gt;record_for_igvn(head);
1330   C-&gt;record_for_igvn(mem);
1331   C-&gt;record_for_igvn(i_phi);
1332   C-&gt;record_for_igvn(charPos);
1333 
1334   // if (sign != 0) {
1335   //     buf [--charPos] = sign;
1336   // }
1337   iff = kit.create_and_map_if(kit.control(), __ Bool(__ CmpI(sign, __ intcon(0)), BoolTest::ne),
1338                               PROB_FAIR, COUNT_UNKNOWN);
1339 
1340   final_merge-&gt;init_req(merge_index + 2, __ IfFalse(iff));
1341   final_mem-&gt;init_req(merge_index + 2, kit.memory(byte_adr_idx));
1342 
1343   kit.set_control(__ IfTrue(iff));
1344   if (kit.stopped()) {
1345     final_merge-&gt;init_req(merge_index + 1, C-&gt;top());
1346     final_mem-&gt;init_req(merge_index + 1, C-&gt;top());
1347   } else {
1348     Node* index = __ SubI(charPos, __ intcon((bt == T_BYTE) ? 1 : 2));
1349     st = __ store_to_memory(kit.control(), kit.array_element_address(dst_array, index, T_BYTE),
1350                             sign, bt, byte_adr_idx, MemNode::unordered, (bt != T_BYTE) /* mismatched */);
1351 
1352     final_merge-&gt;init_req(merge_index + 1, kit.control());
1353     final_mem-&gt;init_req(merge_index + 1, st);
1354   }
1355 }
1356 
1357 // Copy the characters representing arg into dst_array starting at start
1358 Node* PhaseStringOpts::int_getChars(GraphKit&amp; kit, Node* arg, Node* dst_array, Node* dst_coder, Node* start, Node* size) {
1359   bool dcon = dst_coder-&gt;is_Con();
1360   bool dbyte = dcon ? (dst_coder-&gt;get_int() == java_lang_String::CODER_LATIN1) : false;
1361   Node* end = __ AddI(start, __ LShiftI(size, dst_coder));
1362 
1363   // The final_merge node has 4 entries in case the encoding is known:
1364   // (0) Control, (1) result w/ sign, (2) result w/o sign, (3) result for Integer.min_value
1365   // or 6 entries in case the encoding is not known:
1366   // (0) Control, (1) Latin1 w/ sign, (2) Latin1 w/o sign, (3) min_value, (4) UTF16 w/ sign, (5) UTF16 w/o sign
1367   RegionNode* final_merge = new RegionNode(dcon ? 4 : 6);
1368   kit.gvn().set_type(final_merge, Type::CONTROL);
1369 
1370   Node* final_mem = PhiNode::make(final_merge, kit.memory(byte_adr_idx), Type::MEMORY, TypeAryPtr::BYTES);
1371   kit.gvn().set_type(final_mem, Type::MEMORY);
1372 
1373   // need to handle arg == Integer.MIN_VALUE specially because negating doesn&#39;t make it positive
1374   IfNode* iff = kit.create_and_map_if(kit.control(), __ Bool(__ CmpI(arg, __ intcon(0x80000000)), BoolTest::ne),
1375                                       PROB_FAIR, COUNT_UNKNOWN);
1376 
1377   Node* old_mem = kit.memory(byte_adr_idx);
1378 
1379   kit.set_control(__ IfFalse(iff));
1380   if (kit.stopped()) {
1381     // Statically not equal to MIN_VALUE so this path is dead
1382     final_merge-&gt;init_req(3, kit.control());
1383   } else {
1384     copy_string(kit, __ makecon(TypeInstPtr::make(C-&gt;env()-&gt;the_min_jint_string())),
1385                 dst_array, dst_coder, start);
1386     final_merge-&gt;init_req(3, kit.control());
1387     final_mem-&gt;init_req(3, kit.memory(byte_adr_idx));
1388   }
1389 
1390   kit.set_control(__ IfTrue(iff));
1391   kit.set_memory(old_mem, byte_adr_idx);
1392 
1393   if (!dcon) {
1394     // Check encoding of destination
1395     iff = kit.create_and_map_if(kit.control(), __ Bool(__ CmpI(dst_coder, __ intcon(0)), BoolTest::eq),
1396                                 PROB_FAIR, COUNT_UNKNOWN);
1397     old_mem = kit.memory(byte_adr_idx);
1398   }
1399   if (!dcon || dbyte) {
1400     // Destination is Latin1,
1401     if (!dcon) {
1402       kit.set_control(__ IfTrue(iff));
1403     }
1404     getChars(kit, arg, dst_array, T_BYTE, end, final_merge, final_mem);
1405   }
1406   if (!dcon || !dbyte) {
1407     // Destination is UTF16
1408     int merge_index = 0;
1409     if (!dcon) {
1410       kit.set_control(__ IfFalse(iff));
1411       kit.set_memory(old_mem, byte_adr_idx);
1412       merge_index = 3; // Account for Latin1 case
1413     }
1414     getChars(kit, arg, dst_array, T_CHAR, end, final_merge, final_mem, merge_index);
1415   }
1416 
1417   // Final merge point for Latin1 and UTF16 case
1418   kit.set_control(final_merge);
1419   kit.set_memory(final_mem, byte_adr_idx);
1420 
1421   C-&gt;record_for_igvn(final_merge);
1422   C-&gt;record_for_igvn(final_mem);
1423   return end;
1424 }
1425 
1426 // Copy &#39;count&#39; bytes/chars from src_array to dst_array starting at index start
1427 void PhaseStringOpts::arraycopy(GraphKit&amp; kit, IdealKit&amp; ideal, Node* src_array, Node* dst_array, BasicType elembt, Node* start, Node* count) {
1428   assert(elembt == T_BYTE || elembt == T_CHAR, &quot;Invalid type for arraycopy&quot;);
1429 
1430   if (elembt == T_CHAR) {
1431     // Get number of chars
1432     count = __ RShiftI(count, __ intcon(1));
1433   }
1434 
1435   Node* extra = NULL;
1436 #ifdef _LP64
1437   count = __ ConvI2L(count);
1438   extra = C-&gt;top();
1439 #endif
1440 
1441   Node* src_ptr = __ array_element_address(src_array, __ intcon(0), T_BYTE);
1442   Node* dst_ptr = __ array_element_address(dst_array, start, T_BYTE);
1443   // Check if destination address is aligned to HeapWordSize
1444   const TypeInt* tdst = __ gvn().type(start)-&gt;is_int();
1445   bool aligned = tdst-&gt;is_con() &amp;&amp; ((tdst-&gt;get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0);
1446   // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1447   const char* copyfunc_name = &quot;arraycopy&quot;;
1448   address     copyfunc_addr = StubRoutines::select_arraycopy_function(elembt, aligned, true, copyfunc_name, true);
1449   ideal.make_leaf_call_no_fp(OptoRuntime::fast_arraycopy_Type(), copyfunc_addr, copyfunc_name,
1450                              TypeAryPtr::BYTES, src_ptr, dst_ptr, count, extra);
1451 }
1452 
1453 #undef __
1454 #define __ ideal.
1455 
1456 // Copy contents of a Latin1 encoded string from src_array to dst_array
1457 void PhaseStringOpts::copy_latin1_string(GraphKit&amp; kit, IdealKit&amp; ideal, Node* src_array, IdealVariable&amp; count,
1458                                          Node* dst_array, Node* dst_coder, Node* start) {
1459   bool dcon = dst_coder-&gt;is_Con();
1460   bool dbyte = dcon ? (dst_coder-&gt;get_int() == java_lang_String::CODER_LATIN1) : false;
1461 
1462   if (!dcon) {
1463     __ if_then(dst_coder, BoolTest::eq, __ ConI(java_lang_String::CODER_LATIN1));
1464   }
1465   if (!dcon || dbyte) {
1466     // Destination is Latin1. Simply emit a byte arraycopy.
1467     arraycopy(kit, ideal, src_array, dst_array, T_BYTE, start, __ value(count));
1468   }
1469   if (!dcon) {
1470     __ else_();
1471   }
1472   if (!dcon || !dbyte) {
1473     // Destination is UTF16. Inflate src_array into dst_array.
1474     kit.sync_kit(ideal);
1475     if (Matcher::match_rule_supported(Op_StrInflatedCopy)) {
1476       // Use fast intrinsic
1477       Node* src = kit.array_element_address(src_array, kit.intcon(0), T_BYTE);
1478       Node* dst = kit.array_element_address(dst_array, start, T_BYTE);
1479       kit.inflate_string(src, dst, TypeAryPtr::BYTES, __ value(count));
1480     } else {
1481       // No intrinsic available, use slow method
1482       kit.inflate_string_slow(src_array, dst_array, start, __ value(count));
1483     }
1484     ideal.sync_kit(&amp;kit);
1485     // Multiply count by two since we now need two bytes per char
1486     __ set(count, __ LShiftI(__ value(count), __ ConI(1)));
1487   }
1488   if (!dcon) {
1489     __ end_if();
1490   }
1491 }
1492 
1493 // Read two bytes from index and index+1 and convert them to a char
1494 static jchar readChar(ciTypeArray* array, int index) {
1495   int shift_high, shift_low;
1496 #ifdef VM_LITTLE_ENDIAN
1497     shift_high = 0;
1498     shift_low = 8;
1499 #else
1500     shift_high = 8;
1501     shift_low = 0;
1502 #endif
1503 
1504   jchar b1 = ((jchar) array-&gt;byte_at(index)) &amp; 0xff;
1505   jchar b2 = ((jchar) array-&gt;byte_at(index+1)) &amp; 0xff;
1506   return (b1 &lt;&lt; shift_high) | (b2 &lt;&lt; shift_low);
1507 }
1508 
1509 // Copy contents of constant src_array to dst_array by emitting individual stores
1510 void PhaseStringOpts::copy_constant_string(GraphKit&amp; kit, IdealKit&amp; ideal, ciTypeArray* src_array, IdealVariable&amp; count,
1511                                            bool src_is_byte, Node* dst_array, Node* dst_coder, Node* start) {
1512   bool dcon = dst_coder-&gt;is_Con();
1513   bool dbyte = dcon ? (dst_coder-&gt;get_int() == java_lang_String::CODER_LATIN1) : false;
1514   int length = src_array-&gt;length();
1515 
1516   if (!dcon) {
1517     __ if_then(dst_coder, BoolTest::eq, __ ConI(java_lang_String::CODER_LATIN1));
1518   }
1519   if (!dcon || dbyte) {
1520     // Destination is Latin1. Copy each byte of src_array into dst_array.
1521     Node* index = start;
1522     for (int i = 0; i &lt; length; i++) {
1523       Node* adr = kit.array_element_address(dst_array, index, T_BYTE);
1524       Node* val = __ ConI(src_array-&gt;byte_at(i));
1525       __ store(__ ctrl(), adr, val, T_BYTE, byte_adr_idx, MemNode::unordered);
1526       index = __ AddI(index, __ ConI(1));
1527     }
1528   }
1529   if (!dcon) {
1530     __ else_();
1531   }
1532   if (!dcon || !dbyte) {
1533     // Destination is UTF16. Copy each char of src_array into dst_array.
1534     Node* index = start;
1535     for (int i = 0; i &lt; length; i++) {
1536       Node* adr = kit.array_element_address(dst_array, index, T_BYTE);
1537       jchar val;
1538       if (src_is_byte) {
1539         val = src_array-&gt;byte_at(i) &amp; 0xff;
1540       } else {
1541         val = readChar(src_array, i++);
1542       }
1543       __ store(__ ctrl(), adr, __ ConI(val), T_CHAR, byte_adr_idx, MemNode::unordered, true /* mismatched */);
1544       index = __ AddI(index, __ ConI(2));
1545     }
1546     if (src_is_byte) {
1547       // Multiply count by two since we now need two bytes per char
1548       __ set(count, __ ConI(2 * length));
1549     }
1550   }
1551   if (!dcon) {
1552     __ end_if();
1553   }
1554 }
1555 
1556 // Compress copy contents of the byte/char String str into dst_array starting at index start.
1557 Node* PhaseStringOpts::copy_string(GraphKit&amp; kit, Node* str, Node* dst_array, Node* dst_coder, Node* start) {
1558   Node* src_array = kit.load_String_value(str, true);
1559 
1560   IdealKit ideal(&amp;kit, true, true);
1561   IdealVariable count(ideal); __ declarations_done();
1562 
1563   if (str-&gt;is_Con()) {
1564     // Constant source string
1565     ciTypeArray* src_array_type = get_constant_value(kit, str);
1566 
1567     // Check encoding of constant string
1568     bool src_is_byte = (get_constant_coder(kit, str) == java_lang_String::CODER_LATIN1);
1569 
1570     // For small constant strings just emit individual stores.
1571     // A length of 6 seems like a good space/speed tradeof.
1572     __ set(count, __ ConI(src_array_type-&gt;length()));
1573     int src_len = src_array_type-&gt;length() / (src_is_byte ? 1 : 2);
1574     if (src_len &lt; unroll_string_copy_length) {
1575       // Small constant string
1576       copy_constant_string(kit, ideal, src_array_type, count, src_is_byte, dst_array, dst_coder, start);
1577     } else if (src_is_byte) {
1578       // Source is Latin1
1579       copy_latin1_string(kit, ideal, src_array, count, dst_array, dst_coder, start);
1580     } else {
1581       // Source is UTF16 (destination too). Simply emit a char arraycopy.
1582       arraycopy(kit, ideal, src_array, dst_array, T_CHAR, start, __ value(count));
1583     }
1584   } else {
1585     Node* size = kit.load_array_length(src_array);
1586     __ set(count, size);
1587     // Non-constant source string
1588     if (CompactStrings) {
1589       // Emit runtime check for coder
1590       Node* coder = kit.load_String_coder(str, true);
1591       __ if_then(coder, BoolTest::eq, __ ConI(java_lang_String::CODER_LATIN1)); {
1592         // Source is Latin1
1593         copy_latin1_string(kit, ideal, src_array, count, dst_array, dst_coder, start);
1594       } __ else_();
1595     }
1596     // Source is UTF16 (destination too). Simply emit a char arraycopy.
1597     arraycopy(kit, ideal, src_array, dst_array, T_CHAR, start, __ value(count));
1598 
1599     if (CompactStrings) {
1600       __ end_if();
1601     }
1602   }
1603 
1604   // Finally sync IdealKit and GraphKit.
1605   kit.sync_kit(ideal);
1606   return __ AddI(start, __ value(count));
1607 }
1608 
1609 // Compress copy the char into dst_array at index start.
1610 Node* PhaseStringOpts::copy_char(GraphKit&amp; kit, Node* val, Node* dst_array, Node* dst_coder, Node* start) {
1611   bool dcon = (dst_coder != NULL) &amp;&amp; dst_coder-&gt;is_Con();
1612   bool dbyte = dcon ? (dst_coder-&gt;get_int() == java_lang_String::CODER_LATIN1) : false;
1613 
1614   IdealKit ideal(&amp;kit, true, true);
1615   IdealVariable end(ideal); __ declarations_done();
1616   Node* adr = kit.array_element_address(dst_array, start, T_BYTE);
1617   if (!dcon){
1618     __ if_then(dst_coder, BoolTest::eq, __ ConI(java_lang_String::CODER_LATIN1));
1619   }
1620   if (!dcon || dbyte) {
1621     // Destination is Latin1. Store a byte.
1622     __ store(__ ctrl(), adr, val, T_BYTE, byte_adr_idx, MemNode::unordered);
1623     __ set(end, __ AddI(start, __ ConI(1)));
1624   }
1625   if (!dcon) {
1626     __ else_();
1627   }
1628   if (!dcon || !dbyte) {
1629     // Destination is UTF16. Store a char.
1630     __ store(__ ctrl(), adr, val, T_CHAR, byte_adr_idx, MemNode::unordered, true /* mismatched */);
1631     __ set(end, __ AddI(start, __ ConI(2)));
1632   }
1633   if (!dcon) {
1634     __ end_if();
1635   }
1636   // Finally sync IdealKit and GraphKit.
1637   kit.sync_kit(ideal);
1638   return __ value(end);
1639 }
1640 
1641 #undef __
1642 #define __ kit.
1643 
1644 // Allocate a byte array of specified length.
1645 Node* PhaseStringOpts::allocate_byte_array(GraphKit&amp; kit, IdealKit* ideal, Node* length) {
1646   if (ideal != NULL) {
1647     // Sync IdealKit and graphKit.
1648     kit.sync_kit(*ideal);
1649   }
1650   Node* byte_array = NULL;
1651   {
1652     PreserveReexecuteState preexecs(&amp;kit);
1653     // The original jvms is for an allocation of either a String or
1654     // StringBuffer so no stack adjustment is necessary for proper
1655     // reexecution.  If we deoptimize in the slow path the bytecode
1656     // will be reexecuted and the char[] allocation will be thrown away.
1657     kit.jvms()-&gt;set_should_reexecute(true);
1658     byte_array = kit.new_array(__ makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_BYTE))),
1659                                length, 1);
1660   }
1661 
1662   // Mark the allocation so that zeroing is skipped since the code
1663   // below will overwrite the entire array
1664   AllocateArrayNode* byte_alloc = AllocateArrayNode::Ideal_array_allocation(byte_array, _gvn);
1665   byte_alloc-&gt;maybe_set_complete(_gvn);
1666 
1667   if (ideal != NULL) {
1668     // Sync IdealKit and graphKit.
1669     ideal-&gt;sync_kit(&amp;kit);
1670   }
1671   return byte_array;
1672 }
1673 
1674 jbyte PhaseStringOpts::get_constant_coder(GraphKit&amp; kit, Node* str) {
1675   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1676   const TypeOopPtr* str_type = kit.gvn().type(str)-&gt;isa_oopptr();
1677   ciInstance* str_instance = str_type-&gt;const_oop()-&gt;as_instance();
1678   jbyte coder = str_instance-&gt;field_value_by_offset(java_lang_String::coder_offset()).as_byte();
1679   assert(CompactStrings || (coder == java_lang_String::CODER_UTF16), &quot;Strings must be UTF16 encoded&quot;);
1680   return coder;
1681 }
1682 
1683 int PhaseStringOpts::get_constant_length(GraphKit&amp; kit, Node* str) {
1684   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1685   return get_constant_value(kit, str)-&gt;length();
1686 }
1687 
1688 ciTypeArray* PhaseStringOpts::get_constant_value(GraphKit&amp; kit, Node* str) {
1689   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1690   const TypeOopPtr* str_type = kit.gvn().type(str)-&gt;isa_oopptr();
1691   ciInstance* str_instance = str_type-&gt;const_oop()-&gt;as_instance();
1692   ciObject* src_array = str_instance-&gt;field_value_by_offset(java_lang_String::value_offset()).as_object();
1693   return src_array-&gt;as_type_array();
1694 }
1695 
1696 void PhaseStringOpts::replace_string_concat(StringConcat* sc) {
1697   // Log a little info about the transformation
1698   sc-&gt;maybe_log_transform();
1699 
1700   // pull the JVMState of the allocation into a SafePointNode to serve as
1701   // as a shim for the insertion of the new code.
1702   JVMState* jvms     = sc-&gt;begin()-&gt;jvms()-&gt;clone_shallow(C);
1703   uint size = sc-&gt;begin()-&gt;req();
1704   SafePointNode* map = new SafePointNode(size, jvms);
1705 
1706   // copy the control and memory state from the final call into our
1707   // new starting state.  This allows any preceeding tests to feed
1708   // into the new section of code.
1709   for (uint i1 = 0; i1 &lt; TypeFunc::Parms; i1++) {
1710     map-&gt;init_req(i1, sc-&gt;end()-&gt;in(i1));
1711   }
1712   // blow away old allocation arguments
1713   for (uint i1 = TypeFunc::Parms; i1 &lt; jvms-&gt;debug_start(); i1++) {
1714     map-&gt;init_req(i1, C-&gt;top());
1715   }
1716   // Copy the rest of the inputs for the JVMState
1717   for (uint i1 = jvms-&gt;debug_start(); i1 &lt; sc-&gt;begin()-&gt;req(); i1++) {
1718     map-&gt;init_req(i1, sc-&gt;begin()-&gt;in(i1));
1719   }
1720   // Make sure the memory state is a MergeMem for parsing.
1721   if (!map-&gt;in(TypeFunc::Memory)-&gt;is_MergeMem()) {
1722     map-&gt;set_req(TypeFunc::Memory, MergeMemNode::make(map-&gt;in(TypeFunc::Memory)));
1723   }
1724 
1725   jvms-&gt;set_map(map);
1726   map-&gt;ensure_stack(jvms, jvms-&gt;method()-&gt;max_stack());
1727 
1728   // disconnect all the old StringBuilder calls from the graph
1729   sc-&gt;eliminate_unneeded_control();
1730 
1731   // At this point all the old work has been completely removed from
1732   // the graph and the saved JVMState exists at the point where the
1733   // final toString call used to be.
1734   GraphKit kit(jvms);
1735 
1736   // There may be uncommon traps which are still using the
1737   // intermediate states and these need to be rewritten to point at
1738   // the JVMState at the beginning of the transformation.
1739   sc-&gt;convert_uncommon_traps(kit, jvms);
1740 
1741   // Now insert the logic to compute the size of the string followed
1742   // by all the logic to construct array and resulting string.
1743 
1744   Node* null_string = __ makecon(TypeInstPtr::make(C-&gt;env()-&gt;the_null_string()));
1745 
1746   // Create a region for the overflow checks to merge into.
1747   int args = MAX2(sc-&gt;num_arguments(), 1);
1748   RegionNode* overflow = new RegionNode(args);
1749   kit.gvn().set_type(overflow, Type::CONTROL);
1750 
1751   // Create a hook node to hold onto the individual sizes since they
1752   // are need for the copying phase.
1753   Node* string_sizes = new Node(args);
1754 
1755   Node* coder = __ intcon(0);
1756   Node* length = __ intcon(0);
1757   // If at least one argument is UTF16 encoded, we can fix the encoding.
1758   bool coder_fixed = false;
1759 
1760   if (!CompactStrings) {
1761     // Fix encoding of result string to UTF16
1762     coder_fixed = true;
1763     coder = __ intcon(java_lang_String::CODER_UTF16);
1764   }
1765 
1766   for (int argi = 0; argi &lt; sc-&gt;num_arguments(); argi++) {
1767     Node* arg = sc-&gt;argument(argi);
1768     switch (sc-&gt;mode(argi)) {
1769       case StringConcat::IntMode: {
1770         Node* string_size = int_stringSize(kit, arg);
1771 
1772         // accumulate total
1773         length = __ AddI(length, string_size);
1774 
1775         // Cache this value for the use by int_toString
1776         string_sizes-&gt;init_req(argi, string_size);
1777         break;
1778       }
1779       case StringConcat::StringNullCheckMode: {
1780         const Type* type = kit.gvn().type(arg);
1781         assert(type != TypePtr::NULL_PTR, &quot;missing check&quot;);
1782         if (!type-&gt;higher_equal(TypeInstPtr::NOTNULL)) {
1783           // Null check with uncommon trap since
1784           // StringBuilder(null) throws exception.
1785           // Use special uncommon trap instead of
1786           // calling normal do_null_check().
1787           Node* p = __ Bool(__ CmpP(arg, kit.null()), BoolTest::ne);
1788           IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_MIN, COUNT_UNKNOWN);
1789           overflow-&gt;add_req(__ IfFalse(iff));
1790           Node* notnull = __ IfTrue(iff);
1791           kit.set_control(notnull); // set control for the cast_not_null
1792           arg = kit.cast_not_null(arg, false);
1793           sc-&gt;set_argument(argi, arg);
1794         }
1795         assert(kit.gvn().type(arg)-&gt;higher_equal(TypeInstPtr::NOTNULL), &quot;sanity&quot;);
1796         // Fallthrough to add string length.
1797       }
1798       case StringConcat::StringMode: {
1799         const Type* type = kit.gvn().type(arg);
1800         Node* count = NULL;
1801         Node* arg_coder = NULL;
1802         if (type == TypePtr::NULL_PTR) {
1803           // replace the argument with the null checked version
1804           arg = null_string;
1805           sc-&gt;set_argument(argi, arg);
1806           count = kit.load_String_length(arg, true);
1807           arg_coder = kit.load_String_coder(arg, true);
1808         } else if (!type-&gt;higher_equal(TypeInstPtr::NOTNULL)) {
1809           // s = s != null ? s : &quot;null&quot;;
1810           // length = length + (s.count - s.offset);
1811           RegionNode *r = new RegionNode(3);
1812           kit.gvn().set_type(r, Type::CONTROL);
1813           Node *phi = new PhiNode(r, type);
1814           kit.gvn().set_type(phi, phi-&gt;bottom_type());
1815           Node* p = __ Bool(__ CmpP(arg, kit.null()), BoolTest::ne);
1816           IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_MIN, COUNT_UNKNOWN);
1817           Node* notnull = __ IfTrue(iff);
1818           Node* isnull =  __ IfFalse(iff);
1819           kit.set_control(notnull); // set control for the cast_not_null
1820           r-&gt;init_req(1, notnull);
1821           phi-&gt;init_req(1, kit.cast_not_null(arg, false));
1822           r-&gt;init_req(2, isnull);
1823           phi-&gt;init_req(2, null_string);
1824           kit.set_control(r);
1825           C-&gt;record_for_igvn(r);
1826           C-&gt;record_for_igvn(phi);
1827           // replace the argument with the null checked version
1828           arg = phi;
1829           sc-&gt;set_argument(argi, arg);
1830           count = kit.load_String_length(arg, true);
1831           arg_coder = kit.load_String_coder(arg, true);
1832         } else {
1833           // A corresponding nullcheck will be connected during IGVN MemNode::Ideal_common_DU_postCCP
1834           // kit.control might be a different test, that can be hoisted above the actual nullcheck
1835           // in case, that the control input is not null, Ideal_common_DU_postCCP will not look for a nullcheck.
1836           count = kit.load_String_length(arg, false);
1837           arg_coder = kit.load_String_coder(arg, false);
1838         }
1839         if (arg-&gt;is_Con()) {
1840           // Constant string. Get constant coder and length.
1841           jbyte const_coder = get_constant_coder(kit, arg);
1842           int const_length = get_constant_length(kit, arg);
1843           if (const_coder == java_lang_String::CODER_LATIN1) {
1844             // Can be latin1 encoded
1845             arg_coder = __ intcon(const_coder);
1846             count = __ intcon(const_length);
1847           } else {
1848             // Found UTF16 encoded string. Fix result array encoding to UTF16.
1849             coder_fixed = true;
1850             coder = __ intcon(const_coder);
1851             count = __ intcon(const_length / 2);
1852           }
1853         }
1854 
1855         if (!coder_fixed) {
1856           coder = __ OrI(coder, arg_coder);
1857         }
1858         length = __ AddI(length, count);
1859         string_sizes-&gt;init_req(argi, NULL);
1860         break;
1861       }
1862       case StringConcat::CharMode: {
1863         // one character only
1864         const TypeInt* t = kit.gvn().type(arg)-&gt;is_int();
1865         if (!coder_fixed &amp;&amp; t-&gt;is_con()) {
1866           // Constant char
1867           if (t-&gt;get_con() &lt;= 255) {
1868             // Can be latin1 encoded
1869             coder = __ OrI(coder, __ intcon(java_lang_String::CODER_LATIN1));
1870           } else {
1871             // Must be UTF16 encoded. Fix result array encoding to UTF16.
1872             coder_fixed = true;
1873             coder = __ intcon(java_lang_String::CODER_UTF16);
1874           }
1875         } else if (!coder_fixed) {
1876           // Not constant
1877 #undef __
1878 #define __ ideal.
1879           IdealKit ideal(&amp;kit, true, true);
1880           IdealVariable char_coder(ideal); __ declarations_done();
1881           // Check if character can be latin1 encoded
1882           __ if_then(arg, BoolTest::le, __ ConI(0xFF));
1883             __ set(char_coder, __ ConI(java_lang_String::CODER_LATIN1));
1884           __ else_();
1885             __ set(char_coder, __ ConI(java_lang_String::CODER_UTF16));
1886           __ end_if();
1887           kit.sync_kit(ideal);
1888           coder = __ OrI(coder, __ value(char_coder));
1889 #undef __
1890 #define __ kit.
1891         }
1892         length = __ AddI(length, __ intcon(1));
1893         break;
1894       }
1895       default:
1896         ShouldNotReachHere();
1897     }
1898     if (argi &gt; 0) {
1899       // Check that the sum hasn&#39;t overflowed
1900       IfNode* iff = kit.create_and_map_if(kit.control(),
1901                                           __ Bool(__ CmpI(length, __ intcon(0)), BoolTest::lt),
1902                                           PROB_MIN, COUNT_UNKNOWN);
1903       kit.set_control(__ IfFalse(iff));
1904       overflow-&gt;set_req(argi, __ IfTrue(iff));
1905     }
1906   }
1907 
1908   {
1909     // Hook
1910     PreserveJVMState pjvms(&amp;kit);
1911     kit.set_control(overflow);
1912     C-&gt;record_for_igvn(overflow);
1913     kit.uncommon_trap(Deoptimization::Reason_intrinsic,
1914                       Deoptimization::Action_make_not_entrant);
1915   }
1916 
1917   Node* result;
1918   if (!kit.stopped()) {
1919     assert(CompactStrings || (coder-&gt;is_Con() &amp;&amp; coder-&gt;get_int() == java_lang_String::CODER_UTF16),
1920            &quot;Result string must be UTF16 encoded if CompactStrings is disabled&quot;);
1921 
1922     Node* dst_array = NULL;
1923     if (sc-&gt;num_arguments() == 1 &amp;&amp;
1924         (sc-&gt;mode(0) == StringConcat::StringMode ||
1925          sc-&gt;mode(0) == StringConcat::StringNullCheckMode)) {
1926       // Handle the case when there is only a single String argument.
1927       // In this case, we can just pull the value from the String itself.
1928       dst_array = kit.load_String_value(sc-&gt;argument(0), true);
1929     } else {
1930       // Allocate destination byte array according to coder
1931       dst_array = allocate_byte_array(kit, NULL, __ LShiftI(length, coder));
1932 
1933       // Now copy the string representations into the final byte[]
1934       Node* start = __ intcon(0);
1935       for (int argi = 0; argi &lt; sc-&gt;num_arguments(); argi++) {
1936         Node* arg = sc-&gt;argument(argi);
1937         switch (sc-&gt;mode(argi)) {
1938           case StringConcat::IntMode: {
1939             start = int_getChars(kit, arg, dst_array, coder, start, string_sizes-&gt;in(argi));
1940             break;
1941           }
1942           case StringConcat::StringNullCheckMode:
1943           case StringConcat::StringMode: {
1944             start = copy_string(kit, arg, dst_array, coder, start);
1945             break;
1946           }
1947           case StringConcat::CharMode: {
1948             start = copy_char(kit, arg, dst_array, coder, start);
1949           break;
1950           }
1951           default:
1952             ShouldNotReachHere();
1953         }
1954       }
1955     }
1956 
1957     // If we&#39;re not reusing an existing String allocation then allocate one here.
1958     result = sc-&gt;string_alloc();
1959     if (result == NULL) {
1960       PreserveReexecuteState preexecs(&amp;kit);
1961       // The original jvms is for an allocation of either a String or
1962       // StringBuffer so no stack adjustment is necessary for proper
1963       // reexecution.
1964       kit.jvms()-&gt;set_should_reexecute(true);
1965       result = kit.new_instance(__ makecon(TypeKlassPtr::make(C-&gt;env()-&gt;String_klass())));
1966     }
1967 
1968     // Initialize the string
1969     kit.store_String_value(result, dst_array);
1970     kit.store_String_coder(result, coder);
1971 
1972     // The value field is final. Emit a barrier here to ensure that the effect
1973     // of the initialization is committed to memory before any code publishes
1974     // a reference to the newly constructed object (see Parse::do_exits()).
1975     assert(AllocateNode::Ideal_allocation(result, _gvn) != NULL, &quot;should be newly allocated&quot;);
1976     kit.insert_mem_bar(Op_MemBarRelease, result);
1977   } else {
1978     result = C-&gt;top();
1979   }
1980   // hook up the outgoing control and result
1981   kit.replace_call(sc-&gt;end(), result);
1982 
1983   // Unhook any hook nodes
1984   string_sizes-&gt;disconnect_inputs(NULL, C);
1985   sc-&gt;cleanup();
1986 }
    </pre>
  </body>
</html>