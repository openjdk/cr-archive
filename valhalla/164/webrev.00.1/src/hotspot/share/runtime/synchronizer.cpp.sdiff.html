<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/synchronizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="safepoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/synchronizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 142   // this list until after a handshake or a safepoint for platforms
 143   // that don&#39;t support handshakes. After the handshake or safepoint,
 144   // the deflated ObjectMonitors are prepended to free_list.
 145   ObjectMonitor* _wait_list;
 146   DEFINE_PAD_MINUS_SIZE(3, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));
 147 
 148   int _free_count;    // # on free_list
 149   DEFINE_PAD_MINUS_SIZE(4, OM_CACHE_LINE_SIZE, sizeof(int));
 150 
 151   int _in_use_count;  // # on in_use_list
 152   DEFINE_PAD_MINUS_SIZE(5, OM_CACHE_LINE_SIZE, sizeof(int));
 153 
 154   int _population;    // # Extant -- in circulation
 155   DEFINE_PAD_MINUS_SIZE(6, OM_CACHE_LINE_SIZE, sizeof(int));
 156 
 157   int _wait_count;    // # on wait_list
 158   DEFINE_PAD_MINUS_SIZE(7, OM_CACHE_LINE_SIZE, sizeof(int));
 159 };
 160 static ObjectMonitorListGlobals om_list_globals;
 161 













 162 #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
 163 
 164 
 165 // =====================&gt; Spin-lock functions
 166 
 167 // ObjectMonitors are not lockable outside of this file. We use spin-locks
 168 // implemented using a bit in the _next_om field instead of the heavier
 169 // weight locking mechanisms for faster list management.
 170 
 171 #define OM_LOCK_BIT 0x1
 172 
 173 // Return true if the ObjectMonitor is locked.
 174 // Otherwise returns false.
 175 static bool is_locked(ObjectMonitor* om) {
 176   return ((intptr_t)om-&gt;next_om() &amp; OM_LOCK_BIT) == OM_LOCK_BIT;
 177 }
 178 
 179 // Mark an ObjectMonitor* with OM_LOCK_BIT and return it.
 180 static ObjectMonitor* mark_om_ptr(ObjectMonitor* om) {
 181   return (ObjectMonitor*)((intptr_t)om | OM_LOCK_BIT);
</pre>
<hr />
<pre>
 419 // returns true  -- to indicate the call was satisfied.
 420 // returns false -- to indicate the call needs the services of the slow-path.
 421 // A no-loitering ordinance is in effect for code in the quick_* family
 422 // operators: safepoints or indefinite blocking (blocking that might span a
 423 // safepoint) are forbidden. Generally the thread_state() is _in_Java upon
 424 // entry.
 425 //
 426 // Consider: An interesting optimization is to have the JIT recognize the
 427 // following common idiom:
 428 //   synchronized (someobj) { .... ; notify(); }
 429 // That is, we find a notify() or notifyAll() call that immediately precedes
 430 // the monitorexit operation.  In that case the JIT could fuse the operations
 431 // into a single notifyAndExit() runtime primitive.
 432 
 433 bool ObjectSynchronizer::quick_notify(oopDesc* obj, Thread* self, bool all) {
 434   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 435   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 436   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 437   NoSafepointVerifier nsv;
 438   if (obj == NULL) return false;  // slow-path for invalid obj

 439   const markWord mark = obj-&gt;mark();
 440 
 441   if (mark.has_locker() &amp;&amp; self-&gt;is_lock_owned((address)mark.locker())) {
 442     // Degenerate notify
 443     // stack-locked by caller so by definition the implied waitset is empty.
 444     return true;
 445   }
 446 
 447   if (mark.has_monitor()) {
 448     ObjectMonitor* const mon = mark.monitor();
 449     assert(mon-&gt;object() == obj, &quot;invariant&quot;);
 450     if (mon-&gt;owner() != self) return false;  // slow-path for IMS exception
 451 
 452     if (mon-&gt;first_waiter() != NULL) {
 453       // We have one or more waiters. Since this is an inflated monitor
 454       // that we own, we can transfer one or more threads from the waitset
 455       // to the entrylist here and now, avoiding the slow-path.
 456       if (all) {
 457         DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);
 458       } else {
</pre>
<hr />
<pre>
 469   }
 470 
 471   // biased locking and any other IMS exception states take the slow-path
 472   return false;
 473 }
 474 
 475 
 476 // The LockNode emitted directly at the synchronization site would have
 477 // been too big if it were to have included support for the cases of inflated
 478 // recursive enter and exit, so they go here instead.
 479 // Note that we can&#39;t safely call AsyncPrintJavaStack() from within
 480 // quick_enter() as our thread state remains _in_Java.
 481 
 482 bool ObjectSynchronizer::quick_enter(oop obj, Thread* self,
 483                                      BasicLock * lock) {
 484   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 485   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 486   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 487   NoSafepointVerifier nsv;
 488   if (obj == NULL) return false;       // Need to throw NPE
<span class="line-modified"> 489 </span>
 490   const markWord mark = obj-&gt;mark();
 491 
 492   if (mark.has_monitor()) {
 493     ObjectMonitor* const m = mark.monitor();
 494     // An async deflation can race us before we manage to make the
 495     // ObjectMonitor busy by setting the owner below. If we detect
 496     // that race we just bail out to the slow-path here.
 497     if (m-&gt;object() == NULL) {
 498       return false;
 499     }
 500     Thread* const owner = (Thread *) m-&gt;_owner;
 501 
 502     // Lock contention and Transactional Lock Elision (TLE) diagnostics
 503     // and observability
 504     // Case: light contention possibly amenable to TLE
 505     // Case: TLE inimical operations such as nested/recursive synchronization
 506 
 507     if (owner == self) {
 508       m-&gt;_recursions++;
 509       return true;
</pre>
<hr />
<pre>
 527     }
 528   }
 529 
 530   // Note that we could inflate in quick_enter.
 531   // This is likely a useful optimization
 532   // Critically, in quick_enter() we must not:
 533   // -- perform bias revocation, or
 534   // -- block indefinitely, or
 535   // -- reach a safepoint
 536 
 537   return false;        // revert to slow-path
 538 }
 539 
 540 // -----------------------------------------------------------------------------
 541 // Monitor Enter/Exit
 542 // The interpreter and compiler assembly code tries to lock using the fast path
 543 // of this algorithm. Make sure to update that code if the following function is
 544 // changed. The implementation is extremely sensitive to race condition. Be careful.
 545 
 546 void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, TRAPS) {

 547   if (UseBiasedLocking) {
 548     if (!SafepointSynchronize::is_at_safepoint()) {
 549       BiasedLocking::revoke(obj, THREAD);
 550     } else {
 551       BiasedLocking::revoke_at_safepoint(obj);
 552     }
 553   }
 554 
 555   markWord mark = obj-&gt;mark();
 556   assert(!mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);
 557 
 558   if (mark.is_neutral()) {
 559     // Anticipate successful CAS -- the ST of the displaced mark must
 560     // be visible &lt;= the ST performed by the CAS.
 561     lock-&gt;set_displaced_header(mark);
 562     if (mark == obj()-&gt;cas_set_mark(markWord::from_pointer(lock), mark)) {
 563       return;
 564     }
 565     // Fall through to inflate() ...
 566   } else if (mark.has_locker() &amp;&amp;
</pre>
<hr />
<pre>
 572   }
 573 
 574   // The object header will never be displaced to this lock,
 575   // so it does not matter what the value is, except that it
 576   // must be non-zero to avoid looking like a re-entrant lock,
 577   // and must not look locked either.
 578   lock-&gt;set_displaced_header(markWord::unused_mark());
 579   // An async deflation can race after the inflate() call and before
 580   // enter() can make the ObjectMonitor busy. enter() returns false if
 581   // we have lost the race to async deflation and we simply try again.
 582   while (true) {
 583     ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_monitor_enter);
 584     if (monitor-&gt;enter(THREAD)) {
 585       return;
 586     }
 587   }
 588 }
 589 
 590 void ObjectSynchronizer::exit(oop object, BasicLock* lock, TRAPS) {
 591   markWord mark = object-&gt;mark();




 592   // We cannot check for Biased Locking if we are racing an inflation.
 593   assert(mark == markWord::INFLATING() ||
 594          !mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);
 595 
 596   markWord dhw = lock-&gt;displaced_header();
 597   if (dhw.value() == 0) {
 598     // If the displaced header is NULL, then this exit matches up with
 599     // a recursive enter. No real work to do here except for diagnostics.
 600 #ifndef PRODUCT
 601     if (mark != markWord::INFLATING()) {
 602       // Only do diagnostics if we are not racing an inflation. Simply
 603       // exiting a recursive enter of a Java Monitor that is being
 604       // inflated is safe; see the has_monitor() comment below.
 605       assert(!mark.is_neutral(), &quot;invariant&quot;);
 606       assert(!mark.has_locker() ||
 607              THREAD-&gt;is_lock_owned((address)mark.locker()), &quot;invariant&quot;);
 608       if (mark.has_monitor()) {
 609         // The BasicLock&#39;s displaced_header is marked as a recursive
 610         // enter and we have an inflated Java Monitor (ObjectMonitor).
 611         // This is a special case where the Java Monitor was inflated
</pre>
<hr />
<pre>
 635   // We have to take the slow-path of possible inflation and then exit.
 636   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 637   // dropped inside exit() and the ObjectMonitor* must be !is_busy().
 638   ObjectMonitor* monitor = inflate(THREAD, object, inflate_cause_vm_internal);
 639   monitor-&gt;exit(true, THREAD);
 640 }
 641 
 642 // -----------------------------------------------------------------------------
 643 // Class Loader  support to workaround deadlocks on the class loader lock objects
 644 // Also used by GC
 645 // complete_exit()/reenter() are used to wait on a nested lock
 646 // i.e. to give up an outer lock completely and then re-enter
 647 // Used when holding nested locks - lock acquisition order: lock1 then lock2
 648 //  1) complete_exit lock1 - saving recursion count
 649 //  2) wait on lock2
 650 //  3) when notified on lock2, unlock lock2
 651 //  4) reenter lock1 with original recursion count
 652 //  5) lock lock2
 653 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 654 intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {

 655   if (UseBiasedLocking) {
 656     BiasedLocking::revoke(obj, THREAD);
 657     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 658   }
 659 
 660   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 661   // dropped inside exit() and the ObjectMonitor* must be !is_busy().
 662   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 663   intptr_t ret_code = monitor-&gt;complete_exit(THREAD);
 664   return ret_code;
 665 }
 666 
 667 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 668 void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {

 669   if (UseBiasedLocking) {
 670     BiasedLocking::revoke(obj, THREAD);
 671     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 672   }
 673 
 674   // An async deflation can race after the inflate() call and before
 675   // reenter() -&gt; enter() can make the ObjectMonitor busy. reenter() -&gt;
 676   // enter() returns false if we have lost the race to async deflation
 677   // and we simply try again.
 678   while (true) {
 679     ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 680     if (monitor-&gt;reenter(recursions, THREAD)) {
 681       return;
 682     }
 683   }
 684 }
 685 
 686 // -----------------------------------------------------------------------------
 687 // JNI locks on java objects
 688 // NOTE: must use heavy weight monitor to handle jni monitor enter
 689 void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
 690   // the current locking is from JNI instead of Java code

 691   if (UseBiasedLocking) {
 692     BiasedLocking::revoke(obj, THREAD);
 693     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 694   }
 695   THREAD-&gt;set_current_pending_monitor_is_from_java(false);
 696   // An async deflation can race after the inflate() call and before
 697   // enter() can make the ObjectMonitor busy. enter() returns false if
 698   // we have lost the race to async deflation and we simply try again.
 699   while (true) {
 700     ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_jni_enter);
 701     if (monitor-&gt;enter(THREAD)) {
 702       break;
 703     }
 704   }
 705   THREAD-&gt;set_current_pending_monitor_is_from_java(true);
 706 }
 707 
 708 // NOTE: must use heavy weight monitor to handle jni monitor exit
 709 void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {

 710   if (UseBiasedLocking) {
 711     Handle h_obj(THREAD, obj);
 712     BiasedLocking::revoke(h_obj, THREAD);
 713     obj = h_obj();
 714   }
 715   assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 716 
 717   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 718   // dropped inside exit() and the ObjectMonitor* must be !is_busy().
 719   ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
 720   // If this thread has locked the object, exit the monitor. We
 721   // intentionally do not use CHECK here because we must exit the
 722   // monitor even if an exception is pending.
 723   if (monitor-&gt;check_owner(THREAD)) {
 724     monitor-&gt;exit(true, THREAD);
 725   }
 726 }
 727 
 728 // -----------------------------------------------------------------------------
 729 // Internal VM locks on java objects
</pre>
<hr />
<pre>
 733   _thread = thread;
 734   _thread-&gt;check_for_valid_safepoint_state();
 735   _obj = obj;
 736 
 737   if (_dolock) {
 738     ObjectSynchronizer::enter(_obj, &amp;_lock, _thread);
 739   }
 740 }
 741 
 742 ObjectLocker::~ObjectLocker() {
 743   if (_dolock) {
 744     ObjectSynchronizer::exit(_obj(), &amp;_lock, _thread);
 745   }
 746 }
 747 
 748 
 749 // -----------------------------------------------------------------------------
 750 //  Wait/Notify/NotifyAll
 751 // NOTE: must use heavy weight monitor to handle wait()
 752 int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {

 753   if (UseBiasedLocking) {
 754     BiasedLocking::revoke(obj, THREAD);
 755     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 756   }
 757   if (millis &lt; 0) {
 758     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 759   }
 760   // The ObjectMonitor* can&#39;t be async deflated because the _waiters
 761   // field is incremented before ownership is dropped and decremented
 762   // after ownership is regained.
 763   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 764 
 765   DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);
 766   monitor-&gt;wait(millis, true, THREAD);
 767 
 768   // This dummy call is in place to get around dtrace bug 6254741.  Once
 769   // that&#39;s fixed we can uncomment the following line, remove the call
 770   // and change this function back into a &quot;void&quot; func.
 771   // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
 772   int ret_code = dtrace_waited_probe(monitor, obj, THREAD);
 773   return ret_code;
 774 }
 775 
 776 void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {

 777   if (UseBiasedLocking) {
 778     BiasedLocking::revoke(obj, THREAD);
 779     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 780   }
 781   if (millis &lt; 0) {
 782     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 783   }
 784   // The ObjectMonitor* can&#39;t be async deflated because the _waiters
 785   // field is incremented before ownership is dropped and decremented
 786   // after ownership is regained.
 787   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 788   monitor-&gt;wait(millis, false, THREAD);
 789 }
 790 
 791 void ObjectSynchronizer::notify(Handle obj, TRAPS) {

 792   if (UseBiasedLocking) {
 793     BiasedLocking::revoke(obj, THREAD);
 794     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 795   }
 796 
 797   markWord mark = obj-&gt;mark();
 798   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 799     return;
 800   }
 801   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 802   // dropped by the calling thread.
 803   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);
 804   monitor-&gt;notify(THREAD);
 805 }
 806 
 807 // NOTE: see comment of notify()
 808 void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {

 809   if (UseBiasedLocking) {
 810     BiasedLocking::revoke(obj, THREAD);
 811     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 812   }
 813 
 814   markWord mark = obj-&gt;mark();
 815   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 816     return;
 817   }
 818   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 819   // dropped by the calling thread.
 820   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);
 821   monitor-&gt;notifyAll(THREAD);
 822 }
 823 
 824 // -----------------------------------------------------------------------------
 825 // Hash Code handling
 826 //
 827 // Performance concern:
 828 // OrderAccess::storestore() calls release() which at one time stored 0
</pre>
<hr />
<pre>
 963     // This is probably the best overall implementation -- we&#39;ll
 964     // likely make this the default in future releases.
 965     unsigned t = self-&gt;_hashStateX;
 966     t ^= (t &lt;&lt; 11);
 967     self-&gt;_hashStateX = self-&gt;_hashStateY;
 968     self-&gt;_hashStateY = self-&gt;_hashStateZ;
 969     self-&gt;_hashStateZ = self-&gt;_hashStateW;
 970     unsigned v = self-&gt;_hashStateW;
 971     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
 972     self-&gt;_hashStateW = v;
 973     value = v;
 974   }
 975 
 976   value &amp;= markWord::hash_mask;
 977   if (value == 0) value = 0xBAD;
 978   assert(value != markWord::no_hash, &quot;invariant&quot;);
 979   return value;
 980 }
 981 
 982 intptr_t ObjectSynchronizer::FastHashCode(Thread* self, oop obj) {




 983   if (UseBiasedLocking) {
 984     // NOTE: many places throughout the JVM do not expect a safepoint
 985     // to be taken here. However, we only ever bias Java instances and all
 986     // of the call sites of identity_hash that might revoke biases have
 987     // been checked to make sure they can handle a safepoint. The
 988     // added check of the bias pattern is to avoid useless calls to
 989     // thread-local storage.
 990     if (obj-&gt;mark().has_bias_pattern()) {
 991       // Handle for oop obj in case of STW safepoint
 992       Handle hobj(self, obj);
 993       // Relaxing assertion for bug 6320749.
 994       assert(Universe::verify_in_progress() ||
 995              !SafepointSynchronize::is_at_safepoint(),
 996              &quot;biases should not be seen by VM thread here&quot;);
 997       BiasedLocking::revoke(hobj, JavaThread::current());
 998       obj = hobj();
 999       assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
1000     }
1001   }
1002 
</pre>
<hr />
<pre>
1104         // If we add any new usages of the header/dmw field, this code
1105         // will need to be updated.
1106         hash = test.hash();
1107         assert(test.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, test.value());
1108         assert(hash != 0, &quot;should only have lost the race to a thread that set a non-zero hash&quot;);
1109       }
1110       if (monitor-&gt;is_being_async_deflated()) {
1111         // If we detect that async deflation has occurred, then we
1112         // attempt to restore the header/dmw to the object&#39;s header
1113         // so that we only retry once if the deflater thread happens
1114         // to be slow.
1115         monitor-&gt;install_displaced_markword_in_object(obj);
1116         continue;
1117       }
1118     }
1119     // We finally get the hash.
1120     return hash;
1121   }
1122 }
1123 
<span class="line-removed">1124 // Deprecated -- use FastHashCode() instead.</span>
<span class="line-removed">1125 </span>
<span class="line-removed">1126 intptr_t ObjectSynchronizer::identity_hash_value_for(Handle obj) {</span>
<span class="line-removed">1127   return FastHashCode(Thread::current(), obj());</span>
<span class="line-removed">1128 }</span>
<span class="line-removed">1129 </span>
1130 
1131 bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,
1132                                                    Handle h_obj) {



1133   if (UseBiasedLocking) {
1134     BiasedLocking::revoke(h_obj, thread);
1135     assert(!h_obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
1136   }
1137 
1138   assert(thread == JavaThread::current(), &quot;Can only be called on current thread&quot;);
1139   oop obj = h_obj();
1140 
1141   markWord mark = read_stable_mark(obj);
1142 
1143   // Uncontended case, header points to stack
1144   if (mark.has_locker()) {
1145     return thread-&gt;is_lock_owned((address)mark.locker());
1146   }
1147   // Contended case, header points to ObjectMonitor (tagged pointer)
1148   if (mark.has_monitor()) {
1149     // The first stage of async deflation does not affect any field
1150     // used by this comparison so the ObjectMonitor* is usable here.
1151     ObjectMonitor* monitor = mark.monitor();
1152     return monitor-&gt;is_entered(thread) != 0;
</pre>
<hr />
<pre>
1765 // Fast path code shared by multiple functions
1766 void ObjectSynchronizer::inflate_helper(oop obj) {
1767   markWord mark = obj-&gt;mark();
1768   if (mark.has_monitor()) {
1769     ObjectMonitor* monitor = mark.monitor();
1770     assert(ObjectSynchronizer::verify_objmon_isinpool(monitor), &quot;monitor=&quot; INTPTR_FORMAT &quot; is invalid&quot;, p2i(monitor));
1771     markWord dmw = monitor-&gt;header();
1772     assert(dmw.is_neutral(), &quot;sanity check: header=&quot; INTPTR_FORMAT, dmw.value());
1773     return;
1774   }
1775   (void)inflate(Thread::current(), obj, inflate_cause_vm_internal);
1776 }
1777 
1778 ObjectMonitor* ObjectSynchronizer::inflate(Thread* self, oop object,
1779                                            const InflateCause cause) {
1780   // Inflate mutates the heap ...
1781   // Relaxing assertion for bug 6320749.
1782   assert(Universe::verify_in_progress() ||
1783          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1784 




1785   EventJavaMonitorInflate event;
1786 
1787   for (;;) {
1788     const markWord mark = object-&gt;mark();
1789     assert(!mark.has_bias_pattern(), &quot;invariant&quot;);
1790 
1791     // The mark can be in one of the following states:
1792     // *  Inflated     - just return
1793     // *  Stack-locked - coerce it to inflated
1794     // *  INFLATING    - busy wait for conversion to complete
1795     // *  Neutral      - aggressively inflate the object.
1796     // *  BIASED       - Illegal.  We should never see this
1797 
1798     // CASE: inflated
1799     if (mark.has_monitor()) {
1800       ObjectMonitor* inf = mark.monitor();
1801       markWord dmw = inf-&gt;header();
1802       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());
1803       assert(ObjectSynchronizer::verify_objmon_isinpool(inf), &quot;monitor is invalid&quot;);
1804       return inf;
</pre>
</td>
<td>
<hr />
<pre>
 142   // this list until after a handshake or a safepoint for platforms
 143   // that don&#39;t support handshakes. After the handshake or safepoint,
 144   // the deflated ObjectMonitors are prepended to free_list.
 145   ObjectMonitor* _wait_list;
 146   DEFINE_PAD_MINUS_SIZE(3, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));
 147 
 148   int _free_count;    // # on free_list
 149   DEFINE_PAD_MINUS_SIZE(4, OM_CACHE_LINE_SIZE, sizeof(int));
 150 
 151   int _in_use_count;  // # on in_use_list
 152   DEFINE_PAD_MINUS_SIZE(5, OM_CACHE_LINE_SIZE, sizeof(int));
 153 
 154   int _population;    // # Extant -- in circulation
 155   DEFINE_PAD_MINUS_SIZE(6, OM_CACHE_LINE_SIZE, sizeof(int));
 156 
 157   int _wait_count;    // # on wait_list
 158   DEFINE_PAD_MINUS_SIZE(7, OM_CACHE_LINE_SIZE, sizeof(int));
 159 };
 160 static ObjectMonitorListGlobals om_list_globals;
 161 
<span class="line-added"> 162 #define CHECK_THROW_NOSYNC_IMSE(obj)  \</span>
<span class="line-added"> 163   if ((obj)-&gt;mark().is_always_locked()) {  \</span>
<span class="line-added"> 164     ResourceMark rm(THREAD);                \</span>
<span class="line-added"> 165     THROW_MSG(vmSymbols::java_lang_IllegalMonitorStateException(), obj-&gt;klass()-&gt;external_name()); \</span>
<span class="line-added"> 166   }</span>
<span class="line-added"> 167 </span>
<span class="line-added"> 168 #define CHECK_THROW_NOSYNC_IMSE_0(obj)  \</span>
<span class="line-added"> 169     if ((obj)-&gt;mark().is_always_locked()) {  \</span>
<span class="line-added"> 170     ResourceMark rm(THREAD);                  \</span>
<span class="line-added"> 171     THROW_MSG_0(vmSymbols::java_lang_IllegalMonitorStateException(), obj-&gt;klass()-&gt;external_name()); \</span>
<span class="line-added"> 172   }</span>
<span class="line-added"> 173 </span>
<span class="line-added"> 174 </span>
 175 #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
 176 
 177 
 178 // =====================&gt; Spin-lock functions
 179 
 180 // ObjectMonitors are not lockable outside of this file. We use spin-locks
 181 // implemented using a bit in the _next_om field instead of the heavier
 182 // weight locking mechanisms for faster list management.
 183 
 184 #define OM_LOCK_BIT 0x1
 185 
 186 // Return true if the ObjectMonitor is locked.
 187 // Otherwise returns false.
 188 static bool is_locked(ObjectMonitor* om) {
 189   return ((intptr_t)om-&gt;next_om() &amp; OM_LOCK_BIT) == OM_LOCK_BIT;
 190 }
 191 
 192 // Mark an ObjectMonitor* with OM_LOCK_BIT and return it.
 193 static ObjectMonitor* mark_om_ptr(ObjectMonitor* om) {
 194   return (ObjectMonitor*)((intptr_t)om | OM_LOCK_BIT);
</pre>
<hr />
<pre>
 432 // returns true  -- to indicate the call was satisfied.
 433 // returns false -- to indicate the call needs the services of the slow-path.
 434 // A no-loitering ordinance is in effect for code in the quick_* family
 435 // operators: safepoints or indefinite blocking (blocking that might span a
 436 // safepoint) are forbidden. Generally the thread_state() is _in_Java upon
 437 // entry.
 438 //
 439 // Consider: An interesting optimization is to have the JIT recognize the
 440 // following common idiom:
 441 //   synchronized (someobj) { .... ; notify(); }
 442 // That is, we find a notify() or notifyAll() call that immediately precedes
 443 // the monitorexit operation.  In that case the JIT could fuse the operations
 444 // into a single notifyAndExit() runtime primitive.
 445 
 446 bool ObjectSynchronizer::quick_notify(oopDesc* obj, Thread* self, bool all) {
 447   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 448   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 449   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 450   NoSafepointVerifier nsv;
 451   if (obj == NULL) return false;  // slow-path for invalid obj
<span class="line-added"> 452   assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_inline_klass(), &quot;monitor op on inline type&quot;);</span>
 453   const markWord mark = obj-&gt;mark();
 454 
 455   if (mark.has_locker() &amp;&amp; self-&gt;is_lock_owned((address)mark.locker())) {
 456     // Degenerate notify
 457     // stack-locked by caller so by definition the implied waitset is empty.
 458     return true;
 459   }
 460 
 461   if (mark.has_monitor()) {
 462     ObjectMonitor* const mon = mark.monitor();
 463     assert(mon-&gt;object() == obj, &quot;invariant&quot;);
 464     if (mon-&gt;owner() != self) return false;  // slow-path for IMS exception
 465 
 466     if (mon-&gt;first_waiter() != NULL) {
 467       // We have one or more waiters. Since this is an inflated monitor
 468       // that we own, we can transfer one or more threads from the waitset
 469       // to the entrylist here and now, avoiding the slow-path.
 470       if (all) {
 471         DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);
 472       } else {
</pre>
<hr />
<pre>
 483   }
 484 
 485   // biased locking and any other IMS exception states take the slow-path
 486   return false;
 487 }
 488 
 489 
 490 // The LockNode emitted directly at the synchronization site would have
 491 // been too big if it were to have included support for the cases of inflated
 492 // recursive enter and exit, so they go here instead.
 493 // Note that we can&#39;t safely call AsyncPrintJavaStack() from within
 494 // quick_enter() as our thread state remains _in_Java.
 495 
 496 bool ObjectSynchronizer::quick_enter(oop obj, Thread* self,
 497                                      BasicLock * lock) {
 498   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 499   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 500   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 501   NoSafepointVerifier nsv;
 502   if (obj == NULL) return false;       // Need to throw NPE
<span class="line-modified"> 503   assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_inline_klass(), &quot;monitor op on inline type&quot;);</span>
 504   const markWord mark = obj-&gt;mark();
 505 
 506   if (mark.has_monitor()) {
 507     ObjectMonitor* const m = mark.monitor();
 508     // An async deflation can race us before we manage to make the
 509     // ObjectMonitor busy by setting the owner below. If we detect
 510     // that race we just bail out to the slow-path here.
 511     if (m-&gt;object() == NULL) {
 512       return false;
 513     }
 514     Thread* const owner = (Thread *) m-&gt;_owner;
 515 
 516     // Lock contention and Transactional Lock Elision (TLE) diagnostics
 517     // and observability
 518     // Case: light contention possibly amenable to TLE
 519     // Case: TLE inimical operations such as nested/recursive synchronization
 520 
 521     if (owner == self) {
 522       m-&gt;_recursions++;
 523       return true;
</pre>
<hr />
<pre>
 541     }
 542   }
 543 
 544   // Note that we could inflate in quick_enter.
 545   // This is likely a useful optimization
 546   // Critically, in quick_enter() we must not:
 547   // -- perform bias revocation, or
 548   // -- block indefinitely, or
 549   // -- reach a safepoint
 550 
 551   return false;        // revert to slow-path
 552 }
 553 
 554 // -----------------------------------------------------------------------------
 555 // Monitor Enter/Exit
 556 // The interpreter and compiler assembly code tries to lock using the fast path
 557 // of this algorithm. Make sure to update that code if the following function is
 558 // changed. The implementation is extremely sensitive to race condition. Be careful.
 559 
 560 void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, TRAPS) {
<span class="line-added"> 561   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 562   if (UseBiasedLocking) {
 563     if (!SafepointSynchronize::is_at_safepoint()) {
 564       BiasedLocking::revoke(obj, THREAD);
 565     } else {
 566       BiasedLocking::revoke_at_safepoint(obj);
 567     }
 568   }
 569 
 570   markWord mark = obj-&gt;mark();
 571   assert(!mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);
 572 
 573   if (mark.is_neutral()) {
 574     // Anticipate successful CAS -- the ST of the displaced mark must
 575     // be visible &lt;= the ST performed by the CAS.
 576     lock-&gt;set_displaced_header(mark);
 577     if (mark == obj()-&gt;cas_set_mark(markWord::from_pointer(lock), mark)) {
 578       return;
 579     }
 580     // Fall through to inflate() ...
 581   } else if (mark.has_locker() &amp;&amp;
</pre>
<hr />
<pre>
 587   }
 588 
 589   // The object header will never be displaced to this lock,
 590   // so it does not matter what the value is, except that it
 591   // must be non-zero to avoid looking like a re-entrant lock,
 592   // and must not look locked either.
 593   lock-&gt;set_displaced_header(markWord::unused_mark());
 594   // An async deflation can race after the inflate() call and before
 595   // enter() can make the ObjectMonitor busy. enter() returns false if
 596   // we have lost the race to async deflation and we simply try again.
 597   while (true) {
 598     ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_monitor_enter);
 599     if (monitor-&gt;enter(THREAD)) {
 600       return;
 601     }
 602   }
 603 }
 604 
 605 void ObjectSynchronizer::exit(oop object, BasicLock* lock, TRAPS) {
 606   markWord mark = object-&gt;mark();
<span class="line-added"> 607   if (EnableValhalla &amp;&amp; mark.is_always_locked()) {</span>
<span class="line-added"> 608     return;</span>
<span class="line-added"> 609   }</span>
<span class="line-added"> 610   assert(!EnableValhalla || !object-&gt;klass()-&gt;is_inline_klass(), &quot;monitor op on inline type&quot;);</span>
 611   // We cannot check for Biased Locking if we are racing an inflation.
 612   assert(mark == markWord::INFLATING() ||
 613          !mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);
 614 
 615   markWord dhw = lock-&gt;displaced_header();
 616   if (dhw.value() == 0) {
 617     // If the displaced header is NULL, then this exit matches up with
 618     // a recursive enter. No real work to do here except for diagnostics.
 619 #ifndef PRODUCT
 620     if (mark != markWord::INFLATING()) {
 621       // Only do diagnostics if we are not racing an inflation. Simply
 622       // exiting a recursive enter of a Java Monitor that is being
 623       // inflated is safe; see the has_monitor() comment below.
 624       assert(!mark.is_neutral(), &quot;invariant&quot;);
 625       assert(!mark.has_locker() ||
 626              THREAD-&gt;is_lock_owned((address)mark.locker()), &quot;invariant&quot;);
 627       if (mark.has_monitor()) {
 628         // The BasicLock&#39;s displaced_header is marked as a recursive
 629         // enter and we have an inflated Java Monitor (ObjectMonitor).
 630         // This is a special case where the Java Monitor was inflated
</pre>
<hr />
<pre>
 654   // We have to take the slow-path of possible inflation and then exit.
 655   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 656   // dropped inside exit() and the ObjectMonitor* must be !is_busy().
 657   ObjectMonitor* monitor = inflate(THREAD, object, inflate_cause_vm_internal);
 658   monitor-&gt;exit(true, THREAD);
 659 }
 660 
 661 // -----------------------------------------------------------------------------
 662 // Class Loader  support to workaround deadlocks on the class loader lock objects
 663 // Also used by GC
 664 // complete_exit()/reenter() are used to wait on a nested lock
 665 // i.e. to give up an outer lock completely and then re-enter
 666 // Used when holding nested locks - lock acquisition order: lock1 then lock2
 667 //  1) complete_exit lock1 - saving recursion count
 668 //  2) wait on lock2
 669 //  3) when notified on lock2, unlock lock2
 670 //  4) reenter lock1 with original recursion count
 671 //  5) lock lock2
 672 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 673 intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {
<span class="line-added"> 674   assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_inline_klass(), &quot;monitor op on inline type&quot;);</span>
 675   if (UseBiasedLocking) {
 676     BiasedLocking::revoke(obj, THREAD);
 677     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 678   }
 679 
 680   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 681   // dropped inside exit() and the ObjectMonitor* must be !is_busy().
 682   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 683   intptr_t ret_code = monitor-&gt;complete_exit(THREAD);
 684   return ret_code;
 685 }
 686 
 687 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 688 void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {
<span class="line-added"> 689   assert(!EnableValhalla || !obj-&gt;klass()-&gt;is_inline_klass(), &quot;monitor op on inline type&quot;);</span>
 690   if (UseBiasedLocking) {
 691     BiasedLocking::revoke(obj, THREAD);
 692     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 693   }
 694 
 695   // An async deflation can race after the inflate() call and before
 696   // reenter() -&gt; enter() can make the ObjectMonitor busy. reenter() -&gt;
 697   // enter() returns false if we have lost the race to async deflation
 698   // and we simply try again.
 699   while (true) {
 700     ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 701     if (monitor-&gt;reenter(recursions, THREAD)) {
 702       return;
 703     }
 704   }
 705 }
 706 
 707 // -----------------------------------------------------------------------------
 708 // JNI locks on java objects
 709 // NOTE: must use heavy weight monitor to handle jni monitor enter
 710 void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
 711   // the current locking is from JNI instead of Java code
<span class="line-added"> 712   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 713   if (UseBiasedLocking) {
 714     BiasedLocking::revoke(obj, THREAD);
 715     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 716   }
 717   THREAD-&gt;set_current_pending_monitor_is_from_java(false);
 718   // An async deflation can race after the inflate() call and before
 719   // enter() can make the ObjectMonitor busy. enter() returns false if
 720   // we have lost the race to async deflation and we simply try again.
 721   while (true) {
 722     ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_jni_enter);
 723     if (monitor-&gt;enter(THREAD)) {
 724       break;
 725     }
 726   }
 727   THREAD-&gt;set_current_pending_monitor_is_from_java(true);
 728 }
 729 
 730 // NOTE: must use heavy weight monitor to handle jni monitor exit
 731 void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {
<span class="line-added"> 732   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 733   if (UseBiasedLocking) {
 734     Handle h_obj(THREAD, obj);
 735     BiasedLocking::revoke(h_obj, THREAD);
 736     obj = h_obj();
 737   }
 738   assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 739 
 740   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 741   // dropped inside exit() and the ObjectMonitor* must be !is_busy().
 742   ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
 743   // If this thread has locked the object, exit the monitor. We
 744   // intentionally do not use CHECK here because we must exit the
 745   // monitor even if an exception is pending.
 746   if (monitor-&gt;check_owner(THREAD)) {
 747     monitor-&gt;exit(true, THREAD);
 748   }
 749 }
 750 
 751 // -----------------------------------------------------------------------------
 752 // Internal VM locks on java objects
</pre>
<hr />
<pre>
 756   _thread = thread;
 757   _thread-&gt;check_for_valid_safepoint_state();
 758   _obj = obj;
 759 
 760   if (_dolock) {
 761     ObjectSynchronizer::enter(_obj, &amp;_lock, _thread);
 762   }
 763 }
 764 
 765 ObjectLocker::~ObjectLocker() {
 766   if (_dolock) {
 767     ObjectSynchronizer::exit(_obj(), &amp;_lock, _thread);
 768   }
 769 }
 770 
 771 
 772 // -----------------------------------------------------------------------------
 773 //  Wait/Notify/NotifyAll
 774 // NOTE: must use heavy weight monitor to handle wait()
 775 int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {
<span class="line-added"> 776   CHECK_THROW_NOSYNC_IMSE_0(obj);</span>
 777   if (UseBiasedLocking) {
 778     BiasedLocking::revoke(obj, THREAD);
 779     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 780   }
 781   if (millis &lt; 0) {
 782     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 783   }
 784   // The ObjectMonitor* can&#39;t be async deflated because the _waiters
 785   // field is incremented before ownership is dropped and decremented
 786   // after ownership is regained.
 787   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 788 
 789   DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);
 790   monitor-&gt;wait(millis, true, THREAD);
 791 
 792   // This dummy call is in place to get around dtrace bug 6254741.  Once
 793   // that&#39;s fixed we can uncomment the following line, remove the call
 794   // and change this function back into a &quot;void&quot; func.
 795   // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
 796   int ret_code = dtrace_waited_probe(monitor, obj, THREAD);
 797   return ret_code;
 798 }
 799 
 800 void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {
<span class="line-added"> 801   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 802   if (UseBiasedLocking) {
 803     BiasedLocking::revoke(obj, THREAD);
 804     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 805   }
 806   if (millis &lt; 0) {
 807     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 808   }
 809   // The ObjectMonitor* can&#39;t be async deflated because the _waiters
 810   // field is incremented before ownership is dropped and decremented
 811   // after ownership is regained.
 812   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 813   monitor-&gt;wait(millis, false, THREAD);
 814 }
 815 
 816 void ObjectSynchronizer::notify(Handle obj, TRAPS) {
<span class="line-added"> 817   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 818   if (UseBiasedLocking) {
 819     BiasedLocking::revoke(obj, THREAD);
 820     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 821   }
 822 
 823   markWord mark = obj-&gt;mark();
 824   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 825     return;
 826   }
 827   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 828   // dropped by the calling thread.
 829   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);
 830   monitor-&gt;notify(THREAD);
 831 }
 832 
 833 // NOTE: see comment of notify()
 834 void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {
<span class="line-added"> 835   CHECK_THROW_NOSYNC_IMSE(obj);</span>
 836   if (UseBiasedLocking) {
 837     BiasedLocking::revoke(obj, THREAD);
 838     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 839   }
 840 
 841   markWord mark = obj-&gt;mark();
 842   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 843     return;
 844   }
 845   // The ObjectMonitor* can&#39;t be async deflated until ownership is
 846   // dropped by the calling thread.
 847   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);
 848   monitor-&gt;notifyAll(THREAD);
 849 }
 850 
 851 // -----------------------------------------------------------------------------
 852 // Hash Code handling
 853 //
 854 // Performance concern:
 855 // OrderAccess::storestore() calls release() which at one time stored 0
</pre>
<hr />
<pre>
 990     // This is probably the best overall implementation -- we&#39;ll
 991     // likely make this the default in future releases.
 992     unsigned t = self-&gt;_hashStateX;
 993     t ^= (t &lt;&lt; 11);
 994     self-&gt;_hashStateX = self-&gt;_hashStateY;
 995     self-&gt;_hashStateY = self-&gt;_hashStateZ;
 996     self-&gt;_hashStateZ = self-&gt;_hashStateW;
 997     unsigned v = self-&gt;_hashStateW;
 998     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
 999     self-&gt;_hashStateW = v;
1000     value = v;
1001   }
1002 
1003   value &amp;= markWord::hash_mask;
1004   if (value == 0) value = 0xBAD;
1005   assert(value != markWord::no_hash, &quot;invariant&quot;);
1006   return value;
1007 }
1008 
1009 intptr_t ObjectSynchronizer::FastHashCode(Thread* self, oop obj) {
<span class="line-added">1010   if (EnableValhalla &amp;&amp; obj-&gt;klass()-&gt;is_inline_klass()) {</span>
<span class="line-added">1011     // VM should be calling bootstrap method</span>
<span class="line-added">1012     ShouldNotReachHere();</span>
<span class="line-added">1013   }</span>
1014   if (UseBiasedLocking) {
1015     // NOTE: many places throughout the JVM do not expect a safepoint
1016     // to be taken here. However, we only ever bias Java instances and all
1017     // of the call sites of identity_hash that might revoke biases have
1018     // been checked to make sure they can handle a safepoint. The
1019     // added check of the bias pattern is to avoid useless calls to
1020     // thread-local storage.
1021     if (obj-&gt;mark().has_bias_pattern()) {
1022       // Handle for oop obj in case of STW safepoint
1023       Handle hobj(self, obj);
1024       // Relaxing assertion for bug 6320749.
1025       assert(Universe::verify_in_progress() ||
1026              !SafepointSynchronize::is_at_safepoint(),
1027              &quot;biases should not be seen by VM thread here&quot;);
1028       BiasedLocking::revoke(hobj, JavaThread::current());
1029       obj = hobj();
1030       assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
1031     }
1032   }
1033 
</pre>
<hr />
<pre>
1135         // If we add any new usages of the header/dmw field, this code
1136         // will need to be updated.
1137         hash = test.hash();
1138         assert(test.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, test.value());
1139         assert(hash != 0, &quot;should only have lost the race to a thread that set a non-zero hash&quot;);
1140       }
1141       if (monitor-&gt;is_being_async_deflated()) {
1142         // If we detect that async deflation has occurred, then we
1143         // attempt to restore the header/dmw to the object&#39;s header
1144         // so that we only retry once if the deflater thread happens
1145         // to be slow.
1146         monitor-&gt;install_displaced_markword_in_object(obj);
1147         continue;
1148       }
1149     }
1150     // We finally get the hash.
1151     return hash;
1152   }
1153 }
1154 






1155 
1156 bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,
1157                                                    Handle h_obj) {
<span class="line-added">1158   if (EnableValhalla &amp;&amp; h_obj-&gt;mark().is_always_locked()) {</span>
<span class="line-added">1159     return false;</span>
<span class="line-added">1160   }</span>
1161   if (UseBiasedLocking) {
1162     BiasedLocking::revoke(h_obj, thread);
1163     assert(!h_obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
1164   }
1165 
1166   assert(thread == JavaThread::current(), &quot;Can only be called on current thread&quot;);
1167   oop obj = h_obj();
1168 
1169   markWord mark = read_stable_mark(obj);
1170 
1171   // Uncontended case, header points to stack
1172   if (mark.has_locker()) {
1173     return thread-&gt;is_lock_owned((address)mark.locker());
1174   }
1175   // Contended case, header points to ObjectMonitor (tagged pointer)
1176   if (mark.has_monitor()) {
1177     // The first stage of async deflation does not affect any field
1178     // used by this comparison so the ObjectMonitor* is usable here.
1179     ObjectMonitor* monitor = mark.monitor();
1180     return monitor-&gt;is_entered(thread) != 0;
</pre>
<hr />
<pre>
1793 // Fast path code shared by multiple functions
1794 void ObjectSynchronizer::inflate_helper(oop obj) {
1795   markWord mark = obj-&gt;mark();
1796   if (mark.has_monitor()) {
1797     ObjectMonitor* monitor = mark.monitor();
1798     assert(ObjectSynchronizer::verify_objmon_isinpool(monitor), &quot;monitor=&quot; INTPTR_FORMAT &quot; is invalid&quot;, p2i(monitor));
1799     markWord dmw = monitor-&gt;header();
1800     assert(dmw.is_neutral(), &quot;sanity check: header=&quot; INTPTR_FORMAT, dmw.value());
1801     return;
1802   }
1803   (void)inflate(Thread::current(), obj, inflate_cause_vm_internal);
1804 }
1805 
1806 ObjectMonitor* ObjectSynchronizer::inflate(Thread* self, oop object,
1807                                            const InflateCause cause) {
1808   // Inflate mutates the heap ...
1809   // Relaxing assertion for bug 6320749.
1810   assert(Universe::verify_in_progress() ||
1811          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1812 
<span class="line-added">1813   if (EnableValhalla) {</span>
<span class="line-added">1814     guarantee(!object-&gt;klass()-&gt;is_inline_klass(), &quot;Attempt to inflate inline type&quot;);</span>
<span class="line-added">1815   }</span>
<span class="line-added">1816 </span>
1817   EventJavaMonitorInflate event;
1818 
1819   for (;;) {
1820     const markWord mark = object-&gt;mark();
1821     assert(!mark.has_bias_pattern(), &quot;invariant&quot;);
1822 
1823     // The mark can be in one of the following states:
1824     // *  Inflated     - just return
1825     // *  Stack-locked - coerce it to inflated
1826     // *  INFLATING    - busy wait for conversion to complete
1827     // *  Neutral      - aggressively inflate the object.
1828     // *  BIASED       - Illegal.  We should never see this
1829 
1830     // CASE: inflated
1831     if (mark.has_monitor()) {
1832       ObjectMonitor* inf = mark.monitor();
1833       markWord dmw = inf-&gt;header();
1834       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());
1835       assert(ObjectSynchronizer::verify_objmon_isinpool(inf), &quot;monitor is invalid&quot;);
1836       return inf;
</pre>
</td>
</tr>
</table>
<center><a href="safepoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>